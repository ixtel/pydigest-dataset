<html><body><div><div id="post">
<p>For past few years I've been primarily a ruby programmer. In the ruby ecosystem, testing is seen as pretty important and I wanted to have the same tooling in python.</p>

<p><a href="http://mobile.thescore.com/">Where I work</a>, we primarily use rspec in conjunction with Rails. The combo comes with a few things by default:</p>

<ol>
<li>Test discovery under <code>spec/</code> or <code>test/</code></li>
<li>Automatic database transaction support per test</li>
</ol>

<p>We have a old, custom python project that I've been working with and slowly modernizing. The need for unit tests came up and I evaluated a few options. I ended up choosing <a href="https://pytest.org/">pytest</a> as it seemed to be most modern and popular framework.</p>

<p>By default, pytest is configured to discover tests in <em>all</em> directories and subdirectories. So, while it does work, it can be slow (because it crawls everything) and it can discover tests that it shouldn't (such as a vendored code).</p>

<p>I worked around this issue by using the <code>norecursedirs</code> option. This option tells pytest which directories <em>not</em> to go into (no option exists to tell it to only go into certain directories). Here's a sample config:</p>

<div class="highlight"><pre><code class="language-ini" data-lang="ini"><span class="c1"># setup.cfg</span>
<span class="k">[pytest]</span>
<span class="na">norecursedirs</span> <span class="o">=</span> <span class="s">.git vendor my-project/lib my-project/helpers docs config log tmp\*</span></code></pre></div>

<p>Note, if you put <code>vendor</code>, then make sure you don't have a directory like <code>tests/vendor/</code> because it will be ignored:</p>

<div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">$ </span>cat setup.cfg
<span class="o">[</span>pytest<span class="o">]</span>
<span class="nv">norecursedirs</span> <span class="o">=</span> config

<span class="nv">$ </span>tree
.
├── config
│   └── file.json
├── file_name.py
├── setup.cfg
└── tests
    ├── config
    │   └── my_test.py
    └── my_test.py

<span class="m">4</span> directories, <span class="m">6</span> files

<span class="nv">$ </span>py.test --collect-only
<span class="o">=======</span> <span class="nb">test </span>session <span class="nv">starts</span> <span class="o">=======</span>
platform darwin -- Python 2.7.9 -- py-1.4.27 -- pytest-2.6.4
collected <span class="m">1</span> items
&lt;Module <span class="s1">'tests/my_test.py'</span>&gt;
  &lt;Class <span class="s1">'Test'</span>&gt;
    &lt;Instance <span class="s1">'()'</span>&gt;
      &lt;Function <span class="s1">'test_foo'</span>&gt;</code></pre></div>

<p>Anyway, buyer be warned!</p>

<p>To solve #2 (automatic database transaction support per test), it got... a bit tricky. We utilized standard xUnit style tests, so our tests would look like this:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">TestWidget</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">setup_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subject</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_can_get_meaning_of_life</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">subject</span><span class="o">.</span><span class="n">get_meaning_of_life</span><span class="p">()</span> <span class="o">==</span> <span class="mi">42</span></code></pre></div>

<p>Say that instantiating <code>Widget</code> actually wrote to the database. At this point, the widget is going to be saved in the database and subsequent tests could error out because they rely on having no widgets in the database.</p>

<p>Our first solution used inheritance like this:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># tests/helper.py</span>
<span class="k">class</span> <span class="nc">BaseTest</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">setup_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="n">orm</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">teardown_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="n">orm</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

<span class="c"># tests/unit/widget_test.py</span>
<span class="kn">from</span> <span class="nn">tests.helper</span> <span class="kn">import</span> <span class="n">BaseTest</span>

<span class="k">class</span> <span class="nc">TestWidget</span><span class="p">(</span><span class="n">BaseTest</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">setup_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BaseTest</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">setup_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subject</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_can_get_meaning_of_life</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">subject</span><span class="o">.</span><span class="n">get_meaning_of_life</span><span class="p">()</span> <span class="o">==</span> <span class="mi">42</span></code></pre></div>

<p>This works for the most part, except that <code>teardown_method</code> does not get called if something failed in <code>setup_method</code> <a href="https://pytest.org/latest/announce/release-2.4.0.html">by design since pytest 2.4</a> (see 'issue322'). This means that <code>orm.session.rollback()</code> might not be called.</p>

<h3>Enter Pytest Fixtures</h3>

<p>While the classic xUnit style doesn't work so well, we do have an alternative: <a href="https://pytest.org/latest/fixture.html">pytest fixtures</a>.</p>

<p>What are these fixtures? Well, they're basically dependencies that you can require for your tests. Here's how our code can look now:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># tests/helper.py</span>
<span class="nd">@pytest.fixture</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">db_transaction</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">orm</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">fin</span><span class="p">():</span>
        <span class="n">orm</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

    <span class="n">request</span><span class="o">.</span><span class="n">addfinalizer</span><span class="p">(</span><span class="n">fin</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">orm</span><span class="o">.</span><span class="n">session</span>

<span class="c"># tests/unit/widget_test.py</span>
<span class="k">class</span> <span class="nc">TestMyWidget</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">test_my_widget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_transaction</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">"</span><span class="se">\n</span><span class="s">in passing test</span><span class="se">\n</span><span class="s">"</span>

    <span class="k">def</span> <span class="nf">test_my_failing_widget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_transaction</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">"</span><span class="se">\n</span><span class="s">in failing test</span><span class="se">\n</span><span class="s">"</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span></code></pre></div>

<p>The extended example and output <a href="https://gist.github.com/Nitrodist/60ced9ca02d9e56cde42">can be found here</a>.</p>

<p>The downside of this technique is that we have to remember to opt-in to every test by specifying <code>db_transaction</code> as one of the arguments. To get around this issue, we tried combining <code>autouse</code> and classes:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># tests/helper.py</span>
<span class="k">class</span> <span class="nc">BaseTest</span><span class="p">:</span>
    <span class="c"># prefixed with '_' since autouse fixtures are executed alphabetically</span>
    <span class="c"># see http://stackoverflow.com/a/28593102/269694</span>
    <span class="nd">@pytest.fixture</span><span class="p">(</span><span class="n">autouse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_wrap_test_in_transaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="n">orm</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">fin</span><span class="p">():</span>
            <span class="n">orm</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

        <span class="n">request</span><span class="o">.</span><span class="n">addfinalizer</span><span class="p">(</span><span class="n">fin</span><span class="p">)</span>

<span class="c"># tests/unit/widget_test.py</span>
<span class="kn">from</span> <span class="nn">tests.helper</span> <span class="kn">import</span> <span class="n">BaseTest</span>

<span class="k">class</span> <span class="nc">TestWidget</span><span class="p">(</span><span class="n">BaseTest</span><span class="p">):</span>

    <span class="nd">@pytest.fixture</span><span class="p">(</span><span class="n">autouse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">before</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subject</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_can_get_meaning_of_life</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">subject</span><span class="o">.</span><span class="n">get_meaning_of_life</span><span class="p">()</span> <span class="o">==</span> <span class="mi">42</span></code></pre></div>

<p>That's it! No other special tricks.</p>

<h3>Conclusion</h3>

<p>This took a bit of thinking to come up with, but maybe you or someone you know has a better way of writing tests with database transactions in pytest. Let me know and leave a comment below, <a href="mailto:me@markcampbell.me">shoot me an email</a>, or <a href="https://twitter.com/intent/tweet?text=Hey%20@Nitrodist,%20you%27re%20wrong%20about%20pytest!">tweet at me</a> -- I promise I won't bite!</p>

</div>



</div></body></html>