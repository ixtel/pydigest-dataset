<html><body><div><div class="entry-content">
      <p>I've <a title="Getting started with Django and AngularJS" href="/blog/getting-started-django-and-angularjs/" target="_blank">blogged before on how to use AngularJS with Django</a>, who both share the same {{ }} placeholders. The trick there was to keep using {{ }} for Django, and &lt;[ ]&gt; (or any other combo) for AngularJS.</p>
<p> </p>
<p>This works well but there's a gotcha: What if you depend on 3rd party AngularJS libraries that depend on template fragments that use {{ }}? This is what happened when I used the excellent <a title="Dynamic Forms for AngularJS" href="https://github.com/Textalk/angular-schema-form" target="_blank">Angular Schema Form</a> package: the forms wouldn't render properly because AngularJS no longer recognizes the {{ }} placeholders.</p>
<p> </p>
<p>My workaround for this is to not use alternative placeholders for AngularJS, but do use &lt;[ ]&gt; (or, again, any other combo) in Django templates for AngularJS code and replace that after Django's template rendering to {{ }}.</p>
<p>So, &lt;[ {{ variable }} ]&gt; will be rendered to &lt;[ x.y ]&gt; (assuming variable is "x.y") which will then be transformed to {{ x.y }} which AngularJS can handle.</p>
<p>The following code can be used to do this placeholder replace:</p>
<pre>from django.template import loader, RequestContext<br/>from django.http import HttpResponse
<br/>def render(request, *args, **kwargs):<br/>    """<br/>    Returns a HttpResponse whose content is filled with the result of calling<br/>    django.template.loader.render_to_string() with the passed arguments.<br/>    Uses a RequestContext by default.<br/>    """<br/>    httpresponse_kwargs = {<br/>    'content_type': kwargs.pop('content_type', None),<br/>    'status': kwargs.pop('status', None),<br/>    }
    if 'context_instance' in kwargs:<br/>        context_instance = kwargs.pop('context_instance')<br/>    if kwargs.get('current_app', None):<br/>        raise ValueError('If you provide a context_instance you must '<br/>                         'set its current_app before calling render()')<br/>    else:<br/>        current_app = kwargs.pop('current_app', None)<br/>        context_instance = RequestContext(request, current_app=current_app)<br/>
    kwargs['context_instance'] = context_instance
    s = loader.render_to_string(*args, **kwargs)<br/>    s = s.replace("&lt;[", "{{").replace("]&gt;", "}}") # &lt;- magic happens *here*
<br/>    return HttpResponse(s, **httpresponse_kwargs)<br/>    </pre>
<p>This is actually Django's render with a minor modification.</p>
<p> </p>
<p>And finally, of course, remove the $interpolateProvider startSymbol/endSymbol change if you have any.</p>
<p> </p>
<p> </p>
    </div>
  </div></body></html>