<html><body><div><div class="SECT1"><h1 class="SECT1"><a name="AEN3738"/>Qt Utility classes and their Python equivalents</h1><p>A good many of the Qt classes overlap with
      Python classes. There is <tt class="CLASSNAME">QString</tt>, which
      offers almost as much functionality as Python's string object
      and Unicode string object, <tt class="CLASSNAME">QRegExp</tt>, which
      does the same as Python's <tt class="FILENAME">re</tt> module. Not
      all Qt classes that overlap with Python classes are available
      from PyQt, but most are. The defining criterion is usually
      whether or not such an overlapping class is needed as an
      argument in method calls.</p><p>In those cases where there is duplication,
      it is up to you to decide which one to use. If you use as many
      Qt classes as possible, your application will appear less
      Pythonic, and will be more difficult to port to other Python
      gui's. However, it will also be easier to port your Python
      prototype to fast, compiled C++ code. Thus, it depends on
      whether you see your Python program as the final goal or as a
      prototype. It is best to take a firm stand, though — you
      shouldn't use Qt regular expressions and Python regular
      expressions in the same program.</p><p>For instance, the dirview Qt example
      program can use the <tt class="CLASSNAME">QDir</tt> class, or use
      <tt class="FUNCTION">os.path.walk()</tt>. Compare the following
      <tt class="FUNCTION">setOpen</tt> functions. The first is a complex
      script which uses the Qt functions; the second uses
      <tt class="FUNCTION">setOpen</tt> with the Python equivalents. Both
      scripts create listview items for all entries in a
      directory:</p><div class="EXAMPLE"><a name="AEN3754"/><p><b>Example 10-18. from dv_qt.py - using Qt utility
        classes</b></p><pre class="PROGRAMLISTING">#!/usr/bin/env python

import sys
from qt import *

class Directory(QListViewItem):
  def __init__(self, parent, name=None):
    apply(QListViewItem.__init__,(self,parent))
    if isinstance(parent, QListView):
      self.p = None
      self.f = '/'
    else:
      self.p = parent
      self.f = name
    self.c = []
    self.readable = 1

  def setOpen(self, o):
    if o and not self.childCount():
      s = self.fullName()
      thisDir = QDir(s)
      if not thisDir.isReadable():
        self.readable = 0
	return

      files = thisDir.entryInfoList()
      if files:
        for f in files:
          fileName = str(f.fileName())
	  if fileName == '.' or fileName == '..':
	    continue
	  elif f.isSymLink():
	    d = QListViewItem(self, fileName, 'Symbolic Link')
	  elif f.isDir():
	    d = Directory(self, fileName)
	  else:
	    if f.isFile():
	      t = 'File'
	    else:
	      t = 'Special'
	    d = QListViewItem(self, fileName, t)
	  self.c.append(d)

    QListViewItem.setOpen(self, o)

  def setup(self):
    self.setExpandable(1)
    QListViewItem.setup(self)

  def fullName(self):
    if self.p:
      s = self.p.fullName() + self.f + '/'
    else:
      s = '/'
    return s

  def text(self, column):
    if column == 0:
      return self.f
    elif self.readable:
      return 'Directory'
    else:
      return 'Unreadable Directory'

a = QApplication(sys.argv)
mw = QListView()
a.setMainWidget(mw)
mw.setCaption('Directory Browser')
mw.addColumn('Name')
mw.addColumn('Type')
mw.resize(400, 400)
mw.setTreeStepSize(20)
root = Directory(mw)
root.setOpen(1)
mw.show()
a.exec_loop()
      </pre></div><div class="EXAMPLE"><a name="AEN3757"/><p><b>Example 10-19. fragment from db_python.py - using Python utility classes</b></p><pre class="PROGRAMLISTING">...
  def setOpen(self, o):
    if o and not self.childCount():
      s = self.fullName()

      if (not os.path.isdir(s)):
        self.readable == 0
        return

      if (not os.access(s, os.F_OK or os.R_OK)):
        self.readable == 0
        return

      files=os.listdir(s)
      if files:
        for fileName in files:
          f=os.path.join(s, fileName)
          if fileName == "." or fileName == "..":
            continue
          elif os.path.islink(f):
            d = QListViewItem(self, fileName, 'Symbolic Link')
          elif os.path.isdir(f):
            d = Directory(self, fileName)
          else:

            if os.path.isfile(f):
              t = 'File'
            else:
              print f
              t = 'Special'
            d = QListViewItem(self, fileName, t)
          self.c.append(d)

    QListViewItem.setOpen(self, o)
...
        </pre></div><p>The result is the same:</p><p>The first snippet has been taken from the
      dirview.py example script that comes with PyQt and BlackAdder;
      the second is my own interpretation of the dirview.cpp example
      application. Both have been slightly adapted to make them more
      alike. Perhaps the similarities between the Qt
      <tt class="CLASSNAME">QDir</tt> object and the Python
      <tt class="FILENAME">os.path</tt> module are even more striking than
      the differences.</p><div class="SECT2"><h2 class="SECT2"><a name="AEN3773"/>High level data structures</h2><p>Qt offers a number of custom high-level
        data structures, where plain C++ is quite primitive in this
        respect. (Or, at least, C++ was quite primitive in this
        respect when Qt was first created. Recently, templates and a
        standard library have been added, and compilers are starting
        to support these constructs).</p><p>Python already has a dictionary, as well
        as list and string data structures that are powerful enough
        for most needs (what Python is missing is an ordered
        dictionary), so PyQt does not need the Qt high-level data
        structures, except where they are demanded as parameters in
        methods.</p><p>Qt has two basic high-level
        datastructures: arrays and collections. Collections are
        specialized into dictionaries, lists and maps. You can always
        use a Python list wherever a <tt class="CLASSNAME">QList</tt> is
        needed, or a string where a <tt class="CLASSNAME">QByteArray</tt>
        is needed. In other cases, some methods are not implemented
        because the datatype is not implemented, as is the case with
        <tt class="CLASSNAME">QMap</tt>.</p><div class="TABLE"><a name="AEN3789"/><p><b>Table 10-1. Qt and Python high-level datastructures</b></p><table border="1" class="CALSTABLE"><thead><tr><th align="LEFT" valign="TOP">Qt Class</th><th align="LEFT" valign="TOP">Python Class</th><th align="LEFT" valign="TOP">Implemented</th><th align="LEFT" valign="TOP">Description</th></tr></thead><tbody><tr><td align="LEFT" valign="TOP">QArray</td><td align="LEFT" valign="TOP">list</td><td align="LEFT" valign="TOP">No</td><td align="LEFT" valign="TOP">Array of simple types.</td></tr><tr><td align="LEFT" valign="TOP">QByteArray</td><td align="LEFT" valign="TOP">String</td><td align="LEFT" valign="TOP">No</td><td align="LEFT" valign="TOP">Use a string wherever a method wants a
                QByteArray</td></tr><tr><td align="LEFT" valign="TOP">QPointArray</td><td align="LEFT" valign="TOP">No equivalent</td><td align="LEFT" valign="TOP">Yes</td><td align="LEFT" valign="TOP">Array of QPoint objects — you can also
                store QPoint objects in a Python list, of course.
              </td></tr><tr><td align="LEFT" valign="TOP">QCollection</td><td align="LEFT" valign="TOP">Dictionary</td><td align="LEFT" valign="TOP">No</td><td align="LEFT" valign="TOP">Abstract base class for QDict, QList and
                QMap.</td></tr><tr><td align="LEFT" valign="TOP">QDict</td><td align="LEFT" valign="TOP">Dictionary</td><td align="LEFT" valign="TOP">No</td><td align="LEFT" valign="TOP">Just like Python dictionaries, but more
                complicated in use.</td></tr><tr><td align="LEFT" valign="TOP">QList</td><td align="LEFT" valign="TOP">list</td><td align="LEFT" valign="TOP">No</td><td align="LEFT" valign="TOP">Just like Python lists, but more
                complicated</td></tr><tr><td align="LEFT" valign="TOP">QMap</td><td align="LEFT" valign="TOP">Dictionary</td><td align="LEFT" valign="TOP">No</td><td align="LEFT" valign="TOP">Use a Python dictionary — however, when
                translating a Python prototype to C++, note that a
                QMap is based on values, not on references; the keys
                indexing the dictionary are
                <span class="emphasis"><i class="EMPHASIS">copies</i></span> of the original objects,
                not references.</td></tr><tr><td align="LEFT" valign="TOP">QCache</td><td align="LEFT" valign="TOP">No equivalent</td><td align="LEFT" valign="TOP">No</td><td align="LEFT" valign="TOP">A QCache is a low-level class that caches string
                values so that two variables containing the same
                text don't use the memory twice. There are similar
                caches for integers and non-Unicode texts. Python
                performs the same trick; see the note: Python and
                Caching.</td></tr><tr><td align="LEFT" valign="TOP">QValueList</td><td align="LEFT" valign="TOP">list</td><td align="LEFT" valign="TOP">No</td><td align="LEFT" valign="TOP">A low-level class that implements a list of
                values (instead of references to objects).</td></tr><tr><td align="LEFT" valign="TOP">QVariant</td><td align="LEFT" valign="TOP">No equivalent</td><td align="LEFT" valign="TOP">Partially</td><td align="LEFT" valign="TOP">QVariant is a wrapper class that makes it possible to
                use C++ as if it were a loosely-typed language (which
                Python already is). This class
                is used for implementing class properties (I find it to be a
                monstrosity compared to Visual Basic's Variant type).</td></tr></tbody></table></div><div class="NOTE"><blockquote class="NOTE"><p><b>Python and caching: </b>Python caches certain often-used
          values and shares those values across variables. Numbers
          from 0 to 99 (inclusive) are cached, and strings are always
          cached. Qt uses the same trick from strings and some other
          objects</p><pre class="SCREEN">Python 2.2a4 (#1, Oct  4 2001, 15:35:57)
[GCC 2.95.2 19991024 (release)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; a=1
&gt;&gt;&gt; b=1
&gt;&gt;&gt; id(a)
135268920
&gt;&gt;&gt; id(b)
135268920
&gt;&gt;&gt; a=100
&gt;&gt;&gt; b=100
&gt;&gt;&gt; id(a)
135338528
&gt;&gt;&gt; id(b)
135338504
&gt;&gt;&gt; a="bla"
&gt;&gt;&gt; b="bla"
&gt;&gt;&gt; id(a)
135563808
&gt;&gt;&gt; id(b)
1355638
        </pre></blockquote></div></div><div class="SECT2"><h2 class="SECT2"><a name="AEN3854"/>Files and other IO</h2><p>Qt's file classes include the following:</p><p/><ul><li><p>QDir — directory information</p></li><li><p>QFile — file handling</p></li><li><p>QFileInfo — file information</p></li><li><p>QIODevice — abstract IO device</p></li><li><p>QBuffer — helper class for buffered
            IO</p></li><li><p>QTextStream — abstract class for text
            IO</p></li><li><p>QTextIStream — text input IO</p></li><li><p>QTextOSStream — text output IO</p></li><li><p>QAsyncIO — abstract base for asynchronous
            IO</p></li><li><p>QDataSink — asynchronous data
            consumer</p></li><li><p>QDataSource — asynchronous data produced of
            data</p></li><li><p>QDataStream — binary IO</p></li><li><p>QIODeviceSource — a datasource that draws
            data from a QIODevice, like QFile.</p></li></ul><p>Qt's file and IO handling classes are divided into three
        groups: classes to handle files on a file system, classes that
        work on streams, and asynchronous IO classes. We have already
        seen an example of working with <tt class="CLASSNAME">QDir</tt>.
        <tt class="CLASSNAME">QFile</tt> is Qt's equivalent of the Python
        file object; it is almost fully implemented in PyQt,  with
        some changes due to naming conflicts.
        <tt class="CLASSNAME">QFileInfo</tt> is a useful class that
        encapsulates and caches information including name, path, creation
        date and access rights. You could use the various function in
        Python's <tt class="CLASSNAME">os.path</tt> module, but those
        don't cache information.</p><p>The base class for all these IO-oriented classes is
        <tt class="CLASSNAME">QIODevice</tt>, which is completely
        implemented in PyQt. You can subclass it for your own IO
        classes. Qt divides its stream handling into text streams and
        binary streams. Only the text stream handling in implemented
        in PyQt, with the <tt class="CLASSNAME">QTextStream</tt>,
        <tt class="CLASSNAME">QTextIStream</tt> and
        <tt class="CLASSNAME">QTextOStream</tt> classes.
        <tt class="CLASSNAME">QTextStream</tt> is the base class,
        <tt class="CLASSNAME">QTextIStream</tt> provides input stream
        functionality and  <tt class="CLASSNAME">QTextOStream</tt> output
        stream functionality. One problem remains with these stream
        classes — operator overloading. C++ relies on the
        &gt;&gt; and &lt;&lt; operators to read from and write to a
        stream. PyQt doesn't support this yet, so you cannot actually make use of
        the streaming capabilities. Instead, you will have to limit yourself to
        using <tt class="FUNCTION">read()</tt> to read the entire contents
        of the stream.</p><p>The asynchronous IO classes, the buffer class
        and the binary IO classes have <span class="emphasis"><i class="EMPHASIS">not</i></span> been implemented yet. You can
        easily substitute the various Python modules for file and IO
        handling. You can use <tt class="CLASSNAME">asyncore</tt>
        in place <tt class="CLASSNAME">QAsyncIO</tt>. The Python
        <tt class="CLASSNAME">file</tt> object is buffered by nature, if
        you <tt class="FUNCTION">open()</tt> your files with the
        <tt class="PARAMETER"><i>bufsize</i></tt> parameter set.</p></div><div class="SECT2"><h2 class="SECT2"><a name="AEN3911"/>Date and time</h2><p/><ul><li><p>QDate — representation of a
            data</p></li><li><p>QTime — clock and time
            functions</p></li><li><p>QDateTime — combination of QDate and
            QTime</p></li></ul><p>While Python has a <tt class="CLASSNAME">time</tt> module,
        this only presents a low-level interface to the system
        date and time functions (and the <tt class="FUNCTION">sleep()</tt> function,
        which halts processing for a while). It does not provide a
        high-level encapsulation of dates and times. PyQt, however, provides just
        that with <tt class="CLASSNAME">QDate</tt> and
        <tt class="CLASSNAME">QTime</tt>. <tt class="CLASSNAME">QDate</tt> is
        especially suited to data arithmetic, and can hold dates from
        1752 to 8000. The first limit is based on the date that our
        Gregorian calendar was introduced; if you need the Julian
        calendar (or perhaps Vikram Samvat or other exotic calendars),
        you must write your own <tt class="CLASSNAME">Date</tt>
        class.</p></div><div class="SECT2"><h2 class="SECT2"><a name="AEN3937"/>Mime</h2><p/><p>Python <tt class="CLASSNAME">mimetools</tt> and the
        <tt class="CLASSNAME">MimeWriter</tt> modules are not exactly
        equivalent to the PyQt <tt class="CLASSNAME">QMimeSource</tt> and
        <tt class="CLASSNAME">QMimeSourceFactory</tt> classes. The Python
        modules are optimized for the handling of mime-encoded e-mail
        messages. The PyQt classes are a more generalized abstraction
        of formatted data, where the format is identified by the IANA
        list of MIME media types.
        <tt class="CLASSNAME">QMimeSource</tt> is used extensively in
        the drag'n'drop subsystem, in the clipboard handling, and in the
        production of images for rich text widgets.</p><p>An example is given in the
        <tt class="FILENAME">application.py</tt> script that is included
        with PyQt. Below, I show a relevant fragment of that example, which takes a
        bit of html-formatted text with an &lt;img&gt; tag to a
        certain name, which is resolved using
        <tt class="CLASSNAME">QMimeSourceFactory</tt>:</p><div class="EXAMPLE"><a name="AEN3961"/><p><b>Example 10-20. Using QMimeSourceFactory (application.py)</b></p><pre class="PROGRAMLISTING"> ...
fileOpenText = \
'''&lt;img source="fileopen"&gt;
Click this button to open a &lt;em&gt;new file&lt;/em&gt;.&lt;br&gt;&lt;br&gt;
You can also select the &lt;b&gt;Open&lt;/b&gt; command from the &lt;b&gt;File&lt;/b&gt; menu.'''
...
        QWhatsThis.add(self.fileOpen,fileOpenText)
        QMimeSourceFactory.defaultFactory().setPixmap('fileopen',openIcon)
...
        </pre></div></div><div class="SECT2"><h2 class="SECT2"><a name="AEN3964"/>Text handling</h2><p/><ul><li><p>QString — string handling </p></li><li><p>QRegExp — regular expressions that work on a
            string.</p></li><li><p>QChar — one Unicode character</p></li><li><p>QValidator — validates input text according
            to certain rules</p></li><li><p>QTextCodec — conversions between text
              encodings</p></li><li><p>QTextDecoder — decode a text to
            Unicode</p></li><li><p>QTextEncoder — encode a text from
            Unicode</p></li></ul><p>Qt's string handling really excels: it is thoroughly based
        upon Unicode, but provides easy functionality for other
        character encodings. However, plain Python also provides
        Unicode string functionality, and the interplay between Python
        strings and PyQt QStrings can be quite complex.</p><p>For most purposes, however, the conversions are
        transparent, and you can use Python strings as parameters in
        any function call where a <tt class="CLASSNAME">QString</tt> is
        expected. If you run across more complex problems, you can
        consult <a href="c2029.htm">Chapter 8</a>, on String Objects in Python and
        Qt.</p></div><div class="SECT2"><h2 class="SECT2"><a name="AEN3992"/>Threads</h2><p/><p>Python threads and Qt threads bite each other frequently.
        Qt thread support itself is still experimental, and with
        Unix/X11, most people still use the un-threaded Qt
        library. The C++ Qt thread class <tt class="CLASSNAME">QMutex</tt>
        has not been ported to PyQt, so you cannot serialize access to
        gui features.</p><p>Python thread support is far more mature, but doesn't mix
        too well with PyQt — you don't want two threads
        accessing the same gui element. You're quite safe though, as
        long as your threads don't access the gui. The next example
        shows a simple pure-python script with two threads:</p><div class="EXAMPLE"><a name="AEN4002"/><p><b>Example 10-21. thread1.py — Python threads without
          gui</b></p><pre class="PROGRAMLISTING">#
# thread1.py
#
import sys
import time
from threading import *

class TextThread(Thread):

    def __init__(self, name, *args):
        self.counter=0
        self.name=name
        apply(Thread.__init__, (self, ) + args)

    def run(self):
        while self.counter &lt; 200:
            print self.name, self.counter
            self.counter = self.counter + 1
            time.sleep(1)

def main(args):
   thread1=TextThread("thread1")
   thread2=TextThread("thread2")
   thread1.start()
   thread2.start()

if __name__=="__main__":
  main(sys.argv)
        </pre></div><p>The next example has a Qt window. The threads run quite
        apart from the window, and yet everything operates fine—
        that is, until you try to close the application. The threads
        will continue to run until they are finished, but it would be
        better to kill the threads when the last window is closed.
        Killing or stopping threads from outside the threads is not
        supported in Python, but you can create a global variable,
        <tt class="VARNAME">stop</tt>, to circumvent this.  In the threads
        themselves, you then check whether <tt class="VARNAME">stop</tt> is
        true.</p><div class="EXAMPLE"><a name="AEN4008"/><p><b>Example 10-22. Python threads and a PyQt gui window</b></p><pre class="PROGRAMLISTING">#
# thread2.py - Python threads
#
import sys, time
from threading import *
from qt import *

class TextThread(Thread):

    def __init__(self, name, *args):
        self.counter=0
        self.name=name
        apply(Thread.__init__, (self, ) + args)

    def run(self):
        while self.counter &lt; 200:
            print self.name, self.counter
            self.counter = self.counter + 1
            time.sleep(1)

class MainWindow(QMainWindow):

    def __init__(self, *args):
        apply(QMainWindow.__init__, (self,) + args)
        self.editor=QMultiLineEdit(self)
        self.setCentralWidget(self.editor)
        self.thread1=TextThread("thread1")
        self.thread2=TextThread("thread2")
        self.thread1.start()
        self.thread2.start()

def main(args):
    app=QApplication(args)
    win=MainWindow()
    win.show()
    app.connect(app, SIGNAL("lastWindowClosed()"),
                app, SLOT("quit()"))
    app.exec_loop()
  
if __name__=="__main__":
    main(sys.argv)
        </pre></div><p>Another technique (though dangerous!) is to have the GUI use
        a timer to periodically check the variables produced by the
        threads. However, concurrent access of a variable can lead to
        nasty problems.</p></div><div class="SECT2"><h2 class="SECT2"><a name="AEN4015"/>URL's</h2><p>The Qt URL-handling classes are quite equivalent to
        Python's urllib module. It's up to you to choose which you
        prefer.</p><p/></div><div class="SECT2"><h2 class="SECT2"><a name="AEN4027"/>Qt modules that overlap with Python modules</h2><p>In addition, there are two Qt modules that are also
        available completely as Python modules: the XML module
        (wrapped by Jim Bublitz) and the Network module. The Python
        equivalent of Qt's XML module, for simple tasks, xmllib, and
        for more complicated problems xml.sax. While xmllib is
        deprecated, it is still very useful and one the simplest ways
        of handling XML data. The xml.sax module depends on the
        presence of the expat parser, which is not available on every
        system.</p><p>The Qt network module has not been
        completely wrapped in PyQt yet. It is mainly useful if you
        want to program your own network clients and servers, and
        intend to move your code to C++ one day. Python offers
        equivalent modules for every service, and a lot more, too
        (such as http and gopher clients). You might find Qt's socket
        objects a bit more convenient than Python's offerings. Another
        possible reason to use the Qt socket classes is that they are
        better implemented on Windows than the Python socket
        classes.</p><div class="TABLE"><a name="AEN4039"/><p><b>Table 10-2. Qt and Python network classes</b></p><table border="1" class="CALSTABLE"><thead><tr><th align="LEFT" valign="TOP">Qt Class</th><th align="LEFT" valign="TOP">Python Class</th><th align="LEFT" valign="TOP">Implemented</th><th align="LEFT" valign="TOP">Description</th></tr></thead><tbody><tr><td align="LEFT" valign="TOP">QSocket</td><td align="LEFT" valign="TOP">socket</td><td align="LEFT" valign="TOP">Partially implemented</td><td align="LEFT" valign="TOP">Low level network connection object. Note that
                Python's socket module is useful both for clients and
                servers, while Qt's QSocket is for clients only:
                servers use QServerSocket.</td></tr><tr><td align="LEFT" valign="TOP">QSocketDevice</td><td align="LEFT" valign="TOP">socket</td><td align="LEFT" valign="TOP">No</td><td align="LEFT" valign="TOP">This class is mostly intended for use inside Qt -
                use QIODevice instead, which is completely implemented
                in PyQt.</td></tr><tr><td align="LEFT" valign="TOP">QServerSocket</td><td align="LEFT" valign="TOP">socket, SocketServer</td><td align="LEFT" valign="TOP">Partially implemented</td><td align="LEFT" valign="TOP">The server-side complement of QSocket. Again,
                Python's socket module servers both for server and
                client applications. Python offers the server-specific
                SocketServer module.</td></tr><tr><td align="LEFT" valign="TOP">QHostAddress</td><td align="LEFT" valign="TOP">No real equivalent</td><td align="LEFT" valign="TOP">Partially — not the functionality for
                IPv6.</td><td align="LEFT" valign="TOP">A platform and protocol independent
                representation of an IP address.</td></tr><tr><td align="LEFT" valign="TOP">QDns</td><td align="LEFT" valign="TOP">No real equivalent</td><td align="LEFT" valign="TOP">Not implemented</td><td align="LEFT" valign="TOP">Asynchronous DNS lookups — it's not
                implemented, all Python libraries do automatic
                synchronous DNS lookups, as do the QSocket derived Qt
                classes.</td></tr><tr><td align="LEFT" valign="TOP">QFtp</td><td align="LEFT" valign="TOP">ftplib</td><td align="LEFT" valign="TOP">Not implemented</td><td align="LEFT" valign="TOP">This class is seldom used: it's easier to just
                open an URL either with QUrlOperator or one of the
                Python Internet protocol handling libraries like
                urllib.
	      </td></tr></tbody></table></div></div></div></div></body></html>