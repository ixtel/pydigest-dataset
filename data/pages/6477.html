<html><body><div><p>Python regex command-line tool, to replace functionality akin to 'perl -ne'.</p>
<div class="section" id="rst-header-usage">
<h2>Usage</h2>
<p>Use --help/-h to view info on the arguments:</p>
<pre class="literal-block">
$ red --help
</pre>
<p>The special variables available:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field"><th class="field-name"><strong>line</strong>:</th><td class="field-body">for the entire line that was matched, without the trailing newline</td>
</tr>
<tr class="field"><th class="field-name"><strong>g</strong>:</th><td class="field-body">for groups, which you index to get that match group, as <strong>g[0]</strong> in "(w+) .*"</td>
</tr>
<tr class="field"><th class="field-name"><strong>ag</strong>:</th><td class="field-body">for aggregated groups with the <em>-a</em> option, which is a list of all match groups</td>
</tr>
<tr class="field"><th class="field-name"><strong>d</strong>:</th><td class="field-body">for the groupdict, which you can index by named group as <strong>d["foo"]</strong> in "(?P&lt;foo&gt;w+) .*"</td>
</tr>
<tr class="field"><th class="field-name"><strong>ad</strong>:</th><td class="field-body">for the aggregated group dicts, a list of dicts</td>
</tr>
</tbody>
</table>
<p>Example usage:</p>
<pre class="literal-block">
$ cat test.txt
foo 1 bar 2
fiz 5 baz 10
funk 10 bunk 9
funk a bunk b
a b c d
aaaaa
bbbb
cc
</pre>
<p>Use it like grep:</p>
<pre class="literal-block">
$ cat test.txt | red "\w+ (\d+) \w+ (\d+)"
foo 1 bar 2
fiz 5 baz 10
funk 10 bunk 9
</pre>
<p>It works with path as argument as well, <em>but the path must appear directly after the regex</em> (oddity of argparse).:</p>
<pre class="literal-block">
$ red "\w+ (\d+) \w+ (\d+)" test.txt
</pre>
<p>Use it to evaluate Python code on groups stored in variable <strong>g</strong>:</p>
<pre class="literal-block">
$ red "\w+ (\d+) \w+ (\d+)" test.txt -e "int(g[0]) + int(g[1])"
3
15
19
</pre>
<p>Import an arbitrary library and do absolutely anything:</p>
<pre class="literal-block">
$ red '\w+ (\d+) \w+ (\d+)' test.txt -i json -e '"{} =&gt; {}".format(line, json.dumps(g))'
foo 1 bar 2 =&gt; ["1", "2"]
fiz 5 baz 10 =&gt; ["5", "10"]
funk 10 bunk 9 =&gt; ["10", "9"]
</pre>
<p>If you want to execute a few python statements before the eval, you can do that as well with <strong>-x</strong>:</p>
<pre class="literal-block">
$ red "(\w+) (\d+).*" test.txt -x 'x = int(g[1]) ; y = g[0][::-1]' -e '(x, y)'
(1, 'oof')
(5, 'zif')
(10, 'knuf')
</pre>
<p>Use it to aggregate across all of stdin, into list <strong>ag</strong>:</p>
<pre class="literal-block">
$ cat test.txt | red "\w+ (\d+) \w+ (\d+)" -a "sum([int(x[0]) for x in ag])"
16
</pre>
<p>Aggregate has its own <strong>-X</strong> for an exec before the aggregate too:</p>
<pre class="literal-block">
$ red "(\w+) (\d+).*" test.txt -X 's = sum(int(g[1]) for g in ag)' -a 's'
16
</pre>
<p>Evaluate on each match, and aggregate against all matches:</p>
<pre class="literal-block">
$ cat test.txt | red "\w+ (\d+) \w+ (\d+)" -a "sum([int(x[0]) for x in ag])" -e "'adding {}'.format(g[0])"
adding 1
adding 5
adding 10
16
</pre>
<p>You can use named groups as well, stored in variables <strong>d</strong> and aggregated into <strong>ad</strong>:</p>
<pre class="literal-block">
$ cat test.txt | red "\w+ (?P&lt;first&gt;\d+) \w+ \d+" -e "'first value is {first}'.format(**d)"
first value is 1
first value is 5
first value is 10
</pre>
<p>Even multiline will work, since whatever is passed into <strong>-x</strong> is just <strong>exec</strong>'d:</p>
<pre class="literal-block">
$ red '.*' test.txt -x '
# if you want multiline, just hit apostrophe and press enter
# and start typing
if line.startswith("foo"):
     print("Line started with foo: {}".format(line))
'

Line started with foo: foo 1 bar 2
</pre>
<p>Get creative!:</p>
<pre class="literal-block">
$ cat urls.txt
https://www.google.com/
http://www.yahoo.com/
http://www.example.com/foo

$ red "(.*)" urls.txt -i requests -x 'response = requests.get(line)' -e '[response.status_code, response.content[:20]]'
[404, '&lt;!doctype html&gt;\n&lt;htm']
[200, '&lt;!doctype html&gt;&lt;html']
[200, '&lt;?xml version="1.0" ']

$ cat somelogfile.log
INFO: visited http://www.example.com/foo
ERROR: visited https://www.google.com/
ERROR: visited http://www.yahoo.com/

$ cat somelogfile.log | red '(?P&lt;debuglevel&gt;ERROR|INFO): \S+ (?P&lt;url&gt;.*)' -i requests,collections -x 'response = requests.get(d["url"])' -e '(response.status_code, response.content[0:20])' -a 'collections.Counter([d["debuglevel"] for d in ad]).items()'
(404, '&lt;!doctype html&gt;\n&lt;htm')
(200, '&lt;!doctype html&gt;&lt;html')
(200, '&lt;?xml version="1.0" ')
[('INFO', 1), ('ERROR', 2)]
</pre>
</div>
</div></body></html>