<html><body><div><div class="post-entry">
					<p>My name is Stephan, and I’m a scientist on the Climatology team at The Climate Corporation. We make extensive use of Python to build statistical weather models, and sometimes we need our code to be fast. Here’s how I choose between  <a href="http://numba.pydata.org/">Numba</a> and <a href="http://cython.org/">Cython</a>, two of the best options for accelerating numeric Python code.</p>
<p>Most of the time, libraries like <a href="http://numpy.org">NumPy</a>, <a href="http://scipy.org">SciPy</a> and <a href="http://pandas.pydata.org">pandas</a>, whose critical loops are already written in a compiled language like C, are enough fast scientific Python code. Unfortunately, sometimes you need to write your own loop in performance critical paths of your code, and also unfortunately, loops in Python are painfully slow. This is where Numba and Cython come in: they both promise the ability to write the inner loop of your code in something that looks a lot like normal Python, but that runs about as fast as handwritten C.</p>
<p>Numba uses LLVM to power Just-In-Time compilation of array oriented Python code. Using Numba is usually about as simple as adding a decorator to your functions:</p>
<pre class="brush: python; title: ; notranslate" title="">
from numba import jit

@jit
def numba_mean(x):
    total = 0
    for xi in x:
        total += xi
    return total / len(x)
</pre>
<p>You can supply optional types, but they aren’t required for performant code as Numba can compile functions on the fly using its JIT compiler.</p>
<p>In contrast, Cython is a general purpose tool, not just for array oriented computing, that compiles Python into C extensions. To see impressive speedups, you need to manually add types:</p>
<pre class="brush: python; title: ; notranslate" title="">
def cython_mean(double[:] x):
    cdef double total = 0
    for i in range(len(x)):
        total += x[i]
    return total / len(x)
</pre>
<p>When I benchmark this example, IPython’s <code>%timeit</code> reports that calling this function on a 100000 element array takes ~16 ms with pure Python version, but only ~93 µs with Numba and ~96 µs with Cython.<sup id="fnref-403-1"><a href="#fn-403-1" rel="footnote">1</a></sup></p>
<p>This trivial example illustrates my broader experience with Numba and Cython: both are pretty easy to use, and result in roughly equivalently fast code. For similar results on a less contrived example, see <a href="https://jakevdp.github.io/blog/2013/06/15/numba-vs-cython-take-2/">this blog post</a> by Jake VanderPlas.</p>
<p>The bottom line is that even though performance is why we reach for tools like Numba and Cython, it doesn’t provide a good basis for choosing one over the other. So here are the questions I ask myself when making that choice for my projects.</p>
<h2>Will other people be deploying your code?</h2>
<p>Cython is easier to distribute than Numba, which makes it a better option for user facing libraries. It’s the preferred option for most of the scientific Python stack, including NumPy, SciPy, pandas and Scikit-Learn. In contrast, there are very few libraries that use Numba. I know of two, both of which are basically in the experimental phase: <a href="https://github.com/continuumio/blaze">Blaze</a> and my project <a href="https://github.com/shoyer/numbagg">numbagg</a>.</p>
<p>The main issue is that it can be difficult to install Numba unless you use <a href="http://conda.io/">Conda</a>, which is a great tool, but not one everyone wants to use. In contrast, distributing a package with Cython based C-extensions is almost miraculous easy. Cython is also a more stable and mature platform, whereas the features and performance of Numba are still evolving.</p>
<p>If you don’t need to distribute your code beyond your computer or your team (especially if you use Conda), then Numba can be a great choice. Otherwise, you should lean toward Cython.</p>
<h2>Do you need advanced Python features or to use C-level APIs?</h2>
<p>The features that Numba supports in the accelerated <code>nopython</code> mode are very limited. For example:</p>
<ul>
<li>Numba only accelerates code that uses scalars or (N-dimensional) arrays. You can’t use built-in types like <code>list</code> or <code>dict</code> or your own custom classes.</li>
<li>You can’t <a href="https://github.com/numba/numba/pull/719">allocate new arrays</a> in accelerated code.</li>
<li>You can’t use <a href="https://github.com/numba/numba/pull/719">recursion</a>.</li>
</ul>
<p>Some of these are <a href="http://numba.pydata.org/numba-doc/0.17.0/user/troubleshoot.html">design decisions</a>; in other cases, these are being actively worked on.</p>
<p>In contrast, Cython can compile arbitrary Python code, and can even directly call C. The ability to “cythonize” an entire module written using advanced Python features and then only tweak the bottlenecks for speed can be really nice.</p>
<p>For example, switching to an <a href="http://docs.cython.org/src/userguide/extension_types.html">extension type</a> and calling C APIs directly can make for big differences in speed, even if you still rely on builtin Python types like lists or dictionaries. Writing<br/>
something like <a href="https://github.com/shoyer/cyordereddict">cyordereddict</a> in Numba would be nearly impossible.</p>
<h2>Do you want to write code that works on N-dimensional arrays?</h2>
<p>Suppose you want a function that takes several arguments and returns a scalar or array, depending on the number of provided arguments. For example, consider a function that averages two numbers:</p>
<pre class="brush: python; title: ; notranslate" title="">
def average(a, b):
    return 0.5 * (a + b)
</pre>
<p>One of the most powerful features of NumPy is that this simple function would work even if <code>a</code> or <code>b</code> are multi-dimensional arrays (tensors), by following <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">broadcasting rules</a>.</p>
<p>Numba makes it easy to accelerate functions with broadcasting by simply adding the <a href="http://numba.pydata.org/numba-doc/0.17.0/user/vectorize.html"><code>vectorize</code></a> decorator. This produces universal functions (ufuncs) that automatically work (even preserving labels) on array-like data structures in the entire scientific Python ecosystem, including <a href="http://xray.readthedocs.org">xray</a> (my project) and <a href="http://pandas.pydata.org">pandas</a>. In other cases, Numba can handle arbitrary dimensional input by using Just-In-Time compilation with <code>jit</code> or by creating generalized universal functions with <code>guvectorize</code>.</p>
<p>In contrast, generally speaking, your Cython functions will only work for input with a number of dimensions that you determine ahead of time (e.g., a 1D vector, but not a scalar or 2D array). It certainly possible to do this sort of stuff with Cython, but it’s not easy, and you’ll need to get your hands dirty with the <a href="http://docs.scipy.org/doc/numpy/reference/c-api.html">NumPy C-API</a>. Keith Goodman has some nice examples in <a href="https://github.com/kwgoodman/bottleneck/issues/92">version 1.0 of bottleneck</a>.</p>
<h2>Still not sure?</h2>
<p>When I’m not constrained by other concerns, I’ll try to make Numba work. Numba is usually easier to write for the simple cases where it works. You may still run into annoying limitations when you try to do complex things, but Numba has been getting a lot better, even just over the past few months (e.g., they recently added support for <a href="https://github.com/numba/numba/pull/981">generating random numbers</a>). At the end of the day, even if you ultimately can’t get things to work, you’ll still have idiomatic Python code that should be easy to accelerate with Cython.</p>
<hr/>
<p>This post is <a href="http://stephanhoyer.com/2015/04/09/numba-vs-cython-how-to-choose/">cross posted</a> to my personal website.</p>

<div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><div class="sharedaddy sd-block sd-like jetpack-likes-widget-wrapper jetpack-likes-widget-unloaded" id="like-post-wrapper-49738468-403-56d5b42a98256" data-src="//widgets.wp.com/likes/#blog_id=49738468&amp;post_id=403&amp;origin=tccengblog.wordpress.com&amp;obj_id=49738468-403-56d5b42a98256" data-name="like-post-frame-49738468-403-56d5b42a98256"><h3 class="sd-title">Like this:</h3><p class="likes-widget-placeholder post-likes-widget-placeholder"><span class="button"><span>Like</span></span> <span class="loading">Loading...</span></p><span class="sd-text-color"/><a class="sd-link-color"/></div>
<p id="jp-relatedposts" class="jp-relatedposts">
	<h3 class="jp-relatedposts-headline"><em>Related</em></h3>
</p></div>
					
									</div>

				</div></body></html>