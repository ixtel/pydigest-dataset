<html><body><div><div class="ArticleText">
<p class="FeatureByline">
           By <b>Jake Edge</b><br/>May 13, 2015
           </p>
<p>
It is already possible to create <a href="http://en.wikipedia.org/wiki/Coroutine">coroutines</a> for
asynchronous processing in Python.
But a recent proposal would elevate coroutines to a full-fledged language
construct, rather than treat them as a type of <a href="https://wiki.python.org/moin/Generators">generator</a> as they are
currently.  Two new keywords, <tt>async</tt> and <tt>await</tt>, would be
added to the language to support coroutines as first-class Python features.
</p>

<p>
A coroutine is a kind of function that can
suspend and resume its execution at various pre-defined locations in its
code.  Subroutines are a special case of coroutines that have just a single
entry point and complete their execution by returning to their caller.
Python's coroutines (both the existing generator-based and the newly
proposed variety) are not fully general, either, since they can only
transfer control back to their caller when suspending their execution,
as opposed to switching to some other coroutine as they can in the general case.
When coupled with an event loop, coroutines can be used to do asynchronous
processing, I/O in particular.
</p>

<p>
Python's current coroutine support is based on the enhanced generators from <a href="https://www.python.org/dev/peps/pep-0342/">PEP 342</a>, which was
adopted into Python 2.5.  That PEP changed the <tt>yield</tt> statement
to be an expression, added several new methods for generators
(<tt>send()</tt>, <tt>throw()</tt>, and <tt>close()</tt>), and ensured that
<tt>close()</tt> would be called when generators get garbage-collected.
That functionality was further enhanced in Python 3.3 with <a href="https://www.python.org/dev/peps/pep-0380/">PEP 380</a>, which
added the <tt>yield from</tt> expression to allow a generator to
delegate some of its functionality to another generator (i.e. a sub-generator).
</p>

<p>
But all of that ties coroutines to generators, which can be confusing and
also limits where in the code it is legal to make an asynchronous call.  In
particular, the <tt>with</tt> and <tt>for</tt> statements could
conceptually use an asynchronous call to a coroutine, but cannot because
the language syntax does not allow <tt>yield</tt> expressions in those
locations.  In addition, if a refactoring of the coroutine moves the
<tt>yield</tt> or <tt>yield from</tt> out of the function (into
a called function, for example), it no
longer is treated as a coroutine, which can lead to non-obvious errors; the <a href="https://docs.python.org/3/library/asyncio.html">asyncio</a> module
works around this deficiency by using a <tt>@asyncio.coroutine</tt> decorator.
</p>

<p>
<a href="https://www.python.org/dev/peps/pep-0492/">PEP 492</a> is meant to
address all of those issues.  The ideas behind it were first <a href="/Articles/644056/">raised</a> by Yury Selivanov on the python-ideas
mailing list in 
mid-April, it was enthusiastically embraced by many in that thread, and by
May 5 it had been <a href="/Articles/644060/">accepted</a> for
Python 3.5 by Guido van Rossum.  Not only that, but the implementation
was merged on May 12.
It all moved rather quickly,
though it was discussed at length in multiple threads on both python-ideas
and python-dev.
</p>

<p>
The changes are fairly straightforward from a syntax point of view:
</p><pre>
    async def read_data(db):
        data = await db.fetch('SELECT ...')
	...
</pre><p>
That example (which comes from the PEP) would create a </p><tt>read_data()</tt><p>
coroutine using the new </p><tt>async def</tt><p> construct.  The
</p><tt>await</tt><p> expression would suspend execution of </p><tt>read_data()</tt><p>
until the </p><tt>db.fetch()</tt> <a href="https://www.python.org/dev/peps/pep-0492/#await-expression">awaitable</a><p> completes and returns its result.
</p><tt>await</tt><p> is similar to </p><tt>yield from</tt><p>, but it validates
that its argument is an awaitable.


</p><p>
There are several different types of awaitable.  A native coroutine object,
as returned by calling a native coroutine (i.e. one defined with
<tt>async def</tt>) is an awaitable, as is a generator-based coroutine
that has been decorated with <tt>@types.coroutine</tt>.  <a href="https://www.python.org/dev/peps/pep-3156/#futures">Future</a>
objects, which represent some processing that will complete in the future,
are also awaitable.  The <tt>__await__()</tt> magic method is present for
objects that are awaitable.
</p>

<p>
There is a problem that occurs when adding new keywords to a language,
however.  Any variables that are named the same as the keyword suddenly
turn into syntax 
errors.  To avoid that problem, Python 3.5 and 3.6 will "softly
deprecate" <tt>async</tt> and <tt>await</tt> as variable names, but not
have them be a syntax error.  The parser will keep track of
<tt>async def</tt> blocks and treat the keywords differently within
those blocks, which will allow existing uses to continue to function.
</p>

<p>
There are two other uses of <tt>async</tt> that will come with the new
feature: asynchronous context managers (i.e. <tt>with</tt>) and iterators
(i.e. <tt>for</tt>).  Inside a coroutine, these two constructs can be used
as shown in these examples from the PEP:
</p><pre>
    async def commit(session, data):
	...

	async with session.transaction():
	    ...
	    await session.update(data)
	    ...
        ...
        async for row in Cursor():
            print(row)
</pre><p>

Asynchronous context managers must implement two magic </p><tt>async</tt><p> methods,
</p><tt>__aenter__()</tt><p> and </p><tt>__aexit__()</tt><p>, both of which return
awaitables, while an asynchronous 
iterator would implement </p><tt>__aiter__()</tt><p> and </p><tt>__anext__()</tt><p>.
Those are effectively the asynchronous versions of the magic methods used
by the existing synchronous context manager and iterator. 


</p><p>
The main question early on was whether the deferred "cofunction" feature (<a href="https://www.python.org/dev/peps/pep-3152/">PEP 3152</a>) might be
a better starting point.  The author of that PEP, Greg Ewing, <a href="/Articles/644066/">raised the issue</a>, but there was a lot of
agreement that the syntax proposed by Selivanov was preferable to 
the <tt>codef</tt>, <tt>cocall</tt>, and the like from Ewing's proposal.
There was a fair amount of back and forth, but the cofunction syntax for
handling 
certain cases got rather complex and non-Pythonic in the eyes of some.  Van
Rossum <a href="/Articles/644128/">summarized</a> the problems with
cofunctions while rejecting that approach.
</p>

<p>
There were also several suggestions of additional asynchronous features
that could be added, 
but nothing that seemed too urgent.  There was some bikeshedding on
the keywords (and their order, some liked <tt>def async</tt>, for
example). The precedence of <tt>await</tt> was also debated at some length,
with the result being that, unlike <tt>yield</tt> and
<tt>yield from</tt> that have the lowest precedence, <tt>await</tt>
has a high precedence: between exponentiation and
subscripting, calls, and attribute references.
</p>

<p>
Mark Shannon <a href="/Articles/644130/">complained</a> that there was no
need to add new syntax to do what Selivanov was proposing.  Others had made
similar observations and it was not disputed by Selivanov or other
proponents.  The idea is to make it <i>easier</i> to program with
coroutines.  Beyond that, Van Rossum wants the places where a coroutine can
be suspended to be <a href="/Articles/644132/">obvious from reading the
code</a>:
</p><p class="BigQuote">
But new syntax is the whole point of the PEP. I want to be able to
*syntactically* tell where the suspension points are in coroutines.
Currently this means looking for yield [from]; PEP 492 just adds looking
for await and async [for|with]. Making await() a function defeats the
purpose because now aliasing can hide its presence, and we're back in the
land of gevent or stackless (where *anything* can potentially suspend the
current task). I don't want to live in that land.
</p>


<p>
Over a two to three week period, multiple versions of the PEP were posted
and debated, with Selivanov patiently explaining his ideas or modifying
them based on the feedback.  For a feature that seems likely to be quite
important in Python's future, the whole process went remarkably quickly—and
smoothly.  It will probably take a fair amount more time for those ideas to
sink in more widely with Python developers.
</p><hr align="left"/><p>
           (</p><a href="https://lwn.net/login?target=/Articles/643786/">Log in</a><p> to post comments)
           </p><p>
           
</p></div> 
</div></body></html>