<html><body><div><div class="entry-content"><p>Most people don't get <a class="reference external" href="http://en.wikipedia.org/wiki/Unicode">Unicode</a> right. It is not their fault, I believe the biggest
trouble here is that people underestimate the complexity of Unicode.</p>
<p>I've been working with text manipulation tasks using Python for a long time.
During the last ten years I've been collecting thousands of mistakes for misinterpreting
Unicode and its implementation in Python.</p>
<p>In order to help beginners avoid a few of them and understand most of them, I've decided
to focus this post on the common pitfalls you can hit with Python 2.x and Unicode.
Python 3.x handles Unicode in a very different way, it has its own issues but are usually
different that the ones you'll fight against on Python 2.x.</p>
<div class="section" id="str-vs-unicode">
<h2>str vs unicode</h2>
<p>Python has two types for strings: <tt class="docutils literal">str</tt> and <tt class="docutils literal">unicode</tt>. <tt class="docutils literal">str</tt> is used for binary data,
unicode for text data. As most of the string operations can be done using the <tt class="docutils literal">str</tt> and as
the literal for byte strings is simpler than the unicode ones you'll end up with lots of text
data handled by the <tt class="docutils literal">str</tt> type. This is <em>not</em> what you really want. Python tries to help you
with automatic coercion between these two types, for example if you concatenate two strings
of both types the result is an <tt class="docutils literal">unicode</tt> string.</p>
<p>How does Python convert <tt class="docutils literal">str</tt> to <tt class="docutils literal">unicode</tt>? It uses a default encoding to decode the
byte string. You can get your default encoding checking the <cite>sys.getdefaultencoding()</cite>.
Normally it is <tt class="docutils literal">ascii</tt> which is easily wrong when you work with non-English languages.</p>
<p>Whenever Python does an automatic decoding it might raises an <tt class="docutils literal">UnicodeDecodeErrror</tt>
exception. This is because the byte string is not a valid representation of the default
encoding.</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="s">'à'</span> <span class="o">+</span> <span class="s">u'foo'</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">UnicodeDecodeError</span><span class="p">:</span> <span class="s">'ascii'</span> <span class="n">codec</span> <span class="n">can</span><span class="s">'t decode byte 0xc3 in position 0: ordinal not in range(128)</span>
</pre></div>
</div>
<div class="section" id="print-vs-write">
<h2>print vs write</h2>
<p><tt class="docutils literal">print</tt> is normally used to write on streams. <tt class="docutils literal">write</tt> is what you should
use for binary data. What <tt class="docutils literal">print</tt> does is first encode the string using the
stream encoding (using the <tt class="docutils literal">encoding</tt> property of the <tt class="docutils literal">file</tt>) if set or the
<tt class="docutils literal">ascii</tt> encoding otherwise. Watch out when you are doing:</p>
<div class="highlight"><pre><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'output.dat'</span><span class="p">,</span> <span class="s">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">fout</span><span class="p">:</span>
    <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">fout</span><span class="p">,</span> <span class="s">u'</span><span class="se">\N{LATIN SMALL LETTER E WITH ACUTE}</span><span class="s">'</span>
</pre></div>
<p>You need to encode the string first:</p>
<div class="highlight"><pre><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'output.dat'</span><span class="p">,</span> <span class="s">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">fout</span><span class="p">:</span>
    <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">fout</span><span class="p">,</span> <span class="s">u'</span><span class="se">\N{LATIN SMALL LETTER E WITH ACUTE}</span><span class="s">'</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'utf8'</span><span class="p">)</span>
</pre></div>
<p>The <tt class="docutils literal">codecs</tt> module suits perfectly in this case as it provides file streams that
support non-ascii encoding. You can either open the file using the <tt class="docutils literal">codecs.open</tt>
function or wrap a stream with a <tt class="docutils literal">codecs.StreamReader</tt> or <tt class="docutils literal">codecs.StreamWriter</tt>:</p>
<div class="highlight"><pre><span class="n">fin</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getreader</span><span class="p">(</span><span class="s">'utf8'</span><span class="p">)(</span><span class="n">fin</span><span class="p">)</span>
<span class="n">fout</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getwriter</span><span class="p">(</span><span class="s">'utf8'</span><span class="p">)(</span><span class="n">fout</span><span class="p">)</span>

<span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">fout</span><span class="p">,</span> <span class="s">u'</span><span class="se">\N{LATIN SMALL LETTER E WITH ACUTE}</span><span class="s">'</span>
</pre></div>
<p>If you run the Python interpreter on the terminal without input/output redirection,
then both <tt class="docutils literal">sys.stdin</tt> and <tt class="docutils literal">sys.stdout</tt> have a default encoding that should be
compatible with the one of the terminal. When you are printing unicode strings
be aware of the fact the encoding can fail.</p>
</div>
<div class="section" id="normalization">
<h2>Normalization</h2>
<p>A character in Unicode can be represented in multiple ways, for instance the character
<tt class="docutils literal">é</tt> in UTF-8 is represented by both the byte strings <tt class="docutils literal">'\xc3\xa9'</tt> and <tt class="docutils literal">'e\xcc\x81'</tt>.
This means you might find out you have the same text represented in two different ways (i.e.
your strings come from different sources found on the Web). Why is this important for us?
Look at this example:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="s">'</span><span class="se">\xc3\xa9</span><span class="s">'</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf8'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="s">'e</span><span class="se">\xcc\x81</span><span class="s">'</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf8'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">a</span>
<span class="err">é</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">b</span>
<span class="err">é</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
<span class="bp">False</span>
</pre></div>
<p>This is where <tt class="docutils literal">unicodedata</tt> module becomes handy. Particularly the function <tt class="docutils literal">normalize</tt>.
This function converts a string to a normal form. You can find the supported canonical forms
in the docs:</p>
<blockquote>
Valid values for form are 'NFC', 'NFKC', 'NFD', and 'NFKD'.</blockquote>
<p>Let's do it:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="s">'</span><span class="se">\xc3\xa9</span><span class="s">'</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf8'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="s">'e</span><span class="se">\xcc\x81</span><span class="s">'</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf8'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">a</span>
<span class="err">é</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">b</span>
<span class="err">é</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">unicodedata</span> <span class="kn">import</span> <span class="n">normalize</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">normalize</span><span class="p">(</span><span class="s">'NFC'</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">normalize</span><span class="p">(</span><span class="s">'NFC'</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="bp">True</span>
</pre></div>
<p>Et voilat, very simple but very subtle.</p>
</div>
<div class="section" id="newlines">
<h2>Newlines</h2>
<p>A few years ago I was working with TSV files. The TSV files were weakly defined, we
basically had no escape characters because the strings contained in each field could
not contain tabs and line feeds. Some of the fields contained ASCII strings, some
others UTF-8 strings. My Python scripts were doing some text manipulation jobs, in
order to read the text from the files I was using the nice <tt class="docutils literal">codecs</tt> module, this
was my function to read the input:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">codecs</span>

<span class="k">def</span> <span class="nf">read_tsv</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">codecs</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">'utf8'</span><span class="p">)</span> <span class="k">as</span> <span class="n">fin</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fin</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">yield</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">)</span>
</pre></div>
<p>Simple, isn't it? ASCII is compatible to UTF-8, so basically there were no problems due to
the encoding mix, I could assume everything was UTF-8 complaint.</p>
<p>This worked <strong>most</strong> of the times. One day it failed. It took a while to understand that
for some reasons one of the line contained less fields than the assumptions made by the
script. Checking the bad line with an editor I could see the right number of fields.</p>
<p>That day I've learned that <a class="reference external" href="http://en.wikipedia.org/wiki/Newline#Unicode">Unicode standard defines multiple ways to represent new lines</a>...</p>
<p>Check this code:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="s">u'hello</span><span class="se">\N{LINE SEPARATOR}</span><span class="s">world'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">))</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">splitlines</span><span class="p">())</span>
<span class="mi">2</span>
</pre></div>
<p>As you can see we've got a text string without line feeds but that still breaks into two
lines using the <tt class="docutils literal">splitlines</tt> string method. Our weakly defined TSV files was right, my
code was wrong. Fields could not contain <strong>tabs</strong> (<tt class="docutils literal">'\t'</tt>) and <strong>line feeds</strong> (<tt class="docutils literal">'\n'</tt>)
and my lazy <tt class="docutils literal">read_tsv</tt> function was wrong. Even if it was an hard issue to spot, it was
easy to fix it:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">read_tsv</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">fin</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fin</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">yield</span> <span class="p">[</span><span class="n">normalize</span><span class="p">(</span><span class="s">'NFC'</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf8'</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">)]</span>
</pre></div>
<p>The new function is actually solving two issues:</p>
<ol class="arabic simple">
<li>It reads the file as a binary file, because IT IS a binary file where each record is
delimited by a line feed character and each field by a tab character.
Incidentally all of the fields are text fields.</li>
<li>It decodes all strings using the same canonical form.</li>
</ol>
<p>Number #2 was specific to my case.</p>
</div>
<div class="section" id="unknown-encodings-wrong-encodings-and-other-tips">
<h2>Unknown encodings, wrong encodings and other tips</h2>
<p>Python <tt class="docutils literal">encode</tt> and <tt class="docutils literal">decode</tt> raise errors when the passed encoding is not compatible
with the source string. You can pass a second argument to both of these methods to change
this behavior. This might be useful in some situations were you are handling mixed
encoding strings and output generated by a bugged software.</p>
<p>Another common task is to guess the character encoding used for a text file
(e.g. internet pages). <a class="reference external" href="https://github.com/chardet/chardet">chardet</a> is an excellent library that might help you. If your
problem is specific to web pages, <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a> is the library for you.</p>
<p>Be aware of Unicode also when you are writing regular expression. For instance if you
want to extract all the words in a text do not do this:</p>
<div class="highlight"><pre><span class="n">words</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'[a-zA-Z]+'</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">U</span><span class="p">)</span>
</pre></div>
<p>The right version is the following:</p>
<div class="highlight"><pre><span class="n">words</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'[^\W\d]+'</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">U</span><span class="p">)</span>
</pre></div>
<p>But probably you want to check the non standard <a class="reference external" href="https://pypi.python.org/pypi/regex">regex</a> module.
(Please check the <a class="reference external" href="http://bugs.python.org/issue12729">issue 12729</a>)</p>
<p>The shell <tt class="docutils literal">iconv</tt> command is useful to convert file encodings:</p>
<div class="highlight"><pre><span class="nv">$ </span>iconv -f latin1 -t utf-8 input.txt &gt; output.txt
</pre></div>
</div>
<div class="section" id="conclusions">
<h2>Conclusions</h2>
<p>Unicode can bring lots of confusion and subtle bugs. In order to avoid these are my
simple recommendations:</p>
<ul class="simple">
<li>Do not mix too many encodings, UTF-8 is fine for most cases, stuck with it.</li>
<li>Decode text data as soon as you read it, but not too early. (check the TSV story)</li>
<li>Normalize Unicode strings if you need it as soon as you can.</li>
<li>Never mix <tt class="docutils literal">str</tt> and <tt class="docutils literal">unicode</tt> types.</li>
<li>Use <tt class="docutils literal">print</tt> to write on files only if opened with the <tt class="docutils literal">codecs</tt> module, or streams
wrapped by the <tt class="docutils literal">codecs</tt> streams.</li>
</ul>
</div>
</div>
    </div></body></html>