<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/files/3cb/d7e/e7f/3cbd7ee7ff4740aba44853a852136391.jpg" alt="image"/>
<p>
Весной нам в голову пришла идея сделать </p><a href="http://bitcalm.com/">простой сервис для облачного бэкапа серверов</a><p>. Поскольку в то время работа над проектом велась преимущественно по вечерам и по выходным, для ускорения процесса было решено использовать только те технологии, в которых у нас есть опыт. Для backend-части был выбран Django, а реализация клиентской части предполагалась в виде </p><abbr title="Single Page Application">SPA </abbr><p> на базе AngularJS. Задумка была в следующем: сделать продукт с минимальным функционалом, а затем постепенно добавлять новые возможности. Для этого необходимо было сделать достаточно гибкую и масштабируемую систему. Немного пораскинув мозгами, мы приступили.
</p><a name="habracut"/>

<h2>Роутинги</h2><p>
И первый вопрос, который возник, был связан с роутингами в клиентской части. Нам была необходима надёжная и простая система, которая поддерживала бы вложенные друг в друга шаблоны и позволяла однозначно сопоставлять определённому URL необходимый шаблон. После недолгих поисков мы выбрали </p><a href="https://github.com/angular-ui/ui-router">ui-router</a><p>.
</p><p>
Была утверждена следующая схема:</p><p>
По пути </p><code>/</code><p> пользователю показывается лэндинг, который никак не связан с приложением. При переходе на </p><code>/app/</code><p> сервер отдаёт файл </p><code>app.html</code><p>, который содержит весь head, все скрипты в конце body и один единственный </p><code>div</code><p> со скромным атрибутом </p><code>ui-view</code><p>. Именно в этот </p><code>div</code><p> грузится всё приложение. В зависимости от того, залогинен пользователь или нет, ему показываются разные заполнения этого </p><code>div</code><p>’a.
</p><p>
Я не буду забегать вперёд, а рассмотрю случай для аутентифицированного пользователя. Итак, в этом случае, если в URL после </p><code>/app/</code><p> нет никакого хэша, то внутрь  грузится следуюший слой: </p><code>index.html</code><p>. Этот файл содержит в себе статическую часть приложения, которая окружает всю рабочую область: хэдер, футер и боковое меню. В </p><code>index.html</code><p> так же есть </p><code>div</code><p> с атрибутом </p><code>ui-view</code><p>, в который будет подгружаться ещё один уровень приложения, а конкретно — различные экраны (в нашем случае это: главный экран, детальный экран сервера, экран биллинга, экран восстановления бэкапа и другие).

</p><img src="https://habrastorage.org/files/077/429/99e/07742999e36140cd93c670e03dfdbefa.png" alt="image"/>
<p>
Рассмотрим, как же это всё описано с помощью ui-router:

</p><pre><code class="javascript">app.config(['$stateProvider', '$urlRouterProvider', function ($stateProvider, $urlRouterProvider) {

    $stateProvider
        .state('index', {
            url: '/',
            templateUrl: '/static/views/index.html'
        })
        .state('index.main', {
            url: '^/main',
            templateUrl: '/static/views/pages/main.html'
        })
        .state('index.client', {
            url: '^/main/c/:id',
            templateUrl: '/static/views/pages/client.html'
        })
        .state('index.billing', {
            url: '^/billing',
            templateUrl: '/static/views/pages/billing.html'
        })
        .state('index.restore', {
            url: '^/restore',
            templateUrl: '/static/views/pages/restore.html'
        });

    $urlRouterProvider.otherwise('/main');  // Если хэш не совпадает ни с одним, то редирект на страницу /main
    
}])
</code></pre>

<h2>Публичные и приватные страницы</h2><p>
Настало время задуматься над разграничением прав доступа пользователей к определённым страницам. Если пользователь не залогинен, то ему могут показываться только публичные страницы, а при попытке захода на приватную страницу его ждёт принудительный редирект на экран логина. Так же и в обратную сторону: если пользователь уже вошёл, то он не сможет увидеть страницы входа, регистрации и восстановления пароля.
</p><p>
Итак, добавим данные о публичных страницах в конфигурацию роутера:

</p><pre><code class="javascript">$stateProvider
    .state('login', {
        url: '/login',
        templateUrl: '/static/views/login.html'
    })
    .state('signup', {
        url: '/signup',
        templateUrl: '/static/views/signup.html'
    })
    .state('recovery', {
        url: '/recovery',
        templateUrl: '/static/views/recovery.html'
    });
</code></pre>
<p>
В модуле, отвечающем за авторизацию, создана фабрика, которая определяет залогинен ли пользователь:

</p><pre><code class="javascript">AuthModule.factory('Auth', ['$cookieStore', function ($cookieStore) {
    var currentUser = $cookieStore.get('login') || 0,
        publicStates = ['login', 'signup', 'recovery'];

    return {
        authorize: function(state) {
            return (this.isLoggedIn() &amp;&amp; (publicStates.indexOf(state) &lt; 0)) || (!this.isLoggedIn() &amp;&amp; (publicStates.indexOf(state) &gt;= 0))
        },
        isLoggedIn: function() {
            return !!currentUser;
        }
    }

}])
</code></pre>
<p>
Метод </p><code>isLoggedIn</code><p> возвращает </p><code>true</code><p>, если пользователь залогинен, либо </p><code>false</code><p> в противном случае. Метод </p><code>authorize</code><p> определяет для текущего состояния, имеет ли право пользователь в нём находиться. 
</p><p>
Использование этих методов осуществляется в обработчике события </p><code>$stateChangeStart</code><p>, которое возникает в момент начала изменения состояния:

</p><pre><code class="javascript">$rootScope.$on("$stateChangeStart", function (event, toState, toParams, fromState, fromParams) {
    // Если пользователь не имеет права находиться в данном состоянии
    if (!Auth.authorize(toState.name)) {
        // Необходимо для предотвращения дальнейшего изменения состояния
        event.preventDefault();
        // Для случая первичного определения пути (при заходе на /app/ без какого-либо хэша)        
        if (fromState.url === '^') {
            if (Auth.isLoggedIn()) {
                $state.go('index.main');
            } else {
                $state.go('auth');
            }
        }
    }
});
</code></pre>

<h2>Аутентификация</h2><p>
Процедура аутентификации на стороне клиента реализована с помощью функции в фабрике </p><code>Auth</code><p>:

</p><pre><code class="javascript">login: function (user, success, error) {
    $http.post('/login/', user)
        .success(function () {
            currentUser = 1;
            success();
        })
        .error(error);
}
</code></pre>
<p>
Вызов этой функции производится в контроллере. В качестве аргументов передаются </p><code>username</code><p>, </p><code>password </code><p> и коллбэки:

</p><pre><code class="javascript">Auth.login({
    username: $scope.login.username,
    password: $scope.login.password
},
function () {
    $state.go('index.main');
},
function () {
    $scope.login.error = true;
});
</code></pre>
<p>
На сервере с помощью стандартных django-сессий хранится информация о пользователе (его id). Для этого используются стандартные методы </p><code>django.contrib.auth</code><p>.

</p><pre><code class="django">from django.contrib.auth import authenticate, login

def login_service(request):
    data = json.loads(request.body)
    user = authenticate(username=data['username'], password=data['password'])
    if user is not None:
        login(request, user)
        return HttpResponse(status=200)
    else:
        return HttpResponse('Login error', status=401)
</code></pre>
<p>
Во время каждого http-запроса сервер проверяет, залогинен ли пользователь, и устанавливает в заголовок 'Set-Cookie' соответствующее значение. Это значение и проверяется в клиентской части с помощью </p><code>$cookieStore.get('login')</code><p>.

</p><h2>Связка между моделями сервера и клиента</h2><p>
С целью ускорения разработки и повышения гибкости приложения, было решено использовать middleware между Django и AngularJS. Выбор пал на </p><a href="https://github.com/jrief/django-angular">django-angular</a><p>.
</p><p>
Основные его преимущества:

</p><ul>
<li>предоставляет возможность выполнять основные <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> операции;</li>
<li>позволяет плотно связать django-формы и angular-контроллеры;</li>
<li>даёт функционал для вызова методов в django прямо из angular-контроллера.</li>
</ul>
<p>
Подробнее об установке и настройке можно прочитать в </p><a href="http://django-angular.readthedocs.org/en/latest/">документации</a><p>.

</p><h2>Итог</h2><p>
В итоге у нас получилось расширяемое и гибкое приложение, в котором модули минимально зависят друг от друга. Код всех модулей хранится в отдельных файлах, а добавление новых оставляет другие нетронутыми. Кроме того, функционал django-angular значительно ускоряет разработку.

</p><hr/><p>
Эта вторая статья из цикла про то, как мы делали сервис облачного резервного копирования серверов </p><a href="http://bitcalm.com/">bitcalm.com</a><p>.
</p><p>
Первая статья: </p><a href="http://habrahabr.ru/company/bitcalm/blog/234861/">Разработка своей системы биллинга на Django</a>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>