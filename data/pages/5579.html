<html><body><div><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-hask" class="anchor" href="#hask" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Hask</h1>

<p><a href="https://travis-ci.org/billpmurphy/hask"><img src="https://camo.githubusercontent.com/eab709540ee24836137875991cdbf31748e0924c/68747470733a2f2f7472617669732d63692e6f72672f62696c6c706d75727068792f6861736b2e737667" alt="Build Status" data-canonical-src="https://travis-ci.org/billpmurphy/hask.svg"/></a>
<a href="https://coveralls.io/github/billpmurphy/hask?branch=master"><img src="https://camo.githubusercontent.com/1d58bf54be210f3de18b4dfdcbfb66f67cc4d854/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f62696c6c706d75727068792f6861736b2f62616467652e7376673f6272616e63683d6d617374657226736572766963653d676974687562" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/billpmurphy/hask/badge.svg?branch=master&amp;service=github"/></a></p>

<p>Hask is a pure-Python, zero-dependencies library that mimics most of the core
language tools from Haskell, including:</p>

<ul>
<li>Full Hindley-Milner type system (with typeclasses) that will typecheck any
function decorated with a Hask type signature</li>
<li>Easy creation of new algebraic data types and new typeclasses, with
Haskell-like syntax</li>
<li>Pattern matching with <code>case</code> expressions</li>
<li>Automagical function currying/partial application and function composition</li>
<li>Efficient, immutable, lazily evaluated <code>List</code> type with Haskell-style list
comprehensions</li>
<li>All your favorite syntax and control flow tools, including operator sections,
monadic error handling, guards, and more</li>
<li>Python port of (some of) the standard libraries from Haskell's <code>base</code>,
including:

<ul>
<li>Algebraic datatypes from the Haskell <code>Prelude</code>, including <code>Maybe</code> and
<code>Either</code></li>
<li>Typeclasses from the Haskell <code>base</code> libraries, including <code>Functor</code>,
<code>Applicative</code>, <code>Monad</code>, <code>Enum</code>, <code>Num</code>, and all the rest</li>
<li>Standard library functions from <code>base</code>, including all functions from
<code>Prelude</code>, <code>Data.List</code>, <code>Data.Maybe</code>, and more</li>
</ul></li>
</ul>

<p>Features not yet implemented, but coming soon:</p>

<ul>
<li>Python 3 compatibility</li>
<li>Better support for polymorphic return values/type defaulting</li>
<li>Better support for lazy evaluation (beyond just the <code>List</code> type and pattern matching)</li>
<li>More of the Haskell standard library (<code>Control.*</code> libraries, QuickCheck, and more)</li>
<li>Monadic, lazy I/O</li>
</ul>

<p><strong>Note that all of this is still very much pre-alpha, and some things may be buggy!</strong></p>

<h2><a id="user-content-installation" class="anchor" href="#installation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Installation</h2>

<p>1) <code>git clone https://github.com/billpmurphy/hask</code></p>

<p>2) <code>python setup.py install</code></p>

<p>To run the tests: <code>python tests.py</code>.</p>

<h2><a id="user-content-why-did-you-make-this" class="anchor" href="#why-did-you-make-this" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Why did you make this?</h2>

<p>I wanted to cram as much of Haskell into Python as possible while still being
100% compatible with the rest of Python, just to see if any useful ideas came
out of the result. Also, it was fun!</p>

<p>Contributions, forks, and extensions to this experiment are always welcome!
Feel free to submit a pull request, open an issue, or email me. In the spirit
of this project, abusing the Python language as much as possible is encouraged.</p>

<h2><a id="user-content-features" class="anchor" href="#features" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Features</h2>

<p>Hask is a grab-bag of features that add up to one big pseudo-Haskell functional
programming library. The rest of this README lays out the basics.</p>

<p>I recommend playing around in the REPL while going through the examples. You</p>

<p>To import all the language features: <code>from hask import *</code>
To import the Prelude: <code>from hask import Prelude</code>
To import a <code>base</code> library, e.g. <code>Data.List</code>: <code>from hask import Data.List</code></p>

<h3><a id="user-content-the-list-type-and-list-comprehensions" class="anchor" href="#the-list-type-and-list-comprehensions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>The List type and list comprehensions</h3>

<p>Hask provides the <code>List</code> type, a lazy and statically-typed list, similar to
Haskell's standard list type.</p>

<p>To create a new <code>List</code>, just put the elements inside <code>L[</code> and <code>]</code> brackets, or
wrap an existing iterable inside <code>L[ ]</code>.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>]
<span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>]

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> my_list <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>]
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">L</span>[my_list]
<span class="pl-c1">L</span>[<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>]

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">L</span>[(x<span class="pl-k">**</span><span class="pl-c1">2</span> <span class="pl-k">for</span> x <span class="pl-k">in</span> <span class="pl-c1">range</span>(<span class="pl-c1">1</span>, <span class="pl-c1">11</span>))]
<span class="pl-c1">L</span>[<span class="pl-c1">1</span> <span class="pl-c1">...</span> ]</pre></div>

<p>To add elements to the front of a List, use <code>^</code>, the cons operator.  To combine
two lists, use <code>+</code>, the concatenation operator.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">1</span> <span class="pl-k">^</span> <span class="pl-c1">L</span>[<span class="pl-c1">2</span>, <span class="pl-c1">3</span>]
<span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>]

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>goodnight<span class="pl-pds">"</span></span> <span class="pl-k">^</span> (<span class="pl-s"><span class="pl-pds">"</span>sweet<span class="pl-pds">"</span></span> <span class="pl-k">^</span> (<span class="pl-s"><span class="pl-pds">"</span>prince<span class="pl-pds">"</span></span> <span class="pl-k">^</span> <span class="pl-c1">L</span>[[]]))
<span class="pl-c1">L</span>[<span class="pl-s"><span class="pl-pds">"</span>goodnight<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>sweet<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>prince<span class="pl-pds">"</span></span>]

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">^</span> <span class="pl-c1">L</span>[<span class="pl-c1">1.0</span>, <span class="pl-c1">10.3</span>]  <span class="pl-c"># type error</span>

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] <span class="pl-k">+</span> <span class="pl-c1">L</span>[<span class="pl-c1">3</span>, <span class="pl-c1">4</span>]
<span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>]</pre></div>

<p>Lists are always evaluated lazily, and will only evaluate list elements as
needed, so you can use infinite Lists or put never-ending generators inside of
a <code>List</code>. (Of course, you can still blow up the interpreter if you try to
evaluate the entirety of an infinite List, e.g. by trying to find the length of
the List with <code>len</code>.)</p>

<p>One way to create infinite lists is via list comprehensions. As in Haskell,
there are four basic type of list comprehensions:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-c"># list from 1 to infinity, counting by ones</span>
<span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">...</span>]

<span class="pl-c"># list from 1 to infinity, counting by twos</span>
<span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">...</span>]

<span class="pl-c"># list from 1 to 20 (inclusive), counting by ones</span>
<span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">...</span>, <span class="pl-c1">20</span>]

<span class="pl-c"># list from 1 to 20 (inclusive), counting by fours</span>
<span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">5</span>, <span class="pl-c1">...</span>, <span class="pl-c1">20</span>]</pre></div>

<p>List comprehensions can be used on ints, longs, floats, one-character strings,
or any other instance of the <code>Enum</code> typeclass (more on this later).</p>

<p>Hask provides all of the Haskell functions for List manipulation (<code>take</code>,
<code>drop</code>, <code>takeWhile</code>, etc.), or you can also use Python-style indexing.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">...</span>]
<span class="pl-c1">L</span>[<span class="pl-c1">1</span> <span class="pl-c1">...</span>]


<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask.Data.List <span class="pl-k">import</span> take
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> take(<span class="pl-c1">5</span>, <span class="pl-c1">L</span>[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>, <span class="pl-c1">...</span>])
<span class="pl-c1">L</span>[<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span>]


<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">L</span>[<span class="pl-c1">1</span>,<span class="pl-c1">...</span>][<span class="pl-c1">5</span>:<span class="pl-c1">10</span>]
<span class="pl-c1">L</span>[<span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>]


<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask.Data.List <span class="pl-k">import</span> <span class="pl-c1">map</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask.Data.Char <span class="pl-k">import</span> <span class="pl-c1">chr</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> letters <span class="pl-k">=</span> <span class="pl-c1">map</span>(<span class="pl-c1">chr</span>, <span class="pl-c1">L</span>[<span class="pl-c1">97</span>, <span class="pl-c1">...</span>])
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> letters[:<span class="pl-c1">9</span>]
<span class="pl-c1">L</span>[<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>f<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>g<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>h<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>i<span class="pl-pds">'</span></span>]


<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">len</span>(<span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">...</span>])  <span class="pl-c"># uh oh</span></pre></div>

<p>Otherwise, you can use <code>List</code> just like you would use a regular Python list.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">L</span>[<span class="pl-c1">0</span>, <span class="pl-c1">...</span>]:
    <span class="pl-c1">print</span> i


<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">55</span> <span class="pl-k">in</span> <span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">...</span>]
<span class="pl-c1">True</span></pre></div>

<h3><a id="user-content-algebraic-data-types" class="anchor" href="#algebraic-data-types" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Algebraic Data Types</h3>

<p>Hask allows you to define <a href="https://wiki.haskell.org/Algebraic_data_type">algebraic
datatypes</a>, which are immutable
objects with a fixed number of typed, unnamed fields.</p>

<p>Here is the definition for the infamous <code>Maybe</code> type:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> hask <span class="pl-k">import</span> data, d, deriving
<span class="pl-k">from</span> hask <span class="pl-k">import</span> Read, Show, Eq, Ord

Maybe, Nothing, Just <span class="pl-k">=</span>\
    data.Maybe(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>) <span class="pl-k">==</span> d.Nothing <span class="pl-k">|</span> d.Just(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>) <span class="pl-k">&amp;</span> deriving(Read, Show, Eq, Ord)</pre></div>

<p>Let's break this down a bit. The syntax for defining a new <a href="https://wiki.haskell.org/Constructor#Type_constructor">type
constructor</a> is:</p>

<div class="highlight highlight-source-python"><pre>data.TypeName(<span class="pl-s"><span class="pl-pds">"</span>type param<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>type param 2<span class="pl-pds">"</span></span> <span class="pl-c1">...</span> <span class="pl-s"><span class="pl-pds">"</span>type param n<span class="pl-pds">"</span></span>)</pre></div>

<p>This defines a new algebraic datatype with type parameters.</p>

<p>To define <a href="https://wiki.haskell.org/Constructor#Data_constructor">data
constructors</a> for this
type, use <code>d.</code> The name of the data constructor goes first, followed by its
fields. Multiple data constructors should be separted by <code>|</code>. If your data
constructor has no fields, you can omit the parens. For example:</p>

<div class="highlight highlight-source-python"><pre>FooBar, Foo, Bar <span class="pl-k">=</span>\
    data.FooBar(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>) <span class="pl-k">==</span> d.Foo(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>, <span class="pl-c1">str</span>) <span class="pl-k">|</span> d.Bar</pre></div>

<p>To automagically derive typeclass instances for the type, add <code>&amp;
deriving(...typeclasses...)</code> after the data constructor declarations.
Currently, the only typeclasses that can be derived are <code>Eq</code>, <code>Show</code>, <code>Read</code>,
<code>Ord</code>, and <code>Bounded</code>.</p>

<p>Putting it all together, here are the definitions of <code>Either</code> and <code>Ordering</code>:</p>

<div class="highlight highlight-source-python"><pre>Either, Left, Right <span class="pl-k">=</span>\
    data.Either(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>) <span class="pl-k">==</span> d.Left(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>) <span class="pl-k">|</span> d.Right(<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>) <span class="pl-k">&amp;</span> deriving(Read, Show, Eq)


Ordering, <span class="pl-c1">LT</span>, <span class="pl-c1">EQ</span>, <span class="pl-c1">GT</span> <span class="pl-k">=</span>\
    data.Ordering <span class="pl-k">==</span> d.<span class="pl-c1">LT</span> <span class="pl-k">|</span> d.<span class="pl-c1">EQ</span> <span class="pl-k">|</span> d.<span class="pl-c1">GT</span> <span class="pl-k">&amp;</span> deriving(Read, Show, Eq, Ord, Bounded)</pre></div>

<p>You can now use the data constructors defined in a <code>data</code> statement to create
instances of these new types. If the data constructor takes no arguments, you
can use it just like a variable.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> Just(<span class="pl-c1">10</span>)
Just(<span class="pl-c1">10</span>)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> Nothing
Nothing

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> Just(Just(<span class="pl-c1">10</span>))
Just(Just(<span class="pl-c1">10</span>))

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> Left(<span class="pl-c1">1</span>)
Left(<span class="pl-c1">1</span>)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> Foo(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>)
Foo(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-s"><span class="pl-pds">'</span>hello<span class="pl-pds">'</span></span>)</pre></div>

<p>You can view the type of an object with <code>_t</code> (equivalent to <code>:t</code> in ghci).</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask <span class="pl-k">import</span> _t

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> _t(<span class="pl-c1">1</span>)
<span class="pl-c1">int</span>

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> _t(Just(<span class="pl-s"><span class="pl-pds">"</span>soylent green<span class="pl-pds">"</span></span>))
(Maybe <span class="pl-c1">str</span>)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> _t(Right((<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>)))
(Either a (<span class="pl-c1">str</span>, <span class="pl-c1">int</span>))

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> _t(Just)
(a <span class="pl-ii">-&gt;</span> Maybe a)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> _t(<span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>])
[<span class="pl-c1">int</span>]</pre></div>

<h3><a id="user-content-the-type-system-and-typed-functions" class="anchor" href="#the-type-system-and-typed-functions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>The type system and typed functions</h3>

<p>So what's up with those types? Hask operates its own shadow <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner
type system</a>
on top of Python's type system; <code>_t</code> shows the Hask type of a particular
object.</p>

<p>In Hask, typed functions take the form of <code>TypedFunc</code> objects, which are typed
wrappers around Python functions. There are two ways to create <code>TypedFunc</code>
objects:</p>

<p>1) Use the <code>sig</code> decorator to decorate the function with the type signature</p>

<div class="highlight highlight-source-python"><pre><span class="pl-en">@sig</span>(<span class="pl-c1">H</span><span class="pl-k">/</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)
<span class="pl-k">def</span> <span class="pl-en">const</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>):
    <span class="pl-k">return</span> x</pre></div>

<p>2) Use the <code>**</code> operator (similar to <code>::</code> in Haskell) to provide the type.
Useful for turning functions or lambdas into <code>TypedFunc</code> objects in the REPL,
or wrapping already-defined Python functions.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">const</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>):
    <span class="pl-k">return</span> x

const <span class="pl-k">=</span> const <span class="pl-k">**</span> (<span class="pl-c1">H</span><span class="pl-k">/</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)</pre></div>

<p><code>TypedFunc</code> objects have several special properties.  First, they are type
checked--when arguments are supplied, the type inference engine will check
whether their types match the type signature, and raise a <code>TypeError</code> if there
is a discrepancy.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> f <span class="pl-k">=</span> (<span class="pl-k">lambda</span> <span class="pl-smi">x</span>, <span class="pl-smi">y</span>: x <span class="pl-k">+</span> y) <span class="pl-k">**</span> (<span class="pl-c1">H</span><span class="pl-k">/</span> <span class="pl-c1">int</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">int</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">int</span>)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> f(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>)
<span class="pl-c1">5</span>

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> f(<span class="pl-c1">9</span>, <span class="pl-c1">1.0</span>)  <span class="pl-c"># type error</span></pre></div>

<p>Second, <code>TypedFunc</code> objects can be <a href="https://wiki.haskell.org/Partial_application">partially
applied</a>:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> g <span class="pl-k">=</span> (<span class="pl-k">lambda</span> <span class="pl-smi">a</span>, <span class="pl-smi">b</span>, <span class="pl-smi">c</span>: a <span class="pl-k">/</span> (b <span class="pl-k">+</span> c)) <span class="pl-k">**</span> (<span class="pl-c1">H</span><span class="pl-k">/</span> <span class="pl-c1">int</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">int</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">int</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">int</span>)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> g(<span class="pl-c1">10</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)
<span class="pl-c1">2</span>

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> part_g <span class="pl-k">=</span> g(<span class="pl-c1">12</span>)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> part_g(<span class="pl-c1">2</span>, <span class="pl-c1">2</span>)
<span class="pl-c1">3</span>

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> g(<span class="pl-c1">20</span>, <span class="pl-c1">1</span>)(<span class="pl-c1">4</span>)
<span class="pl-c1">4</span></pre></div>

<p><code>TypedFunc</code> objects also have two special infix operators, the <code>*</code> and <code>%</code>
operators. <code>*</code> is the compose operator (equivalent to <code>(.)</code> in Haskell), so
<code>f * g</code> is equivalent to <code>lambda x: f(g(x))</code>. <code>%</code> is just the apply operator,
which applies a <code>TypedFunc</code> to one argument (equivalent to <code>($)</code> in Haskell).
The convinience of this notation (when combined with partial application)
cannot be overstated--you can get rid of a ton of nested parenthesis this way.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask.Prelude <span class="pl-k">import</span> flip
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> h <span class="pl-k">=</span> (<span class="pl-k">lambda</span> <span class="pl-smi">x</span>, <span class="pl-smi">y</span>: x <span class="pl-k">/</span> y) <span class="pl-k">**</span> (<span class="pl-c1">H</span><span class="pl-k">/</span> <span class="pl-c1">float</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">float</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">float</span>)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> h(<span class="pl-c1">3.0</span>) <span class="pl-k">*</span> h(<span class="pl-c1">6.0</span>) <span class="pl-k">*</span> flip(h, <span class="pl-c1">2.0</span>) <span class="pl-k">%</span> <span class="pl-c1">36.0</span>
<span class="pl-c1">9.0</span></pre></div>

<p>The compose operation is also typed-checked, which makes it appealing to write
programs in <a href="https://wiki.haskell.org/Pointfree">pointfree style</a>, i.e,
chaining together lots of functions with composition and relying on the type
system to catch programming errors.</p>

<p>As you would expect, data constructors are also just <code>TypedFunc</code> objects:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> Just <span class="pl-k">*</span> Just <span class="pl-k">*</span> Just <span class="pl-k">*</span> Just <span class="pl-k">%</span> <span class="pl-c1">77</span>
Just(Just(Just(Just(<span class="pl-c1">77</span>))))</pre></div>

<p>The type signature syntax is very simple, and consists of a few basic
primitives that can be combined to build any type signature:</p>

<table><thead>
<tr>
<th>Primitive</th>
<th>Syntax/examples</th>
</tr>
</thead><tbody>
<tr>
<td>Type literal for Python builtin type or user-defined class</td>
<td><code>int</code>, <code>float</code>, <code>set</code>, <code>list</code></td>
</tr>
<tr>
<td>Type variable</td>
<td><code>"a"</code>, <code>"b"</code>, <code>"zz"</code></td>
</tr>
<tr>
<td><code>List</code> of some type</td>
<td><code>[int]</code>, <code>["a"]</code>, <code>[["a"]]</code></td>
</tr>
<tr>
<td>Tuple type</td>
<td><code>(int, int)</code>, <code>("a", "b", "c")</code>, <code>(int, ("a", "b"))</code></td>
</tr>
<tr>
<td>ADT with type parameters</td>
<td><code>t(Maybe, "a")</code>, <code>t(Either, "a", str)</code></td>
</tr>
<tr>
<td>Unit type (<code>None</code>)</td>
<td><code>None</code></td>
</tr>
<tr>
<td>Untyped Python function</td>
<td><code>func</code></td>
</tr>
<tr>
<td>Typeclass constraint</td>
<td><code>H[(Eq, "a"), (Show, "b")]/</code>, <code>H[(Functor, "f"), (Show, "f")]/</code></td>
</tr>
</tbody></table>

<p>Some examples:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-c"># add two ints together</span>
<span class="pl-en">@sig</span>(<span class="pl-c1">H</span><span class="pl-k">/</span> <span class="pl-c1">int</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">int</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">int</span>)
<span class="pl-k">def</span> <span class="pl-en">add</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>):
    <span class="pl-k">return</span> x <span class="pl-k">+</span> y


<span class="pl-c"># reverse order of arguments to a function</span>
<span class="pl-en">@sig</span>(<span class="pl-c1">H</span><span class="pl-k">/</span> (<span class="pl-c1">H</span><span class="pl-k">/</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>) <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>)
<span class="pl-k">def</span> <span class="pl-en">flip</span>(<span class="pl-smi">f</span>, <span class="pl-smi">b</span>, <span class="pl-smi">a</span>):
    <span class="pl-k">return</span> f(a, b)


<span class="pl-c"># map a Python (untyped) function over a Python (untyped) set</span>
<span class="pl-en">@sig</span>(<span class="pl-c1">H</span><span class="pl-k">/</span> func <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">set</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">set</span>)
<span class="pl-k">def</span> <span class="pl-en">set_map</span>(<span class="pl-smi">fn</span>, <span class="pl-smi">lst</span>):
    <span class="pl-k">return</span> <span class="pl-c1">set</span>((fn(x) <span class="pl-k">for</span> x <span class="pl-k">in</span> lst))


<span class="pl-c"># map a typed function over a List</span>
<span class="pl-en">@sig</span>(<span class="pl-c1">H</span><span class="pl-k">/</span> (<span class="pl-c1">H</span><span class="pl-k">/</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>) <span class="pl-k">&gt;&gt;</span> [<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>] <span class="pl-k">&gt;&gt;</span> [<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>])
<span class="pl-k">def</span> <span class="pl-c1">map</span>(<span class="pl-smi">f</span>, <span class="pl-smi">xs</span>):
    <span class="pl-k">return</span> <span class="pl-c1">L</span>[(f(x) <span class="pl-k">for</span> x <span class="pl-k">in</span> xs)]


<span class="pl-c"># type signature with an Eq constraint</span>
<span class="pl-en">@sig</span>(<span class="pl-c1">H</span>[(Eq, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)]<span class="pl-k">/</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">&gt;&gt;</span> [<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>] <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">bool</span>)
<span class="pl-k">def</span> <span class="pl-en">not_in</span>(<span class="pl-smi">y</span>, <span class="pl-smi">xs</span>):
    <span class="pl-k">return</span> <span class="pl-k">not</span> <span class="pl-c1">any</span>((x <span class="pl-k">==</span> y <span class="pl-k">for</span> x <span class="pl-k">in</span> xs))


<span class="pl-c"># type signature with a type constructor (Maybe) that has type arguments</span>
<span class="pl-en">@sig</span>(<span class="pl-c1">H</span><span class="pl-k">/</span> <span class="pl-c1">int</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">int</span> <span class="pl-k">&gt;&gt;</span> t(Maybe, <span class="pl-c1">int</span>))
<span class="pl-k">def</span> <span class="pl-en">safe_div</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>):
    <span class="pl-k">return</span> Nothing <span class="pl-k">if</span> y <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">else</span> Just(x<span class="pl-k">/</span>y)


<span class="pl-c"># type signature for a function that returns nothing</span>
<span class="pl-en">@sig</span>(<span class="pl-c1">H</span><span class="pl-k">/</span> <span class="pl-c1">int</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">None</span>)
<span class="pl-k">def</span> <span class="pl-en">launch_missiles</span>(<span class="pl-smi">num_missiles</span>):
    <span class="pl-c1">print</span> <span class="pl-s"><span class="pl-pds">"</span>Launching <span class="pl-c1">{0}</span> missiles! Bombs away!<span class="pl-pds">"</span></span> <span class="pl-k">%</span> num_missiles</pre></div>

<p>It is also possible to create type synonyms using <code>t</code>. For example, check out the definition of <code>Rational</code>:</p>

<div class="highlight highlight-source-python"><pre>Ratio, <span class="pl-c1">R</span> <span class="pl-k">=</span>\
        data.Ratio(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>) <span class="pl-k">==</span> d.R(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>) <span class="pl-k">&amp;</span> deriving(Eq)


Rational <span class="pl-k">=</span> t(Ratio, <span class="pl-c1">int</span>)


<span class="pl-en">@sig</span>(<span class="pl-c1">H</span><span class="pl-k">/</span> Rational <span class="pl-k">&gt;&gt;</span> Rational <span class="pl-k">&gt;&gt;</span> Rational)
<span class="pl-k">def</span> <span class="pl-en">addRational</span>(<span class="pl-smi">rat1</span>, <span class="pl-smi">rat2</span>):
    <span class="pl-c1">...</span></pre></div>

<h3><a id="user-content-pattern-matching" class="anchor" href="#pattern-matching" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Pattern matching</h3>

<p>Pattern matching is a more powerful control flow tool than the <code>if</code> statement,
and can be used to deconstruct iterables and ADTs and bind values to local
variables.</p>

<p>Pattern matching expressions follow this syntax:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">~</span>(caseof(value_to_match)
    <span class="pl-k">|</span> m(pattern_1) <span class="pl-k">&gt;&gt;</span> return_value_1
    <span class="pl-k">|</span> m(pattern_2) <span class="pl-k">&gt;&gt;</span> return_value_2
    <span class="pl-k">|</span> m(pattern_3) <span class="pl-k">&gt;&gt;</span> return_value_3)</pre></div>

<p>Here is a function that uses pattern matching to compute the fibonacci
sequence. Note that within a pattern match expression, <code>m.*</code> is used to bind
variables, and <code>p.*</code> is used to access them.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">fib</span>(<span class="pl-smi">x</span>):
    <span class="pl-k">return</span> <span class="pl-k">~</span>(caseof(x)
                <span class="pl-k">|</span> m(<span class="pl-c1">0</span>)   <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">1</span>
                <span class="pl-k">|</span> m(<span class="pl-c1">1</span>)   <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">1</span>
                <span class="pl-k">|</span> m(m.n) <span class="pl-k">&gt;&gt;</span> fib(p.n <span class="pl-k">-</span> <span class="pl-c1">1</span>) <span class="pl-k">+</span> fib(p.n <span class="pl-k">-</span> <span class="pl-c1">2</span>))

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> fib(<span class="pl-c1">1</span>)
<span class="pl-c1">1</span>

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> fib(<span class="pl-c1">6</span>)
<span class="pl-c1">13</span></pre></div>

<p>As the above example shows, you can combine pattern matching and recursive
functions without a hitch.</p>

<p>You can also deconstruct an iterable using <code>^</code> (the cons operator). The variable
before the <code>^</code> is bound to the first element of the iterable, and the variable
after the <code>^</code> is bound to the rest of the iterable. Here is a function that
adds the first two elements of any iterable, returning <code>Nothing</code> if there are
less than two elements:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-en">@sig</span>(<span class="pl-c1">H</span>[(Num, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)]<span class="pl-k">/</span> [<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>] <span class="pl-k">&gt;&gt;</span> t(Maybe, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>))
<span class="pl-k">def</span> <span class="pl-en">add_first_two</span>(<span class="pl-smi">xs</span>):
    <span class="pl-k">return</span> <span class="pl-k">~</span>(caseof(xs)
                <span class="pl-k">|</span> m(m.x <span class="pl-k">^</span> (m.y <span class="pl-k">^</span> m.z)) <span class="pl-k">&gt;&gt;</span> Just(p.x <span class="pl-k">+</span> p.y)
                <span class="pl-k">|</span> m(m.x)               <span class="pl-k">&gt;&gt;</span> Nothing)


<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> add_first_two(<span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>])
Just(<span class="pl-c1">3</span>)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> add_first_two(<span class="pl-c1">L</span>[<span class="pl-c1">9.0</span>])
Nothing</pre></div>

<p>Pattern matching is also very useful for deconstructing ADTs and assigning
their fields to temporary variables.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">default_to_zero</span>(<span class="pl-smi">x</span>):
    <span class="pl-k">return</span> <span class="pl-k">~</span>(caseof(x)
                <span class="pl-k">|</span> m(Just(m.x)) <span class="pl-k">&gt;&gt;</span> p.x
                <span class="pl-k">|</span> m(Nothing)   <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">0</span>)


<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> default_to_zero(Just(<span class="pl-c1">27</span>))
<span class="pl-c1">27</span>


<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> default_to_zero(Nothing)
<span class="pl-c1">0</span></pre></div>

<p>If you find pattern matching on ADTs too cumbersome, you can also use numeric
indexing on ADT fields. An <code>IndexError</code> will be thrown if you mess something
up.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> Just(<span class="pl-c1">20.0</span>)[<span class="pl-c1">0</span>]
<span class="pl-c1">20.0</span>

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> Left(<span class="pl-s"><span class="pl-pds">"</span>words words words words<span class="pl-pds">"</span></span>)[<span class="pl-c1">0</span>]
<span class="pl-s"><span class="pl-pds">'</span>words words words words<span class="pl-pds">'</span></span>

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> Nothing[<span class="pl-c1">0</span>]  <span class="pl-c"># IndexError</span></pre></div>

<h3><a id="user-content-typeclasses-and-typeclass-instances" class="anchor" href="#typeclasses-and-typeclass-instances" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Typeclasses and typeclass instances</h3>

<p><a href="https://en.wikipedia.org/wiki/Type_class">Typeclasses</a> allow you to add
additional functionality to your ADTs. Hask implements all of the major
typeclasses from Haskell (see the Appendix for a full list) and provides syntax
for creating new typeclass instances.</p>

<p>As an example, let's add a <a href="https://wiki.haskell.org/Monad"><code>Monad</code></a> instance
for the <code>Maybe</code> type.  First, however, <code>Maybe</code> needs
<a href="https://wiki.haskell.org/Functor"><code>Functor</code></a> and
<a href="https://wiki.haskell.org/Applicative_functor"><code>Applicative</code></a> instances.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">maybe_fmap</span>(<span class="pl-smi">fn</span>, <span class="pl-smi">x</span>):
    <span class="pl-s"><span class="pl-pds">"""</span>Apply a function to the value inside of a (Maybe a) value<span class="pl-pds">"""</span></span>
    <span class="pl-k">return</span> <span class="pl-k">~</span>(caseof(x)
                <span class="pl-k">|</span> m(Nothing)   <span class="pl-k">&gt;&gt;</span> Nothing
                <span class="pl-k">|</span> m(Just(m.x)) <span class="pl-k">&gt;&gt;</span> Just(fn(p.x)))


instance(Functor, Maybe).where(
    <span class="pl-v">fmap</span> <span class="pl-k">=</span> maybe_fmap
)</pre></div>

<p><code>Maybe</code> is now an instance of <code>Functor</code>. This allows us to call <code>fmap</code>
and map any function of type <code>a -&gt; b</code> into a value of type <code>Maybe a</code>.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> times2 <span class="pl-k">=</span> (<span class="pl-k">lambda</span> <span class="pl-smi">x</span>: x <span class="pl-k">*</span> <span class="pl-c1">2</span>) <span class="pl-k">**</span> (<span class="pl-c1">H</span><span class="pl-k">/</span> <span class="pl-c1">int</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">int</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> toFloat <span class="pl-k">=</span> <span class="pl-c1">float</span> <span class="pl-k">**</span> (<span class="pl-c1">H</span><span class="pl-k">/</span> <span class="pl-c1">int</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">float</span>)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> fmap(toFloat, Just(<span class="pl-c1">10</span>))
Just(<span class="pl-c1">10.0</span>)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> fmap(toFloat, fmap(times2, Just(<span class="pl-c1">25</span>)))
Just(<span class="pl-c1">50.0</span>)</pre></div>

<p>Lots of nested calls to <code>fmap</code> get unwieldy very fast. Fortunately, any
instance of <code>Functor</code> can be used with the infix <code>fmap</code> operator, <code>*</code>. This is
equivalent to <code>&lt;$&gt;</code> in Haskell. Rewriting our example from above:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> (toFloat <span class="pl-k">*</span> times2) <span class="pl-k">*</span> Just(<span class="pl-c1">25</span>)
Just(<span class="pl-c1">50.0</span>)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> (toFloat <span class="pl-k">*</span> times2) <span class="pl-k">*</span> Nothing
Nothing</pre></div>

<p>Note that this example uses <code>*</code> as both the function compose operator and as
<code>fmap</code>, to lift functions into a <code>Maybe</code> value. If this seems confusing,
remember that <code>fmap</code> for functions is just function composition!</p>

<p>Now that <code>Maybe</code> is an instance of <code>Functor</code>, we can make it an instance of
<code>Applicative</code> and then an instance of <code>Monad</code> by defining the appropriate
function implementations. To implement <code>Applicative</code>, we just need to provide
<code>pure</code>. To implement <code>Monad</code>, we need to provide <code>bind</code>.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> hask <span class="pl-k">import</span> Applicative, Monad

instance(Applicative, Maybe).where(
    <span class="pl-v">pure</span> <span class="pl-k">=</span> Just
)

instance(Monad, Maybe).where(
    <span class="pl-v">bind</span> <span class="pl-k">=</span> <span class="pl-k">lambda</span> <span class="pl-smi">x</span>, <span class="pl-smi">f</span>: <span class="pl-k">~</span>(caseof(x)
                            <span class="pl-k">|</span> m(Just(m.a)) <span class="pl-k">&gt;&gt;</span> f(p.a)
                            <span class="pl-k">|</span> m(Nothing)   <span class="pl-k">&gt;&gt;</span> Nothing)
)</pre></div>

<p>The <code>bind</code> function also has an infix form, which is <code>&gt;&gt;</code> in Hask.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-en">@sig</span>(<span class="pl-c1">H</span><span class="pl-k">/</span> <span class="pl-c1">int</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">int</span> <span class="pl-k">&gt;&gt;</span> t(Maybe, <span class="pl-c1">int</span>))
<span class="pl-k">def</span> <span class="pl-en">safe_div</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>):
    <span class="pl-k">return</span> Nothing <span class="pl-k">if</span> y <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">else</span> Just(x<span class="pl-k">/</span>y)


<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask.Prelude <span class="pl-k">import</span> flip
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> divBy <span class="pl-k">=</span> flip(safe_div)


<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> Just(<span class="pl-c1">9</span>) <span class="pl-k">&gt;&gt;</span> divBy(<span class="pl-c1">3</span>)
Just(<span class="pl-c1">3</span>)


<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> Just(<span class="pl-c1">12</span>) <span class="pl-k">&gt;&gt;</span> divBy(<span class="pl-c1">2</span>) <span class="pl-k">&gt;&gt;</span> divBy(<span class="pl-c1">2</span>) <span class="pl-k">&gt;&gt;</span> divBy(<span class="pl-c1">3</span>)
Just(<span class="pl-c1">1</span>)


<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> Just(<span class="pl-c1">12</span>) <span class="pl-k">&gt;&gt;</span> divBy(<span class="pl-c1">0</span>) <span class="pl-k">&gt;&gt;</span> divBy(<span class="pl-c1">6</span>)
Nothing</pre></div>

<p>As in Haskell, <code>List</code> is also a monad, and <code>bind</code> for the <code>List</code> type is just
<code>concatMap</code>.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask.Data.List <span class="pl-k">import</span> replicate
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] <span class="pl-k">&gt;&gt;</span> replicate(<span class="pl-c1">2</span>) <span class="pl-k">&gt;&gt;</span> replicate(<span class="pl-c1">2</span>)
<span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>]</pre></div>

<p>You can also define typeclass instances for classes that are not ADTs:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-c1">object</span>):
    <span class="pl-k">def</span> <span class="pl-c1">__init__</span>(<span class="pl-smi"><span class="pl-smi">self</span></span>, <span class="pl-smi">name</span>, <span class="pl-smi">age</span>):
        <span class="pl-v">self</span>.name <span class="pl-k">=</span> name
        <span class="pl-v">self</span>.age <span class="pl-k">=</span> age


instance(Eq, Person).where(
    <span class="pl-v">eq</span> <span class="pl-k">=</span> <span class="pl-k">lambda</span> <span class="pl-smi">p1</span>, <span class="pl-smi">p2</span>: p1.name <span class="pl-k">==</span> p2.name <span class="pl-k">and</span> p1.age <span class="pl-k">==</span> p2.age
)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> Person(<span class="pl-s"><span class="pl-pds">"</span>Philip Wadler<span class="pl-pds">"</span></span>, <span class="pl-c1">59</span>) <span class="pl-k">==</span> Person(<span class="pl-s"><span class="pl-pds">"</span>Simon Peyton Jones<span class="pl-pds">"</span></span>, <span class="pl-c1">57</span>)
<span class="pl-c1">False</span></pre></div>

<p>If you want instances of the <code>Show</code>, <code>Eq</code>, <code>Read</code>, <code>Ord</code>, and <code>Bounded</code>
typeclasses for your ADTs, it is adviseable to use <code>deriving</code> to automagically
generate instances rather than defining them manually.</p>

<p>Defining your own typeclasses is pretty easy--take a look at <code>help(Typeclass)</code>
and look at the typeclasses defined in <code>Data.Functor</code> and <code>Data.Num</code> to
see how it's done.</p>

<h3><a id="user-content-operator-sections" class="anchor" href="#operator-sections" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Operator sections</h3>

<p>Hask also supports operator sections (e.g. <code>(1+)</code> in Haskell). Sections are
just <code>TypedFunc</code> objects, so they are automagically curried and typechecked.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask <span class="pl-k">import</span> __

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> f <span class="pl-k">=</span> (__ <span class="pl-k">-</span> <span class="pl-c1">20</span>) <span class="pl-k">*</span> (<span class="pl-c1">2</span> <span class="pl-k">**</span> __) <span class="pl-k">*</span> (__ <span class="pl-k">+</span> <span class="pl-c1">3</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> f(<span class="pl-c1">10</span>)
<span class="pl-c1">8172</span>

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> ((<span class="pl-c1">90</span><span class="pl-k">/</span>__) <span class="pl-k">*</span> (<span class="pl-c1">10</span><span class="pl-k">+</span>__)) <span class="pl-k">*</span> Just(<span class="pl-c1">20</span>)
Just(<span class="pl-c1">3</span>)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask.Data.List <span class="pl-k">import</span> takeWhile
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> takeWhile(__<span class="pl-k">&lt;</span><span class="pl-c1">5</span>, <span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">...</span>])
<span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>]

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> (__<span class="pl-k">+</span>__)(<span class="pl-s"><span class="pl-pds">'</span>Hello <span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>world<span class="pl-pds">'</span></span>)
<span class="pl-s"><span class="pl-pds">'</span>Hello world<span class="pl-pds">'</span></span>

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> (__<span class="pl-k">**</span>__)(<span class="pl-c1">2</span>)(<span class="pl-c1">10</span>)
<span class="pl-c1">1024</span>

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask.Data.List <span class="pl-k">import</span> zipWith, take
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> take(<span class="pl-c1">5</span>) <span class="pl-k">%</span> zipWith(__ <span class="pl-k">*</span> __, <span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">...</span>], <span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">...</span>])
<span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">4</span>, <span class="pl-c1">9</span>, <span class="pl-c1">16</span>, <span class="pl-c1">25</span>]</pre></div>

<p>As you can see, this much easier than using <code>lambda</code> and adding a type
signature with the <code>(lambda x: ...) ** (H/ ...)</code> syntax.</p>

<p>In addition, the types of the <code>TypedFuncs</code> created by sections are always
polymorphic, to allow for any operator overloading.</p>

<p>Note that if you are using IPython, Hask's <code>__</code> will conflict with IPython's
special double underscore variable. To avoid conflicts, you can use <code>from hask
import __ as _s</code> in IPython.</p>

<h3><a id="user-content-guards" class="anchor" href="#guards" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Guards</h3>

<p>If you don't need the full power of pattern matching and just want a neater
switch statement, you can use guards. The syntax for guards is almost identical
to the syntax for pattern matching.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">~</span>(guard(expr_to_test)
    <span class="pl-k">|</span> c(test_1) <span class="pl-k">&gt;&gt;</span> return_value_1
    <span class="pl-k">|</span> c(test_2) <span class="pl-k">&gt;&gt;</span> return_value_2
    <span class="pl-k">|</span> otherwise <span class="pl-k">&gt;&gt;</span> return_value_3
)</pre></div>

<p>As in Haskell, <code>otherwise</code> will always evaluate to <code>True</code> and can be used as a
catch-all in guard expressions. If no match is found (and an <code>otherwise</code> clause
is not present), a <code>NoGuardMatchException</code> will be raised.</p>

<p>Guards will also play nicely with sections:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask <span class="pl-k">import</span> guard, c, otherwise

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> porridge_tempurature <span class="pl-k">=</span> <span class="pl-c1">80</span>

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">~</span>(guard(porridge_tempurature)
<span class="pl-c1">...</span>     <span class="pl-k">|</span> c(__ <span class="pl-k">&lt;</span> <span class="pl-c1">20</span>)  <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Porridge is too cold!<span class="pl-pds">"</span></span>
<span class="pl-c1">...</span>     <span class="pl-k">|</span> c(__ <span class="pl-k">&lt;</span> <span class="pl-c1">90</span>)  <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Porridge is just right!<span class="pl-pds">"</span></span>
<span class="pl-c1">...</span>     <span class="pl-k">|</span> c(__ <span class="pl-k">&lt;</span> <span class="pl-c1">150</span>) <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Porridge is too hot!<span class="pl-pds">"</span></span>
<span class="pl-c1">...</span>     <span class="pl-k">|</span> otherwise   <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Porridge has gone thermonuclear<span class="pl-pds">"</span></span>
<span class="pl-c1">...</span> )
<span class="pl-s"><span class="pl-pds">'</span>Porridge is just right!<span class="pl-pds">'</span></span></pre></div>

<p>If you need a more complex conditional, you can always use lambdas, regular
Python functions, or any other callable in your guard condition.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">examine_password_security</span>(<span class="pl-smi">password</span>):
    analysis <span class="pl-k">=</span> <span class="pl-k">~</span>(guard(password)
        <span class="pl-k">|</span> c(<span class="pl-k">lambda</span> <span class="pl-smi">x</span>: <span class="pl-c1">len</span>(x) <span class="pl-k">&gt;</span> <span class="pl-c1">20</span>) <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Wow, that's one secure password<span class="pl-pds">"</span></span>
        <span class="pl-k">|</span> c(<span class="pl-k">lambda</span> <span class="pl-smi">x</span>: <span class="pl-c1">len</span>(x) <span class="pl-k">&lt;</span> <span class="pl-c1">5</span>)  <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>You made Bruce Schneier cry<span class="pl-pds">"</span></span>
        <span class="pl-k">|</span> c(__ <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>12345<span class="pl-pds">"</span></span>)         <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Same combination as my luggage!<span class="pl-pds">"</span></span>
        <span class="pl-k">|</span> otherwise                <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Hope it's not 'password'<span class="pl-pds">"</span></span>
    )
    <span class="pl-k">return</span> analysis


<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> nuclear_launch_code <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>12345<span class="pl-pds">"</span></span>

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> examine_password_security(nuclear_launch_code)
<span class="pl-s"><span class="pl-pds">'</span>Same combination as my luggage!<span class="pl-pds">'</span></span></pre></div>

<h3><a id="user-content-monadic-error-handling-of-python-functions" class="anchor" href="#monadic-error-handling-of-python-functions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Monadic error handling (of Python functions)</h3>

<p>If you want to use <code>Maybe</code> and <code>Either</code> to handle errors raised by Python
functions defined outside Hask, you can use the decorators <code>in_maybe</code> and
<code>in_either</code> to create functions that call the original function and return the
result wrapped inside a <code>Maybe</code> or <code>Either</code> value.</p>

<p>If a function wrapped in <code>in_maybe</code> raises an exception, the wrapped function
will return <code>Nothing</code>. Otherwise, the result will be returned wrapped in a
<code>Just</code>.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">eat_cheese</span>(<span class="pl-smi">cheese</span>):
    <span class="pl-k">if</span> cheese <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>:
        <span class="pl-k">raise</span> <span class="pl-c1">ValueError</span>(<span class="pl-s"><span class="pl-pds">"</span>Out of cheese error<span class="pl-pds">"</span></span>)
    <span class="pl-k">return</span> cheese <span class="pl-k">-</span> <span class="pl-c1">1</span>

maybe_eat <span class="pl-k">=</span> in_maybe(eat_cheese)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> maybe_eat(<span class="pl-c1">1</span>)
Just(<span class="pl-c1">0</span>)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> maybe_eat(<span class="pl-c1">0</span>)
Nothing</pre></div>

<p>Note that this is equivalent to lifting the original function into the Maybe
monad. That is, its type has changed from <code>func</code> to <code>a -&gt; Maybe b</code>.  This
makes it easier to use the convineient monad error handling style commonly seen
in Haskell with existing Python functions.</p>

<p>Continuing with this silly example, let's try to eat three pieces of cheese,
returning <code>Nothing</code> if the attempt was unsuccessful:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> cheese <span class="pl-k">=</span> <span class="pl-c1">10</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> cheese_left <span class="pl-k">=</span> Just(cheese) <span class="pl-k">&gt;&gt;</span> maybe_eat <span class="pl-k">&gt;&gt;</span> maybe_eat <span class="pl-k">&gt;&gt;</span> maybe_eat
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> cheese_left
Just(<span class="pl-c1">7</span>)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> cheese <span class="pl-k">=</span> <span class="pl-c1">1</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> cheese_left <span class="pl-k">=</span> Just(cheese) <span class="pl-k">&gt;&gt;</span> maybe_eat <span class="pl-k">&gt;&gt;</span> maybe_eat <span class="pl-k">&gt;&gt;</span> maybe_eat
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> cheese_left
Nothing</pre></div>

<p>Notice that we have taken a regular Python function that throws Exceptions, and
are now handling it in a type-safe, monadic way.</p>

<p>The <code>in_either</code> function works just like <code>in_maybe</code>. If an Exception is thrown,
the wrapped function will return the exception wrapped in <code>Left</code>. Otherwise,
the result will be returned wrapped in <code>Right</code>.</p>

<div class="highlight highlight-source-python"><pre>either_eat <span class="pl-k">=</span> in_either(eat_cheese)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> either_eat(Right(<span class="pl-c1">10</span>))
Right(<span class="pl-c1">9</span>)

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> either_eat(Right(<span class="pl-c1">0</span>))
Left(<span class="pl-c1">ValueError</span>(<span class="pl-s"><span class="pl-pds">'</span>Out of cheese error<span class="pl-pds">'</span></span>,))</pre></div>

<p>Chained cheese-eating in the <code>Either</code> monad is left as an exercise for
the reader.</p>

<p>You can also use <code>in_maybe</code> or <code>in_either</code> as decorators:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-en">@in_maybe</span>
<span class="pl-k">def</span> <span class="pl-en">some_function</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>):
    <span class="pl-c1">...</span></pre></div>

<h3><a id="user-content-standard-libraries" class="anchor" href="#standard-libraries" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Standard libraries</h3>

<p>All of your favorite functions from <code>Prelude</code>, <code>Data.List</code>, <code>Data.Maybe</code>,
<code>Data.Either</code>, <code>Data.Monoid</code>, and more are implemented too. Everything is
pretty well documented, so if you're not sure about some function or typeclass,
use <code>help</code> liberally. See the Appendix below for a full list of modules. Some
highlights:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask.Data.Maybe <span class="pl-k">import</span> mapMaybe
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> mapMaybe(safe_div(<span class="pl-c1">12</span>)) <span class="pl-k">%</span> <span class="pl-c1">L</span>[<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">0</span>, <span class="pl-c1">6</span>]
<span class="pl-c1">L</span>[<span class="pl-c1">12</span>, <span class="pl-c1">4</span>, <span class="pl-c1">2</span>]


<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask.Data.List <span class="pl-k">import</span> isInfixOf
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> isInfixOf(<span class="pl-c1">L</span>[<span class="pl-c1">2</span>, <span class="pl-c1">8</span>], <span class="pl-c1">L</span>[<span class="pl-c1">1</span>, <span class="pl-c1">4</span>, <span class="pl-c1">6</span>, <span class="pl-c1">2</span>, <span class="pl-c1">8</span>, <span class="pl-c1">3</span>, <span class="pl-c1">7</span>])
<span class="pl-c1">True</span>


<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask.Control.Monad <span class="pl-k">import</span> join
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> join(Just(Just(<span class="pl-c1">1</span>)))
Just(<span class="pl-c1">1</span>)</pre></div>

<p>Hask also provies <code>TypeFunc</code> wrappers for everything in <code>__builtins__</code> for ease
of compatibity. (Eventually, Hask will have typed wrappers for most of the
Python standard library.)</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask.Prelude <span class="pl-k">import</span> flip
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask.Data.Tuple <span class="pl-k">import</span> snd
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> hask.Python.builtins <span class="pl-k">import</span> <span class="pl-c1">divmod</span>, <span class="pl-c1">hex</span>

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> hexMod <span class="pl-k">=</span> <span class="pl-c1">hex</span> <span class="pl-k">*</span> snd <span class="pl-k">*</span> flip(<span class="pl-c1">divmod</span>, <span class="pl-c1">16</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> hexMod(<span class="pl-c1">24</span>)
<span class="pl-s"><span class="pl-pds">'</span>0x8<span class="pl-pds">'</span></span></pre></div>

<h3><a id="user-content-internals" class="anchor" href="#internals" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Internals</h3>

<p>If you want to poke around behind the curtain, here are some useful starting
points:</p>

<ul>
<li><code>typeof(obj)</code> returns an object's type in Hask's type system</li>
<li><code>has_instance(some_type, typeclass)</code> tests for typeclass membership</li>
<li><code>nt_to_tuple</code> converts instances of <code>namedtuple</code> (including Hask ADTs) into
regular tuples</li>
<li><code>typify</code> converts a Python function into a <code>TypedFunc</code> object</li>
</ul>

<h2><a id="user-content-appendix" class="anchor" href="#appendix" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Appendix</h2>

<p><strong>Table 1.</strong> Overview of Hask typeclasses.</p>

<table><thead>
<tr>
<th>Typeclass</th>
<th>Superclasses</th>
<th>Required functions</th>
<th>Optional functions</th>
<th>Magic Methods</th>
</tr>
</thead><tbody>
<tr>
<td><code>Show</code></td>
<td/>
<td><code>show</code></td>
<td/>
<td><code>str</code></td>
</tr>
<tr>
<td><code>Read</code></td>
<td/>
<td><code>read</code></td>
<td/>
<td/>
</tr>
<tr>
<td><code>Eq</code></td>
<td/>
<td><code>eq</code></td>
<td><code>ne</code></td>
<td><code>==</code>, <code>!=</code></td>
</tr>
<tr>
<td><code>Ord</code></td>
<td><code>Eq</code></td>
<td><code>lt</code></td>
<td><code>gt</code>, <code>le</code>, <code>ge</code></td>
<td><code>&lt;</code>, <code>&lt;</code>, <code>=&lt;</code>, <code>=&gt;</code></td>
</tr>
<tr>
<td><code>Enum</code></td>
<td/>
<td><code>toEnum</code>, <code>fromEnum</code></td>
<td><code>pred</code>, <code>succ</code>, <code>enumTo</code>, <code>enumFromTo</code>, <code>enumFromThen</code>, <code>enumFromThenTo</code></td>
<td/>
</tr>
<tr>
<td><code>Bounded</code></td>
<td/>
<td><code>minBound</code>, <code>maxBound</code></td>
<td/>
<td/>
</tr>
<tr>
<td><code>Functor</code></td>
<td/>
<td><code>fmap</code></td>
<td/>
<td><code>*</code></td>
</tr>
<tr>
<td><code>Applicative</code></td>
<td><code>Functor</code></td>
<td><code>pure</code></td>
<td/>
<td/>
</tr>
<tr>
<td><code>Monad</code></td>
<td><code>Applicative</code></td>
<td><code>bind</code></td>
<td/>
<td><code>&gt;&gt;</code></td>
</tr>
<tr>
<td><code>Monoid</code></td>
<td/>
<td><code>mappend</code>, <code>mempty</code></td>
<td><code>mconcat</code></td>
<td><code>+</code></td>
</tr>
<tr>
<td><code>Foldable</code></td>
<td/>
<td><code>foldr</code></td>
<td><code>foldr_</code>, <code>foldl</code>, <code>foldl_</code>, <code>foldr1</code>, <code>foldl1</code>, <code>toList</code>, <code>null</code>, <code>length</code>, <code>elem</code>, <code>maximum</code>, <code>minimum</code>, <code>sum</code>, <code>product</code></td>
<td><code>len</code>, <code>iter</code></td>
</tr>
<tr>
<td><code>Traversable</code></td>
<td><code>Foldable</code>, <code>Functor</code></td>
<td><code>traverse</code></td>
<td><code>sequenceA</code>, <code>mapM</code>, <code>sequence</code></td>
<td/>
</tr>
<tr>
<td><code>Num</code></td>
<td><code>Show</code>, <code>Eq</code></td>
<td><code>add</code>, <code>mul</code>, <code>abs</code>, <code>signum</code>, <code>fromInteger</code>, <code>negate</code></td>
<td><code>sub</code></td>
<td><code>+</code>, <code>-</code>, <code>*</code></td>
</tr>
<tr>
<td><code>Real</code></td>
<td><code>Num</code>, <code>Ord</code></td>
<td><code>toRational</code></td>
<td/>
<td/>
</tr>
<tr>
<td><code>Integral</code></td>
<td><code>Real</code>, <code>Enum</code></td>
<td><code>quotRem</code>, <code>divMod</code>, <code>toInteger</code></td>
<td><code>quot</code>, <code>rem</code>, <code>div</code>, <code>mod</code></td>
<td><code>/</code>, <code>%</code></td>
</tr>
<tr>
<td><code>Fractional</code></td>
<td><code>Num</code></td>
<td><code>fromRational</code>, <code>div</code></td>
<td><code>recip</code></td>
<td><code>/</code></td>
</tr>
<tr>
<td><code>Floating</code></td>
<td><code>Fractional</code></td>
<td><code>exp</code>, <code>sqrt</code>, <code>log</code>, <code>pow</code>, <code>logBase</code>, <code>sin</code>, <code>tan</code>, <code>cos</code>, <code>asin</code>, <code>atan</code>, <code>acos</code>, <code>sinh</code>, <code>tanh</code>, <code>cosh</code>, <code>asinh</code>, <code>atanh</code>, <code>acosh</code></td>
<td/>
<td/>
</tr>
<tr>
<td><code>RealFrac</code></td>
<td><code>Real</code>, <code>Fractional</code></td>
<td><code>properFraction</code>, <code>truncate</code>, <code>round</code>, <code>ceiling</code>, <code>floor</code></td>
<td/>
<td/>
</tr>
<tr>
<td><code>RealFloat</code></td>
<td><code>Floating</code>, <code>RealFrac</code></td>
<td><code>floatRange</code>, <code>isNaN</code>, <code>isInfinite</code>, <code>isNegativeZero</code>, <code>atan2</code></td>
<td/>
<td/>
</tr>
</tbody></table>

<p><strong>Table 2.</strong> Hask library structure.</p>

<table><thead>
<tr>
<th>Module</th>
<th>Dependencies</th>
<th>Exported functions</th>
</tr>
</thead><tbody>
<tr>
<td><code>hask</code></td>
<td><code>hask.lang</code>, <code>hask.Data.Char</code>, <code>hask.Data.Either</code>, <code>hask.Data.Eq</code>, <code>hask.Data.Foldable</code>, <code>hask.Data.Functor</code>, <code>hask.Data.List</code>, <code>hask.Data.Maybe</code>, <code>hask.Data.Monoid</code>, <code>hask.Data.Num</code>, <code>hask.Data.Ord</code>, <code>hask.Data.Ratio</code>, <code>hask.Data.String</code>, <code>hask.Data.Traversable</code>, <code>hask.Data.Tuple</code>, <code>hask.Control.Applicative</code>, <code>hask.Control.Monad</code>, <code>hask.Python.builtins</code></td>
<td><code>instance</code>, <code>__</code>, <code>guard</code>, <code>c</code>, <code>otherwise</code>, <code>NoGuardMatchException</code>, <code>L</code>, <code>data</code>, <code>d</code>, <code>deriving</code>, <code>sig</code>, <code>H</code>, <code>t</code>, <code>func</code>, <code>TypeSignatureError</code>, <code>caseof</code>, <code>p</code>, <code>m</code>, <code>IncompletePatternError</code>, <code>_t</code>, <code>_i</code>, <code>_q</code>, <code>typeof</code>, <code>has_instance</code>, <code>Typeclass</code>, <code>Hask</code>, <code>Read</code>, <code>Show</code>, <code>Eq</code>, <code>Ord</code>, <code>Enum</code>, <code>Bounded</code>, <code>Num</code>, <code>Real</code>, <code>Integral</code>, <code>Fractional</code>, <code>Floating</code>, <code>RealFrac</code>, <code>RealFloat</code>, <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, <code>Traversable</code>, <code>Foldable</code>, <code>Maybe</code>, <code>Just</code>, <code>Nothing</code>, <code>in_maybe</code>, <code>Either</code>, <code>Left</code>, <code>Right</code>, <code>in_either</code>, <code>Ordering</code>, <code>LT</code>, <code>EQ</code>, <code>GT</code></td>
</tr>
<tr>
<td><code>hask.Prelude</code></td>
<td><code>hask.lang</code></td>
<td><code>hask.Data.Either</code>, <code>hask.Data.Eq</code>, <code>hask.Data.Foldable</code>, <code>hask.Data.Functor</code>, <code>hask.Data.List</code>, <code>hask.Data.Maybe</code>, <code>hask.Data.Num</code>, <code>hask.Data.Ord</code>, <code>hask.Data.Traversable</code>, <code>hask.Data.Tuple</code>, <code>hask.Control.Applicative</code>, <code>hask.Control.Monad</code></td>
</tr>
<tr>
<td><code>hask.Data.Maybe</code></td>
<td><code>hask.lang</code>, <code>hask.Data.Eq</code>, <code>hask.Data.Ord</code>, <code>hask.Data.Functor</code>, <code>hask.Control.Applicative</code>, <code>hask.Control.Monad</code></td>
<td><code>Maybe</code> (<code>Nothing</code>, <code>Just</code>), <code>in_maybe</code>, <code>maybe</code>, <code>isJust</code>, <code>isNothing</code>, <code>fromJust</code>, <code>listToMaybe</code>, <code>maybeToList</code>, <code>catMaybes</code>, <code>mapMaybe</code></td>
</tr>
<tr>
<td><code>hask.Data.Either</code></td>
<td><code>hask.lang</code>, <code>hask.Data.Eq</code>, <code>hask.Data.Ord</code>, <code>hask.Data.Functor</code>, <code>hask.Control.Applicative</code>, <code>hask.Control.Monad</code></td>
<td><code>Either</code> (<code>Left</code>, <code>Right</code>), <code>in_either</code>, <code>either</code>, <code>lefts</code>, <code>rights</code>, <code>isLeft</code>, <code>isRight</code>, <code>partitionEithers</code></td>
</tr>
<tr>
<td><code>hask.Data.List</code></td>
<td><code>hask.lang</code>, <code>hask.Data.Foldable</code>, <code>hask.Data.Eq</code>, <code>hask.Data.Ord</code>, <code>hask.Data.Num</code>, <code>hask.Data.Maybe</code></td>
<td><code>head</code>, <code>last</code>, <code>tail</code>, <code>init</code>, <code>uncons</code>, <code>null</code>, <code>length</code>, <code>map</code>, <code>reverse</code>, <code>intersperse</code>, <code>intercalate</code>, <code>transpose</code>, <code>subsequences</code>, <code>permutations</code>, <code>foldl</code>, <code>foldl_</code>, <code>foldl1</code>, <code>foldl1_</code>, <code>foldr</code>, <code>foldr1</code>, <code>concat</code>, <code>concatMap</code>, <code>and_</code>, <code>or_</code>, <code>any</code>, <code>all</code>, <code>sum</code>, <code>product</code>, <code>minimum</code>, <code>maximum</code>, <code>scanl</code>, <code>scanl1</code>, <code>scanr</code>, <code>scanr1</code>, <code>mapAccumL</code>, <code>mapAccumR</code>, <code>iterate</code>, <code>repeat</code>, <code>replicate</code>, <code>cycle</code>, <code>unfoldr</code>, <code>take</code>, <code>drop</code>, <code>splitAt</code>, <code>takeWhile</code>, <code>dropWhile</code>, <code>dropWhileEnd</code>, <code>span</code>, <code>break_</code>, <code>stripPrefix</code>, <code>group</code>, <code>inits</code>, <code>tails</code>, <code>isPrefixOf</code>, <code>isSuffixOf</code>, <code>isInfixOf</code>, <code>isSubsequenceOf</code>, <code>elem</code>, <code>notElem</code>, <code>lookup</code>, <code>find</code>, <code>filter</code>, <code>partition</code>, <code>elemIndex</code>, <code>elemIndices</code>, <code>findIndex</code>, <code>findIndicies</code>, <code>zip</code>, <code>zip3</code>, <code>zip4</code>, <code>zip5</code>, <code>zip6</code>, <code>zip7</code>, <code>zipWith</code>, <code>zipWith3</code>, <code>zipWith4</code>, <code>zipWith5</code>, <code>zipWith6</code>, <code>zipWith7</code>, <code>unzip</code>, <code>unzip3</code>, <code>unzip4</code>, <code>unzip5</code>, <code>unzip6</code>, <code>unzip7</code>, <code>lines</code>, <code>words</code>, <code>unlines</code>, <code>unwords</code>, <code>nub</code>, <code>delete</code>, <code>diff</code>, <code>union</code>, <code>intersect</code>, <code>sort</code>, <code>sortOn</code>, <code>insert</code>, <code>nubBy</code>, <code>deleteBy</code>, <code>deleteFirstBy</code>, <code>unionBy</code>, <code>intersectBy</code>, <code>groupBy</code>, <code>sortBy</code>, <code>insertBy</code>, <code>maximumBy</code>, <code>minimumBy</code>, <code>genericLength</code>, <code>genericTake</code>, <code>genericDrop</code>, <code>genericSplitAt</code>, <code>genericIndex</code>, <code>genericReplicate</code></td>
</tr>
<tr>
<td><code>hask.Data.String</code></td>
<td><code>hask.lang</code></td>
<td><code>words</code>, <code>unwords</code>, <code>lines</code>, <code>unlines</code></td>
</tr>
<tr>
<td><code>hask.Data.Tuple</code></td>
<td><code>hask.lang</code></td>
<td><code>fst</code>, <code>snd</code>, <code>swap</code>, <code>curry</code>, <code>uncurry</code></td>
</tr>
<tr>
<td><code>hask.Data.Char</code></td>
<td><code>hask.lang</code></td>
<td><code>isControl</code>, <code>isSpace</code>, <code>isLower</code>, <code>isUpper</code>, <code>isAlpha</code>, <code>isAlphaNum</code>, <code>isPrint</code>, <code>isDigit</code>, <code>isOctDigit</code>, <code>isHexDigit</code>, <code>isLetter</code>, <code>isMark</code>, <code>isNumber</code>, <code>isPunctuation</code>, <code>isSymbol</code>, <code>isSeparator</code>, <code>isAscii</code>, <code>isLatin1</code>, <code>isAsciiUpper</code>, <code>toLower</code>, <code>toUpper</code>, <code>toTitle</code>, <code>digitToInt</code>, <code>intToDigit</code>, <code>chr</code>, <code>ord</code></td>
</tr>
<tr>
<td><code>hask.Data.Eq</code></td>
<td><code>hask.lang</code></td>
<td><code>Eq</code> (<code>==</code>, <code>!=</code>)</td>
</tr>
<tr>
<td><code>hask.Data.Ord</code></td>
<td><code>hask.lang</code>, <code>hask.Data.Eq</code></td>
<td><code>Ord</code> (<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>), <code>Ordering</code> (<code>LT</code>, <code>EQ</code>, <code>GT</code>), <code>max</code>, <code>min</code>, <code>compare</code>, <code>comparing</code></td>
</tr>
<tr>
<td><code>hask.Data.Functor</code></td>
<td><code>hask.lang</code></td>
<td><code>Functor</code> (<code>fmap</code>, <code>*</code>),</td>
</tr>
<tr>
<td><code>hask.Data.Foldable</code></td>
<td><code>hask.lang</code></td>
<td><code>Foldable</code> (<code>foldr</code>, <code>foldr_</code>, <code>foldl</code>, <code>foldl_</code>, <code>foldr1</code>, <code>foldl1</code>, <code>toList</code>, <code>null</code>, <code>length</code>, <code>elem</code>, <code>maximum</code>, <code>minimum</code>, <code>sum</code>, <code>product</code>), <code>foldlM</code>, <code>foldrM</code>, <code>traverse_</code>, <code>for_</code>, <code>sequenceA_</code>, <code>mapM_</code>, <code>forM_</code>, <code>sequence_</code>, <code>concat</code>, <code>concatMap</code> , <code>and_</code>, <code>or_</code>, <code>all_</code>, <code>maximumBy_</code>, <code>minimumBy</code>, <code>notElem</code>, <code>find</code></td>
</tr>
<tr>
<td><code>hask.Data.Traversable</code></td>
<td><code>hask.lang</code>, <code>hask.Data.Foldable</code>, <code>hask.Data.Functor</code></td>
<td><code>Traversable</code> (<code>traverse</code>, <code>sequenceA</code>, <code>mapM</code>, <code>sequence</code>), <code>for1</code>, <code>forM</code>, <code>mapAccumL</code>, <code>mapAccumR</code></td>
</tr>
<tr>
<td><code>hask.Data.Monoid</code></td>
<td><code>hask.lang</code></td>
<td><code>Monoid</code> (<code>mappend</code>, <code>mempty</code>, <code>mconcat</code>)</td>
</tr>
<tr>
<td><code>hask.Data.Ratio</code></td>
<td><code>hask.lang</code>, <code>hask.Data.Num</code></td>
<td><code>Integral</code>, <code>Ratio</code> (<code>R</code>), <code>Rational</code>, <code>toRatio</code>, <code>toRational</code>, <code>numerator</code>, <code>denominator</code></td>
</tr>
<tr>
<td><code>hask.Data.Num</code></td>
<td><code>hask.lang</code>, <code>hask.Data.Eq</code>, <code>hask.Data.Ord</code></td>
<td><code>Num</code> (<code>+</code>, <code>*</code>, <code>abs</code>, <code>signum</code>, <code>fromInteger</code>, <code>negate</code>, <code>-</code>), <code>Fractional</code> (<code>fromRational</code>, <code>/</code>, <code>recip</code>), <code>Floating</code> (<code>exp</code>, <code>sqrt</code>, <code>log</code>, <code>pow</code>, <code>logBase</code>, <code>sin</code>, <code>tan</code>, <code>cos</code>, <code>asin</code>, <code>atan</code>, <code>acos</code>, <code>sinh</code>, <code>tanh</code>, <code>cosh</code>, <code>asinh</code>, <code>atanh</code>, <code>acosh</code>), <code>Real</code> (<code>toRational</code>), <code>Integral</code> (<code>quotRem</code>, <code>quot</code>, <code>rem</code>, <code>div</code>, <code>mod</code>), <code>toRatio</code>, <code>RealFrac</code> (<code>properFraction</code>, <code>truncate</code>, <code>round</code>, <code>ceiling</code>, <code>floor</code>), <code>RealFloat</code> (<code>isNan</code>, <code>isInfinite</code>, <code>isNegativeZero</code>, <code>atan2</code>)</td>
</tr>
<tr>
<td><code>hask.Control.Applicative</code></td>
<td><code>hask.lang</code>, <code>hask.Data.Functor</code></td>
<td><code>Applicative</code></td>
</tr>
<tr>
<td><code>hask.Control.Monad</code></td>
<td><code>hask.lang</code>, <code>hask.Control.Applicative</code>, <code>hask.Data.Functor</code></td>
<td><code>Monad</code> (<code>bind</code>, <code>&gt;&gt;</code>), <code>join</code>, <code>liftM</code></td>
</tr>
<tr>
<td><code>hask.Python.builtins</code></td>
<td><code>hask.lang</code></td>
<td><code>callable</code>, <code>cmp</code>, <code>delattr</code>, <code>divmod</code>, <code>frozenset</code>, <code>getattr</code>, <code>hasattr</code>, <code>hash</code>, <code>hex</code>, <code>isinstance</code>, <code>issubclass</code>, <code>len</code>, <code>oct</code>, <code>repr</code>, <code>setattr</code>, <code>sorted</code>, <code>unichr</code></td>
</tr>
<tr>
<td><code>hask.lang</code></td>
<td/>
<td><code>Show</code> (<code>show</code>), <code>Read</code>, <code>Eq</code>, <code>Ord</code>, <code>Enum</code> (<code>fromEnum</code>, <code>succ</code>, <code>pred</code>, <code>enumFrom</code>, <code>enumFromTo</code>, <code>enumFromThen</code>, <code>enumFromThenTo</code>), <code>Bounded</code>, <code>typeof</code>, <code>is_builtin</code>, <code>has_instance</code>, <code>nt_to_tuple</code>, <code>build_instance</code>, <code>Typeclass</code>, <code>Hask</code>, <code>TypedFunc</code>, <code>TypeSignatureError</code>, <code>undefined</code>, <code>caseof</code>, <code>m</code>, <code>p</code>, <code>IncompletePattnerError</code>, <code>data</code>, <code>d</code>, <code>deriving</code>, <code>H</code>, <code>sig</code>, <code>t</code>, <code>func</code>, <code>typify</code>, <code>NoGuardMatchException</code>, <code>guard</code>, <code>c</code>, <code>otherwise</code>, <code>instance</code>, <code>__</code>, <code>_t</code>, <code>_q</code>, <code>_i</code>, <code>List</code>, <code>L</code></td>
</tr>
</tbody></table>
</article>
  </div></body></html>