<html><body><div><section class="the_post">
    <p>Although having a specialized indexing solution is what most experts recommend when dealing with large, real word sites, sometimes it can be overkill if we’re only working on a simple system with few users and models or if you lack the resources or expertise to manage an additional external dependency.</p>
<p>Most modern relational databases have some sort of full text search functionality built in. We’ll show you how to take advantage of this to provide full text search in a <a class="reference external" href="https://www.djangoproject.com/">Django</a> site using the database back-ends. We chose <a class="reference external" href="http://www.postgresql.org/">PostgreSQL</a> and <a class="reference external" href="https://www.mysql.com/">MySQL</a> (and by extension <a class="reference external" href="https://mariadb.org/">MariaDB</a>) given their popularity and ease of implementation of full text search indexes. The solution is quite simple, and can be adapted for other database back-ends.</p>
<div class="section" id="the-application">
<h2>The application</h2>
<p>The application is just a plain old Django site with a single app named “items”, which has the following model:</p>
<div class="highlight-python">
<div class="highlight">
<pre><span class="k">class</span> <span class="nc">Item</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">description</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>


<span class="k">class</span> <span class="nc">Part</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s">'items.Item'</span><span class="p">,</span> <span class="n">related_name</span><span class="o">=</span><span class="s">'parts'</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</pre>
</div>
</div>
<p>Just two models that refer to each other (so I can show you how to use full text search with related models).</p>
</div>
<div class="section" id="full-text-search-with-postgresql">
<h2>Full Text Search with PostgreSQL</h2>
<p>Starting with version <a class="reference external" href="http://www.postgresql.org/docs/8.3/static/release-8-3.html">8.3</a> PostgreSQL introduced fully featured full text search capabilities. The system is <a class="reference external" href="http://www.postgresql.org/docs/9.4/static/textsearch-intro.html">quite flexible</a> and easy to use if you just want the default configuration for the English language (which I’ll use here).</p>
<p>As shown in the <a class="reference external" href="http://www.postgresql.org/docs/9.4/static/textsearch-tables.html#TEXTSEARCH-TABLES-SEARCH">documentation</a>, doing a full text search on the contents of a table is quite simple:</p>
<div class="highlight-python">
<pre>SELECT title
FROM pgweb
WHERE to_tsvector('english', body) @@ to_tsquery('english', 'friend');</pre>
</div>
<p>In this example, the user is looking for ‘friend’ on the ‘body’ column of the ‘pgweb’ table using the ‘english’ configuration. We can easily adapt this to query a Django model, but first we can speed things up by creating an index on the columns that we want to query. We’ll create our index using a migration:</p>
<div class="highlight-python">
<div class="highlight">
<pre><span class="k">class</span> <span class="nc">Migration</span><span class="p">(</span><span class="n">migrations</span><span class="o">.</span><span class="n">Migration</span><span class="p">):</span>

    <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s">'items'</span><span class="p">,</span> <span class="s">'0001_initial'</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="n">operations</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">migrations</span><span class="o">.</span><span class="n">RunSQL</span><span class="p">(</span>
            <span class="s">"CREATE INDEX items_item_name_ts_idx ON items_item USING gin(to_tsvector('english', name));"</span><span class="p">,</span>
            <span class="s">"DROP INDEX IF EXISTS items_item_name_ts_idx;"</span>
        <span class="p">),</span>
        <span class="n">migrations</span><span class="o">.</span><span class="n">RunSQL</span><span class="p">(</span>
            <span class="s">"CREATE INDEX items_part_name_ts_idx ON items_part USING gin(to_tsvector('english', name));"</span><span class="p">,</span>
            <span class="s">"DROP INDEX IF EXISTS items_part_name_ts_idx;"</span>
        <span class="p">),</span>
    <span class="p">]</span>
</pre>
</div>
</div>
<p>We’re creating two indexes here: one for the <tt class="docutils literal"><span class="pre">Item</span></tt>‘s name and one for the <tt class="docutils literal"><span class="pre">Part</span></tt>‘s name. As mentioned in the PostgreSQL <a class="reference external" href="http://www.postgresql.org/docs/9.4/static/textsearch-tables.html#TEXTSEARCH-TABLES-INDEX">documentation</a>, as long as the queries use the same <tt class="docutils literal"><span class="pre">ts_vector</span></tt> configuration, the index will be used. Next, we’ll write the Django ORM queries for the <tt class="docutils literal"><span class="pre">Item</span></tt> and <tt class="docutils literal"><span class="pre">Part</span></tt> models as <tt class="docutils literal"><span class="pre">QuerySet</span></tt>:</p>
<div class="highlight-python">
<div class="highlight">
<pre><span class="k">class</span> <span class="nc">ItemQueryset</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">QuerySet</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">text_search_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
            <span class="n">select</span><span class="o">=</span><span class="p">{</span><span class="s">'rank'</span><span class="p">:</span> <span class="s">"ts_rank_cd(to_tsvector('english', name), plainto_tsquery(</span><span class="si">%s</span><span class="s">), 32)"</span><span class="p">},</span>
            <span class="n">select_params</span><span class="o">=</span><span class="p">(</span><span class="n">name</span><span class="p">,),</span>
            <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="s">"to_tsvector('english', name) @@ plainto_tsquery(</span><span class="si">%s</span><span class="s">)"</span><span class="p">,),</span>
            <span class="n">params</span><span class="o">=</span><span class="p">(</span><span class="n">name</span><span class="p">,),</span>
            <span class="n">order_by</span><span class="o">=</span><span class="p">(</span><span class="s">'-rank'</span><span class="p">,)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">text_search_part_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">parts__id__in</span><span class="o">=</span><span class="n">Part</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">text_search_name</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">PartQueryset</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">QuerySet</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">text_search_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
            <span class="n">select</span><span class="o">=</span><span class="p">{</span><span class="s">'rank'</span><span class="p">:</span> <span class="s">"ts_rank_cd(to_tsvector('english', name), plainto_tsquery(</span><span class="si">%s</span><span class="s">), 32)"</span><span class="p">},</span>
            <span class="n">select_params</span><span class="o">=</span><span class="p">(</span><span class="n">name</span><span class="p">,),</span>
            <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="s">"to_tsvector('english', name) @@ to_tsquery(</span><span class="si">%s</span><span class="s">)"</span><span class="p">,),</span>
            <span class="n">params</span><span class="o">=</span><span class="p">(</span><span class="n">name</span><span class="p">,),</span>
            <span class="n">order_by</span><span class="o">=</span><span class="p">(</span><span class="s">'-rank'</span><span class="p">,)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">text_search_item_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_related</span><span class="p">()</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
            <span class="n">select</span><span class="o">=</span><span class="p">{</span><span class="s">'rank'</span><span class="p">:</span> <span class="s">"ts_rank_cd(to_tsvector('english', items_item.name), to_tsquery(</span><span class="si">%s</span><span class="s">), 32)"</span><span class="p">},</span>
            <span class="n">select_params</span><span class="o">=</span><span class="p">(</span><span class="n">name</span><span class="p">,),</span>
            <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="s">"to_tsvector('english', items_item.name) @@ plainto_tsquery(</span><span class="si">%s</span><span class="s">)"</span><span class="p">,),</span>
            <span class="n">params</span><span class="o">=</span><span class="p">(</span><span class="n">name</span><span class="p">,),</span>
            <span class="n">order_by</span><span class="o">=</span><span class="p">(</span><span class="s">'-rank'</span><span class="p">,)</span>
        <span class="p">)</span>
</pre>
</div>
</div>
<p>We made use of the <tt class="docutils literal"><span class="pre">QuerySet</span></tt> <a class="reference external" href="https://docs.djangoproject.com/en/1.9/ref/models/querysets/#extra">extra</a> modifier to express the full text search queries. The <tt class="docutils literal"><span class="pre">text_search_name</span></tt> methods use a similar query to the one in the example, with a simple modification: We use PostgreSQL’s <a class="reference external" href="http://www.postgresql.org/docs/9.4/static/functions-textsearch.html">ts_rank_cd</a> function to define a ranking between the matches, which allows us to order the results, something we usually want in these cases. Notice that we use the ‘english’ configuration so the indexes created in the migration are properly used. Be aware that if you use a different configuration <strong>the query won’t fail</strong>, but it will not use the index.</p>
<p>The <tt class="docutils literal"><span class="pre">text_search_item_name</span></tt> and <tt class="docutils literal"><span class="pre">text_search_part_name</span></tt> shows you how to use the full text search with related tables. In <tt class="docutils literal"><span class="pre">text_search_item_name</span></tt>, we’re looking for Part objects whose related Item matches a specific text search query on its name. We can accomplish this by applying the query to the <tt class="docutils literal"><span class="pre">items_item.name</span></tt> column, but we have to make sure that we call <a class="reference external" href="https://docs.djangoproject.com/en/1.9/ref/models/querysets/#select-related">select_related</a> so the Item table is JOINed and its columns are available in the query.</p>
<p>We cannot use the <tt class="docutils literal"><span class="pre">select_related</span></tt> trick with <tt class="docutils literal"><span class="pre">text_search_part_name</span></tt> as it doesn’t work with reverse relationships. To get around this, we simply make use of <tt class="docutils literal"><span class="pre">PartQueryset</span></tt>‘s <tt class="docutils literal"><span class="pre">text_search_name</span></tt> with a <tt class="docutils literal"><span class="pre">parts__id__in</span></tt> lookup, which will be translated to an inner query that does the full text search. Notice that the result of this query might have duplicates, so you might want to add a <a class="reference external" href="https://docs.djangoproject.com/en/1.9/ref/models/querysets/#distinct">distinct</a> modifier to it.</p>
</div>
<div class="section" id="full-text-search-with-mysql">
<h2>Full Text Search with MySQL</h2>
<p>MySQL introduced <a class="reference external" href="https://dev.mysql.com/doc/refman/5.5/en/fulltext-search.html">full text search for MyISAM tables in version 5.5</a>. Subsequent versions allow <a class="reference external" href="https://dev.mysql.com/doc/refman/5.7/en/fulltext-search.html">full text search with InnoDB</a> tables as well. Full text search is performed using the <a class="reference external" href="https://dev.mysql.com/doc/refman/5.7/en/fulltext-search.html#function_match">MATCH</a> function:</p>
<div class="highlight-python">
<pre>mysql&gt; SELECT * FROM articles
    WHERE MATCH (title,body)
    AGAINST ('database' IN NATURAL LANGUAGE MODE);
+----+-------------------+------------------------------------------+
| id | title             | body                                     |
+----+-------------------+------------------------------------------+
|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |
|  5 | MySQL vs. YourSQL | In the following database comparison ... |
+----+-------------------+------------------------------------------+
2 rows in set (0.00 sec)</pre>
</div>
<p>The query above (taken from MySQL’s documentation) looks for ‘database’ on the ‘title’ and ‘body’ columns of the ‘articles’ table using full text search. This will only work if the ‘article’ table has a FULLTEXT index defined against the ‘title’ and ‘body’ tables. As with any regular index, it can be defined during the table creation:</p>
<div class="highlight-python">
<pre>CREATE TABLE articles (
    id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
    title VARCHAR(200),
    body TEXT,
    FULLTEXT (title,body)
) ENGINE=InnoDB;</pre>
</div>
<p>or afterwards:</p>
<div class="highlight-python">
<pre>CREATE FULLTEXT INDEX title_body_ft_idx ON articles(title, body);</pre>
</div>
<p>So, before we can make full text search queries with MySQL from our Django model, we have to create those indexes. We’ll use a migration for this:</p>
<div class="highlight-python">
<div class="highlight">
<pre><span class="k">class</span> <span class="nc">Migration</span><span class="p">(</span><span class="n">migrations</span><span class="o">.</span><span class="n">Migration</span><span class="p">):</span>

    <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s">'items'</span><span class="p">,</span> <span class="s">'0001_initial'</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="n">operations</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">migrations</span><span class="o">.</span><span class="n">RunSQL</span><span class="p">(</span>
            <span class="s">'CREATE FULLTEXT INDEX items_item_name_ts_idx ON items_item(name);'</span><span class="p">,</span>
            <span class="s">'ALTER TABLE items_item DROP INDEX items_item_name_ts_idx;'</span>
        <span class="p">),</span>
        <span class="n">migrations</span><span class="o">.</span><span class="n">RunSQL</span><span class="p">(</span>
            <span class="s">'CREATE FULLTEXT INDEX items_part_name_ts_idx ON items_part(name);'</span><span class="p">,</span>
            <span class="s">'ALTER TABLE items_part DROP INDEX items_part_name_ts_idx;'</span>
        <span class="p">)</span>
    <span class="p">]</span>
</pre>
</div>
</div>
<p>As in the PostgreSQL section, We are creating two indexes: one for the <tt class="docutils literal"><span class="pre">Item</span></tt>‘s name and one for the <tt class="docutils literal"><span class="pre">Part</span></tt>‘s name. We can now make full text search queries on the <tt class="docutils literal"><span class="pre">name</span></tt> field of the <tt class="docutils literal"><span class="pre">Item</span></tt> and <tt class="docutils literal"><span class="pre">Part</span></tt> models. We can now write these queries as <tt class="docutils literal"><span class="pre">QuerySet</span></tt> methods:</p>
<div class="highlight-python">
<div class="highlight">
<pre><span class="k">class</span> <span class="nc">ItemQueryset</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">QuerySet</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">text_search_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
            <span class="n">select</span><span class="o">=</span><span class="p">{</span><span class="s">'rank'</span><span class="p">:</span> <span class="s">"MATCH (name) AGAINST (</span><span class="si">%s</span><span class="s"> IN NATURAL LANGUAGE MODE)"</span><span class="p">},</span>
            <span class="n">select_params</span><span class="o">=</span><span class="p">(</span><span class="n">name</span><span class="p">,),</span>
            <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="s">'MATCH (name) AGAINST (</span><span class="si">%s</span><span class="s"> IN NATURAL LANGUAGE MODE) &gt; 0'</span><span class="p">,),</span>
            <span class="n">params</span><span class="o">=</span><span class="p">(</span><span class="n">name</span><span class="p">,),</span>
            <span class="n">order_by</span><span class="o">=</span><span class="p">(</span><span class="s">'-rank'</span><span class="p">,)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">text_search_part_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">parts__id__in</span><span class="o">=</span><span class="n">Part</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">text_search_name</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">PartQueryset</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">QuerySet</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">text_search_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
            <span class="n">select</span><span class="o">=</span><span class="p">{</span><span class="s">'rank'</span><span class="p">:</span> <span class="s">"MATCH (name) AGAINST (</span><span class="si">%s</span><span class="s"> IN NATURAL LANGUAGE MODE)"</span><span class="p">},</span>
            <span class="n">select_params</span><span class="o">=</span><span class="p">(</span><span class="n">name</span><span class="p">,),</span>
            <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="s">'MATCH (name) AGAINST (</span><span class="si">%s</span><span class="s"> IN NATURAL LANGUAGE MODE) &gt; 0'</span><span class="p">,),</span>
            <span class="n">params</span><span class="o">=</span><span class="p">(</span><span class="n">name</span><span class="p">,),</span>
            <span class="n">order_by</span><span class="o">=</span><span class="p">(</span><span class="s">'-rank'</span><span class="p">,)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">text_search_item_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_related</span><span class="p">()</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
            <span class="n">select</span><span class="o">=</span><span class="p">{</span><span class="s">'rank'</span><span class="p">:</span> <span class="s">"MATCH (items_item.name) AGAINST (</span><span class="si">%s</span><span class="s"> IN NATURAL LANGUAGE MODE)"</span><span class="p">},</span>
            <span class="n">select_params</span><span class="o">=</span><span class="p">(</span><span class="n">name</span><span class="p">,),</span>
            <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="s">'MATCH (items_item.name) AGAINST (</span><span class="si">%s</span><span class="s"> IN NATURAL LANGUAGE MODE) &gt; 0'</span><span class="p">,),</span>
            <span class="n">params</span><span class="o">=</span><span class="p">(</span><span class="n">name</span><span class="p">,),</span>
            <span class="n">order_by</span><span class="o">=</span><span class="p">(</span><span class="s">'-rank'</span><span class="p">,)</span>
        <span class="p">)</span>
</pre>
</div>
</div>
<p>Again, we made use of the <tt class="docutils literal"><span class="pre">QuerySet</span></tt> <a class="reference external" href="https://docs.djangoproject.com/en/1.9/ref/models/querysets/#extra">extra</a> modifier to express the full text search queries using the MATCH function to exclude rows that doesn’t match our query (those with MATCH values equal to 0), and we order the results based on this value.</p>
<p>The <tt class="docutils literal"><span class="pre">text_search_item_name</span></tt> and <tt class="docutils literal"><span class="pre">text_search_part_name</span></tt> shows you how to use the full text search with related tables. In <tt class="docutils literal"><span class="pre">text_search_item_name</span></tt>, we’re looking for Part objects whose related Item matches a specific text search query on its name. We can accomplish this by applying the query to the <tt class="docutils literal"><span class="pre">items_item.name</span></tt> column, but we have to make sure that we call <a class="reference external" href="https://docs.djangoproject.com/en/1.9/ref/models/querysets/#select-related">select_related</a> so the Item table is JOINed and its columns are available in the query.</p>
<p>We cannot use the <tt class="docutils literal"><span class="pre">select_related</span></tt> trick with <tt class="docutils literal"><span class="pre">text_search_part_name</span></tt> as it doesn’t work with reverse relationships. To get around this, we simply make use of <tt class="docutils literal"><span class="pre">PartQueryset</span></tt>‘s <tt class="docutils literal"><span class="pre">text_search_name</span></tt> with a <tt class="docutils literal"><span class="pre">parts__id__in</span></tt> lookup, which will be translated to an inner query that does the full text search. Notice that the result of this query might have duplicates, so you might want to add a <a class="reference external" href="https://docs.djangoproject.com/en/1.9/ref/models/querysets/#distinct">distinct</a> modifier to it.</p>
</div>
<div class="section" id="example">
<h2>Example</h2>
<p>Before showin you a sample shell session making the queries, first we must configure the <tt class="docutils literal"><span class="pre">QuerySet</span></tt> as managers of our models:</p>
<div class="highlight-python">
<div class="highlight">
<pre><span class="k">class</span> <span class="nc">Item</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="n">objects</span> <span class="o">=</span> <span class="n">ItemQueryset</span><span class="o">.</span><span class="n">as_manager</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Part</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="n">objects</span> <span class="o">=</span> <span class="n">PartQueryset</span><span class="o">.</span><span class="n">as_manager</span><span class="p">()</span>
</pre>
</div>
</div>
<p>In the following sample shell session you can see how the searches are performed. This works both for PostgreSQL and MySQL:</p>
<div class="highlight-python">
<div class="highlight">
<pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Item</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">text_search_name</span><span class="p">(</span><span class="s">'malesuada'</span><span class="p">)</span>
<span class="go">[&lt;Item: a, malesuada id, erat. Etiam vestibulum&gt;, &lt;Item: elit, dictum eu, eleifend nec, malesuada ut, sem.&gt;, &lt;Item: blandit. Nam nulla magna, malesuada vel, convallis&gt;, &lt;Item: malesuada fames ac turpis egestas. Aliquam fringilla cursus&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Part</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">text_search_name</span><span class="p">(</span><span class="s">'zatyPjg'</span><span class="p">)</span>
<span class="go">[&lt;Part: XlUfMZz zatyPjg jtrJDm sFYXb vdoZx&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Item</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">text_search_part_name</span><span class="p">(</span><span class="s">'zatyPjg'</span><span class="p">)</span>
<span class="go">[&lt;Item: elit, dictum eu, eleifend nec, malesuada ut, sem.&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Part</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">text_search_item_name</span><span class="p">(</span><span class="s">'malesuada'</span><span class="p">)</span>
<span class="go">[&lt;Part: GHxACaz&gt;, &lt;Part: OhXQwmHx CABsgVDI EKaBA x NFBKOT joDLaM&gt;, &lt;Part: npQAIhf FjacKz hbWDwG IicMPqpK EWYQmj YXz hlUsvjBO&gt;, &lt;Part: XlUfMZz zatyPjg jtrJDm sFYXb vdoZx&gt;, &lt;Part: ls JlNp YDghUXW FpRhxSk&gt;, &lt;Part: Onh ZuESiM M&gt;, &lt;Part: gTJtUC IatOSclg&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">part</span><span class="o">.</span><span class="n">item</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">Part</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">text_search_item_name</span><span class="p">(</span><span class="s">'malesuada'</span><span class="p">)]</span>
<span class="go">[&lt;Item: a, malesuada id, erat. Etiam vestibulum&gt;, &lt;Item: elit, dictum eu, eleifend nec, malesuada ut, sem.&gt;, &lt;Item: elit, dictum eu, eleifend nec, malesuada ut, sem.&gt;, &lt;Item: elit, dictum eu, eleifend nec, malesuada ut, sem.&gt;, &lt;Item: blandit. Nam nulla magna, malesuada vel, convallis&gt;, &lt;Item: blandit. Nam nulla magna, malesuada vel, convallis&gt;, &lt;Item: malesuada fames ac turpis egestas. Aliquam fringilla cursus&gt;]</span>
</pre>
</div>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>As you can see, the solution is pretty much identical in both cases, which suggests that it might be possible to adapt it to other database backends with full text search support (as <a class="reference external" href="https://sqlite.org/fts5.html">SQLite</a>). Although I haven’t personally tested these solutions with a large site, I found several articles online suggesting that the full text search support from MySQL and PostgreSQL are both efficient and reliable.</p>
</div>
<div class="section" id="the-code">
<h2>The code</h2>
<p>You can get the code for both solutions on <a class="reference external" href="https://github.com/abarto/full_text_search_django">GitHub</a>. The code for each solution is on its own branch:</p>

</div>
<div class="section" id="vagrant">
<h2>Vagrant</h2>
<p>A <a class="reference external" href="https://www.vagrantup.com/">Vagrant</a> configuration file is included if you want to test the solutions.</p>
</div>
<div class="section" id="feedback">
<h2>Feedback</h2>
<p>As usual, comments and suggestions are more than welcome.</p>
</div>
</section>


</div></body></html>