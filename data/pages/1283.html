<html><body><div><article>
	<p>Sometimes, you need a resource to behave differently in a test and the change must be temporary, lest it affect other unrelated tests. To change a resource's behavior temporarily, you can employ patching, a capability built into Python's Mock module, whose workings I explained <a href="http://www.drdobbs.com/testing/using-mocks-in-python/240168251">in a previous article</a>.</p>
<p>
</p><p>In this article, I explain the mock patching mechanism and describe four types of patch decorators, then demonstrate several ways to apply a patch. I also examine the <code>MagicMock</code> class and explain its role in patching.</p>
<p>
</p><p>The code works with all versions of Python 2.x from v. 2.4.1 on. It also uses Mock 1.0.1.  Readers should have a good grasp of Python, the <code>Mock</code> class, and basic unit testing.</p>
<h3>Reasons to Patch</h3>
<p>
</p><p>Suppose you want a resource to raise an error or exception on cue. You could try changing the resource's source code itself; but this means exclusive access to the source code  not possible when the resource  is a commercial product. If you do have source access, changing the source incurs overhead. You need to locate the appropriate code and figure out what changes to make. You have to rebuild the resource, fix any errors that crop up, then test to make sure your changes work as expected and and that you have not broken anything else.</p>
<p>
</p><p>A better and safer approach is to use a mock. A mock takes the place of the test resource and offers the same method interface. You can have each method return a value or raise an error/exception. And you can easily customize a mock to suit a specific test or test routine. This customization, especially, when done temporarily, is where patching comes in handy. There are many situations in which this can happen, for example, forcing an unusual condition or behavior so you can test it, without creating an entirely new mock object simply to exhibit the desired behavior.</p>
 
<h3>The Patch Decorators</h3>
<p>The <code>Mock</code> module uses four decorators to patch a resource. Decorators are specialized methods. They return the patched resource as a mock, a separate object, or class.</p>
<p>The core decorator <code>patch</code> is  most often used. It takes several arguments, of which <code>target</code> argument is required.</p>
<p/><pre class="brush: python; html: collapse;">patch(target, new = DEFAULT, spec|spec_set = None,
  new_callable = None, autospec = None, **kwArgs)</pre>
<p>
</p><p>The <code>target</code> argument is the patch target, which can be a class or a mock. If the class is in a separate file, pass its name as <code>package.module.ClassName</code>. If the class is in the same file as the decorator, pass <code>'__main__.ClassName'</code>.</p>
<p>
</p><p>The <code>spec</code> and <code>spec_set</code> arguments sets the attributes for patching. The attributes can come from a list of names or from a class. Omitting <code>spec</code> and <code>spec_set</code> tells the core decorator to use the target's attributes.</p>
<p>The <code>autospec</code> argument is another way to supply attributes for patching. Pass an arbitrary object, and the patched resource will take on that object's attributes. Pass a <code>True</code>, and the patched resource takes on the target's attributes.</p>
<p>The <code>new</code> argument sets the basis for the patched resource. This can be a class, an object, or even another mock. If omitted, the decorator builds the patched resource using the <code>MagicMock</code> class (more about <code>MagicMock</code> later).</p>
<p>The <code>new_callable</code> argument also sets the class or object with which to base the patched resource. But the class/object must be callable; that is, it implements the magic method <code>__call__()</code>. Again, the decorator uses the <code>MagicMock</code> class by default.</p>
<p>
</p><p>Finally, the <code>kwArgs</code> argument uses a dictionary object as a source of attributes. Unlike <code>spec</code>, <code>spec_set</code>, or <code>autospec</code>, <code>kwArgs</code> also sets the initial values for each attribute. Each dictionary entry consists of the attribute name (the key) and the patch value.</p>
<p>The decorator <code>patch.object</code> is another way to create a patched resource. It shares the same optional arguments as the core decorator. The decorator expects at least two arguments.</p>
<p>
</p><p/><pre class="brush: python; html: collapse;">patch.object(target, attribute, [value, ...])</pre>
<p>The <code>target</code> argument is the target resource. The <code>attribute</code> argument is the attribute being patched. The optional <code>value</code> argument is the value to assign to the attribute. The other six optional arguments are the same as in the previous core decorator.</p>
<p>
</p><p>The decorator <code>patch.dict</code> uses a dictionary object for a target. </p>
<p/><pre class="brush: python; html: collapse;">patch.dict(target, values = {}, [clear = False, **kwArgs])</pre>
<p>The <code>values</code> argument is a sequence of key/value pairs to patch into the target. The optional argument <code>clear</code> resets the target, removing all its entries prior to patching. And the <code>kwArgs</code> argument is another dictionary, whose entries are patched into the target.</p>
<p>
</p><p>The decorator <code>patch.multiple</code> enables you patch several target resources at a time.</p>
<p/><pre class="brush: python; html: collapse;">patch.multiple(target, mock1 = DEFAULT,...,mockN = DEFAULT, [spec|spec_set = None, autospec = None, new_callable = None, **kwArgs])</pre>
<p>
</p><p>The <code>target</code> argument sets the location of the target resources. Again, if the resources are in the same file as the decorator, set this argument to <code>"__main__"</code>. The arguments <code>mock1</code> to <code>mockN</code> are the targets. Setting a target to <code>DEFAULT</code> produces a <code>MagicMock</code> instance, with the same attributes as the target's. Setting a target to a class produces a callable class. The <code>patch.multiple</code> decorator uses the same optional arguments as the core decorator, but <code>patch.multiple</code> applies those arguments equally to all targets.</p>
<p>
</p><h3>The <code>MagicMock</code> class</h3>
<p>You may have noticed that all four patch decorators can use the <code>MagicMock</code> class to produce the patched resource. <code>MagicMock</code> is a subclass of <code>Mock</code>. It shares the same constructor arguments as <code>Mock</code>, as well as the same assert and history routines. However, <code>MagicMock</code> provides default implementations for a handful of magic methods.</p>
<p>
</p><p> Figure 1 shows the classes that form <code>MagicMock</code>. The <code>Mock</code> class supplies the properties, methods, and asserts that <code>MagicMock</code> needs. It is the same class I covered in <a href="http://www.drdobbs.com/testing/using-mocks-in-python/240168251">Using Mocks in Python</a>. The <code>MagicMixin</code> class also defines the return values for the magic methods.</p>
<p>
</p><p><img src="http://twimgs.com/ddj/images/article/2014/0814/cruzFigure1.gif" alt="patching mocks in python" title="PythonMocks"/><br/><b>Figure 1.</b></p>
<p>Table 1 lists some of those magic methods and their intended responses.</p>
<p>

</p><table border=".3" cellspacing="1" cellpadding="3">
  <tr>
    <td valign="top"><b>Magic Method</b></td>
    <td valign="top"><b>Default Response</b></td>
  </tr>
  <tr>
    <td valign="top"><p><code>__int__</code></p></td>
    <td valign="top"><p><code>1</code></p></td>
  </tr>
  <tr>
    <td valign="top"><p><code>__float__</code></p></td>
    <td valign="top"><p><code>1.0</code></p></td>
  </tr>
    <tr>
    <td valign="top"><p><code>__long__</code></p></td>
    <td valign="top"><p><code>1</code></p></td>
  </tr>
  <tr>
    <td valign="top"><p><code>__hex__</code></p></td>
    <td valign="top"><p><code>0x1</code></p></td>
  </tr>
    <tr>
    <td valign="top"><p><code>__str__</code></p></td>
    <td valign="top"><p><code>&lt;MagicMock id='499344'&gt;</code></p></td>
  </tr>
  <tr>
  <td valign="top"><p><code>__len__</code></p></td>
    <td valign="top"><p><code>0</code></p></td>
  </tr>
    <tr>
    <td valign="top"><p>__hash__</p></td>
    <td valign="top"><p><code>499344</code></p></td>
  </tr>
</table>
<p><b>Table 1.</b></p>
<p>
</p><p> Listing One shows some of those responses. The first five methods return the same numeric value of<code> 1</code>. The<code> __str__</code> method returns a <code>MagicMock</code> instance, the <code>__len__</code> method returns a <code>0</code>. And the <code>__hash__</code> method returns the object's unique ID (the same ID returned by <code>__str__</code>).</p>
<p><strong>Listing One</strong></p>
<p/><pre class="brush: python; html: collapse;">
from mock import Mock, MagicMock

# create mock object
fooMock = MagicMock()

# test magic methods
print int(fooMock)
# returns: 1
print float(fooMock)
# returns: 1.0
print oct(fooMock)
# returns: 1
print hex(fooMock)
# returns: 0x1
print long(fooMock)
#returns: 1

print str(fooMock)
#returns: &lt;MagicMock id='499344'&gt;
print len(fooMock)
# returns: 0
print hash(fooMock)
#returns: 499344

print fooMock == fooMock
#returns: True
print fooMock == MagicMock()
#returns: False
print fooMock != 'MagicMock'
#returns: True
print fooMock &gt; 'MagicMock'
#returns: False
print fooMock &lt; 'MagicMock'
#returns: True
</pre>
<p>
</p><p>However, other magic methods are not implemented. Methods such as<code>__init__</code>,<code> __getattr__</code>, and<code> __setattr__</code> are used by the parent class <code>Mock</code>. You must avoid changing these methods, lest you affect the mock's behavior. Methods such as <code>__bool__</code> and <code>__next__</code> are not implemented because these are specific to Python 3. Similarly, methods such as<code> __unicode__</code> and <code>__nonzero__</code> are not implemented because they are Python 2-specific.</p>
<p>	
		</p></article>
</div></body></html>