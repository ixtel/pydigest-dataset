<html><body><div><div class="post-text" itemprop="text">
<p><strong>[EDIT]</strong></p>

<p>Maybe the most interesting part of this question is <strong>Why I cannot patch <code>somefunction.__call__</code>?</strong> </p>

<p>Because the function don't use <code>__call__</code>'s code but <code>__call__</code> (a method-wrapper object) use function's code.</p>

<p>I don't find any well sourced documentation about that, but I can prove it (Python2.7):</p>

<pre><code>&gt;&gt;&gt; def f():
...     return "f"
... 
&gt;&gt;&gt; def g():
...     return "g"
... 
&gt;&gt;&gt; f
&lt;function f at 0x7f1576381848&gt;
&gt;&gt;&gt; f.__call__
&lt;method-wrapper '__call__' of function object at 0x7f1576381848&gt;
&gt;&gt;&gt; g
&lt;function g at 0x7f15763817d0&gt;
&gt;&gt;&gt; g.__call__
&lt;method-wrapper '__call__' of function object at 0x7f15763817d0&gt;
</code></pre>

<p>Replace <code>f</code>'s code by <code>g</code>'s code:</p>

<pre><code>&gt;&gt;&gt; f.func_code = g.func_code
&gt;&gt;&gt; f()
'g'
&gt;&gt;&gt; f.__call__()
'g'
</code></pre>

<p>Of course <code>f</code> and <code>f.__call__</code> references are not changed:</p>

<pre><code>&gt;&gt;&gt; f
&lt;function f at 0x7f1576381848&gt;
&gt;&gt;&gt; f.__call__
&lt;method-wrapper '__call__' of function object at 0x7f1576381848&gt;
</code></pre>

<p>Recover original implementation and copy <code>__call__</code> references instead:</p>

<pre><code>&gt;&gt;&gt; def f():
...     return "f"
... 
&gt;&gt;&gt; f()
'f'
&gt;&gt;&gt; f.__call__ = g.__call__
&gt;&gt;&gt; f()
'f'
&gt;&gt;&gt; f.__call__()
'g'
</code></pre>

<p>This don't have any effect on <code>f</code> function. <strong>Note:</strong> In Python 3 you should use <code>__code__</code> instead of <code>func_code</code>.</p>

<p>I Hope that somebody can point me to the documentation that explain this behavior. </p>

<p>You have a way to work around that: in <code>utils</code> you can define</p>

<pre><code>class Utcnow(object):
    def __call__(self):
        return datetime.datetime.utcnow()


utcnow = Utcnow()
</code></pre>

<p>And now your patch can work like a charm.</p>

<hr/>

<p>Follow the original answer that I consider even the best way to implement your tests.</p>

<p>I've my own <em>gold rule</em>: <strong>never patch protected methods</strong>. In this case the things are little bit smoother because protected method was introduced just for testing but I cannot see why. </p>

<p>The real problem here is that you cannot to patch <code>datetime.datetime.utcnow</code> directly (is C extension as you wrote in the comment above). What you can do is to patch <code>datetime</code> by wrap the standard behavior and override <code>utcnow</code> function:</p>

<pre><code>&gt;&gt;&gt; with mock.patch("datetime.datetime", mock.Mock(wraps=datetime.datetime, utcnow=mock.Mock(return_value=3))):
...  print(datetime.datetime.utcnow())
... 
3
</code></pre>

<p>Ok that is not really clear and neat but you can introduce your own function like</p>

<pre><code>def mock_utcnow(return_value):
    return mock.Mock(wraps=datetime.datetime, 
                     utcnow=mock.Mock(return_value=return_value)):
</code></pre>

<p>and now</p>

<pre><code>mock.patch("datetime.datetime", mock_utcnow(***))
</code></pre>

<p>do exactly what you need without any other layer and for every kind of import.</p>

<p>Another solution can be import <code>datetime</code> in <code>utils</code> and to patch <code>***.utils.datetime</code>; that can give you some freedom to change <code>datetime</code> reference implementation without change your tests (in this case take care to change <code>mock_utcnow()</code> <code>wraps</code> argument too).</p>
    </div>
    </div></body></html>