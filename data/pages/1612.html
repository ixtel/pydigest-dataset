<html><body><div><article class="markdown-body entry-content" itemprop="text"><pre><code>
     _____________________________/\/\______________________________/\/\_____
    _/\/\/\__/\/\____/\/\/\______/\/\______/\/\/\____/\/\__/\/\__/\/\/\/\/\_
   _/\/\/\/\/\/\/\______/\/\____/\/\____/\/\__/\/\__/\/\/\/\______/\/\_____
  _/\/\__/\__/\/\__/\/\/\/\____/\/\____/\/\__/\/\__/\/\__________/\/\_____
 _/\/\______/\/\__/\/\/\/\/\__/\/\/\____/\/\/\____/\/\__________/\/\/\___
________________________________________________________________________

</code></pre>

<h3><a id="user-content-malort-json---relational-db-column-types" class="anchor" href="#malort-json---relational-db-column-types" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Malort: JSON -&gt; Relational DB Column Types</h3>

<p>Malort is a tool for taking nested JSON data and trying to sniff out the appropriate relational db column types from the keys and values. It currently only supports Redshift, but the column mappers can be easily extended to other DBs.</p>

<h2><a id="user-content-the-problem" class="anchor" href="#the-problem" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>The Problem</h2>

<p>A producer is dumping semi-structured .json or delimited json blobs into a directory/S3 and you need to warehouse it somewhere. You don't know the schema, but want to find out if it's stable enough to break out into columns, or if you need to dump the whole blob into a JSON column type.</p>

<h2><a id="user-content-why" class="anchor" href="#why" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Why</h2>

<p>Because for (mostly) structured documents where we're expecting the schema to rarely change, we'd rather have the speed and familiar query/index-ability of table columns rather than dumping the entire blob into a single column.</p>

<h2><a id="user-content-how" class="anchor" href="#how" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>How</h2>

<p>Malort will read through a directory of .json or flat text files (optionally gzipped) with delimited JSON blobs and generate relevant statistics on each key. It uses the Dask libary to parallelize these computations.</p>

<p>For example, let's look at a directory with two JSON files, and one text file with newline-delimited JSON:</p>

<div class="highlight highlight-source-json"><pre>{<span class="pl-s"><span class="pl-pds">"</span>intfield<span class="pl-pds">"</span></span>: <span class="pl-c1">5</span>,
 <span class="pl-s"><span class="pl-pds">"</span>floatfield<span class="pl-pds">"</span></span>: <span class="pl-c1">2.345</span>,
 <span class="pl-s"><span class="pl-pds">"</span>parentkey<span class="pl-pds">"</span></span>: {
     <span class="pl-s"><span class="pl-pds">"</span>datefield<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>2014-09-26 17:00:00<span class="pl-pds">"</span></span>,
     <span class="pl-s"><span class="pl-pds">"</span>charfield<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>fixedlength<span class="pl-pds">"</span></span>
 },
 <span class="pl-s"><span class="pl-pds">"</span>varcharfield<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>var<span class="pl-pds">"</span></span>}

{<span class="pl-s"><span class="pl-pds">"</span>intfield<span class="pl-pds">"</span></span>: <span class="pl-c1">10</span>,
 <span class="pl-s"><span class="pl-pds">"</span>floatfield<span class="pl-pds">"</span></span>: <span class="pl-c1">4.7891</span>,
 <span class="pl-s"><span class="pl-pds">"</span>parentkey<span class="pl-pds">"</span></span>: {
     <span class="pl-s"><span class="pl-pds">"</span>datefield<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>2014-09-26 17:00:00<span class="pl-pds">"</span></span>,
     <span class="pl-s"><span class="pl-pds">"</span>charfield<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>fixedlength<span class="pl-pds">"</span></span>
 },
 <span class="pl-s"><span class="pl-pds">"</span>varcharfield<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>varyin<span class="pl-pds">"</span></span>}</pre></div>

<pre><code>{"intfield": 15,"floatfield": 3.0012,"parentkey":{"charfield": "fixedlength","datefield": "2014-09-26 17:00:00"}, "varcharfield": "varyingle"}
{"intfield": 20,"floatfield": 10.8392,"parentkey" :{"charfield": "fixedlength","datefield": "2014-09-26 17:00:00"},"varcharfield": "varyinglengt"}
</code></pre>

<p>Malort will calculate relevant statistics for each key, with both the base key and the nested key path:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">import</span> malort <span class="pl-k">as</span> mt
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> result <span class="pl-k">=</span> mt.analyze(<span class="pl-s"><span class="pl-pds">'</span>dir<span class="pl-pds">'</span></span>, <span class="pl-v">delimiter</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> result.stats
{<span class="pl-s"><span class="pl-pds">'</span>floatfield<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>base_key<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>floatfield<span class="pl-pds">'</span></span>,
                <span class="pl-s"><span class="pl-pds">'</span>float<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>count<span class="pl-pds">'</span></span>: <span class="pl-c1">4</span>,
                          <span class="pl-s"><span class="pl-pds">'</span>fixed_length<span class="pl-pds">'</span></span>: <span class="pl-c1">False</span>,
                          <span class="pl-s"><span class="pl-pds">'</span>max<span class="pl-pds">'</span></span>: <span class="pl-c1">10.8392</span>,
                          <span class="pl-s"><span class="pl-pds">'</span>max_precision<span class="pl-pds">'</span></span>: <span class="pl-c1">6</span>,
                          <span class="pl-s"><span class="pl-pds">'</span>max_scale<span class="pl-pds">'</span></span>: <span class="pl-c1">4</span>,
                          <span class="pl-s"><span class="pl-pds">'</span>mean<span class="pl-pds">'</span></span>: <span class="pl-c1">5.243</span>,
                          <span class="pl-s"><span class="pl-pds">'</span>min<span class="pl-pds">'</span></span>: <span class="pl-c1">2.345</span>}},
 <span class="pl-s"><span class="pl-pds">'</span>intfield<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>base_key<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>intfield<span class="pl-pds">'</span></span>,
              <span class="pl-s"><span class="pl-pds">'</span>int<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>count<span class="pl-pds">'</span></span>: <span class="pl-c1">4</span>, <span class="pl-s"><span class="pl-pds">'</span>max<span class="pl-pds">'</span></span>: <span class="pl-c1">20</span>, <span class="pl-s"><span class="pl-pds">'</span>mean<span class="pl-pds">'</span></span>: <span class="pl-c1">12.5</span>, <span class="pl-s"><span class="pl-pds">'</span>min<span class="pl-pds">'</span></span>: <span class="pl-c1">5</span>}},
 <span class="pl-s"><span class="pl-pds">'</span>parentkey.charfield<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>base_key<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>charfield<span class="pl-pds">'</span></span>,
                         <span class="pl-s"><span class="pl-pds">'</span>str<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>count<span class="pl-pds">'</span></span>: <span class="pl-c1">4</span>,
                                 <span class="pl-s"><span class="pl-pds">'</span>max<span class="pl-pds">'</span></span>: <span class="pl-c1">11</span>,
                                 <span class="pl-s"><span class="pl-pds">'</span>mean<span class="pl-pds">'</span></span>: <span class="pl-c1">11.0</span>,
                                 <span class="pl-s"><span class="pl-pds">'</span>min<span class="pl-pds">'</span></span>: <span class="pl-c1">11</span>,
                                 <span class="pl-s"><span class="pl-pds">'</span>sample<span class="pl-pds">'</span></span>: [<span class="pl-s"><span class="pl-pds">'</span>fixedlength<span class="pl-pds">'</span></span>,
                                            <span class="pl-s"><span class="pl-pds">'</span>fixedlength<span class="pl-pds">'</span></span>,
                                            <span class="pl-s"><span class="pl-pds">'</span>fixedlength<span class="pl-pds">'</span></span>]}},
 <span class="pl-s"><span class="pl-pds">'</span>parentkey.datefield<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>base_key<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>datefield<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>datetime<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>count<span class="pl-pds">'</span></span>: <span class="pl-c1">4</span>}},
 <span class="pl-s"><span class="pl-pds">'</span>varcharfield<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>base_key<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>varcharfield<span class="pl-pds">'</span></span>,
                  <span class="pl-s"><span class="pl-pds">'</span>str<span class="pl-pds">'</span></span>: {<span class="pl-s"><span class="pl-pds">'</span>count<span class="pl-pds">'</span></span>: <span class="pl-c1">4</span>,
                          <span class="pl-s"><span class="pl-pds">'</span>max<span class="pl-pds">'</span></span>: <span class="pl-c1">12</span>,
                          <span class="pl-s"><span class="pl-pds">'</span>mean<span class="pl-pds">'</span></span>: <span class="pl-c1">7.5</span>,
                          <span class="pl-s"><span class="pl-pds">'</span>min<span class="pl-pds">'</span></span>: <span class="pl-c1">3</span>,
                          <span class="pl-s"><span class="pl-pds">'</span>sample<span class="pl-pds">'</span></span>: [<span class="pl-s"><span class="pl-pds">'</span>varyin<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>varyingle<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>varyinglengt<span class="pl-pds">'</span></span>]}}}</pre></div>

<p>Malort has determined the type(s) for each key, as well as relevant statistics for that type. Malort can then be used to guess the Redshift column types:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> result.get_redshift_types()
{<span class="pl-s"><span class="pl-pds">'</span>parentkey.charfield<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>char(11)<span class="pl-pds">'</span></span>,
 <span class="pl-s"><span class="pl-pds">'</span>parentkey.datefield<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>TIMESTAMP<span class="pl-pds">'</span></span>,
 <span class="pl-s"><span class="pl-pds">'</span>varcharfield<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>varchar(12)<span class="pl-pds">'</span></span>,
 <span class="pl-s"><span class="pl-pds">'</span>floatfield<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>REAL<span class="pl-pds">'</span></span>,
 <span class="pl-s"><span class="pl-pds">'</span>intfield<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>SMALLINT<span class="pl-pds">'</span></span>}</pre></div>

<p>Malort supports the ability to print the entire result as a Pandas DataFrame:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> df <span class="pl-k">=</span> result.to_dataframe()
                   key      base_key  count      <span class="pl-c1">type</span>    mean      <span class="pl-c1">max</span>     <span class="pl-c1">min</span>  max_precision  max_scale fixed_length                                   sample redshift_types
<span class="pl-c1">0</span>  parentkey.charfield     charfield      <span class="pl-c1">4</span>       <span class="pl-c1">str</span>  <span class="pl-c1">11.000</span>  <span class="pl-c1">11.0000</span>  <span class="pl-c1">11.000</span>            NaN        NaN         <span class="pl-c1">None</span>  [fixedlength, fixedlength, fixedlength]       char(<span class="pl-c1">11</span>)
<span class="pl-c1">1</span>             intfield      intfield      <span class="pl-c1">4</span>       <span class="pl-c1">int</span>  <span class="pl-c1">12.500</span>  <span class="pl-c1">20.0000</span>   <span class="pl-c1">5.000</span>            NaN        NaN         <span class="pl-c1">None</span>                                     <span class="pl-c1">None</span>       <span class="pl-c1">SMALLINT</span>
<span class="pl-c1">2</span>         varcharfield  varcharfield      <span class="pl-c1">4</span>       <span class="pl-c1">str</span>   <span class="pl-c1">7.500</span>  <span class="pl-c1">12.0000</span>   <span class="pl-c1">3.000</span>            NaN        NaN         <span class="pl-c1">None</span>                 [var, varyin, varyingle]    varchar(<span class="pl-c1">12</span>)
<span class="pl-c1">3</span>           floatfield    floatfield      <span class="pl-c1">4</span>     <span class="pl-c1">float</span>   <span class="pl-c1">5.243</span>  <span class="pl-c1">10.8392</span>   <span class="pl-c1">2.345</span>              <span class="pl-c1">6</span>          <span class="pl-c1">4</span>        <span class="pl-c1">False</span>                                     <span class="pl-c1">None</span>           <span class="pl-c1">REAL</span>
<span class="pl-c1">4</span>  parentkey.datefield     datefield      <span class="pl-c1">4</span>  datetime     NaN      NaN     NaN            NaN        NaN         <span class="pl-c1">None</span>                                     <span class="pl-c1">None</span>      <span class="pl-c1">TIMESTAMP</span></pre></div>

<h2><a id="user-content-install" class="anchor" href="#install" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Install</h2>

<p><code>$ pip install malort</code></p>

<h2><a id="user-content-api" class="anchor" href="#api" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>API</h2>

<ul>
<li><code>result = malort.analyze(path, parse_timestamps=True)</code></li>
</ul>

<div class="highlight highlight-source-python"><pre>Analyze a given directory of either .json, flat text files
<span class="pl-k">with</span> newline<span class="pl-k">-</span>delimited <span class="pl-c1">JSON</span>, <span class="pl-k">or</span> gzipped files <span class="pl-k">with</span> newline<span class="pl-k">-</span>delimted <span class="pl-c1">JSON</span> to get relevant key statistics.

Parameters
<span class="pl-ii">----------</span>
path: string
    Path to directory
parse_timestamps: boolean, default <span class="pl-c1">True</span>
    If <span class="pl-c1">True</span>, will attempt to regex match <span class="pl-c1">ISO8601</span> formatted parse_timestamps</pre></div>

<ul>
<li><code>result.stats</code>: Dictionary of key statistics</li>
<li><code>result.get_conflicting_types</code>: Return only stats where there are multiple types detected for a given key</li>
<li><code>result.get_redshift_types</code>: Guess the Amazon Redshift column types for the result keys</li>
<li><code>result.gen_redshift_jsonpaths</code>: Generate Redshift <a href="http://docs.aws.amazon.com/redshift/latest/dg/r_COPY_command_examples.html#copy-from-json-examples-using-jsonpaths">jsonpaths</a> file</li>
<li><code>result.to_dataframe</code>: Export the result set to a dataframe</li>
<li><code>result.get_cleaned_column_names</code>: Clean up the result keys into underscored/camel-cased column names</li>
</ul>

<h2><a id="user-content-adding-new-type-mappers" class="anchor" href="#adding-new-type-mappers" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Adding New Type Mappers</h2>

<p>New type mappers must have functions that map from a given input type (bool, str, int, float, date) to a database column type. For example, the <code>RedshiftMapper</code> integer mapper:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-en">@</span><span class="pl-c1">staticmethod</span>
<span class="pl-k">def</span> <span class="pl-en">ints</span>(<span class="pl-smi">stat</span>):
    <span class="pl-k">if</span> stat[<span class="pl-s"><span class="pl-pds">'</span>min<span class="pl-pds">'</span></span>] <span class="pl-k">&gt;</span> <span class="pl-k">-</span><span class="pl-c1">32768</span> <span class="pl-k">and</span> stat[<span class="pl-s"><span class="pl-pds">'</span>max<span class="pl-pds">'</span></span>] <span class="pl-k">&lt;</span> <span class="pl-c1">32767</span>:
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>SMALLINT<span class="pl-pds">'</span></span>
    <span class="pl-k">elif</span> stat[<span class="pl-s"><span class="pl-pds">'</span>min<span class="pl-pds">'</span></span>] <span class="pl-k">&gt;</span> <span class="pl-k">-</span><span class="pl-c1">2147483648</span> <span class="pl-k">and</span> stat[<span class="pl-s"><span class="pl-pds">'</span>max<span class="pl-pds">'</span></span>] <span class="pl-k">&lt;</span> <span class="pl-c1">2147483647</span>:
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>INTEGER<span class="pl-pds">'</span></span>
    <span class="pl-k">else</span>:
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>BIGINT<span class="pl-pds">'</span></span></pre></div>

<p>This allows malort to be easily extended to other Databases.</p>

<h2><a id="user-content-why-is-it-named-malort" class="anchor" href="#why-is-it-named-malort" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Why is it named Malort?</h2>

<p>Because this is kind of a distasteful thing to do in the first place.</p>

<h2><a id="user-content-couldnt-i-have-done-this-with-sedawkxargsmapreduce" class="anchor" href="#couldnt-i-have-done-this-with-sedawkxargsmapreduce" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Couldn't I have done this with sed/awk/xargs/mapreduce?</h2>

<p>Yes.</p>

<h2><a id="user-content-how-fast-is-it" class="anchor" href="#how-fast-is-it" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>How fast is it?</h2>

<p>With timestamp parsing turned on, I used Malort to process 2.1 GB of files (1,326,794 nested JSON blobs) in 8 minutes. There are undoubtedly ways to do it faster. Speed will depend on a number of factors, including nesting depth.</p>

<h2><a id="user-content-should-i-use-the-column-type-results-verbatim" class="anchor" href="#should-i-use-the-column-type-results-verbatim" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Should I use the column type results verbatim?</h2>

<p>Probably not- they're meant to be a guide, not a CREATE TABLE statement. It's up to you to determine whether your data represents a large and representative enough sample to set fixed-width columns with certainty, or whether you might anticipate schema changes in the future. Like a lot of data tools, it's meant to help guide your engineering judgement. Additionally, it does round/truncate statistics to three decimal points, so there will be floating point errors in the calculation.</p>
</article>
  </div></body></html>