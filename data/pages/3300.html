<html><body><div><div class="ibm-col-6-4"> 
    <p>If you have a basic understanding of Python, and want to develop web
                applications from scratch and deploy them to IBM® Bluemix®, then
                this tutorial is for you. Learn about development using the Pyramid
                framework and its security model, real-time communication using Socket.IO
                abstraction, and integration with SQLAlchemy. SQLAlchemy provides an easy
                way to integrate with database services in the Bluemix environment.</p><p> By systematically adding one feature at a time, you create the Chatter
                chat app where users can exchange messages in real time. Messages are
                stored in a database. Upon login, users see the last 10 messages exchanged
                in the app. Login is simply for identification purposes — no
                passwords, but the approach is applicable for typical authentication and
                authorization requirements.</p><div class="dw-article-ps-hbox"><h2 id="1.2.Whatyoullneedtobuildyourapplication|outline">What
                you need to build your application</h2><p id="cmt_3" class="cmt_icon"/><p class="cmt_arrow"> </p></div><div class="dw-article-ps-hbox"><h2 id="1.3.Step1.InstallingPyramidandcfclient|outline">Step 1.
                Install Pyramid and the CF client</h2><p id="cmt_4" class="cmt_icon"/><p class="cmt_arrow"> </p></div><p>For Ubuntu/Debian installation:</p><ol><li>Download the <a href="https://github.com/cloudfoundry/cli#downloads">CF client</a> as a Stable Installers for Debian.</li><li>As a root, install CF client: <code>dpkg -i cf-cli_*.deb</code>.</li><li>As a root, install Python package manager, development environment,
                    and virtual environment:
                    <code>apt-get install python-pip python-dev python-virtualenv</code>.</li><li>As a regular user, set up a personal virtual environment:
                    <code>virtualenv $HOME/venv</code>.</li><li>Activate your virtual environment:
                        <code>. $HOME/venv/bin/activate</code>.<p> Sourcing the activate
                        file ensures that Python and pip are used from the virtual
                        environment.</p></li><li>Install the Pyramid framework: <code>pip install pyramid</code>.</li></ol><p>For Windows® installation:</p><ol><li>Download the <a href="https://github.com/cloudfoundry/cli#downloads">CF client</a> as Stable Installers for Windows.</li><li>Unzip and run the cf_installer.exe file.</li><li>Download the <a href="https://www.python.org/downloads/release/python-279/">Python
                        MSI installer</a> for your platform.</li><li>When installing the downloaded file, select <strong>Install just for
                        me</strong> on the first page and add <strong>Add python.exe to
                        Path</strong> on the Customize Python page.</li><li>Download and install <a href="http://aka.ms/vcpython27">MS Visual C++
                        Compiler for Python 2.7</a>. </li><li>Open an MS-DOS prompt and install the Pyramid framework:
                    <code>pip install pyramid</code>.</li></ol><p class="dw-article-ps-see-blk"><span class="dw-article-ps-see-head">READ:</span><a class="dw-article-ps-see" href="http://pyramid.readthedocs.org/">Pyramid documentation</a></p><div class="dw-article-ps-hbox"><h2 id="1.4.Step2.CreatefirstdraftofChatter|outline">Step 2.
                Create a first draft of Chatter</h2><p id="cmt_5" class="cmt_icon"/><p class="cmt_arrow"> </p></div><p> Pyramid provides different templates (scaffolds). Use the SQLAlchemy
                scaffold to create a Pyramid project for this example:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">pcreate -s alchemy Chatter
cd Chatter</pre></div><p>I changed the current directory into the created directory because this
                tutorial assumes paths relative to that directory.</p><p>Use the following files:</p><table border="0" cellpadding="0" cellspacing="0" class="ibm-data-table"><thead xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th scope="col">File</th><th scope="col">Description</th></tr></thead><tbody xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th class="ibm-table-row" scope="row">development.ini</th><td>Configuration file to run the app in development
                        mode</td></tr><tr><th class="ibm-table-row" scope="row">production.ini</th><td>Configuration file to run the app in production
                        mode</td></tr><tr><th class="ibm-table-row" scope="row">setup.py</th><td>Script to
                            set up the app before it can run and to package it for
                            distribution</td></tr><tr><th class="ibm-table-row" scope="row">chatter/__init__.py</th><td>Contains code to configure the
                            app</td></tr><tr><th class="ibm-table-row" scope="row">chatter/models.py</th><td>Contains the app model (classes
                            handling access to a database)</td></tr><tr><th class="ibm-table-row" scope="row">chatter/views.py</th><td>Contains <code>view-callable</code>
                            methods controlling logic of the app</td></tr><tr><th class="ibm-table-row" scope="row">chatter/static
                            directory</th><td>Contains static resources used by the
                            app</td></tr><tr><th class="ibm-table-row" scope="row">chatter/templates
                            directory</th><td>Contains page templates used by the
                            app</td></tr></tbody></table><p class="dw-article-ps-see-blk"><span class="dw-article-ps-see-head">READ:</span><a class="dw-article-ps-see" href="http://sqlalchemy.readthedocs.org/">SQLAlchemy documentation</a></p><p>The project uses package references to itself. For the references to work
                correctly, install it in development mode, which also installs all the
                extra dependencies described in the required list in the setup.py
                file:</p><p>Start the app:</p><p>This command reports the process running the app and the URL from which the
                app can be accessed, then waits to be stopped with the &lt;Ctrl&gt;-C key
                combination.</p><p> The default server configuration in production.ini is to listen on port
                6543 (see the <code>port</code> parameter in the file), so access it from
                a browser at <a href="http://localhost:6543/">http://localhost:6543</a>.</p><p>Instead of a fancy page, the browser displays a message that tables in the
                database are not initialized. In lieu of a separate step to create
                database tables, for this app I recommend that you do it on application
                startup. In the chatter/__init__.py file, change the line
                <code>Base.metadata.bind = </code><code>engine</code> to: </p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">    Base.metadata.create_all(bind = engine)</pre></div><p>All tables extending the <code>Base</code> class are created but only if
                they do not exist already. By default the production.ini file has
                <code>sqlalchemy.url = sqlite:///%(here)s/Chatter.sqlite</code> specified
                for the database, which means all data is stored in the Chatter.sqlite
                file. Whenever you change the model, you can simply remove that file
                before starting the app.</p><p>Because there is not a separate step to create tables in the database,
                remove the chatter/scripts
                directory:<br/><code>rm -rf chatter/scripts</code> (Unix)
                or<br/><code>rmdir /s/q chatter\scripts</code> (Windows)</p><div class="dw-article-ps-sidebar"><p><strong>For Python newcomers</strong></p><p>When you copy and paste code, Python uses indentation to delimit blocks
                    of code. An increase in indentation means start of a block, and a
                    decrease signifies the end of the current block. Change in indentation
                    can contain any number of white spaces but it should be the same
                    amount for the whole block.</p></div><p>You are updating static files during this tutorial, so let's disable their
                caching (you enable it at the end). In chatter/__init__.py in the
                <code>config.add_static_view()</code> call, change the
                <code>cache_max_age=3600</code> parameter to
                <code>cache_max_age=0</code>.</p><p>Start the app and access it in a browser, where you should see the Pyramid
                SQLAlchemy scaffold welcome page.</p><div class="dw-article-ps-hbox"><h3 id="1.4.0.1.AddingMessageclasstomodel|outline">Add
                <code>Message</code> class to model</h3><p id="cmt_15" class="cmt_icon"/><p class="cmt_arrow"> </p></div><p>Messages in the app are stored in a database. The data structure to use is
                declared in the chatter/models.py file. The file already contains an
                example of a class, but you need to change it to something useful for your
                purpose. Remove all lines starting with
                <code>class
                MyModel(Base):</code> through the end of file.
                Add the following lines instead:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">import datetime

from sqlalchemy import (
    Sequence,
    DateTime,
    )

class Message(Base):
    __tablename__ = 'messages'
    id = Column(Integer, Sequence('msid', optional=True), primary_key=True)
    text = Column(Text, nullable=False)
    created = Column(DateTime, default=datetime.datetime.utcnow)

    def __init__(self, text):
        self.text = text</pre></div><p>This code declares a class for accessing table <code>'messages'</code>
                (indicated by the <code>__tablename__</code> attribute), which contains
                three columns: <code>id</code> (primary key, Integer type),
                <code>text</code> (Text type), and <code>created</code> (DateTime type).
                The class extends the <code>Base</code> class (declared in the
                chatter/model/meta.py file) to integrate it with the SQLAlchemy framework
                and to add it into metadata held by the <code>Base</code> instance. The
                <code>Sequence()</code> call makes the <code>id</code> column have
                auto-incremented value.</p><p> The <code>created</code> attribute uses the default value of the time the
                instance is created. I use <code>datetime.datetime.utcnow</code> to store
                time with a Time Zone independent value. Also, note that it is a reference
                to a function and not a call to this function. If you made it into a call
                by changing it to <code>datetime.datetime.utcnow()</code>, the default
                value is the time declaration when the <code>Message</code> class was
                initialized instead of the time of each <code>Message</code> instance.</p><p> Now that you removed <code>MyModel</code>, remove Chatter.sqlite.</p><div class="dw-article-ps-hbox"><h3 id="1.4.0.2.Addingmessageview-callable|outline">Add message
                <code> view callable</code></h3><p id="cmt_16" class="cmt_icon"/><p class="cmt_arrow"> </p></div><p><code>View callable</code> in Pyramid processes artifacts' requests into
                responses. Change the content of the chatter/views.py file to the
                following:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">from pyramid.httpexceptions import HTTPFound
from pyramid.view import view_config
import transaction

from .models import (
    DBSession,
    Message,
    )

@view_config(route_name='home', renderer='templates/messages.pt')
def index(request):
    messages = DBSession.query(Message).order_by(Message.created)[-10:]
    return {'messages': messages}

@view_config(route_name='send')
def send(request):
    text = request.params.get('message')
    with transaction.manager:
        message = Message(text)
        DBSession.add(message)
    return HTTPFound(location=request.route_url('home'))</pre></div><p>The <code>index</code> callable is associated with route
                <code>'home'</code>, which is by default associated with the
                <code>/</code> URL of the app. It retrieves up to the last 10 messages
                from the database using the <code>Message</code> class declared in the
                chatter/model.py file and returns them as a <code>'message'</code>
                parameter for the rendering template templates/messages.pt.</p><p>The <code>send</code> callable is associated with <code>'send'</code> route
                (to be added in the next step). It processes submit requests from the form
                in the templates/messages.pt file by simply inserting a new row using
                <code>DBSession</code> and <code>Message</code> classes and redirecting
                the request back to the <code>'home'</code> route. Doing redirection after
                a POST type of submit is a good practice to avoid duplicate submissions of
                the form when a user reloads the page. I use <code>route_url</code> to
                find the redirection location to make this code independent of what the
                URL route <code>'home'</code> is mapped to.</p><p> Add the mapping for route <code>'send'</code> into the chatter/__init__.py
                file (add it before the <code>config.scan()</code> line):</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">    config.add_route('send', '/send')</pre></div><p>To avoid having files you won't use, remove all templates and static files
                before
                proceeding:<br/><code>rm -f chatter/templates/* chatter/static/*</code>
                (UNIX) or <br/><code>del /q chatter\templates chatter\static</code>
                (Windows)</p><p> It's there by default, so let's use the Chameleon rendering engine for the
                templates. Create a chatter/templates/messages.pt file (the .pt extension
                indicates that it should be processed by the Chameleon engine) with the
                following content:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Messages&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="/static/messages.css"/&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="chatlog"&gt;
      &lt;ul&gt;
        &lt;li tal:repeat="m messages" tal:content="m.text" /&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;hr/&gt;
    &lt;form action="${request.route_url('send')}" method="post"&gt;
      &lt;input id="send" name="send" type="submit" value="Send" /&gt;
      &lt;input id="message" name="message" type="text" /&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>This template creates a page containing the listing of all the messages
                passed to it from the view callable and a form to send messages to the
                <code>'send'</code> route. The <code>tal:repeat="m messages"</code>
                attribute is a Chameleon way of creating a &lt;li&gt; element for each
                item in the array <code>'messages'</code> using the <code>'m'</code>
                variable for each item. The <code>tal:content="m.text"</code> attribute
                tells the template engine to put the value of <code>"m.text"</code> inside
                the element (between &lt;li&gt; and &lt;/li&gt;).</p><p>To make text look more like a message exchange than an unordered list of
                items, create the chatter/static/messages.css stylesheet with the
                following content:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">#chatlog &gt; ul {
  padding: 0 0;
  list-style-type: none;
}</pre></div><p>OK, that's the first iteration of the app. Start it with the
                <code>pserve production.ini</code> command and access it using <a href="http://localhost:6543/">http://localhost:6543</a>. Clicking the
                Send button shows the last 10 messages from the database. If more than one
                user accesses this page, they see each other's messages.</p><p>Use tag step2-first-draft in the Git repository to see the code up to this
                point.</p><p class="dw-article-ps-see-blk"><span class="dw-article-ps-see-head">READ:</span><a class="dw-article-ps-see" href="https://chameleon.readthedocs.org/">Chameleon template language</a></p><div class="dw-article-ps-hbox"><h2 id="1.5.Step3.MakingChattermoredynamicwithSocketIO|outline">Step 3. Make Chatter more dynamic with SocketIO</h2><p id="cmt_6" class="cmt_icon"/><p class="cmt_arrow"> </p></div><p>When there is more than one user sending messages, the app thus far is not
                very useful because each user sees other messages only when they send
                their own. Let's make messages appear right away for all users connected
                to the server. You need to add support for SocketIO abstract (originally
                developed for NodeJS).</p><p>First, adjust how the app is started. The <code>pserve</code> command does
                not let you choose a server so you need to have your own starter script.
                Create the serve.py file in the current directory with the following
                lines:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">import os
from paste.deploy import loadapp
from socketio.server import serve
from gevent import monkey; monkey.patch_all()

if __name__ == '__main__':

    app = loadapp('config:production.ini', relative_to=os.getcwd())
    try:
        serve(app, host='0.0.0.0')
    except KeyboardInterrupt:
        pass</pre></div><p>You also need to install the package containing <code>socketio</code>. Add
                the line <code>gevent-socketio,</code> into the requires[] list in the
                setup.py file and run <code>python setup.py develop</code> again.</p><p>This script uses SocketIOServer implementation instead of the default
                WSGIServer to listen for requests. Test the script now by running
                <code>python serve.py</code> to see that the app still behaves the same
                way.</p><div class="dw-article-ps-hbox"><h3 id="1.5.0.2.UpdatingserversideofSocketIO|outline">Update
                server side of SocketIO</h3><p id="cmt_19" class="cmt_icon"/><p class="cmt_arrow"> </p></div><p>To change how the <code>send</code> callable handles the incoming
                requests, replace the declaration of the method <code>send</code>
                (starting with the line <code>@view_config(route_name='send')</code> to
                the end of the file) in the chatter/views.py with:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">from socketio import socketio_manage
from socketio.mixins import BroadcastMixin
from socketio.namespace import BaseNamespace
from pyramid.response import Response

@view_config(route_name='send')
def send(request):
    socketio_manage(request.environ, {'/chat': ChatNamespace}, request)
    return Response('')

class ChatNamespace(BroadcastMixin, BaseNamespace):
    def on_chat(self, text):
        with transaction.manager:
            message = Message(text)
            DBSession.add(message)
            self.broadcast_event('chat', text)</pre></div><p>Requests to the <code>send</code> route are now handled in a special
                SocketIO way, delegating handling of requests on <code>/chat</code> name space to the
                <code>ChatNamespace</code> class. In turn, <code>ChatNamespace</code>
                handles <code>chat</code> events by adding messages to the database and
                broadcasting message text to all clients connected to the server.</p><p> The SocketIO requests are sent via a special path starting with
                <code>/socket.io/</code>, so adjust the mapping you have for <code>send</code>
                route in chatter/__init__.py as well. Change the line
                <code>config.add_route('send', '/send')</code> to:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">    config.add_route('send', '/socket.io/*remaining')</pre></div><div class="dw-article-ps-hbox"><h3 id="1.5.0.3.UpdatingclientsideofSocketIO|outline">Update
                client side of SocketIO</h3><p id="cmt_20" class="cmt_icon"/><p class="cmt_arrow"> </p></div><p>The changes above took care of the server side of the SocketIO
                communication. For the client, adjust the template and add JavaScript to
                handle SocketIO exchange.</p><p>Change form declaration (between <code>&lt;form&gt;</code> and
                <code>&lt;/form&gt;</code> elements) in chatter/templates/messages.pl
                to:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">    &lt;form id="chatform"&gt;
      &lt;input id="send" name="send" type="submit" value="Send" /&gt;
      &lt;input id="message" name="message" type="text" /&gt;
    &lt;/form&gt;
    &lt;script src="//cdn.jsdelivr.net/jquery/2.1.1/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/socket.io/0.9.16/socket.io.min.js"&gt;&lt;/script&gt;
    &lt;script src="/static/chat.js" type="text/javascript"&gt;&lt;/script&gt;</pre></div><p>I added <code>id</code> to the submission form for JavaScript code to
                find it, and added a set of JavaScript files. The jquery.min.js is there
                to simplify finding elements on the page.</p><p><strong>Note:</strong> Use socket.io.js version 0.9.16 because the
                <code>gevent-socketio</code> implementation supports, or is compatible with, that
                version. Version 1.0 of socket.io.js introduced changes that are
                incompatible with the previous versions of SocketIO. </p><p> The chat.js script handles SocketIO for the app, so create it in
                chatter/static/chat.js with:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">$(document).ready(function() {
  var socket = io.connect('/chat')

  $(window).bind("beforeunload", function() {
    socket.disconnect();
  });

  var chatlog = $("#chatlog&gt;ul")

  var addMessage = function(data) {
    chatlog.append($('&lt;li&gt;').append(data));
  }

  socket.on("chat", function(e) {
    addMessage(e);
    chatlog.scrollTop(chatlog.height());
  });

  $("#chatform").submit(function(e) {
    // don't allow the form to submit
    e.preventDefault();

    // send out the "chat" event with the textbox as the only argument
    socket.emit("chat", $("#message").val());
    $("#message").val("");
  });
});</pre></div><p>The script:</p><ul class="ibm-bullet-list"><li>Connects to the '/chat' name space (the same space that
                    <code>ChatNamespace</code> is mapped to in the <code>send</code>
                    view callable).</li><li>Listens for chat events (broadcast by <code>ChatNameserver</code> in
                    the <code>on_chat</code> method) to append the
                    <code>'&lt;li&gt;'</code> element with received data to
                    <code>chatlog</code>.</li><li>Emits chat events (handled by <code>ChatNameserver</code> with the
                    <code>on_chat</code> method) when <code>chatform</code> is submitted.</li></ul><p> If you start the app now with <code>python serve.py</code>, messages from
                all users connected to the app are displayed right away. Notice that
                <code>chatform</code> is getting pushed down with every new message,
                which is not what chat apps usually do. Add the necessary style properties
                into chatter/static/messages.css (the new file content):</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">#chatlog &gt; ul {
  padding: 0 0;
  list-style-type: none;
  height: 200pt;
  overflow-y: scroll;
}
#message {
  width: 80%;
}</pre></div><p>Now it should feel more like a chat app.</p><p>Use tag step3-add-socketio in the Git repository to see the code up to this
                point.</p><p class="dw-article-ps-see-blk"><span class="dw-article-ps-see-head">READ:</span><a class="dw-article-ps-see" href="https://gevent-socketio.readthedocs.org/">Socket.IO in Python</a></p><div class="dw-article-ps-hbox"><h2 id="1.6.Step4.AddinguserstoChatter|outline">Step 4. Add
                users to Chatter</h2><p id="cmt_7" class="cmt_icon"/><p class="cmt_arrow"> </p></div><p>To require login before users can join the chat:</p><ol><li>Enable authentication and authorization policies for your app.</li><li>Require permission to access the view callables.</li><li>Map users to the permission principal.</li><li>Add a login view to let users authenticate themselves.</li></ol><p>Add the following lines into chatter/__init__.py before declaration of the
                function <code>main</code>:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">from pyramid.security import Allow, Everyone
from pyramid.authentication import AuthTktAuthenticationPolicy
from pyramid.authorization import ACLAuthorizationPolicy

class Root:
    __acl__ = [ (Allow, 'group:view', 'view') ]
    def __init__(self, request):
        pass

def groupfinder(userid, request):
    return ['group:view']</pre></div><p>This code adds the <code>Root</code> class, which is used as a context for
                all requests to the app. It gives members of <code>'group:view'</code>
                permission <code>'view'</code> and forbids access to everybody else. The
                function <code>groupfinder</code> is added for retrieving a list of
                groups that <code>userid</code> belongs to. All users in the app belong to
                <code>'group:view'</code>.</p><p> To start using these objects in the app, in the same file
                (chatter/__init__.py) in the <code>main</code> function change line
                <code>config = Configurator(settings=settings)</code> to:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">    config = Configurator(root_factory=Root, settings=settings)
    config.set_authentication_policy(AuthTktAuthenticationPolicy(
        'chattersecret', groupfinder, hashalg='sha512'))
    config.set_authorization_policy(ACLAuthorizationPolicy())
    config.set_default_permission('view')
    config.add_route('logout', '/logout')</pre></div><p>The <code>Root</code> class is now set as a root context for the app. The
                code also set policy to use <code>auth_tkt</code> cookies for
                authentication information (due to the
                <code>AuthTktAuthenticationPolicy</code> instance), which is encrypted
                using <code>'chattersecret'</code> as a keyword (should be unique for each
                application) and hashed using the <code>'sha512'</code> algorithm. It uses
                the <code>groupfinder</code> method as a callback to find groups users
                belong to using authentication information. The code uses ACL for
                authorization policy, which means access to a context object is specified
                as <code>'__acl__'</code> class attribute.</p><p> If you try to run the app now you get the <code>403 Forbidden</code> error because
                you didn't provide a way for users to authenticate themselves. You need to
                add <code>forbidden_view</code> into chatter/views.py. Add the following
                lines to the end of the file:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">from pyramid.view import forbidden_view_config
from pyramid.security import remember, forget

@forbidden_view_config(renderer='templates/login.pt')
def login(request):
    error = ''
    if 'login' in request.params:
        username = request.params['username']
        if not username:
            error = "user name can not be empty"
        else:
            headers = remember(request, username)
            return HTTPFound(location=request.route_url('home'),
                headers=headers)
    return {'error': error}

@view_config(route_name="logout")
def logout(request):
    headers = forget(request)
    return HTTPFound(location=request.route_url('home'), headers=headers)</pre></div><p>The <code>forbidden_view_config</code> decorator makes the app call this
                view callable instead of returning the default forbidden error page. The
                same callable is also used when the login page is submitted. The presence
                of <code>'login'</code> (the name of the submit button in login.pt) is
                used to distinguish between these two events. For now, let's simply ensure
                that the provided username is not an empty string. If that condition is
                satisfied, the user information is stored and the call back is redirected
                to <code>'home'</code>. Otherwise, it goes back to the login page with an
                error message.</p><p>The <code>logout</code> callable allows user to request to be
                "forgotten."</p><p>Add the template for the login page into the chatter/templates/login.pt
                file:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Login&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="/static/login.css" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;span id="error" tal:condition="error" tal:content="error" /&gt;
    &lt;form method="post"&gt;
Username: &lt;input id="username" name="username" type="text" /&gt;
      &lt;input id="login" name="login" value="Login" type="submit" /&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p><code>tal:condition="error" tal:content="error"</code> means that this
                <code>span</code> element is added only if the <code>error</code>
                value is not empty. The content of the element is <code>error</code>'s
                value. In all other aspects, this template is a simple login form.</p><p>To make error messages stand out, create the chatter/static/login.css file
                with:</p><p>Users need the ability to logout, so add the following into
                chatter/templates/messages.pl after the <code>chatform</code>:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">    &lt;form action="${request.route_url('logout')}" method="post"&gt;
 ${request.authenticated_userid}: &lt;input id="logout" type="submit" value="Logout" /&gt;
    &lt;/form&gt;</pre></div><p> You should be able to login to the app by simply specifying your name
                now.</p><p>Use tag step4a-add-login in the Git repository to see the code up to this
                point.</p><div class="dw-article-ps-hbox"><h3 id="1.6.0.2.AddingUserclasstomodel|outline">Add user class
                to the model</h3><p id="cmt_22" class="cmt_icon"/><p class="cmt_arrow"> </p></div><p>These changes thus far still don't associate messages with their
                originator. You need to add users into the model and associate messages to
                them. In chatter/models.py, added <code>User</code> and updated
                <code>Message</code> classes are shown below (replace lines starting with
                <code>class Message(Base)</code> through the end of the file):</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">from sqlalchemy import (
    Unicode,
    ForeignKey,
    )
from sqlalchemy.orm import relation

class Message(Base):
    __tablename__ = 'messages'
    id = Column(Integer, Sequence('msid', optional=True), primary_key=True)
    text = Column(Text, nullable=False)
    created = Column(DateTime, default=datetime.datetime.utcnow)
    userid = Column(Integer, ForeignKey('users.id'), nullable=False)

    def __init__(self, user, text):
        self.user = user
        self.text = text

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, Sequence('usid', optional=True), primary_key=True)
    name = Column(Unicode(255))
    messages = relation(Message, backref="user")

    def __init__(self, name):
        self.name = name</pre></div><p>Note the addition of the <code>userid</code> attribute as a
                <code>ForeignKey</code> for the <code>'users.id'</code> column, indicated
                via table name used by the <code>User</code> class. The same relationship
                is used in the declaration of the <code>messages</code> attribute of the
                <code>User</code> class. The call to <code>relation(Message)</code>
                creates a query attribute that returns an array of <code>Message</code>
                instances whose foreign key matches <code>User</code>'s primary key. The
                <code>backref="user"</code> option causes the addition of a
                <code>user</code> attribute on the <code>Message</code> class, returning
                the <code>User</code> instance that the foreign key refers to.</p><p>The database model was changed, so recreate the database. Simply delete the
                old database (Chatter.sqlite file) and it is recreated with the proper
                model on the next run of the app.</p><p> To adjust the <code>login</code> and <code>messages</code> callables to
                take user information into account, and avoid user duplication, store
                <code>userid</code> instead of <code>username</code> in the request. In
                chatter/views.py, change the line
                <code>headers = remember(request, username)</code> in the declaration for
                the <code>login</code> method to:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">            with transaction.manager:
                users = DBSession.query(User).filter_by(name=username).all()
                if users:
                    user = users[0]
                else:
                    user = User(name=username)
                    DBSession.add(user)
                    DBSession.flush()
                headers = remember(request, user.id)</pre></div><p>The <code>remember</code> call should be in the scope of
                <code>with
                transaction.manager</code> or else it won't be
                able to access <code>User</code> instance attributes. Also, the call to
                <code>DBSession.flush()</code> is added so that a request to add a user is
                passed to the database to create a new userid, thus making it available
                for retrieval from the <code>user</code> instance.</p><p> The next change should be made in the code handling <code>chat</code>
                events because the <code>Message</code> instance now requires User to be
                specified. The updated <code>on_chat</code> method of the
                <code>ChatNamespace</code> class should look like this:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">    def on_chat(self, text):
        with transaction.manager:
            user = DBSession.query(User).get(self.request.authenticated_userid)
            if user:
                message = Message(user, text)
                DBSession.add(message)
                self.broadcast_event('chat', text)</pre></div><p>Correct the name you use before the <code>Logout</code> button. For this,
                send the user's name as another entry to the template. Change the
                declaration for the <code>index</code> method to:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">from .models import User

@view_config(route_name='home', renderer='templates/messages.pt')
def index(request):
    user = DBSession.query(User).get(request.authenticated_userid)
    if user:
        messages = DBSession.query(Message).order_by(Message.created)[-10:]
        return {'messages': messages, 'username': user.name}
    else:
        return logout(request)</pre></div><p>You also need to update chatter/templates/messages.pt with the following
                line for the <code>logout</code> submit button:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">${username}: &lt;input id="logout" type="submit" value="Logout" /&gt;</pre></div><p>Now the app works as before but stores the association between a user and a
                message.</p><p>Use tag step4b-user-info in the Git repository to see the code up to this
                point.</p><div class="dw-article-ps-hbox"><h3 id="1.6.0.3.Addinguserandtimedatatochatevent|outline">Add
                user and time data to chat event</h3><p id="cmt_23" class="cmt_icon"/><p class="cmt_arrow"> </p></div><p>The whole point of having an association between a user and a message is to
                have it available in the output. Let's adjust the SocketIO request to have
                this information available to the browser.</p><p>You have a more complicated structure than a simple string passed to the
                client, so let's do formatting of the initial historic messages on the
                client as well. To accommodate this and avoid code duplication, change the
                <code>chat</code> request to always send an array of message objects
                instead of just one object. Change the declaration for the
                <code>ChatNamespace</code> class in chatter/views.py to the following:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">def mToD(message):
    return {'who': message.user.name,
            'when': message.created.isoformat(),
            'what': message.text}

class ChatNamespace(BroadcastMixin, BaseNamespace):
    def recv_disconnect(self):
        self.disconnect(silent=True)

    def on_history(self):
        self.emit('chat', [mToD(m) for m in DBSession.query(Message).order_by(
                  Message.created)[-10:]])

    def on_chat(self, text):
        with transaction.manager:
            user = DBSession.query(User).get(self.request.authenticated_userid)
            if user:
                message = Message(user, text)
                DBSession.add(message)
                DBSession.flush()
                self.broadcast_event('chat', [mToD(message)])</pre></div><p>You also need to remove adding of messages in the <code>index</code>
                method. Change it to:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">def index(request):
    user = DBSession.query(User).get(request.authenticated_userid)
    if user:
        return {'username': user.name}
    else:
        return logout(request)</pre></div><p>Remove their addition in chatter/templates/messages.pt as well. Remove the
                following line:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">        &lt;li tal:repeat="m messages" tal:content="m.text" /&gt;</pre></div><p>Here are the corresponding changes in chatter/static/chat.js (just the
                changed lines with the <code>addMessage</code> function declaration and
                handler for <code>chat</code> events):</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">  var prevDateString = '';

  var addMessage = function(data) {
    currDate = new Date(data.when);
    currDateString = currDate.toDateString()
    if (currDateString !== prevDateString) {
      chatlog.append($('&lt;li&gt;').attr('class', 'date').text(currDateString));
      prevDateString = currDateString;
    }
    chatlog.append($('&lt;li&gt;').append(
      $('&lt;span&gt;').attr('class', 'when').text("["+currDate.toLocaleTimeString()+
                                             "]")).append(" ").append(
      $('&lt;span&gt;').attr('class', 'who').text(data.who + ":")).append(" ").append(
      $('&lt;span&gt;').attr('class', 'what').text(data.what)));
  }

  socket.on("chat", function(e) {
    for (i=0; i&lt;e.length; i++) {
      addMessage(e[i]);
    }
    chatlog.scrollTop(chatlog.height());
  });

  socket.emit("history")</pre></div><p>To better see the difference between different parts of the message, add
                the following lines to chatter/static/messages.css:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">.date {
  text-align: center;
  font-size: 140%;
}
.who {
  font-weight: bold;
}
.when {
  font-style: italic;
  color: gray;
}</pre></div><p>Try the app now with <code>python serve.py</code>.</p><p>Use tag <code>step4c-display-usertime</code> in the Git repository to see the code up to
                this point.</p><div class="dw-article-ps-hbox"><h3 id="1.6.0.4.Adding“whoson”information|outline">Add “who's
                on” information</h3><p id="cmt_24" class="cmt_icon"/><p class="cmt_arrow"> </p></div><p>In most chat apps, users can see participants of the conversation. To
                achieve this in your app, add the new table class <code>Connect</code> to
                contain connection information. Add the following class declaration to the
                chatter/models.py file:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">from sqlalchemy import Boolean

class Connect(Base):
    __tablename__ = 'connects'
    id = Column(Integer, Sequence('cnid', optional=True), primary_key=True)
    userid = Column(Integer, ForeignKey('users.id'), nullable=False)
    time = Column(DateTime, default=datetime.datetime.utcnow)
    ison = Column(Boolean)

    def __init__(self, user, ison):
        self.userid = user.id
        self.ison = ison</pre></div><p>This table contains records for each connect and disconnect event for a
                user. Since declaration for existing tables in the model didn't change,
                there's no need to delete Chatter.sqlite. The new table is added to the
                existing tables on the next run of the app.</p><p> User status information is sent to the client in a <code>status</code>
                event. The event data contains an array of users and their current status:
                <code>'on'</code> or <code>'off'</code>. Add handling of the
                <code>connect</code> event with the <code>recv_disconnect</code> method,
                and update the <code>recv_disconnect</code> and <code>on_history</code>
                methods, in chatter/views.py as follows (the <code>on_chat</code> method
                should stay the same):</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">from sqlalchemy import func
from .models import Connect

lastIdQuery = DBSession.query(func.max(Connect.id).label('max')).group_by(
              Connect.userid).subquery()
connQuery = DBSession.query(Connect).join(
            lastIdQuery, Connect.id == lastIdQuery.c.max).subquery()
connectedUsers = DBSession.query(User).join(connQuery).filter(connQuery.c.ison)

def disconn_all():
    with transaction.manager:
        for user in connectedUsers:
            DBSession.add(Connect(user, False))

def uToD(user, ison):
    return {'id': user.id,
            'name': user.name,
            'ison': ison}

class ChatNamespace(BroadcastMixin, BaseNamespace):
    def recv_connect(self):
        self._connect_event(True)

    def recv_disconnect(self):
        self._connect_event(False)
        self.disconnect(silent=True)

    def _connect_event(self, ison):
        with transaction.manager:
            user = DBSession.query(User).get(self.request.authenticated_userid)
            if user:
                DBSession.add(Connect(user, ison))
                self.broadcast_event('status', [uToD(user, ison)])

    def on_history(self):
        self.emit('chat', [mToD(m) for m in DBSession.query(Message).order_by(
                  Message.created)[-10:]])
        self.emit('status', [uToD(u, True) for u in connectedUsers])</pre></div><p> To clarify:</p><ul class="ibm-bullet-list"><li> Upon <code>connect</code> and <code>disconnect</code> events, a
                    new record is added to the Connect table and the <code>status</code>
                    event is broadcast to all users.</li><li> Upon a <code>history</code> request from a client, a list of
                    currently connected users is sent in with the <code>status</code>
                    event and the <code>chat</code> event.</li><li> Regarding <code>connectedUsers</code>, the <code>lastIdQuery</code>
                    returns ids from Connect records maximal for each user. The
                    <code>connQuery</code> returns records from the Connect table
                    corresponding to these ids (the last record for each user). The
                    <code>connectedUsers</code> returns users with the <code>ison</code>
                    value of <code>True</code> in their last record in the Connect
                    table.</li></ul><p> To prevent the same user from being connected simultaneously more than
                once, update the <code>user</code> query and verification in the
                <code>login</code> method, in the same chatter/views.py, as follows (the
                <code>else</code> condition should stay the same):</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">                users = DBSession.query(User, connQuery.c.ison).join(
                        connQuery).filter(User.name==username).all()
                if users:
                    user = users[0][0]
                    if users[0][1]:
                        return {'error': 'User "%s" is already connected' % user.name}
                else:</pre></div><p> When the server is restarted, mark all users disconnected before their
                clients get connected again. To accomplish this, the
                <code>disconn_all()</code> method introduced above needs to be called on
                app startup. Add the following lines to chatter/__init__.py after the
                <code>create_all()</code> call creating all the tables:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">    from .views import disconn_all
    disconn_all()</pre></div><p>On the client the message log is side by side with the list of users.
                Change <code>&lt;div id="chatlog"&gt;</code> in
                chatter/templates/messsages.pt to the table:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">    &lt;table&gt;
      &lt;tr&gt;
        &lt;td id="chatlog"&gt;
          &lt;ul/&gt;
        &lt;/td&gt;
        &lt;td id="users"&gt;
          &lt;ul/&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;</pre></div><p>To make this view look reasonable, add the following entries to
                chatter/static/messages.css:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">table {
  width: 100%;
}
#chatlog {
  width: 80%;
  vertical-align: top;
}
#users {
  vertical-align: top;
}
#users &gt; ul {
  padding: 0 0;
  list-style-type: none;
}</pre></div><p>Add handling of <code>status</code> events to add and remove users, based
                on their <code>ison</code> status, to chatter/static/chat.js:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">  var users = $("#users&gt;ul");

  var updateStatus = function(data) {
    user = $("#user-" + data.id);
    if ((user.length === 0) === data.ison) {
      if (data.ison) {
        users.append($('&lt;li&gt;').text(data.name).attr('id', "user-" + data.id));
      } else {
        user.remove();
      }
    }
  }

  socket.on("status", function(e) {
    for (i=0; i&lt;e.length; i++) {
      updateStatus(e[i]);
    }
  });</pre></div><p>At this point the app shows currently connected users. You're done changing
                static files, so the <code>cache_max_age=0</code> can be changed back to
                <code>cache_max_age=3600</code> in chatter/__init__.py now.</p><p>Use tag <code>step4-add-users</code> in the Git repository to see the code up to this
                point.</p><div class="dw-article-ps-hbox"><h2 id="1.7.Step5.DeployChattertoBluemix|outline">Step 5.
                Deploy Chatter to Bluemix</h2><p id="cmt_8" class="cmt_icon"/><p class="cmt_arrow"> </p></div><p>It is really simple to deploy the app to Bluemix. To ease deploying the app
                into Bluemix repeatedly, create a manifest.yml file with:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">---
applications:
- name: TestChatter
  memory: 128M
  buildpack: https://github.com/cloudfoundry/cf-buildpack-python.git
  command: python serve.py</pre></div><p>This tells the CF client to push the app with the name TestChatter using
                128M, Python buildpack, and serve.py as the starting script.</p><p>To ensure that unnecessary files are not pushed to Bluemix with the app,
                create a .cfignore file with:</p><p>For the app to work in Bluemix, it should listen on the proper port. Add
                the <code>port</code> parameter to the <code>serve</code> call in
                serve.py:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">        serve(app, host='0.0.0.0', port=os.getenv('VCAP_APP_PORT', 6543))</pre></div><p>Now login, push the app to Bluemix, and access it using the application
                URL:</p><p>If the app is restarted, the conversation log will disappear. For it to be
                permanently available, use database Bluemix services. Change how the
                database engine gets initialized by changing the line
                <code>engine = engine_from_config(settings, 'sqlalchemy.')</code> in
                chatter/__init__.py to:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">    engine = None
    import os
    if os.environ.has_key("VCAP_SERVICES"):
        import json
        services = json.loads(os.environ["VCAP_SERVICES"])
        for service in reduce(lambda x,y: x+y, services.values(), []):
            if service['name'] == 'messages':
                from sqlalchemy import create_engine
                engine = create_engine(service['credentials']['uri'], pool_recycle=3600)
    if not engine:
        engine = engine_from_config(settings, 'sqlalchemy.')</pre></div><p>This code uses a service called 'messages' to retrieve the database's URI
                to use. Services periodically close long-living connections. To handle
                that properly, recycle (close and open) connections periodically. The
                <code>pool_recycle=3600</code> causes such a recycle to occur for
                connections open more than an hour. In addition to the URI, you also need
                to add drivers for the database. They are added in setup.py in the
                requires[] list. Add PostgreSQL using the <code>psycopg2</code> line.
                Now the app can be used with PostgreSQL databases:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">cf create-service postgresql 100 messages
cf bind-service TestChatter messages
cf push</pre></div><p>Notice that data is now retained even if the app is restarted:</p><p class="dw-article-ps-see-blk"><span class="dw-article-ps-see-head">READ:</span><a class="dw-article-ps-see" href="https://www.ng.bluemix.net/docs/#services/PostgreSQL/index.html">Getting started with PostgreSQL service</a></p><p> DB2 does not have an open source client, so add the necessary libraries to
                the app directly. Download the Data Server Driver Package for Linux/x86-64
                64 bit from <a href="https://www.ibm.com/support/docview.wss?uid=swg27016878">Fix
                    Packs for IBM Data Server Client Packages</a> and put it into the root
                of the app. Use the Linux/x86-64 download even if you are developing this
                app on a different platform because the app will run on that platform in
                Bluemix. The v10.5 Fix Pack 5 version of the driver is
                v10.5fp5_linuxx64_dsdriver.tar.gz</p><p>Add the installation of DB2 packages into setup.py. The default pip
                package manager does not handle prepackaged files, so use
                <code>easy_install</code> instead. Add the following lines into the
                setup.py file before the <code>setup()</code> call:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">if "-".join(os.uname()[0::4]) == "Linux-x86_64":
    from glob import glob
    from subprocess import call

    if not os.path.isdir('./dsdriver'):
        db2_drivers=glob("./v*_linuxx64_dsdriver.tar.gz")
        if db2_drivers:
            import tarfile
            print "Using %s" % db2_drivers[0]
            tar = tarfile.open(db2_drivers[0])
            tar.extractall()
            tar.close()
            call(["bash", "./dsdriver/installDSDriver"])

            for f in db2_drivers:
                os.remove(f)
            import shutil
            for d in os.listdir("./dsdriver"):
                if not d in ["lib", "python"]:
                    f = os.path.join("./dsdriver", d)
                    if os.path.isdir(f):
                        shutil.rmtree(f)
                    else:
                        os.remove(f)

    if os.path.isdir('./dsdriver/python/python64'):
        call(["easy_install", "-N", glob("./dsdriver/python/python64/ibm_db-*-linux-x86_64.egg")[0]])
        call(["easy_install", "-N", glob("./dsdriver/python/python64/ibm_db_sa-*.egg")[0]])</pre></div><p> Note that:</p><ul class="ibm-bullet-list"><li>Installation occurs only if the OS is indeed the one you have the
                    driver for. Extracting of the files is done only if it was not done
                    before.</li><li>The <code>-N</code> options tells <code>easy_install</code> not to
                    check the network for newer packages.</li><li><code>glob</code> is used so the code will work with any version of
                    the packages.</li><li>Splitting the driver installation and Python packages installation
                    into two separate <code>if</code> conditions lets users with access
                    to Linux speed up initial app startup by including the
                    already-installed driver in the app.</li><li>Removal of the files at the end of the first of the <code>if</code>
                    blocks reduces the disk footprint of the app on the cloud.</li></ul><p>Finally, add the DB2 native library to the library load path. This is done
                in the app's environment, so let's update the manifest.yml file with the
                following line:</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">  env:
   LD_LIBRARY_PATH: /app/dsdriver/lib:$LD_LIBRARY_PATH</pre></div><p>Now the app is ready to use DB2 as a service (delete any previous service
                instance first):</p><div class="codesection"><pre data-editor-readonly="true" data-editor-show-annotation-ruler="false" data-editor-lang="js" class="displaycodeps editor">cf unbind-service TestChatter messages
cf delete-service -f messages
cf create-service sqldb sqldb_free messages
cf bind-service TestChatter messages
cf push</pre></div><p>Use tag <code>step5-bluemixify</code> in the Git repository to see the code up to this
                point.</p><p>This tutorial showed how to:</p><ul class="ibm-bullet-list"><li>Create a Pyramid-based application and abstract its database model in
                    a database-independent way.</li><li>Enable dynamic page update with SocketIO abstraction.</li><li>Enforce user authentication before app use.</li><li>Deploy the app to the Bluemix environment.</li><li>Use the database services available in Bluemix. </li></ul><p>It provided the groundwork for creating Python-based applications in the
                Bluemix environment.</p><p>In its current state, the example app contains useful information that is
                not accessed by the interface. Consider this an invitation to use the
                skills gained in this tutorial to extend the app further. Some ideas:
                allow scrolling through all stored messages, add search through messages,
                or display the app popularity as a number of users visiting each day. </p><p class="ibm-rule dw-article-ps-topic-rule"><hr/></p><p><span class="dw-article-ps-topic-head">RELATED TOPICS:</span><a class="dw-article-ps-topic" href="https://www.ng.bluemix.net/docs/#services/SQLDB/index.html">SQL Database on Bluemix</a><a class="dw-article-ps-topic" href="https://code.google.com/p/ibm-db/wiki/README">IBM DB2 for SQLAlchemy</a><a class="dw-article-ps-topic" href="http://www.ibm.com/developerworks/cloud/bluemix/">Bluemix resources</a></p>
    
    
</div>

  

</div></body></html>