<html><body><div><div class="content html_format"><p>
      Недавно для решения задачи о прохождении лабиринта, которых, кстати, не мало, я решил воспользоваться «волновым алгоритмом», о котором ранее мне приходилось слышать. К моему сожаления, найти внятное объяснение его работы с примерами реализации на нужном мне языке не получилось, следствием чего является эта статья.</p>
<p>
Итак, будем пытаться написать его самостоятельно, а для этого нужно продумать, как он должен работать. Для этого возьмём достаточно легкую задачу:
</p><a name="habracut"/>
<img src="https://habrastorage.org/getpro/habr/post_images/c9b/da2/84d/c9bda284d8c4b1c0d994273d2f9a7d5e.png"/> 

<ol>
<li>Для начала разберемся с входными данными: у нас есть матрица элементов, где 0 — пустые клетки, а 1 — стенки. </li>
<li>При вводе меняем «1» на "-1" (этого требует алгоритм) </li>
<li>Далее нужно выбрать ячейку, с которой начнется обход </li>
<li>Рекурсивно обойти лабиринт от выбранной ячейки, вставляя в ячейку текущий «уровень волны» </li>
</ol><p>
Ввод данных будет выглядеть следующим образом:

</p><pre><code class="python">rdl = list(map(int,input().split()))
n, m = rdl
for i in range(n):
        rdl = input()
        cur = []
        for k in range(m):
            if int(rdl[k]) == 1:
                cur.append(-1)   
            else:    
                cur.append(int(rdl[k]))
        lab.append(cur)</code></pre><p>
Теперь у нас есть двумерная матрица, представляющая наш лабиринт.</p><p>
Далее нам нужно написать функцию, которая будет обходить наш лабиринт:

</p><pre><code class="python">def voln(x, y, cur, n, m, lab):
</code></pre><p>
Где x, y — координаты текущей ячейки; cur — «уровень волны»; n, m — размеры лабиринта; lab — сам лабиринт.</p><p>
Для начало нужно заполнить текущую ячейку уровнем воды:

</p><pre><code class="python">lab[x][y] = cur
</code></pre><p>
Далее проверим, есть ли у нас возможность «пойти» влево:

</p><pre><code class="python">if y+1 &lt; m:
</code></pre><p>
Если есть такая возможность, то проверяем, нет ли там стенки или </p><u> текущий «уровень воды» меньше, чем в ячейке справа </u><p>:

</p><pre><code class="python">if lab[x][y+1] == 0 or (lab[x][y+1] != -1 and lab[x][y+1] &gt; cur):
</code></pre><p>
И в случае «успеха» рекурсивно идем вправо:

</p><pre><code class="python">voln(x,y+1,cur+1,n,m,lab)
</code></pre><p>
Теперь нужно точно также проверить возможность пройти вниз, влево и вверх:

</p><pre><code class="python">if x+1&lt;n:
    if lab[x+1][y] == 0 or (lab[x+1][y] != -1 and lab[x+1][y] &gt; cur):
            voln(x+1,y,cur+1,n,m)
if x-1&gt;=0:
    if lab[x-1][y] == 0 or (lab[x-1][y] != -1 and lab[x-1][y] &gt; cur):
            voln(x-1,y,cur+1,n,m)
if y-1&gt;=0:
    if lab[x][y-1] == 0 or (lab[x][y-1] != -1 and lab[x][y-1] &gt; cur):
            voln(x,y-1,cur+1,n,m)
</code></pre><p>
Все, осталось в конце вернуть текущий лабиринт:

</p><pre><code class="python">return lab
</code></pre><p>
Готовая программа:

</p><pre><code class="python">def main():
    lab = []
    rdl = list(map(int,input().split()))
    n, m = rdl
    for i in range(n):
        rdl = input()
        cur = []
        for k in range(m):
            if int(rdl[k]) == 1:
                cur.append(-1)   
            else:    
                cur.append(int(rdl[k]))
        lab.append(cur)
    rdl = list(map(int,input().split()))
    x1, y1 = rdl[0]-1, rdl[1]-1
    rdl = list(map(int,input().split()))
    x2, y2 = rdl[0]-1, rdl[1] -1
    lab = voln(x1,y1,1,n,m,lab)
    if lab[x2][y2] &gt; 0:
        print("Mozhet")
    else:
        print("Ne mozhet")    
def voln(x,y,cur,n,m):
    lab[x][y] = cur
    if y+1&lt;m:
        if lab[x][y+1] == 0 or (lab[x][y+1] != -1 and lab[x][y+1] &gt; cur):
            voln(x,y+1,cur+1,n,m,lab)
    if x+1&lt;n:
        if lab[x+1][y] == 0 or (lab[x+1][y] != -1 and lab[x+1][y] &gt; cur):
            voln(x+1,y,cur+1,n,m,lab)
    if x-1&gt;=0:
        if lab[x-1][y] == 0 or (lab[x-1][y] != -1 and lab[x-1][y] &gt; cur):
            voln(x-1,y,cur+1,n,m,lab)
    if y-1&gt;=0:
        if lab[x][y-1] == 0 or (lab[x][y-1] != -1 and lab[x][y-1] &gt; cur):
            voln(x,y-1,cur+1,n,m,lab)
    return lab
main()
</code></pre>
<p>
Спасибо за прочтение, надеюсь, кому-то будет полезно.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>