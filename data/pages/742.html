<html><body><div><div class="content html_format"><p>
      Мы уже рассказали вам, </p><a href="http://habrahabr.ru/company/yandex/blog/209324/">что такое</a><p> Cocaine и </p><a href="http://habrahabr.ru/company/yandex/blog/214069/">как его развернуть</a><p> «в домашних условиях». Сегодня речь пойдёт о том, как пользоваться его инфраструктурой на уровне программиста. Кстати, 26 апреля в 14:00 в московском офисе Яндекса пройдет </p><a href="http://tech.yandex.ru/events/meetings/cocaine_lab/">встреча</a><p>, на которой можно будет вживую пообщаться с нами — командой, которая делает Cocaine. Приходите, но не забывайте </p><a href="http://tech.yandex.ru/events/meetings/cocaine_lab/register/">регистрироваться</a><p>. 

</p><a href="http://habrahabr.ru/company/yandex/blog/220243/"><img src="https://habrastorage.org/getpro/habr/post_images/20d/bdc/014/20dbdc014b76c99188fa05a6a745c6d0.jpg"/></a>
<p>
Итак, из сегодняшнего поста вы узнаете:

</p><ul>
<li>как писать приложения;</li>
<li>как пользоваться приложениями и сервисами нативно, используя предоставленные фреймворки;</li>
<li>как изменить приложение, чтобы оно отвечало по http, а также как потестировать эти приложения, используя Cocaine http proxy;</li>
<li>как написать собственный сервис.</li>
</ul><p>
Давайте же начнем наше погружение в «кокаиновые» будни программиста. 
</p><a name="habracut"/><p>
Этот текст достаточно объёмный и очень технический. Подразумевается, что вы читали наши предыдущие посты, и у вас есть доступ к кокаиновому облаку, на машинках которого установлены требуемые библиотеки и программы. И что вы достаточно хорошо знакомы с асинхронным программированием и вас не пугают слова: event loop, callback и корутины. Для каждого примера требования будут перечислены под катом или явно. И да, для повторения всего рассказанного совершенно не обязательно иметь кластер из 50 машин. Мне было достаточно одного ноутбука с Mac OS.

</p><h2>Часть 1. Работаем с Cocaine</h2><p>
Начнём наш обзор с того, что загрузим в облако уже сконфигурированное готовое приложение, мощь которого не знает границ, — </p><a href="https://github.com/3Hren/cocaine-paper-sources/tree/master/src/echo">echo</a><p>. Приложение написано на Питоне и представляет собой типичный Hello World для тестирования корректности новых фреймворков.

</p><h4>Как загрузить приложение</h4><p>
Практически по всей статье будут использоваться консольные утилиты cocaine-tool, которые сами зависят от установленного cocaine-framework-python. В волшебном мире Питона данные библиотеки устанавливаются командой:

</p><pre><code class="python">pip install cocaine-tools</code></pre>
<p>
Загрузить приложение в облако можно перейдя в каталог с приложением и выполнив следующую команду:

</p><pre><code class="python">cocaine-tool app upload</code></pre>

<strong>Это важно:</strong><p> перед загрузкой не забудьте сделать входную точку в ваше приложение исполняемой. В нашем случае:

</p><pre><code class="python">chmod u+x echo.py</code></pre>
<p>
В результате будет выведено:
</p><img src="https://habrastorage.org/getpro/habr/post_images/b29/cd5/95d/b29cd595d80a3651f60be0f85b4b3662.png" alt="Загрузка тестового приложения"/>
<p>
Для его запуска нам понадобится готовый профиль. В случае, если у вас Cocaine настроен на использование Docker в качестве системы изоляции, можно воспользоваться профилем, приведенным в предыдущей </p><a href="http://habrahabr.ru/company/yandex/blog/214069/">статье</a><p>. Если же Cocaine настроен на обычный process spawn, просто воспользуйтесь профилем, который я подготовил (profile.json):

</p><pre><code class="python">{
    "isolate": {
        "args": {
            "spool": "/var/spool/cocaine"
        },
        "type": "process"
    }
}
</code></pre>
<p>
Загрузить профиль можно аналогичной командой:

</p><pre><code class="python">cocaine-tool profile upload --name profile@test --profile ./profile.json</code></pre>
<p>
Результат работы должен быть примерно таким:
</p><img src="https://habrastorage.org/getpro/habr/post_images/e1b/5fa/4ce/e1b5fa4ced58d38891070fa598b6226a.png" alt="Загрузка профиля"/><p>
Имея готовый профиль, остается лишь запустить недавно загруженное приложение:

</p><pre><code class="python">cocaine-tool app start --name echo --profile profile@test</code></pre>
<p>
Если в консоли будет выведено что-то типа такого, значит, все было проделано успешно и наше приложение теперь</p><p>
часть облака.
</p><img src="https://habrastorage.org/getpro/habr/post_images/192/408/a65/192408a6547488b0d409c484e27f3b7c.png" alt="Запуск тестового приложения"/><p>
Вернемся к примеру. Пока не особо вникайте в код. Скоро мы напишем аналогичное, но более функциональное приложение, но на этот раз</p><p>
уже с объяснениями. Единственное, что делает это приложение — отвечает на событие с именем </p><strong>ping</strong><p> тем же</p><p>
самым сообщением, которое было ему послано.
</p><p>
Сейчас же наша задача — написать код, формирующий запрос и принимающий ответ от этого приложения. Стоит отметить, что кокаиновые приложения могут быть доступны как по HTTP, так и напрямую из клиентского кода. Первый способ мы рассмотрим чуть позднее, второй способ предполагает использование одного из предоставленных фреймворков. Для разминки мы напишем код на Питоне, используя питонячий фреймворк, который должен был поставиться вместе с </p><strong>cocaine-tool</strong><p>.

</p><pre><code class="python">from cocaine.futures import chain
from cocaine.services import Service

from tornado.ioloop import IOLoop

# Alias for more readability.
asynchronous = chain.source

if __name__ == '__main__':
    io_loop = IOLoop.current()
    service = Service('echo')

    @asynchronous
    def invoke(message):
        result = yield service.enqueue('ping', message)
        print(result)

    invoke('Hello World!')
    invoke('Hello again!')
    io_loop.start()
</code></pre>
<p>
После импортирования необходимых библиотек и классов мы просто создает объект кокаинового сервиса, используя библиотечный класс </p><code>Service</code><p>, передав ему в качестве параметра имя приложения (в нашем случае — echo). Этот объект представляет собой отображение методов и событий облачного сервиса/приложения на методы класса в используемом языке. Наша работа с ним заключается в том, чтобы </p><strong>асинхронно</strong><p> вызвать предоставляемый всеми приложениями метод </p><code>enqueue</code><p>, передав ему в качестве первого параметра имя события, а в качестве остальных параметров (внезапно) — остальные параметры, требующиеся приложению; а затем так же асинхронно дождаться ответа. Для этого мы получаем объект цикла обработки событий, используя библиотеку </p><a href="http://www.tornadoweb.org">Tornado</a><p>, запускаем его и ждем. Когда будет получен ответ, цикл не останавливается явно.

</p><strong>Это важно:</strong><p> когда писался питонячий фреймворк, то библиотека </p><a href="https://docs.python.org/3.4/library/asyncio.html">Asyncio</a><p> еще не была полностью готова, и выбирать приходилось между Twisted и Tornado. Выбор пал на Tornado в основном из-за его более современного вида и функциональности. Сейчас полным ходом идет полное переписывание питонячего фреймворка на asyncio, а точнее— на его бэкпорт для второго Питона — </p><a href="http://trollius.readthedocs.org">Trollius</a><p>.
</p><p>
Последовательность вызовов можно изобразить следующим образом:
</p><img src="https://habrastorage.org/getpro/habr/post_images/df3/c57/333/df3c57333f550e039f8f310a5ff67e01.gif" alt="Последовательность вызовов в примере"/>
<p>
В облако же приложение будет ходить вот так:
</p> 
<p>
Таинственный декоратор </p><code>@asynchronous</code><p> подмешивает в декорируемую функцию дополнительные действия, а именно:
</p><ul>
<li>добавляет ее вызов в цикл обработки событий;</li>
<li>если функция является корутиной — контролирует ее процесс асинхронной раскрутки.</li>
</ul><p>
Проверим написанный код:
</p><img src="https://habrastorage.org/getpro/habr/post_images/f68/ef5/898/f68ef5898e6d58349f3e4f6c1a2c4715.png" alt="Тестирование приложения"/>
<strong>Стоит отметить</strong><p>, что во фреймворках для динамических языков, коим Python является, набор доступных методов получается динамически во время подключения объекта класса </p><code>Service</code><p> к Cocaine. В остальных языках приходится писать те или иные заглушки, что будет показано далее.
</p><p>
Наверняка у вас сразу появились вопросы:
</p><ul>
<li>Зачем так сложно?</li>
<li>Почему была выбрана асинхронная модель?</li>
</ul><p>На них мы обязательно ответим несколькими абзацами ниже, а пока посмотрим, как Cocaine (и фреймворк соответственно)</p><p>
реагирует на ошибочные запросы. Например, зададим в качестве имени приложения, передаваемому объекту </p><code>Service</code><p> не
</p><strong>echo</strong><p>, а какое-нибудь имя несуществующего приложения. Скажем, </p><strong>42</strong><p>, то есть:

</p><pre><code class="python">echo = Service('42')</code></pre>
<p>
Искренне недаюсь, что такого приложения у вас нет в облаке. В этом случае Cocaine вернет ошибку, а фреймворк выбросит</p><p>
исключение.
</p><img src="https://habrastorage.org/getpro/habr/post_images/649/350/ab1/649350ab17eb093c408aa7a74ca910aa.png" alt="Проброс ошибок"/>
<strong>Стоит отметить</strong><p>, что фреймворки совершенно не обязаны выбрасывать исключения на ошибки. Фреймворки специально создаются, чтобы предоставить пользователю нативный для языка интерфейс работы с Cocaine, а значит, если для рассматриваемого языка наиболее предпочтительным (или единственным, в случае Go) способом возвращения ошибки является, например, возврат кода ошибки, то он и будет использован.
</p><p>
Аналогичные образом можно попробовать запросить обработку несуществующего события, передать неправильное число аргументов или ошибиться в их типах.

</p><h3>Кокаиновый протокол</h3><p>
Давайте на минутку остановимся и заглянем под капот нашей облачной платформы. Каким образом Cocaine узнает о том, какой именно</p><p>
запрос к нему пришел и как его обрабатывать? Другими словами, кратко рассмотрим протокол, по которому Cocaine общается с клиентами.
</p><p>
На каждый вызов Cocaine открывает типизированный канал, который позволяет обмениваться с приложением сообщениями. Сообщения могут быть трех типов:

</p><pre><code class="python">0, Chunk    ::= &lt;Tuple&gt;
1, Error    ::= (&lt;Number&gt;, &lt;String&gt;)
2, Choke    ::= ()</code></pre>

<strong>Chunk</strong><p> представляет собой обычное сообщение, информацию, которую клиент хочет передать приложению или наоборот. В случае возникновенbя какой-либо ошибки приложение (или сам Cocaine, если он сможет распознать ошибку заранее) отвечает типом </p><strong>Error</strong><p>, несущим какой-то код и человекопонятное описание возникшей ошибки. Наконец, каждый канал должен закрываться сообщением типа </p><strong>Choke</strong><p>. Cocaine гарантирует, что после такого сообщения не будет больше никаких других сообщений.
</p><p>
К чему я это? Под капотом каждый фреймворк реализует данный протокол (и немного больше), маскируя под вызовы функций</p><p>
или методов обычное формирование сообщения и, с другой стороны, осуществляя диспетчеризацию, распаковывая полученные</p><p>
сообщения и направляя их обратно клиенту.
</p><p>
Так как протокол является стримовым, и последним сообщением всегда приходит </p><code>Choke</code><p>, строго говоря, приложения могут</p><p>
возвращать неизвестное количество </p><code>Chunk</code><p>'ов, тем самым организуя настоящую поточную обработку данных и их асинхронный</p><p>
возврат.

</p><h3>Возвращаясь к примеру</h3><p>
Давайте модифицируем наше приложение, чтобы оно возвращало не один Chunk, а несколько. Скажем, два. Рассмотрим код нашего супер-приложения, из которого был выкинут логгер:

</p><pre><code class="python">from cocaine.worker import Worker&lt;/python&gt;
def echo(request, response):
    message = yield request.read()
    response.write(message)
    response.close()


W = Worker()
W.run({
    'ping': echo,
})
</code></pre>
<p>
Как видно, используется практически тот же паттерн обработки, который мы писали в клиентском коде. На каждое приходящее событие с именем </p><code>ping</code><p> вызывается функция </p><code>echo</code><p>, которая в качестве аргументов принимает уже подготовленные объекты запроса и ответа. Вызывая метод </p><code>request.read()</code><p> мы асинхронно считываем по одному Chunk'у запроса (в нашем случае он строго один), а отвечаем — используя метод </p><code>response.write(...)</code><p>.
</p><p>
Соответственно, чтобы наше приложение отвечало несколькими Chunk'ами, достаточно вызвать этот метод еще раз. Например:

</p><pre><code class="python">def echo(request, response):
    message = yield request.read()
    response.write(message)
    response.write('Additional message')
    response.close()
</code></pre>
<p>
Как это проверить? Ну, во-первых, приложение следует перезалить и перезапустить:

</p><pre><code class="python">cocaine-tool app upload &amp;&amp; cocaine-tool app restart --name echo --profile profile@test
</code></pre>

<strong>Это важно:</strong><p> если измененное приложение упорно не хочет обновляться и работает по-старому даже после перезаливки,</p><p>
проверьте настройки кэша в конфиге cocaine-runtime (секция cache).
</p><p>
После чего заново запустим наш клиент, и он выдаст… то же самое, что и раньше. Это нормальное поведение. Напомню, что протокол у нас стримовый, и мы вычитываем из канала ровно по одном Chunk'у. Чтобы все заработало, изменим функцию </p><code>invoke</code><p> следующим образом:

</p><pre><code class="python">@asynchronous
def invoke(message):
    result = yield service.enqueue('ping', message)
    another_result = yield
    print(result, another_result)
    io_loop.stop()
</code></pre>
<p>
При попытке считать еще один чанк фреймворком, будет выброшен специальный эксепшн </p><code>ChokeEvent</code><p>, который опять-таки</p><p>
фреймворкозависим (в других его может не быть и оповещение о закрытом канале осуществлется другим образом).

</p><h3>Асинхронность везде</h3><p>
Теперь, когда мы рассмотрели базовую работу с приложением и питонячим фреймворком, рассмотрим причины, побудившие нас остановиться на выборе асинхронной модели работы с кодом.
</p><p>
Для этого рассмотрим Cocaine и окружающие его фреймворки более детально. Как было отмечено в нашей первой статье, основная модель, заложенная в основу Cocaine'а — это модель акторов. Фреймворки же в свою очередь представляют собой не более чем обертки над RPC-вызовами к Cocaine и обработку его ответов. Вот, мы запросили что-то у объекта </p><code>Service</code><p>. Что у него происходит? После кодирования сообщения и его отправки, он, ждет. Ждет ответа, ждет ошибку, ждет наступления таймаута. Все эти ожидания — обычные IO операции, не тратящие ресурсы процессора. Так зачем давать ему лишний раз остывать, если можно дать еще работы? Представьте, что вы делаете запросы к какому-нибудь приложению или сервису не из клентского кода, а из </p><strong>другого приложения</strong><p>. Понятно, что если это приложение будет делать stop the world на каждом таком запросе, это приведет к быстрому спавнингу таких приложений, что впоследствии будет просто тратой ресурсов системы.
</p><p>
В таких случаях используют два распространенных подхода. В первом из них каждый запрос обрабатывается в отдельном потоке, а управление в код возвращается в основном в методе ожидания выданного future'а, во втором случае используется цикл обработки событий и кооперативная многозадачность (callback'и, coroutine'ы, fiber'ы — не важно). Но опять-таки в случае обработки тысячи одновременных запросов — что вполне себе реальная ситуация для высоконагруженных систем — первый способ дает существенный оверхед в производительности.
</p><p>
Именно поэтому все кокаиновые фреймворки реализуют в первую очередь асинхронный способ взаимодействия с сервисами. Некоторые в дополнение реализуют также синхронный способ, но не все.

</p><h3>А как же остальные языки?</h3><p>
После того, как мы залили приложение в Cocaine, оно стало </p><strong>частью инфраструктуры</strong><p>, или </p><strong>унифицированным</strong><p>. Теперь к нему можно обращаться из любого удобного для разработки языка и производить с ним все те же действия, рассмотренные выше, но при этом не сковывая себя в выборе парадигм разработки и библиотек.
</p><p>
Продемонстрируем это, написав клиентов для нескольких фреймворков на различных языках. При этом тестировать будем изначальную версию echo приложения.

</p><h4>C++</h4><p>
Аналогичный клиент на C++ будет выглядеть следующим образом:

</p><pre><code>#include &lt;cocaine/framework/services/app.hpp&gt;
#include &lt;cocaine/framework/services/storage.hpp&gt;

#include &lt;iostream&gt;
#include &lt;condition_variable&gt;
#include &lt;mutex&gt;
#include &lt;atomic&gt;

namespace cf = cocaine::framework;

int main(int argc, char** argv) {
    auto manager = cf::service_manager_t::create(cf::service_manager_t::endpoint_t("localhost", 10053));

    // Get application service object.
    auto app = manager-&gt;get_service&lt;cf::app_service_t&gt;("echo");

    std::atomic&lt;int&gt; counter(0);

    std::condition_variable cv;

    // Call application.
    auto g1 = app-&gt;enqueue("ping", "Hello from C++");
    auto g2 = app-&gt;enqueue("ping", "Hello again!");
    auto handler = [&amp;counter, &amp;cv](cf::generator&lt;std::string&gt;&amp; g) {
        counter++;

        try {
            // Always packed data.
            std::cout &lt;&lt; "result: " &lt;&lt; g.next() &lt;&lt; std::endl;
        } catch (const std::exception&amp; e) {
            std::cout &lt;&lt; "error: " &lt;&lt; e.what() &lt;&lt; std::endl;
        }

        cv.notify_all();
    };
    g1.then(handler);
    g2.then(handler);

    std::mutex m;
    std::unique_lock&lt;std::mutex&gt; guard(m);

    while (counter &lt; 2) {
        cv.wait(guard);
    }

    return 0;
}
</code></pre>
<p>
Компилировать нужно следующим образом (в случае использования clang):

</p><pre><code>clang++ -std=c++11 -stdlib=libc++ -lcocaine-core -lcocaine-framework -lmsgpack -lboost_system -lev ../src/clients/echo-client.cpp
</code></pre>
<p>
Если же вы используете GCC, то просто замените clang++ на g++, и уберите необходимость использования libc++ вместо libstdc++, убрав </p><code>-stdlib=libc++</code><p>.
</p><p>
Особо комментировать код не буду, более подробно об использованиии native framework'а можно почитать </p><a href="https://github.com/cocaine/cocaine-docs/blob/v0.11/doc/tutorial_cplusplus.md">здесь</a><p>.

</p><h4>Ruby</h4><p>
В случае Ruby все совсем просто. Мы используем прекрасный фреймворк </p><code>eventmachine</code><p>, который предоставляет возможность</p><p>
использовать Ruby Fiber и писать асинхронный код так, как будто бы он синхронный. Никаких колбэков и фьючеров!

</p><pre><code>require 'cocaine'
require 'cocaine/synchrony/service'
require 'em-synchrony'

class EchoClient
  EM.synchrony do
    results = []
    service = Cocaine::Synchrony::Service.new 'echo'
    channel = service.enqueue('ping', 'Hello from Ruby!')
    channel.each do |result|
      results.push result
    end
    puts results
    EM.stop
  end
end
</code></pre>
<p>
Как видно из примеров, в отличии от CORBA в Cocaine нет необходимости заранее определять </p><a href="http://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%BE%D0%B2">IDL</a><p> используемых приложений и сервисов. В случае статически типизированных языков для удобства использования и проверки типов можно писать заглушки для каждого сервиса, но обычно их реализация занимает не очень много места. Если язык имеет хоть сколько-нибудь нормальный рефлекшн, то даже нет необходимости писать реализацию — достаточно лишь интерфейсов. В случае же динамически типизированных языков можно вообще обойтись без заглушек и создавать API сервиса динамически, получая ее после определения основной информации о нем во время работы метода Локатора </p><code>resolve</code><p>.

</p><h2>Часть 2. Воркеры</h2><p>
Размявшись написанием клиентского кода для кокаиновых приложений, предлагаю перейти на другую сторону облака и рассмотреть правила, по которым пишутся сами приложения и средства для их написания. На самом деле, большой разницы между клиентским кодом и кодом приложения немного — скоро вы сами увидите.
</p><p>
Каждый из существуюших фреймворков имеет вспомогательные средства для написания всевозможных приложений, которые будут множиться Cocaine-ом под нагрузкой. Мы же для разминки воспользуемся опять питонячим API.
</p><p>
В качестве примера напишем приложение, которое будет генерировать QR-коды определенного размера по запросу. Чтобы не было скучно, приложение также будет осуществлять кэширование самых больших картинок в сервисе </p><code>Storage</code><p>, используя вторичные запросы из приложения назад в Cocaine.
</p><p>
Таким нехитрым образом можно построить настоящую паутину запросов между маленькими, но сцепленными приложениями. При этом очень остро встает вопрос экономии ресурсов. Помните мы рассматривали, почему все фреймворки построены на асинхроной событийно-ориентированной модели? Именно экономия ресурсов побудила нас к такому выбору.
</p><p>
Возвращаясь к нашему примеру, мы дадим нашему приложению событие с именем </p><code>generate</code><p>. Оно будет возвращать сгенерированный QR-код в бинарном виде в виде какого-то массива байтов (ну, а как иначе?), который мы скормим специальному объекту, дабы сконвертировать их в настоящую картинку.

</p><strong>Это важно:</strong><p> при написании этого примера мы будем пользоваться питонячей библиотекой </p><a href="https://pypi.python.org/pypi/qrcode">qrcode</a><p>. Она зависит от известного </p><code>PIL</code><p> или </p><code>pillow</code><p>, который в свою очередь, требует множество бинарных зависимостей, например libpng. Убедитесь, что они у вас есть, а затем поставьте </p><code>qrcode</code><p>, используя тот же </p><code>pip</code><p>:

</p><pre><code class="python">&gt;pip install qrcode
</code></pre>
<p>
Приведу сразу код всего приложения, а затем подробно разберу каждую строчку, которая может вызвать хотя бы малейшие вопросы:

</p><pre><code class="python">#!/usr/bin/env python

import StringIO
import msgpack

import qrcode

from cocaine.exceptions import ServiceError
from cocaine.decorators import http
from cocaine.logging import Logger
from cocaine.services import Service
from cocaine.worker import Worker

storage = Service('storage')


def generate_qr(message, size=10):
    if size &lt;= 0 or size &gt;= 20:
        raise ValueError('size argument must fit in [0; 20]')

    out = StringIO.StringIO()
    img = qrcode.make(message, box_size=size)
    img.save(out, 'png')
    return out.getvalue()


def generate(request, response):
    rq = yield request.read()
    message, size = msgpack.loads(rq)

    try:
        if size &lt; 10:
            data = generate_qr(message, size)
        else:
            key = '{0}size={1}'.format(message, size)
            try:
                data = yield storage.read('qr-codes', key)
            except ServiceError:
                data = generate_qr(message, size)
                yield storage.write('qr-codes', key, data)
        response.write(data)
    except Exception as err:
        response.error(1, str(err))
    finally:
        response.close()


w = Worker()
w.run({
    'generate': generate
})
</code></pre>
<p>
Строкой </p><code>storage = Service('storage')</code><p> мы объявляем глобальный для воркера сервис </p><code>Storage</code><p>, который, напомню, мы</p><p>
настраивали в конфиге cocaine-runtime во второй статье. По умолчанию это будет файловое хранилище. В данном случае нам это совершенно не важно, так как мы используем предоставляемую нам инфраструктуру облака.
</p><p>
Теперь обратите внимание на последние строчки:

</p><pre><code class="python">w = Worker()
w.run({
    'generate': generate
})
</code></pre>
<p>
Этим кодом мы создаем объект воркера, который за сценой установит подключение с Cocaine'ом, а также некоторые другие действия. Затем запускаем цикл обработки событий, попутно регистрируя обработчик события </p><code>generate</code><p>. Теперь любое </p><code>invoke</code><p> сообщение с правильными параметрами будет перенаправлено в указанную функцию. Рассмотрим ее подробнее.
</p><p>
В каждую такую функцию передается ровно два параметра:
</p><ul>
<li>подготовленный объект запроса, который содержит единственный метод <code>read</code> для отложенного чтения присланных данных<br/>
из сокета;</li>
<li>объект ответа, который представляет собой канал, в который можно писать (вспомните описание протокола) все<br/>
перечисленные типы сообщений (<code>Chunk</code>, <code>Error</code>, <code>Choke</code>).</li>
</ul><p>Собственно, строками:

</p><pre><code class="python">rq = yield request.read()
message, size = msgpack.loads(rq)
</code></pre>
<p>
Мы считываем данные из сокета и распаковываем их. Зачем делать дополнительную запаковку, почему нельзя сразу написать что-то типа: </p><code>message, size = yield request.read()</code><p>? Не забывайте, что мы должны распаковать из сырых байтов какую-то структуру. В прошлый раз это была строка, в этот раз — кортеж. Нужен какой-то кодер/декодер. Для этой цели может сгодиться хоть </p><a href="http://www.json.org/">json</a><p>, хоть </p><a href="http://msgpack.org/">msgpack</a><p>, хоть </p><a href="https://code.google.com/p/protobuf/">protobuf</a><p>. Мы выбрали msgpack в этом примере, так как его реализации существуют для всех популярных языков и он быстрый.
</p><p>
После распаковки необходимых аргументов следует логика самого приложения. Завернув ее в большой try/except блок мы гарантируем, что все выкинутые исключения будут пойманы не фреймворком, а нами, и будут иметь необходимые нам коды ошибок и сообщения.

</p><strong>Это важно:</strong><p> если мы не поймаем исключение сами, это сделает фреймворк.
</p><p>
После проверки размера картинки у нас происходит ветвление. Если размер достаточно мал, то мы генерируем QR-код заново, в противном случае строками:

</p><pre><code class="python">key = '{0}size={1}'.format(message, size)
try:
    data = yield storage.read('qr-codes', key)
except ServiceError:
    data = generate_qr(message, size)
    yield storage.write('qr-codes', key, data)
</code></pre>
<p>
Мы формируем ключ и проверяем, есть ли такой документ в нашем хранилище по такому ключу. Если его нет, то вызванный метод </p><code>storage.read('qr-codes', key)</code><p> выбросит исключение. В этом случае мы все же генерируем картинку и сохраняем ее.

</p><strong>Это важно:</strong><p> операции </p><code>read</code><p> и </p><code>write</code><p> выполняются асинхронно. Каждый раз, когда мы в нашей корутине натыкаемся на ключевое слово </p><code>yield</code><p>, управление возвращается в цикл обработки событий. Обратно оно возвращается лишь тогда,</p><p>
когда наше ожидаемое событие настало. До сих пор обрабатываются </p><strong>остальные</strong><p> события. Так, если у нас сильно тормозит</p><p>
Storage, вполне реально ожидание тысяч корутин на методе </p><code>read</code><p>. Экономия ресурсов налицо.
</p><p>
После того, как мы тем или иным образом получим массив байтов с картинкой, мы его просто записываем в канал. Закроется он автоматически в </p><code>finally</code><p> блоке. Впрочем, если его не закрыть ясно, он закроется фреймворком, но в лог будет написано предупреждение.
</p><p>
Последовательность вызовов на этот раз будет такая:
</p><a href="http://beta.hstor.org/files/343/0b1/a79/3430b1a79b1f439aa5b93dfafd5004ec.jpg"/>
<p>
Если рассматривать полный путь запроса от пользователя к приложению, то мы получим:

</p>
<p>
Как проверить наше приложение? Аналогичным образом, как и проверяли </p><code>echo</code><p> приложение. Вновь загружаем наш код в Cocaine, используя </p><code>cocaine-tool</code><p>:

</p><pre><code class="python">cd src/qr &amp;&amp; cocaine-tool app upload &amp;&amp; cocaine-tool app start --name qr --profile profile@test
</code></pre>
<p>
Затем пишем небольшой клиентский код. На самом деле, тут различия от клиентского кода проверки </p><code>echo</code><p> приложения минимальны:
</p><pre><code class="python">import StringIO
import msgpack

from PIL import Image

from tornado.ioloop import IOLoop

from cocaine.futures import chain
from cocaine.services import Service

# Alias for more readability.
asynchronous = chain.source


if __name__ == '__main__':
    io_loop = IOLoop.current()
    service = Service('qr')

    @asynchronous
    def invoke(message):
        try:
            result = yield service.enqueue('generate', msgpack.dumps([message, 10]))
            print('Result:', result)
            out = StringIO.StringIO()
            out.write(result)
            out.seek(0)
            img = Image.open(out)
            img.save('qr.png', 'png')
        except Exception as err:
            print('Error: ', err)
        finally:
            io_loop.stop()

    invoke('What is best in life? To crush your enemies, see them driven before you, and to hear the lamentation of '
           'their women.')
    io_loop.start()
</code></pre>
<p>
Вся работа происходит в функции </p><code>invoke</code><p>, где мы отправляем запрос в наше приложение и ждем ответа. После того как ответ получен, мы просто записываем его в файл, используя библиотеку </p><code>PIL</code><p>.
</p><p>
Видите, достаточно несложно. Давайте теперь чуть-чуть расширим приложение, добавив него дополнительное событие, научив его отвечать по HTTP.

</p><strong>Это важно:</strong><p> для каждого фреймворка существуют различные способы добиться этого функционала.
</p><p>
В случае Питона все совсем просто: мы награждаем наш новый обработчик события </p><code>@http</code><p> декоратором. При этом (к сожалению Питон этого не показывает синтаксически) семантика передаваемых объектов </p><code>request</code><p> и </p><code>response</code><p> меняется. Объект запроса по-прежнему имеет единственный метод </p><code>read</code><p>, но в этом случае он возвращает не сырые байты, переданные в запросе, а уже подготовленный объект </p><code>cocaine.decorators.http._HTTPRequest</code><p>, хранящий всю необходимую информацию о запросе — заголовки, тело, параметры и т.п. Объект канала (</p><code>response</code><p>) в свою очередь имеет методы записи заголовков и тела ответа.
</p><p>
Код измененного приложения:

</p><pre><code class="python">&gt;#!/usr/bin/env python

import StringIO
import msgpack

import qrcode

from cocaine.exceptions import ServiceError
from cocaine.decorators import http
from cocaine.logging import Logger
from cocaine.services import Service
from cocaine.worker import Worker


storage = Service('storage')
log = Logger()


def generate_qr(message, size=10):
    if size &lt;= 0 or size &gt;= 20:
        raise ValueError('size argument must fit in [0; 20]')

    out = StringIO.StringIO()
    img = qrcode.make(message, box_size=size)
    img.save(out, 'png')
    return out.getvalue()


@http
def generate(request, response):
    request = yield request.read()
    try:
        message = request.request['message']
        size = int(request.request.get('size', 10))

        if size &lt; 10:
            data = generate_qr(message, size)
        else:
            key = '{0}size={1}'.format(message, size)
            try:
                data = yield storage.read('qr-codes', key)
            except ServiceError:
                data = generate_qr(message, size)
                yield storage.write('qr-codes', key, data)

        response.write_head(200, [('Content-type', 'image/png')])
        response.write(data)
    except KeyError:
        response.write_head(400, [('Content-type', 'text/plain')])
        response.write('Query field "message" is required')
    except Exception as err:
        response.write_head(400, [('Content-type', 'text/plain')])
        response.write(str(err))
    finally:
        response.close()


w = Worker()
w.run({
    'generate-http': generate
})
</code></pre>
<p>
Кроме декорирования функции обработчика события мы просто воспользовались новым API передаваемых объектов, никаких изменений функциональной части нет.

</p><strong>Обратите внимание:</strong><p> событие теперь называется </p><code>generate-http</code><p> — это просто переименование и ни на что не влияет.
</p><p>
Как это протестировать? Понятное дело, что раз теперь приложение отдает нам какой-то запакованный кортеж, состоящий из http-данных, то на клиентской части нам нужно всего лишь его распаковать. Но этот код мы писать не будем, потому что такие программы уже написаны, и о них было рассказано в предыдущих статьях. Речь идет о cocaine-proxy — специальной программе, которая слушает лицом HTTP, трансформирует его в запросы к облаку и делает обратные преобразования над полученным ответом. Во второй статье </p><a href="http://habrahabr.ru/company/yandex/blog/214069/">рассказывалось</a><p> как развернуть у себя </p><code>cocaine-native-proxy</code><p>. В случае, если вы по каким-то причинам сделать этого не смогли, можно воспользоваться </p><code>cocaine-tool</code><p>, которые имеют встроенную проксю для тестовых целей, написанную на Python, но которая по функционалу совпадает с вышеуказанной:

</p><pre><code class="python">cocaine-tool proxy start --count=32
</code></pre>
<p>
где </p><code>count</code><p> — число процессов, которые будут обрабатывать входящие запросы.

</p><strong>Это важно:</strong><p> в production окружении настоятельно рекомендуется пользоваться все же </p><code>cocaine-native-proxy</code><p>. Она быстрее, надежней и является основной проксей.
</p><p>
Итак, будем предполагать, что прокся успешно сконфигурирована и работает. Как ею пользоваться? На данный момент существует два паттерна ее использования.
</p><p>
Первый способ заключается в использовании URI синтаксиса. Обращение к интересующему нас приложению происходит следующим образом: </p><code>&lt;APP&gt;/&lt;METHOD&gt;[?&lt;Args&gt;]</code><p>.
</p><p>
Во втором способе имя приложения и события передается в заголовках </p><code>X-Cocaine-Service</code><p> и </p><code>X-Cocaine-Event</code><p> соответственно.
</p><p>
Мы будем пользоваться первым способом. В нашем случае URI запроса будет: </p><code>/qr/generate-http?message=Hello%20World!&amp;size=10</code><p>.
</p><p>
Сходим по нему браузером. Если все работает правильно, то в результате должно быть что-то вроде этого:

</p><img src="http://habrastorage.org/getpro/habr/post_images/e27/5b2/1c1/e275b21c116220c42d76259d221d8d19.png"/>

<strong>Это важно:</strong><p> через </p><code>cocaine-proxy</code><p> нельзя ходить в сервисы (например, в </p><code>Storage</code><p>) — только в приложения.

</p><h3>Подключаем нагрузку</h3><p>
В нашем облаке теперь находится самое настоящее приложение, совершающее, пусть и не самые ресурсозатратные, но все же и не тривиальные действия. От облачной платформы не очень много пользы, если она не будет подстраиваться под изменяющуюся нагрузку.
</p><p>
Так давайте же нагрузим наше приложение и проанализируем, как себя ведет Cocaine под нагрузкой.
</p><p>
Для этого воспользуемся утилитой </p><a href="http://httpd.apache.org/docs/2.2/programs/ab.html">ab</a><p>. План такой: мы будем стрелять в наше приложение, скажем, 100000 раз в 32 потока (столько же, сколько проксей) и посмотрим, как Cocaine будет себя вести при этом.
</p><p>
Предполагается, что одного инстанса приложения не хватит для разгребания всей очереди сообщений, поэтому будут</p><p>
созданы дополнительные экземпляры воркера. Мониторить текущее состояние </p><code>cocaine-runtime</code><p> мы будем, воспользовавшись</p><p>
командой:

</p><pre><code class="python">cocaine-tool info
</code></pre>
<p>
Если Cocaine не под нагрузкой, то будет выведено что-то типа:

</p><img src="http://habrastorage.org/getpro/habr/post_images/738/e5f/285/738e5f285e81aa7ec759d0e73b8f800e.png"/>
<p>
Кратко поясним, что же значат показанные параметры. Перед вами список приложений. Поле «state» говорит о текущем статусе приложения. Оно может быть запущено или сломано. Поля «slaves» показывают сколько экземпляров данного приложение запущено, сколько в данный момент обрабатывают запросы и максимальное количество экземпляров, которое может запустить Cocaine (конфигурируется в профиле). Поля «queue» показывают состояние очереди сообщений актора (то есть, сервиса) в настоящее время и ее максимальный размер. Поле профиля показывает, с каким профилем запущено приложение. Наконец, поля «sessions» показывают состояние сессий в данный момент, например, их количество. Напоминаем, что приложение может отвечать достаточно долго, используя каналы. Каждый такой канал — отдельная сессия.
</p><p>
Пальнем по нашему приложению! Выполните следующую команду и понаблюдайте, что творится в логах </p><code>cocaine-runtime</code><p> и </p><code>cocaine-tool info</code><p>:

</p><pre><code class="python">ab -n 100000 -c 32 'localhost:8080/qr/generate-http?message=Hello%20World!&amp;size=10'
</code></pre>
<p>
Имя хоста и номер порта, понятное дело, надо подставить свои. Эта команда начинает пальбу в 100000 запросов в 32 потока. При этом в моем случае </p><code>cocaine-runtime</code><p> понял, что одного воркера недостаточно для своевременой обработки запроса и наплодил целых 6 экземпляров нашего QR-приложения, что можно видеть в логах </p><code>cocaine-runtime</code><p> по строчке:

</p><pre><code class="python">[Tue Apr  8 15:36:18 2014] [INFO] app/qr: enlarging the pool from 5 to 6 slaves
</code></pre>
<p>
Показания </p><code>cocaine-tool info</code><p> в моем случае где-то в середине стрельбы были следующие:
</p><img src="http://habrastorage.org/getpro/habr/post_images/ee2/204/c2e/ee2204c2e1b6a79c4ba8050196f0885f.png"/><p>
Видно, что количество активных воркеров равно 6, при их максимальном количестве равном 10. В очереди запросов нет, но висит 7 активных сессий. Если нагрузка будет увеличиваться, то Cocaine будет пытаться сбалансировать ее, спавня дополнительные воркеры.
</p><p>
Наконец, когда пик нагрузки пройдет, внутренний балансировщик будет посылать приходящие сообщения в свободные воркеры по порядку. Если какие-то из них не получат сообщений в течение определенного количества времени — они будут жестоко и цинично убиты сигналом </p><code>SIGTERM</code><p>, который поймается фреймворком и сделает необходимые действия по освобождению занятых ресурсов.
</p><p>
Так выглядит жизненный цикл нашего приложения в Cocaine.

</p><h2>Но я не умею писать на Python!</h2><p>
Не беда! У нас же есть множество различных фреймворков под разные языки программирования, чье назначение — позволить пользователю (то есть нам) писать приложения на любимом языке, чтобы оно потом было доступно по единому интерфейсу.
</p><p>
В качестве примеров мы написали еще один аналогичный пример на Go, который делает практически то же самое, что и вышеуказанное приложение. Его код оставим без дополнительных объяснений, потому что не составит большого труда провести аналогии и понять, что и как работает. Тем более, что для каждого языка используются те средства, которые язык предоставляет.
</p><p>
В случае Go — это привычные каналы и горутины. Have fun!

</p><pre><code class="go">&gt;package main

import (
    "net/http"

    "code.google.com/p/rsc/qr"
    "github.com/ugorji/go/codec"

    "github.com/cocaine/cocaine-framework-go/cocaine"
)

//msgpack specific
var (
    mh codec.MsgpackHandle
    h  = &amp;mh
)

var (
    OkHeaders    cocaine.Headers = cocaine.Headers{[2]string{"Content-type", "image/png"}}
    ErrorHeaders cocaine.Headers = cocaine.Headers{[2]string{"Content-type", "text/plain"}}

    storage *cocaine.Service
)

const (
    cacheNamepspace = "qr-code"
    cacheTag        = "qr-tag"
)

func qenerate(text string) (png []byte, err error) {
    res := &lt;-storage.Call("read", cacheNamepspace, text)
    if res.Err() == nil {
        err = res.Extract(&amp;png)
        return
    }

    c, err := qr.Encode(text, qr.L)
    if err != nil {
        return
    }
    png = c.PNG()

    &lt;-storage.Call("write", cacheNamepspace, text, string(png), []string{cacheTag})
    return
}

func on_generate(request *cocaine.Request, response *cocaine.Response) {
    defer response.Close()
    inc := &lt;-request.Read()
    var task struct {
        Text string
        Size int
    }

    err := codec.NewDecoderBytes(inc, h).Decode(&amp;task)
    if err != nil {
        response.ErrorMsg(-100, err.Error())
        return
    }

    png, err := qenerate(task.Text)
    if err != nil {
        response.ErrorMsg(-200, err.Error())
        return
    }

    response.Write(png)
}

func on_http_generate(request *cocaine.Request, response *cocaine.Response) {
    defer response.Close()
    r, err := cocaine.UnpackProxyRequest(&lt;-request.Read())
    if err != nil {
        response.ErrorMsg(-200, err.Error())
        return
    }

    message := r.FormValue("message")
    if len(message) == 0 {
        response.Write(cocaine.WriteHead(http.StatusBadRequest, ErrorHeaders))
        response.Write("Missing argument `message`")
        return
    }

    png, err := qenerate(message)
    if err != nil {
        response.Write(cocaine.WriteHead(http.StatusInternalServerError, ErrorHeaders))
        response.Write("Unable to generate QR")
        return
    }

    response.Write(cocaine.WriteHead(http.StatusOK, OkHeaders))
    response.Write(png)
}

func main() {
    binds := map[string]cocaine.EventHandler{
        "generate":      on_generate,
        "generate-http": on_http_generate,
    }

    Worker, err := cocaine.NewWorker()
    if err != nil {
        panic(err)
    }

    storage, err = cocaine.NewService("storage")
    if err != nil {
        panic(err)
    }

    Worker.Loop(binds)
}

</code></pre>
<p>
Несмотря на различие в написании приложений, код клиентов для их тестирования не изменится! Попадая в Cocaine ваш код становится унифицированным и взаимозаменяемым.

</p><h2>Вместо заключения</h2>
<p>
Сегодня мы кратко рассмотрели основные возможности платформы Cocaine и средства, позволяющие писать различные приложения и клиенты к ним. Конечно, множество вопросов все еще поджидают впереди. Например, как писать сервисы, которые являются неотъемлемой частью Cocaine Runtime, или как добавить поддержку любимого языка. Конечно, у нас есть </p><a href="https://github.com/cocaine/cocaine-docs/blob/v0.11/doc/contents.md">документация</a><p>, которая охватывает большую часть проблем, но иногда и ее недостаточно. Еще больше вопросов могут возникать по мере практического опыта использования Cocaine.
</p><p>
Поэтому мы организуем </p><a href="http://tech.yandex.ru/events/meetings/cocaine_lab/">встречу</a><p>, о которой я сказал в самом начале поста. Если у вас есть или остались вопросы по Cocaine, или вам хочется узнать больше и попробовать его под присмотром опытных специалистов, приходите. А для тех, кто попасть на неё не сможет, мы, как обычно, организуем трансляцию.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>