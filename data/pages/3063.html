<html><body><div><div class="post-body entry-content" id="post-body-5294938857927513362" itemprop="description articleBody"><p>
This is the second part that talks about Python generic singleton pattern. In the </p><a href="http://tech.zarmory.com/2015/01/python-singleton-pattern-generic.html">first</a><p> part I've talked about decorator approach and now we'll look into classmethod approach.

</p><h2><code>@classmethod</code> approach</h2><p>
Another way to implement singleton is to prevent any actual instance creation and use our class itself as a singleton:

</p><pre class="code prettyprint">
class SingletonClass(object):
    __initialized = False

    def __new__(cls, *args, **kwargs):
        if not cls.__initialized:
            cls.__init__(*args, **kwargs)
            cls.__initialized = True
        return cls

class MyClass(SingletonClass):
   @classmethod
   def __init__(cls, x, y):
       print "init is here"
            
   @classmethod
   def do(cls):
       print "doing stuff"
</pre>

<p>The downside is that we now have to decorate each of our methods with <code>@classmethod</code> which is inconvenient and defies my original desire that I could turn any existing class into singleton.

</p><p>OK, so if we need to type <code>@classmethod</code> string before each and every method we define in <code>MyClass</code>, why don't we kindly ask Python do it for us? Metaclasses comes to mind - we actually want to convert all methods of the <code>MyClass</code> to classmethods. <code>MyClass</code> is created during its type <code>__new__</code> stage, so lets hook in:

</p><pre class="code prettyprint">
class SingletonClassMeta(type):
    def __new__(mcls, *args, **kwargs):
        cls = super(SingletonClassMeta, mcls).__new__(mcls, *args, **kwargs)
        for k, v in cls.__dict__.items():
            if isinstance(v, types.FunctionType):
                setattr(cls, k, classmethod(v))
        return cls

class SingletonClass(object):
    __metaclass__ = SingletonClassMeta
    __initialized = False
    ...
</pre>

<p>We just check that if <code>MyClass</code> has an attribute that is plain function, we convert this function to classmethod (decorators are just callables, so we are calling them :). Now the definition of <code>MyClass</code> is more elegant:

</p><pre class="code prettyprint">
class MyClass(SingletonClass):
   def __init__(cls, x, y):
       print "init is here"
            
   def do(cls):
       print "doing stuff"
</pre>

<p>This is almost perfect. I write my class as usual, just need to inherit from <code>SingletonClass</code>. I say "almost", because given third-party class <code>OtherClass</code> I still can not convert it to singleton. The below will NOT make <code>MyClass.do</code> to behave as if <code>MyClass</code> was a singleton:

</p><pre class="code prettyprint">
class OtherClass(object):
   def __init__(cls, x, y):
       print "init is here"
            
   def do(cls):
       print "doing stuff"

class MyClass(SingletonClass, OtherClass): pass
</pre>

<p>It does not do the trick because the metaclass's <code>__new__</code> augments attributes defined in our class (<code>MyClass</code> that is) and in the later case, <code>MyClass</code> does not define any attributes at all - they all are in its base class <code>OtherClass</code>.

</p><p>So how to solve this? Well, we could look through our <a href="https://www.python.org/download/releases/2.3/mro/">MRO</a> chain during metacalss <code>__new__</code> and to augment attributes of our base classes, but that's quite a destructive process - we screw things up for other regular users of a particular base class.

</p><p>To overcome this we need to hook in into attribute lookup mechanism of <code>MyClass</code>. Here is the revised metaclass:
</p><pre class="code prettyprint">
import types
class SingletonClassMeta(type):
    def __getattribute__(cls, attr):
        val = super(SingletonClassMeta, cls).__getattribute__(attr)
        if isinstance(val, types.MethodType) and not val.__self__:
            val = types.MethodType(val.__func__, cls, type(cls))
            # the above is equivalent to:
            # val = val.__func__.__get__(cls, type(cls))
        return val
</pre>

<p>Here our metaclass overloads the attribute lookup machinery:
</p><ul>
<li> We are doing regular attribute lookup
</li><li> Then we check that attribute value is an unbound method - by checking that it is a method and its <code>self is None</code>
</li><li> If its an unbound methond, we construct new, bound method on the fly from the original function
</li></ul>

<p>There is one rather long but important point to note here: 
</p><ul>
<li>Previously, code in <code>__new__</code> method change attributes of the class before they were ever accessed. Attribute retrieval machinery is described <a href="https://docs.python.org/2/howto/descriptor.html">here</a>, but in <em>very</em> short it can be summed as "Look the <code>__dict</code> of instance, its class and its parents. If whatever you found has <code>__get__</code> method, call it with current instance and its type and return result to the caller". 
</li><li><b>Every python function is a descriptor!</b> That is, when you stuff any function in some class <code>__dict__</code> and then try to retrieve it later as an attribute, descriptor protocol kicks in and returns bound/unbound methods instead. 
</li><li>Back to <code>__new__</code> - when we set class attribute, it needs to be something that would play nice with attribute lookup protocol. We used <code>classmethod</code> which is a decorator object that remembers a function and then acts as descriptor converting remembered function to bound (to class) method when it get fetched. We could (almost) equally just do <code>setattr(cls, k, functools.partial(v, cls))</code> - it would do the job as well, but would break semantics, because if someone would inspect our class methods it would see <code>&lt;functools.partial object...</code> instead of <code>&lt;bound method...</code>, that's why I prefer to use <code>classmethod</code>
</li><li>In our last example, we took <em>full</em> responsibility for object retrieval. Thus if we try to just return <code>classmethod(val.__func__)</code> we'd fail with 
<pre class="code prettyprint">
TypeError: 'classmethod' object is not callable
</pre>
We took the responsibility, so no one cares if we are returning a descriptor. That is, we need to build and return bound method by ourselves. Again, every function is a descriptor, i.e. every function has <code>__get__</code> method. You can construct method from any function - it does not even have to belong to any particular class:
<pre class="code prettyprint">
&gt;&gt;&gt; class C(object): pass
... 
&gt;&gt;&gt; def a(): pass
... 
&gt;&gt;&gt; a.__get__(C(), C) # instance method of C()
<bound method="" c.a="" of="" object="" at="">&gt;
&gt;&gt;&gt; 
&gt;&gt;&gt; a.__get__(C, type(C)) # class method of C
<bound method="" type.a="" of="">&gt;
&gt;&gt;&gt; 

</bound></bound></pre>
</li></ul>


<p/>
</div>
</div></body></html>