<html><body><div><div class="text">
                <p>Уже <a href="http://igorshevchenko.ru/blog/entries/hangman">известно</a>, что спастись от смерти на виселице можно с помощью жижи и цацки. Давайте попробуем узнать, как лучше играть в другую игру — в города.</p>
<p>Правила можно прочитать в <a href="http://ru.wikipedia.org/wiki/%D0%93%D0%BE%D1%80%D0%BE%D0%B4%D0%B0_%28%D0%B8%D0%B3%D1%80%D0%B0%29">википедии</a>: игроки по очереди называют города, каждый следующий начинается с последней буквы предыдущего. Там же предлагают стратегию:</p>
<blockquote>
<p>По не до конца выясненным лингвистическим причинам многие города мира начинаются и/или заканчиваются на букву «А», в связи с чем можно предполагать, что выиграет игрок, знающий больше городов на эту букву (Анапа, Алушта, Аделаида и т. д.).</p>
</blockquote>
<p>Для проверки этого утверждения потребуется список городов мира и немного кода на питоне.</p>
<h3>Получение списка городов</h3>
<p>Города — такая игра, в которую невозможно играть, не зная названий городов. Поэтому для анализа требуется словарь с городами на русском языке.</p>
<p>В интернете есть базы, которые в основном предназначены для использования на сайтах для указания города при регистрации. Но все они не понравились мне. Некоторые из них, обещая список полностью на русском языке, внезапно переходили на родной язык для городов из других стран. Для сайта это нормально, но играть в города так нельзя. А в остальных базах городов было слишком мало. Для проверки полноты я придумал «тест Аддис-Абебы», и ни одна из них его не прошла.</p>
<p>Пришлось вытаскивать названия из википедии. Там последней проблемы нет, и даже наоборот: уже на первой странице <a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%9D%D0%B0%D1%81%D0%B5%D0%BB%D1%91%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BF%D1%83%D0%BD%D0%BA%D1%82%D1%8B_%D0%BF%D0%BE_%D0%B0%D0%BB%D1%84%D0%B0%D0%B2%D0%B8%D1%82%D1%83">категории</a> можно увидеть <a href="http://ru.wikipedia.org/wiki/XVI_%D0%9F%D0%B0%D1%80%D1%82%D1%81%D1%8A%D0%B5%D0%B7%D0%B4">XVI Партсъезд</a> и <a href="http://ru.wikipedia.org/wiki/25_%D0%BA%D0%BC_%D0%96%D0%B5%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D0%B9_%D0%94%D0%BE%D1%80%D0%BE%D0%B3%D0%B8_%D0%9C%D0%BE%D0%BD%D1%87%D0%B5%D0%B3%D0%BE%D1%80%D1%81%D0%BA-%D0%9E%D0%BB%D0%B5%D0%BD%D1%8C%D1%8F">25 км Железной Дороги Мончегорск-Оленья</a>, а где-то дальше есть больше всего впечатливший меня <a href="http://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D1%91%D0%BB%D0%BE%D0%BA_%D0%90%D0%B1%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%AF%D1%89%D0%B8%D0%BA%D0%B0_001">Посёлок Абонентного Ящика 001</a>. Но это не так страшно, удалить всегда можно.</p>
<p>И сразу же код.</p>
<pre><code>import mwclient

def get_page_names():
    site = mwclient.Site('ru.wikipedia.org')
    category = site.Pages[u'Категория:Населённые пункты по алфавиту']
    return (page.name for page in category)
</code></pre>
<p>Для получения списка страниц категории будем обращаться к апи википедии, используя библиотеку <a href="https://github.com/mwclient/mwclient">mwclient</a>.</p>
<pre><code>def is_letter(c):
    return u'а' &lt;= c.lower() &lt;= u'я'


def starts_and_ends_with_letter(name):
    first = name[0]
    last = name[-1]
    return is_letter(first) and is_letter(last)
</code></pre>
<p>Так будем выбрасывать названия, которые начинаются или заканчиваются не на букву.</p>
<pre><code>def remove_braces(name):
    return name.split('(')[0].strip()
</code></pre>
<p>Хорошее название для города придумать трудно, поэтому они иногда повторяются. В таких случаях в википедии пишут в скобках пояснение, о каком городе эта статья. Нас это не интересует, поэтому скобки и всё, что после них, будем обрезать.</p>
<pre><code>def get_cities():
    used_cities = set()
    for name in get_page_names():
        city = remove_braces(name)
        if starts_and_ends_with_letter(city) and city not in used_cities:
            used_cities.add(city)
            yield city
</code></pre>
<p>Получим список городов, выбрасывая повторяющиеся и те, которые нам не подходят.</p>
<pre><code>import codecs

with codecs.open('cities.txt', 'w', 'utf8') as f:
    for city in get_cities():
        f.write(city + '\n')
</code></pre>
<p>Этот список сохраним в файл.</p>
<p>Полностью скрипт получился <a href="https://gist.github.com/igor-shevchenko/8340922#file-wikiget-py">таким</a>.</p>
<p>Извлеченный словарь содержит 130 тысяч городов. В нем еще мог остаться какой-то единичный мусор, который общую картину менять не должен.</p>
<h3>Анализ</h3>
<p>В отличие от виселицы, где можно было полностью перебирать словарь, здесь так сделать не получится. Есть 130 тысяч вариантов первого хода, потом в среднем 4 тысячи вариантов второго, потом еще 4 тысячи третьего... Все эти числа надо перемножить, и в итоге получится совершенно астрономическое количество вариантов. Но самое обидное, что если даже получится построить оптимальные стратегии для всех игроков, они окажутся бесполезными для игры с другим словарем. А словари вообще у каждого человека разные. Поэтому самое полезное, что можно сделать, — вычислить букву, на которую стоит обратить особое внимание (как в википедии).</p>
<p>Начнем с упрощения модели. В названиях городов для нас значимыми являются только первая и последняя буквы. Так список из 130 тысяч городов уменьшается до маленького ориентированного графа. Вершинами его будут буквы, а ребро из <em>x</em> в <em>y</em> будет иметь вес, равный количеству названий, начинающихся с <em>x</em> и заканчивающимися на <em>y</em>.</p>
<p>Может быть, в графе уже можно решать полным перебором? Там же всего 30 вариантов начала, 30 вариантов второго хода, 30 вариантов третьего, четвертого, пятого, шестого... Нет, тоже многовато.</p>
<p>Просто сравнить сумму весов исходящих и входящих ребер? Если на какую-то букву начинается мало городов, а заканчивается ею много, то ее можно хорошо использовать против соперника. Но реальность игры в города сложнее: ведь надо учитывать, из каких вершин надо попадать в эту вершину, как попадать в них и так далее. Поэтому используем более хитрый алгоритм.</p>
<p>У каждой буквы будет рейтинг, который зависит от ее связей. Входящие ребра будут передавать часть рейтинга от вершины, из который они выходят, и часть этого рейтинга будет уходить дальше через исходящие ребра. Вычисляется такой рейтинг с помощью алгоритма PageRank, про который я однажды уже <a href="http://igorshevchenko.ru/blog/entries/textrank">рассказывал</a>.</p>
<p>Перейдем к коду.</p>
<pre><code>def get_cities():
    with open('cities.txt') as f:
        for line in f:
            yield line.strip().decode('utf8').lower()
</code></pre>
<p>Достаем список городов из файла.</p>
<pre><code>def get_edge(city):
    return city[0], city[-1]
</code></pre>
<p>Определяем функцию для получения из города ребра (то есть начальной и конечной вершин).</p>
<pre><code>from collections import Counter

def get_weighted_edges(cities):
    counter = Counter(get_edge(city) for city in cities)
    return ((a, b, float(weight)) for (a, b), weight in counter.iteritems())
</code></pre>
<p>И еще одну, которая получает список городов и возвращает ребра в виде списка кортежей из начальной вершины, конечной вершины и веса. Здесь используется удобная способность контейнера Counter сразу же пересчитывать всё, что передается в него при инициализации.</p>
<pre><code>import networkx as nx

def get_graph():
    cities = get_cities()
    edges = get_weighted_edges(cities)
    g = nx.DiGraph()
    g.add_weighted_edges_from(edges)
    return g
</code></pre>
<p>Создаем ориентированный граф из этих ребер с использованием уже известной библиотеки <a href="http://networkx.github.io/">networkx</a>.</p>
<pre><code>def add_final_vertices(g):
    g.add_weighted_edges_from((v, v + u'_finish', 1.0) for v in g.nodes())
</code></pre>
<p>Пейджранки вершин будут показывать, насколько активно буква используется в процессе обычной игры. Чтобы оценить шансы каждой буквы завершить игру, создадим еще по одной вершине для каждой буквы, в которую будет идти ребро только из нее.</p>
<pre><code>def evaluate_letters():
    g = get_graph()
    add_final_vertices(g)
    pr = nx.pagerank(g)

    for a, b in sorted(pr.items(), key=lambda x: x[1]):
        if a[1:] == '_finish':
            print a[0], b
</code></pre>
<p>Посчитаем пейджранки и выведем результат. Результат получился таким:</p>
<pre><code>б 0.0047940481766
п 0.00479409201359
м 0.00479468124255
л 0.00479518712277
в 0.00479519556089
к 0.00479524573281
с 0.00479536849038
з 0.00479577419979
э 0.00479586689975
г 0.00479595151747
ч 0.00479598047734
д 0.00479609383531
т 0.00479638754244
ф 0.00479694481314
ш 0.00479694980713
х 0.0047970864409
ж 0.00479821870855
р 0.00479830237913
у 0.00480167551917
н 0.00480336443514
ю 0.00480600994751
ц 0.00480935947044
а 0.00480975757728
и 0.00481506621565
щ 0.00481612997918
о 0.00481980791183
я 0.00482062139306
е 0.00486013871912
й 0.00491924389476
ы 0.00593319978398
ь 0.0278309795176
</code></pre>
<p>Ой. Будем считать, что алгоритм прошел проверку на разумность: победил мягкий знак, на который некоторые города заканчиваются, но ни один не начинается. Поправим код, чтобы обрезать мягкий знак на конце слов. (А заодно и <em>ы</em>. Ыспарты и еще нескольких городов не достаточно, чтобы можно было нормально играть с ней.)</p>
<pre><code>def get_edge(city):
    return city[0], city.strip(u'ъыь')[-1]


def get_weighted_edges(cities):
    counter = Counter(get_edge(city) for city in cities if not city.startswith(u'ы'))
    return [(a, b, float(weight)) for (a, b), weight in counter.iteritems()]
</code></pre>
<p>Полностью код выглядит <a href="https://gist.github.com/igor-shevchenko/8340922#file-pagerank-py">так</a>, и он выдал такой результат:</p>
<pre><code>б 0.00450930556033
п 0.00450944258223
м 0.00451008313833
к 0.00451058888306
в 0.00451067983318
с 0.00451093647496
э 0.00451113552385
з 0.00451128722349
ч 0.00451135271873
г 0.00451146651546
д 0.0045119188442
х 0.00451228788221
т 0.00451237835021
ф 0.00451246102843
ш 0.0045125190597
л 0.00451323505599
ж 0.00451361765873
р 0.00451425487076
у 0.00451717313258
н 0.00451985073145
ю 0.00452106046281
а 0.0045266942414
щ 0.00453027578976
и 0.00453275391185
ц 0.00453579724983
о 0.00453796965795
я 0.00453843101065
е 0.00458125968474
й 0.00463979500792
</code></pre>
<p>Самой востребованной буквой оказалась <em>й</em>. На нее в использованном словаре заканчиваются 4093 слова, а начинаются с нее всего 187 слов.</p>
<h3>Проблема длиннейшего сиритори</h3>
<p>В ходе анализа я пытался найти чужие решения подобной задачи. За рубежом эта игра называется Geography и является частным случаем игры <a href="http://en.wikipedia.org/wiki/Word_chain">Word Chain</a>. Но результаты нашлись только для японского названия — сиритори (не путать с <a href="http://igorshevchenko.ru/blog/entries/wind-breath">упоротым авангардистом</a>).</p>
<p>От него получила имя задача, которая называется проблемой длиннейшего сиритори: построить из заданного словаря как можно большую цепочку в соответствии с правилами игры. Есть несколько японских статей об этой задаче. Вот <a href="http://research.nii.ac.jp/~hu/pub/ipsj02-ito.pdf">эта</a>, например. Ничего, кроме абстракта не понятно, но по картинкам видно, что у них тоже какие-то графы.</p>
<p>К счастью, есть <a href="http://siritori.info/report_siritori.pdf">статья</a> Даики Каваками (надеюсь, правильно транскрибировал) на английском, которая написана позднее и учитывает накопленный опыт по этому вопросу. Там предлагается интерактивный алгоритм, способный решить проблему длиннейшего сиритори.</p>
<p>Даики Каваками представляет словарь в виде такого же ориентированного графа, как у нас, а игру — как перемещение между вершинами с уменьшением веса использованного ребра на единицу. Решение задачи находится в процессе игры с использованием алгоритмов, называемых итераторами, которые оценивают текущее состояние и выбирают следующую вершину. В статье приводится три итератора:</p>
<ol>
<li>Первый выбирает вершину, в которую ведет самое тяжелое ребро.</li>
<li>Второй выбирает вершину, для которой сумма исходящих весов максимальна (то есть заглядывает на один шаг вперед).</li>
<li>Третий учитывает оба этих значения, складывая их с разными коэффициентами.</li>
</ol>
<p>Все эти алгоритмы прогнали на японских словарях. Выяснилось, что второй итератор работает значительно лучше первого, а для третий выдает свой наилучший результат, когда коэффициент для веса ребра из текущей вершины в следующую равен нулю (то есть когда третий итератор выдает тот же результат, что и второй). В общем, победа второго итератора.</p>
<p>Полученная с его помощью цепочка содержала 50% словаря, тогда как более ранние методы могли покрыть словарь только на 46%. (Из этого почему-то сделали вывод, что проблему длиннейшего сиритори теперь можно считать решенной. Не очень понял, почему результат нельзя улучшить еще, заглядывая вперед на два шага, например, ну да ладно.)</p>
<p>Этот алгоритм предлагает самый альтруистичный вариант игры: ходить так, чтобы у соперника был максимальный выбор ходов. Нас же интересует противоположная стратегия, которую можно получить из этой. Начнем с реализации исходного алгоритма.</p>
<pre><code>def get_out_weight(graph, vertex):
    return sum(d['weight'] for u, v, d in graph.out_edges(vertex, data=True))
</code></pre>
<p>Эта функция вычисляет вес всех ребер, исходящих из вершины.</p>
<pre><code>def choose_next_vertex(graph, vertex):
    possible_moves = [n for n in graph.neighbors(vertex)
                        if graph[vertex][n]['weight'] &gt; 0]
    if not possible_moves:
        return None
    scores = max((get_out_weight(graph, n), n) for n in possible_moves)
    return scores[1]
</code></pre>
<p>Эта функция выбирает следующую букву, используя алгоритм второго итератора.</p>
<pre><code>def run_shiritori_algorithm():
    g = get_graph()
    current_letter = choice(g.nodes())
    i = 0
    while True:
        next_letter = choose_next_vertex(g, current_letter)
        if not next_letter:
            print current_letter, i
            break
        g[current_letter][next_letter]['weight'] -= 1
        i += 1
        current_letter = next_letter
</code></pre>
<p>И вот так происходит само моделирование: переходим от буквы к букве, пока не окажемся в тупике. Начальная буква выбирается случайно.</p>
<p>Независимо от начальной буквы, при каждом запуске у меня всё всегда заканчивалось на букве <em>е</em> с цепочкой из примерно 49 тысяч слов. Покрытие 38%.</p>
<p>Теперь изменим стратегию так, чтобы выбиралась вершина, из которой ходов меньше всего. Для этого нужно всего лишь заменить <em>max</em> на <em>min</em> в функции <em>choose_next_vertex</em>. Полностью код можно посмотреть <a href="https://gist.github.com/igor-shevchenko/8340922#file-shiritori-py">здесь</a>.</p>
<p>Тогда игра будет заканчиваться после 372–373 городов. В букве <em>й</em>, конечно. Судя по тому, что длина цепочки в два раза больше количества городов, начинающихся с <em>й</em> (чуть меньше за счет Йенбая и Йосвайняя), вся игра представляла собой танцы вокруг этой буквы. То есть ничего примечательного в таком результате нет. Интересно, могут ли быть графы, в которых проблема кратчайшего сиритори решается не так скучно.</p>
<h3>Итог</h3>
<p>Как и википедия, я не могу объяснить лингвистические причины, из-за которых названий на букву <em>й</em> так мало, кроме того, что ее вообще считают ущербной. Зато городов, которые заканчиваются ею, достаточно много благодаря множеству топонимов-прилагательных. Список из четырех тысяч названий, грепнутый из использованного словаря, я выложил <a href="https://gist.github.com/igor-shevchenko/8341069">сюда</a>. Выберите оттуда штук двести городов, которые вам понравятся, и запомните до следующего раза, когда будете играть в города. Больше вам, скорее всего, не понадобится.</p>
            </div>
            </div></body></html>