<html><body><div><div class="post-body entry-content" id="post-body-6097196217242594404" itemprop="description articleBody">
<p>Сделал "пузомерку" для сравнения производительности
<a href="https://pypi.python.org/pypi/aiozmq">aiozmq</a> и <em>просто</em>
<a href="https://pypi.python.org/pypi/pyzmq/">pyzmq</a>.</p>
<p><em>aiozmq</em> использует <em>pyzmq</em> в своих внутренностях и стало интересно
 узнать, какие тормоза добавляет связка <em>aiozmq</em> + <em>asyncio</em> по
 сравнению с "простыми zmq сокетами".</p>
<p>Тест делался для пары <em>DEALER</em>/<em>ROUTER</em> (<em>RPC</em>) в разных режимах.</p>
<p>Результаты запуска <a href="https://github.com/aio-libs/aiozmq/blob/master/benchmarks/simple.py">измерителя
производительности</a>:</p>
<pre><code>(aiozmq)andrew@tiktaalik2:~/projects/aiozmq (master)$ python benchmarks/simple.py -n 10000
Run tests for 10*10000 iterations: ['aiozmq.rpc', 'core aiozmq', 'single thread raw zmq', 'single thread zmq with poller', 'zmq with threads']
..................................................

Results for aiozmq.rpc
RPS: 2469,   average: 0.405 ms

Results for core aiozmq
RPS: 5064,   average: 0.197 ms

Results for single thread raw zmq
RPS: 9895,   average: 0.101 ms

Results for single thread zmq with poller
RPS: 12574,  average: 0.080 ms

Results for zmq with threads
RPS: 9702,   average: 0.103 ms
</code></pre>
<p><em>zmq</em> шустрее, естественно. Обработка <strong>request-response</strong> на <em>zmq</em> в
 одном потоке примерно вдвое быстрее той же работы, которую делает
 <em>aiozmq</em> на своих транспортах и протоколах, плюс еще <em>asyncio</em>
 добавляет тормозов.</p>
<p>Даже на нитях (threads) <em>zmq</em> уверенно побеждает. В этом заслуга
<em>libzmq</em>, которая создает свой внутренний thread для обработки send и
в результате для Питона send получается неблокирующим.</p>
<p><em>aiozmq.rpc</em> добавляет тормозов по сравнению с <em>aiozmq.core</em> примерно
 в два раза. Я считаю это приемлемой платой за прозрачную
 упаковку/распаковку аргументов вызываемой функции, поиск обработчика
 на стороне сервера, проверку сигнатур для параметров, пробрасывания
 исключения назад вызывающей стороне.</p>
<p>Если всю эту необходимую работу сделать на <em>zmq</em> -- думаю, получится
не сильно быстрее.</p>
<h2 id="_1">Результат</h2>
<p><em>aiozmq.core</em> дает примерно 5000 <em>requests per second</em>, что довольно неплохо.</p>
<p><em>aiozmq.rpc</em> способен выжать примерно 2500 <em>rps</em>.</p>
<p>То есть если вас устраивает обработка запроса к <em>aiozmq.rpc</em> меньше
чем за одни <em>милисекунду</em> -- <em>aiozmq</em> вам подойдёт.</p>
<p>И, <strong>самое главное</strong>: если на стороне RPC сервера вы делаете запросы в
<em>redis, mongo, postgresql, mysql</em> или обращаетесь каким другим
<em>внешним для вашего процесса ресурсам</em> -- скорее всего тормоза будут
именно в этом месте.</p>
<h2 id="_2">Почему это не очень важно</h2>
<p>Да, я знаю что <em>redis</em> неимоверно быстр: показывает 70000+ <em>rps</em> на
простых запросах. Но скорее всего вам таких обращений потребуется
несколько, и делать вы их будете из питона используя библиотеку вроде
<a href="https://github.com/jonathanslenders/asyncio-redis">asyncio-redis</a>.</p>
<p>Которая добавляет немало приятных плюшек и расплачивается за это
<strong>производительностью</strong>.</p>
<p>Это не значит что за скорость не нужно бороться. Просто для меня
<em>aiozmq</em> показала ожидаемые и вполне неплохие результаты.  Самый
простой путь к ускорению лежит в оптимизации <em>asyncio</em> путём создания
<em>optional C Extensions</em> для <em>event loop</em> и <em>selector</em>. Возможно, я этим
займусь, или сделают другие Python Core Developers.  Как это произошло
с <a href="https://docs.python.org/dev/library/io.html">модулем io</a> из стандартной
библиотеки: после того как его переписали на С в Python 3.2 получили
30% ускорение.</p>
<p/>
</div>
</div></body></html>