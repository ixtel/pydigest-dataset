<html><body><div><p>If you have prior experience using template engines, the syntax should feel quite familiar.  Lines prefixed with a
colon (<tt>:</tt>) are “code”.  Lines prefixed with a hash mark (<cite>#</cite>) are comments.  All other lines are treated as
template text.  Template text is not allowed at the module level as it is not valid for a module to <tt>yield</tt>.</p>
<p>Code lines are processed by each of the different “block” and “inline” processor classes and runs of template text
are processed by the <tt>cinje.inline.text</tt> processor, with replacements processed by the <tt>cinje.util.chunk</tt>
helper function.</p>
<p>We use a shell-like argument format for illustrating the syntax.</p>
<div id="variable-replacement">
<h3>Variable Replacement</h3>
<p>There are several flavours of variable replacement available.  Within these use of curly braces is allowed only if
the braces are balanced.  Any of the helper functions mentioned can be overridden at the module or function level.</p>
<p>All variable replacement is a simple transformation of the source text into a function call wrapped version of the
source text.</p>
<div id="html-xml-escaped-replacement">
<h4>HTML/XML Escaped Replacement</h4>
<blockquote>
<tt><span class="pre">${&lt;expr&gt;}</span></tt> → <tt><span class="pre">_escape(&lt;expr&gt;)</span></tt></blockquote>
<p>The default replacement operator is a Python expression surrounded by <tt>${</tt> and <tt>}</tt>.  In the generated code your
expression will be wrapped in a call to <tt>_escape()</tt> which defaults to the <tt>escape</tt> function imported from the
<tt>cinje.helpers</tt> module.  If <tt>markupsafe</tt> is installed its escaping function will be used, otherwise the Python-
standard <tt>html.escape</tt> function will be used.  Please see the
<a href="https://pypi.python.org/pypi/MarkupSafe" rel="nofollow">MarkupSafe</a> documentation for a full description of the additional
capabilities it offers.  The result is appended to the current buffer.</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr><th>cinje</th>
<th>Python</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr><td><tt>${2+2}</tt></td>
<td><tt>_escape(2+2)</tt></td>
<td><tt>"4"</tt></td>
</tr>
<tr><td><tt><span class="pre">${"&lt;i&gt;Hi.&lt;/i&gt;"}</span></tt></td>
<td><tt><span class="pre">_escape("&lt;i&gt;Hi.&lt;/i&gt;")</span></tt></td>
<td><tt><span class="pre">"&amp;lt;i&amp;gt;Hi.&amp;lt;/i&amp;gt;"</span></tt></td>
</tr>
</tbody>
</table>
</div>
<div id="unescaped-replacement">
<h4>Unescaped Replacement</h4>
<blockquote>
<tt><span class="pre">#{&lt;expr&gt;}</span></tt> → <tt><span class="pre">_bless(&lt;expr&gt;)</span></tt></blockquote>
<p>The less-safe replacement does not escape HTML entities; you should be careful where this is used.  For trusted
data, though, this form is somewhat more efficient.  In the generated code your expression will be wrapped in a call
to <tt>_bless()</tt> which defaults to the <tt>bless</tt> function imported from the <tt>cinje.helpers</tt> module.  If
<tt>markupsafe</tt> is installed its <tt>Markup</tt> class will be used, otherwise the Python <tt>str</tt> function will be used.
The result is appended to the current buffer.</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr><th>cinje</th>
<th>Python</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr><td><tt>#{27*42}</tt></td>
<td><tt>_bless(27*42)</tt></td>
<td><tt>"1134"</tt></td>
</tr>
<tr><td><tt><span class="pre">#{"&lt;i&gt;Hi.&lt;/i&gt;"}</span></tt></td>
<td><tt><span class="pre">_bless("&lt;i&gt;Hi.&lt;/i&gt;")</span></tt></td>
<td><tt><span class="pre">"&lt;i&gt;Hi.&lt;/i&gt;"</span></tt></td>
</tr>
</tbody>
</table>
</div>
<div id="html-attributes-replacement">
<h4>HTML Attributes Replacement</h4>
<blockquote>
<tt><span class="pre">&amp;{&lt;argspec&gt;}</span></tt> → <tt><span class="pre">_args(&lt;argspec&gt;)</span></tt></blockquote>
<p>A frequent pattern in reusable templates is to provide some method to emit key/value pairs, with defaults, as HTML or
XML attributes.  To eliminate boilerplate cinje provides a replacement which handles this naturally and can help
users, especially users new to template engines, avoid certain common but hideous structures to conditionally add
attributes.</p>
<p>Attributes which are literally <tt>True</tt> have no emitted value.  Attributes which are literally <tt>False</tt> or <tt>None</tt>
are omitted.  Non-string iterables are treated as a space-separated set of strings, for example, for use as a set of
CSS classes.  Trailing underscores are removed, to allow for use of Python-reserved words.  Single underscores
(<tt>_</tt>) within the key are replaced with hyphens.  Double underscores (<tt>__</tt>) within a key are replaced with colons.</p>
<p>A value can be provided, then defaults provided using the <tt>key=value</tt> keyword argument style; if the key does not
have a value in the initial argument, the default will be used.</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr><th>cinje</th>
<th>Python</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr><td><tt>&amp;{autocomplete=True}</tt></td>
<td><tt>_args(autocomplete=True)</tt></td>
<td><tt>" autocomplete"</tt></td>
</tr>
<tr><td><tt>&amp;{autocomplete=False}</tt></td>
<td><tt>_args(autocomplete=False)</tt></td>
<td><tt>""</tt> (empty)</td>
</tr>
<tr><td><tt><span class="pre">&amp;{data_key="value"}</span></tt></td>
<td><tt><span class="pre">_args(data_key="value")</span></tt></td>
<td><tt>' <span class="pre">data-key="value"'</span></tt></td>
</tr>
<tr><td><tt><span class="pre">&amp;{xmlns__foo="bob"}</span></tt></td>
<td><tt><span class="pre">_args(xmlns__foo="bob")</span></tt></td>
<td><tt>' <span class="pre">xmlns:bob="foo"'</span></tt></td>
</tr>
<tr><td><tt><span class="pre">&amp;{name="Bob</span> Dole"}</tt></td>
<td><tt><span class="pre">_args(name="Bob</span> Dole")</tt></td>
<td><tt>' <span class="pre">name="Bob</span> Dole"'</tt></td>
</tr>
<tr><td><tt>&amp;{somevar, default=27}</tt></td>
<td><tt>_args(somevar, <span class="pre">default="hello")</span></tt></td>
<td>(depends on <tt>somevar</tt>)</td>
</tr>
</tbody>
</table>
<p>A preceeding space will be emitted automatically if any values would be emitted.  The following would be correct:</p>
<pre>&lt;meta&amp;{name=name, content=content}&gt;
</pre>
</div>
<div id="formatted-replacement">
<h4>Formatted Replacement</h4>
<blockquote>
<tt><span class="pre">%{&lt;expr&gt;</span> &lt;argspec&gt;}</tt> → <tt><span class="pre">_bless(&lt;expr&gt;).format(&lt;argspec&gt;)</span></tt></blockquote>
<p>Modern string formatting in Python utilizes the <tt>str.format</tt> string formatting system.  To facilitate replacements
using the advanced formatting features available in <tt>markupsafe</tt> while removing common boilerplate the “formatted
replacement” is made available.  Your source expression undergoes some mild reformatting, similar to that applied to
function declarations, seen later.</p>
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr><th>cinje</th>
<th>Python</th>
</tr>
</thead>
<tbody>
<tr><td><tt>%{somevar 42, num=27}</tt></td>
<td><tt><span class="pre">_bless(somevar).format(42,</span> num=27)</tt></td>
</tr>
<tr><td><tt><span class="pre">%{"Lif:</span> {}  {num}" 42, num=27}</tt></td>
<td><tt><span class="pre">_bless("Lif:</span> {}  <span class="pre">{num}").format(42,</span> num=27)</tt></td>
</tr>
</tbody>
</table>
<p>Any expression can be used for the “format string” expression, however for sanity’s sake it’s generally a good idea to
keep it as a short string literal or provide it from a variable.</p>
<p><strong>Note:</strong> The format string is blessed, meaning it should not be sourced from user-supplied data, for security
reasons.  When MarkupSafe is <em>not</em> installed the replacements are passed through to Python-standard string formatting.
If, however, MarkupSafe <em>is</em> installed, then the replacements are escaped prior to formatting and additional
functionality is available to make your objects HTML-formatting aware.  (See the MarkupSafe documentation.)</p>
</div>
<div id="json-object-replacement">
<h4>JSON Object Replacement</h4>
<blockquote>
<tt><span class="pre">@{&lt;expr&gt;}</span></tt> → <tt><span class="pre">_json(&lt;expr&gt;)</span></tt></blockquote>
<p>It is sometimes useful to pass data through a template to JavaScript. This will emit the JSON-serialized version of
the expression result.</p>
</div>
</div>
<div id="block-transformations">
<h3>Block Transformations</h3>
<p>Block transformations typically denote some form of scope change or flow control, and must be terminated with an
“end” instruction.  Blocks not terminated by the end of the file will be automatically terminated, allowing trailing
terminators to be elided away and omitted from most templates.</p>
<div id="module-scope">
<h4>Module Scope</h4>
<p>This is an automatic transformer triggered by the start of a source file.  It automatically adds a few imports to the
top of your file to import the required helpers from cinje.</p>
</div>
<div id="function-declaration">
<h4>Function Declaration</h4>
<blockquote>
<tt>: def <span class="pre">&lt;name-literal&gt;[</span> &lt;argspec&gt;]</tt> → <tt>def <span class="pre">&lt;name-literal&gt;([&lt;argspec&gt;][&lt;scope-binding&gt;]):</span></tt></blockquote>
<p>Lines beginning with <tt>: def</tt> are used to declare functions within your template source:</p>
<pre>: def somefunction
        Hello world!
: end
</pre>
<p>The above transforms to, roughly, the following Python source:</p>
<pre>def somefunction(*, _escape=_escape, _bless=_bless):
        _buffer = []
        _buffer.append(_bless("\tHello world!\n"))
        yield ''.join(_buffer)
</pre>
<p>You do not need the extraneous trailing colon to denote the end of the declaration, nor do you need to provide
parenthesis around the argument specification.  The optimization keyword-only arguments will be added automatically to
the argument specification you give on non-Pypy Python 3 versions.  It will gracefully handle integration into your
arglist even if your arglist already includes the keyword-only marker, or combinations of <tt>*args</tt> or <tt>**kw</tt>.</p>
</div>
<div id="flow-control">
<h4>Flow Control</h4>
<blockquote>
<tt>: &lt;statement&gt;</tt> → <tt>&lt;statement&gt;:</tt></blockquote>
<p>Cinje is fairly agnostic towards most Python flow control statements.  The <tt>cinje.block.generic</tt> transformer handles
most Python block scope syntax.  These include:</p>
<ul>
<li><strong>Conditionals</strong> including <tt>if</tt>, <tt>elif</tt>, and <tt>else</tt>.</li>
<li><strong>Iterators</strong> including <tt>while</tt>, and <tt>for</tt>, inlcuding the <tt>else</tt> block for <tt>for</tt> loops.</li>
<li><strong>Context managers</strong> via <tt>with</tt>.</li>
<li><strong>Exception handling</strong> including <tt>try</tt>, <tt>except</tt>, <tt>finally</tt>, and <tt>else</tt>.</li>
</ul>
<p>In all cases the only real transformation done is moving the colon from the beginning of the declared line to the end.</p>
<p>A helper is provided called <tt>iterate</tt> which acts similarly to <tt>enumerate</tt> but can provide additional details.
It’s a generator that yields <tt>namedtuple</tt> values in the form <tt>(first, last, index, total, value)</tt>.  If the current
loop iteration represents the first iteration, <tt>first</tt> will be True.  Similarly—and even for generators where a
total number of values being iterated could not be calculated beforehand—on the final iteration <tt>last</tt> will be True.
The <tt>index</tt> value is an atomic counter provided by <tt>enumerate</tt>, and <tt>total</tt> will be the total number of elements
being iterated if the object being iterated supports length determination.  You can loop over its results directly:</p>
<pre>: for item in iterate(iterable)
        : if item.first
                …
        : end
: end
</pre>
<p>You can also unpack them:</p>
<pre>: for first, last, index, total, value in iterate(iterable)
        …
: end
</pre>
<p>If you wish to unpack the values being iterated, you can wrap the additional unpacking in a tuple:</p>
<pre>: for first, last, i, total, (foo, bar, baz) in iterate(iterable)
        …
: end
</pre>
</div>
</div>
<div id="inline-transformations">
<h3>Inline Transformations</h3>
<p>Inline transformations are code lines that do not “start” a section that subsequently needs an “end”.</p>
<div id="code">
<h4>Code</h4>
<p>Lines prefixed with a colon (<tt>:</tt>) that aren’t matched by another transformation rule are treated as inline Python
code in the generated module.  Within these bits of code you do have access to the helpers and buffer, and so can
easily customize template rendering at will.</p>
<p>The only lines acceptable at the module scope are code and comments.</p>
</div>

<div id="flush">
<h4>Flush</h4>
<p>The <tt>: flush</tt> statement triggers cinje to emit the Python code needed to yield the current contents of the template
buffer and clear it.  The result, in Python, is roughly analogous to:</p>
<pre>yield ''.join(_buffer)
_buffer.clear()
</pre>
<p>A flush is automatically triggered when falling off the bottom of a template function if it is known that there will
be un-flushed text in the buffer.  (Processing context marked with the “dirty” flag.)</p>
</div>
<div id="text">
<h4>Text</h4>
<p>Text covers every other line present in your template source.  Cinje efficiently gathers consecutive lines of template
text, collapses runs of static text into single strings, and splits the template text up to process replacements.</p>
<p>Template text is not permitted at the module scope as there can be no way to “yield” the buffer from there.  To save
on method calls, the following:</p>
<pre>&lt;meta&amp;{name=name, content=content}&gt;
</pre>
<p>Is transformed, roughly, into the following single outer call and three nested calls:</p>
<pre>__w((
        _bless('&lt;meta'),
        _args(name=name, content=content),
        _bless('&gt;')
))
</pre>
<p>See the Variable Replacement section for details on the replacement options that are available and how they operate.</p>
</div>
</div>
<div id="inheritance">
<h3>Inheritance</h3>
<p>Due to the streaming and “native Python code” natures of cinje, template inheritance is generally handled through
the standard definition of functions, and passing of those first-class objects around.  The most common case, where
one template “wraps” another, is handled through the <tt>: using</tt> and <tt>: yield</tt> directives.</p>
<p>An example “wrapper” template:</p>
<pre>: def page **properties
&lt;html&gt;
        &lt;body&amp;{properties}&gt;
                : yield
        &lt;/body&gt;
&lt;/html&gt;
: end
</pre>
<p>When called, functions that include a bare yield (and only one is allowed per function) will flush their buffers
automatically prior to the yield, then flush automatically at the end of the function, just like any other.  This has
the effect of extending the wrapped template’s buffer by, at a minimum, two elements (prefix and suffix), though
additional <tt>: flush</tt> statements within the wrapper are allowed.</p>
<p><strong>Note:</strong> Because the bare yield will produce a value of <tt>None</tt>, wrapping functions like these are <strong>not</strong>
safe for use as a WSGI body iterable without wrapping in a generator to throw away <tt>None</tt> values.</p>
<p>The syntax for the <tt>using</tt> directive is <tt>: using &lt;expr&gt;[ &lt;argspec&gt;]</tt>, thus to use this wrapper:</p>
<pre>: using page
        &lt;p&gt;Hello world!&lt;/p&gt;
: end
</pre>
<p>Execution of this would produce the following HTML:</p>
<pre>&lt;html&gt;
        &lt;body&gt;
                &lt;p&gt;Hello world!&lt;/p&gt;
        &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Because wrapping templates are just template functions like any other, you can pass arguments to them.  In the above
example we’re using arbitrary keyword arguments as an “HTML attribute” replacement.  The following:</p>
<pre>: using page class_="hero"
: end
</pre>
<p>Would produce the following:</p>
<pre>&lt;html&gt;
        &lt;body class="hero"&gt;
        &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Lastly, there is a quick shortcut for consuming a template function and injecting its output into the current buffer:</p>
<pre>: use &lt;expr&gt;[ &lt;argspec&gt;]
</pre>
<p>And directly transforms to:</p>
<pre>__w(&lt;expr&gt;(&lt;argspec&gt;))
</pre>
<p>Just like with <tt>using</tt>, the result of the expression must be a callable generator function.</p>
</div>
</div></body></html>