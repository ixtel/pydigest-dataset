<html><body><div><div class="content html_format"><p>
      В этой статье пойдёт речь о том, как реализован словарь в Python. Я постараюсь ответить на вопрос, почему элементы словаря не упорядочены, описать, каким образом словари хранят, добавляют и удаляют свои элементы. Надеюсь, что статья будет полезна не только людям, изучающим Python, но и всем, кто интересуется внутренним устройством и организацией структур данных.</p>
<a name="habracut"/><p>
На написание этой статьи меня натолкнул </p><a href="http://stackoverflow.com/questions/8271139/why-is-early-return-slower-than-else">вопрос</a><p> на Stack Overflow.</p><p>
В статье рассматривается реализация CPython версии 2.7. Все примеры были подготовлены в 32-битной версии Python на 64-битной ОС, для другой версии значения будут отличаться.

</p><h4>Словарь в Python</h4><p>
Словарь в Python является ассоциативным массивом, то есть хранит данные в виде пар (ключ, значение). Словарь – измененяемый тип данных. Это значит, что в него можно добавлять элементы, изменять их и удалять из словаря. Он также предоставляет операцию поиска и возвращения элемента по ключу.
</p><p>
Инициализация и добавление элементов:

</p><pre><code class="python">&gt;&gt;&gt; d = {} # то же самое, что d = dict()
&gt;&gt;&gt; d['a'] = 123
&gt;&gt;&gt; d['b'] = 345
&gt;&gt;&gt; d['c'] = 678
&gt;&gt;&gt; d
{'a': 123, 'c': 678, 'b': 345}
</code></pre><p>
Получение элемента:

</p><pre><code class="python">&gt;&gt;&gt; d['b']
345
</code></pre><p>
Удаление элемента:

</p><pre><code class="python">&gt;&gt;&gt; del d['c']
&gt;&gt;&gt; d
{'a': 123, 'b': 345}
</code></pre><p>
Ключами словаря могут быть значения только hashable типов, то есть типов, у которых может быть получен хэш (для этого у них должен быть метод __hash__()). Поэтому значения таких типов, как список (list), набор (set) и собственно сам словарь (dict), не могут быть ключами словаря:

</p><pre><code class="python">&gt;&gt;&gt; d[list()] = 1
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
&gt;&gt;&gt; d[set()] = 2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'set'
&gt;&gt;&gt; d[dict()] = 3
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'dict'
</code></pre>

<h4>Реализация</h4><p>
Словарь в Python реализован в виде хэш-таблицы. Как известно, реализация хэш-таблицы должна учитывать возможность появления коллизий – ситуаций, когда разные ключи имеют одинаковое значение хэша. Должен быть способ вставки и извлечения элементов с учётом коллизий. Существует несколько способов разрешения коллизий, например метод цепочек и метод открытой адресации. В Python используется метод открытой адресации. Разработчики предпочли метод открытой адресации методу цепочек ввиду того, что он позволяет значительно сэкономить память на хранении указателей, которые используются в хэш-таблицах с цепочками. 
</p><p>
В рассматриваемой реализации каждая запись (PyDictEntry) в хэш-таблице словаря состоит из трёх элементов – хэш, ключ и значение.

</p><pre><code class="cpp">typedef struct {
  Py_ssize_t me_hash;
  PyObject *me_key;
  PyObject *me_value;
} PyDictEntry;
</code></pre><p>
Структура PyDictObject выглядит следующим образом:

</p><pre><code class="cpp">#define PyDict_MINSIZE 8
typedef struct _dictobject PyDictObject;
struct _dictobject {
  PyObject_HEAD
  Py_ssize_t ma_fill;
  Py_ssize_t ma_used;
  Py_ssize_t ma_mask;
  PyDictEntry *ma_table;
  PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
  PyDictEntry ma_smalltable[PyDict_MINSIZE];
};
</code></pre><p>
При создании нового объекта словаря его размер равен 8. Это значение определяется константой PyDict_MINSIZE. Для хранения хэш-таблицы в PyDictObject были введены переменные ma_smalltable и ma_table. Переменная ma_smalltable с предвыделенной памятью размером PyDict_MINSIZE (то есть 8) позволяет небольшим словарям (до 8 объектов PyDictEntry) храниться без дополнительного выделения памяти. Эксперименты, проведённые разработчиками, показали, что этого размера вполне достаточно для большинства словарей: небольших словарей экземпляров и обычно небольших словарей, созданных для передачи именованных аргументов (kwargs). Переменная ma_table соответствует ma_smalltable для маленьких таблиц (то есть для таблиц из 8 ячеек). Для таблиц большего размера память ma_table выделяется отдельно. Переменная ma_table не может быть равна NULL.
</p><p>
Если кому-то вдруг захочется изменить значение PyDict_MINSIZE, это можно сделать в исходниках, а затем пересобрать Python. Значение рекомендуется делать равным степени двойки, но не меньше четырёх.

</p><h4>Ячейка в хэш-таблице может иметь три состояния</h4><p>
1) Неиспользованная (me_key == me_value == NULL)</p><p>
Данное состояние означает, что ячейка не содержит и ещё никогда не содержала пару (ключ, значение). </p><p>
После вставки ключа «неиспользованная» ячейка переходит в состояние «активная».</p><p>
Это состояние – единственный случай, когда me_key = NULL и является начальным состоянием для всех ячеек в таблице.</p><p>
2) Активная (me_key != NULL и me_key != dummy и me_value != NULL)</p><p>
Означает, что ячейка содержит активную пару (ключ, значение).</p><p>
После удаления ключа ячейка из состояния «активная» переходит в состояние «пустая» (то есть me_key = dummy, а </p><p>
dummy = PyString_FromString("&lt;dummy key&gt;")).</p><p>
Это единственное состояние, когда me_value != NULL.</p><p>
3) Пустая (me_key == dummy и me_value == NULL)</p><p>
Это состояние говорит о том, что ячейка ранее содержала активную пару (ключ, значение), но она была удалена, и новая активная пара ещё не записана в ячейку.</p><p>
Так же как и при состоянии «неиспользованная», после вставки ключа ячейка из состояния «пустая» переходит в состояние «активная».</p><p>
«Пустая» ячейка не может вернуться в состояние «неиспользованная», то есть вернуть me_key = NULL, так как в данном случае последовательность проб в случае коллизии не будет иметь возможность узнать, были ли ячейки «активны».

</p><h4>Переменные-члены структуры</h4><p>
ma_fill – число ненулевых ключей (me_key != NULL), то есть сумма «активных» и «пустых» ячеек.</p><p>
ma_used – число ненулевых и не «пустых» ключей (me_key != NULL, me_key != dummy), то есть число «активных» ячеек.</p><p>
ma_mask – маска, равная PyDict_MINSIZE — 1.</p><p>
ma_lookup – функция поиска. По умолчанию при создании нового словаря используется lookdict_string. Так сделано потому, что разработчики посчитали, что большинство словарей содержат только строковые ключи.

</p><h4>Основные тонкости</h4><p>
Эффективность хэш-таблицы зависит от наличия «хороших» хэш-функций. «Хорошая» хэш-функция должна вычисляться быстро и с минимальным количеством коллизий. Но, к сожалению, наиболее часто используемые и важные хэш-функции (для строкового и целого типов) возвращают достаточно регулярные значения, что приводит к коллизиям. Возьмём пример:

</p><pre><code class="python">&gt;&gt;&gt; map(hash, [0, 1, 2, 3, 4])
[0, 1, 2, 3, 4]
&gt;&gt;&gt; map(hash, ['abca', 'abcb', 'abcc', 'abcd', 'abce'])
[1540938117, 1540938118, 1540938119, 1540938112, 1540938113]
</code></pre><p>
Для целых чисел хэшами являются их значения, поэтому подряд идущие числа будут иметь подряд идущие хэши, а для строк подряд идущие строки имеют практически подряд идущие хэши. Это не обязательно плохо, напротив, в таблице размером 2**i взятие i младших бит хэша как начального индекса таблицы выполняется очень быстро, и для словарей, проиндексированных последовательностью целых чисел, коллизий не будет вообще:

</p><img src="https://habrastorage.org/files/608/1d4/f5c/6081d4f5c6a5432192e379b3f2b5cf5e.png"/>
<p>
То же самое будет почти полностью соблюдаться, если ключи словаря – это «подряд идущие» строки (как в примере выше). В общих случаях это дает более чем случайное поведение, что и требуется.

</p><img src="https://habrastorage.org/files/262/99b/969/26299b969d0d4f8eaf00de6fc4db3e93.png"/>
<p>
Взятие только i младших бит хэша в качестве индекса также уязвимо к коллизиям: например, возьмём список [i &lt;&lt; 16 for i in range(20000)] в качестве набора ключей. Так как целые являются их собственными хэшами и это вписывается в словарь размера 2**15 (так как 20000 &lt; 32768), последние 15 бит от каждого хэша все будут равны 0.

</p><pre><code class="python">&gt;&gt;&gt; map(lambda x: '{0:016b}'.format(x), [i &lt;&lt; 16 for i in xrange(20000)])
['0000000000000000', '10000000000000000', '100000000000000000', '110000000000000000', '1000000000000000000', '1010000000000000000', '1100000000000000000', '1110000000000000000', ...]
</code></pre><p>
Получится, что все ключи будут иметь один и тот же индекс. То есть для всех ключей (кроме первого) произойдут коллизии. </p><p>
Примеры специально подобранных «плохих» случаев не должны влиять на обычные случаи, так что просто оставим взятие последних i бит. Всё остальное отдаётся на откуп методу разрешения коллизий.

</p><h4>Метод разрешения коллизий</h4><p>
Процедура выбора подходящей ячейки для вставки элемента в хэш-таблицу называется пробирование, а рассматриваемая ячейка-кандидат – проба.
</p><p>
Обычно ячейка находится с первой попытки (и это действительно так, ведь коэффициент заполнения хэш-таблицы держится ниже 2/3), что позволяет не тратить время на пробирование и делает расчет начального индекса очень быстрым. Но давайте рассмотрим, что случится, если произойдёт коллизия. 
</p><p>
Первая часть метода разрешения коллизий заключается в расчёте индексов таблицы для пробирования с помощью формулы: 

</p><pre><code class="python">j = ((5 * j) + 1) % 2**i
</code></pre><p>
Для любого начального j в пределах [0..(2**i — 1)] вызов данной формулы 2**i раз вернёт каждое число в пределах [0..(2**i — 1)] ровно один раз. Например:

</p><pre><code class="python">&gt;&gt;&gt; j = 0
&gt;&gt;&gt; i = 3
&gt;&gt;&gt; for _ in xrange(0, 2**i):
...     print j,
...     j = ((5 * j) + 1) % 2**i
...
0 1 6 7 4 5 2 3
</code></pre><p>
Вы скажете, что это ничем не лучше использования линейного пробирования с постоянным шагом, ведь в данном случае ячейки в хэш-таблице также просматриваются в определенном порядке, но это не единственное отличие. В общих случаях, когда хэш значения ключей идут подряд, данный метод лучше линейного пробирования. Из примера выше можно проследить, что для таблицы размером 8 (2**3) порядок индексов будет следующим:

</p><pre><code class="python">0 -&gt; 1 -&gt; 6 -&gt; 7 -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 3 -&gt; 0 -&gt; … (затем идут повторения)
</code></pre><p>
Если произойдёт коллизия для пробы с индексом, равным 5, то следующий индекс пробы будет 2, а не 6, как в случае линейного пробирования с шагом +1, поэтому для ключа, добавляемого в будущем, индекс пробы которого будет равен 6, коллизии не произойдёт. Линейное пробирование в данном случае (при последовательных значениях ключей) было бы плохим вариантом, так как происходило бы много коллизий. Вероятность же того, что хэш значения ключей будут идти в порядке 5 * j + 1, намного меньше.
</p><p>
Вторая часть метода разрешения коллизий заключается в использовании не только младших i бит хэша, но и остальных бит тоже. Это реализовано с использованием переменной perturb следующим образом:

</p><pre><code class="python">    j = (5 * j) + 1 + perturb
    perturb &gt;&gt;= PERTURB_SHIFT
    затем j % 2**i используется как следующий индекс пробы
где:
    perturb = hash(key)
    PERTURB_SHIFT = 5
</code></pre><p>
После этого последовательность проб будет зависеть от каждого бита хэша. Псевдослучайное изменение очень эффективно, потому что быстро увеличивает различия в битах. Так как переменная perturb – беззнаковая, то, если пробирование выполняется достаточно часто, переменная perturb в конечном итоге становится и остаётся равной нулю. В этот момент (который достигается очень редко) результат j снова становится равен 5 * j + 1. Далее поиск происходит точно так же, как в первой части метода, и свободная ячейка в конечном счете будет найдена, поскольку, как было сказано ранее, каждое число в диапазоне [0..(2**i — 1)] будет возвращено ровно один раз, и мы уверены, что всегда есть по крайней мере одна «неиспользованная» ячейка. 
</p><p>
Выбор «хорошего» значения для PERTURB_SHIFT – это вопрос балансировки. Если сделать его малым, то старшие биты хэша будут влиять на последовательность проб по итерациям. Если же сделать его большим, то в действительно «плохих» случаях старшие биты хэша будут оказывать влияние только на ранних итерациях. В результате экспериментов, которые провёл один из разработчиков Python – Тим Питерс, значение PERTURB_SHIFT было выбрано равным 5, так как это значение оказалось «лучшим». То есть показало минимальное общее число коллизий как для нормальных, так и для специально подобранных «плохих» случаев, хотя значения 4 и 6 не были значительно хуже.
</p><p>
Историческая справка: Один из разработчиков Python, Реймер Берендс, предлагал идею использования подхода расчёта индексов таблицы, основанного на многочленах, который затем был улучшен Кристианом Тисмером. Этот подход также показал отличные результаты по возникновению коллизий, но требовал больше операций, а также дополнительной переменной для хранения многочлена таблицы в структуре PyDictObject. В экспериментах Тима Питерса текущий, используемый в Python метод оказался быстрее, показывая в равной степени хорошие результаты по возникновению коллизий, но требовал меньше кода и использовал меньше памяти.

</p><h4>Инициализация словаря</h4><p>
Когда вы создаёте словарь, вызывается функция PyDict_New. В этой функции последовательно выполняются следующие операции: происходит выделение памяти для нового объекта словаря PyDictObject. Переменная ma_smalltable очищается. Переменные ma_used и ma_fill приравниваются 0, ma_table становится равной ma_smalltable. Значение ma_mask приравнивается PyDict_MINSIZE — 1. Функция для поиска ma_lookup делается равной lookdict_string. Возвращается созданный объект словаря.

</p><h4>Добавление элемента</h4><p>
При добавлении элемента в словарь или изменении значения элемента в словаре вызывается функция PyDict_SetItem. В этой функции берётся значение хэша и вызывается функция insertdict, а также функция dictresize, если таблица заполняется на 2/3 от текущего размера.
</p><p>
В свою очередь в функции insertdict происходит вызов lookdict_string (или lookdict, если в словаре есть не строковый ключ), в которой происходит поиск свободной ячейки в хэш-таблице для вставки. Эта же функция используется для нахождения ключа при извлечении.
</p><p>
Начальный индекс пробы в этой функции рассчитывается как хэш ключа, поделённый по модулю на размер таблицы (таким образом, происходит взятие младших бит хэша). То есть: 

</p><pre><code class="python">&gt;&gt;&gt; PyDict_MINSIZE = 8
&gt;&gt;&gt; key = 123
&gt;&gt;&gt; hash(key) % PyDict_MINSIZE
&gt;&gt;&gt; 3
</code></pre><p>
В Python это реализовано с использованием логической операции «И» и маски. Маска равна следующему значению: mask = PyDict_MINSIZE — 1.

</p><pre><code class="python">&gt;&gt;&gt; PyDict_MINSIZE = 8
&gt;&gt;&gt; mask = PyDict_MINSIZE - 1
&gt;&gt;&gt; key = 123
&gt;&gt;&gt; hash(key) &amp; mask
&gt;&gt;&gt; 3
</code></pre><p>
Так получаются младшие биты хэша:</p><p>
2**i = PyDict_MINSIZE, отсюда i = 3, то есть достаточно трёх младших бит.</p><p>
hash(123) = 123 = 1111011</p><sub>2</sub><p>
mask = PyDict_MINSIZE — 1 = 8 — 1 = 7 = 111</p><sub>2</sub><p>
index = hash(123) &amp; mask = 1111</p><font>011</font><sub>2</sub><p> &amp; </p><font>111</font><sub>2</sub><p> = </p><font>011</font><sub>2</sub><p> = 3
</p><p>
После того как индекс рассчитан, выполняется проверка ячейки по индексу, и если она «неиспользованная», то в неё добавляется запись (хэш, ключ, значение). Но если эта ячейка занята, из-за того, что другая запись имеет тот же хэш (то есть произошла коллизия), выполняется сравнение хэша и ключа вставляемой записи и записи в ячейке. Если хэш и ключ для записей совпадают, то считается, что запись уже существует в словаре, и выполняется её обновление. 
</p><p>
Это объясняет хитрый момент, связанный с добавлением равных по значению, но разных по типу ключей (к примеру, float, int и complex):

</p><pre><code class="python">&gt;&gt;&gt; 7.0 == 7 == (7+0j)
True
&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d[7.0]='float'
&gt;&gt;&gt; d
{7.0: 'float'}
&gt;&gt;&gt; d[7]='int'
&gt;&gt;&gt; d
{7.0: 'int'}
&gt;&gt;&gt; d[7+0j]='complex'
&gt;&gt;&gt; d
{7.0: 'complex'}
&gt;&gt;&gt; type(d.keys()[0])
&lt;type 'float'&gt;
</code></pre><p>
То есть тот тип, который был добавлен в словарь первым, и будет типом ключа, несмотря на обновление. Это объясняется тем, что реализация хэша для float значений возвращает хэш от int, если дробная часть равна 0.0. Пример расчёта хэша для float, переписанный на Python:

</p><pre><code class="python">def float_hash(float_value):
    ...
    fractpart, intpart = math.modf(float_value)
    if fractpart == 0.0:
        return int_hash(int(float_value))  # использовать хэш int 
    ...
</code></pre><p>
А хэш от complex возвращает хэш от float. В данном случае возвращается хэш только действительной части, так как мнимая часть равна нулю:

</p><pre><code class="python">def complex_hash(complex_value):
    hashreal = float_hash(complex_value.real)
    if hashreal == -1:
        return -1
    hashimag = float_hash(complex_value.imag)
    if hashimag == -1:
        return -1
    res = hashreal + 1000003 * hashimag
    res = handle_overflow(res)
    if res == -1:
        res = -2
    return res
</code></pre><p>
Пример:

</p><pre><code class="python">&gt;&gt;&gt; hash(7)
7
&gt;&gt;&gt; hash(7.0)
7
&gt;&gt;&gt; hash(7+0j)
7
</code></pre><p>
Ввиду того, что и хэши, и значения для всех трёх типов равны, выполняется простое обновление значения найденной записи.
</p><p>
Замечание по поводу добавления элементов: Python запрещает добавление элементов в словарь во время итерации, поэтому при попытке добавить новый элемент произойдёт ошибка:

</p><pre><code class="python">&gt;&gt;&gt; d = {'a': 1}
&gt;&gt;&gt; for i in d:
...     d['new item'] = 123
...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
RuntimeError: dictionary changed size during iteration
</code></pre><p>
Вернёмся к процедуре добавления элемента в словарь. После успешного добавления или обновления записи в хэш-таблице происходит сравнение следующей записи-кандидата на вставку. Если хэш или ключ у записей не совпадают, начинается пробирование. Происходит поиск «неиспользованной» ячейки для вставки. В данной реализации Python используется случайное (а если переменная perturb равна нулю – квадратичное) пробирование. Как было описано выше, при случайном пробировании индекс следующей ячейки выбирается псевдослучайным образом. Запись добавляется в первую найденную «неиспользованную» ячейку. То есть два ключа a и b, у которых hash(a) == hash(b), но a != b могут легко существовать в одном словаре. В случае если ячейка по начальному индексу пробы «пустая», произойдёт пробирование. И если первая найденная ячейка будет «нулевая», то «пустая» ячейка будет использована заново. Это позволяет перезаписать удалённые ячейки, сохраняя ещё неиспользованные.
</p><p>
Получается, что индексы добавляемых в словарь элементов зависят от уже находящихся в нём элементов, и порядок ключей для двух словарей, состоящих из одного и того же набора пар (ключ, значение), может быть разным и определяется очерёдностью добавления элементов:

</p><pre><code class="python">&gt;&gt;&gt; d1 = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5}
&gt;&gt;&gt; d2 = {'three': 3, 'two': 2, 'five': 5, 'four': 4, 'one': 1}
&gt;&gt;&gt; d1 == d2
True
&gt;&gt;&gt; d1.keys()
['four', 'three', 'five', 'two', 'one']
&gt;&gt;&gt; d2.keys()
['four', 'one', 'five', 'three', 'two']
</code></pre><p>
Это объясняет, почему словари в Python при выводе содержимого отображают хранимые пары (ключ, значение) не в порядке их добавления в словарь. Словари выводят их в порядке расположения в хэш-таблице (то есть в порядке индексов).
</p><p>
Рассмотрим пример:

</p><pre><code class="python">&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d['habr'] = 1
</code></pre>
<img src="//habrastorage.org/files/66c/c2a/7dd/66cc2a7dda0b48648ca4cc24d1b18c3a.png"/>
<p>
Произошла вставка по индексу 5. Переменные ma_fill и ma_used стали равны 1.

</p><pre><code class="python">&gt;&gt;&gt; d['python'] = 2
</code></pre>
<img src="//habrastorage.org/files/256/7ac/9dc/2567ac9dcc114eb495b25b080eed866b.png"/>
<p>
Произошла вставка по индексу 0. Переменные ma_fill и ma_used стали равны 2.

</p><pre><code class="python">&gt;&gt;&gt; d['dict'] = 3
</code></pre>
<img src="//habrastorage.org/files/90b/150/fc4/90b150fc4ca6437691d9152cff3dea47.png"/>
<p>
Произошла вставка по индексу 4. Переменные ma_fill и ma_used стали равны 3.
</p><pre><code class="python">&gt;&gt;&gt; d['article'] = 4
</code></pre>
<img src="//habrastorage.org/files/d3e/98d/81e/d3e98d81e22e46bea0874036fc47576e.png"/>
<p>
Произошла вставка по индексу 1. Переменные ma_fill и ma_used стали равны 4.

</p><pre><code class="python">&gt;&gt;&gt; d['!!!'] = 5
</code></pre>
<img src="//habrastorage.org/files/b64/28f/61a/b6428f61a9e5444ebd4b177da29cacc3.png"/>
<p>
Произошло следующее: </p><p>
hash('!!!') = -1297030748</p><p>
i = -1297030748 &amp; 7 = 4</p><p>
Но как видно из таблицы, индекс 4 уже занят записью с ключом 'dict'. То есть произошла коллизия. Начинается пробирование:</p><p>
perturb = -1297030748</p><p>
i = (i * 5) + 1 + perturb</p><p>
i = (4 * 5) + 1 + (-1297030748) = -1297030727</p><p>
index = -1297030727 &amp; 7 = 1</p><p>
Новый индекс пробы равен 1, но данный индекс тоже занят (записью с ключом 'article'). Произошла ещё одна коллизия, продолжаем пробирование:</p><p>
perturb = perturb &gt;&gt; PERTURB_SHIFT</p><p>
perturb = -1297030748 &gt;&gt; 5 = -40532211</p><p>
i = (i * 5) + 1 + perturb</p><p>
i = (-1297030727 * 5) + 1 + (-40532211) = -6525685845</p><p>
index = -6525685845 &amp; 7 = 3</p><p>
Новый индекс пробы равен 3, и, так как он не занят, происходит вставка записи с ключом '!!!' в ячейку с третьим индексом. В данном случае запись была добавлена после двух проб из-за произошедших коллизий. Переменные ma_fill и ma_used стали равны 5.

</p><pre><code class="python">&gt;&gt;&gt; d
{'python': 2, 'article': 4, '!!!': 5, 'dict': 3, 'habr': 1}
</code></pre><p>
Пробуем добавить шестой элемент в словарь.

</p><pre><code class="python">&gt;&gt;&gt; d[';)'] = 6
</code></pre>
<img src="//habrastorage.org/files/a30/9c5/624/a309c56248754f7fb83c5c7081380543.png"/>
<p>
После добавления шестого элемента таблица будет заполнена на 2/3, а соответственно, произойдёт изменение её размера. После того как размер изменится (в данном случае увеличится в 4 раза), произойдёт полная перестройка хэш-таблицы с учётом нового размера – все «активные» ячейки будут перераспределены, а «пустые» и «неиспользованные» ячейки будут проигнорированы.
</p><p>
Размер хэш-таблицы теперь равен 32, а переменные ma_fill и ma_used стали равны 6. Как видно, порядок элементов полностью поменялся:

</p><pre><code class="python">&gt;&gt;&gt; d
{'!!!': 5, 'python': 2, 'habr': 1, 'dict': 3, 'article': 4, ';)': 6}
</code></pre>

<h4>Поиск элемента</h4><p>
Поиск записи в хэш-таблице словаря происходит аналогично, начинаясь с ячейки i, где i зависит от хэша ключа. Если хэш и ключ не совпадают с хэшом и ключом найденной записи (то есть была коллизия и надо найти подходящую запись) – начинается пробирование, которое продолжается, пока не будет найдена запись, для которой хэш и ключ совпадают. Если же все ячейки были просмотрены, но запись не найдена, возвращается ошибка.

</p><pre><code class="python">&gt;&gt;&gt; d = {'a': 123, 'b': 345, 'c': 678}
&gt;&gt;&gt; d['x']
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'x'
</code></pre>

<h4>Коэффициент заполнения хэш-таблицы</h4><p>
Размер таблицы изменяется, когда она заполняется на 2/3. То есть для начального размера хэш-таблицы словаря, равного 8, изменение произойдёт после того, как будет добавлен 6 элемент.

</p><pre><code class="python">&gt;&gt;&gt; 8 * 2.0 / 3
5.333333333333333
</code></pre><p>
При этом происходит перестройка хэш-таблицы с учётом её нового размера, а соответственно, меняются и индексы всех записей.
</p><p>
Значение 2/3 от размера было выбрано как оптимальное, для того чтобы пробирование не занимало слишком много времени, то есть вставка новой записи происходила быстро. Увеличение этого значения приводит к тому, что словарь плотнее заполняется записями, что в свою очередь увеличивает количество коллизий. Уменьшение же увеличивает разреженность записей в ущерб увеличения занимаемых ими кэш-линий процессора и в ущерб увеличения общего объема памяти. Проверка заполнения таблицы происходит в весьма чувствительном ко времени участке кода. Попытки сделать проверку более сложной (например, изменяя коэффициент заполнения для разных размеров хэш-таблицы) уменьшали производительность.
</p><p>
Проверить, что размер словаря действительно изменяется, можно так:

</p><pre><code class="python">&gt;&gt;&gt; d = dict.fromkeys(range(5))
&gt;&gt;&gt; d.__sizeof__()
248
&gt;&gt;&gt; d = dict.fromkeys(range(6))
&gt;&gt;&gt; d.__sizeof__()
1016
</code></pre><p>
В примере возвращается размер всего объекта PyDictObject для 64-битной версии ОС.</p><p>
Начальный размер таблицы равен 8. Таким образом, когда число заполненных ячеек будет равно 6 (то есть больше 2/3 от размера), размер таблицы увеличится до 32. Затем, когда число будет равно 22, увеличится до 128. При 86 увеличится до 512, при 342 – до 2048 и так далее.

</p><h4>Коэффициент увеличения размера таблицы</h4><p>
Коэффициент увеличения размера таблицы при достижении максимального уровня заполнения равен 4, если размер таблицы меньше 50000 элементов, и 2 – для таблиц большего размера. Такой подход может быть полезен приложениям с ограничениями по памяти. 
</p><p>
Увеличение размера таблицы улучшает среднюю разреженность, то есть разбросанность записей по таблице словаря (уменьшая коллизии), за счёт увеличения объема потребляемой памяти и скорости итераций, а также уменьшает количество дорогостоящих операций выделения памяти при изменении размера для растущего словаря.
</p><p>
Обычно добавление элемента в словарь может увеличить его размер в 4 или 2 раза в зависимости от текущего размера словаря, но также возможно, что размер словаря уменьшится. Такая ситуация может произойти, если ma_fill (количество ненулевых ключей, сумма «активных» и «пустых» ячеек) намного больше ma_used (количество «активных» ячеек), то есть много ключей было удалено.

</p><h4>Удаление элемента</h4><p>
При удалении элемента из словаря вызывается функция PyDict_DelItem. </p><p>
Удаление из словаря происходит по ключу, хотя в действительности освобождения памяти не происходит. В этой функции вычисляется хэш значение ключа, а затем происходит поиск записи в хэш-таблице с использованием всё той же функции lookdict_string или lookdict. В случае если запись с таким ключом и хэшем найдена, ключ этой записи выставляется в состояние «пустой» (то есть me_key = dummy), а значение записи – в NULL (me_value = NULL). После этого переменная ma_used уменьшится на единицу, а ma_fill останется без изменения. Если же запись не найдена, возвращается ошибка.

</p><pre><code class="python">&gt;&gt;&gt; del d['!!!']
</code></pre>
<img src="//habrastorage.org/files/8cc/3b0/b62/8cc3b0b625c6437eb8e0d83f8e67433a.png"/>
<p>
После удаления переменная ma_used стала равна 4, а ma_fill осталась равной 5, так как ячейка не была удалена, а всего лишь была помечена как «пустая» и продолжает занимать ячейку в хэш-таблице.

</p><h4>Рандомизация хэшей</h4><p>
При запуске python можно воспользоваться ключом -R, чтобы использовать псевдослучайную «соль». В этом случае хэш значения таких типов, как строки, buffer, bytes, и объекты datetime (date, time и datetime) будут непредсказуемыми между вызовами интерпретатора. Данный способ предложен в качестве защиты от DoS атак.

</p><h4>Ссылки</h4>
<a href="https://github.com/python/cpython/blob/2.7/Objects/dictobject.c">github.com/python/cpython/blob/2.7/Objects/dictobject.c</a>
<a href="https://github.com/python/cpython/blob/2.7/Include/dictobject.h">github.com/python/cpython/blob/2.7/Include/dictobject.h</a>
<a href="https://github.com/python/cpython/blob/2.7/Objects/dictnotes.txt">github.com/python/cpython/blob/2.7/Objects/dictnotes.txt</a>
<a href="http://www.shutupandship.com/2012/02/how-hash-collisions-are-resolved-in.html">www.shutupandship.com/2012/02/how-hash-collisions-are-resolved-in.html</a>
<a href="http://www.laurentluce.com/posts/python-dictionary-implementation/">www.laurentluce.com/posts/python-dictionary-implementation</a>
<a href="http://rhodesmill.org/brandon/slides/2010-03-pycon/">rhodesmill.org/brandon/slides/2010-03-pycon</a>
<a href="http://www.slideshare.net/MinskPythonMeetup/ss-26224561">www.slideshare.net/MinskPythonMeetup/ss-26224561</a><p> – Dictionary в Python. По мотивам Objects/dictnotes.txt – SlideShare (Cyril  </p><a href="http://habrahabr.ru/users/notorca/" class="user_link">notorca</a><p> Lashkevich)
</p><a href="http://www.youtube.com/watch?v=JhixzgVpmdM">www.youtube.com/watch?v=JhixzgVpmdM</a><p> – Видео доклада «Dictionary в Python. По мотивам Objects/dictnotes.txt»
      </p><p class="clear"/>
    </div>

    
  </div></body></html>