<html><body><div><div itemprop="articleBody"><p>I was reading <a class="reference external" href="http://www.occasionalinspiration.com/2014/09/100-functions.html">this</a> the other day. The article presents this peculiar quote:</p><blockquote class="highlights"><p>"It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures."</p><p class="attribution">—Alan J. Perlis <a class="footnote-reference" href="#id6" id="id1">[1]</a></p></blockquote><p>And then some thoughts and questions regarding the quote that seemed a bit ridiculous. But what does this seemingly ambiguous quote really mean?</p><p>After some thought, I've concluded that it's an apologia for Lisp's <em>lists everywhere</em> philosophy.</p><p>You can reduce the quote to:</p><blockquote class="highlights"> It's better to have one extremely generic type than 10 incompatible types.</blockquote><p>Python already does this: every object implements, surprise, an object interface that boils down to a bunch of magic methods.</p><p>On the other hand, Lisp has <a class="reference external" href="http://en.wikipedia.org/wiki/Generic_function">generic functions</a>. What this mean is that there is a dispatch system that binds certain function implementations to certain data-structures. A data structure that is bound with specific actions (aka functions or methods) is what I call a <em>type</em>.</p><p>The idea of not having specialised data-structures is an illusion - if a function takes something as an input then you have assumed a specific data structure, not just a mere list. This is why I think it's worthwhile designing the data-structures before the actions you'll want to have in the system.</p><p>Sounds counter-intuitive, as actions make the system run, not the data-structures - it seems natural to map out the actions first. Alas, starting with data-structures first lets you easily see what actions you could have and what actions you can't. In other words, it gives you perspective on many things: hard constrains, data flow and dependencies.</p><p>Just the actions don't give you perspective on dependencies. Dependencies imply state. State implies data. They don't give you perspective on what the system can and can't do - actions depends on inputs, <em>data</em> in other words. To put it another way, data is the limiting factor on what actions you could have and what actions you could not.</p><p>Given Python's lax access to the innards of objects, a large part of your type's API is just the data-structure. Also, given Python's support for properties <a class="footnote-reference" href="#id7" id="id2">[2]</a>, a large part of your API could be something that <em>looks like</em> a data-structure. So it's worthwhile to look really hard at this aspect of software design in the early stages of your project.</p><div class="section" id="generality-of-types"><h2>Generality of types<a class="headerlink" href="#generality-of-types" title="Permalink to this headline"> *</a></h2><img alt="A graph with few examples of Utility/Reach proportions" src="https://blog.ionelmc.ro/2014/09/22/ramblings-about-data-structures/data-structures.png"/><p>There are two main properties of types:</p><ul class="simple"><li><span class="uppercase">Utility</span>: How well does the type supports the consumer of said type. Does it have all the required actions? Is the API well suited or it makes the customer handle things that he should not be concerned with? Those are the key questions.</li><li><span class="uppercase">Reach</span>: How many distinct consumers can use this type. Does the type bring unwanted dependencies or concerns in the consumer? Does the type have many actions that go unused, and can't be used, by a large part of all the possible consumers?</li></ul><p>To give examples few examples:</p><ul class="simple"><li>A <cite>list</cite> has a very large <span class="uppercase">reach</span> and most of the time it fits fairly well consumers that just need a sequence-like type. However, the <span class="uppercase">utility</span> is very limited - you wouldn't use a list where you would use a higher level type, like an <cite>invoice</cite>.</li><li>An <cite>invoice</cite> has a very limited <span class="uppercase">reach</span>, you can only use it in billing code. But the <span class="uppercase">utility</span> of it is tremendous - you wouldn't want to use a mere <cite>list</cite> - you'd burden your payment code with concerns that are better encapsulated in the <cite>invoice</cite> type.</li></ul><p>There's a tradeoff in having both <span class="uppercase">reach</span> and <span class="uppercase">utility</span>: complexity vs re-usability. Something with <span class="uppercase">reach</span> and <span class="uppercase">utility</span> can be used in many places. However, complexity is bound to occur - handling all those disparate use-cases is taxing.</p><p>I'd even go as far to argue there's a hard limit to reaching both goals - pushing one goal limits the other, from the perspective of what you can have in an API.</p><p>If you can afford to change things later it's best to start with good <span class="uppercase">utility</span> and then move towards <span class="uppercase">reach</span> as use-cases arise. Otherwise you're at risk of over-engineering and wasting time both on development and maintenance.</p><div class="section" id="what-about-the-javascript-array"><h3>What about the JavaScript Array?<a class="headerlink" href="#what-about-the-javascript-array" title="Permalink to this headline"> *</a></h3><p>The <cite>Array</cite> object (as any other object in JavaScript) is very interesting problem from the perspective of the iterator interface. A <tt class="docutils literal">for (var element in variable)</tt> block will iterate on whatever is there, both attributes and elements of the actual sequence. From this perspective the <cite>Array</cite> increases complexity (there's a cognitive burden, both on the implementers of the <cite>Array</cite> object and the users of it). If the <cite>Array</cite> would not allow attributes then this wouldn't be such an issue. But then the <span class="uppercase">reach</span> would be less.</p><p>On the other hand, you could in theory use an <cite>Array</cite> object as an <cite>invoice</cite> substitute, you could just slap the <cite>invoice</cite> fields like buyer, seller, total value, reference number etc on the <cite>Array</cite> object. So from this perspective it has higher <span class="uppercase">utility</span> than a plain <cite>list</cite> where you can't have arbitrary attributes (<tt class="docutils literal">AttributeError: 'list' object has no attribute 'buyer'</tt>).</p></div></div><div class="section" id="importance-of-data-structures"><h2>Importance of data-structures<a class="headerlink" href="#importance-of-data-structures" title="Permalink to this headline"> *</a></h2><p>So, you see, designing data-structures is tricky. There are tradeoffs to be made. If your data is wrongly designed then you'll have to compensate those flaws in your code. That means more code, crappy code, to maintain.</p><p>Interestingly, this has been well put almost 40 years ago:</p><blockquote class="highlights"><p>"Show me your tables, and I won't usually need your flowchart; it'll be obvious."</p><p class="attribution">—Fred Brooks, in <cite>Chapter 9</cite> of <cite>The Mythical Man-Month</cite> <a class="footnote-reference" href="#id8" id="id3">[3]</a></p></blockquote><p>The same thing, in more modern language:</p><blockquote class="highlights"><p>"Show me your data structures, and I won't usually need your code; it'll be obvious."</p><p class="attribution">—Eric Raymond, in <cite>The Cathedral and the Bazaar</cite>, paraphrasing Brooks <a class="footnote-reference" href="#id8" id="id4">[3]</a></p></blockquote><p>Though it seems this isn't instilled in everyone's mind: some people actually think that you can accurately reason about business logic before reasoning about the data <a class="footnote-reference" href="#id9" id="id5">[4]</a>. You can't reliably reason about logic if you don't know what data dependencies said logic has.</p></div><div class="section" id="chicken-and-egg"><h2>Chicken and egg<a class="headerlink" href="#chicken-and-egg" title="Permalink to this headline"> *</a></h2><p>There are situations where you can't know what data you need to store before you know what the actions are. So you'd be inclined to start thinking about all the actions first.</p><p>I prefer to sketch out a minimalistic data-structure and refine it as I become aware of what actions I need to support, making a note of what actions I have so far. This works reasonably well and allows me to easily see any redundancy or potential to generalize, or the need to specialize for that matter. In a way, this is similar to <a class="reference external" href="http://en.wikipedia.org/wiki/Class-responsibility-collaboration_card">CRC cards</a> but more profound.</p></div><div class="section" id="redundancy"><h2>Redundancy<a class="headerlink" href="#redundancy" title="Permalink to this headline"> *</a></h2><p>Starting with the data first allows you to easily see any redundancy in the data and make intelligent <a class="reference external" href="http://en.wikipedia.org/wiki/Database_normalization">normalization</a> choices.</p><p>Duplicated data-structures, especially the ones that are slightly different but distinct are a special kind of evil. They will frequently encourage, and sometimes even force the programmer to produce duplicated code, or code that <cite>tries</cite> to handle all the variances. It's very tempting because they are so similar. But alas, you can only think of so many things at the same time.</p><p>Even if you don't want to normalize your data, starting with the data first can result in <cite>synergy</cite>: the data from <cite>this</cite> place mixes or adapts well to the data from <cite>that other</cite> place. This <cite>synergy</cite> will reduce the amount of boilerplate and adapter code.</p></div><div class="section" id="closing-thoughts"><h2>Closing thoughts<a class="headerlink" href="#closing-thoughts" title="Permalink to this headline"> *</a></h2><p>Alan J. Perlis' principle can't be applied in all situations as the <span class="uppercase">reach</span> property is not always the imperative of software design and it has some disadvantages as illustrated above.</p><p>There are situations where none of these ideas apply (I don't mean to be complete):</p><ul class="simple"><li>You don't have any data or your application is not data-centric, or there other more pressing things to consider first.</li><li>You live in the perfect world of frozen requirements that are known before implementation.</li></ul></div></div></div></body></html>