<html><body><div><div class="field-item even" property="content:encoded"><p>Metadata locking has been an exciting adventure for the last couple years in MySQL and MariaDB. Users and applications using only MyISAM tables are learning the joys of locking conflicts between transactions/connections. Users with InnoDB tables who either rely on global autocommit behavior or have explicitly set that globally in their configuration might be surprised to find Some users are seeing more than their fair share of these crop up in some very surprising places due to a particular, pernicious Python behavior: <a href="http://legacy.python.org/dev/peps/pep-0249/#commit">PEP-249 mandates that autocommit <b>"must be initially off"</b></a>. Every time your Python programs/scripts connect to MySQL or MariaDB, a new transaction is started, and, crucially: <b><i>by default, every time you <code>SELECT</code> in a Python program, your connection acquires a metadata lock</i></b>.</p>
<p>These locks are not released until your program ends or explicitly ends the transaction using <code>COMMIT</code> or <code>ROLLBACK</code>.</p>
<p>A long-running monitoring tool or something that may connect, execute a couple simple SELECT statements, and keep its connection for some period of time, can cause havoc if you have other processes that try to execute <code>ALTER TABLE</code> or other DDL on those tables.</p>
<p>MariaDB 10.0 gives us a great plugin to inspect metadata locks, so we can see this behavior in action.</p>
<pre class="kolbe">
MariaDB&gt; create table test.t1 (id int unsigned not null auto_increment primary key) engine=myisam;
Query OK, 0 rows affected (0.02 sec)

MariaDB&gt; insert into test.t1 values (),(),();
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0
</pre><pre class="kolbe">
$ cat simple.py
#!/usr/bin/env python

import sys, os
import mysql.connector

db = mysql.connector.Connect(user='root')

cursor = db.cursor()
cursor.execute("SELECT 1 FROM test.t1")
cursor.fetchall()
cursor.close()

cursor = db.cursor()
cursor.execute("SELECT SLEEP(60)")
cursor.fetchall()
cursor.close()

db.close()

$ python simple.py
</pre><pre class="kolbe">
MariaDB&gt; install soname 'metadata_lock_info';
Query OK, 0 rows affected (0.00 sec)

MariaDB&gt; show processlist;
+----+------+-----------------+------+---------+------+------------+------------------+----------+
| Id | User | Host            | db   | Command | Time | State      | Info             | Progress |
+----+------+-----------------+------+---------+------+------------+------------------+----------+
|  3 | root | localhost       | test | Query   |    0 | init       | show processlist |    0.000 |
| 14 | root | localhost:59875 | NULL | Query   |   40 | User sleep | SELECT SLEEP(60) |    0.000 |
+----+------+-----------------+------+---------+------+------------+------------------+----------+
2 rows in set (0.00 sec)

MariaDB&gt; select * from information_schema.metadata_lock_info;
+-----------+-----------------+-----------------+---------------------+--------------+------------+
| THREAD_ID | LOCK_MODE       | LOCK_DURATION   | LOCK_TYPE           | TABLE_SCHEMA | TABLE_NAME |
+-----------+-----------------+-----------------+---------------------+--------------+------------+
|        14 | MDL_SHARED_READ | MDL_TRANSACTION | Table metadata lock | test         | t1         |
+-----------+-----------------+-----------------+---------------------+--------------+------------+
1 row in set (0.00 sec)
</pre><p>
Here's an excerpt from the general query log, to show what statements this connection has executed since it began:</p>
<pre class="kolbe">
140624 17:24:48    14 Connect   root@localhost as anonymous on
                   14 Query     SET NAMES 'utf8' COLLATE 'utf8_general_ci'
                   14 Query     SET @@session.autocommit = OFF
                   14 Query     SELECT 1 FROM test.t1
                   14 Query     SELECT SLEEP(60)
</pre><p>
There we can see the <code>SET @@session.autocommit = OFF</code> statement that disables autocommit. This behavior can be influenced in a few different ways, when using <a href="http://dev.mysql.com/doc/connector-python/en/index.html">MySQL Connector/Python</a>:</p>
<ol><li> Set the <code>autocommit</code> connection argument to "True".
</li><li> Modify the <code>autocommit</code> property of the connection after connecting.
</li><li> Execute <code>SET AUTOCOMMIT=1</code> or <code>AUTOCOMMIT=ON</code> after connecting.
</li></ol><p>The facilities available may depend on the specific Python driver you are using. The <a href="http://mysql-python.sourceforge.net/MySQLdb.html">MySQLdb</a> driver, for instance, does not support an <code>autocommit</code> connection argument.</p>
<p>If you have Python programs that connect to MySQL or MariaDB, make sure you understand their autocommit behavior. It's a good practice, no matter the language or API you're using, to explicitly set the autocommit behavior that your program relies on.</p>
<p>Good luck avoiding those metadata locks!</p>
</div></div></body></html>