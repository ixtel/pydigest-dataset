<html><body><div><div class="ibm-col-1-1">

<h2 id="N1004E">Введение</h2><p>Проект SWIG предоставляет универсальный интерфейс к C/C++ не только из языка Python, но и других языков. 
В его документации говорится, что SWIG – это инструмент разработки ПО, позволяющий интегрировать 
программы, написанные на языках C и С++, с другими высокоуровневыми языками программирования. SWIG 
может использоваться с различными типами языков, включая скриптовые языки, например, Perl, PHP, Python, Tcl и 
Ruby. Также поддерживаются такие языки как C#, Common Lisp (CLISP, Allegro CL, CFFI, UFFI), D, Go, язык Java, 
включая платформу Android и др.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N10054">Архитектура SWIG</h2><p>Повышенная универсальность и гибкость ведёт к увеличению сложности, поэтому при освоении SWIG 
возможно возникновение досадных и неожиданных ошибок. Но освоив этот инструмент, вы получите 
возможность создавать интерфейсы к любому из указанных языков.</p><p>Этот проект активно развивается, так его последняя версия 2.0.11 была выпущена 15 сентября 2013 года. 
Так как SWIG является мультиплатформенным проектом, то пользователям предлагаются версии для платформ 
Windows и Linux (но в дальнейших примерах будет использоваться версия для ОС Linux). Актуальную версию 
SWIG можно собрать из исходных кодов (см. ссылку в разделе "Ресурсы"). Также его можно найти практически 
в любом дистрибутиве и установить с помощью менеджера пакетной системы Linux, как показано ниже:</p><div class="codesection"><pre class="displaycode"><strong>$ sudo yum install swig*</strong>
...
---&gt; Пакет swig.i686 0:2.0.8-1.fc17 помечен для установки
---&gt; Пакет swig-doc.noarch 0:2.0.8-1.fc17 помечен для установки
...
Объем загрузки: 3.7 M
Объем изменений: 12 M
...</pre></div><p>Базовая идея SWIG заключается в том, что:</p><ol><li>
готовится реализация будущего <strong>модуля</strong> на языке C (.c) или C++ (.cc);
</li><li>
создаётся интерфейсный файл (.i) на специальном <strong>макроязыке</strong> SWIG;
</li><li>
SWIG генерирует код для интерфейсного файла (.c), который далее собирается вместе с реализацией 
модуля (.c) в разделяемую динамическую библиотеку модуля;
</li></ol><p>При этом язык программирования (например, Python), для которого генерируется интерфейсный файл, 
указывается в качестве <strong>входного параметра</strong> команды SWIG, а вид интерфейсного файла (.i) не 
зависит от того, для какого конкретного языка будет генерироваться интерфейс.</p><p>Далее будет представлен простой пример использования SWIG, который может послужить отправной точкой 
для последующих разработок. В листинге 1 представлен исходный модуль на языке С, реализующий требуемую 
функцию (см. файл <strong>ownmod.c</strong> в архиве <strong>python_c_interaction.tgz</strong> в 
разделе "Материалы для скачивания").</p><h5 id="listing1">Листинг 1. Код реализации модуля</h5><div class="codesection"><pre class="displaycode">#include &lt;stdio.h&gt;

void echo( void ) {
   printf( "вывод из экспортированного кода!\n" );
}</pre></div><p>К этому модулю следует подготовить файл с описанием интерфейса на макроязыке SWIG. В листинге 2 
представлен пример такого файла для нашего модуля (см. файл <strong>ownmod.i</strong> из архива 
<strong>python_c_interaction.tgz</strong>):</p><h5 id="N1008F">Листинг 2. Определение интерфейса</h5><div class="codesection"><pre class="displaycode">%module ownmod
extern void echo( void );</pre></div><p>Этих двух файлов достаточно для начала работы с SWIG. Далее выполняются следующие шаги:</p><ol><li>
генерация кода интерфейса (по умолчанию это будет файл <strong>ownmod_wrap.c</strong>, но название файла 
можно переопределить опциями команды <strong><code>swig</code></strong>):

<div class="codesection"><pre class="displaycode"><strong>$ swig -python -module ownmod ownmod.i</strong></pre></div></li><li>
компиляция всех исходных файлов <strong>.c</strong> в соответствующие объектные файлы <strong>.o</strong>:

<div class="codesection"><pre class="displaycode"><strong>$ gcc -c -fpic ownmod_wrap.c ownmod.c -DHAVE_CONFIG_H -I/usr/include/python2.7</strong></pre></div></li><li>
сборка их в единую библиотеку:

<div class="codesection"><pre class="displaycode"><strong>$ gcc -shared ownmod.o ownmod_wrap.o -o _ownmod.so</strong></pre></div></li><li>
также сборку в библиотеку можно выполнить следующей командой

<div class="codesection"><pre class="displaycode"><strong>$ ld -shared ownmod.o ownmod_wrap.o -o _ownmod.so</strong></pre></div></li></ol><p>Теперь мы можем использовать созданный модуль в Python, как показано в файле 
<strong>test.py</strong> в листинге 3:</p><h5 id="N100C7">Листинг 3. Тестовое приложение</h5><div class="codesection"><pre class="displaycode">#!/usr/bin/python
# -*- coding: utf-8 -*-

import ownmod
ownmod.echo()</pre></div><p>Запустим тестовый Python-сценарий:</p><div class="codesection"><pre class="displaycode"><strong>$ python test.py</strong>
вывод из экспортированного кода!</pre></div><p>Хотя показанный пример крайне схематичен, но он показывает общую логику использования SWIG для 
разработки модулей любой степени сложности. Однако, в отдельных случаях описание интерфейсов 
(<strong>.i</strong>) на макроязыке SWIG может оказаться сложной задачей. В архив 
<strong>python_c_interaction.tgz</strong> включён пример функции (файл <strong>freq.c</strong>), 
подсчитывающей число вхождений каждого из 256 символов ASCII в тексте, переданном ей в качестве 
параметра.</p><h5 id="N100E1">Листинг 4. Исходная функция на языке С, требующая динамического выделения буфера</h5><div class="codesection"><pre class="displaycode">#include &lt;stdlib.h&gt;

int* frequency( char s[] ) {
   int *freq;
   char *ptr;
   freq = (int*)( calloc( 256, sizeof( int ) ) );
   if( freq != NULL )
      for( ptr = s; *ptr; ptr++ )
         freq[ *ptr ] += 1;
   return freq;
}</pre></div><p>Подобная функция потребует более сложного файла с описанием интерфейса, так как она динамически 
выделяет память буфера, которая должна освобождаться <strong>вызывающим</strong> кодом Python. В 
листинге 5 представлен пример такого файла (см. файл <strong>freq.i</strong> в архиве 
<strong>python_c_interactions.tgz</strong>).</p><h5 id="N100F3">Листинг 5. Описание интерфейса для функции frequency()</h5><div class="codesection"><pre class="displaycode">%module freq
%typemap(out) int* {
   int i;
   $result = PyTuple_New( 256 );
   for( i = 0; i &lt; 256; i++ )
      PyTuple_SetItem( $result, i, PyLong_FromLong( $1[ i ] ) );
   free( $1 );
}

extern int* frequency( char s[] );</pre></div><p>Сборка модуля выполняется также как и в предыдущем примере. В листинге 6 представлено 
Python-приложение, использующее модуль с данной функцией.</p><h5 id="N100FC">Листинг 6. Программа подсчёта частоты вхождений символов</h5><div class="codesection"><pre class="displaycode">#!/usr/bin/python
# -*- coding: utf-8 -*-

from sys import argv
import freq

sarg = lambda : ( len( argv ) &gt; 1 and argv[ 1 ] ) or str( input( "string?: " ) )

f = freq.frequency( sarg() )

s = ""
for i in range( 256 ):
    if f[ i ] != 0:
        s = s + "'%c'[0x%x]:%d " % ( i, i, f[ i ] )

print s</pre></div><p>Запустим эту программу:</p><div class="codesection"><pre class="displaycode">$ python test.py "1234123121 abc ab a"
' '[0x20]:3 '1'[0x31]:4 '2'[0x32]:3 '3'[0x33]:2 '4'[0x34]:1 'a'[0x61]:3 'b'[0x62]:2 ...</pre></div><p>Ещё одним преимуществом использования SWIG является простота создания <strong>интерфейсных 
модулей</strong> к уже существующим DLL библиотекам, в частности, к системным библиотекам и библиотекам 
сторонних проектов GNU. В этом случае не требуется создавать никаких реализаций на С (они уже имеются), 
достаточно будет подготовить только файл описания интерфейса, как показано в листинге 10 (файл 
<strong>fileio.i</strong> из архива <strong>python_c_interaction.tgz</strong>):</p><h5 id="N10114">Листинг 7. Интерфейс к файловым операциям</h5><div class="codesection"><pre class="displaycode">%module fileio
extern FILE *fopen(char *, char *);
extern int fclose(FILE *);
extern unsigned fread(void *ptr, unsigned size, unsigned nobj, FILE *);
extern unsigned fwrite(void *ptr, unsigned size, unsigned nobj, FILE *);
extern void *malloc(int nbytes);
extern void free(void *);</pre></div><p>Остаётся выполнить сборку разделяемой библиотеки <strong>_fileio.so</strong>, реализующей интерфейс 
нового модуля. Обратите внимание, что в сборку включена стандартная C-библиотека <strong>libc.so</strong>, 
в которой и находится реализация:</p><div class="codesection"><pre class="displaycode"><strong> $ swig -python fileio.i 
 $ gcc -c -fpic fileio_wrap.c -DHAVE_CONFIG_H -I/usr/include/python2.7 \ 
      -I/usr/lib/python2.7/config 
 $ ld -shared fileio_wrap.o -lc -o _fileio.so </strong></pre></div><p>Теперь в коде Python можно напрямую использовать файловые операции POSIX, как показано в листинге 8 
(файл <strong>fiotest.py</strong> из архива <strong>python_c_interaction.tgz</strong>):</p><h5 id="N10130">Листинг 8. Копирование файлов из Python с использованием POSIX операций</h5><div class="codesection"><pre class="displaycode">#!/usr/bin/python
# -*- coding: utf-8 -*-

from fileio import *
from sys import argv

def filecopy( source, target ):         <strong> # копирование файла</strong> 
    sum = long( 0 )
    f1 = fopen( source, "r" )
    if f1 == None: return -1
    f2 = fopen( target, "w" )
    buffer = malloc( 8192 )
    nbytes = fread( buffer, 1, 8192, f1 )
    while( nbytes &gt; 0 ):
        fwrite( buffer, 1, nbytes, f2 )
        sum = sum + nbytes
        nbytes = fread( buffer, 1, 8192, f1 )
    free( buffer )
    fclose( f1 )
    fclose( f2 )
    return sum

n = filecopy( ( len( argv ) &gt; 1 and argv[ 1 ] ) or "in.txt", \
              ( len( argv ) &gt; 2 and argv[ 2 ] ) or "out.txt" )
print "скопировано %d байт" % n</pre></div><p>Запустим данное приложение и посмотрим на результаты его работы:</p><div class="codesection"><pre class="displaycode"><strong>$ python fiotest.py in.txt out.txt</strong>
скопировано 178 байт
<strong>$ ls -l *.txt</strong>
-rw-rw-r-- 1 olej olej 178 июня  21 23:48 in.txt
-rw-rw-r-- 1 olej olej 178 июня  22 00:14 out.txt</pre></div><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N10143">Интеграция Python-кода в C/C++ приложения</h2><p>Интеграция Python-кода в проект, написанный на C или C++, представляет собой обратную задачу, которая 
также может возникнуть в различных областях. Многие крупные проекты (например, телефонные коммутаторы 
для IP-телефонии - Asterisk и FreeSWITCH) используют встраивание одного или нескольких интерпретирующих 
языков (Python, JavaScript, Lua, ...) для быстрой реализации сценариев, позволяющих управлять основной 
функциональностью. Также подобные языки могут применяться для конфигурации проекта без необходимости 
его повторной компиляции. В листинге 9 представлен простейший интерпретатор, встроенный в C-приложение, 
(см. файл <strong>interpr.c</strong> в разделе <strong>python_c_interaction.tgz</strong>):</p><h5 id="N10151">Листинг 9. Интерпретатор Python, встроенный в C-приложение</h5><div class="codesection"><pre class="displaycode"><strong>/* Пример встраивания интерпретатора Python в другую программу */</strong>
#include "Python.h"

main( int argc, char **argv ) {
   Py_SetProgramName( argv[ 0 ] ); <strong>// Передает argv[0] интерпретатору Python</strong>
   Py_Initialize();                <strong>// Инициализация интерпретатора</strong>
   /* ... */
   while( 1 ) {            <strong> // Выполнение операторов Python</strong>
      char buf[ 120 ];
      fprintf( stdout, "&gt;&gt;&gt; " );
      fflush( stdout );
      fgets( buf, sizeof( buf ) - 2, stdin );
      buf[ strlen( buf ) - 1 ] = '\n';
      buf[ strlen( buf ) ] = '\0';
      if( 0 == strcmp( buf, "quit\n" ) || 0 == strcmp( buf, "exit\n" ) ) break;
      PyRun_SimpleString( buf );
   }
   Py_Finalize();           <strong>// Завершение работы интерпретатора</strong>
}</pre></div><p>Пример запуска данного приложения:</p><div class="codesection"><pre class="displaycode"><strong>$ ./interpr</strong>
&gt;&gt;&gt;<strong> print 2+2</strong>
4
&gt;&gt;&gt;<strong> import sys</strong>
&gt;&gt;&gt; <strong>print sys.version_info</strong>
sys.version_info(major=2, minor=7, micro=3, releaselevel='final', serial=0)
&gt;&gt;&gt;<strong> quit</strong></pre></div><p>Хотя этот пример и похож на использование стандартного интерпретатора CPython, но на самом деле это 
самостоятельное приложение, так как в нём не используются клавиши редактирования вводимой строки, и в 
тоже время из него можно выйти, введя команду <strong><code>quit</code></strong>.</p><p>Важное преимущество подобного встраивания Python-функций в С-приложения — это возможность 
<strong>доступа</strong> к переменным и объектам C-кода из Python. Эта возможность обеспечивается 
специальным API для встраивания, входящим в состав Python, (дополнительную информацию об этом API можно 
найти в разделе "Ресурсы").</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N10182">Заключение</h2><p>В этой статье мы завершаем знакомство с различными технологиями расширения возможностей 
Python-проектов c помощью кода, написанного на языках C/C++. Выбор способа, подходящего к конкретной 
ситуации, как обычно остаётся за разработчиком проекта. Но при всех различиях и особенностях, каждая из 
этих технологий позволяет достичь одного и того же конечного результата — подключить фрагменты C/C++ кода 
к проекту на Python. Также в рамках этой статьи была рассмотрена и обратная задача: интеграция Python-кода 
в проект, написанный на C/C++.</p><p>В следующей статье, завершающей цикл "Тонкости использования Python", мы поговорим об особенностях 
применения Python для разработки GUI-приложений.</p>
<p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="download">Загрузка</h2>

</div>
</div></body></html>