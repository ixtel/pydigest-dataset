<html><body><div><article>
	<p>Unit testing is considered an essential part of software development. Through unit testing, we can evaluate each code component, find out how well it performs, and determine how well it reacts to valid or invalid input. A regression suite of unit tests is also an excellent way of detecting unexpected changes in a code base caused by refactoring or writing new code. </p>
<p>In this article, I examine the mechanisms of unit testing in Python, starting with the unittest module and its key classes. I examine tests individually and in suites, and I discuss how to facilitate their construction and use. Readers should have a working knowledge of Python. The sample test code requires Python 2.5 or later.</p>
<h3>The unittest Module</h3>
<p>The unittest module started life as the third-party module PyUnit. PyUnit was a Python port of JUnit, the Java unit testing framework.  Designed by Steve Purcell, PyUnit became an official Python module starting with version 2.5.</p>
<p/><p><img src="http://twimgs.com/ddj/images/article/2014/0114/PythonUnitTest1.gif" alt="Python Unit Tests" title="Python Unit Tests"/><br/><b>Figure 1: Core classes in unittest.</b></p>
<p>As Figure 1 shows, there are five key classes in the unittest module. The <code>TestCase</code> class holds the test routines and provides hooks for preparing each routine and for cleaning up after. The <code>TestSuite</code> class serves as a collection container. It can hold multiple <code>TestCase</code> objects and multiple <code>TestSuite</code> objects.</p>
<p>The <code>TestLoader</code> class loads test cases and suites defined locally or from an external file. It emits a <code>TestSuite</code> object that holds those cases and suites. The <code>TextTestRunner</code> class provides a standard platform to run the tests. The <code>TestResults</code> class provides a standard container for the test results.</p>
<p>Out of these five classes, only <code>TestCase</code> must be subclassed. The other four classes can also be subclassed, but they are generally used as is.</p>
<h3>Preparing a Test Case</h3>
<p>Figure 2 shows the structure of the <code>TestCase</code> class. In it are three sets of methods that are used most often in designing the tests. In the first set are the pre- and post-test hooks. The <code>setUp()</code> method fires before each test routine, the <code>tearDown()</code> after the routine. Override these methods when you create a custom test case.</p>
<p/><p><img src="http://twimgs.com/ddj/images/article/2014/0114/PythonUnitTest2.gif" alt="Python Unit Tests" title="Python Unit Tests"/><br/>
<b>Figure 2: The structure of a TestCase class.</b></p>
<p>
</p><p>The second pair of methods control test execution. Both methods take a message string as input, and both abort an ongoing test. But the <code>skipTest()</code> method cancels the current test, while the<code> fail()</code> method fails it explicitly.</p>
<p>The third set of methods help identify the test. The method<code> id()</code> returns a string containing the name of the <code>TestCase</code> object and of the test routine. And the method <code>shortDescription()</code> returns the <code>docstr</code> comment at the start of each test routine. If the routine has no such comment, <code>shortDescription() </code>returns a <code>None</code>.</p>
<p>Listing One shows the sample bare bones test case <code>FooTest</code>. <code>FooTest</code> has two test routines: <code>testA() </code>and<code> testB()</code>. Both routines get the required argument of <code>self</code>. Both have a <code>docstr</code> comment for a first line. </p>
<p><b/></p><p>Listing One: Code to show the sequence of unit test execution.</p>
<p/><pre class="brush: python; html: collapse;">
#!/usr/bin/python

import unittest

class FooTest(unittest.TestCase):
    """Sample test case"""
    
    # preparing to test
    def setUp(self):
        """ Setting up for the test """
        print "FooTest:setUp_:begin"
        ## do something...
        print "FooTest:setUp_:end"
    
    # ending the test
    def tearDown(self):
        """Cleaning up after the test"""
        print "FooTest:tearDown_:begin"
        ## do something...
        print "FooTest:tearDown_:end"
    
    # test routine A
    def testA(self):
        """Test routine A"""
        print "FooTest:testA"
    
    # test routine B
    def testB(self):
        """Test routine B"""
        print "FooTest:testB"
</pre>
<p>
</p><p>Figure 3 shows how <code>FooTest</code> behaves when executed. </p>
<p/><p><img src="http://twimgs.com/ddj/images/article/2014/0114/PythonUnitTest3.gif" alt="Python Unit Tests" title="Python Unit Tests"/><br/><b>Figure 3: FooTest behavior.</b></p>
<p>Note the same <code>setUp() </code>and <code>tearDown()</code> methods run before and after each test routine. So how do you let <code>setUp()</code> and <code>tearDown() </code>know which routine is being run?  You must first identify the routine by calling <code>shortDescription()</code> or <code>id()</code> (See Listing Two). Then use an <code>if-else</code> block to route to the appropriate code. In the sample snippet, <code>FooTest</code> calls <code>shortDescription()</code> to get the routine's <code>docstr</code> comment, then runs the prep and clean-up code for that routine.</p>
<p><strong>Listing Two: Using test descriptions.</strong></p>
<p>
</p><pre class="brush: python; html: collapse;">
import unittest

class FooTest(unittest.TestCase):
    """Sample test case"""
    
    # preparing to test
    def setUp(self):
        """ Setting up for the test """
        print "FooTest:setUp_:begin"
        
        testName = self.shortDescription()
        if (testName == "Test routine A"):
            print "setting up for test A"
            
        elif (testName == "Test routine B"):
            print "setting up for test B"
            
        else:
            print "UNKNOWN TEST ROUTINE" 
            
        print "FooTest:setUp_:end"
    
    # ending the test
    def tearDown(self):
        """Cleaning up after the test"""
        print "FooTest:tearDown_:begin"
        
        testName = self.shortDescription()
        if (testName == "Test routine A"):
            print "cleaning up after test A"
            
        elif (testName == "Test routine B"):
            print "cleaning up after test B"
            
        else:
            print "UNKNOWN TEST ROUTINE"
            
        print "FooTest:tearDown_:end"
    
    # see Listing One...
</pre>

<h3>Designing a Test Routine</h3>
<p>Each test routine must have the prefix "test" in its name. Without that prefix, the routine will not run. To perform a test, the test routine should use an <code>assert</code> method. An <code>assert</code> method gets one or more test arguments and an optional assert message. When a test fails, the <code>assert</code> halts the routine and sends the error message to <code>stdout</code>.</p>
<p>There are three sets of <code>assert</code> methods. In the first set (Table 1) are the basic Boolean asserts, which fire on a <code>True</code> or <code>False</code> result. </p>
<table border=".3" cellspacing="1" cellpadding="3">
  <tr>
    <td valign="top"><b>Assert</b></td>
    <td valign="top"><b>Complement Assert</b></td>
    <td valign="top"><b>Operation</b></td>
  </tr>
  <tr>
    <td valign="top"><p><code>assertTrue(a, M)</code></p></td>
    <td valign="top"><p><code>assertFalse(a, M)</code></p></td>
    <td valign="top"><p><code>a = True; a = False</code></p></td>
  </tr>
  <tr>
    <td valign="top"><p><code>assertEqual(a, b, M)</code></p></td>
    <td valign="top"><p><code>assertNotEqual(a, b, M)</code></p></td>
    <td valign="top"><p><code>a = b; a ≠ b</code></p></td>
  </tr>
  <tr>
    <td valign="top"><p><code>assertIs(a, b, M)</code></p></td>
    <td valign="top"><p><code>assertIsNot(a, b, M)</code></p></td>
    <td valign="top"><p><code>a is b; a is not b</code></p></td>
  </tr>
  <tr>
    <td valign="top"><p><code>assertIsNone(a, M)</code></p></td>
    <td valign="top"><p><code>assertIsNotNone(a, M)</code></p></td>
    <td valign="top"><p><code>a = nil; a ≠ nil</code></p></td>
  </tr>
  <tr>
    <td valign="top"><p><code>AssertIsInstance(a, b, M)</code></p></td>
    <td valign="top"><p><code>AssertIsNotInstance(a, b, M)</code></p></td>
    <td valign="top"><p><code>isinstance(a,b);<br/>not isinstance(a,b)</code></p></td>
  </tr>
</table>	
<p><b>Table 1: Basic asserts in unittest. </b></p>
<p>To check for just a <code>True</code> or <code>False</code>, use <code>assertTrue()</code> or <code>assertFalse()</code>, as in Listing Three: </p>
<p><b>Listing Three: Checking for True or False.</b></p>
<p/><pre class="brush: python; html: collapse;">
self.assertTrue(argState, "foobar() gave back a False")
# -- fires when the instance method foobar() returns a True

self.assertFalse(argState)
# -- fires when foobar() returns a False
# Notice this one does not supply an assert message
</pre>
<p>
</p><p>To check whether two arguments are the same, use <code>assertEqual() </code>and <code>assertNotEqual()</code> as in Listing Four. These last two <code>assert</code>s check the arguments' values, as well as their data types.</p>
<p><strong>Listing Four: Checking arguments. </strong></p>
<p/><pre class="brush: python; html: collapse;">
argFoo = "narf"
argBar = "zort"

self.assertEqual(argFoo, argBar, "These are not the same")
# -- this assert will fail

self.assertNotEqual(argFoo, argBar, "These are the same")
# -- this assert will succeed

argFoo = 123
argBar = "123"

self.assertEqual(argFoo, argBar, "These are not the same")
# -- this assert will fail
</pre>
<p>To check if the arguments are the same objects, use <code>assertIs()</code> and <code>assertIsNot()</code>. Like <code>assertEqual() </code>and <code>assertNotEqual()</code>, these two <code>assert</code>s examine both argument values and type. To check if an argument is an instance of a specific class, use <code>assertIsInstance()</code> and <code>assertIsNotInstance()</code> as in Listing Five.</p>
<p><strong>Listing Five: Checking if an argument is an instance of a specific class.</strong></p>
<p/><pre class="brush: python; html: collapse;">
argFoo = Bar()

# checking against class Bar
self.assertIsInstance(argFoo, Bar, "The object is not an instance of class Bar")
# -- this assert will succeed

# checking against class Foo
self.assertIsNotInstance(argFoo, Foo, "The object is an instance of class Foo")
# -- this assert will fail
</pre>
<p>Both <code>assert</code>s get a class name as a second argument. Both behave similarly to the library function<code> isInstance()</code>. Finally, to check for a <code>nil</code>, use<code> assertIsNone()</code> and <code>assertIsNotNone()</code>.</p>
<p>The second set of <code>assert</code>s are comparative (see Table 2).</p>
<p>
</p><table border=".3" cellspacing="1" cellpadding="3">
  <tr>
    <td valign="top"><b>Assert</b></td>
    <td valign="top"><b>Complement Assert</b></td>
    <td valign="top"><b>Operation</b></td>
  </tr>
  <tr>
    <td valign="top"><p><code>assertGreater(a, b, M)</code></p></td>
    <td valign="top"><p><code>assertLess(a, b, M)</code></p></td>
    <td valign="top"><p><code>a &gt; b; a &lt; b</code></p></td>
  </tr>
  <tr>
    <td valign="top"><p><code>assertGreaterEqual(a, b, M)</code></p></td>
    <td valign="top"><p><code>assertLessEqual(a, b, M)</code></p></td>
    <td valign="top"><p><code>a ≥ b; a ≤ b</code></p></td>
  </tr>
  <tr>
    <td valign="top"><p><code>assertAlmostEqual(a, b, n, M)</code></p></td>
    <td valign="top"><p><code>assertNotAlmostEqual(a, b, n, M)</code></p></td>
    <td valign="top"><p><code>round(a-b, n) = 0<br/> round)a-b, n) ≠ 0</code></p></td>
  </tr>
  <tr>
    <td valign="top"><p><code>assertItemsEqual(a, b, M)</code></p></td>
    <td valign="top"><p><code><i>none</i></code></p></td>
    <td valign="top"><p><code>sort(a) = sort(b);<br/>sort(a) ≠ sort(b)</code></p></td>
  </tr>
</table>
<p><strong>Table 2: The comparative assertions.</strong></p>
<p>	
		</p></article>
</div></body></html>