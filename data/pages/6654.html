<html><body><div><div class="entry-content">
  <p>Python has a big problem.  While it’s easy and fun to produce software in
Python, it’s hard to produce software that people - especially laypeople who
are not professional software developers - can <em>use</em>.</p>
<p>In the modern software ecosystem, there are a few places that you might want to
use a program:</p>
<ol>
<li>On a server, by loading a web page.</li>
<li>On a web page, by running it in your browser.</li>
<li>As a command-line tool, on Mac,</li>
<li>... Windows,</li>
<li>... or Linux.</li>
<li>As a desktop application, on Mac,</li>
<li>... Windows,</li>
<li>... or Linux.</li>
<li>As a mobile application, on iOS,</li>
<li>... or Android,</li>
<li>... Or Windows Phone.  (Just kidding.)</li>
</ol>
<p>Out of these 10 scenarios, Python currently has half of a good deployment story
for <em>one</em> of them: running an application on a server, as a back-end.  This is
a serious problem for the future of Python and one we need to figure out how to
face as a community.</p>
<p>Even the “good” deployment story is somewhat convoluted, as you need to know
about at least some Linux distribution’s package manager, and native
dependencies, and Pip, and virtualenv, and wheels, and
<a href="https://glyph.twistedmatrix.com/2015/03/docker-deploy-double-dutch.html">probably docker too</a>.</p>
<p>If you want to run a Python application in your browser, your best bet right
now is probably <a href="http://brython.info">Brython</a>.  However, brython is still in
its infancy, and basic faciltiies like
<a href="https://github.com/brython-dev/brython/issues/239">preparing your code for production to achieve acceptable start-up performance</a>,
and
<a href="https://github.com/brython-dev/brython/issues/119">an explanation of how to use libraries</a>
are missing.  With big chunks like that missing it’s hard to advocate for
Brython’s use in production.</p>
<p>Moving on to scenario 3, this may be one of the best-supported configurations;
<a href="http://pythonhosted.org/py2app/">py2app</a> actually works surprisingly well.
But it’s still incredibly confusing for new users.  Which native objects
(dylibs and frameworks and data files) to bundle are options to py2app itself,
and not something that can be handled automatically by libraries.  So if, for
example, PyGame depends on <code>SDL.framework</code> or <code>libSDL.dylib</code>, you as an
application developer need to understand how to figure that out and specify
that list.</p>
<p>On Windows, the situation gets worse.  To work as a Windows exectuable, you
need to bundle the Python interpreter, but unlike in an OS X application, you
can’t just copy in a whole directory.  So you end up needing a tool like
<a href="https://github.com/pyinstaller/pyinstaller/wiki">PyInstaller</a> or
<a href="https://warehouse.python.org/project/cx_Freeze/">cx_Freeze</a>.  PyInstaller
hasn’t seen a release in the last 2 years; it doesn’t support Python 3.  It
also doesn’t work: if I try to package the most basic Twisted program possible,
with pyinstaller 2.1 I get “no module named zope.interface”, and if I try to
package it with pyinstaller trunk, I get “no module named itertools”.
cx_Freeze similarly can’t figure out how to include zope.interface no matter
what I tell it to do.  This problem
<a href="http://stackoverflow.com/questions/26821102/cx-freeze-cant-find-oslo-module">isn’t specific to libraries that I use</a>;
most Python projects will run into it.</p>
<p>py2exe, on the other hand, <em>only</em> supports Python 3.3+, and so is unusable with
a lot of important python libraries.</p>
<p>For a GUI application for Linux, you might have some small hope of building a
distro-specific package that users could install, but that would involve using
a distro-specific toolchain that had nothing to do with Python, and you need to
repeat that work for Debian, Ubuntu, Fedora, and whatever other distros you
want to support.</p>
<p>All of these same tools are what I would use to build a stand-alone
command-line executable for Windows, Mac, or Linux, and they all break down in
similar ways.</p>
<p>In the mobile space, there is absolutely zero tooling included with the
language to even get started there.  It might be possible to use
<a href="http://kivy.org/">Kivy</a> to get a build onto
<a href="http://kivy.org/docs/guide/packaging-ios.html#compile-the-distribution">iOS</a>
or
<a href="http://kivy.org/docs/guide/packaging-android.html#packaging-your-application-into-apk">Android</a>.
I haven’t had an opportunity to test those.  But they still require you to
install Homebrew, and a C compiler, and a whole bunch of fairly specific
platform tooling to get started, and there are lots of different ways that can
go wrong.</p>
<p>So how do other languages stack up?</p>
<ol>
<li>In JavaScript, if you want an application in the browser, it’s as simple as
   ... writing some JavaScript.</li>
<li>In JavaScript, if you want a desktop application, you can just grab
   <a href="http://electron.atom.io">Electron</a> and be up and running in a few minutes.</li>
<li>In JavaScript, if you want a command-line UNIX tool, you can grab
   <a href="https://github.com/h2non/nar">nar</a> and build something self-contained
   almost immediately.</li>
<li>And of course, in Go, there’s no way to get anything <em>but</em> a fully
   functional self-contained executable at the end of the build process.
   Everything is fully redistributable by default.</li>
</ol>
<p>As a community, Python <em>needs</em> a clear, well-documented, well-supported, modern
way to produce build artifacts that are easy to create and easy to share.  We
need to have this for all popular platforms and the browser.  This is a tricky
problem: it requires knowledge of lots of fiddly build details.</p>
<p>This wheel has been re-invented, poorly, a dozen or so times.  My list above
was just a subset.  In addition to py2app, py2exe, pyinstaller, cx_Freeze, and
the Kivy bundling tools, we’ve also got terrarium, bbfreeze (which is
unmaintained), pipsi, pex, and probably some others I don’t know about.</p>
<p>In order to compete with JavaScript and Go for developers’ attention, Python
must be able to <strong>become an implementation detail and disappear</strong> when the user
is running the program.  This means that some of these tools (terrarium, pipsi,
pex) are not suitable for this purpose because they are envelopes for
deployment into an environment with an installed Python interpreter.</p>
<p>All of the tools I’m aware of that are trying to provide fully self-contained
execution, though (pyinstaller, cx_freeze, bb-freeze, py2app) are poorly
designed because they value <em>optimized distribution size</em> over <em>actually
working by default</em>.  Rather than reading setuptools metadata and discovering
the full set of dependencies which have been declared to be required, all of
these tools use weird AST-parsing heuristics and buggy path-traversal hacks to
try to construct a guess as to the minimal set of files that <em>might</em> be
required, then require the poor application developer to fill in the gaps.
This means none of them work with namespace packages, none of them work
properly with plugin systems or runtime configuration systems; generally, they
don’t work correctly with late binding, which is one of Python’s greatest
strengths.  Of course, a full Python interpreter with the whole standard
library is quite large.  If we had a tool that worked well but produced very
large executables, we could of course start adding an “optimized mode” to try
to crunch things down for production.</p>
<p>And all this is to say nothing of the insanely intricate and detailed knowledge
that every Python programmer eventually acquires about the C runtime semantics
of their chosen platform.  When a C compiler is required but missing, most
tools still just emit tracebacks.  When a shared library goes missing dues to
an OS upgrade or package removal, you just see whatever the dynamic linker
thinks to report, no explanation of how to fix it or what to do next.</p>
<p>The Python packaging ecosystem has made great strides in the last few years;
Pip, in particular, has gone from a buggy and insecure mess to a mostly
workable software delivery mechanism for developers.  There are still bugs, but
they are getting dealt with at a reasonable clip.  However, Pip only delivers
software to <em>developers</em>, and still requires you to have a Python runtime, a
build environment, and tricky command-line tools to get things in place for
development.  The Python community has effectively no tools to deliver software
to <em>users</em>.</p>
<p>To sum up, we need a tool which:</p>
<ol>
<li>works by default, including with “tricky” packages with namespace packages,
   data files, and native dependencies</li>
<li>produces useful, actionable error messages when something is missing and the
   build can’t be completed (like “you don’t have a C compiler installed” or
   “you need to install <a href="http://brew.sh">Homewbrew</a> and then <code>brew install
   openssl</code>”)</li>
<li>can produce both command-line and GUI executables for the mac, windows, and
   linux (and, for bonus points, a web browser)</li>
</ol>
<p>The bad news is that I don’t have the time to start this project myself, and
I’m not sure who does.  The worse news is that every day we don’t have this,
more and more people are re-writing their user-facing tools and applications in
JavaScript or Go or Swift or Java, to suit their target platform, because it is
<em>honestly easier to learn an entirely new programming language and toolchain,
and rewrite an entire application</em> than to figure out how to build a
self-contained executable in Python right now.</p>
<p>The <em>good</em> news, though, is that it’s a simple matter of programming, and that
all the core technologies for doing all the really hard things that need to be
done (pip, and <a href="https://docs.python.org/2/library/zipimport.html">zipimport</a>
and <a href="https://pypi.python.org/pypi/macholib">macholib</a>, for example) already
exist.  It’s just a simple matter of programming: wiring together the metadata
from setuptools, determining native dependencies with something like <code>otool</code> or
<code>ldd</code> (or whatever the equivalent is on Windows, I still haven’t figured that
out myself), pulling them all into a bundle, tacking the Python interpreter on.</p>
</div>
</div></body></html>