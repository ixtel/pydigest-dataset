<html><body><div><div class="clearfix"><p><img src="/images/blog/skele-cli.png" title="Skele CLI" alt="skele-cli"/></p>

<p>Building command line programs has been a long time passion of mine. There’s
something magical about making a simple, intuitive, and composable CLI. There’s also
nothing more beautiful than chaining together a series of CLI programs to solve
a complex problem quickly.</p>

<p>Here at <a href="https://stormpath.com/" title="Stormpath">Stormpath</a>, we’ve built our entire <a href="https://github.com/stormpath/stormpath-cli" title="Stormpath CLI">product CLI</a> in Python to
create / manage / edit users for your applications, and have
been really happy with the result.</p>

<p>Most of this is thanks to the wonderful <a href="http://docopt.org/" title="docopt">docopt</a> library, which provides
<strong>automatic</strong> CLI argument parsing and makes building complicated CLIs <strong>incredibly
simple</strong>.  And the best part? It works across more than <strong>20 different
programming languages!</strong>  This means that even if you’re building a new CLI app
in Go, Rust, or something in between, chances are you can use <em>docopt</em>, too!</p>

<p>If you want to know how to structure your next CLI-based app to minimize
complexity and maximize awesomeness, keep reading.</p>

<h2>An Overview of CLI Tools</h2>

<p>For the purposes of this article, we’re going to be building a really simple CLI
called <em>skele</em> that works via subcommands.</p>

<p>There are typically two types of CLI tools that people build: single and
multi-command.  A good example of a single command CLI tool would be the
<a href="http://www.gnu.org/software/grep/manual/grep.html" title="grep">grep</a> command.</p>

<p>This is because the <em>grep</em> tool takes various options, but does only one thing:
match text.</p>

<p>For instance, if I wanted to search a file for my name, I might run the
following command:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="console"><span class="line"><span class="gp">$</span> grep <span class="s1">'Randall'</span> some-file.txt
</span></code></pre></td></tr></table></div></figure>


<p>On the other hand, there are CLI tools that operate via sub-commands, and do
many things.  These tools are typically harder to build as they have more
complexity.</p>

<p>A good example of sub-command driven CLI tool would be the <a href="https://devcenter.heroku.com/articles/heroku-command" title="Heroku CLI">Heroku</a> CLI tool.
This tool allows you to create new web applications, deploy them live, and
provision resources for these applications — all via sub-commands.</p>

<p>For instance, if I wanted to create a new Heroku application, I might run the
following command:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="console"><span class="line"><span class="gp">$</span> heroku applications:create my-new-app
</span></code></pre></td></tr></table></div></figure>


<p>In the example above, <code>applications:create</code> is the name of a sub-command.</p>

<p>If I wanted to later remove my application from Heroku, I could then say:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="console"><span class="line"><span class="gp">$</span> heroku applications:destroy my-new-app
</span></code></pre></td></tr></table></div></figure>


<p>See how the one CLI tool can perform different actions?  Well, that’s what we’ll
be building today.  A CLI tool that is capable of simply running sub-commands
and handling them in a graceful way.</p>

<p>The specific CLI tool I’ve built as reference material for this article is
called <em>skele</em>, and can be found on this <a href="https://github.com/rdegges/skele-cli" title="skele-cli">Github page</a>.</p>

<p>This tool ships with a single sub-command <em>hello</em>, that just prints some text to
the console.  It also includes a manual page, help information, and version
information in a standard UNIX-compliant manner.</p>

<p>So, on with the show!</p>

<h2>Structuring a CLI Project in Python</h2>

<p>Before we dive into all the specifics regarding how to build good CLI-based
applications, let’s first talk about structuring your project properly. If you
want to skip ahead and just look at the source code to figure out how things
work, here’s a link to the <a href="https://github.com/rdegges/skele-cli" title="skele-cli">Github page</a>.</p>

<p>There is an infinite number of ways to structure Python projects, but for CLI
apps in particular, I like the following approach the best as it is straightforward, and keeps things simple:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="console"><span class="line"><span class="go">skele-cli</span>
</span><span class="line"><span class="go">├── MANIFEST.in</span>
</span><span class="line"><span class="go">├── README.rst</span>
</span><span class="line"><span class="go">├── setup.cfg</span>
</span><span class="line"><span class="go">├── setup.py</span>
</span><span class="line"><span class="go">└── skele</span>
</span><span class="line"><span class="go">    ├── __init__.py</span>
</span><span class="line"><span class="go">    ├── cli.py</span>
</span><span class="line"><span class="go">    └── commands</span>
</span><span class="line"><span class="go">        ├── __init__.py</span>
</span><span class="line"><span class="go">        ├── base.py</span>
</span><span class="line"><span class="go">        └── hello.py</span>
</span><span class="line">
</span><span class="line"><span class="go">2 directories, 9 files</span>
</span></code></pre></td></tr></table></div></figure>


<p>At the very top-level, you’ve got the project folder, which in this case is
called <code>skele-cli</code>.  This will be your main code repository.</p>

<h3>Python Packaging Files</h3>

<p>Inside of the top-level project folder, you’ve got a few Python packaging
files that I’ll explain below.</p>

<p>Firstly, you’ve got <code>MANIFEST.in</code>.  This tells the Python build tool what files
to include when you ship your package to the world.</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="console"><span class="line"><span class="gp">#</span> MANIFEST.in
</span><span class="line"><span class="go">exclude .gitignore</span>
</span><span class="line"><span class="go">exclude .coverage</span>
</span><span class="line"><span class="go">exclude .travis.yml</span>
</span><span class="line"><span class="go">include README.rst</span>
</span><span class="line"><span class="go">include setup.cfg</span>
</span><span class="line"><span class="go">prune .cache</span>
</span><span class="line"><span class="go">prune .git</span>
</span><span class="line"><span class="go">prune build</span>
</span><span class="line"><span class="go">prune dist</span>
</span><span class="line"><span class="go">recursive-exclude *.egg-info *</span>
</span><span class="line"><span class="go">recursive-include tests *</span>
</span></code></pre></td></tr></table></div></figure>


<p>As you’ll notice above, I’m pro-actively removing and excluding a lot of
unnecessary files that would otherwise get included in the package.</p>

<p>Whenever you <em>build</em> your Python package, this file will be scanned by the
Python build tool, and these rules will be used to remove or add files in your
package accordingly.</p>

<p>In particular, I don’t like including private git folders, build folders,
coverage reports, etc. in my package builds, as it unnecessarily clutters up a
user’s system.</p>

<p>Next up, you’ve got the <code>setup.cfg</code> file.  This file just tells the Python
build tool that your program should run on all platforms when building the
binary.  If this isn’t true for your specific project, you can remove this
file.</p>

<p><strong>NOTE</strong>: For 99.99% of people, you’ll want to leave this file alone =)</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="console"><span class="line"><span class="gp">#</span> setup.cfg
</span><span class="line"><span class="go">[bdist_wheel]</span>
</span><span class="line"><span class="go">universal=1</span>
</span></code></pre></td></tr></table></div></figure>


<p>Finally, you’ve got the <code>setup.py</code> file.  This is where you tell Python all
about your CLI tool and how it is packaged up.</p>

<p>Now, the next file we’re going to look at is quite large (<code>setup.py</code>), so I
won’t copy / paste all the contents here, if you want to view the entire
thing, check it out on Github: <a href="https://github.com/rdegges/skele-cli/blob/master/setup.py">https://github.com/rdegges/skele-cli/blob/master/setup.py</a></p>

<p>Here’s the important / cool bits you should know about:</p>

<ul>
<li>This setup script will automatically use your <code>README.rst</code> file for
documentation.  This is nice because when you deploy your package to PyPI,
it will have legitimate looking documentation:</li>
</ul>


<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">this_dir</span> <span class="o">=</span> <span class="n">abspath</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">))</span>
</span><span class="line"><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">this_dir</span><span class="p">,</span> <span class="s">'README.rst'</span><span class="p">),</span> <span class="n">encoding</span><span class="o">=</span><span class="s">'utf-8'</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
</span><span class="line">    <span class="n">long_description</span> <span class="o">=</span> <span class="nb">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>This setup script includes testing support via the popular <a href="http://pytest.org/latest/" title="py.test">py.test</a> library
(and coverage reporting, too!).  This means that if you run the <code>$ python
setup.py test</code> command, your entire package will be tested nicely (assuming
you write tests, that is).  Here’s the code that makes this possible:</li>
</ul>


<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">RunTests</span><span class="p">(</span><span class="n">Command</span><span class="p">):</span>
</span><span class="line">    <span class="sd">"""Run all tests."""</span>
</span><span class="line">    <span class="n">description</span> <span class="o">=</span> <span class="s">'run tests'</span>
</span><span class="line">    <span class="n">user_options</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">initialize_options</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">pass</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">finalize_options</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">pass</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="sd">"""Run all tests!"""</span>
</span><span class="line">        <span class="n">errno</span> <span class="o">=</span> <span class="n">call</span><span class="p">([</span><span class="s">'py.test'</span><span class="p">,</span> <span class="s">'--cov=skele'</span><span class="p">,</span> <span class="s">'--cov-report=term-missing'</span><span class="p">])</span>
</span><span class="line">        <span class="k">raise</span> <span class="ne">SystemExit</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>This setup script won’t accidentally install your documentation or tests on
the user’s system as actual packages.  This happens quite frequently, and
causes nasty namespace collisions.  The relevant bit of code that prevents
this from happening can be seen below:</li>
</ul>


<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">packages</span> <span class="o">=</span> <span class="n">find_packages</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="s">'docs'</span><span class="p">,</span> <span class="s">'tests*'</span><span class="p">]),</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>This setup script can install all development dependencies easily — this
means that if you’re cloning this project fresh, and want to work on it for
development purposes, you can run the <code>$ pip install -e .[test]</code> command and
the entire CLI program as well as <strong>all test dependencies</strong> will be installed!</li>
</ul>


<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">extras_require</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">    <span class="s">'test'</span><span class="p">:</span> <span class="p">[</span><span class="s">'coverage'</span><span class="p">,</span> <span class="s">'pytest'</span><span class="p">,</span> <span class="s">'pytest-cov'</span><span class="p">],</span>
</span><span class="line"><span class="p">},</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Lastly, this script ensures that your CLI program is started correctly when
run from the command line.  If a user installs your CLI program, they’ll be
able to run it by simply typing the program name, in this case, <code>$ skele</code> in
the terminal:</li>
</ul>


<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">entry_points</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">    <span class="s">'console_scripts'</span><span class="p">:</span> <span class="p">[</span>
</span><span class="line">        <span class="s">'skele=skele.cli:main'</span><span class="p">,</span>
</span><span class="line">    <span class="p">],</span>
</span><span class="line"><span class="p">},</span>
</span></code></pre></td></tr></table></div></figure>


<h3>The CLI Package</h3>

<p>Now that we’ve covered the Python packaging files, let’s talk about the actual
CLI package itself! How do we structure our actual Python code?</p>

<p>The first thing we’ll need is a package (a folder in this case) called <code>skele</code>
— as this is our application’s name.</p>

<p>Inside of this folder there are two files we need to quickly discuss.</p>

<p>First, the <code>__init__.py</code> file.  The only thing this file contains is our
program’s version number:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># __init__.py</span>
</span><span class="line"><span class="n">__version__</span> <span class="o">=</span> <span class="s">'1.0.0'</span>
</span></code></pre></td></tr></table></div></figure>


<p>This version number is what you’ll update when you make new releases.</p>

<p>Second, we’ve got our <code>cli.py</code> file — this is where most of the magic happens.
This file contains a function named <code>main</code> which is the code that will actually
run when a user types <code>$ skele</code> in the command line.</p>

<p>The reason this function is the one that runs is because of the code we setup
previously in our <code>setup.py</code> file:
<a href="https://github.com/rdegges/skele-cli/blob/master/setup.py#L64-L68">https://github.com/rdegges/skele-cli/blob/master/setup.py#L64-L68</a> (these lines
of code tell Python to execute this particular function when our program is run).</p>

<p>So, next up we’ve got our <code>commands</code> module (another folder).  This module
contains the actual implementation of our CLI commands.</p>

<p>If you take a look in this folder, you’ll see the following files defined:</p>

<ul>
<li><code>__init__.py</code> – This contains our import statements.</li>
<li><code>base.py</code> – A base command class that all other classes will extend.</li>
<li><code>hello.py</code> – This is an example command implementation.</li>
</ul>


<p>If I was building a CLI app that could be used by typing:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="console"><span class="line"><span class="gp">$</span> skele hi
</span><span class="line"><span class="gp">$</span> skele bye
</span></code></pre></td></tr></table></div></figure>


<p>Then I’d have two new Python files in my <code>commands</code> folder: <code>hi.py</code> and
<code>bye.py</code>.  This is how I like to structure things to keep them as simple as
possible.</p>

<p>So now that we’ve covered the basic layout, let’s talk about the actual
implementation.</p>

<h2>Using docopt to Build a Simple CLI</h2>

<p><img src="/images/blog/docopt.png" alt="docopt" class="center-block"/></p>

<p>I love the <a href="http://docopt.org/" title="docopt">docopt</a> library.  It makes defining CLI interfaces incredibly
simple.</p>

<p>The way docopt works is pretty magical: instead of writing rules and telling
your program what options to look for, you instead just define the manual page
for your CLI program, and docopt will <strong>automatically</strong> parse this string for
you, and generate all the option parsing code too!</p>

<p>Here’s how it works in the <code>skele</code> example application I’ve built.  This is the
<code>cli.py</code> file source code (notice the big docstring at the top of the file):</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="sd">"""</span>
</span><span class="line"><span class="sd">skele</span>
</span><span class="line">
</span><span class="line"><span class="sd">Usage:</span>
</span><span class="line"><span class="sd">  skele hello</span>
</span><span class="line"><span class="sd">  skele -h | --help</span>
</span><span class="line"><span class="sd">  skele --version</span>
</span><span class="line">
</span><span class="line"><span class="sd">Options:</span>
</span><span class="line"><span class="sd">  -h --help                         Show this screen.</span>
</span><span class="line"><span class="sd">  --version                         Show version.</span>
</span><span class="line">
</span><span class="line"><span class="sd">Examples:</span>
</span><span class="line"><span class="sd">  skele hello</span>
</span><span class="line">
</span><span class="line"><span class="sd">Help:</span>
</span><span class="line"><span class="sd">  For help using this tool, please open an issue on the Github repository:</span>
</span><span class="line"><span class="sd">  https://github.com/rdegges/skele-cli</span>
</span><span class="line"><span class="sd">"""</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">getmembers</span><span class="p">,</span> <span class="n">isclass</span>
</span><span class="line">
</span><span class="line"><span class="kn">from</span> <span class="nn">docopt</span> <span class="kn">import</span> <span class="n">docopt</span>
</span><span class="line">
</span><span class="line"><span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">__version__</span> <span class="k">as</span> <span class="n">VERSION</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span><span class="line">    <span class="sd">"""Main CLI entrypoint."""</span>
</span><span class="line">    <span class="kn">import</span> <span class="nn">commands</span>
</span><span class="line">    <span class="n">options</span> <span class="o">=</span> <span class="n">docopt</span><span class="p">(</span><span class="n">__doc__</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="n">VERSION</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="c"># Here we'll try to dynamically match the command the user is trying to run</span>
</span><span class="line">    <span class="c"># with a pre-defined command class we've already created.</span>
</span><span class="line">    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">options</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
</span><span class="line">        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
</span><span class="line">            <span class="n">module</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</span><span class="line">            <span class="n">commands</span> <span class="o">=</span> <span class="n">getmembers</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">isclass</span><span class="p">)</span>
</span><span class="line">            <span class="n">command</span> <span class="o">=</span> <span class="p">[</span><span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span> <span class="k">if</span> <span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'Base'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</span><span class="line">            <span class="n">command</span> <span class="o">=</span> <span class="n">command</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
</span><span class="line">            <span class="n">command</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>That huge docstring at the top of the file is standard CLI documentation, right?
It looks like the output you see when you run a CLI program.  It lists how to
use the program, how it works, and what options are available.</p>

<p>Well, what happens here is that down below, in the <code>main</code> function, I’m using
the <code>docopt</code> library to parse that huge docstring and generate a list of options
automatically:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># __doc__ is a special variable that references this file's docstring.</span>
</span><span class="line"><span class="n">options</span> <span class="o">=</span> <span class="n">docopt</span><span class="p">(</span><span class="n">__doc__</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="n">VERSION</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you go ahead and print out the <code>options</code> variable, you’ll see something
similar to the following (depending on how you run the program):</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># `$ skele hello` is the command I ran to output these options.</span>
</span><span class="line"><span class="p">{</span><span class="s">'--help'</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
</span><span class="line"> <span class="s">'--version'</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
</span><span class="line">  <span class="s">'hello'</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Pretty amazing, right?  docopt generated a dictionary of options that have
already been parsed and validated automatically.</p>

<p>Notice how the <code>hello</code> variable is set to <code>True</code>? This means that the user
typed the <code>$ skele hello</code> command =)</p>

<p>Now, since we know that docopt is already handling the hard stuff:</p>

<ul>
<li>Parsing our CLI documentation into real options.</li>
<li>Generating a dictionary of options.</li>
</ul>


<p>All we have to do is call the appropriate code to run, right?</p>

<p>In the above example, we’re running the <code>$ skele hello</code> command on the CLI — so
in the next section, we’ll take a look at how to hook that logic into our app.</p>

<h2>Defining Commands in the CLI Program</h2>

<p>When building a CLI program, most of the time your program is going to do
different things based on what sub-commands are being run.</p>

<p>For instance, in our example <code>skele</code> application, I might want to define several
sub-commands that a user can run:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="console"><span class="line"><span class="gp">$</span> skele hello   <span class="c"># say hello, world!</span>
</span><span class="line"><span class="gp">$</span> skele bye     <span class="c"># say bye!</span>
</span><span class="line"><span class="gp">#</span> etc...
</span></code></pre></td></tr></table></div></figure>


<p>In the example above, I’m referring to both <code>hello</code> and <code>bye</code> as sub-commands.</p>

<p>The way I’ve structured the <code>skele</code> sample app is such that you can define a
Python file for each sub-command you want to support, and it will get run
automatically when the user specifies that command.</p>

<p>Let’s take a look at how a command works.  We’ll start by looking at the
<code>hello.py</code> file:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># skele/commands/hello.py</span>
</span><span class="line"><span class="sd">"""The hello command."""</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="kn">from</span> <span class="nn">json</span> <span class="kn">import</span> <span class="n">dumps</span>
</span><span class="line">
</span><span class="line"><span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">Base</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">Hello</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
</span><span class="line">    <span class="sd">"""Say hello, world!"""</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">print</span> <span class="s">'Hello, world!'</span>
</span><span class="line">        <span class="k">print</span> <span class="s">'You supplied the following options:'</span><span class="p">,</span> <span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The idea is that each command will have a class inside of it that extends from
<code>Base</code>.  Here’s what <code>base.py</code> looks like:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># skele/commands/base.py</span>
</span><span class="line"><span class="sd">"""The base command."""</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class="line">    <span class="sd">"""A base command."""</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">'You must implement the run() method yourself!'</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Whenever we construct a new instance of a command class, we’ll pass in the
options that were generated using docopt. This way, each sub-command has access
to all the user supplied CLI information.</p>

<p>Finally, we’ll define a <code>run</code> method on each command class, and this is what
we’ll call to actually do something that the user wants.  This is where we’ll put
our logic.</p>

<p>In the <code>hello.py</code> example, we’re simply going to say “Hello, world!” and output
the options.</p>

<p>Now, going back to the <code>cli.py</code> file, let’s take a look at how we actually use
these command classes to get stuff done:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># skele/cli.py</span>
</span><span class="line"><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span><span class="line">    <span class="sd">"""Main CLI entrypoint."""</span>
</span><span class="line">    <span class="kn">import</span> <span class="nn">commands</span>
</span><span class="line">    <span class="n">options</span> <span class="o">=</span> <span class="n">docopt</span><span class="p">(</span><span class="n">__doc__</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="n">VERSION</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="c"># Here we'll try to dynamically match the command the user is trying to run</span>
</span><span class="line">    <span class="c"># with a pre-defined command class we've already created.</span>
</span><span class="line">    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">options</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
</span><span class="line">        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
</span><span class="line">            <span class="n">module</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</span><span class="line">            <span class="n">commands</span> <span class="o">=</span> <span class="n">getmembers</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">isclass</span><span class="p">)</span>
</span><span class="line">            <span class="n">command</span> <span class="o">=</span> <span class="p">[</span><span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span> <span class="k">if</span> <span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'Base'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</span><span class="line">            <span class="n">command</span> <span class="o">=</span> <span class="n">command</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
</span><span class="line">            <span class="n">command</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>What we’re doing here is this:</p>

<ul>
<li>We parse the CLI options from the user via docopt.</li>
<li>We loop through the CLI options.</li>
<li>If there is a command module whose name matches a CLI option, then we’ll
dynamically figure out the name of the command class.</li>
<li>After getting the command class, we’ll create an instance of it, passing along
the user supplied options from docopt.</li>
<li>Finally, we’ll call the <code>run</code> method on our class, which will actually make
stuff happen.</li>
</ul>


<p>If we were to say <code>$ skele hello</code>, for instance, here’s what would happen:</p>

<ul>
<li>We’d loop through the commands module and find that <code>commands.hello</code> is a
valid Python module.</li>
<li>We’d then figure out that <code>Hello</code> is the name of the class we’ve defined
inside that file.</li>
<li>Finally, we’ll create a new instance of a <code>Hello</code> class, and call the <code>run</code>
method.</li>
</ul>


<p>All together now, this is what makes our CLI program work!</p>

<p>This is pretty cool because it means that adding or changing our CLI interface
is as simple as modifying the docstring we’ve defined in <code>skele/cli.py</code>, as well
as creating a proper command in our <code>commands</code> directory.</p>

<p>Simple, right?</p>

<h2>Building CLIs Made Simple</h2>

<p>By utilizing the awesome <a href="http://docopt.org/" title="docopt">docopt</a> module, and structuring your project the
right way, building simple CLI programs can be really easy!</p>

<p>Be sure to check out <a href="https://github.com/rdegges/skele-cli">skele-cli</a> on Github for reference, and if you’re looking for more information about Python packaging best practices, be sure to check out the official <a href="https://python-packaging-user-guide.readthedocs.org/en/latest/" title="Python Packaging Guide">Python packaging guide</a>.</p>
</div>



            </div></body></html>