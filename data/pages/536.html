<html><body><div><div class="content html_format"><p>
      Добрый день, хабраюзер.</p>
<p>
Предлагаю статью с реализацией поля формы django типа «вложенная таблица», с хранением данных в XML-формате.</p><p>
Это поможет интересующимся лучше разобраться с работой поля и виджета django и сделать шаг к созданию любого произвольного поля.</p><p>
Если вы это и так знаете, то для вас статья может быть не интересной.

</p><img src="https://habrastorage.org/getpro/habr/post_images/d39/d61/5c6/d39d615c6e8106691a21e24d781eee59.jpg"/>

<a name="habracut"/>
<p>
Для одного документооборота на django </p><p>
нужно сделать поддержку ввода в поля документа массива структурированных элементов (таблицу).
</p><p>
После недельного раздумья между вариантами </p><p>
 — Inline formset</p><p>
 — Вложенные документы (такой функционал уже был)</p><p>
 — Пользовательски поле / виджет c сериализацией в XML/JSON</p><p>
был выбран formset в XML
</p><p>
Inline formset был отклонен из-за существенного усложнения архитектуры:</p><p>
 — Нужно сохранять inline только после его создания (влезаем в метод сохранения документа)</p><p>
 — Нужна отдельная модель, </p><p>
 — Модельные формы
</p><p>
Вложенные документы тоже не подошли (не делать же свою структуру документа под каждое такое поле)
</p><p>
Идея с кастомным полем привлекла больше.</p><p>
Можно засунуть всю логику в поле / виджер и забыть о ней.</p><p>
Этот подход добавляет минимум сложности к архитектуре системы.
</p><p>
Несмотря на удобную работу с JSON (loads, dumps), </p><p>
был выбран XML из-за необходимости формирования отчетов из базы данных с помощью SQL.</p><p>
Если PostgreSQL поддерживает работу с JSON, то у Oracle она появляется только с 12 версии.</p><p>
При манипуляции с XML можно использовать индексы на уровне БД через xpath.

</p><div class="spoiler"><b class="spoiler_title">Работа на уровне SQL</b><div class="spoiler_text"><pre><code class="sql">-- Разбираем XML на колонки
select 
    t.id, 
    (xpath('/item/@n_phone', nt))[1] as n_phone1,
    (xpath('/item/@is_primary', nt))[1] as is_primary1,
    (xpath('/item/@n_phone', nt))[2] as n_phone2,
    (xpath('/item/@is_primary', nt))[2] as is_primary2
from docflow_document17 t
cross join unnest(xpath('/xml/item', t.nested_table::xml)) as nt;

-- Проверяем строки XML-таблицы
select 
    t.id
from docflow_document17 t
where t.id = 2
and ('1231234', 'False') in (
    select 
        (xpath('/item/@n_phone', nt_row))[1]::text,
        (xpath('/item/@is_primary', nt_row))[1]::text  
    from unnest(xpath('/xml/item', t.nested_table::xml)) as nt_row
);
</code></pre>
</div></div>
<p>
Изначально сходу был написан работающий виджет, который </p><p>
 — Принимал XML в метод render</p><p>
 — Генерировал и показывал formset</p><p>
 — В value_from_datadict генерировался formset, принимая параметр data, валидировал, собирал XML и выплевывал ее
</p><div class="spoiler"><b class="spoiler_title">Все это отлично работало и было очень простым</b><div class="spoiler_text"><pre><code class="python">class XMLTableWidget(widgets_django.Textarea):
    
    class Media:
        js = (settings.STATIC_URL + 'forms_custom/xmltable.js',)

    def __init__(self, formset_class, attrs=None):
        super(XMLTableWidget, self).__init__(attrs=None)

        self._Formset = formset_class

    def render(self, name, value, attrs=None):

        initial = []
        if value:
            xml = etree.fromstring(value)
            for row in xml:
                initial.append(row.attrib)

        formset = self._Formset(initial=initial, prefix=name)
        return render_to_string('forms_custom/xmltable.html', {'formset': formset})

    def value_from_datadict(self, data, files, name):
        u""" Если валидация прошла успешно, 
        то возвратиться измененный XML
        Если что-то с formset-ом не так, то будет возвращено initial-значение
        Внимание: валидацию на уровне formset-а делать нельзя, 
        потому что отсюда выбрасывать исключения нельзя """

        formset_data = {k: v for k, v in data.items() if k.startswith(name)}
        formset = self._Formset(data=formset_data, prefix=name)

        if formset.is_valid():
            from lxml.builder import E

            xml_items = []
            for item in formset.cleaned_data:

                if item and not item[formset_deletion_field_name]:
                    del item[formset_deletion_field_name]
                    item = {k: unicode(v) for k, v in item.items()}
                    xml_items.append(E.item("", item))

            xml = E.xml(*xml_items)
            return etree.tostring(xml, pretty_print=False)
        else:
            initial_value = data.get('initial-%s' % name)
            if initial_value:
                return initial_value
            else:
                raise Exception(_('Error in table and initial not find'))
</code></pre>
</div></div>
<p>
Если бы не один нюанс: невозможность нормальной валидации formset-а.</p><p>
Можно, конечно, сделать formset максимально мягким, ловить XML и проверять данные на уровне поля или формы.</p><p>
Можно, наверное в виджете хранить аттрибут «is_formset_valid» и проверять ее из поля типа self.widget.is_formset_valid, </p><p>
но от этого как-то нехорошо становилось.
</p><p>
Нужно делать совместную работу поля и виджета.</p><p>
Вот что получилось в итоге.
</p><p>
Решил не докучать перечитыванием исходного кода. </p><p>
Вместо этого, излишне подробно прокомментировал методы.</p><p>
Основная идея в том, чтобы стандартизировать разные входные параметры:</p><p>
 — XML, полученную при инициализации поля</p><p>
 — Словарь с данными на выходе из виджета</p><p>
 — Правильно подготовленную конструкцию</p><p>
преобразовать в единый формат типа {«formset»: formset, «xml_initial»: xml_string}</p><p>
А дальше «дело техники»

</p><div class="spoiler"><b class="spoiler_title">поле XMLTableField</b><div class="spoiler_text"><pre><code class="python">class XMLTableField(fields.Field):
    widget = widgets_custom.XMLTableWidget
    hidden_widget = widgets_custom.XMLTableHiddenWidget
    default_error_messages = {'invalid': _('Error in table')}

    def __init__(self, formset_class, form_prefix, *args, **kwargs):

        kwargs['show_hidden_initial'] = True  # Для получения значения при ошибках валидации
        super(XMLTableField, self).__init__(*args, **kwargs)

        self._formset_class = formset_class
        self._formset_prefix = form_prefix

        self._procss_widget_data_cache = {}
        self._prepare_value_cache = {}

    def prepare_value(self, value):
        u"""
        Принимаем на вход данные в произвольном виде из разных источников
        и приводим их к единому виду
        Если входной аргумент unicode,
            то это XML, считанная из БД при инициализации формы через initial
        Если словарь,
            то это или кусок POST-массива, полученного от виджета,
                В этом случае, мы преобразуем его в formset, а xml_initial
                поднимаем из hidden_initial формы.
                именно для этого принудительно выставлено show_hidden_initial = True
            или уже нормально подготовленный словарь, который не нужно подменять.

        """

        if value is None:
            return {'xml_initial': value,
                    'formset': self._formset_class(initial=[],
                                                   prefix=self._formset_prefix)}

        elif type(value) == unicode:

            value_hash = hash(value)
            if value_hash not in self._prepare_value_cache:
                initial = []
                if value:
                    xml = etree.fromstring(value)
                    for row in xml:
                        
                        # Нужно привести строковое 'False' в False, 
                        # потому что в XML оно хранится в тексте,
                        # а нам нужно в bool
                        attrs = {}
                        for k,v in row.attrib.items():
                            attrs[k] = False if v == 'False' else v
                        
                        initial.append(attrs)

                formset = self._formset_class(initial=initial, prefix=self._formset_prefix)
                self._prepare_value_cache[value_hash] = formset

            return {'xml_initial': value, 'formset': self._prepare_value_cache[value_hash]}

        elif type(value) == dict:

            if 'xml' not in value:
                formset = self._widget_data_to_formset(value)
                return {'xml_initial': value['initial'], 'formset': formset}

            return value

    def clean(self, value):
        u"""
        При преобразовании данных от виджета в данные, возвращаемые формой,
        пропускаем через валидацию formset-ом, 
        а потом этот formset переводим в XML
        в методе _formset_to_xml может вызываться ValidationError, если formset не валидный
        """

        formset = self._widget_data_to_formset(value, 'clean')
        return self._formset_to_xml(formset)

    def _formset_to_xml(self, formset):
        u""" 
        Преобразование в XML
        вынесено в отдельную функцию.
        Используется в _has_changed для проверки измененности XML
        и в clean для сохранения в cleaned_data
        """

        if formset.is_valid():

            from lxml.builder import E

            xml_items = []
            for item in formset.cleaned_data:
                if item and not item.get(formset_deletion_field_name, False):
                    if formset_deletion_field_name in item:
                        del item[formset_deletion_field_name]
                    item = {k: unicode(v) for k, v in item.items()}
                    xml_items.append(E.item("", item))

            xml = E.xml(*xml_items)
            xml_str = etree.tostring(xml, pretty_print=False)
            return xml_str

        else:
            raise ValidationError(self.error_messages['invalid'], code='invalid')

    def _widget_data_to_formset(self, value, call_from=None):
        u""" 
        Преобразуем кусок POST-словаря, относящегося к formset-у
        Прогоняем через кэш, потому что через prepare_value эта функция вызывается много раз,
        а на этапе валидации FormSet-а могут быть много сложной логики
        """

        # Хэш для уменьшения нагрузки из-за частых вызовов self.prepare_value
        formset_hash = hash(frozenset(value.items()))
        if formset_hash not in self._procss_widget_data_cache:
            formset = self._formset_class(data=value, prefix=self._formset_prefix)
            self._procss_widget_data_cache[formset_hash] = formset
            return formset
        else:
            return self._procss_widget_data_cache[formset_hash]

    def _has_changed(self, initial, data):
        u"""
        Сюда приходят данные из виджета.
        Их нужно перегнать в formset с его валидацией, потом в XML для сравнения c исходным значением,
        потому что initial-значение лежит в XML
        """

        formset = self._widget_data_to_formset(data)
        try:
            data_value = self._formset_to_xml(formset)
        except ValidationError:
            return True

        return data_value != initial
</code></pre>
</div></div>

<div class="spoiler"><b class="spoiler_title">XMLTableHiddenWidget</b><div class="spoiler_text"><pre><code class="python">class XMLTableHiddenWidget(widgets_django.HiddenInput):
    
    def render(self, name, value, attrs=None):
        u""" Берем из массива xml_initial и пересылаем на render """
        
        value = value['xml_initial']
        return super(XMLTableHiddenWidget, self).render(name, value, attrs)
</code></pre>
</div></div>

<div class="spoiler"><b class="spoiler_title">XMLTableWidget</b><div class="spoiler_text"><pre><code class="python">class XMLTableWidget(widgets_django.Widget):
    
    class Media:
        js = (settings.STATIC_URL + 'forms_custom/xmltable.js',)

    def render(self, name, value, attrs=None):
        u""" 
        Сюда может прийти formset, инициализированный через initial
        или через data
        В любом случае, работаем с ним одинаково
        """
        formset = value['formset']
        return render_to_string('forms_custom/xmltable.html', {'formset': formset})

    def value_from_datadict(self, data, files, name):
        u""" 
        Нужно вытащить кусок данных, относящихся к formset-у 
        и отправить их на clean в поле
        Дополнительно к этому, прицепим initial-значение,
        которое пригодится при подготовки данных в поле
        """

        formset_data = {k: v for k, v in data.items() if k.startswith(name)}

        initial_key = 'initial-%s' % name
        formset_data['initial'] = data[initial_key]

        return formset_data
</code></pre>
</div></div>
<p>
В этом случае, основной задачей было обеспечение максимальной компактности
</p><div class="spoiler"><b class="spoiler_title">XMLTableWidget - шаблон</b><div class="spoiler_text"><pre><code class="django">{% load base_tags %}
{% load base_filters %}

{{formset.management_form}}

{% if formset.non_field_errors %}
    &lt;div class='alert alert-danger'&gt;
        {% for error in form.non_field_errors %}
            {{ error }}&lt;br/&gt;
        {% endfor %}
    &lt;/div&gt;
{% endif %}

&lt;table&gt;
    {% for form in formset %}
        {% if forloop.first %}
            &lt;tr&gt;
                {% for field in form.visible_fields %}
                    {% if field.name == 'DELETE' %}
                        &lt;td&gt;&lt;/td&gt;
                    {% else %}
                        &lt;td&gt;{{field.label}}&lt;/td&gt;
                    {% endif %}
                {% endfor %}
            &lt;/tr&gt;
        {% endif %}

        &lt;tr&gt;
            {% for field in form.visible_fields %}
                {% if field.name == 'DELETE' %}
                    &lt;th &gt;
                        &lt;div class='hide'&gt;{{field}}&lt;/div&gt;
                        &lt;a onclick="xmltable_mark_deleted(this, '{{field.auto_id}}')" class="pointer"&gt;
                            &lt;span class="glyphicon glyphicon-remove"&gt;&lt;/span&gt;
                        &lt;/a&gt;
                    &lt;/th&gt;
                {% else %}
                    &lt;td&gt;
                        {{ field|add_widget_css:"form-control" }}
                        {% if field.errors %}
                            &lt;span class="help-block"&gt;
                                        {% for error in field.errors %}
                                            {{ error }}&lt;br/&gt;
                                        {% endfor %}
                                        &lt;/span&gt;
                        {% endif %}
                    &lt;/td&gt;
                {% endif %}
            {% endfor %}
        &lt;/tr&gt;
    {% endfor %}
&lt;/table&gt;

</code></pre>
</div></div>
<p>
Заменим стандартные CheckBox-ы на иконки «крестиков» </p><p>
и будем подкрашивать строку при пометке ее на удаление
</p><div class="spoiler"><b class="spoiler_title">XMLTableWidget - скрипт</b><div class="spoiler_text"><pre><code class="javascript">function xmltable_mark_deleted(p_a, p_checkbox_id) {
    
    var chb = $('#' + p_checkbox_id)
    var row = $(p_a).parents('tr')

    if(chb.prop('checked')) {
        chb.removeProp('checked')
        row.css('background-color', 'white')
    }
    else {
        chb.attr('checked', '1')
        row.css('background-color', '#f2dede')
    }
}
</code></pre>
</div></div>
<p>
Вот, в общем-то и все.</p><p>
Можем теперь использовать это поле и получать сложные таблицы, валидировать их как нужно</p><p>
и не сильно усложнили код системы
</p><p>
Пользователю нужно только подготовить FormSet:
</p><div class="spoiler"><b class="spoiler_title">XMLTableWidget</b><div class="spoiler_text"><pre><code class="python">class NestedTableForm(forms.Form):

    phone_type = forms.ChoiceField(label=u"Тип",
                                   choices=[('', '---'), 
                                            ('1', 'Моб.'), 
                                            ('2', 'Раб.')], 
                                   required=False)
    n_phone = forms.CharField(label=u"Номер", required=False)
    is_primary = forms.BooleanField(label=u"Осн", required=False,
                         widget=forms.CheckboxInput(check_test=boolean_check))

nested_table_formset_class = formset_factory(NestedTableForm, can_delete=True)
</code></pre>
</div></div>
<p>
и получить это поле.
</p><p>
Привожу ссылку на репозиторий с приложением для django, в составе которого можно найти это поле.</p><p>
Можно как подключить приложение, так и скопировать код поля / виджетов / шаблона / скрипта куда угодно.
</p><a href="https://bitbucket.org/dibrovsd/django_forms_custom/src">bitbucket.org/dibrovsd/django_forms_custom/src</a>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>