<html><body><div><div class="post-content section-inner thin">
		    
		    	<p class="mailmunch-forms-before-post"/><p>I was planning my trip to Amsterdam in January and was looking through hostels in <a href="http://www.hostelworld.com/" target="_blank">Hostel World</a> filtering for different features and amenities. One amenity that I thought I would definitely need was free wifi if I wanted to do some programming from the hostel and also just because life demands it in general. While there’s a ton of hostels that offer free wifi, I’ve definitely been at the end of the stick where the quality of wifi has been unmentionably bad. This probably goes for hotels as well as hostels, but generally hostels are cheaper and offer less in the way of complementary services.</p>
<p>That got me thinking about creating an interesting application that could judge the quality of wifi in reviews. Randomly I decided to spin up a new idea for a scraping/api for Hostel World where I could actually find the reviews that mention wifi and other amenities that would be useful. Instead of meticulously scanning through hundreds of reviews, I could just scrape the reviews, parse out keywords, and assign sentiment scores to each review.</p>
<p>Eventually I made it into a Twitter Bot:</p>
<blockquote class="twitter-tweet" lang="en">
<p dir="ltr" lang="en"><a href="https://twitter.com/racketracer">@racketracer</a> Hostel noise: 77.0/100. Positive: 15 Negative: 5 “even with the bar downstairs i never had any noise issues in my room”</p>
<p>— Jay Feng (@HotelReviewsBot) <a href="https://twitter.com/HotelReviewsBot/status/666878546212577280">November 18, 2015</a></p></blockquote>
<p/>
<p>Heh, I am replying to myself. Try it out yourselves! Mention <a href="https://twitter.com/HotelReviewsBot" target="_blank">@HostelReviewBot</a> and link a hostel from Hostelworld and include the word wifi, breakfast, noise, bathroom, or shower.</p>
<p>The positive and negative refers to the number of positive  and negative sentiment reviews respectively. The quote is picked from being an overall average of common words mentioned when scraping the site. Overall there’s too much information that can’t really get stuffed into 140 characters which is quite a sham. I should learn how to create a quick flask api. Maybe that’s for later.</p>
<p>Let’s go through a quick tutorial of some python stuff.</p>
<div>
<pre>amenities <span>=</span> {
<span>'wifi'</span>:      [<span>'wifi'</span>,<span>'internet'</span>,<span>'wi-fi'</span>, <span>'wi fi'</span>, <span>'wireless'</span>],
<span>'breakfast'</span>: [<span>'breakfast'</span>, <span>'breakfest'</span>, <span>'break fast'</span>, <span>'brunch'</span>],
<span>'bathroom'</span>:  [<span>'bathroom'</span>, <span>'bath room'</span>, <span>'bath'</span>, <span>'restroom'</span>, <span>'toilet'</span>, 
<span>              'urinal'</span>, <span>'lavatory'</span>, <span>'washroom'</span>],
<span>'shower'</span>:    [<span>'shower'</span>, <span>'bathe'</span>, <span>'showers'</span>],
<span>'noise'</span>:     [<span>'noise'</span>, <span>'noisy'</span>, <span>'quiet'</span>, <span>'loud'</span>, <span>'silent'</span>]
}
</pre>
</div>
<p>The idea is to first create a list of amenities that we would like to track from each hostel. I can think of five pretty important things that a hostel or a hotel should have that aren’t rated on Hostel World or another review site like Tripadvisor. <em>Amenities</em> is a dictionary of key value stores where the values are chained synonyms that could be used in text to describe our amenities. That way if someone mentions or misspells “wifi” with “wi fi” or “wi-fi” or just another definition like “internet”, we can track their opinion. I welcome any more ideas that could be things to track that right now can be ambiguous or require reading-reviews-effort.</p>
<p><strong>Scraping</strong></p>
<p/>
<div>
<pre><span>import</span> <span>requests</span>
<span>from <span>lxml</span> import</span><span> html</span>

url <span>=</span>  <span>"http://www.hostelworld.com/hosteldetails.php/Black-Swan/Barcelona/66913/reviews/"</span>
amenity <span>=</span>   <span>'wifi'</span>
first_url <span>=</span> url <span>+</span> <span>"1?period=all"</span>
xml <span>=</span>       request_xml(first_url)
pages <span>=</span>     find_end(xml)

<span>def</span> <span>request_xml</span>(url):
    <span>""" Passes in a url and returns the xml of the page """</span>
    response <span>=</span> requests<span>.</span>get(url)
    xml <span>=</span> html<span>.</span>fromstring(response<span>.</span>text)
    <span>return</span> xml

<span>def</span> <span>find_end</span>(<span>self</span>, xml):
    <span>""" Pass in xml and returns the number of pages to scrape.</span>
<span>        Grab first 25 pages which is 500 reviews for relevancy.</span>
<span>    """</span>
    num_reviews <span>=</span> <span>int</span>(xml
<span>        .</span>xpath(<span>"//div/div[@class='results']/text()"</span>)[<span>0</span>]
<span>        .</span>split(<span>' '</span>)[<span>0</span>]<span>.</span>split(<span>'('</span>)[<span>1</span>]) <span>#extract total number of reviews</span>
    <span>if</span> num_reviews <span>/</span> <span>20</span> <span>&gt;</span> <span>25</span>: 
        pages <span>=</span> <span>26</span>
    <span>else</span>:
        pages <span>=</span> num_reviews <span>/</span> <span>20</span>
    <span>return</span> pages</pre>
</div>
<p>I’m using the requests library to grab the html from Hostel World. Here I’ve picked the <a href="http://www.hostelworld.com/hosteldetails.php/Black-Swan/Barcelona/66913/reviews/" target="_blank">Black Swan hostel</a> in Barcelona as an example and taken the url from their reviews site.</p>
<p>lxml is a useful package for taking an html page and transforming it into an xml tree to then use xpath to select elements. By grabbing the total number of reviews from the original base url, we can find out how many pages we need to scrape if the review count is less than 500. Else we can just go from page 1 to 25 because Hostel World lists 20 reviews per page.</p>
<div>
<pre><span>import</span> <span>pandas</span> <span>as</span> <span>pd</span>

<span>def</span> <span>scrape_to_df</span>(base_url, pages):
    <span>"""</span>
<span>    Takes base url and number of pages and returns a dataframe</span>
<span>    with each row representing a review. Columns are: 
    ratings, review, and page number</span>
<span>    """</span>
    df <span>=</span> []
    <span>for</span> i <span>in</span> <span>xrange</span>(<span>1</span>, pages):
        url <span>=</span> base_url <span>+</span> <span>str</span>(i) <span>+</span> <span>"?period=all"</span>
        xml <span>=</span> request_xml(url)
        reviews <span>=</span> xml<span>.</span>xpath(<span>'//div[@class="microreviews rounded"]'</span>)
        <span>for</span> review <span>in</span> reviews:
            df<span>.</span>append({
             <span>'rating'</span>: <span>int</span>(review
<span>                 .</span>xpath(<span>'.//div/text()'</span>)[<span>1</span>]<span>.</span>replace(<span>'%'</span>, <span>''</span>)),
             <span>'review'</span>: <span>''</span><span>.</span>join(review
<span>                 .</span>xpath(<span>'.//div/p/text()'</span>))<span>.</span>strip(),
             <span>'page'</span>: i
            })
    <span>return</span> pd<span>.</span>DataFrame(df) 
</pre>
</div>
<p>Each review comes with a rating from 1-100 that we want to grab so that we can get a rating for each review. We can also use this later to subset the hotel reviews by our specific keyword (in this case “wifi”) and then see what the average rating of those reviews are. Chances are that if there’s a general average of lower reviews when the keyword “wifi” is in the review, the hostel probably doesn’t do well in that amenity. I used pandas to store the data for ease of use.</p><p class="mailmunch-forms-in-post-middle"/>
<p>This should be an example of what the dataframe would look like: (Actually I already subsetted out the non-related reviews)</p>
<div id="attachment_842" class="wp-caption aligncenter"><a href="http://i0.wp.com/www.racketracer.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-16-at-10.07.39-AM.png"><img class="size-full wp-image-842" src="http://i0.wp.com/www.racketracer.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-16-at-10.07.39-AM.png?resize=740%2C352" alt="Excel Screenshot of Dataframe Head. I really need to integrate IPython notebooks" srcset="http://i0.wp.com/www.racketracer.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-16-at-10.07.39-AM.png?resize=300%2C143 300w, http://i0.wp.com/www.racketracer.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-16-at-10.07.39-AM.png?resize=1024%2C487 1024w, http://i0.wp.com/www.racketracer.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-16-at-10.07.39-AM.png?w=1338 1338w" sizes="(max-width: 1338px) 100vw, 1338px" data-recalc-dims="1"/></a><p class="wp-caption-text">Excel Screenshot of the head of the dataframe. I really need to integrate IPython notebooks.</p></div>
<p><strong>Natural Language Processing</strong></p>
<p>There’s a couple different interesting ways we can approach text analysis when looking at reviews. I haven’t read the entire NLTK tutorial guide yet so the only ways I can think of analyzing these reviews would be to use a couple of methods that I might do if I were thinking about doing the whole situation manually.</p>
<ul>
<li><strong>Averaging the subsetted reviews: </strong>As mentioned before, we can subset the reviews by the reviews that mentioned the key word and take their average rating and compare it against the overall average.</li>
<li><strong>N-grams: </strong>Another possibility to find common two word or three word phrases. The problem for the reviews is that there may not be enough reviews to extract these phrases. Also we chained the keyword “wifi” so theoretically we could replace each keyword we find with “wifi” in it to see if there are repeated n-grams, but with maybe 10-20 reviews actually describing the wifi, it might not be enough to be anything significant.</li>
<li><strong>Common words: </strong>An alternative to getting n-grams is to try finding common words  in the reviews. Essentially these would be uni-grams so technically n-grams but we can also filter out the non-important words that don’t really contribute to the conversation when selecting these uni-grams.</li>
<li><strong>Sentiment analysis</strong>: Sentiment analysis is always a bit tricky when done programmatically because it means we then need to curate our tokenization and dictionary with specific keywords for our purpose. If we were to individually read each review that contained “wifi” in it, we could probably get a sense of how each reviewer felt about the wifi. We would then tally up the number of good reviews and bad reviews in our head and get a sense of how we feel about it. But programmatically it’s always harder to just assign sentiment without going into huge amounts of customization for the product at hand. For example, “too gimmicky for them to need a <em>“like”</em> on Facebook to use their wifi”. We understand that as being a small negative, though overall that really doesn’t even describe the wifi as being good quality or not. A machine could interpret that as being a great review though if it sees the keyword “like” and “wifi” in the same sentence and doesn’t understand the process of Facebook “likes” as gimmicked advertisements. In conclusion, I decided using a package called <a href="https://textblob.readthedocs.org/en/dev/">TextBlob</a>, which is a wrapper around NLTK and effectively gives general sentiment scores on sentences and phrases. It’s a pretty good solution for general purpose projects and you don’t have to go into too much manual positive and negative sentiment dictionary searching.</li>
</ul>
<p>Okay, let’s just try extracting the key phrases first. In each review, we have to first find the sentence or phrase where our keyword of “wifi” was mentioned. To do this, we’ll first need to split up the review into chunks of phrases with specific delimiters as commas, periods, etc.. After that, we’ll check if “wifi” exists in in the list of phrases and then if it does we’ll parse it out into it’s own column called “wifi” in the dataframe. I used the apply method here and passed in the function <em>get_key_sentence </em> which checks if the key exists and if it doesn’t just returns null.</p>
<p/>
<div>
<pre><span>import</span> <span>re</span>

<span>def</span> <span>count_amenities</span>(hostel, key):
    <span>""" If key/amenity found in review, apply phrase in key column """</span>
    hostel[key] <span>=</span> hostel<span>.</span>apply(<span>lambda</span> x: 
        get_key_sentence(x[<span>'review'</span>], amenities[key]), axis<span>=</span><span>1</span>)
    <span>return</span> hostel
    
<span>def</span> <span>get_key_sentence</span>(x, key_list):
    <span>"""Passes in a review and a bag of words associated with the key</span>
<span>       Returns a sentence in the review containing one or more of the bag of words</span>
<span>    """</span>
    delimiters <span>=</span> <span>','</span>, <span>'.'</span>, <span>';'</span>, <span>'!'</span>, <span>'?'</span>
    sentences <span>=</span> split(delimiters, x, maxsplit<span>=</span><span>0</span>)
    <span>for</span> sent <span>in</span> sentences: 
        <span>for</span> word <span>in</span> sent<span>.</span>split(): <span>#loop through words in phrase</span>
            <span>if</span> word<span>.</span>lower() <span>in</span> key_list:
                <span>return</span> sent<span>.</span>lower()<span>.</span>strip() <span>#return phrase</span>

<span>def</span> <span>split</span>(delimiters, string, maxsplit<span>=</span><span>0</span>):
    <span>""" Takes in comma separated delimiters and splits paragraph string</span>
<span>        into a list of phrases """</span>
    regexPattern <span>=</span> <span>'|'</span><span>.</span>join(<span>map</span>(re<span>.</span>escape, delimiters))
    <span>return</span> re<span>.</span>split(regexPattern, string, maxsplit)</pre>
</div>
<p>Awesome so now we got a dataframe that we can subset to get just the reviews that contain “wifi” in them and isolate the individual sentences and phrases with wifi in it. Let’s apply TextBlob to each one of the phrases to get numerical sentiments.</p>
<div>
<pre><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>  
<span>from</span> <span>textblob</span> <span>import</span> TextBlob
<span>import</span> <span>nltk</span>
<span>from</span> <span>nltk.util</span> <span>import</span> ngrams
<span>from</span> <span>nltk.collocations</span> <span>import</span> <span>*</span>
<span>from</span> <span>collections</span> <span>import</span> Counter

subset <span>=</span> hostel<span>.</span>dropna() <span>#drop reviews not mentioning key</span>
subset<span>.</span>reset_index(inplace<span>=</span><span>True</span>) 

<span>#Apply sentiment values to each phrase </span>
subset[<span>'sentiment'</span>] <span>=</span> subset[key]<span>.</span>apply(<span>lambda</span> x: 
    TextBlob(x)<span>.</span>sentiment<span>.</span>polarity)</pre>
</div>
<p>Cool so we got sentiment analysis pretty easily. Note that this is probably the hackiest and easiest way to do it when a library wrapper is already packaged around NLTK. It really works for all of us when we are okay with  80% of it being correct and can deal with a possible completely off 20%. The next step is grabbing common uni-gram words.</p>
<p/>
<div>
<pre>word_freq <span>=</span> parse_reviews(subset, key)
d <span>=</span> Counter(word_freq)
phrase_words <span>=</span> [x[<span>0</span>] <span>for</span> x <span>in</span> d<span>.</span>most_common(<span>3</span>)] <span>#find top 3 keywords describing each review</span>

<span>def</span> <span>count_words</span>(word_freq, sent, stopwords, list_key):
    <span>"""Takes in a dictionary, sentence or phrase, stopwords, and bag of words</span>
<span>       and appends counts for word frequencies not in stopwords to find</span>
<span>       the most common words in the reviews</span>
<span>    """</span>
    <span>for</span> word <span>in</span> sent<span>.</span>split():
        <span>if</span> word <span>not</span> <span>in</span> stopwords <span>and</span> word <span>not</span> <span>in</span> list_key:
            <span>if</span> word <span>not</span> <span>in</span> word_freq:
                word_freq[word] <span>=</span> <span>1</span>
            <span>else</span>:
                word_freq[word] <span>+=</span> <span>1</span>
    
<span>def</span> <span>parse_reviews</span>(subset, key):
    <span>""" Takes in a dataframe and key</span>
<span>        Returns a dictionary with the highest frequency words and their counts</span>
<span>        where the key was found in the reviews</span>
<span>    """</span>
    word_freq <span>=</span> {}
    stopwords <span>=</span> nltk<span>.</span>corpus<span>.</span>stopwords<span>.</span>words(<span>'english'</span>)
    <span>for</span> i <span>in</span> <span>xrange</span>(<span>0</span>, <span>len</span>(subset)): <span>#loop through each review</span>
        count_words(word_freq, subset[key][i], stopwords, <span>self</span><span>.</span>amenities[key])    
    <span>return</span> word_freq
</pre>
</div>
<p>Here nltk is grabbing <em>stopwords </em> which are essentially words that should be parsed out that are words like “is, the, i, etc…”. We want to count occurrences for all words besides stopwords and we do that by passing in a dictionary and tallying counts (Note NLTK has it’s own library for this but I didn’t figure it out in time). Since dictionaries are pass by reference in Python, we can pass in the value of <em>word_freq </em> and it’ll update the dictionary without having to return the actual value. Then we’ll implement the collections library which gives us an easy way to grab the top three common words.</p>
<p/>
<div>
<pre>summary <span>=</span> {
   <span>'phrase_words'</span>: d<span>.</span>most_common(<span>3</span>), <span>#dictionary of top 3 common keywords and their counts</span>
   <span>'hotel_avg'</span>: np<span>.</span>mean(hostel[<span>'rating'</span>]), <span>#average rating of the hostel</span>
   <span>'key_avg'</span>:   np<span>.</span>mean(subset[<span>'rating'</span>]), <span>#average rating of reviews specific to key</span>
   <span>'num'</span>:       <span>len</span>(hostel), <span>#number of reviews at hostel</span>
   <span>'mean'</span>:      np<span>.</span>mean(subset[<span>'sentiment'</span>]), <span>#average sentiment of review related to key</span>
   <span>'positive'</span>:  <span>len</span>(subset[subset[<span>'sentiment'</span>] <span>&gt;</span> <span>0</span>]), <span>#number of positive reviews</span>
   <span>'negative'</span>:  <span>len</span>(subset[subset[<span>'sentiment'</span>] <span>&lt;</span> <span>0</span>]), <span>#number of negative reviews</span>
   <span>'zero'</span>:      <span>len</span>(subset[subset[<span>'sentiment'</span>] <span>==</span> <span>0</span>]), <span>#number of zero sentiment reviews</span>
   <span>'max_val'</span>:   {
       <span>'num'</span>: subset<span>.</span>loc[subset[<span>'sentiment'</span>]<span>.</span>idxmax()][<span>'sentiment'</span>], <span>#sentiment rating for best review</span>
       <span>'phrase'</span>: subset<span>.</span>loc[subset[<span>'sentiment'</span>]<span>.</span>idxmax()][key] <span>#text for best review</span>
    },
   <span>'min_val'</span>:   {
       <span>'num'</span>: subset<span>.</span>loc[subset[<span>'sentiment'</span>]<span>.</span>idxmin()][<span>'sentiment'</span>], <span>#sentiment rating for worst reviews</span>
       <span>'phrase'</span>: subset<span>.</span>loc[subset[<span>'sentiment'</span>]<span>.</span>idxmin()][key] <span>#text for worst review</span>
    },
   <span>'common_phrase'</span>: {
       <span>'phrase'</span>: <span>''</span>, 
       <span>'num'</span>: <span>-</span><span>1</span>
    }
}
<span># Find the review with the most number of common words aggregated from all key reviews</span>
<span>for</span> phrase <span>in</span> subset[key]:
    num_words <span>=</span> <span>len</span>([x <span>for</span> word <span>in</span> phrase<span>.</span>split() <span>for</span> x <span>in</span> phrase_words <span>if</span> x <span>in</span> word])
    <span>if</span>  num_words <span>&gt;</span> summary[<span>'common_phrase'</span>][<span>'num'</span>]:
        summary[<span>'common_phrase'</span>] <span>=</span> {
            <span>'phrase'</span>: phrase, 
            <span>'num'</span>: num_words
        }
</pre>
</div>
<p>This humongous dictionary called <em>summary </em> is an object of analysis that spans from the most positive phrase, most negative phrase, positive and negative sentiments, and rating averages. Ultimately it’s hard to store all of the information in a concise way to return it to the twitter bot. Ultimately it should be pretty clear what each averaged metric is doing, but in the end I only used a couple of the metrics as Twitter really only has 140 characters maxed out. For <em>common_phrase </em> I looked took the top three common words from <em>word_freq </em> and looked for the reviews that had the most out of the three.</p>
<div>
<pre>{
<span>'common_phrase':</span> <span>{
    'num':</span>    <span>2,</span>
    <span>'phrase':</span> <span>'free</span> <span>breakfast</span> <span>and</span> <span>sometimes</span> <span>free</span> <span>dinner'</span>}<span>,</span>
 <span>'hotel_avg':</span> 94.708<span>,</span>
 <span>'key_avg':</span>   92.59375<span>,</span>
 <span>'max_val':</span> {
<span>     'num':</span>    <span>0.80000000000000004,</span> 
<span>     'phrase':</span> <span>'breakfast</span> <span>was</span> <span>great'</span>}<span>,</span>
 <span>'mean':</span>       0.24566998106060609<span>,</span>
 <span>'min_val':</span> {  
<span>     'num':</span> <span>-0.27083333333333331,</span>
     <span>'phrase':</span> <span>"breakfast was weak and it's a bit expensive for being not too close to major sights of barce"</span>}<span>,</span>
 <span>'negative':</span> 3<span>,</span>
 <span>'num':</span>      500<span>,</span>
 <span>'phrase_words':</span> [<span>('free'</span>, 17<span>)</span>, <span>('cereal'</span>, 3<span>)</span>, <span>('nice'</span>, 3<span>)</span>]<span>,</span>
 <span>'positive':</span> 22<span>,</span>
 <span>'zero':</span> 7
<span>}</span>
</pre>
</div>
<p>The rest of the <a href="https://github.com/jayfeng1/hostel_reviews_nltk/" target="_blank">code is up on github</a>. I’ll be sure to upload my Twitter API code up as well when it’s totally bug free. There’s a lot of things that can be improved as I hope that I can add in concurrent requests (though not to re-invent scrapy) and add in caching of previous hotels. There’s also a lot to be improved in natural language processing as I’ve just touched the surface with some trivial things. As the knowledge of NLTK grows I am going to want to implement more customized features as there’s a ton of hidden gems in a huge wealth of information like hostel and hotel reviews. The only real problem is laziness.</p>
<p>Please add comments and feedback.</p>
<p>Connect with me on <a href="https://www.linkedin.com/in/jay-feng-ab66b049" target="_blank">LinkedIn</a>, <a href="https://twitter.com/racketracer" target="_blank">Twitter</a>, <a href="mailto:jayofeng@gmail.com?subject=whattup">Email</a></p>
<p class="mailmunch-forms-after-post"/>
<p id="jp-relatedposts" class="jp-relatedposts">
	<h3 class="jp-relatedposts-headline"><em>Related</em></h3>
</p>
		    	<p class="clear"/>
		    	
		    			    
		    </div>
		    
			</div></body></html>