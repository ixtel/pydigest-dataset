<html><body><div><div class="css-entry"> 
                     										
                                
                   

            
				                                                                                                             	      	        			                             <p dir="ltr">When I wrote <a href="https://www.ibm.com/developerworks/community/blogs/jfp/entry/Python_Is_Not_C?lang=en" target="_blank">Python Is Not C</a> 6 months ago I did not imagine that it would be my most popular post ever, with more than 67k views. The conclusion of that post reads:</p>

<p dir="ltr"><em>The lesson is clear: do not write Python code as you would do in C.  Use numpy array operations rather than iterate on arrays.  For me it meant a mental shift.</em></p>

<p dir="ltr">Given Python ecosystem is rapidly evolving, I decided to revisit this conclusion using the performance improvement tools that I discuss in my <a href="https://www.ibm.com/developerworks/community/blogs/jfp/entry/Python_Meets_Julia_Micro_Performance?lang=en" target="_blank">previous post</a>.  </p>

<p dir="ltr">Let me briefly introduce the topic again for those who haven't read<wbr> <a href="https://www.ibm.com/developerworks/community/blogs/jfp/entry/Python_Is_Not_C?lang=en" target="_blank">Pyt<wbr>hon <wbr>Is N<wbr>ot <wbr>C</wbr></wbr></wbr></wbr></a>.  I had to deal with geospatial data as part of a project aiming t<wbr>o<a href="https://www.ibm.com/developerworks/community/blogs/jfp/entry/the_perfect_race?lang=en" target="_blank"> he<wbr>lp a<wbr> cyc<wbr>list<wbr> ath<wbr>let<wbr>e</wbr></wbr></wbr></wbr></wbr></wbr></a> for the <a href="http://www.raceacrossamerica.org/raam/raam2.php?N_webcat_id=1" target="_blank">Race Across America</a> (RAAM) 2015 competition  I was given a gps track with about 25,000 points, and I repeatedly needed to find the closest point on that track given a latitude and a longitude.  Let me focus on this problem from now on.  I will be using two datasets for my experiments:</wbr></wbr></p>

<ol dir="ltr">
	<li><strong>Raam</strong>: track and waypoints from the 2015 RAAM competition.  It has 25,092 track points and 428 waypoints.</li>
	<li><strong>Random</strong>: track and waypoints are uniformly drawn in the North East part of the world: <span>0&lt;= Latitude &lt;= 90</span> and <span>0 &lt;= Longitude &lt;= 180.</span>  It has 25,000 track points and 400 waypoints.</li>
</ol>

<p dir="ltr">These data sets are pretty different in nature.  Here are the way points plotted along latitude and longitude:</p>

<p dir="ltr"><a href="https://www.ibm.com/developerworks/community/blogs/jfp/resource/BLOGS_UPLOADED_IMAGES/nneighbors.png" target="_blank"><img alt="image" src="https://www.ibm.com/developerworks/community/blogs/jfp/resource/BLOGS_UPLOADED_IMAGES/nneighbors.png"/></a></p>

<p dir="ltr"> </p>

<p dir="ltr">All the code used in this blog entry is available in a notebook on <a href="https://gist.github.com/jfpuget/2ab238a18565d9ea9cad">github</a> or <a href="http://nbviewer.jupyter.org/gist/jfpuget/2ab238a18565d9ea9cad/Python_Is_Not_C_Take_Two.ipynb">nbviewer</a>.  Timings were obtained with Anaconda 64 bits and Python 3.5 on a Windows laptop.</p>

<h2 dir="ltr">A Naive Code</h2>

<p dir="ltr">When I first coded that problem, I had little time.  My first reaction had been to look for a code snippet that would compute the distance between two points given their latitudes and longitudes. This is called the <em>great circle distance</em>.  It so happens that John D. Cook made such <a href="http://www.johndcook.com/blog/python_longitude_latitude/" target="_blank" text="undefined">cod<wbr>e<wbr/> av<wbr>a<wbr/>ila<wbr>b<wbr/>le <wbr>i<wbr/>n t<wbr>h<wbr/>e p<wbr>u<wbr/>bli<wbr>c<wbr/> do<wbr>m<wbr/>a<wbr>i<wbr/>n</wbr></wbr></wbr></wbr></wbr></wbr></wbr></wbr></wbr></a>.  Mathematics behind his code can be found <a href="http://www.johndcook.com/lat_long_details.html" target="_blank">here</a><a href="http://www.johndcook.com/lat_long_details.html"><wbr/>.</a></p>

<p dir="ltr">I was all set!  All I needed to do was to write a little Python function that returns the index of the point closest to the input coordinates:</p>

<blockquote dir="ltr">
<pre>
<span class="k">def</span> <span class="nf">clos<wbr>est_<wbr>dist<wbr>anc<wbr>e</wbr></wbr></wbr></wbr></span><span class="p">(</span><span class="n">la<wbr>titu<wbr>d<wbr>e</wbr></wbr></wbr></span><span class="p">,</span><span class="n">lo<wbr>ngit<wbr>ud<wbr>e</wbr></wbr></wbr></span><span class="p">,</span><span class="n">po<wbr>int<wbr>s</wbr></wbr></span><span class="p">)<wbr>:</wbr></span>
    <span class="n">d</span> <span class="o">=</span> <span class="mf">100000.0</span>
    <span class="n">best</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">index</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">latitude_i</span> <span class="o">=</span> <span class="n">poin<wbr>t<wbr>s</wbr></wbr></span><span class="o">.</span><span class="n">i<wbr>x</wbr></span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1"><wbr>'Lat<wbr>itud<wbr>e<wbr>'</wbr></wbr></wbr></wbr></span><span class="p">]</span>
        <span class="n">longitude_i</span> <span class="o">=</span> <span class="n">poin<wbr>t<wbr>s</wbr></wbr></span><span class="o">.</span><span class="n">i<wbr>x</wbr></span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1"><wbr>'Lon<wbr>gitu<wbr>de<wbr>'</wbr></wbr></wbr></wbr></span><span class="p">]</span>
        <span class="n">md</span> <span class="o">=</span> <span class="n">dist<wbr>ance<wbr>_on_<wbr>unit<wbr>_sph<wbr>er<wbr>e</wbr></wbr></wbr></wbr></wbr></wbr></span><span class="p">(</span><span class="n">la<wbr>titu<wbr>d<wbr>e</wbr></wbr></wbr></span><span class="p">,</span> <span class="n">longitude</span><span class="p">,</span> <span class="n">latitude_i</span><span class="p">,</span> <span class="n">longitude_i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">md</span><span class="p">:</span>
            <span class="n">best</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">md</span>
    <span class="k">return</span> <span class="n">best</span><span class="p">,</span><span class="n">d</span></pre>
</blockquote>

<p dir="ltr">where <span>dis<wbr>t<wbr/>anc<wbr>e<wbr/>_on<wbr>_<wbr/>uni<wbr>t<wbr/>_sp<wbr>h<wbr/>e<wbr>r<wbr/>e</wbr></wbr></wbr></wbr></wbr></wbr></span> is John D. Cook's function, and <span>points</span> is a <a href="http://pandas.pydata.org/" target="_blank" text="undefined">pand<wbr/>as d<wbr/>ata <wbr/>fram<wbr/>e </a>containing the coordinates of the track points. </p>

<p dir="ltr">In order to profile it I am now using the following function.  It gets two data frames as input, and computes for each point in the second dataframe the closest point in the first data frame.  It stores the result in the second dataframe.</p>

<blockquote dir="ltr">
<pre>
<span class="k">def</span> <span class="nf">tes<wbr>t</wbr></span><span class="p">(</span><span class="n">tr<wbr>ack_<wbr>poin<wbr>t<wbr>s</wbr></wbr></wbr></wbr></span><span class="p">,</span><span class="n">te<wbr>st_p<wbr>oint<wbr>s</wbr></wbr></wbr></span><span class="p">)<wbr>:</wbr></span>
    <span class="n">test<wbr>_poi<wbr>nt<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'C<wbr>lose<wbr>st_p<wbr>oint<wbr>'</wbr></wbr></wbr></wbr></span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">test<wbr>_poi<wbr>nt<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'C<wbr>lose<wbr>st_d<wbr>ista<wbr>nce<wbr>'</wbr></wbr></wbr></wbr></wbr></span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">rang<wbr>e</wbr></span><span class="p">(</span><span class="nb">le<wbr>n</wbr></span><span class="p">(</span><span class="n">te<wbr>st_p<wbr>oint<wbr>s</wbr></wbr></wbr></span><span class="p">))<wbr>:</wbr></span> 
        <span class="n">latitude_i</span> <span class="o">=</span> <span class="n">test<wbr>_poi<wbr>nt<wbr>s</wbr></wbr></wbr></span><span class="o">.</span><span class="n">i<wbr>x</wbr></span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1"><wbr>'Lat<wbr>itud<wbr>e<wbr>'</wbr></wbr></wbr></wbr></span><span class="p">]</span>
        <span class="n">longitude_i</span> <span class="o">=</span> <span class="n">test<wbr>_poi<wbr>nt<wbr>s</wbr></wbr></wbr></span><span class="o">.</span><span class="n">i<wbr>x</wbr></span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1"><wbr>'Lon<wbr>gitu<wbr>de<wbr>'</wbr></wbr></wbr></wbr></span><span class="p">]</span>
        <span class="n">best</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">clos<wbr>est_<wbr>dist<wbr>anc<wbr>e</wbr></wbr></wbr></wbr></span><span class="p">(</span><span class="n">la<wbr>titu<wbr>de_<wbr>i</wbr></wbr></wbr></span><span class="p">,</span> <span class="n">longitude_i</span><span class="p">,</span> <span class="n">track_points</span><span class="p">)</span>
        <span class="n">test<wbr>_poi<wbr>nt<wbr>s</wbr></wbr></wbr></span><span class="o">.</span><span class="n">i<wbr>x</wbr></span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1"><wbr>'Clo<wbr>sest<wbr>_poi<wbr>nt<wbr>'</wbr></wbr></wbr></wbr></wbr></span><span class="p">]</span> <span class="o">=</span> <span class="n">best</span>
        <span class="n">test<wbr>_poi<wbr>nt<wbr>s</wbr></wbr></wbr></span><span class="o">.</span><span class="n">i<wbr>x</wbr></span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1"><wbr>'Clo<wbr>sest<wbr>_dis<wbr>tanc<wbr>e<wbr>'</wbr></wbr></wbr></wbr></wbr></wbr></span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
    <span class="k">return</span> <span class="n">test_points</span>  </pre>
</blockquote>

<p dir="ltr">This code takes 3 minutes 42 seconds on my laptop for the raam dataset, and 3 minutes 44 seconds with the random dataset.</p>

<h2 dir="ltr">Using Vectorized Operations</h2>

<p dir="ltr">Cutting a long story short, I could slash running time using Numpy vectorized functions.  Here is the resulting function for computing closest distance without explicit Python loops.  It is mimicked after John's D. Cook's function:</p>

<blockquote dir="ltr">
<pre>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span></pre>

<pre>
<span class="k">def</span> <span class="nf">clos<wbr>est_<wbr>dist<wbr>ance<wbr>_pan<wbr>da<wbr>s</wbr></wbr></wbr></wbr></wbr></wbr></span> <span class="p">(</span><span class="n">lat1</span><span class="p">,</span> <span class="n">long1</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
    <span class="n">degrees_to_radians</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span>
    <span class="n">phi1</span> <span class="o">=</span> <span class="p">(</span><span class="mf">90.0</span> <span class="o">-</span> <span class="n">lat<wbr>1</wbr></span><span class="p">)</span><span class="o">*</span><span class="n">d<wbr>egre<wbr>es_t<wbr>o_ra<wbr>dian<wbr>s</wbr></wbr></wbr></wbr></wbr></span>
    <span class="n">phi2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">90.0</span> <span class="o">-</span> <span class="n">poin<wbr>t<wbr>s</wbr></wbr></span><span class="o">.</span><span class="n">La<wbr>titu<wbr>d<wbr>e</wbr></wbr></wbr></span><span class="p">)</span><span class="o">*</span><span class="n">d<wbr>egre<wbr>es_t<wbr>o_ra<wbr>dian<wbr>s</wbr></wbr></wbr></wbr></wbr></span>
    <span class="n">theta1</span> <span class="o">=</span> <span class="n">long<wbr>1</wbr></span><span class="o">*</span><span class="n">de<wbr>gree<wbr>s_to<wbr>_rad<wbr>ian<wbr>s</wbr></wbr></wbr></wbr></wbr></span>
    <span class="n">theta2</span> <span class="o">=</span> <span class="n">poin<wbr>t<wbr>s</wbr></wbr></span><span class="o">.</span><span class="n">Lo<wbr>ngit<wbr>ud<wbr>e</wbr></wbr></wbr></span><span class="o">*</span><span class="n">de<wbr>gree<wbr>s_to<wbr>_rad<wbr>ian<wbr>s</wbr></wbr></wbr></wbr></wbr></span>
    <span class="n">cos</span> <span class="o">=</span> <span class="p">(</span><span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">si<wbr>n</wbr></span><span class="p">(</span><span class="n">ph<wbr>i<wbr>1</wbr></wbr></span><span class="p">)</span><span class="o">*</span><span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">si<wbr>n</wbr></span><span class="p">(</span><span class="n">ph<wbr>i<wbr>2</wbr></wbr></span><span class="p">)</span><span class="o">*</span><span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">co<wbr>s</wbr></span><span class="p">(</span><span class="n">th<wbr>eta<wbr>1</wbr></wbr></span> <span class="o">-</span> <span class="n">theta2</span><span class="p">)</span> <span class="o">+</span>
           <span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">co<wbr>s</wbr></span><span class="p">(</span><span class="n">ph<wbr>i<wbr>1</wbr></wbr></span><span class="p">)</span><span class="o">*</span><span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">co<wbr>s</wbr></span><span class="p">(</span><span class="n">ph<wbr>i<wbr>2</wbr></wbr></span><span class="p">)<wbr>)</wbr></span>
    <span class="n">arc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span> <span class="n">cos</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">arc</span><span class="o">.</span><span class="n">idxmin</span><span class="p">(),</span> <span class="n">arc</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></pre>
</blockquote>

<p dir="ltr">That code runs in 2.3 seconds  with the raam dataset and in 2.17 seconds with the random dataset. </p>

<p dir="ltr">That was the best I could do 6 months ago with the great circle distance.  I was very happy because it is a 100 time speedup compared to the naive code!</p>

<h2 dir="ltr">Using Numpy</h2>

<p dir="ltr">Can we do better now?  We can, by switching to Numpy from Pandas  as recommended on <a href="http://pandas.pydata.org/pandas-docs/stable/enhancingperf.html" target="_blank" text="undefined">Enh<wbr>a<wbr/>nci<wbr>n<wbr/>g P<wbr>e<wbr/>rfo<wbr>r<wbr/>man<wbr>c<wbr/>e</wbr></wbr></wbr></wbr></wbr></a> in pandas documentation.  Instead of passing a data frame via a call like this</p>

<blockquote dir="ltr">
<pre>
<span class="n">best</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">clos<wbr>est_<wbr>dist<wbr>anc<wbr>e</wbr></wbr></wbr></wbr></span><span class="p">(</span><span class="n">la<wbr>titu<wbr>de_<wbr>i</wbr></wbr></wbr></span><span class="p">,</span> <span class="n">longitude_i</span><span class="p">,</span> <span class="n">track_points</span><span class="p">)</span></pre>
</blockquote>

<p dir="ltr">we pass the arrays corresponding to the columns of the data frame:</p>

<blockquote dir="ltr">
<pre>
<span class="n">track_latitudes</span> <span class="o">=</span> <span class="n">trac<wbr>k_po<wbr>int<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'L<wbr>atit<wbr>ude<wbr>'</wbr></wbr></wbr></span><span class="p">]</span><span class="o">.</span><span class="n">v<wbr>alue<wbr>s</wbr></wbr></span>
<span class="n">track_longitudes</span> <span class="o">=</span> <span class="n">trac<wbr>k_po<wbr>int<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'L<wbr>ongi<wbr>tude<wbr>'</wbr></wbr></wbr></span><span class="p">]</span><span class="o">.</span><span class="n">v<wbr>alue<wbr>s</wbr></wbr></span></pre>

<pre>
<span class="n">best</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">clos<wbr>est_<wbr>dist<wbr>ance<wbr>_bro<wbr>adca<wbr>s<wbr>t</wbr></wbr></wbr></wbr></wbr></wbr></wbr></span><span class="p">(</span><span class="n">la<wbr>titu<wbr>de_<wbr>i</wbr></wbr></wbr></span><span class="p">,</span> <span class="n">longitude_i</span><span class="p">,</span> \ 
<span class="n">track_latitudes</span><span class="p">,</span> <span class="n">track_longitudes</span><span class="p">)</span></pre>
</blockquote>

<p dir="ltr">The code of the closest distance function is modified accordingly:</p>

<blockquote dir="ltr">
<pre>
<span class="k">def</span> <span class="nf">clos<wbr>est_<wbr>dist<wbr>ance<wbr>_bro<wbr>adca<wbr>s<wbr>t</wbr></wbr></wbr></wbr></wbr></wbr></wbr></span> <span class="p">(</span><span class="n">lat1</span><span class="p">,</span> <span class="n">long1</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">,</span> <span class="n">longitudes</span><span class="p">):</span>
    <span class="n">degrees_to_radians</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span>
    <span class="n">phi1</span> <span class="o">=</span> <span class="p">(</span><span class="mf">90.0</span> <span class="o">-</span> <span class="n">lat<wbr>1</wbr></span><span class="p">)</span><span class="o">*</span><span class="n">d<wbr>egre<wbr>es_t<wbr>o_ra<wbr>dian<wbr>s</wbr></wbr></wbr></wbr></wbr></span>
    <span class="n">phi2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">90.0</span> <span class="o">-</span> <span class="n">lati<wbr>tude<wbr>s</wbr></wbr></span><span class="p">)</span><span class="o">*</span><span class="n">d<wbr>egre<wbr>es_t<wbr>o_ra<wbr>dian<wbr>s</wbr></wbr></wbr></wbr></wbr></span>
    <span class="n">theta1</span> <span class="o">=</span> <span class="n">long<wbr>1</wbr></span><span class="o">*</span><span class="n">de<wbr>gree<wbr>s_to<wbr>_rad<wbr>ian<wbr>s</wbr></wbr></wbr></wbr></wbr></span>
    <span class="n">theta2</span> <span class="o">=</span> <span class="n">long<wbr>itud<wbr>e<wbr>s</wbr></wbr></wbr></span><span class="o">*</span><span class="n">de<wbr>gree<wbr>s_to<wbr>_rad<wbr>ian<wbr>s</wbr></wbr></wbr></wbr></wbr></span>
    <span class="n">cos</span> <span class="o">=</span> <span class="p">(</span><span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">si<wbr>n</wbr></span><span class="p">(</span><span class="n">ph<wbr>i<wbr>1</wbr></wbr></span><span class="p">)</span><span class="o">*</span><span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">si<wbr>n</wbr></span><span class="p">(</span><span class="n">ph<wbr>i<wbr>2</wbr></wbr></span><span class="p">)</span><span class="o">*</span><span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">co<wbr>s</wbr></span><span class="p">(</span><span class="n">th<wbr>eta<wbr>1</wbr></wbr></span> <span class="o">-</span> <span class="n">theta2</span><span class="p">)</span> <span class="o">+</span>
           <span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">co<wbr>s</wbr></span><span class="p">(</span><span class="n">ph<wbr>i<wbr>1</wbr></wbr></span><span class="p">)</span><span class="o">*</span><span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">co<wbr>s</wbr></span><span class="p">(</span><span class="n">ph<wbr>i<wbr>2</wbr></wbr></span><span class="p">)<wbr>)</wbr></span>
    <span class="n">arc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span> <span class="n">cos</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">arc</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span> <span class="n">arc</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></pre>
</blockquote>

<p dir="ltr">We also rewrite the profiling function as follow:</p>

<blockquote dir="ltr">
<pre>
<span class="k">def</span> <span class="nf">test<wbr>_bro<wbr>adca<wbr>s<wbr>t</wbr></wbr></wbr></wbr></span><span class="p">(</span><span class="n">tr<wbr>ack_<wbr>poin<wbr>t<wbr>s</wbr></wbr></wbr></wbr></span><span class="p">,</span><span class="n">te<wbr>st_p<wbr>oint<wbr>s</wbr></wbr></wbr></span><span class="p">)<wbr>:</wbr></span>
    <span class="n">track_latitudes</span> <span class="o">=</span> <span class="n">trac<wbr>k_po<wbr>int<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'L<wbr>atit<wbr>ude<wbr>'</wbr></wbr></wbr></span><span class="p">]</span><span class="o">.</span><span class="n">v<wbr>alue<wbr>s</wbr></wbr></span>
    <span class="n">track_longitudes</span> <span class="o">=</span> <span class="n">trac<wbr>k_po<wbr>int<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'L<wbr>ongi<wbr>tude<wbr>'</wbr></wbr></wbr></span><span class="p">]</span><span class="o">.</span><span class="n">v<wbr>alue<wbr>s</wbr></wbr></span>

    <span class="n">test_latitudes</span> <span class="o">=</span> <span class="n">test<wbr>_poi<wbr>nt<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'L<wbr>atit<wbr>ude<wbr>'</wbr></wbr></wbr></span><span class="p">]</span><span class="o">.</span><span class="n">v<wbr>alue<wbr>s</wbr></wbr></span>
    <span class="n">test_longitudes</span> <span class="o">=</span> <span class="n">test<wbr>_poi<wbr>nt<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'L<wbr>ongi<wbr>tude<wbr>'</wbr></wbr></wbr></span><span class="p">]</span><span class="o">.</span><span class="n">v<wbr>alue<wbr>s</wbr></wbr></span>
    
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_points</span><span class="p">)</span>
    <span class="n">test_closest_point</span> <span class="o">=</span> <span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">nd<wbr>arra<wbr>y</wbr></wbr></span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n"><wbr>dtyp<wbr>e</wbr></wbr></span><span class="o">=</span><span class="nb">in<wbr>t</wbr></span><span class="p">)</span>
    <span class="n">test<wbr>_clo<wbr>sest<wbr>_dis<wbr>tanc<wbr>e</wbr></wbr></wbr></wbr></wbr></span> <span class="o">=</span> <span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">nd<wbr>arra<wbr>y</wbr></wbr></span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n"><wbr>dtyp<wbr>e</wbr></wbr></span><span class="o">=</span><span class="nb">fl<wbr>oa<wbr>t</wbr></wbr></span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> 
        <span class="n">latitude_i</span> <span class="o">=</span> <span class="n">test_latitudes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">longitude_i</span> <span class="o">=</span> <span class="n">test_longitudes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">best</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">clos<wbr>est_<wbr>dist<wbr>ance<wbr>_bro<wbr>adca<wbr>s<wbr>t</wbr></wbr></wbr></wbr></wbr></wbr></wbr></span><span class="p">(</span><span class="n">la<wbr>titu<wbr>de_<wbr>i</wbr></wbr></wbr></span><span class="p">,</span> <span class="n">longitude_i</span><span class="p">,</span> <span class="n">track_latitudes</span><span class="p">,</span> <span class="n">track_longitudes</span><span class="p">)</span>
        <span class="n">test<wbr>_clo<wbr>sest<wbr>_poi<wbr>n<wbr>t</wbr></wbr></wbr></wbr></wbr></span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">best</span>
        <span class="n">test<wbr>_clo<wbr>sest<wbr>_dis<wbr>tanc<wbr>e</wbr></wbr></wbr></wbr></wbr></span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
     
    <span class="n">test<wbr>_poi<wbr>nt<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'C<wbr>lose<wbr>st_p<wbr>oint<wbr>'</wbr></wbr></wbr></wbr></span><span class="p">]</span> <span class="o">=</span> <span class="n">test_closest_point</span>
    <span class="n">test<wbr>_poi<wbr>nt<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'C<wbr>lose<wbr>st_d<wbr>ista<wbr>nce<wbr>'</wbr></wbr></wbr></wbr></wbr></span><span class="p">]</span> <span class="o">=</span> <span class="n">test<wbr>_clo<wbr>sest<wbr>_dis<wbr>tanc<wbr>e</wbr></wbr></wbr></wbr></wbr></span>
    <span class="k">return</span> <span class="n">test_points</span>  </pre>
</blockquote>

<p dir="ltr">The code now runs in 806 milliseconds with the raam dataset, and 797 milliseconds with the random dataset.  More than  twice as fast!</p>

<p dir="ltr">Can we do better using the tools discussed in my <a href="https://www.ibm.com/developerworks/community/blogs/jfp/entry/Python_Meets_Julia_Micro_Performance?lang=en" target="_blank">previous post</a>? </p>

<p dir="ltr">Using <a href="http://numba.pydata.org/" target="_blank">Numba</a> yields another 25% speedup, with 678 milliseconds with the raam dataset, and 614 milliseconds with the random dataset. </p>

<h2 dir="ltr">An Approximation</h2>

<p dir="ltr">I didn't stop there 6 months ago.  I decided to use an approximation where I replaced the great circle distance with the Manhattan distance (or city block distance).  That approximation was valid on the raam dataset I was using.  It was providing the same closest point as when using the great circle distance.  This approximation isn't valid for points near the pole as latitude and longitude aren't commensurate anymore. </p>

<p dir="ltr">Using array operations, our closest distance function became:</p>

<blockquote dir="ltr">
<pre>
<span class="k">def</span> <span class="nf">clos<wbr>est_<wbr>manh<wbr>atta<wbr>n</wbr></wbr></wbr></wbr></span><span class="p">(</span><span class="n">la<wbr>t</wbr></span><span class="p">,</span><span class="n">lo<wbr>n</wbr></span><span class="p">,</span><span class="n">tr<wbr>kpt<wbr>s</wbr></wbr></span><span class="p">)<wbr>:</wbr></span>
    <span class="n">cl</span> <span class="o">=</span> <span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">ab<wbr>s</wbr></span><span class="p">(</span><span class="n">tr<wbr>kpt<wbr>s</wbr></wbr></span><span class="o">.</span><span class="n">La<wbr>titu<wbr>d<wbr>e</wbr></wbr></wbr></span> <span class="o">-</span> <span class="n">lat</span><span class="p">)</span> <span class="o">+</span> <span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">ab<wbr>s</wbr></span><span class="p">(</span><span class="n">tr<wbr>kpt<wbr>s</wbr></wbr></span><span class="o">.</span><span class="n">Lo<wbr>ngit<wbr>ud<wbr>e</wbr></wbr></wbr></span> <span class="o">-</span> <span class="n">lon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cl</span><span class="o">.</span><span class="n">idxmin</span><span class="p">(),</span> <span class="n">cl</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></pre>
</blockquote>

<p dir="ltr">This code runs in 884 milliseconds with the raam dataset and in 809 milliseconds with the random dataset.  It is about 3 times faster than using the great circle distance.  That was the best I found 6 months ago.</p>

<p dir="ltr">As explained above, we can now speed up this code by using Numpy arrays instead of Pandas.  The code becomes.</p>

<blockquote dir="ltr">
<pre>
<span class="k">def</span> <span class="nf">clos<wbr>est_<wbr>manh<wbr>atta<wbr>n_nu<wbr>mp<wbr>y</wbr></wbr></wbr></wbr></wbr></wbr></span><span class="p">(</span><span class="n">la<wbr>t</wbr></span><span class="p">,</span><span class="n">lo<wbr>n</wbr></span><span class="p">,</span><span class="n">la<wbr>titu<wbr>de<wbr>s</wbr></wbr></wbr></span><span class="p">,</span> <span class="n">longitudes</span><span class="p">):</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">latitudes</span> <span class="o">-</span> <span class="n">lat</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">longitudes</span> <span class="o">-</span> <span class="n">lon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cl</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span> <span class="n">cl</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></pre>
</blockquote>

<p dir="ltr">Using the Numpy profiling function, the code now runs in  76.7 milliseconds with the raam data set and in 52.2 milliseconds with the random dataset.  This is a 10 times speedup! </p>

<h2 dir="ltr">Revisiting The Naive code</h2>

<p dir="ltr">Can we speed up the naive code using the tools I discuss in my <a href="https://www.ibm.com/developerworks/community/blogs/jfp/entry/Python_Meets_Julia_Micro_Performance?lang=en">previous post</a>?</p>

<p dir="ltr">Let's rewrite it using Numpy instead of Pandas, and compile it with Numba:</p>

<blockquote dir="ltr">
<pre>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">clos<wbr>est_<wbr>manh<wbr>atta<wbr>n_nu<wbr>mb<wbr>a</wbr></wbr></wbr></wbr></wbr></wbr></span><span class="p">(</span><span class="n">la<wbr>titu<wbr>d<wbr>e</wbr></wbr></wbr></span><span class="p">,</span><span class="n">lo<wbr>ngit<wbr>ud<wbr>e</wbr></wbr></wbr></span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n"><wbr>poin<wbr>ts_l<wbr>atit<wbr>ud<wbr>e</wbr></wbr></wbr></wbr></wbr></span><span class="p">,</span><span class="n">po<wbr>ints<wbr>_lon<wbr>gitu<wbr>d<wbr>e</wbr></wbr></wbr></wbr></wbr></span><span class="p">)<wbr>:</wbr></span>
    <span class="n">d</span> <span class="o">=</span> <span class="mf">100000.0</span>
    <span class="n">best</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">latitude_i</span> <span class="o">=</span> <span class="n">points_latitude</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">longitude_i</span> <span class="o">=</span> <span class="n">points_longitude</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">md</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">latitude</span> <span class="o">-</span> <span class="n">latitude_i</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">longitude</span> <span class="o">-</span> <span class="n">longitude_i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">md</span><span class="p">:</span>
            <span class="n">best</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">md</span>
    <span class="k">return</span> <span class="n">best</span><span class="p">,</span><span class="n">d</span></pre>
</blockquote>

<p dir="ltr">This code runs in 35.7 milliseconds with the raam dataset and in 30.4 milliseconds with the random dataset.  We are now<em> twice as fast </em>as Numpy vectorized operations!</p>

<p dir="ltr">This is somewhat incredible.  Let me say it again:</p>

<p dir="ltr"><em>Python code compiled with Numba runs twice as fast as Numpy code written directly in C.</em> </p>

<h2 dir="ltr">Using Trees</h2>

<p dir="ltr">Well, there may be faster C code around.  Computing nearest neighbor has received quite a lot of interest since it became a key ingredient in clustering algorithms used in machine learning.  Not surprisingly, the scientific Python stack offers several implementations.  Let's use them on our datasets.  I will specifically use these implementations:</p>



<p dir="ltr">I haven't looked in detail at how these implementation differ.  A general comparison between some of these tree implementations has been performed by Jake Vanderplas, see his excellent  <a href="https://jakevdp.github.io/blog/2013/04/29/benchmarking-nearest-neighbor-searches-in-python/" target="_blank">Benc<wbr>hmar<wbr>king<wbr> Nea<wbr>rest<wbr> Nei<wbr>ghbo<wbr>r Se<wbr>arch<wbr>es i<wbr>n Py<wbr>tho<wbr>n</wbr></wbr></wbr></wbr></wbr></wbr></wbr></wbr></wbr></wbr></wbr></wbr></a>.</p>

<p dir="ltr">Let me evaluate these trees on my datasets. </p>

<p dir="ltr">They have very similar api.  Using them is rather simple.  We first create a tree with the track points:</p>

<blockquote dir="ltr">
<pre>
<span class="kn">import</span> <span class="nn">scipy.spatial</span>
<span class="kn">import</span> <span class="nn">sklearn.neighbors</span>
</pre>

<p> </p>

<pre>
<span class="n">points</span> <span class="o">=</span> <span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">ze<wbr>ro<wbr>s</wbr></wbr></span><span class="p">(<wbr>(</wbr></span><span class="nb">le<wbr>n</wbr></span><span class="p">(</span><span class="n">tr<wbr>ack_<wbr>poin<wbr>t<wbr>s</wbr></wbr></wbr></wbr></span><span class="p">)<wbr>,</wbr></span><span class="mi">2</span><span class="p">)<wbr>)</wbr></span>
<span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">trac<wbr>k_po<wbr>int<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'L<wbr>atit<wbr>ude<wbr>'</wbr></wbr></wbr></span><span class="p">]</span>
<span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">trac<wbr>k_po<wbr>int<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'L<wbr>ongi<wbr>tude<wbr>'</wbr></wbr></wbr></span><span class="p">]</span>
</pre>

<p> </p>

<pre>
<span class="n">t1</span> <span class="o">=</span> <span class="n">scip<wbr>y</wbr></span><span class="o">.</span><span class="n">sp<wbr>atia<wbr>l</wbr></wbr></span><span class="o">.</span><span class="n">cK<wbr>DTre<wbr>e</wbr></wbr></span><span class="p">(</span><span class="n">po<wbr>int<wbr>s</wbr></wbr></span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">scip<wbr>y</wbr></span><span class="o">.</span><span class="n">sp<wbr>atia<wbr>l</wbr></wbr></span><span class="o">.</span><span class="n">KD<wbr>Tre<wbr>e</wbr></wbr></span><span class="p">(</span><span class="n">po<wbr>int<wbr>s</wbr></wbr></span><span class="p">)</span>
<span class="n">t3</span> <span class="o">=</span> <span class="n">skle<wbr>ar<wbr>n</wbr></wbr></span><span class="o">.</span><span class="n">ne<wbr>ighb<wbr>or<wbr>s</wbr></wbr></wbr></span><span class="o">.</span><span class="n">KD<wbr>Tre<wbr>e</wbr></wbr></span><span class="p">(</span><span class="n">po<wbr>int<wbr>s</wbr></wbr></span><span class="p">,</span><span class="n">me<wbr>tri<wbr>c</wbr></wbr></span><span class="o">=</span><span class="s1">'m<wbr>inko<wbr>wski<wbr>'</wbr></wbr></wbr></span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="mi"><wbr>1</wbr></span><span class="p">)</span>
<span class="n">t4</span> <span class="o">=</span> <span class="n">skle<wbr>ar<wbr>n</wbr></wbr></span><span class="o">.</span><span class="n">ne<wbr>ighb<wbr>or<wbr>s</wbr></wbr></wbr></span><span class="o">.</span><span class="n">Ba<wbr>llTr<wbr>e<wbr>e</wbr></wbr></wbr></span><span class="p">(</span><span class="n">po<wbr>int<wbr>s</wbr></wbr></span><span class="p">,</span><span class="n">me<wbr>tri<wbr>c</wbr></wbr></span><span class="o">=</span><span class="s1">'m<wbr>inko<wbr>wski<wbr>'</wbr></wbr></wbr></span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="mi"><wbr>1</wbr></span><span class="p">)</span></pre>
</blockquote>

<p dir="ltr">We must pass the data as one Numpy array that we construct from our dataframe.  Note that for the last two trees we must say that we are not using the default distance (euclidian distance).  We rather use the Manhattan distance, or L1 norm.</p>

<p dir="ltr">Then we query the resulting tree with each point of our test set.  We must also say in the query that we are using the L1 norm.  The profiling function becomes</p>

<blockquote dir="ltr">
<pre>
<span class="k">def</span> <span class="nf">test_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">test_points</span><span class="p">):</span>

    <span class="n">tests</span> <span class="o">=</span> <span class="n">n<wbr>p</wbr></span><span class="o">.</span><span class="n">ze<wbr>ro<wbr>s</wbr></wbr></span><span class="p">(<wbr>(</wbr></span><span class="nb">le<wbr>n</wbr></span><span class="p">(</span><span class="n">te<wbr>st_p<wbr>oint<wbr>s</wbr></wbr></wbr></span><span class="p">)<wbr>,</wbr></span><span class="mi">2</span><span class="p">)<wbr>)</wbr></span>
    <span class="n">tests</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">test<wbr>_poi<wbr>nt<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'L<wbr>atit<wbr>ude<wbr>'</wbr></wbr></wbr></span><span class="p">]</span>
    <span class="n">tests</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">test<wbr>_poi<wbr>nt<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'L<wbr>ongi<wbr>tude<wbr>'</wbr></wbr></wbr></span><span class="p">]</span>

    <span class="n">distances</span><span class="p">,</span> <span class="n">closests</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">tests</span><span class="p">)</span>
    
    <span class="n">test<wbr>_poi<wbr>nt<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'C<wbr>lose<wbr>st_p<wbr>oint<wbr>'</wbr></wbr></wbr></wbr></span><span class="p">]</span> <span class="o">=</span> <span class="n">closests</span>
    <span class="n">test<wbr>_poi<wbr>nt<wbr>s</wbr></wbr></wbr></span><span class="p">[</span><span class="s1">'C<wbr>lose<wbr>st_d<wbr>ista<wbr>nce<wbr>'</wbr></wbr></wbr></wbr></wbr></span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span>
    <span class="k">return</span> <span class="n">test_points</span>  </pre>
</blockquote>

<p dir="ltr">Note that the query function accepts an array of point coordinates in a single call.</p>

<p dir="ltr">We run each tree implementation on both datasets. </p>

<h2 dir="ltr">Wrapping Up</h2>

<p dir="ltr">The table below summarizes the running times we get in milliseconds.  The construction time is significantly higher in the raam case for three of them.  The query time is also significantly higher for one tree implementation.</p>

<p dir="ltr">The table also includes our code  for comparison.  We see that the running times are quite similar between the two datasets for the code I wrote.  Note that these times are for computing the nearest neighbor for each of the way points.  Average time for one way point is about 1/400 of the reported time.</p>

<p dir="ltr"> </p>

<table border="1" dir="ltr">
	<tbody>
		<tr>
			<td colspan="2" rowspan="2">Running times in milliseconds</td>
			<td colspan="2" rowspan="1">Query</td>
			<td colspan="2" rowspan="1">Tree creation</td>
		</tr>
		<tr>
			<td>Raam</td>
			<td>Random</td>
			<td>Raam</td>
			<td>Random</td>
		</tr>
		<tr>
			<td colspan="1" rowspan="3">Great Circle<br/>
			Distance</td>
			<td>Naive 6 months ago</td>
			<td>222,000</td>
			<td>224,000</td>
			<td colspan="2" rowspan="6"> Not Applicable</td>
		</tr>
		<tr>
			<td>Vectorized 6 months ago</td>
			<td>2,300</td>
			<td>2,170</td>
		</tr>
		<tr>
			<td>Vectorized with Numpy instead of Pandas</td>
			<td>678</td>
			<td>614</td>
		</tr>
		<tr>
			<td colspan="1" rowspan="7">Manhattan<br/>
			Distance</td>
			<td>Vectorized 6 months ago</td>
			<td>884</td>
			<td>809</td>
		</tr>
		<tr>
			<td>Vectorized + Numpy instead of Pandas</td>
			<td>76.7</td>
			<td>52.2</td>
		</tr>
		<tr>
			<td>Naive + Numpy<br/>
			+ Numba</td>
			<td>35.7</td>
			<td>30.4</td>
		</tr>
		<tr>
			<td>Scipy cKDTree</td>
			<td>0.76</td>
			<td>0.8</td>
			<td>802</td>
			<td>10.9</td>
		</tr>
		<tr>
			<td>Scipy KDTree</td>
			<td>111</td>
			<td>87.7</td>
			<td>205</td>
			<td>136</td>
		</tr>
		<tr>
			<td>Sklearn KDTree</td>
			<td>1.02</td>
			<td>1.1</td>
			<td>967</td>
			<td>11</td>
		</tr>
		<tr>
			<td>SKlearn BallTree</td>
			<td>1.29</td>
			<td>1.9</td>
			<td>971</td>
			<td>10.4</td>
		</tr>
	</tbody>
</table>

<p dir="ltr"> </p>

<p dir="ltr">When it is compiled with Numba, our native Manhattan distance code using loops over Numpy arrays is about 7,000 times faster than the code we started with 6 months ago.  This is awesome, but there is something even more impressive: it is also competitive with the tree implementations.  Indeed, these have a short query time, but the time to construct the tree largely offsets it.  In particular, our code is way faster overall for the raam dataset.</p>

<p dir="ltr">I think it is still safe to say that Python is not C, but we can also say that Numba makes it close.  This is true both in term of running times and in coding style. </p>

<p dir="ltr">Note that the above comparison may not be representative of the performance of the code with other data sets.  Performance of trees can vary with dataset size and parameter settings as documented in <a href="https://jakevdp.github.io/blog/2013/04/29/benchmarking-nearest-neighbor-searches-in-python/" target="_blank">Benc<wbr>hmar<wbr>king<wbr> Nea<wbr>rest<wbr> Nei<wbr>ghbo<wbr>r Se<wbr>arch<wbr>es i<wbr>n Py<wbr>tho<wbr>n</wbr></wbr></wbr></wbr></wbr></wbr></wbr></wbr></wbr></wbr></wbr></wbr></a>.  I haven't tried to tune parameters.   Maybe someone can get better running times with trees than me.</p>

<p dir="ltr"> </p>

<p dir="ltr"><strong>Update on December 16, 2015.</strong>  I was contacted by  Serge Guelton, one of the developer of <a href="https://pythonhosted.org/pythran/MANUAL.html">Pythran</a>, a Python compiler.  I'll blog about it soon as it yields additional speedups.  I also have repeated comments in my Python related performance posts asking why I am not using <a href="http://pypy.org/">Pypy</a>. I didn't use Pypy so far because it  only supports part of Numpy, and not Pandas, Scipy, and Sklearn.  It may be that Pypy supports enough of Numpy to run my closest distance code though.  If that's the case, then I'll blog about it soon.</p>

<p dir="ltr"> </p>

<p dir="ltr"><strong>Update on February 9, 2016.</strong>  Updated times with Python 3.5.  Improved the code for built-in trees benchmark.  Added a link to the notebook on <a href="https://gist.github.com/jfpuget/2ab238a18565d9ea9cad">github</a> and <a href="http://nbviewer.jupyter.org/gist/jfpuget/2ab238a18565d9ea9cad/Python_Is_Not_C_Take_Two.ipynb">nbviewer</a>.</p>           
                                	              		            			
			   <span class="min-tags" role="list">
				Tags:&amp;nbsp
			       			        <span role="listitem">
					<a href="https://www.ibm.com/developerworks/community/blogs/jfp?tags=numba&amp;lang=en" title="numba">numba</a>
				</span>
							        <span role="listitem">
					<a href="https://www.ibm.com/developerworks/community/blogs/jfp?tags=python&amp;lang=en" title="python">python</a>
				</span>
							        <span role="listitem">
					<a href="https://www.ibm.com/developerworks/community/blogs/jfp?tags=numpy&amp;lang=en" title="numpy">numpy</a>
				</span>
							        <span role="listitem">
					<a href="https://www.ibm.com/developerworks/community/blogs/jfp?tags=nearest_neighbors&amp;lang=en" title="nearest_neighbors">nearest_neighbors</a>
				</span>
							        <span role="listitem">
					<a href="https://www.ibm.com/developerworks/community/blogs/jfp?tags=scipy&amp;lang=en" title="scipy">scipy</a>
				</span>
							        <span role="listitem">
					<a href="https://www.ibm.com/developerworks/community/blogs/jfp?tags=sklearn&amp;lang=en" title="sklearn">sklearn</a>
				</span>
							  </span>
			                     <p/>

                    
                                                                  
                                                   
           <p/>
           
	        </div>
 		</div></body></html>