<html><body><div><div class="field-item even" property="content:encoded"><p>There is a <a href="http://www.hackersdelight.org/">"A Hacker's Assistant" program (<i>Aha!</i>)</a> written by Henry Warren, who is also the author of the great "Hacker's Delight" book.<br/>
The <i>Aha!</i> program is essentially <a href="http://en.wikipedia.org/wiki/Superoptimization">superoptimizer</a>, which blindly brute-force a list of some generic RISC CPU instructions to achieve shortest possible (and jumpless or branch-free) CPU code sequence for desired operation.<br/>
One of the impressive examples of its work is finding of <a href="http://aggregate.org/MAGIC/#Average%20of%20Integers">Dietz's formula</a>, which is the code of computing average number of two numbers without overflow (which is important if you want to find average number of numbers like 0xFFFFFF00 and so on, using 32-bit registers).<br/>
Taking this in input:</p>
<pre>
int userfun(int x, int y) {     // To find Dietz's formula for
                                // the floor-average of two
                                // unsigned integers.
   return ((unsigned long long)x + (unsigned long long)y) &gt;&gt; 1;
}
</pre><p>
... the <i>Aha!</i> gives this:</p>
<pre>
Found a 4-operation program:
   and   r1,ry,rx
   xor   r2,ry,rx
   shrs  r3,r2,1
   add   r4,r3,r1
   Expr: (((y ^ x) &gt;&gt;s 1) + (y &amp; x))
</pre><p>
And it works correctly.</p>
<p><i>Aha!</i> can also find jumpless version of abs() function easily.</p>
<p>Compiler developers use superoptimization to find shortest possible (and/or jumpless) code, but I tried to do otherwise -- to find longest code for some basic operation.<br/>
I tried <i>Aha!</i> to find equivalent of basic XOR operation without usage of the actual XOR instruction, and the most bizarre example <i>Aha!</i> gave is:</p>
<pre>
Found a 4-operation program:
   add   r1,ry,rx
   and   r2,ry,rx
   mul   r3,r2,-2
   add   r4,r3,r1
   Expr: (((y &amp; x)*-2) + (y + x))
</pre><p>
Beat me to death, but I can't understand how it works. But it works.<br/>
And it's hard to say, why/where we can use it, maybe for obfuscation, I'm not sure.<br/>
I would call this <i>suboptimization</i> (as opposed to <i>superoptimization</i>). Or maybe <i>superdeoptimization</i>.</p>
<p>But my another question was also, is it possible to prove that this is correct formula at all?<br/>
The <i>Aha!</i> checking some intput/output values against XOR operation, but of course, not all the possible values.<br/>
It is 32-bit code, so it may take very long time to try all possible 32-bit inputs to test it.</p>
<p>We can try <a href="http://research.microsoft.com/en-us/um/redmond/projects/z3/">Z3 theorem prover</a> for the job. It's called <i>prover</i>, after all.</p>
<p>So I wrote this:</p>
<pre>
#!/usr/bin/python
from z3 import *

x = BitVec('x', 32)
y = BitVec('y', 32)
output = BitVec('output', 32)
s = Solver()
s.add(x^y==output)
s.add(((y &amp; x)*0xFFFFFFFE) + (y + x)!=output)
print s.check()
</pre><p>
In plain English language, this means "are there any case for x and y where x^y doesn't equals to ((y &amp; x)*-2) + (y + x)?"<br/>
... and Z3 prints "unsat", meaning, it can't find any counterexample to the equation.<br/>
So this <i>Aha!</i> output is proved to be working just like XOR operation.</p>
<p>Oh, I also tried to extend the formula to 64-bit:</p>
<pre>
#!/usr/bin/python
from z3 import *

x = BitVec('x', 64)
y = BitVec('y', 64)
output = BitVec('output', 64)
s = Solver()
s.add(x^y==output)
s.add(((y &amp; x)*0xFFFFFFFE) + (y + x)!=output)
print s.check()
</pre><p>
Nope, now it says "sat", meaning, Z3 found at least one counterexample.<br/>
Oops, it's because I forgot to extend -2 number to 64-bit value:</p>
<pre>
#!/usr/bin/python
from z3 import *

x = BitVec('x', 64)
y = BitVec('y', 64)
output = BitVec('output', 64)
s = Solver()
s.add(x^y==output)
s.add(((y &amp; x)*0xFFFFFFFFFFFFFFFE) + (y + x)!=output)
print s.check()
</pre><p>
Now it says "unsat", so the formula given by <i>Aha!</i> works for 64-bit code as well.</p>
<p>See also my another article about Z3: <a href="http://yurichev.com/writings/z3_rockey.pdf">Finding unknown algorithm using only input/output pairs and Z3 SMT solver</a> and also <a href="http://dennisyurichev.blogspot.nl/2013/05/in-england-currency-is-made-up-of-pound.html">Solving Problem Euler 31 - "Coin sums" using Z3 SMT-solver</a>.</p>
<p>Interesting in articles like this? Subscribe to my twitter: <a href="https://twitter.com/yurichev">@yurichev</a>.</p>
<p>Update: <a href="https://twitter.com/sevenps/status/590017518900744192">"It works because x+y = (x^y) + 2*(x&amp;y) (related to Dietz's formula). Ergo x^y = x + y - 2*(x&amp;y)." (@sevenps)</a></p>
<p>Update2: some of discussions:<br/><a href="http://www.reddit.com/r/programming/comments/33830f/using_z3_theorem_prover_to_prove_equivalence_of/">http://www.reddit.com/r/programming/comments/33830f/using_z3_theorem_pro...</a><br/><a href="http://www.reddit.com/r/ReverseEngineering/comments/33815w/using_z3_theorem_prover_to_prove_equivalence_of/">http://www.reddit.com/r/ReverseEngineering/comments/33815w/using_z3_theo...</a><br/><a href="http://www.reddit.com/r/Python/comments/3384bt/using_z3_theorem_prover_to_prove_equivalence_of/">http://www.reddit.com/r/Python/comments/3384bt/using_z3_theorem_prover_t...</a><br/><a href="https://news.ycombinator.com/item?id=9407366">https://news.ycombinator.com/item?id=9407366</a><br/><a href="http://vk.com/wall-30666517_1127706">http://vk.com/wall-30666517_1127706</a> (Russian social networking site)</p>
</div></div></body></html>