<html><body><div><div class="content html_format"><p>
      В этой статье мы соберём вместе aiorest + jinja2 + angular.js + gulp.js + bower.js + nginx. В результате мы получим: </p><ul>
<li>авто-перезапуск сервера при изменении python-кода и jinja-шаблонов</li>
<li>сборка, минификация и автоматическая пересборка при изменении клиентского js-кода</li>
</ul><p>  Начнём с главного — как пользоваться, а затем я подробнее опишу некоторые моменты реализации. Если вам легче читать код — вот ссылка на </p><a href="https://github.com/imbolc/aiorest-angular-template">репу</a><p>. 

</p><a name="habracut"/> <h3>Установка</h3>
 <pre><code class="python">$ git clone git@github.com:imbolc/aiorest-angular-template.git 
$ cd aiorest-angular-template 
$ sudo npm install -g gulp bower 
$ npm install 
$ bower install 
$ ./bin/buildenv.py 
$ sudo ./bin/configure_nginx.py 
</code></pre><p>
 Добавляем в </p><code>/etc/hosts</code><p>: 

  </p><pre><code class="python">127.0.1.1   aio-angular.l.com 
</code></pre><p>
 И запускаем сервер разработчика: 

  </p><pre><code class="python">$ gulp 
</code></pre><p>
 Готово, теперь можно открывать в браузере: </p><a href="http://aio-angular.l.com/">http://aio-angular.l.com/</a> 

  <h3>Использование</h3><p>
  Просто добавляйте обработчики в </p><code>handlers.py</code><p>, урлы — в </p><code>urls.py</code><p>, а клиентский код раскладывайте в папке </p><code>client</code><p> в удобной для вас структуре. 

  </p><h3>Конфигурация</h3>
  <a href="https://github.com/aio-libs/aiorest">aiorest</a><p> не умеет ничего, кроме как отдавать json, поэтому, для отдачи статики мы будем использовать nginx, шаблон его конфига как и другие настройки находится в папке </p><code>cfg</code><p>. Там же находится файлик с питон-зависимостями </p><code>pipreq.txt</code><p> и конфиг для питон-части приложения </p><code>__init__.py</code><p> + </p><code>local.py</code><p> (последний в джанга-стайл перезаписывает специфичную для текущего сервера конфигурацию первого). 
</p><p>
   Хранить конфигурацию лучше в одном месте, поэтому клиентский конфиг мы так же генерируем на сервере, а потом подсовываем ангуляру в виде </p><code>value</code><p> (</p><code>templates/client_config.js</code><p>): 

  </p><pre><code class="python">angular.module('app').value('cfg', &lt;&lt; config|tojson|safe &gt;&gt;); 
</code></pre>
<h3>Сборка js</h3><p>
  Мы будем пользоваться мудростью этой статьи, которую я всячески рекомендую к прочтению: </p><a href="http://modernweb.com/2014/07/28/best-practices-building-angular-js-apps/">Real-World Best Practices for Building Angular.js Apps without Browserify or Require.js</a><p>. Вкратце: require.js для ангуляра не подходит, browserify — подходит, но нам не нужна большая часть его функционала потому, что в ангуляре уже есть модули. 
</p><p>
   Итак, будем использовать </p><a href="http://gulpjs.com/">gulp.js</a><p> — современную замену grunt.js, он не использует промежуточных файлов, имеет более приятный синтаксис описания задач и уже аналогичную кучу готовых плагинов. Смотрим в </p><code>gulpfile.js</code><p>: 

  </p><pre><code class="python">gulp.task('js', function () { 
    gulp.src(['client/app.js', 'client/**/*.js']) 
    .pipe(plumber()) 
    .pipe(sourcemaps.init()) 
    .pipe(concat('app.js')) 
    .pipe(ngAnnotate()) 
    .pipe(uglify()) 
    .pipe(sourcemaps.write()) 
    .pipe(gulp.dest('./static/build')); 
}); 
</code></pre>
<ul>
<li><code>sourcemaps.init</code> + <code>sourcemaps.write</code> добавляют в сборку <a href="https://docs.google.com/a/imbolc.name/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit">source map</a> который позволяет в консоли браузера видеть ошибки и лог-сообщения с нумерацией строк исходных файлов</li>
<li><code>concat</code> — копирует все файлы в один</li>
<li><code>ngAnnotate</code> — нельзя просто так взять и минифицировать ангуляр-код: <a href="https://docs.angularjs.org/guide/di">Dependency Annotation</a></li>
<li><code>uglify</code> — минификация</li>
<li><code>plumber</code> — перехватывает ошибки в ходе всего этого, чем не даёт падать авто-персборке</li>
</ul> 

<h3>Авто-перезапуск сервера</h3>
 <pre><code class="python">gulp.task('dev_server', shell.task([ 
    ('nodemon ./app.py --exec "var/env/bin/python"' + 
    ' --ext "py html" --ignore "static"') 
])); 
</code></pre><p>
 Дада, </p><a href="http://nodemon.io/">nodemon</a><p> умеет перезапускать не только node.js :) 

  </p><h3>Серверный код</h3><p>
  Приложение начинается в </p><code>app.py</code><p>: 

  </p><pre><code class="python">import asyncio 
import aiorest 
 
import cfg 
import lib.logging 
import prepare_static 
import urls 
 
 
lib.logging.setup(cfg.LOG_FILE) 
prepare_static.client_config(urls=urls.CLIENT_URLS) 
prepare_static.render_html('index.html') 
 
 
server = aiorest.RESTServer(hostname='127.0.0.1') 
for url in urls.SERVER_URLS: 
    server.add_url(*url) 
 
 
loop = asyncio.get_event_loop() 
loop.run_until_complete(loop.create_server( 
    server.make_handler, '127.0.0.1', cfg.PORT)) 
try: 
    loop.run_forever() 
except KeyboardInterrupt: 
    pass 
</code></pre><p>
 Здесь мы настраиваем логирование, подготавливаем клиентский конфиг описанный выше. Затем рендерим пока единственный шаблон т.к. в нём есть некоторая логика: 

  </p><pre><code class="python">&lt;% if cfg.DEBUG %&gt; 
    &lt;script src="/static/bower/angular/angular.js"&gt;&lt;/script&gt; 
    &lt;script src="/static/bower/angular-resource/angular-resource.js"&gt;&lt;/script&gt; 
&lt;% else %&gt; 
    &lt;script src="//ajax.googleapis.com/ajax/libs/angularjs/1.3.0-beta.14/angular.min.js"&gt;&lt;/script&gt; 
    &lt;script src="//ajax.googleapis.com/ajax/libs/angularjs/1.3.0-beta.14/angular-resource.min.js"&gt;&lt;/script&gt; 
&lt;% endif %&gt; 
</code></pre><p>
 И да, мы переопределили обозначения управляющих конструкций в jinja2 (</p><code>{{ }}</code><p> =&gt; </p><code>&lt;&lt; &gt;&gt;</code><p>, </p><code>{% %}</code><p> =&gt; </p><code>&lt;% %&gt;</code><p>), т.к. ангуляр использует такие же. 
</p><p>
   Далее мы создаём aiorest-сервер, добавляем урлы из файлика </p><code>urls.py</code><p>: 

  </p><pre><code class="python">import handlers 
 
 
SERVER_URLS = [ 
    ('GET', '/hello',        handlers.hello), 
    ('GET', '/hello/{name}', handlers.hello), 
] 
 
CLIENT_URLS = { 
    'hello': '/api/hello/:name', 
} 
</code></pre>
 <code>CLIENT_URLS</code><p> — это аякс урлы которые мы будем использовать в браузерном кодe. А хендлеры для серверных урлов находятся в файлике </p><code>handlers.py</code><p>: 

  </p><pre><code class="python">def hello(request):
    name = request.matchdict.get('name', 'world')
    message = 'Hello, {}!'.format(name)
    return {'message': message}
</code></pre>
<h3>Angular-код</h3><p>
  Описывать hello world на ангуляре пожалуй не буду :) Единственное, обращу внимание на использование клиентского конфига, который мы готовили выше (</p><code>client/hello/hello.svc.js</code><p>): 

  </p><pre><code class="python">angular.module('app') 
    .service('HelloSvc', function ($resource, cfg) { 
        this.fetchGreeting = function () { 
            return $resource(cfg.urls.hello).get.apply(this, arguments); 
        }; 
    }); 
</code></pre>


      
      <p class="clear"/>
    </div>

    
  </div></body></html>