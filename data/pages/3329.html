<html><body><div><div class="content html_format"><p>
      Продолжение перевода неофициальной документации Selenium для Python.</p><p>
Перевод сделан с разрешения автора Baiju Muthukadan.</p><p>
Оригинал можно найти </p><a href="http://selenium-python.readthedocs.org/index.html">здесь</a><p>.

</p><h2>Содержание:</h2><p>
1. </p><a href="http://habrahabr.ru/post/248559/">Установка</a><p>
2. </p><a href="http://habrahabr.ru/post/250921/">Первые Шаги</a><p>
3. Навигация</p><p>
4. </p><a href="http://habrahabr.ru/post/250975/">Поиск Элементов</a><p>
5. Ожидания</p><p>
6. Объекты Страницы</p><p>
7. WebDriver API</p><p>
8. Приложение: Часто Задаваемые Вопросы
</p><a name="habracut"/>
<h1>3. Навигация</h1><p>
Предположительно, первое, что вы захотите сделать с помощью WebDriver, будет переход по ссылке. Обычно для таких целей используют метод get:

</p><pre><code class="python">driver.get("http://www.google.com")
</code></pre><p>
Метод driver.get перенаправляет к странице URL, поданной в параметре. WebDriver будет ждать пока страница не загрузится полностью (то есть, событие “onload” игнорируется), прежде чем передать контроль вашему тесту или скрипту. Стоит отметить, что если страница использует много AJAX-кода при загрузке, то WebDriver может не распознать, загрузилась ли она полностью. Если необходимо гарантировать полную загрузку страниц, вы можете использовать ожидания (англ. waits).

</p><h2>3.1. Взаимодействие со страницей</h2><p>
Сама по себе возможность переходить по ссылке не так уж полезна. Что действительно хочется сделать, так это взаимодействовать со страницей, или, если быть точным, с элементами HTML на странице. Прежде всего необходимо найти их. WebDriver предоставляет ряд способов для поиска элементов. К примеру, на странице есть элемент, определенный таким образом:

</p><pre><code class="html">&lt;input type="text" name="passwd" id="passwd-id" /&gt;
</code></pre><p>
Его можно найти, используя любой из следующих методов:

</p><pre><code class="python">element = driver.find_element_by_id("passwd-id")
element = driver.find_element_by_name("passwd")
element = driver.find_element_by_xpath("//input[@id='passwd-id']")
</code></pre><p>
Также вы можете искать адрес гиперссылки по тексту гиперссылки, но будьте бдительны: текст должен совпадать в точности. Также будьте внимательны при использовании XPATH в WebDriver. Если существует больше одного элемента, удовлетворяющего условиям запроса, вернется только первый найденный. Если ничего не будет найдено, будет возбуждено исключение NoSuchElementException.
</p><p>
WebDriver имеет “Объекто-ориентированное” API [Интерфейс прикладного программирования (c англ. application programming interface) — набор готовых методов и свойств, предоставляемых приложением (библиотекой, сервисом) для использования во внешних программных продуктах. API позволяет пользоваться функционалом исходного приложения (библиотеки, сервиса), не вникая в тонкости реализации этого функционала. — Прим. пер.]; мы представляем все типы элементов используя один и тот же интерфейс. Это означает, что хоть вы и видите множество доступных методов, которые можно выбрать при нажатии комбинации клавиш автозаполнения в вашем IDE [Интегрированная среда разработки (англ. Integrated Development Environment) — система программных средств, используемая программистами для разработки программного обеспечения. — Прим. пер.], не все из них будут иметь для вас смысл или не все будут действующими. Не беспокойтесь! WebDriver попытается все исправить, так что если вы вызовете метод, используя его неправильно (например, используете “setSelected()” для “мета” тэга [Мета-теги (англ. meta tags) — HTML-теги, предназначенные для предоставления структурированных метаданных о веб-странице. Как правило, указываются в заголовке HTML-документа. — Прим. пер.]), WebDriver возбудит исключение.
</p><p>
Итак, мы получили элемент. Что вы можете с ним сделать? Первым делом вы захотите ввести какой-нибудь текст в текстовое поле:

</p><pre><code class="python">element.send_keys("some text")
</code></pre><p>
Также вы можете имитировать нажатие клавиш-стрелок клавиатуры с помощью класса “Keys”:

</p><pre><code class="python">element.send_keys(" and some", Keys.ARROW_DOWN)
</code></pre><p>
Метод send_keys можно вызвать для любого элемента, который позволяет проверить сочетания клавиш, такие как те, что используются в GMail. Существует побочный эффект, заключающийся в том, что ввод в текстовое поле не очищает его автоматически. Вместо этого то, что вы набираете на клавиатуре, будет дописываться к уже вписанному в поле. Очистить содержимое тектового поля или текстовой области textarea легко — с помощью метода clear:

</p><pre><code class="python">element.clear()
</code></pre>
<h2>3.2. Заполнение форм</h2><p>
Мы уже рассмотрели ввод текста в текстовую область или текстовое поле, а как быть с другими элементами? Вы можете попробовать раскрыть раскрывающийся список, после чего можно использовать “setSelected” для выделения тэгов вроде OPTION. Работать с тэгами SELECT не так уж сложно:

</p><pre><code class="python">element = driver.find_element_by_xpath("//select[@name='name']")
all_options = element.find_elements_by_tag_name("option")
for option in all_options:
    print("Value is: %s" % option.get_attribute("value"))
    option.click()
</code></pre><p>
Такой код найдет первый элемент “SELECT” на странице, и в цикле пройдет по всем тэгам OPTION поочередно, сообщая их значения и поочередно выделяя их.
</p><p>
Как можно заметить, это не самый быстрый способ работы с элементами SELECT. Поддерживаемые вебдрайвером классы содержат один, называющийся “Select”, он предоставляет более удобные способы взаимодействия:

</p><pre><code class="python">from selenium.webdriver.support.ui import Select
select = Select(driver.find_element_by_name('name'))
select.select_by_index(index)
select.select_by_visible_text("text")
select.select_by_value(value)
</code></pre><p>
Также WebDriver предоставляет возможность снятия выделения со всех элементов выпадающего списка:

</p><pre><code class="python">select = Select(driver.find_element_by_id('id'))
select.deselect_all()
</code></pre><p>
Этот код снимает выделение со всех тегов OPTION первого тега SELECT на странице.
</p><p>
Допустим, для теста вам необходим список всех выделенных по умолчанию опций. Класс Select предоставляет такое свойство (возвращает список):

</p><pre><code class="python">select = Select(driver.find_element_by_xpath("xpath"))
all_selected_options = select.all_selected_options
</code></pre><p>
Для получения всех доступных опций используйте:

</p><pre><code class="python">options = select.options
</code></pre><p>
После того как с заполнением формы будет покончено, вы, вероятно, захотите “сохранить” изменения [submit — отправить, передать, подтвердить — Прим. пер.]. Одним из способов сделать это — найти кнопку “submit” и кликнуть по ней:

</p><pre><code class="python"># Предположим, ID кнопки равен "submit" :)
driver.find_element_by_id("submit").click()
</code></pre><p>
В качестве альтернативы первому методу можно использовать метод “submit”, доступный для каждого элемента. Если вызвать его для элемента внутри формы, WebDriver пробежится по всей структуре DOM, пока не найдет закрывающийся тег формы, и затем вызовет для нее submit. Если элемент находится не в форме, тогда возбудится исключение NoSuchElementException:

</p><pre><code class="python">element.submit()
</code></pre>
<h2>3.3. Перетаскивание</h2><p>
Есть два варианта «перетаскивания» элементов: перемещение элемента на определенную величину, либо перетаскивание его на другой элемент:

</p><pre><code class="python">element = driver.find_element_by_name("source")
target = driver.find_element_by_name("target")

from selenium.webdriver import ActionChains
action_chains = ActionChains(driver)
action_chains.drag_and_drop(element, target)
</code></pre>
<h2>3.4. Переключение между окнами и фрэймами</h2><p>
Современные веб-приложения редко обходятся без фреймов (frame) и редко когда ограничиваются одним окном. WebDriver поддерживает переключение между именованными окнами с помощью метода “switch_to_window”:

</p><pre><code class="python">driver.switch_to_window("windowName")
</code></pre><p>
Все вызовы, начинающиеся с driver теперь будут истолкованы как обращенные к полученному окну. Но откуда вам знать имя окна? Взгляните на код javascript или ссылку, которые открывают окно:

</p><pre><code class="html">&lt;a href="кое_где.html" target="имяОкна"&gt;Нажмите сюда, чтобы открыть новое окно&lt;/a&gt;
</code></pre><p>
Также вы можете послать “дескриптор окна” методу “switch_to_window()”. Пользуясь этой особенностью, вы можете использовать цикл для перебора всех открытых окон, к примеру, так:

</p><pre><code class="python">for handle in driver.window_handles:
    driver.switch_to_window(handle)
</code></pre><p>
Еще вы можете переходить между фрэймами (frame или iframes):

</p><pre><code class="python">driver.switch_to_frame("frameName")
</code></pre><p>
Можно получить доступ к подчиненным фреймам, подавая путь, разделяемый точкой, или можно получить фрейм по индексу:

</p><pre><code class="python">driver.switch_to_frame("frameName.0.child")
</code></pre><p>
Следующий код перенаправит к фрейму с именем “child”, который в свою очередь принадлежит первому подчиненному фрейму фрейма “frameName”. </p><b>Пути к фреймам описываются полностью — от верхнего уровня</b><p>:

</p><pre><code class="python">driver.switch_to_frame("frameName.0.child")
</code></pre><p>
Когда работа с фреймами будет завершена, необходимо переключиться обратно, к главному фрейму, что может быть сделано следующим образом:

</p><pre><code class="python">driver.switch_to_default_content()
</code></pre>
<h2>3.5. Всплывающие окна</h2><p>
Selenium WebDriver из упаковки поддерживает управление всплывающими диалоговыми окнами. После того как вы инициируете запуск, откроется окно, управлять им можно так:

</p><pre><code class="python">alert = driver.switch_to_alert()
</code></pre><p>
Код вернет объект текущего открытого окна. С этим объектом вы можете принять, отклонить вопрос окна, прочитать его содержимое или даже ввести текст по приглашению окна. Интерфейс взаимодействия со всплывающими окнами работает одинаково хорошо как для предупреждений (alerts), так и для запросов к подтверждению (confirms) и приглашений к вводу (prompts). За дополнительной информацией обратитесь к документации API.

</p><h2>3.6. Навигация: история и локация</h2><p>
Чуть раньше мы упомянули о навигации по ссылке с ипользованием комманды “get” ( driver.get(«</p><a href="http://www.example.com">www.example.com</a><p>») ). Как вы уже могли заметить, WebDriver для отдельных случаев предоставляет узконаправленные, специализированные интерфейсы взаимодействия, и навигация не исключение. Чтобы перейти по ссылке, вы можете воспользоваться методом get:

</p><pre><code class="python">driver.get("http://www.example.com")
</code></pre><p>
Чтобы перейти вперед или назад по истории вкладки:

</p><pre><code class="python">driver.forward()
driver.back()
</code></pre><p>
Имейте в виду, что этот функционал полностью зависит от используемого драйвера. Вы можете получить непредвиденный результат, если привыкли к поведению какого-либо конкретного браузера, а работаете с другим.

</p><h2>3.7. Куки (cookies)</h2><p>
Прежде, чем мы завершим эту главу, вам возможно будет интересно узнать как использовать куки. Прежде всего, вам необходим домен, использующий куки:

</p><pre><code class="python"># Перейти на необходимый домен
driver.get("http://www.example.com")

# Установить куки. Следующий cookie действителен для всего домена
cookie = {"ключ": "значение"})
driver.add_cookie(cookie)

# И теперь получим все доступные куки для текущего адреса URL
all_cookies = driver.get_cookies()
for cookie_name, cookie_value in all_cookies.items():
    print("%s -&gt; %s", cookie_name, cookie_value)
</code></pre>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>