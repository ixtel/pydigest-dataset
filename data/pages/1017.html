<html><body><div><div class="content">
      
        <h1 class="content-title">SQLite: Small. Fast. Reliable. Choose any three.</h1>
      
      
      
  
  
  
    <p><a href="http://media.charlesleifer.com/blog/photos/sqlite-logo.png" title="Sqlite Logo"><img alt="Sqlite Logo" class="img-responsive" src="http://m.charlesleifer.com/t/800x-/blog/photos/sqlite-logo.png?key=jnNPdovFyTlAY-sn4785qg"/></a></p>
<p><a href="http://sqlite.org">SQLite</a> is a fantastic database and in this post
I'd like to explain why I think that, for many scenarios, SQLite is
actually a great choice. I hope to also clear up some common misconceptions
about SQLite.</p>
<h3>Concurrency</h3>
<p>As the maintainer of an ORM, I get asked a lot of questions about databases. One of
the more common questions is:</p>
<blockquote>
<p>Can I use SQLite in my web app? I've heard it doesn't do concurrency.</p>
</blockquote>
<p>SQLite <em>does</em> support multiple concurrent connections, and therefore it can be used
with a multi-threaded or multi-process application. The catch is that when SQLite opens a
write transaction, it will lock all the tables.</p>
<p>Locking the entire database may sound scary, but typically writes occur very
quickly, and there are ways to make them faster (discussed below).
So, even though the database is locked while you are writing, the writes happen
so quickly that it's only likely to be an issue if you are doing a <em>lot</em> of
concurrent writes.</p>
<p>Additionally, the Python SQLite driver will automatically retry queries that fail due to the
database being locked. You can configure this behavior using the <code>timeout</code>
parameter, which has a default value of 5 seconds. Since most writes occur
in milliseconds, the 5 second timeout is a relative eternity.</p>
<p>If you'd like to learn more about SQLite's locking behavior, I'd suggest reading the
<a href="http://www.sqlite.org/lockingv3.html">SQLite locking documentation</a>.</p>
<h4>Faster concurrent operations</h4>
<p>By using write-ahead logging (WAL), available since version 3.7.0,
you can gain additional speed when performing concurrent operations. WAL allows
multiple readers to operate on the database, even while a write is occuring.
To enable WAL, execute the following query after opening a new connection to the database:</p>

<p>Another way to achieve higher concurrency is to compile <a href="http://www.oracle.com/technetwork/products/berkeleydb/overview/index.html">BerkeleyDB</a>
with a SQLite-compatible API. Then, by compiling the python SQLite driver
against the BerkeleyDB SQLite library, you can achieve some <a href="http://www.oracle.com/technetwork/database/berkeleydb/learnmore/bdbvssqlite-wp-186779.pdf">pretty awesome performance</a>. The image below shows how BerkeleyDB delivers many
more transactions-per-second when using multiple threads.</p>
<p><a href="http://media.charlesleifer.com/blog/photos/p1405279996.65.png" title="p1405279996.65.png"><img alt="p1405279996.65.png" class="img-responsive" src="http://m.charlesleifer.com/t/800x-/blog/photos/p1405279996.65.png?key=-lmVnGZAzqFj-R0soKa7zw"/></a></p>
<p>If you're interested in trying out the BerkeleyDB SQLite library, <a href="/blog/building-the-python-sqlite-driver-for-use-with-berkeleydb/">this post</a>
contains instructions for compiling BerkeleyDB and the Python SQLite driver.
Also, if you're using <a href="http://docs.peewee-orm.com">peewee ORM</a>, you can use the <code>berkeley_build.sh</code> shell script (contained
in the <code>playhouse</code> directory). This script will download BerkeleyDB from Oracle's site, compile it with support
for the SQL API, then compile <code>pysqlite</code> against the BerkeleyDB SQLite driver.</p>
<h3>SQLite is not a "real" database</h3>
<p>I've occasionally heard people say that SQLite is not a <em>real</em> database. The
reasons for this opinion vary, but here are some that come to mind:</p>
<ul>
<li>Column data-types are not enforced, e.g. you can store text in an integer column.</li>
<li>After a table is created, columns cannot be dropped or renamed (though you can add new columns).</li>
<li>Database is locked for writes.</li>
</ul>
<p>On the other hand, look at all the features that SQLite does provide:</p>
<ul>
<li>Transactions are atomic, consistent, isolated and durable (ACID).</li>
<li>Support for a wide variety of SQL queries.</li>
<li>Indexes, constraints, foreign keys, views, and partial support for triggers.</li>
<li>Savepoints (nested transactions).</li>
<li>Multiple concurrent connections to the database.</li>
<li>Databases can be up to 140TB in size.</li>
<li>SQLite can recover from program crashes, operating system crashes, and even power failures.</li>
<li>Write your own extensions, define your own aggregates, collations, and SQL functions.</li>
<li>Full-text search and other neat extensions.</li>
</ul>
<p>Every database I've used differs slightly in the subset of SQL it supports,
and even though the data-types and <code>ALTER TABLE</code> behavior of SQLite are unusual,
I don't think either of them means that SQLite is not a real database.</p>
<h4>Working around ALTER TABLE</h4>
<p>The standard approach when altering or dropping columns from a SQLite database is
to create a new table, copy the data you want, then replace the old table with the
new. This can be quite cumbersome, especially when your table has a large number of
columns.</p>
<p>To make this easier, I wrote a lightweight <a href="http://docs.peewee-orm.com/en/latest/peewee/playhouse.html#schema-migrations">schema migrations extension</a>
for the peewee ORM. I'm not positive, but I imagine something similar exists for
SQLAlchemy users. This extension will automatically handle creating the temporary
table and copying over the data, so all you need to do is tell peewee which columns
to drop (or rename, etc):</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">playhouse.migrate</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">migrator</span> <span class="o">=</span> <span class="n">SqliteMigrator</span><span class="p">(</span><span class="s1">'mydata.db'</span><span class="p">)</span>
<span class="n">migrate</span><span class="p">(</span>
    <span class="n">migrator</span><span class="o">.</span><span class="n">drop_column</span><span class="p">(</span><span class="s1">'some_table'</span><span class="p">,</span> <span class="s1">'some_column'</span><span class="p">),</span>
    <span class="n">migrator</span><span class="o">.</span><span class="n">drop_column</span><span class="p">(</span><span class="s1">'some_table'</span><span class="p">,</span> <span class="s1">'another_column'</span><span class="p">),</span>
    <span class="n">migrator</span><span class="o">.</span><span class="n">rename_column</span><span class="p">(</span><span class="s1">'some_table'</span><span class="p">,</span> <span class="s1">'old_colname'</span><span class="p">,</span> <span class="s1">'new_colname'</span><span class="p">),</span>
<span class="p">)</span>
</pre></div>
<p>Even if you aren't using an ORM you can still use the migrator library to help with schema changes.</p>
<h2>When would SQLite not be a good choice?</h2>
<p>Now that I've sung the praises of SQLite and described some ways to work around
its limitations, I'd like to describe some scenarios where SQLite would be a bad
choice.</p>
<ul>
<li>Multiple servers communicating with the database over the network, or situations
  in which you plan to run your database on a separate server.</li>
<li>Highly concurrent applications, including websites that receive a very large
  amount of traffic.</li>
<li>Very large data-sets.</li>
</ul>
<p>The main consideration there, I think, is when you have multiple web-servers and
need to connect to your database over the network. While you <em>can</em> use SQLite over
an NFS mount, for instance, the SQLite documentation seems to indicate that this
may be buggy.</p>
<h2>Wrapping up</h2>
<p>Both SQLite and Postgres have their place in the developer's toolkit. Postgres
is a phenomenal database, and I could go on and on about how awesome it is. But this
post is about clearing up some misconceptions about SQLite, and hopefully convincing
you that it is a great choice for many applications, <em>including web development</em>.</p>
<p>Donald Knuth said,</p>
<blockquote>
<p>Premature optimization is the root of all evil.</p>
</blockquote>
<p>In that vein, don't be afraid to give SQLite a try -- I'd be willing to bet it would
work very well for you!</p>
<p>Oh, and in case you were wondering, yes -- this site uses SQLite!</p>
<h3>Edit</h3>
<p>I was asked on a <a href="http://www.reddit.com/r/Python/comments/2aonc3/sqlite_small_fast_reliable_choose_any_three/">Reddit discussion</a> to quantify how much traffic a site should receive before it is "too much". This obviously depends on a lot of factors (ratio of reads to writes, length of time it takes to perform a write, disk speed, etc). I will share a quote from the <a href="http://www.sqlite.org/whentouse.html">SQLite docs</a>, though:</p>
<blockquote>
<p>SQLite usually will work great as the database engine for low to medium traffic websites (which is to say, 99.9% of all websites). The amount of web traffic that SQLite can handle depends, of course, on how heavily the website uses its database. Generally speaking, any site that gets fewer than 100K hits/day should work fine with SQLite. The 100K hits/day figure is a conservative estimate, not a hard upper bound. SQLite has been demonstrated to work with 10 times that amount of traffic.</p>
</blockquote>
<h2>Links</h2>
<p>Thanks for taking the time to read this post, if you have any questions or comments,
please feel free to <a href="#comments">leave a comment</a> below.</p>
<p>If you'd like to learn more about the topics mentioned in this post, here are some
links which you might find useful:</p>

  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  


<hr/>

  <p>Commenting has been closed, but please feel free to <a href="/contact/">contact me</a></p>


    </div>

    </div></body></html>