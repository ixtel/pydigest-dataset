<html><body><div><div class="entry-content">
                
                
        <p><em>This post applies to Python 2.5 and 2.6 - if you see any difference for Python 3, please let me know.</em></p>
<p>Destructors are a very important concept in C++, where they're an essential ingredient of <a class="reference external" href="http://en.wikipedia.org/wiki/RAII">RAII</a> - virtually the only real safe way to write code that involves allocation and deallocation of resources in an exception-throwing program.</p>
<p>In Python, destructors are needed much less, because Python has a garbage collector that handles memory management. However, while memory is the most common resource allocated, it is not the only one. There are also sockets and database connections to be closed, files, buffers and caches flushed and a few more resources that need to be released when an object is done with them.</p>
<p>So Python has the destructor concept - the <tt class="docutils literal"><span class="pre">__del__</span></tt> method. For some reason, many in the Python community believe that <tt class="docutils literal"><span class="pre">__del__</span></tt> is evil and shouldn't be used. However, a simple <tt class="docutils literal"><span class="pre">grep</span></tt> of the standard library shows dozens of uses of <tt class="docutils literal"><span class="pre">__del__</span></tt> in classes we all use and love, so where's the catch? In this article I'll try to make it clear (first and foremost for myself), when <tt class="docutils literal"><span class="pre">__del__</span></tt> should be used, and how.</p>
<div class="section" id="simple-code-samples">
<h3>Simple code samples</h3>
<p>First a basic example:</p>
<div class="highlight"><pre><span>class</span> <span>FooType</span>(<span>object</span>):
    <span>def</span> <span>__init__</span>(<span>self</span>, <span>id</span>):
        <span>self</span>.id = <span>id</span>
        <span>print</span> <span>self</span>.id, <span>'born'</span>

    <span>def</span> <span>__del__</span>(<span>self</span>):
        <span>print</span> <span>self</span>.id, <span>'died'</span>


ft = FooType(<span>1</span>)
</pre></div>
<p>This prints:</p>

<p>Now, recall that due to the usage of a reference-counting garbage collector, Python won't clean up an object when it goes out of scope. It will clean it up when the last reference to it has gone out of scope. Here's a demonstration:</p>
<div class="highlight"><pre><span>class</span> <span>FooType</span>(<span>object</span>):
    <span>def</span> <span>__init__</span>(<span>self</span>, <span>id</span>):
        <span>self</span>.id = <span>id</span>
        <span>print</span> <span>self</span>.id, <span>'born'</span>

    <span>def</span> <span>__del__</span>(<span>self</span>):
        <span>print</span> <span>self</span>.id, <span>'died'</span>

<span>def</span> <span>make_foo</span>():
    <span>print</span> <span>'Making...'</span>
    ft = FooType(<span>1</span>)
    <span>print</span> <span>'Returning...'</span>
    <span>return</span> ft

<span>print</span> <span>'Calling...'</span>
ft = make_foo()
<span>print</span> <span>'End...'</span>
</pre></div>
<p>This prints:</p>
<div class="highlight"><pre>Calling...
Making...
1 born
Returning...
End...
1 died
</pre></div>
<p>The destructor was called after the program ended, not when <tt class="docutils literal"><span class="pre">ft</span></tt> went out of scope inside <tt class="docutils literal"><span class="pre">make_foo</span></tt>.</p>
</div>
<div class="section" id="alternatives-to-the-destructor">
<h3>Alternatives to the destructor</h3>
<p>Before I proceed, a proper disclosure: Python provides a better method for managing resources than destructors - contexts. I won't turn this into a tutorial of contexts, but you should really get yourself familiar with the <tt class="docutils literal"><span class="pre">with</span></tt> statement and objects that can be used inside. For example, the best way to handle writing to a file is:</p>
<div class="highlight"><pre><span>with</span> <span>open</span>(<span>'out.txt'</span>, <span>'w'</span>) <span>as</span> of:
    of.write(<span>'222'</span>)
</pre></div>
<p>This makes sure the file is properly closed when the block inside <tt class="docutils literal"><span class="pre">with</span></tt> exits, even if exceptions are thrown. Note that this demonstrates a standard context manager. Another is <tt class="docutils literal"><span class="pre">threading.lock</span></tt>, which returns a context manager very suitable to be used in a <tt class="docutils literal"><span class="pre">with</span></tt> statement. You should read <a class="reference external" href="http://www.python.org/dev/peps/pep-0343/">PEP 343</a> for more details.</p>
<p>While recommended, <tt class="docutils literal"><span class="pre">with</span></tt> isn't always applicable. For example, assume you have an object that encapsulates some sort of a database that has to be committed and closed when the object ends its existence. Now suppose the object should be a member variable of some large and complex class (say, a GUI dialog, or a MVC model class). The parent interacts with the DB object from time to time in different methods, so using <tt class="docutils literal"><span class="pre">with</span></tt> isn't practical. What's needed is a functioning destructor.</p>
</div>
<div class="section" id="where-destructors-go-astray">
<h3>Where destructors go astray</h3>
<p>To solve the use case I presented in the last paragraph, you can employ the <tt class="docutils literal"><span class="pre">__del__</span></tt> destructor. However, it's important to know that this doesn't always work well. The nemesis of a reference-counting garbage collector is circular references. Here's an example:</p>
<div class="highlight"><pre><span>class</span> <span>FooType</span>(<span>object</span>):
    <span>def</span> <span>__init__</span>(<span>self</span>, <span>id</span>, parent):
        <span>self</span>.id = <span>id</span>
        <span>self</span>.parent = parent
        <span>print</span> <span>'Foo'</span>, <span>self</span>.id, <span>'born'</span>

    <span>def</span> <span>__del__</span>(<span>self</span>):
        <span>print</span> <span>'Foo'</span>, <span>self</span>.id, <span>'died'</span>


<span>class</span> <span>BarType</span>(<span>object</span>):
    <span>def</span> <span>__init__</span>(<span>self</span>, <span>id</span>):
        <span>self</span>.id = <span>id</span>
        <span>self</span>.foo = FooType(<span>id</span>, <span>self</span>)
        <span>print</span> <span>'Bar'</span>, <span>self</span>.id, <span>'born'</span>

    <span>def</span> <span>__del__</span>(<span>self</span>):
        <span>print</span> <span>'Bar'</span>, <span>self</span>.id, <span>'died'</span>


b = BarType(<span>12</span>)
</pre></div>
<p>Output:</p>

<p>Ouch... what has happened? Where are the destructors? Here's what the Python documentation has to say on the matter:</p>
<blockquote>
Circular references which are garbage are detected when the option cycle detector is enabled (itâs on by default), but can only be cleaned up if there are no Python-level __del__() methods involved.</blockquote>
<p>Python doesn't know the order in which it's safe to destroy objects that hold circular references to each other, so as a design decision, it just doesn't call the destructors for such methods!</p>
</div>
<div class="section" id="so-now-what">
<h3>So, now what?</h3>
<p>Shouldn't we use destructors because of this deficiency? I'm very surprised to see that many Pythonistas think so, and recommend to use explicit <tt class="docutils literal"><span class="pre">close</span></tt> methods. But I disagree - explicit <tt class="docutils literal"><span class="pre">close</span></tt> methods are less safe, since they are easy to forget to call. Moreover, when exceptions can happen (and in Python they happen all the time), managing explicit closing becomes very difficult and burdensome.</p>
<p>I actually think that destructors can and should be used safely in Python. With a couple of precautions, it's definitely possible.</p>
<p>First and foremost, note that justified cyclic references are a rare occurrence. I say <em>justified</em> on purpose - a lot of uses in which cyclic references arise are an example of bad design and leaky abstractions.</p>
<p>As a general rule of thumb, resources should be held by the lowest-level objects possible. Don't hold a DB resource directly in your GUI dialog. Use an object to encapsulate the DB connection and close it safely in the destructor. The DB object has no reason whatsoever to hold references to other objects in your code. If it does - it violates several good-design practices.</p>
<p>Sometimes <a class="reference external" href="http://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> can help prevent cyclic references in complex code, but even in those rare few cases when you find yourself needing a true cyclic reference, there's a solution. Python provides the <a class="reference external" href="http://docs.python.org/lib/module-weakref.html">weakref</a> module for this purpose. The documentation quickly reveals that this is exactly what we need here:</p>
<blockquote>
A weak reference to an object is not enough to keep the object alive: when the only remaining references to a referent are weak references, garbage collection is free to destroy the referent and reuse its memory for something else. A primary use for weak references is to implement caches or mappings holding large objects, where itâs desired that a large object not be kept alive solely because it appears in a cache or mapping.</blockquote>
<p>Here's the previous example rewritten with <tt class="docutils literal"><span class="pre">weakref</span></tt>:</p>
<div class="highlight"><pre><span>import</span> <span>weakref</span>

<span>class</span> <span>FooType</span>(<span>object</span>):
    <span>def</span> <span>__init__</span>(<span>self</span>, <span>id</span>, parent):
        <span>self</span>.id = <span>id</span>
        <span>self</span>.parent = weakref.ref(parent)
        <span>print</span> <span>'Foo'</span>, <span>self</span>.id, <span>'born'</span>

    <span>def</span> <span>__del__</span>(<span>self</span>):
        <span>print</span> <span>'Foo'</span>, <span>self</span>.id, <span>'died'</span>


<span>class</span> <span>BarType</span>(<span>object</span>):
    <span>def</span> <span>__init__</span>(<span>self</span>, <span>id</span>):
        <span>self</span>.id = <span>id</span>
        <span>self</span>.foo = FooType(<span>id</span>, <span>self</span>)
        <span>print</span> <span>'Bar'</span>, <span>self</span>.id, <span>'born'</span>

    <span>def</span> <span>__del__</span>(<span>self</span>):
        <span>print</span> <span>'Bar'</span>, <span>self</span>.id, <span>'died'</span>

b = BarType(<span>12</span>)
</pre></div>
<p>Now we get the result we want:</p>
<div class="highlight"><pre>Foo 12 born
Bar 12 born
Bar 12 died
Foo 12 died
</pre></div>
<p>The tiny change in this example is that I use <tt class="docutils literal"><span class="pre">weakref.ref</span></tt> to assign the <tt class="docutils literal"><span class="pre">parent</span></tt> reference in the constructor <tt class="docutils literal"><span class="pre">FooType</span></tt>. This is a weak reference, so it doesn't really create a cycle. Since the GC sees no cycle, it destroys both objects.</p>
</div>
<div class="section" id="conclusion">
<h3>Conclusion</h3>
<p>Python has perfectly usable object destruction via the <tt class="docutils literal"><span class="pre">__del__</span></tt> method. It works fine for the vast majority of use-cases, but chokes on cyclic references. Cyclic references, however, are often a sign of bad design, and few of them are justified. For the teeny tiny amount of uses cases where justified cyclic references have to be used, the cycles can be easily broken with weak references, which Python provides in the <tt class="docutils literal"><span class="pre">weakref</span></tt> module.</p>
</div>
<div class="section" id="references">
<h3>References</h3>
<p>Some links that were useful in the preparation of this article:</p>

</div>

    
            </div>
            

    </div></body></html>