<html><body><div><section class="post-content entry-content">
	            

<p>How to ensure that your tests run code that you think they are running, and how to measure your coverage over multiple <code>tox</code> runs (in parallel!).</p>

<h2 id="src:e4638ef4409675201612f24300b76f01"><code>src</code></h2>

<p>I used to scoff when I saw Python projects that put their packages into a separate <code>src</code> directory.  It seems unnecessary and reminded me of Java.  <a href="http://the-hitchhikers-guide-to-packaging.readthedocs.org/en/latest/quickstart.html#lay-out-your-project">But</a> <a href="https://www.digitalocean.com/community/tutorials/how-to-package-and-distribute-python-applications">it</a> <a href="https://www.jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/">also</a> <a href="https://github.com/kennethreitz/requests/">seemed</a> <a href="https://github.com/twisted/twisted">to</a> <a href="https://github.com/twisted/twisted">be</a> <a href="https://github.com/Pylons/pyramid">dying</a> <a href="https://github.com/django/django/">out</a>.</p>

<p>Imagine my surprise when I saw <a href="https://github.com/pyca/cryptography"><code>cryptography</code></a> – one of Python’s most modern projects – <a href="https://github.com/pyca/cryptography/commit/c62a78c015cf7aeb0c05bce82ef14cd86fe0b0fc">adopt</a> a <code>src</code> directory <em>subsequently</em> (if you’re <em>not</em> surprised, feel free to skip to <a href="#cc">Combined Coverage</a>)!</p>

<hr/>

<p>Soon after I got a <a href="https://github.com/hynek/prometheus_async/issues/1">bug report</a> that my <a href="https://testrun.org/tox/latest/index.html"><code>tox</code></a> and <a href="https://coverage.readthedocs.org/"><code>coverage</code></a> setup works only by accident: my tests didn’t run against the version of my app that got installed into <code>tox</code>’s <code>virtualenv</code>s.  They ran against the actual directory.  Let me reinforce this point once more:</p>

<p><strong>Your tests do <em>not</em> run against the package as it will be installed by its users.  They run against whatever the situation in your project directory is</strong>.</p>

<p>In general, that’s not a big deal.  In the end, it’s the same code.  But you can miss packaging issues which are especially frustrating to track down: ever forgot to include a resource (like templates) or a package?  It demonstrated to me that there’s likely more that can go wrong than I thought and that isolating the code into a separate – un-importable – directory might be a good idea<sup class="footnote-ref" id="fnref:e4638ef4409675201612f24300b76f01:more-reasons"><a rel="footnote" href="#fn:e4638ef4409675201612f24300b76f01:more-reasons">1</a></sup>.</p>

<p>To achieve that, you add a <code>where</code> argument to <code>find_packages()</code> and tell <code>setup()</code> about it:</p>

<pre><code class="language-python">setup(
    [...]
    packages=find_packages(where="src"),
    package_dir={"": "src"},
)
</code></pre>

<p>Coping with that rather minor issue exposed me to a more interesting problem: measuring coverage over multiple <code>tox</code> runs.</p>

<h2 id="a-name-cc-a-combined-coverage:e4638ef4409675201612f24300b76f01"><a name="cc"/> Combined Coverage</h2>

<p>The combo of running your tests against various versions and configurations using <code>tox</code> and measuring the coverage is popular.</p>

<p>In my experience though, most projects only consider the coverage for one version (depending on where you stand on the Python 2 vs 3 debate) and either ignore the coverage for other versions or push them to 100% too using <code># pragma nocover</code>.</p>

<hr/>

<p>But it’s much nicer to have the combined coverage computed over <em>all</em> your <code>tox</code> runs like the wonderful <a href="https://codecov.io">codecov</a> will do for you.  No more guessing and reasoning; you get an accurate report on which lines and branches have been executed and which not.</p>

<p>This feat is easily achieved if you run your tests <em>directly</em> against your source directory.  You add two environments to your <code>tox</code> configuration: one that erases left-over coverage data from the past run and one that will combine and report the current one<sup class="footnote-ref" id="fnref:e4638ef4409675201612f24300b76f01:detox"><a rel="footnote" href="#fn:e4638ef4409675201612f24300b76f01:detox">2</a></sup>:</p>

<pre><code class="language-ini">[tox]
envlist = coverage-clean,py27,py35,pypy,coverage-report

[testenv:coverage-clean]
deps = coverage
skip_install = true
commands = coverage erase

[testenv:coverage-report]
deps = coverage
skip_install = true
commands =
    coverage combine
    coverage report
</code></pre>

<p>Now run <code>coverage</code> in parallel mode and you’re done:</p>

<pre><code class="language-bash">coverage run --parallel -m pytest tests
</code></pre>

<hr/>

<p>It gets more complicated if your tests run against the <em>installed</em> version of your package though.  That’s because now the paths of the <em>actually executed</em> modules look like</p>

<pre><code class="language-nohighlight">.tox/py35/lib/python3.5/site-packages/attr/__init__.py
</code></pre>

<p>So you end up with a very long coverage output with <em>all</em> <code>site-packages</code> of <em>all</em> <code>tox</code> environments.</p>

<p>Fortunately there is a solution in <code>coverage</code> which is the little known <code>[paths]</code> <a href="https://coverage.readthedocs.org/en/latest/config.html#paths">configuration section</a>.  It allows you to tell <code>coverage</code> which paths it should consider equivalent:</p>

<pre><code class="language-ini">[run]
branch = True
source = attr

[paths]
source =
   src/attr
   .tox/*/lib/python*/site-packages/attr
   .tox/pypy*/site-packages/attr
</code></pre>

<p>Now <code>coverage combine</code> will fold the coverage data of these paths together and you get what you expect:</p>

<pre><code class="language-nohighlight">Name                     Stmts   Miss Branch BrPart  Cover   Missing
--------------------------------------------------------------------
src/attr/__init__.py        17      0      0      0   100%
src/attr/_compat.py         15      0      2      0   100%
src/attr/_config.py          9      0      2      0   100%
src/attr/_funcs.py          35      0     18      0   100%
src/attr/_make.py          202      0     92      0   100%
src/attr/filters.py         15      0      3      0   100%
src/attr/validators.py      33      0     12      0   100%
--------------------------------------------------------------------
TOTAL                      326      0    129      0   100%
</code></pre>

<h3 id="speeding-up-with-parallelization:e4638ef4409675201612f24300b76f01">Speeding Up With Parallelization</h3>

<p>This approach works but it relies on the <em>order</em> in which the environments are ran.</p>

<p>Thus if you want to use something like <a href="https://pypi.python.org/pypi/detox/"><code>detox</code></a> that runs your <code>tox</code> environments in parallel, you’ll have to make sure that cleanup and reporting run separately.</p>

<p>To illustrate how much of a difference <code>detox</code> makes: the modest <a href="http://www.structlog.org/"><code>structlog</code></a> test suite in all it’s variations takes about 50s serially and about 20s when parallelized using <code>detox</code>.  I think ~100% faster is pretty sweet and worth coming up with a solution<sup class="footnote-ref" id="fnref:e4638ef4409675201612f24300b76f01:tracker"><a rel="footnote" href="#fn:e4638ef4409675201612f24300b76f01:tracker">3</a></sup>.</p>

<p>So I wrote a simple tool called <code>detoxize</code> that reads a list of environments from <code>stdin</code> (probably <code>tox -l</code> output) and prints a command line that runs <code>tox</code> with the first environment, then <code>detox</code> with all environments except the first and the last, and finally <code>tox</code> again with the last environment:</p>

<pre><code class="language-python">#!/usr/bin/env python3

import sys


if __name__ == "__main__":
    envs = [env.strip() for env in sys.stdin.readlines()]
    print(
        "tox -e " + envs[0] + "; " +
        "detox -e " + ",".join(env for env in envs[1:-1]) + "; "
        "tox -e " + envs[-1]
    )
</code></pre>

<p>In other words if you have:</p>

<pre><code class="language-ini">[tox]
envlist = coverage-clean,py27,py35,pypy,coverage-report
</code></pre>

<p>in your <code>tox.ini</code> and pipe <code>tox -l</code> into <code>detoxize</code>, it will print</p>

<pre><code class="language-bash">tox -e coverage-clean; detox -e py27,py35,pypy; tox -e coverage-report
</code></pre>

<hr/>

<p>If you set up a <code>tox</code> project like I’ve sketched out before, you can run</p>

<pre><code class="language-bash">tox -l | detoxize | sh
</code></pre>

<p>and you get the benefits of parallel speed together with a combined coverage report.  You may want to add a shell alias for that if you’re lazy like me:</p>

<h4 id="bash-zsh:e4638ef4409675201612f24300b76f01">bash/zsh</h4>

<pre><code class="language-bash">alias dt="tox -l | detoxize | sh"
</code></pre>

<h4 id="fish:e4638ef4409675201612f24300b76f01">fish</h4>

<pre><code class="language-fish">alias dt "tox -l | detoxize | time sh"
</code></pre>

<h3 id="travis-codecov:e4638ef4409675201612f24300b76f01">Travis &amp; codecov</h3>

<p>Turns out™ that <code>codecov</code> doesn’t work properly if you run <code>coverage</code> in parallel mode.  Therefore you have to <code>coverage combine</code> your coverage data between each run and submit:</p>

<pre><code class="language-yaml">after_success:
  - tox -e coverage-report
  - codecov
</code></pre>

<h2 id="summary:e4638ef4409675201612f24300b76f01">Summary</h2>

<p>You can have a look at the <a href="https://github.com/hynek/attrs/blob/master/setup.py"><code>setup.py</code></a>, <a href="https://github.com/hynek/attrs/blob/master/tox.ini"><code>tox.ini</code></a> and <a href="https://github.com/hynek/attrs/blob/master/.coveragerc"><code>.coveragerc</code></a> of <a href="https://attrs.readthedocs.org/"><code>attrs</code></a> if you want a simple yet complete and functional example.</p>




	        </section>

	        
	        
	        
	        
	        
	        
	        
	        
	        
	        
	        
	        
	        
	        

	        </div></body></html>