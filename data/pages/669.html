<html><body><div><article class="card post-298 post type-post status-publish format-standard hentry category-python category-ws4py" id="post-298">

                <h2>The joy of distributing Python packages for Python 2 and 3</h2>
                

                
<p class="topsy_widget_data topsy_theme_blue"/>
<p>I released <a href="https://pypi.python.org/pypi/ws4py" target="_blank">ws4py 0.3.4</a> this weekend and although I had integrated support for Python 2 and 3 for a long time now, I ran into a challenge I had quite missed. Indeed, until now my Python 3 support had mainly been concerned about string handling and various <a href="https://github.com/Lawouach/WebSocket-for-Python/blob/master/ws4py/compat.py" target="_blank">compatibility modules</a>. This has proven to work very well and avoided having to rely on external packages such as six.</p>
<p>However, in the past few weeks and I added asyncio support to ws4py and therefore introduced the newly <a href="http://legacy.python.org/dev/peps/pep-0380/" target="_blank">yield from</a> statement. Of course, this isn’t tolerated by Python 2 which complains with a well deserved SyntaxError.</p>
<p>The issues however is that I wished to distribute the same source code with a single source distribution archive. Initially, I had written a <a href="https://github.com/Lawouach/WebSocket-for-Python/blob/dc12c02ff7b8b8b42eda666abd408eaa57418263/setup.py#L10" target="_blank">function that was preventing modules using that statement to actually be packaged</a>. However, this was rather daft since that, if it weren’t packaged, it wouldn’t be distributed either. Next, I decided to some of <a href="https://pythonhosted.org/setuptools/python3.html" target="_blank">setuptools magic</a>. Well, it didn’t help since that’s not what it’s there for anyhow. At this stage, I should say: <em>Don’t simply copy/paste. It will do no good.</em></p>
<p>Finally, I opted for a <a href="https://github.com/Lawouach/WebSocket-for-Python/blob/master/setup.py#L11" target="_blank">fairly simple solution</a>. I knew that when a package is installed from a distribution packages, it is obviously built first. I therefore had to act after Python modules had been gathered but before they would be built. After briefly browsing through distutils source code, I found where I would perform surgery: the <strong>find_package_modules</strong> of the <strong>distutils.command.build_py.build_py</strong> class. The nice aspect of this solution is that the source distribution contains indeed all the modules, whether they aim Python 2 or 3 but it’s only when installed that the appropriate modules will be selected and built.</p>
<p>Am I doing it wrong? Is there a cleaner, nicer more pythonic way? If so, please let me know. If not, I hope this may help others that want a simple solution to handle their Python 2 and 3 modules in a single baseline.</p>


                <p><span class="post-meta"><span class="fa fa-tags"/>   </span></p>
                                <hr/>
            	
	<h2 class="text-danger" id="comments"><span class="fa fa-comments-ot"/>  
	2 Comments	</h2>
	<hr/>
	<ol class="commentlist">
		
    <li class="comment even thread-even depth-1" id="li-comment-21374">
        
    <ul class="children">

    <li class="comment byuser comment-author-admin bypostauthor odd alt depth-2" id="li-comment-21375">
        
    </li>
</ul>
</li>
	</ol>
	
 
                

            </article>

    
</div></body></html>