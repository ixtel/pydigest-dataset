<html><body><div><div class="entry-content"><p>Операция присваивания не копирует объект, он лишь создаёт ссылку на объект. Для изменяемых коллекций, или для коллекций, содержащих изменяемые элементы, часто необходима такая копия, чтобы её можно было изменить, не изменяя оригинал. Данный модуль предоставляет общие (поверхностная и глубокая) операции копирования.</p><p><b>copy.copy</b>(x) - возвращает поверхностную копию x.</p><p><b>copy.deepcopy</b>(x) - возвращает полную копию x.</p><p><a href="http://pythonworld.ru/tipy-dannyx-v-python/isklyucheniya-v-python-konstrukciya-try-except-dlya-obrabotki-isklyuchenij.html" target="_blank">Исключение</a><b>copy.error</b> - возникает, если объект невозможно скопировать.</p><p>Разница между поверхностным и глубоким копированием существенна только для составных объектов, содержащих изменяемые объекты (например, список списков, или словарь, в качестве значений которого - списки или словари):</p><ul><li><b>Поверхностная копия</b> создает новый составной объект, и затем (по мере возможности) вставляет в него ссылки на объекты, находящиеся в оригинале.</li><li><b>Глубокая копия</b> создает новый составной объект, и затем рекурсивно вставляет в него копии объектов, находящихся в оригинале.</li></ul><pre class="code pycon literal-block">
<span class="kn"/><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">copy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">test_1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">test_1</span><span class="p">,</span> <span class="n">test_copy</span><span class="p">)</span>
<span class="go">[1, 2, 3, [1, 2, 3]] [1, 2, 3, [1, 2, 3]]
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">test_copy</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">test_1</span><span class="p">,</span> <span class="n">test_copy</span><span class="p">)</span>
<span class="go">[1, 2, 3, [1, 2, 3, 4]] [1, 2, 3, [1, 2, 3, 4]]
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">test_1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_deepcopy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">test_1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_deepcopy</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">test_1</span><span class="p">,</span> <span class="n">test_deepcopy</span><span class="p">)</span>
<span class="go">[1, 2, 3, [1, 2, 3]] [1, 2, 3, [1, 2, 3, 4]]</span></pre><p>Для операции глубокого копирования часто возникают две проблемы, которых нет у операции поверхностного копирования:</p><ul><li>Рекурсивные объекты (составные объекты, которые явно или неявно содержат ссылки на себя) могут стать причиной рекурсивного цикла;</li><li>Поскольку глубокая копия копирует всё, она может скопировать слишком много, например, административные структуры данных, которые должны быть разделяемы даже между копиями.</li></ul><p>Функция deepcopy решает эти проблемы путем:</p><ul><li>Хранения "memo" словаря объектов, скопированных во время текущего прохода копирования;</li><li>Позволения классам, определенным пользователем, переопределять операцию копирования или набор копируемых компонентов.</li></ul><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="go">[1, 2, 3, [...]]
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">[1, 2, 3, [...]]</span></pre><p>Этот модуль не копирует типы вроде <a href="http://pythonworld.ru/moduli" target="_blank">модулей</a>, <a href="http://pythonworld.ru/osnovy/obektno-orientirovannoe-programmirovanie-obshhee-predstavlenie.html" target="_blank">классов</a>, <a href="http://pythonworld.ru/tipy-dannyx-v-python/vse-o-funkciyax-i-ix-argumentax.html" target="_blank">функций</a>, методов, следа в стеке, стековых кадров, <a href="http://pythonworld.ru/tipy-dannyx-v-python/fajly-rabota-s-fajlami.html" target="_blank">файлов</a>, сокетов, окон, и подобных типов.</p><p>Поверхностная копия изменяемых объектов также может быть создана методом .copy() у <a href="http://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html" target="_blank">списков</a> (начиная с <a href="http://pythonworld.ru/novosti-mira-python/chto-novogo-v-python-33.html" target="_blank">Python 3.3</a>), присваиванием среза (copied_list = original_list[:]), методом .copy() <a href="http://pythonworld.ru/tipy-dannyx-v-python/slovari-dict-funkcii-i-metody-slovarej.html" target="_blank">словарей</a> и <a href="http://pythonworld.ru/tipy-dannyx-v-python/mnozhestva-set-i-frozenset.html" target="_blank">множеств</a>. Создавать копию неизменяемых объектов (таких, как, например, <a href="http://pythonworld.ru/tipy-dannyx-v-python/stroki-funkcii-i-metody-strok.html" target="_blank">строк</a>) необязательно (они же неизменяемые).</p><p>Для того, чтобы определить собственную реализацию копирования, класс может определить специальные методы __copy__() и __deepcopy__(). Первый вызывается для реализации операции поверхностного копирования; дополнительных аргументов не передается. Второй вызывается для реализации операции глубокого копирования; ему передается один аргумент, словарь memo. Если реализация __deepcopy__() нуждается в создании глубокой копии компонента, то он должен вызвать функцию deepcopy() с компонентом в качестве первого аргумента и словарем memo в качестве второго аргумента.</p></div></div></body></html>