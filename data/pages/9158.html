<html><body><div><div class="content html_format">
      <h3><b>Начало</b></h3><p>
Однажды мне пришлось заняться разработкой Web-приложения для корпоративного использования на Python+Django. И самым первым вопросом, который пришлось решать — это прозрачная авторизация на сайте или </p><b>Single Sign-On (SSO)</b><p>.
</p><p>
На предприятии широко используется служба каталогов на базе Microsoft Active Directory, и к настоящему моменту практически все корпоративные приложения позволяют использовать windows-авторизацию и не вводить постоянно логины/пароли, поэтому новое приложение просто должно было удовлетворять существующему положению вещей и реализовывать указанную выше возможность для «прозрачной» авторизации пользователей.
</p><p>
Хотя о вопросе реализации SSO для Django написано немало статей, однако для того, чтобы реализовать то, что мне было необходимо, пришлось затратить относительно много времени. Поэтому, чтобы избавить некоторых из вас от возможных долгих поисков информации и ее сборки в работающую схему, предлагаю вам свой мануал, как сделать прозрачную авторизацию в приложении Django с использованием учетных записей Active Directory.

</p><b>Итак мы имеем:</b><a name="habracut"/>

<ul>
<li>Служба каталогов Microsoft Active Directory,</li>
<li>Имя домена Windows: <b>company.ru</b></li>
<li>Имя контроллера домена Windows 2012 Server: <b>DC-1</b></li>
<li>IP Address контроллера домена Windows 2012 Server: <b>192.168.7.110</b></li>
<li>Сервер для работы нашего приложения: <b>CentOS7, Apache, Python 3.5.1, Django 1.9.1</b></li>
<li>Hostname Linux Server с CentOS7: <b>srv-app</b></li>
<li>IP Address Linux Server с CentOS7: <b>192.168.7.105</b></li>
<li>URL Приложения на Django: <b>srv-app.company.ru</b></li>
</ul>
<b>Нужно сделать:</b>

<ul>
<li>Пользователь, зарегистрированный в Active Directory при открытии любой страницы сайта на srv-app.company.ru должен автоматически, без запроса логина/пароля, быть авторизован Django. При авторизации, в профиль пользователя в Django должна быть перенесена некоторая информация о нем из Active Directory (first_name, last_name, mail; флаги is_active, is_staff, is_supersuser должны быть установлены на основании членства пользователя в соответствующих группах Active Directory).</li>
<li>Пользователю, не зарегистрированному в Active Directory вход на сайт должен быть запрещен.</li>
</ul>
<b>Изучив ряд опубликованных статей и описаний стало понятно, что добиться нужного результата можно, выполнив два основных шага:</b>
<ul>
<li>Настройка прозрачной аутентификации при доступе к приложению сервером Apache с использованием Kerberos.</li>
<li>Авторизация в Django c использованием доступа к контроллеру домена по протоколу LDAP для получения необходимой информации об авторизующемся пользователе.</li>
</ul>
<h3><b>Этап 1. Настройка прозрачной аутентификации с использованием Kerberos</b></h3><p>
Совершенно очевидно, что реализация принципа SSO в сети Windows AD возможно используя протокол Kerberos. Поэтому основной задачей первого этапа настройки будет установка Kerberos в среде Linux+Apache и настройка связи с контроллером домена Windows AD.

</p><h4><b>Установка и настройка Kerberos на сервере Linux</b></h4>
<h5><b>Настройка /etc/hosts, /etc/resolv.conf на <b>srv-app</b>, DNS на <b>DC-1</b></b></h5><p>
На </p><b>srv-app</b><p> добавляем в /etc/hosts: 

</p><pre><code class="bash">    192.168.7.105   srv-app.company.ru
</code></pre> <p>
На </p><b>srv-app</b><p> изменяем /etc/resolv.conf (В реальности этот файл в CentOS7 генерирует NetworkManager, поэтому изменения нужно вносить в /etc/sysconfig/network-scripts/ifcfg-eth0):

</p><pre><code class="bash">    search company.ru
    nameserver 192.168.7.110
</code></pre><p>
На Контроллере домена </p><b>DC-1</b><p>:

</p><ul>
<li>при помощи оснастки «Диспетчер DNS» добавим хост <b>srv-app</b> с адресом <b>192.168.7.105</b></li>
<li>при помощи оснастки «AD — пользователи и компьютеры» добавим пользователя <b>svc-apache</b>, установим для него пароль <b>P@ssw0rd</b>. Этот пользователь понадобится нам позже для создания keytab-файла, который свяжет нашу Linux-машину и Active Directory.</li>
</ul>
<h4><b>Устанавливаем модули для работы с Kerberos</b></h4>
<pre><code class="bash">    [root@srv-app ~]# yum install mod_auth_kerb     # Устанавливаем модуль для apache
    [root@srv-app ~]# yum install krb5-workstation    # Устанавливаем пакет для настройки и тестирования kerberos
</code></pre>
<h5><b>Конфигурируем Kerberos при помощи редактирования файла /etc/krb5.conf</b></h5>
<pre><code class="bash">    [logging]
     default = FILE:/var/log/krb5libs.log
     kdc = FILE:/var/log/krb5kdc.log
     admin_server = FILE:/var/log/kadmind.log
     
    [libdefaults]
     dns_lookup_realm = false
     ticket_lifetime = 24h
     renew_lifetime = 7d
     forwardable = true
     rdns = false
     default_realm = COMPANY.RU
     default_ccache_name = KEYRING:persistent:%{uid}

    [realms]
     COMPANY.RU = {
      kdc = 192.168.7.110
      admin_server = 192.168.7.110
     }

    [domain_realm]
     .company.ru = COMPANY.RU
     company.ru = COMPANY.RU
</code></pre><p>
Немного объяснений по поводу содержимого конфигурационного файла:

</p><ul>
<li><b>COMPANY.RU</b> — задаем имя области kerberos (realm) в linux. Следует запомнить что kerberos realm чувствительный к регистру (case-sensetive) </li>
</ul>
<h5><b>Выполняем несколько проверок работы kerberos на компьютере srv-app</b></h5><p>
Ранее, на нашем контроллере домена мы создали пользователя </p><b>srv-apache</b><p> с паролем </p><b>P@ssw0rd</b><p>. Попробуем залогиниться на КД при помощи утилиты kinit:

</p><pre><code class="bash">    [root@dsrv-app ~]# kinit svc-apache@COMPANY.RU
    Password for admin@COMPANY.RU: ****
</code></pre><p>
Если ошибок нет, посмотрим какие билеты (tickets) у нас имеются: 

</p><pre><code class="bash">    [root@srv-app ~]# klist
    
    Ticket cache: FILE:/tmp/krb5cc_0
    Default principal: srv-apache@COMPANY.RU

    Ticket cache: KEYRING:persistent:0:0
    Default principal: svc-apache@COMPANY.RU

    Valid starting       Expires              Service principal
    20.12.2015 16:12:59  21.12.2015 02:12:59  krbtgt/COMPANY.RU@COMPANY.RU
            renew until 27.12.2015 16:12:55
</code></pre><p>
Таким образом мы залогинились на КД при помощи kerberos, теперь разорвем соединение, удалив</p><p>
полученный билет:

</p><pre><code class="bash">    [root@srv-app ~]# kdestroy
</code></pre> <p>
Если все работает, то для дальнейшей настройки нам необходимо создать файл krb5.keytab для сервиса аутентификации при помощи</p><p>
Apache и mod_auth_kerb. 

</p><h5><b>Генерация keytab на Контроллере Домена Windows</b></h5><p>
Сгенерировать keytab можно на контроллере домена </p><b>DC-1</b><p> при помощи команды ktpass.exe: 

</p><pre><code class="bash">    ktpass.exe /princ HTTP/srv-app.company.ru@COMPANY.RU /mapuser svc-apache@COMPANY.RU  /crypto ALL /ptype KRB5_NT_PRINCIPAL /mapop set /pass P@ssw0rd /out c:\share\keytab
</code></pre> 
<ul>
<li>Ключ <b>/princ HTTP/srv-app.company.ru@COMPANY.RU</b> задает уникальное имя клиента (principal) на Linux-машине, которому будет разрешено выполнять аутентификацию в kerberos.</li>
<li>Ключи <b>/mapuser svc-apache@COMPANY.RU</b> и <b>/pass P@ssw0rd</b>, связывают principal с конкретным пользователем в Active Directory</li>
<li>Ключ <b>/crypto ALL</b> задает способ шифрования. Вместо <b>/crypto ALL</b> можно указать конкретный способ шифрования например <b>/crypto AES256-SHA1</b></li>
<li>Ключ <b>/mapop set</b> устанавливает mapping между принципалом Linux и пользовательским аккаутном Active Directory (<b>/mapop add</b> добавит этот маппинг в keytab)</li>
<li>Ключ <b>/ptype KRB5_NT_PRINCIPAL</b> — задать тип принципала в запросе (указанный тип является основным и рекомендуется использовать именно его)</li>
<li>Ключ <b>/out c:\share\keytab</b> задает путь для выходного файла keytab.</li>
<li>При желании дополнительно значения ключей можно посмотреть при помощи <b>ktpass.exe /help</b></li>
</ul><p>
В итоге мы получаем файл c:\share\keytab, который необходимо скопировать на </p><b>srv-app</b><p> и назвать /etc/krb5.keytab. Далее необходимо предоставить доступ к этому файлу пользователю, из под учетной записи которого выполняется сервер httpd. В нашем случае это </p><b>apache</b><p>. Для того чтобы </p><b>apache</b><p> мог прочитать этот файл просто разрешаем его чтение всем пользователям: 

</p><pre><code class="bash">   chmod a+r /etc/krb5.keytab
</code></pre><p>
Проверить работает ли наш keytab можно следующим образом:
</p><p>
1. При помощи </p><b>ktutil</b><p>:

</p><pre><code class="bash">    [root@srv-app ~]# ktutil
    ktutil:  rkt /etc/krb5.keytab
    ktutil:  list
    slot KVNO Principal
    ---- ---- ---------------------------------------------------------------------
       1    3           HTTP/srv-app.company.ru@COMPANY.RU
       2    3           HTTP/srv-app.company.ru@COMPANY.RU
       3    3           HTTP/srv-app.company.ru@COMPANY.RU
       4    3           HTTP/srv-app.company.ru@COMPANY.RU
       5    3           HTTP/srv-app.company.ru@cCOMPANY.RU
    ktutil:  q
</code></pre>
 <p>
2. При помощи </p><b>kvno</b><p>:

</p><pre><code class="cs">    # логинимся на KDC
    [root@srv-app ~]# kinit svc-apache
    Password for svc-apache@COMPANY.RU:

    # запрашивем тикет для сервиса &lt;b&gt;HTTP/srv-app.company.ru@COMPANY.RU&lt;/b&gt; и печатает номера версий для каждого принципала в keytab
    [root@srv-app ~]# kvno HTTP/srv-app.company.ru@COMPANY.RU
    HTTP/srv-app.company.ru@COMPANY.RU: kvno = 3
    
    # Удаляем тикет
    [root@srv-app ~]# kdestroy
</code></pre>
<h5><b>Настройка Apache</b></h5><p>
Ниже приведен файл /etc/httpd/conf.d/company_main.conf, который содержит конфигурационные инструкции для настройки Kerberos-аутенификации при обращении к URI "/":

</p><pre><code class="apache">    &lt;Location "/"&gt;
       # Kerberos authentication:
       AuthType Kerberos
       AuthName "SRV-APP auth"
       KrbMethodNegotiate on
       KrbMethodK5Passwd off
       KrbServiceName HTTP/srv-app.company.ru@COMPANY.RU
       KrbAuthRealms COMPANY.RU
       Krb5Keytab /etc/krb5.keytab
       KrbLocalUserMapping On
       Require valid-user
    &lt;/Location&gt;
</code></pre><p>
Хочу обратить внимание на настройку </p><b>KrbMethodK5Passwd off</b><p>. Указанная настройка приводит к тому что при входе в указанный раздел сайта будет произведена kerberos-аутентификациия с использованием технологии </p><b>Single Sign-On</b><p>. При неуспешной аутентификации сразу будет ошибка «401 Unautorized». Однако, если изменить настройку на </p><b>KrbMethodK5Passwd on</b><p>, то после неуспешной авторизации </p><b>Single Sign-On</b><p>, будет предпринята попытка авторизации по имени и паролю.
 </p><p>
И еще одна недокументированная возможность, которой мы воспользуемся: Настройка </p><b>KrbLocalUserMapping On</b><p> приводит к тому что в переменной REMOTE_USER будет помещено имя зарегистрированного пользователя (в случае </p><b>KrbLocalUserMapping Off</b><p> REMOTE_USER будет содержать username@COMPANY RU).
</p><p>
Дополнительную информацию по настройкам модуля mod_auth_kerb пожно прочитать </p><a href="http://modauthkerb.sourceforge.net/configure.html">здесь</a><p>.

</p><h5><b>Single Sign-On (SSO) с рабочих станций Windows</b></h5><p>
Еще раз повторюсь, что вся работа по настройке kerberos аутентификации в Linux проделана для того, чтобы иметь возможность входить на страницы портала опубликованного на Linux машине с использованием корпоративных аккаунтов, хранящихся в Active Directory, кроме того для упрощения жизни пользователям этот вход должен быть «прозрачным», без запроса пароля, что достигается иcпользованием технологии Single Sign-On (SSO), которая поддерживается в Windows 7 и выше и браузером Internet Explorer (и Mozilla Firefox).
</p><p>
Однако для того чтобы все проходило гладко, на рабочей станции, откуда осуществляется такой вход, должны быть выполнены следующие настройки:

</p><ol>
<li>Сайт на который осуществляется вход (в нашем случае <b>srv-app.company.ru</b> должен быть внесен в узлы «Местной интрасети» при помощи меню <br/>
Internet Explorer: <b>Сервис -&gt; Свойства обозревателя -&gt; Безопасность -&gt; Местная интрасеть -&gt; Узлы -&gt; Дополнительно</b></li>
<li>В IE должны быть включены следующие опции (как правило они включены «по умолчанию»): <br/>
<ul>
<li><b>Сервис -&gt; Свойства обозревателя -&gt; Дополнительно -&gt; Безопасность -&gt; Разрешить встроенную проверку Windows = ON</b> </li>
<li><b>Сервис -&gt; Свойства обозревателя -&gt; Безопасность -&gt; Местная интрасеть -&gt; Уровень безопасности для этой зоны -&gt; Другой -&gt; Проверка подлинности пользователя -&gt; Автоматический вход в сеть только в зоне интрасети</b></li>
</ul><br/>
</li>
<li>Кроме того, SSO при попытке доступа на сайт по IP-адресу работать не будет. Необходимо обязательно использовать доменное имя srv-app.company.ru !</li>
</ol>
<h3><b>Этап 2. Авторизация пользователя в Django</b></h3><p>
Итак, в результате работы проведенной на первом этапе, мы получили следующие результаты:

</p><ul>
<li>При входе в любой раздел нашего Django-приложения, пользователем, который был авторизован контроллером домена, мы во-первых получаем доступ к нашему Django-приложению, а во-вторых сервер Apache помещает в переменную REMOTE_USER имя авторизованного пользователя, которое совпадает с аттрибутом <b>sAMAccountName</b> этого пользователя в Active Directory.</li>
<li>Если пользователь не авторизован в АД, то Apache вернет нам ошибку «401 Unautorized» (При помощи опции ErrorDocument мы можем в этом случае перенаправить неавторизованного пользователя на какую-либо страницу для гостей)</li>
</ul><p>
Однако, несмотря на то, что сервер Apache авторизовал нашего пользователя, для Django-приложения он все еще остается неизвестным и, соответственно, весь отлаженный в Django механизм аутентификации/авторизации пользователей и использования сессий остается пока незадействованным.

</p><h4><b>Использование RemoteUserBackend</b></h4><p>
Специально для таких целей в Django существует </p><a href="https://docs.djangoproject.com/en/dev/howto/auth-remote-user/">простое решение</a><p>, включающее механизм авторизации в системе пользователей, уже аутентифицированных внешними приложениями, такими как IIS или Apache (способами аналогичными, примененному нами на этапе 1: mod_authnz_ldap, CAS, Cosign, WebAuth, mod_auth_sspi, mod_auth_krb).
</p><p>
Согласно описанию на официальном сайте djangoproject.org, для использования прозрачной аутентификации и авторизации в Django таким способом, достаточно задействовать механизм </p><b>RemoteUserBackend</b><p>, выполнив следующие шаги:
</p><p>
1. В файле настроек Django-проекта settings.py добавить </p><b>django.contrib.auth.middleware.RemoteUserMiddleware</b><p> в список </p><b>MIDDLEWARE_CLASSES</b><p> сразу после </p><b>django.contrib.auth.middleware.AuthenticationMiddleware</b><p>:

</p><pre><code class="django">MIDDLEWARE_CLASSES = [
    '...',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.auth.middleware.RemoteUserMiddleware',
    '...',
]
</code></pre><p>
2. Там же заменить </p><b>ModelBackend</b><p> на </p><b>RemoteUserBackend</b><p> в списке </p><b>AUTHENTICATION_BACKENDS</b><p> (либо добавить этот список в settings.py):

</p><pre><code class="django">AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.RemoteUserBackend',
]
</code></pre><p>
В результате этих изменений </p><b>RemoteUserMiddleware</b><p> будет извлекать username посредством </p><b>request.META['REMOTE_USER']</b><p> и автоматически выполнять аутентификацию и авторизацию (login) этого пользователя при помощи </p><b>RemoteUserBackend</b><p>. Кроме того </p><b>RemoteUserBackend</b><p> при такой авторизации добавит нового пользователя в таблицу auth_user, задействуя таким образом стандартный для Django механизм работы с учетными записями.
</p><p>
Но, к сожалению, этот способ не позволит нам получать из Active Directory и использовать в нашем приложении нужную нам информацию (first_name, last_name, mail, участие в группах AD и др). 

</p><h4><b>Использование django-auth-ldap</b></h4><p>
Итак, нам нужно получить доступ к Active Directory при помощи протокола LDAP. К счастью отличным Django-приложением для этих целей является </p><a href="http://pythonhosted.org/django-auth-ldap/">django-auth-ldap</a><p>. Установить его можно стандартно при помощи pip:

</p><pre><code class="bash">pip install django-auth-ldap
</code></pre><p>
После этого придется удалить из settings.py добавленные в предыдущем разделе </p><b>MIDDLEWARE_CLASSES</b><p>, а именно </p><b>'django.contrib.auth.middleware.RemoteUserMiddleware'</b><p>, а список </p><b>AUTHENTICATION_BACKENDS</b><p> должен выглядеть следующим образом:

</p><pre><code class="django">AUTHENTICATION_BACKENDS = (
    'django_auth_ldap.backend.LDAPBackend',
    'django.contrib.auth.backends.ModelBackend',
)
</code></pre><p>
Кроме того, в settings.py необходимо включить следующие конфигурационные параметры:

</p><div class="spoiler"><b class="spoiler_title">settings.py</b><div class="spoiler_text"><pre><code class="django"># Baseline LDAP configuration.
AUTH_LDAP_SERVER_URI = "ldap://DC-1.COMPANY.ru"
AUTH_LDAP_AUTHORIZE_ALL_USERS = True
AUTH_LDAP_PERMIT_EMPTY_PASSWORD = True

# Логин пользователя от чьего имени будут выполнятся запросы к LDAP (кроме авторизации)
AUTH_LDAP_BIND_DN = "cn=svc-apache,cn=Users,dc=company,dc=ru"
AUTH_LDAP_BIND_PASSWORD = "P@ssw0rd"

# Настройка будет пытаться найти пользователя в созданной нами OU Django и стандартной папке Users, 
# сопоставляя введенный login пользователя с аттрибутами sAMAccountName
AUTH_LDAP_USER_SEARCH = LDAPSearchUnion(
        LDAPSearch("ou=Django,dc=company,dc=ru", ldap.SCOPE_SUBTREE, "(sAMAccountName=%(user)s)"),
        LDAPSearch("cn=Users,dc=company,dc=ru", ldap.SCOPE_SUBTREE, "(sAMAccountName=%(user)s)"),
)

# Set up the basic group parameters.
AUTH_LDAP_GROUP_SEARCH = LDAPSearch("ou=Groups,ou=Django,dc=company,dc=ru",
    ldap.SCOPE_SUBTREE, "(objectClass=groupOfNames)"
)
AUTH_LDAP_GROUP_TYPE = GroupOfNamesType(name_attr="cn")

# Simple group restrictions
# AUTH_LDAP_REQUIRE_GROUP - если определено DN для этой настройки, то требуется присутсвие пользователя в этой группе
# в противном случае пользовталю будет отказано в аутентификации
# таким образом указываем, что для того чтобы пользователь был аутентифицирован он обязан находится в группе "active"
AUTH_LDAP_REQUIRE_GROUP = "cn=active,ou=Groups,ou=Django,dc=company,dc=ru"

# AUTH_LDAP_DENY_GROUP - если определено DN для этой настройки, то в случае члентсва пользователя в этой группе
# ему будет отказано в аутентификации
AUTH_LDAP_DENY_GROUP = "cn=disabled,ou=Groups,ou=Django,dc=company,dc=ru"

# Populate the Django user from the LDAP directory.
# Указываем как переносить данные из AD в стандартный профиль пользователя Django
AUTH_LDAP_USER_ATTR_MAP = {
    "first_name": "givenName",
    "last_name": "sn",
    "email": "mail"
}
# Указываем как переносить данные из AD в расширенный профиль пользователя Django
AUTH_LDAP_PROFILE_ATTR_MAP = {
    "employee_number": "employeeNumber"
}

# Указываем привязку стандартных флагов is_active, is_staff и is_superuser к членству в группах AD
# Флаг is_active при использовании django_remote_auth_ldap сам по себе не оказывает вляния на разрешение аутнтификации
# поэтому для создания обычного поведения Django также определяме настройку AUTH_LDAP_REQUIRE_GROUP (см.выше)
AUTH_LDAP_USER_FLAGS_BY_GROUP = {
    "is_active": "cn=active,ou=Groups,ou=Django,dc=company,dc=ru",
    "is_staff": "cn=staff,ou=Groups,ou=Django,dc=company,dc=ru",
    "is_superuser": "cn=superuser,ou=Groups,ou=Django,dc=company,dc=ru"
}

# Указываем привязку флагов расширенного профиля к членству в группах AD
AUTH_LDAP_PROFILE_FLAGS_BY_GROUP = {
    "is_awesome": "cn=awesome,ou=Groups,ou=Django,dc=company,dc=ru",
}

# This is the default, but I like to be explicit.
AUTH_LDAP_ALWAYS_UPDATE_USER = True

# Use LDAP group membership to calculate group permissions.
AUTH_LDAP_FIND_GROUP_PERMS = True

# Cache group memberships for an hour to minimize LDAP traffic
AUTH_LDAP_CACHE_GROUPS = True
AUTH_LDAP_GROUP_CACHE_TIMEOUT = 3600
</code></pre>
</div></div><p>
Django-auth-ldap — это замечательное приложение. С его помощью в профиль пользователя Django можно загрузить практически любую информацию по нему из AD, даже есть возможность «подтянуть» группы в которых этот пользователь участвует в соответствующую модель Django.
</p><p>
Однако для авторизации при помощи django-auth-ldap все-таки необходимо запрашивать у пользователя его имя и пароль, что нам категорически не подходит. 
</p><p>
Хотя в документации указано что, вроде бы, можно «скрестить» </p><b>django-auth-ldap</b><p> и </p><b>RemoteUserBackend</b><p>:

</p><div class="spoiler"><b class="spoiler_title">Non-LDAP Users</b><p class="spoiler_text">LDAPBackend has one more feature pertaining to permissions, which is the ability to handle authorization for users that it did not authenticate. For example, you might be using RemoteUserBackend to map externally authenticated users to Django users. By setting AUTH_LDAP_AUTHORIZE_ALL_USERS, LDAPBackend will map these users to LDAP users in the normal way in order to provide authorization information. Note that this does not work with AUTH_LDAP_MIRROR_GROUPS; group mirroring is a feature of authentication, not authorization.<br/>
</p></div><p>
Но это не работает, так как нам надо. Пользователь действительно сможет авторизоваться, но это происходит ровно так, как если бы мы просто использовали </p><b>RemoteUserBackend</b><p> (см.предыдущий раздел). Информация из AD в профиль пользователя Django автоматически не загружается. 
</p><p>
Конечно, это можно сделать самостоятельно, воспользовашись следующей рекомендацией:

</p><div class="spoiler"><b class="spoiler_title">Updating Users</b><div class="spoiler_text"><p>By default, all mapped user fields will be updated each time the user logs in. To disable this, set AUTH_LDAP_ALWAYS_UPDATE_USER to False. If you need to populate a user outside of the authentication process—for example, to create associated model objects before the user logs in for the first time—you can call django_auth_ldap.backend.LDAPBackend.populate_user(). You’ll need an instance of LDAPBackend, which you should feel free to create yourself. populate_user() returns the User or None if the user could not be found in LDAP.</p>

<pre><code class="python">from django_auth_ldap.backend import LDAPBackend

user = LDAPBackend().populate_user('alice')
if user is None:
    raise Exception('No user named alice')
</code></pre>
</div></div>
<h4><b>Использование django-remote-auth-ldap</b></h4><p>
Но, как оказалось, все гораздо проще. Велосипед уже придуман, и нам остается только им воспользоватся. Приложение </p><b><a href="https://pypi.python.org/pypi/django-remote-auth-ldap/0.1.0">django-remote-auth-ldap</a></b><p> является небольшой надстройкой над </p><b>django_auth_ldap</b><p> и позволяет без лишних усилий авторизовать пользователя и загрузить его данные из AD во время авторизации.
</p><p>
Устанавливаем </p><b>django-remote-auth-ldap</b><p> стандартно (</p><b>django-auth-ldap</b><p> также необходим для работы этой надстройки):

</p><pre><code class="bash">pip install django-remote-auth-ldap
</code></pre><p>
Далее, необходимо добавить в settings.py следующую настройку:

</p><pre><code class="bash">DRAL_CHECK_DOMAIN = False
</code></pre><p>
Дело в том, что </p><b>django-remote-auth-ldap</b><p>, видимо разработан для работы c IIS, который переменную REMOTE_USER устанавливает в формате «DOMAIN/username», мы же выполнили настройку mod_auth_kerb так, что имя домена в REMOTE_USER не попадает. Указанная выше настройка заставляет </p><b>django-remote-auth-ldap</b><p> считать что в REMOTE_USER только одно имя пользователя без указания домена, т.е. именно так, как нам и нужно.</p><p>
Ну и снова рекомендации для настройки </p><b>MIDDLEWARE_CLASSES</b><p> и </p><b>AUTHENTICATION_BACKENDS</b><p>:
</p><p>
1. В файле настроек Django-проекта settings.py добавить </p><b>django.contrib.auth.middleware.RemoteUserMiddleware</b><p> в список </p><b>MIDDLEWARE_CLASSES</b><p> сразу после </p><b>django.contrib.auth.middleware.AuthenticationMiddleware</b><p>:

</p><pre><code class="django">MIDDLEWARE_CLASSES = [
    '...',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.auth.middleware.RemoteUserMiddleware',
    '...',
]
</code></pre><p>
2. </p><b>AUTHENTICATION_BACKENDS</b><p> должен выглядеть так:

</p><pre><code class="django">AUTHENTICATION_BACKENDS = [
    'django_remote_auth_ldap.backend.RemoteUserLDAPBackend',
]
</code></pre><p>
На этом все, прозрачная аутентификация в Django настроена. 
</p><p>
Если пользователь входящий в ваше Django-приложение, уже авторизован в Active Directory, то:
</p><p>
1. </p><b>Apache</b><p> авторизует его при помощи Kerberos, допустит к страницам вашего приложения и запишет в REMOTE_USER имя авторизованного пользователя.</p><p>
2. </p><b>RemoteUserMiddleware</b><p> «увидит» значение REMOTE_USER и иницирует аутентификацию и авторизацию указанного пользователя в Django с помощью </p><b>django-remote-auth-ldap</b><p>
3. </p><b>django-remote-auth-ldap</b><p> аутентифицирует и авторизует пользователя при помощи методов, унаследованных от приложения </p><b>django-auth-ldap</b><p>, которое «подтянет» в Django необходимую вам информацию из Active Directory.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>