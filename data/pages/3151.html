<html><body><div><div class="entry-content">
                    <p><em>The following is a sample from the new book <a href="/">Effective Python</a>.</em><br/><br/></p>


<p>A common use of metaclasses is to automatically register types in your program. Registration is useful for doing reverse lookups, where you need to map a simple identifier back to a corresponding class.</p>
<p>For example, say you want to implement your own serialized representation of a Python object using <span class="caps">JSON</span>. You need a way to take an object and turn it into a <span class="caps">JSON</span> string. Here I do this generically by defining a base class that records the constructor parameters and turns them into a <span class="caps">JSON</span> dictionary.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Serializable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s">'args'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">})</span>
</pre></div>


<p>This class makes it easy to serialize simple, immutable data structures like <code>Point2D</code> to a string.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">Serializable</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">'Point2D(</span><span class="si">%d</span><span class="s">, </span><span class="si">%d</span><span class="s">)'</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

<span class="n">point</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Object:    '</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Serialized:'</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">serialize</span><span class="p">())</span>
</pre></div>


<div class="highlight"><pre>&gt;&gt;&gt;
Object:     Point2D(5, 3)
Serialized: {"args": [5, 3]}
</pre></div>


<p>Now I need to deserialize this <span class="caps">JSON</span> string and construct the <code>Point2D</code> object it represents. Here I define another class that can deserialize the data from its <code>Serializable</code> parent class.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Deserializable</span><span class="p">(</span><span class="n">Serializable</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">json_data</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">json_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="s">'args'</span><span class="p">])</span>
</pre></div>


<p>Using <code>Deserializable</code> makes it easy to serialize and deserialize simple, immutable objects in a generic way.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">BetterPoint2D</span><span class="p">(</span><span class="n">Deserializable</span><span class="p">):</span>
    <span class="c"># ...</span>

<span class="n">point</span> <span class="o">=</span> <span class="n">BetterPoint2D</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Before:    '</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Serialized:'</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="n">after</span> <span class="o">=</span> <span class="n">BetterPoint2D</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'After:     '</span><span class="p">,</span> <span class="n">after</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre>&gt;&gt;&gt;
Before:     BetterPoint2D(5, 3)
Serialized: {"args": [5, 3]}
After:      BetterPoint2D(5, 3)
</pre></div>


<p>The problem with this approach is it only works if you know the intended type of the serialized data ahead of time (e.g., <code>Point2D</code>, <code>BetterPoint2D</code>). Ideally you’d have a large number of classes serializing to <span class="caps">JSON</span> and one common function that could deserialize any of them back to a corresponding Python object.</p>
<p>To do this, I can include the serialized object’s class name in the <span class="caps">JSON</span> data.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">BetterSerializable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span>
            <span class="s">'class'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
            <span class="s">'args'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span>
        <span class="p">})</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># ...</span>
</pre></div>


<p>Then I can maintain a mapping of class names back to constructors for those objects. The general <code>deserialize</code> function will work for any classes passed to <code>register_class</code>.</p>
<div class="highlight"><pre><span class="n">registry</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">register_class</span><span class="p">(</span><span class="n">target_class</span><span class="p">):</span>
    <span class="n">registry</span><span class="p">[</span><span class="n">target_class</span><span class="o">.</span><span class="n">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_class</span>

<span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s">'class'</span><span class="p">]</span>
    <span class="n">target_class</span> <span class="o">=</span> <span class="n">registry</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">target_class</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="s">'args'</span><span class="p">])</span>
</pre></div>


<p>To ensure <code>deserialize</code> always works properly, I must call <code>register_class</code> for every class I may want to deserialize in the future.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">EvenBetterPoint2D</span><span class="p">(</span><span class="n">BetterSerializable</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

<span class="n">register_class</span><span class="p">(</span><span class="n">EvenBetterPoint2D</span><span class="p">)</span>
</pre></div>


<p>Now I can deserialize an arbitrary <span class="caps">JSON</span> string without having to know which class it contains.</p>
<div class="highlight"><pre><span class="n">point</span> <span class="o">=</span> <span class="n">EvenBetterPoint2D</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Before:    '</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Serialized:'</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="n">after</span> <span class="o">=</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'After:     '</span><span class="p">,</span> <span class="n">after</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre>&gt;&gt;&gt;
Before:     EvenBetterPoint2D(5, 3)
Serialized: {"class": "EvenBetterPoint2D", "args": [5, 3]}
After:      EvenBetterPoint2D(5, 3)
</pre></div>


<p>The problem with this approach is that you can forget to call <code>register_class</code>.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">BetterSerializable</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">z</span>

<span class="c"># Forgot to call register_class! Whoops!</span>
</pre></div>


<p>This will cause your code to break at runtime, when you finally try to deserialize an object of a class you forgot to register.</p>
<div class="highlight"><pre><span class="n">point</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span>
<span class="n">deserialize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>





<p>Even though you chose to subclass <code>BetterSerializable</code>, you won’t actually get all of its features if you forget to call <code>register_class</code> after your <code>class</code> statement body. This approach is error prone and especially challenging for beginners. The same omission can happen with <em>class decorators</em> in Python 3.</p>
<p>What if you could somehow act on the programmer’s intent to use <code>BetterSerializable</code> and ensure <code>register_class</code> is called in all cases? Metaclasses enable this by intercepting the <code>class</code> statement when subclasses are defined. This lets you register the new type immediately after the class’s body.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">class_dict</span><span class="p">):</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">class_dict</span><span class="p">)</span>
        <span class="n">register_class</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls</span>

<span class="k">class</span> <span class="nc">RegisteredSerializable</span><span class="p">(</span><span class="n">BetterSerializable</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>


<p>When I define a subclass of <code>RegisteredSerializable</code>, I can be confident that the call to <code>register_class</code> happened and <code>deserialize</code> will always work as expected.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Vector3D</span><span class="p">(</span><span class="n">RegisteredSerializable</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>

<span class="n">v3</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Before:    '</span><span class="p">,</span> <span class="n">v3</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">v3</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Serialized:'</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'After:     '</span><span class="p">,</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</pre></div>


<div class="highlight"><pre>&gt;&gt;&gt;
Before:     Vector3D(10, -7, 3)
Serialized: {"class": "Vector3D", "args": [10, -7, 3]}
After:      Vector3D(10, -7, 3)
</pre></div>


<p>Using metaclasses for class registration ensures that you’ll never miss a class as long as the inheritance tree is right. This works well for serialization, as I’ve shown, and also applies to Database ORMs, plug-in systems, and system hooks.</p>
<h3>Things to Remember</h3>
<ul>
<li>Class registration is a helpful pattern for building modular Python programs.</li>
<li>Metaclasses let you run registration code automatically each time your base class is subclassed in a program.</li>
<li>Using metaclasses for class registration avoids errors by ensuring that you never miss a registration call.</li>
</ul>
                </div>
            </div></body></html>