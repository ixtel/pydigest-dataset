<html><body><div><div class="post-text" itemprop="text">
<p>There are four strong cases for preferring Python's more-specific methods in the <a href="https://docs.python.org/2/library/os.html"><code>os</code></a> module over using <a href="https://docs.python.org/2/library/os.html#os.system"><code>os.system</code></a> or the <a href="https://docs.python.org/2/library/subprocess.html"><code>subprocess</code></a> module when executing a command:</p>

<ul>
<li><strong>Redundancy</strong> - spawning another process is redundant and wastes time and resources.</li>
<li><strong>Portability</strong> - Many of the methods in the <code>os</code> module are available in multiple platforms while many shell commands are os-specific.</li>
<li><strong>Understanding the results</strong> - Spawning a process to execute arbitrary commands forces you to parse the results from the output and understand <strong>if</strong> and <strong>why</strong> a command has done something wrong.</li>
<li><strong>Safety</strong> - A process can potentially execute any command it's given. This is a weak design and it can be avoided by using specific methods in the <code>os</code> module.</li>
</ul>



<p>You're actually executing a redundant "middle-man" on your way to the eventual system calls (<code>chmod</code> in your example). This middle man is a new process or sub-shell.</p>

<p>From <a href="https://docs.python.org/2/library/os.html#os.system"><code>os.system</code></a>:</p>

<blockquote>
  <p>Execute the command (a string) in a subshell ...</p>
</blockquote>

<p>And <a href="https://docs.python.org/2/library/subprocess.html"><code>subprocess</code></a> is just a module to spawn new processes.</p>

<p>You can do what you need without spawning these processes.</p>



<p>The <a href="https://docs.python.org/2/library/os.html"><code>os</code></a> module's aim is to provide generic operating-system services and it's description starts with:</p>

<blockquote>
  <p>This module provides a portable way of using operating system dependent functionality.</p>
</blockquote>

<p>You can use <a href="https://docs.python.org/2/library/os.html#os.listdir"><code>os.listdir</code></a> on both windows and unix. Trying to use <code>os.system</code> / <code>subprocess</code> for this functionality will force you to maintain two calls (for <code>ls</code> / <code>dir</code>) and check what operating system you're on. This is not as portable and <strong>will</strong> cause even more frustration later on (see <strong>Handling Output</strong>).</p>

<h2>Understanding the command's results:</h2>

<p>Suppose you want to list the files in a directory.</p>

<p>If you're using <code>os.system("ls")</code> / <code>subprocess.call(['ls'])</code>, you can only get the process's output back, which is basically a big string with the file names.</p>

<p>How can you tell a file with a space in it's name from two files?</p>

<p>What if you have no permission to list the files?</p>

<p>How should you map the data to python objects?</p>

<p>These are only off the top of my head, and while there are solutions to these problems - why solve again a problem that was solved for you?</p>

<p>This is an example of following the <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">Don't Repeat Yourself</a> principle (Often reffered to as "DRY") by <strong>not</strong> repeating an implementation that already exists and is freely available for you.</p>

<h2>Safety:</h2>

<p><code>os.system</code> and <code>subprocess</code> are powerful. It's good when you need this power, but it's dangerous when you don't. When you use <code>os.listdir</code>, you <strong>know</strong> it can not do anything else other then list files or raise an error. When you use <code>os.system</code> or <code>subprocess</code> to achieve the same behaviour you can potentially end up doing something you did not mean to do.</p>

<p><strong>Injection Safety (see <a href="http://en.wikipedia.org/wiki/Code_injection#Shell_injection"><em>shell injection examples</em></a>)</strong>:</p>

<p>If you use input from the user as a new command you've basically given him a shell. This is much like SQL injection providing a shell in the DB for the user.</p>

<p>An example would be a command of the form:</p>

<pre><code># ... read some user input
os.system(user_input + " some continutation")
</code></pre>

<p>This can be easily exploited to run <strong>any</strong> arbitrary code using the input: <code>NASTY COMMAND;#</code> to create the eventual:</p>

<pre><code>os.system("NASTY COMMAND; # some continuation")
</code></pre>

<p>There are many such commands that can put your system at risk.</p>
    </div>
    </div></body></html>