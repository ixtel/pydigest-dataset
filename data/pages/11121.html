<html><body><div><article class="markdown-body entry-content" itemprop="text"><h3><a id="user-content-berrl---mapbox-map-output-made-simple-with-python-data-structures" class="anchor" href="#berrl---mapbox-map-output-made-simple-with-python-data-structures" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>berrl - MapBox map output made simple with Python data structures</h3>

<p><a href="https://cloud.githubusercontent.com/assets/10904982/13395720/9b331588-debe-11e5-9b71-cb8d09c8684c.png" target="_blank"><img src="https://cloud.githubusercontent.com/assets/10904982/13395720/9b331588-debe-11e5-9b71-cb8d09c8684c.png" alt=""/></a></p>

<h4><a id="user-content-what-is-it" class="anchor" href="#what-is-it" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>What is it?</h4>

<p>This repository is a combination of 3 repositories I've previously made for geospatial data analysis. These modules I often found myself using in conjuction with one another and figured it would be useful to make an intuitive all in one repository to take full advantage and simplify the work I've already done. The general premise is keep things static enough to where pandas data structures can be integrated in a simple and intuitive manner by making some general assumptions about how the data will be inputted. The main asssumptions being: all geospatial fields will contain 'LAT','LONG', or 'ELEV' for their representive geo fields, and assuming that points and blocks (geohashed squares) can be input in multiples (i.e. each row is 1 element) and that polygons and linestrings are input one element at a time but still in tabular style. </p>

<p>Instead of using functions made for JS and ported to Python I do the reverse making pandas dataframes able to be directly input and parsed correctly into geojson and styled generally how I desire it.By doing this one can put the geospatial analysis on the shoulders of pandas and numpy and put a lot of the hang ups when dealing with geospatial data to the side or at least make them static enough to negate a lot of the confusion. </p>

<p><strong>The result is a more stable, manageable system, that is ready for data to be dealt with in realtime, which pretty cool.</strong></p>

<h5><a id="user-content-realtime-mapping-of-buses-in-la" class="anchor" href="#realtime-mapping-of-buses-in-la" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Realtime mapping of Buses in LA</h5>

<p align="center">
  <a href="https://cloud.githubusercontent.com/assets/10904982/13334258/1edaf6be-dbd9-11e5-9484-2a6aaa17e0db.gif" target="_blank"><img src="https://cloud.githubusercontent.com/assets/10904982/13334258/1edaf6be-dbd9-11e5-9484-2a6aaa17e0db.gif" alt="Realtime Data"/></a>
</p>

<h4><a id="user-content-htmljavascript-side-of-mapping" class="anchor" href="#htmljavascript-side-of-mapping" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>HTML/JavaScript side of mapping?</h4>

<p>Collecting all the geojson locations as you make them and inputting a color field kwarg allows you to style/pipe data into the correct HTML by simply "peaking" into the geojsons fields and outputting the correct HTML for each individual geojson. So essentially by keeping things static we can parse the HTML into working maps pretty easily and reliably. </p>

<p>The 3 modules include:</p>

<ul>
<li><a href="https://github.com/murphy214/pipegeohash">pipegeohash</a> - A table operation for geohashing then a groupby operation at the end (useful for a lot of algorithms and clustering)</li>
<li><a href="https://github.com/murphy214/pipegeojson">pipegeojson</a> - A csv/list/dataframe to geojson parser that uses the assumptions listed above to allow styling from fields in a dataframe column</li>
<li><a href="https://github.com/murphy214/pipehtml">pipehtml</a> - A module that parses the html/JavaScript for all given geojson locations peaking into the geojson to style the pop-up icon in a manner I generally desire</li>
</ul>

<h4><a id="user-content-short-videos-i-think-show-some-cool-features" class="anchor" href="#short-videos-i-think-show-some-cool-features" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Short Videos I think show some cool Features</h4>



<h4><a id="user-content-setup-and-usage-notes" class="anchor" href="#setup-and-usage-notes" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Setup and Usage Notes</h4>

<p>To install berrl in terminial enter:</p>

<pre><code>pip install berrl
</code></pre>

<p>Prereqs include:</p>

<ul>
<li><a href="https://github.com/hkwi/python-geohash">geohash</a> (which I think requires XCode this isn't my module just the one I used for the pipegeohash module)</li>
<li>pandas/numpy</li>
</ul>

<h5><a id="user-content-usage-notes" class="anchor" href="#usage-notes" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Usage Notes</h5>

<p>To use berrl the way its currently implemented I recommend using Safari due to being the easiest to use local http references and on the safari bar navigate to "Develop&gt;Disable Local File Restrictions" to allow for local file references. </p>

<p>As you might have guessed this means you will have to setup a local http server which luckily isn't hard just navigate to the correct directory in terminal that you will be executing your script in and start the HTTP server with the following command in terminal:</p>

<pre><code>python -m SimpleHTTPServer
</code></pre>

<p>Then you should be ready to Map!</p>

<h4><a id="user-content-simple-example-of-berrl" class="anchor" href="#simple-example-of-berrl" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Simple Example of berrl</h4>

<p>Below shows an example of berrl thats is about as simple as I can make it taking a csv file of shark attacks and turning it into geojson parsing and loading the appropriate HTML</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> berrl <span class="pl-k">as</span> bl

apikey<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>your api key<span class="pl-pds">'</span></span>

a<span class="pl-k">=</span>bl.make_points(<span class="pl-s"><span class="pl-pds">'</span>sharks.csv<span class="pl-pds">'</span></span>)
bl.parselist(a,<span class="pl-s"><span class="pl-pds">'</span>sharks.geojson<span class="pl-pds">'</span></span>) <span class="pl-c"># simply writes a list of lines to file name location</span>

bl.loadparsehtml([<span class="pl-s"><span class="pl-pds">'</span>sharks.geojson<span class="pl-pds">'</span></span>],apikey)</pre></div>

<h5><a id="user-content-output-of-map-below" class="anchor" href="#output-of-map-below" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Output of Map Below</h5>

<p><a href="https://cloud.githubusercontent.com/assets/10904982/13379890/e24ec73c-de00-11e5-9ebf-ef7028553d64.png" target="_blank"><img src="https://cloud.githubusercontent.com/assets/10904982/13379890/e24ec73c-de00-11e5-9ebf-ef7028553d64.png" alt=""/></a></p>

<h4><a id="user-content-example-berrl-for-problem-reduction" class="anchor" href="#example-berrl-for-problem-reduction" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Example: Berrl for Problem Reduction</h4>

<p>One of the main annoyances of geospatial data is it can be nasty to work with so many floating points numbers and develop reliable fast algorithms doing so. A common example of a problem like this is getting the occurances of points from a set that occur on a certain route. Here I'll first start by loading the points file and line file to visualize the problem. </p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> berrl <span class="pl-k">as</span> bl
<span class="pl-k">import</span> numpy <span class="pl-k">as</span> np
<span class="pl-k">import</span> pandas <span class="pl-k">as</span> pd

key<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>your api key<span class="pl-pds">'</span></span>

line<span class="pl-k">=</span>pd.read_csv(<span class="pl-s"><span class="pl-pds">'</span>line_example.csv<span class="pl-pds">'</span></span>)
points<span class="pl-k">=</span>pd.read_csv(<span class="pl-s"><span class="pl-pds">'</span>points_example.csv<span class="pl-pds">'</span></span>)

<span class="pl-c"># makes the file if given the kwarg filename for any make function</span>
bl.make_line(line,<span class="pl-v">list</span><span class="pl-k">=</span><span class="pl-c1">True</span>,<span class="pl-v">filename</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>line.geojson<span class="pl-pds">'</span></span>)
bl.make_points(points,<span class="pl-v">list</span><span class="pl-k">=</span><span class="pl-c1">True</span>,<span class="pl-v">filename</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>points.geojson<span class="pl-pds">'</span></span>)

bl.loadparsehtml(bl.collect(),key) <span class="pl-c"># collects all the geojsons that exist in the current directory </span></pre></div>

<h5><a id="user-content-output-of-map-below-1" class="anchor" href="#output-of-map-below-1" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Output of Map Below</h5>

<p><a href="https://cloud.githubusercontent.com/assets/10904982/13375628/e002668e-dd72-11e5-8b12-25191003e906.png" target="_blank"><img src="https://cloud.githubusercontent.com/assets/10904982/13375628/e002668e-dd72-11e5-8b12-25191003e906.png" alt=""/></a></p>

<h5><a id="user-content-turning-the-problem-into-one-were-familiar-with" class="anchor" href="#turning-the-problem-into-one-were-familiar-with" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Turning the Problem into One were familiar with</h5>

<p>The code below shows how just a few steps with map_table() function can turn a problem like this into a simple list comprehension and shows you the blocks were iterating through to help you visualize whats going on. Were sort of windowing through blocks on the line instead of all points to simplify the problem.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> berrl <span class="pl-k">as</span> bl
<span class="pl-k">import</span> numpy <span class="pl-k">as</span> np
<span class="pl-k">import</span> pandas <span class="pl-k">as</span> pd

key<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>your api key<span class="pl-pds">'</span></span>

<span class="pl-c"># reading into memory</span>
points<span class="pl-k">=</span>pd.read_csv(<span class="pl-s"><span class="pl-pds">'</span>points_example.csv<span class="pl-pds">'</span></span>)
line<span class="pl-k">=</span>pd.read_csv(<span class="pl-s"><span class="pl-pds">'</span>line_example.csv<span class="pl-pds">'</span></span>)

<span class="pl-c"># geohashing each table</span>
points<span class="pl-k">=</span>bl.map_table(points,<span class="pl-c1">7</span>,<span class="pl-v">list</span><span class="pl-k">=</span><span class="pl-c1">True</span>)
line<span class="pl-k">=</span>bl.map_table(line,<span class="pl-c1">7</span>,<span class="pl-v">list</span><span class="pl-k">=</span><span class="pl-c1">True</span>)

<span class="pl-c"># getting unique geohashs </span>
uniquepoints<span class="pl-k">=</span>np.unique(points[<span class="pl-s"><span class="pl-pds">'</span>GEOHASH<span class="pl-pds">'</span></span>]).tolist()
uniqueline<span class="pl-k">=</span>np.unique(line[<span class="pl-s"><span class="pl-pds">'</span>GEOHASH<span class="pl-pds">'</span></span>]).tolist()

newpoints<span class="pl-k">=</span>[points.columns.values.tolist()]
<span class="pl-c"># we know if a unique point is in any unique line its on the route</span>
<span class="pl-k">for</span> row <span class="pl-k">in</span> uniquepoints:
    oldrow<span class="pl-k">=</span>row
    <span class="pl-k">for</span> row <span class="pl-k">in</span> uniqueline:
        <span class="pl-k">if</span> row<span class="pl-k">==</span>oldrow:
            temp<span class="pl-k">=</span>points[points.<span class="pl-c1">GEOHASH</span><span class="pl-k">==</span>oldrow]
            temp<span class="pl-k">=</span>bl.df2list(temp)
            newpoints<span class="pl-k">+=</span>temp[<span class="pl-c1">1</span>:] <span class="pl-c"># getting all the points within this geohashs</span>

<span class="pl-c"># making the new points, line, and blocks along line </span>
bl.make_points(newpoints,<span class="pl-v">list</span><span class="pl-k">=</span><span class="pl-c1">True</span>,<span class="pl-v">filename</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>points.geojson<span class="pl-pds">'</span></span>)
bl.make_blocks(<span class="pl-s"><span class="pl-pds">'</span>squares7.csv<span class="pl-pds">'</span></span>,<span class="pl-v">filename</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>blocks_on_line.geojson<span class="pl-pds">'</span></span>)
bl.make_line(line,<span class="pl-v">list</span><span class="pl-k">=</span><span class="pl-c1">True</span>,<span class="pl-v">filename</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>line.geojson<span class="pl-pds">'</span></span>)

<span class="pl-c"># loading html</span>
bl.loadparsehtml(bl.collect(),key)</pre></div>

<h5><a id="user-content-output-of-map-below-2" class="anchor" href="#output-of-map-below-2" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Output of Map Below</h5>

<p><a href="https://cloud.githubusercontent.com/assets/10904982/13375726/680e642c-dd75-11e5-9086-a998ccb48cd9.png" target="_blank"><img src="https://cloud.githubusercontent.com/assets/10904982/13375726/680e642c-dd75-11e5-9086-a998ccb48cd9.png" alt=""/></a></p>

<h5><a id="user-content-view-the-documentation" class="anchor" href="#view-the-documentation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>View the Documentation</h5>

<p><strong>View the Documentation <a href="https://raw.githubusercontent.com/murphy214/berrl/master/documentation.txt">here</a></strong></p>

<h4><a id="user-content-berrls-structure" class="anchor" href="#berrls-structure" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Berrl's Structure</h4>

<p>Berrl's strength is its sparse structure. Berrl has 4 main functions for geojson creation:</p>

<ul>
<li>make_line(table,**kwargs)</li>
<li>make_polygon(table,**kwargs)</li>
<li>make_points(table,<strong>kwargs) **notice the s's!</strong></li>
<li>make_blocks(table,<strong>kwargs) **notice the s's!</strong></li>
</ul>

<p>By default all these make_ functions assume your inputting a csv file, if not and its a list/dataframe input the kwarg "list=True". These functions by default return a list of lines to be written to a geojson file. However if you wish to write out the geojson file on the spot the kwarg for the filename location is "filename" so simply set filename equal to wherever you wish to write out the geojson.</p>

<p>If you understand above and the next sentence you understand berrl: **lines and polygons are assumed to be 1 element per geojson/dataframe, while blocks and points are assumed to represent multiple elements per dataframe/geojson. Generally speaking blocks are usually the output of pipegeohash. </p>

<h5><a id="user-content-pipegeohash" class="anchor" href="#pipegeohash" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Pipegeohash</h5>

<p>Pipegeohash is basically a way of working with vector tile sets most mapping platforms don't want you to have or don't think you would understand.(seriously) This is the foundation for a lot of mapping services and a core component in problem reduction for geospatial algorithms. However its simple in approach and implementation, it is a defined set of hierical squares on earth that can be rounded to the nearest digit and hashed into a unique string. There are 8 tiers each string from of the hash getting 1 character longer each tier and incorporating its parent hash's in all but last digit. Your taking what would be a two dimmensional block of points point numbers and turning it into a single line string representation of that square. By doing this your giving points that had no awareness of neighors around them a field to pivot and group by. </p>

<p>Since I'm not serving any tiles, I don't care what you do. I use this ALL the time. Right now I'm currently tweaking with some cool geofencing algorithms that could completely turn it (geofencing) into a scalable list iteration. My module pipegeohash basically consists of one function map_table(table,precision,kwargs). It does two things a table operation on the input table for geohashing adding a field, then it groupsby geohashs and gets the block points (4 corners) yielding a table with every block in a input and the count each occurence in a block it returns the mapped table and does nothing with squares csv file. More often then not I'll end up using it somewhere down the script.</p>

<p><strong>TL:DR If your doing a lot of decimal distance calculations followed by distance querries try this module out. You could turn a nightmare into a tutorial list comphension</strong></p>

<h5><a id="user-content-pipehtmlpiperealtime" class="anchor" href="#pipehtmlpiperealtime" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Pipehtml/Piperealtime</h5>

<p>Pipehtml/piperealtime have been explained quite extensively the functions however have not.</p>

<ul>
<li>loadparsehtml(geojsons,apikey,**kwargs)

<ul>
<li>geojsons is a list of geojson elements in the current directory to be loaded can also use collect() function</li>
<li>apikey is the mapbox apikey</li>
<li>**colorkey is the field in all dataframes that represents the color to be styled</li>
<li>**file_dictionary dictionary with syntax {filename:color} for all geojsons with a unique style</li>
</ul></li>
<li>loadparsehtmlrealtime(geojsons,apikey,**kwargs)

<ul>
<li>**kwargs can accept time interval to refresh geojsons by default 2 seconds. </li>
</ul></li>
</ul>

<h5><a id="user-content-how-to-use-berrl" class="anchor" href="#how-to-use-berrl" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>How to use Berrl</h5>

<p>Berrl's strength lies more in its simplicity then its complexity. Berrl allows you to make geojson elements, you either collect them in a list or use the collect() function to open up every geojson file in the directory and it automatically parses the JS/HTML so that element features are inserted into the popup window. Berrl also allows for a few more things abstractions from this, for example to style by color for each geojson element you have two options. </p>

<ul>
<li>Insert a column within the dataframe making sure to keep the same column field name for every dataframe then input a colorkey=column header kwarg in parseloadhtml() or parseloadhtmlrealtime() </li>
<li>passing in a dictionary with the <strong>filenames as the key</strong> and the colors as the value to look up, this dictionary doesn't have to be the length of the geojson list it can just be a specific portion of geojsons, the rest will be assumed to be the default (blue) </li>
<li>Colors supported include:

<ul>
<li>light green</li>
<li>blue</li>
<li>red</li>
<li>yellow</li>
<li>light blue</li>
<li>orange</li>
<li>purple</li>
<li>green</li>
<li>brown</li>
<li>pink</li>
<li>default</li>
</ul></li>
</ul>

<p><strong>I reserve the right to use as tacky colors as I please. Eventually more will be added later.</strong></p>

<h5><a id="user-content-implementing-a-cool-map-of-baltimore-911-calls" class="anchor" href="#implementing-a-cool-map-of-baltimore-911-calls" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Implementing a cool map of Baltimore 911 calls</h5>

<p>This csv file was about 1.2 million lines</p>

<p><strong>Due to combined location fields I had to clean this csv file iterating through it once and removing in points lacking lat/long values while I was at it (Normally just plotted at 0,0)</strong></p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> berrl <span class="pl-k">as</span> bl
<span class="pl-k">import</span> numpy <span class="pl-k">as</span> np
<span class="pl-k">import</span> pandas <span class="pl-k">as</span> pd
<span class="pl-k">import</span> itertools

key<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>your api key<span class="pl-pds">'</span></span>
data<span class="pl-k">=</span>bl.read(<span class="pl-s"><span class="pl-pds">'</span>cleaned_baltimore.csv<span class="pl-pds">'</span></span>)

bl.map_table(data,<span class="pl-c1">6</span>,<span class="pl-v">list</span><span class="pl-k">=</span><span class="pl-c1">True</span>)

<span class="pl-c"># reading square table into memory </span>
squares<span class="pl-k">=</span>pd.read_csv(<span class="pl-s"><span class="pl-pds">'</span>squares6.csv<span class="pl-pds">'</span></span>)
maximum<span class="pl-k">=</span>squares[<span class="pl-s"><span class="pl-pds">'</span>COUNT<span class="pl-pds">'</span></span>].max()

factor<span class="pl-k">=</span>maximum<span class="pl-k">/</span><span class="pl-c1">5</span>
oldfactor<span class="pl-k">=</span><span class="pl-c1">0</span>
count<span class="pl-k">=</span><span class="pl-c1">0</span>
factors<span class="pl-k">=</span>[<span class="pl-c1">.5</span><span class="pl-k">*</span>factor,<span class="pl-c1">1.25</span><span class="pl-k">*</span>factor,<span class="pl-c1">1.5</span><span class="pl-k">*</span>factor,<span class="pl-c1">2</span><span class="pl-k">*</span>factor,<span class="pl-c1">2.5</span><span class="pl-k">*</span>factor]
colors<span class="pl-k">=</span>[<span class="pl-s"><span class="pl-pds">'</span>blue<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>light blue<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>light green<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>yellow<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>red<span class="pl-pds">'</span></span>]
<span class="pl-c"># iterating through heat map factors slicing through each one</span>
<span class="pl-k">for</span> a,b <span class="pl-k">in</span> itertools.izip(colors,factors):
    count<span class="pl-k">+=</span><span class="pl-c1">1</span>
    filename<span class="pl-k">=</span><span class="pl-c1">str</span>(count)<span class="pl-k">+</span><span class="pl-s"><span class="pl-pds">'</span>.geojson<span class="pl-pds">'</span></span>
    <span class="pl-k">if</span> oldfactor<span class="pl-k">==</span><span class="pl-c1">0</span>: <span class="pl-c">#starting dictionary off in the beginning </span>
        file_dictionary<span class="pl-k">=</span>{filename:a}
    <span class="pl-k">else</span>:
        <span class="pl-c1">print</span> filename,a,file_dictionary
        file_dictionary[filename]<span class="pl-k">=</span><span class="pl-c1">str</span>(a)
    <span class="pl-k">if</span> factors[<span class="pl-k">-</span><span class="pl-c1">1</span>]<span class="pl-k">==</span>b:
        temp<span class="pl-k">=</span>squares[squares.<span class="pl-c1">COUNT</span><span class="pl-k">&gt;</span>oldfactor]
    <span class="pl-k">else</span>:
        temp<span class="pl-k">=</span>squares[(squares.<span class="pl-c1">COUNT</span><span class="pl-k">&gt;</span>oldfactor)<span class="pl-k">&amp;</span>(squares.<span class="pl-c1">COUNT</span><span class="pl-k">&lt;</span>b)]
    bl.make_blocks(temp,<span class="pl-v">list</span><span class="pl-k">=</span><span class="pl-c1">True</span>,<span class="pl-v">filename</span><span class="pl-k">=</span>filename)
    oldfactor<span class="pl-k">=</span>b

<span class="pl-c">#creating legend to send into html parser</span>
legend<span class="pl-k">=</span>[<span class="pl-s"><span class="pl-pds">'</span>911 Caller Incident Frequency in Baltimore<span class="pl-pds">'</span></span>,colors,factors]

<span class="pl-c1">print</span> file_dictionary
bl.loadparsehtml(bl.collect(),key,<span class="pl-v">legend</span><span class="pl-k">=</span>legend,<span class="pl-v">file_dictionary</span><span class="pl-k">=</span>file_dictionary)</pre></div>

<p><a href="https://cloud.githubusercontent.com/assets/10904982/13390608/7f2d39fc-de9d-11e5-9571-02c1cfab477d.png" target="_blank"><img src="https://cloud.githubusercontent.com/assets/10904982/13390608/7f2d39fc-de9d-11e5-9571-02c1cfab477d.png" alt=""/></a></p>

<h4><a id="user-content-using-the-file_dictionary-kwarg-argument-for-styling" class="anchor" href="#using-the-file_dictionary-kwarg-argument-for-styling" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Using the file_dictionary **Kwarg Argument for Styling</h4>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> berrl <span class="pl-k">as</span> bl
<span class="pl-k">import</span> itertools
key<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>your api key<span class="pl-pds">'</span></span>
<span class="pl-c"># making all geojson</span>
bl.make_points(<span class="pl-s"><span class="pl-pds">'</span>sharks.csv<span class="pl-pds">'</span></span>,<span class="pl-v">filename</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>sharks.geojson<span class="pl-pds">'</span></span>)
bl.make_line(<span class="pl-s"><span class="pl-pds">'</span>line_example.csv<span class="pl-pds">'</span></span>,<span class="pl-v">filename</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>line.geojson<span class="pl-pds">'</span></span>)
bl.make_blocks(<span class="pl-s"><span class="pl-pds">'</span>blocks_example.csv<span class="pl-pds">'</span></span>,<span class="pl-v">filename</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>blocks.geojson<span class="pl-pds">'</span></span>)
bl.make_polygon(<span class="pl-s"><span class="pl-pds">'</span>polygon_example.csv<span class="pl-pds">'</span></span>,<span class="pl-v">filename</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>polygon.geojson<span class="pl-pds">'</span></span>)

<span class="pl-c"># setting up colors list</span>
colors<span class="pl-k">=</span>[<span class="pl-s"><span class="pl-pds">'</span>red<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>green<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>yellow<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>purple<span class="pl-pds">'</span></span>]
count<span class="pl-k">=</span><span class="pl-c1">0</span>
<span class="pl-k">for</span> a,b <span class="pl-k">in</span> itertools.izip(colors,bl.collect()):
    <span class="pl-k">if</span> count<span class="pl-k">==</span><span class="pl-c1">0</span>:
        filecolordict<span class="pl-k">=</span>{b:a} <span class="pl-c"># starting the creating of the dictionary that will import styling into html</span>
        count<span class="pl-k">=</span><span class="pl-c1">1</span>
    <span class="pl-k">else</span>:
        filecolordict[<span class="pl-c1">str</span>(b)]<span class="pl-k">=</span><span class="pl-c1">str</span>(a)
<span class="pl-c1">print</span> filecolordict
bl.loadparsehtml(bl.collect(),key,<span class="pl-v">file_dictionary</span><span class="pl-k">=</span>filecolordict)</pre></div>

<p><strong>Output of the styled map below using the file_dictionary argument</strong>
<a href="https://cloud.githubusercontent.com/assets/10904982/13392789/2602bdee-deab-11e5-89ae-6590a904ff7e.png" target="_blank"><img src="https://cloud.githubusercontent.com/assets/10904982/13392789/2602bdee-deab-11e5-89ae-6590a904ff7e.png" alt=""/></a></p>

<h4><a id="user-content-styling-a-series-of-line-segments-randomly" class="anchor" href="#styling-a-series-of-line-segments-randomly" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Styling a Series of Line Segments Randomly</h4>

<p>The final example I'll do is to show how you could do directory operation on entire sets of data representing a layer or in this case a road network and make the process more intuitive for styling then most mapping services I've seen. (in code at least) The issue is most services or other frameworks like to use Classes or Objects for their apis making them limited to the extent and thats my antithesis, from how I've seen a lot of modules implemented classes rarely increase code complexity while being inherently hard to understand, decreasing comprhension while increasing complexity. A function everyone understands, theres no room for intereptation or assumptions hopefully my use of this functions has made documentation and familiarization with berrl easier. Good luck!!</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> pandas <span class="pl-k">as</span> pd
<span class="pl-k">import</span> numpy <span class="pl-k">as</span> np
<span class="pl-k">import</span> berrl <span class="pl-k">as</span> bl
<span class="pl-k">import</span> itertools
<span class="pl-k">import</span> random
key<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>pk.eyJ1IjoibXVycGh5MjE0IiwiYSI6ImNpam5kb3puZzAwZ2l0aG01ZW1uMTRjbnoifQ.5Znb4MArp7v3Wwrn6WFE6A<span class="pl-pds">'</span></span>

<span class="pl-c"># random colors put into the dictionary </span>
colors<span class="pl-k">=</span>[<span class="pl-s"><span class="pl-pds">'</span>light green<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>blue<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>red<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>yellow<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>light blue<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>orange<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>purple<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>green<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>brown<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>pink<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>default<span class="pl-pds">'</span></span>]
count<span class="pl-k">=</span><span class="pl-c1">0</span>
csvfiles<span class="pl-k">=</span>bl.get_filetype(<span class="pl-s"><span class="pl-pds">'</span>csvs<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>csv<span class="pl-pds">'</span></span>) <span class="pl-c"># getting all the csv files with the csv folder</span>
<span class="pl-k">for</span> row <span class="pl-k">in</span> csvfiles:
    <span class="pl-k">if</span> count<span class="pl-k">==</span><span class="pl-c1">0</span>:
        count<span class="pl-k">+=</span><span class="pl-c1">1</span>
        filename<span class="pl-k">=</span><span class="pl-c1">str</span>(count)<span class="pl-k">+</span><span class="pl-s"><span class="pl-pds">'</span>.geojson<span class="pl-pds">'</span></span>
        bl.make_line(row,<span class="pl-v">filename</span><span class="pl-k">=</span>filename)
        color<span class="pl-k">=</span>colors[random.randint(<span class="pl-c1">0</span>,<span class="pl-c1">len</span>(colors)<span class="pl-k">-</span><span class="pl-c1">1</span>)]
        file_dictionary<span class="pl-k">=</span>{filename:color}
    <span class="pl-k">else</span>:
        count<span class="pl-k">+=</span><span class="pl-c1">1</span>
        filename<span class="pl-k">=</span><span class="pl-c1">str</span>(count)<span class="pl-k">+</span><span class="pl-s"><span class="pl-pds">'</span>.geojson<span class="pl-pds">'</span></span>
        bl.make_line(row,<span class="pl-v">filename</span><span class="pl-k">=</span>filename)
        color<span class="pl-k">=</span>colors[random.randint(<span class="pl-c1">0</span>,<span class="pl-c1">len</span>(colors)<span class="pl-k">-</span><span class="pl-c1">1</span>)]
        file_dictionary[filename]<span class="pl-k">=</span>color

<span class="pl-c1">print</span> file_dictionary
bl.loadparsehtml(bl.collect(),key,<span class="pl-v">file_dictionary</span><span class="pl-k">=</span>file_dictionary)</pre></div>

<p><strong>Below shows the a line string network making the coal fields more colorful!</strong>
<a href="https://cloud.githubusercontent.com/assets/10904982/13400697/f9a73aaa-ded6-11e5-922a-b83efe5561a8.png" target="_blank"><img src="https://cloud.githubusercontent.com/assets/10904982/13400697/f9a73aaa-ded6-11e5-922a-b83efe5561a8.png" alt=""/></a></p>
</article>
  </div></body></html>