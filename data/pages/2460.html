<html><body><div><div class="clearfix"><p><img src="/images/blog/python-logo.png" title="Python Logo" alt="Python Logo"/></p>

<p>You know what’s really lame?  <em>Slow websites.</em></p>

<p>Unfortunately, certain parts of the authentication process are <em>supposed</em> to
be slow.  This may seem counterintuitive, but slowness in the authentication
process is a big part of being secure.</p>

<p>This article talks about how authentication works in Python
(<em>not just hashing</em>), and how you can make your site faster for your users
without compromising your security.</p>

<p>I’ll walk you through Python pseudocode, and show you exactly what you need to
understand to ensure your auth system is as quick as possible.</p>




<p/>

<h2>Password Hashing is Slow</h2>

<p>When a user signs up on your website, and gives you their password — the best
practice is to <em>hash</em> the user’s password before storage.  This means you’ll use
a hashing algorithm like <a href="https://pypi.python.org/pypi/bcrypt/" title="python bcrypt">bcrypt</a> or <a href="https://pypi.python.org/pypi/scrypt/" title="python scrypt">scrypt</a> which translates a password
string into a bunk of gibberish that cannot be <em>reversed</em>.</p>

<p>Once you have a hash, there’s no way to recover the original password.</p>

<p>Here’s the important bit: strong hashing functions like bcrypt and scrypt are
<em>meant to be slow</em>!</p>

<p>The more CPU, RAM, and time required to compute a hash means an attacker will
need to spend that much longer attempting to brute for a password.</p>

<p>Pretend for a moment, that you’ve hacked a company user database and now have
access to all user password hashes.</p>

<p>Let’s also say that these are bcrypt 10 hashes.</p>

<p>If you’re trying to figure out what the password are, there’s only one thing for
you to do: brute force them.</p>

<p>To do this, you might write some code that iterates over every possible
password combination (<em>in the example below I’m using the <a href="https://github.com/rdegges/brute" title="brute on Github">brute</a> library on
PyPI</em>):</p>

<pre><code>$ pip install brute

# crack.py
from brute import brute

HASH_TO_CRACK = 'xxx'

for pw in brute(length=8):
    if HASH_TO_CRACK == bcrypt(pw):
        print 'Password is:', pw
        break
</code></pre>

<p>In the example above, we’ll iterate over every possible password of 8 characters
and less, attempting to brute force it.</p>

<p>Each time you generate a new possible password, you’d then run it through the
<code>bcrypt</code> function, get the resulting hash, and compare it to the hacked password
hash you have.  If you get a match, it means you’ve successfully brute forced
the user’s password!</p>

<p>But here’s the kicker: bcrypt and scrypt take a while to compute, and use a lot
of resources.</p>

<p>Since both bcrypt and scrypt are mathematically slow to compute, attackers have
a much harder time brute forcing these hashes as it requires a lot of computer
resources (<em>$$$</em>).</p>

<p>So, since we now understand how hashing works, and why it is time intensive —
let’s talk about authentication.</p>

<p><strong>NOTE</strong>: If you’re interested in learning more about password security, you
might want to read through an article we wrote a while back on
<a href="https://stormpath.com/blog/password-security-right-way/" title="The Right Way to do Password Security">the right way to do password security</a> — it’s a good read.  And if you want
<em>even more</em> info, check <a href="https://stormpath.com/blog/5-myths-password-security/" title="5 Myths of Password Security">this out</a>.</p>

<h2>How Authentication Works</h2>

<p>When a user typically registers or signs into a site, you’re going to be hashing
their password, and either storing it in a database or comparing it to a value
in a database — but what happens after that?  You remember the user either with
an ID in a session, or via an API key of some sort.</p>

<p>Here’s some pseudocode:</p>

<pre><code># register.py
user = User('r@rdegges.com', 'hithere!123')
user.save()     # save this user to the database

# Create a new session cookie in the browser, which holds the user ID.
session.create('session', user.id)
</code></pre>

<p>The idea is that a user ID will be stored in the user’s browser via cookies —
this way, the next time the user requests a page on your site, the user’s
browser will send that cookie with the user’s ID along to your server, allowing
you to look up this user’s account information, without needing the email
address and password again.</p>

<p>Here’s some more pseudocode:</p>

<pre><code># views.py
user = User.find(id=session)
</code></pre>

<p>As you can imagine — finding a user account by ID is very quick (<em>no password
hashing is necessary</em>).</p>

<p>So — what this means is that only the initial user creation and login processes
are slow — the rest of your site can still be fast!</p>

<p>But let’s not stop just yet.</p>

<h2>Optimizing for Speed</h2>

<p>Since user data is typically required on every page of a website, this data is
accessed very frequently.</p>

<p>If you’re using a database like <a href="http://www.postgresql.org/" title="Postgres">Postgres</a> or <a href="http://www.mysql.com/" title="MySQL">MySQL</a>, this means that if
you have a few hundred website users, you might be querying your <code>users</code> table
in the database a couple hundred times per second.</p>

<p>That’s quite a few queries!</p>

<p>If your site needs to do other things, you might be unnecessarily slowing down
page loads.</p>

<p>So what can you do to speed things up?  <strong>Cache!</strong></p>

<p>Caching is the solution to most speed and performance problems — and making
user data quickly available is one of the most effective ways to speed up your
site.</p>

<p>The idea is pretty simple: keep a key / value store in memory that consists of
a user ID for the key, and the user’s account data as the hash.</p>

<p>This helps, because the next time a user makes a request for a page on your
site, and sends you their session cookie, instead of querying the database to
find the account, you can instead query an in-memory cache directly for this
information.</p>

<p>This might be the difference between 1ms and 100+ms in <em>every user request</em>:
that’s a lot of saved time!  While it doesn’t seem like much on it’s own, when
you start adding in latency caused by other parts of your application, you can
really speed things up a lot overall.</p>

<p>For caching, you’ll most likely want to store this data in a cache system like
<a href="http://memcached.org/" title="memcached">memcached</a> or <a href="http://redis.io/" title="redis">redis</a>, both of which have awesome python libraries.</p>

<p>In pseudocode, you’ll likely do something like this:</p>

<pre><code>if session:
    user = cache.get(session)

    # If no user was found in the cache, try querying the database directly.
    if not user:
        user = User.get(id=session)
</code></pre>

<h2>Implementation</h2>

<p>If you’re using a web framework like <a href="https://www.djangoproject.com/" title="Django">Django</a>, you can really easily do all of
the things mentioned in this article by simply using the built-in auth system.</p>

<p>If you’re using another framework / tool, you might want to google around for
libraries — there are typically a few good options to help with this stuff
regardless of what tooling you’re using.</p>

<p>Lastly, if you’re using Python / Flask / Django, and want to get all the
awesomeness of best practices around user storage and security, you might want
to check out our developer service: <a href="https://stormpath.com/" title="Stormpath">Stormpath</a>.</p>

<p>Our service stores user accounts and user data for you, taking care of password
hashing, encryption, data security, best practices, and everything else.</p>

<p>It’s free to use for most applications, and integrates easily into Python,
Flask, and Django apps.</p>

<p>The latest release of our Python library includes built-in support in-memory,
memcached, and redis caching to ensure your site is ALWAYS as fast as possible,
out of the box.</p>

<p>If you’d like to get started with Stormpath, you can check out our libraries
here:</p>




<p>To learn more about what Stormpath is doing for password security, check out
our <a href="https://stormpath.com/product/password_security/" title="Stormpath Password Security">security page</a>.</p>
</div>



            </div></body></html>