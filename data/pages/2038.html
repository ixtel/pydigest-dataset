<html><body><div><div class="ibm-col-1-1">

<p>OpenStack – это непрерывно развивающееся решение с открытым исходным кодом для развертывания облачной IaaS-инфраструктуры. OpenStack поставляется с Web-панелью для выполнения задач в ручном режиме (например, запуск отдельных экземпляров виртуальных машин), но если вы хотите автоматизировать задачи, вам придется писать сценарии для управления OpenStack.</p><p>Многие пользователи пишут сценарии автоматизации, используя REST-интерфейс OpenStack или сценарии командной оболочки, вызывающие утилиты командной строки (например, <code>keystone</code> или <code>nova</code>). Но лучше писать сценарии автоматизации OpenStack на языке Python. Все сервисы OpenStack имеют нативные интерфейсы Python, предоставляющие набор функций, аналогичных утилитам командной строки. К сожалению, документации по этим интерфейсам не так много.</p><p>Для программистов на Python работать с интерфейсами Python намного проще, чем с утилитами командной строки или REST-интерфейсами. В данной статье я продемонстрирую использование нативных Python-интерфейсов OpenStack для автоматизации повторяющихся пользовательских и административных задач.</p><h2 id="projects-and-codenames">Проекты OpenStack и кодовые имена</h2><p><em>OpenStack</em> не является одиночным приложением. Скорее это набор сервисов, совместная работа которых обеспечивает функционирование IaaS-облака. (В боковой вкладке <a href="#services">Сервисы OpenStack</a> определяется значение термина "сервис" для нашего случая.) Каждый сервис OpenStack имеет официальное имя и кодовое имя.</p><h5 id="table1">Таблица 1. Сервисы OpenStack и кодовые имена</h5><table border="0" cellpadding="0" cellspacing="0" class="ibm-data-table" summary="2 column table with headings"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th scope="col">Официальное имя</th><th scope="col">Кодовое имя</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td>Identity Service</td><td><code>keystone</code></td></tr><tr><td>Image Service</td><td><code>glance</code></td></tr><tr><td>Compute Service</td><td><code>nova</code></td></tr><tr><td>Networking Service</td><td><code>quantum</code></td></tr><tr><td>Block Storage Service</td><td><code>cinder</code></td></tr><tr><td>Object Storage Service</td><td><code>swift</code></td></tr></tbody></table><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="installing_bindings">Установка связываний Python</h2><p>У каждого сервиса есть утилиты командной строки, к которым прилагаются связывания для Python. Фактически каждая утилита командной строки реализуется с использованием соответствующего программного интерфейса Python. Каждую утилиту можно установить из каталога пакетов Python (Python Package Index или PyPi – см. раздел <a href="#resources">Ресурсы</a>) с помощью <code>pip</code> – менеджера пакетов Python. Имена <code>pip</code>-пакетов:</p><ul class="ibm-bullet-list"><li><code>python-keystoneclient</code></li><li><code>python-glanceclient</code></li><li><code>python-novaclient</code></li><li><code>python-quantumclient</code></li><li><code>python-cinderclient</code></li><li><code>python-swiftclient</code></li></ul><p>Например, для установки клиента keystone нужно выполнить следующую команду:</p><div class="codesection"><pre class="displaycode">$ pip install python-keystoneclient</pre></div><p>Эти пакеты устанавливаются в виртуальную среду Python (virtualenv) или в общесистемные библиотеки Python (system-wide), если у вас есть полномочия root на вашей локальной машине.</p><p>Все программные интерфейсы OpenStack имеют поддержку разные версии, поэтому связывания для Python поддерживают несколько версий интерфейсов для обеспечения обратной совместимости. В связи с этим лучше всего загружать последние версии пакетов, поскольку они будут работать со всеми прежними версиями сервисов OpenStack.</p><p>В данной статье мы сосредоточимся на примерах интерфейсов Python следующих сервисов:</p><ul class="ibm-bullet-list"><li>OpenStack Identity Service (<code>keystone</code>)</li><li>OpenStack Image Service (<code>glance</code>)</li><li>OpenStack Compute Service (<code>nova</code>)</li></ul><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="test-env">Установка среды тестирования</h2><p>Для полного изучения представленного в статье материала рекомендуется получить доступ к облаку OpenStack с правами администратора, чтобы иметь возможность запускать фрагменты кода. Если у вас нет административного доступа к облаку OpenStack, просто разверните OpenStack на виртуальной машине. Проект DevStack (см. раздел <a href="#resources">Ресурсы</a>) позволяет создать ориентированный на разработку экземпляр OpenStack на одной машине. С помощью инструмента виртуализации (например, VirtualBox) можно реализовать облако OpenStack на ноутбуке (даже с операционной системой Mac или Windows®).</p><p>Также можно бесплатно зарегистрироваться в TryStack – песочнице сообщества OpenStack (см. раздел <a href="#resources">Ресурсы</a>). Обратите внимание, что в TryStack можно получить только полномочия пользователя, а не администратора, поэтому вы не сможете использовать TryStack для тестирования сценариев, требующих административных полномочий.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="keystone">Сервис OpenStack Identity (keystone)</h2><p>Клиент выполняет запросы к интерфейсу Identity (<code>keystone</code>), создавая соответствующий объект keystone клиента Python и вызывая его методы. Поскольку эти интерфейсы имеют разные версии, клиенты Python всегда связываются с конкретной версией интерфейса.</p><p>В листинге 1 показан пример использования клиента <code>keystone</code> версии 2.0 для добавления сервиса Image Service в каталог сервисов.</p><h5 id="list1">Листинг 1. Создание роли администратора с помощью keystone</h5><div class="codesection"><pre class="displaycode">import keystoneclient.v2_0.client as ksclient
# Заменяем аргументы метода аргументами локальной конфигурации
keystone = ksclient.Client(auth_url="http://192.168.27.100:35357/v2.0",
                           username="admin",
                           password="devstack",
                           tenant_name="demo")
glance_service = keystone.services.create(name="glance",
                            service_type="image",
                            description="OpenStack Image Service")</pre></div><h3 id="auth">Учетные данные</h3><p>При создании объекта <code>keystoneclient.v2_0.client.Client</code> необходимо задать учетные данные. Оконечная точка <code>keystone</code> принимает два вида учетных данных: маркер или имя пользователя и пароль. Администратор может использовать специальный маркер <code>admin</code> с полномочиями администратора и неограниченным сроком действия. Этот маркер определяется с помощью конфигурационного параметра <code>admin_token</code> в файле /etc/keystone/keystone.conf на машине, где выполняется сервис <code>keystone</code> (см. листинг 2).</p><h5 id="list2">Листинг 2. Аутентификация с помощью маркера</h5><div class="codesection"><pre class="displaycode">import keystoneclient.v2_0.client as ksclient

# Заменяем значения значениями для локальной конфигурации
endpoint = "http://192.168.27.100:35357/v2.0"
admin_token = "devstack"

keystone = ksclient.Client(endpoint=endpoint, token=admin_token)</pre></div><p>По соображениям безопасности использование маркера <code>admin</code>, как правило, не приветствуется. Разработчики OpenStack Identity настоятельно рекомендуют создавать пользователя с полномочиями администратора и использовать для аутентификации имя пользователя и пароль этого пользователя.</p><h5 id="list3">Листинг 3. Аутентификация с помощью имени пользователя и пароля</h5><div class="codesection"><pre class="displaycode">import keystoneclient.v2_0.client as ksclient

#  Заменяем значения значениями для локальной конфигурации
auth_url = "http://192.168.27.100:35357/v2.0"
username = "admin"
password = "devstack"
tenant_name = "demo"

keystone = ksclient.Client(auth_url=auth_url, username=username,
                           password=password, tenant_name=tenant_name)</pre></div><h3 id="openrc">Загрузка файла OpenRC</h3><p>Для упрощения аутентификации я рекомендую создать файл openrc, который экспортирует учетные данные для переменных среды. Это позволяет избежать жесткого кодирования учетных данных в сценариях. В листинге 4 показан пример файла openrc.</p><h5 id="list4">Листинг 4. Загрузка учетных данных из переменных среды</h5><div class="codesection"><pre class="displaycode">export OS_USERNAME="myname"
export OS_PASSWORD="mypassword"
export OS_TENANT_NAME="mytenant"
export OS_AUTH_URL="http://10.20.0.2:5000/v2.0/"</pre></div><p>Переменные среды OS_USERNAME, OS_PASSWORD, OS_TENANT_NAME и OS_AUTH_URL являются стандартными для всех утилит командной строки Python. Если переменные среды установлены, утилиты командной строки (<code>keystone</code>, <code>nova</code>) будут использовать их для аутентификации в оконечных точках интерфейса.</p><p>Загрузите переменные среды в вашу командную оболочку с помощью встроенной Bash-команды <code>source</code>. Если в качестве стандартной командной оболочки используется Bash, можно добавить в .profile приведенную ниже строку, чтобы переменные среды автоматически устанавливались при каждом входе:</p><p>Помимо файла openrc, сценарии Python могут извлекать учетные данные из среды. Давайте создадим файл credentials.py (см. листинг 5), который извлекает учетные данные из среды. Обратите внимание, что <code>keystone</code> и <code>nova</code> используют в методах инициализатора клиента немного различающиеся имена переменных, поэтому я определил отдельную функцию для каждого.</p><h5 id="list5">Листинг 5. Файл credentials.py</h5><div class="codesection"><pre class="displaycode">#!/usr/bin/env python
import os

def get_keystone_creds():
    d = {}
    d['username'] = os.environ['OS_USERNAME']
    d['password'] = os.environ['OS_PASSWORD']
    d['auth_url'] = os.environ['OS_AUTH_URL']
    d['tenant_name'] = os.environ['OS_TENANT_NAME']
    return d

def get_nova_creds():
    d = {}
    d['username'] = os.environ['OS_USERNAME']
    d['api_key'] = os.environ['OS_PASSWORD']
    d['auth_url'] = os.environ['OS_AUTH_URL']
    d['project_id'] = os.environ['OS_TENANT_NAME']
    return d</pre></div><h3 id="tokens">Маркеры аутентификации</h3><p>Если инициализатор клиента не возвращает исключительное состояние, значит, он успешно прошел аутентификацию в оконечной точке. К созданному маркеру <code>keystone</code> можно обратиться с помощью атрибута <code>auth_token</code> возвращенного объекта (см. листинг 6). При аутентификации в интерфейсе <code>glance</code> необходимо явно передать маркер аутентификации <code>keystone</code> в качестве аргумента инициализатора, о чем пойдет речь ниже.</p><h5 id="list6">Листинг 6. Успешная аутентификация в оконечной точке keystone в интерактивном сеансе Python</h5><div class="codesection"><pre class="displaycode">&gt; import keystoneclient.v2_0.client as ksclient
&gt; from credentials import get_keystone_creds
&gt; creds = get_keystone_creds()
&gt; keystone = ksclient.Client(**creds)
&gt; keystone.auth_token
u'MIILkAYJKoZIhvcNAQcCoIILgTCCC30CAQExCTAHBgUrDgMCGjCCCmkGCSqGSIb3DQEHAaCCCloE
ggpWeyJhY2Nlc3MiOiB7InRva2VuIjogeyJpc3N1ZWRfYXQiOiAiMjAxMy0wNS0yNlQwMjoxMjo0Mi
42MDAwMjUiLCAiZXhwaXJlcyI6ICIyMDEzLTA1LTI3VDAyOjEyOjQyWiIsICJpZCI6ICJwbGFjZWhv
bGRlciIsICJ0ZW5hbnQiOiB7ImRlc2NyaXB0aW9uIjogbnVsbCwgImVuYWJsZWQiOiB0cnVlLCAiaW
...
fI9JnOBZJwuoma8je0a1AvLff6AcJ1zFkVZGb'</pre></div><p><strong>Примечание</strong>. Версия Grizzly сервиса OpenStack Identity по умолчанию использует маркеры Public Key Infrastructure, которые намного длиннее маркеров Universally Unique Identifier (например, 7d9fde355f09458f8e97986a5a652bfe), использовавшихся в предыдущих версиях OpenStack.</p><h3 id="crud">Операции CRUD</h3><p>По существу, программный интерфейс <code>keystone</code> – это интерфейс создания (create), чтения (read), изменения (update) и удаления (delete): большинство взаимодействий с интерфейсом <code>keystone</code> служит для чтения или модификации данных серверной базы данных <code>keystone</code>. Большинство взаимодействий интерфейса осуществляется с помощью вызовов объектов <code>Manager</code>. Объект <code>Manager</code> представляет коллекцию объектов одного типа. Например, <code>UserManager</code> управляет пользователями <code>keystone</code>, <code>TenantManager</code> управляет арендаторами, <code>RoleManager</code> управляет ролями и т.д. Объекты <code>Manager</code> поддерживают операции <code>create</code> (создание нового объекта), <code>get</code> (извлечение объекта по идентификатору), <code>list</code> (извлечение всех объектов) и <code>delete</code> (удаление).</p><h3 id="users-tenants-roles">Создание пользователей, арендаторов и ролей</h3><p>Как правило, при развертывании OpenStack одной из первых задач является создание арендатора <code>keystone</code>, а затем пользователя <code>keystone</code> с административными полномочиями. В <a href="#list7">листинге 7</a> показан пример автоматизации этого процесса с использованием программного интерфейса Python. Этот сценарий выполняет следующие задачи:</p><ul class="ibm-bullet-list"><li>Создание роли пользователя (<code>Client.roles.create</code>).</li><li>Создание роли администратора (<code>Client.roles.create</code>).</li><li>Создание арендатора с именем acme (<code>Client.tenants.create</code>).</li><li>Создание пользователя с именем admin (<code>Client.users.create</code>).</li><li>Назначение пользователя admin роли admin арендатору acme (<code>Client.roles.add_user_role</code>).</li></ul><p>Этот сценарий подходит для использования маркера <code>admin</code>, поскольку в Identity Service еще нет пользователей с административными полномочиями.</p><h5 id="list7">Листинг 7. Создание пользователя, арендатора и роли</h5><div class="codesection"><pre class="displaycode">import keystoneclient.v2_0.client as ksclient
endpoint = "http://192.168.27.100:35357/v2.0"
admin_token = "devstack"

keystone = ksclient.Client(endpoint=endpoint, token=admin_token)
user_role = keystone.roles.create("user")
admin_role = keystone.roles.create("admin")
acme_tenant = keystone.tenants.create(tenant_name="Acme",
                        description="Employees of Acme Corp.",
                        enabled=True)
admin_user = keystone.users.create(name="admin",
                password="a.G'03134!j",
                email="cloudmaster@example.com", tenant_id=acme_tenant.id)
keystone.roles.add_user_role(admin_user, admin_role, acme_tenant)</pre></div><h3 id="services-endpoints">Создание сервисов и оконечных точек</h3><p>Обычно следующей задачей развертывания Identity Service в облаке OpenStack является добавление в <code>keystone</code> сервисов облака и оконечных точек. В листинге 8 показан пример добавления сервиса и оконечной точки для Identity Service с помощью методов <code>Client.services.create</code> и <code>Client.endpoints.create</code>.</p><h5 id="list8">Листинг 8. Создание сервиса и оконечной точки</h5><div class="codesection"><pre class="displaycode">import keystoneclient.v2_0.client as ksclient
creds = get_keystone_creds() # See <a href="openrc-creds">xxx</a>
keystone = ksclient.Client(**creds)
service = keystone.services.create(name="keystone",
                                   service_type="identity",
                                   description="OpenStack Identity Service")

keystone_publicurl = "http://192.168.27.100:5000/v2.0"
keystone_adminurl = "http://192.168.27.100:35357/v2.0"
keystone.endpoints.create(service_id=service.id,
                          region="Northeast",
                          publicurl=keystone_publicurl,
                          adminurl=keystone_adminurl,
                          internalurl=keystone_publicurl)</pre></div><h3 id="accessing-endpoints">Доступ к каталогу сервисов</h3><p>Одной из основных функций <code>keystone</code> является обслуживание каталога сервисов. Клиенты могут использовать <code>keystone</code> для поиска URL-адреса оконечной точки сервиса OpenStack. Этот интерфейс предоставляет данную функциональность с помощью метода <code>keystoneclient.v2_0.client.Client.service_catalog.url_for</code>. Он позволяет искать оконечную точку по типу сервиса (image, volume, compute, network) и по типу оконечной точки (<code>publicURL</code>, <code>internalURL</code>, <code>adminURL</code>).</p><p>В листинге 9 показано использование метода <code>url_for</code> для извлечения оконечной точки сервиса OpenStack Image (<code>glance</code>).</p><h5 id="list9">Листинг 9. Запрос оконечной точки glance в интерактивном сеансе Python</h5><div class="codesection"><pre class="displaycode">&gt; import keystoneclient.v2_0.client as ksclient
&gt; creds = get_keystone_creds() # See &lt;a href="openrc-creds" /&gt;
&gt; keystone = ksclient.Client(**creds)
&gt; glance_endpoint = keystone.service_catalog.url_for(service_type='image',
                                                       endpoint_type='publicURL')
&gt; glance_endpoint
u'http://192.168.27.100:9292'</pre></div><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="nova">OpenStack Compute (nova)</h2><p>Программный интерфейс OpenStack Compute (<code>nova</code>) работает аналогично интерфейсу OpenStack Identity. В статье используется интерфейс <code>nova</code> версии 1.1, поэтому классы Python-связываний <code>nova</code> версии 1.1 находятся в пространстве имен <code>novaclient.v1_1</code>.</p><h3 id="auth-against-api">Аутентификация в оконечной точке nova-api</h3><p>Запросы к оконечной точке <code>nova-ap</code> можно выполнять с помощью вызовов объекта <code>novaclient.v1_1.client.Client</code>. Извлечение клиента, взаимодействующего с интерфейсом версии 1.1, можно выполнить двумя способами. В листинге 10 показано извлечение соответствующего клиента путем передачи в качестве аргумента номера версии в виде строки.</p><h5 id="list10">Листинг 10. Передача версии в качестве аргумента</h5><div class="codesection"><pre class="displaycode">from novaclient import client as novaclient
from credentials import get_nova_creds
creds = get_nova_creds()
nova = novaclient.Client("1.1", **creds)</pre></div><p>В листинге 11 показано извлечение соответствующего клиента путем непосредственного импорта модуля версии 1.1.</p><h5 id="list11">Листинг 11. Непосредственный импорт версии</h5><div class="codesection"><pre class="displaycode">import novaclient.v1_1.client as nvclient
from credentials import get_nova_creds
creds = get_nova_creds()
nova = nvclient.Client(**creds)</pre></div><h3 id="listing_instances">Получение списка экземпляров виртуальных машин</h3><p>Для получения списка экземпляров виртуальных машин используется метод <code>Client.servers.list</code> (см. листинг 12).</p><h5 id="list12">Листинг 12. Извлечение списка экземпляров виртуальных машин в интерактивном сеансе Python</h5><div class="codesection"><pre class="displaycode">&gt; import novaclient.v1_1.client as nvclient
&gt; from credentials import get_nova_creds
&gt; creds = get_nova_creds()
&gt; nova = nvclient.Client(**creds)
&gt; nova.servers.list()
[&lt;Server: cirros&gt;]</pre></div><h3 id="shutting-down">Извлечение экземпляра по имени и его отключение</h3><p>Если идентификатор экземпляра неизвестен, но известно его имя, можно использовать метод <code>Server.find</code>. В листинге 13 показан поиск экземпляра по имени и его останов с помощью метода <code>Server.delete</code>.</p><h5 id="list13">Листинг 13. Останов экземпляра my-vm</h5><div class="codesection"><pre class="displaycode">import novaclient.v1_1.client as nvclient
from credentials import get_nova_creds
creds = get_nova_creds()
nova = nvclient.Client(**creds)

server = nova.servers.find(name="my-vm")
server.delete()</pre></div><h3 id="booting">Начальная загрузка экземпляра и проверка состояния</h3><p>Для запуска нового экземпляра используется метод <code>Client.servers.create</code> (см. листинг 14). Обратите внимание, что в него передаются объекты <code>image</code> и <code>flavor</code>, а не имена образа и версии. В примере также используется метод <code>Client.keypairs.create</code> для обновления открытого SSH-ключа в каталоге <code>~/.ssh/id_rsa.pub</code> и присваивания имени <code>mykey</code> паре ключей в предположении, что пара ключей еще не существует. Наконец, в примере используется метод опроса состояния <code>Client.servers.get</code> для получения текущего состояния экземпляра.</p><h5 id="list14">Листинг 14. Начальная загрузка нового экземпляра</h5><div class="codesection"><pre class="displaycode">import os
import time
import novaclient.v1_1.client as nvclient
from credentials import get_nova_creds
creds = get_nova_creds()
nova = nvclient.Client(**creds)
if not nova.keypairs.findall(name="mykey"):
    with open(os.path.expanduser('~/.ssh/id_rsa.pub')) as fpubkey:
        nova.keypairs.create(name="mykey", public_key=fpubkey.read())
image = nova.images.find(name="cirros")
flavor = nova.flavors.find(name="m1.tiny")
instance = nova.servers.create(name="test", image=image, flavor=flavor, key_name="mykey")

# Опрос с интервалом в 5 секунд, пока не прекратится состояние BUILD
status = instance.status
while status == 'BUILD':
    time.sleep(5)
    # Повторное получение экземпляра и обновление поля состояния
    instance = nova.servers.get(instance.id)
    status = instance.status
print "status: %s" % status</pre></div><h3 id="floating-ip">Прикрепление плавающего IP-адреса</h3><p>Чтобы прикрепить плавающий IP-адрес, нужно сначала убедиться, что OpenStack имеет доступный плавающий IP-адрес. Для получения списка доступных плавающих IP-адресов используйте метод <code>Client.floating_ips.list</code>. Если итоговый список пуст, определите новый плавающий IP-адрес с помощью метода <code>Client.floating_ips.create</code>, а затем назначьте его экземпляру, используя метод <code>Server.add_floating_ip</code> (см. листинг 15).</p><h5 id="list15">Листинг 15. Создание плавающего IP-адреса</h5><div class="codesection"><pre class="displaycode">&gt; nova.floating_ips.list()
[]
&gt; floating_ip = nova.floating_ips.create()
&lt;FloatingIP fixed_ip=None, id=1, instance_id=None, ip=192.168.27.129, pool=public&gt;
&gt; instance = nova.servers.find(name="test")
&gt; instance.add_floating_ip(floating_ip)</pre></div><h3 id="secgroup">Изменение группы безопасности</h3><p>Чтобы добавить правила в группу безопасности, используйте метод <code>Client.security_group_rules.create</code>. В листинге 16 показан пример включения в группу безопасности по умолчанию трафика SSH на порту 22 и всего ICMP-трафика. Чтобы извлечь группу безопасности с именем default, я использовал метод <code>Client.security_groups.find</code>.</p><h5 id="list16">Листинг 16. Включение порта 22 и ICMP в группу безопасности default</h5><div class="codesection"><pre class="displaycode">import novaclient.v1_1.client as nvclient
from credentials import get_nova_creds
creds = get_nova_creds()
nova = nvclient.Client(**creds)

secgroup = nova.security_groups.find(name="default")
nova.security_group_rules.create(secgroup.id,
                               ip_protocol="tcp",
                               from_port=22,
                               to_port=22)
nova.security_group_rules.create(secgroup.id,
                               ip_protocol="icmp",
                               from_port=-1,
                               to_port=-1)</pre></div><h3 id="host-key">Извлечение сообщений консоли</h3><p>Метод <code>Server.get_console_output</code> извлекает текст, направляемый в консоль при загрузке виртуальной машины. Анализ содержимого консоли помогает решить стандартную проблему изменения ключей хоста.</p><p>Одним из недостатков IaaS-облака, такого как OpenStack, является проблема с проверкой SSH-ключа хоста. Если вы зашли на экземпляр по адресу, скажем, 10.40.1.150, а этот IP-адрес прежде использовался другим экземпляром, на который вы заходили в прошлом, произойдет ошибка (см. листинг 17).</p><h5 id="list17">Листинг 17. Ошибка при изменении идентификатора хоста</h5><div class="codesection"><pre class="displaycode">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
6f:2b:59:46:cb:8c:81:48:06:f3:c5:db:40:23:d3:be.
Please contact your system administrator.
Add correct host key in /home/mylogin/.ssh/known_hosts to get rid of this message.
Offending key in /home/mylogin/.ssh/known_hosts:1
RSA host key for 10.40.1.150 has changed and you have requested strict checking.
Host key verification failed.</pre></div><p>Если на вашей виртуальной машине установлен пакет <code>cloud-init</code> (см. раздел <a href="#resources">Ресурсы</a>), он будет выводить ключ хоста на консоль (см. листинг 18).</p><h5 id="list18">Листинг 18. Пример вывода SSH-ключа на консоль</h5><div class="codesection"><pre class="displaycode">-----BEGIN SSH HOST KEY KEYS-----
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDciNMyzj0osyPOM+
1OyseTWgkzw+M43zp5H2CchG8daRDHel7V3OHETVdI6WofNn
SdBJAwIoisRFPxyroNGiVw= root@my-name
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDU854+fNdcKMZTLCUejMOZllQmmphr6V5Aaz1F2+x2jXql5rqKQ
d5/h6OdFszcp+gdTeVtfgG++/298qodTemVVrvqwjp4eN87iHvhPxH6GDEevAKlEed2ckdAmgvzI9rcOYgR/46G9x
Iea0IdgNjMvN1baj6WPtv+HfcfH/ZV58G306lSJfbz/GVxNTIxW+Wg7ZQCAe6jWgm4oQ+66sco+7Fub24EPue3kO8
jqufqq3mY5+MFlzEHSX5B04ioG5Alw/JuqVx5+7zHt9I2wA3nzsyUdKtCTrw8V4fYEhWDm53WLOpW+8CeYCXuv+yL
7EjwLqhIH/TUuzGQiWmFGvyz root@my-name
-----END SSH HOST KEY KEYS-----</pre></div><p>В листинге 19 показан сценарий, в котором метод интерфейса <code>Server.get_console_output</code> извлекает из консоли SSH-ключ хоста и обновляет файл <code>~/.ssh/known_hosts</code>; в результате вы не будете получать предупреждения при первом обращении по SSH к экземпляру с плавающим IP-адресом.</p><h5 id="list19">Листинг 19. Извлечение SSH-ключа хоста из консоли</h5><div class="codesection"><pre class="displaycode">import os
import subprocess
import novaclient.v1_1.client as nvclient
from credentials import get_nova_creds


def get_server(creds, servername):
    nova = nvclient.Client(**creds)
    return nova.servers.find(name=servername)


def remove_hostkey(ip):
    subprocess.call(["ssh-keygen", "-R", ip])


def get_hostkey_from_console(text):
    lines = text.split('\n')
    start = '-----BEGIN SSH HOST KEY KEYS-----\r'
    end = '-----END SSH HOST KEY KEYS-----\r'
    start_ind = lines.index(start)
    end_ind = lines.index(end)
    for i in range(start_ind+1, end_ind):
        key = lines[i].rstrip()
        if key.startswith('ssh-rsa'):
            return key
    raise KeyError("ssh host key not found")


def main():
    server = get_server(get_nova_creds(), "my-server")
    netname = "my-network"
    (fixed_ip, floating_ip) = server.networks[netname]
    # Remove existing key, if any
    remove_hostkey(floating_ip)
    output = server.get_console_output()
    key = get_hostkey_from_console(output)
    with open(os.path.expanduser("~/.ssh/known_hosts"), 'a') as f:
        f.write("{0} {1}\n".format(floating_ip, key))


if __name__ == '__main__':
    main()</pre></div><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="glance">Сервис OpenStack Image (glance)</h2><p>Сервис OpenStack Image (<code>glance</code>) отвечает за управление каталогом образов виртуальных машин, которые использует сервис Compute.</p><h3 id="glance-auth">Аутентификация в оконечной точке glance</h3><p>Python-интерфейс OpenStack Image (<code>glance</code>) имеет незначительные отличия от интерфейса Compute при выполнении первоначальной аутентификации. Интерфейс <code>glance</code> использует информацию, которую он должен получить от интерфейса <code>keystone</code>:</p><ul class="ibm-bullet-list"><li>URL-адрес оконечной точки <code>glance</code>.</li><li>Маркер аутентификации <code>keystone</code>.</li></ul><p>Аналогично интерфейсу <code>nova</code>, интерфейс <code>glance</code> передает версию в качестве аргумента или импортирует модуль напрямую. В листинге 20 показан пример аутентификации в оконечной точке <code>glance</code> с помощью интерфейса версии 2.</p><h5 id="list20">Листинг 20. Аутентификация с помощью интерфейса glance</h5><div class="codesection"><pre class="displaycode">import keystoneclient.v2_0.client as ksclient
import glanceclient
creds = get_keystone_creds()
keystone = ksclient.Client(**creds)
glance_endpoint = keystone.service_catalog.url_for(service_type='image',
                                                   endpoint_type='publicURL')
glance = glanceclient.Client('2',glance_endpoint, token=keystone.auth_token)</pre></div><p>В листинге 21 приведен пример импорта соответствующего модуля <code>glance</code> напрямую.</p><h5 id="list21">Листинг 21. Импорт модуля glance напрямую</h5><div class="codesection"><pre class="displaycode">import keystoneclient.v2_0.client as ksclient
import glanceclient.v2.client as glclient
creds = get_keystone_creds()
keystone = ksclient.Client(**creds)
glance_endpoint = keystone.service_catalog.url_for(service_type='image',
                                                   endpoint_type='publicURL')
glance = glclient.Client(glance_endpoint, token=keystone.auth_token)</pre></div><h3 id="glance-list">Перечень доступных образов</h3><p>Чтобы получить перечень доступных образов, используйте метод <code>Client.images.list</code> (см. листинг 22). Обратите внимание, что этот метод возвращает генератор, в то время как методы <code>list</code> интерфейса <code>nova</code> возвращают списки.</p><h5 id="list22">Листинг 22. Получение перечня образов виртуальных маши</h5><div class="codesection"><pre class="displaycode">&gt; import keystoneclient.v2_0.client as ksclient
&gt; import glanceclient.v2.client as glclient
&gt; creds = get_keystone_creds()
&gt; keystone = ksclient.Client(**creds)
&gt; glance_endpoint = keystone.service_catalog.url_for(service_type='image',
...                                                    endpoint_type='publicURL')
&gt; glance = glclient.Client(glance_endpoint, token=keystone.auth_token)
&gt; images = glance.images.list()
&gt; images
&lt;generator object list at 0x10c8efd70&gt;
&gt; images.next()
{u'status': u'active', u'tags': [], u'kernel_id':
u'8ab02091-21ea-434c-9b7b-9b4e2ae49591', u'container_format': u'ami', u'min_ram': 0,
u'ramdisk_id': u'd36267b5-7cae-4dec-b5bc-6d2de5c89c64', u'updated_at':
u'2013-05-28T00:44:21Z', u'visibility': u'public', u'file':
u'/v2/images/cac50405-f4d4-4715-b1f6-7f00ff5030e6/file', u'min_disk': 0,
u'id': u'cac50405-f4d4-4715-b1f6-7f00ff5030e6', u'size': 25165824, u'name':
u'cirros-0.3.1-x86_64-uec', u'checksum': u'f8a2eeee2dc65b3d9b6e63678955bd83',
u'created_at': u'2013-05-28T00:44:21Z', u'disk_format': u'ami', u'protected':
False, u'schema': u'/v2/schemas/image'}</pre></div><h3 id="glance-upload">Загрузка образа в glance</h3><p>В листинге 23 показан пример использования интерфейса <code>glance</code> для загрузки файла. Для создания образа необходимо использовать интерфейс версии 1, поскольку связывания интерфейса Python не имеют метода <code>create</code> для версии 2.</p><h5 id="list23">Листинг 23. Загрузка образа в glance</h5><div class="codesection"><pre class="displaycode">import keystoneclient.v2_0.client as ksclient
import glanceclient
creds = get_keystone_creds()
keystone = ksclient.Client(**creds)
glance_endpoint = keystone.service_catalog.url_for(service_type='image',
                                                   endpoint_type='publicURL')
glance = glanceclient.Client('1',glance_endpoint, token=keystone.auth_token)
with open('/tmp/cirros-0.3.0-x86_64-disk.img') as fimage:
    glance.images.create(name="cirros", is_public=True, disk_format="qcow2",
                         container_format="bare", data=fimage)</pre></div><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="next-steps">Дальнейшие действия</h2><p>В этой статье было представлено лишь краткое введение в функциональность программных интерфейсов OpenStack Python. Ниже перечислено несколько возможностей получения дополнительной информации об этих интерфейсах.</p><h3 id="api-docs">Официальная документация по интерфейсам</h3><p>В проекте OpenStack ведется документация для всех программных интерфейсов OpenStack Python (см. раздел <code>Ресурсы</code>). Все интерфейсы имеют автоматически генерируемую документацию по каждому модулю, классу и методу. Документация некоторых (но не всех) интерфейсов содержит примеры использования.</p><h3 id="introspect">Самостоятельное исследование интерфейсов</h3><p>Одним из лучших способов изучения интерфейсов является использование их в интерактивном интерпретаторе командной строки Python. Интерпретатор bpython – это расширенный интерпретатор Python, который в процессе ввода отображает подходящие имена методов и информацию об их назначении (см. рисунок 1).</p><h5 id="fig1">Рисунок 1. Автоматическое отображение справочной информации в bpython</h5><img alt="Автоматическое отображение справочной информации в bpython" src="figure1.jpg"/><h3 id="examine-cli">Исследование исходного кода интерфейса командной строки</h3><p>Одной из сильных сторон языка Python является его читабельность, и нет лучшего способа изучить интерфейс, чем читать исходный код. Все пакеты можно найти на сайте github в разделе openstack. Чтобы получить копию исходного кода интерфейса <code>nova</code>, выполните следующую команду:</p><div class="codesection"><pre class="displaycode">git clone http://github.com/openstack/python-novaclient</pre></div><p>Поскольку клиенты командной строки реализуются с использованием программного интерфейса, каждый пакет поставляется с примером применения.</p><p>Для интерфейса <code>novaclient</code> наиболее интересны файлы в каталоге novaclient/v1_1, который содержит классы Python, формирующие этот интерфейс. Операции командной строки реализованы в виде методов <code>do_*</code> в файле novaclient/v1_1/shell.py. Например, список версий nova реализован в виде метода <code>do_flavor_list</code>, который вызывает метод интерфейса <code>Client.flavors.list</code>.</p><h3 id="dashboard">Исследование других приложений, использующих программные интерфейсы Python</h3><p>Программные интерфейсы OpenStack Python используются рядом других приложений. Панель OpenStack Dashboard (см. раздел <a href="#resources">Ресурсы</a>) взаимодействует с различными сервисами OpenStack исключительно с помощью интерфейсов Python. Это отличный пример приложения, использующего интерфейсы Python. Изучите каталог openstack_dashboard/api, чтобы понять, как панель использует интерфейсы Python.</p><p>Проект клиента OpenStack Client (см. раздел <a href="#resources">Ресурсы</a>) объединяет функциональность существующих клиентов в единый интерфейс командной строки. Он использует интерфейсы Python всех остальных проектов.</p><p>Проект Heat, являющийся решением для оркестровки работы с OpenStack, также использует интерфейсы Python. Изучите файл heat/engine/clients.py.</p><p>Написанная на Python программа управления конфигурациями Ansible имеет несколько модулей OpenStack, которые используют интерфейсы Python. Изучите каталог library/cloud, содержащий модули Ansible OpenStack.</p><p>Изучив работу интерфейсов Python, вы едва ли захотите вернуться к использованию REST-интерфейсов или утилит командной строки при создании сценариев автоматизации OpenStack.</p>


</div>
</div></body></html>