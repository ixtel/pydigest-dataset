<html><body><div><div class="post-text" itemprop="text">
<p>The simplest way I can find to work around this issue is to simply switch the order of multiplication.</p>

<p>If in <code>testcplx.pyx</code> I change</p>

<pre><code>varc128 = varc128 * varf64
</code></pre>

<p>to</p>

<pre><code>varc128 = varf64 * varc128
</code></pre>

<p>I change from the failing situation to described to one that works correctly.  This scenario is useful as it allows a direct diff of the produced C code.</p>

<h3>tl;dr</h3>

<p>The order of the multiplication changes the translation, meaning that in the failing version the multiplication is attempted via <code>__pyx_t_npy_float64_complex</code> types, whereas in the working version it is done via <code>__pyx_t_double_complex</code> types.  This in turn introduces the typedef line <code>typedef npy_float64 _Complex __pyx_t_npy_float64_complex;</code>, which is invalid. </p>

<p>I am fairly sure this is a cython bug (Update: <a href="http://trac.cython.org/ticket/850#ticket">reported here</a>).  Although <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=19514">this is a very old gcc bug report</a>, the response explicitly states (in saying that it is not, in fact, a <strong><em>gcc</em></strong> bug, but user code error):</p>

<blockquote>
<pre><code>typedef R _Complex C;
</code></pre>
  
  <p>This is not valid code; you can't use _Complex together with a typedef, 
  only together with "float", "double" or "long double" in one of the forms 
  listed in C99.</p>
</blockquote>

<p>They conclude that <code>double _Complex</code> is a valid type specifier whereas <code>ArbitraryType _Complex</code> is not.  <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=36692">This more recent report</a> has the same type of response - trying to use <code>_Complex</code> on a non fundamental type is outside spec, and the <a href="http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Standard-Complex-Number-Types">GCC manual</a> indicates that <code>_Complex</code> can only be used with <code>float</code>, <code>double</code> and <code>long double</code></p>

<p>So - we can hack the cython generated C code to test that: replace <code>typedef npy_float64 _Complex __pyx_t_npy_float64_complex;</code> with  <code>typedef double _Complex __pyx_t_npy_float64_complex;</code> and verify that it is indeed valid and can make the output code compile.</p>

<hr/>

<h3>Short trek through the code</h3>

<p>Swapping the multiplication order only highlights the problem that we are told about by the compiler. In the first case, the offending line is the one that says <code>typedef npy_float64 _Complex __pyx_t_npy_float64_complex;</code> - it is trying to assign the type <code>npy_float64</code> <strong><em>and</em></strong> use the keyword <code>_Complex</code> to the type <code>__pyx_t_npy_float64_complex</code>.</p>

<p><code>float _Complex</code> or <code>double _Complex</code> is a valid type, whereas <code>npy_float64 _Complex</code> is not. To see the effect, you can just delete <code>npy_float64</code> from that line, or replace it with <code>double</code> or <code>float</code> and the code compiles fine.  The next question is why that line is produced in the first place...</p>

<p>This seems to be produced by <a href="https://github.com/cython/cython/blob/bb4d9c2de71b7c7e1e02d9dfeae53f4547fa9d7d/Cython/Compiler/PyrexTypes.py#L1949">this line</a> in the Cython source code.</p>

<p>Why does the order of the multiplication change the code significantly - such that the type <code>__pyx_t_npy_float64_complex</code> is introduced, and introduced in a way that fails?</p>

<p>In the failing instance, the code to implement the multiplication turns <code>varf64</code> into a <code>__pyx_t_npy_float64_complex</code> type, does the multiplication on real and imaginary parts and then reassembles the complex number.  In the working version, it does the product directly via the <code>__pyx_t_double_complex</code> type using the function <code>__Pyx_c_prod</code></p>

<p>I guess this is as simple as the cython code taking its cue for which type to use for the multiplication from the first variable it encounters.  In the first case, it sees a float 64, so produces (<em>invalid</em>) C code based on that, whereas in the second, it sees the (double) complex128 type and bases its translation on that.  This explanation is a little hand-wavy and I hope to return to an analysis of it if time allows...</p>

<p>A note on this - <a href="https://github.com/cython/cython/blob/e3f5343f3b648fc0033bdaf0def3268abab7b9ea/Cython/Includes/numpy/__init__.pxd#L331">here we see</a> that the <code>typedef</code> for <code>npy_float64</code> is <code>double</code>, so in this particular case, a fix might consist of modifying <a href="https://github.com/cython/cython/blob/bb4d9c2de71b7c7e1e02d9dfeae53f4547fa9d7d/Cython/Compiler/Nodes.py#L1011">the code here</a> to use <code>double _Complex</code> where <code>type</code> is <code>npy_float64</code>, but this is getting beyond the scope of a SO answer and doesn't present a general solution.</p>

<hr/>

<h1>C code diff result</h1>

<h3>Working version</h3>

<p>Creates this C code from the line `varc128 = varf64 * varc128</p>

<pre><code>__pyx_v_8testcplx_varc128 = __Pyx_c_prod(__pyx_t_double_complex_from_parts(__pyx_v_8testcplx_varf64, 0), __pyx_v_8testcplx_varc128);
</code></pre>

<h3>Failing version</h3>

<p>Creates this C code from the line <code>varc128 = varc128 * varf64</code></p>

<pre><code>__pyx_t_2 = __Pyx_c_prod_npy_float64(__pyx_t_npy_float64_complex_from_parts(__Pyx_CREAL(__pyx_v_8testcplx_varc128), __Pyx_CIMAG(__pyx_v_8testcplx_varc128)), __pyx_t_npy_float64_complex_from_parts(__pyx_v_8testcplx_varf64, 0));
  __pyx_v_8testcplx_varc128 = __pyx_t_double_complex_from_parts(__Pyx_CREAL(__pyx_t_2), __Pyx_CIMAG(__pyx_t_2));
</code></pre>

<p>Which necessitates these extra imports - and the offending line is the one that says <code>typedef npy_float64 _Complex __pyx_t_npy_float64_complex;</code> - it is trying to assign the type <code>npy_float64</code> <strong><em>and</em></strong> the type <code>_Complex</code> to the type <code>__pyx_t_npy_float64_complex</code></p>

<pre><code>#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    typedef ::std::complex&lt; npy_float64 &gt; __pyx_t_npy_float64_complex;
  #else
    typedef npy_float64 _Complex __pyx_t_npy_float64_complex;
  #endif
#else
    typedef struct { npy_float64 real, imag; } __pyx_t_npy_float64_complex;
#endif

/*... loads of other stuff the same ... */

static CYTHON_INLINE __pyx_t_npy_float64_complex __pyx_t_npy_float64_complex_from_parts(npy_float64, npy_float64);

#if CYTHON_CCOMPLEX
    #define __Pyx_c_eq_npy_float64(a, b)   ((a)==(b))
    #define __Pyx_c_sum_npy_float64(a, b)  ((a)+(b))
    #define __Pyx_c_diff_npy_float64(a, b) ((a)-(b))
    #define __Pyx_c_prod_npy_float64(a, b) ((a)*(b))
    #define __Pyx_c_quot_npy_float64(a, b) ((a)/(b))
    #define __Pyx_c_neg_npy_float64(a)     (-(a))
  #ifdef __cplusplus
    #define __Pyx_c_is_zero_npy_float64(z) ((z)==(npy_float64)0)
    #define __Pyx_c_conj_npy_float64(z)    (::std::conj(z))
    #if 1
        #define __Pyx_c_abs_npy_float64(z)     (::std::abs(z))
        #define __Pyx_c_pow_npy_float64(a, b)  (::std::pow(a, b))
    #endif
  #else
    #define __Pyx_c_is_zero_npy_float64(z) ((z)==0)
    #define __Pyx_c_conj_npy_float64(z)    (conj_npy_float64(z))
    #if 1
        #define __Pyx_c_abs_npy_float64(z)     (cabs_npy_float64(z))
        #define __Pyx_c_pow_npy_float64(a, b)  (cpow_npy_float64(a, b))
    #endif
 #endif
#else
    static CYTHON_INLINE int __Pyx_c_eq_npy_float64(__pyx_t_npy_float64_complex, __pyx_t_npy_float64_complex);
    static CYTHON_INLINE __pyx_t_npy_float64_complex __Pyx_c_sum_npy_float64(__pyx_t_npy_float64_complex, __pyx_t_npy_float64_complex);
    static CYTHON_INLINE __pyx_t_npy_float64_complex __Pyx_c_diff_npy_float64(__pyx_t_npy_float64_complex, __pyx_t_npy_float64_complex);
    static CYTHON_INLINE __pyx_t_npy_float64_complex __Pyx_c_prod_npy_float64(__pyx_t_npy_float64_complex, __pyx_t_npy_float64_complex);
    static CYTHON_INLINE __pyx_t_npy_float64_complex __Pyx_c_quot_npy_float64(__pyx_t_npy_float64_complex, __pyx_t_npy_float64_complex);
    static CYTHON_INLINE __pyx_t_npy_float64_complex __Pyx_c_neg_npy_float64(__pyx_t_npy_float64_complex);
    static CYTHON_INLINE int __Pyx_c_is_zero_npy_float64(__pyx_t_npy_float64_complex);
    static CYTHON_INLINE __pyx_t_npy_float64_complex __Pyx_c_conj_npy_float64(__pyx_t_npy_float64_complex);
    #if 1
        static CYTHON_INLINE npy_float64 __Pyx_c_abs_npy_float64(__pyx_t_npy_float64_complex);
        static CYTHON_INLINE __pyx_t_npy_float64_complex __Pyx_c_pow_npy_float64(__pyx_t_npy_float64_complex, __pyx_t_npy_float64_complex);
    #endif
#endif
</code></pre>
    </div>
    </div></body></html>