<html><body><div><div class="content html_format"><p>
      Парсинг (синтаксический анализ) представляет собой процесс сопоставления последовательности слов или символов — так называемой формальной грамматике. Например, для строчки кода:</p>

<pre><code>import matplotlib.pyplot  as plt
</code></pre><p>
имеет место следующая грамматика: сначала идёт ключевое слово import, потом название модуля или цепочка имён модулей, разделённых точкой, потом ключевое слово as, а за ним — наше название импортируемому модулю.
</p><p>
В результате парсинга, например, может быть необходимо прийти к следующему выражению:

</p><pre><code>{ 'import': [ 'matplotlib', 'pyplot' ], 'as': 'plt' }
</code></pre><p>
Данное выражение представляет собой словарь Python, который имеет два ключа: 'import' и 'as'. Значением для ключа 'import' является список, в котором по порядку перечислены названия импортируемых модулей.
</p><p>
Для парсинга как правило используют регулярные выражения. Для этого имеется модуль Python под названием re (regular expression — регулярное выражение). Если вам не доводилось работать с регулярными выражениями, их вид может вас испугать. Например, для строки кода 'import matplotlib.pyplot as plt' оно будет иметь вид:

</p><pre><code>r'^[ \t]*import +\D+\.\D+ +as \D+'
</code></pre><p>
К счастью, есть удобный и гибкий инструмент для парсинга, который называется Pyparsing. Главное его достоинство — он делает код более читаемым, а также позволяет проводить дополнительную обработку анализируемого текста.
</p><p>
В данной статье мы установим Pyparsing и создадим на нём наш первый парсер.

</p><a name="habracut"/><p>
Вначале установим Pyparsing. Если Вы работаете в Linux, в командной строке наберите:

</p><pre><code>sudo pip install pyparsing
</code></pre><p>
В Windows Вам необходимо в командной строке, запущенной с правами администратора, предварительно зайти в каталог, где лежит файл pip.exe (например, C:\Python27\Scripts\), после чего выполнить:

</p><pre><code>pip install pyparsing
</code></pre><p>
Другой способ — это зайти на </p><a href="http://sourceforge.net/projects/pyparsing/files/">страницу проекта Pyparsing на SourceForge</a><p>, скачать там инсталлятор для Windows и установить Pyparsing как обычную программу. Полную информацию о всевозможных способах установки Pyparsing можно получить на </p><a href="http://pyparsing.wikispaces.com/Download+and+Installation">странице проекта</a><p>.
</p><p>
Перейдём к парсингу. Пусть s — следующая строка:

</p><pre><code>s = 'import matplotlib.pyplot as plt'
</code></pre><p>
В результате парсинга мы хотим получить словарь:

</p><pre><code>{ 'import': [ 'matplotlib', 'pyplot' ], 'as': 'plt' }
</code></pre><p>
Сначала необходимо импортировать Pyparsing. Запустите например Python IDLE и введите:

</p><pre><code>from pyparsing import *
</code></pre><p>
Звёздочка * выше означает импорт всех имён из pyparsing. В результате это может нарушить рабочее пространство имён, что приведёт к ошибкам в работе программы. В нашем случае * используется временно, потому что мы пока не знаем, какие классы из Pyparsing мы будем использовать. После того, как мы напишем парсер, мы заменим * на названия использованных нами классов.
</p><p>
При использовании pyparsing, парсер вначале пишется для отдельных ключевых слов, символов, коротких фраз, а потом из отдельных частей получается парсер для всего текста.
</p><p>
Начнём с того, что у нас в строке есть название модуля. Формальная грамматика: в общем случае название модуля — это слово, состоящее из букв и символа нижнего подчёркивания. На pyparsing:

</p><pre><code>module_name = Word(alphas + '_')
</code></pre><p>
Word — это слово, alphas — буквы. </p><code>Word(alphas + '_')</code><p> — слово, состоящее из букв и нижнего подчёркивания. module_name переводится как название модуля. Теперь читаем всё вместе: название модуля — это слово, состоящее из букв и символа нижнего подчёркивания. Таким образом, запись на Pyparsing очень близка к естественному языку.
</p><p>
Полное имя модуля — это название модуля, потом точка, потом название другого модуля, потом снова точка, потом название третьего модуля и так далее, пока по цепочке не дойдём до искомого модуля. Полное имя модуля может состоять из имени одного модуля и не иметь точек. На pyparsing:

</p><pre><code>full_module_name = module_name + ZeroOrMore('.' + module_name)
</code></pre><p>
ZeroOrMore дословно переводится как «ноль или более», а это означает, что содержимое в скобках может повторяться несколько раз или отсутствовать. В итоге читаем полностью вторую строчку парсера: полное имя модуля — это название модуля, после которого ноль и более раз идут точка и название модуля.
</p><p>
После полного названия модуля идёт необязательная часть 'as plt'. Она представляет собой ключевое слово 'as', после которого идёт имя, которое мы сами дали импортируемому модулю. На pyparsing:

</p><pre><code>import_as = Optional('as' + module_name)
</code></pre><p>
Optional дословно переводится как «необязательный», а это означает, что содержимое в скобках может быть, а может отсутствовать. В сумме получаем: «необязательное выражение, состоящее из слова 'as' и названия модуля.
</p><p>
Полная инструкция импорта состоит из ключевого слова import, после которого идёт полное имя модуля, потом необязательная конструкция 'as plt'. На pyparsing:

</p><pre><code>parse_module = 'import' + full_module_name + import_as
</code></pre><p>
В итоге имеем наш первый парсер:

</p><pre><code>module_name = Word(alphas + '_')
full_module_name = module_name + ZeroOrMore('.' + module_name)
import_as = Optional('as' + module_name)
parse_module = 'import' + full_module_name + import_as
</code></pre><p>
Теперь надо распарсить строку s:

</p><pre><code>parse_module.parseString(s)
</code></pre><p>
Мы получим:

</p><pre><code>(['import', 'matplotlib', '.', 'pyplot', 'as', 'plt'], {})
</code></pre><p>
Вывод можно улучшить, преобразовав результат в список:

</p><pre><code>parse_module.parseString(s).asList()
</code></pre><p>
Получим: 

</p><pre><code>['import', 'matplotlib', '.', 'pyplot', 'as', 'plt']
</code></pre><p>
Теперь будем совершенствовать парсер. Прежде всего, мы бы не хотели видеть в выводе парсера слово import и точку между названиями модулей. Для подавления вывода используется Suppress(). С учётом этого наш парсер выглядит так:

</p><pre><code>module_name = Word(alphas + '_')
full_module_name = module_name + ZeroOrMore(Suppress('.') + module_name)
import_as = Optional(Suppress('as') + module_name)
parse_module = Suppress('import') + full_module_name + import_as
</code></pre><p>
Выполнив </p><code>parse_module.parseString(s).asList()</code><p>, получим:

</p><pre><code>['matplotlib', 'pyplot', 'plt']
</code></pre><p>
Давайте теперь сделаем так, чтобы парсер сразу возвращал нам словарь вида </p><code>{'import':[модуль1, модуль2, ...], 'as':модуль}</code><p>. Прежде чем сделать это, вначале нужно отдельно получить доступ к списку импортируемых модулей (full_module_name) и к нашему собственному названию модуля (import_as). Для этого pyparsing позволяет назначать имена результатам парсинга. Давайте дадим списку импортируемых модулей имя 'modules', а тому, как мы сами назвали модуль — имя 'import as':

</p><pre><code>full_module_name = (module_name + ZeroOrMore(Suppress('.') + module_name))('modules')
import_as = (Optional(Suppress('as') + module_name))('import_as')
</code></pre><p>
Как видно из двух строчек выше, чтобы дать результату парсинга имя, нужно выражение парсера поставить в скобки, и после этого выражения в скобках дать название результата. Давайте посмотрим, что изменилось. Для этого выполним код:

</p><pre><code>res = parse_module.parseString(s)
print(res.modules.asList())
print(res.import_as.asList())
</code></pre><p>
Получим:

</p><pre><code>['matplotlib', 'pyplot']
['plt']
</code></pre><p>
Теперь мы можем отдельно извлекать цепочку модулей для импорта искомого и наше название для него. Осталось сделать так, чтобы парсер возвращал словарь. Для этого используется так называемое ParseAction — действие в процессе парсинга:

</p><pre><code>parse_module = (Suppress('import') + full_module_name).setParseAction(lambda t: {'import': t.modules.asList(), 'as': t.import_as.asList()[0]})
</code></pre><p>
lambda — это анонимная функция в Python, t — аргумент этой функции. Потом идёт двоеточие и выражение словаря Python, в который мы подставляем нужные нам данные. Когда мы вызываем asList(), мы получаем список. Имя модуля после as всегда одно, и список </p><code>t.import_as.asList()</code><p> всегда будет содержать только одно значение. Поэтому мы берём единственный элемент списка (он имеет индекс ноль) и пишем asList()[0].
</p><p>
Проверим парсер. Выполним </p><code>parse_module.parseString(s).asList()</code><p> и получим:

</p><pre><code>[{ 'import': [ 'matplotlib', 'pyplot' ], 'as': 'plt' }]
</code></pre><p>
Мы почти достигли цели. Так как у полученного списка единственный аргумент, добавим [0] в конце строки для парсинга текста: </p><code>parse_module.parseString(s).asList()[0]<br/>
</code>
<p>
В итоге:

</p><pre><code>{ 'import': [ 'matplotlib', 'pyplot' ], 'as': 'plt' }
</code></pre><p>
Мы получили то, что хотели.
</p><p>
Достигнув цели, необходимо вернуться к 'from pyparsing import *' и поменять звёздочку на те классы, которые нам пригодились:

</p><pre><code>from pyparsing import Word, alphas, ZeroOrMore, Suppress, Optional
</code></pre><p>
В итоге наш код имеет следующий вид:

</p><pre><code>from pyparsing import Word, alphas, ZeroOrMore, Suppress, Optional
module_name = Word(alphas + "_")
full_module_name = (module_name + ZeroOrMore(Suppress('.') + module_name))('modules')
import_as = (Optional(Suppress('as') + module_name))('import_as')
parse_module = (Suppress('import') + full_module_name + import_as).setParseAction(lambda t: {'import': t.modules.asList(), 'as': t.import_as.asList()[0]})
</code></pre><p>
Мы рассмотрели совсем простой пример и лишь небольшую часть возможностей Pyparsing. За бортом — создание рекурсивных выражений, обработка таблиц, поиск по тексту с оптимизацией, резко ускоряющей сам поиск, и многое другое.
</p><p>
В заключение пару слов о себе. Я аспирант и ассистент МГТУ им. Баумана (кафедра МТ-1 „Металлорежущие станки“). Увлекаюсь Python, Linux, HTML, CSS и JS. Моё хобби — автоматизация инженерной деятельности и инженерных расчётов. Считаю, что могу быть полезным Хабру, делясь своими знаниями о работе в Pyparsing, Sage и некоторыми особенностями автоматизации инженерных расчётов. Также знаю среду SageMathCloud, которая является мощной альтернативой Wolfram Alpha. SageMathCloud заточена на проведение расчётов на Python в облаке. При этом Вам доступна консоль (Ubuntu под капотом), Sage, IPython и LaTeX. Есть возможность совместной работы. Помимо кода на Python SageMathCloud поддерживает html, css, js, coffescript, go, fortran, scilab и многое другое. В настоящее время среда бесплатна (достаточно стабильная бета-версия), потом будет будет работать по системе Freemium. На текущий момент времени эта среда не освещена на Хабре, и я хотел бы восполнить этот пробел.
</p><p>
Благодарю Дарью Фролову и Никиту Коновалова за помощь в редактировании статьи.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>