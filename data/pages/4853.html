<html><body><div><div class="post-text" itemprop="text">
<p>First, to answer your question in the title: <code>filter</code> is just a function. Hence, its thread-safety will rely on the data-structure you use it with.</p>

<p>As pointed out in the comments already, list operations themselves are thread-safe in CPython and protected by the GIL, but that is arguably only an implementation detail of CPython that you shouldn't really rely on. Even if you could rely on it, thread safety of some of their operations probably does not mean the kind of thread safety you mean:</p>

<p>The problem is that iterating over a sequence with <code>filter</code> is in general not an atomic operation. The sequence could be changed during iteration. Depending on the data-structure underlying your iterator this might cause more or less weird effects. One way to overcome this problem is by iterating over a copy of the sequence that is created with one atomic action. Easiest way to do this for standard sequences like <code>tuple</code>, <code>list</code>, <code>string</code> is with the slice operator like this:</p>

<pre><code>filter(lambda x: x[0] == "in", l[:])
</code></pre>

<p>Apart from this not necessarily being thread-safe for other data-types, there's one problem with this though: it's only a shallow copy. As your list's elements seem to be list-like as well, another thread could in parallel do <code>del l[1000][:]</code> to empty one of the inner lists (which are pointed to in your shallow copy as well). This would make your filter expression fail with an <code>IndexError</code>.</p>

<p>All that said, it's not a shame to use a lock to protect access to your list and I'd definitely recommend it. Depending on how your data changes and how you work with the returned data, it might even be wise to deep-copy the elements while holding the lock and to return those copies. That way you can guarantee that once returned the filter condition won't suddenly change for the returned elements.</p>

<p>Wrt. your <code>Logger</code> code: I'm not 100 % sure how you plan to use this and if it's critical for you to run several threads on one queue and <code>join</code> them. What looks weird to me is that you never use <a href="https://docs.python.org/2/library/queue.html#Queue.Queue.task_done"><code>Queue.task_done()</code></a> (assuming that its <code>self.log</code> is a <code>Queue</code>). Also your polling of the queue is potentially wasteful. If you don't need the <code>join</code> of the thread, I'd suggest to at least turn the lock acquisition around:</p>

<pre><code>class Logger(threading.Thread):
    def __init__(self, log):
        super(Logger, self).__init__()
        self.daemon = True
        self.log = log
        self.data = []
        self.data_lock = threading.Lock()

    def run(self):
        while True:
            l = self.log.get()  # thread will sleep here indefinitely
            with self.data_lock: 
                self.data.append(l)
            self.log.task_done()

    def get_data(self, cond):
        with self.data_lock: 
            d = filter(cond, self.data)
            # maybe deepcopy d here
        return d
</code></pre>

<p>Externally you could still do <code>log.join()</code> to make sure that all of the elements of the <code>log</code> queue are processed.</p>
    </div>
    </div></body></html>