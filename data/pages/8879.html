<html><body><div><div class="post-text" itemprop="text">
<h1>Use</h1>

<p>I've developed a heuristic function for this specific case. It is not a perfect hashing, as the mapping is not between <code>[0,9!-1]</code> but between <code>[1,767359]</code>, but it is <code>O(1)</code>.</p>

<p>Let's assume we already have a file / reserved memory / whatever with 767359 bits set to 0 (e.g., <code>mem = [False] * 767359</code>). Let a 8puzzle pattern be mapped to a python string (e.g., <code>'125346987'</code>). Then, the hash function is determined by:</p>

<pre><code>def getPosition( input_str ):
data = []
opts = range(1,10)
n = int(input_str[0])
opts.pop(opts.index(n))
for c in input_str[1:len(input_str)-1]:
    k = opts.index(int(c))
    opts.pop(k)
    data.append(k)
ind = data[3]&lt;&lt;14 | data[5]&lt;&lt;12 | data[2]&lt;&lt;9 | data[1]&lt;&lt;6 | data[0]&lt;&lt;3 | data[4]&lt;&lt;1 | data[6]&lt;&lt;0
output_str = str(ind)+str(n)
output = int(output_str)
return output
</code></pre>

<p>I.e., in order to check if a 8puzzle pattern = <code>125346987</code> has already been used, we need to:</p>

<pre><code>pattern = '125346987'
pos = getPosition(pattern)
used = mem[pos-1] #mem starts in 0, getPosition in 1.
</code></pre>

<p>With a perfect hashing we would have needed 9! bits to store the booleans. In this case we need 2x more (<code>767359/9! = 2.11</code>), but recall that it is not even 1Mb (barely <strong>100KB</strong>).</p>

<p>Note that the function is easily invertible.</p>

<h1>Check</h1>

<p>I could prove you mathematically why this works and why there won't be any collision, but since this is a programming forum let's just run it for every possible permutation and check that all the hash values (positions) are indeed different:</p>

<pre><code>def getPosition( input_str ):
data = []
opts = range(1,10)
n = int(input_str[0])
opts.pop(opts.index(n))
for c in input_str[1:len(input_str)-1]:
    k = opts.index(int(c))
    opts.pop(k)
    data.append(k)
ind = data[3]&lt;&lt;14 | data[5]&lt;&lt;12 | data[2]&lt;&lt;9 | data[1]&lt;&lt;6 | data[0]&lt;&lt;3 | data[4]&lt;&lt;1 | data[6]&lt;&lt;0
output_str = str(ind)+str(n)
output = int(output_str)
return output


#CHECKING PURPOSES
def addperm(x,l):
    return [ l[0:i] + [x] + l[i:]  for i in range(len(l)+1) ]

def perm(l):
    if len(l) == 0:
        return [[]]
    return [x for y in perm(l[1:]) for x in addperm(l[0],y) ]

#We generate all the permutations
all_perms = perm([ i for i in range(1,10)])
print "Number of all possible perms.: "+str(len(all_perms)) #indeed 9! = 362880

#We execute our hash function over all the perms and store the output.
all_positions = [];
for permutation in all_perms:
    perm_string = ''.join(map(str,permutation))
    all_positions.append(getPosition(perm_string))

#We wan't to check if there has been any collision, i.e., if there
#is one position that is repeated at least twice.
print "Number of different hashes: "+str(len(set(all_positions))) 
#also 9!, so the hash works properly.
</code></pre>

<h1>How does it work?</h1>

<p>The idea behind this has to do with a tree: at the beginning it has 9 branches going to 9 nodes, each corresponding to a digit. From each of these nodes we have 8 branches going to 8 nodes, each corresponding to a digit except its parent, then 7, and so on. </p>

<p>We first store the first digit of our input string in a separate variable and pop it out from our 'node' list, because we have already taken the branch corresponding to the first digit.</p>

<p>Then we have 8 branches, we choose the one corresponding with our second digit. Note that, since there are 8 branches, we need 3 bits to store the index of our chosen branch and the maximum value it can take is <code>111</code> for the 8th branch (we map branch 1-8 to binary <code>000-111</code>). Once we have chosen and store the branch index, we pop that value out, so that the next node list doesn't include again this digit.</p>

<p>We proceed in the same way for branches 7, 6 and 5. Note that when we have 7 branches we still need 3 bits, though the maximum value will be <code>110</code>. When we have 5 branches, the index will be at most binary <code>100</code>.</p>

<p>Then we get to 4 branches and we notice that this can be stored just with 2 bits, same for 3 branches. For 2 branches we will just need 1bit, and for the last branch we don't need any bit: there will be just one branch pointing to the last digit, which will be the remaining from our 1-9 original list.</p>

<p>So, what we have so far: the first digit stored in a separated variable and a list of 7 indexes representing branches. The first 4 indexes can be represented with 3bits, the following 2 indexes can be represented with 2bits and the last index with 1bit. </p>

<p>The idea is to concatenate all this indexes in their bit form to create a larger number. Since we have 17bits, this number will be at most <code>2^17=131072</code>. Now we just add the first digit we had stored to the end of that number (at most this digit will be 9) and we have that the biggest number we can create is <code>1310729</code>.</p>

<p>But we can do better: recall that when we had 5 branches we needed 3 bits, though the maximum value was binary <code>100</code>. What if we arrange our bits so that those with more 0s come first? If so, in the worst case scenario our final bit number will be the concatenation of:</p>

<p><code>100 10 101 110 111 11 1</code></p>

<p>Which in decimal is <code>76735</code>. Then we proceed as before (adding the 9 at the end) and we get that our biggest possible generated number is <code>767359</code>, which is the ammount of bits we need and corresponds to input string <code>987654321</code>, while the lowest possible number is <code>1</code> which corresponds to input string <code>123456789</code>.</p>

<p>Just to finish: one might wonder why have we stored the first digit in a separate variable and added it at the end. The reason is that if we had kept it then the number of branches at the beginning would have been 9, so for storing the first index (1-9) we would have needed 4 bits (<code>0000</code> to <code>1000</code>). which would have make our mapping much less efficient, as in that case the biggest possible number (and therefore the amount of memory needed) would have been</p>

<p><code>1000 100 10 101 110 111 11 1</code></p>

<p>which is 1125311 in decimal (1.13Mb vs 768Kb). It is quite interesting to see that the ratio <code>1.13M/0.768K = 1.47</code> has something to do with the ratio of the four bits compared to just adding a decimal value (<code>2^4/10 = 1.6</code>) which makes a lot of sense (the difference is due to the fact that with the first approach we are not fully using the 4 bits).</p>
    </div>
    </div></body></html>