<html><body><div><div class="entry-content">
              <div class="section" id="introduction">
<h2>Introduction</h2>
<p>I spent this summer working on a web platform running on Node.js. This was the
first time I worked full-time with Node.js and one thing that became quite
apparent after a few weeks of working with it was that many developers,
including myself at the time, lack clarify on exactly how the asynchronous
features of Node.js work, and how they are implemented at a lower level.  Since
I believe the only way to use a platform efficiently is to have a clear
understanding of how it works, I decided to dig deeper. This curiosity also
made me start playing around with implementing similar asynchronous features in
other languages, in particular Python, it being my go-to language for
experimenting and learning. This led me to Python 3.4's asynchronous IO library
<code class="py python3"><span class="n">asyncio</span></code> in particular, which intersected with my already existing
interest in coroutines (<a class="reference external" href="http://sahandsaba.com/combinatorial-generation-using-coroutines-in-python.html">see my post on combinatorial generation using
coroutines in Python</a>.)
This post is about exploring the questions and answers that came up while I was
learning more about this subject, which I hope can help clarify and answer some
questions for others as well.</p>
<p>All the Python code is intended for Python 3.4. This is mostly because
Python 3.4 introduces the <code class="py python3"><span class="n">selectors</span></code> module as well as <code class="py python3"><span class="n">asyncio</span></code>. For
earlier versions of Python, libraries such as Twisted, gevent, and tornado,
provide similar functionality.</p>
<p>In the early examples below, I chose to almost entirely ignore the issue of
error handling and exceptions. This was done mostly for the sake of simplicity,
and it should be noted that proper handling of exceptions should be a very
important aspect of the type of code we see below. I will provide a few
examples of how Python 3.4's <code class="py python3"><span class="n">asyncio</span></code> module handles exceptions at the
end.</p>
</div>
<div class="section" id="getting-started-hello-world-revisited">
<h2>Getting Started: Hello World Revisited</h2>
<p>Let's start by writing a program to solve a very simple problem. We will use
this problem and minor variations of it for the rest of the section to
demonstrate the ideas.</p>
<blockquote>
Write a program to print "Hello world!" every three seconds, and at the
same time wait for input from the user. Each line of user input will
contain a single positive number <span class="math">\(n\)</span>. As soon as input is entered,
calculate and output the Fibonacci number <span class="math">\(F(n)\)</span> and continue to wait
for more input.</blockquote>
<p>Note that there's a chance the periodic "Hello world!" is inserted in the middle of
user input, but we do not care about that.</p>
<p>Those of you familiar with Node.js and JavaScript might already have a
solution in mind that will likely look something like this:</p>
<div class="highlight"><pre><span class="nx">log_execution_time</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./utils'</span><span class="p">).</span><span class="nx">log_execution_time</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">fib</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">timed_fib</span> <span class="o">=</span> <span class="nx">log_execution_time</span><span class="p">(</span><span class="nx">fib</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="k">new</span> <span class="nb">Date</span><span class="p">()).</span><span class="nx">getTime</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="s2">" - Hello world!"</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">handleInput</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">handleInput</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'fib('</span> <span class="o">+</span> <span class="nx">n</span> <span class="o">+</span> <span class="s1">') = '</span> <span class="o">+</span> <span class="nx">timed_fib</span><span class="p">(</span><span class="nx">n</span><span class="p">));</span>
<span class="p">};</span>

<span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'data'</span><span class="p">,</span> <span class="nx">handleInput</span><span class="p">);</span>
<span class="nx">setInterval</span><span class="p">(</span><span class="nx">sayHello</span><span class="p">,</span> <span class="mi">3000</span><span class="p">);</span>
</pre></div>
<p>As you can see, this is quite easy to do in Node.js. All we have to do is set
an interval timer to print "Hello world!" and attach an event handler to the
<code class="py python3"><span class="n">data</span></code> event of <code class="py python3"><span class="n">process</span><span class="o">.</span><span class="n">stdin</span></code> and we are done. Simple to
understand on an abstract level, and very easy to use. It just works! But how?
To answer this let's try to do the exact same thing in Python.</p>
<p>Also notice that we use a <code class="py python3"><span class="n">log_execution_time</span></code> decorator to output the
time it takes to calculate the Fibonacci number. Here's the definition of this
decorator in Python:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">time</span>


<span class="k">def</span> <span class="nf">log_execution_time</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s">"Executing {} took {:.03} seconds."</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                                                             <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">return_value</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
<p>And similarly, in JavaScript:</p>
<div class="highlight"><pre><span class="c1">// We do not care about handling the "this" parameter correctly our examples.</span>
<span class="c1">// Do not use this decorator where that's needed!</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">log_execution_time</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">log_execution_time</span><span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">start</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">()).</span><span class="nx">getTime</span><span class="p">();</span>
        <span class="nx">return_value</span> <span class="o">=</span> <span class="nx">func</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
        <span class="nx">message</span> <span class="o">=</span> <span class="s2">"Calculation took "</span> <span class="o">+</span> <span class="p">((</span><span class="k">new</span> <span class="nb">Date</span><span class="p">()).</span><span class="nx">getTime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">start</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">+</span> <span class="s2">" seconds"</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">return_value</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">wrapper</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>The algorithm to calculate the Fibonacci numbers used here is intentionally
chosen to be the slowest one of all (exponential running time).  This is
because this post is not about Fibonacci numbers (see this <a class="reference external" href="http://sahandsaba.com/five-ways-to-calculate-fibonacci-numbers-with-python-code.html">post</a> on that subject, as
there is a logarithmic-time algorithm) and that I actually want the code to be
slow to demonstrate some of the concepts below. Here's the Python code for it,
that will be used multiple times below.</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">log_execution_time</span> <span class="k">import</span> <span class="n">log_execution_time</span>


<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span>


<span class="n">timed_fib</span> <span class="o">=</span> <span class="n">log_execution_time</span><span class="p">(</span><span class="n">fib</span><span class="p">)</span>
</pre></div>
<p>So, back to the task at hand. How do we even begin? Python does not provide a
built-in <code class="py python3"><span class="n">setInterval</span></code> or <code class="py python3"><span class="n">setTimeout</span></code>. So a first possible solution is
to use OS-level concurrency for this. Let's look at using two threads to do
what we need. We will look at threads in some more detail in a bit.</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">threading</span> <span class="k">import</span> <span class="n">Thread</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">sleep</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">time</span>
<span class="kn">from</span> <span class="nn">fib</span> <span class="k">import</span> <span class="n">timed_fib</span>


<span class="k">def</span> <span class="nf">print_hello</span><span class="p">():</span>
    <span class="k">while</span> <span class="k">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">"{} - Hello world!"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="p">())))</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_and_process_input</span><span class="p">():</span>
    <span class="k">while</span> <span class="k">True</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">'fib({}) = {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">timed_fib</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c"># Second thread will print the hello message. Starting as a daemon means</span>
    <span class="c"># the thread will not prevent the process from exiting.</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">print_hello</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="k">True</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="c"># Main thread will read and process input</span>
    <span class="n">read_and_process_input</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>Quite simple as well. But are the thread-based Python solution and the Node.js
solution equivalent? Let's do an experiment.  As we discussed, our Fibonacci
number calculation code is very slow, so let's try a rather large number, say
37 for Python and 45 for Node.js (JavaScript is quite a bit faster than Python
at numerical calculations).</p>
<pre class="code text literal-block">
$ python3.4 hello_threads.py
1412360472 - Hello world!
37
1412360475 - Hello world!
1412360478 - Hello world!
1412360481 - Hello world!
Executing fib took 8.96 seconds.
fib(37) = 24157817
1412360484 - Hello world!
</pre>
<p>As you notice, it took about 9 seconds for the calculation to be finished but
the "Hello world!" message is printed while that calculation takes place. Let's
try it with Node.js:</p>
<pre class="code text literal-block">
$ node hello.js
1412360534 - Hello world!
1412360537 - Hello world!
45
Calculation took 12.793 seconds
fib(45) = 1134903170
1412360551 - Hello world!
1412360554 - Hello world!
1412360557 - Hello world!
</pre>
<p>With Node.js on the other hand, the printing of the "Hello world!" message is
paused while the Fibonacci number is calculated. Let's see how this makes
sense.</p>
</div>
<div class="section" id="event-loops-and-threads">
<h2>Event Loops and Threads</h2>
<p>To understand the difference in behaviour of the two solutions in the previous
section, we need to have a simple understanding of threads and event loops.
Let's start with threads. Think of a thread as a single sequence of
instructions and the CPU's current state in executing them (CPU state refers to
e.g. register values, in particular the next instruction register).</p>
<p>A simple synchronous program often runs on a single thread, which is why if an
operation needs to wait for something, say an IO operation or a timer, the
execution of the program is paused until the operation is finished. One of the
simplest blocking operations is <code class="py python3"><span class="n">sleep</span></code>. In fact, that's all <code class="py python3"><span class="n">sleep</span></code>
does, namely blocking the thread it is executed on for the given length of
time. A process can have multiple threads running in it. Threads in the same
process share the same process-level resources, such as memory and its address
space, file descriptors, etc.</p>
<p>The operating system is in charge of handling threads, and the <em>scheduler</em> in
the OS takes care of jumping between threads in a process (and between
processes, but we are not too concerned with that part, since it is outside the
scope of this post.) The operating system's scheduler will choose when to put a
thread on pause and give control of the CPU to another thread for execution.
This is called a <em>context switch</em>, and involves saving of the <em>context</em> of the
current thread (e.g.  CPU register values) and then loading the state of the
target thread. Context switching can be somewhat expensive in that it itself
requires CPU cycles.</p>
<p>There are many reasons the OS might choose to switch to another thread.
Examples can be that another higher priority process or thread requires
immediate attention (for example, code that handles hardware interrupts), that
the thread itself asks to be paused for a while (e.g. in <code class="py python3"><span class="n">sleep</span></code>), or
because the thread has used the dedicated time it was assigned (this is also
called the <em>thread quantum</em>) and will have to go back into a queue to be
scheduled to continue execution.</p>
<p>Going back to our solutions above, the Python solution is clearly
multi-threaded. This explains why the two tasks are run concurrently, and why
the calculation of the large Fibonacci number, which is CPU intensive, is not
blocking the execution of the other thread.</p>
<p>But what about Node.js? It appears, based on the fact that the calculation is
blocking the other task, that the our code is running on a single thread. And
this is in fact how Node.js is implemented. As far as the operating system is
concerned your application is running in a single thread (I am simplifying
things a little bit here, since depending on the platform libuv <strong>might</strong> use
thread pools for some of the IO events, but even that doesn't change the fact
that your JavaScript code is still running on a single thread.)</p>
<p>There are a few reasons you might want to avoid threads in certain situations.
One is that threads can be computationally and resource-wise expensive, and the
other that the true concurrent behaviour of threads, along with shared memory
means concurrency issues such as deadlocks and race conditions enter the
picture, leading to more complex code and the need to keep thread safety in
mind while programming. (Of course, these are relative, and there's a time and
place for threads. But that's besides the point of this article!)</p>
<p>Let's see if we can solve the above problem without using multi-threading. To
do so, we will imitate what Node.js uses behind the scenes: an <em>event loop</em>.
First, we will need a way to <em>poll</em> <code class="py python3"><span class="n">stdin</span></code> for input availability, that
is, a system call that asks if a file descriptor (in this case <code class="py python3"><span class="n">stdin</span></code>) has
input available for reading or not. Depending on the operating system, there
are a variety of system calls for this, such as <code class="py python3"><span class="n">poll</span></code>, <code class="py python3"><span class="n">select</span></code>,
<code class="py python3"><span class="n">kqueue</span></code>, etc. In Python 3.4, the <code class="py python3"><span class="n">selectors</span></code> module provides an
abstraction over these system calls so you can use them (somewhat) safely on a
variety of machines.</p>
<p>Once we have the polling functionality, our event loop will be very simple: in
each iteration of the loop, we check to see if there's input available for
reading, and if so we read and process it. After that, we check to see if more
than three seconds has passed since the last printing of "Hello world!" and if
yes, we print it. Let's give this a shot.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">selectors</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">time</span>
<span class="kn">from</span> <span class="nn">fib</span> <span class="k">import</span> <span class="n">timed_fib</span>


<span class="k">def</span> <span class="nf">process_input</span><span class="p">(</span><span class="n">stream</span><span class="p">):</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">'fib({}) = {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">timed_fib</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">print_hello</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">"{} - Hello world!"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="p">())))</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">selector</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">DefaultSelector</span><span class="p">()</span>
    <span class="c"># Register the selector to poll for "read" readiness on stdin</span>
    <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="p">,</span> <span class="n">selectors</span><span class="o">.</span><span class="n">EVENT_READ</span><span class="p">)</span>
    <span class="n">last_hello</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># Setting to 0 means the timer will start right away</span>
    <span class="k">while</span> <span class="k">True</span><span class="p">:</span>
        <span class="c"># Wait at most 100 milliseconds for input to be available</span>
        <span class="k">for</span> <span class="n">event</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="mf">0.1</span><span class="p">):</span>
            <span class="n">process_input</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">fileobj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">last_hello</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">last_hello</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
            <span class="n">print_hello</span><span class="p">()</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>And the output:</p>
<pre class="code literal-block">
$ python3.4 hello_eventloop.py
1412376429 - Hello world!
1412376432 - Hello world!
1412376435 - Hello world!
37
Executing fib took 9.7 seconds.
fib(37) = 24157817
1412376447 - Hello world!
1412376450 - Hello world!
</pre>
<p>And as expected, because we are using a single thread, the program acts the
same way as Node.js does, that is, the calculation blocks the running of the
"Hello world!" task.  Great, this is neat! But our solution is rather
hard-coded for the specific problem. In next sections, we will look at
generalizing our event loop code to be a bit more powerful and easier to
program for, first using callbacks and then using coroutines.</p>
</div>
<div class="section" id="event-loops-with-callbacks">
<h2>Event Loops With Callbacks</h2>
<p>A natural generalization of the previous section's event loop is to allow for
generic event handlers. This can be relatively easily achieved using callbacks:
for each event type (in our case, we only have two of them, input on
<code class="py python3"><span class="n">stdin</span></code> and timers going off), allow the user to add arbitrary functions
as event handlers. The code is simple enough that we might as well just jump to
it directly. There is only one bit that's a bit tricky, and it's the use of
<code class="py python3"><span class="n">bisect</span><span class="o">.</span><span class="n">insort</span></code> to handle timer events. The algorithm here is to keep the
list of timer events sorted, with the timers to run earliest first. This way,
at each iteration of the event loop, we just have to check to see if there are
any timers, and if there are, start at the beginning and run all timers that
have expired. <code class="py python3"><span class="n">bisect</span><span class="o">.</span><span class="n">insort</span></code> makes this easier by inserting the item in
correct index in the list. There are various other approaches to this but this
is the one I opted for.</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">bisect</span> <span class="k">import</span> <span class="n">insort</span>
<span class="kn">from</span> <span class="nn">fib</span> <span class="k">import</span> <span class="n">timed_fib</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="nn">selectors</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="k">class</span> <span class="nc">EventLoop</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Implements a callback based single-threaded event loop as a simple</span>
<span class="sd">    demonstration.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">tasks</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="k">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stdin_handlers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selector</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">DefaultSelector</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="p">,</span> <span class="n">selectors</span><span class="o">.</span><span class="n">EVENT_READ</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run_forever</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="k">True</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_running</span><span class="p">:</span>
            <span class="c"># First check for available IO input</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selector</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">fileobj</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">callback</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stdin_handlers</span><span class="p">:</span>
                    <span class="n">callback</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

            <span class="c"># Handle timer events</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timers</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">time</span><span class="p">():</span>
                <span class="n">handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">handler</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_stdin_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stdin_handlers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_timer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wait_time</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="n">insort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_timers</span><span class="p">,</span> <span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">wait_time</span><span class="p">,</span> <span class="n">callback</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="k">False</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">EventLoop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_stdin_input</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s">'exit'</span><span class="p">:</span>
            <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">"fib({}) = {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">timed_fib</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">print_hello</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">"{} - Hello world!"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="p">())))</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">add_timer</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">print_hello</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="n">loop</span><span class="o">.</span><span class="n">add_stdin_handler</span><span class="p">(</span><span class="n">on_stdin_input</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">add_timer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">print_hello</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>This looks quite simple, and in practise, this is the method most commonly used
in Node.js code as well. However, in more complicated applications, this style
of writing asynchronous code, especially once error handling is added, quite
quickly becomes what is known as <em>callback hell</em>. To quote Guido van Rossum on
callbacks:</p>
<blockquote>
It requires super human discipline to write readable code in callbacks and
if you donât believe me look at any piece of JavaScript code. - Guido van
Rossum</blockquote>
<p>There are multiple other alternative approaches to this, such as promises and
coroutines (and about a million NPM libraries for each alternative). The one I
prefer the most (it's no secret that I think <a class="reference external" href="http://sahandsaba.com/combinatorial-generation-using-coroutines-in-python.html">coroutines are very cool</a>!)
is using coroutines. Next section goes over implementing a similar event loop
that uses coroutines as tasks.</p>
</div>
<div class="section" id="event-loops-with-coroutines">
<h2>Event Loops With Coroutines</h2>
<p>A <em>coroutine</em> is a function that can "return" while still remembering the state
in which it is returning (value of local variables, and what the next
instruction should be). This will then allow the coroutine to be called again,
which results in it continuing from where it left off. This form of "returning"
is often called <em>yielding</em>. I go into much more detail on coroutines and their
implementation in Python in my <a class="reference external" href="http://sahandsaba.com/combinatorial-generation-using-coroutines-in-python.html">combinatorial generation using coroutines article</a>.
Below I provide a much quicker introduction to them before we use them in the
example.</p>
<p>In Python, the <code class="py python3"><span class="k">yield</span></code> keyword can be used to create coroutines. When
used as a simple statement, such as <code class="py python3"><span class="k">yield</span> <span class="n">value</span></code>, the given value is
yielded, and control is given back to the caller. To continue the coroutine
starting from the instruction after the <code class="py python3"><span class="k">yield</span></code> statement, the caller
needs to use the built-in <code class="py python3"><span class="nb">next</span></code> function. When used as an expression,
such as <code class="py python3"><span class="n">y</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">x</span></code>, the value <code class="py python3"><span class="n">x</span></code> is yielded, and to continue
the coroutine, the coroutine's <code class="py python3"><span class="n">send</span></code> method can be used, in which case
the value given to <code class="py python3"><span class="n">send</span></code> will be sent back to the coroutine as the value
returned by the expression (and hence assigned to <code class="py python3"><span class="n">y</span></code> in this example).</p>
<p>This means that we can write our asynchronous code as coroutines, and simply
yield when we need to wait on an asynchronous operation. To do this, we simply
yield the task or other coroutine whose value we will need to continue. The
code will then look very sequential and similar to synchronous code. Here's a
simple example of what the Fibonacci portion of our solution will look
like:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">read_input</span><span class="p">():</span>
    <span class="k">while</span> <span class="k">True</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">"fib({}) = {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">timed_fib</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
</pre></div>
<p>Of course for this to work, we will need an event loop that can handle
coroutines. To achieve this, we will maintain a queue of tasks to be run by the
event loop. When input is available, or a timer goes off (or more generally,
any other event that we care about), we have a list of coroutines that need to
continue (possibly with a value to be sent to them). With each task, we have a
bound <code>stack</code> variable that keeps track of the stack of coroutines to run
in the chain, each depending on the next to finish. This is based on the
example of a "Trampoline" provided in <a class="reference external" href="http://legacy.python.org/dev/peps/pep-0342/">PEP 342</a>. I also use
<code class="py python3"><span class="n">functools</span><span class="o">.</span><span class="n">partial</span></code> as the Python equivalent of <code>Function.prototype.bind</code> in
JavaScript, namely to <a class="reference external" href="http://en.wikipedia.org/wiki/Currying">Curry</a> a
function by binding parameter values to it.</p>
<p>This is what it would look like:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">bisect</span> <span class="k">import</span> <span class="n">insort</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">fib</span> <span class="k">import</span> <span class="n">timed_fib</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="nn">selectors</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">types</span>


<span class="k">class</span> <span class="nc">sleep_for_seconds</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Yield an object of this type from a coroutine to have it "sleep" for the</span>
<span class="sd">    given number of seconds.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wait_time</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wait_time</span> <span class="o">=</span> <span class="n">wait_time</span>


<span class="k">class</span> <span class="nc">EventLoop</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Implements a simplified coroutine-based event loop as a demonstration.</span>
<span class="sd">    Very similar to the "Trampoline" example in PEP 342, with exception</span>
<span class="sd">    handling taken out for simplicity, and selectors added to handle file IO</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">tasks</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="k">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selector</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">DefaultSelector</span><span class="p">()</span>

        <span class="c"># Queue of functions scheduled to run</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>

        <span class="c"># (coroutine, stack) pair of tasks waiting for input from stdin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tasks_waiting_on_stdin</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># List of (time_to_run, task) pairs, in sorted order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timers</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># Register for polling stdin for input to read</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="p">,</span> <span class="n">selectors</span><span class="o">.</span><span class="n">EVENT_READ</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">resume_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coroutine</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="p">()):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">coroutine</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="k">None</span><span class="p">,</span> <span class="p">(</span><span class="n">coroutine</span><span class="p">,</span> <span class="n">stack</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">sleep_for_seconds</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">coroutine</span><span class="p">,</span> <span class="k">None</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">result</span><span class="o">.</span><span class="n">_wait_time</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">result</span> <span class="ow">is</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tasks_waiting_on_stdin</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">coroutine</span><span class="p">,</span> <span class="n">stack</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">stack</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">result</span><span class="p">,</span> <span class="n">stack</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">schedule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coroutine</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="p">(),</span> <span class="n">when</span><span class="o">=</span><span class="k">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Schedule a coroutine task to be run, with value to be sent to it, and</span>
<span class="sd">        stack containing the coroutines that are waiting for the value yielded</span>
<span class="sd">        by this coroutine.</span>
<span class="sd">        """</span>
        <span class="c"># Bind the parameters to a function to be scheduled as a function with</span>
        <span class="c"># no parameters.</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resume_task</span><span class="p">,</span> <span class="n">coroutine</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">when</span><span class="p">:</span>
            <span class="n">insort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_timers</span><span class="p">,</span> <span class="p">(</span><span class="n">when</span><span class="p">,</span> <span class="n">task</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="k">False</span>

    <span class="k">def</span> <span class="nf">do_on_next_tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">run_forever</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="k">True</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_running</span><span class="p">:</span>
            <span class="c"># First check for available IO input</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selector</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">fileobj</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">task</span><span class="p">,</span> <span class="n">stack</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tasks_waiting_on_stdin</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tasks_waiting_on_stdin</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

            <span class="c"># Next, run the next task</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span><span class="p">:</span>
                <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">task</span><span class="p">()</span>

            <span class="c"># Finally run time scheduled tasks</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timers</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">time</span><span class="p">():</span>
                <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">task</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="k">False</span>


<span class="k">def</span> <span class="nf">print_every</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Coroutine task to repeatedly print the message at the given interval</span>
<span class="sd">    (in seconds)</span>
<span class="sd">    """</span>
    <span class="k">while</span> <span class="k">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">"{} - {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="p">()),</span> <span class="n">message</span><span class="p">))</span>
        <span class="k">yield</span> <span class="n">sleep_for_seconds</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">read_input</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Coroutine task to repeatedly read new lines of input from stdin, treat</span>
<span class="sd">    the input as a number n, and calculate and display fib(n).</span>
<span class="sd">    """</span>
    <span class="k">while</span> <span class="k">True</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span>
        <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s">'exit'</span><span class="p">:</span>
            <span class="n">loop</span><span class="o">.</span><span class="n">do_on_next_tick</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">"fib({}) = {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">timed_fib</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">EventLoop</span><span class="p">()</span>
    <span class="n">hello_task</span> <span class="o">=</span> <span class="n">print_every</span><span class="p">(</span><span class="s">'Hello world!'</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">fib_task</span> <span class="o">=</span> <span class="n">read_input</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">hello_task</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">fib_task</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>Note that this implementation also lets us add a simple <code class="py python3"><span class="n">do_on_next_tick</span></code>
function which more or less does what <code class="py python3"><span class="n">process</span><span class="o">.</span><span class="n">nextTick</span></code> does in Node.js. I
use it to implement a simple type <tt class="docutils literal">exit</tt> to quit feature. (Although, I didn't
really have to use <code class="py python3"><span class="n">do_on_next_tick</span></code>, I could have just called
<code class="py python3"><span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span></code> directly!)</p>
<p>Another interesting thing to point out here is that we can re-implement our
recursive Fibonacci algorithm using coroutines instead of recursive calls, and
in doing so we can have it run in "parallel" to other coroutines, including the
one that prints hello. This is what it would look like:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">event_loop_coroutine</span> <span class="k">import</span> <span class="n">EventLoop</span>
<span class="kn">from</span> <span class="nn">event_loop_coroutine</span> <span class="k">import</span> <span class="n">print_every</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">read_input</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
    <span class="k">while</span> <span class="k">True</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">fib_n</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">"fib({}) = {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">fib_n</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">EventLoop</span><span class="p">()</span>
    <span class="n">hello_task</span> <span class="o">=</span> <span class="n">print_every</span><span class="p">(</span><span class="s">'Hello world!'</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">fib_task</span> <span class="o">=</span> <span class="n">read_input</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">hello_task</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">fib_task</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>The output for this program will be:</p>
<div class="highlight"><pre>$ python3.4 fib_coroutine.py
1412727829 - Hello world!
1412727832 - Hello world!
28
1412727835 - Hello world!
1412727838 - Hello world!
fib(28) = 317811
1412727841 - Hello world!
1412727844 - Hello world!
</pre></div>
</div>
<div class="section" id="not-reinventing-the-wheel">
<h2>Not Reinventing The Wheel</h2>
<p>In the previous two sections, we went over the general ideas that go into
implementing an event loop to allow us to write asynchronous code using either
callbacks or coroutines. This was great for the purposes of experimenting and
learning about the ideas but in practise, there are already quite mature
libraries for Python that provide event loops. In addition, Python 3.4 ships
with the <code class="py python3"><span class="n">asyncio</span></code> module that has event loops and coroutines for IO
operations, networking, and more. Let's first solve the above problem using
<code class="py python3"><span class="n">asyncio</span></code> and then look at a few more interesting examples.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">time</span>
<span class="kn">from</span> <span class="nn">fib</span> <span class="k">import</span> <span class="n">timed_fib</span>


<span class="k">def</span> <span class="nf">process_input</span><span class="p">():</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">'fib({}) = {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">timed_fib</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>


<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">print_hello</span><span class="p">():</span>
    <span class="k">while</span> <span class="k">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">"{} - Hello world!"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="p">())))</span>
        <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="p">,</span> <span class="n">process_input</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">print_hello</span><span class="p">())</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>Notice how <code class="py python3"><span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span></code> is used to decorate coroutines, and
<code class="py python3"><span class="k">yield from</span></code> as opposed to just <code class="py python3"><span class="k">yield</span></code> is used to values from other
coroutines.</p>
</div>
<div class="section" id="handling-exceptions">
<h2>Handling Exceptions</h2>
<p>Python's coroutine's allow an exception to be thrown in the stack frame of the
coroutine, and have it be caught at the point the coroutine has paused. Let's
look at a simple example:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">coroutine</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">"Starting"</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="s">"Let's pause until continued."</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">"Continuing"</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">yield</span> <span class="s">"Got an exception: "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">coroutine</span><span class="p">()</span>
    <span class="nb">next</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  <span class="c"># Execute until the first yield</span>
    <span class="c"># Now throw an exception at the point where the coroutine has paused</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">Exception</span><span class="p">(</span><span class="s">"Have an exceptional day!"</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>Which outputs:</p>
<div class="highlight"><pre>Starting
Got an exception: Have an exceptional day!
</pre></div>
<p>This makes it rather easy to have one unified way of handling errors using
exceptions, in both synchronous and asynchronous code, provided the event loop
catches and propagates exceptions properly. For example, let's look at an
example with chained coroutines and an event loop:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>


<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">A</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">"Something went wrong in A!"</span><span class="p">)</span>


<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">B</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">A</span><span class="p">()</span>
    <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>


<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">C</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">B</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">"C got exception:"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">C</span><span class="p">())</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>Output:</p>
<div class="highlight"><pre>C got exception: Something went wrong in A!
</pre></div>
<p>In this example, coroutine <code class="py python3"><span class="n">C</span></code> relies on the result of <code class="py python3"><span class="n">B</span></code> which in
turn relies on the result of <code class="py python3"><span class="n">A</span></code>, which decides to throw an exception. As
you can see, the exception gets propagated all the way <code class="py python3"><span class="n">C</span></code>, which catches
it and prints the message. As you can see, this behaves almost exactly the same
as synchronous code would. No more catching and passing of errors through
callbacks manually!</p>
<p>Of course, this example is rather theoretical and uninspired. Let's look at a
real example: let's write some code to asynchronously grab the external IP
address of the computer using <a class="reference external" href="http://www.ipify.org">ipify</a>. Since
<code class="py python3"><span class="n">asyncio</span></code> does not ship with an HTTP client (yet, anyway!) we have to go to
the TCP level and write the HTTP request and parse the response ourselves.
Since we are doing this with a very specific API in mind (and as an example,
not production code!), let's actually go ahead and do this. In practise, using
a library meant for exactly this, for example <code class="py python3"><span class="n">aiohttp</span></code>, is a much better
idea of course. Let's see what this looks like:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">json</span>


<span class="n">host</span> <span class="o">=</span> <span class="s">'api.ipify.org'</span>
<span class="n">request_headers</span> <span class="o">=</span> <span class="p">{</span><span class="s">'User-Agent'</span><span class="p">:</span> <span class="s">'python/3.4'</span><span class="p">,</span>
                   <span class="s">'Host'</span><span class="p">:</span> <span class="n">host</span><span class="p">,</span>
                   <span class="s">'Accept'</span><span class="p">:</span> <span class="s">'application/json'</span><span class="p">,</span>
                   <span class="s">'Accept-Charset'</span><span class="p">:</span> <span class="s">'UTF-8'</span><span class="p">}</span>


<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">write_headers</span><span class="p">(</span><span class="n">writer</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">request_headers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="n">key</span> <span class="o">+</span> <span class="s">': '</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="s">'</span><span class="se">\r\n</span><span class="s">'</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s">'</span><span class="se">\r\n</span><span class="s">'</span><span class="p">)</span>
    <span class="k">yield from</span> <span class="n">writer</span><span class="o">.</span><span class="n">drain</span><span class="p">()</span>


<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">read_headers</span><span class="p">(</span><span class="n">reader</span><span class="p">):</span>
    <span class="n">response_headers</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">while</span> <span class="k">True</span><span class="p">:</span>
        <span class="n">line_bytes</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line_bytes</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">response_headers</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">response_headers</span>


<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">get_my_ip_address</span><span class="p">(</span><span class="n">verbose</span><span class="p">):</span>
    <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s">'GET /?format=json HTTP/1.1</span><span class="se">\r\n</span><span class="s">'</span><span class="p">)</span>
    <span class="k">yield from</span> <span class="n">write_headers</span><span class="p">(</span><span class="n">writer</span><span class="p">)</span>
    <span class="n">status_line</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="n">status_line</span> <span class="o">=</span> <span class="n">status_line</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">http_version</span><span class="p">,</span> <span class="n">status_code</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">status_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">'Got status {} {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">status_code</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span>
    <span class="n">response_headers</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">read_headers</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">'Response headers:'</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">response_headers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="s">': '</span> <span class="o">+</span> <span class="n">value</span><span class="p">)</span>
    <span class="c"># Assume the content length is sent by the server, which is the case</span>
    <span class="c"># with ipify</span>
    <span class="n">content_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">response_headers</span><span class="p">[</span><span class="s">'Content-Length'</span><span class="p">])</span>
    <span class="n">response_body_bytes</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">content_length</span><span class="p">)</span>
    <span class="n">response_body</span> <span class="o">=</span> <span class="n">response_body_bytes</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">response_object</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">response_body</span><span class="p">)</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">response_object</span><span class="p">[</span><span class="s">'ip'</span><span class="p">]</span>


<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">print_my_ip_address</span><span class="p">(</span><span class="n">verbose</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ip_address</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">get_my_ip_address</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">"My IP address is:"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ip_address</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">"Error: "</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">print_my_ip_address</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="k">True</span><span class="p">))</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>Again, notice the similarity to synchronous code: no callbacks, no complicated
error handling, just easy and very readable code. Let's see how it works,
without any errors:</p>
<div class="highlight"><pre>$ python3.4 ipify.py
Got status 200 OK
Response headers:
Content-Length: 21
Server: Cowboy
Connection: keep-alive
Via: 1.1 vegur
Content-Type: application/json
Date: Fri, 10 Oct 2014 03:46:31 GMT
My IP address is:
&lt;my IP address here, hidden for privacy!&gt;
</pre></div>
<p>On the other hand, if something goes wrong, for example if I am not connected
to the internet, here is the output:</p>
<div class="highlight"><pre>$ python3.4 ipify.py
Error:  [Errno 8] nodename nor servname provided, or not known
</pre></div>
<p>This is one of the main advantages to using coroutines for asynchronous code in
my opinion: error handling will be perfectly consistent with synchronous code.
For example, in the above, it doesn't matter if one of the chained coroutines
fails, or if one of the synchronous calls fails, the exception is caught and
handled the exact same way.</p>
</div>
<div class="section" id="relying-on-the-results-of-multiple-independent-coroutines">
<h2>Relying On The Results of Multiple Independent Coroutines</h2>
<p>In the above examples, we wrote asynchronous code that was inherently
sequential, meaning each statement in a coroutine relies on the previous
statements finishing before continuing. Sometimes, we want to execute a set of
independent tasks and use them <em>as completed</em>, without caring about the order
they run in.  For example, as a web crawler, we might want to send asynchronous
requests to all the links on a web page and add the responses to a queue to be
processed as we go.</p>
<p>Coroutines allow for writing asynchronous code that flows very sequentially,
but for running independent tasks and processing their results either all at
once or as they come, callbacks may, at first, seem to be better. However,
Python 3.4's <code class="py python3"><span class="n">asyncio</span></code> comes with built-in functions for precisely these
two scenarios, namely functions <code class="py python3"><span class="n">asyncio</span><span class="o">.</span><span class="n">as_completed</span></code> and
<code class="py python3"><span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span></code>.</p>
<p>Let's look at a simple example in which we need to load three URLs. We do it in
two ways, first by processing the results as they come in using
<code class="py python3"><span class="n">asyncio</span><span class="o">.</span><span class="n">as_completed</span></code>, and in the next one only once they have all
finished loading using <code class="py python3"><span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span></code>. Instead of actually loading URLs,
I chose to have a simple coroutine that pauses for random number of seconds.
Here's the code:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">random</span>


<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">get_url</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">wait_time</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">wait_time</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">'Done: URL {} took {}s to get!'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">wait_time</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">url</span><span class="p">,</span> <span class="n">wait_time</span>


<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">process_as_results_come_in</span><span class="p">():</span>
    <span class="n">coroutines</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="p">[</span><span class="s">'URL1'</span><span class="p">,</span> <span class="s">'URL2'</span><span class="p">,</span> <span class="s">'URL3'</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">coroutine</span> <span class="ow">in</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">as_completed</span><span class="p">(</span><span class="n">coroutines</span><span class="p">):</span>
        <span class="n">url</span><span class="p">,</span> <span class="n">wait_time</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">coroutine</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">'Coroutine for {} is done'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">url</span><span class="p">))</span>


<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">process_once_everything_ready</span><span class="p">():</span>
    <span class="n">coroutines</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="p">[</span><span class="s">'URL1'</span><span class="p">,</span> <span class="s">'URL2'</span><span class="p">,</span> <span class="s">'URL3'</span><span class="p">]]</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">coroutines</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">"First, process results as they come in:"</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">process_as_results_come_in</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Now, process results once they are all ready:"</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">process_once_everything_ready</span><span class="p">())</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>And the output:</p>
<div class="highlight"><pre>$ python3.4 gather.py
First, process results as they come in:
Done: URL URL2 took 2s to get!
Coroutine for URL2 is done
Done: URL URL3 took 3s to get!
Coroutine for URL3 is done
Done: URL URL1 took 4s to get!
Coroutine for URL1 is done

Now, process results once they are all ready:
Done: URL URL1 took 1s to get!
Done: URL URL2 took 3s to get!
Done: URL URL3 took 4s to get!
[('URL1', 1), ('URL2', 3), ('URL3', 4)]
</pre></div>
</div>


            </div>



</div></body></html>