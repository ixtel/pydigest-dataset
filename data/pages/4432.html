<html><body><div><div class="post-body entry-content" id="post-body-4375652711495636911">
<p>Finally!  CFFI 1.0 is almost ready.  CFFI gives Python developers a convenient way to call external C libraries.  Here "Python" == "CPython or PyPy", but this post is mostly about the CPython side of CFFI, as the PyPy version is not ready yet.</p>
<p>On CPython, you can download the version
"1.0.0b1" either by looking for the <code>cffi-1.0</code> branch in
<a href="https://bitbucket.org/cffi/cffi">the repository</a>, or by
saying</p>

<tt class="docutils literal">pip install <span class="pre">"cffi&gt;=1.0.dev0&amp;quot</span></tt>

<p>(Until 1.0 final is ready,
<tt class="docutils literal">pip install cffi</tt> will still give you version 0.9.2.)</p>
<p>The main news: you can now explicitly generate and compile a CPython C
extension module from a "build" script.  Then in the rest of your
program or library, you no longer need to import cffi at all.
Instead, you simply say:</p>
<pre class="literal-block">
from _my_custom_module import ffi, lib
</pre>
<p>Then you use <tt class="docutils literal">ffi</tt> and <tt class="docutils literal">lib</tt> just like you did in your
<tt class="docutils literal">verify()</tt>-based project in CFFI 0.9.2.  (The <tt class="docutils literal">lib</tt> is what used to
be the result of <tt class="docutils literal">verify()</tt>.)  The details of <em>how</em> you use them
should not have changed at all, so that the rest of your program should
not need any update.</p>
<div class="section" id="benefits">
<h2>Benefits</h2>
<p>This is a big step towards standard practices for making and
distributing Python packages with C extension modules:</p>
<ul class="simple">
<li>on the one hand, you need an explicit compilation step, triggered
here by running the "build" script;</li>
<li>on the other hand, what you gain in return is better control over
when and why the C compilation occurs, and more standard ways to write
distutils- or setuptools-based <tt class="docutils literal">setup.py</tt> files (see below).</li>
</ul>
<p>Additionally, this completely removes one of the main drawbacks of using
CFFI to interface with large C APIs: the start-up time.  In some cases
it could be extreme on slow machines (cases of 10-20 seconds on ARM
boards occur commonly).  Now, the <tt class="docutils literal">import</tt> above is instantaneous.</p>
<p>In fact, none of the pure Python <tt class="docutils literal">cffi</tt> package is needed any more at
runtime (it needs only an internal extension module from CFFI, which
can be installed by doing "<tt class="docutils literal">pip install <span class="pre">cffi-runtime</span></tt>" [*] if you only need that).
The <tt class="docutils literal">ffi</tt> object you get by the import above is of a
completely different class written entirely in C.  The two
implementations might get merged in the future; for now they are
independent, but give two compatible APIs.  The differences are that
some methods like <tt class="docutils literal">cdef()</tt> and <tt class="docutils literal">verify()</tt> and <tt class="docutils literal">set_source()</tt> are
omitted from the C version, because it is supposed to be a complete FFI
already; and other methods like <tt class="docutils literal">new()</tt>, which take as parameter a
string describing a C type, are faster now because that string is parsed
using a custom small-subset-of-C parser, written in C too.</p>
</div>
<div class="section" id="in-practice">
<h2>In practice</h2>
<p>CFFI 1.0 beta 1 was tested on CPython 2.7 and 3.3/3.4, on Linux and to
some extent on Windows and OS/X.  Its PyPy version is not ready yet,
and the only docs available so far are those below.</p>
<p>This is <em>beta</em> software, so there might be bugs and details may change.  We are interested in hearing any feedback (irc.freenode.net #pypy) or <a href="https://bitbucket.org/cffi/cffi/issues?status=new&amp;status=open">bug reports.</a></p>
<p>To use the new features, create a source file that is <em>not</em> imported by the rest of
your project, in which you place (or move) the code to build the FFI
object:</p>
<pre class="literal-block">
# foo_build.py
import cffi
ffi = cffi.FFI()

ffi.cdef("""
    int printf(const char *format, ...);
""")

ffi.set_source("_foo", """
    #include &lt;stdio.h&gt;
""")   # and other arguments like libraries=[...]

if __name__ == '__main__':
    ffi.compile()
</pre>
<p>The <tt class="docutils literal">ffi.set_source()</tt> replaces the <tt class="docutils literal">ffi.verify()</tt> of CFFI 0.9.2.
Calling it attaches the given source code to the ffi object, but this call doesn't
compile or return anything by itself.  It may be placed above the <tt class="docutils literal">ffi.cdef()</tt>
if you prefer.  Its first argument is the name of the C extension module
that will be produced.</p>
<p>Actual compilation (including generating the complete C sources) occurs
later, in one of two places: either in <tt class="docutils literal">ffi.compile()</tt>, shown above,
or indirectly from the <tt class="docutils literal">setup.py</tt>, shown next.</p>
<p>If you directly execute the file <tt class="docutils literal">foo_build.py</tt> above, it will
generate a local file <tt class="docutils literal">_foo.c</tt> and compile it to <tt class="docutils literal">_foo.so</tt> (or the
appropriate extension, like <tt class="docutils literal">_foo.pyd</tt> on Windows).  This is the
extension module that can be used in the rest of your program by saying
"<tt class="docutils literal">from _foo import ffi, lib</tt>".</p>
</div>
<div class="section" id="distutils">
<h2>Distutils</h2>
<p>If you want to distribute your program, you write a <tt class="docutils literal">setup.py</tt> using
either distutils or setuptools.  Using setuptools is generally
recommended nowdays, but using distutils is possible too.  We show it
first:</p>
<pre class="literal-block">
# setup.py
from distutils.core import setup
import foo_build

setup(
    name="example",
    version="0.1",
    py_modules=["example"],
    ext_modules=[foo_build.ffi.distutils_extension()],
)
</pre>
<p>This is similar to the CFFI 0.9.2 way.  It only works if cffi was
installed previously, because otherwise <tt class="docutils literal">foo_build</tt> cannot be
imported.  The difference is that you use <tt class="docutils literal">ffi.distutils_extension()</tt>
instead of <tt class="docutils literal">ffi.verifier.get_extension()</tt>, because there is no longer
any <tt class="docutils literal">verifier</tt> object if you use <tt class="docutils literal">set_source()</tt>.</p>
</div>

<div class="section" id="thanks">
<h2>Thanks</h2>
<p>Special thanks go to the PSF (Python Software Foundation) for their
financial support, without which this work---er... it might likely have occurred anyway, but at an unknown future date :-)</p>
<p>(For reference, the amount I asked for (and got) is equal to one
month of what a Google Summer of Code student gets, for work that will
take a bit longer than one month. At least I personally am running mostly
on such money, and so I want to thank the PSF again for their
contribution to CFFI---and while I'm at it, thanks to all other
contributors to PyPy---for making this job more than an unpaid hobby on
the side :-)</p>

<p><i>Armin Rigo</i></p>
</div>
<p/>
</div>
</div></body></html>