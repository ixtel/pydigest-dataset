<html><body><div><div id="content">

<p id="subheading">More stateful functions.</p>






<div class="paragraph">
<p>A good friend of mine once described <a href="http://krenzel.info/?p=95">two complaints</a> about Python, the more serious of the two being self hell.  Self hell is usually something Pythonistas grumble about from time to time.  Basically, you find that every line in your program begins with <code>self</code>.  Every other word in the program is <code>self</code>.  For a language without needless braces, begins, ends or other useless syntax, the over abundance of a single token really stands out.  This is self hell.
</p>
</div>

<p class="clear"> </p>
<div class="p_c_summary">
<div class="post"><p>There is an obvious trick to avoiding self hell:  don't ever use <code>self</code>.
</p></div>

</div>
<p class="clear"> </p>


<div class="paragraph">
<p>Chain of implications:  No <code>self</code> means no classes.  No classes means no object orientedness.  If you were a Java or C++ programmer once, you probably think I am a crackpot.
</p>
</div>

<div class="paragraph">
<p>There is more to life than OOP.  Here is a simple little class, whose only purpose is window comparison.
</p>
</div>

<div class="paragraph">
<pre><code>class Window(object):
    def __init__(self, minimum, maximum):
        self.minimum = minimum
        self.maximum = maximum
    def __call__(self, x):
        return self.minimum &lt;= x &lt;= self.maximum
</code></pre>
</div>

<div class="paragraph">
<p>Does not seem so bad.<br/>
<code>Self</code> requires on average five characters per line, nothing horrible.
</p>
</div>



<div class="paragraph">
<pre><code>&gt;&gt;&gt; between = Window(1,5)
&gt;&gt;&gt; between(2.4)
True
&gt;&gt;&gt; between(-7)
False
&gt;&gt;&gt; between(12)
False
</code></pre>
</div>

<div class="paragraph">
<p>Now, let's say you need to add a feature.  Defensively protect the input so that <code>minimum</code> and <code>maximum</code> may arrive out of order.
</p>
</div>

<p class="clear"> </p>
<div class="p_c_summary">
<div class="post"><pre><code>class Window(object):
    def __init__(self, minimum, maximum):
        self.minimum = minimum
        self.maximum = maximum
        self.minimum, self.maximum = min(self.minimum, self.maximum), max(self.minimum, self.maximum)
    def __call__(self, x):
        return self.minimum &lt;= x &lt;= self.maximum
</code></pre></div>

</div>
<p class="clear"> </p>


<div class="paragraph">
<p>That newest line sums up what self hell is all about.  It could be mitigated by swapping <code>min</code> &amp; <code>max</code> before saving them to <code>self.min</code> &amp; <code>self.max</code>, but eventually you'll need a line like this outside of <code>init</code>, and there will be no other course but the gratuitous use of <code>self</code>.
</p>
</div>

<div class="paragraph">
<p>Let's remake it using closures.  Closures, in a nutshell, allow functions to be defined on the fly while remembering the function's scope.  Note this code already includes the defensive variable swap.
</p>
</div>

<div class="paragraph">
<pre><code>def Window(minimum, maximum):
    def w(x):
        return minimum &lt;= x &lt;= maximum
    minimum, maximum = min(minimum, maximum), max(minimum, maximum)
    return w
</code></pre>
</div>

<div class="paragraph">
<p><code>Self</code> never appears once.  The use case is identical.  It is smaller (quantitatively) and more elegant (qualitatively).
</p>
</div>

<div class="paragraph">
<p>But what the heck is up with the nested <code>def</code>s?<br/>
<code>w()</code> is called an inner function.  If you've never heard of it before, don't feel too bad, lots of really smart people have not either.  Why, until recently Vim did not know how to automatically indent such code.
</p>
</div>

<div class="paragraph">
<p>The closure part is not having to explicitly pass <code>minimum</code> or <code>maximum</code> to <code>w()</code>.  When python tries to execute <code>w()</code>, it looks for <code>min</code> and <code>max</code> inside of <code>w()</code>.  It does not see them, so it checks the next scope up, <code>Window()</code>.  The double checking costs a few CPU cycles but saves a lot of keystrokes.
</p>
</div>

<div class="paragraph">
<p>Some claim objects are needed for storing changing state between calls.  Not so.  For example, say you have a prime number generator.  Every time you instance it, the generator starts over from 2, the first prime.  Every time <code>next()</code> is called, the generator returns the next prime.  Simple enough.
</p>
</div>

<div class="paragraph">
<p>A smarter prime number generator would cache the previous results, so each new instance does not have to recompute every number from the very beginning.  Normally this screams "Use an object!".  It can all be done with a single function:
</p>
</div>

<div class="paragraph">
<pre><code>def primes(p_cache=[2]):
    for i in p_cache:
        yield i
    for i in count(p_cache[-1] + 1):
        sqr = int(i**0.5) + 1
        if all(i%p for p in takewhile(lambda x: x&lt;sqr, p_cache)):
            p_cache.append(i)
            yield i
</code></pre>
</div>

<div class="paragraph">
<p>Ever been bitten by a Python's default argument behavior?  This hack uses that classic gotcha to update the <code>p_cache</code> list.  It is not the most idiomatic code.  While it proves you can do almost anything with just functions, it is also proof I should have my Python Licence revoked.
</p>
</div>

<p class="clear"> </p>
<div class="p_c_summary">
<div class="post"><p>There are two cases were defining a class is pretty much unavoidable:  defining new data structures and changing Python's syntax.  If you want to make a Tree type, you'll need to class it.  If you want to do stuff like this:
</p></div>

</div>
<p class="clear"> </p>


<div class="paragraph">
<pre><code>&gt;&gt;&gt; 'Do a barrel shift!' &lt;&lt; 5
'barrel shift!Do a '
</code></pre>
</div>

<div class="paragraph">
<p>You'll have to make a new <code>String</code> object inheriting from the old <code>String</code>, extended with <code>lshift</code> and <code>rshift</code>.
</p>
</div>

<div class="paragraph">
<p>I've found that a hybrid approach works best.  All of your class methods that actually do computation should be moved into closures, and extensions to clean up syntax should be kept in classes.  Stuff the closures into classes, treating the class much like a namespace.  The closures are essentially static functions, and so do not require <code>self</code>s*, even in the class.
</p>
</div>

<div class="paragraph">
<ul>
 <li>
     <code>Self</code>s, plural.  Functions still need one <code>self</code>, in the function definition.
 </li>
</ul>
</div>
<p class="clear"> </p>



</div>
</div></body></html>