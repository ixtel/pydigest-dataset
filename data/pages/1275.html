<html><body><div><div id="article">
  
  <h1>Python Mock Gotchas</h1>

  
<p>
Published on 16 November 2012, updated on 16 November 2012, <a href="http://alexmarandon.com/articles/python_mock_gotchas/#disqus_thread">Comments</a>
</p>





<p><a href="http://www.voidspace.org.uk/python/mock/">Mock</a> is a Python mocking and
testing library. It has become a <em>de facto</em> standard and is now <a href="http://docs.python.org/3/library/unittest.mock.html">included in the
Python standard library</a>. </p>

<p>Lately Iâve had the chance to work on a fairly large code base built upon a
service-oriented architecture. In order to test each service in isolation, we
make extensive use of Mock to simulate services that the code under test depends
on.</p>

<p>During this process, we noticed that each member our team seemed to be hitting
the same pitfalls, which Iâm going to present in this article in the hope that
it might help other developers.</p>

<h2 id="patching-in-the-wrong-place">Patching in the wrong place</h2>

<p>The first thing that puzzles people is when the <code>patch</code> method seem to have no
effect.</p>

<p>Letâs consider a very simple example where you have some kind of domain model
object that uses a data source module to get data and return it to the client.
In a real world situation, the data source module would query a database or an external
service. For the sake of simplicity, here the data source just returns
hard-coded values:</p>

<pre class="code-snippet CodeRay"><code class="language-python"><span class="comment"># data_source.py</span>
<span class="keyword">def</span> <span class="function">get_name</span>():
    <span class="keyword">return</span> <span class="string"><span class="delimiter">"</span><span class="content">Alice</span><span class="delimiter">"</span></span></code></pre>

<p>The <code>Person</code> class exposes a method that fetches data from the data source:</p>

<pre class="code-snippet CodeRay"><code class="language-python"><span class="comment"># person.py</span>
<span class="keyword">from</span> <span class="include">data_source</span> <span class="keyword">import</span> <span class="include">get_name</span>

<span class="keyword">class</span> <span class="class">Person</span>(<span class="predefined">object</span>):
    <span class="keyword">def</span> <span class="function">name</span>(<span class="predefined-constant">self</span>):
        <span class="keyword">return</span> get_name()</code></pre>

<p>One might then start to write a test case that looks like this:</p>

<pre class="code-snippet CodeRay"><code class="language-python"><span class="comment"># test_person.py</span>
<span class="keyword">from</span> <span class="include">mock</span> <span class="keyword">import</span> <span class="include">patch</span>
<span class="keyword">from</span> <span class="include">person</span> <span class="keyword">import</span> <span class="include">Person</span>

<span class="comment"># mock the get_name function</span>
<span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">data_source.get_name</span><span class="delimiter">'</span></span>) <span class="comment"># This won't work as expected!</span>
<span class="keyword">def</span> <span class="function">test_name</span>(mock_get_name):
    <span class="comment"># set a return value for our mock object</span>
    mock_get_name.return_value = <span class="string"><span class="delimiter">"</span><span class="content">Bob</span><span class="delimiter">"</span></span> 
    person = Person()
    name = person.name()
    <span class="keyword">assert</span> name == <span class="string"><span class="delimiter">"</span><span class="content">Bob</span><span class="delimiter">"</span></span></code></pre>

<p>Unfortunately, the example above doesnât work as expected. If you run it with a testing tool such as <a href="https://nose.readthedocs.org/en/latest/">nose</a>, youâll get a result similar to:</p>

<pre class="code-snippet CodeRay"><code class="language-shell">$ nosetests test_person.py
F
======================================================================
FAIL: test_person.test_name
----------------------------------------------------------------------
[...]
    return func(*args, **keywargs)
  File "/home/al/essais/python/test_person.py", line 13, in test_name
    assert name == "Bob"
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.002s

FAILED (failures=1)</code></pre>

<p>The reason why it doesnât work is explained in the documentation in a section called <a href="http://www.voidspace.org.uk/python/mock/patch.html#where-to-patch">Where to patch</a>. Now go and read it if you havenât already, Iâll wait for you right here.</p>

<p>The problem in the example above is that weâre changing where the <em>name</em>
<code>get_name</code> points to within the <code>data_source</code> module. However the code weâre
testing doesnât refer to <code>get_name</code> within the <code>data_source</code> module, it refers
to that <em>name</em> within the <code>person</code> module.</p>

<p>Our patching would have worked correctly if the code under test had referred to
<code>get_name</code> within the <code>data_source</code> module like this:</p>

<pre class="code-snippet CodeRay"><code class="language-python"><span class="comment"># person.py</span>
<span class="keyword">import</span> <span class="include">data_source</span>

<span class="keyword">class</span> <span class="class">Person</span>(<span class="predefined">object</span>):
    <span class="keyword">def</span> <span class="function">name</span>(<span class="predefined-constant">self</span>):
        <span class="keyword">return</span> data_source.get_name()</code></pre>

<p>If we want to leave our application code unchanged, weâll have to change the
way we use Mock within our test so that it modifies where <code>get_name</code> points to
within the <code>person</code> module:</p>

<pre class="code-snippet CodeRay"><code class="language-python"><span class="keyword">from</span> <span class="include">mock</span> <span class="keyword">import</span> <span class="include">patch</span>
<span class="keyword">from</span> <span class="include">person</span> <span class="keyword">import</span> <span class="include">Person</span>

<span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">person.get_name</span><span class="delimiter">'</span></span>)
<span class="keyword">def</span> <span class="function">test_name</span>(mock_get_name):
    mock_get_name.return_value = <span class="string"><span class="delimiter">"</span><span class="content">Bob</span><span class="delimiter">"</span></span>
    person = Person()
    name = person.name()
    <span class="keyword">assert</span> name == <span class="string"><span class="delimiter">"</span><span class="content">Bob</span><span class="delimiter">"</span></span></code></pre>

<h2 id="forgetting-to-patch-the-returnvalue">Forgetting to patch the return_value</h2>

<p>Another common issue is patching an object instead of patching the return value
of that object. It is particularly easy to get trapped into this when patching
objects deep down inside a chain of class instantiations and method calls.</p>

<p>Letâs say <code>Person</code> has a relationship with <code>Pet</code>:</p>

<pre class="code-snippet CodeRay"><code class="language-python"><span class="keyword">class</span> <span class="class">Person</span>(<span class="predefined">object</span>):
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="predefined-constant">self</span>):
        <span class="predefined-constant">self</span>.pet = Pet()
    [... other methods ...]

<span class="keyword">class</span> <span class="class">Pet</span>(<span class="predefined">object</span>):
    <span class="keyword">def</span> <span class="function">noise</span>(<span class="predefined-constant">self</span>):
        <span class="keyword">return</span> <span class="string"><span class="delimiter">"</span><span class="content">Woof</span><span class="delimiter">"</span></span></code></pre>

<p>It might look natural to write a test like this:</p>

<pre class="code-snippet CodeRay"><code class="language-python"><span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">person.Pet</span><span class="delimiter">'</span></span>)
<span class="keyword">def</span> <span class="function">test_dog_noise</span>(mock_pet):
    mock_pet.noise.return_value = <span class="string"><span class="delimiter">"</span><span class="content">Meoow</span><span class="delimiter">"</span></span>
    person = Person()
    <span class="keyword">assert</span> person.pet.noise() == <span class="string"><span class="delimiter">"</span><span class="content">Meoow</span><span class="delimiter">"</span></span></code></pre>

<p>This wonât work because a <code>pet</code> object is the result of instantiating the <code>Pet</code>
class, which in Python means <em>calling</em> the class. We must therefore access the
<code>noise</code> method via the <code>return_value</code> of the mocked <code>Pet</code> class:</p>

<pre class="code-snippet CodeRay"><code class="language-python"><span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">person.Pet</span><span class="delimiter">'</span></span>)
<span class="keyword">def</span> <span class="function">test_dog_noise</span>(mock_pet):
    <span class="comment"># Here we need an extra `return_value` attribute in order to access the</span>
    <span class="comment"># instance of the class</span>
    mock_pet.return_value.noise.return_value = <span class="string"><span class="delimiter">"</span><span class="content">Meoow</span><span class="delimiter">"</span></span>
    person = Person()
    <span class="keyword">assert</span> person.pet.noise() == <span class="string"><span class="delimiter">"</span><span class="content">Meoow</span><span class="delimiter">"</span></span></code></pre>

<h2 id="patching-decorators">Patching decorators</h2>

<p>Patching decorators might also lead to some surprising behaviors. Letâs say we
have a very simple decorator that just logs the result of decorated functions:</p>

<pre class="code-snippet CodeRay"><code class="language-python"><span class="comment"># decorators.py</span>
<span class="keyword">def</span> <span class="function">noise_logger</span>(func):
    <span class="keyword">def</span> <span class="function">wrapped</span>(<span class="predefined-constant">self</span>):
        result = func(<span class="predefined-constant">self</span>)
        <span class="comment"># In a real-world scenario, the decorator would access an external</span>
        <span class="comment"># resource which we don't want our tests to depend on, such as a</span>
        <span class="comment"># caching service.</span>
        <span class="keyword">print</span> <span class="string"><span class="delimiter">"</span><span class="content">Pet made noise: </span><span class="delimiter">"</span></span>, result
        <span class="keyword">return</span> result
    <span class="keyword">return</span> wrapped</code></pre>

<p>Our domain model makes use of that decorator:</p>

<pre class="code-snippet CodeRay"><code class="language-python"><span class="comment"># person.py</span>
<span class="keyword">from</span> <span class="include">decorators</span> <span class="keyword">import</span> <span class="include">noise_logger</span>

<span class="keyword">class</span> <span class="class">Person</span>(<span class="predefined">object</span>):
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="predefined-constant">self</span>):
        <span class="predefined-constant">self</span>.pet = Pet()

<span class="keyword">class</span> <span class="class">Pet</span>(<span class="predefined">object</span>):
    <span class="decorator">@noise_logger</span>
    <span class="keyword">def</span> <span class="function">noise</span>(<span class="predefined-constant">self</span>):
        <span class="keyword">return</span> <span class="string"><span class="delimiter">"</span><span class="content">Woof</span><span class="delimiter">"</span></span></code></pre>

<p>Now weâd like to patch our decorator to make sure it doesnât call any external
service we want to isolate from. Intuitively, we might write a test like this:</p>

<pre class="code-snippet CodeRay"><code class="language-python"><span class="keyword">from</span> <span class="include">mock</span> <span class="keyword">import</span> <span class="include">patch</span>
<span class="keyword">from</span> <span class="include">person</span> <span class="keyword">import</span> <span class="include">Person</span>

<span class="decorator">@patch</span>(<span class="string"><span class="delimiter">'</span><span class="content">person.noise_logger</span><span class="delimiter">'</span></span>, <span class="keyword">lambda</span> x: x)
<span class="keyword">def</span> <span class="function">test_decorator</span>():
    person = Person()
    <span class="keyword">assert</span> person.pet.noise() == <span class="string"><span class="delimiter">"</span><span class="content">Woof</span><span class="delimiter">"</span></span></code></pre>

<p>Unfortunately this wonât work at all because by the time we patch our
decorator, it has already been applied and our <code>noise</code> method has already been
<code>wrapped</code>. Here is what happens if we run our test with the <code>-s</code> switch, which
tells nose to print stdout output:</p>

<pre class="code-snippet CodeRay"><code class="language-shell">$ nosetests -s test_person.py
Pet made noise:  Woof
.
----------------------------------------------------------------------
Ran 1 test in 0.001s

OK</code></pre>

<p>This is because the decorator has been applied when the class
definition was loaded, as soon as we imported the <code>person</code> module. Remember
that instructions within a class definition are typically interpreted when we
load the module containing the class. Consider this:</p>

<pre class="code-snippet CodeRay"><code class="language-python"><span class="keyword">def</span> <span class="function">useless_decorator</span>(func):
    <span class="keyword">print</span> <span class="string"><span class="delimiter">"</span><span class="content">Hi, I'm a decorator that does nothing.</span><span class="delimiter">"</span></span>
    <span class="keyword">return</span> func

<span class="keyword">class</span> <span class="class">Foo</span>(<span class="predefined">object</span>):
    <span class="keyword">print</span> <span class="string"><span class="delimiter">"</span><span class="content">Entering Foo class definition</span><span class="delimiter">"</span></span>

    <span class="decorator">@useless_decorator</span>
    <span class="keyword">def</span> <span class="function">bar</span>(<span class="predefined-constant">self</span>):
        <span class="keyword">return</span> <span class="integer">42</span>

<span class="keyword">print</span> <span class="string"><span class="delimiter">"</span><span class="content">OK, we're done with that class definition.</span><span class="delimiter">"</span></span></code></pre>

<p>If you execute this code with your Python interpreter, you should get this output:</p>

<pre class="code-snippet CodeRay"><code class="language-shell">Entering Foo class definition
Hi, I'm a decorator that does nothing.
OK, we're done with that class definition.</code></pre>

<p>I hope this silly example convinces you that decorators are applied when the
class is created, which happens straight away when we load the module
containing the class.</p>

<p>To deal with this you first have to make sure that your decorator is defined in a
module separate from the class, otherwise youâll never get a chance to replace
it with a mock before the class definition calls it. Then you need to write
your test code so that it patches the decorator <em>before</em> it gets applied to the
methods of your class:</p>

<pre class="code-snippet CodeRay"><code class="language-python"><span class="keyword">from</span> <span class="include">mock</span> <span class="keyword">import</span> <span class="include">patch</span>
patch(<span class="string"><span class="delimiter">'</span><span class="content">decorators.noise_logger</span><span class="delimiter">'</span></span>, <span class="keyword">lambda</span> x: x).start()
<span class="keyword">from</span> <span class="include">person</span> <span class="keyword">import</span> <span class="include">Person</span>

<span class="keyword">def</span> <span class="function">test_decorator</span>():
    person = Person()
    <span class="keyword">assert</span> person.pet.noise() == <span class="string"><span class="delimiter">"</span><span class="content">Woof</span><span class="delimiter">"</span></span></code></pre>

<p>Now if you run nosetests with <code>-s</code>, you shouldnât see any message from the decorator because itâs been replaced by a <code>lambda</code> that does nothing.</p>



</div>
</div></body></html>