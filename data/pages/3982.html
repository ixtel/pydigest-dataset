<html><body><div><div class="entry-content">
                
                    <p>Remember, in <a href="http://ruslanspivak.com/lsbaws-part1/" title="Part 1">Part 1</a> I asked you a question: “How do you run a Django application, Flask application, and Pyramid application under your freshly minted Web server without making a single change to the server to accommodate all those different Web frameworks?” Read on to find out the answer.</p>
<p>In the past, your choice of a Python Web framework would limit your choice of usable Web servers, and vice versa. If the framework and the server were designed to work together, then you were okay:</p>
<p><img alt="Server Framework Fit" src="https://ruslanspivak.com/lsbaws-part2/lsbaws_part2_before_wsgi.png"/></p>
<p>But you could have been faced (and maybe you were) with the following problem when trying to combine a server and a framework that weren’t designed to work together:</p>
<p><img alt="Server Framework Clash" src="https://ruslanspivak.com/lsbaws-part2/lsbaws_part2_after_wsgi.png"/>
Basically you had to use what worked together and not what you might have wanted to use.</p>
<p>So, how do you then make sure that you can run your Web server with multiple Web frameworks without making code changes either to the Web server or to the Web frameworks?
And the answer to that problem became the <strong>Python Web Server Gateway Interface</strong> (or <a href="https://www.python.org/dev/peps/pep-0333/" title="WSGI"><span class="caps">WSGI</span></a> for short, pronounced <em>“wizgy”</em>).</p>
<p><img alt="WSGI Interface" src="https://ruslanspivak.com/lsbaws-part2/lsbaws_part2_wsgi_idea.png"/></p>
<p><a href="https://www.python.org/dev/peps/pep-0333/" title="WSGI"><span class="caps">WSGI</span></a> allowed developers to separate choice of a Web framework from choice of a Web server. Now you can actually mix and match Web servers and Web frameworks and choose a pairing that suits your needs. You can run <a href="https://www.djangoproject.com/" title="Django">Django</a>, <a href="http://flask.pocoo.org/" title="Flask">Flask</a>, or <a href="http://trypyramid.com/" title="Pyramid">Pyramid</a>, for example, with <a href="http://gunicorn.org/" title="Gunicorn">Gunicorn</a> or <a href="http://uwsgi-docs.readthedocs.org" title="uWSGI">Nginx/uWSGI</a> or <a href="http://waitress.readthedocs.org" title="Waitress">Waitress</a>. Real mix and match, thanks to the <span class="caps">WSGI</span> support in both servers and frameworks:
<img alt="Mix &amp; Match" src="https://ruslanspivak.com/lsbaws-part2/lsbaws_part2_wsgi_interop.png"/></p>
<p>So, <a href="https://www.python.org/dev/peps/pep-0333/" title="WSGI"><span class="caps">WSGI</span></a> is the answer to the question I asked you in <a href="http://ruslanspivak.com/lsbaws-part1/" title="Part 1">Part 1</a> and repeated at the beginning of this article. Your Web server must implement the server portion of a <span class="caps">WSGI</span> interface and all modern Python Web Frameworks already implement the framework side of the <span class="caps">WSGI</span> interface, which allows you to use them with your Web server without ever modifying your server’s code to accommodate a particular Web framework.</p>
<p>Now you know that <span class="caps">WSGI</span> support by Web servers and Web frameworks allows you to choose a pairing that suits you, but it is also beneficial to server and framework developers because they can focus on their preferred area of specialization and not step on each other’s toes. Other languages have similar interfaces too: Java, for example, has <a href="http://en.wikipedia.org/wiki/Java_servlet" title="Servlet API">Servlet <span class="caps">API</span></a> and Ruby has <a href="http://en.wikipedia.org/wiki/Rack_%28web_server_interface%29" title="Rack">Rack</a>.</p>
<p>It’s all good, but I bet you are saying: “Show me the code!”
Okay, take a look at this pretty minimalistic <span class="caps">WSGI</span> server implementation:</p>
<div class="highlight"><pre><span class="c"># Tested with Python 2.7.9, Linux &amp; Mac OS X</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">StringIO</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="k">class</span> <span class="nc">WSGIServer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">address_family</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span>
    <span class="n">socket_type</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span>
    <span class="n">request_queue_size</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">server_address</span><span class="p">):</span>
        <span class="c"># Create a listening socket</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listen_socket</span> <span class="o">=</span> <span class="n">listen_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">address_family</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">socket_type</span>
        <span class="p">)</span>
        <span class="c"># Allow to reuse the same address</span>
        <span class="n">listen_socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c"># Bind</span>
        <span class="n">listen_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
        <span class="c"># Activate</span>
        <span class="n">listen_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">request_queue_size</span><span class="p">)</span>
        <span class="c"># Get server host name and port</span>
        <span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listen_socket</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server_name</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">getfqdn</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server_port</span> <span class="o">=</span> <span class="n">port</span>
        <span class="c"># Return headers set by Web framework/Web application</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">headers_set</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">set_app</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">application</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">application</span> <span class="o">=</span> <span class="n">application</span>

    <span class="k">def</span> <span class="nf">serve_forever</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">listen_socket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listen_socket</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c"># New client connection</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">client_connection</span><span class="p">,</span> <span class="n">client_address</span> <span class="o">=</span> <span class="n">listen_socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
            <span class="c"># Handle one request and close the client connection. Then</span>
            <span class="c"># loop over to wait for another client connection</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle_one_request</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">handle_one_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">request_data</span> <span class="o">=</span> <span class="n">request_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_connection</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
        <span class="c"># Print formatted request data a la 'curl -v'</span>
        <span class="k">print</span><span class="p">(</span><span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s">'&lt; {line}</span><span class="se">\n</span><span class="s">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">request_data</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parse_request</span><span class="p">(</span><span class="n">request_data</span><span class="p">)</span>

        <span class="c"># Construct environment dictionary using request data</span>
        <span class="n">env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_environ</span><span class="p">()</span>

        <span class="c"># It's time to call our application callable and get</span>
        <span class="c"># back a result that will become HTTP response body</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">application</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_response</span><span class="p">)</span>

        <span class="c"># Construct a response and send it back to the client</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finish_response</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">request_line</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">request_line</span> <span class="o">=</span> <span class="n">request_line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">'</span><span class="se">\r\n</span><span class="s">'</span><span class="p">)</span>
        <span class="c"># Break down the request line into components</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">request_method</span><span class="p">,</span>  <span class="c"># GET</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>            <span class="c"># /hello</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">request_version</span>  <span class="c"># HTTP/1.1</span>
         <span class="p">)</span> <span class="o">=</span> <span class="n">request_line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_environ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">env</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c"># The following code snippet does not follow PEP8 conventions</span>
        <span class="c"># but it's formatted the way it is for demonstration purposes</span>
        <span class="c"># to emphasize the required variables and their values</span>
        <span class="c">#</span>
        <span class="c"># Required WSGI variables</span>
        <span class="n">env</span><span class="p">[</span><span class="s">'wsgi.version'</span><span class="p">]</span>      <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">env</span><span class="p">[</span><span class="s">'wsgi.url_scheme'</span><span class="p">]</span>   <span class="o">=</span> <span class="s">'http'</span>
        <span class="n">env</span><span class="p">[</span><span class="s">'wsgi.input'</span><span class="p">]</span>        <span class="o">=</span> <span class="n">StringIO</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">request_data</span><span class="p">)</span>
        <span class="n">env</span><span class="p">[</span><span class="s">'wsgi.errors'</span><span class="p">]</span>       <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span>
        <span class="n">env</span><span class="p">[</span><span class="s">'wsgi.multithread'</span><span class="p">]</span>  <span class="o">=</span> <span class="bp">False</span>
        <span class="n">env</span><span class="p">[</span><span class="s">'wsgi.multiprocess'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">env</span><span class="p">[</span><span class="s">'wsgi.run_once'</span><span class="p">]</span>     <span class="o">=</span> <span class="bp">False</span>
        <span class="c"># Required CGI variables</span>
        <span class="n">env</span><span class="p">[</span><span class="s">'REQUEST_METHOD'</span><span class="p">]</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_method</span>    <span class="c"># GET</span>
        <span class="n">env</span><span class="p">[</span><span class="s">'PATH_INFO'</span><span class="p">]</span>         <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>              <span class="c"># /hello</span>
        <span class="n">env</span><span class="p">[</span><span class="s">'SERVER_NAME'</span><span class="p">]</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">server_name</span>       <span class="c"># localhost</span>
        <span class="n">env</span><span class="p">[</span><span class="s">'SERVER_PORT'</span><span class="p">]</span>       <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">server_port</span><span class="p">)</span>  <span class="c"># 8888</span>
        <span class="k">return</span> <span class="n">env</span>

    <span class="k">def</span> <span class="nf">start_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># Add necessary server headers</span>
        <span class="n">server_headers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s">'Date'</span><span class="p">,</span> <span class="s">'Tue, 31 Mar 2015 12:54:48 GMT'</span><span class="p">),</span>
            <span class="p">(</span><span class="s">'Server'</span><span class="p">,</span> <span class="s">'WSGIServer 0.2'</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">headers_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span> <span class="o">+</span> <span class="n">server_headers</span><span class="p">]</span>
        <span class="c"># To adhere to WSGI specification the start_response must return</span>
        <span class="c"># a 'write' callable. We simplicity's sake we'll ignore that detail</span>
        <span class="c"># for now.</span>
        <span class="c"># return self.finish_response</span>

    <span class="k">def</span> <span class="nf">finish_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers_set</span>
            <span class="n">response</span> <span class="o">=</span> <span class="s">'HTTP/1.1 {status}</span><span class="se">\r\n</span><span class="s">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="n">status</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="n">response_headers</span><span class="p">:</span>
                <span class="n">response</span> <span class="o">+=</span> <span class="s">'{0}: {1}</span><span class="se">\r\n</span><span class="s">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">header</span><span class="p">)</span>
            <span class="n">response</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\r\n</span><span class="s">'</span>
            <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">response</span> <span class="o">+=</span> <span class="n">data</span>
            <span class="c"># Print formatted response data a la 'curl -v'</span>
            <span class="k">print</span><span class="p">(</span><span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="s">'&gt; {line}</span><span class="se">\n</span><span class="s">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
            <span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">client_connection</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">client_connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="n">SERVER_ADDRESS</span> <span class="o">=</span> <span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span> <span class="o">=</span> <span class="s">''</span><span class="p">,</span> <span class="mi">8888</span>


<span class="k">def</span> <span class="nf">make_server</span><span class="p">(</span><span class="n">server_address</span><span class="p">,</span> <span class="n">application</span><span class="p">):</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">WSGIServer</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">set_app</span><span class="p">(</span><span class="n">application</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">server</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s">'Provide a WSGI application object as module:callable'</span><span class="p">)</span>
    <span class="n">app_path</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">module</span><span class="p">,</span> <span class="n">application</span> <span class="o">=</span> <span class="n">app_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">':'</span><span class="p">)</span>
    <span class="n">module</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="n">application</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">application</span><span class="p">)</span>
    <span class="n">httpd</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="n">SERVER_ADDRESS</span><span class="p">,</span> <span class="n">application</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'WSGIServer: Serving HTTP on port {port} ...</span><span class="se">\n</span><span class="s">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">port</span><span class="o">=</span><span class="n">PORT</span><span class="p">))</span>
    <span class="n">httpd</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>


<p>It’s definitely bigger than the server code in <a href="http://ruslanspivak.com/lsbaws-part1/" title="Part 1">Part 1</a>, but it’s also small enough (just under 150 lines) for you to understand without getting bogged down in details. The above server also does more - it can run your basic Web application written with your beloved Web framework, be it Pyramid, Flask, Django, or some other Python <span class="caps">WSGI</span> framework.</p>
<p>Don’t believe me? Try it and see for yourself. Save the above code as <em>webserver2.py</em> or download it directly from <a href="https://github.com/rspivak/lsbaws/blob/master/part2/webserver2.py">GitHub</a>. If you try to run it without any parameters it’s going to complain and exit.</p>
<div class="highlight"><pre><span class="nv">$ </span>python webserver2.py
Provide a WSGI application object as module:callable
</pre></div>


<p>It really wants to serve your Web application and that’s where the fun begins. To run the server the only thing you need installed is Python. But to run applications written with Pyramid, Flask, and Django you need to install those frameworks first. Let’s install all three of them. My preferred method is by using <a href="https://virtualenv.pypa.io" title="virtualenv">virtualenv</a>. Just follow the steps below to create and activate a virtual environment and then install all three Web frameworks.</p>
<div class="highlight"><pre><span class="nv">$ </span><span class="o">[</span>sudo<span class="o">]</span> pip install virtualenv
<span class="nv">$ </span>mkdir ~/envs
<span class="nv">$ </span>virtualenv ~/envs/lsbaws/
<span class="nv">$ </span><span class="nb">cd</span> ~/envs/lsbaws/
<span class="nv">$ </span>ls
bin  include  lib
<span class="nv">$ </span><span class="nb">source </span>bin/activate
<span class="o">(</span>lsbaws<span class="o">)</span> <span class="nv">$ </span>pip install pyramid
<span class="o">(</span>lsbaws<span class="o">)</span> <span class="nv">$ </span>pip install flask
<span class="o">(</span>lsbaws<span class="o">)</span> <span class="nv">$ </span>pip install django
</pre></div>


<p>At this point you need to create a Web application.
Let’s start with <a href="http://trypyramid.com/" title="Pyramid">Pyramid</a> first.
Save the following code as <em>pyramidapp.py</em> to the same directory where you saved <em>webserver2.py</em> or download the file directly from <a href="https://github.com/rspivak/lsbaws/blob/master/part2/pyramidapp.py">GitHub</a>:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>


<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span>
        <span class="s">'Hello world from Pyramid!</span><span class="se">\n</span><span class="s">'</span><span class="p">,</span>
        <span class="n">content_type</span><span class="o">=</span><span class="s">'text/plain'</span><span class="p">,</span>
    <span class="p">)</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s">'hello'</span><span class="p">,</span> <span class="s">'/hello'</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="n">hello_world</span><span class="p">,</span> <span class="n">route_name</span><span class="o">=</span><span class="s">'hello'</span><span class="p">)</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">make_wsgi_app</span><span class="p">()</span>
</pre></div>


<p>Now you’re ready to serve your Pyramid application with your very own Web server:</p>
<div class="highlight"><pre><span class="o">(</span>lsbaws<span class="o">)</span> <span class="nv">$ </span>python webserver2.py pyramidapp:app
WSGIServer: Serving HTTP on port <span class="m">8888</span> ...
</pre></div>


<p>You just told your server to load the <em>‘app’</em> callable from the python module <em>‘pyramidapp’</em> Your server is now ready to take requests and forward them to your Pyramid application. The application only handles one route now: the <em>/hello</em> route.
Type <a href="http://localhost:8888/hello">http://localhost:8888/hello</a> address into your browser, press Enter, and observe the result:</p>
<p><img alt="Pyramid" src="https://ruslanspivak.com/lsbaws-part2/lsbaws_part2_browser_pyramid.png"/></p>
<p>You can also test the server on the command line using the <em>‘curl’</em> utility:</p>
<div class="highlight"><pre><span class="nv">$ </span>curl -v http://localhost:8888/hello
...
</pre></div>


<p>Check what the server and <em>curl</em> prints to standard output.</p>
<p>Now onto <a href="http://flask.pocoo.org/" title="Flask">Flask</a>. Let’s follow the same steps.</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Response</span>
<span class="n">flask_app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="s">'flaskapp'</span><span class="p">)</span>


<span class="nd">@flask_app.route</span><span class="p">(</span><span class="s">'/hello'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span>
        <span class="s">'Hello world from Flask!</span><span class="se">\n</span><span class="s">'</span><span class="p">,</span>
        <span class="n">mimetype</span><span class="o">=</span><span class="s">'text/plain'</span>
    <span class="p">)</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">flask_app</span><span class="o">.</span><span class="n">wsgi_app</span>
</pre></div>


<p>Save the above code as <em>flaskapp.py</em> or download it from <a href="https://github.com/rspivak/lsbaws/blob/master/part2/flaskapp.py">GitHub</a> and run the server as:</p>
<div class="highlight"><pre><span class="o">(</span>lsbaws<span class="o">)</span> <span class="nv">$ </span>python webserver2.py flaskapp:app
WSGIServer: Serving HTTP on port <span class="m">8888</span> ...
</pre></div>


<p>Now type in the <a href="http://localhost:8888/hello">http://localhost:8888/hello</a> into your browser and press Enter:</p>
<p><img alt="Flask" src="https://ruslanspivak.com/lsbaws-part2/lsbaws_part2_browser_flask.png"/></p>
<p>Again, try <em>‘curl’</em> and see for yourself that the server returns a message generated by the Flask application:</p>
<div class="highlight"><pre><span class="nv">$ </span>curl -v http://localhost:8888/hello
...
</pre></div>


<p>Can the server also handle a <a href="https://www.djangoproject.com/" title="Django">Django</a> application? Try it out!
It’s a little bit more involved, though, and I would recommend cloning the whole repo and use <a href="https://github.com/rspivak/lsbaws/blob/master/part2/djangoapp.py">djangoapp.py</a>, which is part of the <a href="https://github.com/rspivak/lsbaws/">GitHub repository</a>.
Here is the source code which basically adds the Django <em>‘helloworld’</em> project (pre-created using Django’s <em>django-admin.py startproject</em> command) to the current Python path and then imports the project’s <span class="caps">WSGI</span> application.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">'./helloworld'</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">helloworld</span> <span class="kn">import</span> <span class="n">wsgi</span>


<span class="n">app</span> <span class="o">=</span> <span class="n">wsgi</span><span class="o">.</span><span class="n">application</span>
</pre></div>


<p>Save the above code as <em>djangoapp.py</em> and run the Django application with your Web server:</p>
<div class="highlight"><pre><span class="o">(</span>lsbaws<span class="o">)</span> <span class="nv">$ </span>python webserver2.py djangoapp:app
WSGIServer: Serving HTTP on port <span class="m">8888</span> ...
</pre></div>


<p>Type in the following address and press Enter:</p>
<p><img alt="Django" src="https://ruslanspivak.com/lsbaws-part2/lsbaws_part2_browser_django.png"/></p>
<p>And as you’ve already done a couple of times before, you can test it on the command line, too, and confirm that it’s the Django application that handles your requests this time around:</p>
<div class="highlight"><pre><span class="nv">$ </span>curl -v http://localhost:8888/hello
...
</pre></div>


<p>Did you try it? Did you make sure the server works with those three frameworks? If not, then please do so. Reading is important, but this series is about rebuilding and that means you need to get your hands dirty. Go and try it. I will wait for you, don’t worry. No seriously, you must try it and, better yet, retype everything yourself and make sure that it works as expected.</p>
<p>Okay, you’ve experienced the power of <span class="caps">WSGI</span>: it allows you to mix and match your Web servers and Web frameworks. <span class="caps">WSGI</span> provides a minimal interface between Python Web servers and Python Web Frameworks. It’s very simple and it’s easy to implement on both the server and the framework side. The following code snippet shows the server and the framework side of the interface:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">run_application</span><span class="p">(</span><span class="n">application</span><span class="p">):</span>
    <span class="sd">"""Server code."""</span>
    <span class="c"># This is where an application/framework stores</span>
    <span class="c"># an HTTP status and HTTP response headers for the server</span>
    <span class="c"># to transmit to the client</span>
    <span class="n">headers_set</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># Environment dictionary with WSGI/CGI variables</span>
    <span class="n">environ</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">start_response</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">headers_set</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span><span class="p">]</span>

    <span class="c"># Server invokes the ‘application' callable and gets back the</span>
    <span class="c"># response body</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
    <span class="c"># Server builds an HTTP response and transmits it to the client</span>
    <span class="err">…</span>

<span class="k">def</span> <span class="nf">app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="sd">"""A barebones WSGI app."""</span>
    <span class="n">start_response</span><span class="p">(</span><span class="s">'200 OK'</span><span class="p">,</span> <span class="p">[(</span><span class="s">'Content-Type'</span><span class="p">,</span> <span class="s">'text/plain'</span><span class="p">)])</span>
    <span class="k">return</span> <span class="p">[</span><span class="s">'Hello world!'</span><span class="p">]</span>

<span class="n">run_application</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</pre></div>


<p>Here is how it works:</p>
<ol>
<li>The framework provides an <em>‘application’</em> callable (The <span class="caps">WSGI</span> specification doesn’t prescribe how that should be implemented)</li>
<li>The server invokes the <em>‘application’</em> callable for each request it receives from an <span class="caps">HTTP</span> client. It passes a dictionary <em>‘environ’</em> containing <span class="caps">WSGI</span>/<span class="caps">CGI</span> variables and a <em>‘start_response’</em> callable as arguments to the <em>‘application’</em> callable.</li>
<li>The framework/application generates an <span class="caps">HTTP</span> status and <span class="caps">HTTP</span> response headers and passes them to the <em>‘start_response’</em> callable for the server to store them. The framework/application also returns a response body.</li>
<li>The server combines the status, the response headers, and the response body into an <span class="caps">HTTP</span> response and transmits it to the client (This step is not part of the specification but it’s the next logical step in the flow and I added it for clarity)</li>
</ol>
<p>And here is a visual representation of the interface:</p>
<p><img alt="WSGI Interface" src="https://ruslanspivak.com/lsbaws-part2/lsbaws_part2_wsgi_interface.png"/></p>
<p>So far, you’ve seen the Pyramid, Flask, and Django Web applications and you’ve seen the server code that implements the server side of the <span class="caps">WSGI</span> specification. You’ve even seen the barebones <span class="caps">WSGI</span> application code snippet that doesn’t use any framework.</p>
<p>The thing is that when you write a Web application using one of those frameworks you work at a higher level and don’t work with <span class="caps">WSGI</span> directly, but I know you’re curious about the framework side of the <span class="caps">WSGI</span> interface, too because you’re reading this article. So, let’s create a minimalistic <span class="caps">WSGI</span> Web application/Web framework without using Pyramid, Flask, or Django and run it with your server:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="sd">"""A barebones WSGI application.</span>

<span class="sd">    This is a starting point for your own Web framework :)</span>
<span class="sd">    """</span>
    <span class="n">status</span> <span class="o">=</span> <span class="s">'200 OK'</span>
    <span class="n">response_headers</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'Content-Type'</span><span class="p">,</span> <span class="s">'text/plain'</span><span class="p">)]</span>
    <span class="n">start_response</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="s">'Hello world from a simple WSGI application!</span><span class="se">\n</span><span class="s">'</span><span class="p">]</span>
</pre></div>


<p>Again, save the above code in <em>wsgiapp.py</em> file or download it from <a href="https://github.com/rspivak/lsbaws/blob/master/part2/wsgiapp.py">GitHub</a> directly and run the application under your Web server as:</p>
<div class="highlight"><pre><span class="o">(</span>lsbaws<span class="o">)</span> <span class="nv">$ </span>python webserver2.py wsgiapp:app
WSGIServer: Serving HTTP on port <span class="m">8888</span> ...
</pre></div>


<p>Type in the following address and press Enter. This is the result you should see:</p>
<p><img alt="Simple WSGI Application" src="https://ruslanspivak.com/lsbaws-part2/lsbaws_part2_browser_simple_wsgi_app.png"/></p>
<p>You just wrote your very own minimalistic <span class="caps">WSGI</span> Web framework while learning about how to create a Web server! Outrageous.</p>
<p>Now, let’s get back to what the server transmits to the client. Here is the <span class="caps">HTTP</span> response the server generates when you call your Pyramid application using an <span class="caps">HTTP</span> client:</p>
<p><img alt="HTTP Response Part 1" src="https://ruslanspivak.com/lsbaws-part2/lsbaws_part2_http_response.png"/></p>
<p>The response has some familiar parts that you saw in <a href="http://ruslanspivak.com/lsbaws-part1/" title="Part 1">Part 1</a> but it also has something new. It has, for example, four <a href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields" title="HTTP header fields"><span class="caps">HTTP</span> headers</a> that you haven’t seen before: <em>Content-Type</em>, <em>Content-Length</em>, <em>Date</em>, and <em>Server</em>. Those are the headers that a response from a Web server generally should have. None of them are strictly required, though. The purpose of the headers is to transmit additional information about the <span class="caps">HTTP</span> request/response.</p>
<p>Now that you know more about the <span class="caps">WSGI</span> interface, here is the same <span class="caps">HTTP</span> response with some more information about what parts produced it:</p>
<p><img alt="HTTP Response Part 2" src="https://ruslanspivak.com/lsbaws-part2/lsbaws_part2_http_response_explanation.png"/></p>
<p>I haven’t said anything about the <strong>‘environ’</strong> dictionary yet, but basically it’s a Python dictionary that must contain certain <span class="caps">WSGI</span> and <span class="caps">CGI</span> variables prescribed by the <span class="caps">WSGI</span> specification.
The server takes the values for the dictionary from the <span class="caps">HTTP</span> request after parsing the request.
This is what the contents of the dictionary look like:</p>
<p><img alt="Environ Python Dictionary" src="https://ruslanspivak.com/lsbaws-part2/lsbaws_part2_environ.png"/></p>
<p>A Web framework uses the information from that dictionary to decide which view to use based on the specified route, request method etc., where to read the request body from and where to write errors, if any.</p>
<p>By now you’ve created your own <span class="caps">WSGI</span> Web server and you’ve made Web applications written with different Web frameworks. And, you’ve also created your barebones Web application/Web framework along the way. It’s been a heck of a journey. Let’s recap what your <span class="caps">WSGI</span> Web server has to do to serve requests aimed at a <span class="caps">WSGI</span> application:</p>
<ul>
<li>First, the server starts and loads an <em>‘application’</em> callable provided by your Web framework/application</li>
<li>Then, the server reads a request</li>
<li>Then, the server parses it</li>
<li>Then, it builds an <em>‘environ’</em> dictionary using the request data</li>
<li>Then, it calls the <em>‘application’</em> callable with the <em>‘environ’</em> dictionary and a <em>‘start_response’</em> callable as parameters and gets back a response body.</li>
<li>Then, the server constructs an <span class="caps">HTTP</span> response using the data returned by the call to the <em>‘application’</em> object and the status and response headers set by the <em>‘start_response’</em> callable.</li>
<li>And finally, the server transmits the <span class="caps">HTTP</span> response back to the client</li>
</ul>
<p><img alt="Server Summary" src="https://ruslanspivak.com/lsbaws-part2/lsbaws_part2_server_summary.png"/></p>
<p>That’s about all there is to it. You now have a working <span class="caps">WSGI</span> server that can serve basic Web applications written with <span class="caps">WSGI</span> compliant Web frameworks like <a href="https://www.djangoproject.com/" title="Django">Django</a>, <a href="http://flask.pocoo.org/" title="Flask">Flask</a>, <a href="http://trypyramid.com/" title="Pyramid">Pyramid</a>, or your very own <span class="caps">WSGI</span> framework. The best part is that the server can be used with multiple Web frameworks without any changes to the server code base. Not bad at all.</p>
<p>Before you go, here is another question for you to think about, <em>“How do you make your server handle more than one request at a time?”</em></p>
<p>Stay tuned and I will show you a way to do that in Part 3. Cheers!</p>
<p><span class="caps">BTW</span>, I’m writing a book “Let’s Build A Web Server: First Steps” that explains how to write a basic web server from scratch and goes into more detail on topics I just covered. Subscribe to the mailing list to get the latest updates about the book and the release date.</p>
<p>


</p>



<p><br/>
<strong>All articles in this series:</strong></p>

            </div>
            
    </div></body></html>