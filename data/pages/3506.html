<html><body><div><article class="text">
        

        <header class="article-header">
            <h1 class="page-title">PEP 0487 -- Simpler customisation of class creation</h1>
        </header>

        

 
  <table class="rfc2822 docutils field-list" frame="void" rules="none">
   <col class="field-name"/>
   
   <col class="field-body"/>
   
   <tbody valign="top">
    <tr class="field">
     <th class="field-name">
      PEP:
     </th>
     <td class="field-body">
      487
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Title:
     </th>
     <td class="field-body">
      Simpler customisation of class creation
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Author:
     </th>
     <td class="field-body">
      Martin Teichmann &lt;lkb.teichmann at gmail.com&gt;,
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Status:
     </th>
     <td class="field-body">
      Draft
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Type:
     </th>
     <td class="field-body">
      Standards Track
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Created:
     </th>
     <td class="field-body">
      27-Feb-2015
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Python-Version:
     </th>
     <td class="field-body">
      3.6
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Post-History:
     </th>
     <td class="field-body">
      27-Feb-2015, 5-Feb-2016
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Replaces:
     </th>
     <td class="field-body">
      <a class="reference external" href="/dev/peps/pep-0422">
       422
      </a>
     </td>
    </tr>
   </tbody>
  </table>
  <hr/>
  
  <div class="section" id="abstract">
   
   <p>
    Currently, customising class creation requires the use of a custom metaclass.
This custom metaclass then persists for the entire lifecycle of the class,
creating the potential for spurious metaclass conflicts.
   </p>
   <p>
    This PEP proposes to instead support a wide range of customisation
scenarios through a new
    <tt class="docutils literal">
     __init_subclass__
    </tt>
    hook in the class body,
a hook to initialize descriptors, and a way to keep the order in which
attributes are defined.
   </p>
   <p>
    Those hooks should at first be defined in a metaclass in the standard
library, with the option that this metaclass eventually becomes the
default
    <tt class="docutils literal">
     type
    </tt>
    metaclass.
   </p>
   <p>
    The new mechanism should be easier to understand and use than
implementing a custom metaclass, and thus should provide a gentler
introduction to the full power Python's metaclass machinery.
   </p>
  </div>
  <div class="section" id="background">
   
   <p>
    Metaclasses are a powerful tool to customize class creation. They have,
however, the problem that there is no automatic way to combine metaclasses.
If one wants to use two metaclasses for a class, a new metaclass combining
those two needs to be created, typically manually.
   </p>
   <p>
    This need often occurs as a surprise to a user: inheriting from two base
classes coming from two different libraries suddenly raises the necessity
to manually create a combined metaclass, where typically one is not
interested in those details about the libraries at all. This becomes
even worse if one library starts to make use of a metaclass which it
has not done before. While the library itself continues to work perfectly,
suddenly every code combining those classes with classes from another library
fails.
   </p>
  </div>
  <div class="section" id="proposal">
   
   <p>
    While there are many possible ways to use a metaclass, the vast majority
of use cases falls into just three categories: some initialization code
running after class creation, the initalization of descriptors and
keeping the order in which class attributes were defined.
   </p>
   <p>
    Those three use cases can easily be performed by just one metaclass. If
this metaclass is put into the standard library, and all libraries that
wish to customize class creation use this very metaclass, no combination
of metaclasses is necessary anymore.
   </p>
   <p>
    The three use cases are achieved as follows:
   </p>
   <ol class="arabic simple">
    <li>
     The metaclass contains an
     <tt class="docutils literal">
      __init_subclass__
     </tt>
     hook that initializes
all subclasses of a given class,
    </li>
    <li>
     the metaclass calls an
     <tt class="docutils literal">
      __init_descriptor__
     </tt>
     hook for all descriptors
defined in the class, and
    </li>
    <li>
     an
     <tt class="docutils literal">
      __attribute_order__
     </tt>
     tuple is left in the class in order to inspect
the order in which attributes were defined.
    </li>
   </ol>
   <p>
    For ease of use, a base class
    <tt class="docutils literal">
     SubclassInit
    </tt>
    is defined, which uses said
metaclass and contains an empty stub for the hook described for use case 1.
   </p>
   <p>
    As an example, the first use case looks as follows:
   </p>
   <pre class="literal-block">
class SpamBase(SubclassInit):
    # this is implicitly a @classmethod
    def __init_subclass__(cls, **kwargs):
        # This is invoked after a subclass is created, but before
        # explicit decorators are called.
        # The usual super() mechanisms are used to correctly support
        # multiple inheritance.
        # **kwargs are the keyword arguments to the subclasses'
        # class creation statement
        super().__init_subclass__(cls, **kwargs)

class Spam(SpamBase):
    pass
# the new hook is called on Spam
</pre>
   <p>
    The base class
    <tt class="docutils literal">
     SubclassInit
    </tt>
    contains an empty
    <tt class="docutils literal">
     __init_subclass__
    </tt>
    method which serves as an endpoint for cooperative multiple inheritance.
Note that this method has no keyword arguments, meaning that all
methods which are more specialized have to process all keyword
arguments.
   </p>
   <p>
    This general proposal is not a new idea (it was first suggested for
inclusion in the language definition
    <a class="reference external" href="http://mail.python.org/pipermail/python-dev/2001-November/018651.html">
     more than 10 years ago
    </a>
    <a class="footnote-reference" href="#id1" id="id2">
     [1]
    </a>
    , and a
similar mechanism has long been supported by
    <a class="reference external" href="http://docs.zope.org/zope_secrets/extensionclass.html">
     Zope's ExtensionClass
    </a>
    <a class="footnote-reference" href="#id3" id="id4">
     [2]
    </a>
    ),
but the situation has changed sufficiently in recent years that
the idea is worth reconsidering for inclusion.
   </p>
   <p>
    The second part of the proposal adds an
    <tt class="docutils literal">
     __init_descriptor__
    </tt>
    initializer for descriptors.  Descriptors are defined in the body of a
class, but they do not know anything about that class, they do not
even know the name they are accessed with. They do get to know their
owner once
    <tt class="docutils literal">
     __get__
    </tt>
    is called, but still they do not know their
name. This is unfortunate, for example they cannot put their
associated value into their object's
    <tt class="docutils literal">
     __dict__
    </tt>
    under their name,
since they do not know that name.  This problem has been solved many
times, and is one of the most important reasons to have a metaclass in
a library. While it would be easy to implement such a mechanism using
the first part of the proposal, it makes sense to have one solution
for this problem for everyone.
   </p>
   <p>
    To give an example of its usage, imagine a descriptor representing weak
referenced values (this is an insanely simplified, yet working example):
   </p>
   <pre class="literal-block">
import weakref

class WeakAttribute:
    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        instance.__dict__[self.name] = weakref.ref(value)

    # this is the new initializer:
    def __init_descriptor__(self, owner, name):
        self.name = name
</pre>
   <p>
    The third part of the proposal is to leave a tuple called
    <tt class="docutils literal">
     __attribute_order__
    </tt>
    in the class that contains the order in which
the attributes were defined. This is a very common usecase, many
libraries use an
    <tt class="docutils literal">
     OrderedDict
    </tt>
    to store this order. This is a very
simple way to achieve the same goal.
   </p>
  </div>
  <div class="section" id="key-benefits">
   
   <div class="section" id="easier-inheritance-of-definition-time-behaviour">
    
    <p>
     Understanding Python's metaclasses requires a deep understanding of
the type system and the class construction process. This is legitimately
seen as challenging, due to the need to keep multiple moving parts (the code,
the metaclass hint, the actual metaclass, the class object, instances of the
class object) clearly distinct in your mind. Even when you know the rules,
it's still easy to make a mistake if you're not being extremely careful.
    </p>
    <p>
     Understanding the proposed implicit class initialization hook only requires
ordinary method inheritance, which isn't quite as daunting a task. The new
hook provides a more gradual path towards understanding all of the phases
involved in the class definition process.
    </p>
   </div>
   
  </div>
  <div class="section" id="a-path-of-introduction-into-python">
   
   <p>
    Most of the benefits of this PEP can already be implemented using
a simple metaclass. For the
    <tt class="docutils literal">
     __init_subclass__
    </tt>
    hook this works
all the way down to Python 2.7, while the attribute order needs Python 3.0
to work. Such a class has been
    <a class="reference external" href="https://pypi.python.org/pypi/metaclass">
     uploaded to PyPI
    </a>
    <a class="footnote-reference" href="#id5" id="id6">
     [3]
    </a>
    .
   </p>
   <p>
    The only drawback of such a metaclass are the mentioned problems with
metaclasses and multiple inheritance. Two classes using such a
metaclass can only be combined, if they use exactly the same such
metaclass. This fact calls for the inclusion of such a class into the
standard library, let's call it
    <tt class="docutils literal">
     SubclassMeta
    </tt>
    , with the base class
using it called
    <tt class="docutils literal">
     SubclassInit
    </tt>
    . Once all users use this standard
library metaclass, classes from different packages can easily be
combined.
   </p>
   <p>
    But still such classes cannot be easily combined with other classes
using other metaclasses. Authors of metaclasses should bear that in
mind and inherit from the standard metaclass if it seems useful
for users of the metaclass to add more functionality. Ultimately,
if the need for combining with other metaclasses is strong enough,
the proposed functionality may be introduced into Python's
    <tt class="docutils literal">
     type
    </tt>
    .
   </p>
   <p>
    Those arguments strongly hint to the following procedure to include
the proposed functionality into Python:
   </p>
   <ol class="arabic simple">
    <li>
     The metaclass implementing this proposal is put onto PyPI, so that
it can be used and scrutinized.
    </li>
    <li>
     Once the code is properly mature, it can be added to the Python
standard library. There should be a new module called
     <tt class="docutils literal">
      metaclass
     </tt>
     which collects tools for metaclass authors, as well
as a documentation of the best practices of how to write
metaclasses.
    </li>
    <li>
     If the need of combining this metaclass with other metaclasses is
strong enough, it may be included into Python itself.
    </li>
   </ol>
   <p>
    While the metaclass is still in the standard library and not in the
language, it may still clash with other metaclasses.  The most
prominent metaclass in use is probably ABCMeta.  It is also a
particularly good example for the need of combining metaclasses. For
users who want to define a ABC with subclass initialization, we should
support a
    <tt class="docutils literal">
     ABCSubclassInit
    </tt>
    class, or let ABCMeta inherit from this
PEP's metaclass.
   </p>
   <p>
    Extensions written in C or C++ also often define their own metaclass.
It would be very useful if those could also inherit from the metaclass
defined here, but this is probably not possible.
   </p>
  </div>
  <div class="section" id="new-ways-of-using-classes">
   
   <p>
    This proposal has many usecases like the following. In the examples,
we still inherit from the
    <tt class="docutils literal">
     SubclassInit
    </tt>
    base class. This would
become unnecessary once this PEP is included in Python directly.
   </p>
   <div class="section" id="subclass-registration">
    
    <p>
     Especially when writing a plugin system, one likes to register new
subclasses of a plugin baseclass. This can be done as follows:
    </p>
    <pre class="literal-block">
class PluginBase(SubclassInit):
    subclasses = []

    def __init_subclass__(cls, **kwargs):
        super().__init_subclass__(**kwargs)
        cls.subclasses.append(cls)
</pre>
    <p>
     One should note that this also works nicely as a mixin class.
    </p>
   </div>
   <div class="section" id="trait-descriptors">
    
    <p>
     There are many designs of Python descriptors in the wild which, for
example, check boundaries of values. Often those "traits" need some support
of a metaclass to work. This is how this would look like with this
PEP:
    </p>
    <pre class="literal-block">
class Trait:
    def __get__(self, instance, owner):
        return instance.__dict__[self.key]

    def __set__(self, instance, value):
        instance.__dict__[self.key] = value

    def __init_descriptor__(self, owner, name):
        self.key = name

class Int(Trait):
    def __set__(self, instance, value):
        # some boundary check code here
        super().__set__(instance, value)
</pre>
   </div>
  </div>
  <div class="section" id="rejected-design-options">
   
   <div class="section" id="calling-the-hook-on-the-class-itself">
    
    <p>
     Adding an
     <tt class="docutils literal">
      __autodecorate__
     </tt>
     hook that would be called on the class
itself was the proposed idea of
     <a class="reference external" href="/dev/peps/pep-0422">
      PEP 422
     </a>
     .  Most examples work the same
way or even better if the hook is called on the subclass. In general,
it is much easier to explicitly call the hook on the class in which it
is defined (to opt-in to such a behavior) than to opt-out, meaning
that one does not want the hook to be called on the class it is
defined in.
    </p>
    <p>
     This becomes most evident if the class in question is designed as a
mixin: it is very unlikely that the code of the mixin is to be
executed for the mixin class itself, as it is not supposed to be a
complete class on its own.
    </p>
    <p>
     The original proposal also made major changes in the class
initialization process, rendering it impossible to back-port the
proposal to older Python versions.
    </p>
   </div>
   <div class="section" id="other-variants-of-calling-the-hook">
    
    <p>
     Other names for the hook were presented, namely
     <tt class="docutils literal">
      __decorate__
     </tt>
     or
     <tt class="docutils literal">
      __autodecorate__
     </tt>
     . This proposal opts for
     <tt class="docutils literal">
      __init_subclass__
     </tt>
     as
it is very close to the
     <tt class="docutils literal">
      __init__
     </tt>
     method, just for the subclass,
while it is not very close to decorators, as it does not return the
class.
    </p>
   </div>
   <div class="section" id="requiring-an-explicit-decorator-on-init-subclass">
    
    <p>
     One could require the explicit use of
     <tt class="docutils literal">
      @classmethod
     </tt>
     on the
     <tt class="docutils literal">
      __init_subclass__
     </tt>
     decorator. It was made implicit since there's no
sensible interpretation for leaving it out, and that case would need
to be detected anyway in order to give a useful error message.
    </p>
    <p>
     This decision was reinforced after noticing that the user experience of
defining
     <tt class="docutils literal">
      __prepare__
     </tt>
     and forgetting the
     <tt class="docutils literal">
      @classmethod
     </tt>
     method
decorator is singularly incomprehensible (particularly since
     <a class="reference external" href="/dev/peps/pep-3115">
      PEP 3115
     </a>
     documents it as an ordinary method, and the current documentation doesn't
explicitly say anything one way or the other).
    </p>
   </div>
   <div class="section" id="defining-arbitrary-namespaces">
    
    <p>
     <a class="reference external" href="/dev/peps/pep-0422">
      PEP 422
     </a>
     defined a generic way to add arbitrary namespaces for class
definitions. This approach is much more flexible than just leaving
the definition order in a tuple. The
     <tt class="docutils literal">
      __prepare__
     </tt>
     method in a metaclass
supports exactly this behavior. But given that effectively
the only use cases that could be found out in the wild were the
     <tt class="docutils literal">
      OrderedDict
     </tt>
     way of determining the attribute order, it seemed
reasonable to only support this special case.
    </p>
    <p>
     The metaclass described in this PEP has been designed to be very simple
such that it could be reasonably made the default metaclass. This was
especially important when designing the attribute order functionality:
This was a highly demanded feature and has been enabled through the
     <tt class="docutils literal">
      __prepare__
     </tt>
     method of metaclasses. This method can be abused in
very weird ways, making it hard to correctly maintain this feature in
CPython. This is why it has been proposed to deprecated this feature,
and instead use
     <tt class="docutils literal">
      OrderedDict
     </tt>
     as the standard namespace, supporting
the most important feature while dropping most of the complexity. But
this would have meant that
     <tt class="docutils literal">
      OrderedDict
     </tt>
     becomes a language builtin
like dict and set, and not just a standard library class. The choice
of the
     <tt class="docutils literal">
      __attribute_order__
     </tt>
     tuple is a much simpler solution to the
problem.
    </p>
   </div>
   <div class="section" id="a-more-new-like-hook">
    
    <p>
     In
     <a class="reference external" href="/dev/peps/pep-0422">
      PEP 422
     </a>
     the hook worked more like the
     <tt class="docutils literal">
      __new__
     </tt>
     method than the
     <tt class="docutils literal">
      __init__
     </tt>
     method, meaning that it returned a class instead of
modifying one. This allows a bit more flexibility, but at the cost
of much harder implementation and undesired side effects.
    </p>
   </div>
  </div>
  <div class="section" id="history">
   
   <p>
    This used to be a competing proposal to
    <a class="reference external" href="/dev/peps/pep-0422">
     PEP 422
    </a>
    by Nick Coughlan and
Daniel Urban. It shares both most of the PEP text and proposed code, but
has major differences in how to achieve its goals. In the meantime,
    <a class="reference external" href="/dev/peps/pep-0422">
     PEP 422
    </a>
    has been withdrawn favouring this approach.
   </p>
  </div>
  
  <div class="section" id="copyright">
   
   <p>
    This document has been placed in the public domain.
   </p>
   
  </div>
 
Source: <a href="https://hg.python.org/peps/file/tip/pep-0487.txt">https://hg.python.org/peps/file/tip/pep-0487.txt</a>

    </article>


                </div></body></html>