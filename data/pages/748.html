<html><body><div><div>
<p>Note</p>
<p>Peep is deprecated, as we have <a href="https://pip.readthedocs.org/en/stable/reference/pip_install/#hash-checking-mode" rel="nofollow">merged its functionality into pip 8</a>. This brings myriad improvements, including support for caching,
detection of omitted dependencies, and better handling of errors and corner
cases. To switch to pip 8’s hash-checking without hitting any race
conditions…</p>
<ol>
<li>Upgrade to peep 3.0 (which exists mainly as a stopgap to support
race-free upgrades like this).</li>
<li>Upgrade to pip 8.</li>
<li>Atomically, switch the format of your requirements files using <tt>peep
port</tt> (described below), and start calling pip instead of peep.</li>
<li>Delete peep from your project.</li>
</ol>
<p>Thank you for using peep! Your early support helped establish hash
verification as a feature worth uplifting, and now the package ecosystem is
safer for everyone.</p>
<p>Here are some <a href="https://github.com/erikrose/peep/wiki/UpgradeToPip8" rel="nofollow">more detailed upgrade instructions</a> in case you need
them.</p>
</div>
<div id="peep">
<h2>Peep</h2>
<p>Deploying Python projects has long been a source of frustration for the
security-conscious: a compromise of PyPI or its third-party CDN could get
you a package different from the one you signed up for. To guarantee
known-good dependencies for your deployments, you had to run a local package
index, manually uploading packages as you vetted them, maintaining a set of
ACLs for that server, and trying to somehow keep an audit trail of who did
what. Alternatively, you could check everything into a vendor library, but that
meant a lot of fooling around with your VCS (or maintaining custom tooling) to
do upgrades.</p>
<p>Peep fixes all that.</p>
<p>Vet your packages, and put hashes of the PyPI-sourced tarballs into
<tt>requirements.txt</tt>, like this:</p>
<pre># sha256: L9XU_-gfdi3So-WEctaQoNu6N2Z3ZQYAOu4-16qor-8
Flask==0.9

# sha256: qF4YU3XbdcEJ-Z7N49VUFfA15waKgiUs9PFsZnrDj0k
Jinja2==2.6
</pre>
<p>Then, use <tt>peep install</tt> instead of <tt>pip install</tt>, and let the crypto do
the rest. If a downloaded package doesn’t match the expected hash, Peep will
freak out, and installation will go no further.</p>
<p>There are no servers to maintain, no enormous vendor libs to wrestle, and no
need to trust a package author’s key management practices. With the addition
of a few hashes to your requirements file, you can know that your chain of
trust is safely rooted in your own source tree.</p>
<div id="switching-to-peep">
<h3>Switching to Peep</h3>
<ol>
<li><p>Install Peep:</p>
<pre>pip install peep
</pre>
<p>(Or, better, embed <tt>peep.py</tt> into your codebase as described in the
Embedding section below. That eliminates having to trust an unauthenticated
PyPI download, assuming you manually vet <tt>peep.py</tt> itself the first time.)</p>
</li>
<li><p>Use Peep to install your project once:</p>
<pre>cd yourproject
peep install -r requirements.txt
</pre>
<p>You’ll get output like this:</p>
<pre>&lt;a bunch of pip output&gt;

The following packages had no hashes specified in the requirements file,
which leaves them open to tampering. Vet these packages to your
satisfaction, then add these "sha256" lines like so:

# sha256: L9XU_-gfdi3So-WEctaQoNu6N2Z3ZQYAOu4-16qor-8
Flask==0.9

# sha256: qF4YU3XbdcEJ-Z7N49VUFfA15waKgiUs9PFsZnrDj0k
Jinja2==2.6

# sha256: u_8C3DCeUoRt2WPSlIOnKV_MAhYkc40zNZxDlxCA-as
Pygments==1.4

# sha256: A1gwhyCNozcxug18_9RjJTmJQa1rctOt-AnP7_yR0PM
https://github.com/jsocol/commonware/archive/b5544185b2d24adc1eb512735990752400ce9cbd.zip#egg=commonware

-------------------------------
Not proceeding to installation.
</pre>
</li>
<li><p>Vet the packages coming off PyPI in whatever way you typically do. For
instance, read them, or compare them with known-good local copies.</p>
</li>
<li><p>Add the recommended hash lines to your <tt>requirements.txt</tt>, each one
directly above the requirement it applies to. (The hashes are of the
original, compressed tarballs from PyPI.)</p>
</li>
<li><p>In the future, always use <tt>peep install</tt> to install your requirements. You
are now cryptographically safe!</p>
</li>
</ol>
<div>
<p>Warning</p>
<p>Be careful not to nullify all your work when you install your actual
project. If you use <tt>python setup.py install</tt>, setuptools will happily go
out and download, unchecked, any requirements you missed in
<tt>requirements.txt</tt> (and it’s easy to miss some as your project evolves).
One way to be safe is to pack up your project and then install that using
pip and <tt><span class="pre">--no-deps</span></tt>:</p>
<pre>python setup.py sdist
pip install --no-deps dist/yourproject-1.0.tar.gz
</pre>
</div>
</div>
<div id="the-fearsome-warning">
<h3>The Fearsome Warning</h3>
<p>If, during installation, a hash doesn’t match, Peep will say something like
this:</p>
<pre>THE FOLLOWING PACKAGES DIDN'T MATCH THE HASHES SPECIFIED IN THE
REQUIREMENTS FILE. If you have updated the package versions, update the
hashes. If not, freak out, because someone has tampered with the packages.

    requests: expected FWvz7Ce6nsfgz4--AoCHGAmdIY3kA-tkpxTXO6GimrE
                   got YhddA1kUpMLVODNbhIgHfQn88vioPHLwayTyqwOJEgY
</pre>
<p>It will then exit with a status of 1. Freak out appropriately.</p>
</div>
<div id="other-features">
<h3>Other Features</h3>
<ul>
<li><p>Peep implicitly turns on pip’s <tt><span class="pre">--no-deps</span></tt> option so unverified
dependencies of your requirements can’t sneak through.</p>
</li>
<li><p>All non-install commands just fall through to pip, so you can use Peep
all the time if you want. This comes in handy for existing scripts that have
a big <tt><span class="pre">$PIP=/path/to/pip</span></tt> at the top.</p>
</li>
<li><p>Peep-compatible requirements files remain entirely usable with <tt>pip</tt>,
because the hashes are just comments, after all.</p>
</li>
<li><p>Have a manually downloaded package you’ve vetted? Run <tt>peep hash</tt> on its
tarball (the original, from PyPI–be sure to keep it around) to get its hash
line:</p>
<pre>% peep hash nose-1.3.0.tar.gz
# sha256: TmPMMyXedc-Y_61AvnL6aXU96CRpUXMXj3TANP5PUmA
</pre>
</li>
<li><p>If a package is already present–which might be the case if you’re installing
into a non-empty virtualenv–Peep doesn’t bother downloading or building it
again. It assumes you installed it with Peep in a previous invocation and
thus trusts it. The only exception to this is for URL-specified requirements where the
URL contains a SHA-like filename (eg <a href="https://github.com/foo/bar/archive" rel="nofollow">https://github.com/foo/bar/archive</a>/&lt;SHA&gt;.zip),
since the package version number is typically not incremented for every commit, so
Peep cannot be sure the contents have not changed.
Note: Re-using a virtualenv during deployment can really speed things up, but you will
need to manually remove dependencies that are no longer in the requirements file.</p>
</li>
<li><p><tt>peep port</tt> converts a peep-savvy requirements file to one compatible with
<a href="https://pip.pypa.io/en/latest/reference/pip_install/#hash-checking-mode" rel="nofollow">pip 8’s new hashing functionality</a>:</p>
<pre>% peep port requirements.txt
certifi==2015.04.28 \
    --hash=sha256:268fa00c27de756d71663dd61f73a4a8d8727569bb1b474b2ce6020553826872 \
    --hash=sha256:99785e6cf715cdcde59dee05a676e99f04835a71e7ced201ca317401c322ba96
click==4.0 --hash=sha256:9ab1d313f99b209f8f71a629f36833030c8d7c72282cf7756834baf567dca662
</pre>
<p>Note that comments and URLs don’t make it through, but the hard part—hash
format conversion—is taken care of for you.</p>
</li>
</ul>
</div>
<div id="embedding">
<h3>Embedding</h3>
<p>Peep was designed for unsupervised continuous deployment scenarios. In such
scenarios, manual ahead-of-time preparation on the deployment machine is a
liability: one more thing to go wrong. To relieve you of having to install (and
upgrade) Peep by hand on your server or build box, we’ve made Peep
embeddable. You can copy the <tt>peep.py</tt> file directly into your project’s
source tree and call it from there in your deployment script. This also gives
you an obvious starting point for your chain of trust: however you trust your
source code is how you trust your copy of Peep, and Peep verifies
everything else via hashes. (Equivalent would be if your OS provided Peep as a
package–presumably you trust your OS packages already–but this is not yet
common.)</p>
</div>
<div id="security-and-insecurity">
<h3>Security and Insecurity</h3>
<p>Here’s what you get for free with Peep–and what you don’t.</p>
<p><strong>You get repeatability.</strong> If you <tt>peep install</tt> package <tt><span class="pre">Foo==1.2.3</span></tt>,
every subsequent install of <tt><span class="pre">Foo==1.2.3</span></tt> will be the same as the original
(or Peep will complain).</p>
<p><strong>Peep does not magically vet your packages.</strong> Peep is not a substitute for
combing through your packages for malicious code or comparing them with
known-good versions. If you don’t vet them, they are not vetted.</p>
<p><strong>Peep does not make authors or indices trustworthy.</strong> All Peep does is
guarantee that subsequent downloads of <tt><span class="pre">Foo==1.2.3</span></tt> are the same as the
first one. It doesn’t guarantee the author of that package is trustworthy. It
doesn’t guarantee that the author of that package is the one who released that
package. It doesn’t guarantee that the package index is trustworthy.</p>
</div>
<div id="troubleshooting">
<h3>Troubleshooting</h3>
<div id="multiple-hashes-architecture-specific-packages-and-old-versions-of-pypi">
<h4>Multiple Hashes: Architecture-Specific Packages and Old Versions of PyPI</h4>
<p>Are you suddenly getting the Fearsome Warning? Maybe you’re really in trouble,
but maybe something more innocuous is happening.</p>
<p>If your packages install from wheels or other potentially architecture-specific
sources, their hashes will obviously differ across platforms. If you deploy on
more than one, you’ll need more than one hash.</p>
<p>Also, some packages offer downloads in multiple formats: for example, zips and
tarballs, or zips and wheels. Which version gets downloaded can vary based on
your version of pip, meaning some packages may effectively have more than one
valid hash.</p>
<p>To support these scenarios, you can stack up multiple known-good hashes above a
requirement, as long as they are within a contiguous block of commented lines:</p>
<pre># Tarball:
# sha256: lvpN706AIAvoJ8P1EUfdez-ohzuSB-MyXUe6Rb8ppcE
#
# And the zip file:
# sha256: 6QTt-5DahBKcBiUs06BfkLTuvBu1uF7pblb_bPaUONU
mock==0.8.0
</pre>
<p>If you don’t want to wait until you’re bitten by this surprise, use the <tt>peep
hash</tt> command to find hashes of each equivalent archive for a package. I like
to vet one of them (say, the tarball), then download the others and use a file
comparison tool to verify that they have identical contents. Then I run <tt>peep
hash</tt> over both original archives, like so, and add the result to my
<tt>requirements.txt</tt>:</p>
<pre>% peep hash mock-0.8.0.tar.gz mock-0.8.0.zip
# sha256: lvpN706AIAvoJ8P1EUfdez-ohzuSB-MyXUe6Rb8ppcE
# sha256: 6QTt-5DahBKcBiUs06BfkLTuvBu1uF7pblb_bPaUONU
</pre>
</div>
<div id="upgrading-wheels-with-old-versions-of-pip">
<h4>Upgrading Wheels with Old Versions of pip</h4>
<p>If you’re reusing a virtualenv and using Peep with pip &lt;6.0, then you should
avoid using wheels. Otherwise, the old version of a package will not be entirely
removed before the new one is installed, due to
<a href="https://github.com/pypa/pip/issues/1825" rel="nofollow">https://github.com/pypa/pip/issues/1825</a>.</p>
<p>If you’re using pip 1.4, don’t pass the <tt><span class="pre">--use-wheel</span></tt> argument.</p>
<p>If you’re using pip 1.5, pass the <tt><span class="pre">--no-use-wheel</span></tt> argument.</p>
</div>
</div>
<div id="version-history">
<h3>Version History</h3>
<dl>
<dt>3.1.1</dt>
<dd><ul>
<li>The “peep had a problem” traceback is no longer output for several cases
of pip installation errors that were not peep’s fault: for instance, the
specified package version or requirements file not existing.</li>
<li><tt>peep port</tt> now emits URLs for URL-based requirements, if you’re using
pip 6.1.0 or greater. (jotes)</li>
</ul>
</dd>
<dt>3.1</dt>
<dd><ul>
<li>Print the name each new requirements file we encounter during <tt>peep
port</tt>. This helps untangle the mess if your files use includes. (pmac)</li>
<li>Always put hashes on their own lines, even if there’s only one. (pmac)</li>
</ul>
</dd>
<dt>3.0</dt>
<dd><ul>
<li>Add support for pip 8.x.</li>
<li>Drop support for the <tt><span class="pre">--allow-external</span></tt>, <tt><span class="pre">--allow-unverified</span></tt> and
<tt><span class="pre">--allow-all-external</span></tt> arguments (for compatibility with pip 8).</li>
<li>Drop support for Python 3.1/3.2.</li>
</ul>
</dd>
<dt>2.5</dt>
<dd><ul>
<li>Support pip 7.x, through the currently latest 7.1.2, working around its
buggy line counting. (kouk)</li>
<li>Add <tt>peep port</tt> command to facilitate the transition to <a href="https://pip.pypa.io/en/latest/reference/pip_install/#hash-checking-mode" rel="nofollow">pip 8’s hashing</a>.</li>
<li>Fix bug in which the right way to call <tt>parse_requirements()</tt> would not
be autodetected.</li>
</ul>
</dd>
<dt>2.4.1</dt>
<dd><ul>
<li>Tolerate pip.__version__ being missing, which can apparently happen in
arcane situations during error handling, obscuring informative tracebacks.</li>
<li>Fix flake8 warnings again, and add flake8 to Travis runs.</li>
</ul>
</dd>
<dt>2.4</dt>
<dd><ul>
<li>Add support for flags in the requirements file, pip-style, such as
specifying alternative indices with <tt><span class="pre">-i</span></tt>.</li>
<li>Remove a duplicate <tt>#egg=</tt> segment from an error message.</li>
</ul>
</dd>
<dt>2.3</dt>
<dd><ul>
<li>Copy the operative portion of the MIT license into peep.py so embedding it
doesn’t break the license.</li>
<li>Fix flake8 linter warnings.</li>
<li>Make peep compatible with pip v6.1.0+.</li>
<li>Add tests against pip 6.0.8, 6.1.0, and 6.1.1 to the tox config.</li>
<li>Run full set of tox tests on Travis.</li>
</ul>
</dd>
<dt>2.2</dt>
<dd><ul>
<li>Add progress indication while downloading. Used with pip 6.0 and above, we
show a nice progress bar. Before that, we just mention the packages as we
download them.</li>
<li>Remove extra skipped lines from the output.</li>
<li>Add tests against pip 6.0.7 to the tox config.</li>
</ul>
</dd>
<dt>2.1.2</dt>
<dd><ul>
<li>Get rid of repetition of explanatory messages at the end of a run when one
applies to multiple packages.</li>
</ul>
</dd>
<dt>2.1.1</dt>
<dd><ul>
<li>Fix bug in which peep would not upgrade a package expressed in terms of a
GitHub-dwelling zip file if its version had not changed.</li>
<li>Add tests against pip 6.0.4, 6.0.5, and 6.0.6 to the tox config.</li>
</ul>
</dd>
<dt>2.1</dt>
<dd><ul>
<li>Support pip 6.x.</li>
<li>Make error reporting friendly, emitting a bug reporting URL and
environment info along with the traceback.</li>
</ul>
</dd>
<dt>2.0</dt>
<dd><ul>
<li>Fix major security hole in which a package’s setup.py would be executed
after download, regardless of whether the package’s archive matched a hash.
Specifically, stop relying on pip for downloading packages, as it likes to
run setup.py to extract metadata. Implement our own downloading using
what’s available everywhere: urllib2. As a result, HTTP proxies,
basic auth, and <tt><span class="pre">--download-cache</span></tt> are unsupported at the moment.</li>
<li>Refactor significantly for comprehensibility.</li>
<li>Drastically improve test coverage.</li>
<li>Note that HTTPS certs are no longer checked. This shouldn’t matter, given
our hash checks.</li>
</ul>
</dd>
<dt>1.4</dt>
<dd><ul>
<li>Allow partial-line comments.</li>
<li>Add the beginnings of a test suite.</li>
<li>Treat package names in requirements files as case-insensitive, like pip.</li>
</ul>
</dd>
<dt>1.3</dt>
<dd><ul>
<li>Pass through most args to the invocation of <tt>pip install</tt> that actually
installs the downloaded archive. This means you can use things like
<tt><span class="pre">--install-options</span></tt> fruitfully.</li>
<li>Add Python 3.4 support by correcting an import.</li>
<li>Install a second peep script named after the active Python version, e.g.
peep-2.7. This is a convenience for those using multiple versions of
Python and not using virtualenvs.</li>
</ul>
</dd>
<dt>1.2</dt>
<dd><ul>
<li>Support GitHub-style tarballs (that is, ones whose filenames don’t contain
the distro name or version and whose version numbers aren’t reliable) in
requirements files. (Will Kahn-Greene)</li>
<li>Warn when a URL-based requirement lacks <tt>#egg=</tt>. (Chris Adams)</li>
</ul>
</dd>
<dt>1.1</dt>
<dd><ul>
<li>Support Python 3. (Keryn Knight)</li>
</ul>
</dd>
<dt>1.0.2</dt>
<dd><ul>
<li>Add support for .tar.bz2 archives. (Paul McLanahan)</li>
</ul>
</dd>
<dt>1.0.1</dt>
<dd><ul>
<li>Fix error (which failed safe) installing packages whose distro names
contain underscores. (Chris Ladd)</li>
</ul>
</dd>
<dt>1.0</dt>
<dd><ul>
<li>Add wheel support. Peep will now work fine when pip decides to download a
wheel file. (Paul McLanahan)</li>
</ul>
</dd>
<dt>0.9.1</dt>
<dd><ul>
<li>Don’t crash when trying to report a missing hash on a package that’s
already installed.</li>
</ul>
</dd>
<dt>0.9</dt>
<dd><ul>
<li>Put the operative parts of peep into a single module rather than a package,
and make it directly executable. (Brian Warner)</li>
</ul>
</dd>
<dt>0.8</dt>
<dd><ul>
<li>Support installing into non-empty virtualenvs, for speed. We do this by
trusting any already-installed package which satisfies a requirement. This
means you no longer have to rebuild <tt>lxml</tt>, for instance, each time you
deploy.</li>
<li>Wrap text output to 80 columns for nicer word wrap.</li>
</ul>
</dd>
<dt>0.7</dt>
<dd><p>Make some practical tweaks for projects which bootstrap their trust chains by
checking a tarball of peep into their source trees.</p>
<ul>
<li>Start supporting versions of pip back to 0.6.2 (released in January 2010).
This way, you can deploy trustworthily on old versions of RHEL just by
checking a tarball of peep into your source tree and pip-installing it; you
don’t have to check in pip itself or go to the bother of unpacking the peep
tarball and running <tt>python setup.py install</tt> from your deploy script.</li>
<li>Remove the explicit dependency on pip. This is so a blithe call to
<tt>pip install peep.tar.gz</tt> without <tt><span class="pre">--no-deps</span></tt> doesn’t go out and pull
an untrusted package from PyPI. Instead, we scream at runtime if pip is
absent or too old. Fail safe.</li>
</ul>
</dd>
<dt>0.6</dt>
<dd><ul>
<li>Add <tt>peep hash</tt> subcommand.</li>
<li>Require pip&gt;=1.2, as lower versions have a bug that causes a crash on
<tt>peep install</tt>.</li>
</ul>
</dd>
<dt>0.5</dt>
<dd>
</dd>
<dt>0.4</dt>
<dd><ul>
<li>Rework how peep downloads files and determines versions so we can tolerate
PEP-386-noncompliant package version numbers. This amounted to a minor
rewrite.</li>
<li>Remove indentation from hash output so you don’t have to dedent it after
pasting it into <tt>requirements.txt</tt>.</li>
</ul>
</dd>
<dt>0.3</dt>
<dd><ul>
<li>Support Windows and other non-Unix OSes.</li>
<li>The hash output now includes the actual version numbers of packages, so you
can just paste it straight into your <tt>requirements.txt</tt>.</li>
</ul>
</dd>
<dt>0.2.1</dt>
<dd><ul>
<li>Add a shebang line so you can actually run <tt>peep</tt> after doing <tt>pip
install peep</tt>. Sorry, folks, I was doing <tt>setup.py develop</tt> on my own
box.</li>
</ul>
</dd>
<dt>0.2</dt>
<dd><ul>
<li>Fix repeated-logging bug.</li>
<li>Fix spurious error message about not having any requirements files.</li>
<li>Pass pip’s exit code through to the outside for calls to non-<tt>install</tt>
subcommands.</li>
<li>Improve spacing in the final output.</li>
</ul>
</dd>
<dt>0.1</dt>
<dd><ul>
<li>Proof of concept. Does all the crypto stuff. Should be secure. Some rough
edges in the UI.</li>
</ul>
</dd>
</dl>
</div>
</div>


</div></body></html>