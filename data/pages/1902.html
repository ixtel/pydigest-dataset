<html><body><div><article>
      <p>I've been working with Python bytecode recently, and wanted to share some of my experience working with it. To be more precise, I've been working exclusively on the bytecode for the CPython interpreter, and limited to versions 2.6 and 2.7.</p>
<p>Python is a dynamic language, and running it from the command line essentially triggers the following steps:</p>
<ul>
<li>The source is compiled the first time it is encountered (e.g., imported as a module or directly executed). This step generates the binary file, with a <code>pyc</code> or <code>pyo</code> extension depending on your system.</li>
<li>The interpreter reads the binary file and executes the instructions (opcodes) one at a time.</li>
</ul>
<p>The python interpreter is stack-based, and to understand the dataflow, we need to know what the stack effect is of each instruction (i.e., opcode and argument).</p>
<h2>Inspecting a Python Binary File</h2>
<p>The simplest way to get the bytecode of a binary file is to unmarshall the <code>CodeType</code> structure:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">marshal</span>
<span class="n">fd</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'path/to/my.pyc'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span>
<span class="n">magic</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c"># python version specific magic num</span>
<span class="n">date</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c"># compilation date</span>
<span class="n">code_object</span> <span class="o">=</span> <span class="n">marshal</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
<span class="n">fd</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>


<p>The <code>code_object</code> now contains a <code>CodeType</code> object which represents the entire module from the loaded file. To inspect all nested code objects from this module, meaning class declarations, methods, etc. we need to recursively inspect the const pool from the <code>CodeType</code>; that means doing something like this:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">types</span>

<span class="k">def</span> <span class="nf">inspect_code_object</span><span class="p">(</span><span class="n">co_obj</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s">''</span><span class="p">):</span>
  <span class="k">print</span> <span class="n">indent</span><span class="p">,</span> <span class="s">"</span><span class="si">%s</span><span class="s">(lineno:</span><span class="si">%d</span><span class="s">)"</span> <span class="o">%</span> <span class="p">(</span><span class="n">co_obj</span><span class="o">.</span><span class="n">co_name</span><span class="p">,</span> <span class="n">co_obj</span><span class="o">.</span><span class="n">co_firstlineno</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">co_obj</span><span class="o">.</span><span class="n">co_consts</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">CodeType</span><span class="p">):</span>
      <span class="n">inspect_code_object</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="s">'  '</span><span class="p">)</span>

<span class="n">inspect_code_object</span><span class="p">(</span><span class="n">code_object</span><span class="p">)</span> <span class="c"># We resume from the previous snippet</span>
</pre></div>


<p>In this case, we'll print a tree of code objects nested under their respective parents. For the following simple code:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>
  <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">'A()'</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="k">print</span> <span class="n">a</span>
</pre></div>


<p>We'll get the tree:</p>
<div class="highlight"><pre> &lt;module&gt;(lineno:2)
   A(lineno:2)
     __init__(lineno:3)
     __repr__(lineno:5)
</pre></div>


<p>For testing, we can get the code object from a string that contains the Python source code by using the <code>compile</code> directive:</p>
<div class="highlight"><pre><span class="n">co_obj</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">python_source_code</span><span class="p">,</span> <span class="s">'&lt;string&gt;'</span><span class="p">,</span> <span class="s">'exec'</span><span class="p">)</span>
</pre></div>


<p>For more inspection of the code object, we can have a look at the <a href="https://docs.python.org/2/library/inspect.html#types-and-members">co_* fields</a> from the Python documentation.</p>
<h2>First Look Into the Bytecode</h2>
<p>Once we get the code objects, we can actually start looking at the disassembly of it (in the <code>co_code</code> field). Parsing the bytecode to make sense out of it means:</p>
<ul>
<li>Interpreting what the opcode means</li>
<li>Dereference any argument</li>
</ul>
<p>The <a href="https://hg.python.org/cpython/file/2.7/Lib/dis.py#l61">disassemble function in the dis module</a> shows how to do that. It will actually provide the following output from our previous code example:</p>
<div class="highlight"><pre>2   0 LOAD_CONST        0 ('A')
    3 LOAD_CONST        3 (())
    6 LOAD_CONST        1 (&lt;code object A at 0x42424242, file "&lt;string&gt;", line 2&gt;)
    9 MAKE_FUNCTION     0
   12 CALL_FUNCTION     0
   15 BUILD_CLASS
   16 STORE_NAME        0 (A)

8  19 LOAD_NAME         0 (A)
   22 CALL_FUNCTION     0
   25 STORE_NAME        1 (a)

9  28 LOAD_NAME         1 (a)
   31 PRINT_ITEM
   32 PRINT_NEWLINE
   33 LOAD_CONST        2 (None)
   36 RETURN_VALUE
</pre></div>


<p>Where we get:</p>
<ul>
<li>The line number (when it changed)</li>
<li>The index of the instruction</li>
<li>The opcode of the current instruction</li>
<li>The oparg, which is what the opcode takes to resolve to the actual argument, it knows where to look based on the opcode. For example, with a <code>LOAD_NAME</code> opcode, the oparg will point to the index in the <code>co_names</code> tuple.</li>
<li>The resolved argument in parentheses</li>
</ul>
<p>As we can see at the index 6, the <code>LOAD_CONST</code> opcode takes an oparg that points to which object should be loaded from the <code>co_consts</code> tuple. Here, it points to the type declaration of <code>A</code>. Recursively, we can go and decompile all code objects to get the full bytecode of the module.</p>
<p>The first part of the bytecode (index 0 to 16) relates to the type declaration of <code>A</code> while the rest represents the code where we instantiate an <code>A</code> and print it. Even in this code, there are constructs that are not relevant unless you plan on modifying the bytecode and changing types, etc.</p>
<h2>Interesting Bytecode Constructs</h2>
<p>The <a href="https://docs.python.org/2/library/dis.html#python-bytecode-instructions">overall opcodes</a> are fairly straight forward, but a few cases seem weird as they might come from:</p>
<ul>
<li>Compiler optimizations</li>
<li>Interpreter optimizations (therefore leading to extra opcodes)</li>
</ul>
<h3>Variables Assignment with Sequences</h3>
<p>In the first category, we can have a look at what happens when the source assign sequences of variables:</p>
<div class="highlight"><pre><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'2'</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">e</span>
<span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">e</span>
<span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">e</span>
</pre></div>


<p>These 4 statements produce quite a different bytecode.</p>
<p>The first case is the simplest one since the right-hand side (RHS) of the assignment contains only constants. In that case, CPython can create the tuple <code>(1, '2')</code>, use <code>UNPACK_SEQUENCE</code> to put 2 elements on the stack, and create a <code>STORE_FAST</code> for each variable <code>a</code> and <code>b</code>:</p>
<div class="highlight"><pre>0 LOAD_CONST               5 ((1, '2'))
3 UNPACK_SEQUENCE          2
6 STORE_FAST               0 (a)
9 STORE_FAST               1 (b)
</pre></div>


<p>The second case however introduce a variable on the RHS, so the generic case is called where an expression is fetched (here, a simple one with a <code>LOAD_GLOBAL</code>). The compiler however does not need to create a new tuple from the values on the stack (at index 18) and use an <code>UNPACK_SEQUENCE</code>; it's sufficient to call the <code>ROT_TWO</code> which swaps the 2 top elements from the stack (it might have been enough to switch 19 and 22 though):</p>
<div class="highlight"><pre>12 LOAD_CONST               1 (1)
15 LOAD_GLOBAL              0 (e)
18 ROT_TWO
19 STORE_FAST               0 (a)
22 STORE_FAST               1 (b)
</pre></div>


<p>The third case is where it becomes really strange. Putting the expressions on the stack is exactly the same mechanism as in the previous case, but after it first swap the 3 top elements, then swap again the 2 top elements:</p>
<div class="highlight"><pre>25 LOAD_CONST               1 (1)
28 LOAD_CONST               3 (2)
31 LOAD_GLOBAL              0 (e)
34 ROT_THREE
35 ROT_TWO
36 STORE_FAST               0 (a)
39 STORE_FAST               1 (b)
42 STORE_FAST               2 (c)
</pre></div>


<p>The final one represents the generic case, where no more <code>ROT_*</code>-play seems possible and a tuple is created and then a call to <code>UNPACK_SEQUENCE</code> to put them on the stack:</p>
<div class="highlight"><pre>45 LOAD_CONST               1 (1)
48 LOAD_CONST               3 (2)
51 LOAD_CONST               4 (3)
54 LOAD_GLOBAL              0 (e)
57 BUILD_TUPLE              4
60 UNPACK_SEQUENCE          4
63 STORE_FAST               0 (a)
66 STORE_FAST               1 (b)
69 STORE_FAST               2 (c)
72 STORE_FAST               3 (d)
</pre></div>


<h3>Call Constructs</h3>
<p>The last set of interesting examples are around the call constructs and the <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION">4 different opcodes</a> to create calls. I suppose the number of opcodes is to optimize the interpreter code, since it's not like in Java where it makes sense to have one of the <code>invokedynamic</code>, <code>invokeinterface</code>, <code>invokespecial</code>, <code>invokestatic</code>, or <code>invokevirtual</code>.</p>
<p>In Java, <code>invokeinterface</code>, <code>invokespecial</code> and <code>invokevirtual</code> are originally coming from the static typing of the language (and <code>invokespecial</code> is only used for calling constructors and superclasses AFAIK). <code>invokestatic</code> is self describing (no need to put the receiver on the stack) and there is no such concept (down to the interpreter and not through decorators) in Python. In short, Python calls could always be translated with an <code>invokedynamic</code>.</p>
<p>The different <code>CALL_*</code> opcodes in Python are indeed not here because of typing, static methods, or the need to have a special access for constructors. They are all targeting on how a method call can be specified in Python; from the grammar:</p>
<div class="highlight"><pre>  Call(expr func, expr* args, keyword* keywords,
       expr? starargs, expr? kwargs)
</pre></div>


<p>The calls structure allow for code like this:</p>
<div class="highlight"><pre><span class="n">func</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="n">SOME_VALUE</span><span class="p">,</span> <span class="o">*</span><span class="n">unpack_list</span><span class="p">,</span> <span class="o">**</span><span class="n">unpack_dict</span><span class="p">)</span>
</pre></div>


<p>The keyword arguments allow for passing formal parameters by name and not just position, the <code>*</code> puts all elements from the iterable as arguments (inlined, not in a tuple), and the <code>**</code> expects a dictionary of keywords with values.</p>
<p>This example actually uses all possible features of the call site construction:</p>
<ul>
<li>Variables argument list passing (<code>_VAR</code>): <code>CALL_FUNCTION_VAR</code>, <code>CALL_FUNCTION_VAR_KW</code></li>
<li>Keyword based dict passing (<code>_KW</code>): <code>CALL_FUNCTION_KW</code>, <code>CALL_FUNCTION_VAR_KW</code></li>
</ul>
<p>The bytecode looks like this:</p>
<div class="highlight"><pre> 0 LOAD_NAME                0 (func)
 3 LOAD_NAME                1 (arg1)
 6 LOAD_NAME                2 (arg2)
 9 LOAD_CONST               0 ('keyword')
12 LOAD_NAME                3 (SOME_VALUE)
15 LOAD_NAME                4 (unpack_list)
18 LOAD_NAME                5 (unpack_dict)
21 CALL_FUNCTION_VAR_KW   258
</pre></div>


<p>Usually, a <code>CALL_FUNCTION</code> takes as oparg the number of arguments for the function. Here however, more information is encoded. The first byte (<code>0xff</code> mask) carries the number of arguments and the second one (<code>(value &gt;&gt; 8) &amp; 0xff</code>) the number of keyword arguments passed. To compute the number of elements to pop from the stack, we then need to get:</p>
<div class="highlight"><pre><span class="n">na</span> <span class="o">=</span> <span class="n">arg</span> <span class="o">&amp;</span> <span class="mh">0xff</span>         <span class="c"># num args</span>
<span class="n">nk</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>  <span class="c"># num keywords</span>
<span class="n">n_to_pop</span> <span class="o">=</span> <span class="n">na</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nk</span> <span class="o">+</span> <span class="n">CALL_EXTRA_ARG_OFFSET</span><span class="p">[</span><span class="n">op</span><span class="p">]</span>
</pre></div>


<p>where <code>CALL_EXTRA_ARG_OFFSET</code> contains an offset specific to the call opcode (2 for <code>CALL_FUNCTION_VAR_KW</code>). Here, that gives us 6, the number of elements to pop before accessing the function name.</p>
<p>To relate to other <code>CALL_*</code> keywords, it then all depends if the code is either using the list passing or dictionary passing argument; it's all about combination here!</p>
<h2>Building a Minimal CFG</h2>
<p>For understanding how the code actually works, it's interesting to build a control-flow graph (CFG) so we can follow which unconditional sequences of opcodes (basic blocks) will be executed, and under what conditions.</p>
<p>Even if the bytecode is a fairly small language, building a reliable CFG requires more details than this blog post can allow, so for an actual implementation of a CFG construction, you can have a look at <a href="https://github.com/neuroo/equip/blob/master/equip/analysis/flow.py#L170">equip</a>.</p>
<p>Here, we'll focus on loop/exception free code, where the control flow only depends on if statements.</p>
<p>There are a handful of opcodes that carry a jump address (for non-loop/exceptions); they are:</p>
<ul>
<li><code>JUMP_FORWARD</code>: Relative jump in the bytecode. Takes the amount of bytes to skip.</li>
<li><code>JUMP_IF_FALSE_OR_POP</code>, <code>JUMP_IF_TRUE_OR_POP</code>, <code>JUMP_ABSOLUTE</code>, <code>POP_JUMP_IF_FALSE</code>, and <code>POP_JUMP_IF_TRUE</code> all take absolute index in the bytecode.</li>
</ul>
<p>Building the CFG for a function means creating basic blocks (sequence of opcodes that have unconditional execution -- except when an exception can occur), and connecting them in a graph that contains conditions on branches. In our case, we only have <code>True</code>, <code>False</code>, and <code>Unconditional</code> branches.</p>
<p>Let's consider the following code example (which should never be used in practice):</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">1</span>
  <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">2</span>
  <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>


<p>As mentioned before, we get the code object for the <code>factorial</code> method:</p>
<div class="highlight"><pre><span class="n">module_co</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">python_source</span><span class="p">,</span> <span class="s">'&lt;string&gt;'</span><span class="p">,</span> <span class="s">'exec'</span><span class="p">)</span>
<span class="n">meth_co</span> <span class="o">=</span> <span class="n">module_co</span><span class="o">.</span><span class="n">co_consts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>


<p>The disassembly looks like this (minus my annotations):</p>
<div class="highlight"><pre>3           0 LOAD_FAST                0 (n)
            3 LOAD_CONST               1 (1)
            6 COMPARE_OP               1 (&lt;=)
            9 POP_JUMP_IF_FALSE       16              &lt;&lt;&lt; control flow

4          12 LOAD_CONST               1 (1)
           15 RETURN_VALUE                            &lt;&lt;&lt; control flow

5     &gt;&gt;   16 LOAD_FAST                0 (n)
           19 LOAD_CONST               2 (2)
           22 COMPARE_OP               2 (==)
           25 POP_JUMP_IF_FALSE       32              &lt;&lt;&lt; control flow

6          28 LOAD_CONST               2 (2)
           31 RETURN_VALUE                            &lt;&lt;&lt; control flow

7     &gt;&gt;   32 LOAD_FAST                0 (n)
           35 LOAD_GLOBAL              0 (factorial)
           38 LOAD_FAST                0 (n)
           41 LOAD_CONST               1 (1)
           44 BINARY_SUBTRACT
           45 CALL_FUNCTION            1
           48 BINARY_MULTIPLY
           49 RETURN_VALUE                            &lt;&lt;&lt; control flow
</pre></div>


<p>In this bytecode, we have 5 instructions that change the structure of the CFG (so adds constraints or allows for quick exit):</p>
<ul>
<li><code>POP_JUMP_IF_FALSE</code>: Jump to the absolute index 16 and 32,</li>
<li><code>RETURN_VALUE</code>: Pop one element from the stack and returns it.</li>
</ul>
<p>Extracting the basic blocks becomes easy since these instructions that change the control flow are the only one we're interested in detecting. In our case, we don't have jumps that impose no fall-through, but <code>JUMP_FORWARD</code> or <code>JUMP_ABSOLUTE</code> do that.</p>
<p>Example code to extract such structure:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">opcode</span>
<span class="n">RETURN_VALUE</span> <span class="o">=</span> <span class="mi">83</span>
<span class="n">JUMP_FORWARD</span><span class="p">,</span> <span class="n">JUMP_ABSOLUTE</span> <span class="o">=</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">113</span>
<span class="n">FALSE_BRANCH_JUMPS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="mi">114</span><span class="p">)</span> <span class="c"># JUMP_IF_FALSE_OR_POP, POP_JUMP_IF_FALSE</span>

<span class="k">def</span> <span class="nf">find_blocks</span><span class="p">(</span><span class="n">meth_co</span><span class="p">):</span>
  <span class="n">blocks</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">code</span> <span class="o">=</span> <span class="n">meth_co</span><span class="o">.</span><span class="n">co_code</span>
  <span class="n">finger_start_block</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">i</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
  <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">:</span>
    <span class="n">op</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">code</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="n">RETURN_VALUE</span><span class="p">:</span> <span class="c"># We force finishing the block after the return,</span>
                           <span class="c"># dead code might still exist after though...</span>
      <span class="n">blocks</span><span class="p">[</span><span class="n">finger_start_block</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'length'</span><span class="p">:</span> <span class="n">i</span> <span class="o">-</span> <span class="n">finger_start_block</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s">'exit'</span><span class="p">:</span> <span class="bp">True</span>
      <span class="p">}</span>
      <span class="n">finger_start_block</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">elif</span> <span class="n">op</span> <span class="o">&gt;=</span> <span class="n">opcode</span><span class="o">.</span><span class="n">HAVE_ARGUMENT</span><span class="p">:</span>
      <span class="n">oparg</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">code</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">code</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
      <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">opcode</span><span class="o">.</span><span class="n">hasjabs</span><span class="p">:</span> <span class="c"># Absolute jump to oparg</span>
        <span class="n">blocks</span><span class="p">[</span><span class="n">finger_start_block</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
          <span class="s">'length'</span><span class="p">:</span> <span class="n">i</span> <span class="o">-</span> <span class="n">finger_start_block</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="n">JUMP_ABSOLUTE</span><span class="p">:</span> <span class="c"># Only uncond absolute jump</span>
          <span class="n">blocks</span><span class="p">[</span><span class="n">finger_start_block</span><span class="p">][</span><span class="s">'conditions'</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">'uncond'</span><span class="p">:</span> <span class="n">oparg</span>
          <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">false_index</span><span class="p">,</span> <span class="n">true_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">oparg</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">FALSE_BRANCH_JUMPS</span> <span class="k">else</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">oparg</span><span class="p">)</span>
          <span class="n">blocks</span><span class="p">[</span><span class="n">finger_start_block</span><span class="p">][</span><span class="s">'conditions'</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">'true'</span><span class="p">:</span> <span class="n">true_index</span><span class="p">,</span>
            <span class="s">'false'</span><span class="p">:</span> <span class="n">false_index</span>
          <span class="p">}</span>
        <span class="n">finger_start_block</span> <span class="o">=</span> <span class="n">i</span>
      <span class="k">elif</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">opcode</span><span class="o">.</span><span class="n">hasjrel</span><span class="p">:</span>
        <span class="c"># Essentially do the same...</span>
        <span class="k">pass</span>

  <span class="k">return</span> <span class="n">blocks</span>
</pre></div>


<p>And we get the following basic blocks:</p>
<div class="highlight"><pre><span class="n">Block</span>  <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s">'length'</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s">'conditions'</span><span class="p">:</span> <span class="p">{</span><span class="s">'false'</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="s">'true'</span><span class="p">:</span> <span class="mi">12</span><span class="p">}}</span>
<span class="n">Block</span> <span class="mi">12</span><span class="p">:</span> <span class="p">{</span><span class="s">'length'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'exit'</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
<span class="n">Block</span> <span class="mi">16</span><span class="p">:</span> <span class="p">{</span><span class="s">'length'</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s">'conditions'</span><span class="p">:</span> <span class="p">{</span><span class="s">'false'</span><span class="p">:</span> <span class="mi">32</span><span class="p">,</span> <span class="s">'true'</span><span class="p">:</span> <span class="mi">28</span><span class="p">}}</span>
<span class="n">Block</span> <span class="mi">28</span><span class="p">:</span> <span class="p">{</span><span class="s">'length'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'exit'</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
<span class="n">Block</span> <span class="mi">32</span><span class="p">:</span> <span class="p">{</span><span class="s">'length'</span><span class="p">:</span> <span class="mi">17</span><span class="p">,</span> <span class="s">'exit'</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
</pre></div>


<p>With the current structure of the blocks:</p>
<div class="highlight"><pre>Basic blocks
  start_block_index :=
     length     := size of instructions
     condition  := true | false | uncond -&gt; target_index
     exit*      := true
</pre></div>


<p>we have our control flow graph (minus the entry and implicit return blocks), and we can for example convert it to dot for visualization:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">to_dot</span><span class="p">(</span><span class="n">blocks</span><span class="p">):</span>
  <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="k">def</span> <span class="nf">get_node_id</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">buf</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
      <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s">'node_</span><span class="si">%d</span><span class="s">'</span> <span class="o">%</span> <span class="n">idx</span>
      <span class="n">buf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'</span><span class="si">%s</span><span class="s"> [label="Block Index </span><span class="si">%d</span><span class="s">"];'</span> <span class="o">%</span> <span class="p">(</span><span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">idx</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

  <span class="nb">buffer</span> <span class="o">=</span> <span class="p">[</span><span class="s">'digraph CFG {'</span><span class="p">]</span>
  <span class="nb">buffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'entry [label="CFG Entry"]; '</span><span class="p">)</span>
  <span class="nb">buffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'exit  [label="CFG Implicit Return"]; '</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">block_idx</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
    <span class="n">node_id</span> <span class="o">=</span> <span class="n">get_node_id</span><span class="p">(</span><span class="n">block_idx</span><span class="p">,</span> <span class="nb">buffer</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">block_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="nb">buffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'entry -&gt; </span><span class="si">%s</span><span class="s">;'</span> <span class="o">%</span> <span class="n">node_id</span><span class="p">)</span>
    <span class="k">if</span> <span class="s">'conditions'</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">[</span><span class="n">block_idx</span><span class="p">]:</span>
      <span class="k">for</span> <span class="n">cond_kind</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">[</span><span class="n">block_idx</span><span class="p">][</span><span class="s">'conditions'</span><span class="p">]:</span>
        <span class="n">target_id</span> <span class="o">=</span> <span class="n">get_node_id</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="n">block_idx</span><span class="p">][</span><span class="s">'conditions'</span><span class="p">][</span><span class="n">cond_kind</span><span class="p">],</span> <span class="nb">buffer</span><span class="p">)</span>
        <span class="nb">buffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'</span><span class="si">%s</span><span class="s"> -&gt; </span><span class="si">%s</span><span class="s"> [label="</span><span class="si">%s</span><span class="s">"];'</span> <span class="o">%</span> <span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">target_id</span><span class="p">,</span> <span class="n">cond_kind</span><span class="p">))</span>
    <span class="k">if</span> <span class="s">'exit'</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">[</span><span class="n">block_idx</span><span class="p">]:</span>
      <span class="nb">buffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'</span><span class="si">%s</span><span class="s"> -&gt; exit;'</span> <span class="o">%</span> <span class="n">node_id</span><span class="p">)</span>

  <span class="nb">buffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'}'</span><span class="p">)</span>
  <span class="k">return</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">buffer</span><span class="p">)</span>
</pre></div>


<p>To produce the source of that graph:
</p><center><img src="/static/media/img/python/bytecode-cfg.png"/></center>
<h2>Why Bother?</h2>
<p>It's indeed fairly rare to only have access to the Python bytecode, but I've had this case a few times in the past. Hopefully, this information can help someone starting a reverse engineering project on Python.</p>
<p>Right now however, I've been investigating the ability to instrument Python code, and especially its bytecode since there are no facilities for doing so in Python (and instrumenting source code often leaves with very inefficient instrumentation code with decorators, etc.). That's where <a href="https://github.com/neuroo/equip">equip</a> comes from.</p>
  </article>

    
  
</div></body></html>