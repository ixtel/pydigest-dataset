<html><body><div><div class="page" title="Page 134">
<div class="layoutArea">
<p class="column">
В каждой комнате должно оказаться ровно два студента. Будем считать, что в каждой комнате есть два отсека, то есть всего их в нашем случае будет десять. Каждому студенту по очереди назначается один из незанятых отсеков; первого можно поместить в любой из десяти отсеков, второго – в любой из оставшихся девяти и т. д.</p>
<p class="column">
<br/></p>

<p class="column">
<br/></p>
<pre class="brush: python"># [9, 8, 7, 6,..., 1]
domain = [i for i in xrange(9, 0, -1)]
</pre>
<p class="column">
<br/>
<h3>
Целевая функция</h3>
Целевая функция работает следующим образом. Создается начальный список отсеков, и уже использованные отсеки из него удаляются. Стоимость вычисляется путем сравнения комнаты, в которую студент помещен, с двумя его пожеланиями. Стоимость не изменяется, если студенту досталась та комната, в которую он больше всего хотел поселиться; увеличивается на 1, если это второе из его пожеланий; и увеличивается на 3, если он вообще не хотел жить в этой комнате. </p>
<p class="column">
<br/></p>
<pre class="brush: python">def dorm_cost(vec):
 cost=0

 # Создаем список отсеков, т.е. первые 2 места - 0 отсек и т.д.
 slots = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4]

 # Цикл по студентам, i - порядковый номер студента
 for i in xrange(len(vec)):
  x = int(vec[i])
  dorm = dorms[slots[x]]
  pref = prefs[i][1]
  print x, '-&gt;', slots[x],'-&gt;', prefs[i][0], pref, '-&gt;', dorm

  # Стоимость основного пожелания равна 0, альтернативного – 1
  # Если комната не входит в список пожеланий, стоимость увеличивается на 3
  if pref[0] == dorm: cost += 0
  elif pref[1] == dorm: cost += 1
  else: cost += 3

  # Удалить выбранный отсек
  # Это самое важное действие тут,
  # прошу особо обратить на него внимание и учесть, что элементы сдвигаются
  del slots[x]

 return cost
</pre>
<p class="layoutArea">
<br/></p><p>
При конструировании целевой функции полезно стремиться к тому, чтобы стоимость идеального решения (в данном случае каждый студент заселился в комнату, которую поставил на первое место в своем списке предпочтений) была равна нулю. В рассматриваемом примере мы уже убедились, что идеальное решение недостижимо, но, зная о том, что его стоимость равна нулю, можно оценить, насколько мы к нему приблизились. У этого правила есть еще одно достоинство – алгоритм оптимизации может прекратить поиск, если уже найдено идеальное решение. </p></div>
<p class="layoutArea">
<br/></p>
<h3>
Оптимизация</h3>
<div><p>
Всем кто не изучил методы оптимизации в </p><a href="http://py-algorithm.blogspot.ru/2014/10/blog-post_21.html">предыдущей статье</a><p>, бегом изучать!) Хорошим мальчикам и может даже девочкам, импортировать любой из методов и запустить!) Я, для примера, попробую на генетическом алгоритме.
</p></div>
<pre class="brush: python">result, score = genetic_optimize(domain, dorm_cost)
print result, score
</pre>
<p>
<br/>
Например у меня, нашелся такой результат [7, 1, 2, 0, 0, 1, 2, 1, 0] 1, что соответствует следующему выводу:<br/>
<br/>
7 -&gt; 3 -&gt; Toby ('Bacchus', 'Hercules') -&gt; Bacchus<br/>
1 -&gt; 0 -&gt; Steve ('Zeus', 'Pluto') -&gt; Zeus<br/>
2 -&gt; 1 -&gt; Karen ('Athena', 'Zeus') -&gt; Athena<br/>
0 -&gt; 0 -&gt; Sarah ('Zeus', 'Pluto') -&gt; Zeus<br/>
0 -&gt; 1 -&gt; Dave ('Athena', 'Bacchus') -&gt; Athena<br/>
1 -&gt; 2 -&gt; Jeff ('Hercules', 'Pluto') -&gt; Hercules<br/>
2 -&gt; 4 -&gt; Fred ('Pluto', 'Athena') -&gt; Pluto<br/>
1 -&gt; 3 -&gt; Suzie ('Bacchus', 'Hercules') -&gt; Bacchus<br/>
0 -&gt; 2 -&gt; Laura ('Bacchus', 'Hercules') -&gt; Hercules</p>
<p>
<br/>
Т.е. не устроило только Lauru и то, учтен был ее 2й вариант)<br/>
<br/>
<h3>
Вместо вывода</h3>
</p>
<p>
Итак, надеюсь, я показал, что используя одни алгоритмы, но меняя область определения и принцип расчета целевой функции, мы можем решить абсолютно разные оптимизационные задачи!)</p>
</div>
</div></body></html>