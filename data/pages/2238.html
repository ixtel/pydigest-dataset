<html><body><div><div class="content html_format"><p>
      Всем привет!</p>
<p>
Вчера мне понадобилось скачать все фотографии из диалога с одним человеком в vk.com. Фотографий было больше 1000 штук. Понятное дело, что ручками это все делать было бы утомительно и… Стыдно. Не для того программированием занимаюсь, чтобы такую </p><s>грязную</s><p> работу делать не автоматизированно. Поэтому было решено написать скрипт.
</p><p>
В качестве языка был выбран Python. Его удобно использовать для консоли, он довольно быстрый, есть модуль urllib, позволяющий «одним движением» скачивать картинки по ссылке. Но главная причина — это то, что я начал изучать его недавно. Решил дополнительно попрактиковаться. 
</p><p>
Сам скрипт получился небольшой, но было бы интересно описать процесс создания. Буду стараться писать побольше комментариев в коде, чтобы те, кто не знает python, тоже смогли понять процесс. А от знатоков очень приветствуются советы и указания. Итак, приступим.
</p><a name="habracut"/><p>
«Вконтакте» не предоставляет API конкретно для скачивания материалов из беседы, поэтому самое долгое время заняло изучение того, как устроена система подгрузки картинок из диалога в vk.com. Все картинки лежат у них, понятное дело, на сервере, и доступ к ним имеет любой, у кого есть ссылка на эту картинку. Таким образом, чтобы скачать все фотографии из диалога, нам надо получить все ссылки на картинки. Тыкаясь туда-сюда, было выяснено, что при нажатии на «Действия -&gt; показать материалы из беседы» отправляется POST запрос на </p><a href="http://vk.com/wkview.php">vk.com/wkview.php</a><p>. Запрос содержит параметры:

</p><ul>
<li>act:show</li>
<li>al:1</li>
<li>loc:im</li>
<li>w:history&lt;dialog_id&gt;_photo</li>
</ul><p>
В этом запросе dialog_id — это значение параметра «sel» в адресной строке, когда мы заходим в диалог.</p><p>
Выполнив такой запрос, мы получим в ответ что-то вроде вот этого:

</p><pre><code class="html">16515&lt;!&gt;wkview.js,wkview.css,page.js,page.css,page_help.css&lt;!&gt;0&lt;!&gt;6590&lt;!&gt;0&lt;!&gt;&lt;!bool&gt;&lt;!&gt;&lt;div id="wk_history_wrap"&gt;
  &lt;div class="wk_history_title tb_title" id="wk_history_title"&gt;Фотографии в переписке с ЮЗЕР_НЭЙМ&lt;/div&gt;
  &lt;div class="wk_history_tabs tb_tabs_wrap"&gt;
    &lt;div class="tb_tabs clear_fix" id="wk_history_tabs"&gt;&lt;div class="progress tb_prg fl_r" id="wk_history_tabs_prg"&gt;&lt;/div&gt;&lt;div class="fl_l summary_tab_sel"&gt;
  &lt;a class="summary_tab2"  onclick="showWiki({w: 'history&lt;dialog_id&gt;_photo'})" &gt;
    &lt;div class="summary_tab3"&gt;
      &lt;nobr&gt;Фотографии&lt;/nobr&gt;
    &lt;/div&gt;
  &lt;/a&gt;
&lt;/div&gt;&lt;div class="fl_l summary_tab"&gt;
  &lt;a class="summary_tab2"  onclick="showWiki({w: 'history&lt;dialog_id&gt;_video'})" &gt;
    &lt;div class="summary_tab3"&gt;
      &lt;nobr&gt;Видеозаписи&lt;/nobr&gt;
    &lt;/div&gt;
  &lt;/a&gt;
&lt;/div&gt;&lt;div class="fl_l summary_tab"&gt;
  &lt;a class="summary_tab2"  onclick="showWiki({w: 'history&lt;dialog_id&gt;_audio'})" &gt;
    &lt;div class="summary_tab3"&gt;
      &lt;nobr&gt;Аудиозаписи&lt;/nobr&gt;
    &lt;/div&gt;
  &lt;/a&gt;
&lt;/div&gt;&lt;div class="fl_l summary_tab"&gt;
  &lt;a class="summary_tab2"  onclick="showWiki({w: 'history&lt;dialog_id&gt;_doc'})" &gt;
    &lt;div class="summary_tab3"&gt;
      &lt;nobr&gt;Документы&lt;/nobr&gt;
    &lt;/div&gt;
  &lt;/a&gt;
&lt;/div&gt;&lt;/div&gt;
    &lt;div class="tb_tabs_sh" id="wk_history_tabs_sh"&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="wall_module wide_wall_module" id="wk_history_wall"&gt;
    &lt;div class="post_media" id="wk_history_rows"&gt;&lt;div class="page_post_sized_thumbs clear_fix" style="width: 597px; height: 1722px;"&gt;&lt;a  onclick="return showPhoto('...', 'mail...', {"temp":{"base":"/","x_":["",500,331]},queue: 1}, event);" style="width: 193px; height: 127px;" class="page_post_thumb_wrap  fl_l"&gt;&lt;img src="" width="193" height="128" style="margin-top: 0px;"  class="page_post_thumb_sized_photo" /&gt;&lt;/a&gt; ... (и еще много ссылок с картинками)&lt;/div&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div id="wk_history_empty" style=""&gt;Список пуст.&lt;/div&gt;
  &lt;div id="wk_history_more" class=""&gt;
    &lt;div id="wk_history_more_link" onclick="return WkView.historyShowMore();" style=""&gt;Показать еще&lt;/div&gt;
    &lt;div id="wk_history_more_progress" class="progress"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;&lt;!&gt;&lt;!json&gt;{"count":"23318","offset":3330,"type":"history","commonClass":"wk_history_content wk_history_photo_content","wkRaw":"history&lt;dialog_id&gt;_photo","canEdit":false,"lang":[]}&lt;!&gt;WkView.historyInit();&lt;!&gt;&lt;!pageview_candidate&gt;
</code></pre><p>
Здесь я заменил ссылки на &lt;некая ссылка&gt;, так как уже говорил, что картинки vk лежат в открытом доступе и получить их может любой, кто знает ссылку.
</p><p>
Из всего этого нам интересны только ссылки, которые находятся внутри &lt;img src=" "&gt;, а так же json на конце. Я был не до конца честен, говоря, что POST запрос принимает 4 параметра. Точнее, он принимает, но если его выполнить нам выдадутся только первые несколько фотографий. Так как vk.com имеет подгрузку контента по мере прокручивания страницы, то существует параметр offset, который отвечает за то, какую часть из всего множества фотографий нам подгрузить. В итоге параметры запроса выглядят вот так:

</p><ul>
<li>act:show</li>
<li>al:1</li>
<li>loc:im</li>
<li>w:history&lt;dialog_id&gt;_photo</li>
<li>offset: offset</li>
<li>part: 1</li>
</ul><p>
Из всех параметров меняться будет меняться только offset. Его мы вытаскивает из того самого json'a на конце ответа. Каждый раз при выполнении запроса offset внутри json'а будет увеличиваться, показывая, какое «смещение» надо сделать в следующий раз. Таким образом, нам надо будет делать запросы до тех пор, пока у нас offset будет меньше count.
</p><p>
Кстати, а что насчет выполнения запросов? Как нам получить доступ к своей странице? Было выяснено, что доступ к странице может получить тот, у кого есть cookie под названием remixsid. Таким образом нам надо подставить эту куку в функцию, которая выполняет запрос и все получится. Безопасно? Не совсем, швыряться куками — это не есть хорошо, но я не нашел другого варианта. Если кто-то знает, напишите пожалуйста.
</p><p>
Общий алгоритм вроде понятен: сделать запрос, вытащить ссылки, записать их в файл, проверить- </p><p>
новый offset&gt;count?-, если нет, то присвоить offset новое значение и выполнить запрос с ним, если да, то выйти из цикла. Затем пройтись по всем ссылкам в файле и скачать картинки лежащие по их адресу. Начинаем писать код.

</p><pre><code class="python"># coding=utf-8
import requests # для выполнения запросов 
import re # для парсинга по регулярным выражениям
import sys # для обработки аргументов командной строки
import os # для создания папок с фотографиями
import urllib # для скачивания картинок
import json # для обработки json

# argv[1] = remixsid_cookie
# argv[2] = dialog_id
# argv[3] = person_name
</code></pre><p>
Аргументы у нас будут передаваться через терминал (remixsid, dialog_id и название папки):

</p><pre><code class="python">remixsid_cookie = sys.argv[1]
# Словарь запроса
RequestData = {
    "act": "show",
    "al": 1,
    "loc":"im",
    "w": "history" + sys.argv[2] + "_photo",
    "offset" : 0,
    "part" : 1
}

request_href = "http://vk.com/wkview.php"
# Установим первоначальные offset и count. Count изменится при первом запросе
bound = {"count" : 10000, "offset" : 0}
</code></pre><p>
Создадим отдельную папку для фотографий:

</p><pre><code class="python">try:
    os.mkdir("drop_" + sys.argv[3]) # Пытаемся создать папку
except OSError:
    print "Проблемы с созданием папки 'drop_" + sys.argv[3] + "'"
if( os.path.exists("drop_" + sys.argv[3]) ):
    os.chdir("drop_" + sys.argv[3]) # Переходим в эту папку
else:
    print "Не удалось создать папку\n"
    exit()
</code></pre><p>
Отлично, начинаем выполнение запросов:

</p><pre><code class="python">test = open("links", "w") 
while( bound['offset'] &lt; bound['count'] ):

    RequestData['offset'] = bound['offset']

    content = requests.post(request_href, cookies={"remixsid": remixsid_cookie}, params=RequestData).text
    # Этой командой мы выполняем post запрос с параметрами params и передавая куки. .text возвращает ответ запроса в виде текста. Все просто.
</code></pre><p>
Теперь начинаем парсинг ответа. Извлекаем все через регулярные выражения. Сначала извлекаем json и устанавливаем следующий offset:

</p><pre><code class="python">    #ищем первое совпадение по регулярному выражению
    json_data_offset = re.compile('\{"count":.+?,"offset":.+?\}').search(content) 
    # .search возвращает специальный объект. У него есть метод span(), который возвращает кортеж с индексами начала и конца найденной подстроки
    bound = json.loads(content[json_data_offset.span()[0]:json_data_offset.span()[1]]) # декодируем json
    bound['count'] = int(bound['count']) #count отдается в виде строки
    bound['offset'] = int(bound['offset']) # на случай, если в будущем тоже будет отдаваться в виде строки. В принципе это написано ради "на всякий случай"
</code></pre><p>
Теперь надо извлечь все ссылки из тегов src. Действуем тем же способом, но используем метод findall, который возвращает массив всех строк, которые совпали с регуляркой:

</p><pre><code class="python">    links = re.compile('src="http://.+?"').findall(content)
</code></pre><p>
Теперь запишем все в файл:

</p><pre><code class="python">    for st in links:
        test.write(st[5:len(st)-1] + '\n') # пишем то, что внутри src="..."
test.close()
</code></pre><p>
С этим все. Осталось только пройтись по файлу и скачать все по ссылкам. Это делается с помощью модуля urllib, вот так:

</p><pre><code class="python">urllib.urlretrieve(ссылка, имя файла)
</code></pre><p>
А для нашего случая:

</p><pre><code class="python">test = open("links", "r")
file_num = 0
for href in test: # берем строку из файла которая является ссылкой, и так до конца файла
    urllib.urlretrieve(href, str(file_num)) # в качестве имени файла просто используем его порядковый номер
    file_num += 1
    print "Скачано " + str(file_num) + " файлов\n"
test.close()
</code></pre><p>
Готово! Но, так как использовать это мы будем из командной строки, давайте еще напишем небольшую документацию (--help), а так же вывод об ошибке, если аргументов командной строки меньше, чем нужно. Добавим в начало:

</p><pre><code class="python">if( sys.argv[1] == '--help' ):
    print """
    Usage: python main.py &lt;remixsid_cookie&gt; &lt;dialog_id&gt; &lt;name_of_folder&gt;
    &lt;dialog_id&gt; is a string parameter "sel" in address line which you see when open a dialog
    """
    exit()
else:
    if( len(sys.argv) &lt; 4 ):
        print """
        Invalid number of arguments. Use parameter --help to know more
        """
        exit()
</code></pre><p>
Вот и все, вроде. Конечно, можно еще многое добавить: проверку на выполнен запрос или нет, проверку на корректность входящих данных, автоматическое вытаскивание &lt;dialog_id&gt; (например, первых 10), но мне просто хотелось описать основные моменты. В итоге те самые 1000 фотографий, которые мне были нужны, были скачаны. Заняло это где-то 2 минуты. Никаких ограничений на запросы, как так понял, vk.com не ставит, хотя могу предположить, что на такой маленький для него трафик он даже не реагирует. 
</p><p>
Весь рабочий код целиком лежит на </p><a href="https://github.com/Shrikimaru/vk_dialog_photos_dump_script">Гитхабе</a><p>.
</p><p>
Всем спасибо.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>