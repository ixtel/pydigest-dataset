<html><body><div><div class="section" id="vmprof-documentation">
<h1>vmprof documentation<a class="headerlink" href="#vmprof-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/vmprof/vmprof-python">vmprof</a> is a lightweight profiler for <a class="reference external" href="http://python.org">CPython</a> 2.7, <a class="reference external" href="http://python.org">CPython</a> 3 and <a class="reference external" href="http://pypy.org">PyPy</a>.
It helps you to find and understand the performance bottlenecks in your code.</p>
<p>vmprof is a <a class="reference external" href="https://en.wikipedia.org/wiki/Profiling_(computer_programming)#Statistical_profilers">statistical profiler</a>: it gathers information about your code by
continuously taking samples of the call stack of the running program, at a
given frequency. This is similar to tools like <a class="reference external" href="https://software.intel.com/en-us/intel-vtune-amplifier-xe">vtune</a> or <a class="reference external" href="https://code.google.com/p/gperftools/">gperftools</a>: the
main difference is that those tools target C and C-like languages and are not
very helpful to profile higher-level languages which run on top of a virtual
machine, while vmprof is designed specifically for them. vmprof is also thread
safe and will correctly display the information regardless of usage of threads.</p>
<p>There are three primary modes. The recommended one is to use our server
infrastructure for a web-based visualization of the result:</p>
<div class="highlight-python"><div class="highlight"><pre>python -m vmprof --web &lt;program.py&gt; &lt;program parameters&gt;
</pre></div>
</div>
<p>If you prefer a barebone terminal-based visualization, which will display only
some basic statistics:</p>
<div class="highlight-python"><div class="highlight"><pre>python -m vmprof &lt;program.py&gt; &lt;program parameters&gt;
</pre></div>
</div>
<p>To display a terminal-based tree of calls:</p>
<div class="highlight-python"><div class="highlight"><pre>python -m vmprof -o output.log &lt;program.py&gt; &lt;program parameters&gt;

vmprofshow output.log
</pre></div>
</div>
<p>To upload an already saved profile log to the vmprof web server:</p>
<div class="highlight-python"><div class="highlight"><pre>python -m vmprof.upload output.log
</pre></div>
</div>
<p>For more advanced use cases, vmprof can be invoked and controlled from within
the program using the given API.</p>
<div class="section" id="requirements">
<h3>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h3>
<p>vmprof 0.2 works only on x86_64 and x86 linux, Mac OS X and x86 windows.
It works on CPython 2.7, 3.4 and 3.5.
PyPy support is already on a branch, but you will need to wait for PyPy
4.1 release to have it officially supported.</p>
</div>
<div class="section" id="installation">
<h3>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h3>
<p>Installation of <code class="docutils literal"><span class="pre">vmprof</span></code> is performed with a simple command:</p>

<p>Since it depends on some C code for CPython, you need a compiler.</p>
<blockquote>
<p>sudo apt-get install python-dev</p></blockquote>
</div>
<div class="section" id="usage">
<h3>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h3>
<p>Main usage of vmprof is via command line. The following shows the basic usage
to profile an example <code class="docutils literal"><span class="pre">x.py</span></code> program:</p>
<div class="highlight-python"><div class="highlight"><pre>fijal@hermann:~/src/vmprof-python$ cat x.py

def g(i, s):
    s += i
    return s

def h(i, s):
    return g(i, s) + 3

def f():
    i = 0
    s = 0
    while i &lt; 10000000:
        s = h(i, s)
        i += 1

if __name__ == '__main__':
    f()

fijal@hermann:~/src/vmprof-python$ python -m vmprof x.py
vmprof output:
% of snapshots:  name:
 100.0%          &lt;module&gt;    x.py:2
 100.0%          f    x.py:9
 55.0%           h    x.py:6
 14.4%           g    x.py:2
</pre></div>
</div>
<p>We stronly suggest using the <code class="docutils literal"><span class="pre">--web</span></code> option that will display you a much
nicer web interface hosted on <code class="docutils literal"><span class="pre">vmprof.com</span></code>.</p>
<p>If you prefer to host your own vmprof visualization server, you need the
<a class="reference external" href="https://github.com/vmprof/vmprof-server">vmprof-server</a> package.</p>
<p>After <code class="docutils literal"><span class="pre">-m</span> <span class="pre">vmprof</span></code> you can specify some options:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">--web</span></code> - Use the web-based visualization. By default, the result can be
viewed on our <a class="reference external" href="http://vmprof.com">server</a>.</li>
<li><code class="docutils literal"><span class="pre">--web-url</span></code> - the URL to upload the profiling info as JSON. The default is
<code class="docutils literal"><span class="pre">vmprof.com</span></code></li>
<li><code class="docutils literal"><span class="pre">--web-auth</span></code> - auth token for user name support in the server.</li>
<li><code class="docutils literal"><span class="pre">-p</span> <span class="pre">period</span></code> - float that gives you how often the profiling happens
(the max is about 300 Hz, rather don’t touch it).</li>
<li><code class="docutils literal"><span class="pre">-n</span></code> - enable all C frames, only useful if you have a debug build of
PyPy or CPython.</li>
<li><code class="docutils literal"><span class="pre">-o</span> <span class="pre">file</span></code> - save logs for later</li>
<li><code class="docutils literal"><span class="pre">--help</span></code> - display help</li>
<li><code class="docutils literal"><span class="pre">--config</span></code> - a ini format config file with all options presented above. When passing a config file along with command line arguments, the command line arguments will take precedence and override the config file values.</li>
</ul>
<p>Example <cite>config.ini</cite> file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">web</span><span class="o">-</span><span class="n">url</span> <span class="o">=</span> <span class="n">vmprof</span><span class="o">.</span><span class="n">com</span>
<span class="n">web</span><span class="o">-</span><span class="n">auth</span> <span class="o">=</span> <span class="n">ffb7d4bee2d6436bbe97e4d191bf7d23f85dfeb2</span>
<span class="n">period</span> <span class="o">=</span> <span class="mf">0.1</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<p>There is also an API that can bring more details to the table,
but consider it unstable. The current API usage is as follows:</p>
<div class="section" id="module-level-functions">
<h3>Module level functions<a class="headerlink" href="#module-level-functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">vmprof.enable(fileno,</span> <span class="pre">period=0.099,</span> <span class="pre">memory=False)</span></code> - enable writing <code class="docutils literal"><span class="pre">vmprof</span></code> data to a
file described by a fileno file descriptor. Timeout is in float seconds. The
minimal available resolution is 4ms, we’re working on improving that
(note the default is 9.9ms). Passing <code class="docutils literal"><span class="pre">memory=True</span></code> will provide additional
data in the form of total RSS of the process memory interspersed with
tracebacks.</li>
<li><code class="docutils literal"><span class="pre">vmprof.disable()</span></code> - finish writing vmprof data, disable the signal handler</li>
<li><code class="docutils literal"><span class="pre">vmprof.read_profile(filename)</span></code> - read vmprof data from
<code class="docutils literal"><span class="pre">filename</span></code> and return <code class="docutils literal"><span class="pre">Stats</span></code> instance.</li>
</ul>
</div>
<div class="section" id="stats-object">
<h3><code class="docutils literal"><span class="pre">Stats</span></code> object<a class="headerlink" href="#stats-object" title="Permalink to this headline">¶</a></h3>
<p>Stats object gives you an overview of data:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">stats.get_tree()</span></code> - Gives you a tree of objects</li>
</ul>
</div>
<div class="section" id="tree-object">
<h3><code class="docutils literal"><span class="pre">Tree</span></code> object<a class="headerlink" href="#tree-object" title="Permalink to this headline">¶</a></h3>
<p>Tree is made of Nodes, each node supports at least the following interface:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">node[key]</span></code> - a fuzzy search of keys (first match)</li>
<li><code class="docutils literal"><span class="pre">repr(node)</span></code> - basic details</li>
<li><code class="docutils literal"><span class="pre">node.flatten()</span></code> - returns a new tree that flattens all the metadata
(gc, blackhole etc.)</li>
<li><code class="docutils literal"><span class="pre">node.walk(callback)</span></code> - call a callable of form <code class="docutils literal"><span class="pre">callback(root)</span></code> that will
be invoked on each node</li>
</ul>
</div>
</div>
<div class="section" id="why-a-new-profiler">
<h2>Why a new profiler?<a class="headerlink" href="#why-a-new-profiler" title="Permalink to this headline">¶</a></h2>
<p>There is a variety of python profilers on the market: <a class="reference external" href="https://docs.python.org/2/library/profile.html">CProfile</a> is the one
bundled with CPython, which together with <a class="reference external" href="https://pypi.python.org/pypi/lsprofcalltree">lsprofcalltree.py</a> provides good
info and decent visualization; <a class="reference external" href="https://github.com/bdarnell/plop">plop</a> is an example of statistical profiler.</p>
<p>We wanted a profiler with the following characteristics:</p>
<ul class="simple">
<li>Minimal overhead, small enough that enabling the profiler in production is a
viable option. Ideally the overhead should be in the range 1-5%, with the
possibility to tune it for more accurate measurments</li>
<li>Ability to display a full stack of calls, so it can show how much time was
spent in a function, including all its children</li>
<li>Good integration with PyPy: in particular, it must be aware of the
underlying JIT, and be able to show how much time is spent inside JITted
code, Garbage collector and normal intepretation.</li>
</ul>
<p>None of the existing solutions satisfied our requirements, hence we decided to
create our own profiler. In particular, cProfile is slow on PyPy, does not
understand the JITted code very well and is shown in the JIT traces.</p>
</div>
<div class="section" id="how-does-it-work">
<h2>How does it work?<a class="headerlink" href="#how-does-it-work" title="Permalink to this headline">¶</a></h2>
<p>As most statistical profilers, the core idea is to have a signal handler which
periodically inspects and dumps the stack of the running program: the most
frequently executed parts of the code will be dumped more often, and the
post-processing and visualization tools have the chance to show the end user
usueful info about the behavior of the profiled program. This is the very same
approach used e.g. by <a class="reference external" href="https://code.google.com/p/gperftools/">gperftools</a>.</p>
<p>However, when profiling an interpreter such as CPython, inspecting the C stack
is not enough, because most of the time will always be spent inside the opcode
dispatching loop of the virtual machine (e.g., <code class="docutils literal"><span class="pre">PyEval_EvalFrameEx</span></code> in case
of CPython).  To be able to display useful information, we need to know which
Python-level function correspond to each C-level <code class="docutils literal"><span class="pre">PyEval_EvalFrameEx</span></code>.</p>
<p>This is done by reading the stack of Python frames instead of C stack.</p>
<p>Additionally, when on top of PyPy the C stack contains also stack frames which
belong to the JITted code: the vmprof signal handler is able to recognize and
extract the relevant info from those as well.</p>
<p>Once we have gathered all the low-level info, we can post-process and
visualize them in various ways: for example, we can decide to filter out the
places where we are inside the <code class="docutils literal"><span class="pre">select()</span></code> syscall, etc.</p>
<p>The machinery to gather the information has been the focus of the initial
phase of vmprof development and now it is working well: we are currently
focusing on the frontend to make sure we can process and display the info in
useful ways.</p>
</div>
</div>


           </div></body></html>