<html><body><div><div class="entry-content">
                    <p><em>The following is a sample from the new book <a href="/">Effective Python</a>.</em> <br/><br/></p>


<p>Threads give Python programmers a way to run multiple functions seemingly at the same time. But there are three big problems with threads:</p>
<ul>
<li>
<p>They require special tools to coordinate with each other safely. This makes code that uses threads harder to reason about than procedural, single-threaded code. This complexity makes threaded code more difficult to extend and maintain over time.</p>
</li>
<li>
<p>Threads require a lot of memory, about <span class="caps">8MB</span> per executing thread. On many computers, that amount of memory doesn’t matter for a dozen threads or so. But what if you want your program to run tens of thousands of functions “simultaneously”? These functions may correspond to user requests to a server, pixels on a screen, particles in a simulation, etc. Running a thread per unique activity just won’t work.</p>
</li>
<li>
<p>Threads are costly to start. If you want to constantly be creating new concurrent functions and finishing them, the overhead of using threads becomes large and slows everything down.</p>
</li>
</ul>
<p>Python can work around all these issues with <em>coroutines</em>. Coroutines let you have many seemingly simultaneous functions in your Python programs. They’re implemented as an extension to generators. The cost of starting a generator coroutine is a function call. Once active, they each use less than <span class="caps">1KB</span> of memory until they’re exhausted.</p>
<p>Coroutines work by enabling the code consuming a generator to <code>send</code> a value back into the generator function after each <code>yield</code> expression. The generator function receives the value passed to the <code>send</code> function as the result of the corresponding <code>yield</code> expression.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">my_coroutine</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">received</span> <span class="o">=</span> <span class="k">yield</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'Received:'</span><span class="p">,</span> <span class="n">received</span><span class="p">)</span>

<span class="n">it</span> <span class="o">=</span> <span class="n">my_coroutine</span><span class="p">()</span>
<span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>             <span class="c"># Prime the coroutine</span>
<span class="n">it</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">'First'</span><span class="p">)</span>
<span class="n">it</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">'Second'</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre>&gt;&gt;&gt;
Received: First
Received: Second
</pre></div>


<p>The initial call to <code>next</code> is required to prepare the generator for receiving the first <code>send</code> by advancing it to the first <code>yield</code> expression. Together, <code>yield</code> and <code>send</code> provide generators with a standard way to vary their next yielded value in response to external input.</p>
<p>For example, say you want to implement a generator coroutine that yields the minimum value it’s been sent so far. Here the bare <code>yield</code> prepares the coroutine with the initial minimum value sent in from the outside. Then the generator repeatedly yields the new minimum in exchange for the next value to consider.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">minimize</span><span class="p">():</span>
    <span class="n">current</span> <span class="o">=</span> <span class="k">yield</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">current</span>
        <span class="n">current</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
</pre></div>


<p>The code consuming the generator can run one step at a time and will output the minimum value seen after each input.</p>
<div class="highlight"><pre><span class="n">it</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">()</span>
<span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>            <span class="c"># Prime the generator</span>
<span class="k">print</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">22</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>





<p>The generator function will seemingly run forever, making forward progress with each new call to <code>send</code>. Like threads, coroutines are independent functions that can consume inputs from their environment and produce resulting outputs. The difference is that coroutines pause at each <code>yield</code> expression in the generator function and resume after each call to <code>send</code> from the outside. This is the magical mechanism of coroutines.</p>
<p>This behavior allows the code consuming the generator to take action after each <code>yield</code> expression in the coroutine. The consuming code can use the generator’s output values to call other functions and update data structures. Most importantly, it can advance other generator functions until their next <code>yield</code> expressions. By advancing many separate generators in lockstep, they will all seem to be running simultaneously, mimicking the concurrent behavior of Python threads.</p>
<h3>The Game of Life</h3>
<p>Let me demonstrate the simultaneous behavior of coroutines with an example. Say you want to use coroutines to implement <a href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life">Conway’s Game of Life</a>. The rules of the game are simple. You have a two-dimensional grid of an arbitrary size. Each cell in the grid can either be alive or empty.</p>



<p>The game progresses one tick of the clock at a time. At each tick, each cell counts how many of its neighboring eight cells are still alive. Based on its neighbor count, each cell decides if it will keep living, die, or regenerate. Here’s an example of a 5x5 Game of Life grid after four generations with time going to the right. I’ll explain the specific rules further below.</p>
<div class="highlight"><pre>  0   |   1   |   2   |   3   |   4  
----- | ----- | ----- | ----- | -----
-*--- | --*-- | --**- | --*-- | -----
--**- | --**- | -*--- | -*--- | -**--
---*- | --**- | --**- | --*-- | -----
----- | ----- | ----- | ----- | -----
</pre></div>


<p>I can model this game by representing each cell as a generator coroutine running in lockstep with all the others.</p>
<p>To implement this, first I need a way to retrieve the status of neighboring cells. I can do this with a coroutine named <code>count_neighbors</code> that works by yielding <code>Query</code> objects. The <code>Query</code> class I define myself. Its purpose is to provide the generator coroutine with a way to ask its surrounding environment for information.</p>
<div class="highlight"><pre><span class="n">Query</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Query'</span><span class="p">,</span> <span class="p">(</span><span class="s">'y'</span><span class="p">,</span> <span class="s">'x'</span><span class="p">))</span>
</pre></div>


<p>The coroutine yields a <code>Query</code> for each neighbor. The result of each <code>yield</code> expression will be the value <code>ALIVE</code> or <code>EMPTY</code>. That’s the interface contract I’ve defined between the coroutine and its consuming code. The <code>count_neighbors</code> generator sees the neighbors’ states and returns the count of living neighbors.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">count_neighbors</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">n_</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">Query</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>  <span class="c"># North</span>
    <span class="n">ne</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">Query</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># Northeast</span>
    <span class="c"># Define e_, se, s_, sw, w_, nw ...</span>
    <span class="c"># ...</span>
    <span class="n">neighbor_states</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_</span><span class="p">,</span> <span class="n">ne</span><span class="p">,</span> <span class="n">e_</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">s_</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">w_</span><span class="p">,</span> <span class="n">nw</span><span class="p">]</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">neighbor_states</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">ALIVE</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">count</span>
</pre></div>


<p>I can drive the <code>count_neighbors</code> coroutine with fake data to test it. Here I show how <code>Query</code> objects will be yielded for each neighbor. <code>count_neighbors</code> expects to receive cell states corresponding to each <code>Query</code> through the coroutine’s <code>send</code> method. The final count is returned in the <code>StopIteration</code> exception that is raised when the generator is exhausted by the <code>return</code> statement.</p>
<div class="highlight"><pre><span class="n">it</span> <span class="o">=</span> <span class="n">count_neighbors</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">q1</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>                  <span class="c"># Get the first query</span>
<span class="k">print</span><span class="p">(</span><span class="s">'First yield: '</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
<span class="n">q2</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">ALIVE</span><span class="p">)</span>            <span class="c"># Send q1 state, get q2</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Second yield:'</span><span class="p">,</span> <span class="n">q2</span><span class="p">)</span>
<span class="n">q3</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">ALIVE</span><span class="p">)</span>            <span class="c"># Send q2 state, get q3</span>
<span class="c"># ...</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">EMPTY</span><span class="p">)</span>     <span class="c"># Send q8 state, retrieve count</span>
<span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Count: '</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>  <span class="c"># Value from return statement</span>
</pre></div>


<div class="highlight"><pre>&gt;&gt;&gt;
First yield:  Query(y=11, x=5)
Second yield: Query(y=11, x=6)
...
Count:  2
</pre></div>


<p>Now I need the ability to indicate that a cell will transition to a new state in response to the neighbor count that it found from <code>count_neighbors</code>. To do this, I define another coroutine called <code>step_cell</code>. This generator will indicate transitions in a cell’s state by yielding <code>Transition</code> objects. This is another class that I define, just like the <code>Query</code> class.</p>
<div class="highlight"><pre><span class="n">Transition</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Transition'</span><span class="p">,</span> <span class="p">(</span><span class="s">'y'</span><span class="p">,</span> <span class="s">'x'</span><span class="p">,</span> <span class="s">'state'</span><span class="p">))</span>
</pre></div>


<p>The <code>step_cell</code> coroutine receives its coordinates in the grid as arguments. It yields a <code>Query</code> to get the initial state of those coordinates. It runs <code>count_neighbors</code> to inspect the cells around it. It runs the game logic to determine what state the cell should have for the next clock tick. Finally, it yields a <code>Transition</code> object to tell the environment the cell’s next state.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">game_logic</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">):</span>
    <span class="c"># ...</span>

<span class="k">def</span> <span class="nf">step_cell</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">state</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">Query</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">count_neighbors</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">next_state</span> <span class="o">=</span> <span class="n">game_logic</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">Transition</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">next_state</span><span class="p">)</span>
</pre></div>


<p>Importantly, the call to <code>count_neighbors</code> uses the <code>yield from</code> expression. This expression allows Python to compose generator coroutines together, making it easy to reuse smaller pieces of functionality and build complex coroutines from simpler ones. When <code>count_neighbors</code> is exhausted, the final value it returns (with the <code>return</code> statement) will be passed to <code>step_cell</code> as the result of the <code>yield from</code> expression.</p>
<p>Now I can finally define the simple game logic for Conway’s Game of Life. There are only three rules.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">game_logic</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">ALIVE</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">neighbors</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">EMPTY</span>     <span class="c"># Die: Too few</span>
        <span class="k">elif</span> <span class="n">neighbors</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">EMPTY</span>     <span class="c"># Die: Too many</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">neighbors</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ALIVE</span>     <span class="c"># Regenerate</span>
    <span class="k">return</span> <span class="n">state</span>
</pre></div>


<p>I can drive the <code>step_cell</code> with fake data to test it.</p>
<div class="highlight"><pre><span class="n">it</span> <span class="o">=</span> <span class="n">step_cell</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">q0</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>           <span class="c"># Initial location query</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Me:      '</span><span class="p">,</span> <span class="n">q0</span><span class="p">)</span>
<span class="n">q1</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">ALIVE</span><span class="p">)</span>     <span class="c"># Send my status, get neighbor query</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Q1:      '</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
<span class="c"># ...</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">EMPTY</span><span class="p">)</span>     <span class="c"># Send for q8, get game decision</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Outcome: '</span><span class="p">,</span> <span class="n">t1</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre>&gt;&gt;&gt;
Me:       Query(y=10, x=5)
Q1:       Query(y=11, x=5)
...
Outcome:  Transition(y=10, x=5, state='-')
</pre></div>


<p>The goal of the game is to run this logic for a whole grid of cells in lockstep. To do this, I can further compose the <code>step_cell</code> coroutine into a <code>simulate</code> coroutine. This coroutine progresses the grid of cells forward by yielding from <code>step_cell</code> many times. After progressing every coordinate, it yields a <code>TICK</code> object to indicate that the current generation of cells have all transitioned.</p>
<div class="highlight"><pre><span class="n">TICK</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
                <span class="k">yield from</span> <span class="n">step_cell</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">TICK</span>
</pre></div>


<p>What’s impressive about <code>simulate</code> is that it’s completely disconnected from the surrounding environment. I still haven’t defined how the grid is represented in Python objects, how <code>Query</code>, <code>Transition</code>, and <code>TICK</code> values are handled on the outside, nor how the game gets its initial state. But the logic is clear. Each cell will transition by running <code>step_cell</code>. Then the game clock will tick. This will continue forever, as long as the <code>simulate</code> coroutine is advanced.</p>
<p>This is the beauty of coroutines. They help you focus on the logic of what you’re trying to accomplish. They decouple your code’s instructions for the environment from the implementation that carries out your wishes. This enables you to run coroutines seemingly in parallel. This also allows you to improve the implementation of following those instructions over time without changing the coroutines.</p>
<p>Now I want to run <code>simulate</code> in a real environment. To do that, I need to represent the state of each cell in the grid. Here I define a class to contain the grid.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Grid</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">EMPTY</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># ...</span>
</pre></div>


<p>The grid allows you to get and set the value of any coordinate. Coordinates that are out of bounds will wrap around, making the the grid act like infinite looping space.</p>
<div class="highlight"><pre>    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">[</span><span class="n">y</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">][</span><span class="n">x</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">[</span><span class="n">y</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">][</span><span class="n">x</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span>
</pre></div>


<p>At last, I can define the function that interprets the values yielded from <code>simulate</code> and all of its interior coroutines. This function turns the instructions from the coroutines into interactions with the surrounding environment. It progresses the whole grid of cells forward a single step and then returns a new grid containing the next state.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">live_a_generation</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
    <span class="n">progeny</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
    <span class="n">item</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">TICK</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Query</span><span class="p">):</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># Must be a Transition</span>
            <span class="n">progeny</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
            <span class="n">item</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">progeny</span>
</pre></div>


<p>To see this function in action, I need to create a grid and set its initial state. Here I make a classic shape called a glider.</p>
<div class="highlight"><pre><span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">grid</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ALIVE</span><span class="p">)</span>
<span class="c"># ...</span>
<span class="k">print</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre>&gt;&gt;&gt;
---*-----
----*----
--***----
---------
---------
</pre></div>


<p>Now I can progress this grid forward one generation at a time. You can see how the glider moves down and to the right on the grid based on the simple rules from the <code>game_logic</code> function.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">ColumnPrinter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c"># ...</span>

<span class="n">columns</span> <span class="o">=</span> <span class="n">ColumnPrinter</span><span class="p">()</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">grid</span><span class="p">))</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">live_a_generation</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">sim</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre>&gt;&gt;&gt;
    0     |     1     |     2     |     3     |     4    
---*----- | --------- | --------- | --------- | ---------
----*---- | --*-*---- | ----*---- | ---*----- | ----*----
--***---- | ---**---- | --*-*---- | ----**--- | -----*---
--------- | ---*----- | ---**---- | ---**---- | ---***---
--------- | --------- | --------- | --------- | ---------
</pre></div>


<p>The best part about this approach is that I can change the <code>game_logic</code> function without having to update the code that surrounds it. I can change the rules or add larger spheres of influence with the existing mechanics of <code>Query</code>, <code>Transition</code>, and <code>TICK</code>. This demonstrates how coroutines enable the separation of concerns, which is an important design principle.</p>
<h3>Coroutines in Python 2</h3>
<p>Unfortunately, Python 2 is missing some of the syntactical sugar that makes coroutines so elegant in Python 3. There are two limitations. First, there is no <code>yield from</code> expression. That means when you want to compose generator coroutines in Python 2, you need to include an additional loop at the delegation point.</p>
<div class="highlight"><pre><span class="c"># Python 2</span>
<span class="k">def</span> <span class="nf">delegated</span><span class="p">():</span>
    <span class="k">yield</span> <span class="mi">1</span>
    <span class="k">yield</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">composed</span><span class="p">():</span>
    <span class="k">yield</span> <span class="s">'A'</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">delegated</span><span class="p">():</span>  <span class="c"># yield from in Python 3</span>
        <span class="k">yield</span> <span class="n">value</span>
    <span class="k">yield</span> <span class="s">'B'</span>

<span class="k">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">composed</span><span class="p">())</span>
</pre></div>





<p>The second limitation is that there is no support for the <code>return</code> statement in Python 2 generators. To get the same behavior that interacts correctly with <code>try</code>/<code>except</code>/<code>finally</code> blocks, you need to define your own exception type and raise it when you want to return a value.</p>
<div class="highlight"><pre><span class="c"># Python 2</span>
<span class="k">class</span> <span class="nc">MyReturn</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

<span class="k">def</span> <span class="nf">delegated</span><span class="p">():</span>
    <span class="k">yield</span> <span class="mi">1</span>
    <span class="k">raise</span> <span class="n">MyReturn</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c"># return 2 in Python 3</span>
    <span class="k">yield</span> <span class="s">'Not reached'</span>

<span class="k">def</span> <span class="nf">composed</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">delegated</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">value</span>
    <span class="k">except</span> <span class="n">MyReturn</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">value</span>
    <span class="k">yield</span> <span class="n">output</span> <span class="o">*</span> <span class="mi">4</span>

<span class="k">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">composed</span><span class="p">())</span>
</pre></div>





<h3>Things to Remember</h3>
<ul>
<li>Coroutines provide an efficient way to run tens of thousands of functions seemingly at the same time.</li>
<li>Within a generator, the value of the <code>yield</code> expression will be whatever value was passed to the generator’s <code>send</code> method from the exterior code.</li>
<li>Coroutines give you a powerful tool for separating the core logic of your program from its interaction with the surrounding environment.</li>
<li>Python 2 doesn’t support <code>yield from</code> or <code>return</code> within generators.</li>
</ul>
                </div>
            </div></body></html>