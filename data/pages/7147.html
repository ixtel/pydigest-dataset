<html><body><div><div class="content html_format"><p>
      В </p><a href="http://habrahabr.ru/post/268993/">предыдущей статье</a><p> я рассказал как создать сервер и клиент на Python 3, используя встроенные сокеты. Но у этого приложения было много недостатков, которые я попытаюсь исправить в этой и последующих статьях.
</p><p>
Так какими же недостатками обладает наше приложение?
</p><ul>
<li>Отсылается один единственный пакет, длина которого не может превышать заранее заданной границы в 1 Кбайт.</li>
<li>Приложение без проверки передаёт аргумент, принятый из сети, в оболочку (URL).</li>
<li>Недостаток функциональности. Мы не можем, например, скачать все изображения с Хабра, или скачать отдельный хаб.</li>
</ul><p>
Сегодня я расскажу как решить первую проблему, а заодно и немного о TCP.

</p><h5>Описание протокола</h5><p>
Мы использовали «голый» протокол TCP для передачи данных между сервером и клиентом. TCP — это потоковый протокол, он передаёт данные последовательным набором байт. Передавая команду с аргументами по сети в первой версии нашего приложения мы читали только 1024 байт данных из принятого пакета. Но что делать, если данные не помещаются в 1024 байт? Выход только один — разбить данные на несколько пакетов на одном хосте и «склеить» их в один кусок при получении на другом хосте. Но как узнать когда заканчивается одна команда (с её аргументами) и начинается другая? Для этого нам нужно нужно знать, какова длина всего передаваемого сообщения.
</p><p>
Так как заранее узнать длину сообщения у нас не получиться, придётся передавать её в одном из пакетов. Разумеется, делать это лучше в самом начале первого пакета. Выделив под хранение длины сообщения всего 4 байта, мы сможем передать сообщение длиной свыше 4 млрд символов! Длина сообщения — это информация о нём, то есть, часть заголовка, заголовка нашего протокола. Какого протокола спросите вы? Если верить Википедии, то
</p><blockquote>Протокол передачи данных — набор соглашений интерфейса логического уровня, которые определяют обмен данными между различными программами.</blockquote><p>
Мы договорились, что будем передавать данные в нескольких пакетах по TCP, а в начале данных первого пакета будет храниться длина всего сообщения в байтах. Таким образом мы разработали наш простой протокол! Нужно помнить, что наш протокол основан на TCP, а значит, обладает теми же особенностями, что и последний.
</p><a name="habracut"/>
<h5>Разработка протокола</h5><p>
Мы описали наш протокол, настало время его разработать!
</p><p>
Метод </p><b>sendall</b><p> сокета в Питоне самостоятельно разбивает данные на пакеты и отправляет их на сервер. Здесь можно не париться. Для передачи длины переведём её в </p><b>C struct</b><p> типа </p><b>unsigned int</b><p> (4 байта) используя встроенную библиотеку </p><b>struct</b><p>.
</p><pre><code class="python">import struct

# Функция отправки данных
def send(connection, data):
    # Трансформируем строку в массив байт
    data = bytes(data, "utf8")
    # Отправляем C struct типа unsigned int размером 4 байта, хранящие длину сообщения. Данные содержат 4 байта, хранящие длину сообщения, плюс само сообщение.
    connection.sendall(struct.pack('&gt;I', len(data)) + data)
</code></pre><p>
Параметр </p><i>'&gt;I'</i><p>, переданный функции </p><b>struct.pack</b><p> просит перевести второй параметр в тип </p><b>unsigned int</b><p> (</p><i>I</i><p>) в обратном порядке байт (</p><i>&gt;</i><p>). Рассмотрим это чуть позже.

</p><pre><code class="python"># Вспомогательная функция
def recv_packets(connection, n):
    piece = b''
    # Пока не получим кусок данных необходимой длины &lt;b&gt;n&lt;/b&gt;
    while len(piece) &lt; n:
        # Читаем участок длиной не более, чем нам недостаёт до длины &lt;b&gt;n&lt;/b&gt;
        packet = connection.recv(n - len(piece))
        # Если пакет получить не удалось, то ничего не возвращаем
        if not packet:
            return None
        piece += packet
    return piece

# Функция чтения принятых данных
def recv(connection):
    # Читаем участок, содержащий длину пакета
    length_data = recv_packets(connection, 4)
    # Если получить не удалось, то ничего не возвращаем
    if not length_data:
        return None
    # Переводим в питоновский тип
    data_len = struct.unpack('&gt;I', length_data)[0]
    # Декодируем, используя кодировку UTF-8. Можно использовать аргументы "utf8", "utf-8", "UTF8", "UTF-8", это одно и то же.
    return recv_packets(connection, data_len).decode("utf8")
</code></pre><p>
В функции </p><b>recv_packets</b><p> мы читаем уже полученные данные до тех пор, пока не получим часть сообщения необходимой нам длины. Если метод </p><b>recv</b><p> сокета ничего не вернёт, значит мы не смогли получить сообщение полностью. В этом случае тоже нечего не возвращаем, а тогда ничего не вернёт и функция </p><b>recv</b><p> нашего протокола.

</p><h5>Использование протокола</h5><p>
Теперь мы можем воспользоваться нашим протоколом, написанным поверх другого протокола — TCP. Заодно, я буду рассказывать о том, что происходит в этот момент под капотом.
</p><p>
Для начала зайдите в каталог с только что созданным файлом </p><b>protocol.py</b><p> и запустите интерпретатор Python 3 (обычно это команда </p><b>python3</b><p>) в двух терминалах, интерпретаторах командных строк, или среде разработки. В обоих поочерёдно введите следующие команды.
</p><pre><code class="python">&gt;&gt;&gt; import socket, protocol
&gt;&gt;&gt; sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
</code></pre><p>
Первая строка импортирует библиотеку сокетов и наш мини-протокол, вторая — создаёт сокет с протоколом TCP/IPv4. AF_INET — пара (домен/IPv4, порт), SOCK_STREAM — потоковый тип подключения, на котором основан TCP протокол.
</p><p>
Следующие две строки вводятся в первый терминал.
</p><pre><code class="python">&gt;&gt;&gt; sock.bind(("localhost", 65043))
&gt;&gt;&gt; sock.listen(True)
</code></pre><p>
В этот момент операционная система система занимает для нашего приложения адрес </p><i>localhost:65043</i><p> и наше приложение начинает его слушать. Если вы ещё не поняли, сокет — это программный интерфейс, который создаётся операционной системой.
</p><p>
Присоединяемся к серверу через второй терминал.
</p><pre><code class="python">&gt;&gt;&gt; sock.connect(("localhost", 65043))
</code></pre><p>
В этот момент происходит следующее. Клиент отправляем небольшой пакет. Первый пакет у меня имеет длину 74 байта. </p><i>(длина не всегда такая, я привожу её, чтобы было примерно понятно, что же отправляется в момент установления соединения.)</i><p> Их можно разложить так: 8 байт — два Ethernet адреса, 20 байт — IP-заголовок, и 46 байт — TCP-заголовок. В пакете есть два бита из TCP-заголовка — </p><b>syn</b><p> и </p><b>ack</b><p>. В первом пакете </p><i>syn = 1, ack = 0</i><p>. После этого сервер отправляет нам пакет такой же длины (74 байта), подтверждая получение и разрешая подключиться, при этом </p><i>syn = 1, ack = 1</i><p>. Затем клиент отправляет уже третий пакет, но длиной не 74, а 66 байт. В третьем пакете </p><i>syn = 0, ack = 1</i><p>. Этот пакет окончательно устанавливает соединение и теперь мы можем принимать и получать пакеты. Так выглядит благополучное соединение. Если вам хочется более подробно изучить TCP и другие возможные случаи, можете прочитать об этом, например, в книге Танентбаума «Компьютерные сети».

</p><pre><code class="python">&gt;&gt;&gt; conn, addr = sock.accept()
</code></pre><p>
Читаем информацию о клиенте. В этот момент никаких пакетов не передаётся, мы просто берём уже записанные данные.
</p><p>
Во втором терминале вводим
</p><pre><code class="python">&gt;&gt;&gt; protocol.send(sock, "Hello, localhost!")
</code></pre><p>
Этой строчкой мы отправляем сообщение серверу, используя наш мини-протокол.</p><p>
В этот момент мы отправляем серверу пакет со следующим содержанием (исключая заголовки):
</p><code>00:00:00:11:48:65:6c:6c:6f:2c:20:6c:6f:63:61:6c:68:6f:73:74:21<br/>
</code>
<i>00:00:00:11</i><p> — </p><b>0x11</b><p>, или </p><b>17</b><p> в десятичной системе счисления, — длина переданного сообщения (не данных, а именно сообщения, так как данные, в данном случае, — это 4 байта длины + сообщение).
</p><i>48:65:6c:6c:6f:2c:20:6c:6f:63:61:6c:68:6f:73:74:21</i><p> — переданная строка </p><b>Hello, localhost!</b><p>
Сервер отвечает нам другим пакетом, подтверждая получение.
</p><p>
И наконец читаем и декодируем сообщение в первом терминале, клиенте:
</p><pre><code class="python">&gt;&gt;&gt; protocol.recv(conn)
</code></pre><p>
Можно разорвать соединение, введя во втором терминале
</p><pre><code class="python">&gt;&gt;&gt; sock.close()
</code></pre><p>
Клиент посылает серверу пакет с установленным битом </p><b>fin</b><p>, говоря о том, что у него больше нет данных для передачи и он хочет разорвать соединение. В ответ сервер так же отправляет пакет с битом </p><i>fin = 1</i><p>.</p><p>
Эта же команда в первом терминале остановит работу сервера и он перестанет слушать.

</p><h5>Заключение</h5><p>
После всего проделанного мы можем легко передавать сообщения между клиентским и серверным приложениями. Изменения не сильно отличаются, так что я не стал приводить листинги кода в статье, а выложил проект на </p><a href="https://github.com/SemperPeritus/httrack-deamon">GitHub</a><p>. В следующей статье я расскажу про безопасность. Если вам интересно что-то ещё, о чём вы хотели бы услышать в следующих статьях, то пишите об этом в комментариях.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>