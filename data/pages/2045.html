<html><body><div><header class="entry-header">
<h1 class="entry-title">Recover a gzipped HTML response from the browser cache</h1>
<p class="bylinemod"><time class="entry-date updated" datetime="2015-01-18T15:00:37+00:00" pubdate="">September 16, 2013</time> — by Jan-Philip Gehrcke</p> </header> 
<div class="entry-content">
<p>Recently, an incident with the server running this website resulted in a total data loss. I had set up a daily remote backup of my WordPress database (to Dropbox, i.e. Amazon S3) and was able to restore a ~24 hour old state of my blog. Unfortunately, one article that I wrote and published only a few hours before the incident was not contained in the last database backup and therefore lost for the moment.</p>
<p>I knew that I had checked the article’s final version from the random visitor’s perspective using Chrome right after publishing it. So the browser cache was the only hope for me to restore the article, at least in HTML form. Consequently, I immediately archived my Chrome cache for further investigation. Thankfully, with a tiny forensics exercise, I was able to retrieve the final contents of the article from a gzipped and cached HTML response. I used Python for extracting the HTML content in clear text and figured that the applied procedure is worth a small blog post on its own. In particular, I think that this is a nice example of why Python has earned the “batteries included” attribute.</p>
<p>I am going to lead you through this by means of an example — a 403 error page in this case, as retrieved by accessing <a href="http://gehrcke.de/files/perm/">http://gehrcke.de/files/perm/</a>. It has the following HTML source:</p>
<div class="wp-geshi-highlight-wrap5"><div class="wp-geshi-highlight-wrap4"><div class="wp-geshi-highlight-wrap3"><div class="wp-geshi-highlight-wrap2"><div class="wp-geshi-highlight-wrap"><div class="wp-geshi-highlight"><div class="html"><pre class="de1">&lt;html&gt;
&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;
&lt;body bgcolor="white"&gt;
&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;
&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;
&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;
&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;
&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;
&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;
&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;</pre></div></div></div></div></div></div></div>
<p>In the moment you have accessed the above-given URL, it is usually already cached by your browser. Let’s assume that this response contains valuable data and our goal is to restore it from the cache.</p>
<p>Chrome’s browser cache is stored in larger binary files, it cannot be conveniently searched or queried by using file system tools or <code>less</code> / <code>grep</code> only. Chrome brings along a rudimentary tool for searching the cache: <a href="chrome://cache/">chrome://cache/</a>. Search that list for “http://gehrcke.de/files/perm” (Strg + F) and you will find a corresponding entry. When clicking it, the details of this cache entry are displayed on a simplistic web page:</p>
<div class="wp-geshi-highlight-wrap5"><div class="wp-geshi-highlight-wrap4"><div class="wp-geshi-highlight-wrap3"><div class="wp-geshi-highlight-wrap2"><div class="wp-geshi-highlight-wrap"><div class="wp-geshi-highlight"><div class="text"><pre class="de1">http://gehrcke.de/files/perm/
HTTP/1.1 403 Forbidden
Date: Mon, 16 Sep 2013 14:03:22 GMT
Content-Type: text/html
Content-Encoding: gzip
 
 
00000000:  9a  00  00  00  03  00  00  00  e3  cf  68  f3  16  45  2e  00  ..........h..E..
00000010:  51  3d  69  f3  16  45  2e  00  6b  00  00  00  48  54  54  50  Q=i..E..k...HTTP
00000020:  2f  31  2e  31  20  34  30  33  20  46  6f  72  62  69  64  64  /1.1 403 Forbidd
00000030:  65  6e  00  44  61  74  65  3a  20  4d  6f  6e  2c  20  31  36  en.Date: Mon, 16
00000040:  20  53  65  70  20  32  30  31  33  20  31  34  3a  30  33  3a   Sep 2013 14:03:
00000050:  32  32  20  47  4d  54  00  43  6f  6e  74  65  6e  74  2d  54  22 GMT.Content-T
00000060:  79  70  65  3a  20  74  65  78  74  2f  68  74  6d  6c  00  43  ype: text/html.C
00000070:  6f  6e  74  65  6e  74  2d  45  6e  63  6f  64  69  6e  67  3a  ontent-Encoding:
00000080:  20  67  7a  69  70  00  00  00  0d  00  00  00  33  37  2e  32   gzip.......37.2
00000090:  32  31  2e  31  39  34  2e  37  32  00  00  00  50  00          21.194.72...P.
 
 
00000000:  1f  8b  08  00  00  00  00  00  00  03  ed  8e  b1  0e  c2  30  ...............0
00000010:  0c  44  77  24  fe  c1  74  8f  02  82  31  64  41  20  31  30  .Dw$..t...1dA 10
00000020:  f1  05  49  6d  92  48  69  82  4c  24  e8  df  93  96  22  21  ..Im.Hi.L$...."!
00000030:  66  46  36  fb  ee  fc  ce  ca  97  2e  ea  f9  4c  79  32  a8  fF6.........Ly2.
00000040:  55  09  25  92  de  2c  d7  70  c8  6c  03  22  25  25  5f  a2  U.%..,.p.l."%%_.
00000050:  92  63  a4  46  6d  c6  1e  ac  6b  73  cc  bc  6d  ee  3e  14  .c.Fm...ks..m.&gt;.
00000060:  6a  06  bd  a5  54  88  b5  f2  ab  6f  42  55  94  9c  ec  a1  j...T....oBU....
00000070:  ab  86  a6  2d  b9  90  1e  9f  9e  1c  e8  e3  f0  fe  6c  21  ...-..........l!
00000080:  04  18  b8  1a  c4  90  1c  94  0c  18  6e  c6  46  82  d3  f9  ..........n.F...
00000090:  b8  07  93  10  76  9e  73  47  70  e1  40  09  63  0f  c4  9c  ....v.sGp.@.c...
000000a0:  b9  5e  38  02  21  fe  88  5f  23  9e  f1  7a  0e  0d  34  02  .^8.!.._#..z..4.
000000b0:  00  00                                                          ..</pre></div></div></div></div></div></div></div>
<p>When looking at the HTML source of this page, three <code>pre</code> blocks stand out:</p>
<ul>
<li>The first pre block contains a formatted version of the HTTP response header.</li>
<li>The second pre block contains a hexdump of the response header.</li>
<li>The third pre block contains a hexdump of the response body.</li>
</ul>
<p>The hexdumps are formatted in a way similar to how <code>hexdump -C</code> would print stuff to stdout: the first column shows an address offset, the second column shows space-separated hex representations of single bytes, the third column shows an ASCII interpretation of single bytes.</p>
<p>From <code>Content-Encoding: gzip</code> we see that this response was delivered in gzipped form by the webserver. Hence, the ASCII representation in the third column of the hexdumps is not human-readable. The programming goal now is to restore the original HTML document from this cache entry web page as displayed by Google Chrome (unfortunately, this obvious feature is not built into the browser itself). As a first step, save the cache entry web page to a file (right click, “Save As” …). I called it <code>cache.html</code>.</p>
<p>I wrote a Python script, <code>recover.py</code>. It reads <code>cache.html</code>, restores the original HTML document, and prints it to stdout:</p>
<div class="wp-geshi-highlight-wrap5"><div class="wp-geshi-highlight-wrap4"><div class="wp-geshi-highlight-wrap3"><div class="wp-geshi-highlight-wrap2"><div class="wp-geshi-highlight-wrap"><div class="wp-geshi-highlight"><div class="text"><pre class="de1">$ python recover.py 
&lt;html&gt;
&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;
&lt;body bgcolor="white"&gt;
&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;
&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;
&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;
&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;
&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;
&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;
&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;</pre></div></div></div></div></div></div></div>
<p>The source of <code>recover.py</code> is:</p>
<div class="wp-geshi-highlight-wrap5"><div class="wp-geshi-highlight-wrap4"><div class="wp-geshi-highlight-wrap3"><div class="wp-geshi-highlight-wrap2"><div class="wp-geshi-highlight-wrap"><div class="wp-geshi-highlight"><div class="python"><ol><li class="li1"><pre class="de1"><span class="kw1">import</span> <span class="kw3">re</span></pre></li><li class="li1"><pre class="de1"><span class="kw1">from</span> <span class="kw3">binascii</span> <span class="kw1">import</span> unhexlify</pre></li><li class="li1"><pre class="de1"><span class="kw1">from</span> <span class="kw3">gzip</span> <span class="kw1">import</span> GzipFile</pre></li><li class="li1"><pre class="de1"><span class="kw1">from</span> <span class="kw3">itertools</span> <span class="kw1">import</span> chain</pre></li><li class="li1"><pre class="de1"><span class="kw1">from</span> <span class="kw3">StringIO</span> <span class="kw1">import</span> <span class="kw3">StringIO</span></pre></li><li class="li1"><pre class="de1"> </pre></li><li class="li1"><pre class="de1"><span class="kw1">with</span> <span class="kw2">open</span><span class="br0">(</span><span class="st0">"cache.html"</span><span class="sy0">,</span> <span class="st0">"rb"</span><span class="br0">)</span> <span class="kw1">as</span> f:</pre></li><li class="li1"><pre class="de1">    html <span class="sy0">=</span> f.<span class="me1">read</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">decode</span><span class="br0">(</span><span class="st0">"utf-8"</span><span class="br0">)</span></pre></li><li class="li1"><pre class="de1"> </pre></li><li class="li1"><pre class="de1">hexlines <span class="sy0">=</span> <span class="kw3">re</span>.<span class="me1">findall</span><span class="br0">(</span><span class="st0">"&lt;pre&gt;(.*?)&lt;/pre&gt;"</span><span class="sy0">,</span> html<span class="sy0">,</span> flags<span class="sy0">=</span><span class="kw3">re</span>.<span class="me1">S</span><span class="br0">)</span><span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span>.<span class="me1">splitlines</span><span class="br0">(</span><span class="br0">)</span></pre></li><li class="li1"><pre class="de1">hexdata <span class="sy0">=</span> <span class="st0">''</span>.<span class="me1">join</span><span class="br0">(</span>chain.<span class="me1">from_iterable</span><span class="br0">(</span>l<span class="br0">[</span><span class="nu0">11</span>:<span class="nu0">73</span><span class="br0">]</span>.<span class="me1">split</span><span class="br0">(</span><span class="br0">)</span> <span class="kw1">for</span> l <span class="kw1">in</span> hexlines<span class="br0">)</span><span class="br0">)</span></pre></li><li class="li1"><pre class="de1"><span class="kw1">print</span> GzipFile<span class="br0">(</span>fileobj<span class="sy0">=</span><span class="kw3">StringIO</span><span class="br0">(</span>unhexlify<span class="br0">(</span>hexdata<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">read</span><span class="br0">(</span><span class="br0">)</span></pre></li></ol></div></div></div></div></div></div></div>
<p>I tested this with Python 2.7. In lines 1-5, a selection of packages, classes, and functions is imported from the Python standard library. As you can already infer from the names, we have a tool at hand for the conversion from data in hex representation to raw binary data (<code>unhexlify</code> from the <code>binascii</code> module), as well as a tool for decompressing data that has previously been compressed according to the <a href="http://tools.ietf.org/html/rfc1952">gzip file format standard</a>. <code>StringIO</code> provides in-memory file handling — that way we can get around writing an actual file to disk containing the gzipped data. <code>re</code> is Python’s regular expression package, I am using it for extracting the contents of the third <code>pre</code> block, i.e. Chrome’s hexdump of the gzipped HTTP response body (as explained above).</p>
<p>A step-by-step walk-through:</p>
<ul>
<li>In lines 7 and 8, the entire content of Chrome’s HTML representation of the cached response (<code>cache.html</code>) is read. Since Chrome tells us that it had encoded <code>cache.html</code> using the <code>UTF-8</code> codec, we use the same codec to decode the file into a Python unicode object.</li>
<li>In line 10, the hexdump representation of the gzipped response body is extracted. A regular expression is used for matching the content of all <code>pre</code> blocks. The third of those is selected. The formatted hexdump is split into a list of single lines for further processing.</li>
<li>In line 11, the three-column formatted hexdump is converted to a raw hex representation, free of any whitespace characters. Only the middle column is extracted of each line (characters 12 to 73). Finally, all characters are concatenated to one single string.</li>
<li>In line 12, the data in hex representation is converted to binary data and written to an in-memory file object. This is treated as gzip file and decompressed. The result is printed to stdout. It is the original HTML response body as sent by the web server.</li>
</ul>
<p>Hopefully this is useful to someone who also has to retrieve important data from Chrome’s cache…</p>
 </div> 
</div></body></html>