<html><body><div><span itemprop="articleBody"><p>Hello everyone. There is something quite common people are trying to do in Django which is accessing a ManyToMany relationship from both ends in Django admin.</p>
<p>Since this is something I am going to have to explain to someone tomorow, I thought I'd take the opportunity to write a short tutorial about it.</p>
      
        
        
          <p>Let's start with a pretty usual use-case scenario: books and authors. Here is what your models.py looks like:</p>
<pre class="brush: python; toolbar: false; first-line: 1; class-name: 'my_personnal_code' ">from django.db import models


class Author(models.Model):

  name = models.CharField(max_length=255)

  def __unicode__(self):
    return self.name


class Book(models.Model):

  name = models.CharField(max_length=255)
  author = models.ManyToManyField(Author, blank=True, null=True, related_name='books')

  def __unicode__(self):
    return self.name
</pre>
<p>And your admin.py:</p>
<pre class="brush: python; toolbar: false; first-line: 1; class-name: 'my_personnal_code' ">from django.contrib import admin

from related_m2m.models import Book, Author

admin.site.register(Author)
admin.site.register(Book)</pre>
        
      
        
          
            <img class="third pull-right" src="/uploads/blog/yle04TQr-Screenshot - 2014-08-19 - 21:06:48.png"/>
          
        
        
          <p>Now, this is what the admin form for Book looks like. And one would expect to be able to have the same ManyToMany field on the  Author form.</p>
<p>Django doesn't automatically add "related" ManyToMany relationships to the admin by default. Since you can access books associated to an author using <em>my_author_object.books.all()</em>,  the intuitive way to achieve that would be to create a ModelAdmin for Author and to add a 'books' field to its default fieldset. Like the following:</p>
<pre class="brush: python; toolbar: false; first-line: 1; class-name: 'my_personnal_code' ">from django.contrib import admin

from related_m2m.models import Book, Author

class AuthorAdmin(admin.ModelAdmin):

  fieldsets = (
    (None, {'fields': ('name', 'books')}),
  )

admin.site.register(Author, AuthorAdmin)
admin.site.register(Book)</pre>
<p>While it is correct, this is not enough. The FormFactory which creates <em>ModelForm</em>'s for the admin doesn't create fields for related ManyToMany relationships so we are going to have to create a custom form ourselves. In this form we will add a ModelMultipleChoiceField and customize its init and save method in order to handle the data related to this field.</p>
<p>Here is our forms.py:</p>
<pre class="brush: python; toolbar: false; first-line: 1; class-name: 'my_personnal_code' ">from django import forms
from django.contrib import admin
                                                               
from related_m2m.models import Author, Book                     
                                                               
class AuthorForm(forms.ModelForm):                             
                                                               
  books = forms.ModelMultipleChoiceField(                      
    Book.objects.all(),                                        
# Add this line to use the double list widget                  
#    widget=admin.widgets.FilteredSelectMultiple('Books', False),
    required=False,                                            
  ) 
    
  def __init__(self, *args, **kwargs):                         
    super(AuthorForm, self).__init__(*args, **kwargs)
    if self.instance.pk:
      #if this is not a new object, we load related books                                       
      self.initial['books'] = self.instance.books.values_list('pk', flat=True)
  
  def save(self, *args, **kwargs):                             
    instance = super(AuthorForm, self).save(*args, **kwargs)   
    if instance.pk:
      for book in instance.books.all():
        if book not in self.cleaned_data['books']:            
          # we remove books which have been unselected 
          instance.books.remove(book)
      for book in self.cleaned_data['books']:                  
        if book not in instance.books.all():                   
          # we add newly selected books
          instance.books.add(book)      
    return instance</pre>
<p> After which you have to update your admin.py file like this:</p>
<pre class="brush: python; toolbar: false; first-line: 1; class-name: 'my_personnal_code' ">from django.contrib import admin

from related_m2m.models import Book, Author
from related_m2m.forms import AuthorForm

class AuthorAdmin(admin.ModelAdmin):

  form = AuthorForm

  fieldsets = (
    (None, {'fields': ('name', 'books')}),
  )

admin.site.register(Author, AuthorAdmin)
admin.site.register(Book)</pre>
        
      
        
          
            <img class="third pull-left" src="/uploads/blog/UOx2EdGq-Screenshot - 2014-08-19 - 21:38:42.png"/>
          
        
        
          <p>Once you have done this, the ManyToMany relationship will also be available from the Author admin form.</p>
<p>Now some of you might have noticed there was something missing from that last screenshot. There is no plus sign next to the <em>books</em> field.<br/>The way Django does it in "regular" admin forms is to wrap relationship fields widgets with a "special wrapper" to add the plus sign (and everything associated with it).<br/>All we have to do to get the plus sign is to add this wrapper in our form as well. Here is the code to add to your <em>forms.py</em>:</p>
<pre class="brush: python; toolbar: false; first-line: 1; class-name: 'my_personnal_code' "># Add those two import lines at the top
from django.db.models.fields.related import ManyToManyRel
from django.contrib.admin.widgets import RelatedFieldWidgetWrapper

.
.
.

class AuthorForm(forms.ModelForm):
.
.
.
  def __init__(self, *args, **kwargs):                         
    super(AuthorForm, self).__init__(*args, **kwargs)
    if self.instance.pk:                                       
      self.initial['books'] = self.instance.books.values_list('pk', flat=True)
      # Add thos to lines to __init__
      rel = ManyToManyRel(Book)
      self.fields['books'].widget = RelatedFieldWidgetWrapper(self.fields['books'].widget, rel, admin.site)
.
.
.</pre>
<p>With this last change you now have a ManyToMany field working exactly the same way either from the Book admin form or the Author admin form.</p>
<p>Later this week we will have the <a href="../../../../blog/creating-re-usable-django-app-part-1.html">next tutorial in the Babbler series</a>. In the mean time, have a great week everyone!</p>
<blockquote>
<p><span>As always, you can browse the code for this tutorial on </span><a href="http://vc.lasolution.be/projects/snippets/repository" target="_blank">http://vc.lasolution.be/projects/snippets/repository</a><span>.</span><br/><span>The code is available for checkout on </span><a href="http://code.lasolution.be/snippets" target="_blank">http://code.lasolution.be/snippets</a><span>.</span><br/><span>The branch associated with this tutorial is </span><strong><em>related_m2m</em></strong></p>
</blockquote>
        
      
        
          
        
        
          <p><strong>Edit 2014-10-05:</strong> For Django 1.5.9, 1.5.10, 1.6.6, 1.6.7 and 1.7, see <a href="../../../../blog/related-manytomanyfield-django-admin-site-continued.html">this post</a>.</p>
        
      
      </span>
      </div></body></html>