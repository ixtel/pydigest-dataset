<html><body><div><div id="articleText">
                    <p id="articleLongDescription">Programming expert Jesse Smith shows how to make Python programs more robust by using exceptions.</p>
                    <p id="articleDescription"/>

                    <a class="relatedBookLink" href="#">Like this article? We recommend <span class="ss-icon"></span></a>
                    
                    

                <p>In this article, I'll continue showing you how to use Python from  an object-oriented (OO) point of view. If you're unfamiliar with object-oriented  concepts such as inheritance, encapsulation, and polymorphism, read my article "<a href="http://www.informit.com/articles/article.aspx?p=2102828">A Primer on  Object-Oriented Concepts</a>" before continuing with this article.</p>
<p>
  This article builds on my earlier article "<a href="/articles/article.aspx?p=2145970">An Introduction to Object-Oriented  Concepts in Python, Part 3</a>." If you haven't read that article already,  please read it before reading this article. The concepts in this article will  take a closer look at Python exception handling.</p>
<p>
  If you've been following my Python series, you know how classes in  Python work. But so far I haven't addressed how Python classes are used to raise exceptions. As in other  programming languages, it's necessary to raise exceptions that not only help  programmers to identify problems, but alert program users to errors.</p>

<hr size="3"/>
<h3>Miss the Earlier Articles in this Python Series?</h3>
<p>In case you joined late, here are the earlier installments in this article series:</p>

<hr size="3"/>

<h2>Python Exceptions</h2>
<p>Like everything else in Python, an exception is really just an  object. All exceptions are derived from the <tt>BasicException</tt> class. As in  other languages, Python uses a familiar <tt>try...except</tt> block to capture an  exception, but a <tt>raise</tt> keyword to throw exceptions. This differs from  other languages that commonly use <tt>throw</tt> to throw new exceptions and a <tt>try...catch</tt> block to catch exceptions.</p>
<p>
  Python has a lot of built-in exceptions that are raised if no other  code catches them. One simple example, which you've likely already seen, is the <tt>SyntaxError</tt> exception. To raise this exception, simply use the <tt>print</tt> function without parentheses:</p>
<pre>print "hello world"</pre>
<p>
  The Python interpreter expects parentheses with the reserved <tt>print</tt> function name; when it doesn't find them, a <tt>SyntaxError</tt> exception is  thrown. This type of exception is referred to as an <em>unhandled</em> exception. No code was there to catch the exception using  the <tt>try...except</tt> block. If we don't handle the exception, the whole program halts in execution—and  crashes. The <tt>SyntaxError</tt> exception is a special exception that we can't  handle explicitly in a program. This type of exception is known as a <em>compile-time error</em>. The program won't  run until this type of exception is corrected during code compilation (before  the program executes). Quite a few built-in exceptions can't be handled that  are <em>not</em> compile-time errors, but  instead are <em>runtime</em> errors. These  exceptions occur while the program is running and are triggered by either a  system or user condition. For example, let's say we have an equation completed  by user input. If the user enters <tt>0</tt>, we can handle (catch) the built-in <tt>ZeroDivisionError</tt> exception by sending the user a friendly message:</p>
<pre>try:
    y = 0
    x = 10/y
except ZeroDivisionError:
    print("invalid input, cannot divide by 0")</pre>
<p>
  Any statements after the <tt>print</tt> statement in this example  would be executed normally. The important thing to note here is that, because  the exception was handled, the program resumes without crashing.</p>
<p>
  What if you want to raise your  own exception? To do this, use the <tt>raise</tt> keyword:</p>
<pre>y = 0
if y == 0:
    raise ZeroDivisionError("invalid input, cannot divide by 0")</pre>
<p>
  In this example, we test the condition for division by 0; if the  condition is true, we raise the <tt>ZeroDivisionError</tt> exception in our code.  The program throws the exception and halts execution because there's no code to  handle (catch) it. Our exception bubbles up to each previous piece of calling  code until it reaches the top. If no code is found to handle the exception, we  get the exception message and stack trace.</p>
<p>
  What if we wanted to raise our own exceptions? In some instances,  none of the built-in exceptions will work as we intended. To raise our own  exceptions, we create a class that's derived from the built-in <tt>Exception</tt> class, which in turn is derived from the <tt>BaseException</tt> class:</p>
<pre>class InvalidFeature(Exception):
    pass
raise InvalidFeature("this is not a valid feature for this product")</pre>
<p>
  Notice that we don't need to add any code to our exception class.  Everything we need is from the built-in <tt>Exception</tt> class. When running  this code, it will behave just like the Python built-in exceptions. To expand  on custom exceptions, we can pass parameters into the <tt>__init__</tt> method of  our exception class:</p>
<pre>class InvalidFeature(Exception):
    def __init__(self, feature):
        if feature != "automatic transmission":
            super().__init__("this is not a valid feature for this product")
raise InvalidFeature("power steering")</pre>
<p>
  We pass in a feature to our custom exception class and test for a  valid feature, if not a valid feature, the __init__ class of the <tt>Exception</tt> superclass is called to print out the message.   You could just as easily add other methods to your custom exception  class. You can also use the <tt>as</tt> keyword, as other languages do when  catching an exception:</p>
<pre>class InvalidFeature(Exception):
    def __init__(self, feature):
        if feature != "automatic transmission":
            print("Invalid Feature")
try:
   raise InvalidFeature("automatic transmission")
except InvalidFeature as e:
    e.__init__("anti-lock brakes")</pre>
<p>
  When running this code, instead of the interpreter printing out the  error message, we print out the message in a friendly format that doesn't halt  execution of the program.  You could use  the <tt>return</tt> keyword in your custom exception class for more elegant  results.</p>
<h2>Conclusion</h2>
<p>In this article, you learned how to use exceptions in Python  programs by using built-in exceptions. It's important to note that all  exception classes, whether built-in or custom-created, are derived from the <tt>BaseException</tt> class. When creating custom exceptions, the <tt>custom</tt> class is derived from  the built-in <tt>Exception</tt> class. The <tt>__init__</tt> method of the <tt>Exception</tt> class can be used in a custom class to provide custom messages. "Raising  an exception" refers to the ability to throw exceptions in our code. When we  raise exceptions, they're not handled unless code is included in the program to handle the exceptions.  There are various program states in which built-in exceptions can occur.  Exceptions raised by the Python interpreter during compilation are known as <em>compile-time exceptions</em>. Exceptions  raised by a user or system action within the program are referred to as <em>runtime exceptions</em>. We can handle runtime exceptions in our programs  and continue execution of the program, but we're unable to handle compile-time  exceptions, which halt the program altogether.</p>
<p>
  At this stage, you should be comfortable using built-in exceptions,  along with creating your own custom exceptions. Knowing the difference is  important, as sometimes the built-in exceptions won't suffice and a custom one  is necessary. Python is a little different from other languages in that it uses  the <tt>except</tt> and <tt>raise</tt> keywords, as opposed to the <tt>catch</tt> and <tt>throw</tt> keywords. (I refer to these as <em>keywords</em>,  but they're really just built-in functions.)</p>
<p>
  In <a href="/articles/article.aspx?p=2145972">Part 5 of this series</a>, I'll continue OO concepts by covering  file handling and data structures. These concepts are important for program  flow and well-designed Python programs.</p>
            </div>
            </div></body></html>