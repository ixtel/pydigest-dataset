<html><body><div><div class="body"><p>Совсем недавно на Stepic.Org был замечательный во всех смыслах курс по основам Java,о котором уже упоминалось </p><a href="http://devdrive.ru/post/Java.Basic%20course%20by%20Stepic.org/">тут</a><p>.</p><p>Новые знания всегда что то изменяют в жизни человека и так уж сложилось,что я привык к указанию типов переменных передаваемых в функцию и возвращаемых ей.</p><p>Это удобно и всегда известно что ожидать от того или иного куска кода и как работать с результатом его деятельности,и после курса этого удобства очень не хватало в Python.</p><p>Но как оказалось всё не так уж и плохо как было на первый взгляд,и попытки как то использовать информацию о передаваемых и возвращаемых значениях они были раньше.</p><p>В этом случае писали нечто вида</p><pre class="literal-block">def compile(source: "something compilable",
            filename: "where the compilable thing comes from",
            mode: "is this a single statement or a suite?"):<br/>            ........<br/></pre><p>а бывало чуток иначе,даже указывали типы передаваемых переменных:</p><pre class="literal-block">def haul(item: Haulable, *vargs: PackAnimal) -&gt; Distance:
    ........</pre><p>Но до недавнего времени таких вариантов было достаточно много и различные IDE поддерживали их по разному.Кто то больше,кто то меньше.</p><p>С публикацией PEP 0484 ситуация изменилось поскольку теперь был выбран некий единый стиль оформления в основе которого был заложен подход используемый в MyPy(статический чекер синтаксиса).</p><h3><b>Как это выглядит сейчас:</b></h3><pre class="literal-block">def greeting(name: str) -&gt; str:
    return 'Hello ' + name</pre><p>Как видно из примера - всё очевидно и просто.Дополнительным плюсом является то что некоторые IDE(например Pycharm &gt;=4.5) уже умеет анализировать ваш код и показывать подсказки если вы например захотите передать вместо списка словарь.То есть передать по прежнему возможно будет,но уведомление о потенциальной несовместимости - IDE покажет.</p><h3>Что можно аннотировать?</h3><p>Можно очень много,то есть вы можете указать что и куда вы передаете и ожидаете.Если в функцию передается список объектов в вашей программе (например список характеризующий людей)  его можно отметить как <br/></p><pre class="literal-block">def accept(peoples: List[People]):
    ....</pre><p>Также можно аннотировать что угодно,главное правильно указать тип переменой.</p><h3>Что будет со старыми программами?</h3><p>Они будут также работать как раньше,вас никто не заставляет насильно писать аннотации,а если вы их не указываете по умолчанию им будет присвоен тип <span>Any </span></p><p>Также питон останется по прежнему динамическим языком,поскольку аннотации направлены на улучшение восприятия кода и создатели гарантируют что всё останется по старому.</p><h3>Что еще дает PEP 484?</h3><p>Обещают поддержку дженериков и других функциональных возможностей.В общем стоит <a href="https://www.python.org/dev/peps/pep-0484/">почитать</a>.<br/></p><h3>Хватит слов,давайте аннотируем что либо и рассмотрим всё в действии!</h3><p>В качестве примера приведу реализацию задачи которую решали в курсе по Java.Нацелена она на работу с классами пожалуй хорошо подойдет для наших целей.Будем моделировать работу почтовой системы,все совпадения случайны =)</p><p>В первую очередь нам нужно что то,что мы будем посылать.Это абстрактное почтовое отправление,письмо и посылка.Описываются они следующим образом<br/></p><pre><span>from </span>abc <span>import </span>ABCMeta<span>, </span>abstractmethod<br/><br/><br/><span>class </span><span>AbstractSendMailing</span>(<span>object</span>):<br/>    <span>"""</span><span>Некое абстрактное почтовое отправление</span><span>"""<br/></span><span>    </span><span>__metaclass__ </span>= ABCMeta<br/>    <br/>    @<span>abstractmethod<br/></span><span>    </span><span>def </span><span>get_source</span>(<span>self</span>):<br/>        <span>pass<br/></span><span><br/></span><span>    </span>@<span>abstractmethod<br/></span><span>    </span><span>def </span><span>get_destination</span>(<span>self</span>):<br/>        <span>pass<br/></span><span><br/></span><span><br/></span><span>class </span><span>Mail</span>(AbstractSendMailing):<br/>    <span>"""</span><span>Родоночальник всех почтовых отправлений</span><span>"""<br/></span><span><br/></span><span>    </span><span>def </span><span>__init__</span>(<span>self</span><span>, </span>source: <span>str</span><span>, </span>destination: <span>str</span>) -&gt; <span>None</span>:<br/>        <span>"""<br/></span><span>        </span><span>:param</span><span> source - </span><span>источник от кого пришло<br/></span><span>        </span><span>:param</span><span> destination - </span><span>назначение кому предначначено</span><span><br/></span><span>        """<br/></span><span>        </span><span>self</span>.__source = source<br/>        <span>self</span>.__destination = destination<br/><br/>    <span>def </span><span>get_source</span>(<span>self</span>) -&gt; <span>str</span>:<br/>        <span>return </span><span>self</span>.__source<br/><br/>    <span>def </span><span>get_destination</span>(<span>self</span>) -&gt; <span>str</span>:<br/>        <span>return </span><span>self</span>.__destination<br/><br/><br/><span>class </span><span>MailMessage</span>(Mail):<br/>    <span>def </span><span>__init__</span>(<span>self</span><span>, </span>source: <span>str</span><span>, </span>destination: <span>str</span><span>, </span>message: <span>str</span>) -&gt; <span>None</span>:<br/>        <span>"""<br/></span><span>        </span><span>Превращает абстрактное почтовое отправление в письмо</span><span>.<br/></span><span>        </span><span>:param</span><span> message  - </span><span>текст письма</span><span><br/></span><span>        """<br/></span><span>        </span><span>super</span>().<span>__init__</span>(source<span>, </span>destination)<br/>        <span>self</span>.__message = message<br/><br/>    <span>def </span><span>get_message</span>(<span>self</span>)-&gt; <span>str</span>:<br/>        <span>return </span><span>self</span>.__message<br/><br/>    <span>def </span><span>get_destination</span>(<span>self</span>):<br/>        <span>super</span>().get_destination()<br/><br/>    <span>def </span><span>get_source</span>(<span>self</span>):<br/>        <span>super</span>().<span>get_source</span>()<br/><br/><br/><span>class </span><span>Package</span>(<span>object</span>):<br/>    <span>def </span><span>__init__</span>(<span>self</span><span>, </span>content: <span>str</span><span>, </span>price: <span>int</span>) -&gt; <span>None</span>:<br/>        <span>"""<br/></span><span>        </span><span>Посылка<br/></span><span>        </span><span>:param</span><span> price - </span><span>ценность посылки<br/></span><span>        </span><span>:param</span><span> content  - </span><span>содержимое посылки</span><span><br/></span><span>        """<br/></span><span>        </span><span>self</span>.__content = content<br/>        <span>self</span>.__price = price<br/><br/>    <span>def </span><span>get_content</span>(<span>self</span>) -&gt; <span>str</span>:<br/>        <span>return </span><span>self</span>.__content<br/><br/>    <span>def </span><span>get_price</span>(<span>self</span>) -&gt; <span>str</span>:<br/>        <span>return </span><span>self</span>.__price<br/><br/>    <span>def </span><span>set_content</span>(<span>self</span><span>, </span>content: <span>str</span>):<br/>        <span>"""<br/></span><span><br/></span><span>        </span><span>:type</span><span> content: </span><span>устанавливает содержимое посылки</span><span><br/></span><span>        """<br/></span><span>        </span><span>self</span>.__content = content<br/><br/><br/><span>class </span><span>MailPackage</span>(Mail):<br/>    <span>def </span><span>__init__</span>(<span>self</span><span>, </span>source: <span>str</span><span>, </span>destination: <span>str</span><span>, </span>content: Package) -&gt; <span>None</span>:<br/>        <span>"""<br/></span><span>        </span><span>Преобразует почтовое отправление в почтовую посылку</span><span>.<br/></span><span>        </span><span>:param</span><span> content  - </span><span>содержимое посылки</span><span><br/></span><span>        """<br/></span><span>        </span><span>super</span>().<span>__init__</span>(source<span>, </span>destination)<br/>        <span>self</span>.__content = content<br/><br/>    <span>def </span><span>get_content</span>(<span>self</span>) -&gt; Package:<br/>        <span>return </span><span>self</span>.__content<br/><br/>    <span>def </span><span>get_destination</span>(<span>self</span>):<br/>        <span>super</span>().get_destination()<br/><br/>    <span>def </span><span>get_source</span>(<span>self</span>):<br/>        <span>super</span>().<span>get_source</span>()<br/></pre><p>Также нам нужны персонажи которые будут взаимодействовать с нашими почтовыми отправлениями.Это "Ненадежный почтовый работник","Шпион","Вор" и "Инспектор". Представлены они  в роли неких почтовых сервисов которые умеют обрабатывать почтовое отправление.</p><pre><span>from </span>logging <span>import </span>Logger<br/><span>from </span>typing <span>import </span>List<br/><br/><span>from </span>abc <span>import </span>ABCMeta<span>, </span>abstractmethod<br/><br/><span>from </span>alerts <span>import </span>IllegalPackageException<span>, </span>StolenPackageException<br/><span>from </span>send_mail <span>import </span>Mail<span>, </span>MailMessage<span>, </span>MailPackage<br/><br/>banned_address = <span>"Austin Powers"<br/></span>weapons = <span>"weapons"<br/></span>banned_substance = <span>"banned substance"<br/></span>stones = <span>"stones"<br/></span><span><br/></span><span><br/></span><span>class </span><span>MailService</span>(<span>object</span>):<br/>    <span>__metaclass__ </span>= ABCMeta<br/><br/>    @<span>abstractmethod<br/></span><span>    </span><span>def </span><span>process_mail</span>(<span>self</span><span>, </span>mail: Mail):<br/>        <span>"""<br/></span><span>        </span><span>Обработкик  почтового отправления<br/></span><span>        </span><span>:param</span><span> mail: </span><span>Некое почтое отправление</span><span><br/></span><span>        """<br/></span><span>        </span><span>pass<br/></span><span><br/></span><span><br/></span><span>class </span><span>RealMailService</span>(MailService):<br/>    <span>"""</span><span>Настоящий обработчик почтовых отправлений</span><span>"""<br/></span><span><br/></span><span>    </span><span>def </span><span>process_mail</span>(<span>self</span><span>, </span>mail) -&gt; Mail:<br/>        <span>return </span>mail<br/><br/><br/><span>class </span><span>UntrustworthyMailWorker</span>(MailService):<br/>    <span>"""<br/></span><span>    </span><span>Ненадежный работник почты<br/></span><span>    Вместо того</span><span>, </span><span>чтобы передать почтовый объект непосредственно в сервис почты</span><span>,<br/></span><span>    </span><span>последовательно передает этот объект набору третьих лиц</span><span>,<br/></span><span>    </span><span>а затем</span><span>, </span><span>в конце концов</span><span>,<br/></span><span>    </span><span>передает получившийся объект непосредственно экземпляру</span><span> RealMailService<br/></span><span>    """<br/></span><span><br/></span><span>    </span><span>def </span><span>__init__</span>(<span>self</span><span>, </span>mail_services: List[MailService]):<br/>        <span>self</span>.mail_services = mail_services<br/>        <span>self</span>.real_mail_service = RealMailService()<br/><br/>    <span>def </span><span>process_mail</span>(<span>self</span><span>, </span>mail: Mail):<br/>        <span>for </span>mail_service <span>in </span><span>self</span>.mail_services:<span><br/></span><span>            </span>mail = mail_service.process_mail(mail)<br/>        <span>return </span><span>self</span>.real_mail_service.process_mail(mail)<br/><br/><br/><span>class </span><span>Spy</span>(MailService):<br/>    <span>"""<br/></span><span>    </span><span>Шпион</span><span>, </span><span>который логгирует о всей почтовой переписке</span><span>, </span><span>которая проходит через его руки</span><span>.<br/></span><span>    </span><span>Он следит только за объектами класса</span><span> MailMessage </span><span>и пишет в логгер следующие сообщения<br/></span><span>    Если в качестве отправителя или получателя указан</span><span> "Austin Powers":<br/></span><span>    </span><span>то нужно написать в лог сообщение с уровнем</span><span> WARN:<br/></span><span>    Detected target mail correspondence: from {from} to {to} "{message}"<br/></span><span>    </span><span>Иначе</span><span>, </span><span>необходимо написать в лог сообщение с уровнем</span><span> INFO:<br/></span><span>    Usual correspondence: from {from} to {to}<br/></span><span>    """<br/></span><span><br/></span><span>    </span><span>def </span><span>__init__</span>(<span>self</span>):<br/>        <span>self</span>.__logger = Logger(<span>"logger"</span>)<br/><br/>    <span>def </span><span>process_mail</span>(<span>self</span><span>, </span>mail: Mail):<br/>        <span>if </span><span>isinstance</span>(mail<span>, </span>MailMessage):<br/>            source = mail.get_source()<br/>            destination = mail.get_destination()<br/>            message = mail.get_message()<br/>            <span>if </span>source == banned_address <span>or </span>destination == banned_address:<br/>                <span>self</span>.__logger.warning(<span>'Detected target mail correspondence: from {0} to {1} "{2}"'</span>.<br/>                                      format(source<span>, </span>destination<span>, </span>message))<br/>            <span>else</span>:<br/>                <span>self</span>.__logger.info(<span>'Usual correspondence: from {0} to {1}'</span>.format(source<span>, </span>destination))<br/>        <span>return </span>mail<br/><br/><br/><span>class </span><span>Thief</span>(MailService):<br/>    <span>"""<br/></span><span>    </span><span>Вор</span><span>, </span><span>который ворует самые ценные посылки и игнорирует все остальное<br/></span><span>    Он следит только за объектами класса</span><span> MailMessage </span><span>и пишет в логгер следующие сообщения<br/></span><span>    Воровство происходит следующим образом</span><span>: </span><span>вместо посылки</span><span>, </span><span>которая пришла вору</span><span>, </span><span>он отдает новую</span><span>,<br/></span><span>    </span><span>такую же</span><span>, </span><span>только с нулевой ценностью и содержимым посылки</span><span> "stones instead of {content}".<br/></span><span>    """<br/></span><span><br/></span><span>    </span><span>def </span><span>__init__</span>(<span>self</span><span>, </span>minimal_cost: <span>int</span>):<br/>        <span>"""<br/></span><span>        </span><span>:type</span><span> minimal_cost: </span><span>Указывает минимальную стоимость посылки</span><span>, </span><span>которую можно своровать</span><span><br/></span><span>        """<br/></span><span>        </span><span>self</span>.__minimal_cost = minimal_cost<br/>        <span>self</span>.__stolen_value = <span>0<br/></span><span><br/></span><span>    </span><span>def </span><span>process_mail</span>(<span>self</span><span>, </span>mail: Mail):<br/>        <span>if </span><span>isinstance</span>(mail<span>, </span>MailPackage):<br/>            content = mail.get_content()<br/>            <span>if </span>content.get_price() &gt;= <span>self</span>.__minimal_cost:<span><br/></span><span>                </span><span>self</span>.__stolen_value += content.get_price()<br/>                content.price = <span>0<br/></span><span>                </span>new_content = <span>"stones instead of {0}"</span>.format(content.get_content())<br/>                content.set_content(new_content)<br/><br/>        <span>return </span>mail<br/><br/>    <span>def </span><span>get_stolen_value</span>(<span>self</span>) -&gt; <span>int</span>:<br/>        <span>"""<br/></span><span>        </span><span>возвращает суммарную стоимость всех посылок</span><span>, </span><span>которые он своровал</span><span><br/></span><span>        """<br/></span><span>        </span><span>return </span><span>self</span>.__stolen_value<br/><br/><br/><span>class </span><span>Inspector</span>(MailService):<br/>    <span>"""<br/></span><span>    </span><span>Инспектор</span><span>, </span><span>который следит за запрещенными и украденными посылками и<br/></span><span>  бьет тревогу в виде исключения</span><span>, </span><span>если была обнаружена подобная посылка<br/></span><span>  Если он заметил запрещенную посылку с одним из запрещенных содержимым</span><span> ("weapons" </span><span>и</span><span> "banned substance"),<br/></span><span>    </span><span>то он бросает</span><span> IllegalPackageException.<br/></span><span>    </span><span>Если он находит посылку</span><span>, </span><span>состаящую из камней</span><span> (</span><span>содержит слово</span><span> "stones"),<br/></span><span>    </span><span>то тревога прозвучит в виде</span><span> StolenPackageException.<br/></span><span>    """<br/></span><span><br/></span><span>    </span><span>def </span><span>process_mail</span>(<span>self</span><span>, </span>mail: Mail):<br/>        <span>if </span><span>isinstance</span>(mail<span>, </span>MailPackage):<br/>            package = mail.get_content()<br/>            content = package.get_content()<br/>            <span>if </span>weapons <span>in </span>content <span>or </span>banned_substance <span>in </span>content:<br/>                <span>raise </span>IllegalPackageException<br/>            <span>if </span>stones <span>in </span>content:<br/>                <span>raise </span>StolenPackageException<br/>        <span>return </span>mail<br/></pre><p>
Также нам нужны исключения для поведения "Инспектора"</p><pre><span>class </span><span>IllegalPackageException</span>(<span>Exception</span>):<br/>    <span>pass<br/></span><span><br/></span><span><br/></span><span>class </span><span>StolenPackageException</span>(<span>Exception</span>):<br/>    <span>pass<br/></span></pre><p>И небольшой набор для эмуляции работы всей системы</p><pre><span>from </span>mail_services <span>import </span>UntrustworthyMailWorker<span>, </span>Spy<span>, </span>Thief<span>, </span>Inspector<br/><span>from </span>send_mail <span>import </span>MailMessage<span>, </span>MailPackage<span>, </span>Package<br/><br/>mail = MailMessage(<span>"Austin Powers"</span><span>, </span><span>"John"</span><span>, </span><span>"Hello!"</span>)<br/>spy = Spy()<br/>mail_services = [spy]<br/>untrustworthy_mail_worker = UntrustworthyMailWorker(mail_services)<span><br/></span>untrustworthy_mail_worker.process_mail(mail)<br/><br/>thief1 = Thief(<span>100</span>)<br/>thief2 = Thief(<span>200</span>)<br/>thief3 = Thief(<span>300</span>)<br/><br/>mail_services = [thief3<span>, </span>thief2<span>, </span>thief1<span>, </span>spy]<br/>untrustworthy_mail_worker = UntrustworthyMailWorker(mail_services)<br/><br/>package = Package(<span>"Vodka"</span><span>, </span><span>100</span>)<br/>mail = MailPackage(<span>"Austin Powers"</span><span>, </span><span>"John"</span><span>, </span>package)<span><br/></span>untrustworthy_mail_worker.process_mail(mail)<br/><span><br/></span><span>assert </span>(thief3.get_stolen_value() == <span>0</span>)<br/><span>assert </span>(thief2.get_stolen_value() == <span>0</span>)<br/><span>assert </span>(thief1.get_stolen_value() == <span>100</span>)<br/><br/><span><br/></span>package = Package(<span>"Whisky"</span><span>, </span><span>150</span>)<br/>mail = MailPackage(<span>"Eric"</span><span>, </span><span>"Peter"</span><span>, </span>package)<br/>inspector = Inspector()<br/>mail_services = [thief3<span>, </span>inspector<span>, </span>thief2<span>, </span>inspector<span>, </span>thief1<span>, </span>inspector]<br/>untrustworthy_mail_worker = UntrustworthyMailWorker(mail_services)<span><br/></span>untrustworthy_mail_worker.process_mail(mail)<br/></pre><p>Как вы видите - большинство классов и функций - аннотировано в новом стиле.Исходный код можно взять </p><a href="https://github.com/VeeSot/post_office">здесь</a><p>Поддержка аннотаций типов доступна начиная с Python 3.5. В Python 2.7 если и планируется - то весьма ограниченая и неполноценная.
</p></div>
        
            </div></body></html>