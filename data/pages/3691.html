<html><body><div><div class="post-text" itemprop="text">

<p>I am trying to locate millions of points inside a half-dozen polygons. Here's my code:</p>

<pre><code>def find_shape(longitude,latitude):
    if longitude != 0 and latitude != 0:
        point = shapely.geometry.Point(longitude,latitude)
    else:
        return "Unknown"
    for current_shape in all_shapes:
        if current_shape['bounding_box'].contains(point):
            if current_shape['shape'].contains(point):
                return current_shape['properties']['ShapeName']
                break
    return "Unknown"
</code></pre>

<p>I've read the other questions that deal with improving performance for point-in-polygon queries with shapely. They suggest Rtrees. However, it seems like this is useful for cases when there are many polygons (<a href="http://stackoverflow.com/questions/20297977/looking-for-a-fast-way-to-find-the-polygon-a-point-belongs-to-using-shapely">36,000 in one question</a>, <a href="http://stackoverflow.com/questions/14697442/faster-way-of-polygon-intersection-with-shapely">100,000 in another</a>) and it is not desirable to loop over them all.</p>

<p>I am already setting up a bounding box, as you can see. Here's my shape setup code:</p>

<pre><code>with fiona.open(SHAPEFILE) as f_col:
    all_shapes = []
    for shapefile_record in f_col:
        current_shape = {}
        current_shape['shape'] = shapely.geometry.asShape(shapefile_record['geometry'])
        minx, miny, maxx, maxy = current_shape['shape'].bounds
        current_shape['bounding_box'] = shapely.geometry.box(minx, miny, maxx, maxy)
        current_shape['properties'] = shapefile_record['properties']
        all_shapes.append(current_shape)
</code></pre>

<p><strong>Would it be useful to <em>also</em> check another very simplified version of the shape</strong>, namely one made of the largest inscribed rectangle (or maybe triangle)?</p>

<p>Checking the shapely docs, it doesn't seem there's a function for this. Maybe some setting of <a href="http://toblerity.org/shapely/manual.html#object.simplify"><code>simplify()</code></a>? Of course, I always want to make sure the new simplified shape does not extend beyond the bounds of the original shape, so I don't have to call <code>contains()</code> on the actual shape. I also think I want to make the new simplified shape as simple as possible, for speed.</p>

<p>Any other suggestions appreciated for as well. Thanks!</p>

<p><strong>EDIT</strong>: While awaiting replies, I have hit on this idea for creating a simplified shape meeting my requirements:</p>

<pre><code>current_shape['simple_shape'] = current_shape['shape'].simplify(.5)
current_shape['simple_shape'] = current_shape['simple_shape'].intersection(current_shape['shape'])
</code></pre>

<p>Here's how I use it when testing each point:</p>

<pre><code>if current_shape['simple_shape'].contains(point):
    return current_shape['properties']['ShapeName']
elif current_shape['shape'].contains(point):
    return current_shape['properties']['ShapeName']
</code></pre>

<p>This is not perfect, because the shape is not as simple as it could be after doing the necessary <code>intersection()</code>. Nevertheless, this approach has yielded a 60% decrease in processing time. In my tests, the simple polygon is used on 85% of point queries.</p>

<p><strong>EDIT 2</strong>: Another related question over on GIS StackExchange: 
<a href="http://gis.stackexchange.com/questions/10033/python-efficiency-need-suggestions-about-how-to-use-ogr-and-shapely-in-more-e">Python Efficiency â€” Need suggestions about how to use OGR and Shapely in more efficient way</a>. This deals with 1.5 million points in about 3,000 polygons.</p>
    </div>
    </div></body></html>