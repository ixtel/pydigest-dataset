<html><body><div><p>It allows to describe the build process of small projects in a very simple way
using a python based configuration file.
This description is then turned into ninja build files, that enable a very
quick turnaround of project builds.</p>
<div id="usage">
<h3>Usage</h3>
<p>The quickest way to execute <strong>pyrate</strong> is:</p>
<pre>pyrate
</pre>
<p>Without any parameters, <strong>pyrate</strong> will use the build configuration script (<em>pyrate script</em>) named <tt>build.py</tt>
and create a ninja build file called <tt>build.ninja</tt>.
If another pyrate script should be used, this can be specified as a positional argument.
The name of the created ninja build file can be customized using the option <tt><span class="pre">-o</span></tt> or <tt><span class="pre">--output</span></tt>.
The quick invocation shown above is therefore equivalent to the following invocation:</p>
<pre>pyrate --output mybuild.ninja mybuild.py
</pre>
<p>When the script is started, it first changes the current directory to the directory
containing the build configuration script, so all path names are relative to it.</p>
<pre>pyrate path/to/mybuild.py
</pre>
<p>will therefore create the ninja build file path/to/build.ninja</p>
<p>If <strong>pyrate</strong> is placed in a directory listed in the PATH environment variable (as automatically
done by <tt>pip install <span class="pre">pyrate-build</span></tt>), the build configure script can be made executable to
invoke <strong>pyrate</strong> automatically by starting the build config script with:</p>
<pre><span class="ch">#!/usr/bin/env pyrate</span>
</pre>
<p><em>There is some experimental support for the generation of plain makefiles,
which can be switched on with</em> <tt><span class="pre">-M</span></tt> <em>or</em> <tt><span class="pre">--makefile</span></tt>.</p>
</div>
<div id="build-file-configuration-syntax">
<h3>Build File Configuration Syntax</h3>
<p>The build configuration for <strong>pyrate</strong> is written in python - so the full power
of python can be used to construct and describe the build process.
Several classes, functions and variables are available to ease and customize
the configuration of the build process.</p>
<div id="specifying-build-input">
<h4>Specifying build input</h4>
<p>In general, a build input list that can be used to construct a build target takes the form:</p>

<p>Each item can be one of the following:</p>
<ul>
<li>a <em>string</em> is interpreted as a file name that is processed according to the rules specified by the packages in the <tt>tool</tt> dictionary</li>
<li>a <em>build target</em> as returned by the functions described in <a href="#defining-build-targets" rel="nofollow">Defining build targets</a> or explicitly defined</li>
<li>an <em>external dependency</em> as returned by the functions described in <a href="#external-dependencies" rel="nofollow">External dependencies</a> or explicitly defined</li>
<li>or any other kind of <tt>BuildSource</tt> (explained later)</li>
</ul>
<p>Instead of a list, it is also possible to specify a space separated string of file names.
Such a string is automatically split, so the following two build input lists behave identically:</p>
<ul>
<li><tt>"&lt;file1&gt; &lt;file2&gt; <span class="pre">..."</span></tt></li>
<li><tt><span class="pre">['&lt;file1&gt;',</span> <span class="pre">'&lt;file2&gt;',</span> <span class="pre">...]</span></tt></li>
</ul>
<p>Besides specifying file names by hand, there are many ways to get a list of files.
Common methods include calling the python function <tt>os.listdir</tt> or using the helper
function <tt>match</tt> provided by <strong>pyrate</strong>:</p>
<ul>
<li><tt>match(selector, dir_name = <span class="pre">'.',</span> recurse = False)</tt></li>
</ul>
<p>This functions allows to select files from a directory using a string consisting
of black / white listing path name patterns.
The selector <tt><span class="pre">'*.cpp</span> <span class="pre">-test*.cpp</span> test3.cpp *.h'</tt> for example selects all files ending with
‘.h’ and ‘.cpp’, with the exception of those ‘.cpp’ files that start with ‘test’ and are not
called ‘test3.cpp’.</p>
</div>
<div id="defining-build-targets">
<h4>Defining build targets</h4>
<p>There are four global helper functions to define object files, executables and libraries based
on a list of build inputs (which can be files, other targets or externals - as shown in <a href="#specifying-build-input" rel="nofollow">Specifying build input</a>):</p>
<ul>
<li><tt>executable(name, input_list, compiler_opts = None, linker_opts = None)</tt></li>
<li><tt>shared_library(name, input_list = None, compiler_opts = None, linker_opts = None)</tt></li>
<li><tt>static_library(name, input_list = None, compiler_opts = None, linker_opts = None)</tt></li>
<li><tt>object_file(name, input_list, compiler_opts = None)</tt></li>
</ul>
<p>Each function returns a build target object, that can be used as input / dependency of another function.
If multiple executables / libraries or object files with the same name but different inputs / options
are defined, <strong>pyrate</strong> will ensure that the output will have a unique name
(by appending a hash based suffix as needed). More details about this is available in <a href="#target-collision-avoidance" rel="nofollow">Target Collision Avoidance</a>.</p>
<p>If no input_list is given to <tt>shared_library</tt> or <tt>static_library</tt>, a BuildSource will be created,
that represents the specified library. Existing libraries can quickly be defined as dependencies this way,
but the name has to be a path to an existing file!</p>
<p>These functions exist as global functions and as member functions of a so-called build context,
that describes how these functions are processed. The global functions are just executing
within the default build context.</p>
<p>By default, all build targets that are defined by the above functions (or direct API calls) are built.
In order to select only certain default targets, the global variable <tt>default_targets</tt> can be used:</p>
<ul>
<li><tt>default_targets = <span class="pre">[&lt;target&gt;,...]</span></tt> (list of targets), <tt>&lt;target&gt;</tt> (single target) or <tt>None</tt> (all targets are built)</li>
</ul>
</div>
<div id="external-dependencies">
<h4>External dependencies</h4>
<p>The build environment / dependencies on external packages can be expressed using the
following functions / variables:</p>
<ul>
<li><tt>find_external(name, <span class="pre">...)</span></tt></li>
<li><tt>use_external(name, <span class="pre">...)</span></tt></li>
</ul>
<p>The function <tt>find_external</tt> searches for some external dependency (built-in, pkg-config package
or self-defined) with the given name and returns either None or a representation of the dependency.
<tt>use_external</tt> will first call <tt>find_external</tt> and add the external to the implicit input list
of the context if it exists.
The function takes additional positional and keyword arguments that depend on the external package.
A common argument for this function is a version selector, that is supplied through a global variable:</p>

<p>The comparison between this variable and a version specifier (eg. <tt>version &gt;= 4.1</tt>)
will return a function that can be used to check the expression and is used by the external package finder.
A version specifier can be a string (<tt>'0.1.2'</tt>) or tuple (<tt>(0, 1, 2)</tt>) with an arbitrary number
of delimeters, or a floating point number (<tt>1.2</tt>).
This allows for example to write <tt><span class="pre">find_external('clang',</span> version &gt;= 3.5)</tt> to discover a clang installation with version 3.5 or later.</p>
<p>Since <tt>find_external</tt> also integrates with <tt><span class="pre">pkg-config</span></tt>, a large number of external packages is
available - in addition to a handful of builtin external packages with special implementation features.
It is also possible to add new packages that are recognized.
A list of the builtin packages is presented in <a href="#externals" rel="nofollow">Externals</a>.</p>
<p>In order to simplify the creation of external packages that already provide a build configuration tool
to query version, linker or compiler options, <strong>pyrate</strong> provides the function:</p>
<ul>
<li><tt>create_external(name, build_helper, <span class="pre">...)</span></tt></li>
</ul>
<p>It requires the user to define a name for the external package and to supply the build configuration tool.
The values of additional parameters are interpreted as command line options for the build configuration tool.
The name of these additional parameters specify the name of the
rule that gets supplied with the flags given by the output of the build configuration tool.
However there are four parameters that have a special meaning:</p>
<ul>
<li><tt>version_query</tt> - similar to the other parameters, the value of this parameter is used as build
configuration tool option to determine the current version of the external package.
As a consequence of providing this option, the resulting external package will support the parameter <tt>version</tt>.</li>
<li><tt>version_parser</tt> - this parameter allows to supply a function that parses the version string
provided by the build configuration tool and is only used if <tt>version_query</tt> is given.</li>
<li><tt>version</tt> - specifies required version (eg. <tt>version = version &gt;= 11.5</tt>) and can only be used if
<tt>version_query</tt> is given</li>
<li><tt>link = opts</tt> is equivalent to specifying <tt>link_shared = opts</tt>, <tt>link_static = opts</tt> and
<tt>link_exe = opts</tt></li>
</ul>
<p>The following example recreates the builtin external package for wxWidgets and returns a representation
of the external package if a matching version is found:</p>
<pre><span class="n">my_wxwidgets</span> <span class="o">=</span> <span class="n">create_external</span><span class="p">(</span><span class="s1">'wxwidgets'</span><span class="p">,</span> <span class="n">build_helper</span> <span class="o">=</span> <span class="s1">'wx-config'</span><span class="p">,</span>
    <span class="n">version_query</span> <span class="o">=</span> <span class="s1">'--version'</span><span class="p">,</span> <span class="n">link</span> <span class="o">=</span> <span class="s1">'--libs'</span><span class="p">,</span> <span class="n">compile_cpp</span> <span class="o">=</span> <span class="s1">'--cxxflags'</span><span class="p">,</span>
    <span class="n">version</span> <span class="o">=</span> <span class="n">version</span> <span class="o">&gt;=</span> <span class="mf">2.8</span><span class="p">)</span>
</pre>
</div>
<div id="configuration-of-the-build-environment">
<h4>Configuration of the build environment</h4>
<p>It is possible to query the current version of <strong>pyrate</strong> via the variable:</p>

<p>this allows to ensure a compatible version of <strong>pyrate</strong> with something along the lines of:</p>
<pre><span class="k">assert</span><span class="p">(</span><span class="n">pyrate_version</span> <span class="o">&gt;</span> <span class="s1">'0.1.8'</span><span class="p">)</span>
</pre>
<p>A build context allows for example to define implicit dependencies that are automatically
included in all generated object files, executables or libraries (via <tt>implicit_*</tt> options).
It is also possible to set base directories for the output generated by the build (via <tt>basepath_*</tt> options).</p>
<p>The default context used by the global functions presented in <a href="#defining-build-targets" rel="nofollow">Defining build targets</a>
can be set or accessed using the variable:</p>
<ul>
<li><tt>default_context = <span class="pre">Context(...)</span></tt></li>
</ul>
<p>An instance of such a build context is created with:</p>
<ul>
<li><tt><span class="pre">Context(...)</span></tt> - the most important parameters are:<ul>
<li><tt>implicit_input</tt>, <tt>implicit_object_input</tt>, <tt>implicit_static_library_input</tt>,
<tt>implicit_shared_library_input</tt> and <tt>implicit_executable_input</tt></li>
<li><tt>basepath</tt>, <tt>basepath_object_file</tt>, <tt>basepath_static_library</tt>, <tt>basepath_shared_libray</tt>,
<tt>basepath_executable</tt></li>
</ul>
</li>
</ul>
<p>These parameters can also be changed on an existing context instance:</p>
<pre><span class="n">default_context</span><span class="o">.</span><span class="n">basepath</span> <span class="o">=</span> <span class="s1">'build'</span>
</pre>
<p>A context also allows to access some additional settings - which are described in
more detail below. These settings are available as member functions of a context or
as global variables (that are provided by the default_context):</p>
<ul>
<li><tt>tools</tt>
This is a dictionary that contains links to external packages that provide the basic rules
and parameters that are used to process sources and generate targets.
This dictionary can be modified, but should not be overwritten.</li>
<li><tt>toolchain</tt>
This is a list of <tt>Toolchain</tt> instances that is used to populate the tools dictionary
in reverse order. There are currently two toolchains available: <tt>gcc</tt> and <tt>llvm</tt>
They can be accessed with the follwing two methods:</li>
<li><tt>find_toolchain(name, <span class="pre">...)</span></tt></li>
<li><tt>use_toolchain(name, <span class="pre">...)</span></tt>
These methods work in the same way as the <tt>find_external</tt> and <tt>use_external</tt> methods.
The available toolchains and their options are presented in <a href="#toolchains" rel="nofollow">Toolchains</a>.
The following example would try to set the clang / clang++ compiler and llvm linker in the tool dictionary</li>
</ul>
<pre><span class="n">use_toolchain</span><span class="p">(</span><span class="s1">'llvm'</span><span class="p">,</span> <span class="n">version</span> <span class="o">&gt;=</span> <span class="mf">3.7</span><span class="p">,</span> <span class="n">cpp_std</span> <span class="o">=</span> <span class="s1">'c++11'</span><span class="p">,</span> <span class="n">cpp_opts</span> <span class="o">=</span> <span class="s1">'-Wall'</span><span class="p">)</span>
<span class="c1"># is the same as</span>
<span class="n">llvm</span> <span class="o">=</span> <span class="n">find_toolchain</span><span class="p">(</span><span class="s1">'llvm'</span><span class="p">,</span> <span class="n">version</span> <span class="o">&gt;=</span> <span class="mf">3.7</span><span class="p">,</span> <span class="n">cpp_std</span> <span class="o">=</span> <span class="s1">'c++11'</span><span class="p">,</span> <span class="n">cpp_opts</span> <span class="o">=</span> <span class="s1">'-Wall'</span><span class="p">)</span>
<span class="k">if</span> <span class="n">llvm</span><span class="p">:</span>
    <span class="n">toolchain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">llvm</span><span class="p">)</span>
</pre>
</div>
<div id="target-collision-avoidance">
<h4>Target Collision Avoidance</h4>
<p>As explained in <a href="#defining-build-targets" rel="nofollow">Defining build targets</a>, <strong>pyrate</strong> will always ensure that targets with different inputs / options but
same name will generate different output files (by appending a hash based suffix as needed).
However it is possible to switch off the renaming of colliding targets for a <strong>unique</strong> target.
Beware: Having two different targets that switch off the renaming with the option
<tt>no_rename = True</tt> will abort the build file generation.
The following build configuration file:</p>
<pre><span class="n">ex1</span> <span class="o">=</span> <span class="n">executable</span><span class="p">(</span><span class="s1">'example.bin'</span><span class="p">,</span> <span class="s1">'test.cpp'</span><span class="p">,</span> <span class="n">compiler_opts</span> <span class="o">=</span> <span class="s1">'-O1'</span><span class="p">)</span>
<span class="n">ex2</span> <span class="o">=</span> <span class="n">executable</span><span class="p">(</span><span class="s1">'example.bin'</span><span class="p">,</span> <span class="s1">'test.cpp'</span><span class="p">,</span> <span class="n">compiler_opts</span> <span class="o">=</span> <span class="s1">'-O2'</span><span class="p">)</span>
<span class="n">ex3</span> <span class="o">=</span> <span class="n">executable</span><span class="p">(</span><span class="s1">'example.bin'</span><span class="p">,</span> <span class="s1">'test.cpp'</span><span class="p">,</span> <span class="n">compiler_opts</span> <span class="o">=</span> <span class="s1">'-O3'</span><span class="p">)</span>
<span class="n">ex4</span> <span class="o">=</span> <span class="n">executable</span><span class="p">(</span><span class="s1">'example.bin'</span><span class="p">,</span> <span class="s1">'test.cpp'</span><span class="p">,</span> <span class="n">compiler_opts</span> <span class="o">=</span> <span class="s1">'-O2'</span><span class="p">,</span> <span class="n">no_rename</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'hash(ex1) = </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">ex1</span><span class="o">.</span><span class="n">get_hash</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'hash(ex2) = </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">ex2</span><span class="o">.</span><span class="n">get_hash</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'hash(ex3) = </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">ex3</span><span class="o">.</span><span class="n">get_hash</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'hash(ex4) = </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">ex4</span><span class="o">.</span><span class="n">get_hash</span><span class="p">())</span>
</pre>
<p>will result (for example in an linux environment) in the generation of <strong>three</strong> object files named
<tt><span class="pre">test_&lt;hash1&gt;.o</span></tt>, <tt><span class="pre">test_&lt;hash2&gt;.o</span></tt>, <tt><span class="pre">test_&lt;hash3&gt;.o</span></tt>, since there are only three different
settings used during the compilation of <tt>test.cpp</tt>.
During the linking step, these object files will generate <strong>three</strong> binaries named
<tt>example.bin</tt>, <tt><span class="pre">example_&lt;hash4&gt;.bin</span></tt>, <tt><span class="pre">example_&lt;hash5&gt;.bin</span></tt>.
Where <tt>example.bin</tt> was compiled with the compiler option ‘-O2’. To identify which
target belongs to which hash, the <tt><span class="pre">&lt;target_obj&gt;.get_hash()</span></tt> function can be used.</p>
<p>However it is <strong>strongly</strong> recommended to always ensure collision free names for executables
and shared / static libraries.</p>
</div>
<div id="buildsource">
<h4>BuildSource</h4>
<p>The build source is the fundamental building block of pyrate. It is modeled by a class <tt>BuildSource</tt>,
which can be constructed with the following code:</p>
<pre><span class="n">BuildSource</span><span class="p">(</span><span class="n">on_use_inputs</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">on_use_deps</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">on_use_variables</span> <span class="o">=</span> <span class="bp">None</span><span class="p">)</span>
</pre>
<p>The three arguments <tt>on_use_inputs</tt>, <tt>on_use_deps</tt> and <tt>on_use_variables</tt> specify how a rule belonging
to a build target should react to having the BuildSource as input. Each argument can be a dictionary, where
the key specifies the rule (a rule name string or <tt>None</tt> to match any rule) and the value specifies for</p>
<ul>
<li><tt>on_use_inputs</tt> a list of objects with <tt>name</tt> attribute that is given as input arguments for the target</li>
<li><tt>on_use_deps</tt> a list of objects with <tt>name</tt> attribute that is specified as dependency of the target</li>
<li><tt>on_use_variables</tt> a dictionary with variables for the target. Probably the most important variable
is <tt>opts</tt>, which is used to supply options to rules</li>
</ul>
<p>Examples for different build sources are:</p>
<ul>
<li>any string that is given as build input is converted into an <tt>InputFile` - a ``BuildSource</tt> that
forwards the specified file name to any rules (using <tt>on_use_inputs</tt>)</li>
<li><tt>Externals</tt> - are a type of <tt>BuildSource</tt> that specify <tt>on_use_variables</tt> among other things</li>
<li>all targets are BuildSources as well - so the result of a <tt>shared_library</tt> call can be used to
link another target against this libray</li>
<li><tt>macro(expr)</tt> - creates a BuildSource that allows to define C/C++ preprocessor macros.</li>
</ul>
</div>
<div id="installing-targets">
<h4>Installing Targets</h4>
<ul>
<li><tt>install(target_list)</tt>
This function will create install targets in the build file to install the given target / list of targets.
In particular an <em>install</em> target will be created that will contain all generated install targets.</li>
</ul>
</div>
<div id="subdirectories">
<h4>Subdirectories</h4>
<ul>
<li><tt>include(build_file_list, inherit = False, target_name = None)</tt>
This function will read in the given build config file(s). If a directory is given
instead of a build config file, <strong>pyrate</strong> will enter the given directory and use the file <tt>build.py</tt>
if available. The parameter <tt>inherit</tt> allows to inherit <tt>basepath_*</tt> and <tt>implicit_*</tt> settings
from the current context. The parameter <tt>target_name</tt> allows to specify the name of the alias that
allows to build all included targets. By default, this target name is derived from the path given in
<tt>build_file_list</tt>.
<em>Current implementation notice - the targets from the included file will be
adapted for proper paths and included in the build output of the main file. The goal is to allow
very loose coupling between the main project and the subsystem projects so each subsystem can
be independently processed without any changes.</em></li>
<li><tt>find_internal(name)</tt>
This function allows to retrieve build targets that were created by <tt>executable</tt>, <tt>shared_library</tt>,
<tt>static_library</tt> and <tt>object_file</tt>. It will match against the user specified name, the installation
name (with platform specific extensions) and the build target name
(derived from the specified <tt>basepath</tt> and <tt><span class="pre">basepath_...</span></tt> and the installation name).
This is in particular useful when trying to specify dependencies one objects included from another file.</li>
</ul>
</div>
</div>
<div id="example">
<h3>Example</h3>
<p>The basic <strong>pyrate</strong> build configuration file for a simple C++ project with a single source file
producing a single executable looks like this:</p>
<pre><span class="n">executable</span><span class="p">(</span><span class="s1">'test'</span><span class="p">,</span> <span class="p">[</span><span class="s1">'test.cpp'</span><span class="p">])</span>
</pre>
<p>A more complicated example is presented in the following code fragment. It demonstrates how to</p>
<ul>
<li>change the default compiler toolchain to llvm (clang / clang++),</li>
<li>define a native static and dynamic library from a set of files selected by wildcards,</li>
<li>generate several executables accessing to the shared library and</li>
<li>generate a wrapper library to access the C++ library from python (if swig is available).</li>
</ul>
<pre><span class="n">use_toolchain</span><span class="p">(</span><span class="s1">'llvm'</span><span class="p">,</span> <span class="n">version</span> <span class="o">&gt;=</span> <span class="mf">3.7</span><span class="p">,</span> <span class="n">cpp_std</span> <span class="o">=</span> <span class="s1">'c++11'</span><span class="p">,</span> <span class="n">cpp_opts</span> <span class="o">=</span> <span class="s1">'-Wall'</span><span class="p">)</span>

<span class="n">lib_files</span> <span class="o">=</span> <span class="n">match</span><span class="p">(</span><span class="s1">'*.cpp -test* -mylib.* -py_foo.cpp'</span><span class="p">)</span>
<span class="n">static_library</span><span class="p">(</span><span class="s1">'libFoo'</span><span class="p">,</span> <span class="n">lib_files</span><span class="p">,</span> <span class="n">compiler_opts</span> <span class="o">=</span> <span class="s1">'-O3'</span><span class="p">)</span>
<span class="n">lib_reference</span> <span class="o">=</span> <span class="n">shared_library</span><span class="p">(</span><span class="s1">'libFoo'</span><span class="p">,</span> <span class="n">lib_files</span><span class="p">)</span>

<span class="n">python</span> <span class="o">=</span> <span class="n">find_external</span><span class="p">(</span><span class="s1">'python'</span><span class="p">,</span> <span class="n">version</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">swig</span> <span class="o">=</span> <span class="n">find_external</span><span class="p">(</span><span class="s1">'swig'</span><span class="p">,</span> <span class="n">version</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">if</span> <span class="n">swig</span> <span class="ow">and</span> <span class="n">python</span><span class="p">:</span>
    <span class="n">swig</span><span class="o">.</span><span class="n">wrapper</span><span class="p">(</span><span class="s1">'python'</span><span class="p">,</span> <span class="s1">'mylib'</span><span class="p">,</span> <span class="s1">'foo.i'</span><span class="p">,</span> <span class="n">libs</span> <span class="o">=</span> <span class="p">[</span><span class="n">lib_reference</span><span class="p">])</span>

<span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">match</span><span class="p">(</span><span class="s1">'test*.cpp'</span><span class="p">):</span>
    <span class="n">executable</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'.cpp'</span><span class="p">,</span> <span class="s1">'.bin'</span><span class="p">),</span> <span class="p">[</span><span class="n">fn</span><span class="p">,</span> <span class="n">lib_reference</span><span class="p">,</span> <span class="n">find_external</span><span class="p">(</span><span class="s1">'pthread'</span><span class="p">)])</span>
</pre>
<p>Many more examples with an increasing level of complexity are available in the <a href="https://github.com/pyrate-build/pyrate-build/tree/master/examples" rel="nofollow">github</a> repository.</p>
</div>
</div></body></html>