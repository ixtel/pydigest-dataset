<html><body><div><div id="introduction">
<h2>Introduction</h2>
<p>Hymn is a monad library for Hy/Python, with do notation for monad
comprehension.</p>
<p>Code are better than words.</p>
<p>The continuation monad</p>
<pre><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="nv">hymn.dsl</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.continuation</span> <span class="p">[</span><span class="nv">cont-m</span> <span class="nv">call-cc</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="c1">;; computations in continuation passing style</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nb">double </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">cont-m.unit</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">length</span> <span class="p">(</span><span class="nf">cont-m.monadic</span> <span class="nv">len</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="c1">;; chain with bind</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.run</span> <span class="p">(</span><span class="nf">&gt;&gt;</span> <span class="p">(</span><span class="nf">cont-m.unit</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span> <span class="nv">length</span> <span class="nv">double</span><span class="p">))</span>
<span class="mi">6</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">square</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nf">call-cc</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">k</span><span class="p">]</span> <span class="p">(</span><span class="nf">k</span> <span class="p">(</span><span class="nf">**</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">)))))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.run</span> <span class="p">(</span><span class="nf">square</span> <span class="mi">12</span><span class="p">))</span>
<span class="mi">144</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.run</span> <span class="p">(</span><span class="nf">square</span> <span class="mi">12</span><span class="p">)</span> <span class="nv">inc</span><span class="p">)</span>
<span class="mi">145</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.run</span> <span class="p">(</span><span class="nf">square</span> <span class="mi">12</span><span class="p">)</span> <span class="nv">str</span><span class="p">)</span>
<span class="ss">'144</span><span class="o">'</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.run</span> <span class="p">(</span><span class="nf">do-monad</span> <span class="p">[</span><span class="nv">sqr</span> <span class="p">(</span><span class="nf">square</span> <span class="mi">42</span><span class="p">)]</span> <span class="p">(</span><span class="nf">.format</span> <span class="s">"answer^2 = {}"</span> <span class="nv">sqr</span><span class="p">)))</span>
<span class="ss">'answer</span><span class="o">^</span><span class="mi">2</span> <span class="nb">= </span><span class="mi">1764</span><span class="o">'</span>
</pre>
<p>The either monad</p>
<pre><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="nv">hymn.dsl</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.either</span> <span class="p">[</span><span class="nv">Left</span> <span class="nv">Right</span> <span class="nv">either</span> <span class="nv">failsafe</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="c1">;; do notation with either monad</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">do-monad</span> <span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nf">Right</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b</span> <span class="p">(</span><span class="nf">Right</span> <span class="mi">2</span><span class="p">)]</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
<span class="nv">Right</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">do-monad</span> <span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nf">Right</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b</span> <span class="p">(</span><span class="nf">Left</span> <span class="ss">'nan</span><span class="p">)]</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
<span class="nv">Left</span><span class="p">(</span><span class="nf">nan</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="c1">;; failsafe is a function decorator that wraps return value into either</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">safe-div</span> <span class="p">(</span><span class="nf">failsafe</span> <span class="nv">/</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="c1">;; returns Right if nothing wrong</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">safe-div</span> <span class="mi">4</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">Right</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="c1">;; returns Left when bad thing happened, like exception being thrown</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">safe-div</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>
<span class="nv">Left</span><span class="p">(</span><span class="nf">ZeroDivisionError</span><span class="p">(</span><span class="ss">'division</span> <span class="nv">by</span> <span class="nv">zero</span><span class="o">'</span>,<span class="p">))</span>
<span class="nv">=&gt;</span> <span class="c1">;; function either tests the value and call functions accordingly</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">either</span> <span class="nb">print inc </span><span class="p">(</span><span class="nf">safe-div</span> <span class="mi">4</span> <span class="mi">2</span><span class="p">))</span>
<span class="mf">3.0</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">either</span> <span class="nb">print inc </span><span class="p">(</span><span class="nf">safe-div</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
<span class="nv">division</span> <span class="nv">by</span> <span class="nv">zero</span>
</pre>
<p>The identity monad</p>
<pre><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="nv">hymn.dsl</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.identity</span> <span class="p">[</span><span class="nv">identity-m</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="c1">;; do notation with identity monad is like let binding</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">do-monad</span> <span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nf">identity-m</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b</span> <span class="p">(</span><span class="nf">identity-m</span> <span class="mi">2</span><span class="p">)]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
<span class="nv">Identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre>
<p>The lazy monad</p>
<pre><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="nv">hymn.dsl</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.lazy</span> <span class="p">[</span><span class="nv">force</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="c1">;; lazy computation implemented as monad</span>
<span class="nv">=&gt;</span> <span class="c1">;; macro lazy create deferred computation</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="nf">lazy</span> <span class="p">(</span><span class="nb">print </span><span class="s">"evaluate a"</span><span class="p">)</span> <span class="mi">42</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="c1">;; the computation is deferred, notice the value is shown as '_'</span>
<span class="nv">=&gt;</span> <span class="nv">a</span>
<span class="nv">Lazy</span><span class="p">(</span><span class="nf">_</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="c1">;; evaluate it</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.evaluate</span> <span class="nv">a</span><span class="p">)</span>
<span class="nv">evaluate</span> <span class="nv">a</span>
<span class="mi">42</span>
<span class="nv">=&gt;</span> <span class="c1">;; now the value is cached</span>
<span class="nv">=&gt;</span> <span class="nv">a</span>
<span class="nv">Lazy</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="c1">;; evaluate again will not trigger the computation</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.evaluate</span> <span class="nv">a</span><span class="p">)</span>
<span class="mi">42</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">b</span> <span class="p">(</span><span class="nf">lazy</span> <span class="p">(</span><span class="nb">print </span><span class="s">"evaluate b"</span><span class="p">)</span> <span class="mi">21</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="nv">b</span>
<span class="nv">Lazy</span><span class="p">(</span><span class="nf">_</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="c1">;; force evaluate the computation, same as calling .evaluate on the monad</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">force</span> <span class="nv">b</span><span class="p">)</span>
<span class="nv">evaluate</span> <span class="nv">b</span>
<span class="mi">21</span>
<span class="nv">=&gt;</span> <span class="c1">;; force on values other than lazy return the value unchanged</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">force</span> <span class="mi">42</span><span class="p">)</span>
<span class="mi">42</span>
<span class="nv">=&gt;</span> <span class="c1">;; do notation with lazy monad</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">c</span> <span class="p">(</span><span class="nf">do-monad</span> <span class="p">[</span><span class="nv">x</span> <span class="p">(</span><span class="nf">lazy</span> <span class="p">(</span><span class="nb">print </span><span class="s">"get x"</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">y</span> <span class="p">(</span><span class="nf">lazy</span> <span class="p">(</span><span class="nb">print </span><span class="s">"get y"</span><span class="p">)</span> <span class="mi">2</span><span class="p">)]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
<span class="nv">=&gt;</span> <span class="c1">;; the computation is deferred</span>
<span class="nv">=&gt;</span> <span class="nv">c</span>
<span class="nv">Lazy</span><span class="p">(</span><span class="nf">_</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="c1">;; do it!</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">force</span> <span class="nv">c</span><span class="p">)</span>
<span class="nb">get </span><span class="nv">x</span>
<span class="nb">get </span><span class="nv">y</span>
<span class="mi">3</span>
<span class="nv">=&gt;</span> <span class="c1">;; again</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">force</span> <span class="nv">c</span><span class="p">)</span>
<span class="mi">3</span>
</pre>
<p>The list monad</p>
<pre><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="nv">hymn.dsl</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.list</span> <span class="p">[</span><span class="nv">list-m</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="c1">;; use list-m contructor to turn sequence into list monad</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">xs</span> <span class="p">(</span><span class="nf">list-m</span> <span class="p">(</span><span class="nb">range </span><span class="mi">2</span><span class="p">)))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">ys</span> <span class="p">(</span><span class="nf">list-m</span> <span class="p">(</span><span class="nb">range </span><span class="mi">3</span><span class="p">)))</span>
<span class="nv">=&gt;</span> <span class="c1">;; do notation with list monad is list comprehension</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">do-monad</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">xs</span> <span class="nv">y</span> <span class="nv">ys</span> <span class="ss">:when</span> <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">zero? </span><span class="nv">y</span><span class="p">))]</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="p">)</span>
<span class="p">[</span><span class="mf">0.0</span>, <span class="mf">0.0</span>, <span class="mf">1.0</span>, <span class="mf">0.5</span><span class="p">]</span>
<span class="nv">=&gt;</span> <span class="c1">;; * is the reader macro for list-m</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">do-monad</span> <span class="p">[</span><span class="nv">x</span> <span class="o">#</span><span class="nv">*</span><span class="p">(</span><span class="nb">range </span><span class="mi">2</span><span class="p">)</span> <span class="nv">y</span> <span class="o">#</span><span class="nv">*</span><span class="p">(</span><span class="nb">range </span><span class="mi">3</span><span class="p">)</span> <span class="ss">:when</span> <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">zero? </span><span class="nv">y</span><span class="p">))]</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="p">)</span>
<span class="p">[</span><span class="mf">0.0</span>, <span class="mf">0.0</span>, <span class="mf">1.0</span>, <span class="mf">0.5</span><span class="p">]</span>
</pre>
<p>The maybe monad</p>
<pre><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="nv">hymn.dsl</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.maybe</span> <span class="p">[</span><span class="nv">Just</span> <span class="nv">Nothing</span> <span class="nv">maybe</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="c1">;; do notation with maybe monad</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">do-monad</span> <span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nf">Just</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b</span> <span class="p">(</span><span class="nf">Just</span> <span class="mi">1</span><span class="p">)]</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
<span class="nv">Just</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="c1">;; Nothing yields Nothing</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">do-monad</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">Nothing</span> <span class="nv">b</span> <span class="p">(</span><span class="nf">Just</span> <span class="mi">1</span><span class="p">)]</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
<span class="nv">Nothing</span>
<span class="nv">=&gt;</span> <span class="c1">;; maybe is a function decorator that wraps return value into maybe</span>
<span class="nv">=&gt;</span> <span class="c1">;; a safe-div with maybe monad</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">safe-div</span> <span class="p">(</span><span class="nf">maybe</span> <span class="nv">/</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">safe-div</span> <span class="mi">42</span> <span class="mi">42</span><span class="p">)</span>
<span class="nv">Just</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">safe-div</span> <span class="mi">42</span> <span class="ss">'answer</span><span class="p">)</span>
<span class="nv">Nothing</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">safe-div</span> <span class="mi">42</span> <span class="mi">0</span><span class="p">)</span>
<span class="nv">Nothing</span>
</pre>
<p>The reader monad</p>
<pre><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="nv">hymn.dsl</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.reader</span> <span class="p">[</span><span class="nv">lookup</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="c1">;; do notation with reader monad, lookup assumes the environment is subscriptable</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">r</span> <span class="p">(</span><span class="nf">do-monad</span> <span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nf">lookup</span> <span class="ss">'a</span><span class="p">)</span> <span class="nv">b</span> <span class="p">(</span><span class="nf">lookup</span> <span class="ss">'b</span><span class="p">)]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
<span class="nv">=&gt;</span> <span class="c1">;; run reader monad r with environment</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.run</span> <span class="nv">r</span> <span class="p">{</span><span class="ss">'a</span> <span class="mi">1</span> <span class="ss">'b</span> <span class="mi">2</span><span class="p">})</span>
<span class="mi">3</span>
</pre>
<p>The state monad</p>
<pre><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="nv">hymn.dsl</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.state</span> <span class="p">[</span><span class="nv">lookup</span> <span class="nv">set-value</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="c1">;; do notation with state monad, set-value sets the value with key in the state</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">s</span> <span class="p">(</span><span class="nf">do-monad</span> <span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nf">lookup</span> <span class="ss">'a</span><span class="p">)</span> <span class="nv">_</span> <span class="p">(</span><span class="nf">set-value</span> <span class="ss">'b</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">a</span><span class="p">))]</span> <span class="nv">a</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="c1">;; run state monad s with initial state</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.run</span> <span class="nv">s</span> <span class="p">{</span><span class="ss">'a</span> <span class="mi">1</span><span class="p">})</span>
<span class="p">(</span>, <span class="mi">1</span> <span class="p">{</span><span class="ss">'a</span> <span class="mi">1</span> <span class="ss">'b</span> <span class="mi">2</span><span class="p">})</span>
</pre>
<p>The writer monad</p>
<pre><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="nv">hymn.dsl</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.writer</span> <span class="p">[</span><span class="nv">tell</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="c1">;; do notation with writer monad</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">do-monad</span> <span class="p">[</span><span class="nv">_</span> <span class="p">(</span><span class="nf">tell</span> <span class="s">"hello"</span><span class="p">)</span> <span class="nv">_</span> <span class="p">(</span><span class="nf">tell</span> <span class="s">" world"</span><span class="p">)]</span> <span class="nv">nil</span><span class="p">)</span>
<span class="nv">StrWriter</span><span class="p">((</span><span class="nf">None</span>, <span class="ss">'hello</span> <span class="nv">world</span><span class="o">'</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="c1">;; int is monoid, too</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.execute</span> <span class="p">(</span><span class="nf">do-monad</span> <span class="p">[</span><span class="nv">_</span> <span class="p">(</span><span class="nf">tell</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">_</span> <span class="p">(</span><span class="nf">tell</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">_</span> <span class="p">(</span><span class="nf">tell</span> <span class="mi">3</span><span class="p">)]</span> <span class="nv">nil</span><span class="p">))</span>
<span class="mi">6</span>
</pre>
<p>Operations on monads</p>
<pre><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="nv">hymn.dsl</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.operations</span> <span class="p">[</span><span class="nv">lift</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="c1">;; lift promotes function into monad</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">m+</span> <span class="p">(</span><span class="nf">lift</span> <span class="nv">+</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="c1">;; lifted function can work on any monad</span>
<span class="nv">=&gt;</span> <span class="c1">;; on the maybe monad</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.maybe</span> <span class="p">[</span><span class="nv">Just</span> <span class="nv">Nothing</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">m+</span> <span class="p">(</span><span class="nf">Just</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">Just</span> <span class="mi">2</span><span class="p">))</span>
<span class="nv">Just</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">m+</span> <span class="p">(</span><span class="nf">Just</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">Nothing</span><span class="p">)</span>
<span class="nv">Nothing</span>
<span class="nv">=&gt;</span> <span class="c1">;; on the either monad</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.either</span> <span class="p">[</span><span class="nv">Left</span> <span class="nv">Right</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">m+</span> <span class="p">(</span><span class="nf">Right</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">Right</span> <span class="mi">2</span><span class="p">))</span>
<span class="nv">Right</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">m+</span> <span class="p">(</span><span class="nf">Left</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">Right</span> <span class="mi">2</span><span class="p">))</span>
<span class="nv">Left</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="c1">;; on the list monad</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.list</span> <span class="p">[</span><span class="nv">list-m</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">m+</span> <span class="p">(</span><span class="nf">list-m</span> <span class="s">"ab"</span><span class="p">)</span> <span class="p">(</span><span class="nf">list-m</span> <span class="s">"123"</span><span class="p">)))</span>
<span class="p">[</span><span class="ss">'a1</span><span class="o">'</span>, <span class="ss">'a2</span><span class="o">'</span>, <span class="ss">'a3</span><span class="o">'</span>, <span class="ss">'b1</span><span class="o">'</span>, <span class="ss">'b2</span><span class="o">'</span>, <span class="ss">'b3</span><span class="o">'</span><span class="p">]</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">m+</span> <span class="p">(</span><span class="nf">list-m</span> <span class="s">"+-"</span><span class="p">)</span> <span class="p">(</span><span class="nf">list-m</span> <span class="s">"123"</span><span class="p">)</span> <span class="p">(</span><span class="nf">list-m</span> <span class="s">"xy"</span><span class="p">)))</span>
<span class="p">[</span><span class="ss">'+1x</span><span class="o">'</span>, <span class="ss">'+1y</span><span class="o">'</span>, <span class="ss">'+2x</span><span class="o">'</span>, <span class="ss">'+2y</span><span class="o">'</span>, <span class="ss">'+3x</span><span class="o">'</span>, <span class="ss">'+3y</span><span class="o">'</span>, <span class="ss">'-1x</span><span class="o">'</span>, <span class="ss">'-1y</span><span class="o">'</span>, <span class="ss">'-2x</span><span class="o">'</span>, <span class="ss">'-2y</span><span class="o">'</span>, <span class="ss">'-3x</span><span class="o">'</span>, <span class="ss">'-3y</span><span class="o">'</span><span class="p">]</span>
<span class="nv">=&gt;</span> <span class="c1">;; can be used as normal function</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">reduce </span><span class="nv">m+</span> <span class="p">[(</span><span class="nf">Just</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">Just</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">Just</span> <span class="mi">3</span><span class="p">)])</span>
<span class="nv">Just</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">reduce </span><span class="nv">m+</span> <span class="p">[(</span><span class="nf">Just</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">Nothing</span> <span class="p">(</span><span class="nf">Just</span> <span class="mi">3</span><span class="p">)])</span>
<span class="nv">Nothing</span>
<span class="nv">=&gt;</span> <span class="c1">;; &lt;- is an alias of lookup</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.reader</span> <span class="p">[</span><span class="nv">&lt;-</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="c1">;; ^ is the reader macro for lift</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">p</span> <span class="p">(</span><span class="o">#^</span><span class="nb">print </span><span class="p">(</span><span class="nf">&lt;-</span> <span class="ss">'message</span><span class="p">)</span> <span class="ss">:end</span> <span class="p">(</span><span class="nf">&lt;-</span> <span class="ss">'end</span><span class="p">)))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.run</span> <span class="nv">p</span> <span class="p">{</span><span class="ss">'message</span> <span class="s">"Hello world"</span> <span class="ss">'end</span> <span class="s">"!\n"</span><span class="p">})</span>
<span class="nv">Hello</span> <span class="nv">world!</span>
<span class="nv">=&gt;</span> <span class="c1">;; random number - linear congruential generator</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.state</span> <span class="p">[</span><span class="nv">get-state</span> <span class="nv">set-state</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">random</span> <span class="p">(</span><span class="nf">&gt;&gt;</span> <span class="nv">get-state</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">s</span><span class="p">]</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">s</span> <span class="p">(</span><span class="nb">* </span><span class="mi">69069</span><span class="p">)</span> <span class="nb">inc </span><span class="p">(</span><span class="nf">%</span> <span class="p">(</span><span class="nf">**</span> <span class="mi">2</span> <span class="mi">32</span><span class="p">))</span> <span class="nv">set-state</span><span class="p">))))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.run</span> <span class="nv">random</span> <span class="mi">1234</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1234</span>, <span class="mi">85231147</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="c1">;; random can be even shorter by using modify</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.state</span> <span class="p">[</span><span class="nv">modify</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">random</span> <span class="p">(</span><span class="nf">modify</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">s</span><span class="p">]</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">s</span> <span class="p">(</span><span class="nb">* </span><span class="mi">69069</span><span class="p">)</span> <span class="nb">inc </span><span class="p">(</span><span class="nf">%</span> <span class="p">(</span><span class="nf">**</span> <span class="mi">2</span> <span class="mi">32</span><span class="p">))))))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.run</span> <span class="nv">random</span> <span class="mi">1234</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1234</span>, <span class="mi">85231147</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="c1">;; use replicate to do computation repeatly</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.operations</span> <span class="p">[</span><span class="nv">replicate</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.evaluate</span> <span class="p">(</span><span class="nb">replicate </span><span class="mi">5</span> <span class="nv">random</span><span class="p">)</span> <span class="mi">42</span><span class="p">)</span>
<span class="p">[</span><span class="mi">42</span>, <span class="mi">2900899</span>, <span class="mi">2793697416</span>, <span class="mi">2186085609</span>, <span class="mi">1171637142</span><span class="p">]</span>
<span class="nv">=&gt;</span> <span class="c1">;; sequence on writer monad</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.operations</span> <span class="p">[</span><span class="nv">sequence</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">hymn.types.writer</span> <span class="p">[</span><span class="nv">tell</span><span class="p">]])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.execute</span> <span class="p">(</span><span class="nf">sequence</span> <span class="p">(</span><span class="nb">map </span><span class="nv">tell</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="mi">101</span><span class="p">))))</span>
<span class="mi">5050</span>
</pre>
<p>Using Hymn in Python</p>
<pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">hymn.dsl</span> <span class="kn">import</span> <span class="o">*</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sequence</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">tell</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">)))</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
<span class="mi">5050</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">msum</span> <span class="o">=</span> <span class="n">lift</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">msum</span><span class="p">(</span><span class="n">sequence</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">maybe</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="s2">"12345"</span><span class="p">)))</span>
<span class="n">Just</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">msum</span><span class="p">(</span><span class="n">sequence</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">maybe</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="s2">"12345a"</span><span class="p">)))</span>
<span class="n">Nothing</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nd">@failsafe</span>
<span class="o">...</span> <span class="k">def</span> <span class="nf">safe_div</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">safe_div</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Right</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">safe_div</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">Left</span><span class="p">(</span><span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
</pre>
</div>
</div></body></html>