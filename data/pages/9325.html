<html><body><div><div class="entry-content">
                    <p>In my previous <a class="reference external" href="http://pydanny.com/pytest-no-boilerplate-testing-2.html">blog post</a> I covered writing exception-based assertions and fixtures. Today I'm going to close things out by demonstrating how to change the behavior of <a class="reference external" href="http://pytest.org/">pytest</a> and how to integrate it with <strong>Django</strong> and <tt class="docutils literal">setup.py</tt>.</p>
<div class="section" id="changing-the-behavior-of-pytest">
<h2>Changing the Behavior of <strong>pytest</strong></h2>
<p>When <strong>pytest</strong> is called, either via the command-line or by <tt class="docutils literal">pytest.main()</tt>, it <a class="reference external" href="http://pytest.org/latest/customize.html#how-test-configuration-is-read-from-configuration-ini-files">looks for a configuration file</a> called either <tt class="docutils literal">pytest.ini</tt>, <tt class="docutils literal">tox.ini</tt>, and <tt class="docutils literal">setup.cfg</tt>. If it finds a configuration file, it follows standard practices for those things. In the following example, I demonstrating searching for tests inside of all Python files while ignoring the <strong>_build</strong> directories:</p>
<div class="highlight"><pre><span class="c1"># pytest.ini (or tox.ini or setup.cfg)</span>
<span class="err">[pytest]</span> <span class="c1"># You must put pytest-related controls in a 'pytest' block</span>
<span class="na">python_files</span><span class="o">=</span><span class="s">*.py  # Run tests against all python modules</span>
<span class="na">norecursedirs</span> <span class="o">=</span> <span class="s">_build # Don't look inside of _build directories</span>
</pre></div>
<div class="section" id="changing-pytest-behavior-dynamically">
<h3>Changing <strong>pytest</strong> Behavior Dynamically</h3>
<p>This is pretty nice, but if I need to ignore certain Python modules like <tt class="docutils literal">setup.py</tt>? I can do this by creating a <tt class="docutils literal">conftest.py</tt> module and defining a <tt class="docutils literal">collect_ignore</tt> variable.</p>
<div class="highlight"><pre><span class="c"># conftest.py</span>
<span class="n">collect_ignore</span> <span class="o">=</span> <span class="p">[</span><span class="s">"setup.py"</span><span class="p">,</span> <span class="s">"conftest.py"</span><span class="p">]</span>
</pre></div>
<p>The <tt class="docutils literal">conftest.py</tt> module can actually be defined per directory. So if test behavior needs to change in different packages, just create additional <tt class="docutils literal">conftest.py</tt> modules. It's simple to do, but really powerful.</p>
<p>The <tt class="docutils literal">conftest</tt> module is capable of a lot of other things. Right now there doesn't seem to be a page that documents it in full, so I'm considering submitting a documentation pull request. In the meantime, I live off the <tt class="docutils literal">conftest.py</tt> <a class="reference external" href="http://pytest.org/latest/search.html?q=conftest&amp;check_keywords=yes&amp;area=default">search results</a>.</p>
</div>
<div class="section" id="pytest-is-plug-in-driven">
<h3><strong>pytest</strong> is Plug-In Driven</h3>
<p>One feature I really like about <strong>pytest</strong> is that much of it's default capabilities are driven by about 20 plug-ins. It's a sign of maturity that not only does it have plug-ins, but that most of the time this feature is transparent. You can add new plug-ins to your project in a <a class="reference external" href="http://pytest.org/latest/plugins.html#plugin-discovery-order-at-tool-startup">number of ways</a>, including <tt class="docutils literal">pip</tt> installation from <a class="reference external" href="https://pypi.python.org/pypi/">PyPI</a>. For locally defined plug-ins I prefer to rely on explicit <tt class="docutils literal">conftest.py</tt> declarations:</p>
<div class="highlight"><pre><span class="c"># conftest.py</span>
<span class="n">collect_ignore</span> <span class="o">=</span> <span class="p">[</span><span class="s">"setup.py"</span><span class="p">,</span> <span class="s">"conftest.py"</span><span class="p">]</span>
<span class="n">pytest_plugins</span> <span class="o">=</span> <span class="p">[</span><span class="s">"dream_plugin"</span><span class="p">,</span> <span class="s">"dream.utils.testplugin"</span><span class="p">]</span>
</pre></div>
<p>There are a lot of <a class="reference external" href="https://pypi.python.org/pypi?%3Aaction=search&amp;term=pytest-&amp;submit=search">third-party pytest plug-ins</a>, which brings me to the next major section: Integration with other tools and frameworks.</p>
</div>
</div>
<div class="section" id="django-integration-is-just-a-plug-in-away">
<h2>Django Integration is Just a Plug-In Away</h2>
<p>If you want to use <strong>pytest</strong> instead of <strong>Django</strong>'s test runner and also get the power of function-based tests, fixture functions, improved test discover, and all the stuff I haven't covered, then check out and/or <tt class="docutils literal">pip</tt> install <a class="reference external" href="https://pypi.python.org/pypi/pytest-django">pytest-django</a>. My <em>admittedly brief</em> usage on some of my existing projects has demonstrating that my existing <strong>unittest</strong>-style tests work.</p>
<p>That previous tests still function means that as with a pure Python project, I can rely on existing <strong>unittests</strong> and write all my new tests as functions. I guess I could say that my existing Django projects just got much easier to maintain.</p>
<p>A good example of using <strong>pytest</strong> with <strong>Django</strong> can be found in <a class="reference external" href="https://github.com/brack3t/django-braces/blob/master/tox.ini">django-braces' tox.ini file</a>.</p>
<div class="section" id="twisted-and-more-integration-is-just-a-plug-in-away">
<h3>Twisted (and more) Integration is Just a Plug-In Away</h3>
<p>The same goes for <a class="reference external" href="http://twistedmatrix.com/">Twisted</a> thanks to <a class="reference external" href="https://pypi.python.org/pypi/pytest-twisted">pytest-twisted</a>. There is also a <a class="reference external" href="http://www.pylonsproject.org/">Pyramid</a> plug-in that was just <a class="reference external" href="https://pypi.python.org/pypi/pytest_pyramid">released</a>. I'm not sure if <a class="reference external" href="http://flask.pocoo.org/">Flask</a> needs it, but I guess there will be <strong>Flask</strong> plug-in soon.</p>
</div>
</div>

<div class="section" id="summary">
<h2>Summary</h2>
<p>Tests are an important part of any project. While they increase the stability of a project, that unfortunately can come at the cost of the boredom of writing tests. Fortunately, <strong>pytest</strong> goes a long way to alleviating that boredom while also empowering Python code authors with lots of additional useful tools. I'm delighted to have finally discovered <strong>pytest</strong>. In the short time I've used <strong>pytest</strong>, it's saved me days, if not weeks, of tedious work.</p>
</div>

                    
                </div>
                                </div></body></html>