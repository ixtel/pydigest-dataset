<html><body><div><div class="entry-content clearfix"><p><em>The following is a collaboration piece between Cam Linke, co-founder of <a href="http://startupedmonton.com/">Startup Edmonton</a>, and the folks at Real Python.</em></p>

<p><strong>Updated 02/22/2015:</strong> Added Python 3 support.</p>




<p><strong>In this section we’re going to get our database set up to store the results of our word counts. Along the way we’ll set up a Postgres database, add SQLAlchemy to our app for use as an ORM, and use Alembic for our data migrations.</strong></p>

<p>Remember, here’s what we’re building: A Flask app that calculates word-frequency pairs based on the text from a given URL. This is a full-stack tutorial.</p>

<ol>
<li><a href="http://www.realpython.com/blog/python/flask-by-example-part-1-project-setup">Part One</a>: Setup a local development environment and then deploy both a staging environment and a production environment on Heroku.</li>
<li><strong>Part Two: Setup a PostgreSQL database along with SQLAlchemy and Alembic to handle migrations. (current)</strong></li>
<li><a href="https://realpython.com/blog/python/flask-by-example-part-3-text-processing-with-requests-beautifulsoup-nltk/">Part Three</a>: Add in the back-end logic to scrape and then process the counting of words from a webpage using the requests, BeautifulSoup, and Natural Language Toolkit (NLTK) libraries.</li>
<li><a href="https://realpython.com/blog/python/flask-by-example-implementing-a-redis-task-queue/">Part Four</a>: Implement a Redis task queue to handle the text processing.</li>
<li><a href="https://realpython.com/blog/python/flask-by-example-integrating-flask-and-angularjs/">Part Five</a>: Setup Angular on the front-end to continuously poll the back-end to see if the request is done.</li>
<li><a href="https://realpython.com/blog/python/updating-the-staging-environment/">Part Six</a>: Push to the staging server on Heroku – setting up Redis, detailing how to run two processes (web and worker) on a single Dyno.</li>
<li><a href="https://realpython.com/blog/python/flask-by-example-updating-the-ui/">Part Seven</a>: Update the front-end to make it more user-friendly.</li>
<li>Part Eight: Add the D3 library into the mix to graph a frequency distribution and histogram.</li>
</ol>


<blockquote><p>Need the code? Grab it from the <a href="https://github.com/realpython/flask-by-example/releases">repo</a>.</p></blockquote>

<a name="Install.Requirements"/>
<h2>Install Requirements</h2>

<p>Tools we’ll use in this part:</p>




<p>To get started install Postgres on your local computer if you don’t have it already. Since Heroku uses Postgres it will be good for us to develop locally on the same database. If you don’t have Postgres installed, <a href="http://postgresapp.com/">Postgres.app</a> is an easy way to get up and running quick for Mac OSX users. Once you have Postgres installed and running, create a database called <em>wordcount_dev</em> to use as our local development database. In order to use our newly created database in the Flask app we’re going to need to install a few things:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>workon wordcounts
</span><span class="line"><span class="nv">$ </span>pip install psycopg2 Flask-SQLAlchemy Flask-Migrate
</span><span class="line"><span class="nv">$ </span>pip freeze &gt; requirements.txt
</span></code></pre></td></tr></table></div></figure>


<p>Psycopg is a Python adapter for Postgres, SQLAlchemy is an awesome Python ORM, and Flask-Migrate will install both that extension and Alembic which we’ll use for our database migrations.</p>

<blockquote><p>If you’re on Mavericks and having trouble installing psycopg2 check out <a href="http://stackoverflow.com/questions/22313407/clang-error-unknown-argument-mno-fused-madd-python-package-installation-fa">this</a> Stack Overflow article.</p></blockquote>

<a name="Update.Configuration"/>
<h2>Update Configuration</h2>

<p>Add <code>SQLALCHEMY_DATABASE_URI</code> field to the <code>Config()</code> class in your <em>config.py</em> file to set your app to use the newly created database in development (local), staging, and production:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">import</span> <span class="nn">os</span>
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">Config</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class="line">    <span class="o">...</span>
</span><span class="line">    <span class="n">SQLALCHEMY_DATABASE_URI</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'DATABASE_URL'</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Your <em>config.py</em> file should now look like this:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">import</span> <span class="nn">os</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">Config</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class="line">    <span class="n">DEBUG</span> <span class="o">=</span> <span class="bp">False</span>
</span><span class="line">    <span class="n">TESTING</span> <span class="o">=</span> <span class="bp">False</span>
</span><span class="line">    <span class="n">CSRF_ENABLED</span> <span class="o">=</span> <span class="bp">True</span>
</span><span class="line">    <span class="n">SECRET_KEY</span> <span class="o">=</span> <span class="s">'this-really-needs-to-be-changed'</span>
</span><span class="line">    <span class="n">SQLALCHEMY_DATABASE_URI</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'DATABASE_URL'</span><span class="p">]</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">ProductionConfig</span><span class="p">(</span><span class="n">Config</span><span class="p">):</span>
</span><span class="line">    <span class="n">DEBUG</span> <span class="o">=</span> <span class="bp">False</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">StagingConfig</span><span class="p">(</span><span class="n">Config</span><span class="p">):</span>
</span><span class="line">    <span class="n">DEVELOPMENT</span> <span class="o">=</span> <span class="bp">True</span>
</span><span class="line">    <span class="n">DEBUG</span> <span class="o">=</span> <span class="bp">True</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">DevelopmentConfig</span><span class="p">(</span><span class="n">Config</span><span class="p">):</span>
</span><span class="line">    <span class="n">DEVELOPMENT</span> <span class="o">=</span> <span class="bp">True</span>
</span><span class="line">    <span class="n">DEBUG</span> <span class="o">=</span> <span class="bp">True</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">TestingConfig</span><span class="p">(</span><span class="n">Config</span><span class="p">):</span>
</span><span class="line">    <span class="n">TESTING</span> <span class="o">=</span> <span class="bp">True</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now when our config is loaded into our app the appropriate database will be connected to it as well.</p>

<p>Similar to how we added an environment variable in the last post, we are going to add a <code>DATABASE_URL</code> variable to our <em>postactivate</em> file (located at <code>$VIRTUAL_ENV/bin/postactivate</code>).</p>

<p>Your postactivate should look like:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="err">$</span><span class="n">cat</span> <span class="err">$</span><span class="n">VIRTUAL_ENV</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">postactivate</span>
</span><span class="line"><span class="c">#!/bin/bash</span>
</span><span class="line">
</span><span class="line"><span class="n">export</span> <span class="n">APP_SETTINGS</span><span class="o">=</span><span class="s">"config.DevelopmentConfig"</span>
</span><span class="line"><span class="n">export</span> <span class="n">DATABASE_URL</span><span class="o">=</span><span class="s">"postgresql://localhost/wordcount_dev"</span>
</span></code></pre></td></tr></table></div></figure>


<p>Restart your environment:</p>

<figure class="code"><figcaption><span/></figcaption></figure>


<p>In your <em>app.py</em> file import SQLAlchemy and connect to the database:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
</span><span class="line"><span class="kn">from</span> <span class="nn">flask.ext.sqlalchemy</span> <span class="kn">import</span> <span class="n">SQLAlchemy</span>
</span><span class="line"><span class="kn">import</span> <span class="nn">os</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
</span><span class="line"><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'APP_SETTINGS'</span><span class="p">])</span>
</span><span class="line"><span class="n">db</span> <span class="o">=</span> <span class="n">SQLAlchemy</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kn">from</span> <span class="nn">models</span> <span class="kn">import</span> <span class="n">Result</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
</span><span class="line"><span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
</span><span class="line">    <span class="k">return</span> <span class="s">"Hello World!"</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="nd">@app.route</span><span class="p">(</span><span class="s">'/&lt;name&gt;'</span><span class="p">)</span>
</span><span class="line"><span class="k">def</span> <span class="nf">hello_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
</span><span class="line">    <span class="k">return</span> <span class="s">"Hello {}!"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
</span><span class="line">    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<a name="Model"/>
<h2>Model</h2>

<p>Set up a basic model to hold the results of the wordcount by adding a <em>models.py</em> file:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">from</span> <span class="nn">app</span> <span class="kn">import</span> <span class="n">db</span>
</span><span class="line"><span class="kn">from</span> <span class="nn">sqlalchemy.dialects.postgresql</span> <span class="kn">import</span> <span class="n">JSON</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">Result</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
</span><span class="line">    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s">'results'</span>
</span><span class="line">
</span><span class="line">    <span class="nb">id</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</span><span class="line">    <span class="n">url</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">String</span><span class="p">())</span>
</span><span class="line">    <span class="n">result_all</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">JSON</span><span class="p">)</span>
</span><span class="line">    <span class="n">result_no_stop_words</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">JSON</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">result_all</span><span class="p">,</span> <span class="n">result_no_stop_words</span><span class="p">):</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">result_all</span> <span class="o">=</span> <span class="n">result_all</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">result_no_stop_words</span> <span class="o">=</span> <span class="n">result_no_stop_words</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="k">return</span> <span class="s">'&lt;id {}&gt;'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>What we’re doing here is creating a table to store the results of our word counts. We first import the database connection that we created in our <em>app.py</em> file as well as JSON from SQLAlchemy’s <a href="http://docs.sqlalchemy.org/en/latest/dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON">PostgreSQL dialects</a>. JSON columns are fairly new to Postgres and are not available in every database supported by SQLAlchemy so we need to import it specifically.</p>

<p>Next we create a <code>Result()</code> class and assign it a table name of <code>results</code>. We then set the attributes that we want to store for a result – the <code>id</code> of the result we stored, the <code>url</code> that we counted the words from, a full list of words that we counted, and a list of words that we counted minus stop words (more on this later).</p>

<p>We then create an <code>__init__()</code> method that will run the first time we create a new result and, finally, a <code>__repr__()</code> method to represent the object when we query for it.</p>

<a name="Local.Migration"/>
<h2>Local Migration</h2>

<p>We are going to use <a href="https://alembic.readthedocs.org/">Alembic</a> and <a href="https://flask-migrate.readthedocs.org/">Flask-Migrate</a> to migrate our database to the latest version. Alembic is migration library for SQLAlchemy and could be used without Flask-Migrate if you want. However Flask-Migrate does help with some of the setup and makes things easier.</p>

<p>Create a new file called <em>manage.py</em>:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">from</span> <span class="nn">flask.ext.script</span> <span class="kn">import</span> <span class="n">Manager</span>
</span><span class="line"><span class="kn">from</span> <span class="nn">flask.ext.migrate</span> <span class="kn">import</span> <span class="n">Migrate</span><span class="p">,</span> <span class="n">MigrateCommand</span>
</span><span class="line"><span class="kn">import</span> <span class="nn">os</span>
</span><span class="line">
</span><span class="line"><span class="kn">from</span> <span class="nn">app</span> <span class="kn">import</span> <span class="n">app</span><span class="p">,</span> <span class="n">db</span>
</span><span class="line"><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'APP_SETTINGS'</span><span class="p">])</span>
</span><span class="line">
</span><span class="line"><span class="n">migrate</span> <span class="o">=</span> <span class="n">Migrate</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span>
</span><span class="line"><span class="n">manager</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">manager</span><span class="o">.</span><span class="n">add_command</span><span class="p">(</span><span class="s">'db'</span><span class="p">,</span> <span class="n">MigrateCommand</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
</span><span class="line">    <span class="n">manager</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>In order to use Flask-Migrate we need to import <code>Manager</code> as well as <code>Migrate</code> and <code>MigrateCommand</code> to our <em>manage.py</em> file. We also import <code>app</code> and <code>db</code> so we have access to them within the script.</p>

<p>First we set our config to get our environment – based on the environment variable – and create a migrate instance with <code>app</code> and <code>db</code> as the arguments and set up a <code>manager</code> command to initialize a <code>Manager</code> instance for our app. Finally we add the <code>db</code> command to our manager so that we can run our migrations from the command line.</p>

<p>In order to run our migrations initialize Alembic:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>python manage.py db init
</span><span class="line">  Creating directory /Users/michael/repos/realpython/flask-by-example/migrations ... <span class="k">done</span>
</span><span class="line"><span class="k">  </span>Creating directory /Users/michael/repos/realpython/flask-by-example/migrations/versions ... <span class="k">done</span>
</span><span class="line"><span class="k">  </span>Generating /Users/michael/repos/realpython/flask-by-example/migrations/alembic.ini ... <span class="k">done</span>
</span><span class="line"><span class="k">  </span>Generating /Users/michael/repos/realpython/flask-by-example/migrations/env.py ... <span class="k">done</span>
</span><span class="line"><span class="k">  </span>Generating /Users/michael/repos/realpython/flask-by-example/migrations/README ... <span class="k">done</span>
</span><span class="line"><span class="k">  </span>Generating /Users/michael/repos/realpython/flask-by-example/migrations/script.py.mako ... <span class="k">done</span>
</span><span class="line"><span class="k">  </span>Please edit configuration/connection/logging settings in <span class="s1">'/Users/michael/repos/realpython/flask-by-</span>
</span><span class="line"><span class="s1">  example/migrations/alembic.ini'</span> before proceeding.
</span></code></pre></td></tr></table></div></figure>


<p>After you run the database initialization you will see a new folder called “migrations” in the project. This holds the setup necessary for Alembic to run migrations on the project. Inside of “migrations” you will see that it has a folder called “versions”, containing the migration scripts as they are created.</p>

<p>Let’s create our first migration by running the <code>migrate</code> command.</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>python manage.py db migrate
</span><span class="line">  INFO  <span class="o">[</span>alembic.migration<span class="o">]</span> Context impl PostgresqlImpl.
</span><span class="line">  INFO  <span class="o">[</span>alembic.migration<span class="o">]</span> Will assume transactional DDL.
</span><span class="line">  INFO  <span class="o">[</span>alembic.autogenerate.compare<span class="o">]</span> Detected added table <span class="s1">'results'</span>
</span><span class="line">  Generating /Users/michael/repos/realpython/flask-by-example/migrations/versions/53c94f1fe77_.py ... <span class="k">done</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now you’ll notice in your “versions” folder there is a migration file. This file is autogenerated by Alembic based on the model. You could generate (or edit) this file yourself; however, for a lot of cases the autogenerated file will do.</p>

<p>Now we’ll apply our upgrades to our database using the <code>db upgrade</code> command:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>python manage.py db upgrade
</span><span class="line">  INFO  <span class="o">[</span>alembic.migration<span class="o">]</span> Context impl PostgresqlImpl.
</span><span class="line">  INFO  <span class="o">[</span>alembic.migration<span class="o">]</span> Will assume transactional DDL.
</span><span class="line">  INFO  <span class="o">[</span>alembic.migration<span class="o">]</span> Running upgrade  -&gt; 53c94f1fe77, empty message
</span></code></pre></td></tr></table></div></figure>


<p>Our database is now ready for us to use in our app.</p>

<a name="Remote.Migration"/>
<h2>Remote Migration</h2>

<p>Finally, let’s apply the migrations to our Heroku databases. First, though, we need to add the details of our staging and production databases to our <em>config.py</em> file. To check if you have a database set up on your staging server run:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>heroku config --app wordcounts-stage
</span><span class="line"><span class="o">===</span> wordcount-stage Config Vars
</span><span class="line">APP_SETTINGS: config.StagingConfig
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>Make sure to replace <code>wordcount-stage</code> with the name of your staging app.</p></blockquote>

<p>Since we don’t see anything about a database, we need to add the Postgres addon to the staging server. To do so, run the following command to add the Postgres addon to your Heroku app:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>heroku addons:create heroku-postgresql:hobby-dev --app wordcounts-stage
</span><span class="line">  Adding heroku-postgresql:dev on wordcount-stage... <span class="k">done</span>, v8 <span class="o">(</span>free<span class="o">)</span>
</span><span class="line">  Attached as HEROKU_POSTGRESQL_AMBER_URL
</span><span class="line">  Database has been created and is available
</span><span class="line">   ! This database is empty. If upgrading, you can transfer
</span><span class="line">   ! data from another database with pgbackups:restore.
</span><span class="line">  Use <span class="sb">`</span>heroku addons:docs heroku-postgresql:dev<span class="sb">`</span> to view documentation.
</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>NOTE</strong>: <code>hobby-dev</code> is the <a href="https://addons.heroku.com/heroku-postgresql#hobby-dev">free tier</a> Heroku Postgres addon.</p></blockquote>

<p>Now when we run Heroku config again we should see the connection settings for our URL.</p>

<p>For example:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line">APP_SETTINGS:               config.StagingConfig
</span><span class="line">DATABASE_URL:               postgres://srxgxusbbyadyc:8NA0X-zdGZfPwPhfOtLuLZ5hzI@ec2-54-221-243-6.compute-1.amazonaws.com:5432/d7j5r8c30kbvuh
</span><span class="line">HEROKU_POSTGRESQL_CYAN_URL: postgres://srxgxusbbyadyc:8NA0X-zdGZfPwPhfOtLuLZ5hzI@ec2-54-221-243-6.compute-1.amazonaws.com:5432/d7j5r8c30kbvuh
</span></code></pre></td></tr></table></div></figure>


<p>Next we need to commit the changes that you’ve made to git and push to your staging server:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>git push stage master
</span></code></pre></td></tr></table></div></figure>


<p>Run the migrations that we created to migrate our staging database. We do this by using the <code>heroku run</code> command to run python scripts within our Heroku app. We will use this to run the same <code>db upgrade</code> command from our <em>manage.py</em> file.</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>heroku run python manage.py db upgrade --app wordcounts-stage
</span><span class="line">  Running <span class="sb">`</span>python manage.py db upgrade<span class="sb">`</span> attached to terminal... up, run.4755
</span><span class="line">  INFO  <span class="o">[</span>alembic.migration<span class="o">]</span> Context impl PostgresqlImpl.
</span><span class="line">  INFO  <span class="o">[</span>alembic.migration<span class="o">]</span> Will assume transactional DDL.
</span><span class="line">  INFO  <span class="o">[</span>alembic.migration<span class="o">]</span> Running upgrade None -&gt; 20ff8063fe45, empty message
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>Notice how we only ran the upgrade, not the <code>init</code> or <code>migrate</code> commands like before. We already have our migration setup and ready to go, we only need to run it on our Heroku database.</p></blockquote>

<p>Let’s now do the same for our production site. Set up a database for your production app on Heroku, just like you did for staging. Push your changes to your production site. Notice how you don’t have to make any changes to the config file – it’s setting the database based on the newly created <code>DATABASE_URL</code> environment variable.</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>heroku addons:create heroku-postgresql:hobby-dev --app wordcounts-pro
</span><span class="line"><span class="nv">$ </span>git push pro master
</span><span class="line"><span class="nv">$ </span>heroku run python manage.py db upgrade --app wordcounts-pro
</span></code></pre></td></tr></table></div></figure>


<p>Now both our staging and production sites have their databases set up and are migrated – and ready to go!</p>

<blockquote><p>When you apply a new migration to your production database, there could be down time. If this is an issue, you can setup database replication by adding a “follower” (commonly known as a slave) database. For more on this, check out the official Heroku <a href="https://devcenter.heroku.com/articles/heroku-postgres-follower-databases">documentation</a>.</p></blockquote>

<a name="Sanity.Check"/>
<h2>Sanity Check</h2>

<p>Remember in Part 1, when we tested the environment variables to make sure the right environment was being detected by adding a print statement to <em>app.py</em> – <code>print(os.environ['APP_SETTINGS'])</code>? Well, let’s do the same thing, but test the Database URIs by adding a <code>print</code> function to the bottom of <em>config.py</em>:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">print</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'DATABASE_URL'</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now let’s test.</p>

<p><strong>Local</strong>:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="err">$</span> <span class="n">python</span> <span class="n">config</span><span class="o">.</span><span class="n">py</span>
</span><span class="line"><span class="n">postgresql</span><span class="p">:</span><span class="o">//</span><span class="n">localhost</span><span class="o">/</span><span class="n">wordcount_dev</span>
</span></code></pre></td></tr></table></div></figure>


<p>Commit and push again to staging and production. Now let’s test it out…</p>

<p><strong>Staging</strong>:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>heroku run python config.py  --app wordcounts-stage
</span><span class="line">Running <span class="sb">`</span>python config.py<span class="sb">`</span> attached to terminal... up, run.1572
</span><span class="line">postgres://eccqpmccvlokrj:d0iLgQB8naQ2Pg8HL4q61G9gOd@ec2-54-235-250-41.compute-1.amazonaws.com:5432/dep90ehmacu89e
</span></code></pre></td></tr></table></div></figure>


<p><strong>Production</strong>:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>heroku run python config.py  --app wordcounts-pro
</span><span class="line">Running <span class="sb">`</span>python config.py<span class="sb">`</span> attached to terminal... up, run.3993
</span><span class="line">postgres://rsjezmhdfavadr:_ams4r9uEHXcGCZOcnDqqD6Pxs@ec2-54-235-250-41.compute-1.amazonaws.com:5432/d6dpkb5kmd7bg9
</span></code></pre></td></tr></table></div></figure>


<p>The URIs for the staging and production should match the URIs displayed when we ran the <code>heroku</code> config commands. Test this out again:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>heroku config --app wordcounts-stage
</span></code></pre></td></tr></table></div></figure>


<p>and</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>heroku config --app wordcount-pro
</span></code></pre></td></tr></table></div></figure>


<a name="Conclusion"/>
<h2>Conclusion</h2>

<p>That’s it for part 2. I hope database migrations make better sense now. Please comment below with questions. In <a href="https://realpython.com/blog/python/flask-by-example-part-3-text-processing-with-requests-beautifulsoup-nltk/">Part 3</a> we’re going to build the word counting functionality and have it sent to a request queue to deal with the longer running wordcount processing. See you next time. Cheers!</p>

<p>Don’t forget to remove the print statement from the config file when done, commit, and then push back up to your various environments.</p>
</div>


      </div></body></html>