<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/getpro/habr/post_images/346/c8c/f1c/346c8cf1c996a2065a3f4528f678b725.png" alt="image"/>

<blockquote>Предлагаю всем джангистам/алхимистам немного отвечься и почитать вольную интерпретацию вводного туториала и частично документации по Peewee – stand-alone ORM, обязательной к ознакомлению любому питонщику и, в особенности, фласкеру. Пишут о ней мало, а зря. С Peewee очень просто подружиться, особенно если вы уже знакомы с какой-нибудь ORM на ActiveRecord. Что более важно – с ней приятно дружить :) Ну, начнём.</blockquote>

<div class="spoiler"><b class="spoiler_title">Установка</b><div class="spoiler_text"><p>С pip:</p>
<pre><code class="python">pip install peewee
</code></pre>
<p>
Из репозитория:
</p><pre><code class="python">git clone https://github.com/coleifer/peewee.git cd peewee python setup.py install
</code></pre>
<p>
Тесты:
</p><pre><code class="python">python setup.py test
</code></pre>
<p>
Есть обвязка для flask:
</p><pre><code class="python">pip install flask-peewee
</code></pre>
</div></div>

<h2>Определение моделей или «попахивает джангой»</h2><p>
Весь нижеследующий код можно повторить один к одному в интерактивном интерпретаторе или отдельном скрипте.

</p><pre><code class="python">from peewee import *

db = SqliteDatabase('people.db')

class Person(Model):
    name = CharField()
    birthday = DateField()
    is_relative = BooleanField()

    class Meta:
        database = db  # модель будет использовать базу данных 'people.db'
</code></pre>
<p>
Типов полей много, </p><a href="http://peewee.readthedocs.org/en/latest/peewee/models.html#field-types-table">на все случаи жизни</a><p>. Peewee берёт на себя преобразование питоновских объектов в значения, подходящие для базы данных, и наоборот.
</p><a name="habracut"/>
<h3>Инициализирующие аргументы</h3><p>
Каждое поле принимает следующие инициализирующие аргументы:
</p><ul>
<li><code>null=False</code> – возможно ли хранение null-значений;</li>
<li><code>index=False</code> – создавать ли индекс для данного столбца в базе;</li>
<li><code>unique=False</code> – создавать ли уникальный индекс для данного столбца в базе. См. также главу <a href="http://peewee.readthedocs.org/en/latest/peewee/models.html#model-indexes">о составных индексах</a>;</li>
<li><code>verbose_name=None</code> – строка для человекопонятного представления поля;</li>
<li><code>help_text=None</code> – строка с вспомогательным текстом для поля;</li>
<li><code>db_column=None</code> – строка, явно задающая название столбца в базе для данного поля, используется например при работе с legacy базой данных;</li>
<li><code>default=None</code> – значение по-умолчанию для полей класса при инстанцировании;</li>
<li><code>choices=None</code> – список или кортеж двухэлементных кортежей, где первый элемент – значение для базы, второй – отображаемое значение (аналогично джанге);</li>
<li><code>primary_key=False</code> – использовать ли данное поле, как первичный ключ;</li>
<li><code>sequence=None</code> – последовательность для наполнения поля (удостоверьтесь, что бекэнд поддерживает такую функциональность);</li>
</ul>

<h3>Метаданные</h3><p>
Для каждой таблицы можно прописать единые метаданные в </p><code>class Meta</code><p>:

</p><table>
<tr>
<th>Опция</th>
<th>Описание</th>
<th>Наследуется?</th>
</tr>
<tr>
<td><code>database</code></td>
<td>база данных для модели</td>
<td>да</td>
</tr>
<tr>
<td><code>db_table</code></td>
<td>название таблицы, в которой будут храниться данные</td>
<td>нет</td>
</tr>
<tr>
<td><code>indexes</code></td>
<td>список полей для индексирования</td>
<td>да</td>
</tr>
<tr>
<td><code>order_by</code></td>
<td>список полей для сортировки по-умолчанию</td>
<td>да</td>
</tr>
<tr>
<td><code>primary_key</code></td>
<td>составной первичный ключ, экземпляр класса CompositeKey, <a href="http://peewee.readthedocs.org/en/latest/peewee/api.html#CompositeKey">пример</a></td>
<td>да</td>
</tr>
<tr>
<td><code>table_alias</code></td>
<td>алиас таблицы для использования в запросах</td>
<td>нет</td>
</tr>
</table>
<p>
Попробуем задать отношения между моделями через внешний ключ. С peewee это просто:

</p><pre><code class="python">class Pet(Model):
    owner = ForeignKeyField(Person, related_name='pets')
    name = CharField()
    animal_type = CharField()

    class Meta:
        database = db  # модель будет использовать базу данных 'people.db'
</code></pre>
<p>
Модели описаны, осталось создать для них соответствующие таблицы в базе данных:

</p><pre><code class="python">&gt;&gt;&gt; Person.create_table()
&gt;&gt;&gt; Pet.create_table()
</code></pre>

<h2>Работа с данными</h2><p>
Для примера создадим нескольких человек и заведём им домашних животных:

</p><pre><code class="python">&gt;&gt;&gt; from datetime import date
&gt;&gt;&gt; uncle_bob = Person(name='Bob', birthday=date(1960, 1, 15), is_relative=True)
&gt;&gt;&gt; uncle_bob.save()  # cохраним Боба в базе данных
</code></pre>
<p>
Записи можно создавать и напрямую с помощью метода Model.create() без явного save():

</p><pre><code class="python">&gt;&gt;&gt; grandma = Person.create(name='Grandma', birthday=date(1935, 3, 1), is_relative=True)
&gt;&gt;&gt; herb = Person.create(name='Herb', birthday=date(1950, 5, 5), is_relative=False)
</code></pre>
<p>
Порадуем бабулю фамилией:

</p><pre><code class="python">&gt;&gt;&gt; grandma.name = 'Grandma L.'
&gt;&gt;&gt; grandma.save()  # обновим запись grandma
</code></pre>
<p>
Теперь сгенерируем немного живности. У бабули аллергия на кошек, а вот у Герба есть </p><a href="http://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%82%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BD%D0%B0%D0%BA%D0%BE%D0%BF%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D1%82%D0%B2%D0%BE_%D0%B6%D0%B8%D0%B2%D0%BE%D1%82%D0%BD%D1%8B%D1%85">некоторые проблемы</a><p>:

</p><pre><code class="python">&gt;&gt;&gt; bob_kitty = Pet.create(owner=uncle_bob, name='Kitty', animal_type='cat')
&gt;&gt;&gt; herb_fido = Pet.create(owner=herb, name='Fido', animal_type='dog')
&gt;&gt;&gt; herb_mittens = Pet.create(owner=herb, name='Mittens', animal_type='cat')
&gt;&gt;&gt; herb_mittens_jr = Pet.create(owner=herb, name='Mittens Jr', animal_type='cat')
</code></pre>
<p>
В какой-то момент Варежке надоело жить с Гербом и, воспользовавшись открытым окном, он гордо убежал в закат. Уважая его право на свободу личности, всё же удалим соответствующую запись из базы:

</p><pre><code class="python">&gt;&gt;&gt; herb_mittens.delete_instance()  # удачи, Варежка
1
</code></pre>
<p>
Как вы могли заметить, операция удаления возвращает количество удалённых записей, в данном случае – 1.
</p><p>
Дядя Боб решил, что у Герба итак много животных и отжал у него Фидо:

</p><pre><code class="python">&gt;&gt;&gt; herb_fido.owner = uncle_bob
&gt;&gt;&gt; herb_fido.save()
&gt;&gt;&gt; bob_fido = herb_fido  # переименуем переменную для лучшего соответствия суровой реальности
</code></pre>

<h2>Выборки</h2><p>
Выборки выполняются прямо с объектом класса и возвращают экземпляры SelectQuery (аналог QuerySet в джанге).

</p><h3>Извлечение одной записи</h3><p>
Для извлечения одной записи используйте метод </p><code>SelectQuery.get()</code><p>:

</p><pre><code class="python">&gt;&gt;&gt; grandma = Person.select().where(Person.name == 'Grandma L.').get()
</code></pre>
<p>
Запрос можно сократить, подставив аргумент напрямую в </p><code>get()</code><p>:

</p><pre><code class="python">&gt;&gt;&gt; grandma = Person.get(Person.name == 'Grandma L.')
</code></pre>

<h3>Извлечение нескольких записей</h3><p>
Пройдемся по всем экземплярам </p><code>Person</code><p> циклом:

</p><pre><code class="python">&gt;&gt;&gt; for person in Person.select():
...     print person.name, person.is_relative
...
Bob True
Grandma L. True
Herb False
</code></pre>
<p>
Пройдемся по экземплярам </p><code>Person</code><p> и по всем связанным с ними записями:

</p><pre><code class="python">&gt;&gt;&gt; for person in Person.select():
...     print person.name, person.pets.count(), 'pets'
...     for pet in person.pets:
...         print '    ', pet.name, pet.animal_type
...
Bob 2 pets
    Kitty cat
    Fido dog
Grandma L. 0 pets
Herb 1 pets
    Mittens Jr cat
</code></pre>
<p>
Выловим всех кошек и их хозяев людей (или наоборот?):

</p><pre><code class="python">&gt;&gt;&gt; for pet in Pet.select().where(Pet.animal_type == 'cat'):
...     print pet.name, pet.owner.name
...
Kitty Bob
Mittens Jr Herb
</code></pre>
<p>
Не без join'ов:

</p><pre><code class="python"># выберем всех животных Боба
&gt;&gt;&gt; for pet in Pet.select().join(Person).where(Person.name == 'Bob'):
...     print pet.name
...
Kitty
Fido
</code></pre>
<p>
Извлечь ту же выборку можно и по-другому – явно передав объект с Бобом в запрос:

</p><pre><code class="python">&gt;&gt;&gt; for pet in Pet.select().where(Pet.owner == uncle_bob):
...     print pet.name
</code></pre>
<p>
Упорядочим выборку в алфавитном порядке. Для этого воспользуемся методом </p><code>SelectQuery.order_by()</code><p>:

</p><pre><code class="python">&gt;&gt;&gt; for pet in Pet.select().where(Pet.owner == uncle_bob).order_by(Pet.name):
...     print pet.name
...
Fido
Kitty
</code></pre>
<p>
Упорядочим людей по возрасту:

</p><pre><code class="python">&gt;&gt;&gt; for person in Person.select().order_by(Person.birthday.desc()):
...     print person.name
...
Bob
Herb
Grandma L.
</code></pre>
<p>
Давайте попробуем более сложный запрос. Выберем всех людей, родившихся
</p>

<pre><code class="python">&gt;&gt;&gt; d1940 = date(1940, 1, 1)
&gt;&gt;&gt; d1960 = date(1960, 1, 1)
&gt;&gt;&gt; for person in Person.select().where((Person.birthday &lt; d1940) | (Person.birthday &gt; d1960)):
...     print person.name
...
Bob
Grandma L.
</code></pre>

<div class="spoiler"><b class="spoiler_title">Хинт</b><p class="spoiler_text">Запрос <code>where((Person.birthday &lt; d1940) | (Person.birthday &gt; d1960))</code> можно написать и как <code>where(Person.birthday &lt; d1940 or Person.birthday &gt; d1960)</code>, но лучше этого не делать, т.к. peewee не всегда правильно обрабатывает такую запись.</p></div>
<p>
А теперь торобоан. Выберем тех, кто родился между 1940 и 1960:

</p><pre><code class="python">&gt;&gt;&gt; for person in Person.select().where((Person.birthday &gt; d1940) &amp; (Person.birthday &lt; d1960)):
...     print person.name
...
Herb
</code></pre>
<p>
And one last thing. Воспользуемся SQL-функцией и выберем всех людей, чьё имя начинается с «G» в любом регистре:

</p><pre><code class="python">&gt;&gt;&gt; for person in Person.select().where(fn.Lower(fn.Substr(Person.name, 1, 1)) == 'g'):
...     print person.name
...
Grandma L.
</code></pre>
<p>
Для выборок также используйте методы:
</p><ul>
<li><code>SelectQuery.group_by()</code></li>
<li><code>SelectQuery.having()</code></li>
<li><code>SelectQuery.limit()</code> и <code>SelectQuery.offset()</code></li>
</ul>
<p>
Если вам понравился данный краткий туториал, обязательно посетите </p><a href="http://peewee.readthedocs.org/en/latest/">официальную документацию</a><p> — там много интересного, включая </p><a href="http://peewee.readthedocs.org/en/latest/peewee/cookbook.html">рецепты с решениями распространённых задач</a><p> и </p><a href="http://peewee.readthedocs.org/en/latest/peewee/playhouse.html">набор плагинов</a><p>, расширяющих базовую функциональность.

</p><h2>Бонус</h2><p>
Автора в его блоге спросили о быстродействии ORM, на что тот ответил:

</p><blockquote>On my machine peewee has been faster than Django and SQA at most tasks, and about the same when iterating and returning Model instances.</blockquote>
<blockquote>На моём компе peewee обошла Django и SQLAlchemy на большинстве задач, и показала сравнимые результаты на итерациях и выборке инстансов.</blockquote>
<p>
После чего опубликовал результаты бенчмарка на гитхабе. Тестились обычные модели и связанные через ForeignKey в различных сценариях. Весьма </p><a href="https://github.com/coleifer/peewee/blob/master/bench/results">любопытно</a><p>. 
</p><p>
Кому интересно, исходники:
</p>
<p>
Хорошая альтернатива Алхимии, как считаете?

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>