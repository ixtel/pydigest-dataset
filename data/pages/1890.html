<html><body><div><div class="entry">
<p>In June 2012, I <a href="http://www.pixelmonkey.org/2012/06/13/clojure">promised myself</a> that I’d learn Clojure “as a mind expander”. As a long-time Python programmer who has been using Python full-time in my work at <a href="http://parse.ly">Parse.ly</a>, I wanted to explore. I wrote then:</p>
<blockquote><p>
I don’t know whether Clojure programs will be better or worse than equivalent Python programs. But I know they will be different.
</p></blockquote>
<p>It took me awhile, but in January of this year, I started teaching myself the language.</p>
<h3>Rich Hickey, and the “Cult of Personality”</h3>
<p>My approach was to first learn the underpinnings of the language from books and online videos. If you embark on this for Clojure, you will inevitably run into the copious publicly-available material from the language’s creator, Rich Hickey.</p>
<p>In stark contrast to Guido van Rossum in the Python community, Rich Hickey is undeniably not just the Clojure language’s creator, but also a kind of spokesperson for a functional programming renaissance. Guido van Rossum generally lays low and lets the Python language and community speak for itself, and tries to avoid controversy. To him, Python is just a popular tool he happened to create, and it doesn’t represent any major paradigm shift in programming. It’s a positive evolutionary improvement supported by a great open source ecosystem and community. To Hickey, however, “traditional” programming languages — but especially popular ones with an object-oriented focus, such as Java and C++ — are just plain wrong. He proposes Clojure as an antidote of sorts.</p>
<p>You can get the gist of this from his motivating videos, such as <a href="https://www.youtube.com/watch?v=f84n5oFoZBc">Hammock-Driven Development</a>, <a href="http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey">Are We There Yet?</a>, and <a href="http://www.infoq.com/presentations/Simple-Made-Easy">Simple Made Easy</a>. For a thorough overview of Clojure as a language, you can also get a walkthrough by Hickey, given to a room full of Java developers, in Clojure for Java Programmers <a href="https://www.youtube.com/watch?v=P76Vbsk_3J0">Part I</a> and <a href="https://www.youtube.com/watch?v=hb3rurFxrZ8">Part II</a>.</p>
<p>Here is a summary of the viewpoint. Most languages are missing some important attributes that can help us tackle the most complex issues in programming projects:</p>
<p><span id="more-1818"/></p>
<ul>
<li><strong>True Immutability</strong>: Data structures should be immutable, and the details of maintaining a revision history for data structures should be an abstracted detail, like memory management is in most modern languages with garbage collection / reference counting. </li>
<li><strong>True Composability</strong>: OO languages purport to offer a way to re-use code, but the mechanisms for doing so often rely upon type inheritance; in functional languages, composability falls naturally out of having simple functions with immutable inputs and outputs and higher-order functions for laying out their execution order. </li>
<li><strong>True Scalability</strong>: Most traditional languages either assume only operating in a single core, or provide low-level mechanisms for working with threads and locks. The free lunch is over for single core, and threads and locks are too complicated to get right. Clojure bundles a Software Transactional Memory (STM) implementation, that, when combined with composable functions and immutable data structures, can simplify parallelism and concurrency.</li>
<li><strong>True Productivity</strong>: Some languages attempt to solve the above problems with a restrictive or verbose layer of static typing. Others try to solve the problems with complicated toolchains and compilation. A truly productive language has a small core, an interactive development flow (typically oriented around a REPL), and declarative, concise code forms.</li>
</ul>
<p>Notice that I put the word “True” in front of each of these attributes. This is because if I were to reflect on Python as a language, I’d say it has all these attributes. You <strong>can</strong> build programs in Python that center around immutable data structures, have composable functions. You can write Python programs that scale up, and you can do so with a high degree of developer productivity. But Clojure tries to make these attributes <strong>fall naturally</strong> out of using the language, through a slew of built-in facilities, rather than enforcement of these attributes being a conscious design decision of the programmer (as is often the case in Python).</p>
<p>Hickey’s forceful arguments in his presentations are that the above attributes <strong>matter more than you might think</strong>. Defaults matter. Whatever is default is widespread.</p>
<p>Consider immutable data structures. In Python, we can code defensively using the <a href="https://docs.python.org/2/library/copy.html">copy</a> module. Some languages, like Java, have immutable data structures as a third-party library, such as Guava Collections and its <a href="https://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">Immutable Collections support</a>. But neither of these are widely used. You might even get negative code reviews from your colleagues for using them excessively. But in Clojure, immutable data structures are the default, thus they are widely used. Mutability is the opt-in behavior that draws strange looks from your programming colleagues.</p>
<p>Likewise, you can write composable functional programs in Python, but it’s probably just as common to write object-oriented programs and class heirarchies. I actually recently wrote a module in functional style on my team, and a few of my colleagues thought it was pretty weird because the code had “so many different entry points”. One even proposed rewriting it in terms of classes for clarity. In Clojure, these debates (class vs function) never happen, because functions are seen as the superior unit of composition. The debate centers around how to name, organize, and structure functions, not whether to use them altogether.</p>
<p>You can scale most dynamic languages beyond a single core using distributed computation frameworks like Hadoop and Storm, but it’s not using built-in language facilities and generally involves complex mechanisms. In Clojure, going from one core to multi-core is usually just a matter of using <a href="https://clojuredocs.org/clojure.core/pmap">a different higher-order mapping function</a>. Going from single-node to multi-node also becomes easier to reason about, because shared state is rare in Clojure programs.</p>
<p>So, all of this is to say, Clojure is not a revolutionary language. But it is different — that’s for sure. If you are used to Python, there are lessons to learn from Clojure, its community, and its code. This post, walking through some “Clojonic” examples of “Pythonic Clojure”, could serve as a good starting point.</p>
<h3>Clojonic iteration</h3>
<p>This is my favorite starting Python program example:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python">nums <span>=</span> <span>[</span><span>45</span><span>,</span> <span>23</span><span>,</span> <span>51</span><span>,</span> <span>32</span><span>,</span> <span>5</span><span>]</span>
<span>for</span> idx<span>,</span> num <span>in</span> <span>enumerate</span><span>(</span>nums<span>)</span>:
     <span>print</span> idx<span>,</span> num
<span># 0 45</span>
<span># 1 23</span>
<span># 2 51</span>
<span># 3 32</span>
<span># 4 5</span></pre></td></tr></table></div>
<p>The equivalent code in Clojure could be written:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="clojure"><span>(</span><span>let</span> <span>[</span>nums <span>[</span><span>45</span> <span>23</span> <span>51</span> <span>32</span> <span>5</span><span>]</span><span>]</span>
    <span>(</span><span>for</span> <span>[</span><span>[</span>idx num<span>]</span> <span>(</span>map<span>-</span>indexed <span>vector</span> nums<span>)</span><span>]</span>
        <span>(</span>println idx num<span>)</span><span>)</span><span>)</span>
<span>; 0 45</span>
<span>; 1 23</span>
<span>; 2 51</span>
<span>; 3 32</span>
<span>; 4 5</span></pre></td></tr></table></div>
<p>If you squint, this code looks pretty similar, but there are some important differences. The main aesthetic difference is a few more parentheses and brackets. Beyond that, the Python programmer will observe that in the Clojure program, many aspects of the program are <strong>implied</strong>, rather than annotated by special syntax. Many Clojure proponents will say that Clojure has a “simple syntax”, but I think this is misleading. They don’t mean simple as in “easy to read without prior context”. They mean simple as in “unceremonious”. Perhaps they mean simple as a contrast to “baroque” (how you might describe Java or C++’s syntax). Clojure does have a syntax, but it is implicit from the layout of the code in the list data structures. I’ve decoded the above code visually below:</p>
<p><a href="http://www.pixelmonkey.org/wordpress/wp-content/uploads/2014/11/clojure_syntax.png"><img src="http://www.pixelmonkey.org/wordpress/wp-content/uploads/2014/11/clojure_syntax.png" alt="clojure_syntax" class="aligncenter wp-image-1824"/></a></p>
<p>So, in Python, the code was a combination of lightweight data structures (<code>[]</code>, aka <code>list</code>), functions (<code>enumerate()</code>), statements (<code>for</code>, <code>print</code>), and explicit syntax (<code>nums = [...]</code> binding, <code>for idx, num</code> unpacking). In Clojure, the code is a combination of lightweight data structures (<code>[]</code>, aka <code>vector</code>), special forms (<code>let</code>), macros (<code>for</code>), functions (<code>println</code>), and implied syntax (<code>let [nums [...]]</code> binding, <code>for [idx num]</code> destructuring). Seems like just a bunch of different names for the same concepts — and indeed, in this simple program, Python and Clojure share a lot of language facilities in common. But, we can start to dig deeper on the Clojure version to make it diverge more from Python.</p>
<p>So, firstly, what’s the difference between the Python <code>list</code> and the Clojure <code>vector</code>? Immutability. They have a similar syntax, but when Clojure’s list-like data structure is created, it cannot change. Other functions can accept the list as input and produce a new list as output.</p>
<p>So, you might ask the question, “How do I add an element to the <code>nums</code> list in Clojure?” The answer is that you <strong>can’t</strong>. You must, instead, pipe the list through a function that might generate a new list. For example, the <code>conj</code> function will construct a <strong>new</strong> immutable list with the additional element, but leave the original list intact. In other words, there is no equivalent to the <code>.append()</code> method.</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="clojure"><span>(</span><span>let</span> <span>[</span>nums <span>[</span><span>45</span> <span>23</span> <span>51</span> <span>32</span> <span>5</span><span>]</span>
      bigger <span>(</span><span>conj</span> nums <span>75</span><span>)</span><span>]</span>
    <span>(</span>println nums<span>)</span>
    <span>(</span>println bigger<span>)</span><span>)</span>
<span>; [45 23 51 32 5]</span>
<span>; [45 23 51 32 5 75]</span></pre></td></tr></table></div>
<p>It would be as if we wrote a <code>conj</code> function in Python like this:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>import</span> <span>copy</span>
 
<span>def</span> conj<span>(</span>a_list<span>,</span> elm<span>)</span>:
    new_list <span>=</span> <span>copy</span>.<span>copy</span><span>(</span>a_list<span>)</span>
    new_list.<span>append</span><span>(</span>elm<span>)</span>
    <span>return</span> new_list</pre></td></tr></table></div>
<p>You might then ask, isn’t that very expensive? If <code>a_list</code> is large, that has to create a full copy in-memory of all its elements. If you wrote a function like this in Python, your colleagues would give you strange looks.</p>
<p>But, in Clojure, these details are handled by the language itself and in an optimized way. It uses a trick called <a href="http://en.wikipedia.org/wiki/Persistent_data_structure">Persistent Data Structures</a>, which leverage a technique called “structural sharing”. Essentially, all of the list values are modeled as a tree that is maintained internally by the language and run-time. The immutable vectors you see as a programmer are “views” of the same arrangement of in-memory elements.</p>
<p>Let’s now look closely at the replacement for the <code>enumerate()</code> built-in we used in the Clojure code above. We had to use the more verbose function call to <code>map-indexed</code> below:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="clojure"><span>(</span>map<span>-</span>indexed <span>vector</span> nums<span>)</span>
<span>; ([0 45] [1 23] [2 51] [3 32] [4 5])</span></pre></td></tr></table></div>
<p>This illustrates a Clojure higher-order function. The <a href="https://clojuredocs.org/clojure.core/map-indexed">docs for <code>map-indexed</code></a> describe its operation:</p>
<blockquote><p>
Returns a lazy sequence consisting of the result of applying f to 0 and the first item of coll, followed by applying f to 1 and the second item in coll, etc, until coll is exhausted. Thus function f should accept 2 arguments, index and item.
</p></blockquote>
<p>The function we passed as <code>f</code> is <code>vector</code>, which is similar to <code>list</code> in Python — it simply creates a vector from its list of arguments. So, this higher-order function will make repeated calls of the following form to our <code>nums</code> elements:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="clojure"><span>(</span><span>vector</span> <span>0</span> <span>45</span><span>)</span> <span>; =&gt; [0 45]</span>
<span>(</span><span>vector</span> <span>1</span> <span>23</span><span>)</span> <span>; =&gt; [1 23]</span>
<span>(</span><span>vector</span> <span>2</span> <span>51</span><span>)</span> <span>; =&gt; [2 51]</span>
<span>(</span><span>vector</span> <span>3</span> <span>32</span><span>)</span> <span>; =&gt; [3 32]</span>
<span>(</span><span>vector</span> <span>4</span> <span>5</span><span>)</span>  <span>; =&gt; [4 5]</span></pre></td></tr></table></div>
<p>And this gives us our pairs of “indexed” elements. We could convert this higher-order function call into another function that operates more like the Python <code>enumerate()</code> counterpart.</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="clojure"><span>(</span><span>defn</span> enumerate <span>[</span>coll<span>]</span>
    <span>(</span>map<span>-</span>indexed <span>vector</span> coll<span>)</span><span>)</span></pre></td></tr></table></div>
<p>And we could then use <code>(enumerate)</code> in our Clojure code as follows:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="clojure"><span>(</span><span>let</span> <span>[</span>nums <span>[</span><span>45</span> <span>23</span> <span>51</span> <span>32</span> <span>5</span><span>]</span><span>]</span>
    <span>(</span><span>for</span> <span>[</span><span>[</span>idx num<span>]</span> <span>(</span>enumerate nums<span>)</span><span>]</span>
        <span>(</span>println idx num<span>)</span><span>)</span><span>)</span></pre></td></tr></table></div>
<p>There, that’s looking a bit closer to the Python. Now, the astute Python programmer will observe that the <code>enumerate()</code> built-in in the Python language is actually an iterator over the indexed values. It lazily returns the enumerated (indexed) values from the passed-in sequence. You could write you own version of <code>enumerate</code> by using <a href="https://docs.python.org/2/tutorial/classes.html#generators">a generator</a>.</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>type</span><span>(</span><span>enumerate</span><span>(</span>nums<span>)</span><span>)</span>
<span># enumerate</span>
<span>enumerate</span><span>(</span>nums<span>)</span>.<span>next</span><span>(</span><span>)</span>
<span># (0, 45)</span>
<span>list</span><span>(</span><span>enumerate</span><span>(</span>nums<span>)</span><span>)</span>
<span># [(0, 45), (1, 23), (2, 51), (3, 32), (4, 5)]</span></pre></td></tr></table></div>
<p>How does our Clojure version compare?</p>
<p>Well, here comes the next surprise. In Python, you opt-in to lazy iteration by writing your own iterators or letting the language write iterators for you by using generator functions via the <code>yield</code> keyword. In Clojure, functions operating on sequences are <strong>lazy by default</strong>.</p>
<p>It turns out our Clojure <code>enumerate</code> function is more like a Python <code>generator</code> than it appears. This is because <code>map-indexed</code> “returns a lazy sequence”. It’s only once the sequence values of <code>enumerate</code> are fetched, an element-at-a-time, that they are evaluated as index pairs. This is done by the <code>for</code> macro, which is <strong>itself</strong> lazy. From the docs, the <code>for</code> macro <a href="https://clojuredocs.org/clojure.core/for">“yields a lazy sequence of evaluations”</a>. The <code>for</code> macro in Clojure is actually closer to a <a href="https://docs.python.org/2/reference/expressions.html#generator-expressions">generator expression</a> in Python than it is to the imperative <code>for</code> looping statement.</p>
<p>Indeed, some Clojure programmers will question my reasoning for using the <code>for</code> macro as an iteration construct. There is another construct, <code>doseq</code>, that has a similar interface, but is meant to be used for iteration. <a href="https://clojuredocs.org/clojure.core/doseq">From the docs</a>:</p>
<blockquote><p>
Repeatedly executes body (presumably for side-effects) with bindings and filtering as provided by “for”. Does not retain the head of the sequence. Returns nil.
</p></blockquote>
<p>So, the following code would be a more idiomatic form of looping:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="clojure"><span>(</span><span>doseq</span> <span>[</span><span>[</span>idx num<span>]</span> <span>(</span>enumerate nums<span>)</span><span>]</span>
    <span>(</span>println idx num<span>)</span><span>)</span></pre></td></tr></table></div>
<p>Another Clojure programmer may also look upon the <code>doseq</code> and suggest it is a bit too verbose, not taking advantage of the fact that often iteration is achieved in Clojure via higher-order functions. The following code is just as good, and perhaps more idiomatic for Clojure:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="clojure"><span>(</span><span>map</span> println <span>(</span>enumerate nums<span>)</span><span>)</span></pre></td></tr></table></div>
<p>Or, even the following, which may look cryptic now but will be explained shortly:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="clojure"><span>(</span><span>-&gt;&gt;</span> nums enumerate <span>(</span><span>map</span> println<span>)</span><span>)</span></pre></td></tr></table></div>
<h3>Beyond Python constructs with macros</h3>
<p>I mentioned that <code>for</code> is a macro in Clojure. Another macro I used briefly was <code>defn</code>, which is a macro that composes the <code>def</code> (global variable declaration) and <code>fn</code> (function) forms. The cryptic <code>-&gt;&gt;</code> symbol in the last example above is also a macro, called “thread-last”.</p>
<p>Macros may be the most fascinating feature of the Clojure language to advanced Python practitioners who have gotten a lot out of Python’s metaprogramming facilities, such as decorators, context managers, and metaclasses.</p>
<p>Macros are like a generalization of these features. They give you, the programmer, a generic compiler hook to transform code. In short, you can make constructs that <strong>look like function calls, but operate as code transformations.</strong> These are both powerful, and dangerous.</p>
<p>Let’s go back to our <code>enumerate</code> example. I could actually rewrite the <code>enumerate</code> function as a macro, as follows:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="clojure"><span>(</span><span>defmacro</span> enumerate <span>[</span>coll<span>]</span>
    `<span>(</span>map<span>-</span>indexed <span>vector</span> ~coll<span>)</span><span>)</span></pre></td></tr></table></div>
<p>The first backtick indicates that this is a literal list. It should not be evaluated as a function call. It should not call <code>map-indexed</code> upon evaluation.</p>
<p>The <code>~coll</code> is telling Clojure that the input to <code>enumerate</code> should be placed, untouched, in the location at <code>~coll</code>. So, in plain English, this says, “Define a macro, <code>enumerate</code>, that looks like a function, but actually gets replaced, at compile-time, with a function call to <code>(map-indexed vector coll)</code>, but where <code>coll</code> is taken from the argument list of <code>enumerate</code> at compile-time.”</p>
<p>In other words, the body of the macro is like a <strong>template</strong> for a code replacement operation, and doesn’t have the overhead of a function call.</p>
<p>This is a pretty trivial example, but let’s explore it a little. Clojure provides <code>macroexpand</code>, which will show what the given macro call actually evaluates into at compile-time.</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="clojure"><span>=&gt;</span> <span>(</span>macroexpand '<span>(</span>enumerate <span>[</span><span>1</span> <span>2</span> <span>3</span><span>]</span><span>)</span><span>)</span>
<span>(</span>clojure<span>.</span>core<span>/</span>map<span>-</span>indexed clojure<span>.</span>core<span>/</span><span>vector</span> <span>[</span><span>1</span> <span>2</span> <span>3</span><span>]</span><span>)</span>
<span>; Translation: the code above is *replaced* with:</span>
<span>(</span>map<span>-</span>indexed <span>vector</span> <span>[</span><span>1</span> <span>2</span> <span>3</span><span>]</span><span>)</span></pre></td></tr></table></div>
<p>In this case, the overhead of the function call is probably negligible, so the complexity of the macro probably isn’t worth it. But anytime you think, “this group of functions has a lot of code repetition” — where in Python you might reach for decorators or context managers — you can use Clojure’s macros to achieve similar feats of code re-use. This gets at Clojure’s notion of True Productivity.</p>
<p>Let’s go back to the <code>-&gt;&gt;</code> thread-last macro from before. This macro does nothing more than rewrite the code that comes after it in “pipeline form”. Instead of thinking of “mapping the println function over the lazy sequence of indexed pairs generated by enumerate”…</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="clojure"><span>(</span><span>map</span> println <span>(</span>enumerate nums<span>)</span><span>)</span></pre></td></tr></table></div>
<p>… it might make more sense to think of it as “pipe the numbers through a function that generates index pairs, then pipe those pairs through a function that prints the results”:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="clojure"><span>(</span><span>-&gt;&gt;</span> nums enumerate <span>(</span><span>map</span> println<span>)</span><span>)</span><span>)</span></pre></td></tr></table></div>
<p>And indeed, these are equivalent formulations of the same code, thanks to the thread-last macro!</p>
<h3>Working through a bigger example</h3>
<p>So, given this introduction, Clojure probably feels very different, but also somewhat familiar. Let’s look at a bigger example program in Python:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span># in twitter.py</span>
<span>import</span> json
 
<span>def</span> with_twitter_data<span>(</span>filename<span>,</span> rdr_fn<span>)</span>:
    <span>with</span> <span>open</span><span>(</span>filename<span>)</span> <span>as</span> rdr:
        <span>return</span> <span>list</span><span>(</span>rdr_fn<span>(</span>rdr<span>)</span><span>)</span>
 
<span>def</span> read_tweets<span>(</span>rdr<span>)</span>:
    <span>for</span> line <span>in</span> rdr:
        apikey<span>,</span> timestamp<span>,</span> entry <span>=</span> line.<span>split</span><span>(</span><span>"|"</span><span>,</span> <span>2</span><span>)</span>
        <span>yield</span> apikey<span>,</span> timestamp<span>,</span> json.<span>loads</span><span>(</span>entry<span>)</span>
 
with_twitter_data<span>(</span><span>"data/tweets.log"</span><span>,</span> read_tweets<span>)</span></pre></td></tr></table></div>
<p>This example defines two Python functions, <code>with_twitter_data</code> and <code>read_tweets</code>. The <code>read_tweets</code> function takes an iterator of lines that are formatted as follows:</p>
<pre><code>1|2014-10-31|{"user": "amontalenti", "tweet": "some text"}
</code></pre>
<p>It splits these lines to get the strings <code>apikey</code> and <code>timestamp</code> and the parsed Python dictionary representing the JSON data, <code>entry</code>. It yields <code>(apikey, timestamp, entry)</code> as a 3-tuple lazily by using a generator function.</p>
<p>Meanwhile, <code>with_twitter_data</code> takes a function as an argument that knows how to parse those log lines, and eagerly evaluates the parsed results into an in-memory list. It then closes the file.</p>
<p>This code can be ported to Clojure very easily:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="clojure"><span>;; in twitter.clj</span>
<span>(</span><span>ns</span> twitter
    <span>(</span>:<span>require</span> <span>[</span>clojure<span>.</span>data<span>.</span>json :<span>as</span> json<span>]</span>
              <span>[</span>clojure<span>.</span>java<span>.</span>io :<span>as</span> io<span>]</span>
              <span>[</span>clojure<span>.</span>string :<span>as</span> <span>str</span><span>]</span><span>)</span><span>)</span>
 
<span>(</span><span>defn</span> with<span>-</span>twitter<span>-</span>data <span>[</span>filename rdr<span>-</span><span>fn</span><span>]</span>
    <span>(</span><span>with-open</span> <span>[</span>rdr <span>(</span>io<span>/</span>reader filename<span>)</span><span>]</span>
        <span>(</span><span>doall</span> <span>(</span>rdr<span>-</span><span>fn</span> rdr<span>)</span><span>)</span><span>)</span><span>)</span>
 
<span>(</span><span>defn</span> read<span>-</span>tweets <span>[</span>rdr<span>]</span>
    <span>(</span><span>for</span> <span>[</span>line <span>(</span><span>line-seq</span> rdr<span>)</span><span>]</span>
        <span>(</span><span>let</span> <span>[</span><span>[</span>apikey timestamp entry<span>]</span> <span>(</span><span>str</span><span>/</span>split line #<span>"<span>\|</span>"</span> <span>3</span><span>)</span><span>]</span>
            <span>(</span><span>vec</span> <span>[</span>apikey timestamp <span>(</span>json<span>/</span>read<span>-</span><span>str</span> entry<span>)</span><span>]</span><span>)</span><span>)</span><span>)</span><span>)</span>
 
<span>(</span>with<span>-</span>twitter<span>-</span>data <span>"data/tweets.log"</span> read<span>-</span>tweets<span>)</span></pre></td></tr></table></div>
<p>What’s different? Well, Clojure’s import facility is a little different. We use the <code>ns</code> macro to declare a namespace, which is similar to a Python module that is implicitly defined using module files. The <code>:require [namespace :as alias]</code> clause is equivalent to Python’s <code>import module as alias</code> syntax.</p>
<p>We can see that <code>read-tweets</code> likewise lazily evaluates the lines of the input <code>rdr</code>, and uses <code>str/split</code> and <code>json/read-str</code> to parse the log lines. Vectors are yielded back lazily thanks to the <code>for</code> macro.</p>
<p>The <code>with-twitter-data</code> function uses <code>with-open</code>, which works similarly to Python’s combination of the <code>with</code> keyword and the <code>open()</code> context manager. It automatically closes the file when it’s done processing. But it implements this using a Clojure macro that surrounds the body of your code with a <code>(try) ... (finally)</code> exception handler and a call to <code>close</code>.</p>
<p>The call to <code>(doall (rdr-fn rdr))</code> may seem curious. This is forcing eager evaluation, similar to Python’s typical use of <code>list()</code> to materialize all the values of a lazy sequence. It’s saying, “repeatedly call rdr-fn on the lines of input until there are no more lines left.”</p>
<h3>Similarities and differences</h3>
<p>My exploration of Clojure so far has made me realize that the languages share surprisingly more in common than I originally thought as an outside observer. Indeed, I think Clojure may be the most “Pythonic” language running on the JVM today (short of Jython, of course). Let’s look at the similarities:</p>
<p><img src="http://www.pixelmonkey.org/wordpress/wp-content/uploads/2014/11/quick_compare.png" alt="quick_compare" class="aligncenter size-full wp-image-1833"/></p>
<p>However, the Clojure language also brings many new ideas to the programming community, while also improving upon ideas found in prior languages (like Common Lisp). I tried to summarize many of the core differences I’ve observed here:</p>
<p><img src="http://www.pixelmonkey.org/wordpress/wp-content/uploads/2014/11/clojure_unique.png" alt="clojure_unique" class="aligncenter size-full wp-image-1834"/></p>
<p>I didn’t cover all of these differences, but we did take a look at Macros, Immutable Data Structures, Lazy Evaluation, and Code as Data very briefly. You can probably already see how a language with true immutability, composability, scalability, and productivity can emerge out of these building blocks.</p>
<p>If you are interested in going further down the Clojure rabbit hole, you’ll probably enjoy some of the additional resources I’ve curated below. I found these particularly helpful to me as a Pythonista exploring the world of functional programming through Clojure.</p>
<p><small>Are you a Pythonista who enjoyed this article? If that’s the case, you’d probably also enjoy working on cutting-edge web analytics problems at <a href="http://parse.ly/jobs">Parse.ly</a>. We are looking to hire software engineers for our real-time analytics platform (Python, Storm, Kafka) and our elegant visualization dashboards (JavaScript, AngularJS, d3.js). We are also looking for people interested in engineering / product management. To apply right now, email <code><a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="14637b667f546475666771786d3a777b79">[email protected]</a></code> with a link to Github, your CV and/or other relevant background! If you reach out about a job opening, be sure to mention this post.</small></p>
<h4>Articles</h4>

<h4>Videos</h4>

<h4>Books</h4>
<p>The two best books out there seem to be:</p>

<p>There is also a free book out that explores Clojure from a beginner’s perspective, called <a href="http://www.braveclojure.com/">Clojure for the Brave and True</a>.</p>
<h4>More materials related to this post</h4>
<ul>
<li><a href="http://pixelmonkey.org/pub/clojonic/">Slides on “Clojonic: Pythonic Clojure”</a>: I put these slides together for a Parse.ly team retreat in Montreal, Canada and also presented them at a local functional programming meetup. This blog post was derived from the content of these slides.</li>
<li><a href="http://pixelmonkey.org/pub/clojonic/notes">Extended notes on the slides</a>: The note form is quickly scannable and may be easier to copy-paste code examples form.</li>
</ul>
<p class="postmetadata alt">
<small><strong>Andrew Montalenti</strong> (aka pixelmonkey, amontalenti) is the co-founder and CTO of <a href="http://parse.ly">Parse.ly</a>, which provides data insights to the web's best publishers. You can follow him on <a href="http://twitter.com/amontalenti">Twitter</a> or <a href="http://linkedin.com/in/andrewmontalenti">LinkedIn</a>. If you liked this post, you should <a href="http://mad.ly/signups/61030/join">subscribe to his free e-mail newsletter, <strong>Fire and Motion</strong></a>, which discusses technology startups and business from the trenches.
</small>
<small>
This entry was posted
on Sunday, November 2nd, 2014 at 2:57 pm and is filed under <a href="http://www.pixelmonkey.org/category/technology/computer-science" title="View all posts in Computer Science" rel="category tag">Computer Science</a>, <a href="http://www.pixelmonkey.org/category/technology/open-source" title="View all posts in Open Source" rel="category tag">Open Source</a>, <a href="http://www.pixelmonkey.org/category/technology/programming" title="View all posts in Programming" rel="category tag">Programming</a>, <a href="http://www.pixelmonkey.org/category/technology" title="View all posts in Technology" rel="category tag">Technology</a>.
You can follow any responses to this entry through the <a href="http://www.pixelmonkey.org/2014/11/02/clojonic/feed">RSS 2.0</a> feed.
You can <a href="#respond">leave a response</a>, or <a href="http://www.pixelmonkey.org/2014/11/02/clojonic/trackback" rel="trackback">trackback</a> from your own site.
</small>
</p>
</div>
</div></body></html>