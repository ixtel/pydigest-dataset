<html><body><div><article class="entry">
<h1>Django Performance: 4 Simple Things</h1>
    <p class="byline">by Frank Wiles on May 6, 2015</p>
    
<p>Optimizing for performance often comes with a bunch of headaches and hard problems, but it doesn’t always have to be that way.</p>

<p>Below are four simple things you can do to quickly and easily improve the performance of your sites. They’re so simple you should make them part of your standard setup.</p>

<h2>Persistent database connections</h2>

<p>New in Django 1.6 Django has built-in database connection persistence. Most everyone uses PostgreSQL for their production systems, and while connecting to PG isn’t particularly slow, it is something we can optimize. </p>

<p>Without persistent connections every request to your site also makes a connection to your database, authenticates the user, etc. This can easily take as much as 20–75ms if your database is on another host even on a fast network. </p>

<p>To setup connection persistence you add the <code>CONN_MAX_AGE</code> parameter to your <code>DATABASES</code> setting to look like this:</p>

<pre><code class="language-python">DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': 'whoohoodb',
        'CONN_MAX_AGE': 600,
    }
}
</code></pre>

<p>With this,we’ve setup persistent connections to stay alive for 10 minutes at a time. This helps to cut down on any possible memory leaks or a flaky connection causing a long term problem. You can certainly use a longer value, but I wouldn’t go much beyond an hour as there will be little benefit.</p>

<p>You can read more details about <a href="https://docs.djangoproject.com/en/1.8/ref/databases/#persistent-connections">persistent database connections</a> in the Django documentation. </p>

<h2>Template Loading</h2>

<p>By default Django comes configured to use the two standard template loaders:</p>

<pre><code class="language-python">TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)
</code></pre>

<p>These loaders search the file system and parse your templates on every request. Kinda surprising that it works as quickly as it does right? </p>

<p>You can turn on cached loading, so Django only has to find and parse your templates one time, by simply changing your configuration to be:</p>

<pre><code class="language-python">TEMPLATE_LOADERS = (
    ('django.template.loaders.cached.Loader', (
        'django.template.loaders.filesystem.Loader',
        'django.template.loaders.app_directories.Loader',
    )),
)
</code></pre>

<p>Now, don’t be silly and turn on cached loading in your development environments as it will get annoying. You’ll be forced to restart runserver (or whatever you’re using locally) on each and every template change. </p>

<h2>Optimize Django Sessions</h2>

<p>If you poll Django users nearly 82% of them have no idea where their sessions are stored. Ok, I admit I made that number up, but in our experience it’s pretty true.</p>

<p>By default, Django stores your user sessions in your database and expects you to occasionally prune out old entries. Very few people do this.</p>

<p>So on each request you’re doing a SQL query to get the session data and another to grab the User object information. If you’re the sort of person who’s concerned about performance you likely already have memcached or Redis setup to cache some things. You can switch to storing your sessions in your cache and easily remove a SQL query from every single request to your site with:</p>

<pre><code class="language-python">SESSION_ENGINE = 'django.contrib.sessions.backends.cache'
</code></pre>

<p>Now this assumes you can safely lose any data you store in your user sessions. If that’s not the case, you can still get some benefit from using: </p>

<pre><code class="language-python">SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db'
</code></pre>

<p>This backend caches your data, but also writes any changes to your database for long term storage. </p>

<h3>select_related() and prefetch_related()</h3>

<p>The first two tips above were super easy, right? Unfortunately this last one, while still easy compared to totally changing up your data storage, does require a bit more than a single configuration setting change. </p>

<p><code>select_related()</code> and <code>prefetch_related()</code> aren’t in everyone’s bag of tricks but they are incredibly useful for cutting down on the number of SQL queries your ORM code is firing. </p>

<p>The situation that usually happens is you have some <code>BlogPost</code> model with a ForeignKey to User. Then in a list view you use <code>queryset = BlogPost.objects.active</code>. Then in your templates you have something like: </p>

<pre><code class="language-markup">&lt;ul&gt;
{% for post in object_list %}
  &lt;li&gt;{{ post.title }} - {{ post.user.email }}&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;
</code></pre>

<p>This ends up doing the expected SELECT against the blog_post table, but then is forced in the template loop to do another SELECT against auth_user <strong>for each and every post in the list</strong>. </p>

<p>Instead, we can ask the Django ORM to go ahead and JOIN in the auth_user table to our results so that <code>object.user</code> is already an object for us. Taking us from <code>BlogPost.objects.active().count()</code> queries down to a single query. </p>

<p>We can fix it by simply changing the view’s queryset to be:</p>

<pre><code class="language-python">queryset = BlogPost.objects.select_related().active()
</code></pre>

<p>While not a simple settings change, still pretty simple to accomplish. </p>

<p><code>prefetch_related</code> is the same mechanism, but for ManyToManyField relationships. Prefetch can’t use a join here, so the <em>join</em> happens in Python at the ORM level. This can be a HUGE performance win for situations where you have a small number of rows in your ManyToManyField() vs a large number of rows in the model itself. However, in general, it’s less useful and thus used less often that <code>select_related()</code>. </p>

<p>So when do you use these you ask? The easiest thing to do is fire up <a href="https://django-debug-toolbar.readthedocs.org/en/1.3/">django-debug-toolbar</a> with your project and some representative data. By representative I mean you shouldn’t have a single BlogPost and a single User, try more like 100+ of each. </p>

<p>Then all you need to do is browse around your app locally with the debug toolbar open looking specifically at the query counts and times. If you see anything over 5–10 queries going on this is your clue to investigate. </p>

<p>Most of the time with 100s of objects in your database you’ll stumble across a view that is doing 200–500+ queries where one of these two options will be a huge win for you. Change your queryset, refresh, and make sure that both your query counts decreased but also your overall time. Occasionally you’ll have a situation where it’s actually faster to do the extra queries vs using joins it happens rarely, but still worth checking the overall query time to make sure you aren’t making things worse. </p>


    
    
    
        <p><strong>Tags:</strong> <small>
            
            <a href="/blog/tags/django/">django</a>,
            
            <a href="/blog/tags/postgresql/">postgresql</a>,
            
            <a href="/blog/tags/python/">python</a>
            
        </small></p>
    
</article>





    
    


            </div></body></html>