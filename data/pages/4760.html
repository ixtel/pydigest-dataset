<html><body><div><p> и немного длинных запросов с парой рецептов. Иногда бывает удобно когда какие-то мелочи собраны в одном месте, надеюсь, каждый, кто интересуется </p><p>, найдет для себя что-то полезное.
</p><p> И так понятно что везде есть свои плюсы и минусы, в данном случае это просто где-то немного справки, где-то немного примеров из того, с чем приходилось сталкиваться. Примеры на </p><p> была добавлена новая система назначения прав пользователей на базы, отдельные коллекции. И, соответственно, при обновлении это нужно учитывать.
</p><p>. С </p><p> перейти не получится нет обратной совместимости, поэтому нужно поэтапно обновлять.
</p><p> и выполнить несколько команд, которые проверят совместимость документов.
</p><p>, как уже было сказано, появились разграничения по ролям и выставление прав для любого пользователя вплоть до коллекции на чтение, запись и т.д., то соответственно надо задать эти роли, иначе не сможете выполнить команду </p><p>. 
</p><p>
4) После этого зайти в свою нужную базу, с которой собрались работать и к которой хотим подключиться, и создаем там пользователя.
</p><p>
Ну и не забываем перегрузить после всего этого.
</p><p> скорее всего, это связано с отсутствием обратной совместимости чтобы при обновлении не перепутать.

</p><p> и революционных изменениях в движке хранилища было уже написано много, не буду повторяться. 
</p><p> не перескакивая. То есть </p><p>.</p><p>.</p><p>
Для каждого компонента указываем версию при установке.
</p><p> то все прошло нормально и теперь можно сменить хранилище. По умолчанию стоит </p><p>.
</p><p> то все нормально.
</p><p>
Даже без обновления самой базы, не все будет работать как прежде. Из того, что сразу было замечено:
</p><code><pre><code class="python">db.test.find({ field:  }).<br/>

{ _id: 1, item: { name: "ab", code: "123" }, qty: 15, tags: [ "A", "B", "C" ] }
{ _id: 2, item: { name: "cd", code: "123" }, qty: 20, tags: [ "B" ] }

db.test.find( { qty: { $eq: 20 } } )
#Аналогичен
db.test.find( { qty: 20 } )

db.test.find( { tags: { $eq: [ "A", "B" ] } } )
#Аналогичен выражению:
db.test.find( { tags: [ "A", "B" ] } ) 
</code></pre><br/>
<em><font>$gt больше чем</font></em><br/>
<code>$gt</code> выбирает те документы, где значение поля больше <code>(&gt;)</code> указанного значения.<br/>
<pre><code class="bash">db.test.find( { qty: { $gt: 10 } } )
</code></pre><br/>
<em><font>$gte больше или равно чем</font></em><br/>
<code>$gte</code> выбирает те документы, где значение поля больше или равно <code>(&gt;=)</code> указанного значения.<br/>
<pre><code class="bash">db.test.find( { qty: { $gte: 10 } } )
</code></pre><br/>
<em><font>$lt меньше чем</font></em><br/>
<code>$lt</code> выбирает те документы, где значение поля меньше <code>(&lt;)</code> указанного <br/>
<pre><code class="bash">db.test.find( { qty: { $lt: 10 } } )
</code></pre><br/>
<em><font>$lte меньше или равно чем</font></em><br/>
<code>$lte</code> выбирает те документы, где значение поля меньше или равно <code>(&lt;=)</code> указанного <br/>
<pre><code class="bash">db.test.find( { qty: { $lte: 10 } } )
</code></pre><br/>
Если прибыль продавца меньше <code>100</code>, то премия аннулируется.<br/>
<pre><code class="bash">db.test.update({ "vendor.profit": { $lte: 100 } }, { $set: { premium: 0 } })
</code></pre><br/>
<em><font>$ne не равно</font></em><br/>
<code>$ne</code> выбирает документы, где значение поля не равно <code>(! =)</code> указанному значению.<br/>
<pre><code class="bash">db.test.find( { qty: { $ne: 10 } } )
</code></pre><br/>
<em><font>$in проверка на вхождение</font></em><br/>
<pre><code class="bash">{ _id: 1, qty: 10, tags: [ "name", "lastname" ], }
db.test.find({ tags: { $in: ["name", "lastname"] } }  )
</code></pre><br/>
Пример с регулярным выражением<br/>
<pre><code class="bash">db.test.find( { tags: { $in: [ /^be/, /^st/ ] } } )
</code></pre><br/>
<em><font>$nin проверка на невхождение</font></em><br/>
Тоже что и <code>$in</code> но наоборот, проверяет, что какое-то значение отсутствует в массиве.<br/>
<pre><code class="python">
db.test.find( { qty: { $nin: [ 5, 15 ] } } )
</code></pre><br/>
<em><font>$or оператор или</font></em><br/>
Классический оператор <code>или</code>, берет несколько значений и проверяет что условию соответствует хотя бы одно из них.<br/>
<pre><code class="python">
db.test.find( { $or: [ { quantity: { $lt: 10 } }, { price: 10 } ] } )
</code></pre><br/>
Для этого запроса предлагается составить два индекса:<br/>
<pre><code class="python">
db.test.createIndex( { quantity: 1 } )
db.test.createIndex( { price: 1 } )
</code></pre><br/>
Если <code>$or</code> используется вместе с оператором <code>$text</code>, предназначенным для полнотекстового поиска то индекс должен быть обязательно.<br/>
<br/>
<em><font>$and оператор "и"</font></em><br/>
Оператор <code>и</code> проверяет присутствие всех перечисленных значений в искомых документах.<br/>
<pre><code class="python">
db.test.find( { $and: [ { price:10 }, { check: true } } ]
</code></pre><br/>
Пример вместе с <code>$or</code>:<br/>
<pre><code class="python">
db.test.find( {
    $and : [
        { $or : [ { price : 50 }, { price : 80 } ] },
        { $or : [ { sale : true }, { qty : { $lt : 20 } } ] }
    ]
} )
</code></pre><br/>
<em><font>$not оператор отрицания</font></em><br/>
Проверяет чтобы в выборке не было документов, соответствующих условию.<br/>
<pre><code class="python">
db.test.find( { price: { $not: { $gt: 10 } } } )
</code></pre><br/>
Пример с регулярным выражением:<br/>
<pre><code class="python">
import re
for no_docs in db.test.find( { "item": { "$not": re.compile("^p.*") } } ):
    print no_docs
</code></pre><br/>
<em><font>$nor оператор не или</font></em><br/>
<pre><code class="javascript">db.test.find( { $nor: [ { price: 10 }, { qty: { $lt: 20 } }, { sale: true } ] } )
</code></pre><br/>
Этот запрос в коллекции test найдет те документы в которых:<br/>
<ul>
<li>Значение поля <code>price</code> не равно 10</li>
<li>Значение поля <code>qty</code> не менее 20</li>
<li>Значение <code>sale</code> не <code>true</code></li>
</ul><br/>
<em><font>$exists проверка поля на существование</font></em><br/>
<code>$exists</code> извлекает те документы, в которых определенный ключ присутствует или отсутствует.<br/>
Если укажем у <code>$exists</code> в качестве параметра <code>false</code>, то запрос вернет те документы, в которых не определен ключ <code>qty</code>.<br/>
<pre><code class="python">
db.test.find( { qty: { $exists: true } } )
</code></pre><br/>
<em><font>$type проверка <code>BSON</code> типа</font></em><br/>
<pre><code class="python">
db.test.find( { field: { $type: -1 } } );
</code></pre><br/>
<div class="spoiler"><b class="spoiler_title">Возможные типы:</b><div class="spoiler_text"><table border="1">
<tbody>
<tr>
<td><strong>Тип</strong></td>
<td><strong>Номер</strong></td>
<td><strong>Аннотации</strong></td>
</tr>
<tr>
<td>Double</td>
<td>1</td>
<td> </td>
</tr>
<tr>
<td>String</td>
<td>2</td>
<td> </td>
</tr>
<tr>
<td>Object</td>
<td>3</td>
<td> </td>
</tr>
<tr>
<td>Array</td>
<td>4</td>
<td> </td>
</tr>
<tr>
<td>Binary data</td>
<td>5</td>
<td> </td>
</tr>
<tr>
<td>Undefined</td>
<td>6</td>
<td>Deprecated.</td>
</tr>
<tr>
<td>Object id</td>
<td>7</td>
<td> </td>
</tr>
<tr>
<td>Boolean</td>
<td>8</td>
<td> </td>
</tr>
<tr>
<td>Date</td>
<td>9</td>
<td> </td>
</tr>
<tr>
<td>Null</td>
<td>10</td>
<td> </td>
</tr>
<tr>
<td>Regular Expression</td>
<td>11</td>
<td> </td>
</tr>
<tr>
<td>JavaScript</td>
<td>13</td>
<td> </td>
</tr>
<tr>
<td>Symbol</td>
<td>14</td>
<td> </td>
</tr>
<tr>
<td>JavaScript (with scope)</td>
<td>15</td>
<td> </td>
</tr>
<tr>
<td>32-bit integer</td>
<td>16</td>
<td> </td>
</tr>
<tr>
<td>Timestamp</td>
<td>17</td>
<td> </td>
</tr>
<tr>
<td>64-bit integer</td>
<td>18</td>
<td> </td>
</tr>
<tr>
<td>Min key</td>
<td>255</td>
<td>Query with -1.</td>
</tr>
<tr>
<td>Max key</td>
<td>127</td>
<td> </td>
</tr>
</tbody>
</table>
</div></div><br/>
<em><font>$mod</font></em><br/>
Оператор <code>$mod</code> используется для выборки полей, значения которых делятся на первый аргумент и остаток от деления равняется второму. <br/>
Например, есть документы:<br/>
<pre><code class="bash">{ "_id" : 1, "item" : "aa123", "qty" : 0 }
{ "_id" : 2, "item" : "bb123", "qty" : 7 }
{ "_id" : 3, "item" : "cc123",  "qty" : 15 }
</code></pre><br/>
Запрос:<br/>
<pre><code class="python">
db.test.find( { qty: { $mod: [ 5, 0 ] } } )
</code></pre><br/>
Вернет следующие документы:<br/>
<pre><code class="bash">{ "_id" : 1, "item" : "aa123", "qty" : 0 }
{ "_id" : 3, "item" : "cc123", "qty" : 15 }
</code></pre><br/>
Аналог из <code>SQL</code> <br/>
<pre><code class="bash">select * from t where qty % 5 = 0;
</code></pre><br/>
C <code>2.6</code> версии запрещено передавать только один элемент, будет возращена ошибка. Также, если передать больше трех аргументов, тоже выдаст ошибку, в предыдущих версиях лишние аргументы просто игнорировались.<br/>
<em><font>$all выбрать соответствующие всем</font></em><br/>
Делает выборку больше чем по одному элементу массива.<br/>
<pre><code class="python">
db.test.find( { tags: { $all: [ "python", "mongodb", "javascript" ] } } )
</code></pre><br/>
<em><font>$elemMatch</font></em><br/>
Используется когда нужно сравнить два и более атрибутов, принадлежащих одному поддокументу.<br/>
Проверяет, что в массиве есть элемент подпадающий под все условия. <br/>
<pre><code class="python">
{ _id: 1, results: [ 82, 85, 88  ] }
{ _id: 2, results: [ 75, 88, 89 ] }
db.test.find(   { results: { $elemMatch: { $gte: 80, $lt: 85 } } } )
</code></pre><br/>
Получаем результат:<br/>
<pre><code class="python">
{ _id: 1, results: [ 82, 85, 88 ] }
</code></pre><br/>
Еще пример:<br/>
<br/>
<pre><code class="python">
{ _id: 1, results: [{ product: "abc", score: 10 }, { product: "xyz", score: 5}] }
{ _id: 2, results: [{ product: "abc", score: 8 }, { product: "xyz", score: 7}] }
{ _id: 3, results: [{ product: "abc", score: 7 }, { product: "xyz", score: 8}] }

&gt;db.test.find(
      { results: { $elemMatch: { product: "xyz", score: { $gte: 8 } } } }
 )

{ "_id": 3, "results": [{ "product": "abc", "score": 7 }, { "product": "xyz", "score": 8 } ] }
</code></pre><br/>
<br/>
<em><font>$size ищет по длине массива</font></em><br/>
Оператор <code>$size</code> находит документы, в которых количество элементов массива равно значению <code>$size</code>. Например, извлечем все документы, в которых в массиве laguages два элемента:<br/>
<pre><code class="python">
db.persons.find ({languages: {$size:2}})
</code></pre><br/>
Такой запрос будет соответствовать, например, следующему документу:<br/>
<pre><code class="python">
{"name": "Alex", "age": "32", languages: ["python", "mongodb"]}
</code></pre><br/>
<em><font>$ позиционный оператор</font></em><br/>
<code>$</code> может использоваться в разных случаях. Когда мы не знаем под каким индексом лежит значение в массиве но хотим его использовать, то применяем "позиционный оператор"<br/>
Например, есть документы:<br/>
<pre><code class="python">
{ "_id" : 3, "semester" : 1, "grades" : [ 85, 100, 90 ] }
{ "_id" : 4, "semester" : 2, "grades" : [ 79, 85, 80 ] }
</code></pre><br/>
И мы хотим, чтобы после поиска по ним вывелось только одно значение, соответствующее запросу, а не весь документ, но заранее мы не знаем какое значение там стоит.<br/>
<pre><code class="python">
&gt;db.test.find( { semester: 1, grades: { $gte: 85 } }, { "grades.$": 1 } )
{ "_id" : 3, "grades" : [ 85 ] }
</code></pre><br/>
Пример для update:<br/>
<pre><code class="python">
db.test.update( { _id: 22 } , { $set: { "array.$.name" : "alex" } } )
</code></pre><br/>
<em><font>$slice находит диапазон</font></em><br/>
<code>$slice</code> - находит диапазон значений хранящихся в массиве.<br/>
Найти первые 10 событий:<br/>
<pre><code class="python">
db.test.find( {  }, { "events" : { $slice: 10 }  }  )
</code></pre><br/>
Найти последние 10 событий:<br/>
<pre><code class="python">
db.test.find( {  }, { "events" : { $slice: -10 }  }  )
</code></pre><br/>
<br/>
<h3><a name="3"/> <font> Полнотекстовый поиск в Mongodb, regexp, индексы и пр.</font></h3><br/>
На Хабре была неплохая <a href="http://habrahabr.ru/post/174457/">публикация</a> про полнотекстовый поиск в <code>mongodb</code> но с того времени добавились новые операторы и новые возможности. <br/>
Текстовый поиск не работает без индексов, поэтому поговорим о них. <br/>
Простой индекс создается по любому текстовому полю или массиву. <br/>
<pre><code class="python">
db.test.createIndex(  {  title: "text",   content: "text"  }  )
</code></pre><br/>
Можно использовать название поля или подстановочный спецификатор:<br/>
<pre><code class="python">
db.text.createIndex( { "$**": "text" }  )
</code></pre><br/>
При создании индекса для полнотекстового поиска надо учитывать язык, если это не английский.<br/>
<pre><code class="python">
db.test.createIndex( { content : "text" }, { default_language: "russian" } )
</code></pre><br/>
Начиная с версии <code>2.6</code> появилась возможность задания текстового индекса сразу для многих языков.<br/>
<div class="spoiler"><b class="spoiler_title">Встроенные языки с сокращениями по которым можно строить индекс.</b><div class="spoiler_text"><ul>
<li>da or danish</li>
<li>nl or dutch</li>
<li>en or english</li>
<li>fi or finnish</li>
<li>fr or french</li>
<li>de or german</li>
<li>hu or hungarian</li>
<li>it or italian</li>
<li>nb or norwegian</li>
<li>pt or portuguese</li>
<li>ro or romanian</li>
<li>ru or russian</li>
<li>es or spanish</li>
<li>sv or swedish</li>
<li>tr or turkish</li>
</ul>
</div></div><br/>
<code>MongoDB</code> будет использовать указанный в документе язык при построении индекса. Язык указанный в документе перекрывает язык по умолчанию. Язык во встроенном документе переопределяет все остальные для индекса.<br/>
<pre><code class="python">
{ _id: 1,
   language: "portuguese",
   original: "A sorte protege os audazes.",
   translation: [
        { language: "english", quote: "Fortune favors the bold." },
        { language: "russian", quote: "Фортуна любит смелых." }
    ] 
}
</code></pre><br/>
<br/>
Также, есть возможность с помощью параметра <code>language_override</code> указывать поле с языком.<br/>
Например, для документов:<br/>
<pre><code class="python">
{ _id: 2, idioma: "english", quote: "Fortune favors the bold." }
{ _id: 3, idioma: "russian", quote: "Фортуна любит смелых." }
</code></pre><br/>
Индекс будет выглядеть таким образом:<br/>
<pre><code class="python">
db.text.createIndex( { quote : "text" },  { language_override: "idioma" } )
</code></pre><br/>
Индексу можно назначать специальное имя <code> { name: "name" } </code>, например:<br/>
<pre><code class="python">
db.text.createIndex(  { content: "text", "users.title": "text" },  {   name: "text_Index"  }  )
</code></pre><br/>
Имя удобно использовать для удаления индексов:<br/>
<pre><code class="python">
db.text.dropIndex("text_Index")
</code></pre><br/>
Также, для текстового индекса можно задавать значимость, вес поля для поиска.<br/>
Например установим вес для следующих полей: <code>content - 10</code>, <code>keywords - 5</code>, и <code>title - 1</code>.<br/>
<pre><code class="python">
db.test.createIndex( 
        {  content: "text", tags: "text", title: "text" },
        { weights: { content: 10, tags: 5, }, name: "TextIndex"}
)
</code></pre><br/>
Через индекс можно ограничить кол-во записей в выдаче:<br/>
<pre><code class="python">
{ _id: 1, dept: "one", content: "red" }
{ _id: 3, dept: "one", content: "red" }
{ _id: 2, dept: "two", content: "gren" }
db.test.createIndex( {  dept: 1,  content: "text"   } )
db.test.find( { dept: "one", $text: { $search: "green" } } )
</code></pre><br/>
На выходе будет только один документ вместо двух, так как мы ограничили в индексе.<br/>
Пример индекса для <code>Python</code>:<br/>
<pre><code class="python">
#PyMongo
db.text.ensure_index( [ ('descr', "text" ), ( 'title.ru', "text" ) ], default_language="russian", name="full_text")
</code></pre><br/>
<h5>Текстовый поиск</h5> <br/>
Сразу после появления текстового поиска в mongodb он осуществлялся с помощью <code>runCommand</code> например:<br/>
<pre><code class="python">
db.collection.runCommand( "text", { search: "меч" } )
</code></pre><br/>
но, начиная с версии <code>2.6</code>, появился новый оператор <em><font>$text</font></em> <br/>
Поиск по одному слову:<br/>
<pre><code class="python">
db.articles.find( { $text: { $search: "coffee" } } )
</code></pre><br/>
Поиск по нескольким словам:<br/>
<pre><code class="python">
db.articles.find( { $text: { $search: "bake coffee cake" } } )
</code></pre><br/>
Поиск по фразе:<br/>
<pre><code class="python">
db.articles.find( { $text: { $search: "\"coffee cake\"" } } )
</code></pre><br/>
Исключение поля из поиска через <em><font>-</font></em><br/>
<pre><code class="python">
db.articles.find( { $text: { $search: "bake coffee -cake" } } )
</code></pre><br/>
Также с <code>mongodb 2.6</code> появился еще один оператор <em><font>$meta</font></em>, показывающий точность совпадения результата с запросом. <br/>
<pre><code class="python">
db.text.insert([
	{ "_id": 4,  "descr" : "новый мировой порядок" },
	{ "_id": 3,  "descr" : "мы живем в стране такой-то" },
	{ "_id":6,   "descr" : "новый мировой порядок" },
	{ "_id":7,   "descr" : "лучшие технологии в мире" },
	{ "_id":8,   "descr" : "чего все хотят" },
	{ "_id":9,   "descr" : "страна, в которой мы живем" },
	{ "_id":10, "descr" : "город, в котором мы живем" },
	{ "_id":11, "descr" : "жизнь проходит своим чередом" }
	{ "_id":12, "descr" : "просто хороший порядок" },
	{ "_id":13, "descr" : "плохой порядок" },
])
db.text.createIndex( { descr : "text" }, { default_language: "russian" } )
db.text.find( { $text: { $search: "порядок" } },  { score: { $meta: "textScore" } }).sort( { score: { $meta: "textScore" } } )

{ "_id" : 13, "descr" : "плохой порядок", "score" : 0.75 }
{ "_id" : 4, "descr" : "новый мировой порядок", "score" : 0.6666666666666666 }
{ "_id" : 6, "descr" : "новый мировой порядок", "score" : 0.6666666666666666 }
{ "_id" : 12, "descr" : "просто хороший порядок", "score" : 0.6666666666666666 }
</code></pre><br/>
Тут <code> { score: { $meta: "textScore" } }</code> мы создаем новое поле в его значении содержится результат и дальше оно уже участвует в сортировке.<br/>
<em><font>Поиск через $regex</font></em><br/>
<code>MongoDB</code> использует <code>Perl</code>-совместимые регулярные выражения. <br/>
<pre><code class="python">
db.test.insert([
    { "_id" : 1, "descr" : "abc123" },
    { "_id" : 2, "descr" : "abc123" },
    { "_id" : 3, "descr" : "eee789" }
])
db.test.find( { sku: { $regex: /^ABC/i } } )
{ "_id" : 1, "sku" : "abc123", "description" : "Single line description." }
{ "_id" : 2, "sku" : "abc123", "description" : "Single line description." }
</code></pre><br/>
<code>i</code> - Нечувствительность к регистру.<br/>
Аналог из <code>PostgreSQL</code><br/>
<pre><code class="bash">select title from article where title ~ '^a'
'abc'
</code></pre><br/>
<br/>
<h3><a name="4"/> <font> Атомарные операторы (модифицирующие данные ) </font></h3><br/>
Как правило все эти модификаторы используются для операций обновления в <code>db.test.update()</code> и <code>db.test.findAndModify() </code><br/>
<br/>
<em><font>$inc инкремент</font></em><br/>
Увеличивает или уменьшает поле на заданное значение<br/>
<pre><code class="python">
db.test.update( { _id: 1 }, { $inc: { qty: -2, "orders": 1 } } )
</code></pre><br/>
<em><font>$mul мультипликативный инкремент</font></em><br/>
Умножает значение поля на заданную величину.<br/>
<pre><code class="python">
{ _id: 5, item: "mac", price: 10 }
db.test.update({ _id: 1 }, { $mul: { price: 2 } } )
{ _id: 5, item: "mac", price : 20 }
</code></pre><br/>
<em><font>$rename переименование поля</font></em><br/>
<pre><code class="python">
{ "_id": 1,   "name": "alex" }
db.test.update( { _id: 1 }, { $rename: { 'name': 'alias'} } )
{ "_id": 1,   "alias": "alex" }
</code></pre><br/>
<em><font>$set изменяет значение полей</font></em><br/>
Наверно это основной модифицирующий оператор, применяемый вместе с <code>update</code>. Часто о нем вспоминают как о простеньких транзакциях в контексте mongodb.<br/>
<pre><code class="python">
db.test.save({ "_id":8,   "qty":"", tags:"" })
db.test.update( { _id: 8 }, { $set: { qty: 100, tags: [ "linux", "ubuntu"]  } })
{ "_id" : 8, "qty" : 100, "tags" : [ "linux", "ubuntu" ] }
</code></pre><br/>
<em><font>$setOnInsert добавляет поля в новый документ</font></em><br/>
В <code>update</code> третьим аргументом идет опция <code>{ upsert: true }</code> это значит, что если документ для изменения не найден, то мы создаем новый. А опция <code>$setOnInsert</code> говорит нам какие поля туда вставить.<br/>
<pre><code class="python">
&gt;db.test.update(  
    { _id: 7 }, { $set: { item: "windows" }, $setOnInsert: { os: 'bad' } }, { upsert: true } )
{ "_id" : 7, "item" : "windows", "os" : "bad" }
</code></pre><br/>
Поле, для которого мы выполняем <code>$set</code> тоже появится в новосозданном документе.<br/>
<em><font>$unset удаляет ключ</font></em><br/>
<pre><code class="python">
{ "_id" : 8, "qty" : 100, "tags" : [ "linux", "ubuntu" ] }
db.test.update( { _id: 8 }, { $unset:  { qty: "",  tags: ""  } } )
{ "_id" : 8 }
</code></pre><br/>
<em><font>$min обновляет, если меньше</font></em><br/>
<code>$min</code> обновляет поле, если указанное значение меньше текущего значения поля, <code>$min</code> может сравнивать значения различных типов.<br/>
<pre><code class="python">
&gt; db.test.save({ _id: 9, high: 800, low: 200 })
&gt; db.test.update( { _id:9 }, { $min: { low: 150 } } )
&gt;db.test.findOne({_id:9})
{ "_id" : 9, "high" : 800, "low" : 150 }
</code></pre><br/>
<em><font>$max обновляет если больше</font></em><br/>
<code>$max</code> обновляет поле, если указанное значение больше текущего значения поля.<br/>
<pre><code class="python">
&gt; db.test.save({ _id: 9, high: 800, low: 200 })
&gt; db.test.update( { _id:9 }, { $max: { high: 900 } } )
&gt; db.test.findOne({_id:9})
{ "_id" : 9, "high" : 900, "low" : 200 }
</code></pre><br/>
<em><font>$currentDate устанавливает текущую дату</font></em><br/>
Устанавливает значением поля текущую дату.<br/>
<pre><code class="python">
&gt; db.test.save({ _id:11, status: "init", date: ISODate("2015-05-05T01:11:11.111Z") })
&gt; db.test.update( { _id:12 },  { $currentDate: { date: true } } )
&gt; db.test.findOne({_id:12})
{ "_id" : 12, "status" : "a", "date" : ISODate("2015-05-10T21:07:31.138Z") }
</code></pre><br/>
<h5>Изменения массивов<h5><em><font>$addToSet добавляет значение, если его нет</font></em><br/>
Добавляет значение в массив, если его там еще нет, а если есть, то ничего не делает.<br/>
<pre><code class="python">
&gt; db.test.save({ _id:1, array: ["a", "b"] })
&gt; db.test.update( { _id: 1 }, { $addToSet: {array: [ "c", "d" ] } } )
{ "_id" : 1, "array" : [ "a", "b", [ "c", "d" ] ] }
&gt; db.test.update( { _id: 1 }, { $addToSet: {array: "e"  } } )
{ "_id" : 1, "array" : [ "a", "b", [ "c", "d" ], "e" ] }
</code></pre><br/>
<em><font>$pop удаляет 1-й или последний</font></em><br/>
Удаляет первый или последний элемент массива. Если указано -1 то удалит первый элемент, если указано 1, то последний.<br/>
<pre><code class="python">
&gt; db.test.save({ _id: 1, scores: [ 6, 7, 8, 9, 10 ] })
{ "_id" : 1, "scores" : [ 6, 7, 8, 9, 10 ] }
&gt; db.test.update( { _id: 1 }, { $pop: { scores: -1 } } )
&gt; db.test.findOne({_id:1})
{ "_id" : 1, "scores" : [ 7, 8, 9, 10 ] }
&gt; db.test.update( { _id: 1 }, { $pop: { scores: 1 } } )
&gt; db.test.findOne({_id:1})
{ "_id" : 1, "scores" : [ 7, 8, 9 ] }
</code></pre><br/>
<em><font>$pullAll удаляет все указанные</font></em><br/>
Удаляет все указанные элементы из массива.<br/>
<pre><code class="python">
{ _id: 1, scores: [ 0, 2, 5, 5, 1, 0 ] }
db.test.update( { _id: 1 }, { $pullAll: { scores: [ 0, 5 ] } } )
{ "_id" : 1, "scores" : [ 2, 1 ] }
</code></pre><br/>
<em><font>$pull удаляет в соответствии с запросом</font></em><br/>
<pre><code class="python">
{ _id: 1, votes: [ 3, 5, 6, 7, 7, 8 ] }
&gt; db.test.update( { _id: 1 }, { $pull: { votes: { $gte: 6 } } } )
{ _id: 1, votes: [  3,  5 ] }
</code></pre><br/>
<em><font>$push добавляет значения</font></em><br/>
Добавляет значения в массив.<br/>
<pre><code class="python">
db.test.update( { _id: 1 }, { $push: { scores: 100} } )
</code></pre><br/>
<code>$pushAll</code> - считается устаревшим<br/>
<h5>Модификаторы для $push<h5><em><font>$each сразу много</font></em><br/>
Добавляет каждый из перечисленных элементов в массив<br/>
Например если мы сделаем так: <code>{ $push: { scores: [ 2, 10 ] } }</code><br/>
То на выходе получится такой массив: <code>"scores" : [7, 8, 9, 90, 92, 85, [ 2, 10 ] ] </code><br/>
то есть добавился еще один элемент являющийся массивом.<br/>
А если через <code>$each</code>, то добавится каждый элемент списка как элемент массива:<br/>
<pre><code class="python">
&gt; db.test.update( { _id: 1 }, { $push: {scores: { $each: [ 90, 92, 85 ] } } }  )
{"_id" : 1, "scores" : [7, 8, 9, 90, 92, 85, 2, 10  ] }
</code></pre><br/>
<em><font>$slice ограничивает количество элементов при использовании $push</font></em><br/>
Ограничивает количество элементов массива при вставке с помощью <code>$push</code>. Обязательно использует <code>$each</code> если попытаться без него использовать, то вернет ошибку.<br/>
<pre><code class="python">
{ "_id" : 1, "scores" : [ 10, 20, 30 ] }
&gt; db.test.update( { _id: 1 }, { $push: { scores: { $each: [50, 60, 70], $slice: -5 } } } )
{ "_id" : 1, "scores" : [  20,  30,  50,  60,  70 ] }
</code></pre><br/>
<code>$slice</code> отрезал первый элемент <code>20</code>. если бы мы указали не <code>-5</code> а <code>5</code> то он бы откинул последний элемент <code>70</code>.<br/>
<br/>
<em><font>$sort сортировка элементов массива</font></em><br/>
Сортирует элементы массива в соответствии с указанным полем. Также обязательно использовать с оператором <code>$each</code>. Если нужно просто отсортировать без вставки, то <code>$each</code> можно оставить пустым.<br/>
<pre><code class="python">
{ "_id" : 2, "tests" : [  80,  70,  80,  50 ] }
&gt; db.test.update( { _id: 2 }, { $push: { tests: { $each: [40, 60], $sort: 1 } } })
{ "_id" : 2, "tests" : [  40,  50,  60,  70,  80,  80 ] }
</code></pre><br/>
Еще пример:<br/>
<pre><code class="python">
db.test.update( { _id: 1 }, { $push: { field: { $each: [ ], $sort: { score: 1 } } } })
{  "_id" : 1, "field" : [ 
     { "id" : 3, "score" : 5 },
     { "id" : 2, "score" : 6 },
     { "id" : 1, "score" : 7 },
  ]
}
</code></pre><br/>
<em><font>$position указывает позицию вставки</font></em><br/>
Указывает с какого по счету элемента массива вставить значения.<br/>
<pre><code class="python">
{ "_id" : 1, "scores" : [ 100 ] }
db.test.update({ _id: 1 }, {$push: { scores: { $each: [50, 60, 70], $position: 0 } } })
{ "_id" : 1, "scores" : [  50,  60,  70,  100 ] }
</code></pre><br/>
<br/>
<em><font>$bit побитово обновляет</font></em><br/>
Выполняет побитовое обновление поля. Оператор поддерживает побитовые <code>and</code>, <code>or</code> и <code>xor</code>.<br/>
<pre><code class="python">
{ "_id" : 1, "expdata" : 13 }
&gt; db.bit.update({_id:1}, {$bit:{expdata:{and:NumberInt(10)} } } )
{ "_id" : 1, "expdata" : 8 }
</code></pre><br/>
<br/>
<em><font>$isolated - атомизация</font></em><br/>
Блокирует документ для чтения и записи, пока с ним происходит, например, операция обновления.<br/>
Использование <code>$isolated</code> при удалении:<br/>
<pre><code class="python">
db.test.remove( { temp: { $lt: 10 }, $isolated: 1 } )
</code></pre><br/>
Использование <code>$isolated</code> при обновлении:<br/>
<pre><code class="python">
db.test.update( {status: "init" , $isolated: 1 },  { $inc: { count : 1 }},  {multi: true } )
</code></pre><br/>
<i>$isolated не работает с шардированными кластерами</i><br/>
С версии <code>2.2</code>: оператор <code>$isolated</code> заменил <code>$atomic</code><br/>
<br/>
<h3><a name="5"/> <font>О транзакциях в mongodb, уникальный индекс, двухфазный коммит</font></h3><br/>
Естественно таких транзакций как в классических <code>SQL</code> решениях типа <code>PostgreeSQL</code> в <code>MongoDB</code> нет и наверно не может быть. А если появится, то это будет уже, скорее, реляционная база данных с полноценной нормализацией и контролем целостности.<br/>
Поэтому, говоря о транзакциях в <code>mongoDB</code>, как правило, имеют в виду атомарные операции типа <code>$set</code>, применяемые в <code>update()</code> и <code>findAndModify()</code> в сочетании с уникальным индексом. А также двухфазный коммит, который распространен среди реляционных баз данных, если нужно обеспечить транзакции в пределах нескольких баз. <br/>
<br/>
<h3><a name="51"/> <font>Уникальный индекс</font></h3><br/>
Уникальный индекс в <code>mongodb</code> является причиной отклонить все документы, которые содержат повторяющиеся значения для индексированных полей.<br/>
<pre><code class="python">
db.test.createIndex( { "user_id": 1 }, { unique: true } )
</code></pre><br/>
Есть коллекция, назовем её <code>test</code>, в этой коллекции нет документов у которых поле <code>name</code> имело бы значение <code>Nik</code>. Предположим, что сразу несколько клиентов одновременно пытается обновить этот документ с параметром <code>{ upsert: true }</code> (означает, что если по условию нет такого документа для обновления, то его нужно создать).<br/>
Пример:<br/>
<pre><code class="python">
db.test.update( { name: "Nik" }, { name: "Nik", vote: 1 }, { upsert: true } )
</code></pre><br/>
Если все операции <code>update()</code> успешно выполнили запрос и нашли обновляемый документ прежде, чем любой из клиентов вставит свои данные, и нет уникального индекса на поле, то все операции обновления могут вставить данные.<br/>
<br/>
Для предотвращения вставки в один и тот же документ несколько раз, нужно создать уникальный индекс на поле. Тогда одна из операций обновлений точно вставит новый документ. Остальные операции либо обновят недавно вставленный документ, либо не смогут выполнить операцию если попытаются вставить дублирующие значения.<br/>
<br/>
По умолчанию <code>unique</code> является <code>false</code> в индексах <code>MongoDB</code><br/>
<br/>
<h3><a name="52"/> <font>Двухфазный коммит</font></h3><br/>
Рассмотрим пример из документации, операцию по переводу денежных средств со счета <code>A</code> на счет <code>B</code>.<br/>
У нас в примере есть две коллекции:<br/>
<ul>
<li>Коллекция <code>accounts</code> где будут хранится счета с которыми мы будем проводить операции.</li>
<li>И коллекция <code>transactions</code> где будут хранится информация о переводе средств, можно сказать информация о транзакциях. </li>
</ul><br/>
<em><font>Инициализация коллекций accounts и transactions</font></em><br/>
Вставляем в коллекцию <code>accounts</code> два документа соответственно для счетов <code>А</code> и <code>В</code><br/>
<pre><code class="python">
db.accounts.insert(
   [
     { _id: "A", balance: 1000, pendingTransactions: [] },
     { _id: "B", balance: 1000, pendingTransactions: [] }
   ]
)
</code></pre><br/>
В коллекцию <code>transactions</code> для каждого перевода средств вставляем документ с информацией о транзакции.<br/>
<pre><code class="python">
db.transactions.insert({ _id: 1, source: "A", destination: "B", value: 100, state: "initial", lastModified: new Date()})
</code></pre><br/>
Где у нас есть следующие поля:<br/>
<ul>
<li>Поля <code>source</code> и <code>destination</code> обозначают исходящий счет и счет на который мы будем переводить средства.</li>
<li>Поле <code>value</code>, определяет сумму которую будут переводить со счета на счет.</li>
<li>Поле <code>state</code> будет сигнализировать о текущем статусе операции. Может иметь следующие состояния <code>initial</code>, <code>pending</code>, <code>applied</code>, <code>done</code>, <code>canceling</code>, и <code>canceled</code>.</li>
<li><code>lastModified</code> поле в котором будет хранится время последней модификации.</li>
</ul><br/>
<br/>
<em><font>1) Получение документа с транзакцией </font></em><br/>
Получаем документ с транзакцией, имеющей статус <code>initial</code>. И присваиваем его переменной <code>t</code> <br/>
<pre><code class="bash">&gt; var t = db.transactions.findOne( { state: "initial" } )
&gt; t
{ "_id" : 1, "source" : "A", 	"destination" : "B", "value" : 100, "state" : "initial", "lastModified" : ISODate("2015-05-26T16:35:54.637Z") }
</code></pre><br/>
<br/>
<em><font>2) Обновление статуса транзакции до состояния pending</font></em><br/>
Меняем состояние нужной транзакции с <code>initial</code> на <code>pending</code> и устанавливаем текущую дату.<br/>
<pre><code class="python">
&gt; db.transactions.update(
    { _id: t._id, state: "initial" },
    { $set: { state: "pending" }, $currentDate: { lastModified: true } }
)
&gt; db.transactions.find()
{ "_id" : 1, "source" : "A", "destination" : "B", "value" : 100, "state" : "pending", "lastModified" : ISODate("2015-05-26T17:02:19.002Z") }
&gt; 
</code></pre><br/>
<br/>
<em><font>3) Изменение обоих счетов</font></em><br/>
Изменяем баланс у обоих документов средства, одному увеличиваем на количество, равное полю <code>value</code> из документа транзакции, а в поле <code>pendingTransactions</code> заносим <code>_id</code> транзакции (документа где хранится информация о транзакции).<br/>
<pre><code class="python">
&gt; db.accounts.update(
   { _id: t.source, pendingTransactions: { $ne: t._id } },
   { $inc: { balance: -t.value }, $push: { pendingTransactions: t._id } }
)

&gt; db.accounts.update(
   { _id: t.destination, pendingTransactions: { $ne: t._id } },
   { $inc: { balance: t.value }, $push: { pendingTransactions: t._id } }
)

&gt; db.accounts.find()
{ "_id" : "A", "balance" : 900,   "pendingTransactions" : [ 1 ] }
{ "_id" : "B", "balance" : 1100, "pendingTransactions" : [ 1 ] }
</code></pre><br/>
<br/>
<em><font>4) Обновление транзакции до состояния applied</font></em><br/>
Обновляем документ с транзакцией и не забываем установить дату последнего изменения.<br/>
<pre><code class="python">
&gt; db.transactions.update(
   { _id: t._id, state: "pending" },
   { $set: { state: "applied" }, $currentDate: { lastModified: true } }
)
&gt; db.transactions.find()
{ "_id" : 1, "source" : "A", "destination" : "B", "value" : 100, "state" : "applied", "lastModified" : ISODate("2015-05-26T17:13:15.517Z") }
</code></pre><br/>
<br/>
<em><font>5) Удаление _id транзакции из обоих документов</font></em><br/>
Находим оба документа в том числе по условию <code>pendingTransactions</code> : <code>_id</code> транзакции и очищаем у них поле <code>pendingTransactions</code>.<br/>
<pre><code class="python">
&gt; db.accounts.update(
   { _id: t.source, pendingTransactions: t._id },
   { $pull: { pendingTransactions: t._id } }
)
&gt; db.accounts.update(
   { _id: t.destination, pendingTransactions: t._id },
   { $pull: { pendingTransactions: t._id } }
)

&gt; db.accounts.find()
{ "_id" : "A", "balance" : 900, "pendingTransactions" : [ ] }
{ "_id" : "B", "balance" : 1100, "pendingTransactions" : [ ] }
 
</code></pre><br/>
<em><font>6) Обновление транзакции до состояния done</font></em><br/>
На этом двухфазный коммит завершён.<br/>
<pre><code class="python">
&gt; db.transactions.update(
   { _id: t._id, state: "applied" },
   { $set: { state: "done" },  $currentDate: { lastModified: true }  }
)
&gt; db.transactions.find()
{ "_id" : 1, "source" : "A", "destination" : "B", "value" : 100, "state" : "done", "lastModified" : ISODate("2015-05-26T17:22:22.194Z") }
</code></pre><br/>
<br/>
<h5>Откат двухфазного коммита</h5><br/>
Теперь рассмотрим случай если у нас остались несработавшие транзакции. В этом случае нам надо вернутся обратно и завершить.<br/>
<em><font>1) Устанавливаем состояние транзакции canceling </font></em><br/>
Находим все документы, которые были в ожидании, и устанавливаем состояние <code>canceling</code>.<br/>
<pre><code class="python">
db.transactions.update(
   { _id: t._id, state: "pending" }, 
   {$set: { state: "canceling" }, $currentDate: { lastModified: true }}
)
&gt; db.transactions.find()
{ "_id" : 1, "source" : "A", "destination" : "B", "value" : 100, "state" : "canceling", "lastModified" : ISODate("2015-05-26T18:29:28.018Z") }
</code></pre><br/>
<em><font>2) Отменяем транзакцию для обоих счетов</font></em><br/>
Возвращаем средства обратно на счет с которого переводили.<br/>
<pre><code class="python">
&gt; db.accounts.update(
   { _id: t.destination, pendingTransactions: t._id },
   {  $inc: { balance: -t.value }, $pull: { pendingTransactions: t._id }  }
)
&gt; db.accounts.update(
   { _id: t.source, pendingTransactions: t._id },
   { $inc: { balance: t.value}, $pull: { pendingTransactions: t._id } }
)

&gt; db.accounts.find()
{ "_id" : "A", "balance" : 1000, "pendingTransactions" : [ 1 ] }
{ "_id" : "B", "balance" : 1000, "pendingTransactions" : [ 1 ] }
&gt; 
</code></pre><br/>
<br/>
<em><font>3) Устанавливаем состояние транзакции cancelled</font></em><br/>
Обновляем состояние с отменяемой до отмененной.<br/>
<pre><code class="python">
db.transactions.update(
   { _id: t._id, state: "canceling" },
   { $set: { state: "cancelled" }, $currentDate: { lastModified: true } }
)
&gt; db.transactions.find()
{ "_id" : 1, "source" : "A", "destination" : "B", "value" : 100, "state" : "cancelled", "lastModified" : ISODate("2015-05-26T19:14:11.830Z") }
</code></pre><br/>
<br/>
<h5>Двухфазный коммит и много приложений</h5><br/>
Когда выполняются несколько приложений, важно чтобы только одно приложение обращалось к транзакции в одно и тоже время. Поэтому дополнительно нужно чтобы документ кроме состояния хранил еще и идентификатор приложения.<br/>
Также рекомендуется использовать метод <code>findAndModify()</code>, чтобы изменить транзакцию и получить документ с ней обратно в один шаг:<br/>
<br/>
<pre><code class="python">
t = db.transactions.findAndModify({
   query:  { state: "initial", application: { $exists: false } },
   update: {$set: { state: "pending", application: "App1"}, $currentDate:{ lastModified: true }},
   new: true
 })
</code></pre><br/>
<br/>
<h3><a name="6"/> <font>6. Агрегационный фреймворк и JOIN-ы</font></h3><br/>
Когда говорят про <code>JOIN</code>-ы в <code>mongo</code> или спрашивают про них, почему-то часто речь заходит о связывании отдельных коллекций. Часто такие подобные вопросы мелькают на <code>stackoverflow</code>, но следует понимать, что это невозможно. <br/>
<br/>
И, как правило, всегда рекомендуется документы, которые могут участвовать в одном запросе, помещать в одну коллекцию. <br/>
<br/>
А если потом есть желание разбить их на какие-то группы по определённым признакам, то различать их по одному из полей, например <code>{ type: 'news' }</code>.<br/>
<br/>
Но бывают случаи когда действительно надо взять несколько документов, у которых нет практически ничего общего, и объединить их в один документ.<br/>
<br/>
К сожалению, простого пути в данном случае нет и нужно делать либо несколько запросов, либо лепить довольно длинную цепочку в <code>aggregation framework</code>. Но на этом примере можно хорошо понять как работает <code>pipeline</code>. Вообще, это очень удобная штука, можно взять выборку документов и проделывать с ними любые операции, объединять, разбивать, группировать и т.д.<br/>
<br/>
Предположим, у нас есть две разновидности документов, в одной находятся пользователи и перечисляется группы к которым они относятся.<br/>
<pre><code class="python">
db.test.insert([
     { "_id":"gomer", "type":"user", "group":["user", "author"] },
     { "_id":"vasya", "type":"user", "group":["user"] }
])
</code></pre><br/>
И есть документы в которых находятся статьи написанные этими пользователями.<br/>
<pre><code class="python">
db.test.insert([
    { "_id": 1,  "type": "blogs", "user": "gomer", "article": "aaa" },
    { "_id": 2,  "type": "blogs", "user": "vasya", "article":  "bbb" },
    { "_id": 3,  "type": "blogs", "user": "gomer", "article": "ccc" }
])
</code></pre><br/>
Задача получить на выходе в одном документе пользователя, статьи которые он написал и группы в которых состоит. Конечно если бы мы это делали несколькими запросами, то все выглядело довольно просто.<br/>
<br/>
Выбрать из блогов только те статьи, где пользователь, опубликовавший материал, состоит в группе "автор".<br/>
<pre><code class="python">
users = [doc._id for doc in db.test.find({"type":'user', 'group': {'$all': ['author']}})]
articles = db.test.find({"type": "blogs", "user": {'$in': users})
</code></pre><br/>
Примерный аналог c джойном из SQL если мы членство в группах храним в таблице:<br/>
<pre><code class="python">
SELECT 
	blogs.*
FROM
	blogs, user, usergroup, group
WHERE
  blogs.user = user.id AND usergroup.user = user.id AND usergroup.group = group.id AND group.name = 'author';
</code></pre><br/>
Или если мы названия групп храним прямо в таблице user, если всё хранится в поле d типа jsonb. Селектами делается два списка - и дальше на них накладываются ровно те же условия:<br/>
<pre><code class="sql">SELECT blogs.*
FROM blogs, user
WHERE blogs.user = user.id AND user.group ? 'author';
SELECT blogs.*
FROM 
	(SELECT * FROM test WHERE d-&gt;type = 'blogs') blogs, 
	(SELECT * FROM test WHERE d-&gt;type = 'user') user
WHERE blogs.d-&gt;user = user.id AND user.d-&gt;group ? 'author';
</code></pre><br/>
Теперь попробуем повторить примерно то же самое с помощью pipe.<br/>
<pre><code class="python">
db.test.aggregate([
	{ $match:  { $or: [ {type: "blogs"}, {type: "user"} ] } },
  	{ $project: { 
			a: 1,
			blogs: {
				$cond: {
					if: { type: '$blogs'},
					then: {_id:"$_id", user:"$user", article:"$article"},
					else: null
				}
			},
			user: {
				$cond: {
					if: { type: '$user' },
					then: { _id:"$_id", group:"$group"},
					else: null
				}
			}
		}
	},
	{ $group : {
	           _id : { a: "$a" },
	           user: { $push: "$user" },
	           blog: { $push: "$blogs" },
	        }
	},
	{ $unwind : "$blog" },
	{ $unwind : "$user" },
	{ $project:{ 
		user: "$user",
		article: "$blog",
		matches: { $eq:[ "$user._id", "$blog.user" ] } }
	}, 
	{ $match: { matches: true } }
])
</code></pre><br/>
 Теперь разберем по порядку что делает запрос. Запрос состоит из 7 частей. <br/>
Как правило, в справке по <code>mongodb</code> и статьях про <code>pipeline</code> приводят эту табличку. Она не совсем отражает смысл каждого оператора, но, имея её перед глазами, немного помогает ориентироваться в длинных цепочках, ну и не забывать, что порядок может быть абсолютно любой и повторяться каждый оператор может много раз. <br/>
</h5></h5></h5></h5><table border="1">
<thead>
<tr>
<th>SQL Terms, Functions, and Concepts</th>
<th>MongoDB Aggregation Operators</th>
</tr>
</thead>
<tbody>
<tr>
<td><font>WHERE</font></td>
<td><font>$match</font></td>
</tr>
<tr>
<td><font>GROUP BY</font></td>
<td><font>$group</font></td>
</tr>
<tr>
<td><font>HAVING</font></td>
<td><font>$match</font></td>
</tr>
<tr>
<td><font>SELECT</font></td>
<td><font>$project</font></td>
</tr>
<tr>
<td><font>ORDER BY</font></td>
<td><font>$sort</font></td>
</tr>
<tr>
<td><font>LIMIT</font></td>
<td><font>$limit</font></td>
</tr>
<tr>
<td><font>SUM()</font></td>
<td><font>$sum</font></td>
</tr>
<tr>
<td><font>COUNT()</font></td>
<td><font>$sum</font></td>
</tr>
<tr>
<td><font>join</font></td>
<td> предлагают использовать оператор <font>$unwind</font></td>
</tr>
</tbody>
</table><br/>
Сначала мы находим все документы с которыми будем работать.<br/>
<pre><code class="python">
&gt; db.ag.aggregate([ { $match:   {$or:[{type:"blogs"},{type:"user"}]} }  ])
{ "_id" : "gomer", "type" : "user", "group" : [ "user", "author" ] }
{ "_id" : "vasya", "type" : "user", "group" : [ "user" ] }
{ "_id" : 1, "type" : "blogs", "user" : "gomer", "article" : "aaa" }
{ "_id" : 2, "type" : "blogs", "user" : "vasya", "article" : "bbb" }
{ "_id" : 3, "type" : "blogs", "user" : "gomer", "article" : "ccc" }
</code></pre><br/>
Сам по себе оператор <code>$match</code> похож на <code>find()</code>, единственное его преимущество в том, что он может встраивается в цепочку.<br/>
Дальше c помощью <code>$project</code> мы формируем новые документы, с основными полями <code>blogs</code> и <code>users</code>. Там мы используем появившийся с версии <code>2.6</code> оператор <code>$cond</code> который позволяет писать внутри себя логические выражения. Проверяем тип документа и уже по результату формируем поля <code>blogs</code> и <code>users</code>, чтобы потом было удобно группировать.<br/>
<pre><code class="python">
db.test.aggregate([
	{ $match:   {$or:[ { type:"blogs"}, { type: "user"} ] } },
  	{ $project: { 
			a: 1,
			blogs: {
				$cond: {
					if: {type: '$blogs'},
					then: {_id:"$_id", user:"$user", article:"$article"},
					else: null
				}
			},
			user: {
				$cond: {
					if: { type: '$user'},
					then: {_id:"$_id", group:"$group"},
					else: null
				}
			}
		}
	}
])
{ "_id": "gomer", "blogs": { "_id" : "gomer" }, "user": { "_id": "gomer", "group": [ "user", "author" ] } }
{ "_id": "vasya", "blogs": { "_id" : "vasya" }, "user" : { "_id" : "vasya", "group": [ "user" ] } }
{ "_id": 1, "user": { "_id": 1 }, "blogs" : { "_id": 1, "user": "gomer", "article": "aaa" } }
{ "_id": 2, "user": { "_id": 2 }, "blogs" : { "_id": 2, "user": "vasya", "article": "bbb" } }
{ "_id": 3, "user": { "_id": 3 }, "blogs" : { "_id": 3, "user": "gomer", "article": "ccc" } }
</code></pre><br/>
<br/>
Следующим этапом группируем эти документы:<br/>
<pre><code class="python">
...{ $group : {
           _id : { a: "$a" },
           user: { $push: "$user" },
           blog: { $push: "$blogs" },
        }
 }...

{ 
     "_id" : { "a" : null }, 
     "user": [
              { "_id": "gomer", "group": [ "user", "author" ] },  { "_id": "vasya", "group": [ "user" ] }, 
              { "_id": 1 }, { "_id": 2 }, { "_id": 3 } 
      ], 
     "blog": [ 
              { "_id": "gomer" }, { "_id": "vasya" }, { "_id": 1, "user": "gomer", "article": "aaa" }, 
              {  "_id": 2, "user": "vasya", "article": "bbb" }, { "_id": 3, "user": "gomer", "article": "ccc"} 
        ] 
}
</code></pre><br/>
<div class="spoiler"><b class="spoiler_title">Раскладываем полученный результат с помощью оператора $unwind</b><div class="spoiler_text"><pre><code class="python">
....{ $unwind : "$blog" },
    { $unwind : "$user" } ....

{ "_id": { "a":null }, "user": { "_id": "gomer", "group": [ "user", "author" ] }, "blog": { "_id": "gomer" } }
{ "_id": { "a":null }, "user": { "_id": "vasya", "group": [ "user" ] }, "blog" : { "_id": "gomer" } }
{ "_id": { "a":null }, "user": { "_id": 1 }, "blog": { "_id" : "gomer" } }
{ "_id": { "a" : null }, "user" : { "_id" : 2 }, "blog" : { "_id" : "gomer" } }
{ "_id": { "a" : null }, "user" : { "_id" : 3 }, "blog" : { "_id" : "gomer" } }
{ "_id": { "a": null }, "user": { "_id": "gomer", "group" : [ "user", "author" ] }, "blog": { "_id": "vasya"}}
{ "_id": { "a" : null }, "user" : { "_id" : "vasya", "group" : [ "user" ] }, "blog" : { "_id" : "vasya" } }
{ "_id": { "a" : null }, "user" : { "_id" : 1 }, "blog" : { "_id" : "vasya" } }
{ "_id": { "a" : null }, "user" : { "_id" : 2 }, "blog" : { "_id" : "vasya" } }
{ "_id": { "a" : null }, "user" : { "_id" : 3 }, "blog" : { "_id" : "vasya" } }
{ "_id": { "a" : null }, "user" : { "_id" : "gomer", "group" : [ "user", "author" ] }, "blog" : { "_id" : 1, "user": "gomer", "article" : "aaa" } }
{ "_id": { "a" : null }, "user": { "_id"  "vasya", "group": [ "user" ] }, "blog": { "_id": 1, "user": "gomer", "article": "aaa" } }
{ "_id": { "a" : null }, "user" : { "_id" : 1 }, "blog" : { "_id" : 1, "user" : "gomer", "article" : "aaa" } }
{ "_id" : { "a" : null }, "user" : { "_id" : 2 }, "blog" : { "_id" : 1, "user" : "gomer", "article" : "aaa" } }
{ "_id": { "a" : null }, "user" : { "_id" : 3 }, "blog" : { "_id" : 1, "user" : "gomer", "article" : "aaa" } }
{ "_id": { "a" : null }, "user" : { "_id" : "gomer", "group" : [ "user", "author" ] }, "blog" : { "_id" : 2, "user": "vasya", "article" : "bbb" } }
{ "_id": { "a" : null }, "user" : { "_id" : "vasya", "group" : [ "user" ] }, "blog" : { "_id" : 2, "user" : "vasya", "article" : "bbb" } }
{ "_id": { "a" : null }, "user" : { "_id" : 1 }, "blog" : { "_id" : 2, "user" : "vasya", "article" : "bbb" } }
{ "_id": { "a" : null }, "user" : { "_id" : 2 }, "blog" : { "_id" : 2, "user" : "vasya", "article" : "bbb" } }
{ "_id": { "a" : null }, "user" : { "_id" : 3 }, "blog" : { "_id" : 2, "user" : "vasya", "article" : "bbb" } }
</code></pre>
</div></div><br/>
<br/>
Еще раз создаем новые документы, где главным является условие <code>$eq:[ "$user._id", "$blog.user" ]</code> в котором мы сравнивая значения двух полей <code>"user" : { "_id" : 2 }</code> и <code>"blog" : { "user" : "vasya" } </code> и маркируем документы которые в последствии будут отфильтрованы и получен окончательный результат.<br/>
<pre><code class="python">
...{ $project:{ 
		user:"$user",
		article:"$blog",
		matches:{ $eq:[ "$user._id", "$blog.user" ] } }
} .....
</code></pre><br/>
<div class="spoiler"><b class="spoiler_title">Вывод получившихся документов</b><div class="spoiler_text"><pre><code class="python">
{ "_id" : { "a" : null }, "user" : { "_id" : 1 }, "article" : { "_id" : 1, "user" : "gomer", "article" : "aaa" }, "matches" : false }
{ "_id" : { "a" : null }, "user" : { "_id" : 2 }, "article" : { "_id" : 1, "user" : "gomer", "article" : "aaa" }, "matches" : false }
{ "_id" : { "a" : null }, "user" : { "_id" : 3 }, "article" : { "_id" : 1, "user" : "gomer", "article" : "aaa" }, "matches" : false }
{ "_id" : { "a" : null }, "user" : { "_id" : "gomer", "group" : [ "user", "author" ] }, "article" : { "_id" : 2, "user" : "vasya", "article" : "bbb" }, "matches" : false }
{ "_id" : { "a" : null }, "user" : { "_id" : "vasya", "group" : [ "user" ] }, "article" : { "_id" : 2, "user" : "vasya", "article" : "bbb" }, "matches" : true }
{ "_id" : { "a" : null }, "user" : { "_id" : 1 }, "article" : { "_id" : 2, "user" : "vasya", "article" : "bbb" }, "matches" : false }
{ "_id" : { "a" : null }, "user" : { "_id" : 2 }, "article" : { "_id" : 2, "user" : "vasya", "article" : "bbb" }, "matches" : false }
{ "_id" : { "a" : null }, "user" : { "_id" : 3 }, "article" : { "_id" : 2, "user" : "vasya", "article" : "bbb" }, "matches" : false }
Type "it" for more
</code></pre>
</div></div><br/>
И завершающая часть:<br/>
<pre><code class="python">
{ $match: { matches:true } }
</code></pre><br/>
<div class="spoiler"><b class="spoiler_title">Окончательный результат</b><p class="spoiler_text">{ "_id" : { "a" : null }, "user" : { "_id" : "gomer", "group" : [ "user", "author" ] }, "article" : { "_id" : 1, "user" : "gomer", "article" : "aaa" }, "matches" : true }<br/>
{ "_id" : { "a" : null }, "user" : { "_id" : "vasya", "group" : [ "user" ] }, "article" : { "_id" : 2, "user" : "vasya", "article" : "bbb" }, "matches" : true }<br/>
{ "_id" : { "a" : null }, "user" : { "_id" : "gomer", "group" : [ "user", "author" ] }, "article" : { "_id" : 3, "user" : "gomer", "article" : "ccc" }, "matches" : true }<br/>
</p></div><br/>
Мы просто отфильтруем те документы, которые соответствовали предыдущему условию.<br/>
И теперь у нас есть документы, в которых указано какую статью написал каждый пользователь и в какой пользовательской группе он состоит.<br/>
<br/>
Конечно, запрос можно было бы написать немного компактней но задачей было показать как можно играться с данными посредством <code>pipeline</code>.<br/>
<br/>
<h3><a name="7"/> <font>7. Примеры </font></h3><br/>
В основном здесь речь пойдет, скорее, о структуре документов чем о запросах. Как правило есть два основных подхода обычно: <br/>
<ul>
<li>Хранение предполагаемых поддокументов или просто полей, по которым будет поиск осуществляться внутри корневого или основного документа.</li>
<li>Хранение отдельно, по возможности стараясь как можно больше заносить в них дополнительной информации.</li>
</ul><br/>
<h3><a name="71"/> <font>Деревья, комментарии в Mongodb</font></h3><br/>
Как правило, одна из самых распространенных задач - это различные древовидные структуры. Это и комментарии, и каталог товаров в интернет магазинах, и схемы хранения на складах, и много чего еще. <br/>
<br/>
<img src="https://habrastorage.org/files/eda/77e/ded/eda77eded16d42f783cf05019e2b81cc.png"/><br/>
<br/>
Рассмотрим пару простых примеров.<br/>
В виде субдокументов:<br/>
<pre><code class="python">
{
   _id:1, type:"blog", title:{ru:"O MongoDB", en:""}, 
    comments: [
          { _id: 1, title: "one", "user": "Alex", parent: "root", child: [2, 3]},
          { _id: 2, title: "two", "user": "Serg", parent: 1 },             
          { _id: 3, title: "two", "user": "Andrey", parent: 1 }
     ]
}
</code></pre><br/>
Просто документы:<br/>
<pre><code class="python">
{ _id: 1, type: "comment", title: "one", "user": "Alex", parent: "root", child: [ 2, 3 ] },
{ _id: 2, type: "comment", title: "two", "user": "Serg", parent: 1 },             
{ _id: 3, type: "comment", title: "two", "user": "Andrey", parent: 1 }
</code></pre><br/>
Сам по себе простой поиск по обоим вариантам будет работать достаточно эффективно.<br/>
Тем более, что по второму варианту можно создать индексы. <br/>
В некоторых случаях вариант с поддокументами нужен для хранения части информации, но в целом сами комментарии хранятся в поддокументах, такие варианты называют модным ныне словом "гибридная" схема.<br/>
<br/>
Теперь рассмотрим несколько примеров работы с документами.<br/>
Удалить одного или несколько детей у родителя:<br/>
<pre><code class="python">

db.test.update( { _id: 1 }, { $pull: { child: 2 } } )

db.test.update( { _id: 1 }, { $pullAll: { child: [ 2, 3 ] } } )
</code></pre><br/>
Добавить одного или несколько детей родителю:<br/>
<pre><code class="python">

db.test.update( { _id: 1 }, { $push: { child: 2 }  }  }  )

db.test.update( { _id: 1 }, { $push: { child: { $each: [ 2, 3 ] } } }  )
</code></pre><br/>
<br/>
Сформируем дерево из полученных документов:<br/>
<pre><code class="python">
def getTree(docs):
	tree = { doc["_id"]: doc for doc in docs }
	for doc in docs:
		doc['child'] = []
	for doc in docs:
		parent = doc["parent"]
		if parent != "root":
			tree[parent]["child"].append(doc)
	docs={"_id": "root", "child": [doc for doc in docs if doc['parent'] == "root" ]}
	return docs


{ _id: 1, type: "comment", title: "one", "user": "Alex",     parent: "root", 
    child: [ 
        { _id: 2, type: "comment", title: "two", "user": "Serg", parent: 1 },
        { _id: 3, type: "comment", title: "two", "user": "Andrey", parent: 1 }
    ] 
}
</code></pre><br/>
<br/>
Посчитаем количество товаров, которые относятся к каждой категории дерева с учетом всех вложенных категорий, при условии, что в каждом товаре хранится <code>_id</code> категории к которой он принадлежит:<br/>
<pre><code class="python">
def count(cls):
	db = connect()
	ctr = db.test.find({'type':'goods', 'class':cls}).count()
	childs = db.test.find_one({'_id':cls})
	for res in childs['child']:
		ctr += count(res)
	return ctr
</code></pre><br/>
Найдем путь к началу, зная <code>_id</code> категории, после чего останется в шаблоне просто фором пройтись по списку кортежей:<br/>
<pre><code class="python">
def path( id ):
        p = []
	parent = db.test.find_one( {"_id": id }, { "parent": 1, "alias":1, "title":1})
	else:
		path.append( ( parent['alias'], parent['title'] ) )
		p += path( parent['parent'] )
	return p
print ( path("123") )

&gt;&gt;&gt;[ ("one", "Первая ветка"), ("two", "Вторая ветка") ]
</code></pre><br/>
<br/>
<h3><a name="72"/> <font>Теги, блоги</font></h3><br/>
Чаще всего для хранения тегов используется гибридный вариант, то есть они хранятся например в поле <code>{ tags : { ru: "один, два" } }</code>, чтобы их сразу удобно было выводить на странице под материалом. И хранятся в массиве для удобного поиска по ним <code>{ tags : [ "один", "два" ] }</code>.<br/>
Облака тегов иногда тоже отдельно хранят, иногда формируют на лету. <br/>
Поиск по массиву тегов, если, к примеру, нужно найти список документов:<br/>
<pre><code class="python">

{ _id: 1, title: "Языки программирования",  tags: [ "php", "python" ]  }

db.test.find({ tags: { $in: ["php", "python" ]  }  }  )

</code></pre><br/>
Ну и теперь отфильтруем:<br/>
<ul>
<li>По тегам, например, хотим чтобы в этом месте показывались документы с тегами <code>python, javascript</code>.</li>
<li>И, в тоже время, не показывались документы где упоминаются теги, например, "реклама".</li>
<li>По типу, учтем какой тип контента нужно показать, например, будем показывать новости.</li>
<li>Учтем пользователей за чьим авторством можно показывать документы.</li>
<li>Также установим, что больше одного документа для одного пользователя нельзя показывать.</li>
<li>Установим срок давности, чтоб выводились документы, которым не более, к примеру, 5 дней давности.</li>
<li>Минимальный рейтинг показа, то есть документы у которых рейтинг меньше <code>+2</code> не показывать.</li>
<li>Проверим чтобы документы были опубликованы и одобрены администратором. </li>
<li>Установим лимит в <code>10</code> штук для показа. </li>
<li>Отсортируем по просмотрам, и те, которые промаркированы специально (иногда бывает нужно). </li>
</ul><br/>
<br/>
<pre><code class="python">
dt = ( datetime.today() + timedelta( days = -5 ) )
db.test.aggregate([
    { $match: {
        // выбираем тип контента и срок давности
     	type: "news", date: { $gt: dt }, 
        //  выбираем минимальный рейтинг.
        vate: { $gte: 2 },  
        //Материалы каких пользователей показывать.
        user: { $in: [ "alex", "pavel" ] }  
    	$and: [ 
             // Документ разрешён к публикации и одобрен.
             { pub: true }, { accept: true }, 
             // Выбираем по каким тегам нужно отфильтровать документы.
             { tags: { $in: ["php", "python" ]  }  } , 
             // Теги с которыми мы не хотим видеть документы.
             { tags: { $nin: ["реклама"]  }  }
     	 ]
    },
     // Сортируем по важности и по дате.
    { $sort: {'primary': -1, view: -1}},
     // Устанавливаем лимит документов, показывать не больше 5 
    { $limit:3},
    // Показывать не более 1 документа для каждого пользователя, группируем по      пользователю.
    { $group: { 
         '_id':'$user',
         'id':    {'$first':'$_id'},
         'type':{'$first':'$type'},
         'title': {'$first':'$title'},
         'content':{'$first':'$content'},
         'count':{'$first':'$count_comm'},
         'last_comm':{'$first':'$last_comm'},
         'vote':{'$first':'$vote'},
         'tags':{'$first':'$tags'}
       }
    },
    //  сгруппированные документы приводим в нужный нам вид.
    { $project :{
        '_id':'$id', 'title':1,  'content':1, 'type':1,  'count':1,  'last_comm':1, 'tags':1, 'vote':1
    }
  }
])
</code></pre><br/>
<div class="spoiler"><b class="spoiler_title">Запрос без комментариев</b><div class="spoiler_text"><pre><code class="python">
db.test.aggregate([
      { $match: {
           type: "news", date: { $gt: dt }, vate: { $gte: 2 }, user: { $in: [ "alex", "pavel" ] }  
    	   $and: [ 
                { pub: true }, { accept: true }, 
                { tags: { $in: ["php", "python" ]  }  } , 
                { tags: { $nin: ["реклама"]  }  }
     	   ]
    },
    { $sort: {'primary': -1, view: -1}},  { $limit:3},
    { $group: {'_id':'$user',
         'id':    {'$first':'$_id'},  'type':{'$first':'$type'},
         'title': {'$first':'$title'},  'content':{'$first':'$content'},
         'count':{'$first':'$count_comm'},
         'last_comm':{'$first':'$last_comm'},
         'vote':{'$first':'$vote'},  'tags':{'$first':'$tags'}
	}
     },
    { $project :{
        '_id':'$id', 'title':1,  'content':1, 'type':1,  'count':1,  'last_comm':1, 'tags':1, 'vote':1
    }
  }
])
</code></pre>
</div></div><br/>
Теперь все, что нам нужно - разделить область видимости сайта на ячейки и для каждой из них можно предоставлять свой контент.<br/>
<br/>
<h3><a name="73"/> <font>Е-commerce и сложные фильтры в Mongodb </font></h3><br/>
Наверное, одна из основных сложностей и задач веб-магазинов и различных учётов - это все-таки фильтры. Они нужны как для создания хитрых отчетов, так и для просто показа где что лежит на складе, ну и, банально, отфильтровать ноутбуки по диагонали, цене, производителю и прочему. <br/>
<br/>
Последним случаем, из-за слишком большого объема материала, мы и ограничимся. Остальные рассмотрим в последующих публикациях.<br/>
<br/>
Существует два вида фильтров, или, если хотите, способа организации контента в веб-магазине. <br/>
<ol>
<li>Неправильный и не требующий ничего (часто достаточно просто спарсить прайс или вообще товары с какого то сайта )</li>
<li>Правильный и требующий детальной настройки пользователем.</li>
</ol><br/>
<br/>
В первом случае, поскольку наличествующие атрибуты у нас просто текстовые поля, ни с чем не связанные, то нам нужно просто по ним сгруппировать документы - и всё. Но в таком случае при неправильном заполнении, а также при развитии учета, в магазине возникнут проблемы и придется все перезаносить.<br/>
<br/>
Во втором случае нам надо для каждой категории товаров настроить свои фильтры и каждый из фильтров тем или иным способом привязать к характеристикам товаров (атрибутам).<br/>
<br/>
Работа с фильтрами состоит из двух этапов:<br/>
<ol>
<li>Показ значений фильтра в зависимости от категории, то есть у категории монитор есть диагональ а у категории процессор тактовая частота.</li>
<li>И поиск по этим значениям.</li>
</ol><br/>
<br/>
Начнем с показа значений фильтра, если у нас настроена привязка фильтров к характеристикам товаров, тогда все выглядит довольно просто. И делается простым запросом:<br/>
<pre><code class="python">
cursor = db.test.find({ "type": "filters", "category": "id_category" })
</code></pre><br/>
Представить данные можно по разному, например, можно сделать древовидной таблицей, где первым уровнем будут названия фильтров, а вторым уровнем его характеристики.<br/>
<br/>
Название =&gt; Диагональ<br/>
Характеристики=&gt; 15.6 дюйма, 17 дюймов и тд.<br/>
<br/>
<img src="https://habrastorage.org/files/343/713/af0/343713af0a4e47588b02aee8bb545469.png"/><br/>
<br/>
Можно по другому представить, пойти как на мой взгляд немного более распространенным путем. Сделать подтаблицами по типу приходных и расходных накладных. Когда есть шапка документа с перечислением реквизитов и тд., и есть список товаров снизу. <br/>
Только в данном случае шапка - это название категории, для которой мы настраиваем фильтры, а список товаров - это список названий фильтров с атрибутами в одной из подчиненных таблиц.<br/>
<br/>
<img src="https://habrastorage.org/files/6af/70b/37a/6af70b37a5ce41af9d27ec59a164aa16.png"/><br/>
<br/>
В этом случае запрос будет немного посложнее и придется группировать данные. Это уже будет похоже на аналогичный запрос к получению фильтров из самих товаров, этот запрос и опишем.<br/>
<br/>
У нас есть список товаров, у каждого есть список атрибутов хранящихся или в отдельных документах, или в нем самом в субдокументах. Визуально это может выглядеть примерно так.<br/>
<br/>
<img src="https://habrastorage.org/files/bec/a7b/61f/beca7b61f10d423386fda03f5b966e02.png"/><br/>
<br/>
В нашем случае возьмем чуть более сложный вариант и предположим, что это будут отдельные документы. Желательно чтобы _id категории хранилось тогда в каждом документе с характеристикой.<br/>
Оператор <code>$addToSet</code> при группировке выбирает уникальные элементы из массива.<br/>
<pre><code class="python">
db.test.aggregate([
     // находим все документы по типу справочника и по id категории            
     { '$match': { type : "goods_attr",  category: id_category } },
     // немного переформатируем документы для более удобной группировки, отбрасывая лишние поля 
     { '$project': { "title" : "$title.ru", 'value': "$attr.ru", 'category': "$category", '_id': 0 } },
     { '$group' : {
            '_id': { 'category' :"$category", 'title': "$title"} , 
            'filters': { '$addToSet': "$value" } 
         } 
     },
     { '$group' : {
          '_id' :"$_id.category", 'title':{ '$addToSet': { 'title': "$_id.title", 'filters': "$filters" } } 
         } 
     }
])
</code></pre><br/>
После первого group мы получаем документы такого типа:<br/>
<pre><code class="python">
...{ '$group'   : {
         '_id': { 'category' :"$category", 'title': "$title"} , 
         'filters': { '$addToSet': "$value" } 
     } 
}....

{ "_id": { "category": "id", "title": "Устойчивость к агрессивным средам" }, "filters": [ "Да" ] }
{ "_id" : { "category" : "id", "title" : "Материал" }, "filters" : [ "Нержавеющая сталь" ] }
{ "_id" : { "category" : "id", "title" : "Тип зажима" }, "filters" : [ "Натяжной" ] }
</code></pre><br/>
<br/>
После второго group мы уже получаем окончательный вариант.<br/>
<pre><code class="python">
...{ '$group'   : {
         '_id':"$_id.category", 'title':{'$addToSet': {'title': "$_id.title", 'filters': "$filters" }} 
      } 
...}

{ 
     "_id" : "id_category", 
      "title" : [ 
             { "title" : "Тип арматуры для ЛЭП", "filters" : 
                    [ "Крюк для ЛЭП", "Скрепа для ЛЭП", "Лента бандажная", "Зажим для ЛЭП" ] 
              }, 
              { "title" : "Тип зажима", "filters" : [ "Натяжной" ] }, 
              { "title" : "Материал", "filters" : [ "Нержавеющая сталь" ] }, 
              { "title" : "Устойчивость к агрессивным средам", "filters" : [ "Да" ] } 
       ] 
}

</code></pre><br/>
<br/>
Теперь, когда мы уже имеем список фильтров, можно поискать по этим фильтрам. Поскольку мы ищем по субдокументам, то есть по характеристикам, то группируем по <code>owner_id</code> это _id документа к которому принадлежат характеристики.<br/>
<br/>
<pre><code class="python">
db.test.aggregate([
     { '$match'  : 
         { 'type' : "goods_attr", "category'':"id", 
              '$or': [
                   {'title': 'Материал', 'attr': 'Нержавеющая сталь'}, 
                   {'title': 'Тип арматуры для ЛЭП', 'attr_val': 'Крюк для ЛЭП'}
               ] 
           } 
     },
     { '$group': {'_id': "$owner_id", "attr": { '$push': "$title" }}},
     { '$match': {"attr": {'$all': [ 'Материал',  'Тип арматуры для ЛЭП' ] }}},
     { '$project': {"_id":1 } }
])
</code></pre><br/>
<br/>
На выходе получаем список _id документов подходящих под фильтры.<br/>
<br/>
<h3><a name="8"/> <font>Небольшая песочница для Python</font></h3><br/>
Как правило при работе с различными типами данных удобно визуализировать в виде различных иерархических и других табличек. <br/>
<br/>
Но часто бывает, что нужно повесить на изменение, к примеру, поля или удаление документа (читай - строки в таблице) какое либо событие. Например, мы поменяли в справочнике валют курс по которому закупаем, и хотим чтоб цены в отечественной валюте пересчитались для всех товаров. <br/>
<br/>
Это достаточно стандартный функционал для различных ERP решений. И, поскольку часто неизвестно кто будет писать для песочницы код, нужна возможность запускать чужой код более-менее безопасно. На данный момент есть библиотеки, которые дают эту возможность, но точно неизвестно как хорошо они ограничивают запускаемый код.<br/>
<br/>
Есть простой способ безопасно выполнять чужой код в <code>python</code>, он привносит некоторые ограничения, но для большинства задач его достаточно.<br/>
<br/>
Пример с <code>exec</code><br/>
<pre><code class="python">
src = '''
result = 0
for i in xrange(100):
    result += i
'''

assert '__' not in src, 'Prohibited to use symbols "__"'
pr = compile(src, '&lt;string&gt;', mode='exec')
glob = { '__builtins__':{ 'xrange':xrange } }
exec(pr, glob)
print glob['result']
</code></pre><br/>
Пример с <code>eval</code> (для вычисления выражения)<br/>
<pre><code class="python">
src = 'max(5,7,3)'
glob = { '__builtins__':{ 'max':max } }
assert '__' not in src, 'Prohibited to use symbols "__"'
print ( eval(src, glob) )
</code></pre><br/>
<br/>
Главное - это:<br/>
<code>assert '__' not in src, 'Prohibited to use symbols "__"'</code><br/>
- запрет доступа к спец объектам, на подобии:<code> __class__, __base__</code><br/>
через которые можно получить полный доступ к python и<br/>
<pre><code class="python">
glob = { '__builtins__':{ 'xrange':xrange } }
</code></pre><br/>
тут мы заменяем весь базовый функционал (import, type...) на нужный/разрешенный функционал.<br/>
<br/>
Так же нельзя давать использовать метод <code>getattr</code>.<br/>
<br/>
Сейчас это считается более менее надежным вариантом <code>sandbox</code>.<br/>
<br/>
P.S. По возможности постарался сокращать, на самом деле по каждому пункту можно было написать отдельную публикацию. Просьба об ошибках грамматического и другого характера писать в личку, так как статья получилась длинная, мог что-то не заметить. <br/>
<br/>
<a href="http://habrahabr.ru/post/260291/"> Продолжение, вторая часть. </a><br/>
<br/>
Используемые материалы.<br/>
<br/>
<a href="http://docs.mongodb.org/manual/">Справка по mongodb </a><br/>
<a href="http://docs.mongodb.org/manual/reference/operator/">Операторы </a><br/>
<a href="http://docs.mongodb.org/manual/administration/indexes-text/">Все про текстовый поиск</a><br/>
<a href="http://docs.mongodb.org/getting-started/python/client/"> Справка по PyMongo </a><br/>
<a href="http://docs.mongodb.org/manual/release-notes/2.6-upgrade/">Обновление mongodb до версии 2.6 </a><br/>
<a href="http://docs.mongodb.org/manual/release-notes/3.0-upgrade/">Обновление mongodb до версии 3.0 </a><br/>
<a href="http://docs.mongodb.org/manual/reference/sql-aggregation-comparison/">Сравнительные примеры SQL запросов и запросов через aggregation pipeline </a><br/>
<a href="http://habrahabr.ru/post/139643/">Статья на хабре про aggregation pipeline </a><br/>
<a href="http://docs.mongodb.org/manual/core/write-operations-atomicity/">Немного о транзакциях</a><br/>
<br/>
</code>

      
      </div></body></html>