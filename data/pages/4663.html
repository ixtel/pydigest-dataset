<html><body><div><div id="entry" class="usertext">
<p>It took me a while but I've finally implemented a <a href="https://github.com/isagalaev/ijson-rust">working parser</a> on top of the lexer in my little <a href="http://softwaremaniacs.org/blog/2015/04/15/ijson-in-rust/en/">Rust learning project</a>. I learned a lot and feel much more comfortable with the language by now. In the meantime I even managed to get out to a Rust Seattle meetup, meet new folks and share an idea about doing some coding together in the future. Let's see how it'll work out.</p>
<p><a name="more"/></p>
<p><a name="yield"/></p>
<h2>Power of <code>yield</code></h2>
<p>First, a digression. It's not about Rust at all, but I'll get to my point eventually, I promise!</p>
<p>When I was coding the <a href="https://github.com/isagalaev/ijson/blob/master/ijson/backends/python.py">same problem in Python</a> I didn't fully appreciate the expressive power of generators, I simply used them because it seemed to be the most natural way. Have a look:</p>
<pre><code>def parse_value(lexer, symbol=None):
    // ...

    elif symbol == '[':
        yield from parse_array(lexer)
    elif symbol == '{':
        yield from parse_object(lexer)

    // ...

def parse_array(lexer):
    yield ('start_array', None)
    symbol = next(lexer)
    if symbol != ']':
        while True:
            yield from parse_value(lexer, symbol)
            symbol = next(lexer)
            if symbol == ']':
                break
            if symbol != ',':
                raise UnexpectedSymbol(symbol)
            symbol = next(lexer)
    yield ('end_array', None)
</code></pre>
<p>Parsing JSON (or almost anything, for that matter) requires keeping a state describing where in the structure you are now: are you expecting a scalar value, or an object key, or a comma, etc. Also, since arrays and objects can be nested you have to keep track of them opening and closing in the correct order in a some sort of stack.</p>
<p>Magic of the <code>yield</code> keyword lets you leave a function and then return to the same place, implicitly giving you both the state and the stack for free:</p>
<ul>
<li>
<p>The state is represented by an execution point. For example, after you yielded a <code>'start_array'</code> event, the next iteration will continue from the same place, ready to check for a closing bracket or the first value in the array. In other words current state is described by the last executed <code>yield</code>.</p>
</li>
<li>
<p>The stack is represented by, well, your runtime's call stack: you call <code>parse_array</code> from <code>parse_value</code> and you'll be back whenever that nested array finishes parsing. No need to check for wrong values or an empty stack.</p>
</li>
</ul>
<p>With both of those facilities out of the way the code simply represents the grammar in the natural order. All of that thanks to the semantics of <code>yield</code>.</p>
<h2>Going the hard, explicit, low-level way</h2>
<p>Rust doesn't have <code>yield</code>. Which means iteration is implemented by repeatedly calling the <code>next()</code> function, and you have to explicitly keep both the state and the stack in the iterator object between the calls.</p>
<p>This is where I spent some number of days trying different approaches, figuring out which states I need, whether I need a loop processing non-significant lexemes like <code>:</code> and <code>,</code> or a recursive call to <code>next()</code> would do the job, stuff like that. It was hard, partly because of my unfamiliarity with the language and partly because I'm definitely not the best algorithmist out there. But ultimately there's always a price you pay in productivity when working in a typed language, especially the one with a strict policy on using pointers.</p>
<p>In Python, I tend to work top-down, starting with roughly sketching the whole algorithm making it just barely runnable to see if it works at all as early as possible. I rely on the language letting me be sloppy with types and error handling and leaving whole parts of the code essentially non-working if I'm not going to run them just yet.</p>
<p>In Rust, the compiler doesn't want to hear your pleads and promises that you're going to cleanup the mess later: <em>everything</em> must be tidied up and compiled, period. Want to play with adding a flag to one of the states? Sure, just go ahead and update the definition a couple of screens up and the initialization a couple of screens down. Want to see if you can call that code recursively? Well, this is <code>next(&amp;mut self)</code> â€” a function taking a <em>mutable</em> reference and you can't have more than one, ever. So no, you can't call that one recursively, you'll probably have to extract that part of logic in another function and go through some amount of yak shaving making sure it's pure and doesn't want a mutable <code>self</code>. At which point it doesn't look like a quick checking out anymore.</p>
<p>Constant context switching between thinking about overall architecture and implementation details, such as reference herding, is the hardest part of Rust for me right now. I think it's unavoidable, even though I'm getting better at it :-)</p>
<p>It's all not in vain, of course. Types <em>do</em> help in reasoning about code. If you see a function taking an immutable reference you know it won't change it without looking through its code. You also know it won't suddenly become non-pure later on.</p>
<h2>Enums</h2>
<p>Enough whining, though. If there's one thing that I'm completely in love right now it's <a href="http://doc.rust-lang.org/book/enums.html">enums</a>! What's so exciting about <em>enums</em>, you ask? Well, first of all, they're misleadingly named. They are really <a href="http://www.wikiwand.com/en/Tagged_union">tagged unions</a> that represent a value coming in several variants. Here's an example.</p>
<p>As my parser goes through a JSON it yields <em>events</em>, like a start of an object, a key, a number, a boolean, an end of an object, etc. You want to know two things about an event: what it is and, for somey, the actual value associated with it. Here's how the type looks in Rust:</p>
<pre><code>enum Event {
    Null,
    Boolean(bool),
    String(String),
    Key(String),
    Number(f64),
    StartArray,
    EndArray,
    StartMap,
    EndMap,
}
</code></pre>
<p>The wonderful part is that when processing this you get safe typed values without doing any casting:</p>
<pre><code>match event {
    Boolean(value) =&gt; // `value` is bool
    Number(value) =&gt;  // `value` is f64
    StartArray =&gt;     // you don't need no values here, so you're not getting any
    // ...
}
</code></pre>
<p>Neat, right!? And <a href="https://doc.rust-lang.org/book/patterns.html">pattern matching</a> can be way more elaborate, by the way.</p>
<p>What you can't do though is to simply check the value of an enum with an if:</p>
<pre><code>if self.state == State::Closed { ... }

// error: binary operation `==` cannot be applied to type `State` [E0369]
</code></pre>
<p>This tripped me up pretty severely at one point when I organized my whole logic around checking for specific states here and there. For example, an object key in JSON is not awfully different from any scalar value: you're parsing a string and then just call it "key" instead of "string". Nope, didn't let me do that, no sir. Had to reshape all that state handling into one big <code>match</code> with very similar looking parts.</p>
<p>But Rust was right, though, after all. Because <a href="https://github.com/isagalaev/ijson-rust/blob/parser/src/main.rs#L218">treating an object key</a> is in fact <em>completely</em> different from <a href="https://github.com/isagalaev/ijson-rust/blob/parser/src/main.rs#L184">treating scalar values</a> if you take into account the dynamics of states and the stack. They won't even share the string parsing code because keys don't need handling of backslash escapes.</p>
<h2><code>if let</code></h2>
<p>Rust extensively uses two enum types throughout the standard library: <a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option</a> and <a href="https://doc.rust-lang.org/std/result/enum.Result.html">Result</a>. I was under the impression that inability to use <code>if</code> means that whenever you work with a function returning any of those you <em>have</em> to handle it with <code>match</code> and lose any dreams of composability.</p>
<p>However a few days ago I stumbled upon an excellent article "<a href="http://blog.burntsushi.net/rust-error-handling/">Error Handling in Rust</a>" which I wholeheartedly recommend to any Rust beginner. From it I learned about <code>if let</code>: it follows the same rules for matching as <code>match</code>, so you can write this:</p>
<pre><code>if let Event::Number(value) = event {
    // handle only the case when `event` is a Number
}
</code></pre>
<p>This is actually an <em>assignment</em>, so you have <code>=</code> instead of <code>==</code> and an rvalue on the right. It can look even weirder with parameter-less enum variants:</p>
<pre><code>if let State::Closed = state {
    // - Did you just assign a variable to a value, Bob?
    // - Shut up and handle your closed state.
}
</code></pre>
<p>However what I miss is something like <code>if not let</code>, basically an else-clause of that if. Say, I want to pop a value from the stack and make sure it's the one I expect (and the stack is not empty, of course). Currently I do this:</p>
<pre><code>match self.stack.pop() {
    Some(b'[') =&gt; (),
    _ =&gt; panic!("Unmatched ]"),
}
</code></pre>
<p>All this business with the do-nothing thingie <code>()</code> and the default case <code>_ =&gt;</code> is a little bit not pretty. What I really want is this:</p>
<pre><code>if not let Some(b'[') = self.stack.pop() {
  panic!("Unmatched ]") // or something more sensible than panic! when I get to it
}
</code></pre>
<p>But it's nitpicking, of course :-)</p>
<h1>Peekable lexer</h1>
<p>It occurred to me at one point that my Lexer, being an iterator, lacks the ability to tell me which lexeme would come next without actually consuming it. In other words, it wasn't "peekable". Without this, for example, I had to call out to the <a href="https://github.com/isagalaev/ijson-rust/blob/44f8ef5056abe18523ba44db5ff73fc64fd18384/src/main.rs#L210">entire non-pure process of handling another parser state</a> when, say, I got a closing brace <code>}</code> while expecting an object key.</p>
<p>So I went ahead and replaced an Iterator trait on the Lexer with a <a href="https://github.com/isagalaev/ijson-rust/commit/1e74241e80e927c2617e93b788e32fc7b299382c">passable custom implementation</a> sporting methods <code>lookup()</code> and <code>consume()</code> (learning about <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.take"><code>Option.take()</code></a> along the way).</p>
<p>Well, turns out they already have this thing, <a href="http://doc.rust-lang.org/core/iter/struct.Peekable.html">right there in the standard library</a>, working on top of any basic Iterator. Now my parser holds a <code>Peekable&lt;Lexer&gt;</code> initialized simply with <code>lexer(file).peekable()</code>, and I can <code>self.lexer.peek()</code> as well as <code>self.lexer.next()</code>. Great! Love deleting custom code!</p>
<p class="note"><small>By the way, <a href="https://pythonhosted.org/more-itertools/api.html#more_itertools.peekable">you can have <code>peekable</code> in Python</a> too, just not from the standard library.</small></p>

<h2>TODO</h2>
<p>The library is shaping up nicely, here's what's next:</p>
<ul>
<li>
<p>Processing -escapes in strings (hate them!)</p>
</li>
<li>
<p>Proper error handling. All those <code>panic!</code> strewn around the code is no good, as Andrew Gallant <a href="http://blog.burntsushi.net/rust-error-handling/">tells us</a>. It's okay only when you're just starting.</p>
</li>
<li>
<p>Becnhmarking. I'm dying to see how it compares to <a href="https://lloyd.github.io/yajl/">yajl</a>.</p>
</li>
<li>
<p>Tests. Weep all you TDD fan boys, I'm writing tests after my code! Because I first want it to work at all before I make sure it works for everyone else. For now a specially crafted <a href="https://github.com/isagalaev/ijson-rust/blob/parser/test.json">test.json</a> would do just fine.</p>
</li>
<li>
<p>Implementing the rest of ijson functionality, like <a href="https://github.com/isagalaev/ijson/blob/master/README.rst">prefixed events and an object builder for <code>items()</code></a>. I really do intend to make it a usable library.</p>
</li>
</ul>
<h2>Call for help</h2>
<p>At this point I'd really love some code review and expert advise from fellow Rustians. If you have time and want to help, please feel free to <a href="https://github.com/isagalaev/ijson-rust">file pull requests</a> or just leave comments here.</p>
<p>Thank you!

</p></div>
</div></body></html>