<html><body><div><tr class="commit js-details-container js-socket-channel js-updatable-content" data-channel="piotrj/rails:commit:f50543c32b87fe820356ef149a90b5c4638fbfae" data-url="/piotrj/rails/commit/f50543c32b87fe820356ef149a90b5c4638fbfae/show_partial?partial=commit%2Fcondensed">
  <td class="commit-icon">
    <svg aria-hidden="true" class="octicon octicon-git-commit" role="img" version="1.1" viewbox="0 0 14 16"><path d="M10.86 7c-0.45-1.72-2-3-3.86-3s-3.41 1.28-3.86 3H0v2h3.14c0.45 1.72 2 3 3.86 3s3.41-1.28 3.86-3h3.14V7H10.86zM7 10.2c-1.22 0-2.2-0.98-2.2-2.2s0.98-2.2 2.2-2.2 2.2 0.98 2.2 2.2-0.98 2.2-2.2 2.2z"/></svg>
  </td>

  <td class="commit-gravatar">
      <a href="/piotrj">
    <img alt="@piotrj" class="avatar avatar-small" src="https://avatars1.githubusercontent.com/u/9296?v=3&amp;s=32"/>
  </a>

  </td>

  <td class="commit-author">
    <strong><a href="/piotrj" class="author" rel="contributor">piotrj</a></strong>
  </td>

  <td class="commit-message">
    <code><a href="/piotrj/rails/commit/f50543c32b87fe820356ef149a90b5c4638fbfae" class="message" data-pjax="true" title="Update counter cache only if the relation is actually saved.&#10;&#10;Fixes #18988, #22602, #23265&#10;&#10;*** Description of the problem&#10;So far the counter cached was incremented when one of two things&#10;happened in following scenario.&#10;&#10;```&#10;  class Post &lt; ActiveRecord::Base&#10;    has_many :coments&#10;  end&#10;&#10;  class Comment &lt; ActiveRecord::base&#10;    belongs_to :post, counter_cache: true&#10;  end&#10;```&#10;&#10;1. comment.post = post was called. This would increment the counter&#10;   cache for post in the db&#10;2. Comment was saved with updated post_id and the counter cache is&#10;   incremented in update callback&#10;&#10;This solution (especially the fact that we did counter cache increment&#10;in situation #1) had few problems:&#10;&#10;1. We bumped the counter cache even if in the end the Comment was not&#10;   saved. For example if something like this happened:&#10;&#10;```&#10;    comment.post = post&#10;    raise SomeException&#10;```&#10;&#10;  then the comment wouldn't have post_id, but post would end up with&#10;&#10;2. If someone did the following&#10;```&#10;    comment.post = post&#10;    comment.save!&#10;```&#10;&#10;   Post would end up with comments_count = 2 because the counter cache&#10;   would get bumped on both of conditions above.&#10;&#10;3. The bump in situation #1 was made outside of transaction that saves&#10;the comment which means we would make unnecessary call to db.&#10;&#10;4. comment.post = post and comment.post_id = post.id are not consistent.&#10;Former bumps the bumper cache while the latter does not.&#10;&#10;*** Solution&#10;This commit removes the counter cache increment on association&#10;assignment. This means that comment.post = post won't bump the counter.&#10;It will only happen when the comment will get saved. This will ensure&#10;more consistency of data in DB.&#10;&#10;Other changes that are introduced in this commit:&#10;1. Counter cache incrementer/decrementer can work with foreign_keys&#10;other than the primary_key of the model. That's why methods&#10;updates_counters_for_key, increment_counter_for_key and&#10;decrement_counter_for_key has been introduced.&#10;&#10;2. The update callback that bumps counter cache will properly increment&#10;counter cache for polymorphic association even if the only thing that&#10;was changed was type of the related object but it happened to have the&#10;same id as the previously related object.&#10;&#10;Notes about chaned tests:&#10;1. In test_belongs_to_counter_with_assigning_nil I changed the models&#10;under test as Comment's post_id is non nullable therefore comment could&#10;never have been saved with post_id = nil. Moreover this test in its&#10;original form shown how flawed the previous behavior of counter cache&#10;was. When nil was assigned to comment.post, that post's comments_count&#10;would get decremented, but in the end it would be possible to save that&#10;comment and it would result in inconsistent data.&#10;&#10;2. test_counter_cache_with_custom_column_name - the relation of&#10;SillyReply is basically broken. It uses the same foreign_key &quot;parent_id&quot;&#10;as the Reply (its superclass) topic relation. That's why I used&#10;DogLovers and Dogs for the test of custom names for counter caches.&#10;&#10;3. Other tests have been updated to actually save the objects in order&#10;to bump counter cache.">Update counter cache only if the relation is actually saved.</a></code>

      <span class="hidden-text-expander inline">
        <button type="button" class="ellipsis-expander js-details-target">â€¦</button>
      </span>
      <div class="commit-desc"><pre class="text-small">Fixes <a href="https://github.com/rails/rails/issues/18988" class="issue-link js-issue-link" data-url="https://github.com/rails/rails/issues/18988" data-id="58072495" data-error-text="Failed to load issue title" data-permission-text="Issue title is private">#18988</a>, <a href="https://github.com/rails/rails/issues/22602" class="issue-link js-issue-link" data-url="https://github.com/rails/rails/issues/22602" data-id="122328862" data-error-text="Failed to load issue title" data-permission-text="Issue title is private">#22602</a>, <a href="https://github.com/rails/rails/issues/23265" class="issue-link js-issue-link" data-url="https://github.com/rails/rails/issues/23265" data-id="128860091" data-error-text="Failed to load issue title" data-permission-text="Issue title is private">#23265</a>

*** Description of the problem
So far the counter cached was incremented when one of two things
happened in following scenario.

```
  class Post &lt; ActiveRecord::Base
    has_many :coments
  end

  class Comment &lt; ActiveRecord::base
    belongs_to :post, counter_cache: true
  end
```

1. comment.post = post was called. This would increment the counter
   cache for post in the db
2. Comment was saved with updated post_id and the counter cache is
   incremented in update callback

This solution (especially the fact that we did counter cache increment
in situation <a href="https://github.com/rails/rails/issues/1" class="issue-link js-issue-link" data-url="https://github.com/rails/rails/issues/1" data-id="132" data-error-text="Failed to load issue title" data-permission-text="Issue title is private">#1</a>) had few problems:

1. We bumped the counter cache even if in the end the Comment was not
   saved. For example if something like this happened:

```
    comment.post = post
    raise SomeException
```

  then the comment wouldn't have post_id, but post would end up with

2. If someone did the following
```
    comment.post = post
    comment.save!
```

   Post would end up with comments_count = 2 because the counter cache
   would get bumped on both of conditions above.

3. The bump in situation <a href="https://github.com/rails/rails/issues/1" class="issue-link js-issue-link" data-url="https://github.com/rails/rails/issues/1" data-id="132" data-error-text="Failed to load issue title" data-permission-text="Issue title is private">#1</a> was made outside of transaction that saves
the comment which means we would make unnecessary call to db.

4. comment.post = post and comment.post_id = post.id are not consistent.
Former bumps the bumper cache while the latter does not.

*** Solution
This commit removes the counter cache increment on association
assignment. This means that comment.post = post won't bump the counter.
It will only happen when the comment will get saved. This will ensure
more consistency of data in DB.

Other changes that are introduced in this commit:
1. Counter cache incrementer/decrementer can work with foreign_keys
other than the primary_key of the model. That's why methods
updates_counters_for_key, increment_counter_for_key and
decrement_counter_for_key has been introduced.

2. The update callback that bumps counter cache will properly increment
counter cache for polymorphic association even if the only thing that
was changed was type of the related object but it happened to have the
same id as the previously related object.

Notes about chaned tests:
1. In test_belongs_to_counter_with_assigning_nil I changed the models
under test as Comment's post_id is non nullable therefore comment could
never have been saved with post_id = nil. Moreover this test in its
original form shown how flawed the previous behavior of counter cache
was. When nil was assigned to comment.post, that post's comments_count
would get decremented, but in the end it would be possible to save that
comment and it would result in inconsistent data.

2. test_counter_cache_with_custom_column_name - the relation of
SillyReply is basically broken. It uses the same foreign_key "parent_id"
as the Reply (its superclass) topic relation. That's why I used
DogLovers and Dogs for the test of custom names for counter caches.

3. Other tests have been updated to actually save the objects in order
to bump counter cache.</pre></div>
  </td>

  <td class="commit-meta">


    <code><a href="/piotrj/rails/commit/f50543c32b87fe820356ef149a90b5c4638fbfae" class="commit-id">f50543c</a></code>
  </td>
</tr>

    </div></body></html>