<html><body><div><div class="post-body entry-content" id="post-body-486569398497703650" itemprop="description articleBody"><p>
Recently, in one of the </p><a href="http://check.io/">check.io</a><p> missions i was playing with a task to find first palindromic prime number (palprime) greater than given argument. The challenge was to make code as small as possible. To check whether a number is a palprime we need to check whether it is both a prime and a palindromic number. In this post I'd like to focus on checking whether a number is palindromic.
</p><p>
Spoiler alert: think twice before reading this post if you're going to play the game.

</p>
<p>
<span>(source: http://40.media.tumblr.com/42ae198800aa76ad3c06878fd93a2d82/tumblr_nf8x7keJkF1rkt29io1_500.png)</span></p>
<p>
I believe most Python devs out there would quickly come with intuitive solution, presented below.
</p><pre id="vimCodeElement"><span class="Identifier">str</span>(n)==<span class="Identifier">reversed</span>(<span class="Identifier">str</span>(n))</pre><p>
The approach here is pretty straightforward - instead of doing arithmetics (like </p><a href="http://stackoverflow.com/questions/199184/how-do-i-check-if-a-number-is-a-palindrome" target="_blank">here</a><p>) we can simply convert the number to a string and then compare it with reversed version of it. The solution consists of 24 characters. Can we make it smaller?

</p>
<p>
<span>(source: http://gemssty.com/wp-content/uploads/2013/03/cardboard_phone_2.jpg)</span></p>
<p>
It will be obvious to seasoned Python programmers to use fabulous Python slices, as shown below.
</p><pre id="vimCodeElement"><span class="Identifier">str</span>(n)==<span class="Identifier">str</span>(n)[::-<span class="Constant">1</span>]</pre><p>
With this simple transformation we saved 4 characters - that's nice. How does it work? Python slices allow specifying start, stop, and step. If we omit start and stop and provide -1 as a step slicing will work in magical way: it will go through the sequence in right-to-left direction. As a side note I can add that slices in Python work in a little weird way - e.g. </p><span>"abcd"[0:len("abcd"):-1]</span><p> gives </p><span>""</span><p> in result while </p><span>"abcd"[len("abcd"):0:-1]</span><p> renders </p><span>"dcb"</span><p>. </p><span>[::-1]</span><p> specifying start and stop parameters would require us to append firs character to the result: </p><span>"abcd"[len("abcd"):0:-1]+"a"</span><p>.
</p><p>
So, going back to the topic, are we stuck with this solution? If we can invert the logic (that won't be always the case), then there's other way that I discovered during trials. It required me to adapt rest of the code, but no single character was introduced. Instead, I saved one more.
</p><pre id="vimCodeElement">n-<span class="Identifier">int</span>(<span class="Identifier">str</span>(n)[::-<span class="Constant">1</span>])</pre><p>
In essence, the idea is that if the number is palindromic then subtracting reversed version of it from the original version should result in 0. Here we are converting to string just to reverse the number and then there's back-to-integer conversion.
</p><p>
So I ended up with 19 characters thinking about what else I can do. I literally ran out of ideas, so I though of googling for operators available in Python language. During my life I managed to ensure myself that even if you think you have mastered your language of choice, you are wrong (C++ helped me to shape this attitude with stuff like template unions, secret shared_ptr c-tors etc. ;)).
</p><p>
In the haystack of results I found a needle. </p><a href="https://docs.python.org/2.7/reference/expressions.html#string-conversions" target="_blank">It turns out</a><p> that in Python 2.x there's a possibility to convert a number (even if it's held in a variable) to a string using backticks (a.k.a backquotes, reverse quotes). Well... what can I say. I never expected existence of such thing, especially in Python.

</p>
<p>
Fortunately it does the job, so was able to use this feature and cut down length of the test to 14. Awesome!
</p><pre id="vimCodeElement">`n`==`n`[::-<span class="Constant">1</span>]</pre><p>
Above solution is the shortest I was able to come with. I wouldn't be surprised if there were shorter ones, though. If you know how to make it shorter, please let me know in comments.
</p><p>
Besides making this check so short I was curious what are differences between conversions and reversions in terms of performance. I decided to give it a go on my machine (i5-3320M 2.6GHz).

</p><span>python -m timeit 'n=2**30; str(n)'</span>
<span>python -m timeit 'n=2**30; repr(n)'</span>
<span>python -m timeit 'n=2**30; `n`'</span>


<span>python -m timeit 's=qwertyuiopasfghjklzxcvbnm; rs=''.join(reversed(s))'</span>
<span>python -m timeit 's=qwertyuiopasfghjklzxcvbnm; rs=s[::-1]'</span>
<p>
My conclusions are:
</p><ul>
<li>there's very slight (almost unnoticeable) difference between three methods of converting integer to string</li>
<li>for some reason Python3.4 is slower than Python2.7</li>
<li>Pypy cruelly outperforms Python, as usual. If you care about performance you should use pypy.</li>
<li>there's almost no difference between reverse(n) and [::-1] when it comes to speed</li>
</ul>
<p>
The fact that there are no performance differences between reverse() and [::-1] surprised me a bit. By looking into byte code I can only assume that in my particular case different set of operations yielded the same performance results.</p>
<p>
<br/></p>
<p>
<span>reversed                             [::-1]</span><br/>
<span>-------------------------------------------------------------------<br/> 0 LOAD_CONST    0 ('qwer...')        </span><span>0 LOAD_CONST    0 ('qwer...')</span></p>
<div>
<p>
<span> 3 STORE_NAME    0 (s)                </span><span>3 STORE_NAME    0 (s)</span></p>
<p>
<b><span> 6 LOAD_CONST    1 ('')               </span><span>6 LOAD_NAME     0 (s)</span></b></p>
<p>
<b><span> 9 LOAD_ATTR     1 (join)             </span><span>9 LOAD_CONST    1 (None)</span></b></p>
<p>
<b><span>12 LOAD_NAME     2 (reversed)        </span><span>12 LOAD_CONST    1 (None)</span></b></p>
<p>
<b><span>15 LOAD_NAME     0 (s)               </span><span>15 LOAD_CONST    3 (-1)</span></b></p>
<p>
<b><span>18 CALL_FUNCTION 1 (1 pos, 0 kw)     </span><span>18 BUILD_SLICE   3</span></b></p>
<p>
<b><span>21 CALL_FUNCTION 1 (1 pos, 0 kw)     </span><span>21 BINARY_SUBSCR</span></b></p>
<p>
<span>24 STORE_NAME    3 (rs)              </span><span>22 STORE_NAME    1 (rs)</span></p>
<p>
<span>27 LOAD_CONST    2 (None)            </span><span>25 LOAD_CONST    1 (None)</span></p>
<p>
<span>30 RETURN_VALUE                      </span><span>28 RETURN_VALUE</span></p>
</div>
<p>
<br/></p>
<p>
In case of conversion from integer to a string I anticipated that <span>str</span> and <span>repr</span> will yield similar results. What I didn't know was how backticks will perform. By looking into byte code I can say that the only difference is that backticks don't call any function, but use <span>UNARY_CONVERT</span> op directly.<br/>
<br/>
<span>str                                  ``</span><br/>
<span>----------------------------------------------------------------------------<br/> 0 LOAD_CONST    0 (1234567890)       </span><span>0 LOAD_CONST            0 (1234567890)</span><br/>
<span> 3 STORE_NAME    0 (n)                </span><span>3 STORE_NAME               0 (n)</span><br/>
<b><span> 6 LOAD_NAME     1 (str)              </span><span>6 LOAD_NAME                0 (n)</span></b><br/>
<b><span> 9 LOAD_NAME     0 (n)                </span><span>9 UNARY_CONVERT</span></b><br/>
<span><b>12 CALL_FUNCTION 1</b>                   </span><span>10 STORE_NAME               1 (s)</span><br/>
<span>15 STORE_NAME    2 (s)               </span><span>13 LOAD_CONST               1 (None)</span><br/>
<span>18 LOAD_CONST    1 (None)            </span><span>16 RETURN_VALUE</span><br/>
<span>21 RETURN_VALUE </span><br/>
<br/>
<br/></p>
<p/>
</div>
</div></body></html>