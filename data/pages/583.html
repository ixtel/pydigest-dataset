<html><body><div><div class="inner">
        	
	        <time datetime="2014-03-09">09 Mar 2014</time> <span class="post-tags">on requests, python, lxml, scrape, proxies, web crawler, download images</span>        	
    	    <h1 class="post-title">Python web scraping resource</h1>
            <p>If you need to extract data from a web page, then the chances are you looked for their API. Unfortunately this isn't always available and you sometimes have to fall back to web scraping.</p>

<p>In this article I'm going to cover a lot of the things that apply to all web scraping projects and how to overcome some common gotchas.</p>

<p><strong>Please Note:</strong> This is a work in progress. I am adding more things as I come across them. Got a suggestion? Drop me an email - <a href="mailto:jake.austwick@gmail.com">jake.austwick@gmail.com</a></p>



<h5 id="important">Important</h5>

<p>Always check for if you can extract information via an API first if they provide one, RSS / Atom feeds are also a great option if provided.</p>

<h3 id="prerequisites">Prerequisites</h3>

<p>We'll be using two external python libraries primarily.  </p>

<h5 id="requests">Requests</h5>

<p>We'll be using the <a href="http://docs.python-requests.org/en/latest/">requests library</a> instead of urllib2. It's better in every way. I could go into details and explain why, but I think the requests page sums it all up in this short paragraph:</p>

<blockquote>
  <p>Python’s standard urllib2 module provides most of the HTTP capabilities you need, but the API is thoroughly broken. It was built for a different time — and a different web. It requires an enormous amount of work (even method overrides) to perform the simplest of tasks.</p>
</blockquote>

<h5 id="lxml">lxml</h5>

<p><a href="http://lxml.de/">lxml</a> is a XML/HTML parser, so we'll be using it to extract the data from the responses we are returned. Some people prefer <a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/">BeautifulSoup</a> but I'm confident at writing my own <a href="http://en.wikipedia.org/wiki/XPath">xPaths</a> and so would prefer to stick with lxml for raw speed.</p>

<h3 id="crawlingspidering">Crawling / Spidering</h3>

<p>Crawling is exactly the same as a "general" scraper, except that you find the next URLs to scrape on each page that you parse. Crawling is a technique used to create large databases of information.</p>

<p>Examples:</p>

<ul>
<li>Crawling an eBay category to gather product information. (<strong>Don't</strong> - they have an API).</li>
<li>Crawling a category in the yellow pages for the contact information of a certain profession.</li>
<li>etc...</li>
</ul>

<h5 id="storingseenurls">Storing seen URLs</h5>

<p>You'll want to store the URLs you've already visited, so that you don't scrape them multiple times. For a small scrape(&lt; 50k URLs), I would suggest simply using a set for this. You can then simply check for the presence of a URL in the set before fetching it / adding it to the "To Fetch Queue".</p>

<p>If you're going to be crawling a large site, then the above technique of simply using a set won't hold up. The set will grow huge and will start using a ton of memory. The solution to this is a <a href="http://en.wikipedia.org/wiki/Bloom_filter">Bloom Filter</a>. I won't go into much detail, but a bloom filter essentially lets us store which urls we have seen, then ask the question <strong>"Have I seen this URL before?"</strong> and <em>probably (very likely)</em> returning the correct answer. It can do this using <strong>very little</strong> memory. <a href="https://github.com/axiak/pybloomfiltermmap">pybloomfiltermmap</a> is a good Bloom Filter implementation for Python.</p>

<p><strong>Important:</strong> Make sure your normalize your URL before inserting it into the set / bloom filter. Depending on the site you may want to remove all query params etc. You don't want to be storing the same URL a ton of times.</p>

<h3 id="cssselectors">CSS Selectors</h3>

<p>If you're coming from a Javascript background, you might be more comfortable querying the DOM with CSS selectors rather than xPath. lxml provides a way to do this, it has a <code>css_to_xpath</code> method. Check out this page for a short guide on how to use it:</p>

<p><a href="http://lxml.de/cssselect.html">http://lxml.de/cssselect.html</a></p>

<p><a href="http://pythonhosted.org/pyquery/">PyQuery</a> also comes highly recommended to me and I know it's widely used, so it's worth checking out too.</p>

<h3 id="extractingthemaincontentblock">Extracting The Main Content Block</h3>

<p>Sometimes you want to perform analysis on just the main content of the page, doing a word count for example. You wouldn't want to include the menu / sidebar within the count.</p>

<p>You can use <a href="https://pypi.python.org/pypi/readability-lxml">readability-lxml</a> for this. It's job is to simply extract the main content block (<strong>note:</strong> It can still contain HTML). Following on our word count example, you would remove the HTML using something like <code>clean_html</code> from within <code>lxml.html.clean</code>, then proceed to split on whitepace and count the results.</p>

<p>You can check out another article on my blog that shows how to use <a href="http://jakeaustwick.me/scraping-content-with-readability-and-python/">Readability to extract the main content</a>.</p>

<h3 id="concurrency">Concurrency</h3>

<p>We all know you want your data now, but hitting the server with 200 concurrent requests is going to make for one angry webmaster. <strong>Don't be that guy.</strong> Do everybody a favour and stick to a reasonable amount. 5 is usually enough.</p>

<p>To send requests concurrently easily with requests, check out the <a href="https://github.com/kennethreitz/grequests">grequests</a> library. It allows you to make your code concurrent in pretty much a line or two.</p>

<pre><code class="language-python">rs = (grequests.get(u) for u in urls)  
responses = grequests.map(rs)  
</code></pre>

<h3 id="robotstxt">Robots.txt</h3>

<p>Almost every guide out there will tell you to <em>always</em> follow robots.txt rules. I'm not going to do that. The simple fact is they are usually really restrictive and don't even reflect what the webmasters restrictions would be. Most sites just use the default robots.txt for their framework / that their SEO plugin generates. Just make sure you're reasonable.</p>

<p>An exception to this rule is if you are writing a general spider. Something like Google/Bing. In this case, I would follow the rules the disallowed directories and crawl delay. If they don't want something indexing, then don't index it in your search engine / application.</p>

<h3 id="avoidingdetection">Avoiding Detection</h3>

<p>Sometimes you don't want to get caught. I get that. It isn't actually that difficult to achieve. The first thing to do it randomize your user agent. Your IP address will still be the same for all the requests, but that isn't unusual. Places like universities / businesses often have a ton of computers that all route traffic via 1 IP.</p>

<p>The next step is to use proxies. You can pick up shared proxies at a very small monthly cost, and when you're using randomized user agents and sending requests from 100 different IP's spread across different IP ranges and even different datacenters, they're gonna have a hard time detecting you.</p>

<p>Recommended Proxy Provider: <a href="http://www.myprivateproxy.net/billing/aff.php?aff=745">My Private Proxy</a></p>

<p>When I've found myself in the unfortunate place of getting my proxies banned before on certain sites, they have been more the happy to switch them out for new IP's for me.</p>

<p><strong>Disclosure:</strong> The above is an affiliate link, I have an account there as I use this proxy service myself.</p>

<h3 id="extendingtheresponseclass">Extending the Response class</h3>

<p>I highly recommend that you extend the <code>requests.model.Response</code> object with some convinience methods of your own. I have wrote a dedicated article on this topic:</p>

<p><a href="http://jakeaustwick.me/extending-the-requests-response-class/">http://jakeaustwick.me/extending-the-requests-response-class/</a></p>

<h3 id="hireme">Hire Me</h3>

<p>I highly reccommend you use this article as a resource to build / fix your own scraper. If you don't have time however or would like to hire somebody to scrape/crawl something for you then drop me a line. You can find my details on my contact page.</p>

<p><a href="http://jakeaustwick.me/contact-me/">http://jakeaustwick.me/contact-me/</a></p>

<h3 id="commonproblems">Common Problems</h3>

<h6 id="installinglxml">Installing lxml</h6>

<p>You may run into some trouble when trying to install lxml, especially on a linux distro. lxml requires the following packages to be installed before:</p>

<p><code>apt-get install libxml2-dev libxslt-dev python-dev lib32z1-dev
</code></p>

<p>You can then run the <code>pip install lxml</code> command as per usual.</p>

<h6 id="thesiteusesajaxicantscrapeit">The site uses AJAX, I can't scrape it!</h6>

<p>This is simply incorrect. Often if a site uses AJAX, it can make your job even easier. Use the Network tab in Chrome Developer Tools to find the AJAX request, you'll usually be greeted by a response in <strong>json</strong>. This saves you the effort of having to parse the page, you can just hit the AJAX endpoint directly. If this isn't the case then I suggest using an actual browser for scraping. Check out the "<a href="#thesiteisshowingdifferentcontenttomyscraper">The site is showing different content to my scraper</a>" section for suggestions on this.</p>

<h6 id="thesiteisshowingdifferentcontenttomyscraper">The site is showing different content to my scraper</h6>

<ol>
<li><p>Check the page source in your browser and make sure the information you want to scrape is actually there. It could be that the content was injected into the page via javascript and <strong>our scraper doesn't run javascript</strong>. If this is the case, your only real option is to run something like <a href="http://phantomjs.org/">PhantomJS</a>. You can control Phantom from Python though, just use something like <a href="https://pypi.python.org/pypi/selenium">selenium</a> or <a href="http://splinter.cobrateam.info/">splinter</a>.</p></li>
<li><p>Sites often serve different content to different user agents. You should check the user agent that you are sending in your browser and set your scraper to have the same.</p></li>
<li><p>It's possible that the site is serving different content to different locations using <a href="http://en.wikipedia.org/wiki/Geotargeting">geotargeting</a>. If you're running your script from a server, then this could be affecting you.</p></li>
</ol>

<h6 id="theitemsineedtoscrapearepaginated">The items I need to scrape are paginated</h6>

<p>Sometimes you need to scrape items that aren't all available on one page. Luckily it's usually an easy fix. I suggest checking the URL when changing between the pages, you'll ussually find there is a <code>page</code> or <code>offset</code> parameter changing. This is easy to scrape with something like the following:  </p>

<pre><code class="language-python">base_url = "http://some-url.com/something/?page=%s"  
for url in [base_url % i for i in xrange(10)]:  
    r = requests.get(url)
</code></pre>

<h6 id="imgetting403errorsratelimited">I'm getting 403 errors / rate limited</h6>

<p>The simple solution to this is <strong>don't hit the site so damn hard</strong>. Be conservative with the amount of concurrent requests you use. Do you really need the data within the hour, can you really not wait 24 hours for it?</p>

<p>If you really need to keep sending requests to the site, then you're going to have to invest in some proxies. You can then simply create a simple proxy manager class that makes sure you only use the same proxy once every X interval so that it doesn't get blocked.</p>

<p>Check out the Concurrency and Avoiding Detection sections above.</p>

<h3 id="codeexamples">Code Examples</h3>

<p>The following examples aren't really of any use on their own. They're simply here as a reference for you.</p>

<h5 id="simplerequestsexample">Simple requests example</h5>

<p>I'm not really going to show much in this example, you can find out all you need over at <a href="http://docs.python-requests.org/en/latest/">the requests documentation</a>.</p>

<pre><code class="language-python">import requests

response = requests.get('http://jakeaustwick.me')

# Response
print response.status_code # Response Code  
print response.headers # Response Headers  
print response.content # Response Body Content

# Request
print response.request.headers # Headers you sent with the request  
</code></pre>

<h5 id="requestwithproxy">Request with proxy</h5>

<pre><code class="language-python">proxy = {'http' : 'http://102.32.3.1:8080',  
           'https': 'http://102.32.3.1:4444'}
response = requests.get('http://jakeaustwick.me', proxies=proxy)  
</code></pre>

<h5 id="parsingtheresponsesbody">Parsing the responses body</h5>

<p>It's easy to parse the html returned with lxml. Once we have it parsed into a tree, we can call xPaths on it to grab the data we are interested in.  </p>

<pre><code class="language-python">import requests  
from lxml import html

response = requests.get('http://jakeaustwick.me')

# Parse the body into a tree
parsed_body = html.fromstring(response.text)

# Perform xpaths on the tree
print parsed_body.xpath('//title/text()') # Get page title  
print parsed_body.xpath('//a/@href') # Get href attribute of all links  
</code></pre>

<h5 id="downloadallimagesonapage">Download all images on a page</h5>

<p>The following script will download all the images, and save them in <code>downloaded_images/</code>. Make sure that directory exists before running it.  </p>

<pre><code class="language-python">import requests  
from lxml import html  
import sys  
import urlparse

response = requests.get('http://imgur.com/')  
parsed_body = html.fromstring(response.text)

# Grab links to all images
images = parsed_body.xpath('//img/@src')  
if not images:  
    sys.exit("Found No Images")

# Convert any relative urls to absolute urls
images = [urlparse.urljoin(response.url, url) for url in images]  
print 'Found %s images' % len(images)

# Only download first 10
for url in images[0:10]:  
    r = requests.get(url)
    f = open('downloaded_images/%s' % url.split('/')[-1], 'w')
    f.write(r.content)
    f.close()
</code></pre>

<h5 id="singlethreadedcrawlerbasic">Single Threaded Crawler (basic)</h5>

<p>This crawler just shows the basic principle behind crawling. It uses a dequeue so you can pop from the left of the queue and therefore fetch URLs in the order you find them. It doesn't do anything useful with the pages, just printing out the page title.</p>

<pre><code class="language-python">import requests  
from lxml import html  
import urlparse  
import collections

STARTING_URL = 'http://jakeaustwick.me'

urls_queue = collections.deque()  
urls_queue.append(STARTING_URL)  
found_urls = set()  
found_urls.add(STARTING_URL)

while len(urls_queue):  
    url = urls_queue.popleft()

    response = requests.get(url)
    parsed_body = html.fromstring(response.content)

    # Prints the page title
    print parsed_body.xpath('//title/text()')

    # Find all links
    links = {urlparse.urljoin(response.url, url) for url in parsed_body.xpath('//a/@href') if urlparse.urljoin(response.url, url).startswith('http')}

    # Set difference to find new URLs
    for link in (links - found_urls):
        found_urls.add(link)
        urls_queue.append(link)
</code></pre>


         </div>

			</div></body></html>