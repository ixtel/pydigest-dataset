<html><body><div><div class="body"><div itemscope="" itemtype="http://schema.org/Article"><h1 class="title" itemprop="name">Wondering about django orm caching frameworks</h1><p class="date"> Wed 25 August 2010</p><div itemprop="articleBody"><p>So briefly looking over the code reveals that:</p><ul class="simple"><li><a class="reference external" href="http://bitbucket.org/jmoiron/johnny-cache">johnny-cache</a> will cache the rows returned by the execution machinery in django's sql compiler (monkey-patches the compilers). It looks like it has fancy-pants invalidation (it basically has bulk invalidation through 2-tiered cache key scheme, unlike cache-machine with relies on <tt class="docutils literal">set_many</tt>) and even support for transactions. I'm using this and it's awesome.</li><li><a class="reference external" href="http://github.com/jbalogh/django-cache-machine">django-cache-machine</a> will cache the result of the <tt class="docutils literal">QuerySet.iterator</tt> method. It seems that it has some limitations: it only (automatically) invalidates on forward relations (FKs) so you have to perform carefull invalidation through your code (eg: you use <tt class="docutils literal">qs.update()</tt>, run queries through models without the custom CachingManager, use <tt class="docutils literal">Model.create()</tt> and whatnot ...). Also, cache-machine will be heavy on the memcached traffic (1 call for every invalidated object, using <tt class="docutils literal">set_many</tt> though ...)</li><li><a class="reference external" href="http://github.com/dziegler/django-cachebot">django-cachebot</a> will cache the rows on the same level as cache-machine (at QuerySet.iterator call). Also, it has a very nice feature that will prefetch objects from reverse relations (like FK reverse descriptors and many to many relations - eg: <tt class="docutils literal"><span class="pre">Group.objects.select_reverse('user_set')</span></tt> and then <tt class="docutils literal">group.user_set_cache</tt> will be equal to <tt class="docutils literal">group.user_set.all()</tt>). Unfortunately the author only tested it on django 1.1 and it needs a django patch to work (the django manager patch is only for 1.1). I really like that <tt class="docutils literal">select_reverse</tt> feature - unfortunately I can't use this on django 1.2 :(</li></ul><p>So I'm thinking what I need is johnny-cache for the low level stuff and then some cache-machine to cache some of that "<tt class="docutils literal">select_reverse</tt>" feng-shui that I would have to do myself.</p><p>Well, I'm probably missing something here and some <a class="reference external" href="http://simonwillison.net/2010/Mar/11/cachemachine/#c61069">other</a> people should have better comparisons for these frameworks. Any feedback?</p><p>Edit: cachebot's <tt class="docutils literal">select_reverse</tt> is based on <a class="reference external" href="http://code.google.com/p/django-selectreverse/">django-selectreverse</a>, however it's enhanced to support nested reverse relations (eg, from the docs: <tt class="docutils literal"><span class="pre">Article.objects.select_reverse('book_set','book_set__publisher_set')</span></tt>)</p></div><p class="tags">This entry was tagged as <a href="https://blog.ionelmc.ro/tag/django/"><span itemprop="keywords">django</span></a><a href="https://blog.ionelmc.ro/tag/python/"><span itemprop="keywords">python</span></a></p></div><p id="disqus_thread"/><noscript> Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript> </div></div></body></html>