<html><body><div><div class="entry-content">
		<p>My <a title="Teaching an old dog new tricks — or, how I learned to love Python’s str.format, and gave up on %" href="http://blog.lerner.co.il/teaching-old-dog-new-tricks-learned-love-str-format-gave/">most recent blog post</a> talked about the use of str.format instead of the % operator for interpolating values into strings. Some people who read the post wondered about their relative speeds.</p>
<p>I should first note that my first response to this is: I don’t really care that much. I’m not saying that speed isn’t important, or that optimization should never be done. Rather, my philosophy is that people are expensive and computers are cheap — and thus, anything we do to make people more productive, even if that comes at the expense of program speed, is probably fine.</p>
<p>Of course, that’s not <em>always</em> going to be true. Sometimes, you need (or just want) to squeeze more out of your computer. And to be a good programmer, you also need to know the relative advantages and disadvantages of the techniques you’re using.</p>
<p>So I decided to run a few, quick benchmarks on the relative speeds of str.format and %.  Sure enough, the % operator was a lot faster.  I ran my benchmarks the magic %timeit command that is built into the IPython interactive shell.  (If you’re using Python and aren’t using IPython, you should really switch ASAP.)  Note that in order to make things easier to read, I’m removing the IPython input and output prompts, and using &gt;&gt;&gt; to denote where I entered text.</p>
<pre><span>&gt;&gt;&gt; name = 'Reuven'
</span>&gt;&gt;&gt; %timeit 'Hello there, {}'.format(name)
1000000 loops, best of 3: 243 ns per loop

&gt;&gt;&gt; %timeit 'Hello there, %s' % name
10000000 loops, best of 3: 147 ns per loop</pre>
<p>Wow.  As you can see, %timeit executed each of these lines of code 1,000,000 times. It then gave the average speed per loop. The % operator was, on average, about 100 ns faster than str.format. That shouldn’t come as a huge surprise, given that % is an operator (and thus doesn’t require a method call), doesn’t handle indexes and attributes, and can (I’m guessing) pass a great deal of its work off to C’s printf function.</p>
<p>Then again, is 100 ns really that long to wait for a formatted string?  I’m not so sure, to be honest.</p>
<p>What happens if we perform more than one interpolation?</p>
<pre>&gt;&gt;&gt; first = 'Reuven'
&gt;&gt;&gt; last = 'Lerner'
&gt;&gt;&gt; %timeit 'Hello there, {} {}'.format(first, last)
1000000 loops, best of 3: 371 ns per loop

&gt;&gt;&gt; %timeit 'Hello there, %s %s' % (first, last)
1000000 loops, best of 3: 243 ns per loop

</pre>
<p>Each of these takes significantly longer to run than was the case with a single replacement. The difference between them continues to be about 120 ns per assignment — still not something to worry about too much, but the difference does exist.</p>
<p>What if I make the strings space-padded?</p>
<pre>&gt;&gt;&gt; %timeit 'Hello there, {:10} {:15}' % (first, last)
1000000 loops, best of 3: 459 ns per loop

&gt;&gt;&gt; %timeit 'Hello there, %10s %15s' % (first, last)
1000000 loops, best of 3: 254 ns per loop</pre>
<p>Now we see an even starker difference between the two ways of handling things. What about something like floating-point math, which takes longer?</p>
<pre>&gt;&gt;&gt; import math
&gt;&gt;&gt; %timeit 'I love to eat {}'.format(math.pi)
1000000 loops, best of 3: 587 ns per loop

&gt;&gt;&gt; %timeit 'I love to eat %f' % math.pi
1000000 loops, best of 3: 354 ns per loop</pre>
<p>Limiting the number of decimals shown doesn’t seem to change the outcome very much:</p>
<pre>&gt;&gt;&gt; %timeit 'I love to eat {:.3}'.format(math.pi)
1000000 loops, best of 3: 582 ns per loop

&gt;&gt;&gt;%timeit 'I love to eat %.3f' % math.pi
1000000 loops, best of 3: 329 ns per loop</pre>
<p><strong>UPDATE</strong>: Several people on Reddit took me to task for failing to consider the overhead of the str.format method call.  I mentioned this briefly above, but should have realized that there was an easy to to avoid this, namely aliasing the attributes (the method str.format and the float math.pi) to local variables:</p>
<pre>&gt;&gt;&gt; f = 'I love to eat {:.3}'.format
&gt;&gt;&gt; p = math.pi
&gt;&gt;&gt; %timeit f(p)
1000000 loops, best of 3: 489 ns per loop

&gt;&gt;&gt; %timeit 'I love to eat %f' % p
1000000 loops, best of 3: 370 ns per loop</pre>
<p>We still see significant overhead. Again, I’m guessing that a lot of this has to do with the overhead of a method vs. an operator. I’m not about to start looking at the bytecodes; this wasn’t meant to be a super-deep investigation or benchmark, but rather a quick check and comparison, and I think that on that front, it did the trick.</p>
<p>So, what have we learned?</p>
<ul>
<li>Yes, str.format is slower than %.</li>
<li>The number of parameters you pass to str.format, and whether you then adjust the output with padding or a specified number of decimals, significantly influences the output speed.</li>
<li>That said, in many programs, the difference in execution speed is often 100 ns, which is not enough to cause trouble in many systems.</li>
</ul>
<p>If speed is really important to you, then you should probably use %, and not str.format. However, if speed is more important than the maintainability or readability of your code, then I’d argue that Python is probably a poor choice of programming language.</p>
	</div>

	
	</div></body></html>