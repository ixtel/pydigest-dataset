<html><body><div><div class="post-content" itemprop="articleBody">
    <p>Some years ago, I lived in Norfolk, VA with a friend who loved craft beer as much as I did. Our hoppy passion motivated us to brew beer at home, visit local craft beer stores, and generally enjoy our nights with a brew here or there. Subconsciously knowing it would be a brilliant idea, we used a tupperware box next to our refrigerator to house a growing collection of beer caps, feeding it a single cap as each beer departed the cold, destined for enjoyment.</p>

<p>After a few years, I realized the box was close to being filled to the brim. The mechanical gears in my head were cranking out an idea to do something creative with the bottle caps. I wanted to incorporate some things I'd learned in my classes related to imaging, computer vision, data mining, and spectral signatures. I also had an old square coffee table (36"x36") that could be the canvas to this project. This was the beginning of a fun exploration in image processing with python to create a bottle cap magnum opus.</p>
<p><strong>Getting it Done</strong><br/>
There were a few things I needed to do; first, I needed more caps.  Given the size of a bottle cap (1") minus some width for a border around the table and a little space between the caps, I found that the table would accept a 30 cap by 30 cap grid, therefore I needed at least 900 caps.  A local bar supported this effort by hosting a 5 gallon bucket for the bartender to drop caps into in lieu of the trash can.</p>
<p>Second, I needed a way to extract the data (color; specifically red, green, and blue) from each individual cap.  I originally arranged the images on a gridded sheet of paper, took a photo, and extracted them row-by-column after performing some image transforms to account for the skewed nature of the image.  As it turns out, there is no good way to get a completely top-down image of the caps; it will always turn out to be smaller at the top and larger at the bottom depending on the angle you held the camera at. The data wasn't fantastic and as more caps came in, I knew I needed a better way; a quick survey of computer vision capabilities turned up a concept called a <a title="Hough Transform (Wikipedia)" href="http://en.wikipedia.org/wiki/Hough_transform" target="_blank">Hough Transform</a>.</p>
<p>Hough transforms are a method of identifying shapes that can be approximated by equations in images; in this case, a circle with a roughly known radius was the target. This synopsis is a vast simplification, but for each pixel in the output image (of the same size as the input image), the algorithm polls those surrounding pixels that might form a circle and assigns a value to that pixel. Based on all the pixels in the image, one can then surmise that the pixels with values above a certain threshold are the center point for a circle of known radius. To facilitate the discovery of circles of a specific radius (as many caps have concentric circle patterns), I used a <a href="http://en.wikipedia.org/wiki/Sobel_operator">Sobel operator</a> to convert the image into an edge-only image.</p>
<p><figure class="alignright"><img class="wp-image-482 size-medium" src="/assets/caps_on_sheet.jpg?w=300" alt="caps_on_sheet"/><figcaption>A subset of the caps, spread out and photographed.</figcaption></figure></p>
<p>Although I initially wrote my own <a href="http://en.wikipedia.org/wiki/Sobel_operator" target="_blank">Sobel Filter</a> and Hough Transform in Python, I think it's smarter to use <a title="OpenCV" href="http://docs.opencv.org/" target="_blank">OpenCV</a>, which I later discovered.  OpenCV is a set of computer vision related functions written in C/C++ with wrappers for Python; Hough transforms are only one of the things that OpenCV can simplify from a multi-hour debacle into a few minutes of digging in the documentation for the right tool. Here  is a quick snippet of something that took me dozens of lines of code in earlier editions:</p>
<p>
<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">cv2hough</span><span class="p">(</span><span class="n">sobel_image</span><span class="p">,</span> <span class="n">color_image</span><span class="p">,</span> <span class="n">minrad</span><span class="p">,</span> <span class="n">maxrad</span><span class="p">):</span>
    <span class="s">'''
    Identifies and cuts out to a directory potentially circular
    shapes that match a known radius range.
    :param sobel_image: sobel-filtered image
    :param color_image: non-sobel filtered version of colored_image
    :return:
    '''</span>
    <span class="n">in_cv_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">sobel_image</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">avg_rad</span> <span class="o">=</span> <span class="p">(</span><span class="n">minrad</span><span class="o">+</span><span class="n">maxrad</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">circles</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">HoughCircles</span><span class="p">(</span><span class="n">in_cv_image</span><span class="p">,</span> <span class="n">cv</span><span class="o">.</span><span class="n">CV_HOUGH_GRADIENT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span>
    <span class="n">param1</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">param2</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">minRadius</span><span class="o">=</span><span class="n">minrad</span><span class="p">,</span> <span class="n">maxRadius</span><span class="o">=</span><span class="n">maxrad</span><span class="p">)</span>
    <span class="n">exportCircles</span><span class="p">(</span><span class="n">circles</span><span class="p">,</span> <span class="n">color_image</span><span class="p">,</span> <span class="s">'caps'</span><span class="p">,</span> <span class="n">avg_rad</span><span class="p">)</span></code></pre></figure>
</p>
<p>(Documentation for <a title="cv2.HoughCircles" href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html?highlight=hough#cv2.HoughCircles" target="_blank">cv2.HoughCircles</a>)</p>
<p>This code snippet concludes by sending a list of all the places on the image where it thinks a cap might be to "exportCircles", where those caps are then cut out of the image and sent to a 30px x 30px JPG file.</p>
<p><figure><img class="wp-image-480" src="/assets/circle_3_img.jpg" alt="circle_3_img"/><figcaption> A cap, post-extraction. It's a rough approximation, but the hough transform was sufficient.</figcaption></figure></p>
<p>Once we have a directory containing hundreds and hundreds of caps, we can begin some analysis. (Full disclosure: I manually scrolled through the images and deleted those that appeared unusable.) Python was used to calculate statistics for each bottle cap image, and eventually stored the data in a structure. Each pixel is calculated applying a red (R), green (G), and blue (B) value. We can average these and get average (R,G,B) triplets for each bottle cap, that is to say; a cap is "mostly" red, or "mostly" blue, etc. I soon found that these numbers weren't that descriptive and began to work in the Hue, Saturation, and Value color spaces. (<a title="HSL &amp; HSV: Wikipedia" href="http://en.wikipedia.org/wiki/HSL_and_HSV" target="_blank">HSL &amp; HSV: Wikipedia</a>).</p>
<p>Protip: I used a quick one-liner to convert from RGB to HSV before storing the data:<br/>
<code>colorsys.rgb_to_hsv(rgb[0], rgb[1], rgb[2])</code></p>
<p>To save time cataloging 900 bottle caps and associated pixels, I <a href="https://docs.python.org/2/library/pickle.html" target="_blank">pickle</a> (serialize) each cap as I generate the data on it so I can quickly reference a data structure containing the caps and rearrange them as I see fit.</p>
<p><figure><img class="wp-image-486 size-large" src="/assets/caps_avg.jpg?w=584" alt="caps_avg"/><figcaption>The caps by average, as the computer sees them.</figcaption></figure></p>
<p><figure><img class="wp-image-487 size-large" src="/assets/comp_output.jpg?w=584" alt="comp_output"/><figcaption> The caps as we see them; the final arrangement was sorted by hue then saturation.</figcaption></figure></p>
<p><b>Final Steps: Output</b><br/>
I originally wanted to see what it would look like when I rearranged the bottle caps into different patterns. This is where we do that, and based on the data we have and the framework we've built, outputting an image or a HTML document (this is a really hasty solution!) becomes fairly easy, minus one hiccup.</p>
<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">first_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="s">'''
    Reach into the internal config and find out what we want to have as
    our first order sort on the caps.
    :return:
    '''</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sortedDatList</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imageDatList</span><span class="p">,</span>
                                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">thislist</span><span class="p">:</span> <span class="n">thislist</span><span class="p">[</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">sorts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s">'first_sort'</span><span class="p">]]])</span>
    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">imageDatList</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">imageDatList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sortedDatList</span>
<span class="k">def</span> <span class="nf">second_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="s">'''
    Second sort on the caps: sort rows individually.
    Example: We want a 30x30 grid of caps, sorted first by hue, then by
    saturation.
    We sort by hue in first_sort, then in second_sort, we sort 30 lists
    of 30 caps each individually and replace them into the list.
    :return:
    '''</span>
    <span class="n">ranges</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s">'out_caps_cols'</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s">'out_caps_cols'</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span>
              <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s">'out_caps_rows'</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imageDatList</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imageDatList</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                              <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">thislist</span><span class="p">:</span> <span class="n">thislist</span><span class="p">[</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">sorts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span>
                                                      <span class="s">'second_sort'</span><span class="p">]]])</span></code></pre></figure>
<p>Here we see two functions: firstSort and secondSort. You can guess that we sort the caps once, then sort them again; what may not be apparent from this code is that the second sort (which is performed on a different attribute), is performed based on the out_caps_rows attribute. This is the hiccup; you must sort multiple sub-segments of the array of bottle caps, in essence, sorting the rows after the columns have been generated. Otherwise each row of bottle caps will have a random pattern as the image trends from one extreme (top) to the other (bottom).</p>
<p><figure><img class="wp-image-483 size-large" src="/assets/caps_organized.jpg?w=584" alt="caps_organized"/><figcaption> Caps, laid out and ready to be transferred to the table.</figcaption></figure></p>
<p><b>The Physical Construction</b><br/>
To finish the project, I physically arranged a pattern based on informal votes from friends and acquaintances. I built a 1/2" lip around the table with "Quarter-Round" molding. I glued this down, sealed the seams with wood glue, and painted everything black.</p>
<p>I filled the bottom of this open-top area with playground sand. This minimized the volume that I would have to fill in with expensive epoxy resin. It had the secondary benefit of lightening up the entire display, knowing the epoxy would darken it. I ordered two kits of "AeroMarine 300/21 Epoxy Resin" (for a total of 3 Gallons) from the internet. Ultimately, I arranged the caps on a sheet of butcher's paper and transferred them one-by-one to the sand box.</p>
<p>A few friends, the famous roommate, and I gathered (with beers); we mixed the resin and began the process of pouring the resin onto the table. The one unseen consequence of the sand was that when the epoxy entered the sand, it pushed air upwards, causing the caps to float; we quickly used toothpicks to push the caps down into the sand, then poured more resin over top.</p>
<p><figure><img class="wp-image-484 size-large" src="/assets/caps_final.jpg?w=584" alt="caps_final"/><figcaption> The table, post-drying and finished.</figcaption></figure></p>
<p>Code for this was hacked together over a number of weeks, I've consolidated it here: <a href="https://github.com/jamesfe/capViz">https://github.com/jamesfe/capViz</a>.  Unfortunately, most of this code was written in a disheveled, disconnected manner and I'm just now beginning to tie it together into one well documented, good-practice PEP-8 compliant piece, but feel free to poke around and let me know what you think!</p>
<p>Thanks to <a href="http://thebirchbar.com/" target="_blank">The Birch</a> for all the beer caps!</p>
<p>If this interested you, follow me on Twitter! <a href="https://twitter.com/jimmysthoughts" target="_blank">@jimmysthoughts</a></p>

  </div>

</div></body></html>