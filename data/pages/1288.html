<html><body><div><section class="body">
        <p>The book <a href="http://pragprog.com/book/bksqla/sql-antipatterns">SQL Antipatterns</a> is one of my favourite books. I took the opportunity to reread it on a trip to <a href="https://www.xero.com/au/xerocon/sydney/">Xerocon</a> in Sydney, and as usual it enlightened me to thing I am probably doing in my database interactions.</p>

<p>So, I’m going to look at these Antipatterns, and discuss how you can avoid them when using <a href="https://ww.django project.com">Django</a>. This post is intended to be read with each chapter of the book. I’ve used the section headings, but instead of the chapter headings, I’ve used the Antipattern headings. They are still in the same order, though.</p>

<p>It seems the printed version of this book is on sale now: I’m tempted to buy a few extra copies for gifts. Ahem, cow-orkers.</p>

<h3 id="part-1">
  Logical Database Design Antipatterns
  <a class="self" href="#part-1">¶</a>
</h3>

<h4 id="chapter-2">
  Format Comma-Separated Lists
  <a class="self" href="#chapter-2">¶</a>
</h4>

<p>This one is pretty simple: use a relation instead of a <a href="https://docs.djangoproject.com/en/1.7/ref/models/fields/#commaseparatedintegerfield">Comma Separated field</a>. In the cases described in the book, a <a href="https://docs.djangoproject.com/en/1.7/ref/models/fields/#manytomanyfield"><code>ManyToManyField</code></a> is in fact simpler than a Comma Separated field. Django gets a gold star here, both in ease of use, but also in documentation about relations.</p>

<p>However, there may be times when a relation is overkill, and a real array is better. For instance, when storing data related to which days of the week are affected by a certain condition, it may make sense to store it in this way.</p>

<p>But we can do better than a simple Comma Separated field. Storing the data in a Postgres Array means we can rely on the database to validate the data, and allows searching. Similarly, we could store it in JSON, too.</p>

<p>I’ve maintained a <a href="https://pypi.python.org/pypi/django-jsonfield">JSONField</a> for Django, although it’s not easily queryable. However, an <a href="https://docs.djangoproject.com/en/dev/ref/contrib/postgres/fields/#arrayfield">ArrayField</a> is coming in Django 1.8. There are alternatives already available if you need to use one now. I’ve got a project to mostly backport the <a href="https://docs.djangoproject.com/en/dev/ref/contrib/postgres/"><code>django.contrib.postgres</code></a> features to 1.7: <a href="https://bitbucket.org/schinckel/django-postgres/">django-postgres</a>.</p>

<p>Things like JSON, Array and Hstore are a better solution than storing other-delimitered values in a straight text column too. With Django 1.7, it became possible to have lookups, which can leverage the DBMS’ ability to query these datatypes.</p>

<h4 id="chapter-3">
  Always Depend on One’s Parent
  <a class="self" href="#chapter-3">¶</a>
</h4>

<p><a href="http://media.pragprog.com/titles/bksqla/trees.pdf">Read chapter online</a>.</p>

<p>Straight into a trickier one! And, Django’s documentation points out how to create his type of relation, but does not call out the possible issues. This book is worth it for this section alone.</p>

<p>So, how do we deal with trees in Django?</p>

<p>We can use <a href="http://django-mptt.github.io/django-mptt/">django-mptt</a>. This gives us (from what I can see) the “Nested Sets” pattern outlined in the book, but under the name “Modified Preorder Tree Traversal”.</p>

<p>I’m quite interested in the idea of using a Closure Table, and there are a couple of projects with quite different approaches to this:</p>

<ul>
  <li><a href="https://github.com/HiddenData/django-ctt">django-ctt</a>: uses a Model class you inherit from.</li>
  <li><a href="http://django-ct.readthedocs.org/en/latest/">django-ct</a>: better documented, but uses an unusual pattern of a pseudo-manager-thing.</li>
</ul>

<p>Knowing me, I’m probably going to spend some time building a not-complete implementation at some point.</p>

<p><em>Update:</em> Whilst I haven’t built an implementation of a Closure Table, I did implement <a href="/2014/09/13/long-live-adjacency-lists/">recursive queries for an Adjacency List</a>.</p>

<h4 id="chapter-4">
  One Size Fits All
  <a class="self" href="#chapter-4">¶</a>
</h4>
<p>Using a field <code>id</code> for all tables by default is probably one of the biggest mistakes I think Django makes. And, as we shall see, we can’t yet avoid them, for at least a subset of situations.</p>

<p>Indeed, Django can use any single column for the primary key, and doesn’t <em>require</em> the use of a key column of name <code>id</code>. So, in my mind, it would have been better to use the <code>&lt;tablename&gt;_id</code>, as suggested in the book. Especially since you may also access the primary key attribute using the <code>pk</code> shortcut.</p>

<div class="highlight"><pre><code class="python"><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">foo_id</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">AutoField</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre>
</div>

<p>However, it’s not currently possible to do composite primary keys (but may be <a href="https://docs.djangoproject.com/en/dev/releases/1.7/#new-method-on-field-subclasses">soon</a>), which makes doing the best thing for a plain ManyToManyField possible: indeed, you don’t control that table anyway, and if you remove the <code>id</code> column (and create a proper primary key), things don’t work. In practice, you can just ignore this issue, since you (mostly) don’t deal with this table, or the objects from it.</p>

<p>So, assuming we are changing the <code>id</code> column into the name suggested in the book, what does that give us?</p>

<p>Nothing, until we actually need to write raw SQL code, and specifically code that joins multiple tables.</p>

<p>Then, we are able to use a slightly less verbose way of defining the join, and not worry about duplicate columns named <code>id</code>:</p>

<div class="highlight"><pre><code class="sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">foo_foo</span> <span class="k">JOIN</span> <span class="n">foo_bar</span> <span class="k">USING</span> <span class="p">(</span><span class="n">foo_id</span><span class="p">);</span>
</code></pre>
</div>

<p>I’m still not sure if it’s actually worthwhile doing this or not. I’m going to start doing it, just to see whether there are any drawbacks (already found one in some of my own code, that hard-coded an <code>id</code> field), or any great benefits.</p>

<h4 id="chapter-5">
  Leave out the Constraints
  <a class="self" href="#chapter-5">¶</a>
</h4>

<p>Within Django, it’s more work to create relations <em>without</em> the relevant constraints, and it’s not possible to create a table without a primary key, so we can just pass this one by with a big:</p>

<p><img src="http://media-cache-ak0.pinimg.com/originals/4c/a2/c5/4ca2c51feb4d02442c3e53d29b1a3e22.jpg" alt="smile and wave, boys"/></p>

<h4 id="chapter-6">
  Use a Generic Attribute Table
  <a class="self" href="#chapter-6">¶</a>
</h4>

<p>Again, it’s possible to create this type of a monstrosity in Django, but not easy. A better solution, if your table’s requirements change is to use migrations (included in Django 1.7), or a more flexible store, like JSON or Hstore. This also has the added advantage of being a column, rather than a related table, which means you can fetch it in one go, simply. Similarly, with Postgres 9.3, you can do all sorts of querying, and even more in 9.4.</p>

<p>Document or key stores are no substitute for proper attributes, but they do have their uses.</p>

<p>The other solution is to use <a href="https://docs.djangoproject.com/en/1.7/topics/db/models/#model-inheritance">Model inheritance</a>, which Django does well. You can choose either abstract or concrete table inheritance, and with something like <a href="http://django-model-utils.readthedocs.org">django-model-utils</a>, even get some nice features like fetching only the subtypes when fetching a queryset of superclass models.</p>

<h4 id="chapter-7">
  Use Dual-Purpose Foreign Key
  <a class="self" href="#chapter-7">¶</a>
</h4>

<p>Unfortunately, Django comes with a built-in way to do this: so-called <a href="https://docs.djangoproject.com/en/1.7/ref/contrib/contenttypes/#generic-relations">Generic Relations</a>.</p>

<p>Using this, it’s possible to have an association from a given model instance to any other object of any other model class.</p>

<blockquote>
  <p>“You may find that this antipattern is unavoidable if you use an object-relational programming framework […]. Such a framework may mitigate the risks introduced by Polymorphic Associations by encapsulating application logic to maintain referential integrity. If you choose a mature and reputable framework, then you have some confidence that its designers have written the code to implement the association without error.”</p>
</blockquote>

<p>I guess we’ll just have to rely on the fact Django is a mature and reputable framework.</p>

<p>In all reality, I’ve used this type of relation <em>once</em>: for notifications that need to be able to refer to any given object. It’s also possible to use, say, a tagging app that had generic relations. But, I’m struggling to think of too many situations where it would be better than a proper relation.</p>

<p>I’ve also come across it in <a href="http://django-reversion.readthedocs.org">django-reversion</a>, and running queries against objects from it is a pain in the arse.</p>

<h4 id="chapter-8">
  Create Multiple Columns
  <a class="self" href="#chapter-8">¶</a>
</h4>

<p>Interestingly, the example for this Antipattern is the example I just used above: tags. And, this type of situation <em>should</em> be done in a better way: a proper relation, or perhaps an Array type. It all depends how good your database is at querying arrays. <a href="https://docs.djangoproject.com/en/dev/ref/contrib/postgres/"><code>django.contrib.postgres</code></a> makes this rather easy:</p>

<div class="highlight"><pre><code class="python"><span class="k">class</span> <span class="nc">Post</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">tags</span> <span class="o">=</span> <span class="n">ArrayField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="n">blank</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">Post</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">tags__contains</span><span class="o">=</span><span class="p">[</span><span class="s">'foo'</span><span class="p">])</span>
</code></pre>
</div>

<p>What may not be so easy is getting <em>all</em> of the tags in use. This may be possible: I just haven’t thought of a way to do this yet. A nice syntax might be:</p>

<div class="highlight"><pre><code class="python"><span class="n">Post</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">All</span><span class="p">(</span><span class="s">'tags'</span><span class="p">))</span>
</code></pre>
</div>

<p>The SQL you might be able to use to get this could look like:</p>

<div class="highlight"><pre><code class="sql"><span class="k">SELECT</span>
  <span class="n">array_agg</span><span class="p">(</span><span class="k">distinct</span> <span class="n">t</span><span class="p">)</span> <span class="k">AS</span> <span class="n">tags</span>
<span class="k">FROM</span> <span class="p">(</span>
  <span class="k">SELECT</span> <span class="k">unnest</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">posts</span>
<span class="p">)</span> <span class="n">t</span><span class="p">;</span>
</code></pre>
</div>

<p>I’m not sure if there’s a better way to get this data.</p>

<h4 id="chapter-9">
  Clone Tables or Columns
  <a class="self" href="#chapter-9">¶</a>
</h4>

<p>I can’t actually see that doing this in Django would be easy, or likely. It’s gotten me interested in some method of seamlessly doing Horizontal Partitioning as a method of archiving old data, and perhaps moving it to a different database. Specifically, moving old audit data into a separate store may become necessary at some point.</p>

<p>Partitioning using a multi-tenancy approach using Postgres’ schemata is another of my interests, and I’ve been working on a django-specific way to do this: <a href="http://django-boardinghouse.readthedocs.org">django-boardinghouse</a>. Note, this is a partial-segmentation approach, where some tables are shared, but others are per-schema.</p>

<h3 id="part-2">
  Physical Database Design Antipatterns
  <a class="self" href="#part-2">¶</a>
</h3>

<h4 id="chapter-10">
  Use FLOAT Data Type
  <a class="self" href="#chapter-10">¶</a>
</h4>

<p>Just don’t.</p>

<p>There’s a <a href="https://docs.djangoproject.com/en/1.7/ref/models/fields/#decimalfield"><code>DecimalField</code></a>, and no reason not to use it.</p>

<h4 id="chapter-11">
  Specify Values in the Column Definition
  <a class="self" href="#chapter-11">¶</a>
</h4>

<p>The example the book uses is to define <em>check constraints</em> on a given question. Django’s approach is a bit different: the valid choices are defined in the column definition, but can be changed in code at any time. Any existing values that are no longer valid are fine, but any attempt to save an object will require it to have one of the newly valid choices.</p>

<p>This is both better and worse than the problem described in the book. There’s no way (short of a migration) to change the existing data, but maybe that’s actually just better.</p>

<p>Again, the <em>best</em> solution is just to use a related field, but in some cases this is indeed overkill: specifically if values are unlikely to change.</p>

<h4 id="chapter-12">
  Assume You Must Use Files
  <a class="self" href="#chapter-12">¶</a>
</h4>

<p>I’m still 50-50 on this one. Basically, storing binary files in your database (a) makes the database much bigger, which means it takes longer to back it up (and restore it), and (b) means that it’s harder to do things like use the web server, rather than the application server, to serve static files (even those user-supplied, that must be authenticated).</p>

<p>The main disadvantage, of not having backups, is purely an operations issue.</p>

<p>The secondary disadvantage: the lack of transactionality is also easily solved: don’t delete files (unless necessary), and don’t overwrite them. If you really must, then use a Postres <code>NOTIFY delete-file &lt;filepath&gt;</code> or similar, and have a listener that handles that.</p>

<p>The other disadvantage, about SQL privilidges is mostly moot under Django anyway, as you are always running as the one database user.</p>

<h4 id="chapter-13">
  Using Indexes Without a Plan
  <a class="self" href="#chapter-13">¶</a>
</h4>

<p>Indexes are fairly tangiential to an ORM: I’m going to pass over this one without too much comment. I’ve been doing a fair bit of index-level optimisations on my production database lately, in an effort to improve performance. Mostly, it’s better to optimise the query, as the likely targets for indexes probably already have them.</p>

<h3 id="part-3">
  Query Antipatterns
  <a class="self" href="#part-3">¶</a>
</h3>

<h4 id="chapter-14">
  Use Null as an Ordinary Value, or Vice Versa.
  <a class="self" href="#chapter-14">¶</a>
</h4>

<p>Python has it’s own <code>None</code> type/value, and using it in queries basically converts it into <code>NULL</code>. Django is a little annoying how at times it stores empty strings instead of <code>NULL</code> in string fields. I was playing around with making these into proper <code>NULL</code>s, but it seemed to create other problems.</p>

<p>At least there is no established pattern to use other values instead of <code>NULL</code>.</p>

<h4 id="chapter-15">
  Reference Non-grouped Columns
  <a class="self" href="#chapter-15">¶</a>
</h4>

<p>Since I’m dealing with Postgres, I understand this one is not much of an issue. Your query will fail if you build it wrong. Which should be the way databases work.</p>

<h4 id="chapter-16">
  Sort Data Randomly
  <a class="self" href="#chapter-16">¶</a>
</h4>

<p><a href="http://media.pragprog.com/titles/bksqla/random.pdf">Read this chapter online</a>.</p>

<p>The problem of how to fetch a single random instance from a Model comes up every now and then on IRC, indeed, it did again <a href="http://django-irc-logs.com/2014/aug/23/#1540792">last weekend</a>. Unsurprisingly, I provided a link to this chapter.</p>

<p>One solution that is presented in the book is to select a single row, using a random offset:</p>

<div class="highlight"><pre><code class="python"><span class="kn">import</span> <span class="nn">random</span>
<span class="c"># Note: the initial version of this would fail since queryset.count()</span>
<span class="c"># is the number of elements, randint(a, b) includes the value 'b',</span>
<span class="c"># and queryset[b] would be out of range.</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">queryset</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">instance</span> <span class="o">=</span> <span class="n">queryset</span><span class="o">.</span><span class="n">all</span><span class="p">()[</span><span class="n">index</span><span class="p">]</span>
</code></pre>
</div>

<p>This, converts to the query:</p>

<div class="highlight"><pre><code class="sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="ss">"table"</span> <span class="k">LIMIT</span> <span class="mi">1</span> <span class="k">OFFSET</span> <span class="o">%</span><span class="n">s</span><span class="p">;</span>
</code></pre>
</div>

<p>However, without an ordering, I believe this will still do a complete table seek. Instead, you want to order on a column with an index. Like the primary key:</p>

<div class="highlight"><pre><code class="python"><span class="n">instance</span> <span class="o">=</span> <span class="n">queryset</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'pk'</span><span class="p">)[</span><span class="n">index</span><span class="p">]</span>
</code></pre>
</div>

<p>It does take two queries, but sometimes two queries is better than one. Obviously, if your table was always going to be small, it may be better to do the random ordering:</p>

<div class="highlight"><pre><code class="python"><span class="n">instance</span> <span class="o">=</span> <span class="n">queryset</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'?'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</code></pre>
</div>

<h4 id="chapter-17">
  Pattern Matching Predicates
  <a class="self" href="#chapter-17">¶</a>
</h4>

<p>I’m sorry to say Django makes it far too easy to do this:</p>

<div class="highlight"><pre><code class="python"><span class="n">queryset</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">foo__contains</span><span class="o">=</span><span class="s">'bar'</span><span class="p">)</span>
</code></pre>
</div>

<p>Becomes something like:</p>

<div class="highlight"><pre><code class="sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="ss">"table"</span> <span class="k">WHERE</span> <span class="ss">"table"</span><span class="p">.</span><span class="ss">"foo"</span> <span class="k">LIKE</span> <span class="s1">'%bar%'</span><span class="p">;</span>
</code></pre>
</div>

<p>In many cases, this will be fine, but as you can imagine, you may get surprising matches, or performance may really suck.</p>

<p>Using Postgres’s full-text search is relatively simple: you can quite easily make a custom field that handles this, and with Django 1.7 or later, you can even create your own lookups:</p>

<div class="highlight"><pre><code class="python"><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span> <span class="nc">TSVectorField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">'tsvector'</span>


<span class="k">class</span> <span class="nc">TSVectorMatches</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">lookups</span><span class="o">.</span><span class="n">BuiltinLookup</span><span class="p">):</span>
    <span class="n">lookup_name</span> <span class="o">=</span> <span class="s">'matches'</span>
    <span class="k">def</span> <span class="nf">process_lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qn</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">lhs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs</span>
        <span class="k">return</span> <span class="n">qn</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_rgs_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">'@@ to_tsquery(</span><span class="si">%s</span><span class="s">)'</span> <span class="o">%</span> <span class="n">rhs</span>

<span class="n">TSVectorField</span><span class="o">.</span><span class="n">register_lookup</span><span class="p">(</span><span class="n">TSVectorMatches</span><span class="p">)</span>
</code></pre>
</div>

<p>Then, you are able, on a correctly defined field, able to do:</p>

<div class="highlight"><pre><code class="python"><span class="n">queryset</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">foo__matches</span><span class="o">=</span><span class="s">'bar'</span><span class="p">)</span>
</code></pre>
</div>

<p>Which roughly translates to:</p>

<div class="highlight"><pre><code class="sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="ss">"table"</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">foo</span> <span class="o">@@</span> <span class="n">to_tsquery</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">));</span>
</code></pre>
</div>

<p>It’s actually a little more complicated than that, but I have a working prototype at <a href="https://bitbucket.org/schinckel/django-postgres/">https://bitbucket.org/schinckel/django-postgres/</a>. There is a field class, but also an example within the <code>search</code> sub-app.</p>

<p>Clearly, you’ll want to be creating the right indexes.</p>

<h4 id="chapter-18">
  Solve a Complex Problem in One Step
  <a class="self" href="#chapter-18">¶</a>
</h4>

<p>By their very nature, ORMs tend to make this a little less easy to do. Because you don’t normally write custom code, this scenario is less common than you might see in a normal SQL access.</p>

<p>However, with Django, it is possible to write over-complicated queries, but also to use things like <code>.raw()</code>, and <code>.extra()</code> to write “Spaghetti Queries”.</p>

<p>However, it is worth noting that with judicious use of these features, you can indeed write queries that perform exceptionally well, indeed, far better than the ORM is able to generate for you. It’s also worth noting that you can write really, really bad queries that take a very long time, just using the ORM (without even doing things like N+1 queries for related objects).</p>

<p>Indeed, the “how to recognize” section of this chapter shows the biggest red flag I have noticed lately: “Just stick another DISTINCT in there”.</p>

<p>I’ve seen, first-hand how a <code>.distinct()</code> can cause a query to take a very long period of time. Removing the need for a distinct by removing the join, and instead using subqueries, caused a query that was taking around 17 seconds with a given data set to suddenly take less than 200ms.</p>

<p>That alone has forced me to reconsider each and every time I use <code>.distinct()</code> in my code (and probably explains why our code that runs queries against <a href="http://django-reversion.readthedocs.org">django-reversion</a>) performs so horribly.</p>

<h4 id="chapter-19">
  A Shortcut That Gets You Lost
  <a class="self" href="#chapter-19">¶</a>
</h4>

<p>I’ve used, in my SQL snippets in this post, the shortcut that is mentioned here: <code>SELECT * FROM ...</code>. Luckily, Django doesn’t use this shortcut, and instead lists out every column it expects to see.</p>

<p>This has a really nice side-effect: if your database tables have not been migrated to add that new column, then whenever you try to run any queries against that table, you will have an error. Which is much more likely to happen immediately, rather than at 3am when that column is first actually used.</p>

<h3 id="part-4">
  Application Development Antipatterns
  <a class="self" href="#part-4">¶</a>
</h3>

<h4 id="chapter-20">
  Store Password in Plain Text
  <a class="self" href="#chapter-20">¶</a>
</h4>

<p>There is no, I repeat, <em>no</em> reason you should ever be doing this. It’s a cardinal sin, and Django has a great authentication and authorisation framework, that you can extend however you need it.</p>

<p>As noted in the legitimate uses section: if you are accessing a third-party system, you may need to store the password in a readable format. In this case, something like Oauth, if available, may make things a little safer.</p>

<h4 id="chapter-21">
  Execute Unverified Input As Code
  <a class="self" href="#chapter-21">¶</a>
</h4>

<p><a href="http://media.pragprog.com/titles/bksqla/injection.pdf">Read this chapter online</a>.</p>

<p>Most of the risks of SQL Injection are <a href="https://docs.djangoproject.com/en/1.7/topics/security/#sql-injection-protection">mitigated</a> when you use an ORM like Django’s. Of course, if you write <code>.raw()</code> or <code>.extra()</code> queries that don’t properly escape user-provided data, then you may still be at risk. <code>.extra()</code> in particular has arguments that allow you to pass an iterable of parameters, which will then be correctly escaped as they are added to the query.</p>

<h4 id="chapter-22">
  Filling in the Corners
  <a class="self" href="#chapter-22">¶</a>
</h4>

<p>Educate your manager if (s)he thinks it’s a bad thing to have non-contiguous primary keys. Transaction rollbacks, deleted objects: there’s all sorts of reasons why there may be gaps.</p>

<h4 id="chapter-23">
  Making Bricks Without Straw
  <a class="self" href="#chapter-23">¶</a>
</h4>

<p>It goes without saying that you should have error handling within your python code.</p>

<h4 id="chapter-24">
  Make SQL a Second-Class Citizen
  <a class="self" href="#chapter-24">¶</a>
</h4>

<p>This is kind-of the point of an ORM: to remove from you the need to deal with creating complex queries in raw SQL.</p>

<p>Your Django models are the documentation of your table structure, or documentation can be generated from them. Your migrations files show the changes that have been made over time. Naturally, both of these will be stored in your Source Code Management system.</p>

<p>Clearly, as soon as you are doing anything in raw SQL, then you should follow the practices you do with the rest of your code.</p>

<p>Testing in-database is something I am a little bit interested in. As I move more code into the database (often for performance reasons, sometimes because it’s just fun), it would be nice to have tests for these functions. I have a long list of things in my Reading List about Postgres Unit Testing. Perhaps I’ll get around to them at some point. Integrating these with the Django test runner would be really neat.</p>

<h4 id="chapter-25">
  The Model Is an Active Record
  <a class="self" href="#chapter-25">¶</a>
</h4>

<p>Django’s use of the <a href="http://www.martinfowler.com/eaaCatalog/activeRecord.html">Active Record</a> is slightly different to Rails. In Rails, the column types in the database control what attributes are on the model, but in Django, the python object is the master. I think this is more meaningful, because it means that everything you need to know about an object is in the model definition: you don’t need to follow the migrations to see what attributes you have.</p>

<p>I do like the concept of a <a href="http://martinfowler.com/eaaCatalog/domainModel.html">Domain Model</a>: it’s an approach I’ve lightly tried in the past. Perhaps it is an avenue I’ll push down further at some point. In some ways, Django’s <code>Form</code> classes allow you to encapsulate this, but mostly business logic still lives on our <code>Model</code> classes.</p>

<h3 id="summary">
  Summary
  <a class="self" href="#summary">¶</a>
</h3>

<p>So, how did Django do?</p>

<p>Pretty good, I’d say. The ones that were less successful either don’t <em>really</em> matter most of the time (primary key column is always called <code>id</code>, choices defined in the model), or you don’t <em>really</em> need to use them (Generic Relations, searching using <code>LIKE %foo%</code>, using raw SQL).</p>

<p>We do fall down a bit with files stored in the database, and fat models, but I would argue that those patterns work just fine, at least for me right now.</p>

    </section>
    </div></body></html>