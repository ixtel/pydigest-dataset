<html><body><div><div class="content html_format"><p>
      Возникла задача: есть приложение под Windows, которое делает HTTPS-запросы к серверу и получает ответы. После обновления сервера приложение перестало работать. Выяснилось, что на сервере изменилась версия SSL (перешли с SSLv3 на TLSv1), а наше приложение умеет работать только по SSLv3. Приложение никто не поддерживает уже давно и менять, перекомпилировать, тестировать не хотелось. Решено было сделать прослойку между приложением и сервером, которая будет транслировать SSLv3 в TLSv1 и наоборот. Я поискал какой-нибудь прокси в интернете, но сходу не нашел (плохо искал). Решил сделать прокси на питоне. Я не профессионал в питоне, но мне показалось что для этой задачи он хорошо подходит, и интересно параллельно по изучать питон на примере реальной задачи.</p>
<a name="habracut"/>
<b>Начало</b>
<p>
Итак, устанавливаем питон 3.4. Пишем скрипт, я для этого использовал блокнот. Для ssl-сокетов понадобится модуль ssl. Для, собственно, сокетов socket.
</p><pre><code class="python">import ssl
import socket
</code></pre><p>
Создаем сокет, слушающий клиента, т.к. это будет SSL-сервер, то придется создать для него само-подписанный сертификат, который он будет предоставлять клиенту. Для создания сертификата, я использовал утилиту openssl. Скачал утилиту отсюда </p><a href="http://indy.fulgan.com/SSL/">indy.fulgan.com/SSL</a><p>. Для создания сертификата потребуется конфиг для утилиты, пример можно взять здесь </p><a href="http://web.mit.edu/crypto/openssl.cnf">web.mit.edu/crypto/openssl.cnf</a><p>. Кладем конфиг в папку на компе и устанавливаем путь к нему (далее все действия в командной строке):
</p><pre><code class="bash">set OPENSSL_CONF=путь_к_файлу\openssl.cnf
</code></pre><p>
Генерим приватный ключ
</p><pre><code class="bash">openssl genrsa -des3 -out server.key 1024
</code></pre><p>
Попутно будет предложено ввести пароль к ключу и подтверждение пароля, вводим. Создаем запрос на сертификат
</p><pre><code class="bash">openssl req -new -key server.key -out server.csr
</code></pre><p>
При генерации запроса нам нужно будет ввести пароль ключа и заполнить информацию о компании, городе, стране и т.д. Заполняем. Для того, чтобы можно было использовать ключ без пароля, копируем его и распароливаем
</p><pre><code class="bash">copy server.key server.key.org
openssl rsa -in server.key.org -out server.key
</code></pre><p>
Наконец, создаем самоподписанный сертификат
</p><pre><code class="bash">openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
</code></pre><p>
Для удобства кладем наш сертификат и ключ рядом со скриптом на питоне. Создаем сокет, который будет слушать клиента и ставим его слушать порт на который будет ходить наше приложение (далее код на питоне)
</p><pre><code class="python">sock = ssl.wrap_socket(socket.socket(), 'server.key', 'server.crt', True)
sock.bind( ('localhost', 43433) )
sock.listen(10)
</code></pre><p>
Получаем входящее соединение и запрос от клиента
</p><pre><code class="python">conn, addr = sock.accept()
data = conn.recv(1024)
</code></pre><p>
Далее нам нужно полученные данные отправить на сервер, которому они предназначались. Создаем для этого сокет и шлем в него данные
</p><pre><code class="python">serv = ssl.wrap_socket(socket.socket())
serv.connect( ('server_url', 443) )
serv.send(data)
</code></pre><p>
Итак, запрос отправили, теперь нам надо получить респонз и отдать его нашему клиенту
</p><pre><code class="python">data = serv.recv(1024)
conn.send(data)
</code></pre><p>
Ну все наш прокси готов, запускаем, кидаем запрос — не работает! Для того чтобы выяснить почему, добавим логирование. 

</p><b>Логирование</b>
<p>
Подключим модуль logging, настроим конфигурацию логирования и добавим логирование в интересные места
</p><pre><code class="python">import logging

logging.basicConfig(filename = "proxy.log", level = logging.DEBUG, format = "%(asctime)s - %(message)s")

logging.info("Ждем входящее соединение");
conn, addr = sock.accept()
logging.info("Получаем запрос")
data = conn.recv(1024)
logging.info(data)

logging.info("Отправляем запрос на сервер")
serv.send(data)

logging.info("Получаем ответ сервера")
data = serv.recv(1024)
logging.info(data)

logging.info("Отдаем ответ клиенту")
client.send(resp)
</code></pre>

<b>Чтение всех данных</b>
<p>
Оказалось что данные клиент передает по блокам, т.е. мы прочитали не полный запрос. Потом выяснится, что сервер также отдает ответ по блокам. Усовершенствуем наш код чтобы читать запрос и ответ по блокам. Для этого создаем буфер, в который будем складывать весь запрос, устанавливаем сокету таймаут 0.1 с, который он будет ждать данные от входящего соединения и в цикле читаем и складываем в буфер данные. Если данных не будет, то получим исключение и выйдем из цикла
</p><pre><code class="python">logging.info("Получаем запрос")
data = conn.recv(1024)
req = b''
conn.settimeout(0.1)
while data:
    req += data
    try:
        data = conn.recv(1024)
    except socket.error:
        break
logging.info(req)
</code></pre><p>
То же для чтения данных от сервера
</p><pre><code class="python">logging.info("Получаем ответ сервера")
resp = b''
serv.settimeout(1)
data = serv.recv(1024)
while data:
    resp += data
    try:
        data = serv.recv(1024)
    except socket.error:
        break
logging.info(resp)
</code></pre><p>
Меняем данные которые будем отправлять серверу и клиенту
</p><pre><code class="python">logging.info("Отправляем запрос на сервер")
serv.send(req)

logging.info("Отдаем ответ клиенту")
client.send(resp)
</code></pre><p>
Запускаем. Теперь работает, однако приходится запускать скрипт при каждом запросе к серверу, что не очень удобно. 

</p><b>Обработка нескольких запросов</b>
<p>
Усовершенствуем скрипт, после обработки запроса будем снова слушать сокет
</p><pre><code class="python">while True:
    logging.info("Ждем входящее соединение");
    conn, addr = sock.accept()
    logging.info("Получаем запрос")
    data = conn.recv(1024)
    req = b''
    conn.settimeout(0.1)
    while data:
        req += data
        try:
            data = conn.recv(1024)
        except socket.error:
            break
    logging.info(req)
	
    logging.info("Отправляем запрос на сервер")
    serv.send(req)
	
    logging.info("Получаем ответ сервера")
    resp = b''
    serv.settimeout(1)
    data = serv.recv(1024)
    while data:
        resp += data
        try:
            data = serv.recv(1024)
        except socket.error:
            break
    logging.info(resp)
	
	logging.info("Отдаем ответ клиенту")
    client.send(resp)
</code></pre><p>
Это будет работать, однако есть проблема — у нас бесконечный цикл из которого программа не может выйти нормальным образом. Для выхода можно использовать клавиатурное прерывание Ctrl+C и отправим запрос, после этого программа завершится по исключению KeyboardInterrupt. 

</p><b>Остановка сервиса</b>
<p>
Чтобы обеспечить более-менее нормальный выход, я решил передавать в сокет STOP, это будет управляющей командой завершения. Напишем обработчик для такой команды. Для этого нам потребуется модифицировать код чтения из клиентского сокета. Получаем первые четыре байта и если они будут STOP, прерываем цикл.
</p><pre><code class="python">    logging.info("Получаем запрос")
    data = conn.recv(4)
    if data == b'STOP':
        break
</code></pre><p>
Напишем функцию для остановки нашего прокси. В ней создадим сокет (ssl) и отправим STOP на наш прокси
</p><pre><code class="python">def stop():
    logging.info("Останов");

    me = ssl.wrap_socket(socket.socket())
    me.connect( ('localhost', 43433) )
    me.send(b'STOP')
    me.close()
</code></pre><p>
Для запуска команды STOP будем использовать параметр командной строки. Если передали строку stop в командной строке, то будем вызывать нашу функцию stop() (Помещаем этот код и функцию стоп в начало, после установки формата логирования).
</p><pre><code class="python">if len(sys.argv) &gt; 1:
    if sys.argv[1] == "stop":
        stop();
</code></pre><p>
Теперь мы можем останавливать наш прокси тем же скриптом. Для того чтобы после остановки не выполнялся код запуска сервера, обернем основной код в функцию run, получится
</p><pre><code class="python">def run():
    # сюда поместим код прокси-сервера описанный выше
	
def stop():
    # код приведен выше

if len(sys.argv) &gt; 1:
    if sys.argv[1] == "stop":
        stop();
	else:
	    print("Неизвестная комманда ", sys.argv[1])
else:
    run()
</code></pre><p>
Заодно обработали случай с неправильной командой. 

</p><b>Демонизация</b>
<p>
Осталась проблема, при запуске нашего прокси приложение будет висеть в командной строке, на первый взгляд кажется, что оно зависло. Для решения этой проблемы сделаем демон. Т.к. у нас Windows, то демон тут делается запуском процесса без окна, этот код будет некроссплатформенным. Итак напишем функцию daemonize()
</p><pre><code class="python">import subprocess

def daemonize():
    logging.info("Запуск демона");
    subprocess.Popen("py proxy.py", creationflags=0x08000000, close_fds=True)
</code></pre> <p>
Здесь creationflags=0x08000000, установка флага CREATE_NO_WINDOW для процесса. Будем запускать наш сервис в режиме демона если передали start в командной строке
</p><pre><code class="python">if len(sys.argv) &gt; 1:
    if sys.argv[1] == "stop":
        stop();
	elif sys.argv[1] == "start":
	    daemonize();
	else:
	    print("Неизвестная комманда ", sys.argv[1])
else:
    run()
</code></pre> <p>
Теперь мы можем запускть наш сервис в режиме демона и останавливать. 

</p><b>Многозадачность</b>
<p>
Еще маленький штрих, добавим возможность обработки нескольких клиентов, для этого вынесем наш код работы с клиентом в отдельную функцию
</p><pre><code class="python">def client_run(client, data):
    req = b''

    logging.info("Получаем запрос")
    client.settimeout(0.1)
    while data:
        req += data
        try:
            data = client.recv(1024)
        except socket.error:
            break

    logging.info(req)

    serv = ssl.wrap_socket(socket.socket())
    serv.connect( ('server_name', 443) )

    logging.info("Отправляем запрос на сервер")
    serv.send(req)

    logging.info("Получаем ответ сервера")
    resp = b''
    serv.settimeout(1)
    data = serv.recv(1024)
    while data:
        resp += data
        try:
            data = serv.recv(1024)
        except socket.error:
            break

    logging.info(resp)

    logging.info("Отдаем ответ клиенту")
    client.send(resp)
</code></pre> <p>
А в главной функции будем запускать client_run в отдельном потоке, т.к. мы устанавливали socket.listen(10), то одновременно у нас может быть до 10 потоков
</p><pre><code class="python">def run():
    logging.info("Старт главного потока");

    sock = ssl.wrap_socket(socket.socket(), 'server.key', 'server.crt', True)
    sock.bind( ('localhost', 43433) )
    sock.listen(10)

    while True:
        logging.info("Ждем входящее соединение");
        conn, addr = sock.accept()

        data = conn.recv(4)
        if data == b'STOP':
            break

        logging.info("Получен запрос")
        t = threading.Thread(target = client_run, args = ( conn, data ) )
        t.run()
    logging.info("Остановка")
</code></pre> <p>
Теперь наш прокси-сервис готов. 
</p><p>
PS: Позже мне коллега подсказал, что для моей задачи можно использовать stunnel, и я решил поставить его, а скрипт выложить сюда, вдруг кому будет интересно. Конфиг для stunnel такой:
</p><pre><code>[client-in]
sslVersion = SSLv3
accept = 127.0.0.1:43433
connect = 127.0.0.1:8080

[server-out]
sslVersion = TLSv1
client = yes
accept = 127.0.0.1:8080
connect = server_name:443
</code></pre><p>
С stunnel также пришлось повозиться, т.к. на сервере были некорректные настройки и не проходила верификация SNI, заработало только с версией 4.36, т.к. там нет такой верификации.
</p><p>
Исходники на github </p><a href="https://github.com/sesk/py_proxy">github.com/sesk/py_proxy</a>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>