<html><body><div><section class="the_post">
    <div class="section" id="motivation">
<h2>Motivation</h2>
<p>During one of our latest projects, we had to do some Data Warehousing for a client with a fairly large dataset. Everything is stored in a MySQL cluster, and given the sensitive nature of the data we were given only partial access to views based on the actual data.</p>
<p>We decided to implement the warehouse using PostgreSQL (we also had to build a Django site based on it, so it was the most natural solution), and initially everything went fine, but as the dataset grew, moving the data from MySQL to PostgreSQL proved challenging and time consuming.</p>
<p>In the past we have had to handle even larger datasets, but none coming from a database, so we had to adapt our solution to the new problem. We want to share some of the components of the solution we found with the community.</p>
</div>
<div class="section" id="rowstextio">
<h2>RowsTextIO</h2>
<p>One of the fastest ways to load data into a <a class="reference external" href="http://www.postgresql.org/">PostgreSQL</a> table is to use the <a class="reference external" href="http://www.postgresql.org/docs/9.4/static/sql-copy.html">COPY</a> SQL command that copies data from a file or from a stream directly into the table. This command is often used when loading large amounts of data from a foreign source (usually CSV files) into the database. This command is also available on <a class="reference external" href="http://initd.org/psycopg/">psycopg</a> (PostgreSQL’s python driver), as the <a class="reference external" href="http://initd.org/psycopg/docs/cursor.html#cursor.copy_from">copy_from</a> method on the cursor class.</p>
<p><a class="reference external" href="https://github.com/abarto/rowstextio">rowstextio</a> is a read-only unicode character and line based interface to stream I/O from the result of a database query. This stream can be given as a parameter to psycopg’s cursor copy_from method to load the data into the target table.</p>
</div>
<div class="section" id="usage">
<h2>Usage</h2>
<p>The following session shows the typical use case for the package.</p>
<div class="highlight-python">
<div class="highlight">
<pre><span class="go">&gt;&gt;&gt;&gt; import psycopg2</span>
<span class="go">&gt;&gt;&gt;&gt; import mysql.connector</span>
<span class="go">&gt;&gt;&gt;&gt; source_connection = mysql.connector.connect(**source_connection_settings)</span>
<span class="go">&gt;&gt;&gt;&gt; target_connection = psycopg2.connect(**target_connection_settings)</span>
<span class="go">&gt;&gt;&gt;&gt; from rowstextio import RowsTextIO</span>
<span class="go">&gt;&gt;&gt;&gt; source_cursor = source_connection.cursor()</span>
<span class="go">&gt;&gt;&gt;&gt; target_cursor = target_connection.cursor()</span>
<span class="go">&gt;&gt;&gt;&gt; f = RowsTextIO(source_cursor, 'SELECT * FROM source_table WHERE id &lt;&gt; %(id)s', {'id': 42})</span>
<span class="go">&gt;&gt;&gt;&gt; target_cursor.copy_expert('COPY target_table FROM STDIN CSV', f)</span>
<span class="go">&gt;&gt;&gt;&gt; target_cursor.close()</span>
<span class="go">&gt;&gt;&gt;&gt; source_cursor.close()</span>
</pre>
</div>
</div>
<p>Assuming that the target table schema is compatible with the rows resulting from the query, the data should be loaded by now.</p>
</div>
<div class="section" id="how-does-it-work">
<h2>How does it work?</h2>
<p>It works by requesting a fixed amount of rows from the source table to populate a buffer, and then reads from that buffer at the client’s request:</p>
<div class="highlight-python">
<div class="highlight">
<pre><span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">read_buffer</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># Read a fixed amount of bytes</span>

        <span class="n">left_to_read</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">while</span> <span class="n">left_to_read</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Keep reading from the buffer</span>

            <span class="n">read_from_buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">left_to_read</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">read_from_buffer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">read_buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">unicode</span><span class="p">(</span><span class="n">read_from_buffer</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">read_from_buffer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">left_to_read</span><span class="p">:</span>
                <span class="c"># We read less than the remaining bytes. Fetch more rows.</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_fetch_rows</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_rows_onto_buffer</span><span class="p">()</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span> <span class="o">==</span> <span class="il">0L</span><span class="p">:</span>
                    <span class="c"># There are no more rows, break the loop</span>
                    <span class="k">break</span>

            <span class="n">left_to_read</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">read_from_buffer</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Read all the rows</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">read_from_buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">read_from_buffer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">read_buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">read_from_buffer</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># We emptied the buffer. Fetch more rows.</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_fetch_rows</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_rows_onto_buffer</span><span class="p">()</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span> <span class="o">==</span> <span class="il">0L</span><span class="p">:</span>
                    <span class="c"># There are no more rows, break the loop</span>
                    <span class="k">break</span>

    <span class="n">read_result</span> <span class="o">=</span> <span class="n">read_buffer</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
    <span class="n">read_buffer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">read_result</span>
</pre>
</div>
</div>
</div>
<div class="section" id="conclusions">
<h2>Conclusions</h2>
<p>This solution gave us the flexibility to load huge amounts of data from complex queries and speed up our ETL process.</p>
<p>As usual, any comments or suggestions are welcomed. We haven’t tried this with other databases, but we think it might be possible to make it work with any interface that takes a text stream as input. We’re interested to know if you managed to use it in a different environment.</p>
</div>
</section>


</div></body></html>