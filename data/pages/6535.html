<html><body><div><div class="post-body entry-content" id="post-body-6810297975173915278" itemprop="description articleBody">
<div dir="ltr" trbidi="on">
<p align="center" class="MsoNormal">
<br/></p>

<div class="MsoNormal">
<span>1. Структура ноды. Порты.
Локальность данных. Механизм «<span lang="EN-US">dirty</span><span lang="EN-US">
</span><span lang="EN-US">propagation</span>» для
оптимального пересчета графа<p/></span></div>

<div class="MsoNormal">
<span>3. Ребра. Правила подключений<p/></span></div>



<div class="MsoNormal">
<span>7. Использованные ресурсы и
литература<p/></span></div>
<p class="MsoNormal">
<span><br/></span></p>
<div align="center" class="MsoNormal">
<b><span>Предисловие. Благодарности<p/></span></b></div>
<div class="MsoNormal">
<span>Всем привет, в этой статье я хочу рассказать
о разработке нодового виджета на PySide, о том с какими проблемами мне пришлось
столкнуться, и как я их решал. Отдельное спасибо хочу сказать Анатолию Юданову
(<b><a href="https://ru.linkedin.com/pub/anatoliy-yudanov/6b/944/41a"><span>LinkedIn</span></a></b>), который помогал мне
бесценными советами, его вклад в осознание мной этой темы был неоценим.</span></div>
<p class="MsoNormal">
<span><br/></span></p>
<div class="MsoNormal">
<span>Что такое граф мы можем узнать из
математической теории графов, это раздел дискретной математики основным
объектом изучения которой и являются графы. Граф - это совокупность вершин
соединенных ребрами. Графы могут быть ориентированными, неориентированными, смешанными
и изоморфными. Что касается терминологии, сразу хочу сказать, что у теории
графов она еще не устоялась, и в разных публикациях под одними и теми же
терминами могут пониматься разные вещи. В нашем случае мы рассматриваем
направленный ациклический граф (<span lang="EN-US">Directed</span><span lang="EN-US"> </span><span lang="EN-US">acyclic</span><span lang="EN-US"> </span><span lang="EN-US">graph</span>). Это такой граф, в котором отсутствуют направленные циклы, то
есть пути, начинающиеся и кончающиеся в одной и той же вершине.<p/></span></div>

<p align="center" class="MsoNormal">
<i><span>Направленный ациклический граф</span></i></p>
<p class="MsoNormal">
<span><br/></span></p>
<div class="MsoNormal">
<span>Графы, или «нодовые редакторы» сейчас очень
популярны и широко используются. Например, графы можно встретить в пакетах 3<span lang="EN-US">d</span> графики или игровых движках, их применяют в
науке, экономике, статистике, логистике, программировании и других дисциплинах.
Понять, как это устроено, для меня было большим соблазном.<p/></span></div>
<p class="MsoNormal">
<span><br/></span></p>

<div align="center" class="MsoNormal">
<b><span>1. Структура. Локальность
данных<p/></span></b></div>
<p class="MsoNormal">
<span>Граф – это объект, который хранит в себе ноды
и связи между ними, определяет порядок пересчета блоков.</span></p>
<p class="MsoNormal">
<span>Нода – это основная единица графа, у нее есть
входные и выходные атрибуты (порты), которые хранят в себе данные разных типов.
Нода берет данные с входных портов, выполняет какое-то действие над ними, и
записывает измененные данные в выходные порты.</span></p>
<div class="MsoNormal">
<span>Порты могут соединяться с другими портами,
образуя связи (Ребра). Ребро – это пара связанных нод.<p/></span></div>
<div class="MsoNormal">
<span>Порты делятся по типам данных. У порта есть
два списка. В первом списке хранятся ссылки на порты, на которые влияет данный
порт, во втором – ссылки портов который влияют на данный порт. Нода не знает
ничего из окружающей среды и никогда не использует данные, которые являются для
нее внешними. Все что она знает это свои входные и выходные порты. Это одно из фундаментальных
правил при проектировании нод. Подобная локальность данных позволяет легко
добавлять новые ноды в граф и строить системы любой сложности.<p/></span></div>
<p class="MsoNormal">
<span>Для оптимального пересчета графа я применил
механизм «<span lang="EN-US">Dirty</span><span lang="EN-US"> </span><span lang="EN-US">propagation</span>», это запатентованная технология <span lang="EN-US">Autodesk</span>. У каждого порта есть бинарное свойство «dirty».
Например, если исходные данные изменились у какой-то одной ноды, то для
получения результата на другом конце, нет необходимости пересчитывать все
дерево нод целиком, достаточно посчитать только те ноды выходные данные которых
потеряли актуальность. В момент изменения данных, вверх по графу расставляются
флаги «<span lang="EN-US">dirty</span>», обозначая маршрут
для пересчета. Здесь я использовал рекурсивную функцию «<span lang="EN-US">push</span>». Конечно же, реализация <span lang="EN-US">Autodesk</span> и моя, могут различаться.</span></p>
<p class="MsoNormal">
<span><br/></span></p>

<div align="center" class="MsoNormal">
<i><span>Порты, обведенные белым пунктиром «грязные»
и их ноды требуют пересчета.<p/></span></i></div>
<div align="center" class="MsoNormal">
<span><i>Во время следующего запроса </i><i><span lang="EN-US">IntNode</span></i><i><span lang="EN-US"> </span></i><i>пересчитываться не будет, а </i><i><span lang="EN-US">SumNode</span></i><i> возьмет данные из </i><i><span lang="EN-US">inputA</span></i><i>.<p/></i></span></div>
<p align="center" class="MsoNormal">
<span><br/></span></p>

<div class="MsoNormal">
<span>Каждая нода вычисляется единожды, по глубине
начиная с конца графа, учитывая «dirty» флаги. Ноды одного уровня не зависят
друг от друга и могут вычисляться параллельно или последовательно на выбор. Ноды
следующего уровня не начинают вычисляться до тех пор, пока не закончится
просчет всех нод с предыдущего уровня, и так до того места от куда поступил
запрос. Для этого я использовал метод графа «<span lang="EN-US">get</span>_<span lang="EN-US">evaluation</span>_<span lang="EN-US">odrer</span>(<span lang="EN-US">node</span>)» которая возвращает дневник вида<p/></span></div>
<p class="MsoNormal">
<span><br/></span></p>





<div class="MsoNormal">
<span>, где ключи - это номера слоев, а значения –
списки нод которые нужно считать. В режиме «<span lang="EN-US">multithreaded</span>» каждая нода слоя считается параллельно с
остальными нодами.<p/></span></div>
<p class="MsoNormal">
<span><br/></span></p>


<p align="center" class="MsoNormal">
<i><span><br/></span></i></p>
<div class="MsoNormal">
<span>Ноды
с первого слоя (<span lang="EN-US">IntNode</span>,
<span lang="EN-US">IntNode</span>1) считаются и
записывают данные во входные порты нод второго слоя (<span lang="EN-US">PowNode</span>), с которыми соединены, затем ноды второго
слоя считаются и записывают значения во входные порты ноды следующего слоя и
так далее.<p/></span></div>
<p class="MsoNormal">
<span><br/></span></p>
<div align="center" class="MsoNormal">
<b><span>3. Ребра. Правила подключений<p/></span></b></div>
<div class="MsoNormal">
<span>Ребро - это объект, соединяющий два порта, определяющий
направление передачи данных (<span lang="EN-US">source</span>
-&gt; <span lang="EN-US">destination</span>). В
абстракции такого класса нет, потому что, по сути, ребро – это два порта, списки
влияния которых содержат ссылки друг на друга, за счет этого можно определить и
направление передачи данных.<p/></span></div>
<div class="MsoNormal">
<span>-
Подключены, могут быть только входной и выходной порты с совместимыми типами
данных.<p/></span></div>
<div class="MsoNormal">
<span>-
Входной порт может принимать только одну связь.<p/></span></div>
<div class="MsoNormal">
<span>-
Выходной порт может связываться со многими.<p/></span></div>
<div class="MsoNormal">
<span>-
Входной порт не может принимать значение с выходного порта собственной ноды.<p/></span></div>
<div class="MsoNormal">
<span>Метод
графа «<span lang="EN-US">add</span>_<span lang="EN-US">edge</span>(<span lang="EN-US">source</span>, <span lang="EN-US">destination</span>)»
проверяет все эти условия и создает связь, возвращая <span lang="EN-US">True</span>, либо если условия не выполнены, ничего не
делает и возвращает <span lang="EN-US">False</span>.<p/></span></div>
<p class="MsoNormal">
<span><br/></span></p>

<div class="MsoNormal">
<span>1)
Выходной порт ноды "А" соединился с входным портом ноды
"Б".<p/></span></div>
<div class="MsoNormal">
<span>    В этот момент заполняются списки влияния портов.<p/></span></div>
<div class="MsoNormal">
<span>    Создается связь, и граф запоминает ссылку
на нее.<p/></span></div>
<div class="MsoNormal">
<span>    Данные из выходного порта ноды
"А" записываются во входной порт ноды "Б".<p/></span></div>
<div class="MsoNormal">
<span>    Расставляются dirty флаги.<p/></span></div>
<div class="MsoNormal">
<span>    Выполняется пустой метод, который можно
перезаписать.<p/></span></div>
<div class="MsoNormal">
<span>2)
Связь между портами разорвалась.<p/></span></div>
<div class="MsoNormal">
<span>    Редактируются списки влияния.<p/></span></div>
<div class="MsoNormal">
<span>    Граф удаляет ссылку связь.<p/></span></div>
<div class="MsoNormal">
<span>    Выполняется пустой метод, который можно
перезаписать.<p/></span></div>
<div class="MsoNormal">
<span>3)
Вызывается метод порта «<span lang="EN-US">set</span>_<span lang="EN-US">data</span>(<span lang="EN-US">data</span>)».<p/></span></div>
<div class="MsoNormal">
<span>    В этот момент по спискам влияния,
выставляются флаги «dirty» вверх до конца графа, начиная с порта в котором
изменились данные.<p/></span></div>
<div class="MsoNormal">
<span>4)
Порт запрашивает данные.<p/></span></div>
<div class="MsoNormal">
<span>    Проверяется dirty флаг, если <span lang="EN-US">T</span>rue, то у графа запрашивается порядок
пересчета нод, и они пересчитываются. Если <span lang="EN-US">F</span>alse, берутся данные с последнего просчета.<p/></span></div>
<p class="MsoNormal">
<span><br/></span></p>

<p class="MsoNormal">
<span>Для визуализации я выбрал <span lang="EN-US">Qt</span>, так как этот Фреймворк пересекается с моей
работой, да и лучшей альтернативы я просто не знаю.</span></p>
<p class="MsoNormal">
<span>Итак, на данный момент мы имеем работающий в
консольке граф зависимости. Все что нам осталось делать - наследоваться от
каждого из объектов графа, и рисовать, при необходимости дополняя методы.
Графом будет класс, унаследованный от <span lang="EN-US">QGraphicsView</span><span lang="EN-US"> </span>и
нашей абстракции графа, нода – <span lang="EN-US">QgraphicsItem</span> и абстрактная нода, ребро – <span lang="EN-US">QPainterPath</span> или <span lang="EN-US">QGraphicsLineItem</span>.</span></p>
<div class="MsoNormal">
<span>В визуализации есть классы, которых нет в абстракции,
например группировщик – объект, в который можно добавлять ноды, и подписывать
комментарий. Этот объект наследуется от <span lang="EN-US">QGraphicsRectItem</span>. Комментарий наследуется от <span lang="EN-US">QGraphicsTextItem</span>, он многострочный. В момент переключения с
него фокуса, геометрия автоматически выравнивается по левому правому углу ноды.
Чтобы создать группировщик, нужно растянуть рамку с <span lang="EN-US">ctrl</span><span lang="EN-US"> </span>+ <span lang="EN-US">shift</span>.
Добавить ноду в группировщик, можно перетащив её в пределы его геометрии, или в
момент растягивания обеспечить пересечение геометрий ноды и будущего
группировщика. Группировщик можно «распаковать» (извлечь из него все ноды),
изменять его размеры при помощи специального элемента в правом нижнем углу,
удалять. При удалении группировщика, его содержимое удаляется из графа. У
группировщика есть функция автоматического изменения размеров под содержимое «<span lang="EN-US">fit</span>_<span lang="EN-US">contents</span>()» которая работает на основе квадрата, который образуют ноды.<p/></span></div>
<p class="MsoNormal">
<span><br/></span></p>

<div class="MsoNormal">
<p>
<span><i>Изменение размеров группировщика</i></span></p>
<p>
<span><br/></span></p>
</div>
<div class="MsoNormal">
<span>Виджет работает с файлом конфигурации <span lang="EN-US">QSettings</span>. В контекстном меню есть пункт «<span lang="EN-US">Options</span>», в котором можно настроить практически
любую визуальную составляющую под себя. Изменения вступают в силу при
перезагрузке приложения. Так же в конце сессии запоминаются положения окон,
слайдеров и другие параметры.<sub><p/></sub></span></div>
<p class="MsoNormal">
<span><br/></span></p>

<p class="separator">
<i>Окно настроек</i></p>
<p class="separator">
<i><br/></i></p>
<div class="MsoNormal">
<span>Некоторые
варианты цветовых схем<p/></span></div>
<p class="MsoNormal">
<span><br/></span></p>



<p class="MsoNormal">
<span><br/></span></p>
<div class="MsoNormal">
<span>Сцену можно масштабировать и панорамировать.
Работают горячие клавиши для операций сохранения, загрузки файлов. Формат файла
представляет собой дневник, описывающий все данные графа.<p/></span></div>
<div class="MsoNormal">
<span>У виджета есть «<span lang="EN-US">Node</span><span lang="EN-US"> </span><span lang="EN-US">box</span>». Это инструмент при помощи которого,
динамически, создаются экземпляры нод. Вызывается он по нажатию кнопки «<span lang="EN-US">Tab</span>». В верхней его части есть поле для поиска
по имени. Граф, при добавлении ноды, выдает ей уникальное имя, проверяя имена
существующих нод. Ноды можно выделять рамкой или с зажатым <span lang="EN-US">ctrl</span>.<p/></span></div>
<p class="MsoNormal">
<span><br/></span></p>

<p align="center" class="MsoNormal">
<span><i>Виджет динамического создания нод</i></span><br/>
<span><i><br/></i></span></p>
<div class="MsoNormal">
<span>Давайте посчитаем
дискриминант многочлена 8<span lang="EN-US">x</span><sup>2</sup> + 4<span lang="EN-US">x</span>
+ 2 = 0.<p/></span></div>
<p class="MsoNormal">
<span><br/></span></p>


<p align="center" class="MsoNormal">
<i><span><br/></span></i></p>
<div class="MsoNormal">
<span>Конечно же, мы можем
«завернуть» дискриминант в одну ноду.<p/></span></div>
<p class="MsoNormal">
<span><br/></span></p>



<p align="center" class="MsoNormal">
<i><span><br/></span></i></p>
<div align="center" class="MsoNormal">
<b><span>6. Применение. Перспективы<p/></span></b></div>
<div class="MsoNormal">
<span>Применять данный виджет можно в 3<span lang="EN-US">d</span><span lang="EN-US"> </span>пакетах, где есть <span lang="EN-US">Python</span>. Например, <span lang="EN-US">Maya</span><span lang="EN-US">
</span>или <span lang="EN-US">Motionbuilder</span>, в последнем, например, вообще нет нодового
редактора. Добавляя собственные ноды, можно «заточить» виджет под любые нужды,
например это может быть маппер персонажей и акторов в <span lang="EN-US">Motionbuilder</span> или визуальная система сборки <span lang="EN-US">particle</span><span lang="EN-US"> </span>эффектов. Отдельным приложением его можно использовать как
продвинутый калькулятор, или <span lang="EN-US">UML</span>. Можно
написать <span lang="EN-US">viewport</span> для отображения
графиков или объектов. Привязать генерацию кода на события
соединения/разъединения портов. Из подобных разработок с открытым исходным
кодом есть интересный проект «<span lang="EN-US">Coral</span>»
(<a href="https://code.google.com/p/coral-repo/">https://code.google.com/p/coral-repo/</a>), который уже давно не поддерживается и
библиотека «<span lang="EN-US">PyQtGraph</span>»
Flowchart widget (<a href="http://www.pyqtgraph.org/">http://www.pyqtgraph.org/</a>).<p/></span></div>
<p class="MsoNormal">
<span><br/></span></p>
<div align="center" class="MsoNormal">
<b><span>7. Использованные ресурсы и
литература<p/></span></b></div>
<div class="MsoNormal">
<span>1. <a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0">Wikipedia</a><span><p/></span></span>
<span>2. Дэвид А.Д. Гоулд - Maya Полное руководство по программированию. Подробное описание языка MEL и интерфейса C++ API</span></div>
</div>
<p/>
</div>
</div></body></html>