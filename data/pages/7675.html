<html><body><div><div class="post-text" itemprop="text">
<p>First of all, I believe the problem you're encountering is because you're normalizing your probabilities incorrectly. This line is incorrect:</p>

<pre><code>a = np.exp(l) / scipy.misc.logsumexp(l)
</code></pre>

<p>You're dividing a probability by a log probability, which makes no sense. Instead you probably want </p>

<pre><code>a = np.exp(l - scipy.misc.logsumexp(l))
</code></pre>

<p>If you do that, you find <code>a = [1, 0]</code> and your multinomial sampler works as expected up to floating point precision in the second probability.</p>

<hr/>

<h3>A Solution for Small N: Histograms</h3>

<p>That said, if you still need more precision and performance is not as much of a concern, one way you could make progress is by implementing a multinomial sampler from scratch, and then modifying this to work at higher precision.</p>

<p>NumPy's multinomial function is <a href="https://github.com/numpy/numpy/blob/master/numpy/random/mtrand/mtrand.pyx#L4406" rel="nofollow">implemented in Cython</a>, and essentially performs a loop over a number of binomial samples and combines them into a multinomial sample.
and you can call it like this:</p>

<pre><code>np.random.multinomial(10, [0.1, 0.2, 0.7])
# [0, 1, 9]
</code></pre>

<p>(Note that the precise output values here &amp; below are random, and will change from call to call).</p>

<p>Another way you might implement a multinomial sampler is to generate <em>N</em> uniform random values, then compute the histogram with bins defined by the cumulative probabilities:</p>

<pre><code>def multinomial(N, p):
    rand = np.random.uniform(size=N)
    p_cuml = np.cumsum(np.hstack([[0], p]))
    p_cuml /= p_cuml[-1]
    return np.histogram(rand, bins=p_cuml)[0]

multinomial(10, [0.1, 0.2, 0.7])
# [1, 1, 8]
</code></pre>

<p>With this method in mind, we can think about doing things to higher precision by keeping <em>everything</em> in log-space. The main trick is to realize that the log of uniform random deviates is equivalent to the negative of exponential random deviates, and so you can do everything above without ever leaving log space:</p>

<pre><code>def multinomial_log(N, logp):
    log_rand = -np.random.exponential(size=N)
    logp_cuml = np.logaddexp.accumulate(np.hstack([[-np.inf], logp]))
    logp_cuml -= logp_cuml[-1]
    return np.histogram(log_rand, bins=logp_cuml)[0]

multinomial_log(10, np.log([0.1, 0.2, 0.7]))
# [1, 2, 7]
</code></pre>

<p>The resulting multinomial draws will maintain precision even for very small values in the <em>p</em> array.
Unfortunately, these histogram-based solutions will be <em>much</em> slower than the native <code>numpy.multinomial</code> function, so if performance is an issue you may need another approach. One option would be to adapt the Cython code linked above to work in log-space, using similar mathematical tricks as I used here.</p>

<hr/>

<h3>A Solution for Large N: Poisson Approximation</h3>

<p>The problem with the above solution is that as <em>N</em> grows large, it becomes <em>very</em> slow.
I was thinking about this and realized there's a more efficient way forward, despite <code>np.random.multinomial</code> failing for probabilities smaller than <code>1E-16</code> or so.</p>

<p>Here's an example of that failure: on a 64-bit machine, this will always give zero for the first entry because of the way the code is implemented, when in reality it should give something near 10:</p>

<pre><code>np.random.multinomial(1E18, [1E-17, 1])
# array([                  0, 1000000000000000000])
</code></pre>

<p>If you dig into the source, you can trace this issue to the binomial function upon which the multinomial function is built. The cython code internally does something like this:</p>

<pre><code>def multinomial_basic(N, p, size=None):
    results = np.array([np.random.binomial(N, pi, size) for pi in p])
    results[-1] = int(N) - results[:-1].sum(0)
    return np.rollaxis(results, 0, results.ndim)

multinomial_basic(1E18, [1E-17, 1])
# array([                  0, 1000000000000000000])
</code></pre>

<p>The problem is that the <code>binomial</code> function chokes on very small values of <code>p</code> â€“ this is because the algorithm <a href="https://github.com/numpy/numpy/blob/master/numpy/random/mtrand/distributions.c#L277" rel="nofollow">computes the value <code>(1 - p)</code></a>, so the value of <code>p</code> is limited by floating-point precision.</p>

<p>So what can we do? Well, it turns out that for small values of p, the Poisson distribution is an extremely good approximation of the binomial distribution, and the implementation doesn't have these issues. So we can build a robust multinomial function based on a robust binomial sampler that switches to a Poisson sampler at small p:</p>

<pre><code>def binomial_robust(N, p, size=None):
    if p &lt; 1E-7:
        return np.random.poisson(N * p, size)
    else:
        return np.random.binomial(N, p, size)

def multinomial_robust(N, p, size=None):
    results = np.array([binomial_robust(N, pi, size) for pi in p])
    results[-1] = int(N) - results[:-1].sum(0)
    return np.rollaxis(results, 0, results.ndim)

multinomial_robust(1E18, [1E-17, 1])
array([                 12, 999999999999999988])
</code></pre>

<p>The first entry is nonzero and near 10 as expected! Note that we can't use <code>N</code> larger than <code>1E18</code>, because it will overflow the long integer.
But we can confirm that our approach works for  smaller probabilities using the <code>size</code> parameter, and averaging over results:</p>

<pre><code>p = [1E-23, 1E-22, 1E-21, 1E-20, 1]
size = int(1E6)
multinomial_robust(1E18, p, size).mean(0)
# array([  1.70000000e-05,   9.00000000e-05,   9.76000000e-04,
#          1.00620000e-02,   1.00000000e+18])
</code></pre>

<p>We see that even for these very small probabilities, the multinomial values are turning up in the right proportion. The result is a very robust and very fast approximation to the multinomial distribution for small <code>p</code>.</p>
    </div>
    </div></body></html>