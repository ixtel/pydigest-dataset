<html><body><div><article class="entry">
<h1>Recommended Django Project Layout</h1>
    <p class="byline">by Frank Wiles on Nov 21, 2014</p>
    <h2>What’s the optimal layout for your Django applications, settings files, and various other associated directories?</h2>

<p>When Django 1.4 was released it included an <a href="https://docs.djangoproject.com/en/dev/releases/1.4/#updated-default-project-layout-and-manage-py">updated project layout</a> which went a long way to improving the default Django project’s layout, but here are some tips for making it even better.</p>

<p>This is a question we get asked all of the time so I wanted to take a bit of time and write down exactly how we feel about this subject so we can easily refer clients to this document. Note that this was written using Django version 1.7.1, but can be applied to any Django version after 1.4 easily. </p>

<h2>Why this layout is better</h2>

<p>The project layout we’re recommending here has several advantages namely:</p>

<ul>
<li>Allows you to pick up, repackage, and reuse individual Django applications for use in other projects. Often it isn’t clear as you are building an app whether or not it is even a candidate for reuse. Building it this way from the start makes it much easier if that time comes.</li>
<li>Encourages designing applications for reuse</li>
<li>Environment specific settings. No more <code>if DEBUG==True</code> nonsense in a single monolithic settings file. This allows to easily see which settings are shared and what is overridden on a per environment basis.</li>
<li>Environment specific PIP requirements</li>
<li>Project level templates and static files that can, if necessary, override app level defaults.</li>
<li>Small more specific test files which are easier to read and understand.</li>
</ul>

<p>Assuming you have two apps <em>blog</em> and <em>users</em> and 2 environments dev and prod your project layout should be structured like this:</p>

<pre><code class="language-bash">myproject/
    manage.py
    myproject/
        __init__.py
        urls.py
        wsgi.py
        settings/
            __init__.py
            base.py
            dev.py
            prod.py
    blog/
        __init__.py
        models.py
        managers.py
        views.py
        urls.py
        templates/
            blog/
                base.html
                list.html
                detail.html
        static/
           …
        tests/
            __init__.py
            test_models.py
            test_managers.py
            test_views.py
    users/
        __init__.py
        models.py
        views.py
        urls.py
        templates/
            users/
                base.html
                list.html
                detail.html
        static/
            …
        tests/
            __init__.py
            test_models.py
            test_views.py
     static/
         css/
             …
         js/
             …
     templates/
         base.html
         index.html
     requirements/
         base.txt
         dev.txt
         test.txt
         prod.txt
</code></pre>

<p>The rest of this article explains how to move a project to this layout and why this layout is better. </p>

<h2>Current Default Layout</h2>

<p>We’re going to call our example project <strong>foo</strong>, yes I realize it’s a very creative name. We’re assuming here that we’re going to be launching <strong>foo.com</strong> but while we like to have our project names reflect the ultimate domain(s) the project will live on this isn’t by any means required. </p>

<p>If you kick off your project using <code>django-admin.py startproject foo</code> you get a directory structure like this:</p>

<pre><code class="language-bash">    foo/
        manage.py
        foo/
           __init__.py
           settings.py
           urls.py
           wsgi.py
</code></pre>

<p>This layout is a great starting place, we have a top level directory <em>foo</em> which contains our manage.py the <em>project</em> directory <em>foo/foo/</em> inside it. This is the directory you would check into your source control system such as git. </p>

<p>You should think of this <em>foo/foo/</em> subdirectory as being <strong>the project</strong> where everything else is either a Django application or ancillary files related to the project. </p>

<h2>Fixing Settings</h2>

<p>We’re on a mission to fix your bad settings files here. We show this layout to new clients and I’m constantly surprised how few people know this is even possible to do. I blame the fact that while everyone knows that settings are just Python code, they don’t think about them <em>as</em> Python code. </p>

<p>So let’s fix up our settings. For our foo project we’re going to have 4 environments: dev, stage, jenkins, and production. So let’s give each it’s own file. The process to do this is:</p>

<ol>
<li>In <em>foo/foo/</em> make a settings directory and create an empty <code>__init__.py</code> file inside it.</li>
<li>Move <em>foo/foo/settings.py</em> into <em>foo/foo/settings/base.py</em></li>
<li><p>Create the individual <em>dev.py</em>, <em>stage.py</em>, <em>jenkins.py</em>, and <em>prod.py</em> files in <em>foo/foo/settings/</em>. Each of these 4 environment specific files should simply contain the following:</p>

<pre><code class="language-python">from base import *
</code></pre></li>
</ol>

<p>So why is this important? Well for local development you want <code>DEBUG=True</code>, but it’s pretty easy to accidentally push out production code with it on, so just open up <em>foo/foo/settings/prod.py</em> and after the initial import from base just add <code>DEBUG=False</code>. Now if your production site is safe from that silly mistake. </p>

<p>What else can you customize? Well it should be pretty obvious you’ll likely have staging, jenkins, and production all pointing at different databases, likely even on different hosts. So adjust those settings in each environment file.</p>

<h2>Using these settings</h2>

<p>Using these settings is easy, no matter which method you typically use. To use the OS’s environment you just do:</p>

<pre><code class="language-bash">export DJANGO_SETTINGS_MODULE=“foo.settings.jenkins”
</code></pre>

<p>And boom, you’re now using the jenkins configuration. </p>

<p>Or maybe you prefer to pass them in as a commandline option like this:</p>

<pre><code class="language-bash">./manage.py migrate —settings=foo.settings.production
</code></pre>

<p>Same if you’re using gunicorn:</p>

<pre><code class="language-bash">gunicorn -w 4 -b 127.0.0.1:8001 —settings=foo.settings.dev
</code></pre>

<h2>What else should be customized about settings?</h2>

<p>Another useful tip with Django settings is to change several of the default settings <em>collections</em> from being tuples to being lists. For example <code>INSTALLED_APPS</code>, by changing it from:</p>

<pre><code class="language-python">INSTALLED_APPS = (
   …
)
</code></pre>

<p>to:</p>

<pre><code class="language-python">INSTALLED_APPS = [
    …
]
</code></pre>

<p>In <em>foo/settings/base.py</em> we can now more easily add and remove apps based on each environment specific settings file. For example, maybe you only want django-debug-toolbar installed in dev, but not your other environments. </p>

<p>This trick is also often useful for the <code>TEMPLATE_DIRS</code> and <code>MIDDLEWARE_CLASSES</code> settings. </p>

<p>Another useful trick we often use is to break up your apps into two lists, one your prerequisites and another for your actual project applications. So like this:</p>

<pre><code class="language-python">PREREQ_APPS = [
   ‘django.contrib.auth’,
   ‘django.contrib.contenttypes’,
   …
   ‘debug_toolbar’,
   ‘imagekit’,
   ‘haystack’,
]

PROJECT_APPS = [
   ‘homepage’,
   ‘users’,
   ‘blog’,
]

INSTALLED_APPS = PREREQ_APPS + PROJECT_APPS
</code></pre>

<p>Why is this useful? For one it helps better distinguish between Django core apps, third party apps, and your own internal project specific applications. However, <code>PROJECT_APPS</code> often comes in handy as a list of your specific apps for things like testing and code coverage. You have a list of <em>your</em> apps, so you can easily and automagically make sure their tests are run and coverage is recorded just for them, not including any third party apps, without having to maintain the list in two separate places.</p>

<h2>Fixing requirements</h2>

<p>Most projects have a single <code>requirements.txt</code> file that is installed like this:</p>

<pre><code class="language-bash">pip install -r requirements.txt
</code></pre>

<p>This is sufficient for small simple projects, but a little known feature of requirements files is that you can use the <code>-r</code> flag to include other files. So we can have a base.txt of all the common requirements and then if we need to be able to run tests have a specific <em>requirements/test.txt</em> that looks like this:</p>

<pre><code class="language-bash">-r base.txt
pytest==2.5.2
coverage==3.7.1
</code></pre>

<p>I’ll admit this is not a <em>HUGE</em> benefit, but it does help separate out what is a requirement in which environment. And for the truly performance conscience it reduces your pip install time in production a touch by not installing a bunch of things that won’t actually be used in production. </p>

<h2>Test Files</h2>

<p>Why did we separate out the tests files so much? One main reason, if you’re writing enough tests a single tests.py file per application will end up being one huge honking file. This is bad for readability, but also just for the simple fact you have to spend time scrolling around a lot in your editor.</p>

<p>You’ll also end up with less merge conflicts when working with other developers which is a nice side benefit. Small files are your friends. </p>

<h2>URLs</h2>

<p>For small projects it’s tempting to put all of your url definitions in <em>foo/urls.py</em> to keep them all in one place. However, if your goal is clarity and reusability you want to define your urls in each app and include them into your main project. So instead of:</p>

<pre><code class="language-python">urlpatterns = patterns(‘’,
    url(r’^$’, HomePageView.as_view(), name=‘home’),
    url(r’^blog/$’, BlogList.as_view(), name=‘blog_list’),
    url(r’^blog/(?P&lt;pk&gt;\d+)/$’, BlogDetail.as_view(), name=‘blog_detail’),
    …
    url(r’^user/list/$’, UserList.as_view(), name=‘user_list’),
    url(r’^user/(?P&lt;username&gt;\w+)/$’, UserDetail.as_view(), name=‘user_detail’),
)
</code></pre>

<p>you should do this:</p>

<pre><code class="language-python">urlpatterns = patterns(‘’,
    url(r’^$’, HomePageView.as_view(), name=‘home’),
    url(r’^blog/‘, include(‘blog.urls’)),
    url(r’^user/‘, include(‘user.urls’)),
)
</code></pre>

<h2>Templates and static media</h2>

<p>Having per app <em>templates/</em> and <em>static/</em> directories gives us the ability to reuse an application basically <strong>as is</strong> in another project. </p>

<p>We get the default templates the app provides and any associated static media like special Javascript for that one cool feature all in one package. </p>

<p>However, it <em>also</em> gives us the ability to override those templates on a per project basis in the main <em>foo/templates/</em> directory. By adding a <code>templates/blog/detail.html</code> template we override, or mask, the default<code>blog/templates/blog/detail.html</code> template. </p>

<h2>Reusing a Django application</h2>

<p>So assuming you’ve been using this layout for awhile, one day you’ll realize that your new project needs a blog and the one from your <em>foo</em> project would be perfect for it. So you copy and paste the files in… <em>pssst WRONG!</em>. Now you have two copies of the application out there. Bug fixes or new features in one have to manually be moved between the projects, and that assumes you even remember to do that. </p>

<p>Instead, make a new repo for your blog and put the <em>foo/blog/</em> directory in it. And adjust both your existing foo project and your new project to pip install it. </p>

<p>They can still both track different versions of the app, if necessary, or keep up to date and get all of your bug fixes and new features as they develop. You still can override the templates and static media as you need to on a per project basis, so there really isn’t any real issues doing this. </p>

<h2>Additional Resources</h2>

<p>Our friends Danny and Audrey over at <a href="http://www.cartwheelweb.com">CartWheel Web</a> reminded us about <a href="https://github.com/audreyr/cookiecutter">Cookie Cutter</a> and specifically Danny's <a href="https://github.com/pydanny/cookiecutter-django">cookiecutter-django</a> as useful tools for making your initial project creations easier and repeatable. </p> 

<p>Also, if you're looking for all around great Django tips and best practices, you can't go wrong with their book <a href="http://www.amazon.com/gp/product/098146730X/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=098146730X&amp;linkCode=as2&amp;tag=revosystblog-20">Two Scoops of Django: Best Practices For Django 1.6</a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=revosystblog-20&amp;l=as2&amp;o=1&amp;a=098146730X" border="0" alt=""/> which we recommend to all of our clients.
</p> 

<h2>Feedback</h2>

<p>We hope you find this improved project layout useful. If you find any bugs, have a suggestion, or just want to chat feel free to reach out to us. Thanks for reading! </p>


    
    
    
        <p><strong>Tags:</strong> <small>
            
            <a href="/blog/tags/django/">django</a>,
            
            <a href="/blog/tags/Featured%20Posts/">Featured Posts</a>,
            
            <a href="/blog/tags/programming/">programming</a>
            
        </small></p>
    
</article>





    
    


            </div></body></html>