<html><body><div><div class="entry-content">
		<p>I have been programming in Python for many years. One of the things that I wondered, soon after starting to work in Python, was how you can get Perl-style variable interpolation. After all, Perl (like the Unix shell) supports two types of quotes — single quotes (in which everything is taken literally) and double quotes (in which variables’ values are inserted). Thus, in Perl, you can do something like:</p>
<pre>$name = 'Reuven';
print "Hello, $name\n";</pre>
<p>And sure enough, it’ll print “Hello, Reuven”.</p>
<p>Because single and double quotes are equivalent in Python (so long as they come as a matched set), there is no variable interpolation. The technique that I learned years ago, when I started with Python, was that you could use the % operator on a string. In this context, % looks to the string on its left, determines how many values within the string need to be replaced, and then looks right to find those values. It then returns a new string, effectively interpolating the values. For example:</p>
<pre>&gt;&gt;&gt; name = 'Reuven'
&gt;&gt;&gt; "Hello, %s" % name

'Hello, Reuven'</pre>
<p>The above Python code works just fine, returning a string with a nice, personalized greeting. And indeed, for the length of my time working with Python, I have enjoyed using this % syntax. Yes, it’s a bit weird. And no, I cannot ever remember more than the absolute basics of printf’s various % codes, meaning that I either make everything a string (with %s), or I guess, or I look up the printf codes and what they do. But to be honest, I normally just use %s, and thus benefit additionally from the fact that Python will silently invoke “str” on the parameter.</p>
<p>The thing is, % is supposedly going away, or is at least deprecated. (A <a title="% not going away" href="https://mail.python.org/pipermail/python-dev/2012-February/116800.html" target="_blank">note on the python-dev list</a> indicates that % will go away no sooner than 2022, which is a heckuva long time from now.) As of Python 2.6, not to mention Python 3.x, we have been told that it will eventually disappear, and that we shouldn’t use % any more. Instead, we should use the str.format method.</p>
<p>I have always mentioned str.format to my <a title="Reuven Lerner's courses" href="http://lerner.co.il/courses" target="_blank">Python classes</a>, but to be honest, I’ve usually relied upon % when giving live demonstrations and answering questions. And I would even encourage my students to use the % syntax, in part because I found it to be so much easier.</p>
<p>And yet.  I knew that I was doing something wrong, and I knew that I was probably misleading my students to some degree. Thus, in the last three classes I taught, I started to push harder in the direction of str.format. And that’s when I realized two things: (1) It’s just as easy as %, and actually easier in some ways, and (2) I hadn’t learned enough about str.format to use it, beyond the simplest ways. I thus spent a great deal of time researching it — and found out that str.format, while it takes some getting used to, is more than worth the effort.</p>
<p>Let’s start with the simplest case. I’d like to be able to say “Good morning” to someone, using both their first and last names. Assuming that I have variables named “first” and “last”, I can do this with the old syntax as follows:</p>
<pre>&gt;&gt;&gt; first = 'Reuven'
&gt;&gt;&gt; last = 'Lerner'
&gt;&gt;&gt; "Good morning, %s %s" % (first, last)

'Good morning, Reuven Lerner'</pre>
<p>In this example, we already see one of the problems with the % syntax — namely, that if we have more than one value, we need to put it into a tuple. Perhaps this is logical and reasonable from Python’s perspective, but I can assure you that it surprises many of my students.</p>
<p>So, how would we do it using str.format? Pretty similarly, in many ways:</p>
<pre>&gt;&gt;&gt; "Good morning, {} {}".format(first, last)

'Good morning, Reuven Lerner'</pre>
<p>Notice that we’ve changed things a bit here. No longer are we invoking a binary operator (%) on the string. Rather, we’re invoking a string method that takes a set of parameters. This is more logical and consistent. I can’t tell you how many of my students think that % is somehow connected to “print”, when in fact it’s connected (in the case of string formatting) to strings. Having to use put the “.format” at the end of the string makes the method call more obvious.</p>
<p>As you might already know, the “{} {}” in the string tells str.format to take its two parameters, and to insert them, in order, into the string. Because there are two arguments, we can only have two {} inside of the string. This is a bit harder to understand, both because having {} in Python reminds many people of a dictionary, and because the empty curly braces look a bit weird. But fine, I can live with that, and got used to it very quickly.</p>
<p>Where str.format quickly shows its advantages over %, however, is if I want to display the input parameters in reverse order. When I use %, there is no real way to do that. Plus, if I want to reuse a value passed to %, I cannot do so. With str.format, I can swap the order in which the inputs are displayed:</p>
<pre>&gt;&gt;&gt; "Good morning, {1} {0}".format(first, last)

'Good morning, Lerner Reuven'</pre>
<p>Notice what happened in the above: If I just use “{} {}”, then str.format uses the two parameters in order. However, I’m also able to treat the parameters as a sequence, with indexes starting at 0. I can then insert them in reverse order, as I did above, or in the regular order:</p>
<pre>&gt;&gt;&gt; "Good morning, {0} {1}".format(first, last)

'Good morning, Reuven Lerner'</pre>
<p>Note that if you explicitly state the field numbers, then you cannot rely on the automatic numbering.</p>
<p>Of course, this lets me also pass a sequence of values to be inserted, so long as we then use the splat (*) operator on it, to turn it into a parameter list:</p>
<pre>&gt;&gt;&gt; names = ('Reuven', 'Lerner')
&gt;&gt;&gt; "Good morning, {} {}".format(*names)

'Good morning, Reuven Lerner'</pre>
<p>You can also call str.format with keyword arguments. When you do this, you can then put a keyword name within the {}:</p>
<pre>&gt;&gt;&gt; "Good morning, {first} {last}".format(first='Reuven', last='Lerner')

'Good morning, Reuven Lerner'</pre>
<p>The above really appeals to me. The named parameters are explicit (if a bit long), and the use of {first} and {last} is quite readable — certainly more so than %(first)s ever was with the % operator!</p>
<p>I can, of course, also pass a dictionary of names, using the ** operator to turn it into a set of keyword arguments:</p>
<pre>&gt;&gt;&gt; person = {'first':'Reuven', 'last':'Lerner'}
&gt;&gt;&gt; "Good morning, {first} {last}".format(**person)

'Good morning, Reuven Lerner'</pre>
<p>I described all of these to my students in the last month, and I was pleasantly surprised to see how comfortable they were with the syntax. I’m sure that this reflects, to some degree, my comfort with the syntax, as well.</p>
<p>I should note that you can combine numeric and keyword arguments when working with str.format. I really suggest that you not do so. The results would look like this:</p>
<pre>&gt;&gt;&gt; person = {'first':'Reuven', 'last':'Lerner'}
&gt;&gt;&gt; "Good {0}, {first} {last}".format('morning', **person)

'Good morning, Reuven Lerner'</pre>
<p>Yukko.</p>
<p>Now, the one thing that would appear to be missing from str.format is… well, formatting! The bad news is that str.format has a completely and different way of indicating how you want to format output. The good news is that it’s not too hard to learn and understand.</p>
<p>Let’s start with the easiest part: If you want to display a string within a fixed-width field, then you can do so by adding a colon (:) and then a number.  So to put my name in a fixed-width field of 10 spaces, we would say:</p>
<pre>&gt;&gt;&gt; "Your name is {name:10}".format(name="Reuven")

'Your name is Reuven    '</pre>
<p>(Notice the trailing spaces after my name.)</p>
<p>In the above example, my name is left-justified. If I want it to be right-justified, I could use a &gt; sign between the : and the number:</p>
<pre>&gt;&gt;&gt; "Your name is {name:&gt;10}".format(name="Reuven")

'Your name is     Reuven'</pre>
<p>And yes, I could have used an optional &lt; symbol to say that my name should be left-justified within the field of 10 spaces in the first example.  Or I could center the text in a field of 10 spaces with the ^ specifier instead of &lt; or &gt;.</p>
<p>To pad the string with something other than a space, we specify it before the &lt;, &gt;, or ^ character. For example, if I’m moving to Hollywood, then perhaps I should do something like this:</p>
<pre>&gt;&gt;&gt; "Your name is {name:*^10}".format(name="Reuven")

'Your name is **Reuven**'</pre>
<p>If I want to put the string in the (default) left-most position of the string, filling with characters on the right, then I must use the &lt; specifier, so that the text will be on the left, and the stars on the right.</p>
<p>So it’s pretty clear that str.format is pretty snazzy when it comes to text. How about numbers? I wasn’t really sure how things would work here, but it turns out that they’re also quite straightforward. If you’re displaying integers, then you can go ahead and say:</p>
<pre>&gt;&gt;&gt; "The price is ${number}.".format(number=123)

'The price is $123.'</pre>
<p>So far, we don’t see any difference between passing an integer and a string. And indeed, they share many characteristics. However, we might want to display an integer in a different way. We can do that using one of the (many) modifiers that str.format provides — letters placed just before the end of the closing } character. For example, we can get the price in binary (with a trailing “b”), or in hexadecimal (with a trailing “x”), as in the following example:</p>
<pre>&gt;&gt;&gt; "The price is ${number:x}.".format(number=123)

'The price is $7b.'</pre>
<p>Of course, we can also zero-pad the number, such that it will always take up a fixed width. Just place a 0 between the colon and the width:</p>
<pre>&gt;&gt;&gt; "Your call is important to us. You are call #{number:05}.".format(number=123)

'Your call is important to us. You are call #00123.'</pre>
<p>Notice that inside of the {}, we cannot put executable Python code. Instead, there is a mini-language that is separate and different from Python. However, there are two small exceptions to this rule: (1) We can retrieve any attribute with the standard . notation, and (2) we can retrieve a single item with the [] notation.</p>
<p>For example:</p>
<pre>&gt;&gt;&gt; class Foo(object):
        def __init__(self):
        self.x = 100
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; 'Your number is {o.x}'.format(o=f)

'Your number is 100'n</pre>
<p>Notice how we were able to retrieve the “x” attribute from the “f” object, which we mapped to “o” within the string. However, while you can retrieve an attribute, you cannot execute it. Thus, the following will not work:</p>
<pre>&gt;&gt;&gt; "Your name is {name.upper()}".format(name="Reuven")

AttributeError: 'str' object has no attribute 'upper()'</pre>
<p>See what happened? I said “name.upper()”, in order to execute the method “str.upper” on “name”.  However, Python doesn’t want me to execute code there. So it takes the name of the attribute literally — and thus complained that there is no attribute “upper()”, with the parentheses. Of course, if you try it without the parentheses, it’ll work, for some value of “work”:</p>
<pre>&gt;&gt;&gt; "Your name is {name.upper}".format(name="Reuven")

'Your name is &lt;built-in method upper of str object at 0x1028bf2a0&gt;'</pre>
<p>Similarly, we can retrieve an individual element of a sequence or mapping with []. However, we cannot use the slice notation for more than one element. For example:</p>
<pre>&gt;&gt;&gt; "Your favorite number is {n[3]}.".format(n=numbers)

'Your favorite number is 3.'</pre>
<p>However:</p>
<pre>&gt;&gt;&gt; "Your favorite numbers are {n[2:4]}.".format(n=numbers)

ValueError: Missing ']' in format string</pre>
<p>The “:” character, which we use for slices, isn’t available in format strings, because it’s used to control the formatting of the output.</p>
<p>You can, of course, use [] on a dictionary, as well. However — and this is a bit weird for Python — we omit the quote marks, even when our key is a string. For example:</p>
<pre>&gt;&gt;&gt; person = {'first':'Reuven', 'last':'Lerner'}
&gt;&gt;&gt; "Your name is {p[first]}.".format(p=person)

'Your name is Reuven.'</pre>
<p>If we were to include the quotes…</p>
<pre>&gt;&gt;&gt; "Your name is {p['first']}.".format(p=person)

KeyError: "'first'"</pre>
<p>There is actually a lot more to str.format than what I have shared here. In particular,  each type has its own format specifications, which means that you can do certain things with floats (e.g., setting the precision) that you cannot do with strings.</p>
<p>You can even add formatting functionality to your own Python classes, such that they’ll be displayed in the way that you want, along with format specifiers that you define.</p>
<p><span>If you want to learn more about this, I’d definitely suggest reading </span><a title="PEP 3101" href="http://legacy.python.org/dev/peps/pep-3101/" target="_blank">PEP 3101</a><span>, which describes str.format. I’d also suggest </span><a title="Slide show about str.format" href="http://www.slideserve.com/jana/str-format" target="_blank">a slide show by Eric Smith</a><span>, which summarizes things nicely. Finally, the </span><a title="Python string temporary language" href="https://docs.python.org/2/library/string.html#format-specification-mini-language" target="_blank">Python documentation</a><span> has some excellent examples, including a guide for moving from % to str.format.</span></p>
<p>I hope that this was helpful and useful! If you enjoyed this blog post, <a title="Reuven Lerner's courses" href="http://lerner.co.il/courses" target="_blank">check out my many other resources</a>, including my free e-mail course on Python scoping, and my free Webinar on functional programming in Python.</p>
	</div>

	
	</div></body></html>