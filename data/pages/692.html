<html><body><div><div class="e2-note-text e2-text e2-published">
<p>В последнее время стараюсь всё больше изучать Питон не только снаружи, но и изнутри. Ведь самое интересное всегда происходит за кулисами.</p>
<p>Если вы ещё не знакомы с <a href="http://zelark.ru/blog/all/vvedenie-v-generatory-spiskov-yazyka-python/">генераторами списков</a> (list comprehensions), то рекомендую сначала прочитать статью, о том, как они работают.</p>
<h2>Проблема</h2>
<p>Несмотря на то, что вторая заповедь питоновского дзена гласит нам: «Явное лучше, чем неявное», — обе функции, в приведённом ниже коде, выведут одинаковый результат.</p>
<pre class="e2-text-code"><code class="python">&gt;&gt;&gt; def foo():
...     x0 = [[1, 2], [3, 4], [5, 6]]
...     y = [x2 for x1 in x0 for x2 in x1]
...     print y
...
&gt;&gt;&gt; def bar():
...     x = [[1, 2], [3, 4], [5, 6]]
...     x = [x for x in x for x in x]
...     print x
...
&gt;&gt;&gt; foo()
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; bar()
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt;
</code></pre><p>WTF? — скажете вы. Но код в функции <b>bar</b> действительно будет работать корректно, правда я сомневаюсь, что кто-то скажет спасибо, если вы будете использовать такую магию в ваших программах. Для того чтобы разобраться что же тут происходит, неплохо будет вспомнить, что одним из краеугольных камней Питона является стек, а другим — объекты. Да, в Питоне, как вы помните, всё является объектами: имена функций, имена переменных, типы данных и т. д., следовательно, имена переменных не хранят в себе значения, а лишь указывают на области памяти, где хранятся значения (объекты).</p>
<h2>Получение байт-кода</h2>
<p>Теперь зная это, обратимся за помощью к модулю <b>dis</b>. В нём есть одноимённая функция, которая позволят  преобразовать байт-код из «абракадабры» в понятный для человека вид. Для большей ясности, я буду объяснять на примере функции <b>foo</b>, в которой все переменные имеют разные имена, но, как вы увидите ниже, всё это будет справедливо и для <b>bar</b>, несмотря на то, что в ней используется лишь одно имя.</p>
<pre class="e2-text-code"><code class="python">&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(foo.__code__)
  2           0 LOAD_CONST               1 (1)
              3 LOAD_CONST               2 (2)
              6 BUILD_LIST               2
              9 LOAD_CONST               3 (3)
             12 LOAD_CONST               4 (4)
             15 BUILD_LIST               2
             18 LOAD_CONST               5 (5)
             21 LOAD_CONST               6 (6)
             24 BUILD_LIST               2
             27 BUILD_LIST               3
             30 STORE_FAST               0 (x0)
 
  3          33 BUILD_LIST               0
             36 LOAD_FAST                0 (x0)
             39 GET_ITER
        &gt;&gt;   40 FOR_ITER                25 (to 68)
             43 STORE_FAST               1 (x1)
             46 LOAD_FAST                1 (x1)
             49 GET_ITER
        &gt;&gt;   50 FOR_ITER                12 (to 65)
             53 STORE_FAST               2 (x2)
             56 LOAD_FAST                2 (x2)
             59 LIST_APPEND              3
             62 JUMP_ABSOLUTE           50
        &gt;&gt;   65 JUMP_ABSOLUTE           40
        &gt;&gt;   68 STORE_FAST               3 (y)
 
  4          71 LOAD_FAST                3 (y)
             74 PRINT_ITEM
             75 PRINT_NEWLINE
             76 LOAD_CONST               0 (None)
             79 RETURN_VALUE
&gt;&gt;&gt;
</code></pre><p>В первом столбце стоят номера строк анализируемого исходного кода. Во втором столбце указано смещение команд в байт-коде. В третьем перечислены имена самих команд. Наконец, четвёртый и пятый столбцы содержат подробности об аргументах выполняемой команды если таковые имеются.</p>
<p>Теперь немного о самих командах. Все команды, которые начинаются с <b>LOAD</b>, означают положить что-то в стек (push). Все команды которые начинаются с <b>STORE</b>, означают вытащить что-то из стека (pop). Также операции со стеком присутствуют и в других командах.</p>
<p><i>Примечание.</i> На самом деле, стек используемый в виртуальной машине питона (Python Virtual Machine), гораздо более гибкий и не ограничивается лишь типичными операциями push и pop.</p>
<h2>Анализ байт-кода</h2>
<p>Команды со смещением от 0 до 30 формируют список, на который затем указывает <b>x0</b>. Команда <b>BUILD_LIST</b> по смещению 33 создаёт пустой список, который кладётся на дно стека. Это тот список, в который будут попадать значения, полученные в результате работы генератора. И вот мы подходим к самому главному. По смещению 36 команда <b>LOAD_FAST</b> кладёт в стек указатель на список из <b>x0</b>. Таким образом, нам уже не важно, что в дальнейшем будет сохранено в <b>x0</b> (или в <b>x</b> как в примере функции <b>bar</b>), т. к. указатель на список уже сохранён в стеке. Затем создаются итераторы, с помощью которых осуществляется проход через весь список, обработка, сохранение итогового результата (выталкивание того самого списка, что лежит на дне стека) и вывод его на экран. На рисунке ниже изображено состояние стека в момент перед тем, как элемент попадёт в результирующий список.</p>
<div class="e2-text-picture">
<img src="http://zelark.ru/blog/pictures/2014-04-08-08.49.39-pm.png" alt=""/>
</div>
<p>Итератор 1 проходит по всем элементам списка, а они, как мы помним, тоже являются списками. Итератор 2 проходится по элементам вложенных списков. В конечном счёте, каждый из этих элемент оказывается на вершине стека, после чего попадает в результирующий список, который лежит на самом дне. После того, как все проходы завершены, остаётся лишь вытолкнуть полученный список из стека.</p>
<p><i>Примечание.</i> Примеры в данной статье основаны на 2-й ветке Питона. В 3-й ветке байт-код будет немного отличатся, но принцип остаётся тот же — прежде чем что-то использовать, указатель на него кладётся в стек.</p>
</div>



 
 

</div></body></html>