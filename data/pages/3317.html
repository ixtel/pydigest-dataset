<html><body><div><div class="content html_format"><p>
      Продолжение перевода неофициальной документации Selenium для Python.</p><p>
Перевод сделан с разрешения автора Baiju Muthukadan.</p><p>
Оригинал можно найти </p><a href="http://selenium-python.readthedocs.org/index.html">здесь</a><p>.

</p><h2>Содержание:</h2><p>
1. </p><a href="http://habrahabr.ru/post/248559/">Установка</a><p>
2. Первые Шаги</p><p>
3. </p><a href="http://habrahabr.ru/post/250947/">Навигация</a><p>
4. </p><a href="http://habrahabr.ru/post/250975/">Поиск Элементов</a><p>
5. Ожидания</p><p>
6. Объекты Страницы</p><p>
7. WebDriver API</p><p>
8. Приложение: Часто Задаваемые Вопросы
</p><a name="habracut"/>
<h1>2. Первые шаги</h1>
<h2>2.1. Простое использование</h2><p>
Если вы установили привязку Selenium к Python, вы можете начать использовать ее с помощью интерпретатора Python.

</p><pre><code class="python">from selenium import webdriver
from selenium.webdriver.common.keys import Keys

driver = webdriver.Firefox()
driver.get("http://www.python.org")
assert "Python" in driver.title
elem = driver.find_element_by_name("q")
elem.send_keys("pycon")
elem.send_keys(Keys.RETURN)
assert "No results found." not in driver.page_source
driver.close()
</code></pre><p>
Код выше может быть сохранен в файл (к примеру, python_org_search.py), и запущен:
</p><blockquote><pre>python python_org_search.py</pre></blockquote><p>Запускаемый вами Python должен содержать установленный модуль selenium.

</p><h2>2.2. Пошаговый разбор примера</h2><p>
Модуль selenium.webdriver предоставляет весь функционал WebDriver'а. На данный момент WebDriver поддерживает реализации Firefox, Chrome, Ie и Remote. Класс Keys обеспечивает взаимодействие с командами клавиатуры, такими как RETURN, F1, ALT и т.д…

</p><pre><code class="python">from selenium import webdriver
from selenium.webdriver.common.keys import Keys
</code></pre><p>
Далее создается элемент класса Firefox WebDriver.

</p><pre><code class="python">driver = webdriver.Firefox()
</code></pre><p>
Метод driver.get перенаправляет к странице URL в параметре. WebDriver будет ждать пока страница не загрузится полностью (то есть, событие “onload” игнорируется), прежде чем передать контроль вашему тесту или скрипту. Стоит отметить, что если страница использует много AJAX-кода при загрузке, то WebDriver может не распознать, загрузилась ли она полностью:

</p><pre><code class="python">driver.get("http://www.python.org")
</code></pre><p>
Следующая строка — это утверждение (англ. assertion), что заголовок содержит слово “Python” [assert позволяет проверять предположения о значениях произвольных данных в произвольном месте программы. По своей сути assert напоминает констатацию факта, расположенную посреди кода программы. В случаях, когда произнесенное утверждение не верно, assert возбуждает исключение. Такое поведение позволяет контролировать выполнение программы в строго определенном русле. Отличие assert от условий заключается в том, что программа с assert не приемлет иного хода событий, считая дальнейшее выполнение программы или функции бессмысленным — Прим. пер.]:

</p><pre><code class="python">assert "Python" in driver.title
</code></pre><p>
WebDriver предоставляет ряд способов получения элементов с помощью методов find_element_by_*. Для примера, элемент ввода текста input может быть найден по его атрибуту name методом find_element_by_name. Подробное описание методов поиска элементов можно найти в главе Поиск Элементов:

</p><pre><code class="python">elem = driver.find_element_by_name("q")
</code></pre><p>
После этого мы посылаем нажатия клавиш (аналогично введению клавиш с клавиатуры). Специальные команды могут быть переданы с помощью класса Keys импортированного из selenium.webdriver.common.keys:

</p><pre><code class="python">elem.send_keys("pycon")
elem.send_keys(Keys.RETURN)
</code></pre><p>
После ответа страницы, вы получите результат, если таковой ожидается. Чтобы удостовериться, что мы получили какой-либо результат, добавим утверждение:

</p><pre><code class="python">assert "No results found." not in driver.page_source
</code></pre><p>
В завершение, окно браузера закрывается. Вы можете также вызывать метод quit вместо close. Метод quit закроет браузер полностью, в то время как close закроет одну вкладку. Однако, в случае, когда открыта только одна вкладка, по умолчанию большинство браузеров закрывается полностью:

</p><pre><code class="python">driver.close()
</code></pre>
<h2>2.3. Использование Selenium для написания тестов</h2><p>
Selenium чаще всего используется для написания тестовых ситуаций. Сам пакет selenium не предоставляет никаких тестовых утилит или инструментов разработки. Вы можете писать тесты с помощью модуля Python unittest. Другим вашим выбором в качестве тестовых утилит/инструментов разработки могут стать py.test и nose.</p><p>
В этой главе, в качестве выбранной утилиты будет использоваться unittest. Ниже приводится видоизмененный пример с использованием этого модуля. Данный скрипт тестирует функциональность поиска на сайте python.org:

</p><pre><code class="python">import unittest
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

class PythonOrgSearch(unittest.TestCase):

    def setUp(self):
        self.driver = webdriver.Firefox()

    def test_search_in_python_org(self):
        driver = self.driver
        driver.get("http://www.python.org")
        self.assertIn("Python", driver.title)
        elem = driver.find_element_by_name("q")
        elem.send_keys("pycon")
        assert "No results found." not in driver.page_source
        elem.send_keys(Keys.RETURN)

    def tearDown(self):
        self.driver.close()

if __name__ == "__main__":
    unittest.main()
</code></pre><p>
Вы можете запустить тест выше из командной строки следующей командой:
</p><blockquote><pre>python test_python_org_search.py
.
----------------------------------------------------------------------
Ran 1 test in 15.566s

OK</pre></blockquote><p>Результат сверху показывает, что тест завершился успешно.

</p><h2>2.4. Пошаговый разбор примера</h2><p>
Сначала были импортированы все основные необходимые модули. Модуль </p><a href="http://docs.python.org/library/unittest.html">unittest</a><p> встроен в Python и реализован на Java’s JUnit. Этот модуль предоставляет собой утилиту для организации тестов.
</p><p>
Модуль selenium.webdriver предоставляет весь функционал WebDriver'а. На данный момент WebDriver поддерживает реализации Firefox, Chrome, Ie и Remote. Класс Keys обеспечивает взаимодействие с командами клавиатуры, такими как RETURN, F1, ALT и т.д…

</p><pre><code class="python">import unittest
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
</code></pre><p>
Класс теста унаследован от unittest.TestCase. Наследование класса TestCase является способом сообщения модулю unittest, что это тест:

</p><pre><code class="python">class PythonOrgSearch(unittest.TestCase):
</code></pre><p>
setUp — это часть инициализации, этот метод будет вызываться перед каждым методом теста, который вы собираетесь написать внутри класса теста. Здесь мы создаем элемент класса Firefox WebDriver.

</p><pre><code class="python">def setUp(self):
    self.driver = webdriver.Firefox()
</code></pre><p>
Далее описан метод нашего теста. Метод теста всегда должен начинаться с фразы test. Первая строка метода создает локальную ссылку на объект драйвера, созданный методом setUp.

</p><pre><code class="python">def test_search_in_python_org(self):
    driver = self.driver
</code></pre><p>
Метод driver.get перенаправляет к странице URL в параметре. WebDriver будет ждать пока страница не загрузится полностью (то есть, событие “onload” игнорируется), прежде чем передать контроль вашему тесту или скрипту. Стоит отметить, что если страница использует много AJAX-кода при загрузке, то WebDriver может не распознать, загрузилась ли она полностью:

</p><pre><code class="python">driver.get("http://www.python.org")
</code></pre><p>
Следующая строка — это утверждение, что заголовок содержит слово “Python”:

</p><pre><code class="python">self.assertIn("Python", driver.title)
</code></pre><p>
WebDriver предоставляет ряд способов получения элементов с помощью методов find_element_by_*. Для примера, элемент ввода текста input может быть найден по его атрибуту name методом find_element_by_name. Подробное описание методов поиска элементов можно найти в главе Поиск Элементов:

</p><pre><code class="python">elem = driver.find_element_by_name("q")
</code></pre><p>
После этого мы посылаем нажатия клавиш (аналогично введению клавиш с клавиатуры). Специальные команды могут быть переданы с помощью класса Keys импортированного из selenium.webdriver.common.keys:

</p><pre><code class="python">elem.send_keys("pycon")
elem.send_keys(Keys.RETURN)
</code></pre><p>
После ответа страницы, вы получите результат, если таковой ожидается. Чтобы удостовериться, что мы получили какой-либо результат, добавим утверждение:

</p><pre><code class="python">assert "No results found." not in driver.page_source
</code></pre><p>
Метод tearDown будет вызван после каждого метода теста. Это метод для действий чистки. В текущем методе реализовано закрытие окна браузера. Вы можете также вызывать метод quit вместо close. Метод quit закроет браузер полностью, в то время как close закроет одну вкладку. Однако, в случае, когда открыта только одна вкладка, по умолчанию большинство браузеров закрывается полностью.:

</p><pre><code class="python">def tearDown(self):
    self.driver.close()
</code></pre><p>
Завершающий код — это стандартная вставка кода для запуска набора тестов [Сравнение __name__ с "__main__" означает, что модуль (файл программы) запущен как отдельная программа («main» (англ.) — «основная», «главная») (а не импортирован из другого модуля). Если вы импортируете модуль, атрибут модуля __name__ будет равен имени файла без каталога и расширения — Прим. пер.]:

</p><pre><code class="python">if __name__ == "__main__":
    unittest.main()
</code></pre>
<h2>2.5. Использование Selenium с remote WebDriver</h2><p>
Для использования remote WebDriver (удаленного веб-драйвера) необходимо запустить Selenium server. Для запуска сервера используйте команду:
</p><blockquote><pre>java -jar selenium-server-standalone-2.x.x.jar</pre></blockquote><p>Пока Selenium server запускается, вы можете видеть сообщения вида:
</p><blockquote><pre>15:43:07.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub</pre></blockquote><p>Строка выше сообщает о том, что вы можете использовать указанный URL для подключения remote WebDriver. Ниже приводится несколько примеров:

</p><pre><code class="python">from selenium.webdriver.common.desired_capabilities import DesiredCapabilities

driver = webdriver.Remote(
   command_executor='http://127.0.0.1:4444/wd/hub',
   desired_capabilities=DesiredCapabilities.CHROME)

driver = webdriver.Remote(
   command_executor='http://127.0.0.1:4444/wd/hub',
   desired_capabilities=DesiredCapabilities.OPERA)

driver = webdriver.Remote(
   command_executor='http://127.0.0.1:4444/wd/hub',
   desired_capabilities=DesiredCapabilities.HTMLUNITWITHJS)
</code></pre><p>
Переменная desired_capabilities — это словарь. Вместо того, чтобы использовать словари по умолчанию, вы можете явно прописать значения:

</p><pre><code class="python">driver = webdriver.Remote(
   command_executor='http://127.0.0.1:4444/wd/hub',
   desired_capabilities={'browserName': 'htmlunit',
                         'version': '2',
                        'javascriptEnabled': True})
</code></pre>
<a href="http://habrahabr.ru/post/250947/">Перейти к следующей главе</a>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>