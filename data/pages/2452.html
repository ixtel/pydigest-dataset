<html><body><div><p>One morning on the Underground, I began to reason that what I needed was
a sort of "IRC Bot Apache" that would handle incoming IRC events of
various sorts (<tt class="docutils literal">PRIVMSG</tt>, <tt class="docutils literal">ACTION</tt>, etc.), and then pass them along
with some connection information to my django code.  I'd dispatch these
messages through the regex-based patterns() system, then call view code
that uses ORM objects to perform queries.</p>
<p>The obvious choice for implementing something like this is Twisted
Python, which shows its age but remains the de facto Python library for
coding state machines.  I'm only occasionally familiar with the system
(and the documentation is filled with distracting Java-esque Software
Engineering babble for some bizarre reason), but I was able to localize
the actual Twisted-using code to one function, which at the very least
makes it simple to hand off to experts to tell me if I'm doing anything
stupid.</p>
<div class="section" id="yardbird">
<h2>Yardbird</h2>
<p>Digging through twisted documentation I found their <a class="reference external" href="http://twistedmatrix.com/projects/words/documentation/examples/ircLogBot.py">example LogBot</a>
and based it loosely on that pattern, subclassing irc.IRCClient and
replacing the <tt class="docutils literal">privmsg</tt> method along the following lines:</p>
<pre class="literal-block">
from twisted.words.protocols import irc
from twisted.internet import defer, threads
from django.core import urlresolvers
from django.conf import settings

class DjangoBot(irc.IRCClient):
    @defer.inlineCallbacks
    def privmsg(self, user, channel, msg):
        resolver = urlresolvers.get_resolver('.'.join(
                                (settings.ROOT_MSGCONF, 'privmsg')))
        request = dict(user=user, channel=channel, msg=msg,
                                settings=settings)
        callback, args, kwargs = resolver.resolve('/' + request['msg'])
        response = yield threads.deferToThread(callback, request,
                                *args, **kwargs)
        defer.returnValue(self.notice(response.recipient,
                                response.data.encode('UTF-8')))
</pre>
<p>Let me go through that line by line:</p>
<pre class="literal-block">
@defer.inlineCallbacks
def privmsg(self, user, channel, msg):
</pre>
<p>The <a class="reference external" href="http://twistedmatrix.com/documents/8.1.0/api/twisted.internet.defer.html#inlineCallbacks">inlineCallbacks</a> decorator essentially catches any <tt class="docutils literal">yield</tt> of a
Twisted deferred object and schedules the next delve into the generator
using standard Twisted deferred-execution mechanisms.  So now <tt class="docutils literal">yield</tt>
really behaves like a scheduler yield, and you can let some more
critical IRC-parsing code run between your own calls.</p>
<p>Next we build a Django <tt class="docutils literal">urlresolver</tt> object so we can dispatch regexes
to handler functions, using some Django <tt class="docutils literal">settings</tt> info to determine
path info:</p>
<pre class="literal-block">
from django.core import urlresolvers
from django.conf import settings

resolver = urlresolvers.get_resolver('.'.join(
                        (settings.ROOT_MSGCONF, 'privmsg')))
</pre>
<p>Then we build a <tt class="docutils literal">request</tt> dictionary.  In normal Django this would be
an <a class="reference external" href="http://docs.djangoproject.com/en/1.0/ref/request-response/#django.http.HttpRequest">HttpRequest</a> object, containing all sorts of information about the web
server and the remote client and the HTTP request itself.  Since this is
a quick-and-dirty example, I've reduced this to a dict for simplicity.
I also passed in the settings namespace just to be lazy (so I can keep
things like nickname in there):</p>
<pre class="literal-block">
request = dict(user=user, channel=channel, msg=msg, settings=settings)
</pre>
<p>Now we actually use our resolver to test the incoming message against
all our patterns in <tt class="docutils literal">privmsg.py</tt> and return to us the appropriate
function, along with all of the anonymous and named matches that were
generated by the winning regular expression.  Note that we have to
prepend a <tt class="docutils literal">/</tt> to our message to appease the URL-centric resolver:</p>
<pre class="literal-block">
callback, args, kwargs = resolver.resolve('/' + request['msg'])
</pre>
<p>Finally we get to the deferred execution magic! We have a function, a
request object, and some arguments made from textual analysis of the
message.  We use the <a class="reference external" href="http://twistedmatrix.com/documents/current/api/twisted.internet.threads.deferToThread.html">threads.deferToThread</a> method to generate a
deferred object that runs in a completely separate thread, and yield it
up to our <a class="reference external" href="http://twistedmatrix.com/documents/8.1.0/api/twisted.internet.defer.html#inlineCallbacks">inlineCallbacks</a> decorator to be scheduled:</p>
<pre class="literal-block">
response = yield threads.deferToThread(callback, request, *args,
                                       **kwargs)
</pre>
<p>Our view function then runs in the background, taking as long as it
likes while our bot concerns itself with answering <tt class="docutils literal">PING</tt> replies and
dispatching further events to the resolver.</p>
<p>We're confident that the Django code is reasonably thread-safe, as it
has to handle concurrency under a variety of Web server models (such as
apache's Worker MPM or a traditional Prefork model).  Once the function
returns a value, the thread closes and execution comes back to this
method again, chucking the returned value into our response object.</p>
<p>We're almost done, but we still need to actually do something with this
information!  In ordinary HTTP Django this would be an <a class="reference external" href="http://docs.djangoproject.com/en/1.0/ref/request-response/#django.http.HttpResponse">HttpResponse</a>
object, containing all sorts of information on what template to render
and what dictionary to pass in as an extra context namespace.  This is a
bit overkill for this example, so I've simplified it to another dict:</p>
<pre class="literal-block">
defer.returnValue(self.notice(response['recipient'],
                        response['data'].encode('UTF-8')))
</pre>
<p>The various RFCs for IRC all state rather loudly that automated bots
are meant to speak using <tt class="docutils literal">NOTICE</tt> but always ignore <tt class="docutils literal">NOTICEs</tt> from
other sources.  This is meant to prevent feedback loops flooding a
channel.  Also note that since this was the final statement of my
<a class="reference external" href="http://twistedmatrix.com/documents/8.1.0/api/twisted.internet.defer.html#inlineCallbacks">inlineCallbacks</a> function, I called the <a class="reference external" href="http://twistedmatrix.com/documents/8.1.0/api/twisted.internet.defer.html#returnValue">defer.returnValue</a> to spit back
the result of the <tt class="docutils literal">notice</tt> call.  I'm not convinced that it was at all
necessary, but I believe it's harmless boilerplate in the worst case.</p>
</div>
</div></body></html>