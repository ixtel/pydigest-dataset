<html><body><div><body id="readabilityBody">
   <h1>[Python-Dev] PEP 466: Network security enhancements for Python	2.7.7</h1>
    <b>Guido van Rossum</b> 
    <a href="mailto:python-dev%40python.org?Subject=Re%3A%20%5BPython-Dev%5D%20PEP%20466%3A%20Network%20security%20enhancements%20for%20Python%0A%092.7.7&amp;In-Reply-To=%3CCAP7%2BvJJVvf8-NG5yqEwmMyU-U20SXzXC%2BB9BJibSHBi3H9znhg%40mail.gmail.com%3E" title="[Python-Dev] PEP 466: Network security enhancements for Python&#9;2.7.7">guido at python.org
       </a><br/>
    <i>Sat Apr 19 01:34:50 CEST 2014</i>
    <p/>
    <hr/>  

<pre>Thanks, Nick. I hereby approve this PEP. You can update the status
yourself. Congrats!


On Wed, Apr 16, 2014 at 3:04 PM, Nick Coghlan &lt;<a href="https://mail.python.org/mailman/listinfo/python-dev">ncoghlan at gmail.com</a>&gt; wrote:

&gt;<i> I've reworded the PEP to make it clear it is now just about
</i>&gt;<i> backporting a specific set of enhancements to 2.7.7, as well as
</i>&gt;<i> switching to updating to new OpenSSL feature releases in the binary
</i>&gt;<i> installers.
</i>&gt;<i>
</i>&gt;<i> The idea of an open ended backport policy is now listed as a rejected
</i>&gt;<i> variant. I believe that change addresses Guido's main remaining
</i>&gt;<i> concern, so I think this version is ready for pronouncement.
</i>&gt;<i>
</i>&gt;<i> Regards,
</i>&gt;<i> Nick.
</i>&gt;<i>
</i>&gt;<i> ========================================
</i>&gt;<i> PEP: 466
</i>&gt;<i> Title: Network Security Enhancements for Python 2.7.7
</i>&gt;<i> Version: $Revision$
</i>&gt;<i> Last-Modified: $Date$
</i>&gt;<i> Author: Nick Coghlan &lt;<a href="https://mail.python.org/mailman/listinfo/python-dev">ncoghlan at gmail.com</a>&gt;,
</i>&gt;<i> Status: Draft
</i>&gt;<i> Type: Informational
</i>&gt;<i> Content-Type: text/x-rst
</i>&gt;<i> Created: 23-Mar-2014
</i>&gt;<i> Post-History: 23-Mar-2014, 24-Mar-2014, 25-Mar-2014, 26-Mar-2014,
</i>&gt;<i> 16-Apr-2014
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Abstract
</i>&gt;<i> ========
</i>&gt;<i>
</i>&gt;<i> Most CPython tracker issues are classified as errors in behaviour or
</i>&gt;<i> proposed enhancements. Most patches to fix behavioural errors are
</i>&gt;<i> applied to all active maintenance branches.  Enhancement patches are
</i>&gt;<i> restricted to the default branch that becomes the next Python version.
</i>&gt;<i>
</i>&gt;<i> This cadence works reasonably well during Python's normal 18-24 month
</i>&gt;<i> feature release cycle, which is still applicable to the Python 3 series.
</i>&gt;<i> However, the age of the standard library in Python 2 has now reached a
</i>&gt;<i> point
</i>&gt;<i> where it is sufficiently far behind the state of the art in network
</i>&gt;<i> security
</i>&gt;<i> protocols for it to be causing real problems in use cases where upgrading
</i>&gt;<i> to
</i>&gt;<i> Python 3 in the near term may not be feasible.
</i>&gt;<i>
</i>&gt;<i> In recognition of the additional practical considerations that have arisen
</i>&gt;<i> during the 4+ year maintenance cycle for Python 2.7, this PEP allows a
</i>&gt;<i> critical set of network security related features to be backported from
</i>&gt;<i> Python 3.4 to the upcoming Python 2.7.7 maintenance release.
</i>&gt;<i>
</i>&gt;<i> While this PEP does not make any changes to the core development team's
</i>&gt;<i> handling of security-fix-only branches that are no longer in active
</i>&gt;<i> maintenance, it *does* recommend that commercial redistributors providing
</i>&gt;<i> extended support periods for the Python standard library either backport
</i>&gt;<i> these features to their supported versions, or else explicitly disclaim
</i>&gt;<i> support for the use of older versions in roles that involve connecting
</i>&gt;<i> directly to the public internet.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> New security related features in Python 2.7.7
</i>&gt;<i> =============================================
</i>&gt;<i>
</i>&gt;<i> Under this proposal, the following features will be backported from Python
</i>&gt;<i> 3.4 to the upcoming Python 2.7.7 maintenance release:
</i>&gt;<i>
</i>&gt;<i> * in the ``os`` module:
</i>&gt;<i>
</i>&gt;<i>   * persistent file descriptor for ``os.urandom()``.
</i>&gt;<i>
</i>&gt;<i> * in the ``hmac`` module:
</i>&gt;<i>
</i>&gt;<i>   * constant time comparison function (``hmac.compare_digest()``).
</i>&gt;<i>
</i>&gt;<i> * in the ``hashlib`` module:
</i>&gt;<i>
</i>&gt;<i>   * password hashing function (``hashlib.pbkdf2_hmac()``).
</i>&gt;<i>   * details of hash algorithm availability
</i>&gt;<i> (``hashlib.algorithms_guaranteed``
</i>&gt;<i>     and ``hashlib.algorithms_available``).
</i>&gt;<i>
</i>&gt;<i> * in the ``ssl`` module:
</i>&gt;<i>
</i>&gt;<i>   * this module is almost entirely synchronised with its Python 3
</i>&gt;<i>     counterpart, bringing TLSv1.x settings, SSLContext manipulation, Server
</i>&gt;<i>     Name Indication, access to platform certificate stores, standard
</i>&gt;<i>     library support for peer hostname validation and more to the Python 2
</i>&gt;<i>     series.
</i>&gt;<i>   * the only ``ssl`` module features *not* backported under this policy are
</i>&gt;<i>     the ``ssl.RAND_*`` functions that provide access to OpenSSL's random
</i>&gt;<i>     number generation capabilities - use ``os.urandom()`` instead.
</i>&gt;<i>
</i>&gt;<i> As a general change in maintenance policy, permission is also granted to
</i>&gt;<i> upgrade to newer feature releases of OpenSSL when preparing the binary
</i>&gt;<i> installers for new maintenance releases of Python 2.7.
</i>&gt;<i>
</i>&gt;<i> This PEP does NOT propose a general exception for backporting new features
</i>&gt;<i> to Python 2.7 - every new feature proposed for backporting will still need
</i>&gt;<i> to be justified independently. In particular, it will need to be explained
</i>&gt;<i> why relying on and independently updated backport on the Python Package
</i>&gt;<i> Index
</i>&gt;<i> instead is not an acceptable solution.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Backwards compatibility considerations
</i>&gt;<i> ======================================
</i>&gt;<i>
</i>&gt;<i> As in the Python 3 series, the backported ``ssl.create_default_context()``
</i>&gt;<i> API is granted a backwards compatibility exemption that permits the
</i>&gt;<i> protocol, options, cipher and other settings of the created SSL context to
</i>&gt;<i> be updated in maintenance releases to use higher default security settings.
</i>&gt;<i> This allows them to appropriately balance compatibility and security at the
</i>&gt;<i> time of the maintenance release, rather than at the time of the original
</i>&gt;<i> feature release.
</i>&gt;<i>
</i>&gt;<i> This PEP does *not* grant any other exemptions to the usual backwards
</i>&gt;<i> compatibility policy for maintenance releases. Instead, by explicitly
</i>&gt;<i> encouraging the use of feature based checks, it is designed to make it
</i>&gt;<i> easier
</i>&gt;<i> to write more secure cross-version compatible Python software, while still
</i>&gt;<i> limiting the risk of breaking currently working software when upgrading to
</i>&gt;<i> a new Python 2.7 maintenance release.
</i>&gt;<i>
</i>&gt;<i> In all cases where this proposal allows new features to be backported to
</i>&gt;<i> the Python 2.7 release series, it is possible to write cross-version
</i>&gt;<i> compatible code that operates by "feature detection" (for example, checking
</i>&gt;<i> for particular attributes in a module), without needing to explicitly check
</i>&gt;<i> the Python version.
</i>&gt;<i>
</i>&gt;<i> It is then up to library and framework code to provide an appropriate
</i>&gt;<i> warning
</i>&gt;<i> and fallback behaviour if a desired feature is found to be missing. While
</i>&gt;<i> some especially security sensitive software MAY fail outright if a desired
</i>&gt;<i> security feature is unavailable, most software SHOULD instead emit a
</i>&gt;<i> warning
</i>&gt;<i> and continue operating using a slightly degraded security configuration.
</i>&gt;<i>
</i>&gt;<i> The backported APIs allow library and application code to perform the
</i>&gt;<i> following actions after detecting the presence of a relevant
</i>&gt;<i> network security related feature:
</i>&gt;<i>
</i>&gt;<i> * explicitly opt in to more secure settings (to allow the use of enhanced
</i>&gt;<i>   security features in older maintenance releases of Python with less
</i>&gt;<i>   secure default behaviour)
</i>&gt;<i> * explicitly opt in to less secure settings (to allow the use of newer
</i>&gt;<i> Python
</i>&gt;<i>   feature releases in lower security environments)
</i>&gt;<i> * determine the default setting for the feature (this MAY require explicit
</i>&gt;<i>   Python version checks to determine the Python feature release, but DOES
</i>&gt;<i>   NOT require checking for a specific maintenance release)
</i>&gt;<i>
</i>&gt;<i> Security related changes to other modules (such as higher level networking
</i>&gt;<i> libraries and data format processing libraries) will continue to be made
</i>&gt;<i> available as backports and new modules on the Python Package Index, as
</i>&gt;<i> independent distribution remains the preferred approach to handling
</i>&gt;<i> software that must continue to evolve to handle changing development
</i>&gt;<i> requirements independently of the Python 2 standard library. Refer to
</i>&gt;<i> the `Motivation and Rationale`_ section for a review of the characteristics
</i>&gt;<i> that make the secure networking infrastructure worthy of special
</i>&gt;<i> consideration.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> OpenSSL compatibility
</i>&gt;<i> ---------------------
</i>&gt;<i>
</i>&gt;<i> Under this proposal, OpenSSL may be upgraded to more recent feature
</i>&gt;<i> releases
</i>&gt;<i> in Python 2.7 maintenance releases. On Linux and most other POSIX systems,
</i>&gt;<i> the specific version of OpenSSL used already varies, as CPython dynamically
</i>&gt;<i> links to the system provided OpenSSL library by default.
</i>&gt;<i>
</i>&gt;<i> For the Windows binary installers, the ``_ssl`` and ``_hashlib`` modules
</i>&gt;<i> are
</i>&gt;<i> statically linked with OpenSSL and the associated symbols are not exported.
</i>&gt;<i> Marc-Andre Lemburg indicates that updating to newer OpenSSL releases in the
</i>&gt;<i> ``egenix-pyopenssl`` binaries has not resulted in any reported
</i>&gt;<i> compatibility
</i>&gt;<i> issues [3]_
</i>&gt;<i>
</i>&gt;<i> The Mac OS X binary installers historically followed the same policy as
</i>&gt;<i> other POSIX installations and dynamically linked to the Apple provided
</i>&gt;<i> OpenSSL libraries. However, Apple has now ceased updating these
</i>&gt;<i> cross-platform libraries, instead requiring that even cross-platform
</i>&gt;<i> developers adopt Mac OS X specific interfaces to access up to date security
</i>&gt;<i> infrastructure on their platform. Accordingly, and independently of this
</i>&gt;<i> PEP, the Mac OS X binary installers were already going to be switched to
</i>&gt;<i> statically linker newer versions of OpenSSL [4]_
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Other Considerations
</i>&gt;<i> ====================
</i>&gt;<i>
</i>&gt;<i> Maintainability
</i>&gt;<i> ---------------
</i>&gt;<i>
</i>&gt;<i> A number of developers, including Alex Gaynor and Donald Stufft, have
</i>&gt;<i> expressed interest in carrying out the feature backports covered by this
</i>&gt;<i> policy, and assisting with any additional maintenance burdens that arise
</i>&gt;<i> in the Python 2 series as a result.
</i>&gt;<i>
</i>&gt;<i> Steve Dower and Brian Curtin have offered to help with the creation of the
</i>&gt;<i> Windows installers, allowing Martin von Löwis the opportunity to step back
</i>&gt;<i> from the task of maintaining the 2.7 Windows installer.
</i>&gt;<i>
</i>&gt;<i> This PEP is primarily about establishing the consensus needed to allow them
</i>&gt;<i> to carry out this work. For other core developers, this policy change
</i>&gt;<i> shouldn't impose any additional effort beyond potentially reviewing the
</i>&gt;<i> resulting patches for those developers specifically interested in the
</i>&gt;<i> affected modules.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Security releases
</i>&gt;<i> -----------------
</i>&gt;<i>
</i>&gt;<i> This PEP does not propose any changes to the handling of security
</i>&gt;<i> releases - those will continue to be source only releases that
</i>&gt;<i> include only critical security fixes.
</i>&gt;<i>
</i>&gt;<i> However, the recommendations for library and application developers are
</i>&gt;<i> deliberately designed to accommodate commercial redistributors that choose
</i>&gt;<i> to apply these changes to additional Python release series that are either
</i>&gt;<i> in security fix only mode, or have been declared "end of life" by the core
</i>&gt;<i> development team.
</i>&gt;<i>
</i>&gt;<i> Whether or not redistributors choose to exercise that option will be up
</i>&gt;<i> to the individual redistributor.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Integration testing
</i>&gt;<i> -------------------
</i>&gt;<i>
</i>&gt;<i> Third party integration testing services should offer users the ability
</i>&gt;<i> to test against multiple Python 2.7 maintenance releases (at least 2.7.6
</i>&gt;<i> and 2.7.7+), to ensure that libraries, frameworks and applications can
</i>&gt;<i> still
</i>&gt;<i> test their handling of the legacy security infrastructure correctly (either
</i>&gt;<i> failing or degrading gracefully, depending on the security sensitivity of
</i>&gt;<i> the software), even after the features covered in this proposal have been
</i>&gt;<i> backported to the Python 2.7 series.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Handling lower security environments with low risk tolerance
</i>&gt;<i> ------------------------------------------------------------
</i>&gt;<i>
</i>&gt;<i> For better or for worse (mostly worse), there are some environments where
</i>&gt;<i> the risk of latent security defects is more tolerated than even a slightly
</i>&gt;<i> increased risk of regressions in maintenance releases. This proposal
</i>&gt;<i> largely
</i>&gt;<i> excludes these environments from consideration where the modules covered by
</i>&gt;<i> the exemption are concerned - this approach is entirely inappropriate for
</i>&gt;<i> software connected to the public internet, and defence in depth security
</i>&gt;<i> principles suggest that it is not appropriate for most private networks
</i>&gt;<i> either.
</i>&gt;<i>
</i>&gt;<i> Downstream redistributors may still choose to cater to such environments,
</i>&gt;<i> but they will need to handle the process of downgrading the security
</i>&gt;<i> related modules and doing the associated regression testing themselves.
</i>&gt;<i> The main CPython continuous integration infrastructure will not cover this
</i>&gt;<i> scenario.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Motivation and Rationale
</i>&gt;<i> ========================
</i>&gt;<i>
</i>&gt;<i> The creation of this PEP was prompted primarily by the aging SSL support in
</i>&gt;<i> the Python 2 series. As of March 2014, the Python 2.7 SSL module is
</i>&gt;<i> approaching four years of age, and the SSL support in the still popular
</i>&gt;<i> Python 2.6 release had its feature set locked six years ago.
</i>&gt;<i>
</i>&gt;<i> These are simply too old to provide a foundation that can be recommended
</i>&gt;<i> in good conscience for secure networking software that operates over the
</i>&gt;<i> public internet, especially in an era where it is becoming quite clearly
</i>&gt;<i> evident that advanced persistent security threats are even more widespread
</i>&gt;<i> and more indiscriminate in their targeting than had previously been
</i>&gt;<i> understood. While they represented reasonable security infrastructure in
</i>&gt;<i> their time, the state of the art has moved on, and we need to investigate
</i>&gt;<i> mechanisms for effectively providing more up to date network security
</i>&gt;<i> infrastructure for users that, for whatever reason, are not currently in
</i>&gt;<i> a position to migrate to Python 3.
</i>&gt;<i>
</i>&gt;<i> While the use of the system OpenSSL installation addresses many of these
</i>&gt;<i> concerns on Linux platforms, it doesn't address all of them (in particular,
</i>&gt;<i> it is still difficult for sotware to explicitly require some higher level
</i>&gt;<i> security settings). The standard library support can be bypassed by using a
</i>&gt;<i> third party library like PyOpenSSL or Pycurl, but this still results in a
</i>&gt;<i> security problem, as these can be difficult dependencies to deploy, and
</i>&gt;<i> many
</i>&gt;<i> users will remain unaware that they might want them. Rather than explaining
</i>&gt;<i> to potentially naive users how to obtain and use these libraries, it seems
</i>&gt;<i> better to just fix the included batteries.
</i>&gt;<i>
</i>&gt;<i> In the case of the binary installers for Windows and Mac OS X that are
</i>&gt;<i> published on python.org, the version of OpenSSL used is entirely within
</i>&gt;<i> the control of the Python core development team, but is currently limited
</i>&gt;<i> to OpenSSL maintenance releases for the version initially shipped with the
</i>&gt;<i> corresponding Python feature release.
</i>&gt;<i>
</i>&gt;<i> With increased popularity comes increased responsibility, and this proposal
</i>&gt;<i> aims to acknowledge the fact that Python's popularity and adoption is at a
</i>&gt;<i> sufficiently high level that some of our design and policy decisions have
</i>&gt;<i> significant implications beyond the Python development community.
</i>&gt;<i>
</i>&gt;<i> As one example, the Python 2 ``ssl`` module does not support the Server
</i>&gt;<i> Name Indication standard. While it is possible to obtain SNI support
</i>&gt;<i> by using the third party ``requests`` client library, actually doing so
</i>&gt;<i> currently requires using not only ``requests`` and its embedded
</i>&gt;<i> dependencies,
</i>&gt;<i> but also half a dozen or more additional libraries. The lack of support
</i>&gt;<i> in the Python 2 series thus serves as an impediment to making effective
</i>&gt;<i> use of SNI on servers, as Python 2 clients will frequently fail to handle
</i>&gt;<i> it correctly.
</i>&gt;<i>
</i>&gt;<i> Another more critical example is the lack of SSL hostname matching in the
</i>&gt;<i> Python 2 standard library - it is currently necessary to rely on a third
</i>&gt;<i> party library, such as ``requests`` or ``backports.ssl_match_hostname`` to
</i>&gt;<i> obtain that functionality in Python 2.
</i>&gt;<i>
</i>&gt;<i> The Python 2 series also remains more vulnerable to remote timing attacks
</i>&gt;<i> on security sensitive comparisons than the Python 3 series, as it lacks a
</i>&gt;<i> standard library equivalent to the timing attack resistant
</i>&gt;<i> ``hmac.compare_digest()`` function. While appropriate secure comparison
</i>&gt;<i> functions can be implemented in third party extensions, many users don't
</i>&gt;<i> even consider the issue and use ordinary equality comparisons instead
</i>&gt;<i> - while a standard library solution doesn't automatically fix that problem,
</i>&gt;<i> it *does* make the barrier to resolution much lower once the problem is
</i>&gt;<i> pointed out.
</i>&gt;<i>
</i>&gt;<i> Python 2.7 represents the only long term maintenance release the core
</i>&gt;<i> development team has provided, and it is natural that there will be things
</i>&gt;<i> that worked over a historically shorter maintenance lifespan that don't
</i>&gt;<i> work
</i>&gt;<i> over this longer support period. In the specific case of the problem
</i>&gt;<i> described in this PEP, the simplest available solution is to acknowledge
</i>&gt;<i> that long term maintenance of network security related modules *requires*
</i>&gt;<i> the ability to add new features, even while retaining backwards
</i>&gt;<i> compatibility
</i>&gt;<i> for existing interfaces.
</i>&gt;<i>
</i>&gt;<i> For those familiar with it, it is worth comparing the approach described in
</i>&gt;<i> this PEP with Red Hat's handling of its long term open source support
</i>&gt;<i> commitments: it isn't the RHEL 6.0 release itself that receives 10 years
</i>&gt;<i> worth of support, but the overall RHEL 6 *series*. The individual RHEL 6.x
</i>&gt;<i> point releases within the series then receive a wide variety of new
</i>&gt;<i> features, including security enhancements, all while meeting strict
</i>&gt;<i> backwards compatibility guarantees for existing software. The proposal
</i>&gt;<i> covered in this PEP brings our approach to long term maintenance more into
</i>&gt;<i> line with this precedent - we retain our strict backwards compatibility
</i>&gt;<i> requirements, but make an exception to the restriction against adding new
</i>&gt;<i> features.
</i>&gt;<i>
</i>&gt;<i> To date, downstream redistributors have respected our upstream policy of
</i>&gt;<i> "no new features in Python maintenance releases". This PEP explicitly
</i>&gt;<i> accepts that a more nuanced policy is appropriate in the case of network
</i>&gt;<i> security related features, and the specific change it describes is
</i>&gt;<i> deliberately designed such that it is potentially suitable for Red Hat
</i>&gt;<i> Enterprise Linux and its downstream derivatives.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Rejected alternative: just advise developers to migrate to Python 3
</i>&gt;<i> -------------------------------------------------------------------
</i>&gt;<i>
</i>&gt;<i> This alternative represents the status quo. Unfortunately, it has proven
</i>&gt;<i> to be unworkable in practice, as the backwards compatibility implications
</i>&gt;<i> mean that this is a non-trivial migration process for large applications
</i>&gt;<i> and integration projects. While the tools for migration have evolved to
</i>&gt;<i> a point where it is possible to migrate even large applications
</i>&gt;<i> opportunistically and incrementally (rather than all at once) by updating
</i>&gt;<i> code to run in the large common subset of Python 2 and Python 3, using the
</i>&gt;<i> most recent technology often isn't a priority in commercial environments.
</i>&gt;<i>
</i>&gt;<i> Previously, this was considered an acceptable harm, as while it was an
</i>&gt;<i> unfortunate problem for the affected developers to have to face, it was
</i>&gt;<i> seen as an issue between them and their management chain to make the case
</i>&gt;<i> for infrastructure modernisation, and this case would become naturally
</i>&gt;<i> more compelling as the Python 3 series evolved.
</i>&gt;<i>
</i>&gt;<i> However, now that we're fully aware of the impact the limitations of the
</i>&gt;<i> Python 2 standard library may be having on the evolution of internet
</i>&gt;<i> security standards, I no longer believe that it is reasonable to expect
</i>&gt;<i> platform and application developers to resolve all of the latent defects
</i>&gt;<i> in an application's Unicode correctness solely in order to gain access to
</i>&gt;<i> the network security enhancements already available in Python 3.
</i>&gt;<i>
</i>&gt;<i> While Ubuntu (and to some extent Debian as well) are committed to porting
</i>&gt;<i> all
</i>&gt;<i> default system services and scripts to Python 3, and to removing Python 2
</i>&gt;<i> from its default distribution images (but not from its archives), this is
</i>&gt;<i> a mammoth task and won't be completed for the Ubuntu 14.04 LTS release
</i>&gt;<i> (at least for the desktop image - it may be achieved for the mobile and
</i>&gt;<i> server images).
</i>&gt;<i>
</i>&gt;<i> Fedora has even more work to do to migrate, and it will take a non-trivial
</i>&gt;<i> amount of time to migrate the relevant infrastructure components. While
</i>&gt;<i> Red Hat are also actively working to make it easier for users to use more
</i>&gt;<i> recent versions of Python on our stable platforms, it's going to take time
</i>&gt;<i> for those efforts to start having an impact on end users' choice of
</i>&gt;<i> version,
</i>&gt;<i> and any such changes also don't benefit the core platform infrastructure
</i>&gt;<i> that runs in the integrated system Python by necessity.
</i>&gt;<i>
</i>&gt;<i> The OpenStack migration to Python 3 is also still in its infancy, and even
</i>&gt;<i> though that's a project with an extensive and relatively robust automated
</i>&gt;<i> test suite, it's still large enough that it is going to take quite some
</i>&gt;<i> time
</i>&gt;<i> to migrate fully to a Python 2/3 compatible code base.
</i>&gt;<i>
</i>&gt;<i> And that's just three of the highest profile open source projects that
</i>&gt;<i> make heavy use of Python. Given the likely existence of large amounts of
</i>&gt;<i> legacy code that lacks the kind of automated regression test suite needed
</i>&gt;<i> to help support a migration from Python 2 to Python 3, there are likely to
</i>&gt;<i> be many cases where reimplementation (perhaps even in Python 3) proves
</i>&gt;<i> easier than migration. The key point of this PEP is that those situations
</i>&gt;<i> affect more people than just the developers and users of the affected
</i>&gt;<i> application: the existence of clients and servers with outdated network
</i>&gt;<i> security infrastructure becomes something that developers of secure
</i>&gt;<i> networked services need to take into account as part of their security
</i>&gt;<i> design, and that's a problem that inhibits the adoption of better security
</i>&gt;<i> standards.
</i>&gt;<i>
</i>&gt;<i> As Terry Reedy noted, if we try to persist with the status quo, the likely
</i>&gt;<i> outcome is that commercial redistributors will attempt to do something
</i>&gt;<i> like this on behalf of their customers *anyway*, but in a potentially
</i>&gt;<i> inconsistent and ad hoc manner. By drawing the scope definition process
</i>&gt;<i> into the upstream project we are in a better position to influence the
</i>&gt;<i> approach taken to address the situation and to help ensure some consistency
</i>&gt;<i> across redistributors.
</i>&gt;<i>
</i>&gt;<i> The problem is real, so *something* needs to change, and this PEP describes
</i>&gt;<i> my preferred approach to addressing the situation.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Rejected alternative: create and release Python 2.8
</i>&gt;<i> ---------------------------------------------------
</i>&gt;<i>
</i>&gt;<i> With sufficient corporate support, it likely *would* be possible to create
</i>&gt;<i> and release Python 2.8 (it's highly unlikely such a project would garner
</i>&gt;<i> enough interest to be achievable with only volunteers). However, this
</i>&gt;<i> wouldn't actually solve the problem, as the aim is to provide a *relatively
</i>&gt;<i> low impact* way to incorporate enhanced security features into integrated
</i>&gt;<i> products and deployments that make use of Python 2.
</i>&gt;<i>
</i>&gt;<i> Upgrading to a new Python feature release would mean both more work for the
</i>&gt;<i> core development team, as well as a more disruptive update that most
</i>&gt;<i> potential end users would likely just skip entirely.
</i>&gt;<i>
</i>&gt;<i> Attempting to create a Python 2.8 release would also bring in suggestions
</i>&gt;<i> to backport many additional features from Python 3 (such as ``tracemalloc``
</i>&gt;<i> and the improved coroutine support), making the migration from Python 2.7
</i>&gt;<i> to this hypothetical 2.8 release even riskier and more disruptive.
</i>&gt;<i>
</i>&gt;<i> This is not a recommended approach, as it would involve substantial
</i>&gt;<i> additional work for a result that is actually less effective in achieving
</i>&gt;<i> the original aim (which is to eliminate the current widespread use of the
</i>&gt;<i> aging network security infrastructure in the Python 2 series).
</i>&gt;<i>
</i>&gt;<i> Furthermore, while I can't make any commitments to actually addressing
</i>&gt;<i> this issue on Red Hat platforms, I *can* categorically rule out the idea
</i>&gt;<i> of a Python 2.8 being of any use to me in even attempting to get it
</i>&gt;<i> addressed.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Rejected alternative: distribute the security enhancements via PyPI
</i>&gt;<i> -------------------------------------------------------------------
</i>&gt;<i>
</i>&gt;<i> While this initially appears to be an attractive and easier to manage
</i>&gt;<i> approach, it actually suffers from several significant problems.
</i>&gt;<i>
</i>&gt;<i> Firstly, this is complex, low level, cross-platform code that integrates
</i>&gt;<i> with the underlying operating system across a variety of POSIX platforms
</i>&gt;<i> (including Mac OS X) and Windows. The CPython BuildBot fleet is already set
</i>&gt;<i> up to handle continuous integration in that context, but most of the
</i>&gt;<i> freely available continuous integration services just offer Linux, and
</i>&gt;<i> perhaps paid access to Windows. Those services work reasonably well for
</i>&gt;<i> software that largely runs on the abstraction layers offered by Python and
</i>&gt;<i> other dynamic languages, as well as the more comprehensive abstraction
</i>&gt;<i> offered by the JVM, but won't suffice for the kind of code involved here.
</i>&gt;<i>
</i>&gt;<i> The OpenSSL dependency for the network security support also qualifies as
</i>&gt;<i> the kind of "complex binary dependency" that isn't yet handled well by the
</i>&gt;<i> ``pip`` based software distribution ecosystem. Relying on a third party
</i>&gt;<i> binary dependency also creates potential compatibility problems for ``pip``
</i>&gt;<i> when running on other interpreters like ``PyPy``.
</i>&gt;<i>
</i>&gt;<i> Another practical problem with the idea is the fact that ``pip`` itself
</i>&gt;<i> relies on the ``ssl`` support in the standard library (with some additional
</i>&gt;<i> support from a bundled copy of ``requests``, which in turn bundles
</i>&gt;<i> ``backport.ssl_match_hostname``), and hence would require any replacement
</i>&gt;<i> module to also be bundled within ``pip``. This wouldn't pose any
</i>&gt;<i> insurmountable difficulties (it's just another dependency to vendor), but
</i>&gt;<i> it *would* mean yet another copy of OpenSSL to keep up to date.
</i>&gt;<i>
</i>&gt;<i> This approach also has the same flaw as all other "improve security by
</i>&gt;<i> renaming things" approaches: they completely miss the users who most need
</i>&gt;<i> help, and raise significant barriers against being able to encourage users
</i>&gt;<i> to do the right thing when their infrastructure supports it (since
</i>&gt;<i> "use this other module" is a much higher impact change than "turn on this
</i>&gt;<i> higher security setting"). Deprecating the aging SSL infrastructure in the
</i>&gt;<i> standard library in favour of an external module would be even more user
</i>&gt;<i> hostile than accepting the slightly increased risk of regressions
</i>&gt;<i> associated
</i>&gt;<i> with upgrading it in place.
</i>&gt;<i>
</i>&gt;<i> Last, but certainly not least, this approach suffers from the same problem
</i>&gt;<i> as the idea of doing a Python 2.8 release: likely not solving the actual
</i>&gt;<i> problem. Commercial redistributors of Python are set up to redistribute
</i>&gt;<i> *Python*, and a pre-existing set of additional packages. Getting new
</i>&gt;<i> packages added to the pre-existing set *can* be done, but means approaching
</i>&gt;<i> each and every redistributor and asking them to update their
</i>&gt;<i> repackaging process accordingly. By contrast, the approach described in
</i>&gt;<i> this PEP would require redistributors to deliberately *opt out* of the
</i>&gt;<i> security enhancements by deliberately downgrading the provided network
</i>&gt;<i> security infrastructure, which most of them are unlikely to do.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Rejected variant: provide a "legacy SSL infrastructure" branch
</i>&gt;<i> --------------------------------------------------------------
</i>&gt;<i>
</i>&gt;<i> Earlier versions of this PEP included the concept of a ``2.7-legacy-ssl``
</i>&gt;<i> branch that preserved the exact feature set of the Python 2.7.6 network
</i>&gt;<i> security infrastructure.
</i>&gt;<i>
</i>&gt;<i> In my opinion, anyone that actually wants this is almost certainly making a
</i>&gt;<i> mistake, and if they insist they really do want it in their specific
</i>&gt;<i> situation, they're welcome to either make it themselves or arrange for a
</i>&gt;<i> downstream redistributor to make it for them.
</i>&gt;<i>
</i>&gt;<i> If they are made publicly available, any such rebuilds should be referred
</i>&gt;<i> to
</i>&gt;<i> as "Python 2.7 with Legacy SSL" to clearly distinguish them from the
</i>&gt;<i> official
</i>&gt;<i> Python 2.7 releases that include more up to date network security
</i>&gt;<i> infrastructure.
</i>&gt;<i>
</i>&gt;<i> After the first Python 2.7 maintenance release that implements this PEP, it
</i>&gt;<i> would also be appropriate to refer to Python 2.7.6 and earlier releases as
</i>&gt;<i> "Python 2.7 with Legacy SSL".
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Rejected variant: synchronise particular modules entirely with Python 3
</i>&gt;<i> -----------------------------------------------------------------------
</i>&gt;<i>
</i>&gt;<i> Earlier versions of this PEP suggested synchronising the ``hmac``,
</i>&gt;<i> ``hashlib`` and ``ssl`` modules entirely with their Python 3 counterparts.
</i>&gt;<i>
</i>&gt;<i> This approach proved too vague to build a compelling case for the
</i>&gt;<i> exception,
</i>&gt;<i> and has thus been replaced by the current more explicit proposal.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Rejected variant: open ended backport policy
</i>&gt;<i> --------------------------------------------
</i>&gt;<i>
</i>&gt;<i> Earlier versions of this PEP suggested a general policy change related to
</i>&gt;<i> future Python 3 enhancements that impact the general security of the
</i>&gt;<i> internet.
</i>&gt;<i>
</i>&gt;<i> That approach created unnecessary uncertainty, so it has been simplified to
</i>&gt;<i> propose backport a specific concrete set of changes. Future feature
</i>&gt;<i> backport proposals can refer back to this PEP as precedent, but it will
</i>&gt;<i> still be necessary to make a specific case for each feature addition to
</i>&gt;<i> the Python 2.7 long term support release.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Disclosure of Interest
</i>&gt;<i> ======================
</i>&gt;<i>
</i>&gt;<i> The author of this PEP currently works for Red Hat on test automation
</i>&gt;<i> tools.
</i>&gt;<i> If this proposal is accepted, I will be strongly encouraging Red Hat to
</i>&gt;<i> take
</i>&gt;<i> advantage of the resulting opportunity to help improve the overall security
</i>&gt;<i> of the Python ecosystem. However, I do not speak for Red Hat in this
</i>&gt;<i> matter,
</i>&gt;<i> and cannot make any commitments on Red Hat's behalf.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Acknowledgements
</i>&gt;<i> ================
</i>&gt;<i>
</i>&gt;<i> Thanks to Christian Heimes and other for their efforts in greatly improving
</i>&gt;<i> Python's SSL support in the Python 3 series, and a variety of members of
</i>&gt;<i> the Python community for helping me to better understand the implications
</i>&gt;<i> of the default settings we provide in our SSL modules, and the impact that
</i>&gt;<i> tolerating the use of SSL infrastructure that was defined in 2010
</i>&gt;<i> (Python 2.7) or even 2008 (Python 2.6) potentially has for the security
</i>&gt;<i> of the web as a whole.
</i>&gt;<i>
</i>&gt;<i> Thanks to Donald Stufft and Alex Gaynor for identifying a more limited set
</i>&gt;<i> of essential security features that allowed the proposal to be made more
</i>&gt;<i> fine-grained than backporting entire modules from Python 3.4 [7,8]_.
</i>&gt;<i>
</i>&gt;<i> Christian and Donald also provided valuable feedback on a preliminary
</i>&gt;<i> draft of this proposal.
</i>&gt;<i>
</i>&gt;<i> Thanks also to participants in the python-dev mailing list threads
</i>&gt;<i> [1,2,5,6]_, as well as the various folks I discussed this issue with at
</i>&gt;<i> PyCon 2014 in Montreal.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> References
</i>&gt;<i> ==========
</i>&gt;<i>
</i>&gt;<i> .. [1] PEP 466 discussion (round 1)
</i>&gt;<i>    (<a href="https://mail.python.org/pipermail/python-dev/2014-March/133334.html">https://mail.python.org/pipermail/python-dev/2014-March/133334.html</a>)
</i>&gt;<i>
</i>&gt;<i> .. [2] PEP 466 discussion (round 2)
</i>&gt;<i>    (<a href="https://mail.python.org/pipermail/python-dev/2014-March/133389.html">https://mail.python.org/pipermail/python-dev/2014-March/133389.html</a>)
</i>&gt;<i>
</i>&gt;<i> .. [3] Marc-Andre Lemburg's OpenSSL feedback for Windows
</i>&gt;<i>    (<a href="https://mail.python.org/pipermail/python-dev/2014-March/133438.html">https://mail.python.org/pipermail/python-dev/2014-March/133438.html</a>)
</i>&gt;<i>
</i>&gt;<i> .. [4] Ned Deily's OpenSSL feedback for Mac OS X
</i>&gt;<i>    (<a href="https://mail.python.org/pipermail/python-dev/2014-March/133347.html">https://mail.python.org/pipermail/python-dev/2014-March/133347.html</a>)
</i>&gt;<i>
</i>&gt;<i> .. [5] PEP 466 discussion (round 3)
</i>&gt;<i>    (<a href="https://mail.python.org/pipermail/python-dev/2014-March/133442.html">https://mail.python.org/pipermail/python-dev/2014-March/133442.html</a>)
</i>&gt;<i>
</i>&gt;<i> .. [6] PEP 466 discussion (round 4)
</i>&gt;<i>    (<a href="https://mail.python.org/pipermail/python-dev/2014-March/133472.html">https://mail.python.org/pipermail/python-dev/2014-March/133472.html</a>)
</i>&gt;<i>
</i>&gt;<i> .. [7] Donald Stufft's recommended set of backported features
</i>&gt;<i>    (<a href="https://mail.python.org/pipermail/python-dev/2014-March/133500.html">https://mail.python.org/pipermail/python-dev/2014-March/133500.html</a>)
</i>&gt;<i>
</i>&gt;<i> .. [8] Alex Gaynor's recommended set of backported features
</i>&gt;<i>    (<a href="https://mail.python.org/pipermail/python-dev/2014-March/133503.html">https://mail.python.org/pipermail/python-dev/2014-March/133503.html</a>)
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> Copyright
</i>&gt;<i> =========
</i>&gt;<i>
</i>&gt;<i> This document has been placed in the public domain.
</i>&gt;<i>
</i>&gt;<i> --
</i>&gt;<i> Nick Coghlan   |   <a href="https://mail.python.org/mailman/listinfo/python-dev">ncoghlan at gmail.com</a>   |   Brisbane, Australia
</i>&gt;<i> _______________________________________________
</i>&gt;<i> Python-Dev mailing list
</i>&gt;<i> <a href="https://mail.python.org/mailman/listinfo/python-dev">Python-Dev at python.org</a>
</i>&gt;<i> <a href="https://mail.python.org/mailman/listinfo/python-dev">https://mail.python.org/mailman/listinfo/python-dev</a>
</i>&gt;<i> Unsubscribe:
</i>&gt;<i> <a href="https://mail.python.org/mailman/options/python-dev/guido%40python.org">https://mail.python.org/mailman/options/python-dev/guido%40python.org</a>
</i>&gt;<i>
</i>


-- 
--Guido van Rossum (python.org/~guido)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<a href="http://mail.python.org/pipermail/python-dev/attachments/20140418/d12d80e3/attachment-0001.html">http://mail.python.org/pipermail/python-dev/attachments/20140418/d12d80e3/attachment-0001.html</a>&gt;
</pre>









    <hr/>
    <p/>

<hr/>
<a href="https://mail.python.org/mailman/listinfo/python-dev">More information about the Python-Dev
mailing list</a><br/>
</body></div></body></html>