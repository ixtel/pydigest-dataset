<html><body><div><div class="article-content"><p>Python is a very expressive language. It provides us with a large standard library and many builtins to get the job done quickly. However, many can get lost in the power that it provides, fail to make full use of the standard library, value one liners over clarity and misunderstand its basic constructs. This is a non-exhaustive list of a few of the pitfalls programmers new to Python fall into.</p><div class="section" id="not-knowing-the-python-version"><p>This is a recurring problem in StackOverflow questions. Many write perfectly working code for one version but they have a <em>different</em> version of Python installed on their system.<a class="footnote-reference" href="#pythree" id="id1">[1]</a> Make sure that you know the Python version you're working with. You can check via the following:</p><div class="highlight"><pre><span class="nv">$ </span>python --version
Python 2.7.9
</pre></div><div class="section" id="not-using-a-version-manager"><h3>Not Using a Version Manager</h3><p><a class="reference external" href="https://github.com/yyuu/pyenv">pyenv</a> is a great tool for managing different Python versions. Unfortunately, it only works on *nix systems. On Mac OS, one can simply install it via <code>brew install pyenv</code> and on Linux, there is an <a class="reference external" href="https://github.com/yyuu/pyenv-installer">automatic installer</a>. <a class="footnote-reference" href="#alternative" id="id2">[2]</a></p></div></div><div class="section" id="obsessing-over-one-liners"><p>Some get a <em>real kick</em> out of one liners. Many boast about their one-liner solutions even if they are less efficient than a multi-line solution.</p><p>What this essentially means in Python is convoluted comprehensions having multiple expressions. For example:</p><div class="highlight"><pre><span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">that</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="n">b</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">b</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">method</span><span class="p">(),</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))]</span>
</pre></div><p>To be perfectly honest, I made the above example up. But, I've seen plenty of people write code like it. Code like this will make no sense in a week's time. If you're trying to do something a little more complex that simply adding an item to a <code>list</code> or <code>set</code> with a condition then you're probably making a mistake.</p><p>One-Liners are not achievements, yes they can seem very clever but they are not achievements. Its like thinking that shoving everything into your closet is an actual attempt at cleaning your room. Good code is clean, easy to read and efficient.</p></div><div class="section" id="initializing-a-set-the-wrong-way"><p>This is a more subtle problem that can catch you off guard. <code>set</code> comprehensions are a lot like list comprehensions.</p><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">({</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">})</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">set</span><span class="s">'&gt;</span>
</pre></div><p>The above is one such example of a set comprehension. Sets are like lists in that they are containers. The difference is that a set cannot have any duplicate values and sets are unordered. Seeing set comprehensions people often make the mistake of thinking that <code>{}</code> initializes an <em>empty</em> set. It does not, it initializes an empty <em>dict</em>.</p><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="p">{}</span>
<span class="p">{}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">({})</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">dict</span><span class="s">'&gt;</span>
</pre></div><p>If we wish to initialize an empty set, then we simply call <code>set()</code>.</p><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="nb">set</span><span class="p">()</span>
<span class="nb">set</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="nb">set</span><span class="p">())</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">set</span><span class="s">'&gt;</span>
</pre></div><p>Note how an empty set is denoted as <code>set()</code> but a set containing something is denoted as items surrounded by curly braces.</p><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span>
<span class="nb">set</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span>
<span class="p">{</span><span class="mi">1</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span>
<span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
</pre></div><p>This is rather counter intuitive, since you'd expect something like <code>set([1, 2])</code>.</p></div><div class="section" id="misunderstanding-the-gil"><p>The GIL (Global Interpreter Lock) means that only one thread in a Python program can be running at any one time. This implies that when we create a thread and expect to run in <em>parallel</em> it doesn't. What the Python interpreter is actually doing is quickly <em>switching</em> between different running threads. But this is an oversimplified version of what is actually happening. There are many instances in which things <em>do</em> run in parallel, like when using libraries that are essentially C extensions. But when running Python code, you don't get parallel execution <em>most</em> of the time. In other words, threads in Python are not like Threads in Java or C++.</p><p>Many will try to defend Python by saying that these are <em>real</em> threads.<a class="footnote-reference" href="#realthreads" id="id3">[3]</a> This is indeed true, but does not change the fact that how Python handles threads is different from what you'd generally expect. This is the same case for a language like Ruby (which also has an interpreter lock).</p><p>The prescribed solution to this is using the <code>multiprocessing</code> module. The <code>multiprocessing</code> module provides you with the <code>Process</code> class which is basically a nice cover over a fork. However, a fork is much more expensive than a thread, so you might not always see the performance benefits since now the different processes have to do a lot of work to co-ordinate with each other.</p><p>However, this problem does not exist every <em>implementation</em> of Python. <a class="reference external" href="http://pypy.readthedocs.org/en/latest/stm.html">PyPy-stm</a> for example is an implementation of Python that tries to get rid of the GIL (still not stable yet). Implementations built on top of other platforms like the JVM (Jython) or CLR (IronPython) do not have GIL problems.</p><p>All in all, be careful when using the <code>Thread</code> class, what you get might not be what you expect.</p></div><div class="section" id="using-old-style-classes"><p>In Python 2 there are two types of classes, there's the "old style" classes, and there's the "new style" classes. If you're using Python 3, then you're using the "new style" classes by default. In order to make sure that you're using "new style" classes in Python 2, you need to inherit from <code>object</code> for <em>any</em> new class you create that isn't already inheriting from a builtin like <code>int</code> or <code>list</code>. In other words, your base class, the class that isn't inheriting from anything else, should always inherit from object.</p><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyNewObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c"># stuff here</span>
</pre></div><p>These "new style" classes fix some very fundamental flaws in the old style classes that we really don't need to get into. However, if anyone is interested they can find the information in the <a class="reference external" href="https://docs.python.org/2/reference/datamodel.html#new-style-and-classic-classes">related documentation</a>.</p></div><div class="section" id="iterating-the-wrong-way"><p>Its very common to see the following code from users who are relatively new to the language:</p><div class="highlight"><pre><span class="k">for</span> <span class="n">name_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">name_index</span><span class="p">])</span>
</pre></div><p>There is no need to call <code>len</code> in the above example, since iterating over the list is actually much simpler:</p><div class="highlight"><pre><span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div><p>Furthermore, there are a whole host of other tools at your disposal to make iteration easier. For example, <code>zip</code> can be used to iterate over two lists at once:<a class="footnote-reference" href="#zip" id="id4">[4]</a></p><div class="highlight"><pre><span class="k">for</span> <span class="n">cat</span><span class="p">,</span> <span class="n">dog</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cats</span><span class="p">,</span> <span class="n">dogs</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">dog</span><span class="p">)</span>
</pre></div><p>If we want to take into consideration both the index <em>and</em> the value list variable, we can use <code>enumerate</code>:<a class="footnote-reference" href="#enumerate" id="id5">[5]</a></p><div class="highlight"><pre><span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">cat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cats</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div><p>There are also many useful functions to choose from in <a class="reference external" href="https://docs.python.org/3/library/itertools.html">itertools</a>. Please note however, that using <code>itertools</code> functions is not always the right choice. If one of the functions in <code>itertools</code> offers a very convenient solution to the problem you're trying to solve, like flattening a list or creating a getting the permutations of the contents of a given list, then go for it. But <em>don't</em> try to fit it into some part of your code just because you want to.</p><p>The problem with <code>itertools</code> abuse happens so often that one highly respected Python contributor on StackOverflow has dedicated a significant part of their profile to it.<a class="footnote-reference" href="#abarnert" id="id6">[6]</a></p></div><div class="section" id="using-mutable-default-arguments"><p>I've seen the following quite a lot:</p><div class="highlight"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">[]):</span>
    <span class="c"># append to c</span>
    <span class="c"># do some more stuff</span>
</pre></div><p>Never use mutable default arguments, instead use the following:</p><div class="highlight"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># append to c</span>
    <span class="c"># do some more stuff</span>
</pre></div><p>Instead of explaining what the problem is, its better to show the effects of using mutable default arguments:</p><div class="highlight"><pre><span class="n">In</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">[]):</span>
<span class="o">...</span>     <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">...</span>     <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">In</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">In</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">In</span><span class="p">[</span><span class="mi">5</span><span class="p">]:</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div><dl class="docutils"><dt>The same <code>c</code> is being referenced again and again every time the function is called. This can have some very</dt><dd>unwanted consequences.</dd></dl></div><div class="section" id="takeaway"><p>These are just some of the problems that one might run into when relatively new at Python. Please note however, that this is far from a comprehensive list of the problems that one might run into. The other pitfalls however are largely to do with people using Python like Java or C++ and trying to use Python in a way that they are familiar with. So, as a continuation of this, try diving into things like Python's <code>super</code> function. Take a look at <code>classmethod</code>, <code>staticmethod</code> and <code>__slots__</code>.</p></div><div class="section" id="update"><p><em>Last Updated on 12 May 2015 4:50 PM (GMT +6)</em></p><hr class="docutils"/></div></div></div></body></html>