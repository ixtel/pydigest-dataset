<html><body><div><div class="entry-content">

                

                <p>Осторожно, МАТАН!!!</p>
<p>По-простому, <strong>преобразование Фурье</strong> — разложение некоторого сигнала на гармонические (синусы или косинусы) колебания (спектр). </p>
<p>Если вы осознанно употребляете слово "частота", вы уже хотя бы интуитивно представляете, что такое преобразование Фурье. Даже в наших ушах есть хардверный анализатор Фурье (улитка) (а также продвинутые драйвера в мозгу), благодаря которому мы различаем голоса, ноты, тембры... Призма раскладывает белый свет на цвета радуги — это тоже Фурье-анализатор. Форматы mp3 и jpeg в своих алгоритмах содержат преобразование Фурье (одномерное и двухмерное, соответственно) для сжатия информации. В природе и технике есть тысячи примеров... Также есть обратное преобразование Фурье, переводящее "частоты" и "амплитуды" в "сигнал", математически очень похожее на прямое.</p>
<p><img alt="Image" src="http://old.pynsk.ru/images/posts/matan_1.jpg"/></p>
<p>Преобразование Фурье является <strong>интегральным преобразованием</strong>. </p>
<p>Если речь идёт о дискретном сигнале, то интеграл обращается в сумму (и становится <code>дискретным преобразованием Фурье, ДПФ</code>). Беда в том, что, чтобы посчитать такую сумму <code>N</code> элементов, надо совершить <code>N^2</code> операций с комплексными числами. Но кто-то очень умный давно (<code>Cooley, Tukey, 1965 г</code>, а ещё сам <code>Гаусс в 1805 г.</code>) придумал алгоритм, вычисляющий <code>ДПФ</code> <code>N</code> элементов в <code>N*log(N)</code> операций (большая часть из которых над действительными числами), что существенно экономит вычислительное время — быстрое преобразование Фурье, БПФ (<code>Fast Fourier Transform, FFT</code>). Именно так реализовано ДПФ в современных компьютерных программах.</p>
<p>В библиотеке <code>numpy</code> содержится всё что нужно для дискретного преобразования Фурье. Всё это лежит в <code>numpy.fft</code>. Вот эти функции.</p>
<p>Общий случай: сигнал может быть как из действительных чисел, так и из комплексных.</p>
<div class="highlight"><pre>fft(a, n=None, axis=-1) — прямое одномерное ДПФ.
ifft(a, n=None, axis=-1) — обратное одномерное ДПФ.
</pre></div>


<p><code>a</code> — "сигнал", входной массив (массив <code>numpy</code>, <code>array</code> или даже питоновский <code>список</code> или <code>кортеж</code>, если в нём только числа). Массив может быть и многомерным, тогда будет вычисляться много <code>ОДНОМЕРНЫХ ПФ</code> по строкам (по умолчанию) или столбцам, в зависимости от параметра axis. Например, <code>a</code> — двухмерный, <code>a[n][m]</code>: при <code>axis=1</code> или <code>-1</code> будет такое (под <code>fourier(a...)</code> понимается результат действия ПФ на <code>a</code>):</p>
<div class="highlight"><pre><span class="k">[fourier(a[0][j]), fourier(a[1][j]), ... foirier(a[n][j])]</span>
<span class="na">При axis</span><span class="o">=</span><span class="s">0 такое:</span>
<span class="k">[fourier(a[i][0]), fourier(a[i][1]), ... foirier(a[i][m])]</span>
</pre></div>


<p><code>n</code> — сколько элементов массива брать. Если меньше длины массива, то обрезать, если больше, то дополнить нулями, по умолчанию <code>len(a)</code>.</p>
<div class="highlight"><pre>fft2(a, s=None, axes=(-2, -1)) — прямое двухмерное ПФ.
ifft2(a, s=None, axes=(-2, -1)) — обратное двухмерное ПФ.
fftn(a, s=None, axes=None) — прямое многомерное ПФ.
ifftn(a, s=None, axes=None) — обратное многомерное ПФ.
</pre></div>


<p>Всё так же, как и для одномерных, но s и axes теперь кортежи для каждой размерности. О размерности <code>fftn</code>, <code>ifftn</code> догадаются по размерности входных массивов или <code>s</code> и <code>axes</code>.</p>
<p>Когда сигнал действительный (<code>real</code>) (пожалуй, самый распространённый случай).</p>
<div class="highlight"><pre>rfft(a, n=None, axis=-1) — прямое одномерное ДПФ (для действительных чисел).
irfft(a, n=None, axis=-1) — обратное одномерное ДПФ.
rfft2(a, s=None, axes=(-2, -1)) — прямое двухмерное ДПФ.
irfft2(a, s=None, axes=(-2, -1)) — обратное двухмерное ДПФ.
rfftn(a, s=None, axes=None) — прямое многомерное ДПФ.
irfftn(a, s=None, axes=None) — обратное многомерное ДПФ.
</pre></div>


<p>Всё так же, как и для общего случая.</p>
<p>Все эти функции возвращают массив соответствующей размерности, в котором записан результат <code>ДПФ</code>. <em>Разница такая</em>. Если длина входного массива (или какой-либо его размерности) <code>N</code>, то в общем случае (с комплексным сигналом) длина выходного массива <code>N</code>. </p>
<p>Там содержатся сначала положительные частоты от нуля до частоты Котельникова (Найквиста), потом отрицательные в порядке возрастания.</p>
<p>В случае действительного сигнала отрицательные частоты полностью симметричны положительным, и тогда нет нужды их записывать: длина выходного массива <code>N/2+1</code>, частоты от нуля до частоты Котельникова.</p>
<p>Если спектр сигнала действительный (а сигнал обладает "эрмитовой симметрией": его половины симметричны относительно центра по модулю и являются комплексно сопряжёнными друг другу), то можно применить такие функции:</p>
<div class="highlight"><pre>hfft(a, n=None, axis=-1) — прямое одномерное ДПФ.
ihfft(a, n=None, axis=-1) — обратное одномерное ДПФ.
</pre></div>


<p>Длина входного массива <code>N</code>, а выходного <code>2*N+1</code>.</p>
<p>Кроме того, есть вспомогательные функции (будет понятнее из примера):</p>
<div class="highlight"><pre>fftfreq(n, d=1.0) — возвращает частоты для выходных массивов функций fft*.
rfftfreq(n, d=1.0) — возвращает частоты для выходных массивов функций rfft*.
n — длина входного массива, d — период дискретизации (обратная частота дискретизации).
fftshift(x, axes=None) — преобразует массив (с результатом ДПФ, от функций fft*) так, чтобы нулевая частота была в центре.
ifftshift(x, axes=None) — делает обратную операцию.
</pre></div>


<p>Приведём такой пример. Допустим, записали мы микрофоном какой-то шум, и надо определить, есть ли там какой-нибудь тон.</p>
<div class="highlight"><pre><span class="ch">#!/usr/bin/env python</span>
<span class="c1">#coding=utf8</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">arange</span><span class="p">,</span> <span class="nb">abs</span> <span class="k">as</span> <span class="n">np_abs</span>
<span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="kn">import</span> <span class="n">rfft</span><span class="p">,</span> <span class="n">rfftfreq</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">uniform</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">pi</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="c1"># а можно импортировать numpy и писать: numpy.fft.rfft</span>
<span class="n">FD</span> <span class="o">=</span> <span class="mi">22050</span> <span class="c1"># частота дискретизации, отсчётов в секунду</span>
<span class="c1"># а это значит, что в дискретном сигнале представлены частоты от нуля до 11025 Гц (это и есть теорема Котельникова)</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">2000</span> <span class="c1"># длина входного массива, 0.091 секунд при такой частоте дискретизации</span>
<span class="c1"># сгенерируем сигнал с частотой 440 Гц длиной N</span>
<span class="n">pure_sig</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mf">6.</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="mf">440.0</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">FD</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>
<span class="c1"># сгенерируем шум, тоже длиной N (это важно!)</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">50.</span><span class="p">,</span><span class="mf">50.</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="c1"># суммируем их и добавим постоянную составляющую 2 мВ (допустим, не очень хороший микрофон попался. Или звуковая карта или АЦП)</span>
<span class="n">sig</span> <span class="o">=</span> <span class="n">pure_sig</span> <span class="o">+</span> <span class="n">noise</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="c1"># в numpy так перегружена функция сложения</span>
<span class="c1"># вычисляем преобразование Фурье. Сигнал действительный, поэтому надо использовать rfft, это быстрее, чем fft</span>
<span class="n">spectrum</span> <span class="o">=</span> <span class="n">rfft</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>

<span class="c1"># нарисуем всё это, используя matplotlib</span>
<span class="c1"># Сначала сигнал зашумлённый и тон отдельно</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">FD</span><span class="p">),</span> <span class="n">sig</span><span class="p">)</span> <span class="c1"># по оси времени секунды!</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">FD</span><span class="p">),</span> <span class="n">pure_sig</span><span class="p">,</span> <span class="s1">'r'</span><span class="p">)</span> <span class="c1"># чистый сигнал будет нарисован красным</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">u'Время, c'</span><span class="p">)</span> <span class="c1"># это всё запускалось в Python 2.7, поэтому юникодовские строки</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">u'Напряжение, мВ'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">u'Зашумлённый сигнал и тон 440 Гц'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># когда закроется этот график, откроется следующий</span>
<span class="c1"># Потом спектр</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="n">FD</span><span class="p">),</span> <span class="n">np_abs</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">)</span>
<span class="c1"># rfftfreq сделает всю работу по преобразованию номеров элементов массива в герцы</span>
<span class="c1"># нас интересует только спектр амплитуд, поэтому используем abs из numpy (действует на массивы поэлементно)</span>
<span class="c1"># делим на число элементов, чтобы амплитуды были в милливольтах, а не в суммах Фурье. Проверить просто — постоянные составляющие должны совпадать в сгенерированном сигнале и в спектре</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">u'Частота, Гц'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">u'Напряжение, мВ'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">u'Спектр'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>


<p><img alt="Image" src="http://old.pynsk.ru/images/posts/matan_2.png"/>
<img alt="Image" src="http://old.pynsk.ru/images/posts/matan_3.png"/></p>
<p>Ссылки для изучения:</p>

            </div>
            
    </div></body></html>