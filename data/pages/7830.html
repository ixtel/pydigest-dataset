<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/files/efa/035/436/efa035436cca4b3a9f41d64e195f9f69.jpg"/>
<p>
В одной из своих статей я рассказывал об </p><a href="http://habrahabr.ru/company/mailru/blog/254727/">асинхронной работе с Tarantool на Python</a><p>. В данной статье продолжу эту тему, но внимание хочу уделить обработке информации через очереди на </p><a href="http://tarantool.org/">Tarantool</a><p>. Мои коллеги опубликовали несколько статей о пользе очередей (</p><a href="http://habrahabr.ru/company/mailru/blog/228131/">Инфраструктура обработки очередей в социальной сети Мой Мир</a><p> и </p><a href="http://habrahabr.ru/company/mailru/blog/232981/">Push-уведомления в REST API на примере системы Таргет Mail.Ru</a><p>). Хочу дополнить информацию об очередях на примере решений наших задач, а также рассказать о работе с </p><a href="https://github.com/tarantool/queue/">Tarantool Queue</a><p> на Python и asyncio. Почему мы выбираем именно Tarantool, а не Redis или RabbitMQ?
</p><a name="habracut"/>
<h1>Задача о рассылке сообщений «по всей базе пользователей»</h1><p>
На Mail.Ru существует множество медийных сайтов: </p><a href="https://news.mail.ru/">Новости</a><p>, </p><a href="https://auto.mail.ru/">Авто</a><p>, </p><a href="https://lady.mail.ru/">Леди</a><p>, </p><a href="https://health.mail.ru/">Здоровье</a><p>, </p><a href="https://hi-tech.mail.ru/">Hi-Tech</a><p> и т.д., и каждый день их посещают миллионы пользователей. Сайты адаптированы для мобильных устройств, для большинства из них существует touch-версия. Для удобства пользователей мы создали </p><a href="https://news.mail.ru/app/">мобильное приложение Новости</a><p>, которое пользуется популярностью на Android- и iOS-устройствах. После публикации «горячей» новости каждому пользователю нашего приложения поступает пуш-уведомление. Выглядит это обычно так: главный редактор выбирает новость, нажимает в админке кнопку «Огонь», и все — поехали! А что же дальше? Дальше нужно как можно быстрее разослать эту новость по всей базе подписчиков. Если кто-то получит пуш-уведомление через полчаса, то, возможно, новость будет уже не такой «горячей», и пользователь узнает о ней из другого источника. Это не наш случай.
</p><p>
Итак, есть база данных, которая хранится в нашем любимом Tarantool. Нужно как можно быстрее обойти всю базу и отправить пуш-уведомление всем подписчикам. Для каждого из них в базе данных хранится пуш-токен и немного информации об устройстве в json-формате: версия приложения, разрешение экрана, часовой пояс, интервал времени, в котором пользователь хочет получать уведомления. Указание часового пояса очень важно, ведь рассылать пуш-уведомления по ночам, когда все спят, не очень хорошая идея.
</p><p>
С требованиями все ясно, идем дальше.

</p><h1>Решаем задачу</h1><p>
Обычно решать задачу мы начинаем в лоб, по-простому. Простой код выглядит всегда очень красиво и понятно:

</p><pre><code class="html">while «Есть пользователи»:
    Выбрать «пачку» пользователей
    Отправить пуш-уведомление каждому пользователю из «пачки»
</code></pre><p>
Основной цикл </p><code>while</code><p> будет выполняться до тех пор, пока он не обойдет всех пользователей. Если база пользователей небольшая, то дальше можно ничего не делать, задача решена. Что здесь можно улучшить? Как ускорить такой цикл? Как рассылать за фиксированное время вне зависимости от размера базы данных? Для этого нужно уточнить детали процесса отправки уведомлений.
</p><p>
Для простоты остановлюсь на двух платформах Android и iOS. Что же такое «отправить пуш»? Как это сделать? Есть описание протоколов </p><a href="https://developers.google.com/cloud-messaging/http?hl=ru">Google Cloud Messaging</a><p> и </p><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html">Apple Push Notification Service</a><p>. Есть готовые библиотеки для отправки пуш-уведомлений в </p><a href="https://pypi.python.org/pypi/gcm-client/">Android</a><p> и </p><a href="https://pypi.python.org/pypi/apns/2.0.1">iOS</a><p> на Python, предназначенные для работы в привычном «синхронном» режиме. Если копнуть глубже, то каждая платформа обладает своей спецификой. Пуш в Android — это отправка json-данных по https, в iOS — отправка бинарных данных в ssl-сокет. Apple скоро обещает поддержку протокола HTTP/2. Под Android возможна отправка нескольким адресатам. В iOS имеется возможность группировки нескольких пользователей и отправки уведомлений группе. То есть группировка для каждой платформы также имеет свои особенности.
</p><p>
Явно напрашивается решение с очередями. Хочется разделить процесс выборки пользователей из базы данных и процесс рассылки уведомлений по платформам. Но есть много важных деталей. Для независимости процесса отправки одной платформы от другой мы можем разделить пользователей из выбранной «пачки» на iOS и Android, сгруппировать пользователей и добавить сообщение на отправку в нужную нам очередь. Далее сообщения можно обработать, то есть выполнить непосредственно саму работу по отправке пуш-уведомлений. Схематично все эти процессы можно представить так:

</p><img src="https://habrastorage.org/files/6fe/28b/a5f/6fe28ba5f0cc42d3a85a68abdfb85c5e.png"/><p>
Схема обхода базы пользователей и обработки сообщений через очередь
</p><p>
Что даст такой подход? Мы отделим процесс обхода базы пользователей от рассылки пуш-уведомлений. Таким образом, начнем быстрее перебирать (выполнять </p><code>select_range</code><p>) «пачки» в нашем исходном цикле. Если при обработке сообщений по одной из платформ мы столкнемся с потенциальными проблемами (а такие бывают достаточно часто), то это никак не повлияет на рассылку по другой платформе. Таким образом, сможем легко распараллелить обработку сообщений по ядрам сервера, ведь у нас теперь есть логические очереди. Если понадобится немного расширить нашу систему, то мы просто добавим новые логические очереди.

</p><h1>Решаем проблемы с нагрузкой и масштабированием</h1><p>
С увеличением нагрузки на одном сервере быстро закончится CPU. Добавляем еще один сервер? Да, в точности такой же. Но лучше это сделать еще на этапе проектирования сервиса. Если заставить работать систему на двух серверах, то добавить еще пару десятков не составит труда. Мы придерживаемся этого принципа: минимум два сервера, даже когда нет настоящей нагрузки. Несколько серверов также повысят надежность сервиса. Архитектура сервиса принимает следующий вид:

</p><img src="https://habrastorage.org/files/ec3/a7f/124/ec3a7f124647429ea4f22fee8e7ed654.png"/><p>
Схема обхода базы пользователей на двух серверах
</p><p>
Итак, мы имеем два сервера, на каждом из которых свои очереди (еще, конечно же, есть база пользователей, считаем, что она просто есть где-то рядом, доступна для выполнения </p><code>select_range</code><p>, не будем уделять этому много внимания). Очень важно запустить цикл обхода параллельно на двух серверах. Можно итерироваться по нашему циклу на одном из серверов, выбирать «пачки», каждую «пачку» помещать в разные очереди, равномерно распределять «пачки» по всем серверам. При таком подходе мы будем вынуждены «гонять» данные по сети. Выбрать «пачку» и положить ее в очередь на другой сервер — слабая сторона такого подхода. Нужно распараллелить </p><code>select_range</code><p> по серверам.
</p><p>
Для этого на одном из серверов необходимо выбрать «пачку», в очередь на «соседнем» сервере добавить маленькое сообщение с информацией о последнем id-пользователя из текущей «пачки». При обработке маленького сообщения на втором сервере мы должны получить «новую пачку» начиная с указанного id, сформировать аналогичное сообщение «серверу-соседу», и т.д., пока не переберем всю базу. Текущую «пачку» нужно всегда обрабатывать локально в своей очереди. Таким образом, мы «как бы» переместим код к нашим данным, распараллелим генерацию «пачек» по серверам и не будем гонять данные по сети.
</p><p>
Диаграмма последовательности будет выглядеть так:
 
</p><img src="https://habrastorage.org/files/ef8/283/46d/ef828346d95c4d98b92fbe991b36889e.png"/>
<p>
Цикл «по всем пользователям» делается неявно через </p><code>queue.put(last_id)</code><p>. Процесс рассылки завершится после того, как в </p><code>select_range</code><p> закончатся пользователи. Очень важно, что в схеме рассылки отсутствуют какие-либо блокировки в БД. Эта схема очень похожа на процесс MapReduce в Hadoop, тот же принцип «Разделяй и властвуй».
</p><p>
Точно такая же архитектура применяется и в нашем продакшен. Для каждого типа мобильного приложения и платформы используются отдельные логические очереди, что позволяет добиваться независимого параллельного выполнения процессов. Рассылка пуш-уведомлений для новости по нашей боевой 2-миллионной базе пользователей занимает около 2 минут. Одновременно с такими рассылками кластер из восьми серверов отправляет около 10 тыс. пуш-уведомлений в секунду.

</p><h1>Особенности написания кода для Tarantool Queue</h1><p>
Как работать с большим количеством логических очередей? Как одновременно разгребать и генерировать данные для всех очередей в одном Python-процессе? На помощь приходят асинхронные приемы в программировании. В примерах я буду использовать Centos 6.4, Python 3, asyncio, </p><a href="https://github.com/shveenkov/aiotarantool-queue-python">aiotarantool_queue</a><p>, Tarantool 1.6 и Tarantool Queue.
</p><p>
Очередь Tarantool Queue выдерживает достаточно большие нагрузки. Есть </p><a href="https://github.com/tarantool/queue">описание</a><p> на GitHub. В одном инстансе с Tarantool Queue можно создать несколько логических очередей при помощи вызова </p><code>queue.create_tube</code><p>. Логические очереди называются tube (тьюбы). Поддерживается несколько типов логических очередей. В Tarantool Queue имеется механизм </p><code>take/ack</code><p>. Вызов </p><code>take</code><p> помечает таск как «в работе». Вызов </p><code>ack</code><p> удаляет таск из очереди, подтверждая таким образом его успешное выполнение. Если дело не дойдет до вызова </p><code>ack</code><p>, то другой процесс «подхватит» таск и выполнит </p><code>take</code><p>. Можно на какое-то время отложить выполнение таска при помощи параметра </p><code>delay</code><p>. Таким функционалом и производительностью обладает не каждая очередь.
</p><p>
Использование Tarantool как для хранилища пользователей, так и для системы очередей делает наш сервис простым в плане используемых технологий. Использовать Tarantool Queue вовсе не обязательно. Tarantool и Lua предоставляют возможность для реализации собственной очереди.
</p><p>
Устанавливаем Tarantool, размещаем </p><a href="https://github.com/tarantool/queue">github.com/tarantool/queue</a><p> в каталоге /usr/local/lua. В конфиге Tarantool /etc/tarantool/instances.enabled/q1.lua указываем:

</p><pre><code class="python">#!/usr/bin/env tarantool

package.path = package.path .. ';/usr/local/lua/tarantool-queue/?.lua'
box.cfg{listen = 3301, slab_alloc_arena = 2}
queue = require 'queue'
queue.start()
box.queue = queue
</code></pre><p>
Стартуем наш инстанс с очередью:

</p><pre><code class="bash">tarantoolctl start q1
</code></pre><p>
Заходим в консоль:

</p><pre><code class="bash"># tarantoolctl enter q1
/usr/bin/tarantoolctl: Connecting to /var/run/tarantool/q1.control
/usr/bin/tarantoolctl: connected to unix/:/var/run/tarantool/q1.control
unix/:/var/run/tarantool/q1.control
</code></pre><p>
Разрешаем гостевой доступ и создаем логическую очередь </p><code>q1</code><p>:

</p><pre><code class="bash">q1.control&gt; box.schema.user.grant('guest','read,write,execute','universe')
q1.control&gt; queue.create_tube('q1', 'fifo')
^D
</code></pre><p>
Разгребать одну очередь можно так:

</p><pre><code class="python">queue = Tarantool.Queue(host="localhost", port=3301)
while True:
    task = queue.take(tube="q1")
    process(task)
    task.ack()
</code></pre><p>
Для того чтобы разгребать N очередей, можно создать N процессов. В каждом процессе необходимо выполнить connect к нужной очереди и запустить точно такой же цикл. Вполне рабочий подход, но если очередей много, то будет много коннектов к Tarantool Queue. Также будет запущено множество процессов, потребляющих физическую память сервера. Ну и «много коннектов» не делает работу с Tarantool настолько эффективной, насколько она может быть. Также в процессах придется держать коннекты к серверам Google и Apple. И опять же, чем меньше коннектов к серверам Google или Apple мы держим, тем меньше мы их нагружаем, тем больше ресурсов нашего сервера нам доступно.
</p><p>
В статье «Асинхронная работа с Tarantool на Python» я подробно рассказывал, почему обращение в один коннект к Tarantool может дать заметный прирост производительности (это очень важно для наших нагрузок). Данный подход можно применить и здесь. Немного модифицируем наш исходный псевдо-код для разгребания очереди. Адаптируем его под asyncio.

</p><pre><code class="python">import asyncio
import aiotarantool_queue
 
@asyncio.coroutine
def worker(tube):
    while True:
        task = yield from tube.take(.5)
        if not task:
            break
        # process(task.data)
        yield from task.ack()

loop = asyncio.get_event_loop()
queue = aiotarantool_queue.Queue("127.0.0.1", 3301, loop=loop)

workers = [asyncio.async(worker(tube), loop=loop)
           for tube in (queue.tube('q1'), queue.tube('q2'), queue.tube('q3'))]

loop.run_until_complete(asyncio.wait(workers))
loop.run_until_complete(queue.close())
loop.close()
</code></pre><p>
В одном процессе создаем коннект к очереди. Создаем корутины с циклом take/ack для всех логических очередей. Запускаем event loop и разгребаем все наши очереди. Так выглядит наш паттерн работы с очередями.
</p><p>
Хочется отметить, что код остался линейным, нет никаких callbacks. Также «под капотом» этого кода скрыто то, что таски из очереди будут вычитываться «пачками» — все это дает из коробки </p><code>aiotarantool_queue</code><p>. И никаких ожиданий, пуллинга очередей и таймаутов! Круто? Для загрузки всех ядер сервера по CPU, конечно, придется сделать несколько таких процессов, но это уже дело техники. Обработка очередей на Python-процессах выглядела бы примерно так же. Вместо корутин были бы процессы. А при синхронном подходе код мог бы получиться еще более запутанным, и самое главное — не таким производительным.
</p><p>
Но есть и минусы использования asyncio. Нужно заставить работать сторонние библиотеки, что не так сложно сделать, но придется внимательно просмотреть код этих библиотек и адаптировать их работу при помощи вызовов asyncio. Если нам нужен производительный сервис, то все старания по поддержке работы сторонних библиотек под asyncio будут оправданы.

</p><h1>А как же Redis и RabbitMQ?</h1><p>
Почему мы используем Tarantool Queue, а не Redis или RabbitMQ? Выбор в пользу того или иного продукта сделать не так просто — мы рассматривали и Redis, и RabbitMQ. Даже был прототип на Redis. Все эти решения обладают достаточно хорошей производительностью. Но тут дело не только в том «кто быстрее»…
</p><p>
Прежде всего, хочется, чтобы очередь была надежной, и находилась не в памяти. Tarantool с его WAL выглядит надежнее, чем Redis и RabbitMQ.
</p><p>
Каждая из систем очередей обладает своими особенностями. В Redis есть механизм pub/sub, а он не подходит для решения наших задач — нам нужна именно очередь. В Redis есть списки и операции rpush/blpop с блокировкой и ожиданием появления данных, однако нет механизма take/ack. В нашем продакшен надежность обеспечивается именно этим механизмом — он не раз проявлял себя с лучшей стороны.
</p><p>
RabbitMQ богат различными паттернами для очередей. Для решения наших задач требуется лишь часть функционала RabbitMQ. Его производительность действительно очень высокая, однако если включить сохранение данных на диск, то производительность при нагрузке сильно падает. Для эксплуатации RabbitMQ нужны опытные системные администраторы, которые смогут диагностировать проблемы в продакшен, а не просто порестартить инстанс RabbitMQ.
</p><p>
Отдельного внимания у RabbitMQ заслуживает его Python API и коннектор для asyncio. API для очередей реализовано на callback-ах. Код от callback-ов становится сложным и тяжело поддерживаемым. Чтобы сделать message.ack в asyncio, нужно создать </p><a href="https://github.com/Polyconseil/aioamqp/blob/master/aioamqp/tests/test_basic.py#L114">Future и дождаться ее</a><p>. Такой код выглядит очень сложно. Также у нас не получилось отправить несколько put/take в один коннект.
</p><p>
У Redis с asyncio все гораздо лучше: есть прекрасный коннектор от автора самого asyncio. Работает действительно быстро.
</p><p>
В Redis и в RabbitMQ отсутствует такая интеграция данных в БД и lua, как у Tarantool. Как правило, задачи на продакшен требуют от очереди чуть больше «логики» из коробки. А в Tarantool этого легко добиться благодаря lua. Например, можно начать хранить счетчики или кеш с данными, или статистику прямо на инстансах с очередями. Все это делает Tarantool удобным для решения различных задач.

</p><h1>Подводим итоги</h1><p>
Мы рассмотрели архитектуру того, как максимально быстро и эффективно распараллелить обход всей базы пользователей с помощью системы очередей на нескольких серверах. Мы рассмотрели паттерны использования Tarantool Queue и asyncio. Уделили внимание проблемам разработки кода с использованием систем очередей. Рассмотрели проблемы RabbitMQ и Redis, а также преимущества Tarantool Queue.
</p><p>
Надеюсь, информация окажется полезной для читателей Хабра. Буду рад, если кто-то поделится своими кейсами применения очередей и расскажет о причинах выбора того или иного решения.
</p><p>
Ссылки, используемые при написании статьи:
</p>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>