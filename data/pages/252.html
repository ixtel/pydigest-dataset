<html><body><div><div class="md"><p>Any metaclass has the capacity to completely change the class you're defining. It can be confusing and counter-intuitive, and generally people tend to overdo it when they use them.</p>

<p>For example, take the Django ORM. Say you have <code>myapp/models.py</code> like so:</p>

<pre><code>class Foo(models.Model):
    bar = models.CharField(max_length=25)
</code></pre>

<p>Then go into <code>manage.py shell</code>. Let's pretend you want to access the <code>max_length</code> property you set in that constructor.</p>

<pre><code>&gt;&gt;&gt; from myapp.models import Foo
&gt;&gt;&gt; Foo.bar.max_length
Traceback (most recent call last):
  File "&lt;console&gt;", line 1, in &lt;module&gt;
AttributeError: type object 'Foo' has no attribute 'bar'
</code></pre>

<p>Meanwhile, in a world without metaclasses:</p>

<pre><code>&gt;&gt;&gt; class Foo(object):
...   bar = CharField(max_length=25)
... 
&gt;&gt;&gt; Foo.bar.max_length
25
</code></pre>

<p>The <code>Model</code> metaclass 'undefines' all the attributes you set in your class definition. The Django team came up with the <code>_meta</code> field to let you access the <code>CharField</code> instance, should you need to. In Python, a leading underscore indicates that you probably shouldn't touch whatever it is you're looking at (as a substitute for something like <code>private</code> in Java). But nevertheless the Django <code>Foo._meta</code> attribute is your only way to do introspection.</p>

<p>This attribute also doesn't seem to be documented on the Django website.</p>

<p>So you launch the interpreter, do <code>dir(Foo._meta)</code>, and see two methods of interest: <code>get_field</code> and <code>get_field_by_name</code>. Well, if one of them takes the name I can't imagine what the other is supposed to take.</p>

<pre><code>&gt;&gt;&gt; Foo._meta.get_field_by_name('bar')
(&lt;django.db.models.fields.CharField: bar&gt;, None, True, False)
</code></pre>

<p>...my poor brain.</p>

<p>So your first time out you might write this:</p>

<pre><code>Foo._meta.get_field_by_name('bar')[0].max_length
</code></pre>

<p>instead of code logically implied by the class definition:</p>

<pre><code>Foo.bar.max_length
</code></pre>

<p>It turns out <code>get_field</code> <em>also</em> takes the field name as the argument, and doesn't return a garbage tuple, so the seasoned Django developer might write</p>

<pre><code>Foo._meta.get_field('bar').max_length
</code></pre>

<p>which is less absurd, but still pointlessly convoluted.</p>

<p>So I'm more averse to the usage by other people as opposed to the functionality in general. Ultimately metaclasses tend to contradict the Python maxim that "explicit is better than implicit" (see <code>&gt;&gt;&gt; import this</code>).</p>

<p>And of course there are some situations where metaclasses really shine. But just, please, sparingly. When there is no other sensible option.</p>
</div>
</div></body></html>