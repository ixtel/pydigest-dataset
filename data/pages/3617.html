<html><body><div><div class="ArticleText">
<p class="FeatureByline">
           By <b>Jake Edge</b><br/>March 4, 2015
           </p>
<p>
The Python dictionary is a
commonly used data structure that supports a rich set of operations.  But
there are 
some operations that it lacks—two operators in particular: "<tt>+</tt>" and
"<tt>+=</tt>".  That lack is the subject of a recent discussion on the
python-ideas 
mailing list.  There are questions about the precise semantics of the
operators, but there is also something of an existential question about the
need for operators whose semantics can already be handled using existing
operations.
</p>

<h4>Some background</h4>

<p>
Dictionaries (or dicts) are also known as associative arrays or hashes in
other languages.  In essence, they map some key, which is usually—but not
always—a string, to some other value.  A simple example:
</p><pre>
    &gt;&gt;&gt; a_dict = { 'a' : 3, 9 : 7, 'foo' : 'bar' }
    &gt;&gt;&gt; a_dict['a']
    3
    &gt;&gt;&gt; a_dict[9]
    7
    &gt;&gt;&gt; a_dict['bar']
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in &lt;module&gt;
    KeyError: 'bar'
</pre><p>
That sets up </p><tt>a_dict</tt><p> as a dict with three elements, then shows accessing
various elements of the dict.  The last key, "bar", is not present, so
attempting to access it
results in a runtime </p><tt>KeyError</tt><p> exception.


</p><p>
One of the other fundamental Python types is the list, which provides an
ordered sequence of objects, in many ways like arrays in other languages.
</p><pre>
    &gt;&gt;&gt; b_list = [ 1, 2, 3 ]
    &gt;&gt;&gt; b_list[2]
    3
</pre><p>
But lists have two operators that dicts lack.  In particular, lists can be
concatenated using </p><tt>+</tt><p> and </p><tt>+=</tt><p>:
</p><pre>
    &gt;&gt;&gt; b_list + b_list
    [1, 2, 3, 1, 2, 3]
    &gt;&gt;&gt; b_list += [ 4, 5, 6 ]
    &gt;&gt;&gt; b_list
    [1, 2, 3, 4, 5, 6]
</pre><p>
Doing something similar with dicts, though, leads to an exception:
</p><pre>
    &gt;&gt;&gt; a_dict + a_dict
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in &lt;module&gt;
    TypeError: unsupported operand type(s) for +: 'dict' and 'dict'
</pre><p>
A </p><tt>TypeError</tt><p> is also raised for the </p><tt>+=</tt><p> operator when used
on dicts. 


</p><h4>Adding + and +=</h4>

<p>
But Ian Lee would like to see that change.
He first raised the issue in
a <a href="/Articles/635421/">brief subthread</a> on the python-dev
mailing list in a discussion about code review for <a href="https://www.python.org/dev/peps/pep-0448/">PEP 448</a>.  
Lee subsequently moved the
topic to python-ideas, where he <a href="/Articles/635420/">suggested</a>
adding both the <tt>+</tt> and <tt>+=</tt> operators for dicts to put them
on an equal footing with lists.
</p>

<p>
The semantics of adding two dicts that have no keys in common seems clear:
the result is a dict with all of the key/value pairs from both operands.  For
<tt>+</tt>, the result is a new dict, while <tt>+=</tt> modifies the dict
on the left.
The only real question is what to do when there are duplicate keys.
Dicts already have an <tt>update()</tt> method that takes the value for a
duplicate key from the argument dict:
</p><pre>
    &gt;&gt;&gt; a_dict = { 'a' : 1, 'b' : 2 }
    &gt;&gt;&gt; a_dict.update( { 'b' : 9 } )
    &gt;&gt;&gt; a_dict
    {'a': 1, 'b': 9}
</pre><p>
Lee
suggested using the "</p><span>last setter wins</span><p>" for the new operators,
as the 
</p><tt>update()</tt><p> method does. So the value for a
duplicate key comes from the right operand:
</p><pre>
    &gt;&gt;&gt; a_dict = { 'a' : 1, 'b' : 2 }
    &gt;&gt;&gt; b_dict = { 'b' : 'bar', 'c' : 'baz' }
    &gt;&gt;&gt; a_dict + b_dict
    { 'a' : 1, <b>'b' : 'bar'</b>, 'c' : 'baz' }
    &gt;&gt;&gt; b_dict += a_dict
    &gt;&gt;&gt; b_dict
    { 'a' : 1, <b>'b' : 2</b>, 'c' : 'baz' }
</pre>



<p>
Donald Stufft <a href="/Articles/635422/">liked</a> the idea behind the
change, but didn't like using <tt>+</tt>.  He would rather use "<tt>|</tt>"
to try to make it clearer that it is really more of a set union operation,
rather than a concatenation or addition.  Ethan Furman, though, <a href="/Articles/635437/">sees</a> <tt>+</tt> as a generic operator for combining
things. On the other hand: "<span>I suppose I could come around to '|',
though -- it does ease 
the tension around the behavior of duplicate keys</span>", he said.
</p>

<p>
After a bit of a digression through a question of commutativity (which is
not preserved by the operators, but that is hardly unique—string
concatenation doesn't either, for example), Marc-André Lemburg <a href="/Articles/635439/">explained</a> that he didn't see the need for
<tt>+</tt>, though <tt>+=</tt> could be useful:
</p><div class="BigQuote"><p>
However, I don't really see the point in having an operation that
takes two dictionaries, creates a new empty one and updates this
with both sides of the operand. It may be theoretically useful,
but it results in the same poor performance you have in string
concatenation.
</p><p>
In applications, you normally just need the update functionality
for dictionaries. If you do need a copy, you can create a copy
explicitly - but those cases are usually rare.
</p></div>


<p>
Having one of those operators without the other seems a bit strange to
some, though.  Operators in Python are implemented as special methods on
objects, so <tt>a + b</tt> becomes <tt>a.__add__(b)</tt>
(similarly, <tt>+=</tt> uses the 
<tt>__iadd__()</tt> special method).  Dicts could pick up an <tt>__iadd__()</tt> method (or the
<tt>|</tt> equivalent: <tt>__ior__()</tt>), but most developers, especially
those new 
to the language, would probably expect <tt>+</tt> to work if <tt>+=</tt> did.
</p>

<h4>Other options</h4>

<p>
In the case of duplicated keys, there are (at least) two other options.  An
exception could be raised when combining two dicts that have keys in
common, as Greg Ewing <a href="/Articles/635512/">suggested</a>, though
that might be surprising.  Another option would be to 
apply the addition operator to the two values, but that might cause its own
set of surprises: 
</p><pre>
    &gt;&gt;&gt; a_dict = { 'a' : 2, 'b' : 'foo' }
    &gt;&gt;&gt; b_dict = { 'a' : 4, 'b' : 'foo' }
    &gt;&gt;&gt; c_dict = { 'b' : 3 }
    &gt;&gt;&gt; a_dict + b_dict
    { 'a' : <b>6</b>, 'b' : <b>'foofoo'</b> }
    &gt;&gt;&gt; b_dict + c_dict
    ...
    TypeError: cannot concatenate 'str' and 'int' objects
</pre><p>
Either the addition/concatenation or the exception might well surprise
developers. 

</p><p>
Lee <a href="/Articles/635444/">summarized</a> the ideas and approaches from
early on in the thread in a kind of a pre-PEP document.

</p><p>
Even though there is a lot of precedent for operators like <tt>+</tt> and
<tt>+=</tt>, Stephen D'Aprano <a href="/Articles/635448/">argued</a> that
they are actually flawed ideas that should not be further propagated.  The
fact that 
lists have those operators is not for the better:
</p><p class="BigQuote">
It is *unfortunate* that += works with lists and tuples because + works, 
not a feature to emulate. Python made the best of a bad deal with 
augmented assignments: a syntax which works fine in C doesn't *quite* 
work cleanly in Python, but demand for it [led] to it being supported. 
The consequence is that every generation of Python programmers now need 
to learn for themselves that += on non-numeric types has surprising 
corner cases. Usually the hard way.
</p>


<p>
D'Aprano described 
one of those corner cases (which also <a href="https://docs.python.org/2/faq/programming.html#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works">appears
in the Python FAQ</a>) for the tuple immutable sequence type:
</p><pre>
    &gt;&gt;&gt; t = ([], None)
    &gt;&gt;&gt; t[0] += [1]
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in &lt;module&gt;
    TypeError: 'tuple' object does not support item assignment
    &gt;&gt;&gt; t
    ([1], None)
</pre><p>
In the example, </p><tt>t</tt><p> is an immutable sequence of two items: an empty
list and </p><tt>None</tt><p>.  Because of the way Python handles the </p><tt>+=</tt><p>
operator, the exception isn't raised until after the "desired" change has
been made to the list.  As Andrew Barnert </p><a href="/Articles/635450/">explained</a><p>, Python essentially turns the
statement into:
</p><pre>
    setitem(t, 0, getitem(t, 0).__iadd__([1]))
</pre><p>
It is the </p><tt>setitem()</tt><p> that fails, but the </p><tt>__iadd__()</tt><p> has
already succeeded in changing the list object.
Another way to look at it would be:
</p><pre>
    &gt;&gt;&gt; l = t[0]
    &gt;&gt;&gt; l += [1]
    &gt;&gt;&gt; t[0] = l
</pre><p>
The final assignment is where that sequence fails, but the list object
</p><tt>l</tt><p> has already been modified.
That "feature" is—at
best—a language 
wart. 


</p><p>
The subject of <tt>dict.__add__()</tt> comes up on python-ideas with some
frequency, and it is clear there are strong feelings on all of the
different sides.  Stufft <a href="/Articles/635482/">thinks</a> it would
make a nice "mini-addition" to the language that might make newer versions
a little more attractive:
</p><div class="BigQuote"><p>
Similarly doing:
</p><pre>
    new_dict = dict1.copy()
    new_dict.update(dict2)
</pre><p>
Isn't confusing or particularly hard to use, however being able to type that
as new_dict = dict1 + dict2 is more succinct, cleaner, and just a little bit
nicer. It adds another small reason why, taken with the other small reasons,
someone might want to drop an older version of Python for a newer version.
</p></div>


<p>
But Stephen J. Turnbull is <a href="/Articles/635483/">not convinced</a>
that the semantics are so clear that what the operators do would be obvious
to most.  He noted that four different ways to handle the duplicate-key
problem had been proposed and added two more, possibly with tongue in
cheek.  In addition, since there are existing ways to perform those operations,
adding another violates the Python "there's only one way to do it" (<a href="https://wiki.python.org/moin/TOOWTDI">TOOWTDI</a>) guideline.
</p>

<p>
Early on, Lee indicated that he would try to shepherd a PEP through the
process to see if the operators could be added to dicts.  Brett Cannon <a href="/Articles/635493/">agreed</a> with that idea:
</p><p class="BigQuote">
 I think a
PEP that finally settled this idea would be good, even if it just ends up
being a historical document as to why dicts don't have an __add__ method.
Obviously there is a good amount of support both for and against the idea.
</p>


<p>
That's where things stand now.  No PEP has yet appeared, though it seems
likely that one will.  It is an interesting question in that both sides
seem to see their choice as the "obvious" one.  There is precedent 
in that lists have the two operators, but that precedent does lead to some
corner cases and warts.  Even if the PEP were to be accepted, it would only
be a feature for some upcoming version of Python 3—features are no
longer being added to Python 2.
One suspects that in the end it will come down to
what benevolent 
dictator for life (BDFL) Guido van Rossum thinks—so far he has been silent
in the thread.
</p><hr align="left"/><p>
           (</p><a href="https://lwn.net/login?target=/Articles/635397/">Log in</a><p> to post comments)
           </p><p>
           
</p></div> 
</div></body></html>