<html><body><div><div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<p><b>Timsort</b> is a <a href="/wiki/Hybrid_algorithm" title="Hybrid algorithm">hybrid</a> <a href="/wiki/Category:Stable_sorts" title="Category:Stable sorts">stable</a> <a href="/wiki/Sorting_algorithm" title="Sorting algorithm">sorting algorithm</a>, derived from <a href="/wiki/Merge_sort" title="Merge sort">merge sort</a> and <a href="/wiki/Insertion_sort" title="Insertion sort">insertion sort</a>, designed to perform well on many kinds of real-world data. It uses techniques from <a href="/w/index.php?title=Peter_McIlroy&amp;action=edit&amp;redlink=1" class="new" title="Peter McIlroy (page does not exist)">Peter McIlroy</a>'s "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. It was implemented by Tim Peters in 2002 for use in the <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python programming language</a>. The algorithm finds subsets of the data that are already ordered, and uses that knowledge to sort the remainder more efficiently. This is done by merging an identified subset, called a run, with existing runs until certain criteria are fulfilled. Timsort has been Python's standard sorting algorithm since version 2.3. It is also used to sort arrays of non-primitive type in <a href="/wiki/Java_7" title="Java 7" class="mw-redirect">Java SE 7</a>,<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> on the <a href="/wiki/Android_(operating_system)" title="Android (operating system)">Android platform</a>,<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup> and in <a href="/wiki/GNU_Octave" title="GNU Octave">GNU Octave</a>.<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup></p>
<p/>

<p/>
<h2><span class="mw-headline" id="Operation">Operation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Timsort&amp;action=edit&amp;section=1" title="Edit section: Operation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Timsort was designed to take advantage of partial orderings that already exist in most real-world data. Timsort operates by finding <i>runs</i>, subsets of at least two elements that are either non-descending (each element is equal to or greater than its predecessor) or strictly descending (each element is lower than its predecessor). If it is descending, it must be strictly descending, since descending runs are later reversed by a simple swap of elements from both ends converging in the middle. After obtaining such a run in the given array, Timsort processes it, and then searches for the next run.</p>

<div class="thumb tright">
<div class="thumbinner"><a href="/wiki/File:Selection_of_minrun_by_timsort.png" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/6/63/Selection_of_minrun_by_timsort.png/280px-Selection_of_minrun_by_timsort.png" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/6/63/Selection_of_minrun_by_timsort.png/420px-Selection_of_minrun_by_timsort.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/6/63/Selection_of_minrun_by_timsort.png/560px-Selection_of_minrun_by_timsort.png 2x" data-file-width="964" data-file-height="451"/></a>
<div class="thumbcaption">
<p>
Timsort algorithm searches for such ordered sequences, minruns, to perform its sort</p></div>
</div>
</div>
<p>A natural run is a sub-array that is already ordered. Natural runs in real-world data may be of varied lengths. Timsort chooses a sorting technique depending on the length of the run. For example, if the run length is smaller than a certain value, insertion sort is used. Thus Timsort is an adaptive sort.<sup id="cite_ref-python_timsort_6-0" class="reference"><a href="#cite_note-python_timsort-6"><span>[</span>6<span>]</span></a></sup></p>
<p>The size of the run is checked against the minimum run size. The minimum run size (minrun) depends on the size of the <a href="/wiki/Array_data_type" title="Array data type">array</a>. For an array of fewer than 64 elements, minrun is the size of the array, reducing Timsort to an insertion sort. For larger arrays, minrun is chosen from the range 32 to 64 inclusive, such that the size of the array, divided by minrun, is equal to, or slightly smaller than, a power of two. The final algorithm takes the six most significant bits of the size of the array, adds one if any of the remaining bits are set, and uses that result as the minrun. This algorithm works for all arrays, including those smaller than 64.<sup id="cite_ref-python_timsort_6-1" class="reference"><a href="#cite_note-python_timsort-6"><span>[</span>6<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Insertion_sort">Insertion sort</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Timsort&amp;action=edit&amp;section=3" title="Edit section: Insertion sort">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>When an array is random, natural runs most likely contain fewer than minrun elements. In this case, an appropriate number of succeeding elements is selected, and an insertion sort increases the size of the run to minrun size. Thus, most runs in a random array are, or become, minrun in length. This results in efficient, balanced merges. It also results in a reasonable number of function calls in the implementation of the sort.<sup id="cite_ref-drmaciver_7-0" class="reference"><a href="#cite_note-drmaciver-7"><span>[</span>7<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Merge_memory">Merge memory</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Timsort&amp;action=edit&amp;section=4" title="Edit section: Merge memory">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div class="thumb tright">
<div class="thumbinner"><a href="/wiki/File:Representation_of_stack_for_merge_memory_in_Timsort.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/e/e1/Representation_of_stack_for_merge_memory_in_Timsort.svg/280px-Representation_of_stack_for_merge_memory_in_Timsort.svg.png" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/e/e1/Representation_of_stack_for_merge_memory_in_Timsort.svg/420px-Representation_of_stack_for_merge_memory_in_Timsort.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/e/e1/Representation_of_stack_for_merge_memory_in_Timsort.svg/560px-Representation_of_stack_for_merge_memory_in_Timsort.svg.png 2x" data-file-width="512" data-file-height="266"/></a>
<div class="thumbcaption">
<p>
The minruns are inserted in a </p><a href="/wiki/Stack_(data_structure)" title="Stack (data structure)" class="mw-redirect">stack</a><p>. If X &lt; Y + Z then X and Y are merged and then inserted into a stack. In this way, merging is continued until all arrays satisfy a) X &gt; Y + Z and b) Y &gt; Z</p></div>
</div>
</div>
<p>Once run lengths are optimized, the runs are merged. When a run is found, the algorithm pushes its base address and length on a stack. A function determines whether the run should be merged with previous runs. Timsort does not merge non-consecutive runs, because doing this would cause the element common to all three runs to become out of order with respect to the middle run.</p>
<p>Thus, merging is always done on consecutive runs. For this, the three top-most runs in the stack which are unsorted are considered. If, say, X, Y, Z represent the lengths of the three uppermost runs in the stack, the algorithm merges the runs so that ultimately the following two rules are satisfied:</p>
<ol type="i">
<li>X &gt; Y + Z</li>
<li>Y &gt; Z<sup id="cite_ref-python_timsort_6-2" class="reference"><a href="#cite_note-python_timsort-6"><span>[</span>6<span>]</span></a></sup></li>
</ol>
<p>For example, if the first of the two rules is not satisfied by the current run status, that is, if X &lt; Y + Z, then, Y is merged with the smaller of X and Z. The merging continues until both rules are satisfied. Then the algorithm determines the next run.<sup id="cite_ref-drmaciver_7-1" class="reference"><a href="#cite_note-drmaciver-7"><span>[</span>7<span>]</span></a></sup></p>
<p>The rules above aim at maintaining run lengths as close to each other as possible to balance the merges. Only a small number of runs are remembered, as the stack is of a specific size. The algorithm exploits the fresh occurrence of the runs to be merged, in <a href="/wiki/CPU_cache" title="CPU cache">cache memory</a>. Thus a compromise is attained between delaying merging, and exploiting fresh occurrence in cache.</p>
<h3><span class="mw-headline" id="Merging_procedure">Merging procedure</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Timsort&amp;action=edit&amp;section=5" title="Edit section: Merging procedure">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div class="thumb tright">
<div class="thumbinner"><a href="/wiki/File:Merging_procedure_for_timsort.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/c/c2/Merging_procedure_for_timsort.svg/280px-Merging_procedure_for_timsort.svg.png" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/c/c2/Merging_procedure_for_timsort.svg/420px-Merging_procedure_for_timsort.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/c/c2/Merging_procedure_for_timsort.svg/560px-Merging_procedure_for_timsort.svg.png 2x" data-file-width="512" data-file-height="257"/></a>
<div class="thumbcaption">
<p>
Algorithm creates a temporary memory equal to size of smaller array. Then, it shifts elements in (say if X is smaller) X to the temporary memory and then sorts and fills elements in final order into combined space of X and Y</p></div>
</div>
</div>
<p>Merging adjacent runs is done with the help of temporary memory. The temporary memory is of the size of the lesser of the two runs. The algorithm copies the smaller of the two runs into this temporary memory and then uses the original memory (of the smaller run) and the memory of the other run to store sorted output.</p>
<p>A simple merge algorithm runs left to right or right to left depending on which run is smaller, on the temporary memory and original memory of the larger run. The final sorted run is stored in the original memory of the two initial runs. Timsort searches for appropriate positions for the starting element of one array in the other using an adaptation of <a href="/wiki/Binary_search" title="Binary search" class="mw-redirect">binary search</a>.</p>
<p>Say, for example, two runs A and B are to be merged, with A as the smaller run. In this case a binary search examines A to find the first position larger than the first element of B (a'). Note that A and B are already sorted individually. When a' is found, the algorithm can ignore elements before that position while inserting B. Similarly, the algorithm also looks for the smallest element in B (b') greater than the largest element in A (a"). The elements after b' can also be ignored for the merging. This preliminary searching is not efficient for highly random data, but is efficient in other situations and is hence included.</p>
<h3><span class="mw-headline" id="Galloping_mode">Galloping mode</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Timsort&amp;action=edit&amp;section=6" title="Edit section: Galloping mode">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div class="thumb tright">
<div class="thumbinner"><a href="/wiki/File:One-one_merging_timsort.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/4/49/One-one_merging_timsort.svg/280px-One-one_merging_timsort.svg.png" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/4/49/One-one_merging_timsort.svg/420px-One-one_merging_timsort.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/4/49/One-one_merging_timsort.svg/560px-One-one_merging_timsort.svg.png 2x" data-file-width="512" data-file-height="398"/></a>
<div class="thumbcaption">
<p>
Elements (pointed to by blue arrow) are compared and the smaller element is moved to its final position (pointed to by red arrow).</p></div>
</div>
</div>
<p>Most of the merge occurs in what is called "one pair at a time" mode, where respective elements of both runs are compared. When the algorithm merges left-to-right, the smaller of the two is brought to a merge area. A count of the number of times the final element appears in a given run is recorded. When this value reaches a certain threshold, MIN_GALLOP, the merge switches to "galloping mode". In this mode we use the previously mentioned adaptation of binary search to identify where the first element of the smaller array must be placed in the larger array (and vice versa). All elements in the larger array that occur before this location can be moved to the merge area as a group (and vice versa). The functions <i>merge-lo</i> and <i>merge-hi</i> increment the value of min-gallop (initialized to MIN_GALLOP), if galloping is not efficient, and decrement it if it is. If too many consecutive elements come from different runs, galloping mode is exited.<sup id="cite_ref-python_timsort_6-3" class="reference"><a href="#cite_note-python_timsort-6"><span>[</span>6<span>]</span></a></sup></p>
<p>In galloping mode, the algorithm searches for the first element of one array in the other. This is done by comparing that first element (initial element) with the zeroth element of the other array, then the first, the third and so on, that is (2<sup>k</sup> - 1)th element, so as to get a range of elements between which the initial element will lie. This shortens the range for binary searching, thus increasing efficiency. Galloping proves to be more efficient except in cases with especially long runs, but random data usually has shorter runs. Also, in cases where galloping is found to be less efficient than <a href="/wiki/Binary_search_algorithm" title="Binary search algorithm">binary search</a>, galloping mode is exited.</p>
<div class="thumb tright">
<div class="thumbinner"><a href="/wiki/File:Copy_galloping_mode_timsort(2).svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/e/e4/Copy_galloping_mode_timsort%282%29.svg/280px-Copy_galloping_mode_timsort%282%29.svg.png" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/e/e4/Copy_galloping_mode_timsort%282%29.svg/420px-Copy_galloping_mode_timsort%282%29.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/e/e4/Copy_galloping_mode_timsort%282%29.svg/560px-Copy_galloping_mode_timsort%282%29.svg.png 2x" data-file-width="512" data-file-height="384"/></a>
<div class="thumbcaption">
<p>
All red elements are smaller than blue (here, 21). Thus they can be moved in a chunk to the final array.</p></div>
</div>
</div>
<p>Galloping is not always efficient. One reason is due to excessive function calls. Function calls are expensive and thus when frequent, they affect program efficiency. In some cases galloping mode requires more comparisons than a simple <a href="/wiki/Linear_search" title="Linear search">linear search</a> (one at a time search). While for the first few cases both modes may require the same number of comparisons, over time galloping mode requires 33% more comparisons than linear search to arrive at the same results. Moreover all comparisons in galloping mode are done by <a href="/wiki/Function_call" title="Function call" class="mw-redirect">function calls</a>.</p>
<p>Galloping is beneficial only when the initial element of one run is not one of the first seven elements of the other run. This implies a MIN_GALLOP of 7. To avoid the drawbacks of galloping mode, the merging functions adjust the value of min-gallop. If the element is from the array currently that has been returning elements, min-gallop is reduced by one. Otherwise, the value is incremented by one, thus discouraging a return to galloping mode. When this is done, in the case of random data, the value of min-gallop becomes so large that galloping mode never recurs.</p>
<p>In the case where merge-hi is used (that is, merging is done right-to-left), galloping starts from the right end of the data, that is, the last element. Galloping from the beginning also gives the required results, but makes more comparisons. Thus, the galloping algorithm uses a variable that gives the index at which galloping should begin. Timsort can enter galloping mode at any index and continue checking at the next index which is offset by 1, 3, 7,...., (2<sup><i>k</i></sup> − 1).. and so on from the current index. In the case of merge-hi, the offsets to the index will be −1, −3, −7,....<sup id="cite_ref-python_timsort_6-4" class="reference"><a href="#cite_note-python_timsort-6"><span>[</span>6<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Analysis">Analysis</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Timsort&amp;action=edit&amp;section=7" title="Edit section: Analysis">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In the <a href="/wiki/Best,_worst_and_average_case" title="Best, worst and average case">worst case</a>, Timsort takes <img class="mwe-math-fallback-image-inline tex" alt="\Theta(n \log n)" src="//upload.wikimedia.org/math/f/2/9/f296a521bff060cd02c3ef6ee7931dd7.png"/> comparisons to sort an array of <span class="texhtml mvar">n</span> elements. In the best case, which occurs when the input is already sorted, it runs in linear time, meaning that it is an <a href="/wiki/Adaptive_sort" title="Adaptive sort">adaptive sorting</a> algorithm.<sup id="cite_ref-Chandramouli_2-1" class="reference"><a href="#cite_note-Chandramouli-2"><span>[</span>2<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Debugging_with_formal_methods">Debugging with formal methods</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Timsort&amp;action=edit&amp;section=8" title="Edit section: Debugging with formal methods">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Researchers discovered using <a href="/wiki/Formal_verification" title="Formal verification">formal verification</a> (<a href="/wiki/KeY" title="KeY">KeY</a>) that the three runs mentioned above are not sufficient to hold the invariant for any arbitrary array.<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>8<span>]</span></a></sup> The bug was not deemed critical because no current machine could hold a sufficient number of elements, approximately 2<sup>49</sup> or 562 trillion, to trigger the error. The bug was patched in Python a day later.<sup id="cite_ref-9" class="reference"><a href="#cite_note-9"><span>[</span>9<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Timsort&amp;action=edit&amp;section=9" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="reflist columns references-column-count references-column-count-2">
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><cite class="citation web">Peters, Tim. <a rel="nofollow" class="external text" href="http://mail.python.org/pipermail/python-dev/2002-July/026837.html">"[Python-Dev] Sorting"</a>. <i>Python Developers Mailinglist</i><span class="reference-accessdate">. Retrieved <span class="nowrap">24 Feb</span> 2011</span>. <q>[Timsort] also has good aspects: It's stable (items that compare equal retain their relative order, so, e.g., if you sort first on zip code, and a second time on name, people with the same name still appear in order of increasing zip code; this is important in apps that, e.g., refine the results of queries based on user input). ... It has no bad cases (O(N log N) is worst case; N−1 compares is best).</q></cite><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATimsort&amp;rft.atitle=%5BPython-Dev%5D+Sorting&amp;rft.aufirst=Tim&amp;rft.aulast=Peters&amp;rft.genre=unknown&amp;rft_id=http%3A%2F%2Fmail.python.org%2Fpipermail%2Fpython-dev%2F2002-July%2F026837.html&amp;rft.jtitle=Python+Developers+Mailinglist&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span> </span></span></span></li>
<li id="cite_note-Chandramouli-2"><span class="mw-cite-backlink">^ <a href="#cite_ref-Chandramouli_2-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Chandramouli_2-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><cite class="citation conference">Chandramouli, Badrish; Goldstein, Jonathan (2014). <i>Patience is a Virtue: Revisiting Merge and Sort on Modern Processors</i>. SIGMOD/PODS.</cite><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATimsort&amp;rft.aufirst=Badrish&amp;rft.au=Goldstein%2C+Jonathan&amp;rft.aulast=Chandramouli&amp;rft.btitle=Patience+is+a+Virtue%3A+Revisiting+Merge+and+Sort+on+Modern+Processors&amp;rft.date=2014&amp;rft.genre=conference&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><cite class="citation web"><a rel="nofollow" class="external text" href="https://bugs.openjdk.java.net/browse/JDK-6804124">"[#JDK-6804124] (coll) Replace "modified mergesort" in java.util.Arrays.sort with timsort"</a>. <i>JDK Bug System</i><span class="reference-accessdate">. Retrieved <span class="nowrap">11 Jun</span> 2014</span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATimsort&amp;rft.atitle=%5B%23JDK-6804124%5D+%28coll%29+Replace+%26quot%3Bmodified+mergesort%26quot%3B+in+java.util.Arrays.sort+with+timsort&amp;rft.genre=unknown&amp;rft_id=https%3A%2F%2Fbugs.openjdk.java.net%2Fbrowse%2FJDK-6804124&amp;rft.jtitle=JDK+Bug+System&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span> </span></span></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><cite class="citation web"><a rel="nofollow" class="external text" href="https://android.googlesource.com/platform/libcore/+/gingerbread/luni/src/main/java/java/util/TimSort.java">"Class: java.util.TimSort&lt;T&gt;"</a>. <i>Android Gingerbread Documentation</i><span class="reference-accessdate">. Retrieved <span class="nowrap">24 Feb</span> 2011</span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATimsort&amp;rft.atitle=Class%3A+java.util.TimSort%3CT%3E&amp;rft.genre=unknown&amp;rft_id=https%3A%2F%2Fandroid.googlesource.com%2Fplatform%2Flibcore%2F%2B%2Fgingerbread%2Fluni%2Fsrc%2Fmain%2Fjava%2Fjava%2Futil%2FTimSort.java&amp;rft.jtitle=Android+Gingerbread+Documentation&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span> </span></span><sup class="noprint Inline-Template"><span>[<i><a href="/wiki/Wikipedia:Link_rot" title="Wikipedia:Link rot"><span title=" since June 2013">dead link</span></a></i>]</span></sup></span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><cite class="citation web"><a rel="nofollow" class="external text" href="http://hg.savannah.gnu.org/hgweb/octave/file/0486a29d780f/liboctave/util/oct-sort.cc">"liboctave/util/oct-sort.cc"</a>. <i>Mercurial repository of Octave source code</i>. Lines 23-25 of the initial comment block<span class="reference-accessdate">. Retrieved <span class="nowrap">18 Feb</span> 2013</span>. <q>Code stolen in large part from Python's, listobject.c, which itself had no license header. However, thanks to Tim Peters for the parts of the code I ripped-off.</q></cite><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATimsort&amp;rft.atitle=liboctave%2Futil%2Foct-sort.cc&amp;rft.genre=unknown&amp;rft_id=http%3A%2F%2Fhg.savannah.gnu.org%2Fhgweb%2Foctave%2Ffile%2F0486a29d780f%2Fliboctave%2Futil%2Foct-sort.cc&amp;rft.jtitle=Mercurial+repository+of+Octave+source+code&amp;rft.pages=Lines+23-25+of+the+initial+comment+block.&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span> </span></span></span></li>
<li id="cite_note-python_timsort-6"><span class="mw-cite-backlink">^ <a href="#cite_ref-python_timsort_6-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-python_timsort_6-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-python_timsort_6-2"><sup><i><b>c</b></i></sup></a> <a href="#cite_ref-python_timsort_6-3"><sup><i><b>d</b></i></sup></a> <a href="#cite_ref-python_timsort_6-4"><sup><i><b>e</b></i></sup></a></span> <span class="reference-text"><cite class="citation web">timsort, python. <a rel="nofollow" class="external text" href="http://hg.python.org/cpython/file/tip/Objects/listsort.txt">"python_timsort"</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATimsort&amp;rft.aufirst=python&amp;rft.aulast=timsort&amp;rft.btitle=python_timsort&amp;rft.genre=unknown&amp;rft_id=http%3A%2F%2Fhg.python.org%2Fcpython%2Ffile%2Ftip%2FObjects%2Flistsort.txt&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span> </span></span></span></li>
<li id="cite_note-drmaciver-7"><span class="mw-cite-backlink">^ <a href="#cite_ref-drmaciver_7-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-drmaciver_7-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><cite class="citation web">MacIver, David R. (11 January 2010). <a rel="nofollow" class="external text" href="http://www.drmaciver.com/2010/01/understanding-timsort-1adaptive-mergesort/">"Understanding timsort, Part 1: Adaptive Mergesort"</a><span class="reference-accessdate">. Retrieved <span class="nowrap">2015-12-05</span></span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATimsort&amp;rft.aufirst=David+R.&amp;rft.aulast=MacIver&amp;rft.btitle=Understanding+timsort%2C+Part+1%3A+Adaptive+Mergesort&amp;rft.date=2010-01-11&amp;rft.genre=unknown&amp;rft_id=http%3A%2F%2Fwww.drmaciver.com%2F2010%2F01%2Funderstanding-timsort-1adaptive-mergesort%2F&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span> </span></span></span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://envisage-project.eu/proving-android-java-and-python-sorting-algorithm-is-broken-and-how-to-fix-it/">Proving that Android’s, Java’s and Python’s sorting algorithm is broken (and showing how to fix it)</a></span></li>
<li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://bugs.python.org/issue23515">Python Issue Tracker - Issue 23515: Bad logic in timsort's merge_collapse</a></span></li>
</ol>
</div>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Timsort&amp;action=edit&amp;section=10" title="Edit section: Further reading">edit</a><span class="mw-editsection-bracket">]</span></span></h2>

<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Timsort&amp;action=edit&amp;section=11" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>









<noscript><img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title=""/></noscript></div>					
				</div></body></html>