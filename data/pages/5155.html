<html><body><div><div class="post-text" itemprop="text">
<p>Important things to understand here are</p>

<ol>
<li><p>generator expressions will be creating function objects internally but list comprehension will not.</p></li>
<li><p>they both will bind the loop variable to the values and the loop variables will be in the current scope if they are not already created.</p></li>
</ol>

<p>Lets see the byte codes of the generator expression</p>

<pre><code>&gt;&gt;&gt; dis(compile('(i(0) + i(1) for a in alist)', 'string', 'exec'))
  1           0 LOAD_CONST               0 (&lt;code object &lt;genexpr&gt; at ...&gt;)
              3 MAKE_FUNCTION            0
              6 LOAD_NAME                0 (alist)
              9 GET_ITER            
             10 CALL_FUNCTION            1
             13 POP_TOP             
             14 LOAD_CONST               1 (None)
             17 RETURN_VALUE        
</code></pre>

<p>It loads the code object and then it makes it a function. Lets see the actual code object.</p>

<pre><code>&gt;&gt;&gt; dis(compile('(i(0) + i(1) for a in alist)', 'string', 'exec').co_consts[0])
  1           0 LOAD_FAST                0 (.0)
        &gt;&gt;    3 FOR_ITER                27 (to 33)
              6 STORE_FAST               1 (a)
              9 LOAD_GLOBAL              0 (i)
             12 LOAD_CONST               0 (0)
             15 CALL_FUNCTION            1
             18 LOAD_GLOBAL              0 (i)
             21 LOAD_CONST               1 (1)
             24 CALL_FUNCTION            1
             27 BINARY_ADD          
             28 YIELD_VALUE         
             29 POP_TOP             
             30 JUMP_ABSOLUTE            3
        &gt;&gt;   33 LOAD_CONST               2 (None)
             36 RETURN_VALUE        
</code></pre>

<p>As you see here, the current value from the iterator is stored in the variable <code>a</code>. But since we make this a function object, the <code>a</code> created will be visible only within the generator expression.</p>

<p>But in case of list comprehension,</p>

<pre><code>&gt;&gt;&gt; dis(compile('[i(0) + i(1) for a in alist]', 'string', 'exec'))
  1           0 BUILD_LIST               0
              3 LOAD_NAME                0 (alist)
              6 GET_ITER            
        &gt;&gt;    7 FOR_ITER                28 (to 38)
             10 STORE_NAME               1 (a)
             13 LOAD_NAME                2 (i)
             16 LOAD_CONST               0 (0)
             19 CALL_FUNCTION            1
             22 LOAD_NAME                2 (i)
             25 LOAD_CONST               1 (1)
             28 CALL_FUNCTION            1
             31 BINARY_ADD          
             32 LIST_APPEND              2
             35 JUMP_ABSOLUTE            7
        &gt;&gt;   38 POP_TOP             
             39 LOAD_CONST               2 (None)
             42 RETURN_VALUE        
</code></pre>

<p>There is no explicit function creation and the variable <code>a</code> is created in the current scope. So, <code>a</code> is leaked in to the current scope.</p>

<hr/>

<p>With this understanding, lets approach your problem.</p>

<pre><code>&gt;&gt;&gt; i = lambda x: a[x]
&gt;&gt;&gt; alist = [(1, 2), (3, 4)]
</code></pre>

<p>Now, when you create a list with comprehension,</p>

<pre><code>&gt;&gt;&gt; [i(0) + i(1) for a in alist]
[3, 7]
&gt;&gt;&gt; a
(3, 4)
</code></pre>

<p>you can see that <code>a</code> is leaked to the current scope and it is still bound to the last value from the iteration.</p>

<p>So, when you iterate the generator expression after the list comprehension, the <code>lambda</code> function uses the leaked <code>a</code>. That is why you are getting <code>[7, 7]</code>, since <code>a</code> is still bound to <code>(3, 4)</code>.</p>

<p>But, if you iterate the generator expression first, then the <code>a</code> will be bound to the values from <code>alist</code> and will not be leaked to the current scope as generator expression becomes a function. So, when the <code>lambda</code> function tries to access <code>a</code>, it couldn't find it anywhere. That is why it fails with the error.</p>

<p><strong>Note:</strong> The same behaviour cannot be observed in Python 3.x, because the leaking is prevented by creating functions for list comprehensions as well. You might want to read more about this in the History of Python blog's post, <a href="http://python-history.blogspot.ie/2010/06/from-list-comprehensions-to-generator.html">From List Comprehensions to Generator Expressions</a>, written by Guido himself.</p>
    </div>
    </div></body></html>