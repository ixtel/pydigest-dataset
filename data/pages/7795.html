<html><body><div><div class="post-text" itemprop="text">
<p><em>There are a few ways to achieve the goal, each with its advantages and disadvantages.</em></p>

<p><em>(some of these overlap with the other answers. I don't mean to plagiarize, only to provide a comprehensive answer).</em></p>

<hr/>

<p><strong>Approach 1: The function should do it</strong></p>

<p>One way to guarantee a function only gets executed once, is to make the function itself stateful, making it "remember" it has already been called. This is more or less what is described by @eestrada and @qarma.</p>

<p>As to implementing this, I agree with @qarma that using memoization is the simplest and most ideomatic way. There are a few simple memoization decorators for python on the internet. The one included in the standard library is <code>functools.lru_cache</code>.  You can simply use it like:</p>

<pre><code>@functools.lru_cache
def set_up():  # this is your original set_up() function, now decorated
    &lt;...same as before...&gt;
</code></pre>

<p>The disadvantage here is that it is arguably not the <code>set_up</code>'s responsibility to maintain the state, it is merely a function. One can argue it <em>should</em> execute twice if being called twice, and it's caller's responsibility to only call it when it needs it (what if you really do want to run it twice)?  The general argument is that a function (in order to be useful and reusable) should not make assumptions about the context in which it is called.</p>

<p>Is this argument valid in your case? It is up to you to decide.</p>

<p>Another disadvantage here is that this can be cosidered an abuse of the memoization tool. Memoization is a tool closely related to functional programming, and should be applied to pure functions. Memoizing a funciton implies "no need to run it again, because we already know the <strong>result</strong>", and not "no need to run it again, because there's some <strong>side effect</strong> we want to avoid".</p>

<p><strong>Approach 2: the one you think is ugly (<code>if __name__=='__main__'</code>)</strong></p>

<p>The most common pythonic way, which you already mention in your question, is using the infamous <a href="http://stackoverflow.com/q/419163/2096752"><code>if __name__=='__main__'</code></a> construct.</p>

<p>This guarantees the function is only called once, because it is only called from the module named <code>__main__</code>, and the interpreter guarantees there is only one such module in your process.</p>

<p>This works. There are no complications nor caveats.  This is the way running main-code (including setup code) is done in python.  It is considered <em>pythonic</em> simply because it is so darn common in python (since there are no better ways).</p>

<p>The only disadvantage is that it is arguably ugly (asthetics-wise, not code-quality-wise). I admit I also winced the first few times I saw it or wrote it, but it grows on you.</p>

<p><strong>Approach 3: leverage python's module-importing mechanism</strong></p>

<p>Python already has a caching mechanism preventing modules from being doubly-imported. You can leverage this mechanism by running the setup code in a new module, then import it. This is similar to @rll's answer. This is simple, to do:</p>

<pre><code># logging_setup.py
from framework import logutils
logutils.set_up()
</code></pre>

<p>Now, each caller can run this by importing the new module:</p>

<pre><code># foo/daily_report.py
import logging_setup # side effect!
def main():
    ...
</code></pre>

<p>Since a module is only imported once, <code>set_up</code> is only called once.</p>

<p>The disadvantage here is that it violates the "explicit is better than implicit" principle. I.e. if you want to call a function, call it.  It isn't good practice to run code with side-effects on module-import time.</p>

<p><strong>Approach 4: monkey patching</strong></p>

<p>This is by far the worst of the approaches in this answer. Don't use it. But it is still a way to get the job done.</p>

<p>The idea is that if you don't want the function to get called after the first call, monkey-patch it (read: vandalize it) after the first call.</p>

<pre><code>from framework import logutils
logutils.set_up_only_once()
</code></pre>

<p>Where <code>set_up_only_once</code> can be implemented like:</p>

<pre><code>def set_up_only_once():
    # run the actual setup (or nothing if already vandalized):
    set_up()
    # vandalize it so it never walks again:
    import sys
    sys.modules['logutils'].set_up = lambda: None
</code></pre>

<p>Disadvantages: your colleagues will hate you.</p>

<hr/>

<p>tl;dr:</p>

<p>The simplest way is to memoize using <code>functools.lru_cache</code>, but it might not be the best solution code-quality-wise. It is up to you if this solution is good enough in your case.</p>

<p>The safest and most pythonic way, while not pleasing to the eye, is using <code>if __name__=='__main__': ...</code>.</p>
    </div>
    </div></body></html>