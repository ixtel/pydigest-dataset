<html><body><div><section class="post-content">
            <p>A new version of the image manipulation library <a href="https://pypi.python.org/pypi/Pillow/2.7.0">Pillow 2.7</a> was released on January 1, 2015. As many changes have been made to it by the <a href="https://uploadcare.com/">Uploadcare</a> team, we are happy to present an extended version of the release notes.</p>

<p>Let’s recall how it all started. According to the authors, Pillow is a “friendly” fork of the Python Imaging Library (PIL). The latest version of PIL (1.1.7) was released in 2009 and mainly contained bugfixes. In the beginning, Pillow aimed just to solve PIL build issues, and the developers were advised to address all the bugs unrelated to the build in the original PIL project. Eventually PIL started to become obsolete. The number of bugs did not decline. In addition, Python 3 appeared on the horizon. Therefore, the Pillow version 2.0 approach was changed. As the <a href="https://pypi.python.org/pypi/Pillow/2.0.0">project description on PyPI</a> states, “Pillow 2.0.0 adds Python 3 support and includes many bug fixes from around the internet”. The project got its second wind. Every three months a new version was released, with an enormous number of bugfixes and other improvements from different developers.</p>

<p>Support for WebP and JPEG2000 formats was probably the most significant improvement so far. Now it’s time for image quality and performance improvements.</p>

<h2 id="imageresizingfilters">Image resizing filters</h2>

<p>The image resizing methods <code>Image.resize()</code> and <code>Image.thumbnail()</code> take the resample argument, which specifies a filter that should be used for the resampling. Possible values are: <code>NEAREST</code>, <code>BILINEAR</code>, <code>BICUBIC</code> and <code>ANTIALIAS</code>. Almost all of them have been changed in this version.</p>

<h3 id="bicubicandbilineardownscaling">Bicubic and bilinear downscaling</h3>

<p>One of the problems both PIL and Pillow had was that the <code>BILINEAR</code> and <code>BICUBIC</code> filters were based on affine transformations, and they used a fixed number of pixels from the source image for every destination pixel (2x2 pixels for <code>BILINEAR</code> and 4x4 for <code>BICUBIC</code>). In addition, the filter size was fixed. It was producing unsatisfactory results for downscaling, as it was almost identical to the <code>NEAREST</code> filter.</p>

<p>  
<img alt="nearest" src="http://media.tumblr.com/3482f8e7c6658d7b1b930e67db8d8c6c/tumblr_inline_nhiofpLq6A1rjpdtt.jpg"/><img alt="affine" src="http://media.tumblr.com/3a149dc4d1cd78cc0b22be6736b66f76/tumblr_inline_nhioftc0ul1rjpdtt.jpg"/><br/><img alt="nearest" src="http://media.tumblr.com/41052f5e67c5d136115da4f8964f897e/tumblr_inline_nhiofwxgmv1rjpdtt.jpg"/><img alt="affine" src="http://media.tumblr.com/6b7d7e83bed981c29981b9fab52b66e5/tumblr_inline_nhiofzCqDu1rjpdtt.jpg"/>  
</p>

<p>The images on the left is downscaled using nearest neighbor method; the one on the right was processed using a <code>BICUBIC</code> filter based on the affine transformations method. The first sample is downscaled 5.8 times, and both methods look almost the same. The second one is downscaled 1.8 times. The differnces are minimal and aliasing can be seen in the sharp diagonal lines.</p>

<p>At the same time, a high quality convolutions-based algorithm with a flexible kernel was used for the <code>ANTIALIAS</code> filter, which gave consistently excellent result for both upscaling and downscaling.</p>

<p>With Pillow 2.7.0, a high quality convolutions-based algorithm is used for these three filters.</p>

<p><img alt="affine" src="http://media.tumblr.com/3a149dc4d1cd78cc0b22be6736b66f76/tumblr_inline_nhioftc0ul1rjpdtt.jpg"/><img alt="convolution" src="http://media.tumblr.com/b4ed5bcc07c70ff7845762132dbbb256/tumblr_inline_nhiokoq6i11rjpdtt.jpg"/><br/><img alt="affine" src="http://media.tumblr.com/6b7d7e83bed981c29981b9fab52b66e5/tumblr_inline_nhiofzCqDu1rjpdtt.jpg"/><img alt="convolution" src="http://media.tumblr.com/8cdd30296a8d2daa673f92a803b3a050/tumblr_inline_nhioktYDd61rjpdtt.jpg"/></p>

<p>The images on the left are results of the <code>BICUBIC</code> filter processing based on the affine transformations method. The images on the right were processed using the same filter based on convolutions. Convolutions definitely win.</p>

<p>If you have previously used any tricks to maintain quality when downscaling with <code>BILINEAR</code> and <code>BICUBIC</code> filters (for example, reducing within several steps), they are unnecessary now.</p>

<h3 id="antialiasrenamedtolanczos">Antialias renamed to Lanczos</h3>

<p>A new <code>LANCZOS</code> constant has been added instead of <code>ANTIALIAS</code>.</p>

<p>When <code>ANTIALIAS</code> was initially defined, it was the only high-quality filter based on convolutions. The name was supposed to reflect this fact. Since Pillow 2.7.0, all the resize methods are based on the convolutions, and they are all antialiasing. The real name of the <code>ANTIALIAS</code> filter is Lanczos filter.</p>

<p>The <code>ANTIALIAS</code> constant is left for backward compatibility and is an alias for <code>LANCZOS</code>.</p>

<h3 id="lanczosupscalingquality">Lanczos upscaling quality</h3>

<p>Oddly enough, the quality of convolutions was not up to par. There was a bug in previous versions, which made the quality of the Lanczos filter on upscaling almost the same as that of the <code>BILINEAR</code> filter. This bug has been fixed.</p>

<p><img alt="before" src="http://media.tumblr.com/4fcea92138d21056b4ca74476f5c16f7/tumblr_inline_nhionfbxry1rjpdtt.jpg"/><img alt="after" src="http://media.tumblr.com/3370206b1cf979bb79a26b881da2b9cb/tumblr_inline_nhionn2Mpz1rjpdtt.jpg"/><br/><img alt="before" src="http://media.tumblr.com/6a5eefa8c0feb57153bc2819f4a60427/tumblr_inline_nhionpYI4z1rjpdtt.jpg"/><img alt="after" src="http://media.tumblr.com/e9743dd76900ef71a02e204973c1149d/tumblr_inline_nhiontXPsg1rjpdtt.jpg"/></p>

<p>The images on the left are upscaled 4.3 times in the previous version; the ones on the right are upscaled with Pillow 2.7.0. As you can see, the images upscaled using the older version are more blurred and pixelated.</p>

<h3 id="bicubicupscalingquality">Bicubic upscaling quality</h3>

<p>The <code>BICUBIC</code> filter for affine transformations was producing a sharp, slightly pixelated image when upscaling. Bicubic for convolutions is softer.</p>

<p><img alt="before" src="http://media.tumblr.com/34a99d65e2ea82284c1bae3c23a97303/tumblr_inline_nhiorsZUnr1rjpdtt.jpg"/><img alt="after" src="http://media.tumblr.com/9f9eb995dd05da7cc9e79434e7375d96/tumblr_inline_nhiortx1yu1rjpdtt.jpg"/><br/><img alt="before" src="http://media.tumblr.com/d84db84c0660db25d9fca975f09825fd/tumblr_inline_nhioru7Ta71rjpdtt.jpg"/><img alt="after" src="http://media.tumblr.com/f1a409e3b1673e1af704a7844694b370/tumblr_inline_nhiorwX3oV1rjpdtt.jpg"/></p>

<p>The left one is the result of upscaling 4.3 times in previous version; the right one was upscaled using in Pillow 2.7.0. The images on the left are more pixelated, yet diagonal lines in the first sample are sharper and less aliased. Both effects are influenced by the “a” parameter in the bicubic equation. Only the higher quality Lanczos filter can eliminate both effects at the same time.</p>

<h3 id="performanceoftheresize">Performance of the resize</h3>

<p>In most cases, convolution is a more expensive algorithm for downscaling because it takes into account all the pixels of a source image. Therefore, the performance of <code>BILINEAR</code> and <code>BICUBIC</code> filters for downscaling may be reduced. On the other hand, the quality of <code>BILINEAR</code> and <code>BICUBIC</code> was close to <code>NEAREST</code>. Therefore, if such a quality is suitable for your use, you can switch to the <code>NEAREST</code> filter for downscaling. It will make a huge improvement in performance.</p>

<p>One of the most significant changes in Pillow 2.7 is the performance of the convolution resampling for downscaling. It has been improved by around a factor of two compared to the previous version and even to ImageMagick. The upscaling performance of the LANCZOS filter has remained the same. The <code>BILINEAR</code> filter has been improved 1.5 times; in case of <code>BICUBIC</code> it is four times faster now.</p>

<p>Most likely, you don’t use any filters for downscaling in your application except <code>LANCZOS</code> (former <code>ANTIALIAS</code>). In this case, the average performance should double. If, for example, you were using <code>LANCZOS</code> only because other filters gave a poor quality, now you can switch to a less expensive filter, such as <code>BILINEAR</code>. This should additionally increase performance approximately twice for downscaling and by 30% for upscaling.</p>

<h3 id="defaultfilterforthumbnails">Default filter for thumbnails</h3>

<p>In Pillow 2.5, the default filter for <code>Image.thumbnail()</code> has been changed from <code>NEAREST</code> to <code>ANTIALIAS</code>. Antialias was chosen because all the other filters produced poor reduction quality. Since Pillow 2.7.0, <code>ANTIALIAS</code> has been replaced with <code>BICUBIC</code> because it’s a bit faster, and because <code>ANTIALIAS</code> doesn’t have any advantages after downscaling with libjpeg, which uses supersampling internally rather than convolutions.</p>

<h2 id="imagetransposition">Image transposition</h2>

<p>A new method called <code>TRANSPOSE</code> has been added to the <code>Image.transpose()</code> operation in addition to <code>FLIP_LEFT_RIGHT</code>, <code>FLIP_TOP_BOTTOM</code>, <code>ROTATE_90</code>, <code>ROTATE_180</code> and <code>ROTATE_270</code>. TRANSPOSE is an algebra transposition, with an image reflected across its main diagonal.</p>

<p>The speed of <code>ROTATE_90</code>, <code>ROTATE_270</code> and TRANSPOSE has been improved significantly for large images that don’t fit in the processor cache. These three methods take pixels from the rows and place them into the columns. This memory access pattern is very inefficient for large images because the data is displaced from the CPU cache on each loop, and the CPU is forced to load it from the memory on every subsequent loop.</p>

<p>In the new version the image is divided to logical 128×128 pixel chunks, and the operation is consistently applied on each chunk. As a result, the data is not displaced from the cache (each chunk requires only 64kb of RAM).</p>

<h2 id="gaussianblurandunsharpmask">Gaussian blur and unsharp mask</h2>

<p>The <code>ImageFilter.GaussianBlur</code> implementation has been replaced with a sequential application of the box filters. The new implementation is based on “Theoretical foundations of Gaussian convolution by extended box filtering” article by the Mathematical Image Analysis Group. As the <code>ImageFilter.UnsharpMask</code> implementation uses Gaussian blur internally, all changes in this chapter are also applicable.</p>

<h3 id="blurradius">Blur radius</h3>

<p>There was an error in the previous version of Pillow, where blur radius (the standard deviation of Gaussian blur) actually meant blur diameter. For example, to blur an image with an actual radius 5 you had to use the value 10. This has been fixed. Now the meaning of the radius is the same as that used in other software.</p>

<p>If you use a Gaussian blur with some radii values, now you need to divide this value by half.</p>

<h3 id="blurperformance">Blur performance</h3>

<p>Box filter computation time is constant relative to the radius and depends on the source image size only. Because the new Gaussian blur implementation is based on box filter, its computation time doesn’t depend on the blur radius.</p>

<p>The new implementation works five times faster for radius 1, 18 times for radius 10, and 85 times faster for radius 50. This should totally satisfy your designer who draws modern interfaces in the iOS 8 style.</p>

<h3 id="blurquality">Blur quality</h3>

<p>In theory, for a Gaussian blur each pixel of the source image should participate in the computation of each destination pixel with certain coefficients. In practice, only pixels within radius 3 × standard deviation make an appreciable contribution. There is no sense in considering pixels beyond this radius.</p>

<p>The previous implementation only took into account pixels in a 2 × standard deviation radius around the destination pixel. It was not enough, so the quality was worse compared with other Gaussian blur software.</p>

<p>Despite the fact that the new implementation uses only a mathematical aproximation, it does’t have this bug.</p>

<p><img alt="before" src="http://media.tumblr.com/5b03933a3b75e67527835721a4b90be7/tumblr_inline_nhiovfTg641rjpdtt.jpg"/><img alt="after" src="http://media.tumblr.com/58a0da21f99d64afd9d3e5043a91954c/tumblr_inline_nhiovhlrDw1rjpdtt.jpg"/><br/><img alt="before" src="http://media.tumblr.com/e29218b13f72a40f3dd5ef1beeeb82ce/tumblr_inline_nhiovkpiga1rjpdtt.jpg"/><img alt="after" src="http://media.tumblr.com/c8b640549e0dd3cbae1053ebfb389bb0/tumblr_inline_nhiovo3vnS1rjpdtt.jpg"/></p>

<p>The images on the left have been blurred with radius 5 in the previous version (considering the double radius bug). The ones on the right have been blurred using the new version. You can see the sharp object edges in the images on the left.</p>

  

<div class="callout">  
  <h5>Pillow in Uploadcare</h5>
  <p>
  All of these changes already work on our servers. Thanks to them we have increased speed and quality of our <a href="https://uploadcare.com/documentation/cdn/#image-operations">on-the-fly image processing API</a>. We also were able to implement the <a href="https://uploadcare.com/documentation/cdn/#operation-blur">fast blur</a>. But this is not all. We are preparing for another big step with Pillow, and we’ll announce it shortly.</p>
  <p><a href="https://uploadcare.com/upload-api-cloud-storage-and-cdn/#crop-resize-and-transform-uploaded-images">See where do we use Pillow</a></p>
</div>
        </section>

        </div></body></html>