<html><body><div><div class="content_body" data-subscribe="true" data-view="content#body"><p>I had a <a href="https://www.toptal.com/python/job-description">programming interview</a> recently, a phone-screen in which we used a <a href="https://code.stypi.com">collaborative text editor</a>.</p>

<p>I was asked to implement a <a href="https://www.toptal.com/api-developers/5-golden-rules-for-designing-a-great-web-api">certain API</a>, and chose to do so in <a href="https://www.toptal.com/python">Python</a>. Abstracting away the problem statement, let’s say I needed a class whose instances stored some <code>data</code> and some <code>other_data</code>.</p>

<p>I took a deep breath and started typing. After a few lines, I had something like this:</p>

<pre><code>class Service(object):
    data = []

    def __init__(self, other_data):
        self.other_data = other_data
    ...
</code></pre>

<p>My interviewer stopped me:</p>

<ul>
  <li>Interviewer: “That line: <code>data = []</code>. I don’t think that’s valid Python?”</li>
  <li>Me: “I’m pretty sure it is. It’s just setting a default value for the instance attribute.”</li>
  <li>Interviewer: “When does that code get executed?”</li>
  <li>Me: “I’m not really sure. I’ll just fix it up to avoid confusion.”</li>
</ul>

<p>For reference, and to give you an idea of what I was going for, here’s how I amended the code:</p>

<pre><code>class Service(object):

    def __init__(self, other_data):
        self.data = []
        self.other_data = other_data
    ...
</code></pre>

<p>As it turns out, we were both wrong. The real answer lay in understanding the distinction between class and instance attributes.</p>

<p class="is-centered"><img src="//assets.toptal.io/uploads/blog/image/302/toptal-blog-image-1392824783170.png" alt="Python class attributes vs. Python instance attributes"/></p>

<p><em>Note: if you have an expert handle on class attributes, you can skip ahead to <a href="#so-when-would-you-use-them">use cases</a>.</em></p>

<h2 id="class-attributes">Class Attributes</h2>

<p>My interviewer was wrong in that the above code <em>is</em> syntactically valid.</p>

<p>I too was wrong in that it isn’t setting a “default value” for the instance attribute. Instead, it’s defining <code>data</code> as a <em>class</em> attribute with value <code>[]</code>.</p>

<p>In my experience, class attributes are a topic that <em>many</em> people know <em>something</em> about, but few understand completely.</p>

<h3 id="whats-the-difference">What’s the difference?</h3>

<p>A class attribute is an attribute of the class (circular, I know), rather than an attribute of an <em>instance</em> of a class.</p>

<p>Let’s use an example to illustrate the difference. Here, <code>class_var</code> is a class attribute, and <code>i_var</code> is an instance attribute:</p>

<pre lang="python"><code>class MyClass(object):
    class_var = 1

    def __init__(self, i_var):
        self.i_var = i_var
</code></pre>

<p>Note that all instances of the class have access to <code>class_var</code>, and that it can also be accessed as a property of the <em>class itself</em>:</p>

<pre lang="python"><code>foo = MyClass(2)
bar = MyClass(3)

foo.class_var, foo.i_var
## 1, 2
bar.class_var, bar.i_var
## 1, 3
MyClass.class_var ## &lt;— This is key
## 1
</code></pre>

<p>For Java or C++ programmers, the class attribute is similar—but not identical—to the static member. We’ll see how they differ <a href="#Handling-assignment">below</a>.</p>

<h3 id="class-vs-instance-namespaces">Class vs. instance namespaces</h3>

<p>To understand what’s happening here, let’s talk briefly about Python namespaces.</p>

<p>A <a href="http://docs.python.org/2/tutorial/classes.html">namespace</a> is a mapping from names to objects, with the property that there is zero relation between names in different namespaces. They’re usually implemented as Python dictionaries, although this is abstracted away.</p>

<p>Depending on the context, you may need to access a namespace using dot syntax (e.g., <code>object.name_from_objects_namespace</code>) or as a local variable (e.g., <code>object_from_namespace</code>). As a concrete example:</p>

<pre lang="python"><code>class MyClass(object):
    ## No need for dot syntax
    class_var = 1

    def __init__(self, i_var):
        self.i_var = i_var

## Need dot syntax as we've left scope of class namespace
MyClass.class_var
## 1
</code></pre>

<p>Python classes <em>and</em> instances of classes each have their own distinct namespaces represented by <a href="http://www2.lib.uchicago.edu/keith/courses/python/class/5/##classinst">pre-defined attributes</a> <code>MyClass.__dict__</code> and <code>instance_of_MyClass.__dict__</code>, respectively.</p>

<p>When you try to access an attribute from an instance of a class, it first looks at its <em>instance</em> namespace. If it finds the attribute, it returns the associated value. If not, it <em>then</em> looks in the <em>class</em> namespace and returns the attribute (if it’s present, throwing an error otherwise). For example:</p>

<pre lang="python"><code>foo = MyClass(2)

## Finds i_var in foo's instance namespace
foo.i_var
## 2

## Doesn't find class_var in instance namespace…
## So look's in class namespace (MyClass.__dict__)
foo.class_var
## 1
</code></pre>

<p>The instance namespace takes supremacy over the class namespace: if there is an attribute with the same name in both, the instance namespace will be checked first and its value returned. Here’s a simplified version of the code (<a href="http://www2.lib.uchicago.edu/keith/courses/python/class/5/##classinst">source</a>) for attribute lookup:</p>

<pre lang="python"><code>def instlookup(inst, name):
    ## simplified algorithm...
    if inst.__dict__.has_key(name):
        return inst.__dict__[name]
    else:
        return inst.__class__.__dict__[name]
</code></pre>

<p>And, in visual form:</p>

<p class="is-centered"><img src="//assets.toptal.io/uploads/blog/image/301/toptal-blog-image-1392824596580.png" alt="attribute lookup in visual form"/></p>

<h3 id="handling-assignment">Handling assignment</h3>

<p>With this in mind, we can make sense of how class attributes handle assignment:</p>

<ul>
  <li>
    <p>If a class attribute is set by accessing the class, it will override the value for <em>all</em> instances. For example:</p>

    <pre lang="python"><code>foo = MyClass(2)
foo.class_var
## 1
MyClass.class_var = 2
foo.class_var
## 2
</code></pre>

    <p><em>At the namespace level…</em> we’re setting <code>MyClass.__dict__['class_var'] = 2</code>. (Note: this <a href="http://stackoverflow.com/questions/432786/how-can-i-assign-a-new-class-attribute-via-dict-in-python">isn’t the exact code</a> (which would be <code>setattr(MyClass, 'class_var', 2)</code>) as <code>__dict__</code> returns a <a href="http://me.veekun.com/blog/2013/08/05/dictproxyhack-or-activestate-code-considered-harmful/##dictproxy">dictproxy</a>, an immutable wrapper that prevents direct assignment, but it helps for demonstration’s sake). Then, when we access <code>foo.class_var</code>, <code>class_var</code> has a new value in the class namespace and thus 2 is returned.</p>
  </li>
  <li>
    <p>If a class variable is set by accessing an instance, it will override the value <em>only for that instance</em>. This essentially overrides the class variable and turns it into an instance variable available, intuitively, <em>only for that instance</em>. For example:</p>

    <pre lang="python"><code>foo = MyClass(2)
foo.class_var
## 1
foo.class_var = 2
foo.class_var
## 2
MyClass.class_var
## 1
</code></pre>

    <p><em>At the namespace level…</em> we’re adding the <code>class_var</code> attribute to <code>foo.__dict__</code>, so when we lookup <code>foo.class_var</code>, we return 2. Meanwhile, other instances of <code>MyClass</code> will <em>not</em> have <code>class_var</code> in their instance namespaces, so they continue to find <code>class_var</code> in <code>MyClass.__dict__</code> and thus return 1.</p>
  </li>
</ul>

<h3 id="mutability">Mutability</h3>

<p>Quiz question: What if your class attribute has a <strong>mutable type</strong>? You can manipulate (mutilate?) the class attribute by accessing it through a particular instance and, in turn, end up <em>manipulating the referenced object that all instances are accessing</em> (as pointed out by <a href="http://timothyawiseman.wordpress.com/2012/10/06/class-and-instance-variables-in-python-2-7/">Timothy Wiseman</a>).</p>

<p>This is best demonstrated by example. Let’s go back to the <code>Service</code> I defined earlier and see how my use of a class variable could have led to problems down the road.</p>

<pre lang="python"><code>class Service(object):
    data = []

    def __init__(self, other_data):
        self.other_data = other_data
    ...
</code></pre>

<p>My goal was to have the empty list (<code>[]</code>) as the default value for <code>data</code>, and for each instance of <code>Service</code> to have <em>its own data</em> that would be altered over time on an instance-by-instance basis. But in this case, we get the following behavior (recall that <code>Service</code> takes some argument <code>other_data</code>, which is arbitrary in this example):</p>

<pre lang="python"><code>s1 = Service(['a', 'b'])
s2 = Service(['c', 'd'])

s1.data.append(1)

s1.data
## [1]
s2.data
## [1]

s2.data.append(2)

s1.data
## [1, 2]
s2.data
## [1, 2]
</code></pre>

<p>This is no good—altering the class variable via one instance alters it for all the others!</p>

<p><em>At the namespace level…</em> all instances of <code>Service</code> are accessing and modifying the same list in <code>Service.__dict__</code> without making their own <code>data</code> attributes in their instance namespaces.</p>

<p>We could get around this using assignment; that is, instead of exploiting the list’s mutability, we could assign our <code>Service</code> objects to have their own lists, as follows:</p>

<pre lang="python"><code>s1 = Service(['a', 'b'])
s2 = Service(['c', 'd'])

s1.data = [1]
s2.data = [2]

s1.data
## [1]
s2.data
## [2]
</code></pre>

<p>In this case, we’re adding <code>s1.__dict__['data'] = [1]</code>, so the original <code>Service.__dict__['data']</code> remains unchanged.</p>

<p>Unfortunately, this requires that <code>Service</code> users have intimate knowledge of its variables, and is certainly prone to mistakes. In a sense, we’d be addressing the symptoms rather than the cause. We’d prefer something that was correct by construction.</p>

<p>My personal solution: if you’re just using a class variable to assign a default value to a would-be instance variable, <strong><em>don’t use mutable values</em></strong>. In this case, every instance of <code>Service</code> was going to override <code>Service.data</code> with its own instance attribute eventually, so using an empty list as the default led to a tiny bug that was easily overlooked. Instead of the above, we could’ve either:</p>

<ol>
  <li>Stuck to instance attributes entirely, as demonstrated in the introduction.</li>
  <li>
    <p>Avoided using the empty list (a mutable value) as our “default”:</p>

    <pre><code>class Service(object):
    data = None

    def __init__(self, other_data):
        self.other_data = other_data
    ...
</code></pre>

    <p>Of course, we’d have to handle the <code>None</code> case appropriately, but that’s a small price to pay.</p>
  </li>
</ol>

<h2 id="so-when-would-you-use-them">So when <em>would</em> you use them?</h2>

<p>Class attributes are tricky, but let’s look at a few cases when they would come in handy:</p>

<ol>
  <li>
    <p><em>Storing constants</em>. As class attributes can be accessed as attributes of the class itself, it’s often nice to use them for storing Class-wide, Class-specific constants. For example:</p>

    <pre><code>class Circle(object):
    pi = 3.14159

    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return Circle.pi * self.radius * self.radius

Circle.pi
## 3.14159

c = Circle(10)
c.pi
## 3.14159
c.area()
## 314.159
</code></pre>
  </li>
  <li>
    <p><em>Defining <a href="http://www.python.org/doc/essays/ppt/acm-ws/sld052.htm">default values</a></em>. As a trivial example, we might create a bounded list (i.e., a list that can only hold a certain number of elements or fewer) and choose to have a default cap of 10 items:</p>

    <pre><code>class MyClass(object):
    limit = 10

    def __init__(self):
        self.data = []

    def item(self, i):
        return self.data[i]

    def add(self, e):
        if len(self.data) &gt;= self.limit:
            raise Exception("Too many elements")
        self.data.append(e)

MyClass.limit
## 10
</code></pre>

    <p>We could then create instances with their own specific limits, too, by assigning to the instance’s <code>limit</code> attribute.</p>

    <pre lang="python"><code>foo = MyClass()
foo.limit = 50
## foo can now hold 50 elements—other instances can hold 10
</code></pre>

    <p>This only makes sense if you will want your typical instance of <code>MyClass</code> to hold just 10 elements or fewer—if you’re giving all of your instances different limits, then <code>limit</code> should be an instance variable. (Remember, though: take care when using mutable values as your defaults.)</p>
  </li>
  <li>
    <p><em>Tracking all data across all instances of a given class</em>. This is sort of specific, but I could see a scenario in which you might want to access a piece of data related to every existing instance of a given class.</p>

    <p>To make the scenario more concrete, let’s say we have a <code>Person</code> class, and every person has a <code>name</code>. We want to keep track of all the names that have been used. One approach might be to <a href="http://stackoverflow.com/questions/328851/printing-all-instances-of-a-class">iterate over the garbage collector’s list of objects</a>, but it’s simpler to use class variables.</p>

    <p><em>Note that, in this case, <code>names</code> will only be accessed as a class variable, so the mutable default is acceptable.</em></p>

    <pre lang="python"><code>class Person(object):
    all_names = []

    def __init__(self, name):
        self.name = name
        Person.all_names.append(name)

joe = Person('Joe')
bob = Person('Bob')
print Person.all_names
## ['Joe', 'Bob']
</code></pre>

    <p>We could even use this design pattern to track all existing instances of a given class, rather than just some associated data.</p>

    <pre lang="python"><code>class Person(object):
    all_people = []

    def __init__(self, name):
        self.name = name
        Person.all_people.append(self)

joe = Person('Joe')
bob = Person('Bob')
print Person.all_people
## [&lt;__main__.Person object at 0x10e428c50&gt;, &lt;__main__.Person object at 0x10e428c90&gt;]
</code></pre>
  </li>
  <li>
    <p><em>Performance</em> (sort of… see below).</p>
  </li>
</ol>



<h2 id="under-the-hood">Under-the-hood</h2>

<p><em>Note: If you’re worrying about performance at this level, you might not want to be use Python in the first place, as the differences will be on the order of tenths of a millisecond—but it’s still fun to poke around a bit, and helps for illustration’s sake.</em></p>

<p>Recall that a class’s namespace is created and filled in at the time of the class’s definition. That means that we do just one assignment—<em>ever</em>—for a given class variable, while instance variables must be assigned every time a new instance is created. Let’s take an example.</p>

<pre lang="python"><code>def called_class():
    print "Class assignment"
    return 2

class Bar(object):
    y = called_class()

    def __init__(self, x):
        self.x = x

## "Class assignment"

def called_instance():
    print "Instance assignment"
    return 2

class Foo(object):
    def __init__(self, x):
        self.y = called_instance()
        self.x = x

Bar(1)
Bar(2)
Foo(1)
## "Instance assignment"
Foo(2)
## "Instance assignment"
</code></pre>

<p>We assign to <code>Bar.y</code> just once, but <code>instance_of_Foo.y</code> on every call to <code>__init__</code>.</p>

<p>As further evidence, let’s use the <a href="http://docs.python.org/library/dis.html">Python disassembler</a>:</p>

<pre lang="python"><code>import dis

class Bar(object):
    y = 2

    def __init__(self, x):
        self.x = x

class Foo(object):
    def __init__(self, x):
        self.y = 2
        self.x = x

dis.dis(Bar)
##  Disassembly of __init__:
##  7           0 LOAD_FAST                1 (x)
##              3 LOAD_FAST                0 (self)
##              6 STORE_ATTR               0 (x)
##              9 LOAD_CONST               0 (None)
##             12 RETURN_VALUE

dis.dis(Foo)
## Disassembly of __init__:
## 11           0 LOAD_CONST               1 (2)
##              3 LOAD_FAST                0 (self)
##              6 STORE_ATTR               0 (y)

## 12           9 LOAD_FAST                1 (x)
##             12 LOAD_FAST                0 (self)
##             15 STORE_ATTR               1 (x)
##             18 LOAD_CONST               0 (None)
##             21 RETURN_VALUE
</code></pre>

<p>When we look at the byte code, it’s again obvious that <code>Foo.__init__</code> has to do two assignments, while <code>Bar.__init__</code> does just one.</p>

<p>In practice, what does this gain really look like? I’ll be the first to admit that timing tests are highly dependent on often uncontrollable factors and the differences between them are often hard to explain accurately.</p>

<p>However, I think these small snippets (run with the Python <a href="http://docs.python.org/library/timeit.html">timeit</a> module) help to illustrate the differences between class and instance variables, so I’ve included them anyway.</p>

<p><em>Note: I’m on a MacBook Pro with OS X 10.8.5 and Python 2.7.2.</em></p>

<h3 id="initialization">Initialization</h3>

<pre><code>10000000 calls to `Bar(2)`: 4.940s
10000000 calls to `Foo(2)`: 6.043s
</code></pre>

<p>The initializations of <code>Bar</code> are faster by over a second, so the difference here does appear to be statistically significant.</p>

<p>So why is this the case? One <em>speculative</em> explanation: we do two assignments in <code>Foo.__init__</code>, but just one in <code>Bar.__init__</code>.</p>

<h3 id="assignment">Assignment</h3>

<pre><code>10000000 calls to `Bar(2).y = 15`: 6.232s
10000000 calls to `Foo(2).y = 15`: 6.855s
10000000 `Bar` assignments: 6.232s - 4.940s = 1.292s
10000000 `Foo` assignments: 6.855s - 6.043s = 0.812s
</code></pre>

<p><em>Note: There’s no way to re-run your setup code on each trial with <a href="http://docs.python.org/library/timeit.html">timeit</a>, so we have to reinitialize our variable on our trial. The second line of times represents the above times with the previously calculated initialization times deducted.</em></p>

<p>From the above, it looks like <code>Foo</code> only takes about 60% as long as <code>Bar</code> to handle assignments.</p>

<p>Why is this the case? One <em>speculative</em> explanation: when we assign to <code>Bar(2).y</code>, we first look in the instance namespace (<code>Bar(2).__dict__[y]</code>), fail to find <code>y</code>, and then look in the class namespace (<code>Bar.__dict__[y]</code>), then making the proper assignment. When we assign to <code>Foo(2).y</code>, we do half as many lookups, as we immediately assign to the instance namespace (<code>Foo(2).__dict__[y]</code>).</p>

<p>In summary, though these performance gains won’t matter in reality, these tests are interesting at the conceptual level. If anything, I hope these differences help illustrate the mechanical distinctions between class and instance variables.</p>

<h2 id="in-conclusion">In Conclusion</h2>

<p>Class attributes seem to be underused in Python; a lot of programmers have different impressions of how they work and why they might be helpful.</p>

<p>My take: class variables have their place within the school of good code. When used with care, they can simplify things and improve readability. But when carelessly thrown into a given class, they’re sure to trip you up.</p>

<h2 id="appendix-private-instance-variables"><em>Appendix</em>: Private instance variables</h2>

<p>One thing I wanted to include but didn’t have a natural entrance point…</p>

<p>Python doesn’t have <em>private</em> variables so-to-speak, but another interesting relationship between class and instance naming comes with name mangling.</p>

<p>In the Python style guide, it’s said that pseudo-private variables should be prefixed with a double underscore: ‘__’. This is not only a sign to others that your variable is meant to be treated privately, but also a way to prevent access to it, of sorts. Here’s what I mean:</p>

<pre lang="python"><code>class Bar(object):
    def __init__(self):
    self.__zap = 1

a = Bar()
a.__zap
## Traceback (most recent call last):
##   File "&lt;stdin&gt;", line 1, in &lt;module&gt;
## AttributeError: 'Bar' object has no attribute '__baz'

## Hmm. So what's in the namespace?
a.__dict__
{'_Bar__zap': 1}
a._Bar__zap
## 1
</code></pre>

<p>Look at that: the instance attribute <code>__zap</code> is automatically prefixed with the class name to yield <code>_Bar__zap</code>.</p>

<p>While still settable and gettable using <code>a._Bar__zap</code>, this name mangling is a means of creating a ‘private’ variable as it prevents you <em>and</em> others from accessing it by accident or through ignorance.</p>

<p><em>Edit: as Pedro Werneck kindly pointed out, this behavior is largely intended to help out with subclassing. In the <a href="http://legacy.python.org/dev/peps/pep-0008/#designing-for-inheritance">PEP 8 style guide</a>, they see it as serving two purposes: (1) preventing subclasses from accessing certain attributes, and (2) preventing namespace clashes in these subclasses. While useful, variable mangling shouldn’t be seen as an invitation to write code with an assumed public-private distinction, such as is present in Java.</em></p>


<p class="template" data-role="subscribe_template" data-template="{&quot;html&quot;:&quot;\u003cdiv class=\&quot;embeddable_form-wrapper\&quot; data-view=\&quot;blog_subscribe#form\&quot;\u003e\u003cform action=\&quot;/blog/subscription\&quot; class=\&quot;embeddable_form for-post\&quot; data-entity=\&quot;blog_subscription\&quot; data-remote=\&quot;\&quot; data-view=\&quot;form#form\&quot; method=\&quot;post\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-step is-email_form is-current\&quot; data-role=\&quot;step\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-row is-label\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-label_title\&quot;\u003eLike what you\u0026#39;re reading?\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-label\&quot;\u003eGet the latest updates first.\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row form-field is-email_field\&quot;\u003e\u003cinput autocomplete=\&quot;off\&quot; class=\&quot;input is-medium\&quot; data-role=\&quot;email\&quot; name=\&quot;blog_subscription[email]\&quot; placeholder=\&quot;Enter your email address...\&quot; type=\&quot;text\&quot; /\u003e\u003cinput name=\&quot;blog_subscription[vertical]\&quot; type=\&quot;hidden\&quot; value=\&quot;developers\&quot; /\u003e\u003cinput name=\&quot;from_widget\&quot; type=\&quot;hidden\&quot; value=\&quot;true\&quot; /\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-submit\&quot;\u003e\u003cinput class=\&quot;button is-green_candy is-default is-full_width\&quot; data-loader-text=\&quot;Subscribing...\&quot; data-role=\&quot;submit\&quot; type=\&quot;submit\&quot; value=\&quot;Get Exclusive Updates\&quot; /\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-privacy\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-privacy\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-privacy_icon\&quot;\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-privacy_text\&quot;\u003eNo spam. Just great engineering and design posts.\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-step is-confirmation\&quot; data-role=\&quot;step\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-row is-label is-success\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-label_title\&quot;\u003eLike what you\u0026#39;re reading?\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-label\&quot;\u003eGet the latest updates first.\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-success\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-label is-header\&quot;\u003eThank you for subscribing!\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-label\&quot;\u003eYou can edit your subscription preferences \u003ca href='#' data-role='preferences_link'\u003ehere\u003c/a\u003e.\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-success\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-done\&quot;\u003e\u003cul class=\&quot;blog_follow_us\&quot;\u003e\u003cul class=\&quot;social_share\&quot;\u003e\u003cli class=\&quot;social_share-item is-facebook\&quot;\u003e\u003cdiv class=\&quot;fb-like\&quot; data-href=\&quot;https://www.toptal.com/blog\&quot; data-layout=\&quot;button_count\&quot; data-send=\&quot;false\&quot; data-show-faces=\&quot;false\&quot; data-width=\&quot;450\&quot;\u003e\u003c/div\u003e\u003c/li\u003e\u003cli class=\&quot;social_share-item is-twitter_follow\&quot;\u003e\u003ca class=\&quot;twitter-follow-button\&quot; data-show-count=\&quot;true\&quot; href=\&quot;https://twitter.com/toptalllc\&quot;\u003eFollow @toptalllc\u003c/a\u003e\u003c/li\u003e\u003cli class=\&quot;social_share-item is-google_plus_follow\&quot;\u003e\u003cdiv class=\&quot;g-follow\&quot; data-annotation=\&quot;bubble\&quot; data-height=\&quot;20\&quot; data-href=\&quot;https://plus.google.com/109028009576318848424\&quot; data-rel=\&quot;publisher\&quot;\u003e\u003c/div\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/form\u003e\u003c/div\u003e&quot;}"/></div></div></body></html>