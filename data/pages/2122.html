<html><body><div><div class="content html_format">
      
<em>Продолжение перевода статей о Django с сайта <a href="http://effectivedjango.com/">effectivedjango.com</a>. Наткнулся я на этот сайт во время изучения данного фреймворка. Информация размещенная на этом ресурсе показалась мне полезной, но так как нигде не нашел перевода на русский, решил сделать сие доброе дело сам. Этот цикл статей, как мне думается, будет полезен веб-разработчикам, которые делают только первые шаги в изучении Django.</em>
<a name="habracut"/>
<hr/>
<a name="contents"/><h1>Оглавление</h1><ul>
<li><a href="http://habrahabr.ru/post/240463/#introduction">Введение</a></li>
<li>Эффективный Django. Руководство<br/>
 </li>
<li>Тестирование в Django</li>
<li>Понимание Middleware'ов</li>
<li>Базы данных и модели</li>
<li>Представления-классы (CBV)</li>
<li>Формы</li>
</ul>
<a name="chapter_03"/><h1>Глава 3. Пишем представление <a href="#contents" title="к оглавлению">⇧</a></h1>
<h2>3.1. Основы представлений</h2><p>
Представления Django получают </p><abbr title="HTTP Request"><a href="https://docs.djangoproject.com/en/1.7/ref/request-response/#httprequest-objects">HTTP запрос</a></abbr><p> и возвращает пользователю </p><abbr title="HTTP Response"><a href="https://docs.djangoproject.com/en/1.7/ref/request-response/#httpresponse-objects">HTTP ответ</a></abbr><p>:
</p><p>
Любой вызываемый объект языка Python может быть представлением. Единственное </p><abbr title="hard and fast">жесткое и необходимое</abbr><p> требование заключается в том, что вызываемый объект Python должен принимать </p><abbr title="request object">объект запроса</abbr><p> в качестве первого аргумента (обычно этот параметр так и именуют — </p><code>request</code><p>). Это означает, что минимальное представление будет очень простым:

</p><pre><code class="python">from django.http import HttpResponse

def hello_world(request):
    return HttpResponse("Hello, World")
</code></pre><p>
Конечно, как и большинство других фреймворков, Django позволяет вам передавать аргументы в представление через URL. Мы поговорим об этом, когда будем строить наше приложение.

</p><h2>3.2. <abbr title="generic">Общие</abbr> представления и <abbr title="class-based views">представления-классы</abbr></h2>
<ul>
<li><a href="https://docs.djangoproject.com/en/1.7/topics/class-based-views/generic-display/">общие представления</a> всегда предоставляют какой-нибудь базовый функционал: <abbr title="render">визуализировать</abbr> шаблон, перенаправить, создать, отредактировать модель и т. д.</li>
<li>начиная с версии 1.3, для общих представлений в Django появились <abbr title="class-based views"><a href="https://docs.djangoproject.com/en/1.7/topics/class-based-views/">представления-классы</a></abbr> (CBV);</li>
<li>общие представления и CBV предоставляют более высокий уровень абстракции и компонуемости;</li>
<li>кроме того, они скрывают немало сложности, которая иначе могла бы сбить с толку новичков;</li>
<li>к счастью, в новых версиях Django документация всего этого стала намного лучше.</li>
</ul><p>
Django 1.3 вводит представления-классы на которых мы сосредоточимся в этой главе. Представления-классы или CBV, могут устранить много шаблонного кода из ваших представлений, особенно из представлений для редактирования чего-либо, где вы хотите предпринимать различные действия для GET и POST запросов. Представления-классы дадут вам возможность собирать функционал по частям. Недостаток заключается в том, что вся эта мощь влечет за собой некоторое дополнительное усложнение.

</p><h2>3.3. Представления-классы (CBV)</h2><p>
Минимальное представление, реализованное как CBV, является наследником класса </p><code>View</code> <sup><a href="https://docs.djangoproject.com/en/1.7/ref/class-based-views/base/#view">doc</a></sup><p> и реализует поддерживаемые HTTP-методы. Ниже находится очень небольшое представление «Hello, World» написанное нами ранее, но выполненное в виде представления-класса:

</p><pre><code class="python">from django.http import HttpResponse
from django.views.generic import View

class MyView(View):

      def get(self, request, *args, **kwargs):
      	  return HttpResponse("Hello, World")
</code></pre><p>
В представлении-классе имена методов HTTP отображаются на методы класса. В нашем случае мы определили обработчик для GET-запроса используя метод класса </p><code>get</code><p>. Точно так же, как при реализации функцией, этот метод принимает объект запроса в качестве первого параметра и возвращает HTTP ответ.

</p><blockquote><b><u>Примечание:</u> <abbr title="Permissive Signatures">Допустимые сигнатуры</abbr></b><br/>
Вы можете заметить несколько дополнительных аргументов в сигнатуре функции, по сравнению с представлением написанным нами ранее, в частности <code>*args</code> и <code>**kwargs</code>. CBV впервые были создавались для того, что бы сделать «общие» представления Django более гибкими. Подразумевалось, что они будут использоваться в множестве различных контекстов, с потенциально различными аргументами, извлеченными из URL. Занимаясь последний год написанием представлений-классов, я продолжаю писать их используя допустимые сигнатуры, и каждый раз это оказывается полезным в неожиданных ситуациях.</blockquote>
<h2>3.4. Вывод перечня контактов</h2><p>
Мы начнем с представления, которое выводит список контактов из базы данных.
</p><p>
Базовая реализация представления очень коротка. Мы можем написать его всего-лишь в несколько строк. Для этого в файле </p><code>views.py</code><p> нашего приложения </p><code>contacts</code><p> наберем следующий код:

</p><pre><code class="python">from django.views.generic import ListView

from contacts.models import Contact

class ListContactView(ListView):

      model = Contact
</code></pre><p>
Класс </p><code>ListView</code> <sup><a href="https://docs.djangoproject.com/en/1.7/ref/class-based-views/generic-display/#listview">doc</a></sup><p>, от которого мы наследовали представление, сам составлен из нескольких </p><abbr title="mixins">примесей</abbr><p>, которые реализуют некоторое поведение. Это дает нам большую мощь при малом количестве кода. В нашем случае мы указали модель (</p><code>model = Contact</code><p>), что заставит это представление вывести список </p><u>всех</u><p> контактов модели </p><code>Contact</code><p> из нашей базы данных.

</p><h2>3.5. Определяем URL'ы</h2><p>
Конфигурация URL (URLconf) указывает Django как по адресу запроса найти ваш Python-код. Django смотрит конфигурацию URL, которая определена в переменной </p><code>urlpatterns</code><p> файла </p><code>urls.py</code><p>.
</p><p>
Давайте добавим в файл </p><code>addressbook/urls.py</code><p> URL-шаблон для нашего представления, которое отображает список контактов:

</p><pre><code class="python">from django.conf.urls import patterns, include, url

import contacts.views

urlpatterns = patterns('',
    url(r'^$', contacts.views.ListContactView.as_view(),
        name='contacts-list',),
)
</code></pre>
<ul>
<li>использование функции <code>url()</code> не является строго обязательным, но я предпочитаю использовать ее: когда вы начнете добавлять больше информации в URL-шаблоны, она позволит вам использовать именованные параметры, делая код более чистым;</li>
<li>первый параметр принимаемый функцией <code>url()</code> — это регулярное выражение. Обратите внимание на замыкающий символ <code>$</code>; как думаете, почему он важен?</li>
<li>вторым параметром указывается вызываемое представление. Это может быть как непосредственно вызываемый объект (импортированный вручную), так и строка описывающая его. Если это строка, то в случае соответствия URL-шаблона строке запроса, Django сам импортирует необходимый модуль (до последней точки), и вызовет последний сегмент строки (после последней точки);</li>
<li>замете, что когда мы используем представление-класс, мы <u>обязаны</u> использовать реальный объект, а не строку описывающую этот объект. Мы должны так делать из за того, что мы вызываем метод класса <code>as_view()</code>. Этот метод возвращает обертку над нашим классом, которую может вызвать диспетчер URL Django;</li>
<li>имя, данное URL-шаблону, позволят вам делать <abbr title="reverse lookup">обратный поиск</abbr>;</li>
<li>имя URL полезно, когда вы ссылаетесь из одного представления на другое, или выполняете перенаправление, так как вы можете управлять структурой URL'ов из одного места.</li>
</ul><p>
В то время, как переменная </p><code>urlpatterns</code><p> должна быть определена, Django также позволяет вам определить несколько других значений (</p><em>переменных</em><p>) для исключительных ситуаций. Эти значения включают в себя </p><code>handler403</code><p>, </p><code>handler404</code><p>, и </p><code>handler500</code><p>, которые указывают Django, какое представление использовать в случае ошибки HTTP. Для более подробной информации смотрите </p><a href="https://docs.djangoproject.com/en/1.7/ref/urls/#handler403">документацию Django</a><p> по конфигурации URL.

</p><blockquote><b><u>Примечание:</u> Ошибки импортирования конфигурации URL</b><br/>
Django загружает конфигурацию URL очень рано во время старта и пытается импортировать найденные внутри модули. Если хотя бы одна из операций импорта обернется неудачей, сообщение об ошибке может быть немного непонятным. Если ваш проект перестал работать по причине ошибки импорта, попробуйте импортировать конфигурацию URL в интерактивной оболочке. Это позволяет, в большинстве случаев, определить в каком месте возникли проблемы.</blockquote>
<h2>3.6. Создание Шаблона</h2><p>
Сейчас, определив URL для нашего представления списка контактов, мы можем испробовать его. Django включает в себя сервер подходящий для целей разработки, который вы можете использовать для тестирования вашего проекта:

</p><pre><code>(venv:tutorial)$ python ./manage.py runserver 0.0.0.0:8080
Validating models...

0 errors found
November 04, 2014 - 15:25:05
Django version 1.6.7, using settings 'addressbook.settings'
Starting development server at http://0.0.0.0:8080/
Quit the server with CONTROL-C.
</code></pre><p>
Если вы посетите </p><a href="http://localhost:8080/">http://localhost:8080/</a><p> в вашем браузере, вы все же получите ошибку </p><code>TemplateDoesNotExists</code>
<blockquote><em><u>Примечание переводчика:</u></em><br/>
<em><code>localhost</code> указывайте в том случае, если запускаете браузер с того же хоста, где запущен сервер. Если сервер у вас запущен на другом хосте (как у меня) — вместо <code>localhost</code> укажите IP адрес этого хоста (в моем случае это <code>192.168.1.51</code>).</em></blockquote>
<a href="http://habrastorage.org/files/406/8ef/bd1/4068efbd1136477fac00d8d86ef57ca9.png"/><p>
Большинство общих представлений Django (сюда относиться, </p><code>ListView</code><p> использованный нами) имеет предустановленное имя шаблона, который они ожидают найти. Мы можем увидеть в этом сообщении об ошибке, что представление ожидало найти файл шаблона с именем </p><code>contact_list.html</code><p>, которое было получено из имени модели. Давайте создадим такой шаблон.
</p><p>
По умолчанию, Django ищет шаблоны в приложениях, так же как и в директориях, указанных в </p><code>settings.TEMPLATE_DIRS</code><p>. Общие представления ожидают, что шаблоны найдутся в директории приложения (в данном случае в директории </p><code>contacts</code><p>), и имя файла будет содержать имя модели (в данном случае ожидаемое имя файла: </p><code>contact_list.html</code><p>). Это приходится кстати, когда вы разрабатываете приложения для повторного использования: пользователь вашего приложения может создать свои шаблоны, которые перекроют шаблоны по умолчанию, и они будут хранится в директории, прямо связанной с приложением.

</p><blockquote><em><u>Примечание переводчика:</u></em><br/>
<em>Django ожидает, что искомый шаблон находится по адресу <code>имя_приложения/templates/имя_приложения/имя_шаблона</code></em></blockquote><p>
Для наших целей, однако, нам не нужен дополнительный слой из структур директорий, так что мы определим шаблон явно, использую свойство </p><code>template_name</code><p> нашего представления-класса. Давайте добавим одну строчку в </p><code>views.py</code><p>:

</p><pre><code class="python">from django.views.generic import ListView

from contacts.models import Contact

class ListContactView(ListView):

      model = Contact
      template_name = 'contact_list.html'
</code></pre><p>
Создадим в директории </p><code>contacts</code><p> (это директория с приложением) поддиректорию </p><code>templates</code><p>, а в ней создадим файл шаблона </p><code>contact_list.html</code><p>:

</p><pre><code class="django">&lt;h1&gt;Contacts&lt;/h1&gt;

&lt;ul&gt;
	{% for contact in object_list %}
	&lt;li class="contact"&gt;{{ contact }}&lt;/li&gt;
	{% endfor %}
&lt;/ul&gt;
</code></pre><p>
Открыв заново (или обновив) в браузере страницу </p><a href="http://localhost:8080/">http://localhost:8080/</a><p>, вы должны будете увидеть как минимум один контакт, созданный нами ранее через интерактивную оболочку.

</p><a href="http://habrastorage.org/files/a20/34f/294/a2034f294bf34cb9a0b07640c75c6f86.png"><img src="https://habrastorage.org/files/77c/40f/097/77c40f097ead4c5fa46f8a03bd83cb33.png"/></a>

<h2>3.7. Создаем контакты</h2><p>
Добавление информации в базу данных через интерактивную оболочку занимает слишком много времени, так что давайте создадим представление для добавления новых контактов.
</p><p>
Так же как и в случае с выводом списка контактов, воспользуемся одним из общих представлений Django. В файле </p><code>views.py</code><p> мы добавим несколько строчек:

</p><pre><code class="python">from django.core.urlresolvers import reverse
from django.views.generic import ListView
from django.views.generic import CreateView

from contacts.models import Contact

class ListContactView(ListView):

	model = Contact
	template_name = 'contact_list.html'

class CreateContactView(CreateView):

	model = Contact
	template_name = 'edit_contact.html'

	def get_success_url(self):
		return reverse('contacts-list')
</code></pre>
<blockquote><em><u>Примечание переводчика:</u></em><br/>
<em>Если вы используете Django версии &gt;= 1.7, то можете добавить к классу <code>CreateContactView</code> дополнительное поле:</em><br/>
<br/>
<pre><code class="python">    fields = ['first_name', 'last_name', 'email']</code></pre><br/>
<em>Это не обязательно, но с версии Django 1.7 <u>неиспользование</u> этого поля в классах с автоматическим генерированием форм объявлено устаревшим (при выполнении тестов вам об этом сообщат). Если вы его не укажете — то в форме редактирования будут использоваться все поля, но с версии Django 1.8 такое поведение будет удалено.</em></blockquote><p>
Большинство общих представлений, которые работают с формами имеют концепцию «удачного URL»: такого URL, на которой перенаправляется пользователь, после того как форма была удачно обработана. Все представления обрабатывающие формы твердо придерживаются практики </p><abbr title="POST-redirect-GET">POST-перенаправление-GET</abbr><p> для принятия изменений, так что обновление конечной страницы не отправляет заново форму. Вы можете реализовать это концепцию как свойство класса, либо переопределить метод </p><code>get_success_url()</code><p>, как это сделали мы. В нашем случае мы используем функцию </p><code>reverse</code><p> для вычисления URL'а списка контактов.

</p><blockquote><b><u>Примечание:</u> Контекстные переменные в представлениях-классах</b><br/>
Набор переменных доступных в шаблоне, когда он выводится, называется <abbr title="Context">Контекстом</abbr>. Контекст — это комбинация данных из представления и информации из <abbr title="context processors"><a href="https://docs.djangoproject.com/en/1.7/ref/templates/api/#subclassing-context-requestcontext">процессоров контекста</a></abbr>.<br/>
Когда вы используете встроенные общие представления, не совсем очевидно какие переменные доступны в контексте. Со временем вы откроете для себя, что их имена (предоставляемые общими представлениями в контекст шаблона) достаточно последовательны — <code>form</code>, <code>object</code> и <code>object_list</code> часто используются — хотя это не поможет вам в начале пути. К счастью, документация по этому вопросу очень похорошела с версии Django 1.5. <br/>
В представлениях-классах метод <code>get_context_data()</code> используются для добавления информации в контекст. Если вы перегрузите этот метод, вам нужно будет разрешить <code>**kwargs</code> и вызвать суперкласс.</blockquote><p>
Шаблон добавления контакта будет немного более сложный, чем шаблон списка контактов, но не слишком. Наш шаблон </p><code>contacts/templates/edit_contact.html</code><p> будет выглядеть как то так:

</p><pre><code class="django">&lt;h1&gt;Add Contact&lt;/h1&gt;

&lt;form action="{% url "contacts-new" %}" method="POST"&gt;
      {% csrf_token  %}
      &lt;ul&gt;
	    {{ form.as_ul }}
      &lt;/ul&gt;
      &lt;input id="save_contact" type="submit" value="Save" /&gt;
&lt;/form&gt;

&lt;a href="{% url "contacts-list" %}"&gt;back to list&lt;/a&gt;
</code></pre><p>
Несколько новых штук на заметку:
</p><ul>
<li><code>form</code> из контекста — это <a href="https://docs.djangoproject.com/en/1.7/topics/forms/">Django Form</a> для нашей модели. Так как мы не указали ни одного своего, Django создал один для нас. Как заботливо;</li>
<li>если бы мы просто написали <code>{{ form }}</code> мы бы получили табличные ряды; но мы добавляем <code>.as_ul</code>, что заставляет выводить поля ввода как элементы ненумерованного списка. Попробуйте вместо этого использовать <code>.as_p</code> и посмотреть что из этого получится;</li>
<li>когда мы выводим форму (<em>пр.: автоматически сгенерированную</em>) выводятся только наши поля, но не обрамляющий форму тег <code><code> или кнопка отправки /&gt;</code>, так что мы добавим их в шаблон сами;</code><br/>
 шаблонный тег <code>{% csrf_token %}</code> вставляет скрытое поле, по которому Django определяет, что запрос пришел с вашего проекта и что это не межсайтовая подделка запроса (<a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">CSRF</a>). Попробуйте не включать его в шаблон: вы все еще будете иметь доступ к странице, но как только вы попробуете отправить форму — вы получите ошибку;<br/>
 мы используем шаблонный тег <code>url</code> для генерирования ссылки назад к списку контактов. Замете, что <code>contacts-list</code> — это имя нашего представления, которое мы указали в настройках URL. Используя <code>url</code> вместо полного пути, нам не придется беспокоится про битые ссылки. <code>url</code> в шаблоне является эквивалентом <code>reverse</code> в коде Python.<br/>
</li>
</ul>
      <p class="clear"/>
    </div>

    
  </div></body></html>