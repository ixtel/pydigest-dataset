<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/files/eff/fa7/a52/efffa7a52db948febafdfd32bcfde903.jpg"/>
<p>
Ни для кого не секрет, что современные социальные сети представляют собой огромные БД, содержащие много интересной информации о частной жизни своих пользователей. Через веб-морду особо много данных не вытянешь, но ведь у каждой сети есть свой API… Так давай же посмотрим, как этим можно воспользоваться для поиска пользователей и сбора информации о них.
</p><p>
Есть в американской разведке такая дисциплина, как OSINT (Open source intelligence), которая отвечает за поиск, сбор и выбор информации из общедоступных источников. К одному из крупнейших поставщиков общедоступной информации можно отнести социальные сети. Ведь практически у каждого из нас есть учетка (а у кого-то и не одна) в одной или нескольких соцсетях. Тут мы делимся своими новостями, личными фотографиями, вкусами (например, лайкая что-то или вступая в какую-либо группу), кругом своих знакомств. Причем делаем это по своей доброй воле и практически совершенно не задумываемся о возможных последствиях. На страницах журнала уже не раз рассматривали, как можно с помощью различных уловок вытаскивать из соцсетей интересные данные. Обычно для этого нужно было вручную совершить какие-то манипуляции. Но для успешной разведки логичнее воспользоваться специальными утилитами. Существует несколько open source утилит, позволяющих вытаскивать информацию о пользователях из соцсетей.
</p><a name="habracut"/>
<h4>Creepy</h4><p>
Одна из наиболее популярных — </p><a href="http://www.geocreepy.com/">Creepy</a><p>. Она предназначена для сбора геолокационной информации о пользователе на основе данных из его аккаунтов Twitter, Instagram, Google+ и Flickr. К достоинствам этого инструмента, который штатно входит в Kali Linux, стоит отнести понятный интерфейс, очень удобный процесс получения токенов для использования API сервисов, а также отображение найденных результатов метками на карте (что, в свою очередь, позволяет проследить за всеми перемещениями пользователя). К недостаткам я бы отнес слабоватый функционал. Тулза умеет собирать геотеги по перечисленным сервисам и выводить их на Google-карте, показывает, кого и сколько раз ретвитил пользователь, считает статистику по устройствам, с которых писались твиты, а также по времени их публикации. Но за счет того, что это open source инструмент, его функционал всегда можно расширить самому. 
</p><p>
Рассматривать, как использовать программу, не будем — все отлично показано в </p><a href="http://www.youtube.com/watch?v=JqJ4zaDIVAs">официальном видео</a><p>, после просмотра которого не должно остаться никаких вопросов по поводу работы с инструментом.

</p><img src="https://habrastorage.org/files/da8/db3/dfc/da8db3dfc7244278aa6c84770062fa90.gif"/>

<h4>fbStalker</h4><p>
Еще два инструмента, которые менее известны, но обладают сильным функционалом и заслуживают твоего внимания, — </p><a href="https://github.com/milo2012/osintstalker">fbStalker и geoStalker</a><p>. 
</p><p>
fbStalker предназначен для сбора информации о пользователе на основе его Facebook-профиля. Позволяет выцепить следующие данные:
</p><ul>
<li>видео, фото, посты пользователя;</li>
<li>кто и сколько раз лайкнул его записи;</li>
<li>геопривязки фоток;</li>
<li>статистика комментариев к его записям и фотографиям;</li>
<li>время, в которое он обычно бывает в онлайне.</li>
</ul><p>
Для работы данного инструмента тебе понадобится Google Chrome, ChromeDriver, который устанавливается следующим образом:

</p><pre><code class="bash">wget http://goo.gl/Kvh33W
unzip chromedriver_linux32_23.0.1240.0.zip
cp chromedriver /usr/bin/chromedriver
chmod 777 /usr/bin/chromedriver
</code></pre><p>
Помимо этого, понадобится установленный Python 2.7, а также pip для установки следующих пакетов: 

</p><pre><code class="bash">pip install pytz
pip install tzlocal
pip install termcolor
pip install selenium
pip install requests --upgrade
pip install beautifulsoup4 
</code></pre><p>
И наконец, понадобится библиотека для парсинга GraphML-файлов:

</p><pre><code class="bash">git clone https://github.com/hadim/pygraphml.git
cd pygraphml
python2.7 setup.py install
</code></pre><p>
После этого можно будет поправить `fbstalker.py`, указав там свое мыло, пароль, имя пользователя, и приступать к поиску. Пользоваться тулзой достаточно просто:

</p><pre><code class="bash">python fbstalker.py -user [имя интересующего пользователя]
</code></pre>
<h4>geoStalker</h4><p>
geoStalker значительно интереснее. Он собирает информацию по координатам, которые ты ему передал. Например:
</p><ul>
<li>местные Wi-Fi-точки на основе базы `wigle.net` (в частности, их `essid`, `bssid`, `geo`);</li>
<li>чекины из Foursquare; </li>
<li>Instagram- и Flickr-аккаунты, с которых постились фотки с привязкой к этим координатам;</li>
<li>все твиты, сделанные в этом районе.</li>
</ul><p>
Для работы инструмента, как и в предыдущем случае, понадобится Chrome &amp; ChromeDriver, Python 2.7, pip (для установки следующих пакетов: google, python-instagram, pygoogle, geopy, lxml, oauth2, python-linkedin, pygeocoder, selenium, termcolor, pysqlite, TwitterSearch, foursquare), а также pygraphml и gdata:

</p><pre><code class="bash">git clone https://github.com/hadim/pygraphml.git
cd pygraphml
python2.7 setup.py install
wget https://gdata-python-client.googlecode.com/files/gdata-2.0.18.tar.gz
tar xvfz gdata-2.0.18.tar.gz
cd gdata-2.0.18
python2.7 setup.py install
</code></pre><p>
После этого редактируем `geostalker.py`, заполняя все необходимые API-ключи и access-токены (если для какой-либо соцсети эти данные не будут указаны, то она просто не будет участвовать в поиске). После чего запускаем инструмент командой `sudo python2.7 geostalker.py` и указываем адрес или координаты. В результате все данные собираются и размещаются на Google-карте, а также сохраняются в HTML-файл. 

</p><h4>Переходим к действиям</h4><p>
До этого речь шла о готовых инструментах. В большинстве случаев их функционала будет не хватать и придется либо их дорабатывать, либо писать свои тулзы — все популярные соцсети предоставляют свои API. Обычно они предстают в виде отдельного поддомена, на который мы шлем GET-запросы, а в ответ получаем XML/JSON-ответы. Например, для «Инстаграма» это `api.instagram.com`, для «Контакта» — `api.vk.com`. Конечно, у большинства таких API есть свои библиотеки функций для работы с ними, но мы ведь хотим разобраться, как это работает, да и утяжелять скрипт лишними внешними библиотеками из-за одной-двух функций не комильфо. Итак, давай возьмем и напишем собственный инструмент, который бы позволял искать фотографии из ВК и «Инстаграма» по заданным координатам и промежутку времени. 
</p><p>
Используя документацию к API VK и Instagram, составляем запросы для получения списка фотографий по географической информации и времени. 
</p><p>
Instagram API Request:

</p><pre><code class="xml">    url = "https://api.instagram.com/v1/media/search?"
        + "lat=" + location_latitude
        + "&amp;lng=" + location_longitude
        + "&amp;distance=" + distance
        + "&amp;min_timestamp=" + timestamp
        + "&amp;max_timestamp=" + (timestamp + date_increment)
        + "&amp;access_token=" + access_token
</code></pre><p>
Vkontakte API Request:

</p><pre><code class="xml">    url = "https://api.vk.com/method/photos.search?"
        + "lat=" + location_latitude
        + "&amp;long=" + location_longitude
        + "&amp;count=" + 100
        + "&amp;radius=" + distance
        + "&amp;start_time=" + timestamp
        + "&amp;end_time=" + (timestamp + date_increment)
</code></pre><p>
Здесь используемые переменные:
</p><ul>
<li>location_latitude — географическая широта;</li>
<li>location_longitude — географическая долгота;</li>
<li>distance — радиус поиска;</li>
<li>timestamp — начальная граница интервала времени;</li>
<li>date_increment — количество секунд от начальной до конечной границы интервала времени; </li>
<li>access_token — токен разработчика. </li>
</ul><p>
Как выяснилось, для доступа к Instagram API требуется access_token. Получить его несложно, но придется немного заморочиться (смотри врезку). Контакт же более лояльно относится к незнакомцам, что очень хорошо для нас. 

</p><blockquote><h4>Получение Instagram Access Token</h4><br/>
<br/>
Для начала регистрируешься в инстаграме. После регистрации переходишь по следующей ссылке:<br/>
<br/>
<a href="http://instagram.com/developer/clients/manage/">instagram.com/developer/clients/manage</a><br/>
<br/>
Жмешь **Register a New Client**. Вводишь номер телефона, ждешь эсэмэску и вводишь код. В открывшемся окне создания нового клиента важные для нас поля нужно заполнить следующим образом:<br/>
<ul>
<li>OAuth redirect_uri: <a href="http://localhost/">localhost</a></li>
<li>Disable implicit OAuth: галочка должна быть снята</li>
</ul><br/>
Остальные поля заполняются произвольно. Как только все заполнил, создавай нового клиента. Теперь нужно получить токен. Для этого впиши в адресную строку браузера следующий URL:<br/>
<pre><code class="xml">https://instagram.com/oauth/authorize/?client_id=[CLIENT_ID]&amp;redirect_uri=http://localhost/&amp;response_type=token
</code></pre><br/>
где вместо [CLIENT_ID] укажи Client ID созданного тобой клиента. После этого делай переход по получившейся ссылке, и если ты сделал все правильно, то тебя переадресует на <a href="http://localhost">localhost</a> и в адресной строке как раз будет написан Access Token.<br/>
<pre><code class="xml">    http://localhost/#access_token=[Access Token]
</code></pre><br/>
Более подробно про этот метод получения токена можешь почитать по следующей ссылке: <a href="http://jelled.com/instagram/access-token">jelled.com/instagram/access-token</a>.</blockquote>

<h4>Автоматизируем процесс</h4><p>
Итак, мы научились составлять нужные запросы, но вручную разбирать ответ сервера (в виде JSON/XML) — не самое крутое занятие. Гораздо удобнее сделать небольшой скриптик, который будет делать это за нас. Использовать мы будем опять же Python 2.7. Логика следующая: мы ищем все фото, которые попадают в заданный радиус относительно заданных координат в заданный промежуток времени. Но учитывай один очень важный момент — выводится ограниченное количество фотографий. Поэтому для большого промежутка времени придется делать несколько запросов с промежуточными интервалами времени (как раз date_increment). Также учитывай погрешность координат и не указывай радиус в несколько метров. И не забывай, что время нужно указывать в timestamp.
</p><p>
Начинаем кодить. Для начала подключим все необходимые нам библиотеки:

</p><pre><code class="python">import httplib
import urllib
import json
import datetime
</code></pre><p>
Пишем функции для получения данных с API через HTTPS. С помощью переданных аргументов функции мы составляем GET-запрос и возвращаем ответ сервера строкой.

</p><pre><code class="python">def get_instagram(latitude, longitude, distance, min_timestamp, max_timestamp, access_token):
    get_request =  '/v1/media/search?lat=' + latitude
    get_request+= '&amp;lng=' + longitude
    get_request += '&amp;distance=' + distance
    get_request += '&amp;min_timestamp=' + str(min_timestamp)
    get_request += '&amp;max_timestamp=' + str(max_timestamp)
    get_request += '&amp;access_token=' + access_token
    local_connect = httplib.HTTPSConnection('api.instagram.com', 443)
    local_connect.request('GET', get_request)
    return local_connect.getresponse().read()

def get_vk(latitude, longitude, distance, min_timestamp, max_timestamp):
    get_request =  '/method/photos.search?lat=' + location_latitude
    get_request+= '&amp;long=' + location_longitude
    get_request+= '&amp;count=100'
    get_request+= '&amp;radius=' + distance
    get_request+= '&amp;start_time=' + str(min_timestamp)
    get_request+= '&amp;end_time=' + str(max_timestamp)
    local_connect = httplib.HTTPSConnection('api.vk.com', 443)
    local_connect.request('GET', get_request)
    return local_connect.getresponse().read()
</code></pre><p>
Еще накодим небольшую функцию конвертации timestamp в человеческий вид:

</p><pre><code class="python">def timestamptodate(timestamp):
    return datetime.datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M:%S')+' UTC' 
</code></pre><p>
Теперь пишем основную логику поиска картинок, предварительно разбив временной отрезок на части, результаты сохраняем в HTML-файл. Функция выглядит громоздко, но основную сложность в ней составляет разбиение временного интервала на блоки. В остальном это обычный парсинг JSON и сохранение нужных данных в HTML.

</p><pre><code class="python">def parse_instagram(location_latitude, location_longitude, distance, min_timestamp, max_timestamp, date_increment, access_token):
    print 'Starting parse instagram..'
    print 'GEO:',location_latitude,location_longitude
    print 'TIME: from',timestamptodate(min_timestamp),'to',timestamptodate(max_timestamp)
    file_inst = open('instagram_'+location_latitude+location_longitude+'.html','w')
    file_inst.write('&lt;html&gt;')
    local_min_timestamp = min_timestamp
    while (1):
        if ( local_min_timestamp &gt;= max_timestamp ):
            break
        local_max_timestamp = local_min_timestamp + date_increment
        if ( local_max_timestamp &gt; max_timestamp ):
            local_max_timestamp = max_timestamp
        print timestamptodate(local_min_timestamp),'-',timestamptodate(local_max_timestamp)
        local_buffer = get_instagram(location_latitude, location_longitude, distance, local_min_timestamp, local_max_timestamp, access_token)
        instagram_json = json.loads(local_buffer)
        for local_i in instagram_json['data']:
            file_inst.write('&lt;br&gt;')
            file_inst.write('&lt;img src='+local_i['images']['standard_resolution']['url']+'&gt;&lt;br&gt;')
            file_inst.write(timestamptodate(int(local_i['created_time']))+'&lt;br&gt;')
            file_inst.write(local_i['link']+'&lt;br&gt;')
            file_inst.write('&lt;br&gt;')
        local_min_timestamp = local_max_timestamp
    file_inst.write('&lt;/html&gt;')
    file_inst.close()
</code></pre><p>
HTML-формат выбран не просто так. Он позволяет нам не сохранять картинки отдельно, а лишь указать ссылки на них. При запуске страницы результаты в браузере картинки автоматически подгрузятся. </p><p>
Пишем точно такую же функцию для «Контакта».

</p><pre><code class="python">def parse_vk(location_latitude, location_longitude, distance, min_timestamp, max_timestamp, date_increment):
    print 'Starting parse vkontakte..'
    print 'GEO:',location_latitude,location_longitude
    print 'TIME: from',timestamptodate(min_timestamp),'to',timestamptodate(max_timestamp)
    file_inst = open('vk_'+location_latitude+location_longitude+'.html','w')
    file_inst.write('&lt;html&gt;')
    local_min_timestamp = min_timestamp
    while (1):
        if ( local_min_timestamp &gt;= max_timestamp ):
            break
        local_max_timestamp = local_min_timestamp + date_increment
        if ( local_max_timestamp &gt; max_timestamp ):
            local_max_timestamp = max_timestamp
        print timestamptodate(local_min_timestamp),'-',timestamptodate(local_max_timestamp)
        vk_json = json.loads(get_vk(location_latitude, location_longitude, distance, local_min_timestamp, local_max_timestamp))
        for local_i in vk_json['response']:
            if type(local_i) is int:
                continue
            file_inst.write('&lt;br&gt;')
            file_inst.write('&lt;img src='+local_i['src_big']+'&gt;&lt;br&gt;')
            file_inst.write(timestamptodate(int(local_i['created']))+'&lt;br&gt;')
            file_inst.write('http://vk.com/id'+str(local_i['owner_id'])+'&lt;br&gt;')
            file_inst.write('&lt;br&gt;')
        local_min_timestamp = local_max_timestamp
    file_inst.write('&lt;/html&gt;')
    file_inst.close()
</code></pre><p>
И конечно же, сами вызовы функций:

</p><pre><code class="python">parse_instagram(location_latitude, location_longitude, distance, min_timestamp, max_timestamp, date_increment, instagram_access_token)
parse_vk(location_latitude, location_longitude, distance, min_timestamp, max_timestamp, date_increment)
</code></pre>

<img src="https://habrastorage.org/files/736/fe9/182/736fe9182132481fa04b7f1cc46179f4.gif"/><p>
Результат работы нашего скрипта в консоли

</p><img src="https://habrastorage.org/files/9b4/57d/32c/9b457d32ccc348d6b3ce51b69c0ab334.gif"/><p>
Один из результатов парсинга Инстаграма

</p><img src="https://habrastorage.org/files/0cf/ab7/8e8/0cfab78e86cf410abe3c8982c4c510be.gif"/><p>
Результат парсинга «Контакта»

</p><h4>Боевое крещение</h4><p>
Скрипт готов, осталось его только опробовать в действии. И тут мне пришла в голову одна идея. Те, кто был на PHD’14, наверняка запомнили очень симпатичных промодевочек от Mail.Ru. Что ж, давай попробуем наверстать упущенное — найти их и познакомиться. 
</p><p>
Собственно, что мы знаем об PHD14:

</p><ul>
<li>место проведения — Digital October — 55.740701,37.609161;</li>
<li>дата проведения — 21–22 мая 2014 года — 1400619600–1400792400.</li>
</ul><p>
Получаем следующий набор данных:
 </p><p>
 location_latitude = '55.740701'</p><p>
 location_longitude = '37.609161'</p><p>
 distance = '100'</p><p>
 min_timestamp = 1400619600</p><p>
 max_timestamp = 1400792400</p><p>
 date_increment = 60*60*3 # every 3 hours</p><p>
 instagram_access_token = [Access Token]

</p><blockquote><h4>Полезные советы</h4><br/>
Если в результате работы скрипта фотографий будет слишком мало, можешь пробовать изменять переменную `date_increment`, поскольку именно она отвечает за интервалы времени, по которым собираются фотографии. Если место популярное, то и интервалы должны быть частыми (уменьшаем `date_increment)`, если же место глухое и фотографии публикуют раз в месяц, то и сбор фотографий интервалами в час не имеет смысла (увеличиваем `date_increment`).</blockquote>
<p>
Запускаем скрипт и идем разбирать полученные результаты. Ага, одна из девочек выложила фотку, сделанную в зеркале в туалете, с привязкой по координатам! Естественно, API не простил такой ошибки, и вскоре были найдены странички всех остальных промодевочек. Как оказалось, две из них близняшки :). 

</p><img src="https://habrastorage.org/files/e0e/bfb/500/e0ebfb500bcf48558256cba17f267c61.gif"/><p>
Та самая фотография промо-девочки с PHD’14, сделанная в туалете

</p><h4>Поучительный пример</h4><p>
В качестве второго примера хочется вспомнить одно из заданий с финала CTF на PHD’14. Собственно, именно после него я заинтересовался данной темой. Суть его заключалась в следующем.
</p><p>
Есть злой хацкер, который разработал некую малварь. Нам дан набор координат и соответствующих им временных меток, из которых он выходил в интернет. Нужно добыть имя и фотку это хацкера. Координаты были следующие:
</p><p>
55.7736147,37.6567926 30 Apr 2014 19:15 MSK;</p><p>
 55.4968379,40.7731697 30 Apr 2014 23:00 MSK;</p><p>
 55.5625259,42.0185773 1 May 2014 00:28 MSK;</p><p>
 55.5399274,42.1926434 1 May 2014 00:46 MSK;</p><p>
 55.5099579,47.4776127 1 May 2014 05:44 MSK;</p><p>
 55.6866654,47.9438484 1 May 2014 06:20 MSK;</p><p>
 55.8419686,48.5611181 1 May 2014 07:10 MSK
</p><p>
Первым делом мы, естественно, посмотрели, каким местам соответствуют эти координаты. Как оказалось, это станции РЖД, причем первая координата — это Казанский вокзал (Москва), а последняя — Зеленый Дол (Зеленодольск). Остальные — это станции между Москвой и Зеленодольском. Получается, что он выходил в интернет из поезда. По времени отправления был найден нужный поезд. Как оказалось, станцией прибытия поезда является Казань. И тут встал главный вопрос: где искать имя и фотку. Логика заключалась в следующем: поскольку требуется найти фотку, то вполне разумно предположить, что искать ее нужно где-то в социальных сетях. Основными целями были выбраны «ВКонтакте», «Фейсбук», «Инстаграм» и «Твиттер». В соревнованиях помимо русских команд участвовали иностранцы, поэтому мы посчитали, что организаторы вряд ли бы выбрали «ВКонтакте». Решено было начать с «Инстаграма». 
</p><p>
Никакими скриптами для поиска фотографий по координатам и времени мы тогда не обладали, и пришлось использовать публичные сервисы, умевшие это делать. Как выяснилось, их довольно мало и они предоставляют довольно скудный интерфейс. Спустя сотни просмотренных фотографий на каждой станции движения поезда наконец была найдена нужная. 
</p><p>
В итоге, чтобы найти поезд и недостающие станции, а также логику дальнейшего поиска, понадобилось не больше часа. А вот на поиск нужной фотографии — очень много времени. Это еще раз подчеркивает, насколько важно иметь правильные и удобные программы в своем арсенале. 

</p><blockquote><h4>WWW</h4><br/>
Исходный код рассмотренного скрипта ты можешь найти в моем <a href="https://bitbucket.org/BetepokNoname/photobygeo/src">Bitbucket-репозитории</a></blockquote>

<h4>Выводы</h4><p>
Статья подошла к завершению, и настало время делать вывод. А вывод простой: заливать фотографии с геопривязкой нужно обдуманно. Конкурентные разведчики готовы зацепиться за любую возможность получить новую информацию, и API социальных сетей им в этом могут очень неплохо помочь. Когда писал эту статью, я изучил еще несколько сервисов, в том числе Twitter, Facebook и LinkedIn, — есть ли подобный функционал. Положительные результаты дал только «Твиттер», что, несомненно, радует. А вот Facebook и LinkedIn огорчили, хотя еще не все потеряно и, возможно, в будущем они расширят свои API. В общем, будь внимательнее, выкладывая свои фото с геопривязкой, — вдруг их найдет кто-нибудь не тот. :)

</p><img src="https://habrastorage.org/getpro/habr/post_images/7a8/146/7e0/7a81467e0c7a59782054603aeec3c678.jpg" alt="image"/>

<i>Впервые опубликовано в журнале «Хакер» от 02/2015.<br/>
Автор: Аркадий Литвиненко (<a href="https://twitter.com/betepo_ok">@BetepO_ok</a>)</i>
<p>
Подпишись на «Хакер»
</p>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>