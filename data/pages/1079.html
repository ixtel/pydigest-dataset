<html><body><div><div id="articleText">
                    <p id="articleLongDescription">Stephen B. Morris draws a comparison between two approaches to ORM-centric database development. One is based on the Python SQLAlchemy ORM tools, and the other uses standard Java JPA. Which is better? The result of comparing a simple use case for both languages is quite surprising.</p>
                    <p id="articleDescription"/>

                    <a class="relatedBookLink" href="#">Like this article? We recommend <span class="ss-icon"></span></a>
                    
                    

                <p>In the late 1990s, it was commonplace to hear quite emotional arguments about the dangers of C programming versus other languages such as Pascal. The Pascal proponents pointed out the pitfalls in C: unchecked array access, pointer manipulation, complexity, and so on. The C supporters, on the other hand, regarded Pascal as a language for learning programming, rather than one for professional development.</p>
<p>Then along came C++ and Java, and a lot of the old arguments were consigned to the history books. I think it's fair to say that Java has become the mainstream language of choice. But other languages such as C/C++ and so forth still have an important to role to play. For example, if you need to develop on small embedded devices, C is a good choice. For larger embedded systems, C++ is routinely used.</p>

<p>One interesting development in the Java world has been the plethora of programming frameworks, including offerings such as Spring, Struts, and so on. Although very useful to the programmer, these frameworks haven't always been to everyone's taste. Indeed, getting up and running with a Spring-based tool chain is most decidedly <em>not</em> an easy undertaking. The same can be said for other frameworks such as Seam. This level of complexity is somewhat at variance with modern trends.</p>
<p>As organizations seek to simplify their IT development, a move is underway toward more lightweight technologies. As part of this effort, some very large corporate and governmental organizations are moving away from the complex and framework-rich environments of Java, embracing languages such as Python. This trend can be seen all the way out to the front end, in the way JavaScript is sometimes being used aggressively as a platform for business logic.</p>
<p>Despite all these changes in programming languages, relational databases still tend to sit at the epicenter of most systems—for large websites as well as even small mobile applications. A separate movement is headed toward <a href="http://en.wikipedia.org/wiki/NoSQL">NoSQL</a> databases such as MongoDB. But, for the moment, relational technology still dominates. Getting database access from a chosen programming language is therefore a key part of the developer's toolkit. Not surprisingly, a range of options are available for programmatic database access. Let's see how Python and Java stack up.</p>

<h3>Python Versus Java</h3>
<p>In this article, I compare the object-relational mapping facilities from Python and Java. While preparing the code for this article, I was struck by the relative difficulty of setting up object-relational mapping (ORM) facilities in the two languages. For Python, the setup is pretty straightforward. Indeed, the <a href="http://docs.sqlalchemy.org/en/rel_0_9/orm/tutorial.html#declare-a-mapping">online Python tutorials</a> are of high quality, which also helps greatly in speeding up user adoption.</p>
<p>On the other hand, the Java tutorials are somewhat more distributed across the Web, and getting up and running with Java ORM is much more difficult than with Python. I have a good deal of experience with Java, which helped me in getting the Java ORM working, but a beginner might not be able to get past the setup difficulties.</p>
<p>However, having used and written about both languages, I should note that despite these occasional difficulties my preference would generally be to use Java. Why? Well, Java is a proven technology; out of the box, Java is structured, secure, strongly typed, and thread-safe.</p>
<p>Anyway, that's enough grumbling. Let's see how to set up some ORM code in these two languages.</p>
<h3>Building a Python ORM Module</h3>
<p>Listing 1 has a bare-bones Python ORM module, based on the example in <a href="http://docs.sqlalchemy.org/en/rel_0_9/orm/tutorial.html#declare-a-mapping">SQLAlchemy documentation</a>. This Python module uses a class definition, which contains the database mapping.</p>
<h4><em>Listing 1A complete Python ORM module.</em></h4>
<pre>import sqlalchemy
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String
from sqlalchemy.orm import sessionmaker
import time

if __name__ == <em>'__main__'</em>:
    sqlalchemy.__version__
    engine = create_engine(<em>'mysql://userName:password@localhost'</em>, echo=False)
    engine.execute(<em>'USE sqlAlchemyJavaORM'</em>)
    Base = declarative_base()

    class <strong>User</strong>(Base):
        __tablename__ = <em>'DBPythonUsers'</em>
        id = Column(Integer, primary_key=True, nullable = False)
        name = Column(String(30), nullable = False)
        fullname = Column(String(30), nullable = False)
        password = Column(String(20), nullable = False)
        
        def <strong>greeting</strong>(<em>self</em>):
            return <em>'Hello world from class name '</em> + <em>self</em>.__class__.__name__
        
        def <strong>__repr__</strong>(<em>self</em>):
            return <em>"&lt;User(name='%s', fullname='%s', password='%s')&gt;"</em> % (
                        <em>self</em>.name, <em>self</em>.fullname, <em>self</em>.password)
    
   x = User()
    print x.greeting()
    startTime = time.time()

    for i in range(0, 100000):
       Base.metadata.create_all(engine)
       Session = sessionmaker(bind=engine)
       session = Session()
       ed_user = User(name='ed' + str(i), fullname='Ed Jones', password='edspassword')
       # Now we can talk to the database
       session.add(ed_user)
       session.commit()
        
    print time.time() - startTime, 'seconds'</pre>
<p>Let's break down Listing 1 into its constituent parts:</p>
<ol>
	<li>Create an engine with which to communicate with the database:</li>

<pre>engine = create_engine('<em>mysql://userName:password@localhost</em>', echo=False)</pre>

	<p>		I used MySQL Server, but to get started quickly you can use the in-memory SQLite. To use the line above, substitute your login name and password in place of <em><tt>userName</tt></em> and <em><tt>password</tt></em>.</p>
	<p>		The <tt>class <strong>User</strong></tt> provides the main ORM mapping. Notice the multiple uses of <tt>Column</tt>; each of them maps to an actual database column.</p>
	<li>Next up, the line <tt>x = User()</tt> creates an instance of the above class.</li>
	<li>Then I call a test method on the class called <tt>x.greeting()</tt>.</li>
	<li>Next, the schema is created with <tt>Base.metadata.create_all(engine)</tt>.</li>
	<li>Using a session instance, I insert data into the database.</li>
	<li>The last step is to roughly record the time taken to execute the database code.</li>
</ol>
<p>That's the overall view. Now let's dig a little deeper into this interesting Python ORM technology. The Python code used here is based on the <a href="http://docs.sqlalchemy.org/en/rel_0_9/orm/tutorial.html#declare-a-mapping">SQLAlchemy tutorial</a>, so I won't go into too much detail beyond the main points above.</p>
<p>One aspect of Listing 1 that requires some explanation is the way the code interacts with the database engine. That is, I allow the Python code to create the table as follows:</p>
<pre>Base.metadata.create_all(engine)</pre>

<p>Listing 2 illustrates the MySQL database table created by the Python module.</p>
<h4><em>Listing 2The newly created database table.</em></h4>
<pre>+----------+-------------+------+-----+---------+----------------+

| Field    | Type        | Null | Key | Default | Extra          |

+----------+-------------+------+-----+---------+----------------+

| id       | int(11)     | NO   | PRI | NULL    | auto_increment |

| name     | varchar(30) | NO   |     | NULL    |                |

| fullname | varchar(30) | NO   |     | NULL    |                |

| password | varchar(20) | NO   |     | NULL    |                |

+----------+-------------+------+-----+---------+----------------+</pre>
<p>A careful comparison between Listings 1 and 2 illustrates the power of ORM: One Python class and module does all this work. But remember that this power brings a lot of responsibility! Notice also the auto-incrementing primary key in Listing 2. This is a very convenient and standard MySQL database column type, where the <tt>id</tt> value is automatically incremented each time a row is inserted into the table.</p>
<p>The last noteworthy section in Listing 1 is the data insertion loop. I use a loop to insert 100,000 rows into the database table.</p>
<p>The Python code is done. Now how do we go about doing something similar in Java?</p>

<h2>Building a Java ORM Facility</h2>
<p>We've seen the approach to Python ORM. Let's look at how an equivalent Java solution might work. Unfortunately, as I mentioned earlier, getting set up with a Java ORM project is not so trivial an undertaking. Interested readers can look at some of my earlier <a href="http://www.informit.com/articles/article.aspx?p=1867759">JPA articles</a>. For this specific case, look at this <a href="http://wiki.eclipse.org/EclipseLink/Examples/JPA/OutsideContainer">EclipseLink example</a> for some guidance.</p>
<p>Listing 3 illustrates a basic Java entity <tt>class JavaORMClass</tt>. Notice the heavy use of Java annotations, such as <tt>@Entity</tt>, <tt>@Table</tt>, <tt>@Column</tt>, and so on. These annotations provide the mapping between the class data members and the underlying database table. Just as in the Python case, Java code can create the database schema.</p>

<h4><em>Listing 3A Java JPA class.</em></h4>
<pre>@Entity
@Table(name = "DBJavaUsers")
<strong>public</strong> <strong>class</strong> JavaORMClass {
    
    @Id @GeneratedValue
    @Column(name = "IDENT_PARAMS_ID")
    <strong>private</strong> Long id;
    
    @Column(name = "name")
    <strong>private</strong> String name; 
    
    @Column(name = "fullname")
    <strong>private</strong> String fullName;
 
    @Column(name = "password")
    <strong>private</strong> String password;

    <strong>public</strong> JavaORMClass() {
    }

    <strong>public</strong> JavaORMClass(String name, String fullName, String password) {
        <strong>super</strong>();
        <strong>this</strong>.name = name;
        <strong>this</strong>.fullName = fullName;
        <strong>this</strong>.password = password;
    }

    <strong>public</strong> Long getId() {
        <strong>return</strong> id;
    }
    
    <strong>public</strong> String getName() {
        <strong>return</strong> name;
    }

    <strong>public</strong> <strong>void</strong> setName(String name) {
        <strong>this</strong>.name = name;
    }

    <strong>public</strong> String getFullName() {
        <strong>return</strong> fullName;
    }

    <strong>public</strong> <strong>void</strong> setFullName(String fullName) {
        <strong>this</strong>.fullName = fullName;
    }

    <strong>public</strong> String getPassword() {
        <strong>return</strong> password;
    }

    <strong>public</strong> <strong>void</strong> setPassword(String password) {
        <strong>this</strong>.password = password;
    }</pre>
<p>Listing 4 illustrates a simple Java class to write to the database. This Java JPA code is all pretty standard stuff, and the bulk of the code in Listing 3 is automatically generated by Eclipse. Notice the use of a transaction in Listing 4 and the call to <tt>persist()</tt>.</p>
<h4><em>Listing 4A Java client class.</em></h4>
<pre><strong>public</strong> <strong>void</strong> saveJavaOrm(JavaORMClass javaORMClassObject) {

    <strong>try</strong> {
        // Start EntityManagerFactory
        EntityManagerFactory emf = Persistence
                .<em>createEntityManagerFactory</em>("helloworld");

        // First unit of work
        EntityManager entityManager = emf.createEntityManager();
        EntityTransaction entityTransaction = entityManager
                .getTransaction();
        entityTransaction.begin();

        entityManager.persist(javaORMClassObject);
        entityTransaction.commit();
        entityManager.close();
        emf.close();
    } <strong>catch</strong> (Exception e) {
        // <strong>TODO</strong> Auto-generated catch block
        e.printStackTrace();
    }
}</pre>
<p>Finally, Listing 5 illustrates invocation of the client class to persist the data to the database.</p>
<h4><em>Listing 5A Java client class to persist the required data.</em></h4>
<pre>ClientCreate clientCreate = <strong>new</strong> ClientCreate();

<strong>long</strong> startTime = System.<em>nanoTime</em>();

<strong>for</strong> (<strong>int</strong> i = 0; i &lt; 100000; i++) {
    JavaORMClass javaORMClassObject = <strong>new</strong> JavaORMClass(
            "ed" + i, "Ed Jones" + i, "password");
    clientCreate.saveJavaOrm(map, javaORMClassObject);
}</pre>
<p>In Listing 5, I use a <tt>for</tt> loop to add the <tt>JavaORMClass</tt> objects to the database.</p>
<p>Okay, we've seen how to produce the code. How about the execution times? Listing 6 illustrates the Python and Java execution times in seconds.</p>
<h4><em>Listing 6Execution times.</em></h4>
<pre>Python ------&gt;  Execution time: 6332
Java --------&gt;  Execution time: 7353</pre>
<p>Python looks a good bit faster! Obviously, the use case here is a little extreme—inserting 100,000 rows isn't going to happen every day. But it shows that Python is considered a lightweight language for good reasons.</p>






            </div>
            </div></body></html>