<html><body><div><div class="section">
              <h1>regal 1.1</h1>

              


<p>A/B Testing or publish smart grouping engine.</p><p>








# Regal</p><p>====</p><p>[![pyversions](https://img.shields.io/badge/Python-2%20%26%203-brightgreen.svg)]()</p><p>[![ver](https://img.shields.io/badge/release-v1.1-red.svg)]()</p><p>[![MIT](https://img.shields.io/badge/license-MIT-blue.svg)]()</p><p>[![coverage](https://img.shields.io/badge/coverage-92%25-yellowgreen.svg)]()</p><p>用于"灰度发布"或 A/B Testing的智能分组引擎</p><p>## Regal能做什么？</p><p>举个最简单的例子，比如需要针对一个版本进行灰度发布，而这一版本对应的可能是一大堆服务器集群， 如下图:</p><p>![](http://i4.tietuku.com/71281a19596c5dd1.png)</p><p>就像图中描述的一样，无论你的服务器是多还是少，尤其很多中小型企业在进行灰度发布时，通常会遇到所制定的分流策略在实际的技术或开发中如何去实现，是机器直接写死？</p><p>因此让``Regal智能分组引擎``直接介入，让它来根据你的策略提前进行动态地分组分流。</p><p>在这里，我再举一个简单的例子，方便大家能够更清楚的明白Regal的主要工作：</p><p>假设有一个版本A，需要针对六台机器进行发布</p><p>![](http://i4.tietuku.com/5f7d4115746b6e97.png)</p><p>现在应该已经了解Regal到底是什么干货了吧，当然了，上面的例子是服务器非常少的情况，实际情况中，所面对的服务器集群是非常多，这个时候可以通过提供的``combine``和``schedule``两个API进行策略调整。详情可以见下文的``使用介绍``</p><p>- Feature：</p><p>  1. 提供发布策略，动态智能分流</p><p>  2. 支持多版本分组和优先级</p><p>  3. 数据格式化</p><p>  4. 同时兼容Python2.5以上和Python3以上的版本（建议使用Python2.7+或者Python3.5以后的版本）  </p><p>## 安装和使用</p><p>### 安装</p><p> -  `` pip install regal ``</p><p>### 使用说明</p><p>- 单个版本场景</p><p>```</p><p>In [1]: from regal import BaseInfo</p><p># 初始化信息，请注意一下格式</p><p>In [6]: ab = BaseInfo(</p><p>version_host={'app-test-version1.0':'10.1.1.1,10.1.1.2,10.1.1.3,10.1.1.4,10.1.1.1.5'},</p><p>combine=2    # combine 希望以每组多少台服务器作为一组,进行用户群B的分流</p><p>             # 在这个例子中为2台</p><p>             # 默认：每组1台</p><p>)</p><p># grouping() 进行分组</p><p>In [11]: smart_grouping = ab.grouping() </p><p># result属性 进行分组后的返回结果</p><p>In [12]: smart_grouping.result</p><p>Out[12]:</p><p>[('app-test-version1.0',</p><p>  [['10.1.1.1'], ['10.1.1.2', '10.1.1.3'], ['10.1.1.4', '10.1.1.1.5']])]</p><p>```</p><p>根据你的策略设置，会得到一个数据结构，我们来观察一下：</p><p>![](http://i4.tietuku.com/70e4610ed795f74e.png)</p><p>再看一个例子</p><p>```</p><p>In [7]: ab = BaseInfo(</p><p>version_host={'app-test-version1.0':'10.1.1.1,10.1.1.2,10.1.1.3,10.1.1.4,10.1.1.5'},</p><p>combine=3,</p><p>schedule=2)</p><p>In [10]: ab.grouping().result</p><p>Out[10]:</p><p>[('app-test-version1.0',</p><p>  [['10.1.1.1,10.1.1.2'], ['10.1.1.3', '10.1.1.4', '10.1.1.5']])]</p><p>```</p><p>- 多版本场景</p><p>``` </p><p>In [17]: ab = BaseInfo(</p><p>   ....: version_host={</p><p>   ....: 'app-test-version1.0': '10.1.1.1,10.1.1.2,10.1.1.3,10.1.1.1.4,10.1.1.5',</p><p>   ....: 'app-test-version2.0': '10.1.1.9,10.1.1.8,10.1.1.7,10.1.1.6'},</p><p>   ....: combine=3,</p><p>   ....: schedule=2</p><p>   ....: )   </p><p>In [20]: ab.grouping().result</p><p>Out[20]:</p><p>[('app-test-version2.0', [['10.1.1.9,10.1.1.8'], ['10.1.1.7', '10.1.1.6']]),</p><p> ('app-test-version1.0',</p><p>  [['10.1.1.1,10.1.1.2'], ['10.1.1.3', '10.1.1.1.4', '10.1.1.5']])]   </p><p># grouping()方法还提供了priority_name参数，当需要在多版本发布的时候，设置优先级，指定你需要优先发布的'版本名'</p><p> In [22]: smart_grouping = ab.grouping(priority_name='app-test-version1.0')</p><p>In [23]: smart_grouping.result</p><p>Out[23]:</p><p>[('app-test-version1.0',</p><p>  [['10.1.1.1,10.1.1.2'], ['10.1.1.3', '10.1.1.1.4', '10.1.1.5']]),</p><p> ('app-test-version2.0', [['10.1.1.9,10.1.1.8'], ['10.1.1.7', '10.1.1.6']])]</p><p># 提供一个简易的API，可以让结果返回的更简洁  </p><p>In [16]: for i in smart_grouping.iter_dict():   </p><p>    print i</p><p>   ....:</p><p>{'app-test-version1.0': ['10.1.1.1', '10.1.1.2,10.1.1.3', '10.1.1.4,10.1.1.1.5']}</p><p>```</p><p>## Demo</p><p>- 你也可以通过 `` git clone https://github.com/boylegu/regal/ ``</p><p>- `` cd regal/ ``</p><p>- 参考`` example.py ``</p><p>## 分流分组之后？</p><p>Regal本身只是一个分组引擎，因此它并不承担直接发布的作用，但是通过Regal分组之后，你所得到数据，是非常容易和其他可以用来发布的组件进行配合；下面是我的一些建议和指导。</p><p>```</p><p>versionA:</p><p>  （第一组）    groupA   ip......     用户群A    </p><p>  （第二组）    groupB1  ip...... __ </p><p>  （第三组）    groupB2  ip......   |</p><p>  （第四组）    groupB3  ip......   | --   用户群B   </p><p>   ......                       --|</p><p>```</p><p>- 关于发布</p><p>  分组之后，每一组的所有机器可以看作一个整体，扔进发布组件，进行'组内并发'</p><p>  你可以把每一组直接放在ansible、saltstack、pssh或异步IO框架等等进行发布；  </p><p>  甚至你也可以和前端nginx＋lua进行组合；</p><p>- 关于停止发布</p><p>  每组进行发布，一旦出现异常，你可以利用发布组件，或者你自己写一套异常抓取工具来停止发布，这个时候就不会再针对剩下的组进行发布操作了。</p><p>- 关于回滚</p><p>  把回滚也看作一种发布,就不多说了</p><p>## 作者</p><p>- 顾鲍尔 (Boyle Gu)  </p><p>## 技术交流与支持</p><p>有任何问题、建议可以通过Github；</p><p>也可以直接加入讨论群 QQ：315308272 与我进行交流</p><p>## Darwin's finches</p><p>![](http://i4.tietuku.com/91bdfbecc9e94efat.jpg)</p><p>第一次在Mac上绘图，这就当做本项目的吉祥物吧～</p><p>人类的创造从来没有离开大自然带给我们的启发，而无论是灰度发布，还是A/B Testing，早在千年以前，大自然早有绝佳的解决方案。因此我以‘Darwin's finches’作为原型，手工绘制了这张图，向伟大的大自然和达尔文《物种起源》致敬。</p><p>&gt; Author: 顾鲍尔     </p><p>&gt; Date： 2015.12.23 绘

</p><a name="downloads"> </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>18</span> downloads in the last week
  </li>
  <li>
    <span>165</span> downloads in the last month
  </li>
</ul>









            </div>


          </div></body></html>