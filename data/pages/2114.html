<html><body><div><div class="post-text" itemprop="text">
<p>The outline of matplotlib axes are controlled by three things:</p>

<ol>
<li>The axes' bounding box within the figure (controlled by a subplot specification or a specific extent such as <code>fig.add_axes([left, bottom, width, height])</code>.  The axes limits (not counting tick labels) will always be within this box.</li>
<li>The <code>adjustable</code> parameter that controls whether changes in limits or aspect ratio are accomodated by changing data limits or the shape of the axes "box".  This can be <code>"datalim"</code>, <code>"box"</code>, or <code>"box-forced"</code>.  (The latter is for use with shared axes.)</li>
<li>The axes limits and aspect ratio.  For plots with a fixed aspect ratio, the axes box or data limits (depending on <code>adjustable</code>) will be changed to maintain the specified aspect ratio.  The aspect ratio refers to data coordinates, <em>not</em> the shape of the axes directly.</li>
</ol>

<p>For the simplest case:</p>

<pre><code>import numpy as np
import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=2)

data = np.random.random((3,3))
xaxis = np.arange(0,3)
yaxis = np.arange(0,3)

axes[0].imshow(data, interpolation='none')
c = axes[0].contour(xaxis, yaxis, data, colors='k')

axes[1].set_aspect(1)

plt.show()
</code></pre>

<p><img src="http://i.stack.imgur.com/fDxoF.png" alt="enter image description here"/></p>

<hr/>

<h2>Shared Axes</h2>

<p>However, if you want to ensure that it stays the same shape regardless, and you're okay with both plots having the same data limits, you can do:</p>

<pre><code>import numpy as np
import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=2), sharex=True, sharey=True)
plt.setp(axes.flat, adjustable='box-forced')

data = np.random.random((5,3))
xaxis = np.arange(0,3)
yaxis = np.arange(0,5)

axes[0].imshow(data, interpolation='none')
c = axes[0].contour(xaxis, yaxis, data, colors='k')

axes[1].plot([-0.5, 2.5], [-0.5, 4.5])
axes[1].set_aspect(1)

plt.show()
</code></pre>

<p><img src="http://i.stack.imgur.com/aE9aq.png" alt="enter image description here"/></p>

<p>However, you may notice that this doesn't look quite right.  That's because the second subplot is controlling the extents of the first subplot due to the order we plotted things in.</p>

<p>Basically, with shared axes, whatever we plot last will control the initial extent, so if we just swap the order we're plotting in:</p>

<pre><code>    import numpy as np
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(nrows=2, sharex=True, sharey=True)
    plt.setp(axes.flat, adjustable='box-forced')

    data = np.random.random((5,3))
    xaxis = np.arange(0,3)
    yaxis = np.arange(0,5)

    axes[1].plot([-0.5, 2.5], [-0.5, 4.5])
    axes[1].set_aspect(1)

    axes[0].imshow(data, interpolation='none')
    c = axes[0].contour(xaxis, yaxis, data, colors='k')

    plt.show()
</code></pre>

<p><img src="http://i.stack.imgur.com/IVzy2.png" alt="enter image description here"/></p>

<p>Of course, if you don't care about the interactive zooming/panning of the plots being linked, you can skip the shared axes altogether and just to:</p>

<pre><code>import numpy as np
import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=2)

data = np.random.random((5,3))
xaxis = np.arange(0,3)
yaxis = np.arange(0,5)

axes[0].imshow(data, interpolation='none')
c = axes[0].contour(xaxis, yaxis, data, colors='k')

axes[1].plot([-0.5, 2.5], [-0.5, 4.5])

# Copy extents and aspect from the first axes...
axes[1].set_aspect(axes[0].get_aspect())
axes[1].axis(axes[0].axis())

plt.show()
</code></pre>

<hr/>

<h2>Non-Shared Axes</h2>

<p>If you don't want the two axes to have the same data extents, it is possible to force them to be the same size (though if you interactively zoom, they won't be linked).  To do this, you need to calculate what the aspect ratio for the second plot should be based on its extents and the extents/aspect of the first plot. </p>

<pre><code>import numpy as np
import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=2)

data = np.random.random((3,3))
xaxis = np.arange(0,3)
yaxis = np.arange(0,3)

axes[0].imshow(data, interpolation='none')
c = axes[0].contour(xaxis, yaxis, data, colors='k')

axes[1].plot(np.linspace(0, 10, 100), np.random.normal(0, 1, 100).cumsum())

# Calculate the proper aspect for the second axes
aspect0 = axes[0].get_aspect()
if aspect0 == 'equal':
    aspect0 = 1.0
dy = np.abs(np.diff(axes[1].get_ylim()))
dx = np.abs(np.diff(axes[1].get_xlim()))

aspect = aspect0 / (float(dy) / dx)
axes[1].set_aspect(aspect)

plt.show()
</code></pre>

<p><img src="http://i.stack.imgur.com/pOD3f.png" alt="enter image description here"/></p>
    </div>
    </div></body></html>