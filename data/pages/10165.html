<html><body><div><div id="content">
        <h3/>
        <h2>Hangman implemented in 3 lines of Python (2)</h2>
        <p><i>Just because you can, doesn't mean you shrdlu.</i></p>
        <p>Yesterday, I was reminded of the
<a href="https://en.wikipedia.org/wiki/Words_(Unix)"><code>/usr/share/dict/words</code></a> file
during a conversation I had at lunch. This file is simply a collection of valid
words, and is present on all UNIX and UNIX-like systems. It can be a pretty
useful resource for solving crossword puzzles or word jumbles.</p>

<p>I had half an hour left for lunch, and so I thought about doing something cool
with it. Without thinking too hard, I came up with the idea of implementing
Hangman in Python. My first implementation was around a dozen lines of readable
code, but already I could see how concise Python allowed me to be, and so I
resolved to revisit the problem the next day from a
<a href="https://en.wikipedia.org/wiki/Code_golf">code-golfer</a>'s point of view, and
attempt to solve it in as few lines as possible (without, of course, the trivial
trick of concatenating all my lines with <code>;</code>). The restriction I set for myself
was that each line must be just one Python statement or expression (although my
solution does stretch that somewhat with tuple-packing/unpacking. I also allow
myself to go over 80 characters a line and ignore PEP-8 in other ways.</p>

<p>The number of bytes of this code could be further shrunk by limiting the size of
variable identifiers, eliminating non-significant whitespace, and using
generator comprehensions where I've used filter() and map(). I feel that
would obscure what's going on here <em>too</em> much. While not a paragon of
readability, the variable names give readers a clue into what I, the author,
intended. Stripped of those, the code crosses the line from acute brevity over
into obfuscation.</p>

<h3>The solution itself</h3>

<p>Here it is, in all it's g(l)ory. You may need to scroll a bit.</p>

<pre><code class="language-python">license, chosen_word, guesses, scaffold, man, guesses_left = 'https://opensource.org/licenses/MIT', ''.join(filter(str.isalpha, __import__('random').choice(open('/usr/share/dict/words').readlines()).upper())), set(), '|======\n|   |\n| {3} {0} {5}\n|  {2}{1}{4}\n|  {6} {7}\n|  {8} {9}\n|', list('OT-\\-//\\||'), 10
while not all(letter in guesses for letter in chosen_word) and guesses_left: _, guesses_left = map(guesses.add, filter(str.isalpha, raw_input('%s(%s guesses left)\n%s\n%s:' % (','.join(sorted(guesses)), guesses_left, scaffold.format(*(man[:10-guesses_left] + [' '] * guesses_left)), ' '.join(letter if letter in guesses else '_' for letter in chosen_word))).upper())), max((10 - len(guesses - set(chosen_word))), 0)
print 'You', ['lose!\n' + scaffold.format(*man), 'win!'][bool(guesses_left)], '\nWord was', chosen_word
</code></pre>

<p>Weighing in at 3 lines of Python code, this is a pretty compact implementation.
If you want to run it at your own terminal to play it yourself on a UNIX-like
machine, you can download it from <a href="https://gist.github.com/danverbraganza/3320ccedd0eef2f2b88d">this
gist</a>, or copy and
paste the 3 lines above into hangman.py and run it. You should notice the following features:</p>

<ul>
<li>A word is chosen randomly from the system dictionary. Of course, this
dictionary includes proper names. The word list can be easily changed.</li>
<li>Keeping track of the number of (wrong) guesses left. Successful guesses do not
add to the hangman, and repeated missed guesses do not add to the hangman.</li>
<li>Positional blanks hint at the hidden word, that are filled in with correct guesses.</li>
<li>An ASCII Hangman built as you continue to guess wrongly.</li>
<li>Multiple guesses are allowed, and non-alphabet character guesses are ignored.</li>
</ul>

<h3>A line-by-line analysis</h3>

<p>To understand what's going on here, I'm going to take you through each line of
the code and explain how the magic happens.</p>

<p>Line the first sets up the variables that we are going to use in the rest of the
code. While good style would probably have each assignment on a different line,
we can make use of Python's multiple assignment to do it all on one.</p>

<pre><code class="language-python">license  = 'https://opensource.org/licenses/MIT'
chosen_word = ''.join(
    filter(
      str.isalpha,
      __import__('random').choice(
        open('/usr/share/dict/words').readlines()
        ).upper()))
guesses = set()
scaffold = '|======\n|   |\n| {3} {0} {5}\n|  {2}{1}{4}\n|  {6} {7}\n|  {8} {9}\n|'
man = list('QT-\\-//\\||')
guesses_left = 10
</code></pre>

<ul>
<li>The license of this little snippet is the <a href="https://opensource.org/licenses/MIT">MIT
License</a></li>
<li><code>chosen_word</code> gets assigned a <code>random.choice()</code> from a list of words created
by reading from the words file. Because the words file may include internal
punctuation, e.g. a word "zucchini's", we filter each character through isalpha
to strip that and trailing newlines, and then join the resulting list back to
make a string. Note that by using the builtin <code>__import__</code> function to import
random, we are able to save the line we would have spent on the <code>import</code></li>
<li><code>guesses</code> is assigned a set, that is going to hold the uppercase letters that
the player has guessed.</li>
<li><code>scaffold</code> is a template string that draws a scaffold, with template slots
defined for one-character body parts of the hangman to go into.</li>
<li><code>man</code> is a 10-character string of ASCII body parts for our hangman.</li>
<li><code>guesses_left</code> is going to be the number of guesses that the player has left.
This starts off at 10.</li>
</ul>

<p>The second line contains the main game loop. Since Python permits (without
recommending) you to put a single-statement body on the same line as the
compound statement, we take advantage of that to fold everything onto one line.
Let's treat them separately here.</p>

<pre><code class="language-python">while not all(letter in guesses for letter in chosen_word) and guesses_left:
</code></pre>

<p>The condition of the while loop accounts for the two ways to end a Hangman game.
You either successfully guess the word, or you run out of guesses. We check if
the player has successfully guessed the word by testing to see if all letters in
the word are in the set of guesses. We check to see if the user has lost by
ensuring that there are still some guesses left. If the user has not guessed all
the letters, and the user still has some guesses left, we must continue playing.</p>

<p>The next part takes advantage of Python orders the evaluation of tuple packing
to condense two lines into one. To reason about it, let's pretend we've replaced
the two major parts with meaningful function names as stand-ins. We can read it
as:</p>

<pre><code class="language-python"> _, guesses_left = process_player_guesses(), calculate_new_guesses_left()
</code></pre>

<p>Which saves a line over:</p>

<pre><code class="language-python">process_player_guesses()
guesses_left = calculate_new_guesses_left()
</code></pre>

<p>but has the same effect. How does the mythical <code>process_player_guesses()</code> work?</p>

<pre><code class="language-python">map(guesses.add,
  filter(
    str.isalpha,
    raw_input('%s(%s guesses left)\n%s\n%s:' % (
      ','.join(sorted(guesses)),
      guesses_left,
      scaffold.format(*(man[:10-guesses_left] + [' '] * guesses_left)),
      ' '.join(letter if letter in guesses else '_' for letter in chosen_word))
      ).upper()))
</code></pre>

<p>A lot of the heavy lifting here is done by <code>raw_input()</code>, as it allows us to
both print out a prompt <em>and</em> get input from the user. The prompt we print out
is composed of:</p>

<ul>
<li>A comma separated list of the users guesses so far, sorted.</li>
<li>The number of guesses the user has left.</li>
<li>The scaffold template string, which we format with</li>
<li>As many pieces of the man as the user has had wrong answers
(<code>man[:10-guesses_left]</code>) plus</li>
<li>Enough empty spaces to fill out the remaining empty slots in the template
string.</li>
</ul>

<p>We take the resulting string that the player entered and run it through a filter
to reject non-alphabet characters. We then convert whatever remains to
uppercase, and add that, one by one, to our set of guesses using the map
function.</p>

<p>Let's come back to the mythical <code>calculate_new_guesses_left()</code></p>

<pre><code class="language-python">max((10 - len(guesses - set(chosen_word))), 0)
</code></pre>

<p><em>After</em> the addition of the new guesses has run, the number of guesses left is
 equal to ten minus the number of wrong guesses, where the number of wrong
 guesses is defined as all the letters that are in the guesses set, but not in
 the set of letters of the chosen word. This number may go into the negative,
 because a user may have entered all 26 alphabets on one line, for example. We
 certainly don't want to reward such behaviour.</p>

<p>The main game loop will continue until one of the terminating conditions have
been achieved. At that point, we determine whether the user has won or lost, and
regardless, tell them what the word was.</p>

<pre><code class="language-python">print 'You', ['lose!\n' + scaffold.format(*man), 'win!'][bool(guesses_left)],
print '\nWord was', chosen_word
</code></pre>

<p>We determine whether the user won by taking the <code>bool</code> of the number of guesses
left. This lets us detect cheaters who might successfully guess all the letters
in the word by entering the entire alphabet. Any winner should have at least one
guess left. In Python, False has the same value as the integer 0, and True has
the same value as 1, so we can use this to index into a list of possible
messages to pick the message we should print out.</p>

<p>Since the main game loop never gets a chance to print out an entire hangman, we
take this opportunity to include the ASCII art with the losing message, while
the winning message is just kept simple.</p>

<h3>Conclusion</h3>

<p>So there you have it. Hangman, complete with ASCII art, in three lines of Python
code.</p>

<p>To write out all the code and make minor refactorings took around 30 minutes. It
took me way longer than that to write this blog post detailing exactly <em>how it
works</em>. If I wanted to draw a moral from an exercise I entered into purely for
amusement, I would have to repeat the oft-quoted wisdom that code that is
readable and understandable is going to save you much more time in the long run.</p>

        <hr/>
      </div>
      
    </div></body></html>