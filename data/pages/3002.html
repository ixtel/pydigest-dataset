<html><body><div><div id="sidebar-b"><img alt="Python-Logo" src="images/python-logo.png"/>

<plusone/>


<p class="fb-like" data-href="www.python-course.eu" data-send="false" data-layout="button_count" data-width="130" data-show-faces="true" data-action="recommend"/>

<p>
This topic in German / Deutsche Ãœbersetzung:
    </p><a href="http://www.python-kurs.eu/python3_memoisation.php">Memoisation und Dekorateure</a><h3>Python 3</h3><p>This is a tutorial in Python3, but this chapter of our course is available in a version for Python 2.x as well: </p><a href="memoization.php">Memoization and Decorators in Python 2.x</a><p>
</p><h3>Book a Dedicated Course</h3><p>
The goal of this website is to provide educational material, 
allowing you to learn Python on your own.

Nevertheless, it is faster and more efficient to attend a "real" 
Python course in a classroom, with
an experienced trainer. 



So why not attend one of the live 
</p><a href="python_classes.php">Python courses<img alt="Bodenseo Kurse in Python" src="images/bodenseo_stairs_to_python.png"/></a><p> in Paris, London, Berlin, Munich
or Lake Constance by Bernd Klein, the author of this tutorial?


</p><h3>Onsite Training Courses</h3><p>

Let us come to your company or institute and train your employees, as we've done it many times in Amsterdam (The Netherlands), Berlin (Germany), Bern (Switzerland), Basel (Switzerland), Zurich (Switzerland), Locarno (Switzerland), Den Haag (The Hague), Hamburg (Germany), Frankfurt (Germany), Toronto (Canada), Edmonton (Canada), Munich (Germany) and many other cities. 
We do training courses in England, Switzerland, Liechtenstein, Austria, Germany,
France, Belgium, the Netherlands, Luxembourg, Poland, UK, Italy and other locations in Europe and in Canada.
</p><p>
This way you will get a perfect training up to your needs and it will be extremely cost efficient as well. 
</p><a id="current" href="contact.php" rel="nofollow">Contact us</a><p> so we can define and find the best course curriculum to meet your needs, and schedule course sessions to be held at your location. 

</p><h3>Skilled Python Programmers</h3><p>
You can hire skilled Python programmers or even a skilled team of Python developers to work exclusively on your project.
</p><a id="current" href="contact.php" rel="nofollow">Contact us</a><p>, if you want more information.


</p><h3>Quote of the Day:</h3><p>"Computer science is no more about computers than astronomy is about telescopes."
(Edsger Dijkstra)
<br/></p><hr/> 

</div>
<div id="content">


<h2>Memoization and Decorators</h2>

<h3>Definition of Memoization</h3>
<img class="imgright" src="images/brain.jpg" alt="Brain"/><p>
The term "memoization" was introduced by Donald Michie in the year 1968. It's based on the Latin word memorandum, meaning "to be remembered". It's not a misspelling of the word memorization, though in a way it has something in common. Memoisation is a technique used in computing to speed up programs. This is accomplished by memorizing the calculation results of processed input such as the
results of function calls. If the same input or a function call with the same parameters is used, the previously stored results can be used again and unnecessary calculation are avoided. In many cases a simple array is used for storing the results, but lots of other structures can be used as well, such as associative arrays, called hashes in Perl or dictionaries in Python.
</p><p>
Memoization can be explicitly programmed by the programmer, but some programming languages like Python provide mechanisms to automatically memoize functions.



</p><h3>Memoization with Function Decorators</h3><p>
In our previous chapter about </p><a href="python3_recursive_functions.php">recursive functions</a><p>, we worked out an iterative and a recursive version to calculate the Fibonacci numbers. We have shown that a direct implementation of the mathematical definition into
a recursive function like the following has an exponential runtime behaviour:

</p><pre>
def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)
</pre>
<p>
We also presented a way to improve the runtime behaviour of the recursive version by adding a 
dictionary to memorize previously calculated values of the function. This is an example of 
explicitly using the technique of memoization, but we didn't call it like this. 
The disadvantage of this method is that the clarity and the beauty of the original 
recursive implementation is lost. 
</p><p>
The "problem" is that we changed the code of the recursive fib function. The following code 
doesn't change our fib function, so that its clarity and legibility isn't touched. To this
purpose, we use function which we call memoize.
memoize() takes a function as an argument. The function memoize uses a dictionary "memo" 
to store the function results. Though the variable "memo" as well as the function "f" are 
local to memoize, they captured by a closure through the helper function which is returned 
as a reference by memoize(). So, the call memoize(fib) returns a reference to the helper() 
which is doing what fib() would have done plus a wrapper which is saving the results, which 
are still not stored, in the memo dictionary and is preventing recalculation of results, 
which are already in memo.  



</p><pre>
def memoize(f):
    memo = {}
    def helper(x):
        if x not in memo:            
            memo[x] = f(x)
        return memo[x]
    return helper
    

def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

fib = memoize(fib)

print(fib(40))
</pre>

<p>
Let's look at the line in our code were we assign memoize to fib:
</p><pre>fib = memoize(fib)</pre><p>
Doing this, we turn memoize into a decorator. 
One says that the fib function is decorated by the the memoize() function.
</p><p>

We will illustrate with the following diagrams how the decoration is accomplished. The first diagram illustrates the state before the decoration, i.e. before we call </p><code>fib = memoize(fib)</code><p>. We can see the function
names referencing their bodies: 

</p><img src="images/memoize1.png" alt="Way of functioning of a decorator"/>
<p>
After having executed </p><code>fib = memoize(fib)</code><p> fib points to the body 
of the helper function, which had been returned by memoize. 
We can also perceive that the code of the original fib function can only be reached via the "f" function of the helper function. There is no way anymore to call the original fib directly, i.e. there is no other reference to it.
The decorated Fibonacci function is called in the return statement </p><code>return fib(n-1) + fib(n-2)</code><p>, this means the code of the helper function which had been returned by memoize:

</p><img src="images/memoize2.png" alt="Way of functioning of a decorator, 2nd diagram"/>
<p>

Another point in the context of decorators deserves special mention: We don't usually write a decorator for just one use case or function. We rather use it multiple times for different functions. So we could imagine having further functions func1, func2, func3 and so on, which consume also a lot of time.  
Therefore, it makes sense to decorate each one with our decorator function "memoize":

 </p><pre>
fib = memoize(fib)
func1 = memoize(func1)
func2 = memoize(func2)
func3 = memoize(func3)
# and so on
</pre>



<h3>Memoize as a Class</h3><p>
The subchapter can be skipped without problems by those who don't know about object orientation so far. 
</p><p>
We can encapsulate the caching of the results in a class as well, as you can see in the 
following example:

</p><pre>
class Memoize:
    def __init__(self, fn):
        self.fn = fn
        self.memo = {}
    def __call__(self, *args):
        if args not in self.memo:
				self.memo[args] = self.fn(*args)
        return self.memo[args]
</pre>
<p>
As we are using a dictionary, we can't use mutable arguments, i.e. the arguments have 
to be immutable.


</p><h3>The Usual Syntax for Decorators in Python</h3><p>

Summarizing we can say that a decorator in Python is a callable Python object that is used to modify a function, method or class definition. The original object, the one which is going to be modified, is passed to a decorator as an argument. The decorator returns a modified object, e.g. a 
modified function, which is bound to the name used in the definition.
</p><p>
The decoration in Python is usually not performed in the way we did it in our previous example, even though the notation  </p><code>fib = memoize(fib)</code><p> is catchy and easy to grasp. The decoration is in the line before the function header. The "@" is followed by the decorator function name.
</p><p>
We will rewrite now our initial example. Instead of writing the statement
</p><pre>fib = memoize(fib)</pre><p>
we can write 
</p><pre>@memoize</pre><p>
But this line has to be directly in front of the decorated function, in our example fib(). The complete example looks like this now:

</p><pre>
def memoize(f):
    memo = {}
    def helper(x):
        if x not in memo:            
            memo[x] = f(x)
        return memo[x]
    return helper
    
@memoize
def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

#fib = memoize(fib)

print(fib(40))
</pre>




<h3>Further Examples for Decorators</h3>
<h4>Checking Arguments with a Decorator</h4><p>
In our chapter about recursive functions we introduced the factorial function. We wanted to 
keep the function as simple as possible and we didn't want to obscure the underlying idea, 
so we hadn't incorporated any argument checks. So, if somebody had called our function with 
a negative argument or with a float argument, our function
would have got into an endless loop.
</p><p>
The following program uses a decorator function to ensure that the argument passed to the 
function factorial is a positive integer:
</p><pre>
def argument_test_natural_number(f):
    def helper(x):
        if type(x) == int and x &gt; 0:
        		return f(x)
        else:
        		raise Exception("Argument is not an integer")
    return helper
    
@argument_test_natural_number
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)

for i in range(1,10):
	print(i, factorial(i))

print(factorial(-1))
</pre>

<h4>Counting Function Calls with Decorators</h4><p>

The following example uses a decorator to count the number of times a function has been called.

</p><pre>
def call_counter(func):
    def helper(*args, **kwargs):
        helper.calls += 1
        return func(*args, **kwargs)
    helper.calls = 0
    helper.__name__= func.__name__

    return helper

@call_counter
def succ(x):
    return x + 1

print(succ.calls)
for i in range(10):
    print(succ(i))
    
print(succ.calls)
</pre><p>

The output looks like this:

</p><pre>
0
10
</pre>

<h3>Exercise</h3>
<ol>
<li>
<img class="imgright" src="images/scales_small.jpg" alt="Scales, Public Domai"/>
Our exercise is an old riddle, going back to 1612. The French Jesuit Claude-Gaspar 
Bachet phrased it. We have to weigh quantities (e.g. sugar or flour) from 1 to 40 pounds. 
What is the least number of weights that can be used on a balance scale to way any of 
these quantities.

<br/><br/>
The first idea might be to use weights of 1, 2, 4, 8, 16 and 32 pounds. This is a 
minimal number, if we restrict ourself to put weights on one side and the stuff, e.g. 
the sugar, on the other side. But it is possible to put weights on both pans of the scale. 
Now, we need only for weights, i.e. 1,3,9,27
<br/><br/>
Write a Python function weigh(), which calculates the weights needed and their 
distribution on the pans to weigh any amount from 1 to 40.
</li>
</ol>

<h3>Solution</h3>

<ol>
<li>
We need the function linear_combination() from our chapter 
"<a href="linear_combinations.php">Linear Combinations</a>".

<pre>
def factors_set():
    factors_set = ( (i,j,k,l) for i in [-1,0,1] 
                          for j in [-1,0,1]
                          for k in [-1,0,1]
                          for l in [-1,0,1])
    for factor in factors_set:
        yield factor

def memoize(f):
    results = {}
    def helper(n):
        if n not in results:
            results[n] = f(n)
        return results[n]
    return helper

@memoize
def linear_combination(n):
    """ returns the tuple (i,j,k,l) satisfying
        n = i*1 + j*3 + k*9 + l*27      """
    weighs = (1,3,9,27)
      
    for factors in factors_set():
       sum = 0
       for i in range(len(factors)):
          sum += factors[i] * weighs[i]
       if sum == n:
          return factors
</pre>

With this, it is easy to write our function weigh().

<pre>
def weigh(pounds):
    weights = (1,3,9,27)
    scalars = linear_combination(pounds)
    left = ""
    right = ""
    for i in range(len(scalars)):
        if scalars[i] == -1:
            left += str(weights[i]) + " "
	elif scalars[i] == 1:
            right += str(weights[i]) + " "
    return (left,right)

for i in [2,3,4,7,8,9,20,40]:
	pans = weigh(i)
	print("Left  pan: " + str(i) + " plus " + pans[0])
	print("Right pan: " + pans[1] + "\n")
</pre>
</li>
</ol>



</div>



</div></body></html>