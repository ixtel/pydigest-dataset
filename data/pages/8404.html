<html><body><div><div class="content html_format">
      <i>Предлагаю вашему вниманию статью, основанную на <a href="http://www.laurentluce.com/posts/python-list-implementation/">публикации</a> Laurent Luce о реализации работы со списками в CPython. Она может быть полезна начинающим программистам на Python, либо готовящимся к собеседованию. Функции C <b>показаны в сокращенном варианте </b>и с моими комментариями. Полный текст функций можно найти в <a href="https://github.com/python/cpython/blob/2.7/Objects/intobject.c">исходниках</a> CPython 2.7.</i>
<p>
Эта статья описывает реализацию объекта списка в CPython, наиболее популярной реализации Python. Списки в Python — это мощный инструмент, и интересно узнать, как они устроены внутри. Взгляните на простой скрипт, который добавляет несколько целых значений в список и выводит их:

</p><pre><code class="python">&gt;&gt;&gt; l = []
&gt;&gt;&gt; l.append(1)
&gt;&gt;&gt; l.append(2)
&gt;&gt;&gt; l.append(3)
&gt;&gt;&gt; l
[1, 2, 3]
&gt;&gt;&gt; for e in l:
...   print e
...
1
2
3
</code></pre><p>
Как вы можете видеть, список является итерируемым объектом.

</p><h5>C-структура объекта списка</h5><p>
Объект списка в CPython представлен нижеследующей структурой в C. ob_item — это список указателей на элементы списка, allocated — количество выделенной памяти.

</p><pre><code class="cpp">typedef struct {
    PyObject_VAR_HEAD
    PyObject **ob_item;
    Py_ssize_t allocated;
} PyListObject;
</code></pre><a name="habracut"/>
<h5>Инициализация списка</h5><p>
Давайте посмотрим, что происходит при создании пустого списка, к примеру l = []. Вызывается функция PyList_New(0):

</p><pre><code class="cpp">/* 
size - размер списка
*/
PyList_New(Py_ssize_t size)
{
    // Вычисляется реальный размер необходимой памяти
    nbytes = size * sizeof(PyObject *);

    // Инициализируется ob_item
    if (size &lt;= 0)
        op-&gt;ob_item = NULL;
    else {
        op-&gt;ob_item = (PyObject **) PyMem_MALLOC(nbytes);
        memset(op-&gt;ob_item, 0, nbytes);
    }

    // Сохраняется количество выделенных ячеек
    op-&gt;allocated = size;

    return (PyObject *) op;
}
</code></pre><p>
Важно понимать разницу между выделенной памятью и размером списка. Размер списка — это тоже самое, что и len(l). allocated — это количество выделенной памяти, которое зачастую может быть больше размера списка. Это делается для предотвращения вызовов realloc при каждом добавлении элементов. Мы разберемся в этом подробнее чуть позже.

</p><h5>Добавление элементов</h5><p>
Мы добавляем целое число в список: l.append(1). Что в этот момент происходит? Вызывается функция C PyList_Append(), которая, в свою очередь, вызывает функцию app1():

</p><pre><code class="cpp">/*
self - указатель на объект списка
v - указатель на добавляемое значение
*/
app1(PyListObject *self, PyObject *v)
{
    // Если не удалось изменить размер списка, возвращаем ошибку - значение (-1)
    if (list_resize(self, n+1) == -1)
        return -1;

    // После изменения размера списка, устанавливаем значение элемента n в v
    PyList_SET_ITEM(self, n, v);
    
    // При успешном выполнении возвращаем 0
    return 0;
}
</code></pre><p>
Давайте посмотрим на функцию list_resize(). Она выделяет больше памяти, чем нужно для предотвращения частых вызовов list_resize. Выделение памяти задается следующей последовательностью: 0, 4, 8, 16, 25, 35, 46, 58, 72, 88, …

</p><pre><code class="cpp">/*
self - указатель на объект списка
newsize - новый размер списка
*/
list_resize(PyListObject *self, Py_ssize_t newsize)
{
    // Если выделенной ранее памяти достаточно для заданного размера - дополнительной памяти не выделяем
    if (allocated &gt;= newsize &amp;&amp; newsize &gt;= (allocated &gt;&gt; 1)) {
        assert(self-&gt;ob_item != NULL || newsize == 0);
        Py_SIZE(self) = newsize;
        return 0;
    }

    /* В противном случае выделяем необходимую память, а также резервируем 
     * дополнительную для следующих увеличений списка
     */
    new_allocated = (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6);

    /* Проверяем на переполнение */
    if (new_allocated &gt; PY_SIZE_MAX - newsize) {
        PyErr_NoMemory();
        return -1;
    } else {
        new_allocated += newsize;
    }

    // Выделяем память
    if (new_allocated &lt;= (PY_SIZE_MAX / sizeof(PyObject *)))
        PyMem_RESIZE(items, PyObject *, new_allocated);

    return 0;
}
</code></pre><p>
4 ячейки сейчас выделено для элементов списка и первый из них — это целое число 1. На изображении вы можете увидеть, что l[0] указывает на целое число, которое мы добавили в список. Квадраты, помеченные прерывистой линией, обозначают выделенную, но еще не использованную память.
</p><p>
Операция добавления элемента в список имеет сложность O(1).

</p><img src="https://habrastorage.org/files/245/65a/313/24565a313dd8404abc23df068fddf5df.png" alt="image"/>
<p>
Добавим еще один элемент в список: l.append(2). list_resize вызывается с n+1 = 2, но, так как размер выделенной памяти 4, нет необходимости выделять дополнительную память. То же самое происходить при добавлении еще двух целых чисел: l.append(3), l.append(4). На картинке показано, что мы имеем в итоге:

</p><img src="https://habrastorage.org/files/aa9/028/419/aa9028419587469dbb9d69023cea2d71.png" alt="image"/>

<h5>Вставка</h5><p>
Вставим новое целое число в позицию 1: l.insert(1,5) и посмотрим, что будет происходить на низком уровне. Вызывается функция ins1():

</p><pre><code class="cpp">/*
self - указатель на объект списка
where - позиция, в которую вставляется новый элемент
v - указатель на вставляемое значение
*/
ins1(PyListObject *self, Py_ssize_t where, PyObject *v)
{
    n = Py_SIZE(self);

    // Изменяем размер списка и возвращаем ошибку в случае неудачи
    if (list_resize(self, n+1) == -1)
        return -1;

    // Если позиция отрицательна, то считаем с конца списка
    if (where &lt; 0) {
        where += n;
        if (where &lt; 0)
            where = 0;
    }
    // Если позиция больше длины списка, то вставляем в конец
    if (where &gt; n)
        where = n;

    // Сдвигаем значения списка от конца до вставляемого элемента
    items = self-&gt;ob_item;
    for (i = n; --i &gt;= where; )
        items[i+1] = items[i];
    // Вставляем новый элемент
    items[where] = v;

    return 0;
}
</code></pre>
<img src="https://habrastorage.org/files/acf/3fe/5f8/acf3fe5f8e114f35b50508b0b171e006.png" alt="image"/>
<p>
Квадраты, помеченные прерывистой линией, обозначают выделенную, но еще не использованную память. Итак, 8 ячеек выделено, но размер списка у нас сейчас 5.
</p><p>
Сложность операции вставки O(n).

</p><h5>Выталкивание</h5><p>
Когда вы выталкиваете элемент из списка, l.pop(), вызывается listpop(). list_resize вызывается внутри listpop() и в случае, если новый размер меньше половины выделенной памяти — то список сжимается.

</p><pre><code class="cpp">/*
self - указатель на объект списка
args - параметры, указывающие на выталкиваемый элемент
*/
listpop(PyListObject *self, PyObject *args)
{
    // По умолчанию выталкиваем последний элемент
    Py_ssize_t i = -1;

    // Если список пуст - возвращаем NULL
    if (Py_SIZE(self) == 0) {
        return NULL;
    }

    // Если индекс отрицательный - считаем с конца
    if (i &lt; 0)
        i += Py_SIZE(self);

    v = self-&gt;ob_item[i];
    // Если выталкивается последний элемент - вызывает list_resize и возвращаем вытолкнутое значение
    if (i == Py_SIZE(self) - 1) {
        status = list_resize(self, Py_SIZE(self) - 1);
        return v; 
    }

    // Если выталкивается элемент из внутренности списка, вызываем специальную функцию для изменения списка
    status = list_ass_slice(self, i, i+1, (PyObject *)NULL);

    return v;
}
</code></pre><p>
Сложность операции O(1).

</p><img src="https://habrastorage.org/files/48d/f2e/689/48df2e689583456f99a11e88ac68b326.png" alt="image"/>
<p>
Вы можете наблюдать, что 4 ячейка все еще указывает на целое, но важно понимать, что размер списка у нас 4.
</p><p>
Вытолкнем еще один элемент. В list_resize(), size-1 = 4-1 = 3 меньше чем половина выделенных ячеек, поэтому список сжимается до 6 ячеек и новый размер списка становится 3.
</p><p>
Вы можете наблюдать, что 3 и 4 ячейка все еще указывают на целое, но важно понимать, что размер списка у нас 3.

</p><img src="https://habrastorage.org/files/e00/4b4/2a8/e004b42a8f0d4ebbb014fcaaf08ca42a.png" alt="image"/>

<h5>Удаление</h5><p>
В Python объект списка имеет метод для удаления элемента с заданным значением: l.remove(5). Вызывается listremove().

</p><pre><code class="cpp">/*
self - указатель на объект списка
v - указатель на удаляемое значение
*/
listremove(PyListObject *self, PyObject *v)
{
    Py_ssize_t i;

    // Пробегаемся по списку
    for (i = 0; i &lt; Py_SIZE(self); i++) {
        int cmp = PyObject_RichCompareBool(self-&gt;ob_item[i], v, Py_EQ);

        // Если нашли подходящее значение - удаляем его и возвращаем Python None
        if (cmp &gt; 0) {
            if (list_ass_slice(self, i, i+1,
                               (PyObject *)NULL) == 0)
                Py_RETURN_NONE;
            return NULL;
        }
        else if (cmp &lt; 0)
            return NULL;
    }

    // Если не нашли элемент - возвращаем NULL
    return NULL;
}
</code></pre>
<p>
Сложность операции удаления — O(n).

</p><img src="https://habrastorage.org/files/942/1c8/ea4/9421c8ea44c0403f9c03b3246cefb298.png" alt="image"/>
      <p class="clear"/>
    </div>

    
  </div></body></html>