<html><body><div><div class="post-content">
                    <p class="pull-quote">No longer are your methods confined to bare calls!</p>

<p>One of my pet peeves when it comes to Django is that you can’t call methods that require arguments in templates. While this is fine most of the time, it does mean that you need to have one property or method per call you want to make, which sometimes gets very cumbersome.</p>
<p>I needed a way to define various dynamic permissions that are calculated at runtime (for irrelevant reasons, Django’s permissions framework wasn’t a good fit), and writing properties like <code>can_register</code>, <code>can_add_tags</code>, <code>can_subscribe</code> got tedious. These tended to be defined all over the place, rather than in one central spot, and it was hard to add more checks without cluttering the classes.</p>
<p>I would much prefer to have a single method (let’s call it <code>can()</code>) that accepted a string with the permission I wanted to check, and return <code>True</code> or <code>False</code>, depending. This is easy to do in the views, but templates would never be able to call it with an argument.</p>
<p>However, since Django can do dictionary-style attribute lookups, I could add a dictionary interface over the method, and allow it to be called both from the views (<code>user.can("add_tags")</code>) and templates (<code>{{ user.can.add_tags }}</code>).</p>
<p>To perform this sort of dynamic call/lookup with an argument in templates, the easiest thing to do is to define a decorator that will enable dict-style access to the method, as well as call-style access. Here’s the code:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">AttrLookup</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span> <span class="o">=</span> <span class="n">instance</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="c"># Return a new instance of the decorator with the class embedded, rather than</span>
        <span class="c"># store instance here, to avoid race conditions in multithreaded scenarios.</span>
        <span class="k">return</span> <span class="n">AttrLookup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">argument</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instance</span><span class="p">,</span> <span class="n">argument</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">argument</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># When resolving something like {{ user.can.change_number }}, Django will call</span>
        <span class="c"># each element in the dot sequence in order (or otherwise try to access it).</span>
        <span class="c"># When trying to call can(), that will fail, because it expects an extra</span>
        <span class="c"># argument, so Django will fail and leave it at that.</span>
        <span class="c"># If there's no argument passed, we return itself, so Django can continue with</span>
        <span class="c"># the attribute lookup down the chain.</span>
        <span class="k">if</span> <span class="n">argument</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instance</span><span class="p">,</span> <span class="n">argument</span><span class="p">)</span>
</pre></div>


<p>Then, just use it like so:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="nd">@AttrLookup</span>
    <span class="k">def</span> <span class="nf">can</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">permission</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">permission</span> <span class="o">==</span> <span class="s">"some_permission"</span><span class="p">:</span>
            <span class="c"># Obviously, your check will be more complicated than this.</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="bp">False</span>
</pre></div>


<p>How it works should be pretty straightforward. The decorator is called with the bound method on instantiation (<code>AttLookup(can)</code>) and returns an AttrLookup instance (let’s call it <code>attr_lookup</code>). When that gets accessed dictionary-style, <code>__getitem__</code> calls the decorated method. Same when it’s called directly, except there’s a small hitch with how Django evaluates templates that needs to be worked around.</p>
<p>As you can see, this is a pretty simple and straightforward way to enable calls of methods that accept a single argument in Django templates. I’m not entirely sure it’s not too clever, but what it does to the decorated function is straightforward and seems like good design. If you disagree, please let me know in the comments, as I’m curious to know if there’s a better way. In any case, I hope you’ll find the decorator useful!</p>
                </div>
            </div></body></html>