<html><body><div><div dir="ltr" trbidi="on">
<div dir="ltr" trbidi="on">
<b>Разрабатывая небольшой сайт с использованием фреймворка Django, я столкнулся со следующей задачей: необходимо было отправить со страницы POST-запрос содержащий определённые параметры, после получения которого Django должен запустить довольно тяжёлый процесс и не дожидаясь результатов его выполнения, вернуть ответ о том что процесс успешно запущен. </b>
<b><br/></b><p>
Для начала вспомним что такое синхронный и асинхронный запрос:
</p><blockquote class="tr_bq">
Синхронный запрос - запрос с ожиданием ответа от сервера.</blockquote>
<blockquote class="tr_bq">
Асинхронный запрос - запрос без ожидания ответа от сервера.</blockquote><p>
Вроде всё просто, но есть один подводный камень: так как Django блокирующий фреймворк, то формально в нём исключена возможность выполнения асинхронных запросов, то есть на каждый запрос мы должны вернуть ответ, даже если этот запрос отправлен с помощью JQuery и AJAX. Но мы можем пойти на хитрость :) Нам ни что не мешает игнорировать ответы при условии что мы его дождёмся. Тогда задача сводится к тому как не "повесить" страницу нашим запросом, если мы хотим запустить тяжёлый фоновый процесс. Да, по факту это не асинхрон, но зато данный подход позволит решить ряд мелких задач и при этом нам не нужно дополнительно разворачивать сервер для обработки асинхронных запросов с нашей страницы.
</p><p>
В данном случае у нас должно получиться синхронно-асинхронное приложение, так как с одной стороны мы ждём ответ об успешно выполненном действии, но с другой стороны наше действие заключается только в том чтобы что-то запустить и со спокойной душой пойти заниматься своими делами, не дожидаясь результатов работы.

</p><b>В примере я использую Python 3.3.4 и Django 1.7, операционная система Linux Kubuntu, среда разработки - PyCharm.</b>
<p>
Перейдём к практике: создайте Django - проект и добавьте в него новое приложение. Я назвал это приложение "async", вы можете выбрать любое другое название для него. Создайте сразу в проекте папку templates для хранения html-шаблонов. Вот как примерно должна выглядеть структура проекта:

</p>
<p>
Этот проект должен прекрасно запускаться командой: </p><b>python3 manage.py runserver</b>
<p>
Теперь в папке templates создайте файл index.html:
</p></div>
<pre><code> &lt;!DOCTYPE html&gt;  
 &lt;html&gt;  
 &lt;head lang="en"&gt;  
   &lt;meta charset="UTF-8"&gt;  
   &lt;title&gt;Пример "асинхронного" запроса&lt;/title&gt;  
   &lt;script src="http://code.jquery.com/jquery-2.0.3.min.js"&gt;&lt;/script&gt;  
   &lt;script&gt;  
     function doIt() {  
       $.ajax({  
         type: "POST",  
         url: "/",  
         data: {  
           csrfmiddlewaretoken: document.getElementsByName('csrfmiddlewaretoken')[0].value,  
           count: $("#input_count").val()  
         },  
         success: function(data) {  
           alert("Процесс запущен!");  
         },  
         error: function(xhr, textStatus, errorThrown) {  
           alert("Error: "+errorThrown+xhr.status+xhr.responseText);  
         }  
       });  
     }  
   &lt;/script&gt;  
 &lt;/head&gt;  
 &lt;body&gt;  
   {% csrf_token %}  
   &lt;input id="input_count" type="number" value="1" min="1" max="10000"&gt;&lt;/p&gt;  
   &lt;input id="button_do_it" type="button" value="Отправить" onclick="doIt()"&gt;  
 &lt;/body&gt;  
 &lt;/html&gt;  
</code></pre>
<p>
Так как у нас тестовый проект, то я решил обойтись без шаблонов, организации статики и прочих предварительных ласк. Всё что нам нужно поместилось на одной странице, а именно: у нас есть поле (</p><b>input_count</b><p>), в которое мы можем ввести число от 1 до 10000 и кнопка (</p><b>button_do_it</b><p>), по нажатию которой вызывается функция doIt(). В этой функции, используя библиотеку JQuery мы отправляем POST-запрос с двумя параметрами:

</p><ol>
<li><b>csrfmiddlewaretoken</b> - значение данного параметра является хэшем для идентификатора сессии плюс секретный ключ. Этот параметр нужен для django.contrib.csrf, который защищает от атак типа «подделка HTTP запросов» (Cross-Site Request Forgery).</li>
<li><b>count </b>- число из поля <b>input_count</b></li>
</ol>
<p>
Теперь создадим наш "тяжёлый" фоновый процесс. Добавьте в пакет async файл processor.py:<br/>
<br/></p>
</div>
<p>
Код примитивный: при каждой итерации спим одну секунду и потом выводим текущее значение счётчика в консоль.
</p></div></body></html>