<html><body><div><article>
    
    <p>Written on Thursday August 20, 2015</p>
    <p/><p><strong>tl;dr: The <a href="https://gist.github.com/mikeanthonywild/4e4784f1974d21f366d5">gist here</a> provides a replacement <code>threading.Thread</code> class with a <code>stop()</code> method using Gevent and greenlets. It should also be prefixed by saying these aren't proper 'threads', but 'greenlets'.</strong></p>
<p>Something which crops up <a href="http://stackoverflow.com/questions/323972/is-there-any-way-to-kill-a-thread-in-python">time</a> and <a href="http://stackoverflow.com/questions/5019436/python-how-to-terminate-a-blocking-thread">time again</a>, is how to stop a blocking thread in Python. Take the following example to spawn a blocking thread in the background:</p>
<div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">time</span>


<span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s2">"Waiting 10s to exit..."</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">"Press &lt;Ctrl-C&gt; to stop thread"</span><span class="p">)</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
        <span class="nb">exit</span><span class="p">(</span><span class="s2">"Keyboard interrupt - waiting for thread to finish..."</span><span class="p">)</span>
</pre></div>


<p>Output:</p>
<div class="highlight"><pre><span/><span class="go">Waiting 10s to exit...</span>
<span class="go">Press &lt;Ctrl-C&gt; to stop thread</span>
<span class="go">^C</span>
<span class="go">Keyboard interrupt - waiting for thread to finish...</span>
<span class="go">[...]</span>
</pre></div>


<p>Notice that even though we catch the <code>^C</code> escape sequence, the main thread won't exit until the sleep thread has finished, even if you mash <code>^C</code>. A quick fix in this case would be to set the <code>t.daemon</code> property to <code>True</code> before the thread is started, meaning that the main thread won't wait for child threads to finish before exiting. This is fine for trivial examples like the one above, but can become a real issue when we start dealing with sockets and the like. </p>
<p>Here's a more realistic example:</p>
<div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">time</span>


<span class="k">class</span> <span class="nc">StoppableThread</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">'127.0.0.1'</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">"Listening on {}:{}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">StoppableThread</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">"Press &lt;Ctrl-C&gt; to stop thread"</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">(</span><span class="s2">"Keyboard interrupt - waiting for thread to finish..."</span><span class="p">)</span>
</pre></div>


<p>Output:</p>
<div class="highlight"><pre><span/><span class="go">Press &lt;Ctrl-C&gt; to stop thread</span>
<span class="go">Listening on 127.0.0.1:65309</span>
<span class="go">^C</span>
<span class="go">Keyboard interrupt - waiting for thread to finish...</span>
<span class="go">[...]</span>
</pre></div>


<p>Using <code>t.daemon = True</code> on a socket server thread can lead to the socket not being released â€“ thus it's impossible to restart the server as Python won't be able to bind to the port you were using (ignoring the <code>SO_REUSEADDR</code> flag). Additionally, sometimes Python can't kill its child threads and you end up having to force-kill the entire process, leading to the afformentioned issue. Yet, if we use <code>t.daemon = False</code>, we have to kill the whole process anyway, because it's blocked by <code>s.accept()</code> until something connects. </p>
<h3>Solution</h3>
<p>The widely-accepted solution is to set a timeout on our blocking functions so we can periodically check a <code>threading.Event</code> which we set from the main thread to indicate we want the child thread to stop. Unfortunately this solution is a little clunky:</p>
<div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">StoppableThread</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">StoppableThread</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stop</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">settimeout</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>             <span class="c1"># Socket will raise exception if nothing received</span>
        <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">'127.0.0.1'</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">"Listening on {}:{}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
                <span class="c1"># Check for stop signal</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                    <span class="k">print</span><span class="p">(</span><span class="s2">"Shutting down cleanly..."</span><span class="p">)</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                    <span class="k">return</span>
</pre></div>


<p>Now when we catch a <code>KeyboardInterrupt</code> we can trigger the server thread to stop:</p>
<div class="highlight"><pre><span/><span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
    <span class="n">t</span><span class="o">.</span><span class="n">_stop</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
    <span class="nb">exit</span><span class="p">(</span><span class="s2">"Keyboard interrupt - waiting for thread to finish..."</span><span class="p">)</span>
</pre></div>


<h3>A better solution using Gevent and greenlets</h3>
<p>The official description of a greenlet is rather confusing given the context of this post, so a simple example will be used to explain it instead (taken from http://sdiehl.github.io/gevent-tutorial/):</p>
<div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">gevent</span>
<span class="kn">from</span> <span class="nn">gevent</span> <span class="kn">import</span> <span class="n">select</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">tic</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="s1">'at </span><span class="si">%1.1f</span><span class="s1"> seconds'</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">gr1</span><span class="p">():</span>
    <span class="c1"># Busy waits for a second, but we don't want to stick around...</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Started Polling: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">tic</span><span class="p">())</span>
    <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Ended Polling: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">tic</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">gr2</span><span class="p">():</span>
    <span class="c1"># Busy waits for a second, but we don't want to stick around...</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Started Polling: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">tic</span><span class="p">())</span>
    <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Ended Polling: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">tic</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">gr3</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">"Hey lets do some stuff while the greenlets poll, </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="n">tic</span><span class="p">())</span>
    <span class="n">gevent</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">gevent</span><span class="o">.</span><span class="n">joinall</span><span class="p">([</span>
    <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">gr1</span><span class="p">),</span>
    <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">gr2</span><span class="p">),</span>
    <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">gr3</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>


<p>Output:</p>
<div class="highlight"><pre><span/><span class="go">Started Polling: at 0.0 seconds</span>
<span class="go">Started Polling: at 0.0 seconds</span>
<span class="go">Hey lets do some stuff while the greenlets poll, at 0.0 seconds</span>
<span class="go">Ended Polling: at 2.0 seconds</span>
<span class="go">Ended Polling: at 2.0 seconds</span>
</pre></div>


<p>What this shows is that Gevent provides pseudo-concurrency by context switching on blocking functions like <code>select()</code>. The keen-eyed observer will notice that the snippet above uses a special <code>gevent.select</code>, a version of the standard Python implementation which has been <a href="http://stackoverflow.com/questions/5626193/what-is-a-monkey-patch">monkeypatched</a> to behave co-operatively to allow the switching behaviour seen above. It's also possible to just import a standard blocking Python module and patch it at runtime like so:</p>
<div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">gevent</span> <span class="kn">import</span> <span class="n">monkey</span>
<span class="n">monkey</span><span class="o">.</span><span class="n">patch_all</span><span class="p">()</span>

<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Now it can be used inside a greenlet!</span>
</pre></div>


<p>This is significant, because without the monkeypatching, it wouldn't be possible to implement a stoppable thread as easily. Critically, Gevent also provides a <code>Greenlet.kill()</code> method, which stops the greenlet from executing.</p>
<h4>Putting everything together</h4>
<p>We can put all of this together to obtain our stoppable thread:</p>
<ol>
<li>Use <code>gevent.spawn()</code> to spawn a new greenlet with the thread's <code>run()</code> method.</li>
<li>Call the greenlet's <code>kill()</code> method to stop the 'thread'.</li>
<li>Release all the resources used by the greenlet.</li>
</ol>
<p>An example stoppable thread class is presented here:</p>
<div class="highlight"><pre><span/><span class="sd">""" betterthreads provides an enhanced replacement for the </span>
<span class="sd">    threading.Thread class geared towards cleanly stopping blocking</span>
<span class="sd">    threads.</span>
<span class="sd">"""</span>

<span class="kn">import</span> <span class="nn">gevent</span>
<span class="kn">import</span> <span class="nn">uuid</span>

<span class="kn">from</span> <span class="nn">gevent.event</span> <span class="kn">import</span> <span class="n">Event</span>


<span class="c1"># Helper to generate new thread names</span>
<span class="n">_counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">def</span> <span class="nf">_newname</span><span class="p">(</span><span class="n">template</span><span class="o">=</span><span class="s2">"Thread-</span><span class="si">%d</span><span class="s2">"</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">_counter</span>
    <span class="n">_counter</span> <span class="o">=</span> <span class="n">_counter</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">template</span> <span class="o">%</span> <span class="n">_counter</span>


<span class="k">class</span> <span class="nc">Thread</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">""" An enhanced replacement for the Python </span>
<span class="sd">    :class:`threading.Thread` class.</span>

<span class="sd">    This isn't actually a true thread, instead it uses Gevent to</span>
<span class="sd">    implement co-routines. Using :func:`gevent.monkey.patch_all`, all</span>
<span class="sd">    Python blocking functions are replaced with non-blocking Gevent</span>
<span class="sd">    alternatives which allow </span>
<span class="sd">    """</span>

    <span class="n">__initialized</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">""" Thread constructor</span>

<span class="sd">        :param group: should be ``None``; reserved for future </span>
<span class="sd">        extension when a :class:`ThreadGroup` class is implemented.</span>
<span class="sd">        :param name: the thread name.  By default, a unique name</span>
<span class="sd">        is constructed of the form "Thread-*N*" where *N* is a small </span>
<span class="sd">        decimal number.</span>

<span class="sd">        If the subclass overrides the constructor, it must make sure </span>
<span class="sd">        to invoke the base class constructor (``Thread.__init__()``) </span>
<span class="sd">        before doing anything else to the thread.</span>
<span class="sd">        """</span>

        <span class="c1"># WARNING: Not sure about the side-effects of this...</span>
        <span class="c1"># Monkeypatch a bunch of blocking and thread-related</span>
        <span class="c1"># constructs to use gevent alternatives. Threads are now</span>
        <span class="c1"># co-routines which yield to each other when a Gevent</span>
        <span class="c1"># blocking operation is called.</span>
        <span class="kn">from</span> <span class="nn">gevent</span> <span class="kn">import</span> <span class="n">monkey</span>
        <span class="n">monkey</span><span class="o">.</span><span class="n">patch_all</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span> <span class="ow">or</span> <span class="n">_newname</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ident</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__started</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">""" Start the thread's activity.</span>

<span class="sd">        It must be called at most once per thread object.  It</span>
<span class="sd">        arranges for the object's :meth:`run` method to be invoked in</span>
<span class="sd">        a separate thread of control.</span>

<span class="sd">        This method will raise a :exc:`RuntimeError` if called more </span>
<span class="sd">        than once on the same thread object.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"thread.__init__() not called"</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"thread already started"</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bootstrap</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_bootstrap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ident</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_g_main</span> <span class="o">=</span> <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">""" Stop the thread's activity.</span>

<span class="sd">        :param blocking: block until thread has stopped completely.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"threads can only be stopped once"</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_g_main</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">blocking</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_g_main</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">""" Method representing the thread's activity.</span>

<span class="sd">        You may override this method in a subclass.</span>
<span class="sd">        """</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">""" Wait until the thread terminates.</span>

<span class="sd">        This blocks the calling thread until the</span>
<span class="sd">        thread whose :meth:`join` method is called terminates -- </span>
<span class="sd">        either normally or through an unhandled exception -- or until</span>
<span class="sd">        the optional timeout occurs.</span>

<span class="sd">        When the *timeout* argument is present and not ``None``, it </span>
<span class="sd">        should be a floating point number specifying a timeout for </span>
<span class="sd">        the operation in seconds (or fractions thereof). As </span>
<span class="sd">        :meth:`join` always returns ``None``, you must call </span>
<span class="sd">        :meth:`isAlive` after :meth:`join` to decide whether a </span>
<span class="sd">        timeout happened -- if the thread is still alive, the </span>
<span class="sd">        :meth:`join` call timed out.</span>

<span class="sd">        When the *timeout* argument is not present or ``None``, the </span>
<span class="sd">        operation will block until the thread terminates.</span>

<span class="sd">        A thread can be :meth:`join`\ ed many times.</span>

<span class="sd">        :meth:`join` raises a :exc:`RuntimeError` if an attempt is </span>
<span class="sd">        made to join the current thread as that would cause a </span>
<span class="sd">        deadlock. It is also an error to :meth:`join` a thread before</span>
<span class="sd">        it has been started and attempts to do so raises the same exception.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Thread.__init__() not called"</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"cannot join thread before it is started"</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g_main</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">shutdown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">""" Cleanup method called when thread is stopping.</span>

<span class="sd">        This method is run when the thread is stopped. Any resources</span>
<span class="sd">        used by the thread (sockets and such) should be safely closed</span>
<span class="sd">        here.</span>

<span class="sd">        You may override this method in a subclass.</span>
<span class="sd">        """</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">"Thread.__init__() was not called"</span>
        <span class="n">status</span> <span class="o">=</span> <span class="s2">"initial"</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s2">"started"</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s2">"stopped"</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ident</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">+=</span> <span class="s2">" </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ident</span>
        <span class="k">return</span> <span class="s2">"&lt;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&gt;"</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">"Thread.__init__() not called"</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span>

    <span class="nd">@name.setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">"Thread.__init__() not called"</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ident</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">"Thread.__init__() not called"</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ident</span>

    <span class="k">def</span> <span class="nf">isAlive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">"Thread.__init__() not called"</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span>

    <span class="n">is_alive</span> <span class="o">=</span> <span class="n">isAlive</span>

    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">setName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</pre></div>


<p>Why use greenlets when we can just implement timeouts and poll our stop flag, as above? Because it's possible to get a stoppable thread using one line of code, instead of implementing timeouts etc. Simple changing <code>class StoppableThread(threading.Thread):</code> to <code>class StoppableThread(betterthreads.Thread):</code> does the trick:</p>
<div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">betterthreads</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">time</span>


<span class="k">class</span> <span class="nc">StoppableThread</span><span class="p">(</span><span class="n">betterthreads</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">'127.0.0.1'</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">"Listening on {}:{}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">shutdown</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">"Shutting down cleanly..."</span><span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">StoppableThread</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">"Press &lt;Ctrl-C&gt; to stop thread"</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">(</span><span class="s2">"Keyboard interrupt - waiting for thread to finish..."</span><span class="p">)</span>
</pre></div>


<p>Output:</p>
<div class="highlight"><pre><span/><span class="go">Press &lt;Ctrl-C&gt; to stop thread</span>
<span class="go">Listening on 127.0.0.1:65309</span>
<span class="go">^C</span>
<span class="go">Keyboard interrupt - waiting for thread to finish...</span>
<span class="go">Shutting down cleanly...</span>

<span class="gp">$</span>
</pre></div>


<p><code>betterthreads.Thread</code> implements the same interface as <code>threading.Thread</code>, so it should be a drop-in replacement.</p>
  </article>

  </div></body></html>