<html><body><div><div class="content html_format"><p>
      Добрый день, уважаемые читатели.</p>
<p>
В сегодняшней статье я хотел бы, как можно подробнее, рассмотреть интеграцию приложений </p><strong>Python</strong><p> и </p><strong>MS Excel</strong><p>. Данные вопрос может возникнуть, например, при создании какой-либо системы онлайн отчетности, которая должна выгружать результаты в общепринятый формат ну или какие-либо другие задачи. Также в статье я покажу и обратную интеграцию, т.е. как использовать функцию написанную на python в Excel, что также может быть полезно для автоматизации отчетов.
</p><a name="habracut"/>
<h3>Работаем с файлами MS Excel на Python</h3><p>
Для работы с Excel файлами из Python мне известны 2 варианта:

</p><ol>
<li><a href="#lib">Использование библиотек, таких как xlrd, xlwt, xlutils или openpyxl</a></li>
<li><a href="#com">Работа с com-объектом</a></li>
</ol><p>
Рассмотрим работу с этими способами подробнее. В качестве примера будем использовать готовый файл excel из которого мы сначала считаем данные из первой ячейки, а затем запишем их во вторую. Таких простых примеров будет достаточно для первого ознакомления.

</p><a name="lib"/><h4>Использование библиотек</h4><p>
Итак, первый метод довольно простой и хорошо описан. Например, есть отличная </p><a href="http://habrahabr.ru/post/99923/">статья</a><p> для описания работы c </p><a href="http://www.python-excel.org">xlrd, xlwt, xlutils</a><p>. Поэтому в данном материале я приведу небольшой кусок кода с их использованием.
</p><p>
Для начала загрузим нужные библиотеки и откроем файл </p><em>xls</em><p> на чтение и выберем</p><p>
нужный лист с данными:

</p><pre><code class="python">import xlrd, xlwt
#открываем файл
rb = xlrd.open_workbook('../ArticleScripts/ExcelPython/xl.xls',formatting_info=True)

#выбираем активный лист
sheet = rb.sheet_by_index(0)
</code></pre><p>
Теперь давайте посмотрим, как считать значения из нужных ячеек:

</p><pre><code class="python">#получаем значение первой ячейки A1
val = sheet.row_values(0)[0]

#получаем список значений из всех записей
vals = [sheet.row_values(rownum) for rownum in range(sheet.nrows)]
</code></pre><p>
Как видно чтение данных не составляет труда. Теперь запишем их в другой файл. Для этого создам новый excel файл с новой рабочей книгой:

</p><pre><code class="python">wb = xlwt.Workbook()
ws = wb.add_sheet('Test')
</code></pre><p>
Запишем в новый файл полученные ранее данные и сохраним изменения:

</p><pre><code class="python">#в A1 записываем значение из ячейки A1 прошлого файла
ws.write(0, 0, val[0])

#в столбец B запишем нашу последовательность из столбца A исходного файла
i = 0
for rec in vals:
    ws.write(i,1,rec[0])
    i =+ i

#сохраняем рабочую книгу
wb.save('../ArticleScripts/ExcelPython/xl_rec.xls')
</code></pre><p>
Из примера выше видно, что библиотека </p><strong>xlrd</strong><p> отвечает за чтение данных, а </p><strong>xlwt</strong><p> — за запись, поэтому нет возможности внести изменения в уже созданную книгу без ее копирования в новую. Кроме этого указанные библиотеки работают только с файлами формата </p><em>xls</em><p> (Excel 2003) и у них нет поддержки нового формата </p><em>xlsx</em><p> (Excel 2007 и выше).
</p><p>
Чтобы успешно работать с форматом xlsx, понадобится библиотека </p><a href="https://pythonhosted.org/openpyxl/index.html">openpyxl</a><p>. Для демонстрации ее работы проделаем действия, которые были показаны для предыдущих библиотек.
</p><p>
Для начала загрузим библиотеку и выберем нужную книгу и рабочий лист:

</p><pre><code class="python">import openpyxl
wb = openpyxl.load_workbook(filename = '../ArticleScripts/ExcelPython/openpyxl.xlsx')
sheet = wb['test']
</code></pre><p>
Как видно из вышеприведенного листинга сделать это не сложно. Теперь посмотрим как можно считать данные:

</p><pre><code class="python">#считываем значение определенной ячейки
val = sheet['A1'].value

#считываем заданный диапазон
vals = [v[0].value for v in sheet.range('A1:A2')]
</code></pre><p>
Отличие от прошлых библиотек в том, что </p><em>openpyxl</em><p> дает возможность отображаться к ячейкам и последовательностям через их имена, что довольно удобно и понятно при чтении программы.
</p><p>
Теперь посмотрим как нам произвести запись и сохранить данные:

</p><pre><code class="python">#записываем значение в определенную ячейку
sheet['B1'] = val

#записываем последовательность
i = 0
for rec in vals:
    sheet.cell(row=i, column=2).value = rec
    i =+ 1

# сохраняем данные
wb.save('../ArticleScripts/ExcelPython/openpyxl.xlsx')
</code></pre><p>
Из примера видно, что запись, тоже производится довольно легко. Кроме того, в коде выше, можно заметить, что </p><em>openpyxl</em><p> кроме имен ячеек может работать и с их индексами.
</p><p>
К недостаткам данной библиотеки можно отнести, то что, как и в предыдущем примере, нет возможности сохранить изменения без создания новой книги.
</p><p>
Как было показано выше, для более менее полноценной работы с excel файлами, в данном случае, нужно 4 библиотеки, и это не всегда удобно. Кроме этого, возможно нужен будет доступ к VBA (допустим для какой-либо последующей обработки) и с помощью этих библиотек его не получить.
</p><p>
Однако, работа с этими библиотеками достаточно проста и удобна для быстрого создания Excel файлов их форматирования, но если Вам надо больше возможностей, то следующий подпункт для Вас.

</p><a name="com"/><h4>Работа с com-объектом</h4><p>
В своих отчетах я предпочитаю использовать второй способ, а именно использование файла Excel через com-объект с использованием библиотеки </p><strong>win32com</strong><p>. Его преимуществом, является то, что вы можете выполнять с файлом все операции, которые позволяет делать обычный Excel с использованием VBA.
</p><p>
Проиллюстрируем это на той же задаче, что и предыдущие примеры.
</p><p>
Для начала загрузим нужную библиотеку и создадим COM объект.

</p><pre><code class="python">import win32com.client
Excel = win32com.client.Dispatch("Excel.Application")
</code></pre><p>
Теперь мы можем работать с помощью объекта </p><em>Excel</em><p> мы можем получить доступ ко всем возможностям VBA. Давайте, для начала, откроем любую книгу и выберем активный лист. Это можно сделать так:

</p><pre><code class="python">wb = Excel.Workbooks.Open(u'D:\\Scripts\\DataScience\\ArticleScripts\\ExcelPython\\xl.xls')
sheet = wb.ActiveSheet
</code></pre><p>
Давайте получим значение первой ячейки и последовательности:

</p><pre><code class="python">#получаем значение первой ячейки
val = sheet.Cells(1,1).value

#получаем значения цепочки A1:A2
vals = [r[0].value for r in sheet.Range("A1:A2")]
</code></pre><p>
Как можно заметить, мы оперируем здесь функциями чистого VBA. Это очень удобно если у вас есть написанные макросы и вы хотите использовать их при работе с Python при минимальных затратах на переделку кода.
</p><p>
Посмотрим, как можно произвести запись полученных значений:

</p><pre><code class="python">#записываем значение в определенную ячейку
sheet.Cells(1,2).value = val

#записываем последовательность
i = 1
for rec in vals:
    sheet.Cells(i,3).value = rec
    i = i + 1

#сохраняем рабочую книгу
wb.Save()

#закрываем ее
wb.Close()

#закрываем COM объект
Excel.Quit()
</code></pre><p>
Из примера видно, что данные операции тоже довольно просто реализовываются. Кроме этого, можно заметить, что изменения мы сохранили в той же книге, которую открыли для чтения, что достаточно удобно.
</p><p>
Однако, внимательный читатель, обратит внимание на переменную </p><em>i</em><p>, которая инициализируется не 0, как принято python, а 1. Это связано с тем, что мы работаем с индексами ячеек как из VBA, а там нумерация начинается не с 0, а с 1.
</p><p>
На этом закончим разбор способов работы с excel файлами в python и перейдем к обратной задаче.

</p><h3>Вызываем функции Python из MS Excel</h3><p>
Может возникнуть такая ситуация, что у вас уже есть какой-либо функция, которая обрабатывает данные на python, и нужно перенести ее функциональность в Excel. Конечно же можно переписать ее на VBA, но зачем?
</p><p>
Для использования функций python в Excel есть прекрасная надстройка </p><a href="http://sourceforge.net/projects/excelpython/">ExcelPython</a><p>. С ее помощью вы сможете вызывать функции написанные на python прямо из Excel, правда придется еще написать небольшую обертку на VBA, и все это будет показано ниже.
</p><p>
Итак, предположим у нас есть функция, написанная на python, которой мы хотим воспользоваться:

</p><pre><code class="python">def get_unique(lists):
    sm = 0
    for i in lists:
        sm = sm + int(i.pop()) 
    return sm
</code></pre><p>
На вход ей подается список, состоящий из списков, это одно из условий, которое должно выполняться для работы данной функции в Excel.
</p><p>
Сохраним функцию в файле </p><em>plugin.py</em><p> и положим его в ту же директорию, где будет лежать наш excel файл, с которым мы будем работать.
</p><p>
Теперь установим </p><a href="http://sourceforge.net/projects/excelpython/">ExcelPython</a><p>. Установка происходит через запуск exe-файла и не вызывает затруднений.
</p><p>
Когда все приготовления выполнены, открываем тестовый файл excel и вызовем </p><em>редактор VBA</em><p> (Alt+F11). Для работы с вышеуказанной надстройкой необходимо ее подключить, через </p><em>Tools-&gt;References</em><p>, как показано на рисунке:

</p>
<p>
Ну что же, теперь можно приступить к написанию функции-обертки для нашего Python-модуля </p><em>plugin.py</em><p>. Выглядеть она будет следующим образом:

</p><pre><code class="vbscript">Function sr(lists As Range)
    On Error GoTo do_error
        Set plugin = PyModule("plugin", AddPath:=ThisWorkbook.Path)
        Set result = PyCall(plugin, "get_unique", PyTuple(lists.Value2))
        sr = WorksheetFunction.Transpose(PyVar(result))
        Exit Function
do_error:
        sr = Err.Description
End Function
</code></pre><p>
Итак, что же происходит в данной функции? 
</p><p>
Для начала, с помощью </p><strong><code>PyModule</code></strong><p>, мы подключаем нужный модуль. Для этого в качестве параметров ей передается имя модуля без расширения, и путь до папки в которой он находится. На выходе работы </p><strong><code>PyModule</code></strong><p> мы получаем объект для работы с модулем.
</p><p>
Затем, с помощью </p><strong><code>PyCall</code></strong><p>, вызываем нужную нам функцию из указанного модуля. В качестве параметров </p><strong><code>PyCall</code></strong><p> получает следующее:

</p><ol>
<li>Объект модуля, полученный на предыдущем шаге</li>
<li>Имя вызываемой функции</li>
<li>Параметры, передаваемые функции (передаются в виде списка)</li>
</ol><p>
Функция </p><strong><code>PyTuple</code></strong><p>, получает на вход какие-либо значения и преобразует их в объект tuple языка Python.</p><p>
Ну и, соответственно, </p><strong><code>PyVar</code></strong><p> выполняет операцию преобразования результата функции python, к типу понятному Excel.
</p><p>
Теперь, чтобы убедиться в работоспособности нашей связки, вызовем нашу свежеиспеченую функцию на листе в Excel:

</p>
<p>
Как видно из рисунка все отработало правильно.
</p><p>
Надо отметить, что в данном материале используется старая версия </p><em>ExcelPython</em><p>, и на </p><a href="https://github.com/ericremoreynolds/excelpython">GitHub'e</a><p> автора доступна новая версия.

</p><h3>Заключение</h3><p>
В качестве заключения, надо отметить, примеры в данной статье самые простые и для более глубоко изучения данных методов, я рекомендую обратиться к</p><p>
документации по нужным пакетам.
</p><p>
Также хочу заметить, что указанные пакеты не являются единственными и в статье опущено рассмотрение, таких пакетов как </p><a href="https://xlsxwriter.readthedocs.org/">xlsxwriter</a><p> для генерации excel файлов или </p><a href="http://xlwings.org/">xlwings</a><p>, который может работать с Excel файлами «на лету», а также же </p><a href="https://www.pyxll.com/index.html">PyXLL</a><p>, который выполняет аналогичные функции </p><em>ExcelPython</em><p>.
</p><p>
Кроме этого в статье я попытался несколько обобщить разборасанный по сети материал, т.к. такие вопросы часто фигурируют на форумах и думаю некоторым будет полезно иметь, такую «шпаргалку» под рукой.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>