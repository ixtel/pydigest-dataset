<html><body><div><div>
<div class="section" id="introduction">
<h2>Introduction</h2>
<p>Guido recently felt he needed to re-empathize that there will be no
Python 2.8. The Python developers have been very clear for years that
there will never be a Python 2.8.</p>
<p><a class="reference external" href="http://legacy.python.org/dev/peps/pep-0404/">http://legacy.python.org/dev/peps/pep-0404/</a></p>
<p>At the Python language summit there were calls for a Python 2.8. Guido
reports:</p>
<blockquote>
We (I) still don't want to do a 2.8 release, and I don't want to
accelerate 3.5, but I do think we should make things better for
people who have to straddle Python 2 and 3 in a single codebase, by
developing more tools, and by security and possibly installer
updates to 2.7 (PEP 466).</blockquote>
<p>At his keynote at PyCon, he said it again:</p>
<img alt="/guido_no.jpg" src="../guido_no.jpg"/>
<p>A very good thing happened to recognize the reality that Python 2.7 is
still massively popular: the end of life date for Python 2.7 was
<a class="reference external" href="http://hg.python.org/peps/rev/76d43e52d978?utm_content=buffer55d59&amp;utm_medium=social&amp;utm_source=facebook.com&amp;utm_campaign=buffer">changed</a> by Guido to 2020 (it was 2015). In the same change he felt he
should repeat there will be no Python 2.8:</p>
<pre class="literal-block">
+There will be no Python 2.8.
</pre>
<p>The call for Python 2.8 is strong. Even Guido feels it!</p>
<p>People talk about a Python 2.8, and are for it, or, like Guido,
against it, but rarely talk about what it should <em>be</em>. So let's
actually have that conversation.</p>
<p>Why talk about something that will never be? Because <strong>we can't call for
something, nor reject something if we don't know what it is</strong>.</p>
</div>
<div class="section" id="what-is-python-2-8-for">
<h2>What is Python 2.8 for?</h2>
<p>Python 2.8 could be different things. It could be a Python 2.x release
that reduces some pain points and adds features for Python 2
developers independent from what's going on in Python 3. It makes
sense, really: we haven't had a new Python 2 feature release since
2010 now. Those of us with existing large Python 2 codebases haven't
benefited from the work the language developers have done in those
years. Even polyglot libraries that support Python 2 and 3 both can't
use the new features, so are also stuck with a 2010 Python. Before
Python 2.7, the release cycle of Python has seen a new compatible
release every 2 years or less. The reality of Python for many of its
users is that there has been no feature update of the language for
years now.</p>
<p>But I don't want to talk about that. I want to talk about Python 2.8
as an incremental upgrade path to Python 3. If we are going to add
features to Python 2, let's take them from Python 3. I want to talk
about bringing Python 2.x closer to Python 3. Python 2 might never
quite reach Python 3 parity, but it could still help a lot if it can
get closer incrementally.</p>
</div>
<div class="section" id="why-an-incremental-upgrade">
<h2>Why an incremental upgrade?</h2>
<p>In the discussion about Python 3 there is a lot of discussion about
the need to port Python libraries to Python 3. This is indeed
important if you want the ability to start new projects on Python
3. But many of us in the trenches are working on large Python 2 code
bases. This isn't just maintenance. A large code base is alive, so
we're building <em>new</em> features in Python 2.</p>
<p>Such a large Python codebase is:</p>
<ul class="simple">
<li>Important to some organization. Important enough for people to
actually pay developers money to work on Python code.</li>
<li>Cannot be easily ported in a giant step to Python 3, even if all
external open source libraries are ported.</li>
<li>Porting would not see any functional gain, so the organization won't
see it as a worthwhile investment.</li>
<li>Porting would entail bugs and breakages, which is what the
organization would want to avoid.</li>
</ul>
<p>You can argue that I'm overstating the risks of porting. But we need
to face it: many codebases written in Python 2 have low automatic test
coverage. We don't like to talk about it because we think everybody
else is better at automated testing than we are, but it's the reality
in the field.</p>
<p>We could say, fine, they can stay on Python 2 forever then! Well, at
least until 2020. I think this would be unwise, as these organizations
are paying a lot of developers money to work on Python code. This has
an effect on the community as a whole.  It contributes to <a class="reference external" href="http://blog.startifact.com/posts/python-2-gravity.html">the gravity
of Python 2</a>.</p>
<p>Those organizations, and thus the wider Python community, would be
helped if there was an incremental way to upgrade their code bases to
Python 3, with easy steps to follow. I think we can do much more to
support such incremental upgrades than Python 2.7 offers right now.</p>
</div>
<div class="section" id="python-2-8-for-polyglot-developers">
<h2>Python 2.8 for polyglot developers</h2>
<p>Besides helping Python 2 code bases go further step by step, Python
2.8 can also help those of us who are maintaining polyglot libraries,
which work in both Python 2 and Python 3.</p>
<p>If a Python 2.8 backported Python 3 features, it means that polyglot
authors can start using those features if they drop Python 2.7 support
right there in their polyglot libraries, <em>without giving up Python 2
compatibility</em>. Python 2.8 would actually help <em>encourage</em> those on
Python 2.7 codebases to move towards Python 3, so they can use the
library upgrades.</p>
<p>Of course dropping Python 2.x support entirely for a polyglot library
will <em>also</em> make that possible. But I think it'll be feasible to drop
Python 2.7 support in favor of Python 2.8 much faster than it is
possible to drop Python 2 support entirely.</p>
</div>
<div class="section" id="but-what-do-we-want">
<h2>But what do we want?</h2>
<p>I've seen Python 3 developers say: but we've done all we could with
Python 2.7 already! What do you <em>want</em> from a Python 2.8?</p>
<p>And that's a great question. It's gone unanswered for far too long. We
should get a lot more concrete.</p>
<p>What follows are just ideas. I want to get them out there, so other
people can start thinking about them. I don't intend to implement any
of it myself; just blogging about it is already breaking my
stress-reducing policy of not worrying about Python 3.</p>
<p>Anyway, I might have it all wrong. But at least I'm trying.</p>
</div>
<div class="section" id="breaking-code">
<h2>Breaking code</h2>
<p>Here's a paradox: I think that in order to make an incremental upgrade
possible for Python 2.x we should actually break existing Python 2.x
code in Python 2.8! Some libraries will need minor adjustments to work
in Python 2.8.</p>
<p>I want to do what the <tt class="docutils literal">from __future__</tt> pattern was introduced for
in the first place: introduce a new incompatible feature in a release
but making it optional, and then later making the incompatible feature
the default.</p>
</div>
<div class="section" id="the-future-is-required">
<h2>The Future is Required</h2>
<p>Python 2.7 lets you do <tt class="docutils literal">from __future__ import something</tt> to get the
interpreter behave a bit more like Python 3. In Python 2.8, those should
be the default behavior.</p>
<p>In order to encourage this and make it really obvious, we may want to
consider <em>requiring</em> these in Python 2.8. That means that the
interpreter raises an error unless it has such a <tt class="docutils literal">from __future__</tt>
import there.</p>
<p>If we go for that, it means you <em>have</em> to have this on the top of all
your Python modules in Python 2.8:</p>
<ul class="simple">
<li><tt class="docutils literal">from __future__ import division</tt></li>
<li><tt class="docutils literal">from __future__ import absolute_import</tt></li>
<li><tt class="docutils literal">from __future__ import print_function</tt></li>
</ul>
<p><tt class="docutils literal">absolute_import</tt> appears to be uncontroversial, but I've seen
people complain about both <tt class="docutils literal">division</tt> and <tt class="docutils literal">print_function</tt>. If
people reject Python 3 for those reasons, I want to make clear I'm not
in the same camp. I believe that is confusing at most a minor
inconvenience with a dealbreaker. I think discussion about these is
pretty pointless, and I'm not going to engage in it.</p>
<p>I've left out <tt class="docutils literal">unicode_literals</tt>. This is because I've seen <em>both</em>
Nick Coghlan <em>and</em> Armin Ronacher <a class="reference external" href="https://github.com/PythonCharmers/python-future/issues/22">argue against them</a>. I have a
different proposal. More below.</p>
<p>What do we gain by this measure? It's ugly! Yes, but we've made the
upgrade path a lot more obvious. If an organisation wants to upgrade
to Python 2.8, they have to review their imports and divisions and
change their print statements to function calls. That should be doable
enough, even in large code bases, and is an upgrade path a developer
can do incrementally, maybe even without having to convince their
bosses first. Compare that to an upgrade to Python 3.</p>
</div>
<div class="section" id="from-future3-import-new-classes">
<h2><tt class="docutils literal">from __future3__ import new_classes</tt></h2>
<p>We can't do everything with the old future imports. We want to allow
<em>more</em> incremental upgrading. So let's introduce a new future import.</p>
<p>New-style classes, that is classes that derive from <tt class="docutils literal">object</tt>, were
introduced in Python 2 many years ago, but old-style classes are still
supported. Python 3 only has new-style classes. Python 2.8 can help
here by making new style classes the default. If you import <tt class="docutils literal">from
__future3__ import new_classes</tt> at the top of your module, any class
definition in that module that looks like this:</p>
<pre class="literal-block">
class Foo:
   pass
</pre>
<p>is interpreted as a new-style class.</p>
<p>This might break the contract of the module, as people may subclass
from this class and expect an old-style class, and in some (rare)
cases this can break code. But at least those problems can be dealt
with incrementally. And the upgrade path is really obvious.</p>
</div>
<div class="section" id="future3">
<h2>
<tt class="docutils literal">__future3__</tt>?</h2>
<p>Why did I write <tt class="docutils literal">__future3__</tt> and not <tt class="docutils literal">__future__</tt>?  Because
otherwise we can't write polyglot code that is compatible in Python 2
and Python 3.</p>
<p>Python 3.4 doesn't support <tt class="docutils literal">from __future__ import new_classes</tt>. We
don't want to wait for a Python 3.5 or Python 3.6 to support this,
even there is even any interest in supporting this among the Python
language developers at all. Because after all, there won't be a Python
2.8.</p>
<p>That problem doesn't exist for <tt class="docutils literal">__future3__</tt>. We can easily fake a
<tt class="docutils literal">__python3__</tt> module in Python 3 without being dependent on the
language developers. So polyglot code can safely use this.</p>
</div>
<div class="section" id="from-future3-import-explicit-literals">
<h2><tt class="docutils literal">from __future3__ import explicit_literals</tt></h2>
<p>Back to the magic moment of Nick Coghlan and Armin Ronacher agreeing.</p>
<p>Let's have a <tt class="docutils literal">from __future3__ import explicit_literals</tt>.</p>
<p>This forces the author to be entirely explicit with string literals in
the module that imports it. <tt class="docutils literal">"foo"</tt> and <tt class="docutils literal">'foo'</tt> are now errors;
the module won't import. Instead the module has to be explicit and use
<tt class="docutils literal">b'foo'</tt> and <tt class="docutils literal">u'foo'</tt> everywhere.</p>
<p>What does that get us? It forces a developer to think about string
literals everywhere, and that helps the codebase become incrementally
more compatible with Python 3.</p>
</div>
<div class="section" id="from-future3-import-str">
<h2><tt class="docutils literal">from __future3__ import str</tt></h2>
<p>This import line does two things:</p>
<ul class="simple">
<li>you get a <tt class="docutils literal">str</tt> function that creates a <em>Python 3 str</em>. This
string has unicode text in it and cannot be combined with Python 2
style bytes and Python 3 style bytes without error (which I'll
discuss later).</li>
<li>if <tt class="docutils literal">from __future__ import explicit_literals</tt> is in effect, a bare
literal now creates a Python 3 str. Or maybe <tt class="docutils literal">explicit_literals</tt>
is a prerequisite and <tt class="docutils literal">from __future3__ import str</tt> should error
if it isn't there.</li>
</ul>
<p>I took this idea from the <a class="reference external" href="http://python-future.org/">Python future</a> module, which makes Python
3 style str and bytes (and much more) available in Python 2.7. I've
modified the idea as I have the imaginary power to change the
interpreter in Python 2.8. Of course anything I got wrong is my own
fault, not the fault of Ed Schofield, the author of the <tt class="docutils literal">future</tt>
module.</p>
</div>
<div class="section" id="from-past-import-bytes">
<h2><tt class="docutils literal">from __past__ import bytes</tt></h2>
<p>To ensure you still have access to Python 2 <tt class="docutils literal">bytes</tt> (really <tt class="docutils literal">str</tt>)
just in case you still need it, we need an additional import:</p>
<pre class="literal-block">
from __past__ import bytes as oldbytes
</pre>
<p><tt class="docutils literal">oldbytes`</tt> can be called with Python 2 <tt class="docutils literal">str</tt>, Python 2 <tt class="docutils literal">bytes</tt>
and Python 3 <tt class="docutils literal">bytes</tt>. It rejects a Python 3 <tt class="docutils literal">str</tt>. I'll talk about
why it can be needed in a bit.</p>
<p>Yes, <tt class="docutils literal">__past__</tt> is another new namespace we can safely support in
Python 3. It would get more involved in Python 3: it contains a
forward port of the Python 2 bytes object. Python 3 bytes have less
features than Python 2 bytes, and this has been a pain point for some
developers who need to work with bytes a lot. Having a more capable
bytes object in Python 3 would not hurt existing Python 3 code, as
combining it with a Python 3 string would still result in an
error. It's just an alternative implementation of <tt class="docutils literal">bytes</tt> with more
methods on it.</p>
</div>
<div class="section" id="from-future3-import-bytes">
<h2><tt class="docutils literal">from __future3__ import bytes</tt></h2>
<p>This is the equivalent import for getting the Python 3 bytes object.</p>
</div>
<div class="section" id="combining-python-3-str-bytes-with-python-2-unicode-str">
<h2>Combining Python 3 str/bytes with Python 2 unicode/str</h2>
<p>So what happens when we somehow combine a Python 3 str/bytes with a
Python 2 str/bytes/unicode? Let's think about it.</p>
<p>The <tt class="docutils literal">future</tt> module by Ed Schofield forbids <tt class="docutils literal">py3bytes +
py2unicode</tt>, but supports other combinations and upcasts them to
their Python 3 version. So, for instance, <tt class="docutils literal">py3str + py2unicode <span class="pre">-&gt;</span>
py3str</tt>. This is a consequence of the way it tries to make Python 2
string literals work a bit like they're Python 3 unicode
literals. There is a big drawback to this approach; a Python 3 bytes
is not fully compatible with APIs that expect a Python 2 str, and a
library that tried to use this approach would suffer API breakage. See
<a class="reference external" href="https://github.com/PythonCharmers/python-future/issues/27">this issue</a> for more information on that.</p>
<p>I think since we have the magical power to change the interpreter, we
can do better. We can make real Python 3 string literals exist in
Python 2 using <tt class="docutils literal">__future3__</tt>.</p>
<p>I think we need these rules:</p>
<ul class="simple">
<li><tt class="docutils literal">py3str + py2unicode <span class="pre">-&gt;</span> py3str</tt></li>
<li><tt class="docutils literal">py3str + py2str: UnicodeError</tt></li>
<li><tt class="docutils literal">py3bytes + py2unicode: TypeError</tt></li>
<li><tt class="docutils literal">py3bytes + py2str: TypeError</tt></li>
</ul>
<p>So while we upcast existing Python 2 unicode strings to Python 3 str
we refuse any other combination.</p>
<p>Why not let people combine Python 2 str/bytes with Python 3 bytes?
Because the Python 3 <tt class="docutils literal">bytes</tt> object is not compatible with the
Python 2 <tt class="docutils literal">bytes</tt> object, and we should refuse to guess and
immediately bail out when someone tries to mix the two. We require an
explicit Python 2 <tt class="docutils literal">str</tt> call to convert a Python 3 bytes to a
<tt class="docutils literal">str</tt>.</p>
<p>This is assuming that the Python 3 <tt class="docutils literal">str</tt> is compatible with Python 2
<tt class="docutils literal">unicode</tt>. I think we should aim for making a Python 3 string behave
like a subclass of a Python 2 <tt class="docutils literal">unicode</tt>.</p>
</div>
<div class="section" id="what-have-we-gained">
<h2>What have we gained?</h2>
<p>We can now start using Python 3 <tt class="docutils literal">str</tt> and Python 3 <tt class="docutils literal">bytes</tt> in
our Python 2 codebases, incrementally upgrading, module by module.</p>
<p>Libraries could upgrade their internals to use Python 3 str and bytes
entirely, and start using Python 3 str objects in any public API that
returns Python 2 unicode strings now. If you're wrong and the users of
your API actually do expect str-as-bytes instead of unicode strings,
you can go deal with these issues one by one, in an incremental
fashion.</p>
<p>For compatibility you can't return Python 3 bytes where Python 2
str-as-bytes is used, so judicious use of <tt class="docutils literal">__past__.str</tt> would be
needed at the boundaries in these cases.</p>
</div>
<div class="section" id="after-python-2-8">
<h2>After Python 2.8</h2>
<p>People who have ported their code to Python 2.8 and have turned on all
the <tt class="docutils literal">__future3__</tt> imports incrementally will be in a better place to
port their code to Python 3. But to offer a more incremental step, we
can have a Python 2.9 that requires the <tt class="docutils literal">__future3__</tt> imports
introduced by Python 2.8. And by then we might have thought of some
other ways to smoothen the upgrade path.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li>There will be no Python 2.8. There will be no Python 2.8! Really,
there will be no Python 2.8.</li>
<li>Large code bases in Python need incremental upgrades.</li>
<li>The upgrade from Python 2 to Python 3 is not incremental enough.</li>
<li>A Python 2.8 could help smoothen the way.</li>
<li>A Python 2.8 could help polyglot libraries.</li>
<li>A Python 2.8 could let us drop support for Python 2.7 with an
obvious upgrade path in place that brings everybody closer to Python
3.</li>
<li>The old <tt class="docutils literal">__future__</tt> imports are mandatory in Python 2.8 (except
<tt class="docutils literal">unicode_literals</tt>).</li>
<li>We introduce a new <tt class="docutils literal">__future3__</tt> in Python 2.8. <tt class="docutils literal">__future3__</tt>
because we can support it in Python 3 today.</li>
<li>We introduce <tt class="docutils literal">from __future3__ import new_classes</tt>, mandating new style
objects for plain class statements.</li>
<li>We introduce <tt class="docutils literal">from __future3__ import explicit_literals, str, bytes</tt> to
support a migration to use Python 3 style str and bytes.</li>
<li>We introduce <tt class="docutils literal">from __past__ import bytes</tt> to be able to access the
old-style bytes object.</li>
<li>A forward port of the Python 2 bytes object to Python 3 would be
useful. It would error if combined with a Python 3 str, just like
the Python 3 bytes does.</li>
<li>A future Python 2.9 could introduce more incremental upgrade steps. But
there will be no Python 2.9.</li>
<li>I'm not going to do the work, but at least now we have something to
talk about.</li>
</ul>
</div>
</div>
    </div></body></html>