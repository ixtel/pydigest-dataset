<html><body><div><div class="section">
              <h1>wcon 0.3.1</h1>

              


<p>Worm tracker Commons Object Notation</p><p>








See https://github.com/openworm/tracker-commons</p><p># Python implementation of Tracker Commons</p><p>This project contains source code in Python that implements the WCON data format for tracking data.</p><p>*When the Python specification and the behavior of the Scala implementation differ, and it is not obvious which one is correct, the behavior of the Scala implementation should be presumed to be authoritative.*</p><p>### Installation</p><p>`wcon` is [registered with the Python Package Index](https://pypi.python.org/pypi/wcon/) so just enter this command from any shell:</p><p>```</p><p>pip install wcon</p><p>```</p><p>Any problems?  Visit the more detailed [installation guide](INSTALL.md).</p><p>### Usage</p><p>```</p><p>import wcon</p><p># Open a worm file, convert it to canonical form, and save it</p><p># (actually it's automatically converted to canon before </p><p>#  saving, but here we do so explicitly)</p><p>w = wcon.WCONWorms.load_from_file('tests/minimax.wcon')</p><p>canon_w = w.to_canon</p><p>canon_w.save_to_file('test.wcon', pretty_print=True)</p><p># From a string literal:</p><p>from io import StringIO</p><p>w2 = WCONWorms.load(StringIO('{"units":{"t":"s","x":"mm","y":"mm"}, '</p><p>                              '"data":[]}'))</p><p># WCONWorms.load_from_file accepts any valid WCON, but .save_to_file </p><p># output is always "canonical" WCON, which makes specific choices about </p><p># how to arrange and format the WCON file.  This way the functional </p><p># equality of any two WCON files can be tested by this:</p><p>w1 = WCONWorms.load_from_file('file1.wcon')</p><p>w2 = WCONWorms.load_from_file('file2.wcon')</p><p>assert(w1 == w2)</p><p># or:</p><p>w1.save_to_file('file1.wcon')</p><p>w2.save_to_file('file2.wcon')</p><p>import filecmp</p><p>assert(filecmp.cmp('file1.wcon', file2.wcon'))</p><p>w3 = w1 + w2  # Merge the two.  An exception is raised if the data clashes</p><p>```</p><p>### `WCONWorms` class: Attributes</p><p>- `units`: dict</p><p>    - May be empty, but is never None since 'units' is required </p><p>    to be specified.</p><p>- `metadata`: dict</p><p>    - If 'metadata' was not specified, metadata is None.</p><p>    - The values in this dict might be nested into further dicts or other</p><p>    data types.</p><p>- `data`: Pandas DataFrame or None</p><p>    - If 'data' was not specified, data is None.</p><p>- [Note: `files`, if present in the input, is not persisted unless the `.load`</p><p>       factory method is used.]</p><p>### `WCONWorms` class: Public-Facing Methods</p><p>- `load_from_file`   (JSON_path)                [class method]</p><p>- `save_to_file`     (JSON_path, pretty_print)</p><p>- `to_canon`                                    [property]</p><p>- `__add__`                                     [use `+`]</p><p>- `__eq__`                                      [use `==`]</p><p>### Custom WCON objects</p><p>Any top-level key other than the basic:</p><p>- files</p><p>- units</p><p>- metadata</p><p>- data</p><p>...are ignored.  It is convenient, but not required, to follow the convention of beginning custom fields with the prefix `"@"`.  Handling custom objects requires subclassing `WCONWorms`.</p><p>### WCON parser: proof of concept</p><p>Thanks to the Python libraries `json` and `jsonschema`, it is relatively trivial to parse and validate a WCON file.  Here's an example of how one might accomplish this, without even using the `wcon` package:</p><p>    import json, jsonschema    </p><p>    # The WCON schema</p><p>    with open("wcon/wcon_schema.json", "r") as wcon_schema_file:</p><p>    	schema = json.loads(wcon_schema_file.read())    </p><p>    # Our example WCON file</p><p>    JSON_path = '../../tests/minimax.wcon'</p><p>    with open(JSON_path, 'r') as infile:</p><p>    	serialized_data = infile.read()    </p><p>    # Load the whole JSON file into a nested dict.</p><p>    w = json.loads(serialized_data)    </p><p>    # Validate the raw file against the WCON schema</p><p>    jsonschema.validate(w, schema)</p><p>With the above code we end up with a nested dictionary `w` containing everything that was serialized in the `minimax.wcon` file.</p><p>### The `wcon` Python package</p><p>Using this `wcon` Python package, something similar can be accomplished:</p><p>    import wcon</p><p>    w = wcon.WCONWorms.load_from_file('../../tests/minimax.wcon')</p><p>Here, instead of being a nested dictionary, `w` is a `WCONWorms` object that is more powerful.  Here are some of the additional things that can be accomplished with the `WCONWorms` object:</p><p>- The WCON file is validated not just against the WCON schema, but also to ensure units are valid, that every data key has a corresponding unit, and that every data segment has "aspects" of the same length.  (e.g. if a skeleton at time `1.3` has 45 `x`-coordinates, it should also have 45 `y`-coordinates.  This condition is not expressible in a JSON schema but it is validated programatically by the WCONWorms initializer.</p><p>- Units are expressed as `MeasurementUnit` objects, which can be compared with other such objects, to verify that "mm" and "millimetres" refer to the same units, for instance.  (see the below section for more details)</p><p>- WCONWorms objects can have their data be converted into canonical units, and then saved again.</p><p>- WCONWorms objects can be loaded from multiple files and combined together, via the `"files"` object.</p><p>- Worm data recorded in multiple "tracks", or elements, in the `"data"` object, can have such tracks merged.</p><p>- Worm data can be extracted in a Pandas DataFrame format for easier downstream processing, since the dimensions of the data have been placed into one two-dimensional array, rather than in a nested array.</p><p>- WCONWorms can be subclassed by labs implementing "special features", in two places: ("type 1") top-level objects starting with `"@"` or ("type 2") objects within individual `"data"` array items starting with `"@"`.</p><p>### MeasurementUnit</p><p>The WCON format requires a `"units"` object, where you specify in what units your quantities are being measured.  `WCONParser` represents these units internally as `MeasurementUnit` objects. With `MeasurementUnit`, you can convert from any supported unit expression to the canonical one: </p><p>    &gt;&gt;&gt; MeasurementUnit.create('m')</p><p>    MeasurementUnit, original form: 'm' canonical form: 'mm'</p><p>    &gt;&gt;&gt; u = MeasurementUnit.create('m')</p><p>    &gt;&gt;&gt; u.to_canon(1)</p><p>    1000.0</p><p>    &gt;&gt;&gt; u.from_canon(100)</p><p>    0.1</p><p>    &gt;&gt;&gt; u = MeasurementUnit.create('F')</p><p>    &gt;&gt;&gt; u.to_canon(72)</p><p>    22.222222222222221</p><p>    &gt;&gt;&gt; u = MeasurementUnit.create('m/min')</p><p>    &gt;&gt;&gt; u.canonical_unit_string</p><p>    'mm/s'</p><p>    &gt;&gt;&gt; u.to_canon(5)</p><p>    83.33333333333334</p><p>    &gt;&gt;&gt; u = MeasurementUnit.create('m^2')</p><p>    &gt;&gt;&gt; u.to_canon(1)</p><p>    1000000.0    </p><p>You can also check the equality of various unit expressions.  For example, all of these expressions will evaluate to `True`:</p><p>    MeasurementUnit.create('mm') == MeasurementUnit.create('millimetre')</p><p>    MeasurementUnit.create('Mm') == MeasurementUnit.create('megametre')</p><p>    MeasurementUnit.create('mm') != MeasurementUnit.create('Mm')

</p><a name="downloads">Â </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>122</span> downloads in the last week
  </li>
  <li>
    <span>1419</span> downloads in the last month
  </li>
</ul>









            </div>


          </div></body></html>