<html><body><div><article class="markdown-body entry-content" itemprop="text"><h2><a id="user-content-installation" class="anchor" href="#installation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Installation</h2>

<pre><code>cabal update &amp;&amp; cabal install pyfi
</code></pre>

<h2><a id="user-content-purpose" class="anchor" href="#purpose" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Purpose</h2>

<p>Pyfi (PYthon Function Interface) lets you call python from haskell without writing C API code. Just define any python function inline, tell haskell the type signature, and let pyfi figure out the rest. The library uses json serialization for basic types and pointers for references to more complex python objects. It's great for either wrapping your existing python projects with haskell or using a python library from a haskell script. At this time, Pyfi only supports single threaded haskell applications.</p>

<h2><a id="user-content-tutorial" class="anchor" href="#tutorial" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Tutorial</h2>

<p>First, let's see an example</p>

<pre><code>-- Square.hs
import Python

square :: Int -&gt; IO Int
square = defVV "export = lambda x: x * x"

main = do
  x &lt;- square 7
  print x
</code></pre>

<p/><p/><p/>

<pre><code>$ runhaskell Square.hs
49
</code></pre>

<p>The <code>defVV</code> function above has type <code>(ToJSON a, FromJSON b) =&gt; String -&gt; (a -&gt; IO b)</code>. The type signature for <code>square</code> further constrains <code>a</code> to be of type <code>Int</code>, and <code>b</code> to be of type <code>Int</code> as well. <code>defVV</code> takes a string of python code defining a function with the name <code>export</code>, and returns a high level interface to that function that can be called from haskell. We could have just as well written:</p>

<pre><code>  square :: Int -&gt; IO Int
  square = defVV "def export(x): return x * x"
</code></pre>

<p>or </p>

<pre><code>  square :: Int -&gt; IO Int
  square = defVV "from numpy import square as export"
</code></pre>

<p>What's imporant is that the python code defines a function <code>export</code> of type <code>Int -&gt; IO Int</code>. If the python returns a value that cannot be interpreted as an <code>Int</code>, pyfi will raise a haskell exception. Any exceptions raised by pyfi can be handled with <code>Control.Exception.catch</code>. Of course, we could have also defined a function of type <code>String -&gt; IO String</code>:</p>

<pre><code>  guess_type :: String -&gt; IO String
  guess_type = defVV "from mimetypes import guess_type; export = lambda x: guess_type(x)[0]"
</code></pre>

<p>or a function of type <code>Float -&gt; Float -&gt; IO Float</code>:</p>

<pre><code>  sin_product :: Float -&gt; Float -&gt; IO Float
  sin_product = defVVV "def export(x, y): from math import sin; return sin(x*y)
</code></pre>

<p>Where <code>defVVV</code> is used to denote that the python function will take two arguments by Value and return a Value. But while <code>defVV</code> and <code>defVVV</code> let us easily wrap python functions, they come at a cost. Any variables that are passed to and from the python function must be serialized into a json string and then deserialized. At some level, this cost is inevitable. Using haskell data in python is going to require instantiating python objects, which will require replicating memory. But if one is passing the same data into python again and again, it shouldn't be necessary to repeatedly serialize. Also, not every python data structure will implement json encoding and decoding. That's why pyfi supports passing around direct references to python objects:</p>

<pre><code>{-# LANGUAGE QuasiQuotes #-}
-- ShortestPaths.hs

import Python

data Graph

getGraph :: [(Int, Int)] -&gt; IO (PyObject Graph)
getGraph = defVO [str|
import networkx
def export(xs):
    g = networkx.Graph()
    for edge in xs:
        g.add_edge(edge[0], edge[1])
    return g
|]

shortestPath :: (Int, Int) -&gt; PyObject Graph -&gt; IO Int
shortestPath = defVOV [str|
import networkx
def export(x, g):
    return int(networkx.shortest_path_length(g, x[0], x[1]))
|] 

main = do
  g &lt;- getGraph [(1,2),(2,3),(3,4)]
  distance &lt;- shortestPath (1,4) g
  print distance
</code></pre>

<p/><p/><p/>

<pre><code>$ runhaskell ShortestPaths.hs
3
</code></pre>

<p>Notice the function <code>defVO</code> above returns a graph object from the networkx library. It would be quite tricky to make sure that a json serialization of this object encoded all the necessary properties, but we don't have to. We just store a reference to that object. We may not be able to manipulate the object directly in haskell, but we <i>can</i> pass it to other functions wrapped with pyfi, such as the <code>shortestPath</code> function defined above. Even better, the object passing in pyfi is implemented with Foreign Pointers, so when <code>g</code> has no remaining references, it will decrement the python reference count to the object, causing it to be garbage collected in python. Even though pyfi manipulates python with the C API, you don't have to do any manual memory management. In fact, pyfi should never cause a SegFault (if it does, please report it as a bug).</p>

<p>By now, you may have noticed a pattern in the naming convention of the <code>def</code> functions. There is one letter for each of the arguments and for the return type. A <code>V</code> indicates that the type will be passed as a json value. An <code>O</code> indicates that the type will be passed as a pointer to a python object. You can use any combination of <code>O</code> and <code>V</code> describing python functions with up to three arguments. So <code>defV</code>, <code>defVOOV</code>, and <code>defOOVV</code> are all available to you after you write <code>import Python</code>.</p>

<p>The technology for catching python exceptions and bubbling them up into haskell exceptions isn't finalized, and it hasn't been tested for thread safety with concurrent IO. Nonetheless, I'm really excited to see what people can do with it.</p>
</article>
  </div></body></html>