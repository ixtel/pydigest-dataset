<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/getpro/habr/post_images/2ad/b8a/842/2adb8a842154aa2a830c8e69f988a07b.png" alt="image" align="left"/><p>Практически любое веб-приложение предоставляет возможность авторизации пользователя с использованием учетной записи пользователя, в каком либо из известных социальных сервисов.
</p><p>
Магия авторизации происходит строго по протоколу OAuth 1.0а и OAuth 2.0 и значительно упрощает жизнь и владельцу веб-приложения и самому пользователю.
</p><p>
Остается сущая мелочь, реализовать нужный протокол применительно к конкретному веб-приложению. Регистрация и вход в веб сервис </p><a href="http://www.theonlypage.com/">TheOnlyPage</a><p> с использованием учетных записей </p><b>Facebook</b><p>, </p><b>Google</b><p>, </p><b>LinkedIn</b><p> и </p><b>Microsoft Live</b><p> работают благодаря python библиотеке </p><a href="http://peterhudec.github.io/authomatic/">Authomatic</a><p>.
</p><p>
Согласно документации </p><b>Authomatic</b><p> обладает следующими замечательными особенностями:
</p><a name="habracut"/>
<ul>
<li>Слабая связанность.</li>
<li>Компактный, но мощный интерфейс</li>
<li>Единственная, причем необязательная зависимость: библиотека <a href="https://pypi.python.org/pypi/python-openid/">python-openid</a></li>
<li>CSRF защита</li>
<li>Благодаря адаптерам нет привязки к конкретному фреймворку. Сразу из коробки поддерживается <b>Django</b>, <b>Flask</b> и <b>Webapp2</b>.</li>
<li>Возможность включать новые появляющиеся протоколы авторизации и аутентификации</li>
<li>Запросы к программному интерфейсу (API) провайдера — проще некуда.</li>
<li> Поддержка асинхронных запросов</li>
<li>В качестве бонуса javascript-библиотека</li>
<li>Сразу из коробки поддержка:<br/>
<ul>
<li><b>OAuth 1.0a</b> провайдеров: Bitbucket, Flickr, Meetup, Plurk, Twitter, Tumblr, UbuntuOne,Vimeo, Xero, Xing and Yahoo</li>
<li><b>OAuth 2.0</b> провайдеров: Behance, Bitly, Cosm, DeviantART, Facebook, Foursquare,GitHub, Google, LinkedIn, PayPal, Reddit, Viadeo, VK, WindowsLive, Yammer и Yandex.</li>
<li><b>python-openid</b> и <b>OpenID</b> основанного на Google App Engine</li>
</ul></li>
</ul><p>
Вдобавок ко всему отмечается, что библиотека находится на </p><b>очень раннем этапе создания</b><p>, и практически </p><b>не протестирована</b><p>.
</p><p>
Несмотря на такое самокритичное заявление, если обратиться к </p><a href="http://authomatic-example.appspot.com/">демонстрационной страничке</a><p>, можно убедиться что библиотека обеспечивает беспроблемную работу со всевозможными провайдерами </p><b>OAuth 1.0a</b><p> и </p><b>OAuth 2.0</b><p>.
</p><p>
Качественная </p><a href="http://peterhudec.github.io/authomatic/examples/index.html">документация</a><p> даёт достаточно информации для использования библиотеки совместно с фреймворками: </p><b>Django</b><p>, </p><b>Flask</b><p>, </p><b>Pyramid</b><p> и </p><b>Webapp2</b><p>.
</p><p>
Проиллюстрируем работу с </p><b>Authomatic</b><p> на примере из реальной жизни. Для того чтобы зарегистрироваться / войти в веб-сервис </p><a href="http://www.theonlypage.com/">TheOnlyPage</a><p> посредством учетной записи </p><b>Facebook</b><p>, </p><b>Google</b><p>, </p><b>LinkedIn</b><p> и </p><b>Microsoft Live</b><p> достаточно кликнуть по соответствующей кнопке, на странице входа в сервис:

</p>
<p>
Процесс авторизации реализован при помощи библиотеки </p><b>Authomatic</b><p>. При этом </p><a href="http://www.theonlypage.com/">TheOnlyPage</a><p> работает на фреймворке </p><a href="http://flask.pocoo.org/">Flask</a><p>. Для того чтобы задействовать библиотеку </p><b>Authomatic</b><p> в связке с фреймворком </p><b>Flask</b><p>, при условии что библиотека уже присутствует в рабочем пространстве, нужно: 

</p><ol>
<li>Зарегистрировать свое приложение в каждом из OAuth-провайдеров.</li>
<li>Добавить параметры OAuth-провайдеров в конфигурационный файл.</li>
<li>Инициировать базовый объект <code>authomatic</code> параметрами, хранящимися в конфигурационном файле.</li>
<li>Создать представление, которое выполнит запрос к провайдеру и получит от него результат.</li>
</ol><p>
Проделаем эти 4 нехитрых шага:

</p><h2>Регистрация приложения</h2><p>
У каждого провайдера свои особенности регистрации. Адреса регистрации приложения 
</p><p>
для Facebook: </p><a href="https://developers.facebook.com/apps">developers.facebook.com/apps</a>
<p>
для Google: </p><a href="https://console.developers.google.com/project">console.developers.google.com/project</a>
<p>
для LinkedIn: </p><a href="https://www.linkedin.com/secure/developer">www.linkedin.com/secure/developer</a>
<p>
для Microsoft Live: </p><a href="https://account.live.com/developers/applications/create">account.live.com/developers/applications/create</a>
<p>
Некоторые параметры, которые потребуется указать, у разных провайдеров могут отличаться, но среди остальных параметров обязательно присутствуют:

</p><ol>
<li>адреса нашего сервиса, с которых разрешен редирект с запросом к <i>провайдеру</i></li>
<li>адрес, по которому <i>провайдер</i> возвращает пользователя к нашему сервису после предоставления доступа </li>
<li>адрес, по которому <i>провайдер</i> возвращает пользователя к нашему сервису при отказе в предоставлении доступа</li>
</ol><p>
В случае использования библиотеки </p><b>Authomatic</b><p> в 1-м и 2-м случае удобно указать один и тот же адрес, так для соответствующих провайдеров будем использовать адреса:

</p><a href="http://www.theonlypage.com/login/facebook">www.theonlypage.com/login/facebook</a> 

<a href="http://www.theonlypage.com/login/google">www.theonlypage.com/login/google</a> 

<a href="http://www.theonlypage.com/login/linkedin">www.theonlypage.com/login/linkedin</a>

<a href="http://www.theonlypage.com/login/microsoft">www.theonlypage.com/login/microsoft</a> 
<p>
Также на страничке регистрации приложения у провайдера, нам надо получить </p><b>код пользователя</b><p> и </p><b>секретный ключ</b><p>, в терминах различных провайдеров они соответственно называются:
</p><table>
<tr>
<th> </th>
<th>код пользователя</th>
<th>секретный ключ</th>
</tr>
<tr>
<td>Facebook</td>
<td>App ID</td>
<td>App Secret</td>
</tr>
<tr>
<td>Google</td>
<td>Client ID</td>
<td>Client secret</td>
</tr>
<tr>
<td>LinkedIn</td>
<td>API Key</td>
<td>Secret Key</td>
</tr>
<tr>
<td>Microsoft Live</td>
<td>Client ID</td>
<td>Client secret</td>
</tr>
</table><p>
Кроме того, в разделе регистрации приложения у провайдера, мы должны выяснить под каким названием фигурируют нужные нам данные. Например, </p><i>адрес электронной почты</i><p> пользователя обозначается:
</p><p>
для Facebook: </p><b>email</b>
<p>
для Google: </p><b>email</b>
<p>
для LinkedIn: </p><b>r_emailaddress</b>
<p>
для Microsoft Live: </p><b>wl.emails</b>
<p>
После того как приложение зарегистрировано во всех провайдерах, </p><b>адреса редиректа</b><p> указаны, </p><b>код пользователя</b><p> и </p><b>секретный ключ</b><p> получены, есть ясность как именуются данные применительно к каждому провайдеру, можно переходить к настройке конфигурационного файла.

</p><h2>Определение конфигурации OAuth провайдеров</h2><p>
В стандартный конфигурационный файл flask-приложения нужно добавить словарь содержащий параметры всех провайдеров:

</p><pre><code class="python">OAUTH_CONFIG = {
  'facebook': {          
    'class_': oauth2.Facebook,
    'consumer_key': 123456789012345',
    'consumer_secret': ' edcba987654321012345679abcdedcab',
    'scope': ['email',],
  },
    'google': {
    'class_': oauth2.Google,
    'consumer_key': '123456789098.apps.googleusercontent.com',
    'consumer_secret': ' ABcDEFgiJKLmNOPQRStUVWxyz ',
    'scope': ['email',],
  },
  'linkedin': {
    'class_': oauth2.LinkedIn,
    'consumer_key': ' ABC123df45GIJ6h ',
    'consumer_secret': ‘zyx987vutSRQponM ',
    'scope': ['r_emailaddress',],
  },
    'microsoft': {        
    'class_': oauth2.WindowsLive,
    'consumer_key': '0000000012345A67',
    'consumer_secret': ' ABcDe123fgHIJK45LmnO6789PQrS0tUVXyz ',
    'scope': ['wl.emails',],
  },
}
</code></pre><p>
Как видим каждому провайдеру ставится в соответствие словарь со следующими атрибутами:

</p><code>class_</code><p> — входящий в состав библиотеки Authomatic класс, соответствующий очередному провайдеру;

</p><code>consumer_key</code><p> — код пользователя у очередного провайдера; 

</p><code>consumer_secret</code><p> — секретный ключ очередного провайдера;

</p><code>scope</code><p> — список данных, которые предполагается запрашивать у очередного провайдера.
</p><p>
Предварительные установки сделаны.

</p><h2>Инициация базового объекта authomatic</h2><p>
Происходит очень просто, с указаним конфигурационных данных и секретной строки:

</p><pre><code class="python">from authomatic import Authomatic
from config import OAUTH_CONFIG 
authomatic = Authomatic(OAUTH_CONFIG, ‘very secret string', report_errors=False)
</code></pre>
<h2>Создание представления</h2><p>
Осталось создать представление, которое:
</p><ul>
<li>соответствует интернет адресу с которого осуществляется редирект запроса данных к провайдеру и получение данных от провайдера;</li>
<li>осуществляет получение электронного адреса пользователя от oauth-провайдера;</li>
<li>и, если этот пользователь зарегистрирован в системе – открывает ему доступ.</li>
</ul>
<pre><code class="python">import re
from authomatic.adapters import WerkzeugAdapter

from flask import redirect, make_response
from flask.ext.login import login_user

from models import User
from app import app

EMAIL_REGEX = re.compile(r'[^@]+@[^@]+\.[^@]+')

@app.route('/login/&lt;provider_name&gt;')
def login(provider_name):
      
  # для работый с адаптером WerkzeugAdapter понадобится объект response
  response = make_response()

  try:
  # перехватываем ошибки которые могут возникнуть при работе с oauth2 провайдером

    # если result = None значит процедура логина находится в процессе выполнения
    result = authomatic.login( WerkzeugAdapter( request, response ), provider_name )

    if result:
    # если получен результат oauth-логина

      if result.user:
      # и если имеется информация о пользователе 

        # получаем информацию о пользователе
        result.user.update()
        # получаем email
        email = result.user.email
		
        if email and EMAIL_REGEX.match(email):
        # если указан правильный адрес
					
          # находим соответствующего пользователя
          user = User.query.filter_by( email = email ).first()

          if user:
          # если пользователь зарегистрирован с системе

            # осуществляем вход в систему
            login_user( user )
            # делаем редирект на главную страницу сервиса
            return redirect( url_for( 'index' ) )

# здесь отрабатываем все варианты отказа в регистрации
# ...
# ...

    else:
    # если результат oauth-логина еще не получен (result=None)
    # возвращаем объект response
     return response

</code></pre><p>
Основаня часть взаимодействия с oauth-провайдером сводится к одной строке:

</p><pre><code class="python">result = authomatic.login( WerkzeugAdapter( request, response ), provider_name )
</code></pre><p>
при первоначальном заходе на адресу: </p><code>authomatic.login</code><p> осуществляет редирект на указанного провайдера и передачу необходимых параметров;
</p><p>
затем провайдер делает обратный редирект по тому же адресу и </p><code>authomatic.login</code><p> получает от провайдера требуемые данные.
</p><p>
Как видите совсем несложно. Основную часть времени занимает не программирование, а регистрация своего приложения в каждом из используемых провайдеров.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>