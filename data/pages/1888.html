<html><body><div><div class="content_body" data-subscribe="true" data-view="content#body"><p><a href="https://www.toptal.com/python">Python</a> is amazing.</p>

<p>Surprisingly, that’s a fairly ambiguous statement. What do I mean by ‘Python’? Do I mean Python the abstract <em>interface</em>? Do I mean CPython, the common Python <em>implementation</em> (and not to be confused with the similarly named Cython)? Or do I mean something else entirely? Maybe I’m obliquely referring to Jython, or IronPython, or PyPy. Or maybe I’ve really gone off the deep end and I’m talking about RPython or RubyPython (which are very, very different things).</p>

<p>While the technologies mentioned above are commonly-named and commonly-referenced, some of them serve completely different purposes (or, at least, operate in completely different ways).</p>

<p>Throughout my time working with the Python interfaces, I’ve run across tons of these .*ython tools. But not until recently did I take the time to understand what they are, how they work, and why they’re necessary (in their own ways).</p>

<p>In this tutorial, I’ll start from scratch and move through the various Python implementations, concluding with a thorough introduction to PyPy, which I believe is the future of the language.</p>

<p>It all starts with an understanding of what ‘Python’ actually is.</p>

<p><em>If you have a good understanding for machine code, virtual machines, and the like, feel free to <a href="#PyPy">skip ahead</a>.</em></p>

<h2 id="is-python-interpreted-or-compiled">“Is Python interpreted or compiled?”</h2>

<p>This is a common point of <a href="https://www.toptal.com/python/top-10-mistakes-that-python-programmers-make">confusion for Python beginners</a>.</p>

<p>The first thing to realize when making a comparison is that ‘Python’ is an <em>interface</em>. There’s a <a href="http://docs.python.org/2/reference/index.html">specification</a> of what Python <em>should</em> do and how it <em>should</em> behave (as with any interface). And there are multiple <em>implementations</em> (as with any interface).</p>

<p>The second thing to realize is that ‘interpreted’ and ‘compiled’ are properties of an <em>implementation</em>, not an <em>interface</em>.</p>

<p>So the question itself isn’t really well-formed.</p>

<p class="pop_out_box is-full_width is-big">
Is Python interpreted or compiled? The question isn't really well-formed.
</p>

<p>That said, for the most common Python implementation (CPython: written in C, often referred to as simply ‘Python’, and surely what you’re using if you have no idea what I’m talking about), the answer is: <strong>interpreted</strong>, with <em>some</em> compilation. CPython <em>compiles</em>* Python source code to bytecode, and then <em>interprets</em> this bytecode, executing it as it goes.</p>

<p>* <em>Note: this isn’t ‘compilation’ in the traditional sense of the word. Typically, we’d say that ‘compilation’ is taking a high-level language and converting it to machine code. But it is a ‘compilation’ of sorts.</em></p>

<p>Let’s look at that answer more closely, as it will help us understand some of the concepts that come up later in the post.</p>

<h2 id="bytecode-vs-machine-code">Bytecode vs. Machine Code</h2>

<p>It’s very important to understand the difference between bytecode vs. machine code (aka native code), perhaps best illustrated by example:</p>

<ul>
  <li>C compiles to machine code, which is then run directly on your processor. Each instruction instructs your CPU to move stuff around.</li>
  <li>Java compiles to bytecode, which is then run on the Java Virtual Machine (JVM), an abstraction of a computer that executes programs. Each instruction is then handled by the JVM, which interacts with your computer.</li>
</ul>

<p>In very brief terms: <strong>machine code is much faster, but bytecode is more portable and secure</strong>.</p>

<p>Machine code looks different depending on your machine, but bytecode looks the same on all machines. One might say that machine code is <em>optimized</em> to your setup.</p>

<p>Returning to CPython implementation, the toolchain process is as follows:</p>

<ol>
  <li>CPython compiles your Python source code into bytecode.</li>
  <li>That bytecode is then executed on the CPython Virtual Machine.</li>
</ol>

<p class="pop_out_box">
Beginners often assume Python is compiled because of .pyc files. There's some truth to that: the .pyc file is the compiled bytecode, which is then interpreted. So if you've run your Python code before and have the .pyc file handy, it will run faster the second time, as it doesn't have to re-compile the bytecode.
</p>

<h2 id="alternative-vms-jython-ironpython-and-more">Alternative VMs: Jython, IronPython, and More</h2>

<p>As I mentioned earlier, Python has <em>several</em> implementations. Again, as mentioned earlier, the most common is CPython, but there are others that should be mentioned for the sake of this comparison guide. This a Python implementation written in C and considered the ‘default’ implementation.</p>

<p>But what about the alternative Python implementations? One of the more prominent is <a href="http://www.jython.org/archive/21/docs/whatis.html">Jython</a>, a Python implementation written Java that utilizes the JVM. While CPython produces bytecode to run on the CPython VM, Jython produces <strong>Java bytecode</strong> to run on the JVM (this is the same stuff that’s produced when you compile a Java program).</p>

<p><img src="//assets.toptal.io/uploads/blog/image/127/toptal-blog-C.png" alt="Jython's use of Java bytecode is depicted in this Python implementation diagram."/></p>

<p>“Why would you ever use an alternative implementation?”, you might ask. Well, for one, these <strong>different Python implementations play nicely with different technology stacks</strong>.</p>

<p>CPython makes it very easy to write C-extensions for your Python code because in the end it is executed by a C interpreter. Jython, on the other hand, makes it very easy to work with other Java programs: you can import <em>any</em> Java classes with no additional effort, summoning up and utilizing your Java classes from within your Jython programs. <em>(Aside: if you haven’t thought about it closely, this is actually nuts. We’re at the point where you can mix and mash different languages and compile them all down to the same substance. (As mentioned by <a href="http://www.reddit.com/user/Rostin">Rostin</a>, programs that mix Fortran and C code have been around for a while. So, of course, this isn’t necessarily new. But it’s still cool.))</em></p>

<p>As an example, this is valid Jython code:</p>

<pre><code>[Java HotSpot(TM) 64-Bit Server VM (Apple Inc.)] on java1.6.0_51
&gt;&gt;&gt; from java.util import HashSet
&gt;&gt;&gt; s = HashSet(5)
&gt;&gt;&gt; s.add("Foo")
&gt;&gt;&gt; s.add("Bar")
&gt;&gt;&gt; s
[Foo, Bar]
</code></pre>

<p><a href="http://ironpython.net">IronPython</a> is another popular Python implementation, written entirely in C# and targeting the .NET stack. In particular, it runs on what you might call the .NET Virtual Machine, Microsoft’s <a href="http://en.wikipedia.org/wiki/Common_Language_Runtime">Common Language Runtime (CLR)</a>, comparable to the JVM.</p>

<p>You might say that <em>Jython : Java :: IronPython : C#</em>. They run on the same respective VMs, you can import C# classes from your IronPython code and Java classes from your Jython code, etc.</p>

<p>It’s totally possible to survive without ever touching a non-CPython Python implementation. But there are advantages to be had from switching, most of which are dependent on your technology stack. Using a lot of JVM-based languages? Jython might be for you. All about the .NET stack? Maybe you should try IronPython (and maybe you already have).</p>

<p><img src="//assets.toptal.io/uploads/blog/image/128/toptal-blog-A.png" alt="This Python comparison chart demonstrates the differences between Python implementations."/></p>

<p>By the way: while this wouldn’t be a <em>reason</em> to use a different implementation, note that these implementations do actually differ in behavior beyond how they treat your Python source code. However, these differences are typically minor, and dissolve or emerge over time as these implementations are under active development. For example, IronPython <a href="http://ironpython.codeplex.com/wikipage?title=IPy1.0.xCPyDifferences&amp;referringTitle=Home">uses Unicode strings by default</a>; CPython, however, <a href="http://docs.python.org/2/howto/unicode.html#encodings">defaults to ASCII</a> for versions 2.x (failing with a UnicodeEncodeError for non-ASCII characters), but does support  <a href="http://docs.python.org/3/howto/unicode.html#python-s-unicode-support">Unicode strings by default for 3.x</a>.</p>

<h2 id="PyPy">Just-in-Time Compilation: PyPy, and the Future</h2>

<p>So we have a Python implementation written in C, one in Java, and one in C#. The next logical step: a Python implementation written in… <a href="https://www.toptal.com/blog#python-posts">Python</a>.  (The educated reader will note that this is slightly misleading.)</p>

<p>Here’s where things might get confusing. First, lets discuss just-in-time (JIT) compilation.</p>

<h3 id="jit-the-why-and-how">JIT: The Why and How</h3>

<p>Recall that native machine code is much faster than bytecode. <em>Well, what if we could compile some of our bytecode and then run it as native code?</em> We’d have to pay some price to compile the bytecode (i.e., time), but if the end result was faster, that’d be great! This is the motivation of JIT compilation, a hybrid technique that mixes the benefits of interpreters and compilers. In basic terms, JIT wants to utilize compilation to speed up an interpreted system.</p>

<p>For example, a common approach taken by JITs:</p>

<ol>
  <li>Identify bytecode that is executed frequently.</li>
  <li>Compile it down to native machine code.</li>
  <li>Cache the result.</li>
  <li>Whenever the same bytecode is set to be run, instead grab the pre-compiled machine code and reap the benefits (i.e., speed boosts).</li>
</ol>

<p>This is what PyPy implementation is all about: bringing JIT to Python (see the <em>Appendix</em> for previous efforts). There are, of course, other goals: PyPy aims to be cross-platform, memory-light, and stackless-supportive. But JIT is really its selling point. As an average over a bunch of time tests, it’s said to improve performance by a factor of <a href="http://speed.pypy.org">6.27</a>. For a breakdown, see this chart from the <a href="http://speed.pypy.org">PyPy Speed Center</a>:</p>

<p><img src="//assets.toptal.io/uploads/blog/image/85/toptal-blog-PyPy.png" alt="Bringing JIT to Python interface using PyPy implementation pays off in performance improvements."/></p>

<h3 id="pypy-is-hard-to-understand">PyPy is Hard to Understand</h3>

<p>PyPy has huge potential, and at this point it’s <a href="http://doc.pypy.org/en/latest/faq.html#is-pypy-a-drop-in-replacement-for-cpython">highly compatible</a> with CPython (so <a href="http://pypy.org/compat.html">it can run Flask, Django</a>, etc.).</p>

<p>But there’s a lot of confusion around PyPy (see, for example, this nonsensical proposal to create a <a href="http://stackoverflow.com/questions/2591879/pypy-how-can-it-possibly-beat-cpython">PyPyPy…</a>). In my opinion, that’s primarily because PyPy is actually two things:</p>

<ol>
  <li>
    <p>A Python interpreter written in <a href="http://doc.pypy.org/en/latest/coding-guide.html#id1">RPython</a> (not Python (I lied before)). RPython is a subset of Python with static typing. In Python, it’s <a href="http://doc.pypy.org/en/latest/faq.html#can-rpython-compile-normal-python-programs-to-c">“mostly impossible”</a> to reason rigorously about types (Why is it so hard? Well consider the fact that:</p>

    <pre><code> x = random.choice([1, "foo"])
</code></pre>

    <p>would be valid Python code (credit to <a href="http://www.reddit.com/user/Ademan">Ademan</a>). What is the type of <code>x</code>? How can we reason about types of variables when the types aren’t even strictly enforced?). With RPython, you sacrifice some flexibility, but instead make it much, much easier to reason about memory management and whatnot, which allows for optimizations.</p>
  </li>
  <li>
    <p>A compiler that compiles RPython code for various targets and adds in JIT. <a href="http://doc.pypy.org/en/release-1.9/translation.html#overview">The default platform is C</a>, i.e., an RPython-to-C compiler, but you could also target the JVM and others.</p>
  </li>
</ol>

<p>Solely for clarity in this Python comparison guide, I’ll refer to these as PyPy (1) and PyPy (2).</p>

<p>Why would you need these two things, and why under the same roof? Think of it this way: PyPy (1) is an interpreter written in RPython. So it takes in the user’s Python code and compiles it down to bytecode. But the interpreter itself (written in RPython) must be interpreted by another Python implementation in order to run, right?</p>

<p>Well, we could just <a href="http://www.stavros.io/posts/what-is-pypy/">use CPython</a> to run the interpreter. But that wouldn’t be very fast.</p>

<p>Instead, the idea is that we use PyPy (2) (referred to as the <a href="http://doc.pypy.org/en/release-1.9/translation.html">RPython Toolchain</a>) to compile PyPy’s interpreter down to code for another platform (e.g., C, JVM, or CLI) to run on our machine, adding in JIT as well. It’s magical: PyPy dynamically adds JIT to an interpreter, generating its own compiler! (<em>Again, this is nuts: we’re compiling an interpreter, adding in another separate, standalone compiler.</em>)</p>

<p>In the end, the result is a standalone executable that interprets Python source code and exploits JIT optimizations. Which is just what we wanted! It’s a mouthful, but maybe this diagram will help:</p>

<p><img src="//assets.toptal.io/uploads/blog/image/129/toptal-blog-B.png" alt="This diagram illustrates the beauty of the PyPy implementation, including an interpreter, compiler, and an executable with JIT."/></p>

<p>To reiterate, the real beauty of PyPy is that we could write ourselves a bunch of different Python interpreters in RPython without worrying about JIT. <em>PyPy would then implement JIT for us</em> using the RPython Toolchain/PyPy (2).</p>

<p>In fact, if we get even more abstract, you could theoretically write an interpreter for <em>any</em> language, feed it to PyPy, and get a JIT for that language. This is because PyPy focuses on optimizing the actual interpreter, rather than the details of the language it’s interpreting.</p>

<p class="pop_out_box is-full_width is-big">
You could theoretically write an interpreter for any language, feed it to PyPy, and get a JIT for that language.
</p>

<p>As a brief digression, I’d like to mention that the JIT itself is absolutely fascinating. It uses a technique called tracing, which executes <a href="http://morepypy.blogspot.com/2009/03/applying-tracing-jit-to-interpreter.html">as follows</a>:</p>

<ol>
  <li>Run the interpreter and interpret everything (adding in no JIT).</li>
  <li>Do some light profiling of the interpreted code.</li>
  <li>Identify operations you’ve performed before.</li>
  <li>Compile these bits of code down to machine code.</li>
</ol>

<p><em>For more, <a href="https://bitbucket.org/pypy/extradoc/src/tip/talk/icooolps2009/bolz-tracing-jit-final.pdf">this paper</a> is highly accessible and very interesting.</em></p>

<p>To wrap up: we use PyPy’s RPython-to-C (or other target platform) compiler to compile PyPy’s RPython-implemented interpreter.</p>

<h2 id="wrapping-up">Wrapping Up</h2>

<p>After a lengthy comparison of Python implementations, I have to ask myself: Why is this so great? Why is this crazy idea worth pursuing? I think <a href="http://pypy.org/people.html#alex-gaynor">Alex Gaynor</a> put it well on his <a href="http://alexgaynor.net/2010/may/15/pypy-future-python/">blog</a>: “[PyPy is the future] because [it] offers better speed, more flexibility, and is a better platform for Python’s growth.”</p>

<p>In short:</p>

<ul>
  <li><strong>It’s fast because it compiles source code to native code</strong> (using JIT).</li>
  <li><strong>It’s flexible because it adds the JIT to your interpreter</strong> with very little additional work.</li>
  <li><strong>It’s flexible (again) because you can write your interpreters in RPython</strong>, which is easier to extend than, say, C (in fact, it’s so easy that there’s a <a href="http://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html">tutorial for writing your own interpreters</a>).</li>
</ul>

<h2 id="appendix-other-python-names-you-may-have-heard">Appendix: Other Python Names You May Have Heard</h2>
<ul>
  <li>
    <p><a href="http://www.python.org/dev/peps/pep-3000/">Python 3000 (Py3k)</a>: an alternative naming for Python 3.0, a major, <a href="http://www.python.org/dev/peps/pep-3000/#compatibility-and-transition">backwards-incompatible</a> Python release that hit the stage in <a href="http://python.org/download/releases/3.0/">2008</a>. The Py3k team predicted that it would take about <a href="http://programmers.stackexchange.com/questions/63859/why-do-people-hesitate-to-use-python-3#answer-63935">five years</a> for this new version to be fully adopted. And while <em>most</em> (warning: anecdotal claim) Python developers continue to use Python 2.x, people are increasingly conscious of Py3k.</p>
  </li>
  <li><a href="http://cython.org">Cython</a>: a superset of Python that includes bindings to call C functions.
    <ul>
      <li>Goal: allow you to write C extensions for your Python code.</li>
      <li>Also lets you add <a href="http://docs.cython.org/src/quickstart/cythonize.html">static typing</a> to your existing Python code, allowing it to be compiled and reach C-like performance.</li>
      <li>This is similar to PyPy, but not the same. In this case, you’re enforcing typing in the user’s code before passing it to a compiler. With PyPy, you write plain old Python, and the compiler handles any optimizations.<br/>
<br/></li>
    </ul>
  </li>
  <li>
    <p><a href="http://numba.pydata.org">Numba</a>: a “just-in-time specializing compiler” that adds JIT to <em>annotated</em> Python code. In the most basic terms, you give it some hints, and it speeds up portions of your code. Numba comes as part of the <a href="http://docs.continuum.io/anaconda/index.html">Anaconda</a> distribution, a set of packages for data analysis and management.</p>
  </li>
  <li>
    <p><a href="http://ipython.org/index.html">IPython</a>: very different from anything else discussed. A computing environment for Python. Interactive with support for GUI toolkits and browser experience, etc.</p>
  </li>
  <li><a href="http://psyco.sourceforge.net">Psyco</a>: a <a href="http://rayli.net/blog/2010/04/what-is-the-purpose-of-pypy/">Python extension module</a>, and one of the early Python JIT efforts. However, it’s since been marked as <a href="http://psyco.sourceforge.net">“unmaintained and dead”</a>. In fact, the lead developer of Psyco, <a href="http://pypy.org/people.html#armin-rigo">Armin Rigo, now works on PyPy</a>.</li>
</ul>

<h3 id="python-language-bindings">Python Language Bindings</h3>

<p/>

<ul>
  <li>
    <p><a href="http://rubypython.rubyforge.org">RubyPython</a>: a bridge between the Ruby and Python VMs. Allows you to embed Python code into your Ruby code. You define where the Python starts and stops, and RubyPython marshals the data between the VMs.</p>
  </li>
  <li>
    <p><a href="http://pythonhosted.org/pyobjc/#release-information">PyObjc</a>: language-bindings between Python and Objective-C, acting as a bridge between them. Practically, that means you can utilize Objective-C libraries (including everything you need to create OS X applications) from your Python code, and Python modules from your Objective-C code. In this case, it’s convenient that CPython is written in C, which is a subset of Objective-C.</p>
  </li>
  <li>
    <p><a href="http://www.riverbankcomputing.com/software/pyqt/intro">PyQt</a>: while PyObjc gives you binding for the OS X GUI components, PyQt does the same for the Qt application framework, letting you create rich graphic interfaces, access SQL databases, etc. Another tool aimed at bringing Python’s simplicity to other <a href="https://www.toptal.com/django/django-flask-and-redis-sharing-user-sessions-between-frameworks">frameworks</a>.</p>
  </li>
</ul>

<h3 id="javascript-frameworks">JavaScript Frameworks</h3>

<p/>

<ul>
  <li>
    <p><a href="http://pyjs.org">pyjs (Pyjamas)</a>: a framework for creating web and desktop applications in Python. Includes a Python-to-JavaScript compiler, a widget set, and some more tools.</p>
  </li>
  <li>
    <p><a href="http://www.brython.info">Brython</a>: a Python VM written in JavaScript to allow for Py3k code to be executed in the browser.</p>
  </li>
</ul>
<p class="template" data-role="subscribe_template" data-template="{&quot;html&quot;:&quot;\u003cdiv class=\&quot;embeddable_form-wrapper\&quot; data-view=\&quot;blog_subscribe#form\&quot;\u003e\u003cform action=\&quot;/blog/subscription\&quot; class=\&quot;embeddable_form for-post\&quot; data-entity=\&quot;blog_subscription\&quot; data-remote=\&quot;\&quot; data-view=\&quot;form#form\&quot; method=\&quot;post\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-step is-email_form is-current\&quot; data-role=\&quot;step\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-row is-label\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-label_title\&quot;\u003eLike what you\u0026#39;re reading?\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-label\&quot;\u003eGet the latest updates first.\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row form-field is-email_field\&quot;\u003e\u003cinput autocomplete=\&quot;off\&quot; class=\&quot;input is-medium\&quot; data-role=\&quot;email\&quot; name=\&quot;blog_subscription[email]\&quot; placeholder=\&quot;Enter your email address...\&quot; type=\&quot;text\&quot; /\u003e\u003cinput name=\&quot;blog_subscription[vertical]\&quot; type=\&quot;hidden\&quot; value=\&quot;developers\&quot; /\u003e\u003cinput name=\&quot;from_widget\&quot; type=\&quot;hidden\&quot; value=\&quot;true\&quot; /\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-submit\&quot;\u003e\u003cinput class=\&quot;button is-green_candy is-default is-full_width\&quot; data-loader-text=\&quot;Subscribing...\&quot; data-role=\&quot;submit\&quot; type=\&quot;submit\&quot; value=\&quot;Get Exclusive Updates\&quot; /\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-privacy\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-privacy\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-privacy_icon\&quot;\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-privacy_text\&quot;\u003eNo spam. Just great engineering and design posts.\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-step is-confirmation\&quot; data-role=\&quot;step\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-row is-label is-success\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-label_title\&quot;\u003eLike what you\u0026#39;re reading?\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-label\&quot;\u003eGet the latest updates first.\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-success\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-label is-header\&quot;\u003eThank you for subscribing!\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-label\&quot;\u003eYou can edit your subscription preferences \u003ca href='#' data-role='preferences_link'\u003ehere\u003c/a\u003e.\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-success\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-done\&quot;\u003e\u003cul class=\&quot;blog_follow_us\&quot;\u003e\u003cul class=\&quot;social_share\&quot;\u003e\u003cli class=\&quot;social_share-item is-facebook\&quot;\u003e\u003cdiv class=\&quot;fb-like\&quot; data-href=\&quot;https://www.toptal.com/blog\&quot; data-layout=\&quot;button_count\&quot; data-send=\&quot;false\&quot; data-show-faces=\&quot;false\&quot; data-width=\&quot;450\&quot;\u003e\u003c/div\u003e\u003c/li\u003e\u003cli class=\&quot;social_share-item is-twitter_follow\&quot;\u003e\u003ca class=\&quot;twitter-follow-button\&quot; data-show-count=\&quot;true\&quot; href=\&quot;https://twitter.com/toptalllc\&quot;\u003eFollow @toptalllc\u003c/a\u003e\u003c/li\u003e\u003cli class=\&quot;social_share-item is-google_plus_follow\&quot;\u003e\u003cdiv class=\&quot;g-follow\&quot; data-annotation=\&quot;bubble\&quot; data-height=\&quot;20\&quot; data-href=\&quot;https://plus.google.com/109028009576318848424\&quot; data-rel=\&quot;publisher\&quot;\u003e\u003c/div\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/form\u003e\u003c/div\u003e&quot;}"/></div></div></body></html>