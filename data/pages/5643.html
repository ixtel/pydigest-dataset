<html><body><div><div class="article__body">
      <h2>Pandas releases the Global-Interpreter-Lock.</h2><p>In the upcoming 0.17.0 version, <a href="http://pandas.pydata.org/">pandas</a> will release the Global-Interpreter-Lock (GIL) on groupby operations. In this post, we are going to answer some important questions:</p><ul><li>What is the GIL?</li><li>Why is this important?</li><li>How did we do it?</li></ul><h2>What is the GIL?</h2><p>The <a href="https://wiki.python.org/moin/GlobalInterpreterLock">Global-Interpreter-Lock (GIL)</a> is a mutex that prevents multiple native threads from running in parallel. In essence, this says that a python program cannot do more than one thing at once via <em>threading</em>.</p><p>However, <a href="https://docs.python.org/2/extending/extending.html">extensions</a>, which are <em>C/C++/Fortran</em> compiled code that are linked to the python interpreter, <strong>CAN</strong> release the GIL. Some python packages, notably <a href="http://www.numpy.org/">NumPy</a>, do release the GIL.</p><h2>Why is this important?</h2><p>It is easy to see that when processing data with pandas, doing more than one thing at once could be really useful! We could do more things faster, or potentially work with a blocking-API. In fact, some of the motiviation for releasing the GIL in pandas was driven by the desire to use this type of in-process parallelism with another project, <a href="http://dask.pydata.org/en/latest/">dask</a>.</p><p>We are going to simulate doing an embarrasingly parallel operation, namely, calculating groupby means. One could imagine using threads to calculate on different groups at the same time. This is what I mean by embarrasingly parallel. There are <strong>no</strong> interactions between the calculations; they are wholly independent.</p><p>First we set up the environment by importing pandas and NumPy. Then we create a large DataFrame with a bunch of randomly created data.</p><figure>
<pre>In [1]: import pandas as pd
In [2]: import numpy as np
In [3]: np.random.seed(1234)
 
In [4]: N = 1000000
In [5]: ngroups = 1000
In [6]: df = DataFrame({'key' : np.random.randint(0,ngroups,size=N),
                        'data' : np.random.randn(N) })
 
In [7]: df.head()
Out[7]:
       data  key
0  0.395838  815
1  0.377571  723
2 -0.452345  294
3 -0.806461   53
4  0.026369  204
 
In [8]: df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
Int64Index: 1000000 entries, 0 to 999999
Data columns (total 2 columns):
data    1000000 non-null float64
key     1000000 non-null int64
dtypes: float64(1), int64(1)
memory usage: 22.9 MB
</pre>

<h4>Python</h4>
<p> </p>
<p>This is a typical groupby scenario. We want to groupby and reduce. In this case we will groupby the key and retrieve the mean for each group.</p>
<figure>
<pre>In [9]: result = df.groupby('key').mean()
In [10]: result.head()
Out[10]:
         data
key
0   -0.059063
1    0.022777
2    0.005029
3    0.021176
4   -0.013846
 
In [11]: result.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
Int64Index: 1000 entries, 0 to 999
Data columns (total 1 columns):
data    1000 non-null float64
dtypes: float64(1)
memory usage: 15.6 KB
</pre>
 
<figcaption>Python</figcaption></figure>
<h3>How long did it take to run this operation?</h3>
<figure>
<pre>In [15]: %timeit df.groupby('key')['data'].mean()
10 loops, best of 3: 24.8 ms per loop</pre>

<figcaption><p>Python</p></figcaption></figure>
<p>Now, we are going to time how long it takes to do this operation twice. This is a serial operation, so it clearly should take about twice as long.</p>
<figure>
<pre>In [13]: def g2():
   ....:     for i in range(2):
   ....:         df.groupby('key')['data'].mean()
   ....:
 
In [14]: %timeit g2()
10 loops, best of 3: 51.63 ms per loop
</pre>
 
<figcaption>Python</figcaption></figure>
<p>Shocker, we were right. About twice as long. So this scales linearly with the number of times we are doing this operation.</p>
<p>This effictively simulates using 2 threads in the current version of pandas. They work one after the other.</p>
<h2>How did we do it</h2>
<p><em>pandas</em> achieves high performance by using <a href="http://www.numpy.org/">NumPy</a> intelligently, several external packages including <a href="http://code.google.com/p/numexpr/">numexpr</a>, and <a href="http://berkeleyanalytics.com/bottleneck">bottleneck</a> and a lot of <a href="http://www.cython.org/">Cython</a> code.</p>
<p>I gave away the solution at the top of this post! <em>Cython</em> allows us to release the GIL during the execution of C code. For operations that involve only basic non-pointer data types, like floats and integers, we can pretty easily release the GIL. These basic non-pointer data types do not include strings. This allows multi-threaded programs to use more of the machine hardware, and consequently, do more work.</p>
<p>We have a created a decorator in pandas, <em>test_parallel</em>, to allow us to run a function with a specified number of threads. This will run the function once per thread with the specified number of threads.</p>
<figure>
<pre>from pandas.util.testing import test_parallel
@test_parallel(num_threads=2)
def pg2():
    df.groupby('key')['data'].mean()
</pre>
 
<figcaption>Python</figcaption></figure>
<p>This is analagous to the <em>g2()</em> function above doing the same amount of work. We will time this next.</p>
<figure>
<pre>In [18]: %timeit pg2()
 
10 loops, best of 3: 26.24 ms per loop
</pre>
 
<figcaption>Python</figcaption></figure>
<p> </p>
<p>Wow. We did the same amount of work in a little bit more than 1/2 of the time. This is great!</p>
<p>Taking this exercise further, let’s get some data by running this on 2, 4 and 8 threads.</p>
<p><img alt="graph of timings for single vs multi threaded groupbys" title="graph of timings for single vs multi threaded groupbys" class="media-element file-default" typeof="foaf:Image" src="/sites/default/files/pandas-release-the-gil-timings.png"/></p>
<p>Furthermore, we calculate a speedup factor, which is the ratio of the single threaded to the multi threaded version. This tells use how much work we could get done in an equivalent amount of time. So using more threads helps! Awesome!</p>
<p><img alt="graph of speed ups for releasing the gil for multi-threads" title="graph of speed ups for releasing the gil for multi-threads" class="media-element file-default" typeof="foaf:Image" src="/sites/default/files/pandas-release-the-gil-speedups.png"/></p>
<h2>Conclusion</h2>
<p>We have seen that it is possible to speed up certain operations in pandas by releasing the Global-Interpreter-Lock. In the future we hope to extend this to other operations and techniques.</p></figure>  </div>

        
  
</div></body></html>