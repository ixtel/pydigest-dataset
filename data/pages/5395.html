<html><body><div><div class="post-content">
      <p>uWSGI is one of those interesting projects that keeps adding features with every new release without becoming totally bloated, slow, and/or unstable. In this post, we'll look at some of its lesser used features and how you might use them to simplify your Python web service.</p>

<p>Let's start by looking at a common Python web project's deployment stack.</p>

<ul>
<li><strong>Nginx</strong>: Static file serving, SSL termination, reverse proxy</li>
<li><strong>Memcached</strong>: Caching</li>
<li><strong>Celery</strong>: Background task runner</li>
<li><strong>Redis or RabbitMQ</strong>: Queue for Celery</li>
<li><strong>uWSGI</strong>: Python WSGI server</li>
</ul>

<p><em>Five</em> services. That's a lot of machinery to run for a basic site. Let's see how uWSGI can help you simplify things:</p>

<h2>Static File Serving</h2>

<p>uWSGI can serve static files quite efficiently. It can even do so without tying up the same worker/thread pool your application uses thanks to it's <a href="http://uwsgi-docs.readthedocs.org/en/latest/OffloadSubsystem.html">offloading subsystem</a>. There are a bunch of configuration options around static files, but the common ones we use are:</p>

<ul>
<li><code data-syntax="text-only">offload-threads</code> the number of threads to dedicate to serving static files</li>
<li><code data-syntax="text-only">check-static</code> this works like Nginx's <code data-syntax="text-only">@tryfiles</code> directive, checking for the existence of a static file before hitting the Python application</li>
<li><code data-syntax="text-only">static-map</code> does the same, but only when a URL pattern is matched</li>
</ul>

<p>Other options exist to allow you to control gzipping and expires headers among other things. An ini configuration for basic static file serving might look like this:</p>

<pre class="highlight"><code data-syntax="ini"><span class="na">offload-threads</span> <span class="o">=</span> <span class="s">4</span>
<span class="na">static-map</span> <span class="o">=</span> <span class="s">/static=/var/www/project/static</span>
<span class="na">static-map</span> <span class="o">=</span> <span class="s">/media=/var/www/project/media</span>
<span class="na">static-expires</span> <span class="o">=</span> <span class="s">/var/www/project/static/* 2592000</span></code></pre>

<p>More information on static file handling is available on a topic page in the <a href="http://uwsgi-docs.readthedocs.org/en/latest/StaticFiles.html">uWSGI docs</a>. When placed behind a CDN, this setup is sufficient for even high-traffic sites.</p>

<h2>SSL Termination</h2>

<p>uWSGI can handle SSL connections and even the SPDY protocol. Here's an example configuration which will use HTTPS and optionally SPDY as well as redirecting HTTP requests to HTTPS:</p>

<pre class="highlight"><code data-syntax="ini"><span class="na">https2</span> <span class="o">=</span> <span class="s">addr=0.0.0.0:8443,cert=domain.crt,key=domain.key,spdy=1</span>
<span class="na">http-to-https</span> <span class="o">=</span> <span class="s">true</span></code></pre>

<h2>Reverse Proxy</h2>

<p>uWSGI speaks HTTP and can handle efficiently routing requests to multiple workers. Here's an example that will start an HTTP listener on port 80:</p>

<pre class="highlight"><code data-syntax="ini"><span class="na">master</span> <span class="o">=</span> <span class="s">true</span>
<span class="na">http</span> <span class="o">=</span> <span class="s">80</span>
<span class="c1"># http://uwsgi-docs.readthedocs.org/en/latest/articles/SerializingAccept.html</span>
<span class="na">thunder-lock</span> <span class="o">=</span> <span class="s">true</span>
<span class="na">uid</span> <span class="o">=</span> <span class="s">www-data</span>
<span class="na">gid</span> <span class="o">=</span> <span class="s">www-data</span></code></pre>

<p>In this scenario, you'll need to start <code data-syntax="text-only">uwsgi</code> as the <code data-syntax="text-only">root</code> user to access port 80, but it will drop privileges to an unprivileged account via the <code data-syntax="text-only">uid/gid</code> arguments.</p>

<p>You can also do routes and redirects (see <a href="http://uwsgi-docs.readthedocs.org/en/latest/InternalRouting.html">the docs</a> for more complex examples):</p>

<pre class="highlight"><code data-syntax="ini"><span class="na">route</span> <span class="o">=</span> <span class="s">^/favicon\.ico$ permanent-redirect:/static/favicon.ico</span></code></pre>

<p><em>Note: It is unclear to me whether uWSGI's HTTP server is vulnerable to DoS attacks such as <a href="https://en.wikipedia.org/wiki/Slowloris_(software">Slowloris</a>. Please leave a comment if you have any more information here.</em></p>

<h2>Caching</h2>

<p>Did you know uWSGI includes a fast in-memory caching framework? The configuration for it looks like this:</p>

<pre class="highlight"><code data-syntax="ini"><span class="na">cache2</span> <span class="o">=</span> <span class="s">name=default,items=5000,purge_lru=1,store=/tmp/uwsgi_cache</span></code></pre>

<p>This will configure a cache named <code data-syntax="text-only">default</code> capable of holding up to 5000 items purging least recently used keys in the event of an overflow. The cache will periodically be asynchronously flushed to disk (<code data-syntax="text-only">/tmp/uwsgi_cache</code>) so the uWSGI process can be restarted without also dropping the entire cache.</p>

<p>You can find the <a href="http://uwsgi-docs.readthedocs.org/en/latest/Caching.html">caching framework docs here</a> and a Django-compliant cache backend, <code data-syntax="text-only">django-uwsgi-cache</code>, is available <a href="https://pypi.python.org/pypi/django-uwsgi-cache">on PyPI</a>.</p>

<h2>Task Queuing</h2>

<p>Yes, that's right, uWSGI includes a task queue too. The uWSGI spooler can not only queue tasks for immediate execution, but also provide cron-like functionality to schedule tasks to run at some point in the future. It is configured, simply by providing a directory to store the queue and the number of workers to run:</p>

<pre class="highlight"><code data-syntax="ini"><span class="na">spooler</span> <span class="o">=</span> <span class="s">/tmp/uwsgi_spooler</span>
<span class="na">spooler-processes</span> <span class="o">=</span> <span class="s">4</span></code></pre>

<p>The <code data-syntax="text-only">uwsgi</code> Python package provides a <code data-syntax="text-only">uwsgidecorators</code> module that can be used to place jobs on the queue for execution. A simple example:</p>

<pre class="highlight"><code data-syntax="python"><span class="kn">from</span> <span class="nn">uwsgidecorators</span> <span class="kn">import</span> <span class="n">cron</span><span class="p">,</span> <span class="n">spool</span>

<span class="nd">@cron</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cronjob_task</span><span class="p">():</span>
    <span class="c"># This will run everyday at midnight</span>
    <span class="o">...</span>

<span class="nd">@spool</span>
<span class="k">def</span> <span class="nf">queued_task</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c"># Something slow you want to queue</span>
    <span class="o">...</span>

<span class="c"># Put a task into the queue</span>
<span class="n">queued_task</span><span class="o">.</span><span class="n">spool</span><span class="p">(</span><span class="n">foo</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="s">'test'</span><span class="p">)</span></code></pre>

<h2>Conclusion</h2>

<p>As you can see, uWSGI really is a swiss army knife for serving Python web services. Actually, it's not even limited to Python. You can use it for Ruby and Perl sites as well. We've used many of these features on production sites with great success. While specialized services are certainly going to be more robust for high-volume workloads, they are simply overkill for the majority of sites.</p>

<p>Distributed microservice architectures may be all the rage, but the reality is that most sites can run on a single server. Reducing the number of services and dependencies makes deployment easier and removes points of failure in your system. Before you jump to add more tools to your stack, it's worth checking if you can make do with what you already have.</p>

    </div>

    
    
    </div></body></html>