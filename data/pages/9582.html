<html><body><div><div class="content html_format">
      <i>Данная статья, <a href="https://github.com/mitsuhiko/flask/wiki/Large-app-how-to">размещенная</a> в репозитории Flask на GitHub, является плодом коллективного творчества небезразличных программистов, а изначальный её автор — <a href="http://bbrriiccee@gmail.com">Brice Leroy</a>. Она представляет собой достаточно полезный для начинающих материал по Flask. Лично для меня он стал ответом на многие простые вопросы, основным из которых был «как структурировать проект».<br/>
 <br/>
Для хоть сколько-то опытных программистов она вряд ли будет полезна, многие могут вовсе не согласиться с описанными принципами, однако для находящихся на ранней стадии обучения она может стать толчком к развитию, как стала для меня. Именно поэтому я сделал перевод на русский язык — у этой статьи очень низкий порог вхождения и стоит сделать его еще ниже.<br/>
<br/>
Описанный пример протестирован на Python 3.5, Flask 0.10, Flask-SQLAlchemy 2.1, Flask-WTF 0.9.</i>
<a name="habracut"/>
<h1>Проектирование простых приложений в Flask</h1><p>
Этот документ не входит в официальную документацию Flask. Он является компиляцией советов, полученных из различных неофициальных источников и никогда не подвергался какой-либо проверке. Описанные методики могут быть весьма полезны, но в то же время и достаточно опасны. Просьба не вносить никаких изменений в оригинальный документ, размещенный на Github, так как на него ссылаются многие ответы на StackOverflow. Вы можете вносить в него любые поправки и заметки, но для размещения используйте личный сайт или блог.
</p><p>
Данная статья является попыткой описать структуру проекта, использующего </p><b>Flask</b><p> и базовые модули </p><b>SQLAlchemy</b><p> и </p><b>WTForms</b><p>.

</p><h2>Установка</h2>
<h3>Flask</h3>
<a href="http://flask.pocoo.org/docs/0.10/installation/">Инструкция</a><p> по установке Flask.
</p><p>
Я рекомендую использовать </p><b>virtualenv</b><p> — эта система очень проста и позволяет размещать несколько виртуальных окружений на одной системе и не требует прав суперпользователя, так как все библиотеки устанавливаются локально.

</p><h3>Flask-SQLAlchemy</h3><p>
SQLAlchemy обеспечивает простой и мощный интерфейс взаимодействия ваших объектов и реляционной базы данных любого типа. Для установки Flask-SQLAlchemy в ваше виртуальное окружение используйте pip:

</p><pre><code>pip install flask-sqlalchemy
</code></pre>
<a href="http://packages.python.org/Flask-SQLAlchemy/">Более полное описание</a><p> пакета Flask-SQLAlchemy.

</p><h3>Flask-WTF</h3>
<b>WTForms</b><p> упрощает получение данных от пользователя.

</p><pre><code>pip install Flask-WTF
</code></pre>
<a href="https://pythonhosted.org/Flask-WTF/">Более полное описание</a><p> пакета Flask-WTF.

</p><h2>Введение</h2><p>
Итак, необходимые библиотеки подготовлены. Так должна выглядеть основная структура вашего проекта:

</p><pre><code>/app/users/__init__.py
/app/users/views.py
/app/users/forms.py
/app/users/constants.py
/app/users/models.py
/app/users/decorators.py
</code></pre><p>
Для каждего модуля (элемента приложения) создаётся следующая структура:

</p><pre><code>/app/templates/404.html
/app/templates/base.html
/app/templates/users/login.html
/app/templates/users/register.html
...
</code></pre><p>
Шаблоны представления (jinja) хранятся в директории </p><em>templates</em><p> и поддиректория модулей:

</p><pre><code>/app/static/js/main.js
/app/static/css/reset.css
/app/static/img/header.png
</code></pre><p>
Для обработки неизменяемых файлов необходимо использовать отдельный веб-сервер, однако на время разработки можно возложить эту работу на Flask. Он автоматически выдает такие файлы из директории </p><em>static</em><p>, а для настройки использования другой директории вы можете воспользоваться информацией из </p><a href="http://flask.pocoo.org/docs/0.10/api/#application-object">данной статьи</a><p>.
</p><p>
Для рассматриваемого приложения будут создан один модуль: users. Он обеспечит управление регистрацией и входом пользователей, просмотр данных своего профайла.

</p><h2>Конфигурация</h2>
<em>/run.py</em><p> используется для запуска веб-сервера:

</p><pre><code>    from app import app
    app.run(debug=True)
</code></pre>
<em>/shell.py</em><p> даст доступ к консоли с возможностью выполнения команд. Возможно, не так удобно, как отладка через </p><b>pdb</b><p>, но достаточно полезно (по крайней мере при инициализации базы данных):

</p><pre><code>    #!/usr/bin/env python
    import os
    import readline
    from pprint import pprint

    from flask import *
    from app import *

    os.environ['PYTHONINSPECT'] = 'True'
</code></pre>
<em>Примечание переводчика:<br/>
В случае, если вы работаете в ОС Windows (не надо бросать кирпичи!), библиотека readline недоступна. В таком случае необходимо установить в своё виртуальное или реальное окружение python библиотеку pyreadline и обернуть импорт в конструкцию вида:</em>

<pre><code>try:
    import readline
except:
    import pyreadline
</code></pre>
<em>В принципе, можно и вовсе обойтись без этой библиотеки, она просто упрощает взаимодействие с консолью, добавляя в нее некоторые bash-like элементы.</em>

<em>/config.py</em><p> хранит всю конфигурацию приложения. В данном примере в качестве базы данных используется SQLite, так как она очень удобна при разработке. Скорее всего файл </p><em>/config.py</em><p> не стоит включать в репозиторий, так как он будет разным на тестовой и промышленной системах.

</p><pre><code>    import os
    _basedir = os.path.abspath(os.path.dirname(__file__))

    DEBUG = False

    ADMINS = frozenset(['youremail@yourdomain.com'])
    SECRET_KEY = 'This string will be replaced with a proper key in production.'

    SQLALCHEMY_DATABASE_URI = 'sqlite:///' + os.path.join(_basedir, 'app.db')
    DATABASE_CONNECT_OPTIONS = {}

    THREADS_PER_PAGE = 8

    WTF_CSRF_ENABLED = True
    WTF_CSRF_SECRET_KEY = "somethingimpossibletoguess"

    RECAPTCHA_USE_SSL = False
    RECAPTCHA_PUBLIC_KEY = '6LeYIbsSAAAAACRPIllxA7wvXjIE411PfdB2gt2J'
    RECAPTCHA_PRIVATE_KEY = '6LeYIbsSAAAAAJezaIq3Ft_hSTo0YtyeFG-JgRtu'
    RECAPTCHA_OPTIONS = {'theme': 'white'}
</code></pre>
<ul>
<li><em>_basedir</em> — переменная, в которую помещается исполняемая директория скрипта;</li>
<li><em>DEBUG</em> определяет появление сообщений об ошибках в тестовом окружении;</li>
<li><em>SECRET_KEY</em> используется для подписи cookies, при его изменении пользователям потребуется логиниться заново;</li>
<li><em>ADMINS</em> содержит адрес электронной почты администраторов для рассылок из приложения;</li>
<li><em>SQLALCHEMY_DATABASE_URI</em> и <em>DATABASE_CONNECT_OPTIONS</em>, как несложно догадаться — опции подключения SQLAlchemy;</li>
<li><em>THREADS_PER_PAGE</em>, как мне кажется, ставил 2 на ядро… Могу ошибаться;</li>
<li><em>WTF_CSRF_ENABLED</em> и <em>WTF_CSRF_SECRET_KEY</em> защищают от подмены POST-сообщений;</li>
<li><em>RECAPTCHA_*<em> используется для входящего в <strong>WTForms</strong> поля <strong>RecaptchaField</strong>. Получить приватный и публичный ключи можно на сайте **recaptcha</em></em>.</li>
</ul>
<h2>Модуль</h2><p>
Настроим модуль </p><b>users</b><p> в следующем порядке: определим модели, связанные с моделями константы, далее форму и, наконец, представление и шаблоны.

</p><h3>Модель</h3>
<em>/app/users/models.py</em><p>:

</p><pre><code>    from app import db
    from app.users import constants as USER

    class User(db.Model):

        __tablename__ = 'users_user'
        id = db.Column(db.Integer, primary_key=True)
        name = db.Column(db.String(50), unique=True)
        email = db.Column(db.String(120), unique=True)
        password = db.Column(db.String(120))
        role = db.Column(db.SmallInteger, default=USER.USER)
        status = db.Column(db.SmallInteger, default=USER.NEW)

        def __init__(self, name=None, email=None, password=None):
          self.name = name
          self.email = email
          self.password = password

        def getStatus(self):
          return USER.STATUS[self.status]

        def getRole(self):
          return USER.ROLE[self.role]

        def __repr__(self):
            return '&lt;User %r&gt;' % (self.name)
</code></pre><p>
И её константы в файле </p><em>/app/users/constants.py</em><p>:

</p><pre><code>    # User role
    ADMIN = 0
    STAFF = 1
    USER = 2
    ROLE = {
      ADMIN: 'admin',
      STAFF: 'staff',
      USER: 'user',
    }

    # user status
    INACTIVE = 0
    NEW = 1
    ACTIVE = 2
    STATUS = {
      INACTIVE: 'inactive',
      NEW: 'new',
      ACTIVE: 'active',
    }</code></pre><p>
К слову о константах: мне нравится, когда константы хранятся в отдельном файле внутри модуля. Константы скорее всего будут использоваться в моделях, формах и представлениях, так что таким образом вы получите удобно организованные данные, которые будет просто найти. К тому же, импортирование констант под именем модуля в верхнем регистре (например </p><em>USERS</em><p> для </p><em>users.constants</em><p>) поможет избежать конфликтов имен.

</p><h3>Форма</h3><p>
Когда создана модель нужного объекта, необходимо сконструировать форму для работы с ней.
</p><p>
Форма регистрации будет запрашивать имя пользователя, адрес электронной почты и пароль, будут использованы валидаторы для проверки корректности введенных пользователем данных, а поле </p><strong>Recaptcha</strong><p> защитит от регистрации ботов. На случай, если понадобится внедрить пользовательское соглашение, также добавлено поле </p><strong>BooleanField</strong><p> с именем </p><strong>accept_tos</strong><p>. Данное поле помечено, как </p><strong>required</strong><p>, то есть пользователь будет обязан отметить генерируемый формой чекбокс. Форма входа снабжена полями </p><strong>email</strong><p> и </p><strong>password</strong><p> с аналогичными валидаторами. 
</p><p>
Описание форм содержится в файле </p><em>/app/users/forms.py</em><p>:

</p><pre><code>    from flask.ext.wtf import Form, RecaptchaField
    from wtforms import TextField, PasswordField, BooleanField
    from wtforms.validators import Required, EqualTo, Email

    class LoginForm(Form):
      email = TextField('Email address', [Required(), Email()])
      password = PasswordField('Password', [Required()])

    class RegisterForm(Form):
      name = TextField('NickName', [Required()])
      email = TextField('Email address', [Required(), Email()])
      password = PasswordField('Password', [Required()])
      confirm = PasswordField('Repeat Password', [
          Required(),
          EqualTo('password', message='Passwords must match')
          ])
      accept_tos = BooleanField('I accept the TOS', [Required()])
      recaptcha = RecaptchaField()
</code></pre><p>
Первый параметр для каждого поля — его метка, например для поля </p><strong>name</strong><p> в форме задана метка </p><strong>NickName</strong><p>. Для полей ввода пароля используется валидатор </p><strong>EqualTo</strong><p>, сравнивающий данные в двух полях.
</p><p>
Более полная информация о возможностях WTForms находится </p><a href="http://wtforms.readthedocs.org/en/latest/">по этой ссылке</a><p>.

</p><h3>Представление</h3><p>
В представлении объявляется </p><strong>Blueprint</strong><p> — объект схемы модуля, в свойствах которого указывается </p><strong>url_prefix</strong><p>, который будет подставляться в начале любого URLа, указанного в </p><strong>route</strong><p>. Также в представлении используется метод формы </p><strong>form.validate_on_submit</strong><p>, выдающий истину для метода HTTP POST и валидной формы. После успешного входа пользователь перенаправляется на страницу профиля (</p><em>/users/me</em><p>). Для предотвращения доступа неавторизованных пользователей создаётся специальный декоратор в файле </p><em>/app/users/decorators.py</em><p>:

</p><pre><code>    from functools import wraps

    from flask import g, flash, redirect, url_for, request

    def requires_login(f):
      @wraps(f)
      def decorated_function(*args, **kwargs):
        if g.user is None:
          flash(u'You need to be signed in for this page.')
          return redirect(url_for('users.login', next=request.path))
        return f(*args, **kwargs)
      return decorated_function
</code></pre><p>
Данный декоратор проверяет наличие данных в переменной </p><strong>g.user</strong><p>. В случае, если переменная не задана, то пользователь не аутенфицирован, тогда задаётся информационное сообщение и осуществляется перенаправление на представление login (вход в систему). Данные в переменную </p><strong>g.user</strong><p> помещаются в функции </p><strong>before_request</strong><p>. Когда вы получаете большой объем данных из профиля пользователя (исторические данные, друзья, сообщения, действия) возможно серьезное замедление работы при обращении к БД, так что кеширование данных пользователей может решить эту проблему (но только пока вы модифицируете объекты централизованно и очищаете кеш при каждом обновлении). Ниже прилагается код представления </p><em>/app/users/views.py</em><p>:

</p><pre><code>    from flask import Blueprint, request, render_template, flash, g, session, redirect, url_for
    from werkzeug import check_password_hash, generate_password_hash

    from app import db
    from app.users.forms import RegisterForm, LoginForm
    from app.users.models import User
    from app.users.decorators import requires_login

    mod = Blueprint('users', __name__, url_prefix='/users')

    @mod.route('/me/')
    @requires_login
    def home():
      return render_template("users/profile.html", user=g.user)

    @mod.before_request
    def before_request():
      """
      pull user's profile from the database before every request are treated
      """
      g.user = None
      if 'user_id' in session:
        g.user = User.query.get(session['user_id'])

    @mod.route('/login/', methods=['GET', 'POST'])
    def login():
      """
      Login form
      """
      form = LoginForm(request.form)
      # make sure data are valid, but doesn't validate password is right
      if form.validate_on_submit():
        user = User.query.filter_by(email=form.email.data).first()
        # we use werzeug to validate user's password
        if user and check_password_hash(user.password, form.password.data):
          # the session can't be modified as it's signed, 
          # it's a safe place to store the user id
          session['user_id'] = user.id
          flash('Welcome %s' % user.name)
          return redirect(url_for('users.home'))
        flash('Wrong email or password', 'error-message')
      return render_template("users/login.html", form=form)

    @mod.route('/register/', methods=['GET', 'POST'])
    def register():
      """
      Registration Form
      """
      form = RegisterForm(request.form)
      if form.validate_on_submit():
        # create an user instance not yet stored in the database
        user = User(name=form.name.data, email=form.email.data, \
          password=generate_password_hash(form.password.data))
        # Insert the record in our database and commit it
        db.session.add(user)
        db.session.commit()

        # Log the user in, as he now has an id
        session['user_id'] = user.id

        # flash will display a message to the user
        flash('Thanks for registering')
        # redirect user to the 'home' method of the user module.
        return redirect(url_for('users.home'))
      return render_template("users/register.html", form=form)
</code></pre>
<h2>Шаблон</h2><p>
Шаблонизатор </p><strong>Jinja</strong><p> встроен в </p><strong>Flask</strong><p>. Одним из его преимуществ является возможность наследования и встроенной логики (зависимости, циклы, контекстные изменения). Создадим шаблон </p><em>/app/templates/base.html</em><p>, от которого будут наследоваться остальные шаблоны. Возможно задание более чем одного наследования (например наследование от шаблона </p><em>twocolumn.html</em><p>, который в свою очередь наслудется от </p><em>main.html</em><p>). Базовый шаблон также упрощает отображение информационных (flash) сообщений из переменной </p><strong>get_flashed_messages</strong><p> в каждом наследующем шаблоне.
</p><p>
Теперь нет необходимости задавать основную структуру страницы и каждое изменение </p><em>base.html</em><p> отразится на наследующих шаблонах. Рекомендуется называть шаблоны в соответствии с вызывающими их представлениями, именно так поименован шаблон </p><em>/app/templates/users/register.html</em><p>:

</p><pre><code>    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;{% block title %}My Site{% endblock %}&lt;/title&gt;
        {% block css %}
        &lt;link rel="stylesheet" href="/static/css/reset-min.css" /&gt;
        &lt;link rel="stylesheet" href="/static/css/main.css" /&gt;
        {% endblock %}
        {% block script %}
        &lt;script src="/static/js/main.js" type="text/javascript"&gt;&lt;/script&gt;
        {% endblock %}
      &lt;/head&gt;
      &lt;body&gt;
        &lt;div id="header"&gt;{% block header %}{% endblock %}&lt;/div&gt;
        &lt;div id="messages-wrap"&gt;
          &lt;div id="messages"&gt;
            {% for category, msg in get_flashed_messages(with_categories=true) %}
              &lt;p class="message flash-{{ category }}"&gt;{{ msg }}&lt;/p&gt;
            {% endfor %}
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div id="content"&gt;{% block content %}{% endblock %}&lt;/div&gt;
        &lt;div id="footer"&gt;{% block footer %}{% endblock %}&lt;/div&gt;
      &lt;/body&gt;
    &lt;/html&gt;
</code></pre><p>
И шаблон </p><em>/app/templates/users/login.html</em><p>:

</p><pre><code>    {% extends "base.html" %}
    {% block content %}
      {% from "forms/macros.html" import render_field %}
      &lt;form method="POST" action="." class="form"&gt;
        {{ form.csrf_token }}
        {{ render_field(form.email, class="input text") }}
        {{ render_field(form.password, class="input text") }}
        &lt;input type="submit" value="Login" class="button green"&gt;
      &lt;/form&gt;
      &lt;a href="{{ url_for('users.register') }}"&gt;Register&lt;/a&gt;
    {% endblock %}
</code></pre><p>
Созданные шаблоны используют макросы для автоматизации создания полей html. Так как этот макрос будет использоваться в различных модулях, он помещен в отдельный файл </p><em>/app/templates/forms/macros.html</em><p>:

</p><pre><code>    {% macro render_field(field) %}
        &lt;div class="form_field"&gt;
        {{ field.label(class="label") }}
        {% if field.errors %}
            {% set css_class = 'has_error ' + kwargs.pop('class', '') %}
            {{ field(class=css_class, **kwargs) }}
            &lt;ul class="errors"&gt;{% for error in field.errors %}&lt;li&gt;{{ error|e }}&lt;/li&gt;{% endfor %}&lt;/ul&gt;
        {% else %}
            {{ field(**kwargs) }}
        {% endif %}
        &lt;/div&gt;
    {% endmacro %}
</code></pre><p>
Наконец, создан примитивный шаблон </p><em>/app/templates/users/profile.html</em><p>:

</p><pre><code>   {% extends "base.html" %}
   {% block content %}
     Hi {{ user.name }}!
   {% endblock %}
</code></pre>
<h2>Инициализация приложения</h2><p>
Как несложно догадаться, инициализация приложения происходит в файле </p><em>/app/init.py</em><p>:

</p><pre><code>    import os
    import sys

    from flask import Flask, render_template
    from flask.ext.sqlalchemy import SQLAlchemy

    app = Flask(__name__)
    app.config.from_object('config')

    db = SQLAlchemy(app)

    ########################
    # Configure Secret Key #
    ########################
    def install_secret_key(app, filename='secret_key'):
        """Configure the SECRET_KEY from a file
        in the instance directory.

        If the file does not exist, print instructions
        to create it from a shell with a random key,
        then exit.
        """
        filename = os.path.join(app.instance_path, filename)

        try:
            app.config['SECRET_KEY'] = open(filename, 'rb').read()
        except IOError:
            print('Error: No secret key. Create it with:')
            full_path = os.path.dirname(filename)
            if not os.path.isdir(full_path):
                print('mkdir -p {filename}'.format(filename=full_path))
            print('head -c 24 /dev/urandom &gt; {filename}'.format(filename=filename))
            sys.exit(1)

    if not app.config['DEBUG']:
        install_secret_key(app)

    @app.errorhandler(404)
    def not_found(error):
        return render_template('404.html'), 404

    from app.users.views import mod as usersModule
    app.register_blueprint(usersModule)

    # Later on you'll import the other blueprints the same way:
    #from app.comments.views import mod as commentsModule
    #from app.posts.views import mod as postsModule
    #app.register_blueprint(commentsModule)
    #app.register_blueprint(postsModule)
</code></pre><p>
Экземпляр БД SQLAlchemy и модель Users находятся в двух разных файлах, необходимо импортировать оба из них в общее пространство имен с помощью строки </p><em>from app.users.views import mod as usersModule</em><p>. В противном случае команда </p><em>db.create_all()</em><p> не принесет результата.
</p><p>
Активируем виртуальное окружение virtualenv и инициализируем БД:

</p><pre><code>user@Machine:~/Projects/dev$ . env/bin/activate
(env)user@Machine:~/Projects/dev$ python shell.py 
&gt;&gt;&gt; from app import db
&gt;&gt;&gt; db.create_all()
&gt;&gt;&gt; exit()
</code></pre><p>
Теперь можно выполнить команду </p><em>python run.py</em><p> и получить сообщение следующего вида:

</p><pre><code>(env)user@Machine:~/Projects/dev$ python run.py 
 * Running on http://127.0.0.1:5000/
 * Restarting with reloader
</code></pre><p>
Открыв в браузере адрес </p><a href="http://127.0.0.1:500/users/me/">http://127.0.0.1:500/users/me/</a><p> вы будете перенаправлены на страницу входа и увидите ссылку на страницу регистрации.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>