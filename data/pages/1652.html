<html><body><div><span itemprop="articleBody">
    <p>
      A few weeks ago, I posted      <a href="http://www.lasolution.be/blog/../../../../blog/related-manytomanyfield-django-admin-site.html" rel="nofollow,noindex">an article about displaying related ManyToManyFields in the Django admin site</a>
      . The trick presented in that article works and was tested in Django 1.5.8 and 1.6.5 (the latest releases at the time). In the mean time, as you probably know, Django 1.7 was released as well as a security update. Using any one of those 3 releases, the trick presented in that article doesn't work as-is anymore. It requires a bit more code.    </p>
    <p>In this article, I'll give out that code and explain why it is now needed.</p>
    <div>
      <p>
        One of the features introduced in the pre-mentioned releases is a security check on admin urls to avoid manipulation by users. One of the checks is made on one of the parameters sent to popup windows triggered by the plus sign on related fields. The check is performed in the new        <em>to_field_allowed</em>
        method of the        <em>ModelAdmin</em>
        .      </p>
      <p>This method basically says whether it is ok to have a popup for this Model using the field passed as a parameter to the url. And in our case Django now replies: "No, you have no reason to have a popup for this field".</p>
    </div>
    <p>In short, the way Django currently determines whether you are allowed to have a popup for a particular model is to see whether that model is on the receiving end of a ForeignKey or a ManyToMany field. In our case we are on the emitting end of a ManyToMany field, that's why Django doesn't allow us to have a popup for our Model.</p>
    <div>
      <p>
        In my humble opinion, this is        <a href="https://code.djangoproject.com/ticket/23604" target="_blank" rel="nofollow,noindex">a regression bug</a>
        (feel free to triage if you feel up to it), but just in case I would be the only one to feel that way, here is a way to work around that:      </p>
      <p>
        What we have to do is to create a        <em>ModelAdmin</em>
        for        <em>Book</em>
        and override its        <em>to_field_allowed</em>
        method.      </p>
    </div>
    <pre class="prettyprint">#related_m2m/admin.py
# Add this import at the top of the file
from django.db.models.fields import FieldDoesNotExist
.
.
.
#Add this class
class BookAdmin(admin.ModelAdmin):

  def to_field_allowed(self, request, to_field):
    rv = super(BookAdmin, self).to_field_allowed(request, to_field)
    if not rv:
      opts = self.model._meta
      try:
        return opts.get_field(to_field)==opts.pk and len(opts.many_to_many)
      except FieldDoesNotExist:
        return False
    return rv


admin.site.register(Author, AuthorAdmin)
#update this line
admin.site.register(Book, BookAdmin)</pre>
    <p>
      What we do here is that, if the original method returns      <em>False</em>
      , we check whether or      <em>Model</em>
      is the origin of any      <em>ManyToMany</em>
      relationships. If it is, for security reasons (to keep the same spirit as the security release of Django), we check that the field passed as a parameter to the popup url is the      <em>Model</em>
      's primary key (which is always the field used for      <em>ManyToMany</em>
      relationships).    </p>
    <p>That's it for today, happy coding everyone!</p>
    <p>
      </p>
    
  </span></div></body></html>