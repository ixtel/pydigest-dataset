<html><body><div><div class="section">
              <h1>ttable 0.2</h1>

              


<p>Command line tool for Boolean algebra operations</p>









<div id="synopsis">
<h2>Synopsis</h2>
<p>tt is a command line tool for truth table and, in the future, Karnaugh Map generation.
It currently features syntax checking of Boolean equations and output of corresponding truth tables.</p>
</div>
<div id="installation">
<h2>Installation</h2>
<p>tt was developed in Python 3 and no effort has been made for compatibility with Python 2.
tt was written in pure Python, so it only requires a compatible Python installation to run.</p>
<p>You can get the latest release from PyPI. Just use:</p>
<pre>$ pip install ttable
</pre>
<p>Using this method, you can invoke tt with:</p>
<pre>$ tt
</pre>
<p>If you want to get the most up to date stable version, you can get the sources directly with:</p>
<pre>$ git clone https://github.com/welchbj/tt.git &amp;&amp; cd tt
</pre>
<p>If you install tt using the git approach, you will have to invoke it directly with Python.
This can be done with:</p>
<pre>$ python -m tt
</pre>
</div>
<div id="command-line-use">
<h2>Command Line Use</h2>
<p>All you need to specify to tt is your Boolean equation, which can be optionally
surrouded in double quotes. Right now, tt assumes that your output variable will be on the left side of your equals sign and that
the equivalent expression will be on the right side of the equals sign.</p>
<p>You can use the <tt><span class="pre">--table</span></tt> option to output a truth table of your passed equation. Omitting all options
except for the required equation will default to truth table generation, too.</p>
<p>A simple example:</p>
<pre>$ tt --table F = A and B
+---+---+---+
| A | B | F |
+---+---+---+
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |
+---+---+---+
</pre>
<p>tt can handle more complex variable names, too:</p>
<pre>$ tt --table out = operand_1 or operand_2
+-----------+-----------+-----+
| operand_1 | operand_2 | out |
+-----------+-----------+-----+
|     0     |     0     |  0  |
|     0     |     1     |  1  |
|     1     |     0     |  1  |
|     1     |     1     |  1  |
+-----------+-----------+-----+
</pre>
<p>tt can handle more complex Boolean operations and syntax, as well:</p>
<pre>$ tt --table out = (op1 xor (op2 and op3)) nand op4
+-----+-----+-----+-----+-----+
| op1 | op2 | op3 | op4 | out |
+-----+-----+-----+-----+-----+
|  0  |  0  |  0  |  0  |  1  |
|  0  |  0  |  0  |  1  |  1  |
|  0  |  0  |  1  |  0  |  1  |
|  0  |  0  |  1  |  1  |  1  |
|  0  |  1  |  0  |  0  |  1  |
|  0  |  1  |  0  |  1  |  1  |
|  0  |  1  |  1  |  0  |  1  |
|  0  |  1  |  1  |  1  |  0  |
|  1  |  0  |  0  |  0  |  1  |
|  1  |  0  |  0  |  1  |  0  |
|  1  |  0  |  1  |  0  |  1  |
|  1  |  0  |  1  |  1  |  0  |
|  1  |  1  |  0  |  0  |  1  |
|  1  |  1  |  0  |  1  |  0  |
|  1  |  1  |  1  |  0  |  1  |
|  1  |  1  |  1  |  1  |  1  |
+-----+-----+-----+-----+-----+
</pre>
<p>tt doesn’t limit you to plain English operations, either. The equation is surrounded in quotes below
to avoid escaping the | character in the terminal.:</p>
<pre>$ tt --table "F = ~(A || B) &amp;&amp; C"
+---+---+---+---+
| A | B | C | F |
+---+---+---+---+
| 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 |
| 0 | 1 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 0 | 0 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 0 |
| 1 | 1 | 1 | 0 |
+---+---+---+---+
</pre>
<p>tt provides syntax checking for your equations, too. Below are a few examples.</p>
<p>Too many equals signs:</p>
<pre>$ tt "out == A or B"
ERROR: Unexpected equals sign.
ERROR: out == A or B
ERROR:      ^
</pre>
<p>Unbalanced parentheses:</p>
<pre>$ tt --table "out = ((A and B) or C))"
ERROR: Unbalanced right parenthesis.
ERROR: ((A and B) or C))
ERROR:                 ^
</pre>
<p>Malformed equation:</p>
<pre>$ tt out = A or (B and and C)
ERROR: Unexpected operation.
ERROR: A or (B and and C)
ERROR:             ^
</pre>
</div>
<div id="development">
<h2>Development</h2>
<p>The tt development pipeline was built with all major OSes in mind, and all command line
instructions should be identical no matter what terminal or cmd prompt you’re using.
All common development tasks should have a corresponding make target (either in make.bat or the Makefile).
If you can’t find a target that you find yourself needing frequently, please feel free to add it!
Please note, though, that the two “make” files are meant to be functionally equivalent,
so please don’t change one without updating the other.</p>
<p>It is recommended that all development is done in a <a href="https://virtualenv.readthedocs.org/en/latest/userguide.html" rel="nofollow">virtualenv</a>. <a href="https://virtualenvwrapper.readthedocs.org/en/latest/" rel="nofollow">virtualenvwrapper</a> is super helpful, too.</p>
<p>Please note: All below examples are assumed to be done from within the top-level tt directory;
this is where the make files reside.</p>
<p>The dependencies for different setups of tt environments are defined in the tt\reqs directory.
For development, you can install the appropriate development packages with:</p>
<pre>$ make install-reqs
</pre>
<p>This file can easily be updated with your current environment’s installed packages with
the target:</p>
<pre>$ make write-reqs
</pre>
<p>We ask that you update the production requirements.txt manually, as there should be significantly fewer
required packages for the published releases and we want to keep the install as lean as possible.</p>
<p>Running tt’s tests is pretty easy, too. You can run all the Python unittests at once with:</p>
<pre>$ make test
</pre>
<p>Alternatively, you can invoke the Python unittest module directly to run different groups
of tests. The same three examples would be run with:</p>
<pre>$ python -m unittest discover -s tt\tests\unit
$ python -m unittest discover -s tt\tests\functional
</pre>
<p>For formatting of the code, tt tries to follow <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow">PEP8</a> closely. flake8 is used to ensure that the code complies
with this standard. Additionally, <a href="https://google.github.io/styleguide/pyguide.html" rel="nofollow">Google style</a> docstrings are used. The docstrings in tt are modelled after
the nice examples in the <a href="http://sphinxcontrib-napoleon.readthedocs.org/en/latest/example_google.html" rel="nofollow">napoleon documentation</a>.</p>
<p>tt is designed to be a thoroughly tested application. Its test are divided into two groups:</p>
<blockquote>
<ol>
<li>unit - For testing individual methods and pieces of functionality</li>
<li>functional - For simulating actual use of the application by capturing what is sent to stdout and stderr</li>
</ol>
</blockquote>
<p>The git structure of tt is pretty simple, as tt is a pretty simple application itself. Each release has its own
branch. Branch names are in the form v{major.minor}. If a branch is in a working and functional state,
it can be merged into the develop branch. Working and functional is defined as:</p>
<blockquote>
<ol>
<li>Passing all tests</li>
<li>No output from flake8</li>
</ol>
</blockquote>
<p>Once a release is completed, the develop branch will be merged into the master branch, and the master branch
will be tagged with the corresponding version, in the form release-{major}.{minor}. Following these guideleines,
any clone from the master or develop branch should yield a functioning version of tt, with master being a fully stable release.</p>
</div>
<div id="roadmap">
<h2>Roadmap</h2>
<p>Below indicates what is aimed to be included in the releases leading up to v1.0:</p>
<blockquote>
<ul>
<li><p>v0.1</p>
<blockquote>
<ol>
<li>Initial release</li>
</ol>
</blockquote>
</li>
<li><p>v0.2</p>
<blockquote>
<ol>
<li>introduce the project’s setup.py file</li>
<li>add Windows make file</li>
<li>improve requirements management, for both production and development</li>
<li>update README, in reStructuredText instead of markdown</li>
<li>introduce functional test framework</li>
<li>initial publish to PyPI</li>
</ol>
</blockquote>
</li>
<li><p>v0.3</p>
<blockquote>
<ol>
<li>introduce Karnaugh Map functionality</li>
<li>add indication of optimal groupings on Karnaugh Maps, perhaps with color via colorama</li>
<li>add –raw modifier to indicate only a plain Karnaugh Map should be output</li>
<li>port Windows make file to *nix</li>
<li>integrate with Travis CI</li>
</ol>
</blockquote>
</li>
<li><p>v.0.4</p>
<blockquote>
<ol>
<li>improve verbose output and logging</li>
<li>product-of-sum (–pos) and sum-of-product (–sop) form generation for Boolean equations</li>
<li>introduce functionality to generate logic circuit diagrams from equations</li>
</ol>
</blockquote>
</li>
</ul>
</blockquote>
</div>



<a name="downloads"> </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>29</span> downloads in the last week
  </li>
  <li>
    <span>258</span> downloads in the last month
  </li>
</ul>









            </div>


          </div></body></html>