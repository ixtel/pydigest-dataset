<html><body><div><div class="entry-content">
		<p>It’s really tempting, when you first start to use Python, to use “is” rather than “==”.  It’s a bit more readable, and it feels like it should just work, especially when you’re dealing with integers. In a language that uses “or” and “and” instead of “||” and “&amp;&amp;”, it seems logical to use “is” instead of “==”. And if you try “is” with small integers, or even with short strings, you might be lulled into thinking that you should use “is” in lots of places.</p>
<p>But you shouldn’t.  Really, in almost no case, should you use “is”; rather, you should almost certainly use “==”.  In fact, there’s only one case in which most Python programmers should be using “is”, and that’s to check to see if something is None.</p>
<p>In this blog post, which is the result of many questions and discussions I’ve had with students in my <a href="http://lerner.co.il/courses">Python classes</a>, I’m going to try to describe the reasons for this — and along the way, describe some parts of how Python’s objects are allocated, and what we mean when we say that two objects are “the same.”</p>
<p>Let’s start with the basics: Everything in Python is an object. Every object in Python has a unique ID number, which we can retrieve from an object by using the built-in “id” function:</p>
<pre>&gt;&gt;&gt; id(5)
140236457829784

&gt;&gt;&gt; id('abc')
4503718088

&gt;&gt;&gt; id([1,2,3])
4504494160</pre>
<p>Now, if two variables are pointing to the same object, they will (not surprisingly) return the same ID:</p>
<pre>&gt;&gt;&gt; x = [1,2,3]
&gt;&gt;&gt; y = x
&gt;&gt;&gt; id(x)
4504494160
&gt;&gt;&gt; id(y)
4504494160</pre>
<p>Given that x and y point to the same list, changes to the list will be reflected in both variables:</p>
<pre>&gt;&gt;&gt; x[0] = '!'
&gt;&gt;&gt; y[1] = '?'
&gt;&gt;&gt; x
['!', '?', 3]
&gt;&gt;&gt; y
['!', '?', 3]</pre>
<p>In such a case, it’s pretty clear that x and y are both pointing to precisely the same object. They aren’t just equal in value; they are one and the same — aliases for one another.</p>
<p>We can ask Python if this is true by using the “is” operator, also known as the “identity operator.” “is” doesn’t compare the values of x and y. Rather, it checks to see if x and y have the same ID. If so, then they are the same object. If not, then they aren’t. It’s as simple as that. Perhaps it goes without saying, but two objects that “is” each other are also “==” to each other, since an object’s value should be equal to itself:</p>
<pre>&gt;&gt;&gt; x == y
True

&gt;&gt;&gt; x is y
True

&gt;&gt;&gt; id(x) == id(y)
True</pre>
<p>The above code shows that x and y have the same ID. This means that they “is” each other; we’re dealing with two names for the same object. Their values are thus equal, which is what “==” checks.</p>
<p>Again: The “is” operator returns “True” if two names are referring to the same object. And the “==” operator returns “True” if two names point to objects that contain the same value.</p>
<p>The most common usage, by far, is when we want to know if something is None. True, we would use “==”. But in both readability and speed, “is None” trumps “== None”. So your code should generally say:</p>
<pre>if x is None:
    print("x is None!")</pre>
<p>It shouldn’t surprise us to find out that “is” is faster than “==”. After all, “is” is implemented in C, and is a simple comparison of the IDs of the two objects. No function call is needed, and we certainly don’t need to compare the values of the two objects, which can also take some time.</p>
<p>The use of “is None” works because the None object is a singleton in Python. No matter what you do, id(None) will always return the same value. (Note that this value won’t stay constant across different invocations of Python.)  In other words:</p>
<pre>&gt;&gt;&gt; id(None)
4315260920

&gt;&gt;&gt; id(None)
4315260920

&gt;&gt;&gt; x = None
&gt;&gt;&gt; id(x)
4315260920</pre>
<p>What happens if you try to create a new instance of None? Well, we would first have to find out None’s type:</p>
<pre>&gt;&gt;&gt; type(None)
&lt;type 'NoneType'&gt;</pre>
<p>Unfortunately, NoneType isn’t a defined identifier in Python:</p>
<pre>&gt;&gt;&gt; NoneType
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'NoneType' is not defined</pre>
<p>So if we want to create a new instance of None, we’ll need to do it ourselves:</p>
<pre>&gt;&gt;&gt; type(None)()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: cannot create 'NoneType' instances</pre>
<p>Aha.  Well, that’s a shame. But I was using Python 2.7 in the above example. What if I try Python 3?</p>
<pre>&gt;&gt;&gt; type(None)
&lt;class 'NoneType'&gt;

&gt;&gt;&gt; NoneType()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'NoneType' is not defined

&gt;&gt;&gt; x = type(None)()
&gt;&gt;&gt; type(x)
&lt;class 'NoneType'&gt;
&gt;&gt;&gt; x is None
True</pre>
<p>So no matter how you slice it, None is a singleton. Which is why you can (and should) use “is None”, rather than “== None”, in your code.</p>
<p>But what happens if you decide that you want to use “is” in other places? The problem is that it will sometimes work. That “sometimes” is because “is” exposes some of Python’s internal optimizations in ways that can be a bit surprising.</p>
<p>Strings are how I was initially introduced to the difference between “==” and “is”, and the danger of using “is” over-zealously. Two equal strings should be “==”, but are they “is”?</p>
<pre>&gt;&gt;&gt; x = 'a' * 5
&gt;&gt;&gt; y = 'a' * 5
&gt;&gt;&gt; x == y
True
&gt;&gt;&gt; x is y
True</pre>
<p>Well, that’s interesting — and I got the same result in Python 2.7, 3.4, and also in PyPy. But why should this be the case? One possibility is that strings are immutable, and that having Python use a single object for each string that we create, would be efficient. And indeed, this is true — so long as the string is short:</p>
<pre>&gt;&gt;&gt;&gt; x = 'a' * 5000
&gt;&gt;&gt;&gt; y = 'a' * 5000
&gt;&gt;&gt;&gt; x == y
True
&gt;&gt;&gt;&gt; x is y
False</pre>
<p>The above, which works the same in Python 2.7, 3.4, and in PyPy, demonstrates that Python won’t reuse just any string that we have created. There is a limit.  I experimented with things a bit, and I found that 21 is the magic length at which strings are no longer “is” to one another. That is:</p>
<pre>&gt;&gt;&gt; x = 'a' * 20
&gt;&gt;&gt; y = 'a' * 20
&gt;&gt;&gt; x is y
True

&gt;&gt;&gt; x = 'a' * 21
&gt;&gt;&gt; y = 'a' * 21
&gt;&gt;&gt; x is y
False</pre>
<p>The above was true in Python 2.7 and 3.4, and also in PyPy. However, I also found some seemingly weird behavior, which is undoubtedly because of the way in which Python byte-compiles and then executes for loops:</p>
<pre>&gt;&gt;&gt; for i in range(15,25):
        x = 'a' * i
        y = 'a' * i
        print("[{0}] x is y: {1}".format(i, x is y))

[15] x is y: False
[16] x is y: False
[17] x is y: False
[18] x is y: False
[19] x is y: False
[20] x is y: False
[21] x is y: False
[22] x is y: False
[23] x is y: False
[24] x is y: False</pre>
<p>Wow, that’s kind of strange, no? Indeed, in a for loop, I found that the only number for which the two strings were “is” to one another was 1:</p>
<pre>&gt;&gt;&gt; for i in range(0,10):
...     x = 'a' * i
...     y = 'a' * i
...     print("[{0}] x is y: {1}".format(i, x is y))
...
[0] x is y: False
[1] x is y: True
[2] x is y: False
[3] x is y: False
[4] x is y: False
[5] x is y: False
[6] x is y: False
[7] x is y: False
[8] x is y: False
[9] x is y: False</pre>
<p>At the same time, if you create a long literal string and assign it to a variable, you’ll likely find that the strings are “is” to one another:</p>
<pre>&gt;&gt;&gt; x = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'

&gt;&gt;&gt; y = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'

&gt;&gt;&gt; x is y
True</pre>
<p>(Forgive the re-formatting that WordPress did to the above assignments; in Python, they were both on one line.)</p>
<p>I’m not sure what is going on here, but it just goes to show that you really shouldn’t use “is” unless you know what you’re doing.  And even if you think that you know what you’re doing, you might still be surprised!  Bottom line: Using “is” on strings is almost always a bad idea.</p>
<p>Now, this is generally something that we don’t need to think or care about very much. But let’s say that you’re working with large strings, and that these strings might repeat themselves on occasion. In such a case, you will end up with many copies of the same string. Python helps us to solve this problem by “interning” strings. <a href="https://en.wikipedia.org/wiki/String_interning">Interning</a> is a technique that has been around for many years in the programming world, which allows us to store only one copy of any given string. In Python 2, we use the built-in “intern” function. In Python 3, we must use sys.intern; intern is no longer a builtin.</p>
<p>“intern” takes a string (and only a string) as a parameter. It returns a reference — either to a new string that was created, or to a string that was already allocated. Thus, the length of the string doesn’t matter; even in the case of a long string, it will only be allocated a single time:</p>
<pre>&gt;&gt;&gt; from sys import intern     # Python 3 only
&gt;&gt;&gt; x = intern('a' * 5000)
&gt;&gt;&gt; y = intern('a' * 5000)
&gt;&gt;&gt; x is y
True</pre>
<p>As you can see, using “intern” guarantees that every unique string is allocated only once. If you use “intern” on the same string a second time, Python returns a reference to the first string.</p>
<p>Python uses “intern” internally for a variety of purposes.  If you’re working with long strings that repeat themselves, then it might be worth using intern. But for the most part, Python creates and allocates so many objects that a few strings here and there are probably not going to make a difference.    Certainly, you should only use “intern” once you have identified bottlenecks.</p>
<p>You might think that even if strings are allocated multiple times, and are thus not “is” to one another, at least integers are going to be identical. After all, Python wouldn’t allocate new objects for numbers, would it?</p>
<p>We can test this pretty easily, of course:</p>
<pre>&gt;&gt;&gt; x = 200
&gt;&gt;&gt; y = 200
&gt;&gt;&gt; x is y
True</pre>
<p>Well, that’s encouraging, right?  Let’s try something bigger:</p>
<pre>&gt;&gt;&gt; x = 2000
&gt;&gt;&gt; y = 2000
&gt;&gt;&gt; x is y
False</pre>
<p>So yes, it turns out that even integers that are equal aren’t necessarily pointing to the same object.   As Amy Hanlon pointed out in <a href="http://dailytechvideo.com/video-181-amy-hanlon-investigating-python-wats/">her fantastic talk about Python “wats”,</a> this is because Python pre-allocates a number of integers. If your integer is within that range, then they will use the same object, and be “is” to one another. But if you’re outside of that range, then you’ll have two separate objects. Unless, of course, you allocate them in the same line of code:</p>
<pre>&gt;&gt;&gt; x = 2000; y = 2000
&gt;&gt;&gt; x is y
True</pre>
<p>Have I mentioned that you really shouldn’t use “is” to compare objects except for None? I hope that you’re increasingly convinced.</p>
<p>I’ll close this post with a bit of mischief: In theory, if two objects are “is”, then they’re pointing to the same object — which means that they should be identical to one another, and thus also give us a True response to “==”.  While Python doesn’t allow us to redefine “is”, we can redefine what an object says when we try to compare with using “==”:</p>
<pre>&gt;&gt;&gt; class Foo(object):
...     def __eq__(self, other):
...         return False
...
&gt;&gt;&gt; f1 = Foo()
&gt;&gt;&gt; f2 = f1
&gt;&gt;&gt; f1 is f2
True
&gt;&gt;&gt; f1 == f2
False</pre>
<p>I cannot think of a situation in which this would be a desirable thing to do. But it’s fun, and allows us to sharpen our understanding of the difference between “==” and “is”.</p>
<p>If you liked this explanation, then you’ll likely also enjoy my ebook, “<a href="http://practicemakespython.com/">Practice Makes Python</a>,” with 50 exercises meant to improve your Python fluency.</p>
	</div>

	
	</div></body></html>