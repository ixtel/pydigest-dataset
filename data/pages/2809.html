<html><body><div><article id="s7xCi2IxYbsmn9GBghNg" class="post  historical">
	<time datetime="2015-01-18" class="article_time">January 18, 2015</time>
  
	<p>Python functions are either named or <em>anonymous</em> set of statements or expressions. In python, <strong><em>functions are first class objects</em></strong>. This means that there is no restriction on the usage of functions. Python functions can be used just like any other python value such as strings and numbers.  Python functions have attributes that can be introspected on using the inbuilt python <a href="https://docs.python.org/2/library/functions.html#dir" rel="nofollow"><code class="prettyprint">dir</code></a> function as shown below:</p>

<pre><code class="prettyprint lang-python">def square(x):
    return x**2

&gt;&gt;&gt; square
&lt;function square at 0x031AA230&gt;
&gt;&gt;&gt; dir(square)
['__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__doc__', '__format__', '__get__', '__getattribute__', '__globals__', '__hash__', '__init__', '__module__', '__name__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'func_closure', 'func_code', 'func_defaults', 'func_dict', 'func_doc', 'func_globals', 'func_name']
&gt;&gt;&gt; 
</code></pre>

<p>Some important function attributes include:</p>

<ul>
<li>
<code class="prettyprint">__doc__</code> returns the documentation string for the given function.</li>
</ul>

<pre><code class="prettyprint lang-python">def square(x):
    """return square of given number"""
    return x**2

&gt;&gt;&gt; square.__doc__
'return square of given number'
</code></pre>

<ul>
<li>
<code class="prettyprint">__name__</code> returns function name.</li>
</ul>

<pre><code class="prettyprint lang-python">def square(x):
    """return square of given number"""
    return x**2

&gt;&gt;&gt; square.func_name
'square'
</code></pre>

<ul>
<li>
<code class="prettyprint">__module__</code> returns the name of module function is defined in.</li>
</ul>

<pre><code class="prettyprint lang-python">def square(x):
    """return square of given number"""
    return x**2

&gt;&gt;&gt; square.__module__
'__main__'
</code></pre>

<ul>
<li>
<code class="prettyprint">func_defaults</code> returns a tuple of the default argument values. Default arguments are discussed later on.</li>
<li>
<code class="prettyprint">func_globals</code>  returns a reference to the dictionary that holds the function’s global variables.</li>
</ul>

<pre><code class="prettyprint lang-python">def square(x):
    """return square of given number"""
    return x**2

&gt;&gt;&gt; square.func_globals
{'__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__name__': '__main__', 'square': &lt;function square at 0x10f099c08&gt;, '__doc__': None, '__package__': None}
</code></pre>

<ul>
<li>
<code class="prettyprint">func_dict</code> returns the namespace supporting arbitrary function attributes.<br/>
</li>
</ul>

<pre><code class="prettyprint lang-python">def square(x):
    """return square of given number"""
    return x**2

&gt;&gt;&gt; square.func_dict
{}
</code></pre>

<ul>
<li>
<code class="prettyprint">func_closure</code> returns tuple of cells that contain bindings for the function’s free variables. Closures are discussed later on.</li>
</ul>

<p>Functions can be passed around as arguments to other functions. These functions that take other functions as argument are commonly referred to as <strong><em>higher order</em></strong> functions and these form a very important part of <strong><em>functional programming</em></strong>. A very good example of this higher order functions  is the <a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow"><code class="prettyprint">map</code></a> function that takes a <em>function</em> and an <code class="prettyprint">iterable</code> and applies the <em>function</em> to each item in the <code class="prettyprint">iterable</code> returning a new list. In the example below we illustrate this by passing the <code class="prettyprint">square</code> function previously defined and an <code class="prettyprint">iterable</code> of numbers to the <code class="prettyprint">map</code> function.</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; map(square, range(10))
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>

<p>Functions can also be defined inside other function code blocks and can be returned from other function calls. </p>

<pre><code class="prettyprint lang-python">def outer():
    outer_var = "outer variable"
    def inner():
        return outer_var
    return inner
</code></pre>

<p>In the above example, we define a function, <code class="prettyprint">inner</code> within another function, <code class="prettyprint">outer</code> and return the <code class="prettyprint">inner</code> function when the <code class="prettyprint">outer</code> function is executed. Functions can also be assigned to variables just like any other python object as shown below: </p>

<pre><code class="prettyprint lang-python">def outer():
    outer_var = "outer variable"
    def inner():
        return outer_var
    return inner

&gt;&gt;&gt; func = outer()
&gt;&gt;&gt; func
&lt;function inner at 0x031AA270&gt;
&gt;&gt;&gt; 
</code></pre>

<p>In the above example, the <code class="prettyprint">outer</code> function returns a function when called and this is assigned to the variable <code class="prettyprint">func</code>. This variable can be called just like the returned function:</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; func()
'outer variable'
</code></pre>
<h1 id="function-definitions_1">
<a class="head_anchor" href="#function-definitions_1" rel="nofollow"> </a>Function Definitions</h1>
<p>The <code class="prettyprint">def</code> keyword is used to create user-defined functions. Functions definitions are executable statements. </p>

<pre><code class="prettyprint lang-python">def square(x):
    return x**2
</code></pre>

<p>In the <code class="prettyprint">square</code> function above, when the module containing the function is loaded into python interpreter or if it is defined within the python <strong>REPL</strong> then the function definition statement which is <code class="prettyprint">def square(x)</code> is executed. <br/>
This has some implications for default arguments that have mutable data structure as values; this will covered later on in this tutorial. The execution of a function definition binds the function name in the current local namespace <em>(think of namespaces as name to value mappings that can also be nested. namespaces and scopes are covered in more detail in another tutorial)</em> to a function object which is a wrapper around the executable code for the function. This function object contains a reference to the current global namespace which is the global namespace that is used when the function is called. The function definition does not execute the function body; this gets executed only when the function is called. </p>
<h1 id="function-call-arguments_1">
<a class="head_anchor" href="#function-call-arguments_1" rel="nofollow"> </a>Function Call Arguments</h1>
<p>In addition to normal arguments, python functions support variable number of arguments. These variable number of arguments come in three flavors that are described below:</p>

<ul>
<li>
<p><strong>Default Argument Values</strong>: This allows a user to define some default<br/><br/>
values for function arguments. In this case, such a function can be called<br/><br/>
with fewer arguments. Python uses the default supplied values for<br/><br/>
arguments that are not supplied during function call. This example below <br/>
is illustrative:</p>

<pre><code class="prettyprint lang-python">  def show_args(arg, def_arg=1, def_arg2=2):
      return "arg={}, def_arg={}, def_arg2={}".format(arg, def_arg, def_arg2)
</code></pre>

<p>The above function has been defined with a single normal positional<br/><br/>
argument, <code class="prettyprint">arg</code> and two default arguments, <code class="prettyprint">def_arg</code> and <br/>
<code class="prettyprint">def_arg2</code>. The above function can be called in any of the following <br/>
ways below:</p>

<ul>
<li>
<p>Supplying non-default positional argument values only; in this case the<br/>
other arguments take on the supplied default values:</p>

<pre><code class="prettyprint lang-python">  def show_args(arg, def_arg=1, def_arg2=2):
      return "arg={}, def_arg={}, def_arg2={}".format(arg, def_arg, def_arg2)

  &gt;&gt;&gt; show_args("tranquility")
  'arg=tranquility, def_arg=1, def_arg2=2'
</code></pre>
</li>
<li>
<p>Supplying values to override some default arguments in addition to the <br/>
non-default positional arguments:</p>

<pre><code class="prettyprint lang-python">  def show_args(arg, def_arg=1, def_arg2=2):
      return "arg={}, def_arg={}, def_arg2={}".format(arg, def_arg, def_arg2)

  &gt;&gt;&gt; show_args("tranquility", "to Houston")
  'arg=tranquility, def_arg=to Houston, def_arg2=2'
</code></pre>
</li>
<li>
<p>Supplying values for all arguments overriding even arguments with default values.</p>

<pre><code class="prettyprint lang-python">  def show_args(arg, def_arg=1, def_arg2=2):
      return "arg={}, def_arg={}, def_arg2={}".format(arg, def_arg, def_arg2)

   &gt;&gt;&gt; show_args("tranquility", "to Houston", "the eagle has landed")
'arg=tranquility, def_arg=to Houston, def_arg2=the eagle has landed'
</code></pre>

<p>It is also very important to be careful when using mutable default data structures as default arguments. Function definitions get executed only once so these mutable data structures which are reference values are created once at definition time. This means that the same mutable data structure is used for all function calls as shown below:</p>

<pre><code class="prettyprint lang-python">  def show_args_using_mutable_defaults(arg, def_arg=[]):
      def_arg.append("Hello World")
      return "arg={}, def_arg={}".format(arg, def_arg)

  &gt;&gt;&gt; show_args_using_mutable_defaults("test")
  "arg=test, def_arg=['Hello World']" 
  &gt;&gt;&gt; show_args_using_mutable_defaults("test 2")
  "arg=test 2, def_arg=['Hello World', 'Hello World']"
</code></pre>

<p>On every function call, <code class="prettyprint">Hello World</code> is added to the <code class="prettyprint">def_arg</code> list and <br/>
after two function calls the default argument has two hello world <br/>
strings.    It is important to take note of this when using mutable default <br/>
arguments as default values. The reason for this will become clearer <br/>
when we discuss the python data model.</p>
</li>
</ul>
</li>
</ul>

<ul>
<li>
<p><strong>Keyword Argument</strong>: Functions can be called using keyword<br/><br/>
arguments of the form <code class="prettyprint">kwarg=value</code>. A <code class="prettyprint">kwarg</code> refers to the name of <br/>
arguments used in a function definition. Take the function defined below <br/>
with positional non-default and default arguments.</p>

<pre><code class="prettyprint lang-python">  def show_args(arg, def_arg=1):
       return "arg={}, def_arg={}".format(arg, def_arg)
</code></pre>

<p>To illustrate  function calls with key word arguments, the following function can be called in any of the following ways:</p>

<pre><code class="prettyprint lang-python">show_args(arg="test", def_arg=3)
</code></pre>

<pre><code class="prettyprint lang-python">show_args(test)
</code></pre>

<pre><code class="prettyprint lang-python">show_args(arg="test")
</code></pre>

<pre><code class="prettyprint lang-python">show_args("test", 3)
</code></pre>

<p>In a function call, keyword arguments must not come before non-keyword arguments thus the following will fail:</p>

<pre><code class="prettyprint lang-python">show_args(def_arg=4)
</code></pre>

<p>A function cannot supply duplicate values for an argument so the<br/>
following is illegal:</p>

<pre><code class="prettyprint lang-python">show_args("test", arg="testing")
</code></pre>

<p>In the above the argument <code class="prettyprint">arg</code> is a positional argument so the value<br/><br/>
<code class="prettyprint">test</code> is assigned to it. Trying to assign to the keyword <code class="prettyprint">arg</code>  again<br/><br/>
 is an attempt at multiple assignment and this is illegal.</p>

<p>All the keyword arguments passed must match one of the arguments <br/>
accepted by the function and the order of keywords including <br/>
non-optional arguments is not important so the following in which the <br/>
order of argument is switched is legal:</p>

<pre><code class="prettyprint lang-python">show_args(def_arg="testing", arg="test")
</code></pre>
</li>
<li>
<p><strong>Arbitrary Argument List</strong>: Python also supports defining functions that<br/>
take arbitrary number of arguments that are passed to the function in a<br/><br/>
tuple. An example of this from the python tutorial is given below:</p>

<pre><code class="prettyprint lang-python">def write_multiple_items(file, separator, *args): 
    file.write(separator.join(args))
</code></pre>

<p>The arbitrary number of arguments must come after normal arguments; <br/>
in this case, after the <code class="prettyprint">file</code> and <code class="prettyprint">separator</code> arguments. The following <br/>
is an example of function calls to the above defined function:</p>

<pre><code class="prettyprint lang-python">f = open("test.txt", "wb")
write_multiple_items(f, " ", "one", "two", "three", "four", "five")
</code></pre>

<p>The arguments <code class="prettyprint">one two three four five</code> are all bunched together into<br/>
a tuple that can be accessed via the <code class="prettyprint">args</code> argument.</p>
</li>
</ul>
<h2 id="unpacking-function-argument_2">
<a class="head_anchor" href="#unpacking-function-argument_2" rel="nofollow"> </a>Unpacking  Function Argument </h2>
<p>Sometimes, we may have arguments for a function call either in a tuple, a list or a dict. These arguments can be unpacked into functions for function calls using <code class="prettyprint">*</code> or <code class="prettyprint">**</code> operators. Consider the following function that takes two positional arguments and prints out the values</p>

<pre><code class="prettyprint lang-python">def print_args(a, b):
    print a
    print b
</code></pre>

<p>If we had the values we wanted to supply to the function in a list then we could unpack these values directly into the function as shown below:</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; args = [1, 2]
&gt;&gt;&gt; print_args(*args)
1
2
</code></pre>

<p>Similarly, when we have keywords,  we can use <code class="prettyprint">dicts</code> to store <code class="prettyprint">kwarg to value</code> mapping and the <code class="prettyprint">**</code> operator to unpack the keyword arguments to the functions as shown below:</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; def parrot(voltage, state=’a stiff’, action=’voom’):
           print "-- This parrot wouldn’t", action,
           print "if you put", voltage, "volts through it.",
           print "E’s", state, "!"

&gt;&gt;&gt; d = {"voltage": "four million", "state": "bleedin’ demised", "action": "VOOM"}
&gt;&gt;&gt; parrot(**d)
&gt;&gt;&gt; This parrot wouldn’t VOOM if you put four million volts through it. E’s bleedin’ demised
</code></pre>
<h2 id="defining-functions-with-code-classprettyprint_2">
<a class="head_anchor" href="#defining-functions-with-code-classprettyprint_2" rel="nofollow"> </a>Defining Functions with <code class="prettyprint">*</code> and <code class="prettyprint">**</code>
</h2>
<p>Sometimes, when defining a function, we may not know before hand the number of arguments to expect. This leads to function definitions of the following signature:</p>

<pre><code class="prettyprint lang-python">show_args(arg, *args, **kwargs)
</code></pre>

<p>The <code class="prettyprint">*args</code> argument represents an unknown length of sequence of positional arguments while <code class="prettyprint">**kwargs</code> represents a dict of keyword name value mappings which may contain any amount of keyword name value mapping. The <code class="prettyprint">*args</code> must come before <code class="prettyprint">**kwargs</code> in the function definition. The following illustrates this:</p>

<pre><code class="prettyprint lang-python">def show_args(arg, *args, **kwargs):
    print arg
    for item in args:
        print args
    for key, value in kwargs:
        print key, value

&gt;&gt;&gt; args = [1, 2, 3, 4]
&gt;&gt;&gt; kwargs = dict(name='testing', age=24, year=2014)
&gt;&gt;&gt; show_args("hey", *args, **kwargs)
hey
1
2
3
4
age 24
name testing
year 2014
</code></pre>

<p>The normal argument must be supplied to the function but the <code class="prettyprint">*args</code> and <code class="prettyprint">**kwargs</code> are optional as shown below:</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; show_args("hey", *args, **kwargs)
hey
</code></pre>

<p>At function call the normal argument is supplied normally while the optional arguments are unpacked into the function call. </p>
<h1 id="anonymous-functions_1">
<a class="head_anchor" href="#anonymous-functions_1" rel="nofollow"> </a>Anonymous Functions</h1>
<p>Python also has support for <strong><em>anonymous functions</em></strong>. These functions are created using the <code class="prettyprint">lambda</code> keyword.  Lambda expressions in python are of the form:</p>

<pre><code class="prettyprint lang-python">lambda_expr ::=  "lambda" [parameter_list]: expression
</code></pre>

<p>Lambda expressions return function objects after evaluation and have same attributes as named functions. Lambda expressions are normally only used for very simple functions in python as shown below.</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; square = lambda x: x**2
&gt;&gt;&gt; for i in range(10):
    square(i)
0
1
4
9
16
25
36
49
64
81
&gt;&gt;&gt; 
</code></pre>

<p>The above lambda expression is equivalent to the following named function:</p>

<pre><code class="prettyprint lang-python">def square(x):
    return x**2
</code></pre>
<h1 id="nested-functions-and-closures_1">
<a class="head_anchor" href="#nested-functions-and-closures_1" rel="nofollow"> </a>Nested functions and Closures</h1>
<p>Function definitions within a function creates nested functions just as shown below:</p>

<pre><code class="prettyprint">```python
   def outer():
       outer_var = "outer variable"
       def inner():
           return outer_var
        return inner
```
</code></pre>

<p>In this type of function definition, the function <code class="prettyprint">inner</code> is only in scope inside the function <code class="prettyprint">outer</code>, so it is most often useful when the inner function is being returned (moving it to the outer scope) or when it is being passed into another function.<br/>
In nested functions such as in the above, a new instance of the nested function is created on each call to outer function. That is because during each execution of the outer function the definition of the new inner function is executed but the body is not executed. </p>

<p>A nested function has access to the environment in which it was created. This is a direct result of the semantics of python function definition. A result is that a variable defined in the outer function can be referenced in the inner function even after the outer functions has finished execution.</p>

<pre><code class="prettyprint lang-python">def outer():
    outer_var = "outer variable"
    def inner():
        return outer_var
    return inner

&gt;&gt;&gt; x = outer()
&gt;&gt;&gt; x
&lt;function inner at 0x0273BCF0&gt;
&gt;&gt;&gt; x()
'outer variable'
</code></pre>

<p>When nested functions reference variables from outer functions we say the nested function is closed over the referenced variable. <br/>
We can use one of the special attribute of function objects, <code class="prettyprint">__closure__</code> to access the closed variables as shown below:</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; cl = x.__closure__
&gt;&gt;&gt; cl
(&lt;cell at 0x029E4470: str object at 0x02A0FD90&gt;,)

&gt;&gt;&gt; cl[0].cell_contents
'outer variable'
</code></pre>

<p>Closures in python have a quirky behavior. In python 2.x and below, variables that point to immutable types such as string and numbers cannot be rebound within a closure. The example below illustrates this</p>

<pre><code class="prettyprint lang-python">def counter():
    count = 0
    def c():
        count += 1
        return count
    return c

&gt;&gt;&gt; c = counter()
&gt;&gt;&gt; c()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 4, in c
UnboundLocalError: local variable 'count' referenced before assignment
</code></pre>

<p>A rather wonky solution to this is to make use of a mutable type to capture the closure as shown below:</p>

<pre><code class="prettyprint lang-python">def counter():
    count = [0]
    def c():
        count[0] += 1
        return count[0]
    return c

&gt;&gt;&gt; c = counter()
&gt;&gt;&gt; c()
1
&gt;&gt;&gt; c()
2
&gt;&gt;&gt; c()
3
</code></pre>

<p>Python 3 introduces the <code class="prettyprint">nonlocal</code> key word that can be used to fix this closure scoping issue as shown below. In the tutorial on <strong>namespaces</strong>, we describe these quirks in more details.</p>

<pre><code class="prettyprint lang-python">   def counter():
       count = 0
       def c():
           nonlocal count
           count += 1
           return count
        return c
</code></pre>

<p>Closures can be used for maintaining states <strong><em>(isn’t that what classes are for)</em></strong> and for some simple cases provide a more succinct and readable solution than classes. We use a logging example curled from <a href="http://tech.pro/tutorial/1512/python-decorators" rel="nofollow">tech_pro</a> to illustrate this. Imagine an extremely trivial logging API using class-based object orientation that can log at different levels:</p>

<pre><code class="prettyprint lang-python">class Log:
    def __init__(self, level):
        self._level = level

    def __call__(self, message):
        print("{}: {}".format(self._level, message))

log_info = Log("info")
log_warning = Log("warning")
log_error = Log("error")
</code></pre>

<p>This same functionality can be implemented with closures as shown below:</p>

<pre><code class="prettyprint lang-python">def make_log(level):
    def _(message):
        print("{}: {}".format(level, message))
    return _

log_info = make_log("info")
log_warning = make_log("warning")
log_error = make_log("error")
</code></pre>

<p>The closure based version as can be seen is way more succinct and readable even though both versions implement exactly the same functionality. Closures also play a major role in a major python function, <strong><em>function decorators</em></strong>. This is a very widely used functionality that is explained in the next tutorial.</p>

<p><em>Did you spot any error, issue or have you got a topic you would like me to write about? Contact me on twitter using my handle @obi_inc</em></p>
<h1 id="further-reading_1">
<a class="head_anchor" href="#further-reading_1" rel="nofollow"> </a>Further Reading</h1>
<p><a href="http://tech.pro/tutorial/1512/python-decorators" rel="nofollow">Closures in Python</a></p>

<p><a href="https://docs.python.org/2/tutorial/controlflow.html#defining-functions" rel="nofollow">Defining Functions</a></p>

  <figure class="postend kudo able clearfix" id="kudo_s7xCi2IxYbsmn9GBghNg">
    <a href="#kudo">
      <p class="filling"> </p>
    </a>
    <p class="num">429</p>
    <p class="txt">Kudos</p>
  </figure>
  <figure class="side kudo able clearfix" id="kudo_side_s7xCi2IxYbsmn9GBghNg">
    <a href="#kudo">
      <p class="filling"> </p>
    </a>
    <p class="num">429</p>
    <p class="txt">Kudos</p>
  </figure>
</article>

</div></body></html>