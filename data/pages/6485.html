<html><body><div><div class="entry-content">
		<p><a href="https://pypi.python.org/pypi/filedepot">DEPOT</a> is a file storage and retrieval framework we created to solve the need of switching different storage systems when deploying in different environments. We wanted a unique and cohesive API that made possible to keep storing files the same way independently from where they were actually stored.</p>
<p>As systems evolve and change during time we also wanted the ability to switch those storages whenever required without breaking past files or changing any code. That lead to various features of DEPOT that specifically pointed this problem, the last of this list is the new <em>Storage Aliases</em> support.</p>
<p>If you used a single storage, <strong>myfiles</strong>, registered as the default one, when you wanted to switch from <em>Local Storage</em> to <em>S3</em> that was easy, you could register a new <strong>mys3files</strong> storage on S3 and switch the default one to be that one. Your old files would continue to be served from the old storage and your new files would be uploaded and served from the new storage, because the system knew that some files were saved in <strong>myfiles</strong> and some were on <strong>mys3files</strong>.</p>
<p>Now, suppose you want to keep your user avatars on a separated storage from their uploaded content. You could already declare an <strong>avatars</strong> storage and just force upload of all your files on that specific storage</p>
<pre>
from depot.fields.sqlalchemy import UploadedFileField

class User(Base):
    __tablename__ = 'users'

    uid = Column(Integer, autoincrement=True, primary_key=True)
    name = Column(Unicode(16), unique=True)

    avatar = Column(UploadedFileField(upload_storage='avatars'))
</pre>
<p>This would correctly store all your user avatars on the <em>avatars</em> storage. But what happened when you wanted to switch your avatars storage from saving files on disk to saving them on S3?</p>
<p>Because in this case DEPOT knew that all your avatars were on the <strong>avatars</strong> storage, you had to put your system on maintenance, manually move all the files on S3, switch the avatars storage configuration and then restart your application. This lead to downtime and wasn’t very convenient.</p>
<p>Introducing the new <a href="http://depot.readthedocs.org/en/latest/userguide.html?highlight=alias#replacing-a-storage-through-aliases" title="Aliases">Aliases</a> feature you can now declare two different storages</p>
<pre>
DepotManager.configure('local_avatars', {'depot.storage_path': '/var/www/lfs'})
DepotManager.configure('s3_avatars', {'depot.backend': 'depot.io.awss3.S3Storage', 'depot.access_key_id': ...})
</pre>
<p>tell DEPOT that <strong>avatars</strong> is just an alias for <strong>local_avatars</strong></p>
<pre>
DepotManager.alias('avatars', 'local_avatars')
</pre>
<p>and whenever you stored a file on <strong>avatars</strong> it would actually be stored on <strong>local_avatars</strong>.</p>
<p>Want now to switch storing your files on S3? Just switch the alias configuration</p>
<pre>
DepotManager.alias('avatars', 's3_avatars')
</pre>
<p>And all your avatars will now be stored on S3 while the old one continue to be served from the disk as DEPOT knows they are actually on <strong>local_avatars</strong>.</p>
<p>This is a pretty simple and convenient solution that perfectly solved our need introducing the ability to evolve your storages forever as far as you only stored files on aliases and never directly on the storages themselves.</p>
			</div>

	</div></body></html>