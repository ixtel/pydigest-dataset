<html><body><div><div class="comment-body markdown-body markdown-format js-comment-body">
          <p>Today <a href="https://github.com/shoyer" class="user-mention">@shoyer</a> and I were talking about a new "protocol" that will let us sidestep the whole macro / method chaining issue.  The basic idea is that pandas objects define a <code>pipe</code> method (ideally other libraries will implement this to, assuming this is useful).</p>

<p>Based on the discussions below, we're leaning towards a method like</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">pipe</span>(<span class="pl-smi"><span class="pl-smi">self</span></span>, <span class="pl-smi">func</span>, <span class="pl-k">*</span><span class="pl-smi">args</span>, <span class="pl-k">**</span><span class="pl-smi">kwargs</span>):
    pipe_func <span class="pl-k">=</span> <span class="pl-c1">getattr</span>(func, <span class="pl-s"><span class="pl-pds">'</span>__pipe_func__<span class="pl-pds">'</span></span>, func)
    <span class="pl-k">return</span> pipe_func(<span class="pl-v">self</span>, <span class="pl-k">*</span>args, <span class="pl-k">**</span>kwargs)</pre></div>

<p>That's it. This lets you write code like:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> seaborn <span class="pl-k">as</span> sns

(sns.load_dataset(<span class="pl-s"><span class="pl-pds">'</span>iris<span class="pl-pds">'</span></span>)
    .query(<span class="pl-s"><span class="pl-pds">"</span>sepal_length &gt; 5<span class="pl-pds">"</span></span>)
    .assign(<span class="pl-v">sepal_ratio</span> <span class="pl-k">=</span> <span class="pl-k">lambda</span> <span class="pl-smi">df</span>: df.sepal_length <span class="pl-k">/</span> df.sepal_width)
    .pipe(<span class="pl-k">lambda</span> <span class="pl-smi">df</span>: sns.violinplot(<span class="pl-v">x</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>species<span class="pl-pds">'</span></span>, <span class="pl-v">y</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>sepal_ratio<span class="pl-pds">'</span></span>, <span class="pl-v">data</span><span class="pl-k">=</span>df))
)</pre></div>

<p>seaborn didn't have to do anything! If the DataFrame is the first argument to the function, things are even simpler:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">f</span>(<span class="pl-smi">x</span>):
    <span class="pl-k">return</span> x <span class="pl-k">/</span> <span class="pl-c1">2</span>

df[<span class="pl-s"><span class="pl-pds">'</span>sepal_length<span class="pl-pds">'</span></span>].pipe(f)</pre></div>

<p>Users or libraries can work around the need for the (somewhat ugly) <code>lambda _:</code>, by using the <code>__pipe_func__</code>  attribute of the function being <code>pipe</code>d in. This is where a protocol (de facto or official) would be useful, since libraries that know nothing else about each other can rely on it. As an example, consider seaborn's violin plot, which expects a DataFrame as its fourth argument, <code>data</code>. Seaborn can define a simple decorator to attach a <code>__pipe_func__</code> attribute, allowing <em>it</em> to define how it expects to be <code>pipe</code>d to. </p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">pipeable</span>(<span class="pl-smi">func</span>):
    <span class="pl-k">def</span> <span class="pl-en">pipe_func</span>(<span class="pl-smi">data</span>, <span class="pl-k">*</span><span class="pl-smi">args</span>, <span class="pl-k">**</span><span class="pl-smi">kwargs</span>):
        <span class="pl-k">return</span> func(<span class="pl-k">*</span>args, <span class="pl-v">data</span><span class="pl-k">=</span>data, <span class="pl-k">**</span>kwargs)
    func.__pipe_func__ <span class="pl-k">=</span> pipe_func
    <span class="pl-k">return</span> func

<span class="pl-c"># now we decorate all the Seaborn methods as pipeable</span>

<span class="pl-en">@pipeable</span>
<span class="pl-k">def</span> <span class="pl-en">violinplot</span>(<span class="pl-smi">x</span><span class="pl-k">=</span><span class="pl-c1">None</span>, <span class="pl-smi">y</span><span class="pl-k">=</span><span class="pl-c1">None</span>, <span class="pl-smi">hue</span><span class="pl-k">=</span><span class="pl-c1">None</span>, <span class="pl-smi">data</span><span class="pl-k">=</span><span class="pl-c1">None</span>, ...):
    <span class="pl-c"># ...   </span></pre></div>

<p>And users write</p>

<div class="highlight highlight-source-python"><pre>(sns.load_dataset(<span class="pl-s"><span class="pl-pds">'</span>iris<span class="pl-pds">'</span></span>)
    .query(<span class="pl-s"><span class="pl-pds">"</span>sepal_length &gt; 5<span class="pl-pds">"</span></span>)
    .assign(<span class="pl-v">sepal_ratio</span> <span class="pl-k">=</span> <span class="pl-k">lambda</span> <span class="pl-smi">x</span>: x.sepal_length <span class="pl-k">/</span> x.sepal_width)
    .pipe(sns.violinplot, <span class="pl-v">x</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>species<span class="pl-pds">'</span></span>, <span class="pl-v">y</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>sepal_ratio<span class="pl-pds">'</span></span>)
)</pre></div>

<h3>Why?</h3>

<p>Heavily nested function calls are bad. They're hard to read, and can easily introduce bugs. Consider:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-c"># f, g, and h are functions that take and receive a DataFrame</span>
result <span class="pl-k">=</span> f(g(h(df), <span class="pl-v">arg1</span><span class="pl-k">=</span><span class="pl-c1">1</span>), <span class="pl-v">arg2</span><span class="pl-k">=</span><span class="pl-c1">2</span>, <span class="pl-v">arg3</span><span class="pl-k">=</span><span class="pl-c1">3</span>)</pre></div>

<p>For pandas, the approach has been to add <code>f</code>, <code>g</code>, and <code>h</code> as methods to (say) <code>DataFrame</code></p>

<div class="highlight highlight-source-python"><pre>(df.h()
   .g(<span class="pl-v">arg1</span><span class="pl-k">=</span><span class="pl-c1">1</span>)
   .f(<span class="pl-v">arg2</span><span class="pl-k">=</span><span class="pl-c1">2</span>, <span class="pl-v">arg3</span><span class="pl-k">=</span><span class="pl-c1">3</span>)
)</pre></div>

<p>The code is certainly cleaner. It reads and flows top to bottom instead of inside-out. The function arguments are next to the function calls. But there's a hidden cost. DataFrame has something like 200+ methods, which is crazy. It's less flexible for users since it's hard to get their own functions into pipelines (short of monkey-patching). With <code>.pipe</code>, we can</p>

<div class="highlight highlight-source-python"><pre>(df.pipe(h)
   .pipe(g, <span class="pl-v">arg1</span><span class="pl-k">=</span><span class="pl-c1">1</span>)
   .pipe(f, <span class="pl-v">arg2</span><span class="pl-k">=</span><span class="pl-c1">2</span>, <span class="pl-v">arg3</span><span class="pl-k">=</span><span class="pl-c1">3</span>)
)</pre></div>

<p>The other way around the nested calls is using temporary variables:</p>

<div class="highlight highlight-source-python"><pre>r1 <span class="pl-k">=</span> h(df)
r2 <span class="pl-k">=</span> g(r1, <span class="pl-v">arg1</span><span class="pl-k">=</span><span class="pl-c1">1</span>)
r3 <span class="pl-k">=</span> f(r2, <span class="pl-v">arg2</span><span class="pl-k">=</span><span class="pl-c1">2</span>, <span class="pl-v">arg3</span><span class="pl-k">=</span><span class="pl-c1">3</span>)</pre></div>

<p>Which is better, but not as good as the <code>.pipe</code> solution.</p>

<hr/>

<p>A relevant thread on python-ideas, started by <a href="https://github.com/mrocklin" class="user-mention">@mrocklin</a>: <a href="https://mail.python.org/pipermail/python-ideas/2015-March/032745.html">https://mail.python.org/pipermail/python-ideas/2015-March/032745.html</a></p>

<p>This doesn't achieve everything macros could. We still can't do things like <code>df.plot(x=x_col, y=y_col)</code> where <code>x_col</code> and <code>y_col</code> are captured by <code>df</code>'s namespace. But it may be good enough.</p>

<p>Going to cc a bunch of people here, who've had interest in the past.</p>

<p><a href="https://github.com/shoyer" class="user-mention">@shoyer</a> <br/>
<a href="https://github.com/mrocklin" class="user-mention">@mrocklin</a><br/>
<a href="https://github.com/datnamer" class="user-mention">@datnamer</a> <br/>
<a href="https://github.com/dalejung" class="user-mention">@dalejung</a></p>
      </div>
    </div></body></html>