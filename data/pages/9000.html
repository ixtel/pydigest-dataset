<html><body><div><div class="post-text" itemprop="text">

<p>I have the following situation:
I receive a request on a socketio server. I answer it (socket.emit(..)) and <strong>then</strong> start something with heavy computation load <strong>in another thread</strong>.</p>

<p>If the heavy computation is caused by <code>subprocess.Popen</code> (using <code>subprocess.PIPE</code>) it totally blocks every incoming request as long as it is being executed although it happens in a separate thread.</p>

<p>No problem - in <a href="https://stackoverflow.com/questions/375427/non-blocking-read-on-a-subprocess-pipe-in-python/4896288#4896288" title="Non-blocking read on a subprocess.PIPE in python">this thread</a> it was suggested to asynchronously read the result of the subprocess with a buffer size of 1 so that between these reads other threads have the chance to do something. Unfortunately this did not help for me. </p>

<p>I also already <a href="https://stackoverflow.com/questions/34581255/python-flask-socketio-send-message-from-thread-not-always-working%20monkeypatched">monkeypatched</a> eventlet and that works fine - as long as I don't use <code>subprocess.Popen</code> with <code>subprocess.PIPE</code> in the thread.</p>

<p>In this code sample you can see that it only happens using <code>subprocess.Popen</code> with <code>subprocess.PIPE</code>. When uncommenting <code>#functionWithSimulatedHeavyLoad()</code> and instead comment <code>functionWithHeavyLoad()</code> everything works like charm.</p>

<pre><code>from flask import Flask
from flask.ext.socketio import SocketIO, emit
import eventlet

eventlet.monkey_patch()
app = Flask(__name__)
socketio = SocketIO(app)

import time
from threading  import Thread

@socketio.on('client command')
def response(data, type = None, nonce = None):
    socketio.emit('client response', ['foo'])
    thread = Thread(target = testThreadFunction)
    thread.daemon = True
    thread.start()

def testThreadFunction():
    #functionWithSimulatedHeavyLoad()
    functionWithHeavyLoad()

def functionWithSimulatedHeavyLoad():
    time.sleep(5)

def functionWithHeavyLoad():
    from datetime import datetime
    import subprocess
    import sys
    from queue import Queue, Empty

    ON_POSIX = 'posix' in sys.builtin_module_names

    def enqueueOutput(out, queue):
        for line in iter(out.readline, b''):
            if line == '':
                break
            queue.put(line)
        out.close()

    # just anything that takes long to be computed
    shellCommand = 'find / test'

    p = subprocess.Popen(shellCommand, universal_newlines=True, shell=True, stdout=subprocess.PIPE, bufsize=1, close_fds=ON_POSIX)
    q = Queue()
    t = Thread(target = enqueueOutput, args = (p.stdout, q))
    t.daemon = True
    t.start()
    t.join()

    text = ''

    while True:
        try:
            line = q.get_nowait()
            text += line
            print(line)
        except Empty:
            break

    socketio.emit('client response', {'text': text})

socketio.run(app)
</code></pre>

<p>The client receives the message 'foo' after the blocking work in the functionWithHeavyLoad() function is completed. It should receive the message earlier, though.</p>

<p>This sample can be copied and pasted in a .py file and the behavior can be instantly reproduced. </p>

<p>I am using Python 3.4.3, Flask 0.10.1, flask-socketio1.2, eventlet 0.17.4</p>

<p><strong>Update</strong></p>

<p>If I put this into the functionWithHeavyLoad function it actually works and everything's fine:</p>

<pre><code>import shlex
shellCommand = shlex.split('find / test')

popen = subprocess.Popen(shellCommand, stdout=subprocess.PIPE)

lines_iterator = iter(popen.stdout.readline, b"")
for line in lines_iterator:
    print(line)
    eventlet.sleep()
</code></pre>

<p>The problem is: I used <code>find</code> for heavy load in order to make the sample for you more easily reproducable. However, in my code I actually use <code>tesseract "{0}" stdout -l deu</code> as the sell command. This (unlike <code>find</code>) still blocks everything. Is this rather a <code>tesseract</code> issue than eventlet? But still: how can this block if it happens in a separate thread where it reads line by line with context switch when <code>find</code> does not block?</p>
    </div>
    </div></body></html>