<html><body><div><p>Collection of classes for programming with functors, applicative functors and monads.</p>








<p>PyMonad is a small library
implementing monads and related data abstractions
– functors, applicative functors, and monoids –
for use in implementing functional style programs.
For those familiar with monads in Haskell,
PyMonad aims to implement many of the features you’re used to
so you can use monads in python quickly and easily.
For those who have never used monads but are interested,
PyMonad is an easy way to learn about them in, perhaps,
a slightly more forgiving environment
without needing to learn Haskell.</p>
<div id="getting-started">
<h2>Getting Started</h2>
<div id="installation">
<h3>Installation</h3>
<p>Using pip:</p>
<pre>pip install PyMonad
</pre>
<p>Or download the package or clone the <a href="https://bitbucket.org/jason_delaat/pymonad" rel="nofollow">git repository from bitbucket</a> and run:</p>
<pre>python setup.py install
</pre>
<p>from the project directory.</p>
</div>
<div id="imports">
<h3>Imports</h3>
<p>Import the entire package:</p>
<pre>from pymonad import *
</pre>
<p>Or just a single monad type:</p>
<pre>from pymonad.Maybe import *
</pre>
<p>If you’re not importing everything
but want to use curried functions:</p>
<pre>from pymonad.Reader import curry
</pre>
</div>
<div id="curried-functions-and-partial-application">
<h3>Curried Functions and Partial Application</h3>
<p>To define a curried function
use the <tt>@curry</tt> decorator:</p>
<pre>@curry
def add(x, y):
    return x + y

@curry
def func(x, y, z):
    # Do something with x, y and z.
    ...
</pre>
<p>The above fuctions can be partially applied
by passing them less than their full set of arguments:</p>
<pre>add(7, 8)            # Calling 'add' normally returns 15 as expected.
add7 = add(7)        # Partial application: 'add7' is a function taking one argument.
add7(8)              # Applying the final argument retruns 15...
add7(400)            # ... or 407, or whatever.

# 'func' can be applied in any of the following ways.
func(1, 2, 3)        # Call func normally.
func(1, 2)(3)        # Partially applying two, then applying the last argument.
func(1)(2, 3)        # Partially applying one, then applying the last two arguments.
func(1)(2)(3)        # Partially applying one, partially applying again, then applying the last argument.
</pre>
</div>
<div id="function-composition">
<h3>Function Composition</h3>
<p>Curried functions can be composed with the <tt>*</tt> operator.
Functions are applied from right to left:</p>
<pre># Returns the first element of a list.
@curry
def head(aList):
    return aList[0]

# Returns everything except the first element of the list.
@curry
def tail(aList):
    return aList[1:]

second = head * tail        # 'tail' will be applied first, then its result passed to 'head'
second([1, 2, 3, 4])        # returns 2
</pre>
<p>You can also compose partially applied functions:</p>
<pre>@curry
def add(x, y):
    return x + y

@curry
def mul(x, y):
    return x * y

comp = add(7) * mul(2)        # 'mul(2)' is evaluated first, and it's result passed to 'add(7)'
comp(4)                        # returns 15

# Composition order matters!
comp = mul(2) * add(7)
comp(4)                        # returns 22
</pre>
</div>
<div id="functors-applicative-functors-and-monads">
<h3>Functors, Applicative Functors, and Monads</h3>
<p>All Monads are also Applicative Functors,
and all Applicative Functors are also Functors,
though the same is not necessarily true in reverse.
All the types included with PyMonad
are defined as all three
but you can define new types however you want.</p>
<p>All of these types ultimately derive from <tt>Container</tt>
which simply holds a value and provides some basic value equality checking.
The method <tt>getValue()</tt> will allow you to “extract” the value
of monadic computations if/when necessary.</p>
</div>
<div id="functors">
<h3>Functors</h3>
<p>All functors define the <tt>fmap</tt> method
which can be invoked via the fmap operator <tt>*</tt>.
<tt>fmap</tt> takes functions which operate on simple types
– integers, strings, etc. –
and allows them to operate of functor types:</p>
<pre>from pymonad.Maybe import *
from pymonad.List import *

# 'neg' knows nothing about functor types...
def neg(x):
    return -x

# ... but that doesn't stop us from using it anyway.
neg * Just(9)                 # returns Just(-9)
neg * Nothing                 # returns Nothing
neg * List(1, 2, 3, 4)        # returns List(-1, -2, -3, -4)
</pre>
<p>Notice that the function is on the left
and the functor type is on the right.
If you think of <tt>*</tt> as a sort of fancy opening paren,
then normal calls and <tt>fmap</tt> calls have basically the same structure:</p>
<pre>------------------------------------------------------------------
                function          open          argument        close
Normal call         neg             (               9              )
fmap call           neg             *             Just(9)
------------------------------------------------------------------
</pre>
<p>Notice that <tt>*</tt> is also the function composition operator.
In fact,
curried functions are instances of the <tt>Reader</tt> monad,
and <tt>fmap</tt> -ing a function over another function
is the same thing as function composition.</p>
</div>
<div id="applicative-functors">
<h3>Applicative Functors</h3>
<p>Functors allow you to use normal functions of a single argument
– like <tt>neg</tt> above –
with functor types.
Applicative Functors extend that capability
– via <tt>amap</tt> and its operator <tt>&amp;</tt> –
allowing you to use normal functions of multiple arguments
with functor types:</p>
<pre># 'add' operates on simple types, not functors or applicatives...
def add(x, y):
    return x + y

# ... but we're going to use it on those types anyway.
# Note that we're still using '*' but now in conjunction with '&amp;'
add * Just(7) &amp; Just(8)                    # returns Just(15)
add * Nothing &amp; Just(8)                    # returns Nothing
add * Just(7) &amp; Nothing                    # returns Nothing
add * List(1, 2, 3) &amp; List(4, 5, 6)        # returns List(5, 6, 7, 6, 7, 8, 7, 8, 9)
</pre>
<p>If <tt>*</tt> is a fancy paren,
<tt>&amp;</tt> is the fancy comma
used to separate arguments.</p>
</div>
<div id="monads">
<h3>Monads</h3>
<p>Monads allow you to sequence a series of calculations
within than monad
using the <tt>bind</tt> operator <tt>&gt;&gt;</tt>.</p>
<p>The first argument to <tt>&gt;&gt;</tt> is a monad type.
The second argument is a function
which takes a single,
non-monad argument
and returns an instance of the same monad:</p>
<pre>from pymonad.List import *
from pymonad.Reader import curry

# Takes a simple number type and returns a 'List' containing that value and it's negative.
def positive_and_negative(x):
    return List(x, -x)

# You can call 'positive_and_negative' normally.
positive_and_negative(9)        # returns List(9, -9)

# Or you can create a List...
x = List(9)

# ... and then use '&gt;&gt;' to apply positive_and_negative'
x &gt;&gt; positive_and_negative        # also returns List(9, -9)

# But 'x' could also have more than one value...
x = List(1, 2)
x &gt;&gt; positive_and_negative        # returns List(1, -1, 2, -2)

# And of course you can sequence partially applied functions.
@curry
def add_and_sub(x, y):
    return List(y + x, y - x)

List(2) &gt;&gt; positive_and_negative &gt;&gt; add_and_sub(3)        # creates List(2)
                                                          # applies positive_and_negative: List(2, -2)
                                                          # then add_and_sub(3): List(5, -1, 1, -5)
                                                          # final result: List(5, -1, 1, -5)
</pre>
</div>
<div id="variable-assignment-in-monadic-code">
<h3>Variable assignment in monadic code</h3>
<p>The second argument to <tt>&gt;&gt;</tt> is a function
which takes a single, non-monad argument.
Because of that,
you can use <tt>lambda</tt> to assign values to a variable
withing monadic code,
like this:</p>
<pre>from pymonad.Maybe import *

Just(9) &gt;&gt; (lambda x:                 # Here, 'x' takes the value '9'
Just(8) &gt;&gt; (lambda y:                 # And 'y' takes the value '8'
Just(x + y)))                         # The final returned value is 'Just(9 + 8)', or 'Just(17)'
</pre>
<p>You can also simply ignore values if you wish:</p>
<pre>Just(9) &gt;&gt; Just(8)                    # The '9' is thrown away and the result of this computation is 'Just(8)'
</pre>
</div>
<div id="implementing-monads">
<h3>Implementing Monads</h3>
<p>Implementing other functors, applicatives, or monads is fairly straight-forward.
There are three classes,
serving as interfaces:</p>
<pre>Monad --&gt; Applicative --&gt; Functor
</pre>
<p>To implement a new functor,
create a new class which derives from <tt>Functor</tt>
and override the <tt>fmap</tt> method.</p>
<p>To implement a new applicative functor,
create a new class which derives from <tt>Applicative</tt>
and override the <tt>amap</tt> and <tt>fmap</tt> methods.</p>
<p>To implement a new monad,
create a new class which derives from <tt>Monad</tt>
and override at least the <tt>bind</tt> method,
and preferably the <tt>amap</tt> and <tt>fmap</tt> methods as well.</p>
<p>The operators, <tt>*</tt>, <tt>&amp;</tt>, and <tt>&gt;&gt;</tt>
are pre-defined to call the above methods
so you shouldn’t need to touch them directly.</p>
</div>
<div id="unit-aka-return">
<h3>unit (aka return)</h3>
<p>The previous version of pymonad
didn’t include the method <tt>unit</tt>
(called <tt>return</tt> in Haskell).
<tt>unit</tt> takes a bare value,
such as <tt>8</tt>,
and places it in a default context for that monad.
Haskell allows polymorphism on return types
as well as supporting type inference,
so you (mostly) don’t have to tell <tt>return</tt> what types to expect,
it just figures it out.
We can’t do that in Python,
so you <em>always</em> need to tell <tt>unit</tt> what type you’re expecting.</p>
<p>The <tt>unit</tt> method is implemented as a class method
in Functor.py, so it can be used with any functor, applicative or monad.
There is also a <tt>unit</tt> <em>function</em> which expects a functor type
(though you can also give it an instance)
and a value
and invokes the corresponding <tt>unit</tt> method.
It is provided to give a more “functional look” to code,
but use whichever method you prefer.
With the Maybe monad for example:</p>
<ol>
<li>Maybe.unit(8)         # returns Just(8)</li>
<li>unit(Maybe, 8)        # also returns Just(8)</li>
</ol>
<p>In either case all functors (and applicatives and monads) should implement the <tt>unit</tt> class method.</p>
</div>
</div>
<div id="monoids">
<h2>Monoids</h2>
<p>Monoids are a data type
which consists of some operation for combining values of that type,
and an identity value for that operation.
The operation is called <tt>mplus</tt>
and the identity value is callled <tt>mzero</tt>.
Despite the names,
they are not necessarily addition and zero.
They <em>can</em> be addition and zero though,
numbers are sort of the typical monoid.</p>
<p>In the case of numbers,
zero is the identity element and addition is the operation.
Monoids adhere to the following laws:</p>
<ol>
<li>Left and right identity: x + 0 = 0 + x = x</li>
<li>Associativity: (x + y) + z = x + (y + z) = x + y + z</li>
</ol>
<p>Stings are also monoids with the identity element <tt>mzero</tt> equal to the empty string,
and the operation <tt>mplus</tt> concatenation.</p>
<div id="creating-new-monoids">
<h3>Creating New Monoids</h3>
<p>To create a new monoids type
create a class deriving from <tt>Monoid</tt>
and override the <tt>mzero</tt> static method
which takes no arguments and should return an instance of the class
containing the identity value for the monoid.
Also override the <tt>mplus</tt> method.
For instance,
numbers can be a monoid in two ways,
one way with zero and addition as discussed above
and the other way with one and multiplication.
We could implement that like this:</p>
<pre>class ProductMonoid(Monoid):
    @staticmethod
    def mzero():
        return ProductMonoid(1)

    def mplus(self, other):
        return ProductMonoid(self.getValue() * other.getValue())
</pre>
<p>The <tt>+</tt> operator (aka __add__()) is defined to call <tt>mplus</tt> on monoid instances,
so you can simply “add” monoid values together rather than having to call <tt>mplus</tt> directly.</p>
</div>
<div id="natural-monoids">
<h3>“Natural” Monoids</h3>
<p>Similar to <tt>unit</tt> for monads,
there is an <tt>mzero</tt> function
which expects a type and can be used instead of the <tt>mzero</tt> method.
Unlike <tt>unit</tt> however,
the <tt>mzero</tt> function serves another purpose.
Numbers, strings and lists can all be used as monoids
and all already have an appropriate definition for <tt>+</tt>.
What they don’t have is an <tt>mzero</tt> method.
To allow numbers, strings and lists to be used as monoids
without any extra work,
the <tt>mzero</tt> <em>function</em> will return the appropriate value for these types
and will attempt to call the <tt>mzero</tt> method on anything else.
For instance:</p>
<pre>mzero(int)                    # returns 0, also works with float
mzero(str)                    # returns ""
mzero(list)                   # returns []
mzero(ProductMonoid)          # return ProductMonoid(1)
                              # etc...
</pre>
<p>If you write code involving monoids,
and you’re not sure what type of monoid you might be handed,
you should use the <tt>mzero</tt> <em>function</em>
and <em>not</em> the <tt>mzero</tt> method.</p>
</div>
</div>
<div id="monoids-and-the-writer-monad">
<h2>Monoids and the Writer Monad</h2>
<p>The Writer monad performs calculations
and keeps a log.
The log can be any monoid type
– strings being a typical example.</p>
<p>The <tt>Writer</tt> class doesn’t have a default log type,
so to use Writer you need to inherit from it.
It is extremely simple as the only thing you need to do is define the log type.
For instance:</p>
<pre>class StringWriter(Writer):
    logType = str
</pre>
<p>That’s it.
Everything else is already defined by <tt>Writer</tt>.
<tt>StringWriter</tt>, <tt>NumberWriter</tt>, and <tt>ListWriter</tt>
are already defined in the <tt>Writer</tt> module for you to use.</p>
<p>Calling <tt>unit</tt> with a <tt>Writer</tt> class
packages whatever value you give it
with the <tt>mzero</tt> of the log type:</p>
<pre>unit(StringWriter, 8)        # Returns Writer(8, "")
</pre>
<p><tt>Writer</tt> constructors take two values,
the first being the result of whatever calculation you’ve just performed,
the second being the log message
– or value, or whatever –
to add to the log.</p>
<p>### Other Methods ###</p>
<p><tt>getValue()</tt>: Returns the result and log as a two-tuple.</p>
<p><tt>getResult()</tt>: Returns only the result.</p>
<p><tt>getLog()</tt>: Returns only the log.</p>
<p>A quick example:</p>
<pre>@curry
def add(x, y):
    return StringWriter(x + y, "Adding " + str(x) + " and " + str(y) + ". ")

x = unit(StringWriter, 8) &gt;&gt; add(4) &gt;&gt; add(5)
print(x.getResult())     # prints 17
print(x.getLog())        # prints "Adding 8 and 4. Adding 12 and 5. "
</pre>
<p>In the definition of <tt>add`,
``StringWriter</tt> could have also been just <tt>Writer</tt>.
It’s really only necessary to use subclasses when using <tt>unit</tt>,
because <tt>unit</tt> checks for the <tt>logType</tt> variable.
Otherwise simply giving plain old <tt>Writer</tt> a string
– or other monoid type argument –
accomplishes the same thing.
Both <tt>unit</tt> and <tt>bind</tt> (or <tt>&gt;&gt;</tt>)
convert <tt>*Writer</tt> types to plain <tt>Writer</tt>
but using <tt>StringWriter</tt>
– or whatever –
makes your intentions more clear.</p>
</div>
<div id="state-monad">
<h2>State Monad</h2>
<p>Unlike most of the other monad types,
the state monad doesn’t wrap values
it wraps functions.
Specifically,
it wraps functions which accept a single ‘state’ argument
and produce a result and a new ‘state’ as a 2-tuple.
The ‘state’ can be anything:
simple types like integers,
lists, dictionaries, custom objects/data types,
whatever.
The important thing
is that any given chain of stateful computations
all use the same type of state.</p>
<p>The <tt>State</tt> constuctor should only be used to create stateful computations.
Trying to use <tt>State</tt> to inject values,
or even non-stateful functions,
into the monad will cause it to function incorrectly.
To inject values,
use the <tt>unit</tt> function.</p>
<p>Here’s an example of using <tt>State</tt>.
We’ll create a little system which can perform addition and subtraction.
Our total will never be allowed to drop below zero.
The state that we’ll be keeping track of is a simple count
of the total number of operations performed.
Every time we perform an addition or subtraction
the count will go up by one:</p>
<pre>@curry
def add(x, y):
        return State(lambda old_state: (x + y, old_state + 1))

@curry
def subtract(y, x):
        @State
        def state_computation(old_state):
                if x - y &lt; 0:
                        return (0, old_state + 1)
                else:
                        return (x - y, old_state + 1)
        return state_computation
</pre>
<p>As mentioned,
The <tt>State</tt> constructor takes a function which accepts a ‘state’,
in this case simply an integer,
and produces a result and a new state as a tuple.
Although we could have done <tt>subtract</tt> as a one-liner,
I wanted to show that,
if your computation is more complex than can easily be contained in a <tt>lambda</tt> expression,
you can use <tt>State</tt> as a decorator to define the stateful computation.</p>
<p>Using these functions is now simple:</p>
<pre>x = unit(State, 1) &gt;&gt; add(2) &gt;&gt; add(3) &gt;&gt; subtract(40) &gt;&gt; add(5)
</pre>
<p><tt>x</tt> now contains a stateful computation but that computation hasn’t been executed yet.
Since <tt>State</tt> values contain functions,
you can call them like functions
by supplying an initial state value:</p>
<pre>y = x(0)        # Since we're counting the total number of operations, we start at zero.
print(y)        # Prints (5, 4), '5' is the result and '4' is the total number of operations performed.
</pre>
<p>Calling a <tt>State</tt> function in this way will always return the (result, state) tuple.
If you’re only interested in the result:</p>
<pre>y = x.getResult(0)        # Here 'y' takes the value 5, the result of the computataion.
</pre>
<p>Or if you only care about the final state:</p>
<pre>y = x.getState(0)         # Here 'y' takes the value 4, the final state of the computation.
</pre>
</div>
<div id="changes">
<h2>Changes</h2>
<p>v1.3, 2014-06-28 – Added Monoid instances for List and Maybe, added First and Last Monoids, add State Monad, updated tests for List and Maybe.</p>
<p>V1.2, 2014-05-17 – Added Monoids and Writer Monad. Added ‘unit’ class method to existing monad types. Added ‘unit’ function. Updated README.txt for new features.</p>
<p>V1.1, 2014-04-13 – Fixed problems with List, Either and Maybe to make package compatible with Python 2</p>
<p>V1.0, 2014-03-29 – Initial Release</p>
</div>


</div></body></html>