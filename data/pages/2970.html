<html><body><div><div class="solo-entry-content entry-content">
    <h2 class="solo-entry-title entry-title">Learning Python by example: list comprehensions</h2>
    <a name="learning-python-by-example-list-comprehensions"/><p>My friend, who is starting to learn Python 2.x, asked me what this snippet did:</p><div class="highlight"><pre><span>def</span> <span>collapse</span>(seq):
    <span># Preserve order.</span>
    uniq <span>=</span> []
    [uniq<span>.</span>append(item) <span>for</span> item <span>in</span> seq <span>if</span> <span>not</span> uniq<span>.</span>count(item)]
    <span>return</span> uniq
</pre></div>
<p>This is not a snippet that should be emulated (i.e. <em>it's bad</em>); however, it
makes me happy: there are so many things that can be informatively corrected!</p><a name="what-is-a-list-comprehension"/><h3>What is a list comprehension?</h3><p>A list comprehension is a special brackety syntax to perform a <em>transform</em>
operation with an optional <em>filter</em> clause that always produces a new sequence
(list) object as a <em>result</em>. To break it down visually, you perform:</p><div class="highlight"><pre>new_range <span>=</span> [i <span>*</span> i          <span>for</span> i <span>in</span> <span>range</span>(<span>5</span>)   <span>if</span> i <span>%</span> <span>2</span> <span>==</span> <span>0</span>]
</pre></div>
<p>Which corresponds to:</p><div class="highlight"><pre>*result*  = [*transform*    *iteration*         *filter*     ]
</pre></div>
<p>The <em>filter</em> piece answers the question, "should this item be transformed?" If
the answer is yes, then the <em>transform</em> piece is evaluated and becomes an
element in the <em>result</em>. The <em>iteration</em> <tt><a href="#learning-python-by-example-list-comprehensions-0" name="learning-python-by-example-list-comprehensions-0-ref">[*]</a></tt> order is preserved in the
<em>result</em>.</p><p>Go ahead and figure out what you expect <tt class="literal">new_range</tt> to be in the prior
example. You can double check me in the Python shell, but I think it comes out
to be:</p><div class="highlight"><pre><span>&gt;&gt;&gt;</span> new_range <span>=</span> [i <span>*</span> i <span>for</span> i <span>in</span> <span>range</span>(<span>5</span>) <span>if</span> i <span>%</span> <span>2</span> <span>==</span> <span>0</span>]
<span>&gt;&gt;&gt;</span> <span>print</span> new_range
[<span>0</span>, <span>4</span>, <span>16</span>]
</pre></div>
<p>If it still isn't clicking, we can try to make the example less noisy by
getting rid of the transform and filter — can you tell what this will produce?</p><div class="highlight"><pre><span>&gt;&gt;&gt;</span> new_range <span>=</span> [i <span>for</span> i <span>in</span> <span>range</span>(<span>5</span>)]
</pre></div>
<a name="so-what-s-wrong-with-that-first-snippet"/><h3>So what's wrong with that first snippet?</h3><p>As we observed in the previous section, a list comprehension always produces a
<em>result</em> list, where the elements of the result list are the <em>transformed</em>
elements of the <em>iteration</em>. That means, if there's no <em>filter</em> piece, there
are exactly as many <em>result</em> elements as there were <em>iteration</em> elements.</p><p>Weird thing number one about the snippet — the list comprehension <em>result</em> is
unused. It's created, mind you — list comprehension always create a value,
even if you don't care what it is — but it just goes off to oblivion. (In
technical terms, it becomes <em>garbage</em>.) When you don't need the <em>result</em>, just
use a <tt class="literal">for</tt> loop! This is better:</p><div class="highlight"><pre><span>def</span> <span>colapse</span>(seq):
    <span>"""Preserve order."""</span>
    uniq <span>=</span> []
    <span>for</span> item <span>in</span> seq:
        <span>if</span> <span>not</span> uniq<span>.</span>count(item):
            uniq<span>.</span>append(item)
    <span>return</span> uniq
</pre></div>
<p>It's two more lines, but it's less weird looking and wasteful. "Better for
everybody who reads <strong>and</strong> runs your code," means <a href="http://steve-yegge.blogspot.com/2008/09/programmings-dirtiest-little-secret.html">you should do it</a>.</p><p>Moral of the story: a list comprehension isn't just, "shorthand for a loop."
It's shorthand for a transform from an input sequence to an output sequence
with an optional filter. If it gets too complex or weird looking, just make a
loop.  It's not that hard and readers of your code will thank you.</p><p>Weird thing number two: the transform, <tt class="literal">list.append(item)</tt>, produces <tt class="literal">None</tt>
as its output value, because the return value from <tt class="literal">list.append</tt> is always
<tt class="literal">None</tt>. Therefore, the <em>result</em>, even though it isn't kept anywhere, is a
list of <tt class="literal">None</tt> values of the same length as <tt class="literal">seq</tt> (notice that there's no
filter clause).</p><p>Weird thing number three: <tt class="literal">list.count(item)</tt> iterates over every element in
the <tt class="literal">list</tt> looking for things that <tt class="literal">==</tt> to <tt class="literal">item</tt>. If you think through
the case where you call <tt class="literal">collapse</tt> on an entirely unique sequence, you can
tell that the collapse algorithm is O(n<sup>2</sup>).  In fact, it's even worse
than it may seem at first glance, because <tt class="literal">count</tt> will keep going all the way
to the end of <tt class="literal">uniq</tt>, even if it finds <tt class="literal">item</tt> in the first index of
<tt class="literal">uniq</tt>. What the original author really wanted was <tt class="literal">item not in uniq</tt>,
which bails out early if it finds <tt class="literal">item</tt> in <tt class="literal">uniq</tt>.</p><p>Also worth mentioning for the computer-sciency folk playing along at home: if
all elements of the sequence are comparable, you can bring that down to O(n *
log n) by using a "shadow" sorted sequence and <a href="http://docs.python.org/library/bisect.html#module-bisect">bisecting</a> to test for
membership. If the sequence is hashable you can bring it down to O(n), perhaps
by using the <a href="http://docs.python.org/library/stdtypes.html#set">set</a> datatype if you are in Python &gt;= 2.3. Note that the common
cases of strings, numbers, and tuples (any built-in immutable datatype, for
that matter) are hashable.</p><a name="from-python-history"/><h3>From Python history</h3><p>It's interesting to note that <a href="http://www.python.org/dev/peps/pep-0270/">Python Enhancement Proposal (PEP) #270</a>
considered putting a <tt class="literal">uniq</tt> function into the language distribution, but
withdrew it with the following statement:</p><blockquote><p>Removing duplicate elements from a list is a common task, but
there are only two reasons I can see for making it a built-in.
The first is if it could be done much faster, which isn't the
case.  The second is if it makes it significantly easier to
write code.  The introduction of <tt class="literal">sets.py</tt> eliminates this
situation since creating a sequence without duplicates is just
a matter of choosing a different data structure: a set instead
of a list.</p></blockquote><p>Remember that sets can only contain hashable elements (same policy as
dictionary keys) and are therefore not suitable for all uniq-ifying tasks, as
mentioned in the last paragraph of the previous section.</p><a name="footnotes"/><h3>Footnotes</h3>
  </div>
  </div></body></html>