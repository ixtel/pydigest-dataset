<html><body><div><p>More information on reference parsers below.</p>
<div id="available-reference-parsers">
<h3>Available reference parsers</h3>
<div id="layer-references">
<h4><tt>layer</tt> references</h4>
<p><tt>layer</tt> references allow you to refer to the physical ID of a resource
that is part of another layer. For instance, consider the following
environment definition:</p>
<pre>---
my-environment:
    description:
        Creates a VPC with a NAT in the public subnet
    layers:
        - {layer: vpc}
        - {layer: nat}
</pre>
<p>Obviously the <tt>nat</tt> layer that takes care of deploying the NAT in the
public subnet will need to know the physical ID of that subnet. You
achieve this by declaring a <tt>layer</tt> reference in the <tt>meta.yaml</tt> for
the <tt>nat</tt> layer:</p>
<pre>---
meta:
    description:
        Creates a managed NAT in the public subnet of the NAT layer
    parameters:
        subnet_id:
            description:
                The physical ID of the subnet where the NAT will be placed
            value:
                ref:
                    parser: layer
                    parameters:
                        layer_name: vpc
                        # The logical name of the subnet in the vpc layer
                        resource_name: PublicSubnet
</pre>
<p>When parsing <tt>meta.yaml</tt> humilis will replace this:</p>
<pre>ref:
    parser: layer
    parameters:
        layer_name: vpc
        # The logical name of the subnet in the vpc layer
        resource_name: PublicSubnet
</pre>
<p>with the physical ID you need (something like <tt><span class="pre">subnet-bafa90cd</span></tt>). You
can then use this physical ID in the <tt>resources.yaml.j2</tt> section of
the <tt>nat</tt> layer:</p>
<pre>{# Pseudo-content of layers/nat/resources.yaml.j2 #}
resources:
    {# An Elastic IP reservation that will be associated to the NAT #}
    NatEip:
      Type: 'AWS::EC2::EIP'
      Properties: {}
    {# Custom resource deploying the NAT #}
    NatGateway:
      Type: 'Custom::NatGateway',
      Properties:
        {# The ARN of the Lambda function backing the custom resource #}
        ServiceToken: 'arn:aws:lambda:eu-west-1:XXXX:function:CreateNatGateway'
        {# Here we use the subnet_id reference defined in meta.yaml #}
        SubnetId: {{subnet_id}}
        AllocationId:
            Ref: NatEip
</pre>
</div>
<div id="output-references">
<h4><tt>output</tt> references</h4>
<p><tt>output</tt> references allow you to refer to outputs produced by another
layer.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><tt>layer_name</tt>: The name of the layer you are referring to</li>
<li><tt>output_name</tt>: The logical name of the output parameter</li>
</ul>
<p>In general you should prefer using <tt>output</tt> references over <tt>layer</tt>
references. The output parameters produced by a layer define an informal
<em>layer interface</em> that is more likely to remain constant than the
logical names of resources within a layer.</p>
</div>
<div id="boto3-references">
<h4><tt>boto3</tt> references</h4>
<p><tt>boto3</tt> references define arbitrary calls to
<a href="https://github.com/InnovativeTravel/boto3facade" rel="nofollow">boto3facade</a>. The
latter is just a simpler facade interface on top of
<a href="https://github.com/boto/boto3" rel="nofollow">boto3</a>.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><tt>service</tt>: The AWS service, e.g. <tt>ec2</tt> or <tt>cloudformation</tt>.
Note that only only AWS services that have a facade in
<a href="https://github.com/InnovativeTravel/boto3facade" rel="nofollow">boto3facade</a> are
supported.</li>
<li><tt>call</tt>: The corresponding facade method, e.g. <tt>get_ami_by_name</tt>.
The value of this parameter must be a dictionary with a <tt>method</tt>
key (the name of the facade method to invoke) and an optional
<tt>args</tt> key (the parameters to pass to the facade method). Best to
look at the example below to understand how this works.</li>
<li><tt>output_attribute</tt>: Optional. If provided the reference parser will
return the value of this attribute from the object returned by the
facade method.</li>
</ul>
<p>Below an example of a layer that uses a <tt>boto3</tt> reference:</p>
<pre>---
meta:
    description:
        Creates an EC2 instance using a named AMI
    # More stuff omitted for brevity
    ami:
        description: The AMI to use when launching the EC2 instance
        value:
            ref:
                parser: boto3
                parameters:
                    service: ec2
                    call:
                        method: get_ami_by_name
                        args:
                            - test-ami
                    output_attribute: id
</pre>
<p><tt>humilis</tt> will parse the reference using this code:</p>
<pre># Import the Ec2 facade
from boto3facade.ec2 import Ec2

# Create a facade object
ec2_facade = Ec2()

# Make the call
ami = ec2_facade.get_ami_by_name('test-ami')

# Extract the requested attribute
ref_value = ami.id
</pre>
</div>
<div id="file-references">
<h4><tt>file</tt> references</h4>
<p><tt>file</tt> references allow you to refer to a local file. The file will be
uploaded to S3 and the reference will evaluate to the corresponding S3
path.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><tt>path</tt>: The path to the file, relative to the layer root directory.</li>
</ul>
</div>
<div id="lambda-references">
<h4><tt>lambda</tt> references</h4>
<p><tt>lambda</tt> references allow you to refer to some Python code in your
local machine. If your code follows some simple conventions <tt>humilis</tt>
will take care of building a <a href="http://docs.aws.amazon.com/lambda/latest/dg/lambda-python-how-to-create-deployment-package.html" rel="nofollow">deployment
package</a>
for you, uploading it to S3, and the reference will evaluate to the S3
path of the deployment package.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><tt>path</tt>: Path to either a completely self-contained <tt>.py</tt> file, or
to the root directory of your lambda code. In the latter case your
code needs to follow some simple conventions for this to work. More
information below.</li>
</ul>
<p><strong>Example</strong>:</p>
<pre>ref:
    parser: lambda
    parameters:
        # Path to the root directory containing your lambda code
        path: dummy_function
</pre>
<p>which will evaluate to a S3 path such as:</p>
<pre>s3://[bucket_name]/[environment_name]/[stage_name]/[func_name]-[commithash].zip
</pre>
<p><strong>Code conventions</strong>:</p>
<p>Following the example above, the contents of the layer responsible of
deploying the <tt>dummy_function</tt> lambda may look like this:</p>
<pre>.
├── dummy_function
│   ├── dummy_function.py
│   └── setup.py
├── meta.yaml
├── outputs.yaml.j2
└── resources.yaml.j2
</pre>
<p>Basically all your code needs to be included under directory
<tt>dummy_function</tt>. In this case there is only one file:
<tt>dummy_function.py</tt>. External dependencies need to be specified in
your <tt>setup.py</tt>.</p>
</div>
</div>
<div id="secrets-vault">
<h3>Secrets vault</h3>
<p>If your environment includes a <a href="https://github.com/InnovativeTravel/humilis-secrets-vault" rel="nofollow">secrets vault
layer</a> you
can use humilis to easily store secrets in the vault:</p>
<pre>humilis set-secret --stage [STAGE] [ENVIRONMENT_FILE] [SECRET_KEY] [SECRET_VAL]
</pre>
<p>You can test that the secret was properly stored using the
<tt><span class="pre">get-secret</span></tt> command:</p>
<pre>humilis set-secret --stage [STAGE] [ENVIRONMENT_FILE] [SECRET_KEY]
</pre>
</div>
</div></body></html>