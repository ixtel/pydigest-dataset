<html><body><div><div id="attributes">
<h3>Attributes</h3>
<p>All attribute and key lookups on a stub will return another stub:</p>
<pre>&gt;&gt;&gt; my_stub.some_attribute
&lt;Stub name='some_attribute' ...&gt;
</pre>
<p>You can define explicit attributes:</p>
<pre>&gt;&gt;&gt; my_stub.some_attribute = 'some value'
&gt;&gt;&gt; my_stub.some_attribute
'some value'

&gt;&gt;&gt; my_stub = Stub('my_stub', predefined_attribute='predefined value')
&gt;&gt;&gt; my_stub.predefined_attribute
'predefined value'
</pre>
</div>
<div id="callables">
<h3>Callables</h3>
<p>You must explictly make your stub callable. This is to avoid false positives
in tests for logic that may depend on the truthyness of a return value.</p>
<pre>&gt;&gt;&gt; my_stub()
Traceback (most recent call last):
    ...
TypeError: &lt;Stub name='my_stub' ...&gt; is not callable ...

&gt;&gt;&gt; from tdubs import calling
&gt;&gt;&gt; calling(my_stub).returns('some return value')
&gt;&gt;&gt; my_stub()
'some return value'
</pre>
<p>Since attribute lookups return a stub by default, you can treat your stub like
an object with callable methods:</p>
<pre>&gt;&gt;&gt; calling(my_stub.some_method).returns('some method result')
&gt;&gt;&gt; my_stub.some_method()
'some method result'
</pre>
<p>You can stub calls with specific arguments:</p>
<pre>&gt;&gt;&gt; calling(my_stub).passing('some argument').returns('specific value')
&gt;&gt;&gt; my_stub('some argument')
'specific value'
</pre>
<p>When you do, the original stubs are retained:</p>
<pre>&gt;&gt;&gt; my_stub()
'some return value'
</pre>
</div>
<div id="mocks">
<h3>Mocks</h3>
<p>Mocks have all the functionality of stubs, but they are callable by default,
and will record calls for verification. So if you need to verify calls, use a
mock (see <a href="#stubs-vs-mocks" rel="nofollow">Stubs vs. Mocks</a> for more details).</p>
<pre>&gt;&gt;&gt; from tdubs import Mock
&gt;&gt;&gt; my_mock = Mock('my_mock')
</pre>
<p>Any call to a mock will return a new mock:</p>
<pre>&gt;&gt;&gt; my_mock()
&lt;Mock ...&gt;
&gt;&gt;&gt; my_mock('arg1', 'arg2', foo='bar')
&lt;Mock ...&gt;
</pre>
<p>All calls to a mock are recorded:</p>
<pre>&gt;&gt;&gt; from tdubs import calls
&gt;&gt;&gt; calls(my_mock)
[&lt;Call args=() kwargs={}&gt;, &lt;Call args=('arg1', 'arg2') kwargs={'foo': 'bar'}&gt;]
</pre>
<p>You can verify that something was called:</p>
<pre>&gt;&gt;&gt; from tdubs import verify
&gt;&gt;&gt; verify(my_mock).called()
True

&gt;&gt;&gt; new_mock = Mock('new_mock')
&gt;&gt;&gt; verify(new_mock).called()
Traceback (most recent call last):
    ...
tdubs.VerificationError: expected &lt;Mock ...&gt; to be called, but it wasn't
</pre>
<p>You can verify that it was called with specific arguments:</p>
<pre>&gt;&gt;&gt; verify(my_mock).called_with('arg1', 'arg2', foo='bar')
True
&gt;&gt;&gt; verify(my_mock).called_with('foo')
Traceback (most recent call last):
    ...
tdubs.VerificationError: expected &lt;Mock ...&gt; to be called with ('foo'), ...
</pre>
<p>You can also verify that it was <em>not</em> called:</p>
<pre>&gt;&gt;&gt; verify(new_mock).not_called()
True
&gt;&gt;&gt; new_mock()
&lt;Mock ...&gt;
&gt;&gt;&gt; verify(new_mock).not_called()
Traceback (most recent call last):
    ...
tdubs.VerificationError: expected &lt;Mock ...&gt; to not be called, but it was
</pre>
<p>Or that it was not called with specific arguments:</p>
<pre>&gt;&gt;&gt; verify(new_mock).not_called_with('foo')
True
&gt;&gt;&gt; new_mock('foo')
&lt;Mock ...&gt;
&gt;&gt;&gt; verify(new_mock).not_called_with('foo')
Traceback (most recent call last):
    ...
tdubs.VerificationError: expected &lt;Mock ...&gt; to not be called with (...), ...
</pre>
</div>
</div></body></html>