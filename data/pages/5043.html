<html><body><div><div class="col-sm-12 md-margin-bottom-40">

  <p class="headline"><h2> "pip -t": A simple and transparent alternative to virtualenv </h2></p>
  <div class="post-author"><p>
    By </p><strong>Eric Reynolds</strong><p> and </p><strong>Felix Zumstein</strong><p>, Partners at Zoomer Analytics (Jun 25, 2015)
 </p><a href="#disqus_thread"> ▼ Comments</a>
  </div>

  <a href="https://twitter.com/share" class="twitter-share-button" data-url="http://blog.zoomeranalytics.com/pip-install-t/" data-via="ZoomerAnalytics" data-hashtags="python, pip">Tweet</a>


  <h3 id="tldr">TL;DR</h3>

<p>Often, <a href="https://virtualenv.pypa.io/en/latest/">virtualenv</a> is overkill for the basic task of installing project 
dependencies and keeping them isolated. We present a simple alternative consisting of:</p>

<ol>
  <li>adding <code>./.pip</code> to your <code>PYTHONPATH</code></li>
  <li>using <code>pip install -t .pip</code> to install modules locally</li>
  <li>executing <code>python</code> from your project’s root directory</li>
</ol>

<h3 id="which-version-would-you-like-today">Which version would you like today?</h3>

<p>Installing dependencies is a required step for almost any Python application. Each Python app depends on a different set
of libraries, and to be sure that it behaves as expected, the best thing is to install exactly the right version of each
library.</p>

<p>The standard practice is to ship Python projects with a <code>requirements.txt</code> file. This file lists the libraries that the
project depends on, and a version number for each one. If present, installing the dependencies is as easy as:</p>

<pre><code class="language-bash">$ pip install -r requirements.txt
</code></pre>

<p>So far so good! The problems start when using <em>two or more projects with conflicting dependencies</em>. Let’s suppose project
A only works with library X version 0.1, and project B uses the same library X, but only works with version 0.2. By
default, pip installs libraries globally into the Python interpreter’s library path. This means that issuing the</p>

<pre><code class="language-bash">$ pip install X==0.2
</code></pre>

<p>command will make X version 0.2 available in <em>every</em> Python instance, overwriting version 0.1 if it was previously
installed. Switching between project A and project B would require reinstalling the right version of X each time, which
is time-consuming and inconvenient.</p>

<h3 id="an-island-in-the-sun">An island in the sun</h3>

<p>One popular solution to this commonly encountered problem is <em>virtual environments</em>. The
<a href="https://virtualenv.pypa.io/en/latest/">virtualenv</a> framework allows you to create isolated Python environments. The
dependencies for each project are kept separate from each other. However, some users find virtualenv complicated to use,
so packages like <a href="https://virtualenvwrapper.readthedocs.org/en/latest/">virtualenvwrapper</a> and
<a href="https://github.com/kennethreitz/autoenv">autoenv</a> extend its functionality in an attempt to make things easier. Other
solutions include <code>Anaconda environments</code> in the Anaconda Python distribution, and <code>pyvenv</code> which is baked into the Python
standard library starting from Python 3.3.</p>

<p>Though these are great tools, we have always felt that they represent a rather heavy and complicated toolset for what
should essentially be a very simple task.</p>

<p>Looking at Javascript, tools like <a href="https://www.npmjs.com/">npm</a> and <a href="http://bower.io//">Bower</a> provide the easy,
reliable and powerful package management capabilities which it feels like Python is missing. The key to their success?
Both tools download a copy of the right versions of the right libraries, by default placing them in a special folder
directly within your project’s directory. The downloaded libraries remain local to only that project, meaning that you
automatically avoid the issues described above.</p>

<h3 id="pure-magic">Pure magic</h3>

<p>As it turns out, there’s a simple way of replicating the npm/Bower approach for Python packages, involving these easy steps:</p>

<ul>
  <li>Add <code>./.pip</code> to your <code>PYTHONPATH</code>.</li>
  <li>Use <code>pip</code> with <code>-t .pip</code> to install your libraries locally.</li>
</ul>

<p>Then, simply execute your code from within your project directory and forget about <code>source env/bin/active</code> and <code>deactivate</code>!</p>

<p>The trick works because <code>./.pip</code> is a relative path. As a result, if you run <code>python</code> from <code>~/dev/project_a</code> then
<code>~/dev/project_a/.pip</code> gets included in that Python instance’s library path. If you run <code>python</code> from <code>~/dev/project_b</code>,
then <code>~/dev/project_b/.pip</code> gets included instead. This works on all major platforms: Linux, Mac and Windows.</p>

<p>The folder name <code>.pip</code> is arbitrary of course — for example, one could choose to name the folder <code>pip_components</code> or <code>libs</code>
instead. However, <code>.pip</code> is quick to type, and the initial <code>.</code> hides the folder by default on Linux/Mac.</p>

<h3 id="step-1-set-the-pythonpath">Step 1: Set the PYTHONPATH</h3>

<ul>
  <li>
    <h5 id="maclinux">MAC/LINUX</h5>
    <p>The following command will permanently set the PYTHONPATH for standard terminal sessions:</p>

    <pre><code class="language-bash">$ echo 'export PYTHONPATH="./.pip:$PYTHONPATH"' &gt;&gt; ~/.bash_profile
</code></pre>

    <p>After that, either restart your terminal or do <code>$ source .bash_profile</code> to make sure the PYTHONPATH is loaded into the
current session. Depending on your platform, you might want to use <code>~/.bashrc</code> instead of <code>~/.bash_profile</code>.</p>
  </li>
  <li>
    <h5 id="windows">WINDOWS</h5>
    <p>Go to Control Panel &gt; System and Security &gt; System &gt; Change Settings &gt; Advanced &gt; Environment Variables, and add/edit
the PYTHONPATH variable either to your user variables or system variables, setting it to <code>.\.pip</code> or <code>.\.pip;(...other paths...)</code>.
Then restart your command prompt.</p>
  </li>
  <li>
    <h5 id="temporary-pythonpath">TEMPORARY PYTHONPATH</h5>
    <p>If you prefer to change the PYTHONPATH only temporarily for the duration of your terminal session, you can also do
<code>$ export PYTHONPATH=./.pip</code> on Mac/Linux or <code>&gt; set PYTHONPATH=.\.pip</code> on Windows.</p>

    <p>On Mac/Linux, you can even set the PYTHONPATH just for the duration of a Python session: <code>$ PYTHONPATH=./.pip python main.py</code>.</p>
  </li>
</ul>

<h3 id="step-2-install-packages-with-pip--t">Step 2: Install packages with “pip -t”</h3>

<p>Now that we have set the PYTHONPATH, the only thing left to do is to install our packages into the right location
using pip. For this, we use the <code>-t</code> or <code>--target</code> switch to indicate the directory into which pip should install the packages:</p>

<pre><code class="language-bash">$ cd project_a
project_a$ pip install requests==2.7.0 -t .pip

project_a$ python
&gt;&gt;&gt; import requests
&gt;&gt;&gt; requests.__version__
'2.7.0'
</code></pre>

<p>Now let’s do the same for another project with another version:</p>

<pre><code class="language-bash">$ cd project_b
project_b$ pip install requests==2.6.0 -t .pip

project_b$ python
&gt;&gt;&gt; import requests
&gt;&gt;&gt; requests.__version__
'2.6.0'
</code></pre>

<p>This works equally well when using a <code>requirements.txt</code> file:</p>

<pre><code class="language-bash">$ pip install -r requirements.txt -t .pip
</code></pre>

<h3 id="potential-pitfalls">Potential pitfalls</h3>

<h5 id="different-python-interpreters">DIFFERENT PYTHON INTERPRETERS</h5>
<p>You can easily run your program with different Python interpreters as follows:</p>

<pre><code class="language-bash">$ /path/to/python main.py
</code></pre>

<p>However, there’s an issue if you are switching between Python 2 and 3 and you are using packages that don’t have a
single code base, i.e. they compile their source code during installation using <code>2to3</code>. In that case, you would have to
introduce something like <code>.pip3</code> and add this path in front of your PYTHONPATH when running things with Python 3.</p>

<h5 id="easyinstall">EASY_INSTALL</h5>
<p>If you happen to have packages that have been installed globally using <code>easy_install</code>, you’ve got the issue that
easy_install prepends the path to those libraries to your <code>sys.path</code> which gives them priority over whatever you have in
<code>.pip</code>. The solution here is to get rid of global easy_install installations. You can easily check if something hijacks
your .pip setup by running <code>import sys;sys.path</code> within a Python session. If there are paths in front of <code>./.pip</code>, then you
might need to clean up things first.</p>



<p id="disqus_thread"/>

<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>


</div>
</div></body></html>