<html><body><div><div class="forum-post blog-post">
            


<p>Let's look at a classical CS problem that was realised as the Checkio mission.
I mean <a href="http://www.checkio.org/mission/golden-pyramid/share/b88523a147fdb0960da155eb777729f0/">"Golden Pyramid"</a> mission.</p>
<p>Consider a triangle of numbers. There is one number in the top of the triangle.
On the next level - two numbers, then three and so on.
You are start at the top and should down to the bottom of the triangle.
For each step down you can move to on of two cell below current.
And you "collect" (summarize) passed numbers.
Your goal is find the maximum possible sum of numbers for all possible routes from top to bottom.</p>
<p><img src="http://checkio.s3.amazonaws.com/blog/share/golden-pyramid-example.svg" alt="GP Example"/></p>
<h2 id="recursive">Recursive</h2>
<p>The first obvious idea is to use recursion and calculate all paths from top to down.
When we down to one level, then all below available cells are the new sub-triangle and
we can start our function one more time for the new triangle. And so on until we reach the bottom.
Simple and obviously.</p>
<pre class="grey-pre"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">golden_pyramid</span><span class="hljs-params">(triangle, row=<span class="hljs-number">0</span>, column=<span class="hljs-number">0</span>, total=<span class="hljs-number">0</span>)</span>:</span>
    <span class="hljs-keyword">global</span> count
    count += <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> row == len(triangle) - <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> total + triangle[row][column]
    <span class="hljs-keyword">return</span> max(golden_pyramid(triangle, row + <span class="hljs-number">1</span>, column, total + triangle[row][column]),
               golden_pyramid(triangle, row + <span class="hljs-number">1</span>, column + <span class="hljs-number">1</span>, total + triangle[row][column]))
</code></pre>

<p>But as we can see for the first level we run our function 2 times, then 4, 8, 16....
So as result we will get 2<sup>N</sup> complexity and
for the hundred-storied pyramid we need ≈ 10<sup>30</sup> function calls. Hm... </p>
<p><img src="http://checkio.s3.amazonaws.com/blog/share/golden-pyramid-recursive.svg" alt="GP Recursion"/></p>
<h2 id="dynamic-programming">Dynamic Programming</h2>
<p>But what if we will use dynamic programming method and break our problem to small pieces,
which can be merged then.
For simplicity look at the triangle upside down. Now look at the second (from new top) level.
For each cell we can choose what is the best possible for this small three element triangle.
Choose the best from the first level (early bottom), summarize with current cell value and write it.
Now we have the new shorter triangle and can repeat this operation again and again.
As result we have (N-1)+(N-2)+...2+1 operations and this is N<sup>2</sup> complexity.</p>
<pre class="grey-pre"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">golden_pyramid_d</span><span class="hljs-params">(triangle)</span>:</span>
    tr = [row[:] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> triangle]  
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(tr) - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i + <span class="hljs-number">1</span>):
            tr[i][j] += max(tr[i + <span class="hljs-number">1</span>][j], tr[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>])
    <span class="hljs-keyword">return</span> tr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
</code></pre><p><img src="http://checkio.s3.amazonaws.com/blog/share/golden-pyramid-dynamic.svg" alt="GP Dynamic"/></p>
<h2 id="checkio-player-solutions">Checkio Player Solutions</h2>
<p><a href="http://www.checkio.org/user/gyahun_dash/">@gyahun_dash</a> made the interesting realisation of dynamic programming method in
<a href="http://www.checkio.org/mission/golden-pyramid/publications/gyahun_dash/python-3/dp/share/28008da26f7ecba0593f7b71a5250b25/">"DP" solution</a>. He used "reduce" to work at rows by pairs with accumulating and
"map" to process each level.</p>
<pre class="grey-pre"><code><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce
​
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum_triangle</span><span class="hljs-params">(top, left, right)</span>:</span>
    <span class="hljs-keyword">return</span> top + max(left, right)
​
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">integrate</span><span class="hljs-params">(lowerline, upperline)</span>:</span>
    <span class="hljs-keyword">return</span> list(map(sum_triangle, upperline, lowerline, lowerline[<span class="hljs-number">1</span>:]))
​
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_gold</span><span class="hljs-params">(pyramid)</span>:</span>
    <span class="hljs-keyword">return</span> reduce(integrate, reversed(pyramid)).pop()
</code></pre><p><a href="http://www.checkio.org/user/evoynov/">@evoynov</a> used binary numbers to define all possible paths as combinations of 1 and 0
 in <a href="http://www.checkio.org/mission/golden-pyramid/publications/evoynov/python-3/binaries/share/95c5578eef9be0c793fc37fe54bdc95e/">"Binaries" solution</a>.
 But this solution has the complexity as recursive method that was described early. </p>
<pre class="grey-pre"><code>def <span class="hljs-function"><span class="hljs-title">count_gold</span><span class="hljs-params">(p)</span></span>:
    path = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">(p)</span></span>
    res = <span class="hljs-number">0</span>
    while <span class="hljs-function"><span class="hljs-title">bin</span><span class="hljs-params">(path)</span></span>.<span class="hljs-function"><span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-string">"1"</span>)</span></span> != <span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">(p)</span></span> + <span class="hljs-number">1</span>:
        s = ind = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-function"><span class="hljs-title">range</span><span class="hljs-params">(len(p)</span></span>):
            ind += <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> row &gt; <span class="hljs-number">0</span> and <span class="hljs-function"><span class="hljs-title">bin</span><span class="hljs-params">(path)</span></span>[<span class="hljs-number">3</span>:][row] == <span class="hljs-string">"1"</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
            s += <span class="hljs-tag">p</span>[row][ind]
        res = <span class="hljs-function"><span class="hljs-title">max</span><span class="hljs-params">(res, s)</span></span>
        path += <span class="hljs-number">1</span>
    return res
</code></pre><p>And just for final little brain breaking puzzle (don't worry it's not too hard) with
<a href="http://www.checkio.org/user/nickie/">@nickie's</a> in <a href="http://www.checkio.org/mission/golden-pyramid/publications/nickie/python-3/functional-dp/share/98bff2a8ad1f0ca4897de6e884ec384d/">"Functional DP" one-liner</a> which is only formally
two-liners. Of course this is solution from "Creative" category and don't think that @nickie
writes this for production. Just for fun.</p>
<pre class="grey-pre"><code>count_gold=lambda <span class="hljs-tag">p</span>:__import__(<span class="hljs-string">"functools"</span>).<span class="hljs-function"><span class="hljs-title">reduce</span><span class="hljs-params">(lambda D,r:[x+max(D[j],D[j+<span class="hljs-number">1</span>])</span></span>
<span class="hljs-keyword">for</span> j,x <span class="hljs-keyword">in</span> <span class="hljs-function"><span class="hljs-title">enumerate</span><span class="hljs-params">(r)</span></span>],<span class="hljs-tag">p</span>[-<span class="hljs-number">2</span>::-<span class="hljs-number">1</span>],<span class="hljs-function"><span class="hljs-title">list</span><span class="hljs-params">(p[-<span class="hljs-number">1</span>])</span></span>)[<span class="hljs-number">0</span>]
</code></pre><p>That's all folks. Propose your ideas for the next articles.</p>
<p><em>Valentin Bryukhanov aka Bryukh</em></p>

        </div>
        </div></body></html>