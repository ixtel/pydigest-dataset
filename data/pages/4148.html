<html><body><div><div class="content html_format">
      <a href="http://habrahabr.ru/company/acronis/blog/249963/"><img src="https://habrastorage.org/files/e91/ba0/95d/e91ba095d5534c389a3ca976f07e0085.jpg" align="left"/></a><p> Привет, Хабр! Сегодня немного поговорим про кроссплатформенную разработку, а именно – на языке Python. 
</p><p>
Язык Python сам по себе считается кросс-платформенным, но до тех пор, пока дело не доходит до взаимодействия python-скрипта и внешних платформозависимых компонентов. Например, механизм подключения сетевой папки в Windows и Linux кардинально отличается. И если Вы пишите кросс-платформенный скрипт или даже библиотеку, то без организации кросс-платформенного кода на самом высоком уровне абстракции вам не обойтись.
</p><a name="habracut"/><p>
Черпать идеи мы будем из самой кросс-платформенной библиотеки среди всех библиотек языка Python — </p><i>os.py</i><p>. В ней импортируются низкоуровневые модули в зависимости от состава стандартной библиотеки. Для разных платформ набор стандартных модулей интерпретатора Python разный. Вы можете в этом убедиться, посмотрев код модуля </p><i>os</i><p>.

</p><pre><code class="python">_names = sys.builtin_module_names

# Note:  more names are added to __all__ later.
__all__ = ["altsep", "curdir", "pardir", "sep", "extsep", "pathsep", "linesep",
           "defpath", "name", "path", "devnull",
           "SEEK_SET", "SEEK_CUR", "SEEK_END"]

def _get_exports_list(module):
    try:
        return list(module.__all__)
    except AttributeError:
        return [n for n in dir(module) if n[0] != '_']

if 'posix' in _names:
    name = 'posix'
    linesep = '\n'
    from posix import *
    try:
        from posix import _exit
    except ImportError:
        pass
    import posixpath as path

    import posix
    __all__.extend(_get_exports_list(posix))
    del posix
</code></pre><p>
Как видите, кортеж names содержит имена всех доступных модулей. Переменная модуля</p><i> __all__</i><p> отвечает, какие объекты будут доступны при импорте c помощью инструкции </p><i>from os import *</i><p>. Если доступен модуль </p><i>«posix»</i><p>, то выполняем специфичный для posix платформ код, а также прописываем ссылки на его доступные объекты в </p><i>os.__all__</i><p>. Затем удаляем объект posix, чтобы он был не доступен по вызову </p><i>os.posix</i><p>, так как он нам больше не нужен.
</p><p>
Таким образом, все объекты модуля posix доступны для вызова с помощью </p><i>os.объект_модуля_posix</i><p>. Аналогично и для Windows, только вместо posix — nt. 
</p><p>
Следует отметить, что в Windows версии интерпретатора доступен только модуль nt. Posix, solaris и другие модули платформ не входят в состав поставки. Аналогично и для других платформ. Тот факт, что интерпретатор скомпилирован под определенную платформу, не вписывается в идею кроссплатформенности. Поэтому дистрибутив нашей библиотеки содержит модули для всех платформ.
</p><p>
Приступим к написанию собственной кросс-платформенной библиотеки. Для примера, напишем библиотеку, которая будет подключать сетевую папку независимо от платформы. Давайте посмотрим на команды, с помощью которых происходит подключение сетевой папки в разных операционных системах:
</p><p>
В Linux:

</p><pre><code class="bash">mount //server/share /mount_point -o user=user,pass=password
</code></pre><p>
В Mac OSX:

</p><pre><code class="bash">mount_smbfs //user:password@server/share /mount_point
</code></pre><p>
В windows:

</p><pre><code class="dos">net use z: \\server\share /user:user password
</code></pre><p>
Не такие уж и разные команды. Как видите, каждая команда имеет в своем синтаксисе server, share, user и password. Все, что нам нужно, это определить платформу и выполнить функцию с входными параметрами server, share, user, password, mount_point (для win это будет буква диска).

</p><h2><font>Структура библиотеки</font></h2><p>
Структура файлов для нашей библиотеки будет следующей:
</p><img src="https://habrastorage.org/files/7af/bec/1a9/7afbec1a98ae483d9c251053047552b5.png"/>

<h3><font>__init__.py</font></h3><p>
Этот файл выполняет 2 функции:

</p><ol>
<li>Определяет, что папка mounter является пакетом</li>
<li>Импортирует в область видимости пакета mounter, объекты в зависимости от платформы</li>
</ol>
<pre><code class="python">if sys.platform == "win32":
    from mounter.win import *
if sys.platform == "darwin":
    from mounter.osx import *
if sys.platform == "linux2":
    from mounter.linux import *
</code></pre>
<h3><font>base.py</font></h3><p>
Содержит общие для всех платформ объекты и прототипы классов, на основе которых будут построены платформозависмые классы.

</p><pre><code class="python">import os
from subprocess import Popen, PIPE

class MounterBase():
    mount_cmd = None
    umount_cmd = None
    mount_point = None
    network_folder = None

    def _prepare(self):
        if not os.path.exists(self.mount_point):
            print 'creating %s folder for mounting' % self.mount_point
            os.makedirs(self.mount_point)

   def mount(self):
        self._prepare()
        Popen(self.mount_cmd, stdout=PIPE, stderr=PIPE, shell=True)

   def umount(self):
        Popen(self.umount_cmd, stdout=PIPE, stderr=PIPE, shell=True)
</code></pre><p>
(UPD: По замечанию пользователя  </p><a href="http://habrahabr.ru/users/hellman/" class="user_link">hellman</a><p> стоит отметить, что использовать shell=True </p><a href="https://docs.python.org/2/library/subprocess.html#frequently-used-arguments">не безопасно</a><p>. Чтобы не усложнять пример, пожертвуем некоторой безопасностью, ради наглядности).</p><p>
Здесь класс MounterBase является прототипом будущих платформозависимых классов из файлов </p><i>win.py</i><p>, </p><i>osx.py</i><p>, </p><i>linux.py</i><p> и пока ничего полезного не умеет, так как команды для монтирования и размонтирования не определенны. А теперь рассмотрим один из платформозависымых модулей.

</p><h3><font>linux.py</font></h3>
<pre><code class="python">import mounter

class Mounter(mounter.MounterBase):
    def __init__(self, network_folder, mount_point, user, password):
        mount_cmd = "mount {network_folder} {mount_point} -o user={user},pass={password}"
        self.mount_cmd = mount_cmd.format(network_folder=network_folder,
                                          mount_point=mount_point,
                                          user=user,
                                          password=password)
        self.umount_cmd = "umount {mount_point}".format(mount_point=mount_point)
</code></pre><p>
В этом классе мы описываем специфичные параметры для платформы Linux, а именно команды монтирования и размонтирования. Сделаем аналогично для Мака и Windows.

</p><h3><font>osx.py</font></h3>
<pre><code class="python">class Mounter(mounter.MounterBase):
    def __init__(self, network_folder, mount_point, user, password):
        mount_cmd = "mount_smbfs //{user}:{password}@{network_folder} {mount_point}"
        self.mount_cmd = mount_cmd.format(network_folder=network_folder,
                                            mount_point=mount_point,
                                            user=user,
                                            password=password)
        self.umount_cmd = "umount {mount_point}".format(mount_point=mount_point)
</code></pre>
<h3><font>win.py</font></h3>
<pre><code class="python">class Mounter(mounter.MounterBase):
    def __init__(self, network_folder, mount_point, user, password):
        network_folder =network_folder.replace("/", "\\")
        mount_cmd = "net use {mount_point} \\{network_folder} /user:{user} {password}"
        self.mount_cmd = mount_cmd.format(network_folder=network_folder,
                                            mount_point=mount_point,
                                            user=user,
                                            password=password)
        self.umount_cmd = "net use {mount_point} /delete /y".format(mount_point=mount_point)
</code></pre><p>
В итоге, чтобы подключить сетевую папку, нам достаточно вызвать метод </p><i>mount()</i><p> экземпляра класса </p><i>mounter.Mounter()</i><p>:

</p><pre><code class="python">import mounter

...
mount_point = "/mnt/mount_moint"
share = mounter.Mounter("server/share", mount_point, "guest", "secret_password")
share.mount()
copy_requared_files(source=mount_point, dest="/tmp")
share.umount()
</code></pre><p>
Теперь не нужно помнить синтаксис команд для всех платформ. Конечно, мы реализовали самый примитивный механизм подключения сетевой папки. В этом механизме не учитывается, что сетевая папка может быть без пароля, а также другие особенности. Реализацию этих особенностей я оставлю вам.
</p><p>
Подобную архитектуру мы используем в автоматическом тестировании продуктов Acronis True Image for Windows и Acronis True Image for Mac. Например, чтобы выполнить процедуру бекапа, достаточно вызвать функцию </p><i>TrueImage.backup()</i><p>, и в зависимости от платформы, на которой был запущен скрипт, будет выполнятся соответствующий платформозависимый код.
</p><p>
Предыдущие посты у нас в блоге:</p><p>
– </p><a href="http://habrahabr.ru/post/237971/">Мультиплатформенная разработка True Image</a><p>
– </p><a href="http://habrahabr.ru/post/234107/">50 оттенков синего, или сказ о том, как мы делали дизайн True Image 2015 </a><p>
– </p><a href="http://habrahabr.ru/post/234287/">Acronis Snap Deploy 5: Массовый деплоймент быстро просто и надёжно</a><p>
– </p><a href="http://habrahabr.ru/post/255131/">«Ни единого разрыва!» или зачем клиенту воевать с техподдержкой</a><p>
– </p><a href="http://habrahabr.ru/post/250145/">Стадии рождения новой функциональности в программном продукте</a><p>
– </p><a href="http://habrahabr.ru/post/254577/">Золотое правило бэкапа</a>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>