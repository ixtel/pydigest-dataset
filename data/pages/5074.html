<html><body><div><div role="main" id="main">
<p>

What if you need to process a series of values to answer a certain question,
that you cannot store in memory as a list?
For example when you read a huge file? Or if you can calculate the next value based on
some of the previous values and some external information that comes to light during
processing. Even a random series. Or if the series is infinite and you don't know up-front
how far you need to go to find your answer.
</p><p>

In this article we are going to see 2 solutions:
</p><p>

</p><ul>
  <li>A plain function.</li>
  <li>A function with a callback.</li>
</ul>
<p>

Then you can follow-up with a solution using <a href="/callback-or-iterator-in-python">iterators</a>
and another solution using <a href="/function-vs-generator-in-python">generators</a>.
</p><p>

</p><p>

In order to avoid the need to explain a complex algorithm, we are going to use
the well-known Fibonacci series and the question we need to answer is
"What is the first number in the series that can be divided by 17."
</p><p>

A much more complex use-case like that would be if you needed to go over DNA sequences
in a database, constantly refining your request for the next sequence before
locating one that fits your requirements.
</p><p>

In the case of the Fibonacci series we could compute the first few elements of
the list up-front, but that won't help in the general case. Even in the case of
the Fibonacci series no fixed sublist will be able to answer any arbitrary question,
and in the case of the DNA sequences, it is quite clear that we don't even have
enough memory to prepare the list up-front.
</p><p>

</p><h2>Simple Fibonacci function</h2>
<p>

So let's see a simple implementation of the Fibonacci series and then tweak that
solution.
</p><p>

<b>examples/python/fibonacci_function.py</b><br/></p><pre class="prettyprint linenums language-python">
#!/usr/bin/env python
from __future__ import print_function

def fibonacci():
    values = []
    while(True):
        if len(values) &lt; 2:
            values.append(1)
        else:
            values = [values[-1], values[-1] + values[-2]]

if __name__ == '__main__':
    fibonacci()
</pre>
<p>

There is nothing fancy in this implementation, but I don't recommend that you
run it, as
it does not have any output, and it does not have a stop condition. So if
you run it, it will appear to be "stuck".
</p><p>

You could include a
</p><p>

</p><pre class="linenums">
print(values[-1])
</pre>
<p>

in the loop to see what's going on and you could include something like this:
</p><p>

</p><pre class="linenums">
if (values[-1] &gt; 100):
    break;
</pre>
<p>

to limit the series.
</p><p>

</p><h2>Our "question" - divide by 17</h2>
<p>

Just to remind you that our task is to "research the Fibonacci series",
and the first question we need to answer is
"What is the first number in the Fibonacci series that can be divided by 17?"
</p><p>

So we enhance the function to return the first value that can be divided by 17:
</p><p>

<b>examples/python/fibonacci_function_mod_17.py</b><br/></p><pre class="prettyprint linenums language-python">
#!/usr/bin/env python
from __future__ import print_function

def fibonacci():
    values = []
    while(True):
        if len(values) &lt; 2:
            values.append(1)
        else:
            values = [values[-1], values[-1] + values[-2]]

        if values[-1] % 17 == 0:
            return(values[-1])

if __name__ == '__main__':
    res = fibonacci()
    print(res)
</pre>
<p>

We just included the following statement, which checks if the current
value of the series can be wholly divided by 17:
</p><p>

</p><pre class="linenums">
if values[-1] % 17 == 0:
    return(values[-1])
</pre>
<p>

We have also changed the code to return the Fibonacci number that fulfills
our requirement. It is much better now that the program prints the result.
</p><p>

Running that script will stop at 34.
</p><p>

Later we might have other question we need to answer. What if there is no answer at all?
In case we'd better add some safety measures so the code will stop.
</p><p>

</p><h2>Safety measures - limit the loop</h2>
<p>

By including a limitation like this, we can make sure our code will eventually
stop, even if we don't have an answer to our particular question.
</p><p>

</p><pre class="linenums">
if values[-1] &gt; 10000:
    return
</pre>
<p>

Of course we could use a much bigger number for that or we could base our limitation
on the number of elements checked.
</p><p>

The full code is here:
</p><p>

<b>examples/python/fibonacci_function_with_safety.py</b><br/></p><pre class="prettyprint linenums language-python">
from __future__ import print_function

def fibonacci():
    values = []
    while(True):
        if len(values) &lt; 2:
            values.append(1)
        else:
            values = [values[-1], values[-1] + values[-2]]

        if values[-1] % 17 == 0:
            return(values[-1])

        if values[-1] &gt; 10000:
            return

if __name__ == '__main__':
    res = fibonacci()
    if (res != None):
        print(res)
</pre>
<p>

</p><h2>What was the problem?</h2>
<p>

We now have a simple function that can check a specific condition and return
the first value that matches the condition. If tomorrow I'll need to answer
"What is the first Fibonacci number that can be divided by 19?",
or maybe
"What is the first Fibonacci number that is the square of another number?",
</p><p>

I can just copy-paste the function and change the condition.
</p><p>

That sounds simple, but that means we have lots of copies of the code implementing
the Fibonacci function. What if our algorithm is much larger? Do we still want to
have that code to be copied over and over again?
</p><p>

What if we find a bug in our algorithm (or just found a better way to calculate it)
after we have created 20 copies to answer various question?
</p><p>

That's clearly not a good path to go down.
</p><p>

Let's have a different approach. Let's change the Fibonacci function so
it will accept a function as parameter and will call that function for
every element in the Fibonacci sequence.
</p><p>

</p><h2>Callback function</h2>
<p>

The <span class="inline_code">fibonacci</span> function now looks like this:
it accepts a parameter called <span class="inline_code">cb</span> which is expected to be a function
and once we have calculated the new element in the series we call
the callback function passing the most recent element to it: <span class="inline_code">cb(values[-1])</span>.
</p><p>

The returned value is expected to be a list or a tuple in which the first element
will be <span class="inline_code">True</span> or <span class="inline_code">False</span> indicating if we have found the answer (True)
or not yet (False). If it i True, we return the second element of the result.
</p><p>

</p><pre class="linenums">
def fibonacci(cb):
    values = []
    while(True):
        if len(values) &lt; 2:
            values.append(1)
        else:
            values = [values[-1], values[-1] + values[-2]]

        r = cb(values[-1])
        if (r[0]):
            return(r[1])
</pre>
<p>

Based on this the callback function must accept a single value and return
a tuple of list in which the first element is True/False and the second element
is the value matching our condition.
</p><p>

The callback function looks like this:
It accepts a value <span class="inline_code">v</span>, the current value of the series.
It returns <span class="inline_code">True</span> and the value it found once it found a value that can
be divided by 17.
</p><p>

It returns <span class="inline_code">True</span> and <span class="inline_code">None</span> if it reached the safety limit we set.
The True will indicate to the fibonacci function that the search has ended,
and the None will indicate to the end-user that no answer was found.
</p><p>

Lastly, we return a tuple with only one <span class="inline_code">False</span> value indicating to
the fibonacci function that this was not a good value and we are expecting to be called
with another value.
</p><p>

</p><pre class="linenums">
def check_17(v):
    if v % 17 == 0:
        return (True, v)

    if v &gt; 10000:
        return (True, None)

    return (False,)
</pre>
<p>

The full implementation look like this:
</p><p>

<b>examples/python/fibonacci_function_callback.py</b><br/></p><pre class="prettyprint linenums language-python">
#!/usr/bin/env python
from __future__ import print_function

def fibonacci(cb):
    values = []
    while(True):
        if len(values) &lt; 2:
            values.append(1)
        else:
            values = [values[-1], values[-1] + values[-2]]

        r = cb(values[-1])
        if (r[0]):
            return(r[1])

def check_17(v):
    if v % 17 == 0:
        return (True, v)

    if v &gt; 10000:
        return (True, None)

    return (False,)


if __name__ == '__main__':
    res = fibonacci(check_17)
    if (res != None):
        print(res)
</pre>
<p>

This solution is much better than the one had earlier. Now we don't need to change
the fibonacci function based on the question we are asking. We could move
the fibonacci function to a module, import it and use it as an external resource.
If it needs fixing, it can be fixed in one place, and all the places it is
used will benefit from that.
</p><p>

Even better, the functions we create as callback can also be reused for by calling
each other or by passing them to other sequence-generating functions.
</p><p>

</p><h2>Iterators and Generators</h2>
<p>

There are two additional solutions to this problem.
One is by creating an <a href="/callback-or-iterator-in-python">iterator</a>,
and the other one is by creating a <a href="/function-vs-generator-in-python">generator</a>.

</p></div>



<p>


  In the comments, please wrap your code snippets within &lt;pre&gt; &lt;/pre&gt; tags and use spaces for indentation.

</p></div></body></html>