<html><body><div><div class="content">
      
        <h1 class="content-title">Window functions, case statements, and savepoints in peewee</h1>
      
      
      
  <div class="post-info"><p>
    
    
      February 21, 2014 10:44
      </p><span class="separator">/</span>
      <a href="#comments">0 comments</a>
      <span class="separator">/</span>
      
        <a href="/blog/tags/peewee/">peewee</a>
      
        <a href="/blog/tags/python/">python</a>
      
        <a href="/blog/tags/sql/">sql</a>
      
    
  </div>
  
  
    <p>In case you've missed the <a href="https://github.com/coleifer/peewee/releases">last few releases</a>, I've
been busy adding some fun new features to peewee. While the changelog and the <a href="http://docs.peewee-orm.com/">docs</a>
explain the new features and describe their usage, I thought I'd write a blog post
to provide a bit more context.</p>
<p>Most of these features were requested by peewee users. I depend heavily on users
like you to help me improve peewee, so thank you very much! Not only have your
feature requests helped make peewee a better library, they've helped me become a
better programmer.</p>
<p>So what's new in peewee? Here is something of an overview:</p>

<p>Hopefully some of those things sound interesting. In this post I will not be
discussing everything, but will hit some of the highlights.</p>
<h3>Window functions</h3>
<p>Someone recently asked me whether peewee supported Postgresql's <a href="http://www.postgresql.org/docs/8.4/static/tutorial-window.html">window functions</a>.
At the time peewee did not, as I kind of had mentally lumped window functions together under
the "exotic SQL things you'll never use" category. After spending some time reading,
I changed my mind and decided peewee absolutely needed to support window functions
(I wanted to start using them on a side project, of course).</p>
<p>If you're also new to window functions, there are many excellent guides online -- I really
enjoyed <a href="http://www.pgcon.org/2009/schedule/attachments/98_Windowing%20Functions.pdf">these slides</a> from
a PGCon talk by Hitoshi Harada. My understanding is that window functions allow you
mix multi-row aggregations with individual result rows. So window functions are
kind of like aggregations, except applied to a subset of the result set, and
then available throughout the result set.</p>
<p>Let's say we're tracking page-views on our site and want to look at response
times to see which pages are slow. To get the average response time for a page,
you would use normal SQL aggregates to write something like:</p>
<div class="highlight"><pre><span class="n">query</span> <span class="o">=</span> <span class="p">(</span><span class="n">PageView</span>
         <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">PageView</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="n">fn</span><span class="o">.</span><span class="n">AVG</span><span class="p">(</span><span class="n">PageView</span><span class="o">.</span><span class="n">response_time</span><span class="p">))</span>
         <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">PageView</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
         <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">AVG</span><span class="p">(</span><span class="n">PageView</span><span class="o">.</span><span class="n">response_time</span><span class="p">)</span><span class="o">.</span><span class="n">desc</span><span class="p">())</span>
         <span class="o">.</span><span class="n">tuples</span><span class="p">())</span>
</pre></div>
<p>This type of query is fine, but it doesn't really give us an indication of how each individual page-view contributed to the average. It would be cool if we could get an idea of which individual page-views were slower than average.</p>
<p>What if we wanted to list out <em>all</em> the PageViews, sorted by how much slower
they were than the average response time of requests to the same URL? That is,
display the difference between the PageView's response time and the average response time
for other requests to the same URL. To do that, we can use window functions. We
will take the average of the response time then partition it by the requested URL:</p>
<div class="highlight"><pre><span class="n">window</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">AVG</span><span class="p">(</span><span class="n">PageView</span><span class="o">.</span><span class="n">response_time</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">partition_by</span><span class="o">=</span><span class="p">[</span><span class="n">PageView</span><span class="o">.</span><span class="n">url</span><span class="p">])</span>
<span class="n">query</span> <span class="o">=</span> <span class="p">(</span><span class="n">PageView</span>
         <span class="o">.</span><span class="n">select</span><span class="p">(</span>
             <span class="n">PageView</span><span class="o">.</span><span class="n">url</span><span class="p">,</span>
             <span class="n">PageView</span><span class="o">.</span><span class="n">response_time</span><span class="p">,</span>
             <span class="n">window</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">'avg_response'</span><span class="p">),</span>
             <span class="p">(</span><span class="n">PageView</span><span class="o">.</span><span class="n">response_time</span> <span class="o">-</span> <span class="n">window</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">'difference'</span><span class="p">),</span>
             <span class="n">PageView</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
         <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span><span class="s1">'difference'</span><span class="p">)</span><span class="o">.</span><span class="n">desc</span><span class="p">()))</span>

<span class="k">for</span> <span class="n">url</span><span class="p">,</span> <span class="n">response_time</span><span class="p">,</span> <span class="n">avg_response</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">timestamp</span> <span class="ow">in</span> <span class="n">query</span><span class="o">.</span><span class="n">tuples</span><span class="p">():</span>
    <span class="k">print</span> <span class="n">url</span><span class="p">,</span> <span class="n">response_time</span><span class="p">,</span> <span class="n">avg_response</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">timestamp</span>
</pre></div>
<p>Here is a sampling of what the results might look like. The <code>avg_response</code> is
calculated for each distinct URL, then included in the result rows. We can also
compare the response time with the average, then sort by that value. The table below
shows which page-views were significantly slower than the average for that URL.
We can see that the worst offenders all occurred around 4 A.M., which coincidentally
is when the backups are run.</p>
<pre>
        url    | resp_time | avg_response | diff   |       timestamp
    -----------+-----------+--------------+--------+---------------------
     /blog/    |       2.5 | 1.099        |  1.400 | 2014-01-02 04:xx:xx
     /about/   |       4.3 | 3.342        |  0.957 | 2014-01-02 04:xx:xx
     /blog/    |         2 | 1.099        |  0.900 | 2014-01-02 04:xx:xx
     /about/   |         4 | 3.342        |  0.657 | 2014-01-02 04:xx:xx
     /about/   |       3.9 | 3.342        |  0.557 | 2014-01-02 04:xx:xx
     /blog/    |       1.5 | 1.099        |  0.400 | 2014-01-02 04:xx:xx
     /blog/    |       1.5 | 1.099        |  0.400 | 2014-01-01 01:xx:xx
     /about/   |       3.7 | 3.342        |  0.357 | 2014-01-02 17:xx:xx
     /blog/    |       1.4 | 1.099        |  0.299 | 2014-01-01 22:xx:xx
     /blog/    |       1.4 | 1.099        |  0.299 | 2014-01-01 11:xx:xx
     /contact/ |       2.5 | 2.308        |  0.191 | 2014-01-01 07:xx:xx
</pre>
<p>Similarly, what if we wanted to compare the response time for a request with the
average response time for all other requests on the same day? To do this we will
look at a window containing the average response times over the course of a
single day (using the SQL <code>date_trunc</code> function):</p>
<div class="highlight"><pre><span class="n">window</span> <span class="o">=</span> <span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">AVG</span><span class="p">(</span><span class="n">PageView</span><span class="o">.</span><span class="n">response_time</span><span class="p">)</span>
          <span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">partition_by</span><span class="o">=</span><span class="p">[</span><span class="n">fn</span><span class="o">.</span><span class="n">date_trunc</span><span class="p">(</span><span class="s1">'day'</span><span class="p">,</span> <span class="n">PageView</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)]))</span>
<span class="n">query</span> <span class="o">=</span> <span class="p">(</span><span class="n">PageView</span>
         <span class="o">.</span><span class="n">select</span><span class="p">(</span>
             <span class="n">PageView</span><span class="o">.</span><span class="n">url</span><span class="p">,</span>
             <span class="n">PageView</span><span class="o">.</span><span class="n">response_time</span><span class="p">,</span>
             <span class="n">window</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">'avg_response'</span><span class="p">),</span>
             <span class="n">PageView</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
         <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">PageView</span><span class="o">.</span><span class="n">timestamp</span><span class="p">))</span>

<span class="k">for</span> <span class="n">url</span><span class="p">,</span> <span class="n">response_time</span><span class="p">,</span> <span class="n">avg_response</span><span class="p">,</span> <span class="n">timestamp</span> <span class="ow">in</span> <span class="n">query</span><span class="o">.</span><span class="n">tuples</span><span class="p">():</span>
    <span class="k">print</span> <span class="n">url</span><span class="p">,</span> <span class="n">response_time</span><span class="p">,</span> <span class="n">avg_response</span><span class="p">,</span> <span class="n">timestamp</span>
</pre></div>
<p>Here are some sample results - the average here is for the day on which the PageView
occurred:</p>
<pre>
        url    | resp_time | avg_response |      timestamp
    -----------+-----------+--------------+---------------------
     /blog/    |       0.7 | 1.535        | 2014-01-01 xx:xx:xx
     /contact/ |       2.5 | 1.535        | 2014-01-01 xx:xx:xx
     /blog/    |       1.4 | 1.535        | 2014-01-01 xx:xx:xx
     /about/   |       3.2 | 1.535        | 2014-01-01 xx:xx:xx
    ...
     /contact/ |     2.125 | 1.744        | 2014-01-02 xx:xx:xx
     /blog/    |       1.5 | 1.744        | 2014-01-02 xx:xx:xx
     /about/   |         4 | 1.744        | 2014-01-02 xx:xx:xx
     /blog/    |         1 | 1.744        | 2014-01-02 xx:xx:xx
</pre>
<p>We can combine the two to compare a single response time with the average
response time for all other requests to the same URL, on the same day. To do
this we will just include both the URL and the <code>date_trunc</code> function in the <code>partition_by</code>
clause when setting up our window:</p>
<div class="highlight"><pre><span class="n">window</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">AVG</span><span class="p">(</span><span class="n">PageView</span><span class="o">.</span><span class="n">response_time</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span>
    <span class="n">partition_by</span><span class="o">=</span><span class="p">[</span><span class="n">PageView</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="n">fn</span><span class="o">.</span><span class="n">date_trunc</span><span class="p">(</span><span class="s1">'day'</span><span class="p">,</span> <span class="n">PageView</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)]),</span>
<span class="n">query</span> <span class="o">=</span> <span class="p">(</span><span class="n">PageView</span>
         <span class="o">.</span><span class="n">select</span><span class="p">(</span>
             <span class="n">PageView</span><span class="o">.</span><span class="n">url</span><span class="p">,</span>
             <span class="n">PageView</span><span class="o">.</span><span class="n">response_time</span><span class="p">,</span>
             <span class="n">window</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">'avg_response'</span><span class="p">),</span>
             <span class="n">PageView</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
         <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">PageView</span><span class="o">.</span><span class="n">timestamp</span><span class="p">))</span>
</pre></div>
<p>This gives us an <code>avg_response</code> for each URL + day:</p>
<pre>
        url    | resp_time | avg_response |      timestamp
    -----------+-----------+--------------+---------------------
     /blog/    |       0.7 |        1.149 | 2014-01-01 xx:xx:xx
     /blog/    |       0.9 |        1.149 | 2014-01-01 xx:xx:xx
     /contact/ |       2.6 |          2.6 | 2014-01-01 xx:xx:xx
     /about/   |         2 |          2.5 | 2014-01-01 xx:xx:xx
     /about/   |       2.3 |          2.5 | 2014-01-01 xx:xx:xx
    ...
     /blog/    |         1 |         1.05 | 2014-01-02 xx:xx:xx
     /blog/    |       1.1 |         1.05 | 2014-01-02 xx:xx:xx
     /contact/ |     2.125 |        2.212 | 2014-01-02 17:00:00
     /about/   |         4 |        3.975 | 2014-01-02 18:00:00
     /about/   |       3.7 |        3.975 | 2014-01-02 15:00:00
</pre>
<p>These examples all show how you can perform aggregates on partitions of the result
set, but that is only half of what window functions can do. Window functions can
also look at rows in relation to other rows in the result set.</p>
<p>Suppose I'm running a race and the runners are in one of two categories (youth
and adult). I've got their time (in seconds) and category, and would like to
let each runner know what order they finished in for their category. The raw
data looks like this:</p>
<pre>
     finish_time | category
    -------------+----------
             339 | adult
             366 | adult
             372 | adult
             384 | adult
             407 | adult
             412 | adult
             414 | adult
             447 | adult
             484 | adult
             315 | youth
             321 | youth
             362 | youth
             363 | youth
             366 | youth
             430 | youth
             449 | youth
             467 | youth
             476 | youth
             485 | youth
             485 | youth
</pre>
<p>As you guessed, we'll be using window functions. We will use the <code>rank()</code> function
to get an absolute ranking:</p>
<div class="highlight"><pre><span class="n">query</span> <span class="o">=</span> <span class="p">(</span><span class="n">Times</span>
         <span class="o">.</span><span class="n">select</span><span class="p">(</span>
             <span class="n">Times</span><span class="o">.</span><span class="n">finish_time</span><span class="p">,</span>
             <span class="n">Times</span><span class="o">.</span><span class="n">category</span><span class="p">,</span>
             <span class="n">fn</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span>
                 <span class="n">partition_by</span><span class="o">=</span><span class="p">[</span><span class="n">Times</span><span class="o">.</span><span class="n">category</span><span class="p">],</span>
                 <span class="n">order_by</span><span class="o">=</span><span class="p">[</span><span class="n">Times</span><span class="o">.</span><span class="n">finish_time</span><span class="p">])</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">'place'</span><span class="p">))</span>
         <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Times</span><span class="o">.</span><span class="n">category</span><span class="p">,</span> <span class="n">SQL</span><span class="p">(</span><span class="s1">'place'</span><span class="p">)))</span>
<span class="k">for</span> <span class="n">ft</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">place</span> <span class="ow">in</span> <span class="n">query</span><span class="o">.</span><span class="n">tuples</span><span class="p">():</span>
    <span class="k">print</span> <span class="n">ft</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">place</span>
</pre></div>
<p>This prints the following table. Note that two runners in the youth category
had the same time (485) -- both runners are given 10th place:</p>
<pre>
     finish_time | category | place
    -------------+----------+-------
             339 | adult    |     1
             366 | adult    |     2
             372 | adult    |     3
             384 | adult    |     4
             407 | adult    |     5
             412 | adult    |     6
             414 | adult    |     7
             447 | adult    |     8
             484 | adult    |     9
             315 | youth    |     1
             321 | youth    |     2
             362 | youth    |     3
             363 | youth    |     4
             366 | youth    |     5
             430 | youth    |     6
             449 | youth    |     7
             467 | youth    |     8
             476 | youth    |     9
             485 | youth    |    10
             485 | youth    |    10
</pre>
<p>What if we wanted to know how much each runner trailed the runner ahead of them?
That is, we want the gaps in each finish time. For this we can use the <code>lag</code>
function, which returns us a value from a preceding row. We will then subtract
the previous runner's time from the current time to get the difference:</p>
<div class="highlight"><pre><span class="n">window</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">lag</span><span class="p">(</span><span class="n">Times</span><span class="o">.</span><span class="n">finish_time</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span>
    <span class="n">partition_by</span><span class="o">=</span><span class="p">[</span><span class="n">Times</span><span class="o">.</span><span class="n">category</span><span class="p">],</span>
    <span class="n">order_by</span><span class="o">=</span><span class="p">[</span><span class="n">Times</span><span class="o">.</span><span class="n">finish_time</span><span class="p">])</span>
<span class="n">query</span> <span class="o">=</span> <span class="p">(</span><span class="n">Times</span>
         <span class="o">.</span><span class="n">select</span><span class="p">(</span>
             <span class="n">Times</span><span class="o">.</span><span class="n">finish_time</span><span class="p">,</span>
             <span class="n">Times</span><span class="o">.</span><span class="n">category</span><span class="p">,</span>
             <span class="p">(</span><span class="n">Times</span><span class="o">.</span><span class="n">finish_time</span> <span class="o">-</span> <span class="n">window</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">'time_diff'</span><span class="p">))</span>
         <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Times</span><span class="o">.</span><span class="n">category</span><span class="p">,</span> <span class="n">Times</span><span class="o">.</span><span class="n">finish_time</span><span class="p">))</span>
</pre></div>
<p>This yields the following table. The first-place runner in each category has
no value in the <code>time_diff</code> column, since nobody finished before them.</p>
<pre>
     finish_time | category | time_diff
    -------------+----------+-----------
             339 | adult    |
             366 | adult    |        27
             372 | adult    |         6
             384 | adult    |        12
             407 | adult    |        23
             412 | adult    |         5
             414 | adult    |         2
             447 | adult    |        33
             484 | adult    |        37
             315 | youth    |
             321 | youth    |         6
             362 | youth    |        41
             363 | youth    |         1
             366 | youth    |         3
             430 | youth    |        64
             449 | youth    |        19
             467 | youth    |        18
             476 | youth    |         9
             485 | youth    |         9
             485 | youth    |         0
</pre>
<p>There are all sorts of special window-specific aggregates in addition to <code>lag</code>
and <code>rank</code>. For a comprehensive list, check out the <a href="http://www.postgresql.org/docs/9.1/static/functions-window.html">Postgresql docs</a>.</p>
<p>I'm still learning my way around, but so far I've had a fun time experimenting
with this feature!</p>
<h3>Case statements</h3>
<p>Somehow I've managed to scrape by the past few years without really needing to
use <code>CASE</code> statements in my queries. Then a couple months ago I had a pretty
tricky query I needed to run, and after struggling for a while, I found that by
using a <code>CASE</code> statement I could simplify things considerably.</p>
<p>So the setup is: let's say you're Amazon and you are shipping a person's order
from several different warehouses, in several different shipments. You want to
know when the person's order has been <em>fully</em> shipped or otherwise reached some
"final" state. We'll say this could happen when each package's status becomes
either "shipped" or "undeliverable".</p>
<p>Here is our simple data model:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Order</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">recipient</span> <span class="o">=</span> <span class="n">CharField</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Package</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">ForeignKeyField</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span>
    <span class="n">description</span> <span class="o">=</span> <span class="n">CharField</span><span class="p">()</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">CharField</span><span class="p">()</span>
</pre></div>
<p>The way I went about getting this list was to calculate the number of Packages
associated with the order, then check that this <em>Count</em> equaled the number of
Packages in a terminal state. Here is the SQL:</p>
<div class="highlight"><pre><span class="k">SELECT</span> <span class="n">t1</span><span class="p">.</span><span class="ss">"id"</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="ss">"recipient"</span> <span class="k">FROM</span> <span class="ss">"order"</span> <span class="k">as</span> <span class="n">t1</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="ss">"package"</span> <span class="k">AS</span> <span class="n">t2</span> <span class="k">ON</span> <span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="ss">"id"</span> <span class="o">=</span> <span class="n">t2</span><span class="p">.</span><span class="ss">"order_id"</span><span class="p">)</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">t1</span><span class="p">.</span><span class="ss">"id"</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="ss">"recipient"</span>
<span class="k">HAVING</span> <span class="p">(</span>
  <span class="k">COUNT</span><span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="ss">"id"</span><span class="p">)</span> <span class="o">=</span> <span class="k">SUM</span><span class="p">(</span>
    <span class="k">CASE</span>
      <span class="k">WHEN</span> <span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="ss">"status"</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">'shipped'</span><span class="p">,</span> <span class="s1">'undeliverable'</span><span class="p">))</span> <span class="k">THEN</span> <span class="mi">1</span>
      <span class="k">ELSE</span> <span class="mi">0</span>
    <span class="k">END</span>
  <span class="p">))</span>
</pre></div>
<p>To express this using peewee, I wrote a little helper in <code>playhouse.shortcuts</code>
to generate the <code>CASE</code> statement:</p>
<div class="highlight"><pre><span class="c1"># Represents "status" IN ('shipped', 'undeliverable')</span>
<span class="n">predicate</span> <span class="o">=</span> <span class="n">Package</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;&lt;</span> <span class="p">[</span><span class="s1">'shipped'</span><span class="p">,</span> <span class="s1">'undeliverable'</span><span class="p">]</span>

<span class="n">shipped</span> <span class="o">=</span> <span class="p">(</span><span class="n">Order</span>
           <span class="o">.</span><span class="n">select</span><span class="p">()</span>
           <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Package</span><span class="p">)</span>
           <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span>
           <span class="o">.</span><span class="n">having</span><span class="p">(</span>
               <span class="n">fn</span><span class="o">.</span><span class="n">COUNT</span><span class="p">(</span><span class="n">Package</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="o">==</span>
               <span class="n">fn</span><span class="o">.</span><span class="n">SUM</span><span class="p">(</span><span class="n">case</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="p">[(</span><span class="n">predicate</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="mi">0</span><span class="p">))</span>
           <span class="p">))</span>
</pre></div>
<p>If you'd like to see more examples of the <code>case</code> helper in peewee, check
out the <a href="http://docs.peewee-orm.com/en/latest/peewee/playhouse.html#case">case documentation</a>.
And yes, this query could also be done with some double negation:</p>
<div class="highlight"><pre><span class="c1"># Packages for the given order that are not in the shipped or</span>
<span class="c1"># undeliverable state.</span>
<span class="n">subquery</span> <span class="o">=</span> <span class="p">(</span><span class="n">Package</span>
            <span class="o">.</span><span class="n">select</span><span class="p">()</span>
            <span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="p">(</span><span class="n">Package</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="n">Order</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="o">&amp;</span>
                <span class="o">~</span><span class="p">(</span><span class="n">Package</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;&lt;</span> <span class="p">[</span><span class="s1">'shipped'</span><span class="p">,</span> <span class="s1">'undeliverable'</span><span class="p">])))</span>

<span class="c1"># Orders for which no packages exist which are *not* shipped</span>
<span class="c1"># or undeliverable. Also do an INNER join to ensure that at</span>
<span class="c1"># least one Package exists.</span>
<span class="n">shipped</span> <span class="o">=</span> <span class="p">(</span><span class="n">Order</span>
           <span class="o">.</span><span class="n">select</span><span class="p">()</span>
           <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Package</span><span class="p">)</span>
           <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">Clause</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span><span class="s1">'EXISTS'</span><span class="p">),</span> <span class="n">subquery</span><span class="p">))</span>
           <span class="o">.</span><span class="n">distinct</span><span class="p">())</span>
</pre></div>
<h3>Savepoints</h3>
<p>The last feature I'll mention here is <a href="http://www.postgresql.org/docs/9.1/static/sql-savepoint.html">savepoints</a>, which
are supported by Postgresql, MySQL and Sqlite. Savepoints
basically allow you to nest transactions. The peewee implementation uses a similar
API to transactions. Here is how you might use savepoints to implement <code>get_or_create</code>:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">CharField</span><span class="p">(</span><span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_or_create</span><span class="p">(</span><span class="n">email</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">db</span><span class="o">.</span><span class="n">savepoint</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">User</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">email</span><span class="o">=</span><span class="n">email</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">IntegrityError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">User</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">email</span> <span class="o">==</span> <span class="n">email</span><span class="p">)</span>
</pre></div>
<p>In the example above, the <code>get_or_create</code> function will create a new savepoint
(so as not to disturb any existing transaction) and then attempt to insert a
new row. If the database raises an <code>IntegrityError</code>, we know that the email is
already in use, so we can catch the exception and return the existing row. Pretty
cool, right?</p>
<h3>What's next?</h3>
<p>This post was getting a bit long so I'm cutting it here, but I hope to write about
the other new features I didn't get to cover (arrays, json fields, compound queries).</p>
<p>In terms of peewee, I'm always interested in ideas for useful features so please
don't be shy if you think something's missing from the library. One that has
come up several times recently is connection pooling, so be on the lookout for that
in the next couple of releases.</p>
<h3>Reading more</h3>
<p>Thanks for taking the time to read this post, I hope you found it interesting.
Feel free to leave a comment below. If you have a specific question about peewee,
you can post it to the <a href="https://groups.google.com/group/peewee-orm">mailing list</a> or ask in <code>#peewee</code> on freenode.</p>
<p>If you'd like to read more, the following links may be of interest:</p>

  
  


<hr/>

  <p>Commenting has been closed, but please feel free to <a href="/contact/">contact me</a></p>


    </div>

    </div></body></html>