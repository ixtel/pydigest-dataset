<html><body><div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

				<p><em>This post was featured on <a href="http://us4.campaign-archive2.com/?u=9735795484d2e4c204da82a29&amp;id=686dc9891c">PyCoders Weekly #151</a>.</em></p>

<p>Lately I had to port 16 thousand lines of Scala code into Python. The task seemed odd at first as usually the Python code is re-written in Scala and not the other way round. Anyway it’s done now and I managed to pick up some Scala skills and also observed the difficulties of translating between those two languages. Before I start: I just want to mention that Scala is a very cool language and I hope to work with Scala again in the near future.</p>

<h2 id="key-value-pairs-in-python-dictionaries-and-scala-maps-have-different-order">1. Key-value pairs in Python dictionaries and Scala maps have different order</h2>

<p>Python doesn’t preserve the order in which the elements are added to the dictionary. I think it’s best to illustrate this with an example:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="c"># let's make a dictionary</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s">'key_a'</span><span class="p">:</span> <span class="s">'value_a'</span><span class="p">,</span> <span class="s">'key_b'</span><span class="p">:</span> <span class="s">'value_b'</span><span class="p">,</span> <span class="s">'key_c'</span><span class="p">:</span> <span class="s">'value_c'</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c"># and iterate over the key/value pairs</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="o">...</span>   <span class="k">print</span> <span class="n">item</span>
<span class="o">...</span> 
<span class="p">(</span><span class="s">'key_a'</span><span class="p">,</span> <span class="s">'value_a'</span><span class="p">)</span>
<span class="p">(</span><span class="s">'key_c'</span><span class="p">,</span> <span class="s">'value_c'</span><span class="p">)</span>
<span class="p">(</span><span class="s">'key_b'</span><span class="p">,</span> <span class="s">'value_b'</span><span class="p">)</span></code></pre></div>

<p>Boom - all messed up! The same snippet in Scala:</p>

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="c1">// let's make a map</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">m</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"key_b"</span> <span class="o">-&gt;</span> <span class="s">"value_b"</span><span class="o">,</span> 
     <span class="o">|</span>             <span class="s">"key_c"</span> <span class="o">-&gt;</span> <span class="s">"value_c"</span><span class="o">,</span> 
     <span class="o">|</span>             <span class="s">"key_a"</span> <span class="o">-&gt;</span> <span class="s">"value_a"</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> 
<span class="n">scala</span><span class="o">&gt;</span> <span class="c1">// and iterate over key/value pairs</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">item</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">item</span><span class="o">))</span>

<span class="o">(</span><span class="n">key_b</span><span class="o">,</span><span class="n">value_b</span><span class="o">)</span>
<span class="o">(</span><span class="n">key_c</span><span class="o">,</span><span class="n">value_c</span><span class="o">)</span>
<span class="o">(</span><span class="n">key_a</span><span class="o">,</span><span class="n">value_a</span><span class="o">)</span></code></pre></div>

<p>So while Python sorts the dictionary elements in a non-obvious way, Scala preserves the order of elements as they were added to the map. Unfortunately I had to learn this the hard way - some parts of the code assumed the ‘correct’ order of elements. Fortunately it’s easy to fix the problem with <a href="https://docs.python.org/2/library/collections.html#collections.OrderedDict">OrderedDict</a>.</p>

<h2 id="be-careful-when-checking-whether-variable-has-a-numerical-value-or-not">2. Be careful when checking whether variable has a numerical value or not</h2>

<p>For example this simple code snippet checks whether <code>x</code> is <code>NaN</code> or not</p>

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span>
<span class="n">scala</span><span class="o">&gt;</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">isNaN</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">println</span><span class="o">(</span><span class="s">"x has no value"</span><span class="o">)</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">println</span><span class="o">(</span><span class="s">"x has a value"</span><span class="o">)</span>
        <span class="o">}</span>

<span class="n">x</span> <span class="n">has</span> <span class="n">no</span> <span class="n">value</span></code></pre></div>

<p>The equivalent in Python is:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="bp">None</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
<span class="o">...</span>   <span class="k">print</span> <span class="s">"x has no value"</span>
<span class="o">...</span> <span class="k">else</span><span class="p">:</span>
<span class="o">...</span>   <span class="k">print</span> <span class="s">"x has a value"</span>
<span class="o">...</span> 
<span class="n">x</span> <span class="n">has</span> <span class="n">no</span> <span class="n">value</span></code></pre></div>

<p>So far so good. But sometimes one wants to take advantage of <a href="http://www.numpy.org/">NumPy</a> to perform some calculations in a more elegant way. Thus it makes more sense to use NumPy’s <code>NaN</code> value as well instead of None. I’m not saying that it’s a mistake of language design or whatever, but it pays to be extra careful when writing something like this:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
<span class="o">...</span>   <span class="k">print</span> <span class="s">"x has no value"</span>
<span class="o">...</span> <span class="k">else</span><span class="p">:</span>
<span class="o">...</span>   <span class="k">print</span> <span class="s">"x has a value"</span>
<span class="o">...</span> 
<span class="n">x</span> <span class="n">has</span> <span class="n">a</span> <span class="n">value</span></code></pre></div>

<p>Surely this was not what I meant!
A similar ‘anomaly’ might occur if the <code>x</code> equals to <code>0</code> and thus already has a value:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
<span class="o">...</span>   <span class="k">print</span> <span class="s">"x has no value"</span>
<span class="o">...</span> <span class="k">else</span><span class="p">:</span>
<span class="o">...</span>   <span class="k">print</span> <span class="s">"x has a value"</span>
<span class="o">...</span> 
<span class="n">x</span> <span class="n">has</span> <span class="n">no</span> <span class="n">value</span></code></pre></div>

<p>It’s very easy to overlook stuff like this when being on autopilot.</p>

<h2 id="porting-classes-with-multiple-constructors">3. Porting classes with multiple constructors</h2>
<p>Let’s say we have a following Scala code</p>

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="k">val</span> <span class="n">firstName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">val</span> <span class="n">lastName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
   
  <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">firstName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">firstName</span><span class="o">,</span> <span class="s">""</span><span class="o">);</span>
  <span class="o">}</span>
   
  <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">firstName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">lastName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">firstName</span><span class="o">,</span> <span class="n">lastName</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<p>How to you port this into Python? This is actually a major pain in the ass since Python doesn’t support multiple constructors. The only reasonable solution I was able to come up with was:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="n">first_name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">last_name</span> <span class="o">=</span> <span class="n">last_name</span>

  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">Person</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">Person</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">"Wrong number of arguments: </span><span class="si">%s</span><span class="s">"</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span></code></pre></div>

<p>And you use it like this:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">shrek</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s">"Shrek"</span><span class="p">)</span>
<span class="n">hugh</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s">"Hugh"</span><span class="p">,</span> <span class="s">"Jass"</span><span class="p">)</span></code></pre></div>

<p>Of course there might be a case where one constructor accepts a string and the other an integer or whatever. In this case it’s probably the best just to check the type of a variable. Something like this:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span>
<span class="bp">False</span></code></pre></div>

<h2 id="port-first-refactor-later">4. Port first, refactor later</h2>
<p>The solutions in the last paragraph are far from ideal, but at least we’re not changing the logic of the code while porting it. Just don’t refactor the code before having a great overview of what all of it is doing. Unless, of course, you want to have some unpleasant what-the-f-is-going-on debugging marathons. This is obviously not Scala-to-Python specific and applies to any kind of code porting.</p>


                
                
                
            
                <hr/>
                <p id="disqus_thread"/>
                
                <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
            </div>
        </div></body></html>