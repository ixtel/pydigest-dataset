<html><body><div><div class="post-body entry-content" id="post-body-3260017241303198594" itemprop="description articleBody">
<p class="tr_bq">
Yesterday, I was looking for some help trying to have a clean way to roll back database transactions at the end of a test in a Python TestCase. So, naturally, I started searching and found some posts on Stack Overflow and started to read them. I was instantly mortified by what I read.</p>
<blockquote class="tr_bq">
<span>But in any case, an in-memory database (SQLite makes this easy) is the best choice for unit tests.</span>Â </blockquote><p>
Huh? I, at least, will listen and have a nice healthy debate when people suggest you should mock out every call to the database in the unit tests because if you are talking to the database it's not a unit test its a functional test. That argument is mainly one of semantics of what you call the test. In the case of using a different database engine in a testing environment than a production environment, why would you want to do that?
</p><p>
What's worse is the next stack overflow question I went to had almost the same answer by another person.
</p><blockquote class="tr_bq">
<span>You can simply create an in-memory SQLite database and bind your session to that.</span></blockquote>
<p>
So, first, I wanted to stand on the rooftop and yell at the top of my lungs to anyone who would listen. This is a really bad idea. Here's why.

</p><ol>
<li>SQLite has different SQL semantics than Postgres, so a query written on SQLite may not run in Postgres</li>
<li>SQLite has different bugs than Postgres, so just because it works in SQLite does not mean it will work in Postgres. Also the reverse is true, just because you can't get it to work in SQLite doesn't mean it won't work in Postgres</li>
<li>Postgres has way more features that SQLite. Try doing a CTE query in SQLite. You can't use any of these features in your application if you test in a different database than you use for your production environment. (It ends up in 2014 SQLite added CTEs to their software, however there are differences, which is the point, for instance it does not appear that you can do insert or update in a SQLite CTE).</li>
<li>How can you test deployments if your test environment uses a different database than your production environment?</li>
<li>How can you test that your application works with the newest version of the database before you push it to production?</li>
</ol>
<p>
This sentiment about testing in a different database than you use in production is not just limited to stackoverflow it seems. I found a document on leading cloud service provider's site that said this:</p>
<p>
<br/></p>
<blockquote class="tr_bq">
</blockquote>

<blockquote>
When To Use SQLite<br/>

It is an overkill for a large portion of applications to use an additional process for testing the business-logic (i.e. the application's main purpose: functionality).</blockquote><p>
This is even more strange coming from them since one of the valid reasons cloud service providers give for using their services is that you can have a test environment that mirrors your production environment as closely as possible.
</p><p>
I specifically mentioned SQLite and Postgres, but in reality you could replace any two technologies and the arguments don't change. You wouldn't want to test on SQLite and use MySQL in production, nor would you want to test on Postgres and use Oracle in production.
</p><p>
So remember don't develop and test against one database and release against a different database.
</p><p>
Edited Aug. 4</p><p>
Fixed spelling error for SQLLite -&gt; SQLite.</p><p>
SQLite does have CTE support since 2014.
</p><p>
Thanks for all the great comments, and the godd discussion this is creating within the community.
</p><p/>
</div>
</div></body></html>