<html><body><div><div class="post-text" itemprop="text">

<p>I'm trying to replicate (and if possible improve on) Python 2.x's sorting behaviour in 3.x, so that mutually orderable types like <code>int</code>, <code>float</code> etc. are sorted as expected, and mutually unorderable types are grouped within the output.</p>

<p>Here's an example of what I'm talking about:</p>

<pre><code>&gt;&gt;&gt; sorted([0, 'one', 2.3, 'four', -5])  # Python 2.x
[-5, 0, 2.3, 'four', 'one']
</code></pre>



<pre><code>&gt;&gt;&gt; sorted([0, 'one', 2.3, 'four', -5])  # Python 3.x
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: str() &lt; int()
</code></pre>

<p>My previous attempt at this, using a class for the key parameter to <code>sorted()</code> (see 
<a href="http://stackoverflow.com/q/26567667/1014938">Why does this key class for sorting heterogeneous sequences behave oddly?</a>) is fundamentally broken, because its approach of</p>

<ol>
<li>Trying to compare values, and</li>
<li>If that fails, falling back to comparing the string representation of their types</li>
</ol>

<p>can lead to intransitive ordering, as explained by <a href="http://stackoverflow.com/a/26567784/1014938">BrenBarn's excellent answer</a>.</p>

<p>A naïve approach, which I initially rejected without even trying to code it, would be to use a key function that returns a <code>(type, value)</code> tuple:</p>

<pre><code>def motley(value):
    return repr(type(value)), value
</code></pre>

<p>However, this doesn't do what I want. In the first place, it breaks the natural ordering of mutually orderable types:</p>

<pre><code>&gt;&gt;&gt; sorted([0, 123.4, 5, -6, 7.89])
[-6, 0, 5, 7.89, 123.4]
&gt;&gt;&gt; sorted([0, 123.4, 5, -6, 7.89], key=motley)
[7.89, 123.4, -6, 0, 5]
</code></pre>

<p>Secondly, it raises an exception when the input contains two objects of the same intrinsically unorderable type:</p>

<pre><code>&gt;&gt;&gt; sorted([{1:2}, {3:4}], key=motley)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: dict() &lt; dict()
</code></pre>

<p>... which admittedly is the standard behaviour in both Python 2.x and 3.x – but ideally I'd like such types to be grouped together (I don't especially care about their ordering, but it would seem in keeping with Python's guarantee of stable sorting that they retain their original order).</p>

<p>I can work around the first of these problems for numeric types by special-casing them:</p>

<pre><code>from numbers import Real
from decimal import Decimal

def motley(value):
    numeric = Real, Decimal
    if isinstance(value, numeric):
        typeinfo = numeric
    else:
        typeinfo = type(value)
    return repr(typeinfo), value
</code></pre>

<p>... which works as far as it goes:</p>

<pre><code>&gt;&gt;&gt; sorted([0, 'one', 2.3, 'four', -5], key=motley)
[-5, 0, 2.3, 'four', 'one']
</code></pre>

<p>... but doesn't account for the fact that there may be other distinct (possibly user-defined) types which are mutually orderable, and of course still fails with intrinsically unorderable types:</p>

<pre><code>&gt;&gt;&gt; sorted([{1:2}, {3:4}], key=motley)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: dict() &lt; dict()
</code></pre>

<p>Is there another approach which solves <strong>both</strong> the problem of arbitrary, distinct-but-mutually-orderable types <strong>and</strong> that of intrinsically unorderable types?</p>
    </div>
    </div></body></html>