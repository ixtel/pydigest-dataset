<html><body><div><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-afl-utils-" class="anchor" href="#afl-utils-" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>afl-utils <a href="https://travis-ci.org/rc0r/afl-utils"><img src="https://camo.githubusercontent.com/bb74524fe9e3bbd0ba94308f06fc711a67b98490/68747470733a2f2f7472617669732d63692e6f72672f726330722f61666c2d7574696c732e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/rc0r/afl-utils.svg?branch=master"/></a><a href="https://coveralls.io/github/rc0r/afl-utils?branch=master"><img src="https://camo.githubusercontent.com/f9b905421a2c50c1dc4168b1b605f000cc451dff/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f726330722f61666c2d7574696c732f62616467652e7376673f6272616e63683d6d617374657226736572766963653d676974687562" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/rc0r/afl-utils/badge.svg?branch=master&amp;service=github"/></a></h1>

<p>afl-utils is a collection of utilities to assist fuzzing with
<a href="http://lcamtuf.coredump.cx/afl/">american-fuzzy-lop (afl)</a>.
afl-utils includes tools for:</p>

<ul>
<li>automated crash sample collection, verification, reduction and analysis (<code>afl-collect</code>, <code>afl-vcrash</code>)</li>
<li>easy management of parallel (multi-core) fuzzing jobs (<code>afl-multicore</code>, <code>afl-multikill</code>)</li>
<li>corpus optimization (<code>afl-minimize</code>)</li>
<li>fuzzer stats supervision (<code>afl-stats</code>)</li>
</ul>

<p><a href="https://raw.githubusercontent.com/rc0r/afl-utils/master/.scrots/afl_stats_sample.png" target="_blank"><img src="https://raw.githubusercontent.com/rc0r/afl-utils/master/.scrots/afl_stats_sample.png" alt="afl-stats_sample"/></a></p>

<p><a href="https://raw.githubusercontent.com/rc0r/afl-utils/master/.scrots/afl_collect_sample.png" target="_blank"><img src="https://raw.githubusercontent.com/rc0r/afl-utils/master/.scrots/afl_collect_sample.png" alt="afl-collect_sample"/></a></p>

<p><strong>For installation instructions see <a href="https://github.com/rc0r/afl-utils/blob/master/docs/INSTALL.md">docs/INSTALL.md</a>.</strong></p>

<p>In versions 1.03a and 1.04a multi-threading capabilities have been introduced to speed up things.
However if you observe some strange behaviour in one of these (or later) versions, please file a
bug report (either open an issue here on GH or send it in directly to <code>hlt99 at blinkenshell dot org</code>).
The latest non-multi-threading release that comes with all features is 1.02a. So if running the
multi-threaded version is somehow troubling for you, you can always <code>git checkout v1.02a</code> after cloning.
I might be adding a separate branch for multi-threaded afl-utils releases in the future.</p>

<h2><a id="user-content-afl-collect" class="anchor" href="#afl-collect" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>afl-collect</h2>

<p><code>afl-collect</code> basically copies all crash sample files from an afl synchronisation directory
(used by multiple afl instances when run in parallel) into a single location providing
easy access for further crash analysis. Beyond that <code>afl-collect</code> has some more advanced
features like invalid crash sample removing (see <code>afl-vcrash</code>) as well as generating and
executing <code>gdb</code> scripts that make use of <a href="https://github.com/jfoote/exploitable">Exploitable</a>.
The purpose of these scripts is to automate crash sample classification (see screenshot below)
and reduction.<br/>
Version 1.01a introduced crash sample de-duplication using backtrace hashes calculated by
exploitable. To use this feature invoke <code>afl-collect</code> with <code>-e &lt;gdb_script&gt;</code> switch for
automatic gdb+exploitable script generation and execution. For each backtrace hash only a
single crash sample file will be kept.<br/>
<code>afl-collect</code> is quite slow when operating on large sample sets and using gdb+exploitable
script execution, so be patient!<br/>
When invoked with <code>-d &lt;database&gt;</code>, sample information will be stored in the <code>database</code>. This
will only be done when the gdb-script execution step is selected (<code>-e</code>). If <code>database</code> is an
existing database containing sample info, <code>afl-collect</code> will skip all samples that already
have a database entry during sample processing. This will work also when <code>-e</code> is not requested.
This makes subsequent <code>afl-collect</code> runs more efficient, since only unseen samples are
processed (and added to the database).  </p>

<p>Usage:</p>

<pre><code>afl-collect [-d DATABASE] [-e|-g GDB_EXPL_SCRIPT_FILE] [-f LIST_FILENAME]
            [-h] [-j THREADS] [-m] [-r] [-rr] sync_dir collection_dir target_cmd

afl-collect copies all crash sample files from an afl sync dir used by multiple
fuzzers when fuzzing in parallel into a single location providing easy access
for further crash analysis.

positional arguments:
  sync_dir              afl synchronisation directory crash samples will be
                        collected from.
  collection_dir        Output directory that will hold a copy of all crash
                        samples and other generated files. Existing files in the
                        collection directory will be overwritten!
  target_cmd            Path to the target binary and its command line arguments.
                        Use '@@' to specify crash sample input file position
                        (see afl-fuzz usage).

optional arguments:
  -h, --help            show this help message and exit
  -d DATABASE_FILE, --database DATABASE_FILE
                        Submit sample data into an sqlite3 database (only when
                        used together with '-e'). afl-collect skips processing
                        of samples already found in existing database.
  -e GDB_EXPL_SCRIPT_FILE, --execute-gdb-script GDB_EXPL_SCRIPT_FILE
                        Generate and execute a gdb+exploitable script after crash
                        sample collection for crash classification. (Like option
                        '-g', plus script execution.)
  -f LIST_FILENAME, --filelist LIST_FILENAME
                        Writes all collected crash sample filenames into a file
                        in the collection directory.
  -g GDB_SCRIPT_FILE, --generate-gdb-script GDB_SCRIPT_FILE
                        Generate gdb script to run 'exploitable.py' on all
                        collected crash samples. Generated script will be placed
                        into collection directory.
  -j NUM_THREADS, --threads NUM_THREADS
                        Enable parallel analysis by specifying the number of
                        threads afl-collect will utilize.
  -m, --minimize-filenames
                        Minimize crash sample file names by only keeping fuzzer
                        name and ID.
  -r, --remove-invalid  Verify collected crash samples and remove samples that
                        do not lead to crashes or cause timeouts (runs
                        'afl-vcrash -r' on collection directory). This step is
                        done prior to any script file execution or file list
                        generation.
  -rr, --remove-unexploitable
                        Remove crash samples that have an exploitable
                        classification of 'NOT_EXPLOITABLE', 'PROBABLY_NOT_EXPLOITABLE'
                        or 'UNKNOWN'. Sample file removal will take place after
                        gdb+exploitable script execution. Has no effect without '-e'.
</code></pre>

<h2><a id="user-content-afl-minimize" class="anchor" href="#afl-minimize" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>afl-minimize</h2>

<p>Helps to create a minimized corpus from samples of a parallel fuzzing job. It
basically works as follows:</p>

<ol>
<li>Collect all queue samples from an afl synchronisation directory in <code>collection_dir</code>.</li>
<li>Run <code>afl-cmin</code> on the collected corpus, save minimized corpus in <code>collection_dir.cmin</code>.</li>
<li>Run <code>afl-tmin</code> on the remaining samples to reduce them in size. Save results in
<code>collection_dir.tmin</code> if step two was omitted or <code>collection_dir.cmin.tmin</code> otherwise.</li>
<li>Perform a "dry-run" for each sample and move crashes/timeouts out of the corpus. This
step will be useful prior to starting a new or resuming a parallel fuzzing job on a
corpus containing intermittent crashes. Crashes will be moved to a <code>.crashes</code> directory,
if one of steps 1, 2 or 3 were performed. If only "dry-run" is requested, crashing
samples will be moved from the <code>queue</code> to the <code>crashes</code> dirs within an afl sync dir.
For timeouts the behavior is similar: When operating on a collection directory timeouts
will be moved to a <code>.hangs</code> directory. When operating on the original afl synchronisation
directory timeouts will go into <code>hangs</code> dir within the corresponding afl fuzzer dir.<br/></li>
</ol>

<p>As already indicated, all these steps are optional, making the tool quite flexible. E.g.
running only step four can be handy before resuming a parallel fuzzing session. In order
to skip step one, simply provide a directory containing fuzzing samples. Then <code>afl-minimize</code>
will not collect any samples, instead <code>afl-cmin</code> and/or <code>afl-tmin</code> are run on the samples
in the provided directory.  </p>

<p>When operating on corpora with many samples use <code>--tmin</code> with caution. Running thousands
of files through <code>afl-tmin</code> can take very long. So make sure the results are as expected
and worth the effort. You don't want to waste days of CPU time just to reduce your corpus
size by a few bytes, don't you?!</p>

<p>Performing the "dry-run" step after running <code>afl-cmin</code> might seem pointless, but my
experience showed that sometimes crashes remain the minimized corpus. So this is just
an additional step to get rid of them. But don't expect "dry-run" to always clear your
corpus from crashes with a 100% success rate!</p>

<p>Usage:</p>

<pre><code>afl-minimize [-c COLLECTION_DIR [--cmin [opts]] [--tmin [opts]]] [-d] [-h]
             [-j] sync_dir -- target_cmd

afl-minimize performs several optimization steps to reduce the size of an afl-
fuzz corpus.

positional arguments:
  sync_dir              afl synchronisation directory containing multiple
                        fuzzers and their queues.
  target_cmd            Path to the target binary and its command line
                        arguments. Use '@@' to specify crash sample input file
                        position (see afl-fuzz usage).

optional arguments:
  -h, --help            show this help message and exit
  -c COLLECTION_DIR, --collect COLLECTION_DIR
                        Collect all samples from the synchronisation dir and
                        store them in the collection dir. Existing files in
                        the collection directory will be overwritten!
  --cmin                Run afl-cmin on collection dir. Has no effect without
                        '-c'.
  --cmin-mem-limit CMIN_MEM_LIMIT
                        Set memory limit for afl-cmin.
  --cmin-timeout CMIN_TIMEOUT
                        Set timeout for afl-cmin.
  --tmin                Run afl-tmin on minimized collection dir if used
                        together with '--cmin'or on unoptimized collection dir
                        otherwise. Has no effect without '-c'.
  --tmin-mem-limit TMIN_MEM_LIMIT
                        Set memory limit for afl-tmin.
  --tmin-timeout TMIN_TIMEOUT
                        Set timeout for afl-tmin.
  -d, --dry-run         Perform dry-run on collection dir, if '-c' is provided
                        or on synchronisation dir otherwise. Dry-run will move
                        intermittent crashes out of the corpus.
  -j NUM_THREADS, --threads NUM_THREADS
                        Enable parallel dry-run and t-minimization step by
                        specifying the number of threads afl-minimize will
                        utilize.
</code></pre>

<h2><a id="user-content-afl-multicore" class="anchor" href="#afl-multicore" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>afl-multicore</h2>

<p><code>afl-multicore</code> starts several parallel fuzzing jobs in the background using <code>nohup</code> (Note:
So afl's fancy interface is gone). Fuzzer outputs (<code>stdout</code> and <code>stderr</code>) will be redirected
to <code>/dev/null</code>. Use <code>--verbose</code> to turn output redirection off. This is particularly useful
when debugging <code>afl-fuzz</code> invocations. The auto-generated file <code>nohup.out</code> might also contain
some useful info.<br/>
Another way to debug <code>afl-fuzz</code> invocations is test mode. Just start <code>afl-multicore</code> and
provide the <code>--test</code> flag to perform a test run. <code>afl-multicore</code> will start a single fuzzing
instance in interactive mode using a test output directory <code>&lt;out-dir&gt;_test</code>. The <code>interactive</code>
setting in your config file will be ignored.<br/>
<strong>Note:</strong> After running a test you will have to clean up the test output directory
<code>&lt;out-dir&gt;_test</code> yourself!<br/>
<strong>Note:</strong> For interactive <em>test runs</em> <code>screen</code> is not required!</p>

<p>If you want to check the fuzzers' progress see <code>fuzzer_stats</code> in the respective fuzzer
directory in the synchronisation dir (<code>sync_dir/SESSION###/fuzzer_stats</code>)! The master instance
files are always located at <code>sync_dir/SESSION000/</code>.<br/>
An <code>afl-multicore</code> session can (and should!) easily be aborted with the help of
<code>afl-multikill</code> (see below).</p>

<p>If you prefer to work with afl's UI instead of background processes and stat files, screen
mode is for you. "Interactive" screen mode can be enabled using the <code>interactive = on</code> directive
in the config file (see below). In order to use it, start <code>afl-multicore</code> from <strong>inside</strong> a
<code>screen</code> session. A new screen window is created for every afl instance. Though screen mode is
not supported by <code>afl-multikill</code>.<br/>
<strong>Attention:</strong> When using screen mode be sure to set necessary environment variables in the
<code>[environment]</code> section of your <code>afl-multicore</code> configuration! Alternatively run
<code>screen -X setenv &lt;var_name&gt; &lt;var_value&gt;</code> from inside <code>screen</code> before running <code>afl-multicore</code>.
Both ways the environment is inherited by all subsequently created screen windows.</p>

<p>Usage:</p>

<pre><code>afl-multicore [-c config] [-h] [-t] [-v] &lt;cmd&gt; &lt;jobs&gt;

afl-multicore starts several parallel fuzzing jobs, that are run in the
background. For fuzzer stats see 'out_dir/SESSION###/fuzzer_stats'!

positional arguments:
  cmd                   afl-multicore command to execute: start, resume, add.
  jobs                  Number of instances to start/resume/add.

optional arguments:
  -h, --help            show this help message and exit
  -c CONFIG_FILE, --config CONFIG_FILE
                        afl-multicore config file (Default: afl-
                        multicore.conf)!
  -t, --test            Perform a test run by starting a single afl instance
                        in interactive mode using a test output directory.
  -v, --verbose         For debugging purposes do not redirect stderr/stdout
                        of the created subprocesses to /dev/null (Default:
                        off). Check 'nohup.out' for further outputs.
</code></pre>

<p>Target settings and afl options are configured in an INI-like configuration file.
The most simple configuration may look something like:</p>

<pre><code>[afl.dirs]
input = ./in
output = ./out

[target]
target = ~/bin/target
cmdline = --target-opt
</code></pre>

<p>Of course a lot more settings can be configured, some of these settings are:</p>

<ul>
<li>afl options: timeout, memory limit, dictionary, ...</li>
<li>job options: session name, interactive mode</li>
<li>environment variables for interactive screen mode</li>
</ul>

<p>For a complete list of options and their descriptions see the included sample
configuration file <code>afl-multicore.conf.sample</code>.</p>

<p>To start four fuzzing instances simply do:</p>

<pre><code>$ afl-multicore -c target.conf start 4
</code></pre>

<p>Now, if you want to add two more instances because <code>afl-gotcpu</code> states you've
got some spare CPU cycles available, use the <code>add</code> command:</p>

<pre><code>$ afl-multicore -c target.conf add 2
</code></pre>

<p>Interrupted fuzzing jobs can be resumed the same way using the <code>resume</code> command.<br/>
<strong>Note:</strong> It is possible to <em>tell</em> <code>afl-multicore</code> to resume more jobs for a
specific target than were previously started. Obviously <code>afl-multicore</code> can
resume just as many afl instances as it finds output directories for! Use the
<code>add</code> command to start additional afl instances!</p>

<p><code>afl-fuzz</code> can be run using its <code>-f &lt;file&gt;</code> argument to specify the location of
the generated sample. When using multiple <code>afl-fuzz</code> instances a single file
obviously can't do the trick, because multiple fuzzers running in parallel would
need separate files to store their data. For that reason <code>afl-multicore</code> extends
the provided filename with the instance number similar to the session naming
scheme: <code>cur_input</code> would be extended into <code>cur_input_000</code>, <code>cur_input_001</code> and
so on. In order to use these files just use <code>%%</code> in the target command line
specification within the config file. <code>afl-multicore</code> will then do all the magic
and use the correct files for the different instances of <code>afl-fuzz</code>.</p>

<p>Example config:</p>

<pre><code>...
[target]
target = /your/app/here
cmdline = --some-target-opts --input-file %%
# ^- translates to:
#    --some-target-opts --input-file /path/to/cur_input_000
#    --some-target-opts --input-file /path/to/cur_input_001
#    ...

...

[afl.ctrl]
file = /path/to/cur_input
</code></pre>

<h2><a id="user-content-afl-multikill" class="anchor" href="#afl-multikill" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>afl-multikill</h2>

<p>Aborts all <code>afl-fuzz</code> instances belonging to an active non-interactive <code>afl-multicore</code>
session. <code>afl-multicore</code> sessions that were started in <code>screen</code> mode can not be aborted!</p>

<p>Usage:</p>

<pre><code>afl-multikill [-S SESSION]

afl-multikill aborts all afl-fuzz instances belonging to an active
afl-multicore session. Interactive screen sessions are not supported!

optional arguments:
  -h, --help            show this help message and exit
  -S SESSION, --session SESSION
                        afl-multicore session to abort
                        (Default='SESSION').
</code></pre>

<h2><a id="user-content-afl-stats" class="anchor" href="#afl-stats" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>afl-stats</h2>

<p>Prints fuzzing statistics similar to <code>afl-whatsup -s</code> and posts (tweets) them to Twitter.
This is especially useful when fuzzing on multiple machines. Regularly ssh-ing into all
of your boxes to check <code>fuzzer_stats</code> quickly becomes a PITA...<br/>
For setup instructions, please see
<a href="https://github.com/rc0r/afl-utils/blob/master/docs/INSTALL.md">docs/INSTALL.md</a>!
Screenshots of sample tweets can be found in the final section of this document.</p>

<p>Usage:</p>

<pre><code>afl-stats [-c]

Post selected contents of fuzzer_stats to Twitter.

optional arguments:
  -h, --help            show this help message and exit
  -c CONFIG_FILE, --config CONFIG_FILE
                        afl-stats config file (Default: afl-stats.conf)!
</code></pre>

<h2><a id="user-content-afl-vcrash" class="anchor" href="#afl-vcrash" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>afl-vcrash</h2>

<p><code>afl-vcrash</code> verifies that afl-fuzz crash samples really lead to crashes in the target
binary and optionally removes these samples automatically.<br/>
Note: <code>afl-vcrash</code> functionality is incorporated into <code>afl-collect</code>. If <code>afl-collect</code> is
invoked with switch <code>-r</code>, it runs <code>afl-vcrash -qr</code> to quietly remove invalid samples from
the collected files.<br/>
To enable parallel crash sample verification provide <code>-j</code> followed by the desired number
of threads <code>afl-vcrash</code> will utilize. Depending on the target process you're fuzzing,
running multiple threads in parallel can significantly improve verification speeds.</p>

<p>Usage:</p>

<pre><code>afl-vcrash [-f LIST_FILENAME] [-h] [-j THREADS] [-q] [-r] [-t TIMEOUT] collection_dir
           target_command [target_command_args]

afl-vcrash verifies that afl-fuzz crash samples lead to crashes in the
target binary.

positional arguments:
  collection_dir        Directory holding all crash samples that will
                        be verified.
  target_command        Target binary including command line options.
                        Use '@@' to specify crash sample input file
                        position (see afl-fuzz usage).

optional arguments:
  -h, --help            show this help message and exit
  -f LIST_FILENAME, --filelist LIST_FILENAME
                        Writes all crash sample file names that do not
                        lead to crashes into a file.
  -j NUM_THREADS, --threads NUM_THREADS
                        Enable parallel verification by specifying the
                        number of threads afl-vcrash will utilize.
  -q, --quiet           Suppress output of crash sample file names that
                        do not lead to crashes. This is particularly
                        useful when combined with '-r' or '-f'.
  -r, --remove          Remove crash samples that do not lead to crashes.
  -t TIMEOUT_SECS, --timeout TIMEOUT_SECS
                        Define the timeout in seconds before killing the
                        verification of a crash sample
</code></pre>

<h2><a id="user-content-screenshots" class="anchor" href="#screenshots" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Screenshots</h2>

<h3><a id="user-content-afl-collect-1" class="anchor" href="#afl-collect-1" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>afl-collect</h3>

<p>Sample output:</p>

<p><a href="https://raw.githubusercontent.com/rc0r/afl-utils/master/.scrots/afl_collect_sample.png" target="_blank"><img src="https://raw.githubusercontent.com/rc0r/afl-utils/master/.scrots/afl_collect_sample.png" alt="afl-collect_sample"/></a></p>

<h3><a id="user-content-afl-multicore-1" class="anchor" href="#afl-multicore-1" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>afl-multicore</h3>

<p>Sample output (normal mode):</p>

<p><a href="https://raw.githubusercontent.com/rc0r/afl-utils/master/.scrots/afl_multicore_sample.png" target="_blank"><img src="https://raw.githubusercontent.com/rc0r/afl-utils/master/.scrots/afl_multicore_sample.png" alt="afl-multicore_sample"/></a></p>

<h3><a id="user-content-afl-stats-1" class="anchor" href="#afl-stats-1" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>afl-stats</h3>

<p><a href="https://raw.githubusercontent.com/rc0r/afl-utils/master/.scrots/afl_stats_sample.png" target="_blank"><img src="https://raw.githubusercontent.com/rc0r/afl-utils/master/.scrots/afl_stats_sample.png" alt="afl-stats_sample"/></a></p>

<p><a href="https://raw.githubusercontent.com/rc0r/afl-utils/master/.scrots/afl_stats_tweet.png" target="_blank"><img src="https://raw.githubusercontent.com/rc0r/afl-utils/master/.scrots/afl_stats_tweet.png" alt="afl-stats_tweet"/></a></p>
</article>
  </div></body></html>