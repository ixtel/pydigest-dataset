<html><body><div><div class="main_container">
        <h3 id="drf-extensions">DRF-extensions</h3>

<p>DRF-extensions is a collection of custom extensions for <a href="https://github.com/tomchristie/django-rest-framework">Django REST Framework</a>.
Source repository is available at <a href="https://github.com/chibisov/drf-extensions">https://github.com/chibisov/drf-extensions</a>.</p>

<h3 id="viewsets">Viewsets</h3>

<p>Extensions for <a href="http://django-rest-framework.org/api-guide/viewsets.html">viewsets</a>.</p>

<h4 id="detailserializermixin">DetailSerializerMixin</h4>

<p>This mixin lets add custom serializer for detail view. Just add mixin and specify <code>serializer_detail_class</code> attribute:</p>

<pre><code>from django.contrib.auth.models import User
from myapps.serializers import UserSerializer, UserDetailSerializer
from rest_framework_extensions.mixins import DetailSerializerMixin

class UserViewSet(DetailSerializerMixin, viewsets.ReadOnlyModelViewSet):
    serializer_class = UserSerializer
    serializer_detail_class = UserDetailSerializer
    queryset = User.objects.all()
</code></pre>

<p>Sometimes you need to set custom QuerySet for detail view. For example, in detail view you want to show user groups and permissions for these groups. You can make it by specifying <code>queryset_detail</code> attribute:</p>

<pre><code>from django.contrib.auth.models import User
from myapps.serializers import UserSerializer, UserDetailSerializer
from rest_framework_extensions.mixins import DetailSerializerMixin

class UserViewSet(DetailSerializerMixin, viewsets.ReadOnlyModelViewSet):
    serializer_class = UserSerializer
    serializer_detail_class = UserDetailSerializer
    queryset = User.objects.all()
    queryset_detail = queryset.prefetch_related('groups__permissions')
</code></pre>

<p>If you use <code>DetailSerializerMixin</code> and don't specify <code>serializer_detail_class</code> attribute, then <code>serializer_class</code> will be used.</p>

<p>If you use <code>DetailSerializerMixin</code> and don't specify <code>queryset_detail</code> attribute, then <code>queryset</code> will be used.</p>

<h4 id="paginatebymaxmixin">PaginateByMaxMixin</h4>

<p><em>New in DRF-extensions 0.2.2</em></p>

<p>This mixin allows to paginate results by <a href="http://www.django-rest-framework.org/api-guide/pagination#pagination-in-the-generic-views">max_paginate_by</a>
value. This approach is useful when clients want to take as much paginated data as possible,
but don't want to bother about backend limitations.</p>

<pre><code>from myapps.serializers import UserSerializer
from rest_framework_extensions.mixins import PaginateByMaxMixin

class UserViewSet(PaginateByMaxMixin,
                  viewsets.ReadOnlyModelViewSet):
    max_paginate_by = 100
    serializer_class = UserSerializer
</code></pre>

<p>And now you can send requests with <code>?page_size=max</code> argument:</p>

<pre><code># Request
GET /users/?page_size=max HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8

{
    count: 1000,
    next: "https://localhost:8000/v1/users/?page=2&amp;page_size=max",
    previous: null,
    results: [
        ...100 items...
    ]
}
</code></pre>

<p>This mixin could be used only with Django Rest Framework &gt;= 2.3.8, because
<a href="http://www.django-rest-framework.org/topics/release-notes#238">max_paginate_by</a>
was introduced in 2.3.8 version.</p>

<h4 id="cache-etag-mixins">Cache/ETAG mixins</h4>

<p><strong>ReadOnlyCacheResponseAndETAGMixin</strong></p>

<p>This mixin combines <code>ReadOnlyETAGMixin</code> and <code>CacheResponseMixin</code>. It could be used with
<a href="http://www.django-rest-framework.org/api-guide/viewsets.html#readonlymodelviewset">ReadOnlyModelViewSet</a> and helps
to process caching + etag calculation for <code>retrieve</code> and <code>list</code> methods:</p>

<pre><code>from myapps.serializers import UserSerializer
from rest_framework_extensions.mixins import (
    ReadOnlyCacheResponseAndETAGMixin
)

class UserViewSet(ReadOnlyCacheResponseAndETAGMixin,
                  viewsets.ReadOnlyModelViewSet):
    serializer_class = UserSerializer
</code></pre>

<p><strong>CacheResponseAndETAGMixin</strong></p>

<p>This mixin combines <code>ETAGMixin</code> and <code>CacheResponseMixin</code>. It could be used with
<a href="http://www.django-rest-framework.org/api-guide/viewsets.html#modelviewset">ModelViewSet</a> and helps
to process:</p>

<ul>
<li>Caching for <code>retrieve</code> and <code>list</code> methods</li>
<li>Etag for <code>retrieve</code>, <code>list</code>, <code>update</code> and <code>destroy</code> methods</li>
</ul>

<p>Usage:</p>

<pre><code>from myapps.serializers import UserSerializer
from rest_framework_extensions.mixins import CacheResponseAndETAGMixin

class UserViewSet(CacheResponseAndETAGMixin,
                  viewsets.ModelViewSet):
    serializer_class = UserSerializer
</code></pre>

<p>Please, read more about <a href="#caching">caching</a>, <a href="#key-constructor">key construction</a> and <a href="#conditional-requests">conditional requests</a>.</p>

<h3 id="routers">Routers</h3>

<p>Extensions for <a href="http://django-rest-framework.org/api-guide/routers.html">routers</a>.</p>

<p>You will need to use custom <code>ExtendedDefaultRouter</code> or <code>ExtendedSimpleRouter</code> for routing if you want to take advantages of described extensions. For example you have standard implementation:</p>

<pre><code>from rest_framework.routers import DefaultRouter
router = DefaultRouter()
</code></pre>

<p>You should replace <code>DefaultRouter</code> with <code>ExtendedDefaultRouter</code>:</p>

<pre><code>from rest_framework_extensions.routers import (
    ExtendedDefaultRouter as DefaultRouter
)
router = DefaultRouter()
</code></pre>

<p>Or <code>SimpleRouter</code> with <code>ExtendedSimpleRouter</code>:</p>

<pre><code>from rest_framework_extensions.routers import (
    ExtendedSimpleRouter as SimpleRouter
)
router = SimpleRouter()
</code></pre>

<h4 id="pluggable-router-mixins">Pluggable router mixins</h4>

<p><em>New in DRF-extensions 0.2.4</em></p>

<p>Every feature in extended routers has it's own mixin. That means that you can use the only features you need in your custom
routers. <code>ExtendedRouterMixin</code> has all set of drf-extensions features. For example you can use it with third-party routes:</p>

<pre><code>from rest_framework_extensions.routers import ExtendedRouterMixin
from third_party_app.routers import SomeRouter

class ExtendedSomeRouter(ExtendedRouterMixin, SomeRouter):
    pass
</code></pre>

<h4 id="collection-level-controllers">Collection level controllers</h4>

<p><em>Pending deprecation due to <a href="http://www.django-rest-framework.org/api-guide/routers/#extra-link-and-actions">extra link and actions</a>.</em></p>

<p><em>Compatible only with Django Rest Framework &lt; 2.4</em></p>

<p>Out of the box Django Rest Framework has controller functionality for detail views. For example:</p>

<pre><code>from django.contrib.auth.models import User
from rest_framework import viewsets
from rest_framework.decorators import action, link
from rest_framework.response import Response
from myapp.serializers import UserSerializer

class UserViewSet(viewsets.ModelViewSet):
    """
    A viewset that provides the standard actions
    """
    queryset = User.objects.all()
    serializer_class = UserSerializer

    @action()
    def set_password(self, request, pk=None):
        return Response(['password changed'])

    @link()
    def groups(self, request, pk=None):
        return Response(['user groups'])
</code></pre>

<p>Change password request:</p>

<pre><code># Request
POST /users/1/set_password/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8

['password changed']
</code></pre>

<p>User groups request:</p>

<pre><code># Request
GET /users/1/groups/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8

['user groups']
</code></pre>

<p>But what if you want to add custom controller to collection level?</p>

<p>DRF-extensions <code>action</code> and <code>link</code> decorators will help you with it. These decorators behaves exactly as default, but can receive additional parameter <code>is_for_list</code>:</p>

<pre><code>...
from rest_framework_extensions.decorators import action, link
...

class UserViewSet(viewsets.ModelViewSet):
    """
    A viewset that provides the standard actions
    """
    queryset = User.objects.all()
    serializer_class = UserSerializer

    @action(is_for_list=True)
    def confirm_email(self, request, pk=None):
        return Response(['email confirmed'])

    @link(is_for_list=True)
    def surname_first_letters(self, request, pk=None):
        return Response(['a', 'b', 'c'])

    @action()
    def set_password(self, request, pk=None):
        return Response(['password changed'])

    @link()
    def groups(self, request, pk=None):
        return Response(['user groups'])
</code></pre>

<p>Now you can post to collection level controller:</p>

<pre><code># Request
POST /users/confirm_email/ HTTP/1.1
Accept: application/json
Content-Type: application/json

{"code": 123456}

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8

['email confirmed']
</code></pre>

<p>Or retrieve data from link collection level controller:</p>

<pre><code># Request
GET /users/surname_first_letters/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8

['a', 'b', 'c']
</code></pre>

<p>You can use <code>rest_framework_extensions.routers.ExtendedActionLinkRouterMixin</code> for adding collection level
controllers into your routers.</p>

<pre><code>from rest_framework_extensions.routers import (
    ExtendedActionLinkRouterMixin
)
from rest_framework.routers import SimpleRouter

class CustomSimpleRouter(ExtendedActionLinkRouterMixin, SimpleRouter):
    pass
</code></pre>

<h4 id="controller-endpoint-name">Controller endpoint name</h4>

<p><em>Pending deprecation due to <a href="http://www.django-rest-framework.org/api-guide/routers/#extra-link-and-actions">extra link and actions</a>.</em></p>

<p><em>Compatible only with Django Rest Framework &lt; 2.4</em></p>

<p>By default function name will be used as name for url routing:</p>

<pre><code># Reqeuest
POST /users/1/set_password/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8

['password changed']
</code></pre>

<p>But what if you want to specify custom name in url. For example <code>set-password</code>.</p>

<p>DRF-extensions <code>action</code> and <code>link</code> decorators will help you to specify custom endpoint name.
These decorators behaves exactly as default, but can receive additional parameter <code>endpoint</code>:</p>

<pre><code>...
from rest_framework_extensions.decorators import action, link
...

class UserViewSet(viewsets.ModelViewSet):
    """
    A viewset that provides the standard actions
    """
    queryset = User.objects.all()
    serializer_class = UserSerializer

    @action(endpoint='set-password')
    def set_password(self, request, pk=None):
        return Response(['password changed'])
</code></pre>

<p>Change password request:</p>

<pre><code># Request
POST /users/1/set-password/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8

['password changed']
</code></pre>

<p>You can use <code>rest_framework_extensions.routers.ExtendedActionLinkRouterMixin</code> for adding controller endpoint name feature
into your routers.</p>

<pre><code>from rest_framework_extensions.routers import (
    ExtendedActionLinkRouterMixin
)
from rest_framework.routers import SimpleRouter

class CustomSimpleRouter(ExtendedActionLinkRouterMixin, SimpleRouter):
    pass
</code></pre>

<h3 id="nested-routes">Nested routes</h3>

<p><em>New in DRF-extensions 0.2.4</em></p>

<p>Nested routes allows you create nested resources with <a href="http://www.django-rest-framework.org/api-guide/viewsets.html">viewsets</a>.</p>

<p>For example:</p>

<pre><code>from rest_framework_extensions.routers import ExtendedSimpleRouter
from yourapp.views import (
    UserViewSet,
    GroupViewSet,
    PermissionViewSet,
)

router = ExtendedSimpleRouter()
(
    router.register(r'users', UserViewSet, base_name='user')
          .register(r'groups',
                    GroupViewSet,
                    base_name='users-group',
                    parents_query_lookups=['user_groups'])
          .register(r'permissions',
                    PermissionViewSet,
                    base_name='users-groups-permission',
                    parents_query_lookups=['group__user', 'group'])
)
urlpatterns = router.urls
</code></pre>

<p>There is one requirement for viewsets which used in nested routers. They should add mixin <code>NestedViewSetMixin</code>. That mixin
adds automatic filtering by parent lookups:</p>

<pre><code># yourapp.views
from rest_framework_extensions.mixins import NestedViewSetMixin

class UserViewSet(NestedViewSetMixin, ModelViewSet):
    model = UserModel

class GroupViewSet(NestedViewSetMixin, ModelViewSet):
    model = GroupModel

class PermissionViewSet(NestedViewSetMixin, ModelViewSet):
    model = PermissionModel
</code></pre>

<p>With such kind of router we have next resources:</p>

<ul>
<li><code>/users/</code> - list of all users. Resolve name is <strong>user-list</strong></li>
<li><code>/users/&lt;pk&gt;/</code> - user detail. Resolve name is <strong>user-detail</strong></li>
<li><code>/users/&lt;parent_lookup_user_groups&gt;/groups/</code> - list of groups for exact user.
Resolve name is <strong>users-group-list</strong></li>
<li><code>/users/&lt;parent_lookup_user_groups&gt;/groups/&lt;pk&gt;/</code> - user group detail. If user doesn't have group then resource will
be not found. Resolve name is <strong>users-group-detail</strong></li>
<li><code>/users/&lt;parent_lookup_group__user&gt;/groups/&lt;parent_lookup_group&gt;/permissions/</code> - list of permissions for user group.
Resolve name is <strong>users-groups-permission-list</strong></li>
<li><code>/users/&lt;parent_lookup_group__user&gt;/groups/&lt;parent_lookup_group&gt;/permissions/&lt;pk&gt;/</code> - user group permission detail.
If user doesn't have group or group doesn't have permission then resource will be not found.
Resolve name is <strong>users-groups-permission-detail</strong></li>
</ul>

<p>Every resource is automatically filtered by parent lookups.</p>

<pre><code># Request
GET /users/1/groups/2/permissions/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8


[
  {
    id: 3,
    name: "read"
  },
  {
    id: 4,
    name: "update"
  },
  {
    id: 5,
    name: "delete"
  }
]
</code></pre>

<p>For request above permissions will be filtered by user with pk <code>1</code> and group with pk <code>2</code>:</p>

<pre><code>Permission.objects.filter(group__user=1, group=2)
</code></pre>

<p>Example with registering more then one nested resource in one depth:</p>

<pre><code>permissions_routes = router.register(
    r'permissions',
    PermissionViewSet,
    base_name='permission'
)
permissions_routes.register(
    r'groups',
    GroupViewSet,
    base_name='permissions-group',
    parents_query_lookups=['permissions']
)
permissions_routes.register(
    r'users',
    UserViewSet,
    base_name='permissions-user',
    parents_query_lookups=['groups__permissions']
)
</code></pre>

<p>With such kind of router we have next resources:</p>

<ul>
<li><code>/permissions/</code> - list of all permissions. Resolve name is <strong>permission-list</strong></li>
<li><code>/permissions/&lt;pk&gt;/</code> - permission detail. Resolve name is <strong>permission-detail</strong></li>
<li><code>/permissions/&lt;parent_lookup_permissions&gt;/groups/</code> - list of groups for exact permission.
Resolve name is <strong>permissions-group-list</strong></li>
<li><code>/permissions/&lt;parent_lookup_permissions&gt;/groups/&lt;pk&gt;/</code> - permission group detail. If group doesn't have
permission then resource will be not found. Resolve name is <strong>permissions-group-detail</strong></li>
<li><code>/permissions/&lt;parent_lookup_groups__permissions&gt;/users/</code> - list of users for exact permission.
Resolve name is <strong>permissions-user-list</strong></li>
<li><code>/permissions/&lt;parent_lookup_groups__permissions&gt;/user/&lt;pk&gt;/</code> - permission user detail. If user doesn't have
permission then resource will be not found. Resolve name is <strong>permissions-user-detail</strong></li>
</ul>

<h4 id="nested-router-mixin">Nested router mixin</h4>

<p>You can use <code>rest_framework_extensions.routers.NestedRouterMixin</code> for adding nesting feature into your routers:</p>

<pre><code>from rest_framework_extensions.routers import NestedRouterMixin
from rest_framework.routers import SimpleRouter

class SimpleRouterWithNesting(NestedRouterMixin, SimpleRouter):
    pass
</code></pre>

<h4 id="usage-with-generic-relations">Usage with generic relations</h4>

<p>If you want to use nested router for <a href="https://docs.djangoproject.com/en/dev/ref/contrib/contenttypes/#generic-relations">generic relation</a>
fields, you should explicitly filter <code>QuerySet</code> by content type.</p>

<p>For example if you have such kind of models:</p>

<pre><code>class Task(models.Model):
    title = models.CharField(max_length=30)

class Book(models.Model):
    title = models.CharField(max_length=30)

class Comment(models.Model):
    content_type = models.ForeignKey(ContentType)
    object_id = models.PositiveIntegerField()
    content_object = generic.GenericForeignKey()
    text = models.CharField(max_length=30)
</code></pre>

<p>Lets create viewsets for that models:</p>

<pre><code>class TaskViewSet(NestedViewSetMixin, ModelViewSet):
    model = TaskModel

class BookViewSet(NestedViewSetMixin, ModelViewSet):
    model = BookModel

class CommentViewSet(NestedViewSetMixin, ModelViewSet):
    queryset = CommentModel.objects.all()
</code></pre>

<p>And router like this:</p>

<pre><code>router = ExtendedSimpleRouter()
# tasks route
(
    router.register(r'tasks', TaskViewSet)
          .register(r'comments',
                    CommentViewSet,
                    'tasks-comment',
                    parents_query_lookups=['object_id'])
)
# books route
(
    router.register(r'books', BookViewSet)
          .register(r'comments',
                    CommentViewSet,
                    'books-comment',
                    parents_query_lookups=['object_id'])
)
</code></pre>

<p>As you can see we've added to <code>parents_query_lookups</code> only one <code>object_id</code> value. But when you make requests to <code>comments</code>
endpoint for both tasks and books routes there is no context for current content type.</p>

<pre><code># Request
GET /tasks/123/comments/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8

[
    {
        id: 1,
        content_type: 1,
        object_id: 123,
        text: "Good task!"
    },
    {
        id: 2,
        content_type: 2,  // oops. Wrong content type (for book)
        object_id: 123,   // task and book has the same id
        text: "Good book!"
    },
]
</code></pre>

<p>For such kind of cases you should explicitly filter <code>QuerySets</code> of nested viewsets by content type:</p>

<pre><code>from django.contrib.contenttypes.models import ContentType

class CommentViewSet(NestedViewSetMixin, ModelViewSet):
    queryset = CommentModel.objects.all()

class TaskCommentViewSet(CommentViewSet):
    def get_queryset(self):
        return super(TaskCommentViewSet, self).get_queryset().filter(
            content_type=ContentType.objects.get_for_model(TaskModel)
        )

class BookCommentViewSet(CommentViewSet):
    def get_queryset(self):
        return super(BookCommentViewSet, self).get_queryset().filter(
            content_type=ContentType.objects.get_for_model(BookModel)
        )
</code></pre>

<p>Lets use new viewsets in router:</p>

<pre><code>router = ExtendedSimpleRouter()
# tasks route
(
    router.register(r'tasks', TaskViewSet)
          .register(r'comments',
                    TaskCommentViewSet,
                    'tasks-comment',
                    parents_query_lookups=['object_id'])
)
# books route
(
    router.register(r'books', BookViewSet)
          .register(r'comments',
                    BookCommentViewSet,
                    'books-comment',
                    parents_query_lookups=['object_id'])
)
</code></pre>

<h3 id="serializers">Serializers</h3>

<p>Extensions for <a href="http://www.django-rest-framework.org/api-guide/serializers">serializers</a> functionality.</p>

<h4 id="partialupdateserializermixin">PartialUpdateSerializerMixin</h4>

<p><em>New in DRF-extensions 0.2.3</em></p>

<p>By default every saving of <a href="http://www.django-rest-framework.org/api-guide/serializers#modelserializer">ModelSerializer</a>
saves the whole object. Even partial update just patches model instance. For example:</p>

<pre><code>from myapps.models import City
from myapps.serializers import CitySerializer

moscow = City.objects.get(pk=10)
city_serializer = CitySerializer(
    instance=moscow,
    data={'country': 'USA'},
    partial=True
)
if city_serializer.is_valid():
    city_serializer.save()

# equivalent to
moscow.country = 'USA'
moscow.save()
</code></pre>

<p>SQL representation for previous example will be:</p>

<pre><code>UPDATE city SET name='Moscow', country='USA' WHERE id=1;
</code></pre>

<p>Django's <code>save</code> method has keyword argument <a href="https://docs.djangoproject.com/en/dev/ref/models/instances/#specifying-which-fields-to-save">update_fields</a>.
Only the fields named in that list will be updated:</p>

<pre><code>moscow.country = 'USA'
moscow.save(update_fields=['country'])
</code></pre>

<p>SQL representation for example with <code>update_fields</code> usage will be:</p>

<pre><code>UPDATE city SET country='USA' WHERE id=1;
</code></pre>

<p>To use <code>update_fields</code> for every partial update you should mixin <code>PartialUpdateSerializerMixin</code> to your serializer:</p>

<pre><code>from rest_framework_extensions.serializers import (
    PartialUpdateSerializerMixin
)

class CitySerializer(PartialUpdateSerializerMixin,
                     serializers.ModelSerializer):
    class Meta:
        model = City
</code></pre>

<h3 id="fields">Fields</h3>

<p>Set of serializer fields that extends <a href="http://www.django-rest-framework.org/api-guide/fields">default fields</a> functionality.</p>

<h4 id="resourceurifield">ResourceUriField</h4>

<p>Represents a hyperlinking uri that points to the detail view for that object.</p>

<pre><code>from rest_framework_extensions.fields import ResourceUriField

class CitySerializer(serializers.ModelSerializer):
    resource_uri = ResourceUriField(view_name='city-detail')

    class Meta:
        model = City
</code></pre>

<p>Request example:</p>

<pre><code># Request
GET /cities/268/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8

{
  id: 268,
  resource_uri: "http://localhost:8000/v1/cities/268/",
  name: "Serpuhov"
}
</code></pre>

<h3 id="permissions">Permissions</h3>

<p>Extensions for <a href="http://www.django-rest-framework.org/api-guide/permissions.html">permissions</a>.</p>

<h4 id="object-permissions">Object permissions</h4>

<p><em>New in DRF-extensions 0.2.2</em></p>

<p>Django Rest Framework allows you to use <a href="http://www.django-rest-framework.org/api-guide/permissions#djangoobjectpermissions">DjangoObjectPermissions</a> out of the box. But it has one limitation - if user has no permissions for viewing resource he will get <code>404</code> as response code. In most cases it's good approach because it solves security issues by default. But what if you wanted to return <code>401</code> or <code>403</code>? What if you wanted to say to user - "You need to be logged in for viewing current resource" or "You don't have permissions for viewing current resource"?</p>

<p><code>ExtenedDjangoObjectPermissions</code> will help you to be more flexible. By default it behaves as standard <a href="http://www.django-rest-framework.org/api-guide/permissions#djangoobjectpermissions">DjangoObjectPermissions</a>. For example, it is safe to replace <code>DjangoObjectPermissions</code> with extended permissions class:</p>

<pre><code>from rest_framework_extensions.permissions import (
    ExtendedDjangoObjectPermissions as DjangoObjectPermissions
)

class CommentView(viewsets.ModelViewSet):
    permission_classes = (DjangoObjectPermissions,)
</code></pre>

<p>Now every request from unauthorized user will get <code>404</code> response:</p>

<pre><code># Request
GET /comments/1/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 404 NOT FOUND
Content-Type: application/json; charset=UTF-8

{"detail": "Not found"}
</code></pre>

<p>With <code>ExtenedDjangoObjectPermissions</code> you can disable hiding forbidden for read objects by changing <code>hide_forbidden_for_read_objects</code> attribute:</p>

<pre><code>from rest_framework_extensions.permissions import (
    ExtendedDjangoObjectPermissions
)

class CommentViewObjectPermissions(ExtendedDjangoObjectPermissions):
    hide_forbidden_for_read_objects = False

class CommentView(viewsets.ModelViewSet):
    permission_classes = (CommentViewObjectPermissions,)
</code></pre>

<p>Now lets see request response for user that has no permissions for viewing <code>CommentView</code> object:</p>

<pre><code># Request
GET /comments/1/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 403 FORBIDDEN
Content-Type: application/json; charset=UTF-8

{u'detail': u'You do not have permission to perform this action.'}
</code></pre>

<p><code>ExtenedDjangoObjectPermissions</code> could be used only with Django Rest Framework &gt;= 2.3.8, because <a href="http://www.django-rest-framework.org/topics/release-notes#238">DjangoObjectPermissions</a> was introduced in 2.3.8 version.</p>

<h3 id="caching">Caching</h3>

<p>To cache something is to save the result of an expensive calculation so that you don't have to perform the calculation next time. Here's some pseudocode explaining how this would work for a dynamically generated api response:</p>

<pre><code>given a URL, try finding that API response in the cache
if the response is in the cache:
    return the cached response
else:
    generate the response
    save the generated response in the cache (for next time)
    return the generated response
</code></pre>

<h4 id="cache-response">Cache response</h4>

<p>DRF-extensions allows you to cache api responses with simple <code>@cache_response</code> decorator.
There are two requirements for decorated method:</p>

<ul>
<li>It should be method of class which is inherited from <code>rest_framework.views.APIView</code></li>
<li>It should return <code>rest_framework.response.Response</code> instance.</li>
</ul>

<p>Usage example:</p>

<pre><code>from rest_framework.response import Response
from rest_framework import views
from rest_framework_extensions.cache.decorators import (
    cache_response
)
from myapp.models import City

class CityView(views.APIView):
    @cache_response()
    def get(self, request, *args, **kwargs):
        cities = City.objects.all().values_list('name', flat=True)
        return Response(cities)
</code></pre>

<p>If you request view first time you'll get it from processed SQL query. (~60ms response time):</p>

<pre><code># Request
GET /cities/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8

['Moscow', 'London', 'Paris']
</code></pre>

<p>Second request will hit the cache. No sql evaluation, no database query. (~30 ms response time):</p>

<pre><code># Request
GET /cities/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8

['Moscow', 'London', 'Paris']
</code></pre>

<p>Reduction in response time depends on calculation complexity inside your API method. Sometimes it reduces from 1 second to 10ms, sometimes you win just 10ms.</p>

<h4 id="timeout">Timeout</h4>

<p>You can specify cache timeout in seconds, providing first argument:</p>

<pre><code>class CityView(views.APIView):
    @cache_response(60 * 15)
    def get(self, request, *args, **kwargs):
        ...
</code></pre>

<p>In the above example, the result of the <code>get()</code> view will be cached for 15 minutes.</p>

<p>If you don't specify <code>cache_timeout</code> argument then value from <code>REST_FRAMEWORK_EXTENSIONS</code> settings will be used. By default it's <code>None</code>, which means "cache forever". You can change this default in settings:</p>

<pre><code>REST_FRAMEWORK_EXTENSIONS = {
    'DEFAULT_CACHE_RESPONSE_TIMEOUT': 60 * 15
}
</code></pre>

<h4 id="usage-of-the-specific-cache">Usage of the specific cache</h4>

<p><em>New in DRF-extensions 0.2.3</em></p>

<p><code>@cache_response</code> can also take an optional keyword argument, <code>cache</code>, which directs the decorator
to use a specific cache (from your <a href="https://docs.djangoproject.com/en/dev/ref/settings/#std:setting-CACHES">CACHES</a> setting) when caching results.
By default, the <code>default</code> cache will be used, but you can specify any cache you want:</p>

<pre><code>class CityView(views.APIView):
    @cache_response(60 * 15, cache='special_cache')
    def get(self, request, *args, **kwargs):
        ...
</code></pre>

<p>You can specify what cache to use by default in settings:</p>

<pre><code>REST_FRAMEWORK_EXTENSIONS = {
    'DEFAULT_USE_CACHE': 'special_cache'
}
</code></pre>

<h4 id="cache-key">Cache key</h4>

<p>By default every cached data from <code>@cache_response</code> decorator stored by key, which calculated
with <a href="#default-key-constructor">DefaultKeyConstructor</a>.</p>

<p>You can change cache key by providing <code>key_func</code> argument, which must be callable:</p>

<pre><code>def calculate_cache_key(view_instance, view_method,
                        request, args, kwargs):
    return '.'.join([
        len(args),
        len(kwargs)
    ])

class CityView(views.APIView):
    @cache_response(60 * 15, key_func=calculate_cache_key)
    def get(self, request, *args, **kwargs):
        ...
</code></pre>

<p>You can implement view method and use it for cache key calculation by specifying <code>key_func</code> argument as string:</p>

<pre><code>class CityView(views.APIView):
    @cache_response(60 * 15, key_func='calculate_cache_key')
    def get(self, request, *args, **kwargs):
        ...

    def calculate_cache_key(self, view_instance, view_method,
                            request, args, kwargs):
        return '.'.join([
            len(args),
            len(kwargs)
        ])
</code></pre>

<p>Key calculation function will be called with next parameters:</p>

<ul>
<li><strong>view_instance</strong> - view instance of decorated method</li>
<li><strong>view_method</strong> - decorated method</li>
<li><strong>request</strong> - decorated method request</li>
<li><strong>args</strong> - decorated method positional arguments</li>
<li><strong>kwargs</strong> - decorated method keyword arguments</li>
</ul>

<h4 id="default-key-function">Default key function</h4>

<p>If <code>@cache_response</code> decorator used without key argument then default key function will be used. You can change this function in
settings:</p>

<pre><code>REST_FRAMEWORK_EXTENSIONS = {
    'DEFAULT_CACHE_KEY_FUNC':
      'rest_framework_extensions.utils.default_cache_key_func'
}
</code></pre>

<p><code>default_cache_key_func</code> uses <a href="#default-key-constructor">DefaultKeyConstructor</a> as a base for key calculation.</p>

<h4 id="caching-errors">Caching errors</h4>

<p><em>New in DRF-extensions 0.2.7</em></p>

<p>By default every response is cached, even failed. For example:</p>

<pre><code>class CityView(views.APIView):
    @cache_response()
    def get(self, request, *args, **kwargs):
        raise Exception("500 error comes from here")
</code></pre>

<p>First request to <code>CityView.get</code> will fail with <code>500</code> status code error and next requests to this endpoint will
return <code>500</code> error from cache.</p>

<p>You can change this behaviour by turning off caching error responses:</p>

<pre><code>class CityView(views.APIView):
    @cache_response(cache_errors=False)
    def get(self, request, *args, **kwargs):
        raise Exception("500 error comes from here")
</code></pre>

<p>You can change default behaviour by changing <code>DEFAULT_CACHE_ERRORS</code> setting:</p>

<pre><code>REST_FRAMEWORK_EXTENSIONS = {
    'DEFAULT_CACHE_ERRORS': False
}
</code></pre>

<h4 id="cacheresponsemixin">CacheResponseMixin</h4>

<p>It is common to cache standard <a href="http://www.django-rest-framework.org/api-guide/viewsets">viewset</a> <code>retrieve</code> and <code>list</code>
methods. That is why <code>CacheResponseMixin</code> exists. Just mix it into viewset implementation and those methods will
use functions, defined in <code>REST_FRAMEWORK_EXTENSIONS</code> <a href="#settings">settings</a>:</p>

<ul>
<li><em>"DEFAULT_OBJECT_CACHE_KEY_FUNC"</em> for <code>retrieve</code> method</li>
<li><em>"DEFAULT_LIST_CACHE_KEY_FUNC"</em> for <code>list</code> method</li>
</ul>

<p>By default those functions are using <a href="#default-key-constructor">DefaultKeyConstructor</a> and extends it:</p>

<ul>
<li>With <code>RetrieveSqlQueryKeyBit</code> for <em>"DEFAULT_OBJECT_CACHE_KEY_FUNC"</em></li>
<li>With <code>ListSqlQueryKeyBit</code> and <code>PaginationKeyBit</code> for <em>"DEFAULT_LIST_CACHE_KEY_FUNC"</em></li>
</ul>

<p>You can change those settings for custom cache key generation:</p>

<pre><code>REST_FRAMEWORK_EXTENSIONS = {
    'DEFAULT_OBJECT_CACHE_KEY_FUNC':
      'rest_framework_extensions.utils.default_object_cache_key_func',
    'DEFAULT_LIST_CACHE_KEY_FUNC':
      'rest_framework_extensions.utils.default_list_cache_key_func',
}
</code></pre>

<p>Mixin example usage:</p>

<pre><code>from myapps.serializers import UserSerializer
from rest_framework_extensions.cache.mixins import CacheResponseMixin

class UserViewSet(CacheResponseMixin, viewsets.ModelViewSet):
    serializer_class = UserSerializer
</code></pre>

<p>You can change cache key function by providing <code>object_cache_key_func</code> or
<code>list_cache_key_func</code> methods in view class:</p>

<pre><code>class UserViewSet(CacheResponseMixin, viewsets.ModelViewSet):
    serializer_class = UserSerializer

    def object_cache_key_func(self, **kwargs):
        return 'some key for object'

    def list_cache_key_func(self, **kwargs):
        return 'some key for list'
</code></pre>

<p>Ofcourse you can use custom <a href="#key-constructor">key constructor</a>:</p>

<pre><code>from yourapp.key_constructors import (
    CustomObjectKeyConstructor,
    CustomListKeyConstructor,
)

class UserViewSet(CacheResponseMixin, viewsets.ModelViewSet):
    serializer_class = UserSerializer
    object_cache_key_func = CustomObjectKeyConstructor()
    list_cache_key_func = CustomListKeyConstructor()
</code></pre>

<p>If you want to cache only <code>retrieve</code> method then you could use <code>rest_framework_extensions.cache.mixins.RetrieveCacheResponseMixin</code>.</p>

<p>If you want to cache only <code>list</code> method then you could use <code>rest_framework_extensions.cache.mixins.ListCacheResponseMixin</code>.</p>

<h3 id="key-constructor">Key constructor</h3>

<p>As you could see from previous section cache key calculation might seem fairly simple operation. But let's see next example. We make ordinary HTTP request to cities resource:</p>

<pre><code># Request
GET /cities/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8

['Moscow', 'London', 'Paris']
</code></pre>

<p>By the moment all goes fine - response returned and cached. Let's make the same request requiring XML response:</p>

<pre><code># Request
GET /cities/ HTTP/1.1
Accept: application/xml

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8

['Moscow', 'London', 'Paris']
</code></pre>

<p>What is that? Oh, we forgot about format negotiations. We can add format to key bits:</p>

<pre><code>def calculate_cache_key(view_instance, view_method,
                        request, args, kwargs):
    return '.'.join([
        len(args),
        len(kwargs),
        request.accepted_renderer.format  # here it is
    ])

# Request
GET /cities/ HTTP/1.1
Accept: application/xml

# Response
HTTP/1.1 200 OK
Content-Type: application/xml; charset=UTF-8

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;root&gt;
    &lt;list-item&gt;Moscow&lt;/list-item&gt;
    &lt;list-item&gt;London&lt;/list-item&gt;
    &lt;list-item&gt;Paris&lt;/list-item&gt;
&lt;/root&gt;
</code></pre>

<p>That's cool now - we have different responses for different formats with different cache keys. But there are many cases, where key should be different for different requests:</p>

<ul>
<li>Response format (json, xml);</li>
<li>User (exact authorized user or anonymous);</li>
<li>Different request meta data (request.META['REMOTE_ADDR']);</li>
<li>Language (ru, en);</li>
<li>Headers;</li>
<li>Query params. For example, <code>jsonp</code> resources need <code>callback</code> param, which rendered in response;</li>
<li>Pagination. We should show different data for different pages;</li>
<li>Etc...</li>
</ul>

<p>Of course we can use custom <code>calculate_cache_key</code> methods and reuse them for different API methods, but we can't reuse just parts of them. For example, one method depends on user id and language, but another only on user id. How to be more DRYish? Let's see some magic:</p>

<pre><code>from rest_framework_extensions.key_constructor.constructors import (
    KeyConstructor
)
from rest_framework_extensions.key_constructor import bits
from your_app.utils import get_city_by_ip

class CityGetKeyConstructor(KeyConstructor):
    unique_method_id = bits.UniqueMethodIdKeyBit()
    format = bits.FormatKeyBit()
    language = bits.LanguageKeyBit()

class CityHeadKeyConstructor(CityGetKeyConstructor):
    user = bits.UserKeyBit()
    request_meta = bits.RequestMetaKeyBit(params=['REMOTE_ADDR'])

class CityView(views.APIView):
    @cache_response(key_func=CityGetKeyConstructor())
    def get(self, request, *args, **kwargs):
        cities = City.objects.all().values_list('name', flat=True)
        return Response(cities)

    @cache_response(key_func=CityHeadKeyConstructor())
    def head(self, request, *args, **kwargs):
        city = ''
        user = self.request.user
        if user.is_authenticated() and user.city:
            city = Response(user.city.name)
        if not city:
            city = get_city_by_ip(request.META['REMOTE_ADDR'])
        return Response(city)
</code></pre>

<p>Firstly, let's revise <code>CityView.get</code> method cache key calculation. It constructs from 3 bits:</p>

<ul>
<li><strong>unique_method_id</strong> - remember that <a href="#cache-key">default key calculation</a>? Here it is. Just one of the cache key bits. <code>head</code> method has different set of bits and they can't collide with <code>get</code> method bits. But there could be another view class with the same bits.</li>
<li><strong>format</strong> - key would be different for different formats.</li>
<li><strong>language</strong> - key would be different for different languages.</li>
</ul>

<p>The second method <code>head</code> has the same <code>unique_method_id</code>, <code>format</code> and <code>language</code> bits, buts extends with 2 more:</p>

<ul>
<li><strong>user</strong> - key would be different for different users. As you can see in response calculation we use <code>request.user</code> instance. For different users we need different responses.</li>
<li><strong>request_meta</strong> - key would be different for different ip addresses. As you can see in response calculation we are falling back to getting city from ip address if couldn't get it from authorized user model.</li>
</ul>

<p>All default key bits are listed in <a href="#default-key-bits">this section</a>.</p>

<h4 id="default-key-constructor">Default key constructor</h4>

<p><code>DefaultKeyConstructor</code> is located in <code>rest_framework_extensions.key_constructor.constructors</code> module and constructs a key
from unique method id, request format and request language. It has next implementation:</p>

<pre><code>class DefaultKeyConstructor(KeyConstructor):
    unique_method_id = bits.UniqueMethodIdKeyBit()
    format = bits.FormatKeyBit()
    language = bits.LanguageKeyBit()
</code></pre>

<h4 id="how-key-constructor-works">How key constructor works</h4>

<p>Key constructor class works in the same manner as the standard <a href="https://docs.djangoproject.com/en/dev/topics/forms/">django forms</a> and
key bits used like form fields. Lets go through key construction steps for <a href="#default-key-constructor">DefaultKeyConstructor</a>.</p>

<p>Firstly, constructor starts iteration over every key bit:</p>

<ul>
<li><strong>unique_method_id</strong></li>
<li><strong>format</strong></li>
<li><strong>language</strong></li>
</ul>

<p>Then constructor gets data from every key bit calling method <code>get_data</code>:</p>

<ul>
<li><strong>unique_method_id</strong> - <code>u'your_app.views.SometView.get'</code></li>
<li><strong>format</strong> - <code>u'json'</code></li>
<li><strong>language</strong> - <code>u'en'</code></li>
</ul>

<p>Every key bit <code>get_data</code> method is called with next arguments:</p>

<ul>
<li><strong>view_instance</strong> - view instance of decorated method</li>
<li><strong>view_method</strong> - decorated method</li>
<li><strong>request</strong> - decorated method request</li>
<li><strong>args</strong> - decorated method positional arguments</li>
<li><strong>kwargs</strong> - decorated method keyword arguments</li>
</ul>

<p>After this it combines every key bit data to one dict, which keys are a key bits names in constructor, and values are returned data:</p>

<pre><code>{
    'unique_method_id': u'your_app.views.SometView.get',
    'format': u'json',
    'language': u'en'
}
</code></pre>

<p>Then constructor dumps resulting dict to json:</p>

<pre><code>'{"unique_method_id": "your_app.views.SometView.get", "language": "en", "format": "json"}'
</code></pre>

<p>And finally compresses json with <strong>sha256</strong> and returns hash value:</p>

<pre><code>'b04f8f03c89df824e0ecd25230a90f0e0ebe184cf8c0114342e9471dd2275baa'
</code></pre>

<h4 id="custom-key-bit">Custom key bit</h4>

<p>We are going to create a simple key bit which could be used in real applications with next properties:</p>

<ul>
<li>High read rate</li>
<li>Low write rate</li>
</ul>

<p>The task is - cache every read request and invalidate all cache data after write to any model, which used in API. This approach
let us don't think about granular cache invalidation - just flush it after any model instance change/creation/deletion.</p>

<p>Lets create models:</p>

<pre><code># models.py
from django.db import models

class Group(models.Model):
    title = models.CharField()

class Profile(models.Model):
    name = models.CharField()
    group = models.ForeignKey(Group)
</code></pre>

<p>Define serializers:</p>

<pre><code># serializers.py
from yourapp.models import Group, Profile
from rest_framework import serializers

class GroupSerializer(serializers.ModelSerializer):
    class Meta:
        model = Group

class ProfileSerializer(serializers.ModelSerializer):
    group = GroupSerializer()

    class Meta:
        model = Profile
</code></pre>

<p>Create views:</p>

<pre><code># views.py
from yourapp.serializers import GroupSerializer, ProfileSerializer
from yourapp.models import Group, Profile

class GroupViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = GroupSerializer
    queryset = Group.objects.all()

class ProfileViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = ProfileSerializer
    queryset = Profile.objects.all()
</code></pre>

<p>And finally register views in router:</p>

<pre><code># urls.py
from yourapp.views import GroupViewSet,ProfileViewSet

router = DefaultRouter()
router.register(r'groups', GroupViewSet)
router.register(r'profiles', ProfileViewSet)
urlpatterns = router.urls
</code></pre>

<p>At the moment we have API, but it's not cached. Lets cache it and create our custom key bit:</p>

<pre><code># views.py
import datetime
from django.core.cache import cache
from django.utils.encoding import force_text
from yourapp.serializers import GroupSerializer, ProfileSerializer
from rest_framework_extensions.cache.decorators import cache_response
from rest_framework_extensions.key_constructor.constructors import (
    DefaultKeyConstructor
)
from rest_framework_extensions.key_constructor.bits import (
    KeyBitBase,
    RetrieveSqlQueryKeyBit,
    ListSqlQueryKeyBit,
    PaginationKeyBit
)

class UpdatedAtKeyBit(KeyBitBase):
    def get_data(self, **kwargs):
        key = 'api_updated_at_timestamp'
        value = cache.get(key, None)
        if not value:
            value = datetime.datetime.utcnow()
            cache.set(key, value=value)
        return force_text(value)

class CustomObjectKeyConstructor(DefaultKeyConstructor):
    retrieve_sql = RetrieveSqlQueryKeyBit()
    updated_at = UpdatedAtKeyBit()

class CustomListKeyConstructor(DefaultKeyConstructor):
    list_sql = ListSqlQueryKeyBit()
    pagination = PaginationKeyBit()
    updated_at = UpdatedAtKeyBit()

class GroupViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = GroupSerializer

    @cache_response(key_func=CustomObjectKeyConstructor())
    def retrieve(self, *args, **kwargs):
        return super(GroupViewSet, self).retrieve(*args, **kwargs)

    @cache_response(key_func=CustomListKeyConstructor())
    def list(self, *args, **kwargs):
        return super(GroupViewSet, self).list(*args, **kwargs)

class ProfileViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = ProfileSerializer

    @cache_response(key_func=CustomObjectKeyConstructor())
    def retrieve(self, *args, **kwargs):
        return super(ProfileViewSet, self).retrieve(*args, **kwargs)

    @cache_response(key_func=CustomListKeyConstructor())
    def list(self, *args, **kwargs):
        return super(ProfileViewSet, self).list(*args, **kwargs)
</code></pre>

<p>As you can see <code>UpdatedAtKeyBit</code> just adds to key information when API models has been update last time. If there is no
information about it then new datetime will be used for key bit data.</p>

<p>Lets write cache invalidation. We just connect models to standard signals and change value in cache by key <code>api_updated_at_timestamp</code>:</p>

<pre><code># models.py
import datetime
from django.db import models
from django.db.models.signals import post_save, post_delete

def change_api_updated_at(sender=None, instance=None, *args, **kwargs):
    cache.set('api_updated_at_timestamp', datetime.datetime.utcnow())

class Group(models.Model):
    title = models.CharField()

class Profile(models.Model):
    name = models.CharField()
    group = models.ForeignKey(Group)

for model in [Group, Profile]:
    post_save.connect(receiver=change_api_updated_at, sender=model)
    post_delete.connect(receiver=change_api_updated_at, sender=model)
</code></pre>

<p>And that's it. When any model changes then value in cache by key <code>api_updated_at_timestamp</code> will be changed too. After this every
key constructor, that used <code>UpdatedAtKeyBit</code>, will construct new keys and <code>@cache_response</code> decorator will
cache data in new places.</p>

<h4 id="key-constructor-params">Key constructor params</h4>

<p><em>New in DRF-extensions 0.2.3</em></p>

<p>You can change <code>params</code> attribute for specific key bit by providing <code>params</code> dict for key constructor initialization
function. For example, here is custom key constructor, which inherits from <a href="#default-key-constructor">DefaultKeyConstructor</a>
and adds geoip key bit:</p>

<pre><code>class CityKeyConstructor(DefaultKeyConstructor):
    geoip = bits.RequestMetaKeyBit(params=['GEOIP_CITY'])
</code></pre>

<p>If you wanted to use <code>GEOIP_COUNTRY</code>, you could create new key constructor:</p>

<pre><code>class CountryKeyConstructor(DefaultKeyConstructor):
    geoip = bits.RequestMetaKeyBit(params=['GEOIP_COUNTRY'])
</code></pre>

<p>But there is another way. You can send <code>params</code> in key constructor initialization method. This is the dict attribute, where
keys are bit names and values are bit <code>params</code> attribute value (look at <code>CountryView</code>):</p>

<pre><code>class CityKeyConstructor(DefaultKeyConstructor):
    geoip = bits.RequestMetaKeyBit(params=['GEOIP_COUNTRY'])

class CityView(views.APIView):
    @cache_response(key_func=CityKeyConstructor())
    def get(self, request, *args, **kwargs):
        ...

class CountryView(views.APIView):
    @cache_response(key_func=CityKeyConstructor(
        params={'geoip': ['GEOIP_COUNTRY']}
    ))
    def get(self, request, *args, **kwargs):
        ...
</code></pre>

<p>If there is no item provided for key bit then default key bit <code>params</code> value will be used.</p>

<h4 id="constructor-s-bits-list">Constructor's bits list</h4>

<p>You can dynamically change key constructor's bits list in initialization method by altering <code>bits</code> attribute:</p>

<pre><code>class CustomKeyConstructor(DefaultKeyConstructor):
    def __init__(self, *args, **kwargs):
        super(CustomKeyConstructor, self).__init__(*args, **kwargs)
        self.bits['geoip'] = bits.RequestMetaKeyBit(
            params=['GEOIP_CITY']
        )
</code></pre>

<h3 id="default-key-bits">Default key bits</h3>

<p>Out of the box DRF-extensions has some basic key bits. They are all located in <code>rest_framework_extensions.key_constructor.bits</code> module.</p>

<h4 id="formatkeybit">FormatKeyBit</h4>

<p>Retrieves format info from request. Usage example:</p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    format = FormatKeyBit()
</code></pre>

<h4 id="languagekeybit">LanguageKeyBit</h4>

<p>Retrieves active language for request. Usage example:</p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    user = LanguageKeyBit()
</code></pre>

<h4 id="userkeybit">UserKeyBit</h4>

<p>Retrieves user id from request. If it is anonymous then returnes <em>"anonymous"</em> string. Usage example:</p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    user = UserKeyBit()
</code></pre>



<p>Retrieves data from <a href="https://docs.djangoproject.com/en/dev/ref/request-response/#django.http.HttpRequest.META">request.META</a> dict.
Usage example:</p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    ip_address_and_user_agent = bits.RequestMetaKeyBit(
        ['REMOTE_ADDR', 'HTTP_USER_AGENT']
    )
</code></pre>

<p>You can use <code>*</code> for retrieving all meta data to key bit:</p>

<p><em>New in DRF-extensions 0.2.7</em></p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    all_request_meta = bits.RequestMetaKeyBit('*')
</code></pre>

<h4 id="headerskeybit">HeadersKeyBit</h4>

<p>Same as <code>RequestMetaKeyBit</code> retrieves data from <a href="https://docs.djangoproject.com/en/dev/ref/request-response/#django.http.HttpRequest.META">request.META</a> dict.
The difference is that <code>HeadersKeyBit</code> allows to use normal header names:</p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    user_agent_and_geobase_id = bits.HeadersKeyBit(
        ['user-agent', 'x-geobase-id']
    )
    # will process request.META['HTTP_USER_AGENT'] and
    #              request.META['HTTP_X_GEOBASE_ID']
</code></pre>

<p>You can use <code>*</code> for retrieving all headers to key bit:</p>

<p><em>New in DRF-extensions 0.2.7</em></p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    all_headers = bits.HeadersKeyBit('*')
</code></pre>

<h4 id="argskeybit">ArgsKeyBit</h4>

<p><em>New in DRF-extensions 0.2.7</em></p>

<p>Retrieves data from the view's positional arguments.
A list of position indices can be passed to indicate which arguments to use. For retrieving all arguments you can use <code>*</code> which is also the default value:</p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    args = bits.ArgsKeyBit()  # will use all positional arguments

class MyKeyConstructor(KeyConstructor):
    args = bits.ArgsKeyBit('*')  # same as above

class MyKeyConstructor(KeyConstructor):
    args = bits.ArgsKeyBit([0, 2])
</code></pre>

<h4 id="kwargskeybit">KwargsKeyBit</h4>

<p><em>New in DRF-extensions 0.2.7</em></p>

<p>Retrieves data from the views's keyword arguments.
A list of keyword argument names can be passed to indicate which kwargs to use. For retrieving all kwargs you can use <code>*</code> which is also the default value:</p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    kwargs = bits.KwargsKeyBit()  # will use all keyword arguments

class MyKeyConstructor(KeyConstructor):
    kwargs = bits.KwargsKeyBit('*')  # same as above

class MyKeyConstructor(KeyConstructor):
    kwargs = bits.KwargsKeyBit(['user_id', 'city'])
</code></pre>

<h4 id="queryparamskeybit">QueryParamsKeyBit</h4>

<p>Retrieves data from <a href="https://docs.djangoproject.com/en/dev/ref/request-response/#django.http.HttpRequest.GET">request.GET</a> dict.
Usage example:</p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    part_and_callback = bits.QueryParamsKeyBit(
        ['part', 'callback']
    )
</code></pre>

<p>You can use <code>*</code> for retrieving all query params to key bit which is also the default value:</p>

<p><em>New in DRF-extensions 0.2.7</em></p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    all_query_params = bits.QueryParamsKeyBit('*')  # all qs parameters

class MyKeyConstructor(KeyConstructor):
    all_query_params = bits.QueryParamsKeyBit()  # same as above
</code></pre>

<h4 id="paginationkeybit">PaginationKeyBit</h4>

<p>Inherits from <code>QueryParamsKeyBit</code> and returns data from used pagination params.</p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    pagination = bits.PaginationKeyBit()
</code></pre>

<h4 id="listsqlquerykeybit">ListSqlQueryKeyBit</h4>

<p>Retrieves sql query for <code>view.filter_queryset(view.get_queryset())</code> filtering.</p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    list_sql_query = bits.ListSqlQueryKeyBit()
</code></pre>

<h4 id="retrievesqlquerykeybit">RetrieveSqlQueryKeyBit</h4>

<p>Retrieves sql query for retrieving exact object.</p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    retrieve_sql_query = bits.RetrieveSqlQueryKeyBit()
</code></pre>

<h4 id="uniqueviewidkeybit">UniqueViewIdKeyBit</h4>

<p>Combines data about view module and view class name.</p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    unique_view_id = bits.UniqueViewIdKeyBit()
</code></pre>

<h4 id="uniquemethodidkeybit">UniqueMethodIdKeyBit</h4>

<p>Combines data about view module, view class name and view method name.</p>

<pre><code>class MyKeyConstructor(KeyConstructor):
    unique_view_id = bits.UniqueMethodIdKeyBit()
</code></pre>

<h3 id="conditional-requests">Conditional requests</h3>

<p><em>This documentation section uses information from <a href="http://shop.oreilly.com/product/9780596801694.do">RESTful Web Services Cookbook</a> 10-th chapter.</em></p>

<p>Conditional HTTP request allows API clients to accomplish 2 goals:</p>

<ul>
<li>Conditional HTTP GET saves client and server time and bandwidth.</li>
<li>For unsafe requests such as PUT, POST, and DELETE, conditional requests provide concurrency control.</li>
</ul>

<h4 id="http-etag">HTTP Etag</h4>

<p><em>An ETag or entity tag, is part of HTTP, the protocol for the World Wide Web. It is one of several mechanisms that HTTP provides for web cache validation, and which allows a client to make conditional requests.</em> - <a href="http://en.wikipedia.org/wiki/HTTP_ETag">Wikipedia</a></p>

<p>For etag calculation and conditional request processing you should use <code>rest_framework_extensions.etag.decorators.etag</code> decorator. It's similar to native <a href="https://docs.djangoproject.com/en/dev/topics/conditional-view-processing/">django decorator</a>.</p>

<pre><code>from rest_framework_extensions.etag.decorators import etag

class CityView(views.APIView):
    @etag()
    def get(self, request, *args, **kwargs):
        cities = City.objects.all().values_list('name', flat=True)
        return Response(cities)
</code></pre>

<p>By default <code>@etag</code> would calculate header value with the same algorithm as <a href="#cache-key">cache key</a> default calculation performs.</p>

<pre><code># Request
GET /cities/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8
ETag: "e7b50490dc546d116635a14cfa58110306dd6c5434146b6740ec08bf0a78f9a2"

['Moscow', 'London', 'Paris']
</code></pre>

<p>You can define custom function for Etag value calculation with <code>etag_func</code> argument:</p>

<pre><code>from rest_framework_extensions.etag.decorators import etag

def calculate_etag(view_instance, view_method,
                   request, args, kwargs):
    return '.'.join([
        len(args),
        len(kwargs)
    ])

class CityView(views.APIView):
    @etag(etag_func=calculate_etag)
    def get(self, request, *args, **kwargs):
        cities = City.objects.all().values_list('name', flat=True)
        return Response(cities)
</code></pre>

<p>You can implement view method and use it for Etag calculation by specifying <code>etag_func</code> argument as string:</p>

<pre><code>from rest_framework_extensions.etag.decorators import etag

class CityView(views.APIView):
    @etag(etag_func='calculate_etag_from_method')
    def get(self, request, *args, **kwargs):
        cities = City.objects.all().values_list('name', flat=True)
        return Response(cities)

    def calculate_etag_from_method(self, view_instance, view_method,
                                   request, args, kwargs):
        return '.'.join([
            len(args),
            len(kwargs)
        ])
</code></pre>

<p>Etag calculation function will be called with next parameters:</p>

<ul>
<li><strong>view_instance</strong> - view instance of decorated method</li>
<li><strong>view_method</strong> - decorated method</li>
<li><strong>request</strong> - decorated method request</li>
<li><strong>args</strong> - decorated method positional arguments</li>
<li><strong>kwargs</strong> - decorated method keyword arguments</li>
</ul>

<h4 id="default-etag-function">Default etag function</h4>

<p>If <code>@etag</code> decorator used without <code>etag_func</code> argument then default etag function will be used. You can change this function in
settings:</p>

<pre><code>REST_FRAMEWORK_EXTENSIONS = {
    'DEFAULT_ETAG_FUNC':
      'rest_framework_extensions.utils.default_etag_func'
}
</code></pre>

<p><code>default_etag_func</code> uses <a href="#default-key-constructor">DefaultKeyConstructor</a> as a base for etag calculation.</p>

<h4 id="usage-with-caching">Usage with caching</h4>

<p>As you can see <code>@etag</code> and <code>@cache_response</code> decorators has similar key calculation approaches. They both can take key from simple callable function. And more then this - in many cases they share the same calculation logic. In the next example we use both decorators, which share one calculation function:</p>

<pre><code>from rest_framework_extensions.etag.decorators import etag
from rest_framework_extensions.cache.decorators import cache_response
from rest_framework_extensions.key_constructor import bits
from rest_framework_extensions.key_constructor.constructors import (
    KeyConstructor
)

class CityGetKeyConstructor(KeyConstructor):
    format = bits.FormatKeyBit()
    language = bits.LanguageKeyBit()

class CityView(views.APIView):
    key_constructor_func = CityGetKeyConstructor()

    @etag(key_constructor_func)
    @cache_response(key_func=key_constructor_func)
    def get(self, request, *args, **kwargs):
        cities = City.objects.all().values_list('name', flat=True)
        return Response(cities)
</code></pre>

<p>Note the decorators order. First goes <code>@etag</code> and after goes <code>@cache_response</code>. We want firstly perform conditional processing and after it response processing.</p>

<p>There is one more point for it. If conditional processing didn't fail then <code>key_constructor_func</code> would be called again in <code>@cache_response</code>.
But in most cases first calculation is enough. To accomplish this goal you could use <code>KeyConstructor</code> initial argument <code>memoize_for_request</code>:</p>

<pre><code>&gt;&gt;&gt; key_constructor_func = CityGetKeyConstructor(memoize_for_request=True)
&gt;&gt;&gt; request1, request1 = 'request1', 'request2'
&gt;&gt;&gt; print key_constructor_func(request=request1)  # full calculation
request1-key
&gt;&gt;&gt; print key_constructor_func(request=request1)  # data from cache
request1-key
&gt;&gt;&gt; print key_constructor_func(request=request2)  # full calculation
request2-key
&gt;&gt;&gt; print key_constructor_func(request=request2)  # data from cache
request2-key
</code></pre>

<p>By default <code>memoize_for_request</code> is <code>False</code>, but you can change it in settings:</p>

<pre><code>REST_FRAMEWORK_EXTENSIONS = {
    'DEFAULT_KEY_CONSTRUCTOR_MEMOIZE_FOR_REQUEST': True
}
</code></pre>

<p>It's important to note that this memoization is thread safe.</p>

<h4 id="saving-time-and-bandwith">Saving time and bandwith</h4>

<p>When a server returns <code>ETag</code> header, you should store it along with the representation data on the client.
When making GET and HEAD requests for the same resource in the future, include the <code>If-None-Match</code> header
to make these requests "conditional".</p>

<p>For example, retrieve all cities:</p>

<pre><code># Request
GET /cities/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8
ETag: "some_etag_value"

['Moscow', 'London', 'Paris']
</code></pre>

<p>If you make same request with <code>If-None-Match</code> and there is the cached value for this request,
then server will respond with <code>304</code> status code without body data.</p>

<pre><code># Request
GET /cities/ HTTP/1.1
Accept: application/json
If-None-Match: some_etag_value

# Response
HTTP/1.1 304 NOT MODIFIED
Content-Type: application/json; charset=UTF-8
Etag: "some_etag_value"
</code></pre>

<p>After this response you can use existing cities data on the client.</p>

<h4 id="concurrency-control">Concurrency control</h4>

<p>Concurrency control ensures the correct processing of data under concurrent operations by clients.
There are two ways to implement concurrency control:</p>

<ul>
<li><strong>Pessimistic concurrency control</strong>. In this model, the client gets a lock, obtains
the current state of the resource, makes modifications, and then releases the lock.
During this process, the server prevents other clients from acquiring a lock on the same resource.
Relational databases operate in this manner.</li>
<li><strong>Optimistic concurrency control</strong>. In this model, the client first gets a token.
Instead of obtaining a lock, the client attempts a write operation with the token included in the request.
The operation succeeds if the token is still valid and fails otherwise.</li>
</ul>

<p>HTTP, being a stateless application control, is designed for optimistic concurrency control.</p>

<pre><code>                                PUT
                                 |
                          +-------------+
                          |  Etag       |
                          |  supplied?  |
                          +-------------+
                           |           |
                          Yes          No
                           |           |
        +--------------------+       +-----------------------+
        |  Do preconditions  |       |  Does the             |
        |  match?            |       |  resource exist?      |
        +--------------------+       +-----------------------+
            |           |                   |              |
            Yes         No                  Yes            No
            |           |                   |              |
+--------------+  +--------------------+  +-------------+  |
|  Update the  |  |  412 Precondition  |  |  403        |  |
|  resource    |  |  failed            |  |  Forbidden  |  |
+--------------+  +--------------------+  +-------------+  |
                                                           |
                                     +-----------------------+
                                     |  Can clients          |
                                     |  create resources     |
                                     +-----------------------+
                                           |           |
                                          Yes          No
                                           |           |
                                     +-----------+   +-------------+
                                     |  201      |   |  404        |
                                     |  Created  |   |  Not Found  |
                                     +-----------+   +-------------+
</code></pre>

<p>Delete:</p>

<pre><code>                               DELETE
                                 |
                          +-------------+
                          |  Etag       |
                          |  supplied?  |
                          +-------------+
                           |           |
                          Yes          No
                           |           |
        +--------------------+       +-------------+
        |  Do preconditions  |       |  403        |
        |  match?            |       |  Forbidden  |
        +--------------------+       +-------------+
            |           |
            Yes         No
            |           |
+--------------+  +--------------------+
|  Delete the  |  |  412 Precondition  |
|  resource    |  |  failed            |
+--------------+  +--------------------+
</code></pre>

<p>Here is example of implementation for all CRUD methods (except create, because it doesn't need concurrency control)
wrapped with <code>etag</code> decorator:</p>

<pre><code>from rest_framework.viewsets import ModelViewSet
from rest_framework_extensions.key_constructor import bits
from rest_framework_extensions.key_constructor.constructors import (
    KeyConstructor
)

from your_app.models import City
from your_app.key_bits import UpdatedAtKeyBit

class CityListKeyConstructor(KeyConstructor):
    format = bits.FormatKeyBit()
    language = bits.LanguageKeyBit()
    pagination = bits.PaginationKeyBit()
    list_sql_query = bits.ListSqlQueryKeyBit()
    unique_view_id = bits.UniqueViewIdKeyBit()

class CityDetailKeyConstructor(KeyConstructor):
    format = bits.FormatKeyBit()
    language = bits.LanguageKeyBit()
    retrieve_sql_query = bits.RetrieveSqlQueryKeyBit()
    unique_view_id = bits.UniqueViewIdKeyBit()
    updated_at = UpdatedAtKeyBit()

class CityViewSet(ModelViewSet):
    list_key_func = CityListKeyConstructor(
        memoize_for_request=True
    )
    obj_key_func = CityDetailKeyConstructor(
        memoize_for_request=True
    )

    @etag(list_key_func)
    @cache_response(key_func=list_key_func)
    def list(self, request, *args, **kwargs):
        return super(CityViewSet, self).list(request, *args, **kwargs)

    @etag(obj_key_func)
    @cache_response(key_func=obj_key_func)
    def retrieve(self, request, *args, **kwargs):
        return super(CityViewSet, self).retrieve(request, *args, **kwargs)

    @etag(obj_key_func)
    def update(self, request, *args, **kwargs):
        return super(CityViewSet, self).update(request, *args, **kwargs)

    @etag(obj_key_func)
    def destroy(self, request, *args, **kwargs):
        return super(CityViewSet, self).destroy(request, *args, **kwargs)
</code></pre>

<h4 id="etag-for-unsafe-methods">Etag for unsafe methods</h4>

<p>From previous section you could see that unsafe methods, such <code>update</code> (PUT, PATCH) or <code>destroy</code> (DELETE), have the same <code>@etag</code>
decorator wrapping manner as the safe methods.</p>

<p>But every unsafe method has one distinction from safe method - it changes the data
which could be used for Etag calculation. In our case it is <code>UpdatedAtKeyBit</code>. It means that we should calculate Etag:</p>

<ul>
<li>Before building response - for <code>If-Match</code> and <code>If-None-Match</code> conditions validation</li>
<li>After building response (if necessary) - for clients</li>
</ul>

<p><code>@etag</code> decorator has special attribute <code>rebuild_after_method_evaluation</code>, which by default is <code>False</code>.</p>

<p>If you specify <code>rebuild_after_method_evaluation</code> as <code>True</code> then Etag will be rebuilt after method evaluation:</p>

<pre><code>class CityViewSet(ModelViewSet):
    ...
    @etag(obj_key_func, rebuild_after_method_evaluation=True)
    def update(self, request, *args, **kwargs):
        return super(CityViewSet, self).update(request, *args, **kwargs)

    @etag(obj_key_func)
    def destroy(self, request, *args, **kwargs):
        return super(CityViewSet, self).destroy(request, *args, **kwargs)

# Request
PUT /cities/1/ HTTP/1.1
Accept: application/json

{"name": "London"}

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8
ETag: "4e63ef056f47270272b96523f51ad938b5ea141024b767880eac047d10a0b339"

{
  id: 1,
  name: "London"
}
</code></pre>

<p>As you can see we didn't specify <code>rebuild_after_method_evaluation</code> for <code>destroy</code> method. That is because there is no
sense to use returned Etag value on clients if object deletion already performed.</p>

<p>With <code>rebuild_after_method_evaluation</code> parameter Etag calculation for <code>PUT</code>/<code>PATCH</code> method would look like:</p>

<pre><code>             +--------------+
             |    Request   |
             +--------------+
                    |
       +--------------------------+
       |  Calculate Etag          |
       |  for condition matching  |
       +--------------------------+
                    |
          +--------------------+
          |  Do preconditions  |
          |  match?            |
          +--------------------+
              |           |
              Yes         No
              |           |
  +--------------+  +--------------------+
  |  Update the  |  |  412 Precondition  |
  |  resource    |  |  failed            |
  +--------------+  +--------------------+
         |
+--------------------+
|  Calculate Etag    |
|  again and add it  |
|  to response       |
+--------------------+
         |
   +------------+
   |  Return    |
   |  response  |
   +------------+
</code></pre>

<p><code>If-None-Match</code> example for <code>DELETE</code> method:</p>

<pre><code># Request
DELETE /cities/1/ HTTP/1.1
Accept: application/json
If-None-Match: some_etag_value

# Response
HTTP/1.1 304 NOT MODIFIED
Content-Type: application/json; charset=UTF-8
Etag: "some_etag_value"
</code></pre>

<p><code>If-Match</code> example for <code>DELETE</code> method:</p>

<pre><code># Request
DELETE /cities/1/ HTTP/1.1
Accept: application/json
If-Match: another_etag_value

# Response
HTTP/1.1 412 PRECONDITION FAILED
Content-Type: application/json; charset=UTF-8
Etag: "some_etag_value"
</code></pre>

<h4 id="etagmixin">ETAGMixin</h4>

<p>It is common to process etags for standard <a href="http://www.django-rest-framework.org/api-guide/viewsets">viewset</a>
<code>retrieve</code>, <code>list</code>, <code>update</code> and <code>destroy</code> methods.
That is why <code>ETAGMixin</code> exists. Just mix it into viewset
implementation and those methods will use functions, defined in <code>REST_FRAMEWORK_EXTENSIONS</code> <a href="#settings">settings</a>:</p>

<ul>
<li><em>"DEFAULT_OBJECT_ETAG_FUNC"</em> for <code>retrieve</code>, <code>update</code> and <code>destroy</code> methods</li>
<li><em>"DEFAULT_LIST_ETAG_FUNC"</em> for <code>list</code> method</li>
</ul>

<p>By default those functions are using <a href="#default-key-constructor">DefaultKeyConstructor</a> and extends it:</p>

<ul>
<li>With <code>RetrieveSqlQueryKeyBit</code> for <em>"DEFAULT_OBJECT_ETAG_FUNC"</em></li>
<li>With <code>ListSqlQueryKeyBit</code> and <code>PaginationKeyBit</code> for <em>"DEFAULT_LIST_ETAG_FUNC"</em></li>
</ul>

<p>You can change those settings for custom etag generation:</p>

<pre><code>REST_FRAMEWORK_EXTENSIONS = {
    'DEFAULT_OBJECT_ETAG_FUNC':
      'rest_framework_extensions.utils.default_object_etag_func',
    'DEFAULT_LIST_ETAG_FUNC':
      'rest_framework_extensions.utils.default_list_etag_func',
}
</code></pre>

<p>Mixin example usage:</p>

<pre><code>from myapps.serializers import UserSerializer
from rest_framework_extensions.etag.mixins import ETAGMixin

class UserViewSet(ETAGMixin, viewsets.ModelViewSet):
    serializer_class = UserSerializer
</code></pre>

<p>You can change etag function by providing <code>object_etag_func</code> or
<code>list_etag_func</code> methods in view class:</p>

<pre><code>class UserViewSet(ETAGMixin, viewsets.ModelViewSet):
    serializer_class = UserSerializer

    def object_etag_func(self, **kwargs):
        return 'some key for object'

    def list_etag_func(self, **kwargs):
        return 'some key for list'
</code></pre>

<p>Ofcourse you can use custom <a href="#key-constructor">key constructor</a>:</p>

<pre><code>from yourapp.key_constructors import (
    CustomObjectKeyConstructor,
    CustomListKeyConstructor,
)

class UserViewSet(ETAGMixin, viewsets.ModelViewSet):
    serializer_class = UserSerializer
    object_etag_func = CustomObjectKeyConstructor()
    list_etag_func = CustomListKeyConstructor()
</code></pre>

<p>It is important to note that etags for unsafe method <code>update</code> is processed with parameter
<code>rebuild_after_method_evaluation</code> equals <code>True</code>. You can read why from <a href="#etag-for-unsafe-methods">this</a> section.</p>

<p>There are other mixins for more granular Etag calculation in <code>rest_framework_extensions.etag.mixins</code> module:</p>

<ul>
<li><strong>ReadOnlyETAGMixin</strong> - only for <code>retrieve</code> and <code>list</code> methods</li>
<li><strong>RetrieveETAGMixin</strong> - only for <code>retrieve</code> method</li>
<li><strong>ListETAGMixin</strong> - only for <code>list</code> method</li>
<li><strong>DestroyETAGMixin</strong> - only for <code>destroy</code> method</li>
<li><strong>UpdateETAGMixin</strong> - only for <code>update</code> method</li>
</ul>



<p>If you use <a href="https://docs.djangoproject.com/en/dev/ref/middleware/#module-django.middleware.gzip">GZipMiddleware</a>
and your client accepts Gzipped response, then you should return different ETags for compressed and not compressed responses.
That's what <code>GZipMiddleware</code> does by default while processing response -
it adds <code>;gzip</code> postfix to ETag response header if client requests compressed response.
Lets see it in example. First request without compression:</p>

<pre><code># Request
GET /cities/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8
ETag: "e7b50490dc"

['Moscow', 'London', 'Paris']
</code></pre>

<p>Second request with compression:</p>

<pre><code># Request
GET /cities/ HTTP/1.1
Accept: application/json
Accept-Encoding: gzip

# Response
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 675
Content-Encoding: gzip
ETag: "e7b50490dc;gzip"

wS?n?0?_%o?cc?Ҫ?Eʒ?Cժʻ?a\1?a?^T*7q&lt;&gt;[Nvh?[?^9?x:/Ms?79?Fd/???ۦjES?ڽ?&amp;??c%^?C[K۲%N?w{?졭2?m?}?Q&amp;Egz??
</code></pre>

<p>As you can see there is <code>;gzip</code> postfix in ETag response header.
That's ok but there is one caveat - drf-extension doesn't know how you post-processed calculated ETag value.
And your clients could have next problem with conditional request:</p>

<ul>
<li>Client sends request to retrieve compressed data about cities to <code>/cities/</code></li>
<li>DRF-extensions decorator calculates ETag header for response equals, for example, <code>123</code></li>
<li><code>GZipMiddleware</code> adds <code>;gzip</code> postfix to ETag header response, and now it equals <code>123;gzip</code></li>
<li>Client retrieves response with ETag equals <code>123;gzip</code></li>
<li>Client again makes request to retrieve compressed data about cities,
but now it's conditional request with <code>If-None-Match</code> header equals <code>123;gzip</code></li>
<li>DRF-extensions decorator calculates ETag value for processing conditional request.
But it doesn't know, that <code>GZipMiddleware</code> added <code>;gzip</code> postfix for previous response.
DRF-extensions decorator calculates ETag equals <code>123</code>, compares it with <code>123;gzip</code> and returns
response with status code 200, because <code>123</code> != <code>123;gzip</code></li>
</ul>

<p>You can solve this problem by stripping <code>;gzip</code> postfix on client side.</p>

<p>But there are so many libraries that just magically uses ETag response header without allowing to
pre-process conditional requests (for example, browser). If that's you case then you could add custom middleware which removes <code>;gzip</code>
postfix from header:</p>

<pre><code># yourapp/middleware.py

class RemoveEtagGzipPostfix(object):
    def process_response(self, request, response):
        if response.has_header('ETag') and response['ETag'][-6:] == ';gzip"':
            response['ETag'] = response['ETag'][:-6] + '"'
        return response
</code></pre>

<p>Don't forget to add this middleware in your settings before <code>GZipMiddleware</code>:</p>

<pre><code># settings.py
MIDDLEWARE_CLASSES = (
    ...
    'yourapp.RemoveEtagGzipPostfix',
    'django.middleware.gzip.GZipMiddleware',
    'django.middleware.common.CommonMiddleware',
    ...
)
</code></pre>

<h3 id="bulk-operations">Bulk operations</h3>

<p><em>New in DRF-extensions 0.2.4</em></p>

<p>Bulk operations allows you to perform operations over set of objects with one request. There is third-party package
<a href="django-rest-framework-bulk">django-rest-framework-bulk</a> with support for all CRUD methods, but it iterates over every
instance in bulk operation, serializes it and only after that executes operation.</p>

<p>It plays nice with <code>create</code> or <code>update</code>
operations, but becomes unacceptable with <code>partial update</code> and <code>delete</code> methods over the <code>QuerySet</code>. Such kind of
<code>QuerySet</code> could contain thousands of objects and should be performed as database query over the set at once.</p>

<p>Please note - DRF-extensions bulk operations applies over <code>QuerySet</code>, not over instances. It means that:</p>

<ul>
<li>No serializer's <code>save</code> or <code>delete</code> methods would be called</li>
<li>No viewset's <code>pre_save</code>, <code>post_save</code>, <code>pre_delete</code> and <code>post_delete</code> would be called</li>
<li>No model signals would be called</li>
</ul>

<h4 id="safety">Safety</h4>

<p>Bulk operations are very dangerous in case of making stupid mistakes. For example you wanted to delete user instance
with <code>DELETE</code> request from your client application.</p>

<pre><code># Request
DELETE /users/1/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 204 NO CONTENT
Content-Type: application/json; charset=UTF-8
</code></pre>

<p>That was example of successful deletion. But there is the common situation when client could not get instance id and sends
request to endpoint without it:</p>

<pre><code># Request
DELETE /users/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 204 NO CONTENT
Content-Type: application/json; charset=UTF-8
</code></pre>

<p>If you used <a href="#bulk-destroy">bulk destroy mixin</a> for <code>/users/</code> endpoint, then all your user objects would be deleted.</p>

<p>To protect from such confusions DRF-extensions asks you to send <code>X-BULK-OPERATION</code> header
for every bulk operation request. With this protection previous example would not delete any user instances:</p>

<pre><code># Request
DELETE /users/ HTTP/1.1
Accept: application/json

# Response
HTTP/1.1 400 BAD REQUEST
Content-Type: application/json; charset=UTF-8

{
  "detail": "Header 'X-BULK-OPERATION' should be provided for bulk operation."
}
</code></pre>

<p>With <code>X-BULK-OPERATION</code> header it works as expected - deletes all user instances:</p>

<pre><code># Request
DELETE /users/ HTTP/1.1
Accept: application/json
X-BULK-OPERATION: true

# Response
HTTP/1.1 204 NO CONTENT
Content-Type: application/json; charset=UTF-8
</code></pre>

<p>You can change bulk operation header name in settings:</p>

<pre><code>REST_FRAMEWORK_EXTENSIONS = {
    'DEFAULT_BULK_OPERATION_HEADER_NAME': 'X-CUSTOM-BULK-OPERATION'
}
</code></pre>

<p>To turn off protection you can set <code>DEFAULT_BULK_OPERATION_HEADER_NAME</code> as <code>None</code>.</p>

<h4 id="bulk-destroy">Bulk destroy</h4>

<p>This mixin allows you to delete many instances with one <code>DELETE</code> request.</p>

<pre><code>from rest_framework_extensions.mixins import ListDestroyModelMixin

class UserViewSet(ListDestroyModelMixin, viewsets.ModelViewSet):
    serializer_class = UserSerializer
</code></pre>

<p>Bulk destroy example - delete all users which emails ends with <code>gmail.com</code>:</p>

<pre><code># Request
DELETE /users/?email__endswith=gmail.com HTTP/1.1
Accept: application/json
X-BULK-OPERATION: true

# Response
HTTP/1.1 204 NO CONTENT
Content-Type: application/json; charset=UTF-8
</code></pre>

<h4 id="bulk-update">Bulk update</h4>

<p>This mixin allows you to update many instances with one <code>PATCH</code> request. Note, that this mixin works only with partial update.</p>

<pre><code>from rest_framework_extensions.mixins import ListUpdateModelMixin

class UserViewSet(ListUpdateModelMixin, viewsets.ModelViewSet):
    serializer_class = UserSerializer
</code></pre>

<p>Bulk partial update example - set <code>email_provider</code> of every user as <code>google</code>, if it's email ends with <code>gmail.com</code>:</p>

<pre><code># Request
PATCH /users/?email__endswith=gmail.com HTTP/1.1
Accept: application/json
X-BULK-OPERATION: true

{"email_provider": "google"}

# Response
HTTP/1.1 204 NO CONTENT
Content-Type: application/json; charset=UTF-8
</code></pre>

<h3 id="settings">Settings</h3>

<p>DRF-extesions follows Django Rest Framework approach in settings implementation.</p>

<p><a href="http://www.django-rest-framework.org/api-guide/settings">In Django Rest Framework</a> you specify custom settings by changing <code>REST_FRAMEWORK</code> variable in settings file:</p>

<pre><code>REST_FRAMEWORK = {
    'DEFAULT_RENDERER_CLASSES': (
        'rest_framework.renderers.YAMLRenderer',
    ),
    'DEFAULT_PARSER_CLASSES': (
        'rest_framework.parsers.YAMLParser',
    )
}
</code></pre>

<p>In DRF-extesions there is a magic variable too called <code>REST_FRAMEWORK_EXTENSIONS</code>:</p>

<pre><code>REST_FRAMEWORK_EXTENSIONS = {
    'DEFAULT_CACHE_RESPONSE_TIMEOUT': 60 * 15
}
</code></pre>

<h4 id="accessing-settings">Accessing settings</h4>

<p>If you need to access the values of DRF-exteinsions API settings in your project, you should use the <code>extensions_api_settings</code> object. For example:</p>

<pre><code>from rest_framework_extensions.settings import extensions_api_settings

print extensions_api_settings.DEFAULT_CACHE_RESPONSE_TIMEOUT
</code></pre>

<h3 id="release-notes">Release notes</h3>

<p>You can read about versioning, deprecation policy and upgrading from
<a href="http://django-rest-framework.org/topics/release-notes">Django REST framework documentation</a>.</p>

<h4 id="0-2-8">0.2.8</h4>

<p><em>Sep 21, 2015</em></p>



<h4 id="0-2-7">0.2.7</h4>

<p><em>Feb 2, 2015</em></p>



<h4 id="0-2-6">0.2.6</h4>

<p><em>Sep 9, 2014</em></p>



<h4 id="0-2-5">0.2.5</h4>

<p><em>July 9, 2014</em></p>



<h4 id="0-2-4">0.2.4</h4>

<p><em>July 7, 2014</em></p>



<h4 id="0-2-3">0.2.3</h4>

<p><em>Apr. 25, 2014</em></p>



<h4 id="0-2-2">0.2.2</h4>

<p><em>Mar. 23, 2014</em></p>



<h4 id="0-2-1">0.2.1</h4>

<p><em>Feb. 1, 2014</em></p>



<h4 id="0-2">0.2</h4>

<p><em>Nov. 5, 2013</em></p>

<ul>
<li>Moved docs from readme to github pages</li>
<li>Docs generation with <a href="https://github.com/chibisov/backdoc">Backdoc</a></li>
</ul>

    </div>
</div></body></html>