<html><body><div><div class="content">
            <section class="post">
                <header class="post-header">
                    
                    <h1>Using Flask Cache</h1>
                    
                    
                    <p class="post-meta">
                    

   <small class="breadcrumb">
      
          
          &gt; <span><a href="http://brunorocha.org/python/">python</a></span>
          
      
          
          &gt; <span><a href="http://brunorocha.org/python/flask/">flask</a></span>
          
      
   </small>


                    </p>
                    
                    <p class="post-meta">
                        // Tags 
                            <a class="post-category" href="http://brunorocha.org/tag/pythonplanet/">pythonplanet</a>
                        
                            <a class="post-category" href="http://brunorocha.org/tag/python/">python</a>
                        
                            <a class="post-category" href="http://brunorocha.org/tag/flask/">flask</a>
                        
                            <a class="post-category" href="http://brunorocha.org/tag/web/">web</a>
                        
                    </p>
                </header>

                 
                      
                 

            </section>

            <p>As a micro framework Flask does not have built-in cache functionality, however, there is <strong>werkzeug</strong> cache API and an excellent extension to provide its caching functionality to your Flask apps,
that extension was created by @thadeusb and is very easy to implement and use.</p>
<h3>installing</h3>
<p>In your env install it via PyPI (recommended)</p>
<pre><code>pip install Flask-Cache  
</code></pre>
<p>You can also install it directly from source code if you need recent changes or bugfixes</p>
<pre><code>pip install https://github.com/thadeusb/flask-cache/tarball/master
</code></pre>
<h3>Configuring</h3>
<p>There is a set of configuration keys you can put in your app settings, but the most important is the cache backend defined by the <strong>CACHE_TYPE</strong> key.</p>
<p>The cache type resolves to an import string which needs to be an object implementing the werkzeug cache api, but there is some aliases to the werkzeug.contrib.cache implementations</p>
<p>By default the CACHE_TYPE is Null which means that your app will have no cache, so you need to choose of the options below:</p>
<ul>
<li><strong>null</strong> | No Cache - NullCache</li>
<li><strong>simple</strong> | Will use in memory pickle and is recommended only for single process development server</li>
<li><strong>memcached</strong> | Requires pylibmc or memcached and requires memcached configuration in settings</li>
<li><strong>redis</strong> | Requires redis, werkzeug 0.7 and redis configuration in settings</li>
<li><strong>filesystem</strong> | The same as <strong>simple</strong> but stores the pickle in a cache_dir</li>
<li><strong>gaememcached</strong> | For Google AppEngine</li>
<li><strong>saslmemcached</strong> | The same as memcached but for SASL - pylibmc required </li>
</ul>
<hr/>
<p>Full options and config variables are in <a href="http://pythonhosted.org/Flask-Cache/#configuring-flask-cache">http://pythonhosted.org/Flask-Cache/#configuring-flask-cache</a></p>
<h3>A Simple Flask app</h3>
<p>a file named <code>app.py</code></p>
<pre><code>import time
from flask import Flask

app = Flask(__name__)

@app.route("/")
def view():
    return time.ctime()

if __name__ == "__main__":
    app.run(port=5000, debug=True, host='0.0.0.0')
</code></pre>
<p>Run the above with <code>python app.py</code> and open <a href="http://localhost:5000">http://localhost:5000</a> in your browser and hit F5 (refresh) to see the current date and time.</p>
<h3>Enabling Flask-Cache for views</h3>
<p>Now we want to enable caching on that small application to avoid the refresh of the current time (for this example we are using current time as return but imagine that it could be a large dataset or huge calculations)</p>
<p>a file named <code>cached_app.py</code></p>
<pre><code>import time
from flask import Flask

# import the flask extension
from flask.ext.cache import Cache   

app = Flask(__name__)

# define the cache config keys, remember that it can be done in a settings file
app.config['CACHE_TYPE'] = 'simple'

# register the cache instance and binds it on to your app 
app.cache = Cache(app)   

@app.route("/")
@app.cache.cached(timeout=300)  # cache this view for 5 minutes
def cached_view():
    return time.ctime()

if __name__ == "__main__":
    app.run(port=5000, debug=True, host='0.0.0.0')
</code></pre>
<p>Run the above with <code>python cached_app.py</code> and open <a href="http://localhost:5000">http://localhost:5000</a> in your browser and hit F5 (refresh) to see that the current date and time is now cached for 5 minutes.</p>
<p><strong>@cache.cached</strong> decorator takes the request.path for that view and use this as cache key, if for any reason you need a different key you can pass a <strong>key_prefix</strong> argument to the decorator. In this case if you pass a key_prefix containing the <strong>%s</strong> placeholder it will be replaced by the current request.path</p>
<p>The above is the simplest and regular example of Flask app and the use of cache, but, if your app is designed using application factories, blueprints, class based views or views located in different modules you will need to use advanced approach.</p>
<h3>Caching regular functions</h3>
<p>The same <strong>cached</strong> decorator can be used to cache regular functions, but in this case you will need to specify the <strong>key_prefix</strong> argument, otherwise it will use the request.path which can lead to conflicts if you have many cached functions.</p>
<p>For this example we are going to use the <code>this</code> module and extract a random quote from the Zen of Python.</p>
<p>A file named <code>cached_function_app.py</code></p>
<pre><code>import time
import random

from this import s, d
from string import translate, maketrans

from flask.ext.cache import Cache
from flask import Flask

app = Flask(__name__)
app.config['CACHE_TYPE'] = 'simple'
app.cache = Cache(app)

@app.cache.cached(timeout=10, key_prefix="current_time")
def get_current_time():
    return time.ctime()

def random_zen_quote():
    """Pick a random quote from the Zen of Python""" 
    transtable = maketrans("".join(d.keys()), "".join(d.values()))
    return random.choice(translate(s, transtable).split("\n")[2:])

@app.route("/")
def zen():
    return """
    &lt;ul&gt;
        &lt;li&gt;&lt;strong&gt;It is cached:&lt;/strong&gt; {cached}&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;It is not cached:&lt;/strong&gt; {not_cached}&lt;/li&gt;
    &lt;/ul&gt;
    """.format(
        cached=get_current_time(),
        not_cached=random_zen_quote()
    )

if __name__ == "__main__":
    app.run(debug=True, port=5000, host='0.0.0.0')
</code></pre>
<p>Now running <code>python cached_function_app.py</code> and opening <a href="http://localhost:5000">http://localhost:5000</a> when hitting F5 to refresh you will see the current time cached for 5 minutes and the random quote updated, you can switch the cache just to see the efect.</p>
<pre><code>def get_current_time():
    return time.ctime()

@app.cache.cached(timeout=10, key_prefix="zen_quote")
def random_zen_quote():
    transtable = maketrans("".join(d.keys()), "".join(d.values()))
    return random.choice(translate(s, transtable).split("\n")[2:])

@app.route("/")
def zen():
    return """
    &lt;ul&gt;
        &lt;li&gt;&lt;strong&gt;It is not cached:&lt;/strong&gt; {cached}&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;It is cached:&lt;/strong&gt; {not_cached}&lt;/li&gt;
    &lt;/ul&gt;
    """.format(
        cached=get_current_time(),
        not_cached=random_zen_quote()
    )
</code></pre>
<blockquote><p>NOTE: Because we are importing the <code>this</code> module for the example, you will see the Zen quotes in your flask terminal, but there is no problem with this.</p>
</blockquote>
<h3>Caching modular views</h3>
<p>Now an example when you have your app splitted in two or more files for better organization</p>
<p>in a folder called <code>app</code> put 3 files<code>__init__.py</code>, <code>app.py</code> and <code>views.py</code></p>
<p><code>app/__init__.py</code> is an empty file</p>
<p><code>app/views.py</code></p>
<pre><code>import time
import random
from this import s, d
from string import translate, maketrans

def get_current_time():
    return time.ctime()

def random_zen_quote():
    transtable = maketrans("".join(d.keys()), "".join(d.values()))
    return random.choice(translate(s, transtable).split("\n")[2:])

def zen_view():
    return """
    &lt;h1&gt;Cached for 10 seconds!&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;{time}&lt;/li&gt;
        &lt;li&gt;{quote}&lt;/li&gt;
    &lt;/ul&gt;
    """.format(
        time=get_current_time(),
        quote=random_zen_quote()
    )
</code></pre>
<p>as you can see the above file defined view functions, as it it a separated file, to avoid circular imports we are not recommended to use <strong>@app.route</strong> neither <strong>@app.cache</strong> so this views will be <strong>app agnostic</strong> and we are going to register its url rules and caching in the main app file.</p>
<p>That kind of structure is needed when your app has too many views and want a better organization.</p>
<blockquote><p>NOTE: For better organization the mostly recommended pattern is Blueprints which I will explain further.</p>
</blockquote>
<p><code>app/app.py</code></p>
<p>Now in the main app we need to import our views, explicitly decorate for caching and also register its urls.</p>
<pre><code>from flask import Flask
from flask.ext.cache import Cache
from views import zen_view

app = Flask(__name__)
app.config['CACHE_TYPE'] = 'simple'
app.cache = Cache(app)

# explicitly apply the cache in the old-style decoration way
cached_zen_view = app.cache.cached(timeout=10)(zen_view)

# explicitly register the cached view url mapping
app.add_url_rule("/", view_func=cached_zen_view)

if __name__ == "__main__":
    app.run(debug=True, port=5000, host='0.0.0.0')
</code></pre>
<blockquote><p>NOTE: You can also separate the <strong>cache</strong> instance in a different file for lazy initialization as we are going to see in the next example</p>
</blockquote>
<h3>Caching Blueprint views</h3>
<p>As mentioned before, the best pattern to follow in Flask applications is the Blueprint pattern which is a way to create separated 'meta-apps' that will be connected to your main application in the time of initialization, the problem here is that Blueprints are meant to be reusable by many different applications, so the delegation of <strong>cache</strong> control should be dynamized.</p>
<p>In order to avoid circular imports you will want to create your cache instance separate from your application instance (you may want to consider switching to the app factory module if you are building something more complex).</p>
<p>Create a folder called <code>blueprint_app</code> with the following structure</p>
<pre><code>cached_blueprint_app/
├── app.py
├── cache.py
├── blueprints
│   ├── __init__.py
│   └── zen_blueprint.py
└── __init__.py
</code></pre>
<p>The <code>cache.py</code></p>
<pre><code>from flask.ext.cache import Cache    
cache = Cache()
</code></pre>
<p>we can create a <strong>dummy</strong> lazy cache instance, that will be initialized in the future when the view will be called. For that in the app we are going to reimport the same cache instance and call <code>init_app</code> method.</p>
<p>The basic <code>blueprints/zen_blueprint.py</code></p>
<pre><code>import time
import random
from this import s, d
from string import translate, maketrans
from flask import Blueprint
from cache import cache

zen = Blueprint('zen', __name__)

def get_current_time():
    return time.ctime()

def random_zen_quote():
    transtable = maketrans("".join(d.keys()), "".join(d.values()))
    return random.choice(translate(s, transtable).split("\n")[2:])

@zen.route("/")
@cache.cached(timeout=20)
def zen_view():
    return """
    &lt;h1&gt;Cached for 20 seconds!&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;{time}&lt;/li&gt;
        &lt;li&gt;{quote}&lt;/li&gt;
    &lt;/ul&gt;
    """.format(
        time=get_current_time(),
        quote=random_zen_quote()
    )
</code></pre>
<blockquote><p>NOTE: In a real application you will want to modularize it separating the views, helpers etc and promoting your blueprint to a Python package.</p>
</blockquote>
<p>The main <code>app.py</code></p>
<pre><code>from flask import Flask

from blueprints.zen_blueprint import zen
from cache import cache

app = Flask(__name__)
app.config['CACHE_TYPE'] = 'simple'
cache.init_app(app)

app.register_blueprint(zen)

if __name__ == "__main__":
    app.run(debug=True, port=5000, host='0.0.0.0')
</code></pre>
<p>Notice that we created a dummy instance of cache in <code>cache.py</code> and then used that instance to decorate the blueprints views, then the cache was initialized in <code>app.py</code> with <code>init_app</code> method. That is possible because of the Flask initialization cycle and the excellent implementation in <strong>Flask-Cache</strong> extension that takes care of this case, if you plan to write yor own Flask extension take a look at the Flask-Cache source code.</p>
<p>Run the application by calling <code>python cached_blueprint_app/app.py</code> and open <a href="http://localhost:5000">http://localhost:5000</a> to see the blueprint view cached for 20 seconds.</p>
<h3>Caching MethodView</h3>
<p>Lets use the same <code>cached_blueprint_app</code> example but turning the <code>zen_view</code> in to a <strong>MethodView</strong></p>
<p>Change your <code>zen_blueprint.py</code> to:</p>
<pre><code>import time
import random
from this import s, d
from string import translate, maketrans
from flask import Blueprint
from flask.views import MethodView
from cache import cache

zen = Blueprint('zen', __name__)

class ZenView(MethodView):

    @cache.cached(30)
    def get(self):
        return """
        &lt;h1&gt;Cached for 30 seconds!&lt;/h1&gt;
        &lt;ul&gt;
            &lt;li&gt;{time}&lt;/li&gt;
            &lt;li&gt;{quote}&lt;/li&gt;
        &lt;/ul&gt;
        """.format(
            time=self.get_current_time(),
            quote=self.random_zen_quote()
        )

    @staticmethod
    def get_current_time():
        return time.ctime()

    @staticmethod
    def random_zen_quote():
        transtable = maketrans("".join(d.keys()), "".join(d.values()))
        return random.choice(translate(s, transtable).split("\n")[2:])


zen.add_url_rule("/", view_func=ZenView.as_view('zen'))
</code></pre>
<p>Method views maps HTTP method names as GET, POST, DELETE to the view methos as get, post, delete etc, So all we needed to do is to create a method called <code>get</code> and decorate it with <code>@cache.cached</code> decorator.</p>
<blockquote><p>NOTE: Due to the implicit self from the caller’s perspective you cannot use regular view decorators on the individual methods of the view however, Flask-Cache is one exception because its implementation allow the use of cached decorator in individual methods. Keep this in mind.</p>
</blockquote>
<p>Alternativelly you may want to cache all the methods in a view, for that you can cache the <strong>dispatch_request</strong> method or even better you can decorate the whole view.</p>
<h5>Caching the dispatcher</h5>
<pre><code>class ZenView(MethodView):
    @cache.cached(timeout=30)
    def dispatch_request(self):
        return super(ZenView, self).dispatch_request()

    ...
</code></pre>
<h5>Caching the whole view (recommended)</h5>
<pre><code>zen = Blueprint('zen', __name__)

class ZenView(MethodView):
    ...

cached_zen_view = cache.cached(timeout=50)(ZenView.as_view('zen'))
zen.add_url_rule("/", view_func=cached_zen_view)
</code></pre>
<h3>Caching template blocks</h3>
<p>Flask cache comes with a template tag able to cache template blocks, lets change our <code>ZenView</code> to use a Jinja2 template</p>
<p>in <code>zen_blueprint.py</code></p>
<pre><code>import time
import random
from this import s, d
from string import translate, maketrans
from flask import Blueprint, render_template
from flask.views import MethodView

zen = Blueprint('zen', __name__)

class ZenView(MethodView):

    def get(self):
        return render_template(
            'zen.html',
            get_random_quote=self.random_zen_quote
        )

    @staticmethod
    def get_current_time():
        return time.ctime()

    @staticmethod
    def random_zen_quote():
        transtable = maketrans("".join(d.keys()), "".join(d.values()))
        return random.choice(translate(s, transtable).split("\n")[2:])

zen.add_url_rule("/", view_func=ZenView.as_view('zen'))
</code></pre>
<p>Now we need to create a template file in <code>cached_blueprint_app/templates/zen.html</code></p>
<pre><code>&lt;h3&gt; Random Zen of Python &lt;/h3&gt;
&lt;strong&gt;{{get_random_quote()}}&lt;/strong&gt;
</code></pre>
<p>Running the application with <code>python cached_blueprint_app/app.py</code> and opening <a href="http://localhost:5000">http://localhost:5000</a> you will see a random quote refreshed every time you push F5, lets cache it for 30 second.</p>
<p>Change the <code>zen.html</code> template</p>
<pre><code>{% cache 30 %}
&lt;h3&gt; Random Zen of Python &lt;/h3&gt;
&lt;strong&gt;{{get_random_quote()}}&lt;/strong&gt;
{% endcache %}
</code></pre>
<p>Now save the file and refresh to see the content cached for 30 seconds.</p>
<h3>Caching functions and views with variant arguments using memoize decorator</h3>
<p>Sometimes yout views and functions receives arguments which can come from url mapping or directly to the function call, yiou may want to cache the view or funtion and use the arguments as keys to cache its different results, Flask-Cache has a different decorator for doing that.</p>
<blockquote><p>NOTE: With functions that do not receive arguments, cached() and memoize() are effectively the same.</p>
</blockquote>
<p>Now with a simple application <code>memoize_app.py</code></p>
<pre><code>import time
from flask.ext.cache import Cache
from flask import Flask

app = Flask(__name__)
app.config['CACHE_TYPE'] = 'simple'
app.cache = Cache(app)

@app.cache.memoize(timeout=5)
def get_current_time_and_name(name):
    return "%s - %s" % (name, time.ctime())

@app.route("/&lt;name&gt;")
def view(name):
    return get_current_time_and_name(name)

if __name__ == "__main__":
    app.run(debug=True, port=5000, host='0.0.0.0')
</code></pre>
<p>Now run <code>python memoize_app.py</code> and open <a href="http://localhost:5000/yourname">http://localhost:5000/yourname</a> and note that the function will be cached for each different name you pass as argument in the url.</p>
<h3>Caching arbitrary objects</h3>
<p>There are some times when decorators cannot be used and you need to explicitly set or get some thing on the cache.</p>
<p>Inside a view or a blueprint you can use current_app</p>
<pre><code>from flask import current_app

def some_function():
    cached = current_app.cache.get('a_key')
    if cached:
        return cached
    result = do_some_stuff()
    current_app.cache.set('a_key', result, timeout=300)
    return result
</code></pre>
<p>Or if using a separete cache instance you can do this directly</p>
<pre><code>from cache import cache

def function():
    cached = cache.get('a_key')
    if cached:
        return cached
    result = do_some_stuff()
    cache.set('a_key', result, timeout=300)
    return result
</code></pre>
<h3>Clearing the cache</h3>
<p>You can create a script to clear the cache, or a function to use it when needed</p>
<pre><code>from flask.ext.cache import Cache    
from yourapp import app
cache = Cache()

def main():
    cache.init_app(app)

    with app.app_context():
        cache.clear()

if __name__ == '__main__':
    main()
</code></pre>
<blockquote><p>WARNING: Some backend implementation do not support completely clearing the case. Also, if you’re not using key prefix, some implementation (e.g. Redis) will flush the whole database. Make sure you’re not storing any other data in your caching database.</p>
</blockquote>
<p>There is a lot of examples and well documented API in flask-Cache website <a href="http://pythonhosted.org/Flask-Cache/">http://pythonhosted.org/Flask-Cache/</a> you can also create your own cache backend following the examples in the Flask-Cache <a href="http://pythonhosted.org/Flask-Cache/#custom-cache-backends">docs</a>.</p>


            
                


            

            
                




            

            
                

 
   
      
        
     
 


            

            
                
    
            <hr/>
            <p class="post-meta">
                // Comment
            </p>
        
           
                   <p id="disqus_thread"/>
    
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
           
        
    

            

            
               <a href="http://brunorocha.org/" class="go-top">Go Top</a>
               <footer class="footer">
    <p>
        <span>Powered by <a href="http://www.quokkaproject.org">Quokka CMS</a></span>
        © BrunoRocha.org | Python web development –
        Based in <a href="https://github.com/PurePelicanTheme/pure">Pure Theme</a> – 
        Access the <a href="http://brunorocha.org/admin">Admin</a> interface
    </p>
</footer>
            
        </div>
    </div></body></html>