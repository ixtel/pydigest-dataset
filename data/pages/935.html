<html><body><div><article class="post-content">
    <p>At its core, this article is about a simple cheat sheet for basic
operations on numeric matrices, which can be very useful if you working
and experimenting with some of the most popular languages that are used
for scientific computing, statistics, and data analysis.</p>

<h2 id="sections">Sections</h2>



<h2 id="introduction">Introduction</h2>

<p>Matrices (or multidimensional arrays) are not only presenting the
fundamental elements of many algebraic equations that are used in many
popular fields, such as pattern classification, machine learning, data
mining, and math and engineering in general. But in context of
scientific computing, they also come in very handy for managing and
storing data in an more organized tabular form.<br/>
Such multidimensional data structures are also very powerful
performance-wise thanks to the concept of automatic vectorization:
instead of the individual and sequential processing of operations on
scalars in loop-structures, the whole computation can be parallelized in
order to make optimal use of modern computer architectures.</p>

<p><img src="/images/blog/2014/numeric-matrix/matcheat_matrix.png" alt="R matrix"/></p>

<h3 id="language-overview">Language overview</h3>

<p>Before we <strong><a href="#cheatsheet">jump to the actual cheat sheet</a></strong>, I wanted to
give you at least a brief overview of the different languages that we
are dealing with.</p>

<p>All four languages, MATLAB/Octave, Python, R, and Julia are dynamically
typed, have a command line interface for the interpreter, and come with
great number of additional and useful libraries to support scientific
and technical computing. Conveniently, these languages also offer great
solutions for easy plotting and visualizations.</p>

<p>Combined with interactive notebook interfaces or dynamic report
generation engines
(<a href="http://www.mathworks.com/discovery/mupad.html">MuPAD</a> for MATLAB,
<a href="http://ipython.org/notebook.html">IPython Notebook</a> for Python,
<a href="http://yihui.name/knitr/">knitr</a> for R, and
<a href="https://github.com/JuliaLang/IJulia.jl">IJulia</a> for Julia based on
IPython Notebook) data analysis and documentation has never been easier.</p>

<h1 id="matlaboctave">MATLAB/Octave</h1>

<p><a href="http://www.mathworks.com/products/matlab/"><img src="/images/blog/2014/numeric-matrix/matcheat_matlab_logo.png" alt="matlab&#10;logo"/></a></p>

<p><a href="http://www.mathworks.com/products/matlab/">MATLAB</a> (stands for MATrix
LABoratory) is the name of an application and language that was
developed by
<a href="http://www.mathworks.com/index.html?s_tid=gn_logo">MathWorks</a> back in
1984. One of its strengths is the variety of different and highly
optimized “toolboxes” (including very powerful functions for image and
other signal processing task), which makes suitable for tackling
basically every possible science and engineering task.\
 Like the other languages, which will be covered in this article, it has
cross-platform support and is using dynamic types, which allows for a
convenient interface, but can also be quite “memory hungry” for
computations on large data sets.</p>

<p>Even today, MATLAB is probably (still) the most popular language for
numeric computation used for engineering tasks in academia as well as in
industry.</p>

<h4 id="gnu-octave">GNU Octave</h4>

<p><a href="http://www.gnu.org/software/octave/"><img src="/images/blog/2014/numeric-matrix/matcheat_octave_logo.png" alt="matlab&#10;logo"/></a></p>

<p>It is also worth mentioning that MATLAB is the only language in this
cheat sheet which is not free and open-sourced. But since it is so
immensely popular, I want to mention it nonetheless. And as an
alternative there is also the free <a href="http://www.gnu.org/software/octave/">GNU Octave
re-implementation</a> that follows the
same syntactic rules so that the code is compatible to MATLAB (except
for very specialized libraries).</p>

<blockquote>
  <p>This <a href="http://commons.wikimedia.org/wiki/File:Matlab_Logo.png">image</a>
is a freely usable media under public domain and represents the first
eigenfunction of the L-shaped membrane, resembling (but not identical
to) MATLAB’s logo trademarked by MathWorks Inc.</p>
</blockquote>

<h1 id="python-numpy">Python NumPy</h1>

<p><img src="/images/blog/2014/numeric-matrix/matcheat_numpy_logo.png" alt="python&#10;logo"/></p>

<p>Initially, the <a href="http://www.numpy.org">NumPy</a> project started out under
the name “Numeric” in 1995 (renamed to NumPy in 2006) as a Python
library for numeric computations based on multi-dimensional data
structures, such as arrays and matrices. Since it makes use of
pre-compiled C code for operations on its “<code class="highlighter-rouge">ndarray</code>” objects, it is
considerably faster than using equivalent approaches in (C)Python.</p>

<p>Python NumPy is my personal favorite since I am a big fan of the Python
programming language. Although similar tools exist for other languages,
I found myself to be most productive doing my research and data analyses
in <a href="http://ipython.org/notebook.html">IPython notebooks</a>.<br/>
 It allows me to easily combine Python code (sometimes optimized by
compiling it via the <a href="http://cython.org">Cython</a> C-Extension or the
just-in-time (JIT) <a href="http://numba.pydata.org">Numba</a> compiler if speed is
a concern) with different libraries from the <a href="http://www.scipy.org/">Scipy
stack</a> including
<a href="http://matplotlib.org">matplotlib</a> for inline data visualization (you
can find some of my example benchmarks in this <a href="http://github.com/rasbt/One-Python-benchmark-per-day">GitHub
repository</a>).</p>

<h1 id="r">R</h1>

<p><img src="/images/blog/2014/numeric-matrix/matcheat_R_logo.png" alt="R&#10;logo"/></p>

<p>The <a href="http://www.r-project.org">R</a> programming language was developed in
1993 and is a modern GNU implementation of an older statistical
programming language called <a href="http://stat.bell-labs.com/S/">S</a>, which was
developed in the <a href="http://stat.bell-labs.com">Bell Laboratories</a> in 1976.
Since its release, it has a fast-growing user base and is particularly
popular among statisticians.</p>

<p>R was also the first language which kindled my fascination for
statistics and computing. I have used it quite extensively a couple of
years ago before I discovered Python as my new favorite language for
data analysis.<br/>
Although R has great in-built functions for performing all sorts
statistics, as well as a plethora of freely available libraries
developed by the large R community, I often hear people complaining
about its rather unintuitive syntax.</p>

<h1 id="julia">Julia</h1>

<p><img src="/images/blog/2014/numeric-matrix/matcheat_julia_logo.png" alt="python&#10;logo"/></p>

<p>With its first release in 2012, <a href="http://julialang.org">Julia</a> is by far
the youngest of the programming languages mentioned in this article. a
While Julia can also be used as an interpreted language with dynamic
types from the command line, it aims for high-performance in scientific
computing that is superior to the other dynamic programming languages
for technical computing thanks to its LLVM-based just-in-time (JIT)
compiler.</p>

<p>Personally, I haven’t used Julia that extensively, yet, but there are
some exciting benchmarks that look very promising:</p>

<p><a href="http://julialang.org/benchmarks/"><img src="/images/blog/2014/numeric-matrix/matcheat_julia_benchmark.png" alt="Julia&#10;benchmark"/></a></p>

<blockquote>
  <p>C compiled by gcc 4.8.1, taking best timing from all optimization levels
(-O0 through -O3). C, Fortran and Julia use OpenBLAS v0.2.8. The Python
implementations of rand_mat_stat and rand_mat_mul use NumPy (v1.6.1)
functions; the rest are pure Python implementations.</p>
</blockquote>

<blockquote>
  <p>Bezanson, J., Karpinski, S., Shah, V.B. and Edelman, A. (2012), “Julia:
A fast dynamic language for technical computing”.<br/>
 (Source: <a href="http://julialang.org/benchmarks/">http://julialang.org/benchmarks/</a>, with permission from the
copyright holder)</p>
</blockquote>

<h1 id="cheat-sheet">Cheat sheet</h1>

<p><a href="/blog/2014/matrix_cheatsheet_table.html"><img src="/images/blog/2014/numeric-matrix/matrix_cheatsheet.png" alt=""/></a></p>

<h3 id="alternative-data-structures-numpy-matrices-vs-numpy-arrays">Alternative data structures: NumPy matrices vs. NumPy arrays</h3>

<p>Python’s NumPy library also has a dedicated “matrix” type with a syntax
that is a little bit closer to the MATLAB matrix: For example, the
“<code class="highlighter-rouge">  *  </code>” operator would perform a matrix-matrix multiplication of NumPy
matrices - same operator performs element-wise multiplication on NumPy
arrays.</p>

<p>Vice versa, the “<code class="highlighter-rouge">.dot()</code>” method is used for element-wise
multiplication of NumPy matrices, wheras the equivalent operation would
for NumPy arrays would be achieved via the “<code class="highlighter-rouge">  *  </code>“-operator.</p>

<p><strong>Most people recommend the usage of the NumPy array type over NumPy
matrices, since arrays are what most of the NumPy functions return.</strong></p>

  </article>


</div></body></html>