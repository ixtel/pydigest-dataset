<html><body><div><body id="readabilityBody">
   <h1>[Python-Dev] Status of PEP 484 and the typing module</h1>
    <b>Guido van Rossum</b> 
    <a href="mailto:python-dev%40python.org?Subject=Re%3A%20%5BPython-Dev%5D%20Status%20of%20PEP%20484%20and%20the%20typing%20module&amp;In-Reply-To=%3CCAP7%2BvJ%2BqtRF4kngnHQEh-C%2BBVaS6cxPk2kifRaB03NA-NiC3sQ%40mail.gmail.com%3E" title="[Python-Dev] Status of PEP 484 and the typing module">guido at python.org
       </a><br/>
    <i>Thu May 21 17:01:01 CEST 2015</i>
    <p/>
    <hr/>  

<pre>Hi Mark,

We're down to the last few items here. I'm CC'ing python-dev so folks can
see how close we are. I'll answer point by point.

On Thu, May 21, 2015 at 6:24 AM, Mark Shannon &lt;<a href="https://mail.python.org/mailman/listinfo/python-dev">mark at hotpy.org</a>&gt; wrote:

&gt;<i> Hi,
</i>&gt;<i>
</i>&gt;<i> The PEP itself is looking fairly good.
</i>&gt;<i>
</i>
I hope you'll accept it at least provisionally so we can iterate over the
finer points while a prototype of typing.py in in beta 1.


&gt;<i> However, I don't think that typing.py is ready yet, for a number of
</i>&gt;<i> reasons:
</i>&gt;<i>
</i>&gt;<i> 1.
</i>&gt;<i> As I've said before, there needs to be a distinction between classes and
</i>&gt;<i> types.
</i>&gt;<i> They is no need for Any, Generic, Generic's subtypes, or Union to subclass
</i>&gt;<i> builtins.type.
</i>&gt;<i>
</i>
I strongly disagree. They can appear in many positions where real classes
are acceptable, in particular annotations can have classes (e.g. int) or
types (e.g. Union[int, str]).


&gt;<i> Playing around with typing.py, it has also become clear to me that it
</i>&gt;<i> is also important to distinguish type constructors from types.
</i>&gt;<i>
</i>&gt;<i> What do I mean by a type constructor?
</i>&gt;<i> A type constructor makes types.
</i>&gt;<i> "List" is an example of a type constructor. It constructs types such as
</i>&gt;<i> List[T] and List[int].
</i>&gt;<i> Saying that something is a List (as opposed to a list) should be rejected.
</i>&gt;<i>
</i>
The PEP actually says that plain List (etc.) is equivalent to List[Any].
(Well, at least that's the intention; it's implied by the section about the
equivalence between Node() and Node[Any]().


&gt;<i> 2.
</i>&gt;<i> Usability of typing as it stands:
</i>&gt;<i>
</i>&gt;<i> Let's try to make a class that implements a mutable mapping.
</i>&gt;<i>
</i>&gt;<i> &gt;&gt;&gt; import typing as tp
</i>&gt;<i> #Make some variables.
</i>&gt;<i> &gt;&gt;&gt; T = tp.TypeVar('T')
</i>&gt;<i> &gt;&gt;&gt; K = tp.TypeVar('K')
</i>&gt;<i> &gt;&gt;&gt; V = tp.TypeVar('V')
</i>&gt;<i>
</i>&gt;<i> #Then make our class:
</i>&gt;<i>
</i>&gt;<i> &gt;&gt;&gt; class MM(tp.MutableMapping): pass
</i>&gt;<i> ...
</i>&gt;<i> #Oh that worked, but it shouldn't. MutableMapping is a type constructor.
</i>&gt;<i>
</i>
It means MutableMapping[Any].


&gt;<i> #Let's make one
</i>&gt;<i> &gt;&gt;&gt; MM()
</i>&gt;<i> Traceback (most recent call last):
</i>&gt;<i>   File "&lt;stdin&gt;", line 1, in &lt;module&gt;
</i>&gt;<i>   File "/home/mark/repositories/typehinting/prototyping/typing.py", line
</i>&gt;<i> 1095, in __new__
</i>&gt;<i>     if _gorg(c) is Generic:
</i>&gt;<i>   File "/home/mark/repositories/typehinting/prototyping/typing.py", line
</i>&gt;<i> 887, in _gorg
</i>&gt;<i>     while a.__origin__ is not None:
</i>&gt;<i> AttributeError: type object 'Sized' has no attribute '__origin__'
</i>&gt;<i>
</i>&gt;<i> # ???
</i>&gt;<i>
</i>
Sorry, that's a bug I introduced in literally the last change to typing.py.
I will fix it. The expected behavior is

TypeError: Can't instantiate abstract class MM with abstract methods __len__



&gt;<i> #Well let's try using type variables.
</i>&gt;<i> class MM2(tp.MutableMapping[K, V]): pass
</i>&gt;<i> ...
</i>&gt;<i> &gt;&gt;&gt; MM2()
</i>&gt;<i> Traceback (most recent call last):
</i>&gt;<i>   File "&lt;stdin&gt;", line 1, in &lt;module&gt;
</i>&gt;<i>   File "/home/mark/repositories/typehinting/prototyping/typing.py", line
</i>&gt;<i> 1095, in __new__
</i>&gt;<i>     if _gorg(c) is Generic:
</i>&gt;<i>   File "/home/mark/repositories/typehinting/prototyping/typing.py", line
</i>&gt;<i> 887, in _gorg
</i>&gt;<i>     while a.__origin__ is not None:
</i>&gt;<i> AttributeError: type object 'Sized' has no attribute '__origin__'
</i>&gt;<i>
</i>
Ditto, and sorry.

&gt;<i>
</i>&gt;<i> At this point, we have to resort to using 'Dict', which forces us to
</i>&gt;<i> subclass 'dict' which may not be what we want as it may cause metaclass
</i>&gt;<i> conflicts.
</i>&gt;<i>
</i>&gt;<i> 3.
</i>&gt;<i> Memory consumption is also a worry. There is no caching, which means every
</i>&gt;<i> time I use "List[int]" as an annotation, a new class object is created.
</i>&gt;<i> Each class may only be a few KB, but collectively this could easily add up
</i>&gt;<i> to several MBs.
</i>&gt;<i> This should be easy to fix.
</i>&gt;<i>
</i>
I can work on this after the beta-1 release. Until then, type aliases can
be used to avoid redundant type creation (and often they are clearer anyway
:<i>-).
</i>

&gt;<i> 4.
</i>&gt;<i> PY2, etc. really need to go.
</i>&gt;<i> Assuming that this code type checks OK:
</i>&gt;<i>
</i>&gt;<i>  if typing.PY2:
</i>&gt;<i>      type_safe_under_py2_only()
</i>&gt;<i>  else:
</i>&gt;<i>      type_safe_under_py3_only()
</i>&gt;<i>
</i>&gt;<i> Is the checker supposed to pass this:
</i>&gt;<i>
</i>&gt;<i>  if sys.hexversion &lt; 0x03000000:
</i>&gt;<i>      type_safe_under_py2_only()
</i>&gt;<i>  else:
</i>&gt;<i>      type_safe_under_py3_only()
</i>&gt;<i>
</i>&gt;<i> If it should pass, then why have PY2, etc. at all.
</i>&gt;<i> If it should fail, well that is just stupid and annoying.
</i>&gt;<i>
</i>&gt;<i> Pylint already understands version checks, as does our (Semmle's) checker.
</i>&gt;<i> I suspect most IDEs do as well.
</i>&gt;<i>
</i>
I have to negotiate this with Jukka but I think he'll agree.


&gt;<i> 5.
</i>&gt;<i> Removing isinstance() support:
</i>&gt;<i>
</i>&gt;<i> As I said before, this is the job of a checker not typing.py.
</i>&gt;<i>
</i>&gt;<i> It also introduces some strange situations:
</i>&gt;<i> D = tp.Dict[str,int]
</i>&gt;<i> d = {}
</i>&gt;<i> assert isinstance(d, D)
</i>&gt;<i> d["x"] = None
</i>&gt;<i> assert isinstance(d, D)
</i>&gt;<i>
</i>&gt;<i> In the above case the first check passes, and the second fails.
</i>&gt;<i> But d is either of type D or it isn't. It can't be both, as types
</i>&gt;<i> are static properties of programs, unlike classes.
</i>&gt;<i>
</i>
Well, isinstance() is a dynamic function. The type checker has no authority
over its behavior beyond its signature.


&gt;<i> And it's broken anyway:
</i>&gt;<i> &gt;&gt;&gt; D = tp.Dict[str,'D']
</i>&gt;<i> &gt;&gt;&gt; d = {"x": {}}
</i>&gt;<i> &gt;&gt;&gt; isinstance(d, D)
</i>&gt;<i> False
</i>&gt;<i>
</i>
That's because _ForwardRef doesn't implement __instancheck__ or
__subclasscheck__. It's easily fixed.

&gt;<i>
</i>&gt;<i> Realistically, I don't see typing.py being ready in time for 3.5.
</i>&gt;<i> I'd be happy to be proved wrong.
</i>&gt;<i>
</i>&gt;<i> Cheers,
</i>&gt;<i> Mark.
</i>&gt;<i>
</i>&gt;<i>
</i>&gt;<i> P.S.
</i>&gt;<i> I am worried by the lack of formal specification. It all seems a bit
</i>&gt;<i> hand-waving. A formal spec reduces the likelihood of some unforeseen corner
</i>&gt;<i> case being a permanent wart.
</i>&gt;<i>
</i>
Formal specs are not my cup of tea. :-( (I'm not proud of this, but it just
is a fact -- see how terrible a job I've done of the Python reference
manual.) The best I could come up with is PEP 483.


&gt;<i> Take the recursive type above. There is no mention of recursive types in
</i>&gt;<i> the PEP and they are clearly possible. Are they allowed?
</i>&gt;<i>
</i>
They should be allowed. I imagine you could create one for which a naive
isinstance() imeplementation ends up in an infinite loop. That can be fixed
too (we fixed this for printing self-referential lists and dicts).


&gt;<i> I'm guessing that Jukka's thesis should cover a lot of this.
</i>&gt;<i> Has it been published yet?
</i>&gt;<i>
</i>
Hopefully Jukka can answer that. :-)

-- 
--Guido van Rossum (python.org/~guido)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<a href="http://mail.python.org/pipermail/python-dev/attachments/20150521/409b5458/attachment.html">http://mail.python.org/pipermail/python-dev/attachments/20150521/409b5458/attachment.html</a>&gt;
</pre>





























    <hr/>
    <p/>

<hr/>
<a href="https://mail.python.org/mailman/listinfo/python-dev">More information about the Python-Dev
mailing list</a><br/>
</body></div></body></html>