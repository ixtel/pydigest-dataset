<html><body><div><div class="content">
      
        <h1 class="content-title">Saturday morning hack: personalized news digest with boolean query parser</h1>
      
      
      
  
  
  
    <p><a href="http://media.charlesleifer.com/blog/photos/coffee-cup-scaled.jpg" title="Saturday morning hacks"><img alt="Saturday morning hacks" class="img-responsive" src="http://m.charlesleifer.com/t/800x-/blog/photos/coffee-cup-scaled.jpg?key=xFJansgcRXa5MCBauZSUhQ"/></a></p>
<p>Because I had so much fun writing my last <a href="/blog/saturday-morning-hack-a-little-note-taking-app-with-flask/">Saturday morning hack</a>, I thought I would share another little hack. I was thinking that I really enjoy my subscription to <a href="http://www.pythonweekly.com/">Python weekly</a> and wouldn't it be great if I had a personal email digest containing just the types of things that interest me? I regularly cruise <a href="http://reddit.com/r/programming">reddit</a> and <a href="http://news.ycombinator.com"><strike>hacker</strike> hater news</a> but in my opinion there's a pretty low signal-to-noise ratio. Occasionally I stumble on fascinating content and that's what keeps me coming back.</p>
<p>I wanted to write an app that would search the sites I read and automatically create an email digest based on search terms that I specified. I recently <a href="/blog/migrating-to-sqlite/">swapped my blog over to SQLite</a> and I love that the SQLite full-text search extension lets you specify boolean queries. With that in mind, I decided that I would have a curated list of boolean search queries which would be used to filter content from the various sites I read. Any articles that match my search would then be emailed to me.</p>
<p>Here are some of my search terms, which I am viewing in the <a href="http://flask-peewee.readthedocs.org/">flask-peewee admin interface</a>:</p>
<p><a href="http://media.charlesleifer.com/blog/photos/s1399741295.45.png" title="Search term admin"><img alt="Search term admin" class="img-responsive" src="http://m.charlesleifer.com/t/800x-/blog/photos/s1399741295.45.png?key=MFu88sejIfq4oYvO0M2SmQ"/></a></p>
<h3>Implementation</h3>
<p>Here is the bill of materials:</p>
<ul>
<li><a href="http://huey.readthedocs.org/">Huey</a> task queue, which will be used to periodically check for new articles and email them to me. If you want you could just write a cronjob, of course.</li>
<li><a href="http://docs.peewee-orm.com/">Peewee ORM</a> for storing the search terms and the links, so I don't send myself the same link twice.</li>
</ul>
<p>The first thing I did was define my database models. As you see, they are very simple:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">peewee</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">BaseModel</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">database</span> <span class="o">=</span> <span class="n">SqliteDatabase</span><span class="p">(</span><span class="s1">'search_terms.db'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SearchTerm</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">phrase</span> <span class="o">=</span> <span class="n">CharField</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phrase</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: we will add this method in a bit.</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">):</span>
        <span class="c1"># TODO: we will add this method in a bit.</span>
        <span class="k">pass</span>

<span class="k">class</span> <span class="nc">SavedLink</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">CharField</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">DateTimeField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>
</pre></div>
<h3>Parsing boolean expressions</h3>
<p>Now we come to the interesting part: the boolean expression parser. If you looked closely at the screenshot included above, you can see a few <code>SearchTerm</code> objects I've specified. Here are the actual phrases:</p>
<ul>
<li><code>peewee AND (orm OR python)</code></li>
<li><code>gevent</code></li>
<li><code>flask</code></li>
<li><code>python "-cheat sheet" -beginner -intro -pypy -free -"python 3"</code></li>
<li><code>sqlite OR unqlite OR berkeleydb OR kyotocabinet OR tokyocabinet</code></li>
</ul>
<p>Search terms consist of phrases joined by conjunctions (<code>AND</code> and <code>OR</code>). Search terms can be negated, indicated by prefixing the term with a dash (<code>-</code>) character. Search terms can also be nested, as in the first example, which will match articles containing the word <code>peewee</code> and also <code>orm</code> <em>or</em> <code>python</code>.</p>
<p>The first step is to split the search term into one or more <em>tokens</em>, which can be accomplished with a short regex. The regex splits on quoted text, parentheses and whitespace:</p>

<p>The parsing code maintains a stack of <code>Node</code> objects which comprise the query tree. The <code>Node</code> class is very basic, and there are two subclasses which are used to represent <code>AND</code> and <code>OR</code> nodes:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">''</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">'</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)'</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">,</span>
                <span class="s1">' '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">AndNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">OrNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
<p>Putting this together, here is the <code>SearchTerm.parse</code> method, which splits the phrase into tokens, then builds a tree of node objects.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">node_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'AND'</span><span class="p">:</span> <span class="n">AndNode</span><span class="p">,</span> <span class="s1">'OR'</span><span class="p">:</span> <span class="n">OrNode</span><span class="p">}</span>

    <span class="c1"># The default conjunction is AND, so if the phrase simply consists of</span>
    <span class="c1"># one or more words, "and"- them together.</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">AndNode</span><span class="p">(</span><span class="s1">'AND'</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'(</span><span class="se">\"</span><span class="s1">.+?</span><span class="se">\"</span><span class="s1">|\(|\s+|\))'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phrase</span><span class="p">):</span>
        <span class="c1"># Ignore any empty tokens.</span>
        <span class="n">token</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">token</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="s1">'('</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="s1">')'</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Error: unbalanced parentheses!'</span><span class="p">)</span>
            <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'AND'</span><span class="p">,</span> <span class="s1">'OR'</span><span class="p">):</span>
            <span class="c1"># In the event the top node uses the same conjunction, just</span>
            <span class="c1"># continue on. Otherwise push a new node onto the stack.</span>
            <span class="k">if</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span> <span class="o">!=</span> <span class="n">token</span><span class="p">:</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node_map</span><span class="p">[</span><span class="n">token</span><span class="p">](</span><span class="n">token</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">top</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s1">''</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">'"'</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
            <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Error: unbalanced parentheses!'</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
<p>If you try this out in the console, you'll get a nice representation of the search terms:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">search_term</span> <span class="o">=</span> <span class="n">SearchTerm</span><span class="p">(</span><span class="n">phrase</span><span class="o">=</span><span class="s1">'peewee AND (python OR orm)'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_term</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>
<span class="go">AND(peewee OR(python orm))</span>
</pre></div>
<h3>Compiling the search query</h3>
<p>Now that we have a query tree, we need to <em>compile</em> it into executable Python code. I struggled with this for a bit, but then I settled on what I hope is a fairly idiomatic implementation -- I just added a <code>code()</code> method to the <code>Node</code> classes which is responsible for recursively generating the list of query conditions.</p>
<p>For text nodes, the question is simply "Does the given title contain the phrase we're interested in?". For <code>AND</code> and <code>OR</code>, we just need to know whether <em>all</em> or <em>any</em> of the child nodes meet their conditions, respectively.</p>
<p>Here are the updated implementations of the <code>Node</code> classes, which now contain a <code>code()</code> method:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">''</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">'</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)'</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">,</span>
                <span class="s1">' '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'-'</span><span class="p">):</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="ow">in</span> <span class="n">s</span>

<span class="k">class</span> <span class="nc">AndNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">([</span>
                <span class="n">child</span><span class="o">.</span><span class="n">code</span><span class="p">()(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">fn</span>

<span class="k">class</span> <span class="nc">OrNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">([</span>
                <span class="n">child</span><span class="o">.</span><span class="n">code</span><span class="p">()(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">fn</span>
</pre></div>
<p>Now that we have a way of converting the query tree into python code, we can fill in the <code>SearchTerm.test()</code> method, which will test whether the title matches the specified <code>SearchTerm.phrase</code>:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">SearchTerm</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="c1"># yadda yadda...</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># ...</span>
        <span class="k">return</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="c1"># Parse the search phrase into a `Node` tree, then generate a python</span>
        <span class="c1"># function corresponding to the query conditions. Finally, apply that</span>
        <span class="c1"># function to the incoming string, `s`.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span><span class="o">.</span><span class="n">code</span><span class="p">()(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
<p>Here's how to test strings against our search terms to see whether they match. Let's check it out in the interactive interpreter:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">playground.models</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span> <span class="o">=</span> <span class="n">SearchTerm</span><span class="p">(</span><span class="n">phrase</span><span class="o">=</span><span class="s1">'peewee AND (python OR orm)'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="s1">'peewee'</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="s1">'peewee is written with python'</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="s1">'an orm named peewee'</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="s1">'an orm written with python'</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
<h3>Extracting links from websites</h3>
<p>The final piece is the code that extracts links from websites. This code needs to retrieve a list of links (consisting of a title and URL) from a specified URL. The catch is that some sites use RSS, some use a REST API, and in the future I may even want to scrape HTML, so the implementation needed to be flexible enough to handle all cases.</p>
<p>As I mentioned, the code will be extracting <code>Link</code> objects. Links are really just a title and a URL, so I've implemented them using <code>namedtuple</code>:</p>
<div class="highlight"><pre><span class="n">Link</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">'Link'</span><span class="p">,</span> <span class="p">(</span><span class="s1">'title'</span><span class="p">,</span> <span class="s1">'url'</span><span class="p">))</span>
</pre></div>
<p>I then created a <code>Searcher</code> class which has a single abstract method <code>extract_links</code>. There are also helper methods for fetching content using HTTP and then testing the link using the <code>SearchTerm</code> model.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">urllib2</span>

<span class="k">class</span> <span class="nc">Searcher</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">user_agent</span> <span class="o">=</span> <span class="s1">'SaturdayMorningHacks/0.1'</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>

    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">request</span> <span class="o">=</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="n">request</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">'User-Agent'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_agent</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">request</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_terms</span><span class="p">):</span>
        <span class="n">content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_links</span><span class="p">(</span><span class="n">content</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">search_term</span> <span class="ow">in</span> <span class="n">search_terms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">search_term</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="n">link</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">lower</span><span class="p">()):</span>
                    <span class="k">yield</span> <span class="n">link</span>
                    <span class="k">break</span>

    <span class="k">def</span> <span class="nf">extract_links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</pre></div>
<p>I needed two implementations of <code>Searcher</code>, one for searching RSS feeds, the other for accessing Reddit's API. While Reddit does have RSS feeds, the links just take you to the comments page for the post, so I opted to use their API which exposes the actual content URL. For simplicity, I used the standard library <code>ElementTree</code> to parse the RSS.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">xml.etree</span> <span class="kn">import</span> <span class="n">ElementTree</span> <span class="k">as</span> <span class="n">etree</span>

<span class="k">class</span> <span class="nc">FeedSearcher</span><span class="p">(</span><span class="n">Searcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">extract_links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
        <span class="n">articles</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">'channel/item'</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">article</span> <span class="ow">in</span> <span class="n">articles</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">Link</span><span class="p">(</span>
                <span class="n">title</span><span class="o">=</span><span class="n">article</span><span class="o">.</span><span class="n">findtext</span><span class="p">(</span><span class="s1">'title'</span><span class="p">),</span>
                <span class="n">url</span><span class="o">=</span><span class="n">article</span><span class="o">.</span><span class="n">findtext</span><span class="p">(</span><span class="s1">'link'</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">RedditSearcher</span><span class="p">(</span><span class="n">Searcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">extract_links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
        <span class="n">content</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
        <span class="n">links</span> <span class="o">=</span> <span class="n">content</span><span class="p">[</span><span class="s1">'data'</span><span class="p">][</span><span class="s1">'children'</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
            <span class="n">link_data</span> <span class="o">=</span> <span class="n">link</span><span class="p">[</span><span class="s1">'data'</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">link_data</span><span class="p">[</span><span class="s1">'selftext'</span><span class="p">]</span> <span class="o">==</span> <span class="s1">''</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">Link</span><span class="p">(</span>
                    <span class="n">title</span><span class="o">=</span><span class="n">link_data</span><span class="p">[</span><span class="s1">'title'</span><span class="p">],</span>
                    <span class="n">url</span><span class="o">=</span><span class="n">link_data</span><span class="p">[</span><span class="s1">'url'</span><span class="p">])</span>
</pre></div>
<p>Now that I have my <code>Searcher</code> implementations, I can create a list containing searchers for the sites I am interested in:</p>
<div class="highlight"><pre><span class="n">SEARCHERS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">FeedSearcher</span><span class="p">(</span><span class="s1">'https://news.ycombinator.com/rss'</span><span class="p">),</span>
    <span class="n">RedditSearcher</span><span class="p">(</span><span class="s1">'http://www.reddit.com/r/programming/hot.json'</span><span class="p">),</span>
    <span class="n">RedditSearcher</span><span class="p">(</span><span class="s1">'http://www.reddit.com/r/Python/hot.json'</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
<h3>Tying up loose ends</h3>
<p>Lastly we need to set up a <code>huey</code> task to fetch the list of articles and generate an email digest. Huey is a multi-threaded task queue that plays nicely with Redis, but if you're just experimenting you can use the SQLite backend (or just run a script as a cronjob).</p>
<div class="highlight"><pre><span class="nd">@huey.periodic_task</span><span class="p">(</span><span class="n">crontab</span><span class="p">(</span><span class="n">minute</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">hour</span><span class="o">=</span><span class="s1">'0'</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">content_search</span><span class="p">():</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">logger</span>
    <span class="n">query</span> <span class="o">=</span> <span class="n">SearchTerm</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
    <span class="n">links</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">searcher</span> <span class="ow">in</span> <span class="n">SEARCHERS</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">searcher</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">'Error fetching </span><span class="si">%s</span><span class="s1">'</span><span class="p">,</span> <span class="n">searcher</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="n">exists</span> <span class="o">=</span> <span class="p">(</span><span class="n">SavedLink</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
                          <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">SavedLink</span><span class="o">.</span><span class="n">url</span> <span class="o">==</span> <span class="n">result</span><span class="o">.</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">())</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">:</span>
                    <span class="n">SavedLink</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">link</span><span class="o">.</span><span class="n">title</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="n">link</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
                    <span class="n">links</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">links</span><span class="p">:</span>
        <span class="n">digest</span> <span class="o">=</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s1">'"</span><span class="si">%s</span><span class="s1">"  -&gt;  </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">link</span><span class="o">.</span><span class="n">title</span><span class="p">,</span> <span class="n">link</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="p">)</span>
        <span class="n">send_email</span><span class="p">(</span><span class="n">my_email_address</span><span class="p">,</span> <span class="s1">'Article digest'</span><span class="p">,</span> <span class="n">digest</span><span class="p">)</span>
</pre></div>
<p>And that's all there is to it! While testing I got my first issue of my new <em>Article digest</em> and was very pleased with the results.</p>
<h3>Thanks for reading</h3>
<p>Thanks for reading this post, I hope you found it interesting. I had a lot of fun working on this project and am looking forward to tweaking my <code>SearchTerms</code> to achieve a really great stream of new content. Look for more posts in the future tagged <code>saturday-morning-hacks</code> -- I'm really liking this format.</p>
<p>If you're interested in more projects like this, check out <a href="/blog/tags/saturday-morning-hacks/">the saturday-morning hack posts</a>.</p>
  
  

  
  
  

  
  
  

  
  
  


<hr/>

  <p>Commenting has been closed, but please feel free to <a href="/contact/">contact me</a></p>


    </div>

    </div></body></html>