<html><body><div><article class="post-content">
    <p>Recently I was working on new exciting part of
<a href="http://www.syncano.com/">syncano-platform</a> and I wanted to create a piece of
api that would allow for filtering resources with many to many relationships.</p>

<p>I wanted to have a resource that can be tagged.</p>

<p><a href="https://www.flickr.com/photos/cambodia4kidsorg/260004685/"><img src="https://farm1.staticflickr.com/117/260004685_8d78d77db0_o_d.jpg" alt=""/></a></p>

<p>Adding such tags should be RESTful and straightforward. Also I wanted to add the ability
to search using tags. My go to Rest library is <a href="http://www.django-rest-framework.org/">Django Rest Framework</a>.</p>

<p>Currently the most popular solution for tagging in django is
<a href="https://github.com/alex/django-taggit">django-taggit</a>, however
it doesn't integrate with Django Rest Framework well and heavily uses ContentTypes.
In my current project at work we don't use ContentTypes at all.</p>

<p>It's also a pretty old library and has support for old django, south migrations, stuff
that we just don't need in new projects.</p>

<p>I've read in a blog post <a href="https://godjango.com/33-tagging-with-django-taggit/">about django-taggit</a>:</p>

<blockquote>
<p>Tags can be hard if you try to implement them yourself, so don't try and just use this library from the start.</p>
</blockquote>

<p>And well, I disagree with this quote, how hard can it can be?</p>

<p>I sometimes prefer to write a simple code, well tailored
to my use case, that install another library with all its dependencies. If library is poorly
written you'll waste a lot of time debugging its strange behaviors and fighting
with it when trying to tailor it your custom requirements. (I'm looking at you <a href="https://github.com/omab/python-social-auth">python social auth</a>)</p>

<p>I decided to just do it myself. We will now distill this experience by building a simple app with two resources and
REST API for them. Here is a <a href="https://github.com/ilonajulczuk/django-tags">code</a> for a whole app.</p>

<h1>App Ingredients</h1>

<ul>
<li>python 3.4</li>
<li>django 1.8</li>
<li>Django Rest Framework 3.1</li>
<li>django-filter</li>
<li>django-cors-headers 1.1.0</li>
</ul>

<p>For simplicity I will use sqlite as a DB.</p>

<h2>Data models</h2>

<p>Let's imagine that we're building a very simplified version of PYPI. We're indexing
libraries, we store their names, websites, descriptions and tags.</p>

<p>User can then search libraries using names, descriptions and tags, they can even
add new tags to them.</p>

<p>How we will build it? We will have two resources</p>



<p>In django, models are defined in <code>models.py</code></p>

<p>models.py</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span> <span class="nc">Tag</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">"""Tag for data. Every tag has unique text.</span>
<span class="sd">    """</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">'Tag[id: {id}, text: {text}]'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Library</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">"""Library represents a piece of software. It has its website url,</span>
<span class="sd">    name, description and as many tags as you like.</span>
<span class="sd">    """</span>

    <span class="c"># django has a nice field that validates URLs</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">URLField</span><span class="p">()</span>

    <span class="c"># name should be in a slug form</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">SlugField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>
    <span class="n">description</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">blank</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">tags</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Tag</span><span class="p">,</span> <span class="n">related_name</span><span class="o">=</span><span class="s">'libraries'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">'Library[id: {id}, name: {name}]'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</code></pre></div>
<p>And we will create nice RESTy api for them. It will be possible to add tags
to libraries and vice versa.</p>

<p>To use django rest framework with those models, we need at three things:</p>

<ul>
<li>serializers</li>
<li>views</li>
<li>routing</li>
</ul>

<p>I usually start with serializers, serializer will translate our models to
serialized date (it can be other way round too). I'm going to use simple
serializers based on models directly. DRF has <code>ModelSerializer</code>s for that.</p>

<p>serializers.py</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">rest_framework</span> <span class="kn">import</span> <span class="n">serializers</span>

<span class="kn">from</span> <span class="nn">.models</span> <span class="kn">import</span> <span class="n">Library</span><span class="p">,</span> <span class="n">Tag</span>


<span class="k">class</span> <span class="nc">TagSerializer</span><span class="p">(</span><span class="n">serializers</span><span class="o">.</span><span class="n">ModelSerializer</span><span class="p">):</span>
    <span class="n">libraries</span> <span class="o">=</span> <span class="n">serializers</span><span class="o">.</span><span class="n">SlugRelatedField</span><span class="p">(</span>
        <span class="n">many</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">read_only</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">slug_field</span><span class="o">=</span><span class="s">'name'</span>
    <span class="p">)</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">Tag</span>


<span class="k">class</span> <span class="nc">LibrarySerializer</span><span class="p">(</span><span class="n">serializers</span><span class="o">.</span><span class="n">ModelSerializer</span><span class="p">):</span>
    <span class="n">tags</span> <span class="o">=</span> <span class="n">serializers</span><span class="o">.</span><span class="n">SlugRelatedField</span><span class="p">(</span>
        <span class="n">many</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">queryset</span><span class="o">=</span><span class="n">Tag</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span>
        <span class="n">slug_field</span><span class="o">=</span><span class="s">'text'</span>
    <span class="p">)</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">Library</span>
</code></pre></div>
<p>The only tricky part there was to define <code>SlugRelatedField</code>s correctly. You can
read more about related fields in DRF
 <a href="http://www.django-rest-framework.org/api-guide/relations/">here</a>.</p>

<p>With serializers in place, we can move to views part. Views let our app to
communicate with the rest of the world.</p>

<p>In DRF you can either use views or viewsets. Views are simpler to understand,
because they have the same methods as http verbs. Viewsets simplify lots of things and
they are on higher abstraction level, so instead of post, you have create method.</p>

<p>Also viewsets combine very well with routers and usually using viewset results in
using much less code.</p>

<p>Here I will use <code>ModelViewSet</code>s, that gives us full CRUD functionality for free.</p>

<p>views.py</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">rest_framework</span> <span class="kn">import</span> <span class="n">viewsets</span>

<span class="kn">from</span> <span class="nn">.models</span> <span class="kn">import</span> <span class="n">Library</span><span class="p">,</span> <span class="n">Tag</span>
<span class="kn">from</span> <span class="nn">.serializers</span> <span class="kn">import</span> <span class="n">LibrarySerializer</span><span class="p">,</span> <span class="n">TagSerializer</span>


<span class="k">class</span> <span class="nc">TagViewSet</span><span class="p">(</span><span class="n">viewsets</span><span class="o">.</span><span class="n">ModelViewSet</span><span class="p">):</span>
    <span class="n">queryset</span> <span class="o">=</span> <span class="n">Tag</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="n">serializer_class</span> <span class="o">=</span> <span class="n">TagSerializer</span>


<span class="k">class</span> <span class="nc">LibraryViewSet</span><span class="p">(</span><span class="n">viewsets</span><span class="o">.</span><span class="n">ModelViewSet</span><span class="p">):</span>
    <span class="n">queryset</span> <span class="o">=</span> <span class="n">Library</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="n">serializer_class</span> <span class="o">=</span> <span class="n">LibrarySerializer</span>
</code></pre></div>
<p>Simple, isn't it?</p>

<p>Now, let's connect views to urls.</p>

<p>urls.py</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">rest_framework.routers</span> <span class="kn">import</span> <span class="n">DefaultRouter</span>

<span class="kn">from</span> <span class="nn">.views</span> <span class="kn">import</span> <span class="n">LibraryViewSet</span><span class="p">,</span> <span class="n">TagViewSet</span>

<span class="n">router</span> <span class="o">=</span> <span class="n">DefaultRouter</span><span class="p">()</span>
<span class="n">router</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s">r'libraries'</span><span class="p">,</span> <span class="n">LibraryViewSet</span><span class="p">)</span>
<span class="n">router</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s">r'tags'</span><span class="p">,</span><span class="n">TagViewSet</span><span class="p">)</span>
<span class="n">urlpatterns</span> <span class="o">=</span> <span class="n">router</span><span class="o">.</span><span class="n">urls</span>
</code></pre></div>
<p>That's actually all we need to create DRF browsable API for those resources.</p>

<p><img src="http://i.imgur.com/2fIMbNZ.png" alt="Imgur"/></p>

<h2>Adding filtering</h2>

<p>We can add new things now, but finding something is currently a pain.</p>

<p><a href="https://www.flickr.com/photos/denverjeffrey/2561885967/in/photolist-4UokrH-qHQEPc-dYCDcW-oufzqn-hG6Xyx-2mnaga-oomyEr-3HbBZD-9bgFge-6Z1VAo-6TCgyp-98ejH9-5yYtyK-c1Duq9-r1edkT-93i2Tk-mnHEDQ-4PZqiV-mf2iWE-ak9s8g-9XK3Hy-agn3Es-8PCJ8C-gto5h-7NxJZy-dBYFge-or48Jg-9qk81s-dHAAcV-9r12Wr-6f3poB-6TL359-esUVsh-sAvZu9-6awutw-qiqT9Y-qLhUXP-m9mdpr-73Gqjb-qiqQKE-92t8FA-fnpaj6-5NByM-9XK9j3-9qPsEz-6khfv-d9Pguk-ggHwRT-fz9kwb-c3vzMS"><img src="https://farm4.staticflickr.com/3278/2561885967_f5f0be5834_z_d.jpg" alt=""/></a></p>

<p>Let's implement filtering! We will enable filtering of libraries by:</p>



<p>DRF has a pretty good support for filtering. You can read more about it <a href="http://www.django-rest-framework.org/api-guide/filtering/">here</a>.</p>

<p>Even though support is good, we still have to do some things:</p>

<ul>
<li>create a custom filter</li>
<li>enable filtering Backend</li>
</ul>

<p>Let start from creating a custom filter. We will put in in separate file, so
it will be easier to find.</p>

<p>filters.py</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">django_filters</span>

<span class="kn">from</span> <span class="nn">.models</span> <span class="kn">import</span> <span class="n">Library</span><span class="p">,</span> <span class="n">Tag</span>


<span class="k">class</span> <span class="nc">LibraryFilter</span><span class="p">(</span><span class="n">django_filters</span><span class="o">.</span><span class="n">FilterSet</span><span class="p">):</span>
    <span class="c"># default for CharFilter is to have exact lookup_type</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">django_filters</span><span class="o">.</span><span class="n">CharFilter</span><span class="p">(</span><span class="n">lookup_type</span><span class="o">=</span><span class="s">'icontains'</span><span class="p">)</span>
    <span class="n">description</span> <span class="o">=</span> <span class="n">django_filters</span><span class="o">.</span><span class="n">CharFilter</span><span class="p">(</span><span class="n">lookup_type</span><span class="o">=</span><span class="s">'icontains'</span><span class="p">)</span>

    <span class="c"># tricky part - how to filter by related field?</span>
    <span class="c"># but not by its foreign key (default)</span>
    <span class="c"># `to_field_name` is crucial here</span>
    <span class="c"># `conjoined=True` makes that, the more tags, the more narrow the search</span>
    <span class="n">tags</span> <span class="o">=</span> <span class="n">django_filters</span><span class="o">.</span><span class="n">ModelMultipleChoiceFilter</span><span class="p">(</span>
        <span class="n">queryset</span><span class="o">=</span><span class="n">Tag</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span>
        <span class="n">to_field_name</span><span class="o">=</span><span class="s">'text'</span><span class="p">,</span>
        <span class="n">conjoined</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">Library</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="s">'name'</span><span class="p">,</span> <span class="s">'description'</span><span class="p">,</span> <span class="s">'tags'</span><span class="p">]</span>
</code></pre></div>
<p>To create a custom filter, we had to inherit after django_filters.FilterSet,
define our model in Meta and define how each of filters should behave.</p>

<p>django_filters offers few types of <code>lookup_type</code>s for example: <code>exact</code> - that
would match an exact string, 'contains', that would returns matches that contain
given string, you can add <code>i</code> before those lookup_types, to make them ignore
case.</p>

<p>The only tricky part is filtering by related field using its field, different than
foreign key. I've seen some examples with filtering by related fields using foreign key,
but I couldn't find in any docs, how to do it with different field (in our case - tag text).</p>

<p>Eventually I had to dig into source of django fields
to find it out. It's enough to set <code>to_field_name='field_name'</code> and it should work.</p>

<p>To connect filter with view, you have to add following too lines to the view:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">filter_backends</span> <span class="o">=</span> <span class="p">(</span><span class="n">filters</span><span class="o">.</span><span class="n">DjangoFilterBackend</span><span class="p">,)</span>
<span class="n">filter_class</span> <span class="o">=</span> <span class="n">LibraryFilter</span>
</code></pre></div>
<p>You can also set filtering backend in django app settings if you like.</p>

<p>Here is how it should look like in context:</p>

<p>views.py</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">rest_framework</span> <span class="kn">import</span> <span class="n">filters</span><span class="p">,</span> <span class="n">viewsets</span>

<span class="kn">from</span> <span class="nn">.filters</span> <span class="kn">import</span> <span class="n">LibraryFilter</span>
<span class="kn">from</span> <span class="nn">.models</span> <span class="kn">import</span> <span class="n">Library</span><span class="p">,</span> <span class="n">Tag</span>
<span class="kn">from</span> <span class="nn">.serializers</span> <span class="kn">import</span> <span class="n">LibrarySerializer</span><span class="p">,</span> <span class="n">TagSerializer</span>


<span class="k">class</span> <span class="nc">TagViewSet</span><span class="p">(</span><span class="n">viewsets</span><span class="o">.</span><span class="n">ModelViewSet</span><span class="p">):</span>
    <span class="n">queryset</span> <span class="o">=</span> <span class="n">Tag</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="n">serializer_class</span> <span class="o">=</span> <span class="n">TagSerializer</span>


<span class="k">class</span> <span class="nc">LibraryViewSet</span><span class="p">(</span><span class="n">viewsets</span><span class="o">.</span><span class="n">ModelViewSet</span><span class="p">):</span>
    <span class="n">queryset</span> <span class="o">=</span> <span class="n">Library</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="n">serializer_class</span> <span class="o">=</span> <span class="n">LibrarySerializer</span>
    <span class="n">filter_backends</span> <span class="o">=</span> <span class="p">(</span><span class="n">filters</span><span class="o">.</span><span class="n">DjangoFilterBackend</span><span class="p">,)</span>
    <span class="n">filter_class</span> <span class="o">=</span> <span class="n">LibraryFilter</span>
</code></pre></div>
<h2>Using our API</h2>

<p>You can now list all tags:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>curl http://127.0.0.1:8000/tags/
</code></pre></div>
<p>Here is how result will look like (if you've created some data before):</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">[</span>
  <span class="p">{</span>
   <span class="nt">"text"</span><span class="p">:</span> <span class="s2">"python"</span><span class="p">,</span>
    <span class="nt">"libraries"</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">"django"</span><span class="p">,</span>
      <span class="s2">"django-rest-framework"</span>
    <span class="p">],</span>
    <span class="nt">"id"</span><span class="p">:</span> <span class="mi">1</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="nt">"text"</span><span class="p">:</span> <span class="s2">"web"</span><span class="p">,</span>
    <span class="nt">"libraries"</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">"django"</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="nt">"id"</span><span class="p">:</span> <span class="mi">2</span>
  <span class="p">}</span>
<span class="p">]</span>
</code></pre></div>
<p>If you curl libraries:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>curl http://127.0.0.1:8000/libraries/
</code></pre></div>
<p>your result will look like this:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">[</span>
  <span class="p">{</span>
    <span class="nt">"description"</span><span class="p">:</span> <span class="s2">"cool web framework"</span><span class="p">,</span>
    <span class="nt">"name"</span><span class="p">:</span> <span class="s2">"django"</span><span class="p">,</span>
    <span class="nt">"url"</span><span class="p">:</span> <span class="s2">"https://www.djangoproject.com/"</span><span class="p">,</span>
    <span class="nt">"tags"</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">"web"</span><span class="p">,</span>
      <span class="s2">"python"</span>
    <span class="p">],</span>
    <span class="nt">"id"</span><span class="p">:</span> <span class="mi">1</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="nt">"description"</span><span class="p">:</span> <span class="s2">"api framework"</span><span class="p">,</span>
    <span class="nt">"name"</span><span class="p">:</span> <span class="s2">"django-rest-framework"</span><span class="p">,</span>
    <span class="nt">"url"</span><span class="p">:</span> <span class="s2">"http://www.django-rest-framework.org/"</span><span class="p">,</span>
    <span class="nt">"tags"</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">"python"</span>
    <span class="p">],</span>
    <span class="nt">"id"</span><span class="p">:</span> <span class="mi">2</span>
  <span class="p">}</span>
<span class="p">]</span>
</code></pre></div>
<p>You can now perform queries with filters like below!</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>curl http://127.0.0.1:8000/libraries/?name<span class="o">=</span>rest<span class="p">&amp;</span><span class="nv">tags</span><span class="o">=</span>python
</code></pre></div><div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">[</span>
  <span class="p">{</span>
    <span class="nt">"description"</span><span class="p">:</span> <span class="s2">"api framework"</span><span class="p">,</span>
    <span class="nt">"name"</span><span class="p">:</span> <span class="s2">"django-rest-framework"</span><span class="p">,</span>
    <span class="nt">"url"</span><span class="p">:</span> <span class="s2">"http://www.django-rest-framework.org/"</span><span class="p">,</span>
    <span class="nt">"tags"</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">"python"</span>
    <span class="p">],</span>
    <span class="nt">"id"</span><span class="p">:</span> <span class="mi">2</span>
  <span class="p">}</span>
<span class="p">]</span>
</code></pre></div>
<p>Pretty neat!</p>

<h2>Summary</h2>

<p>I hope that you'll find this blog post useful. Building an APIs can actually be
a pretty complex task, because there are so many components that have to be
connected.</p>

<p>Also, we've just scratched a surface. Our API doesn't have proper
authorization, paging, ordering, permission system or tests, we also have pretty scarce validation, no api versioning
and we only handle JSON.</p>

<p>You can download or read full code on <a href="https://github.com/ilonajulczuk/django-tags">github</a>.</p>

  </article>
</div></body></html>