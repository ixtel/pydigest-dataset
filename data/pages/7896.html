<html><body><div><div class="post-text" itemprop="text">
<p>I was going to suggest <a href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.streamplot" rel="nofollow"><code>matplotlib.pyplot.streamplot</code></a> which supports the keyword argument <code>start_points</code> as of version 1.5.0, however it's not practical and also very inaccurate.</p>

<p>Your code examples are a bit confusing to me: if you have <code>vx</code>, <code>vy</code> vector field coordinates, then you should have <em>two</em> meshes: <code>x</code> and <code>y</code>. Using these you can indeed use <code>scipy.interpolate.griddata</code> to obtain a smooth vector field for integration, however that seemed to eat up too much memory when I tried to do that. Here's a similar solution based on <code>scipy.interpolate.interp2d</code>:</p>

<pre><code>import numpy as np
import matplotlib.pyplot as plt
import scipy.interpolate as interp
import scipy.integrate as integrate

#dummy input from the streamplot demo
y, x = np.mgrid[-3:3:100j, -3:3:100j]
vx = -1 - x**2 + y
vy = 1 + x - y**2

#dfun = lambda x,y: [interp.griddata((x,y),vx,np.array([[x,y]])), interp.griddata((x,y),vy,np.array([[x,y]]))]
dfunx = interp.interp2d(x[:],y[:],vx[:])
dfuny = interp.interp2d(x[:],y[:],vy[:])
dfun = lambda xy,t: [dfunx(xy[0],xy[1])[0], dfuny(xy[0],xy[1])[0]]

p0 = (0.5,0.5)
dt = 0.01
t0 = 0
t1 = 1
t = np.arange(t0,t1+dt,dt)

streamline=integrate.odeint(dfun,p0,t)

#plot it
plt.figure()
plt.plot(streamline[:,0],streamline[:,1])
plt.axis('equal')
mymask = (streamline[:,0].min()*0.9&lt;=x) &amp; (x&lt;=streamline[:,0].max()*1.1) &amp; (streamline[:,1].min()*0.9&lt;=y) &amp; (y&lt;=streamline[:,1].max()*1.1)
plt.quiver(x[mymask],y[mymask],vx[mymask],vy[mymask])
plt.show()
</code></pre>

<p>Note that I made the integration mesh more dense for additional precision, but it didn't change much in this case.</p>

<p>Result:</p>

<p><a href="http://i.stack.imgur.com/LkeIu.png" rel="nofollow"><img src="http://i.stack.imgur.com/LkeIu.png" alt="output"/></a></p>

<h2>Update</h2>

<p>After some notes in comments I revisited my original <code>griddata</code>-based approach. The reason for this was that while <code>interp2d</code> computes an interpolant for the entire data grid, <code>griddata</code> only computes the interpolating value at the points given to it, so in case of a few points the latter should be much faster.</p>

<p>I fixed the bugs in my earlier <code>griddata</code> attempt and came up with</p>

<pre><code>xyarr = np.array(zip(x.flatten(),y.flatten()))
dfun = lambda p,t: [interp.griddata(xyarr,vx.flatten(),np.array([p]))[0], interp.griddata(xyarr,vy.flatten(),np.array([p]))[0]]
</code></pre>

<p>which is compatible with <code>odeint</code>. It computes the interpolated values for each <code>p</code> point given to it by <code>odeint</code>. This solution doesn't consume excessive memory, however it takes <em>much much</em> longer to run with the above parameters. This is probably due to a lot of evaluations of <code>dfun</code> in <code>odeint</code>, much more than what would be evident from the 100 time points given to it as input.</p>

<p>However, the resulting streamline is much smoother than the one obtained with <code>interp2d</code>, even though both methods used the default <code>linear</code> interpolation method:</p>

<p><a href="http://i.stack.imgur.com/z9th6.png" rel="nofollow"><img src="http://i.stack.imgur.com/z9th6.png" alt="improved result"/></a></p>
    </div>
    </div></body></html>