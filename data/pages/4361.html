<html><body><div><div class="post-text" itemprop="text">


<p>With <a href="https://docs.python.org/3.2/library/pdb.html" rel="nofollow"><code>pdb</code></a> you can use nice combination of <a href="https://docs.python.org/3.2/library/pdb.html#pdbcommand-break" rel="nofollow"><code>break function</code></a> and <a href="https://docs.python.org/3.2/library/pdb.html#pdbcommand-until" rel="nofollow"><code>until lineno</code></a>:</p>

<blockquote>
  <p>Without argument, continue execution until the line with a number
  greater than the current one is reached.</p>
  
  <p>With a line number, continue execution until a line with a number
  greater or equal to that is reached. In both cases, also stop when the
  current frame returns.</p>
  
  <p>Changed in version 3.2: Allow giving an explicit line number.</p>
</blockquote>

<p>You can achieve what you needed.</p>

<p>I modified your example a bit (so you would see that instruction gets executed although pdb reports it as "<em>next instruction</em>"):</p>

<pre class="lang-python prettyprint-override"><code>01: class A(object):
02: 
03:     def __init__(self):
04:         self.X = []
05:         
06:     def f(self):         
07:         print('pre exec')
08:         for i in range(10):
09:             self.X.append(i)
10:         print('post exec')
11:             
12: a = A()
13: a.f()
14: print('Game is over')
15:
</code></pre>

<p>And result from running with <code>python -m pdb test.py</code> goes like this:</p>

<p>Start debugging and run it just after class declaration (so you can add named breakpoint):</p>

<pre class="lang-none prettyprint-override"><code>&gt; d:\tmp\stack\test.py(1)&lt;module&gt;()
-&gt; class A(object):
(Pdb) until 11
&gt; d:\tmp\stack\test.py(12)&lt;module&gt;()
-&gt; a = A()
</code></pre>

<p>Now, break at the beginning of function:</p>

<pre class="lang-none prettyprint-override"><code>(Pdb) break A.f
Breakpoint 1 at d:\tmp\stack\test.py:6
</code></pre>

<p>Just continue with execution until it hits breakpoint:</p>

<pre class="lang-none prettyprint-override"><code>(Pdb) continue
&gt; d:\tmp\stack\test.py(7)f()
-&gt; print('pre exec')
</code></pre>

<p>Take advantage of <em>"also stop when the current frame returns"</em>:</p>

<pre class="lang-none prettyprint-override"><code>(Pdb) until 14
pre exec
post exec
--Return--
</code></pre>

<p>As you can see, both <em>pre exec</em> and <em>post exec</em> were printed, but when executing <code>where</code> you are still in <code>f()</code>:</p>

<pre class="lang-none prettyprint-override"><code>(Pdb) w
  c:\python32\lib\bdb.py(405)run()
-&gt; exec(cmd, globals, locals)
  &lt;string&gt;(1)&lt;module&gt;()
  d:\tmp\stack\test.py(13)&lt;module&gt;()
-&gt; a.f()
&gt; d:\tmp\stack\test.py(10)f()-&gt;None
-&gt; print('post exec')
&gt; d:\tmp\stack\test.py(10)f()-&gt;None
-&gt; print('post exec')
</code></pre>

<p>And all context variables are intact:</p>

<pre class="lang-none prettyprint-override"><code>(Pdb) p self.X
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<hr/>

<p>Now with your real life example:</p>

<pre class="lang-python prettyprint-override"><code>01: class A(object):
02:     def __init__(self):
03:         self.X = []
04:         
05:     def f(self):         
06:         for i in range(10):
07:             self.X.append(i)
08:             
09: a = A()
10: a.f()
11: print('Game is over')
</code></pre>

<p>Start the similar fashion as before:</p>

<pre class="lang-none prettyprint-override"><code>&gt; d:\tmp\stack\test.py(1)&lt;module&gt;()
-&gt; class A(object):
(Pdb) until 8
&gt; d:\tmp\stack\test.py(9)&lt;module&gt;()
-&gt; a = A()
(Pdb) break A.f
Breakpoint 1 at d:\tmp\stack\test.py:5
(Pdb) cont
&gt; d:\tmp\stack\test.py(6)f()
-&gt; for i in range(10):
</code></pre>

<p>Now... Breakpoint in <code>f.A</code> actually means breakpoint at first statement of <code>f.A</code> which is unfortunately <code>for i in...</code> so it would break on it every time.</p>

<p>If you don't actually start your real code with loop, you can skip this part.</p>

<pre class="lang-none prettyprint-override"><code>(Pdb) disable 1
Disabled breakpoint 1 at d:\tmp\stack\test.py:5
</code></pre>

<p>Again, use the <code>until &lt;end of file&gt;</code>:</p>

<pre class="lang-none prettyprint-override"><code>(Pdb) until 10
--Return--
&gt; d:\tmp\stack\test.py(6)f()-&gt;None
-&gt; for i in range(10):
</code></pre>

<p>And again, all frame variables are available:</p>

<pre class="lang-none prettyprint-override"><code>(Pdb) p i
9
(Pdb) w
  c:\python32\lib\bdb.py(405)run()
-&gt; exec(cmd, globals, locals)
  &lt;string&gt;(1)&lt;module&gt;()
  d:\tmp\stack\test.py(10)&lt;module&gt;()
-&gt; a.f()
&gt; d:\tmp\stack\test.py(6)f()-&gt;None
-&gt; for i in range(10):
(Pdb)
</code></pre>

<hr/>

<p>The sad thing here is, that I wanted to try this piece of automation:</p>

<pre class="lang-none prettyprint-override"><code>(Pdb) break A.f
Breakpoint 1 at d:\tmp\stack\test.py:5
(Pdb) commands 1
(com) disable 1
(com) until 11
(com) end
</code></pre>

<p>Which would do everything you need automatically (again, <code>disable 1</code> not needed when you have at least one pre-loop statement), but according to documentation on <a href="https://docs.python.org/3.2/library/pdb.html#pdbcommand-commands" rel="nofollow"><code>commands</code></a>:</p>

<blockquote>
  <p>Specifying any command resuming execution (currently continue, step, next, return, jump, quit and their abbreviations) terminates the command list (as if that command was immediately followed by end). This is because any time you resume execution (even with a simple next or step), you may encounter another breakpointâ€“which could have its own command list, leading to ambiguities about which list to execute.</p>
</blockquote>

<p>So <code>until</code> just doesn't seem to work (at least for Python 3.2.5 under windows) and you have to do this by hand.</p>
    </div>
    </div></body></html>