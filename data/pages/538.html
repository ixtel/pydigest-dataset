<html><body><div><div class="col-xs-9">
                                <div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/Screen%20Shot%202014-02-21%20at%208.26.17%20PM.png"/>
<p>
Our Pythonthusiast Qt Widgets Application running in OSX 10.8.4 Mountain Lion
</p>
</div>
<p align="justify">
This part of the series is probably the essence (and the lengthiest!) of all articles in this series: doing GUI development using Qt. Although Qt develop itself as a full stack application framework, the association of Qt is always about GUI development. That's not entirely correct, as you can completely drop GUI part of the framework, and go <a href="http://doc.qt.digia.com/solutions/4/qtsingleapplication/qtsinglecoreapplication-example-console.html">only with the console</a>. But, indeed the strongest part of Qt is mainly about GUI development : starting from desktop GUI using <a href="http://pythonthusiast.pythonblogs.com/">QtGui</a> and now targeting mobile GUI using <a href="http://pythonthusiast.pythonblogs.com/">QtQuick</a>. In this Qt article series, we still talk about desktop GUI development using QtGui modules. Although QtQuick future may cross QtGui area by maturing itself as another option to develop desktop GUI application, but QtGui will always be there as part of Qt framework.
</p>
<p align="justify">
To add a more interesting twist on this series, we will develop all of our applications in Apple OSX operating system (still using Mountain Lion 10.8.4 though, haven't upgrade it to Mavericks). Comparing it with the official Python/PyQt/PySide distribution for Windows, if done incorrectly, preparing a working environment of all them in OSX is a lot harder. But we will have a look on how it's done correctly : with the least effort as possible. 
</p>
<p align="justify">
So, what are we waiting for? Lets start our first journey toward QtGui application development!
</p>
<p align="justify">
 
</p>
<h2>General Guide on Qt GUI Application Development<br/>
</h2>
<p align="justify">
As with any GUI application framework, developing GUI application using Qt GUI can be breakdown into these series of tasks:
</p>
<div align="justify">
<ol>
	<li>Design the application user interface using provided GUI designer tool.<br/>
	In this regard, you will use Qt Designer to design your Qt application user interfaces, saved in file having <code>*.ui</code> extension. The task of using Qt Designer can be made seamless, if we develop a C++ Qt application using Qt Creator. If however we develop Qt application using Python via PyQt/PySide, we must invoke Qt Designer manually. Another point to note that, using a GUI designer is actually an optional (but highly recommended) requirement. You can develop your application GUI bare handed using plain C++/Python code. But surely, using a visual GUI designer tool to laying out your application GUI elements is much more pleasant than manually hand coding them.</li>
	<li>If we are using GUI designer tool, there will be a process of importing our GUI designer file into our application code.<br/>
	Once again, if we are using a highly integrated IDE, this process will be seamless. You may not realize that this task ever existed, as with the case of developing C++ Qt application using Qt Creator. Developing it using Python though, will require us to invoke either PyQt <code>pyuic4</code> tool or PySide <code>pyside-uic</code> to import our <code>*.ui</code> files into Python <code>*.py</code> code. If you have experience using Netbeans IDE to develop Java application, think of this process as the seamless process done by Netbeans when it automatically import Netbeans <code>*.form</code> file into Java code.</li>
	<li>Connecting certain events in objects GUI element/widget event into event handler.<br/>
	Well, using the term events in this particular case may not fit well in Qt world. But, I put a bet that most casual GUI programmer are more familiar with the term events than the term <a href="http://qt-project.org/doc/qt-4.8/signalsandslots.html">signal and slot</a> used in Qt. For example, when you want to respond to a click of a button, what do you have in mind? Handling click events or connecting click signal with a slot function/method? Now, you got my point... <img src="http://pythonthusiast.pythonblogs.com/js/tinymce/plugins/emotions/images/smiley-laughing.gif" border="0" alt="Laughing" title="Laughing"/><br/>
	Qt indeed have the term <a href="http://qt-project.org/doc/qt-4.8/eventsandfilters.html">events</a>, and together with signal and slot both did have the same purpose : object interconnection. However, the way event and signal/slot was carried out are an important matter that differentiate this two concepts:<br/>
	<ul>
		<li> Event is implemented as a virtual method, where as slot is a function that can exist either as an object method or as a simple function. In this regard, Qt design event to be utilize by means of object inheritance, where as signal and slot is to be implemented as a loosely coupled connection between two object.</li>
		<li>There are chains of events that eventually can be cut off by our overridden method, where as after emitting signal, any functions that already connected as the receiving slot can respond in parallel, without regard of the other slot.</li>
		<li>Events is carried out from within system events loop, making it able to receive external system events such as mouse movement or keyboard strokes. This means an event handler may took sometime to execute after event did occur. This is significantly different with signal and slot, where slot function of a connected signal is --<a href="https://qt-project.org/doc/qt-5/qt.html#ConnectionType-enum">usually</a>-- carried out immediately after a signal is emitted. </li>
	</ul>
	Once again, having use a good IDE can simplify your life of connecting the available signal from a widget to a user defined slot. Yes, correct, I am talking about QtCreator <img src="http://pythonthusiast.pythonblogs.com/js/tinymce/plugins/emotions/images/smiley-smile.gif" border="0" alt="Smile" title="Smile"/></li>
	<li>Defining resource file and importing it to our code.<br/>
	Qt has its own resource file saved in an <code>*.qrc</code> file which is actually a regular XML file. This is a cross platform resource file where you can define files and text resource for your application. In C++ project, the task of importing <code>*.qrc</code> file into <code>*.cpp</code>  file is carried out by Qt <code>rcc</code> tool. This tool is called automatically by Qt Creator, where as its PyQt counterpart, <code>pyrcc4</code>, or its PySide counterpart,<code> pyside-rcc</code>, must be called manually for a Python project.</li>
</ol>
</div>
<p align="justify">
 
</p>
<h2>Preparing Qt,PyQt and PySide in OSX using Homebrew<br/>
</h2>
<p align="justify">
Using <a href="http://brew.sh">Homebrew</a> to take the role as the OSX package manager is probably the effortless way to install Python/PyQt/PySide. If Homebrew works correctly on your OSX machine, then we can say that preparing a working Python environment in OSX is way a lot easier than its Windows counterpart. It may be on a par with Ubuntu with its apt package manager. If it is as simple as doing <code>apt-get install</code> in Ubuntu, then it is also as simple as doing <code>brew install</code> on OSX. How cool is that? 
</p>
<p align="justify">
Anyway, although you can inspect that OSX already shipped with Python environment (Python 2.7.2 in my Mountain Lion), but the subsequent task of upgrading/installing Python packages is not <em>officially </em>supported by Apple. Therefore, using Homebrew (or simply Brew) to manage our OSX packages, is simply irresistible. And it's always better to left Apple built-in python distribution to be untouched. 
</p>
<p align="justify">
Now lets move on to the task of preparing Python working environment in our OSX system using brew. 
</p>
<p>
<strong>First</strong>, lets install  brew using this command : <code>ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"</code>. Brew installation is very informative and a pleasant to work with. Just execute it and follow any error messages (if any), informational message or recommendation of how to make brew working as effective as possible in your OSX environment. Anyway, don't worry about that <code>ruby</code> thing. OSX is also shipped with ruby distribution. So, after waiting for coupla minutes, soon you will have a working brew binary ready in your OSX environment.
</p>
<p align="justify">
<strong>Second</strong>,  you can go ahead and install any Python and its packages using the command <code>brew install &lt;FORMULA&gt;</code>. Formula is just another name for package. To search for available package, simply issue the command <code>brew search &lt;FORMULA&gt;</code>. So, to find out whether we can install <code>qt</code> using brew, simply issue the command <code>brew search qt</code>. It will give you qt, qt5, pyqt and pyqt5 amongst other things. 
</p>
<p align="justify">
Recall that PyQt5 is distributed only as Python 3 package, so if you want to use PytQt4, you will end up installing Python 2.7 also. This means, eventually you will have two different version of Python. Don't worry about it though. Brew will take care of this for you. 
</p>
<p align="justify">
To install Qt4, PyQt4 and PySide, issue the command <code>brew install python qt pyqt pyside pyside-tools</code>.
</p>
<p align="justify">
To install Qt5 and PyQt5, issue the command <code>brew install python3 qt5 pyqt5</code>. 
</p>
<p align="justify">
Installing Qt4 or Qt5 using brew will not install QtCreator, which is an important factor for a successful C++ Qt project development. To finish the preparation you can download QtCreator  manually from <a href="http://qt-project.org/downloads#qt-creator">here</a>. In my OSX workstation I install the full binary distribution of Qt 5.2.1 along with its QtCreator. I also install PyQt4/PyQt5/PySide along with Qt4/Qt5 using brew, to allow PyQt/PySide available in my Python 2/3 environment. 
</p>
<p align="justify">
There is one last requirement should you want to develop C++ Qt application in OSX : you must do a full installation of XCode. Yep, that dreaded 1.6GB of *.dmg file must be downloaded and installed in your machine. I have try to install the XCode command line tools only, but QtCreator still need the full installation of XCode in order for it to able to build and package our C++ Qt application. The good news is you can <a href="http://developer.apple.com /downloads">download XCode</a> freely once you register as Apple Developer (which is also free). I purposely upgrade my Mountain Lion 10.8.2 into 10.8.4 to let me install the latest XCode 5.0.2. It works well with the latest QtCreator shipped with Qt 5.2.1.
</p>
<h2>Developing Qt Widgets Application with C++ Qt </h2>
<h3>The need to produce multiple binary files</h3>
<p align="justify">
Before starting our C++ Qt project, there is one important concept to clear out first : every<strong> C++ project</strong> regardless of its framework being used or its dependent operating system, will always produce <strong>one binary file</strong>. Only with certain management, multiple binary can be produced by a C++ project. Previously we already have a Unittest project, producing one binary file namely <code>unittest</code>. In this project, we will build another project, a QtGui project, that will also create another binary file, lets name it <code>pythonthusiast</code>. This mean, special consideration must be made to allow our project produced multiple binary file. To allow a better understanding of the overall development process, I love to start with a <strong>new</strong> C++ project that produce single binary file first (the QtGui project), and then we will modify it to produce another binary file (the <strong>existing</strong> Unittest project).
</p>
<p align="justify">
If you go with the Python path, this complexity is not even known. Why? Simply because there is no concept of binary file in Python. You can feed any *.py file into Python interpreter and it will try to run it : regardless of whether this *.py file is actually your main Python file or not.
</p>
<p align="justify">
Pretty nice eh? 
</p>
<h2>Developing Pythonthusiast as a Single C++ Qt Widgets Application</h2>
<h3>Creating a Qt Widgets Application</h3>
<p align="justify">
Lets start a new QtGui project by choosing Qt Widgets Application in the existing QtCreator template. I am going to use the name Pythonthusiast as this project name, but of course you are free to chose other name.
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/Screen%20Shot%202014-02-26%20at%208.07.52%20AM.png" alt="A Qt Widgets Application template"/>
<p>
A Qt Widgets Application template
</p>
</div>
<p align="justify">
Accept all the default values in the subsequent wizard page, because indeed we will create a MainWindow application using <code>QMainWindow</code> as the base class. The important thing to note from this wizard page is that, QtCreator will present you with a Kit Selection dialog as seen below:
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/Screen%20Shot%202014-02-26%20at%208.12.56%20AM.png" alt="Kit selection dialog for shadow building feature in QtCreator"/>
<p>
Kit selection dialog for shadow build feature in QtCreator
</p>
</div>
<p align="justify">
This dialog present you with the directory use by QtCreator to produce all intermediate objects and target binary(-ies) for your project. By default, QtCreator will use shadow build feature, meaning that all the resultant artifacts will be placed outside of your source code directory, which is a great feature, as we don't want our source code directory to be clutter up with buncha binary files. This configuration was saved in a *.pro.user file. So, if you move out your project to another directory, be sure to delete this *.pro.user file, as QtCreator will create it again for you. If not, you will get this annoying warning, <code>Qmake does not support build directories below the source directory</code>. Another important technique is to add *.pro.user pattern in your <code>.gitignore</code> file. 
</p>
<p align="justify">
Okay, as everything were clearly explained (I hope so), let just run our new project (hit ⌘+R in OSX or CTRL+R in other OS) and see the result. Great isn't it? 
</p>
<h3>Create A New Login Dialog<br/>
</h3>
<p align="justify">
Reviewing again our application flow from the <a href="http://pythonthusiast.pythonblogs.com/230_pythonthusiast/archive/1351_developing_cross_platform_application_using_qt_pyqt_and_pyside__first_iteration_of_the_overall_application_design_and_hello_world-part_2_of_7.html">first article</a> in this series, it is clear for us that we need a login dialog. Hence, right click on our root project node and select Add New, and choose Qt Designer Form Class from the available Qt template. Choose either Dialog with Buttons Bottom or Dialog with Buttons Right, click continue and name it <code>LoginDialog</code>. This class is a subclass of <code>QDialog</code> which feature a standard popup dialog in a Qt application.
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/Screen%20Shot%202014-02-26%20at%208.46.15%20AM.png" alt="I choose the Dialog with Buttons Bottom"/>
<p>
I choose the Dialog with Buttons Bottom template
</p>
</div>
<p align="justify">
I bet you have the urge to start dragging and dropping all that cool Qt Widgets into this dialog. Well, don't be. Lets select a proper Layout first, which is in our case that would be Form Layout.
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/Screen%20Shot%202014-02-26%20at%204.38.23%20PM.png" alt="Drag and drop Form Layout to our LoginDialog form designer"/>
<p>
Drag and drop Form Layout element to our LoginDialog form designer
</p>
</div>
<p align="justify">
Place it in the proper position, and then right click inside Form Layout red rectangle guide, and then choose Add form layout row. You'll be presented with this dialog:
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/Screen%20Shot%202014-02-26%20at%204.43.58%20PM.png" alt="Add pair of QLabel and QLineEdit for each row"/>
<p>
Add pair of QLabel and QLineEdit for each row
</p>
</div>
<p align="justify">
Make two rows that comprise of --intuitively-- username and password input widgets. You may realize that for the QLineEdit control I like to rename it using the pattern <code>txt*</code>, which is the pattern that I preserve since my Visual Basic programming career. Of course you can use any naming convention that suit you. One modification about QLineEdit for password is, you should change its <code>echoMode</code> to <code>Password</code>, which will make it behave as a standard password field. Below is the resultant login dialog:
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/Screen%20Shot%202014-02-26%20at%204.55.58%20PM.png" alt="Final user interface design of LoginDialog"/>
<p>
Final user interface design of LoginDialog
</p>
</div>
<p align="justify">
 
</p>
<h3>Implement Slot for LoginDialog Signals
</h3>
<p align="justify">
Yeah, for veteran in other desktop GUI application framework (Delphi, VB/VC 6.0, .NET and Java) this sub chapter title may seems weird. You can mentally read it as, "Implement Event Handler for LoginDialog Events", and pragmatically, it suit just well. Right click on our Button Box that comprise of OK and Cancel button, and click Go to slot. 
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/Screen%20Shot%202014-02-26%20at%205.07.36%20PM.png" alt="All the available signals for a ButtonBox widget"/>
<p>
All the available signals for a ButtonBox widget
</p>
</div>
<p align="justify">
Choose <code>accepted()</code> signal and press OK. QtCreator will create/direct you to the function that will act as slot for that signal. <code>accepted() </code>will be emitted if user press OK button in our LoginDialog. I have designed that this dialog should return three possible values that being implemented as a C++ enum as follows:
</p>
<p align="justify">
</p>
<table class="cpp code"><tbody><tr class="li1"><td><pre>1
</pre></td><td><pre><span>enum</span> LoginStatus <span>{</span> Success, Failed, Rejected <span>}</span><span>;</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
A built-in behaviour for <code>QDialog</code> subclass is to close the dialog and return <code>QDialog::Accepted</code> when user click OK and close the dialog and returning <code>QDialog::Rejected</code> when user click Cancel button. As this dialog will eventually trying to authenticate provided credential with existing one from the database, therefore I modify <code>LoginDialog</code> return value to suit authentication result :<code> </code>Success (when the credentials are a match), Failed (unmatched credentials) and Rejected (user cancel the login dialog). At this step, we haven't use our previous <code>Auth</code> class, therefore we simply compare <code>txtUsername-&gt;text()</code> to be equal with certain username. 
</p>
<p>
</p>
<table class="cpp code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td><pre><span>void</span> LoginDialog<span>::</span><span>on_buttonBox_accepted</span><span>(</span><span>)</span>
<span>{</span>
    <span>if</span><span>(</span>ui<span>-</span><span>&gt;</span>txtUsername<span>-</span><span>&gt;</span>text<span>(</span><span>)</span><span>==</span><span>"admin"</span><span>)</span>
    <span>{</span>
        setResult<span>(</span>LoginDialog<span>::</span><span>Success</span><span>)</span><span>;</span>
    <span>}</span><span>else</span><span>{</span>
        QMessageBox msgBox<span>(</span><span>this</span><span>)</span><span>;</span>
        msgBox.<span>setIcon</span><span>(</span>QMessageBox<span>::</span><span>Warning</span><span>)</span><span>;</span>
        msgBox.<span>setWindowTitle</span><span>(</span>tr<span>(</span><span>"Pythonthusiast"</span><span>)</span><span>)</span><span>;</span>
        msgBox.<span>setText</span><span>(</span>tr<span>(</span><span>"Either incorrect username and/or password. Try again!"</span><span>)</span><span>)</span><span>;</span>
        msgBox.<span>setStandardButtons</span><span>(</span>QMessageBox<span>::</span><span>Ok</span><span>)</span><span>;</span>
        msgBox.<span>exec</span><span>(</span><span>)</span><span>;</span>
 
        setResult<span>(</span>LoginDialog<span>::</span><span>Failed</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
Here, we use <code>QMessageBox</code> to display warning when authentication method is failed. Observe that we use <code>tr()</code> method to correctly return translated string for certain language localization. For now it simply return the given string.
</p>
<p align="justify">
Finally, connect ButtonBox <code>rejected()</code> signal with its slot using the following code: 
</p>
<p align="justify">
</p>
<table class="cpp code"><tbody><tr class="li1"><td><pre>1
2
3
4
</pre></td><td><pre><span>void</span> LoginDialog<span>::</span><span>on_buttonBox_rejected</span><span>(</span><span>)</span>
<span>{</span>
    setResult<span>(</span>LoginDialog<span>::</span><span>Rejected</span><span>)</span><span>;</span>
<span>}</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
 
</p>
<h3>Using LoginDialog in Our Application
</h3>
<p align="justify">
Once again, examine our application flow design, and think how we can use LoginDialog in the existing application code. For a start, our C++ Qt application is configure to execute <code>main.cpp</code> which contain <code>main()</code> function as the initial starting point for any C/C++ application. Observe the current <code>main()</code> function as follows:
</p>
<p align="justify">
</p>
<table class="cpp code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span>int</span> main<span>(</span><span>int</span> argc, <span>char</span> <span>*</span>argv<span>[</span><span>]</span><span>)</span>
<span>{</span>
    QApplication a<span>(</span>argc, argv<span>)</span><span>;</span>
    MainWindow w<span>;</span>
    w.<span>show</span><span>(</span><span>)</span><span>;</span>
 
    <span>return</span> a.<span>exec</span><span>(</span><span>)</span><span>;</span>
<span>}</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
The above code simply create a <code>QApplication</code> instance, showing MainWindow and starting application events loop. And to adjust it to suit our login feature application flow, we must use our LoginDialog class and modify this <code>main()</code> function as follows:
</p>
<p align="justify">
</p>
<table class="cpp code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td><pre><span>int</span> main<span>(</span><span>int</span> argc, <span>char</span> <span>*</span>argv<span>[</span><span>]</span><span>)</span>
<span>{</span>
    QApplication a<span>(</span>argc, argv<span>)</span><span>;</span>
    LoginDialog login<span>;</span>
    <span>bool</span> isAuth <span>=</span> <span>false</span><span>;</span>
    <span>int</span> result<span>;</span>
    <span>do</span>
    <span>{</span>
        result <span>=</span> login.<span>exec</span><span>(</span><span>)</span><span>;</span>
        isAuth <span>=</span> result <span>==</span> LoginDialog<span>::</span><span>Success</span> <span>||</span> result <span>==</span> LoginDialog<span>::</span><span>Rejected</span><span>;</span>
    <span>}</span> <span>while</span><span>(</span><span>!</span>isAuth<span>)</span><span>;</span>
 
    <span>if</span><span>(</span>result <span>==</span> LoginDialog<span>::</span><span>Success</span><span>)</span>
    <span>{</span>
        MainWindow w<span>;</span>
        w.<span>show</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> a.<span>exec</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
 
 
    a.<span>quit</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>-</span><span>1</span><span>;</span>
<span>}</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
I am sure the code above is self explanatory as it really an implementation from our designed application flow. Try to run this application, and instead of directly presenting our MainWindow object, now you will be presented with a Login Dialog that either must be filled with correct credentials or cancelled. The MainWindow object will be shown only when the credentials are correct. If not, well, you'll be stuck with this LoginDialog... <img src="http://pythonthusiast.pythonblogs.com/js/tinymce/plugins/emotions/images/smiley-laughing.gif" border="0" alt="Laughing" title="Laughing"/>  
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/Screen%20Shot%202014-02-26%20at%206.13.11%20PM.png" alt="You must enter proper credentials to pass this login dialog"/>
<p>
You must enter proper credentials to pass this login dialog
</p>
</div>
<h3>Modifying MainWindow<br/>
</h3>
<p align="justify">
In the next article, we will work intensely in this MainWindow class. For now, we will keep ourselves satisfy by adding two menu items in it : File-&gt;Exit and Help-&gt;About. To configure menu for this MainWindow, simply open (double click) the file <code>mainwindow.ui</code> and start typing in the menu placeholder already provided by QtCreator. Once all the menu items were added, you can directly write the slot function that will handle <code>triggered()</code> signal for that particular menu item. Example given for Exit menu item as seen below:
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/Screen%20Shot%202014-02-26%20at%208.27.31%20PM.png" alt="Connecting Exit menu item triggerred() signal to slot function"/>
<p>
Connecting Exit menu item triggerred() signal to slot function
</p>
</div>
<p align="justify">
For the exit slot function itself, we will confirm user about this action by using the following code:
</p>
<p align="justify">
</p>
<table class="cpp code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td><pre><span>void</span> MainWindow<span>::</span><span>on_actionExit_triggered</span><span>(</span><span>)</span>
<span>{</span>
    QMessageBox msgBox<span>(</span><span>this</span><span>)</span><span>;</span>
    msgBox.<span>setIcon</span><span>(</span>QMessageBox<span>::</span><span>Question</span><span>)</span><span>;</span>
    msgBox.<span>setWindowTitle</span><span>(</span>tr<span>(</span><span>"Pythonthusiast"</span><span>)</span><span>)</span><span>;</span>
    msgBox.<span>setText</span><span>(</span>tr<span>(</span><span>"Are you sure you want to quit?"</span><span>)</span><span>)</span><span>;</span>
    msgBox.<span>setStandardButtons</span><span>(</span>QMessageBox<span>::</span><span>No</span><span>|</span>QMessageBox<span>::</span><span>Yes</span><span>)</span><span>;</span>
    msgBox.<span>setDefaultButton</span><span>(</span>QMessageBox<span>::</span><span>Yes</span><span>)</span><span>;</span>
 
    <span>if</span><span>(</span>msgBox.<span>exec</span><span>(</span><span>)</span><span>==</span>QMessageBox<span>::</span><span>Yes</span><span>)</span>
    <span>{</span>
        qApp<span>-</span><span>&gt;</span>quit<span>(</span><span>)</span><span>;</span>
    <span>}</span>    
<span>}</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
Whereas for the About menu item, we use the following slot function, that will display an informational dialog box about our application:
</p>
<p align="justify">
</p>
<table class="cpp code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>void</span> MainWindow<span>::</span><span>on_actionAbout_triggered</span><span>(</span><span>)</span>
<span>{</span>
    QMessageBox msgBox<span>(</span><span>this</span><span>)</span><span>;</span>
    msgBox.<span>setIconPixmap</span><span>(</span>QPixmap<span>(</span><span>":/images/sherlock.png"</span><span>)</span><span>)</span><span>;</span>
    msgBox.<span>setWindowTitle</span><span>(</span>tr<span>(</span><span>"Pythonthusiast"</span><span>)</span><span>)</span><span>;</span>
    msgBox.<span>setText</span><span>(</span>tr<span>(</span><span>"Well Watson, isn't it obvious to you that Qt rocks?"</span><span>)</span><span>)</span><span>;</span>
    msgBox.<span>setStandardButtons</span><span>(</span>QMessageBox<span>::</span><span>Ok</span><span>)</span><span>;</span>
    msgBox.<span>exec</span><span>(</span><span>)</span><span>;</span>    
<span>}</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
Notice something different there?  Instead of the default icon provided by <code>QMessageBox</code>, we use our own icon in it. This feature is provided by means of Qt Resource file (*.qrc), which is simply an XML file that will be processed by Qt <code>rcc</code> tool (automatically if you are using QtCreator) into a *.cpp code. 
</p>
<p align="justify">
To manage your resource file, add a Qt Resource File to your project, name it <code>app.qrc</code> (or anything that you like) and you will be able to use QtCreator easy to use resource editor to manage your *.qrc file. 
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/Screen%20Shot%202014-02-26%20at%208.45.35%20PM.png" alt="Qt easy to use resource editor"/>
<p>
Qt easy to use resource editor
</p>
</div>
<p align="justify">
First, you have to prepare all your resource files to be stored inside of your source directory. Of course you can use sub directory to better manage its layout. Second, you will have to add a prefix for your resource files (e.g /images, /icon, /art, etc.). This is not to be confused with where you put your actual resource files. After adding a prefix, click it and then start to add file for that particular resource prefixes. And... voila! Your resource files are ready to use like the example given above.
</p>
<h3>Conclusion</h3>
<p align="justify">
This conclude a detailed explanation of how to create a Qt Widgets Application, that produce a single binary. You can find the resultant binary file in your shadow build directory. But this project missing one important feature : how can we use our previous <code>Auth</code> class and <code>helper</code> file in our previous Unittest project? 
</p>
<p align="justify">
Ready to move on? Great. Lets continue our journey on the subsequent section talking about a subdirs project template. 
</p>
<h2>Developing Pythonthusiast as a Multiple C++ Qt Project</h2>
<h3>Introducing Subdirs Project Template<br/>
</h3>
<p align="justify">
In earlier section, I've introduced you to the reason why we need a C++ Qt project that produce multiple binary file. And now, we will have a look on how it is done. Qmake has as special project template called <a href="http://qt-project.org/doc/qt-4.8/qmake-variable-reference.html#subdirs">subdirs</a> template. Project created with subdirs template will only serve as the container for any other Qmake projects (called subprojects). Contrary to its name that may lead you to think that these subprojects must reside in a sub directory of the Subdirs project, well, in practice you can put it anywhere. Even in the same directory! (Now you can literally say goodbye to the lexical meaning of subdirs..)  As you know that every Qmake project is defined in a *.pro file, this means with a subdirs project basically you are only managing these multiple *.pro files (called subprojects) using a single *.pro file (called subdirs project), that lets you create multiple binary for each of the subprojects.  
</p>
<h3>Creating Subdirs Project<br/>
</h3>
<p>
To create a subdirs project, choose Other Project-&gt;Subdirs Project from the available project template.
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/Screen%20Shot%202014-02-27%20at%205.20.21%20AM.png" alt="Subdirs Project of QtCreator"/>
<p>
Subdirs Project of QtCreator
</p>
</div>
<p>
 
</p>
<p align="justify">
In the final page of the Subdirs Project you'll be asked to start Adding Subprojects. Click this button. But in doing so, QtCreator will prompt you to create a new Qt project that will reside in subdirectory of this Subdirs project (Yeah, the meaning of subdirs project is preserve this way). As we already have our existing Qt Widgets project from earlier section and an existing Unittest project from earlier article, we will have to dismiss this add new project dialog. Click Cancel, and QtCreator will return you to the editor of your new subdirs project *.pro file. Here we will add our own *.pro files, using these configuration:
</p>
<p align="justify">
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre>TEMPLATE <span>=</span> subdirs
 
SUBDIRS +<span>=</span> Pythonthusiast \
           Unittest
 
Pythonthusiast.<span>file</span> <span>=</span> src/Pythonthusiast.<span>pro</span>
Unittest.<span>file</span> <span>=</span> <span>test</span>/Unittest.<span>pro</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
In my project configuration, I create two subdirectory : <code>src</code> and <code>test</code>. All of our application source code will be placed in <code>src</code> directory, while all the test related source code will be placed in <code>test</code> directory. Before saving this new subdirs *.pro file, you will have to copy all of our previous Pythonthusiast (or whatever you name your Qt Widgets application earlier) to this src directory. For the <code>Unittest</code> project, except for the <code>Unittest.pro</code> file and <code>TestCase01.cpp</code> that goes to <code>test</code> directory, all other source code (<code>auth.*</code> and <code>helper.*</code>) are also goes to <code>src</code> directory. This is because we are going to use these two files as part of Pythonthusiast project. We will need to really authenticate our users, right?
</p>
<p align="justify">
Save it, and QtCreator will automatically list all of subprojects defined in this *.pro file. Pretty neat, eh?
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/Screen%20Shot%202014-02-27%20at%205.56.20%20AM.png" alt="Subdirs Project with Two Subprojects"/>
<p>
Subdirs Project with Two Subprojects
</p>
</div>
<p align="justify">
With this configuration, you can automatically build all of Subprojects binary easily, or you can also build and run each of subprojects manually. The usual case is that, you will frequently work with core features of the application and test them by running Unittest project. 
</p>
<p align="justify">
Finally, as we modify our Unittest project files location, we have to reflect this changes in the existing <code>Unittest.pro</code> file, using these configuration:
</p>
<p align="justify">
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td><pre>QT +<span>=</span> testlib sql
TEMPLATE <span>=</span> app
TARGET <span>=</span> Unittest
DEPENDPATH +<span>=</span> .
<span>INCLUDEPATH</span> +<span>=</span> .
<span>CONFIG</span>   -<span>=</span> app_bundle
 
<span># Input</span>
HEADERS +<span>=</span> \
    ../src/helper.<span>h</span> \
    ../src/auth.<span>h</span>
SOURCES +<span>=</span> TestCase01.<span>cpp</span> \
    ../src/helper.<span>cpp</span> \
    ../src/auth.<span>cpp</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
In the above configuration, we point HEADERS and SOURCES to the correct location of our <code>auth.*</code> and <code>helper.*</code> file. The similar modifications (adding <code>auth.*</code> and <code>helper.*</code>) must also be made into <code>Pythonthusiast.pro</code> file as follows:
</p>
<p align="justify">
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td><pre>SOURCES +<span>=</span> main.<span>cpp</span>\
        mainwindow.<span>cpp</span> \
    logindialog.<span>cpp</span> \
    auth.<span>cpp</span> \
    helper.<span>cpp</span>
 
HEADERS  +<span>=</span> mainwindow.<span>h</span> \
    logindialog.<span>h</span> \
    auth.<span>h</span> \
    helper.<span>h</span></pre></td></tr></tbody></table>
<p> 
</p>
<h3>Modifying Pythonthusiast Project to Use The Existing Authentication Feature
</h3>
<p align="justify">
As we have already made <code>auth.*</code> and <code>helper.*</code> available in our Pythonthusiast project, now we can easily use them (and feel safe because it is already test-proof). Our task will come into two part : 
</p>
<div align="justify">
<ol>
	<li>Connecting to the database <br/>
	We simply call <code>Helper::dbConnect()</code> in <code>main.cpp</code> to open our database connection. Beware that, in certain application this behaviour may not appropriate. For example, what if our application connect to a networked PostgreSQL database and the network is not available? Our application will behave not as expected for sure and confuse user. But, as we use a local and created on the fly SQLite database, this will not pose this kind of issue. The database will always be available.  </li>
	<li>Authenticate user credentials <br/>
	We simply replace the logic of checking the entered user credentials by using our test-proof <code>Auth::doLogin</code> method <br/>
	
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
</pre></td><td><pre><span>if</span><span>(</span>auth.<span>doLogin</span><span>(</span>ui-<span>&gt;</span>txtUsername-<span>&gt;</span>text<span>(</span><span>)</span><span>,</span> ui-<span>&gt;</span>txtPassword-<span>&gt;</span>text<span>(</span><span>)</span><span>)</span><span>)</span>
            <span>{</span> ... <span>}</span> </pre></td></tr></tbody></table>
<p/></li>
</ol>
<p>
Done. <img src="http://www.pythonblogs.com/js/tinymce/plugins/emotions/images/smiley-smile.gif" border="0" alt="Smile" title="Smile"/>
</p>
<p>
We have create a solid and fully functional (but not yet complete) C++ Qt MainWindow application. In the next section, we will have a hands-on on how to create the same application in PyQt/PySide. Almost all of the C++ code can be directly translated to the Python version, but without the aid of the same level comfortable develoment feature that QtCreator provided. 
</p>
<ol>
</ol>
</div>
<h2>Developing Qt Widgets Application with PyQt 
</h2>
<h4>General Guide on Developing Qt Application Using Python
</h4>
<p align="justify">
Foreword warning : so far, there is no Python IDE equivalent in Qt development features compare to QtCreator. You will have to go back and forth between your Python IDE and QtDesigner to design application GUI interfaces, manually issue all counterpart command line utility of <code>uic</code> (import QtDesigner *.ui file into Python *.py code) and <code>rcc</code> (import Qt resource file *.qrc into Python *.py file) in its PyQt/PySide version and  connect manually all your signal widgets to slot function. It lead me to think that, if there is no strict Python requirement in your Qt project,  just use C++. Live can be so much easier. Or, in another perspective, imagine if someday they make Python support directly accessible in QtCreator. Now that's a simple life... 
</p>
<p align="justify">
Anyway, in this PyQt project (and the later PySide version) we are going to use <a href="http://www.jetbrains.com/pycharm/download/‎">PyCharm Community Edition</a> for Mac OS X as our Python IDE. It's a great IDE, despite its lack of tight support in PyQt/PySide application development. But then again, there is no Python IDE having that kind of support... So, PyCharm CE suit us just well... 
</p>
<h3>Creating A PyQt Project in PyCharm
</h3>
<p align="justify">
Well, it's actually a regular Python project. Nothing special. Click File-&gt;New Project and choose your appropriate Python interpreter (don't worry adding one can be trivially done using PyCharm, just click on that little ellipsis button on the right of Python interpreter combo box)
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/Screen%20Shot%202014-02-27%20at%209.26.27%20AM.png" alt="Create a new Python project"/>
<p>
Create a new Python project
</p>
</div>
<p align="justify">
Okay, what do you get? Just a plain Python project with nothing in it.. <img src="http://www.pythonblogs.com/js/tinymce/plugins/emotions/images/smiley-laughing.gif" border="0" alt="Laughing" title="Laughing"/> To mimic our C++ Qt project, right click on the root Project node (or simply click File-&gt;New) and choose Python file. Gives it the name <code>main</code>. As previously we already finished our <code>main.cpp</code>, here we will simply translate its into Python code. It really is straightforward. Have a try on this process!
</p>
<p align="justify">
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td><pre><span>import</span> <span>sys</span>
<span>from</span> PyQt4.<span>QtGui</span> <span>import</span> QApplication
<span>from</span> logindialog <span>import</span> LoginDialog
<span>from</span> mainwindow <span>import</span> MainWindow
<span>import</span> helper
 
<span>if</span> __name__ <span>==</span> <span>"__main__"</span>:
    a <span>=</span> QApplication<span>(</span><span>sys</span>.<span>argv</span><span>)</span>
    helper.<span>dbConnect</span><span>(</span><span>)</span>
 
    loginDialog <span>=</span> LoginDialog<span>(</span><span>)</span>
 
    isAuth <span>=</span> <span>False</span>
    result <span>=</span> -<span>1</span>
    <span>while</span> <span>not</span> isAuth:
        result <span>=</span> loginDialog.<span>exec_</span><span>(</span><span>)</span>
        <span>if</span> result <span>==</span> LoginDialog.<span>Success</span> <span>or</span> result <span>==</span> LoginDialog.<span>Rejected</span>:
            isAuth <span>=</span> <span>True</span>
        <span>else</span>:
            isAuth <span>=</span> <span>False</span>
 
 
    <span>if</span> result <span>==</span> LoginDialog.<span>Success</span>:
        w <span>=</span> MainWindow<span>(</span><span>)</span>
        w.<span>show</span><span>(</span><span>)</span>
        a.<span>exec_</span><span>(</span><span>)</span>
 
    <span>sys</span>.<span>exit</span><span>(</span>-<span>1</span><span>)</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
Surely Python will complains a lot if you try to run this <code>main.py</code> file (CTRL+SHIFT+R). Beside copying all previous *.py file from our Unittest project (<code>auth.py</code>, <code>helper.py</code> and <code>test_features01.py</code>) to this project directory, we will also need to  prepare <code>mainwindow.py</code> and <code>logindialog.py</code> which are classes derived from generated class from its respective *.ui files. Lets see how it is done using PyQt.
</p>
<h3>Developing LoginDialog Interface
</h3>
<p align="justify">
If previously we can easily create Qt Designer Form Class from within QtCreator itself, now the case is different with PyQt. You will have to manually run QtDesigner (hit ⌘ + SPACE and type Designer), create new Qt Designer Form, design it as you would in QtCreator and finally save it in your PyQt project directory. After that, you will have to open a terminal, and manually issue this command : <code>pyuic4 logindialog.ui -o ui_logindialog.py</code>. Have a look at this automatically generated Python file. It contains <code>UI_LoginDialog</code> class that will construct our LoginDialog GUI. I use the pattern <code>ui_*</code> in the generated Python file, as it is also the pattern use by QtCreator when generating *.cpp from *.ui files (have a look at your C++ Qt project shadow build folder!). 
</p>
<p align="justify">
Finally, (yes, sorry, there is still one final task must be done), you will have to subclass this <code>UI_LoginDialog</code> class in a new class named <code>LoginDialog</code> and saved it in a file named <code>logindialog.py</code>. It is in this class, that you finally develop your LoginDialog behaviour. Inspect this LoginDialog code snippet:
</p>
<p align="justify">
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td><pre><span>class</span> LoginDialog<span>(</span>QDialog<span>,</span> Ui_LoginDialog<span>)</span>:
    Success<span>,</span>Failed<span>,</span>Rejected <span>=</span> <span>range</span><span>(</span><span>0</span><span>,</span><span>3</span><span>)</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>)</span>:
        QDialog.<span>__init__</span><span>(</span><span>self</span><span>)</span>
        <span>self</span>.<span>setupUi</span><span>(</span><span>self</span><span>)</span>
        QtCore.<span>QObject</span>.<span>connect</span><span>(</span><span>self</span>.<span>buttonBox</span><span>,</span> QtCore.<span>SIGNAL</span><span>(</span>_fromUtf8<span>(</span><span>"accepted()"</span><span>)</span><span>)</span><span>,</span> <span>self</span>.<span>onAccept</span><span>)</span>
        QtCore.<span>QObject</span>.<span>connect</span><span>(</span><span>self</span>.<span>buttonBox</span><span>,</span> QtCore.<span>SIGNAL</span><span>(</span>_fromUtf8<span>(</span><span>"rejected()"</span><span>)</span><span>)</span><span>,</span> <span>self</span>.<span>onReject</span><span>)</span>
 
    <span>def</span> onAccept<span>(</span><span>self</span><span>)</span>:
        auth <span>=</span> Auth<span>(</span><span>)</span>
        <span>if</span> auth.<span>doLogin</span><span>(</span><span>str</span><span>(</span><span>self</span>.<span>txtUsername</span>.<span>text</span><span>(</span><span>)</span><span>)</span><span>,</span> <span>str</span><span>(</span><span>self</span>.<span>txtPassword</span>.<span>text</span><span>(</span><span>)</span><span>)</span><span>)</span>:
            <span>self</span>.<span>setResult</span><span>(</span><span>self</span>.<span>Success</span><span>)</span>
        <span>else</span>:
            msgBox <span>=</span> QMessageBox<span>(</span><span>self</span><span>)</span>
            msgBox.<span>setIcon</span><span>(</span>QMessageBox.<span>Warning</span><span>)</span>
            msgBox.<span>setWindowTitle</span><span>(</span>_translate<span>(</span><span>"LoginDialog"</span><span>,</span> <span>"Pythonthusiast"</span><span>,</span> <span>None</span><span>)</span><span>)</span>
            msgBox.<span>setText</span><span>(</span>_translate<span>(</span><span>"LoginDialog"</span><span>,</span> <span>"Either incorrect username and/or password. Try again!"</span><span>,</span> <span>None</span><span>)</span><span>)</span>
            msgBox.<span>setStandardButtons</span><span>(</span>QMessageBox.<span>Ok</span><span>)</span>
            msgBox.<span>exec_</span><span>(</span><span>)</span>
            <span>self</span>.<span>setResult</span><span>(</span><span>self</span>.<span>Failed</span><span>)</span>
 
    <span>def</span> onReject<span>(</span><span>self</span><span>)</span>:
        <span>self</span>.<span>setResult</span><span>(</span><span>self</span>.<span>Rejected</span><span>)</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
Observe that the above class is derived from Qt <code>QDialog</code> class and the previously generated <code>UI_LoginDialog</code> class. In the constructor of this class, we connect particular widgets signal to Python methods that serve as its slot function. Until this point you may already realize how comfortable it is to let QtCreator do these code plumbing for you. Yeah, it'd be wonderful if QtCreator also support Python development in the future..
</p>
<p align="justify">
An important note about Qt *.ui files are, it's a cross platform and language independent code. Meaning, the existing *.ui files that were created for a C++ Qt project, can be reused in another Qt project : either PyQt/PySide. So, if you are following this tutorial as it is, you can copy all your existing *.ui files from the previous C++ Qt project to the PyQt project directory and directly generate *.py files using <code>pyuic4</code> tool.
</p>
<p align="justify">
Great. Now that you have completed our LoginDialog, you can try running the application again. If all goes well, you'll have the same  Qt application as previously developed using C++. 
</p>
<h3>Developing MainWindow Interface
</h3>
<p>
After finishing our LoginDialog, the next step is to polish our MainWindow by adding (as previously done with the C++ version) File-&gt;Exit and Help-&gt;About. Now that you have the knowledge to generate *.py from *.ui files using <code>pyuic4</code> tool, I can directly show you the code for <code>MainWindow</code> class.
</p>
<p>
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td><pre><span>from</span> PyQt4 <span>import</span> QtCore<span>,</span> QtGui
<span>from</span> PyQt4.<span>QtGui</span> <span>import</span> QMainWindow<span>,</span> QMessageBox<span>,</span> QPixmap
<span>from</span> PyQt4.<span>QtGui</span> <span>import</span> QApplication
<span>from</span> ui_mainwindow <span>import</span> Ui_MainWindow
 
<span>class</span> MainWindow<span>(</span>QMainWindow<span>,</span> Ui_MainWindow<span>)</span>:
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>)</span>:
        QMainWindow.<span>__init__</span><span>(</span><span>self</span><span>)</span>
        <span>self</span>.<span>setupUi</span><span>(</span><span>self</span><span>)</span>
        <span>self</span>.<span>actionE_xit</span>.<span>triggered</span>.<span>connect</span><span>(</span><span>self</span>.<span>onExit</span><span>)</span>
        <span>self</span>.<span>action_About</span>.<span>triggered</span>.<span>connect</span><span>(</span><span>self</span>.<span>onAbout</span><span>)</span>
 
    <span>def</span> onExit<span>(</span><span>self</span><span>)</span>:
        msgBox <span>=</span> QMessageBox<span>(</span><span>self</span><span>)</span>
        msgBox.<span>setIcon</span><span>(</span>QMessageBox.<span>Question</span><span>)</span>
        msgBox.<span>setWindowTitle</span><span>(</span>_translate<span>(</span><span>"MainWindow"</span><span>,</span> <span>"Pythonthusiast"</span><span>,</span> <span>None</span><span>)</span><span>)</span><span>;</span>
        msgBox.<span>setText</span><span>(</span>_translate<span>(</span><span>"MainWindow"</span><span>,</span> <span>"Are you sure you want to quit?"</span><span>,</span> <span>None</span><span>)</span><span>)</span>
        msgBox.<span>setStandardButtons</span><span>(</span>QMessageBox.<span>No</span>|QMessageBox.<span>Yes</span><span>)</span>
        msgBox.<span>setDefaultButton</span><span>(</span>QMessageBox.<span>Yes</span><span>)</span>
        msgBox.<span>exec_</span>
        <span>if</span> msgBox.<span>exec_</span><span>(</span><span>)</span> <span>==</span> QMessageBox.<span>Yes</span>:
          QtGui.<span>qApp</span>.<span>quit</span><span>(</span><span>)</span>
 
    <span>def</span> onAbout<span>(</span><span>self</span><span>)</span>:
        msgBox <span>=</span> QMessageBox<span>(</span><span>self</span><span>)</span>
        msgBox.<span>setIconPixmap</span><span>(</span>QPixmap<span>(</span><span>":/images/sherlock.png"</span><span>)</span><span>)</span>
        msgBox.<span>setWindowTitle</span><span>(</span>_translate<span>(</span><span>"MainWindow"</span><span>,</span> <span>"Pythonthusiast"</span><span>,</span> <span>None</span><span>)</span><span>)</span>
        msgBox.<span>setText</span><span>(</span>_translate<span>(</span><span>"MainWindow"</span><span>,</span> <span>"Well Watson, isn't it obvious to you that Qt rocks?"</span><span>,</span> <span>None</span><span>)</span><span>)</span>
        msgBox.<span>setStandardButtons</span><span>(</span>QMessageBox.<span>Ok</span><span>)</span>
        msgBox.<span>exec_</span><span>(</span><span>)</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
Now, what about our <code>app.qrc</code> ? How can we create such file in our PyCharm? Well, as it was just an *.xml file, you can easily  create a new empty file, name it into <code>app.qrc</code>, and manually hand code its content by looking at <code>app.qrc</code> previously created by QtCreator. For your reference, this is the generated by QtCreator (well, actually it was created by QtDesigner embedded inside QtCreator):
</p>
<p align="justify">
</p>
<table class="xml code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
</pre></td><td><pre><span><span>&lt;RCC<span>&gt;</span></span></span>
    <span><span>&lt;qresource</span> <span>prefix</span>=<span>"/images"</span><span>&gt;</span></span>
        <span><span>&lt;file<span>&gt;</span></span></span>sherlock.png<span><span>&lt;/file<span>&gt;</span></span></span>
    <span><span>&lt;/qresource<span>&gt;</span></span></span>
<span><span>&lt;/RCC<span>&gt;</span></span></span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
Pretty easy isn't it? But QtDesigner can create this file for you using one of its pallet : Resource Browser. Try to create a new <code>app.qrc</code> file or use existing one created form the previous C++ Qt project. But still, for each changes in the resource file, you'll have to manually issue the command :  <code>pyrcc4 app.qrc -o app_rc.py</code>. Why the name <code>app_rc.py</code>? Because it's the default name use by QtDesigner when using imported resource file for your GUI in *.ui files. Failed to do so, Python will warn you about this missing file, so you can generate it manually. 
</p>
<p align="justify">
Great. We have finish our Pythonthusiast PyQt application and now we are ready to move on to convert this PyQt application to use PySide. Lets see whether we really don't have to do any other extra works than simply to replace all import of PyQt into PySide. 
</p>
<h2>Developing Qt Widgets Application with PySide </h2>
<h3>Change All PyQt Import Into PySide<br/>
</h3>
<p align="justify">
An important thing to note is, you will eventually ended up using PyQt _or_ PySide. Certainly not both. The first task in converting a PyQt application into PySide is removing all import of PyQt and then change it into PySide. The good news is, using a great Python IDE such as PyCharm will greatly ease us on this process (you don't have to remember PySide equivalent of import statement for particular PyQt import). Simply delete all import statement, wait for a while, go to the first line of Unresolved references problem in your code and then hit CTRL+ENTER. PyCharm will show you the following popup dialog: 
</p>
<p align="justify">
 <img src="http://pythonthusiast.pythonblogs.com/gallery/230/Screen%20Shot%202014-02-27%20at%206.05.05%20PM.png" alt="Automatically fixes all unresolved import"/>
</p>
<p align="justify">
Choose Fix all 'Unresolved references' problems and .. voila! Your PyQt code is safely turn into PySide. Nice, eh?
</p>
<h2>Use PySide Tools instead of PyQt<br/>
</h2>
<p align="justify">
Recall that we need certain PyQt tools to make our Qt specific files (*.ui and *.qrc) available from our Python code. Using PySide certainly will require us to use its own tools. So, instead of using <code>pyuic4</code> to generate *.py from *.ui you, will have to use <code>pyside-uic</code>. And instead of using <code>pyrcc4</code> to generate *.py from *.qrc, you will have to use <code>pyside-rcc</code>. The same usual workflow apply here. Even the command line parameters are the same!  
</p>
<p align="justify">
And that's all that you need to use PySide instead of PyQt... 
</p>
<h2>Prepare For Differences Between PyQt and PySide
</h2>
<h3>Understanding API Level 1 and Level 2 in PyQt </h3>
<p align="justify">
The current PyQt4, was shipped with PyQt API Level 1 and API Level 2. For Python 2.x, it's defaulted to API Level 1. PySide itself is only supporting PyQt API Level 2. This mean, to port PyQt application to PySide as effortless as possible is to use an API Level 2 of PyQt. The important feature in API Level 2 is, there is no Qt QString, QVariant, etc. They automatically converted into Python relevant data types.
</p>
<p align="justify">
An excellent example is our <code>Helper::computeHash()</code> method, shown below:
</p>
<p align="justify">
</p>
<table class="cpp code"><tbody><tr class="li1"><td><pre>1
2
3
4
</pre></td><td><pre>QString Helper<span>::</span><span>computeHash</span><span>(</span>QString original<span>)</span>
<span>{</span>
    <span>return</span> QCryptographicHash<span>::</span><span>hash</span><span>(</span>original.<span>toUtf8</span><span>(</span><span>)</span>,QCryptographicHash<span>::</span><span>Md5</span><span>)</span>.<span>toHex</span><span>(</span><span>)</span><span>;</span>
<span>}</span></pre></td></tr></tbody></table>
<p>
</p>
<p align="justify">
To use a Qt centric code, we use this Python code in PyQt:
</p>
<p align="justify">
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
</pre></td><td><pre><span>def</span> computeHash<span>(</span>original<span>)</span>:
    <span>return</span> QCryptographicHash.<span>hash</span><span>(</span>QString<span>(</span>original<span>)</span>.<span>toUtf8</span><span>(</span><span>)</span><span>,</span> QCryptographicHash.<span>Md5</span><span>)</span>.<span>toHex</span><span>(</span><span>)</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
It really is a 1-on-1 translation from its Qt version, right? But, as you may already know, this Python code wont' run in PySide. It will complained when you do the login process, <code>"argument 1 has unexpected type of 'QString'"</code>. To use a much more Pythonic way, lets convert the above method into this one:
</p>
<p align="justify">
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
</pre></td><td><pre><span>def</span> computeHash<span>(</span>original<span>)</span>:
    <span>return</span> QCryptographicHash.<span>hash</span><span>(</span>original<span>,</span> QCryptographicHash.<span>Md5</span><span>)</span>.<span>toHex</span><span>(</span><span>)</span></pre></td></tr></tbody></table>
<p>
</p>
<p align="justify">
No QString there, and it works just great in PySide. In PyQt? You have to first set its API Level to 2, and it also works flawlessly.
</p>
<p align="justify">
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
</pre></td><td><pre><span>import</span> sip
sip.<span>setapi</span><span>(</span><span>"QString"</span><span>,</span> <span>2</span><span>)</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
This code must come first in the file <code>main.py</code> --or any Python file that start your application. Failed to do so, Python will raised error : <code>ValueError: API 'QString' has already been set to version 1</code>.
</p>
<h3>PySide Failed to Show Non-Native Menubar on OSX</h3>
<p>
 
</p>
<p align="justify">
In this project, I encounter an issue with PySide on OSX where its application menubar won't showing in the application MainWindow, even though I have already set menuBar <code>nativeMenuBar</code> to False. Eventually I found out that the problem lies in the glitch, that PySide still use <code>self.centralWidget = QtGui.QWidget()</code> in <code>ui_mainwindow.py</code> even though <code>nativeMenuBar</code> set to False, where it should be <code>self.centralWidget = QtGui.QWidget(MainWindow)</code> to let the menu bar live inside of application's MainWindow.  You got to manually fix this glitch, after each running of <code>pyside-uic</code>. This case is not happening in PyQt.  
</p>
<p align="justify">
This issue arise because we are developing an application targeting Apple OSX, where it has strict User Interface Guidelines regarding application menu bar to be moved out to OSX unified system menu bar, instead of living in the application MainWindow. However, in this section I opted to still use non-native menu bar, and move the discussion of making an application that conform to user's Operating System to the last article of this series where we will discuss in great length about how to package a C++ Qt/PyQt/PySide application in Windows/OSX/Linux. 
</p>
<p align="justify">
 
</p>
<h2>Conclusion</h2>
<p align="justify">
Phew... This is probably the lengthiest article I've ever written in this site! And if you do read this article until this conclusion section, well, I am pretty sure you have serious problem with enthusiasm in Qt <img src="http://pythonthusiast.pythonblogs.com/js/tinymce/plugins/emotions/images/smiley-laughing.gif" border="0" alt="Laughing" title="Laughing"/> 
</p>
<p align="justify">
There are two more articles that I would like to write in this series : Part 6 about developing this Pythonthusiast application as a Qt application that talk to a back-end Django API (that get designed and built with <a href="http://apiary.io">Apiary.io</a>) and Part 7 about packaging these Qt application into its native independent distribution format (using <a href="http://www.py2exe.org">py2exe</a> for Windows and <a href="http://pythonhosted.org/py2app">py2app</a> for OSX). But, as I think those two articles can be viewed as an independent articles, hereby I wrap up these series into five parts, making this article as the last one in this series.
</p>
<p align="justify">
As always, you can download the current state of the application here : <a href="https://www.dropbox.com/sh/t4r9zq0a56xxutk/Cd_0Uzbk5O/Cross%20Platform%20Qt%20using%20C%2B%2B%2C%20PyQt%20or%20PySide/crossplatformqt-5.zip">crossplatformqt-4.zip</a>
</p>
<p align="justify">
Or, follow its Github repository here : <a href="https://github.com/pythonthusiast/CrossPlatformQt">pythonthusiast/CrossPlatformQt</a>.
</p>
<p align="justify">
Stay tuned for my subsequent article!
</p>
<p align="justify">
PS : And I do apologize for bringing this article so late (it' been two week since my last article!). I think I've been cursed by the <em>God of Perfection</em> when saying similar things with,<em> "In this article I will talk about how to develop Qt application using either C++, PyQt or PySide"</em>. Well, there you go.. A complete (I hope so) practical hands-on on those three technologies. 
</p>


                

            </div>

            </div></body></html>