<html><body><div><div class="content html_format"><p>
      Я много работаю с данными, поэтому практически все процессы у меня завязаны на Jupyter (IPython Notebook). Эта среда прекрасна и я её большой фанат. По сути, Jupyter — это обычная питоновая консоль и весь код там выполняется последовательно. Но иногда возникает желание запустить вычисления в ячейке и, не дожидаясь пока они закончатся, продолжить работу. Например, нужно скачать 1000 урлов и достать у них заголовки страниц. Хорошо бы запустить процесс скачивания и сразу начать отлаживать код для выделения заголовков.</p>
<p>
Это должно выглядеть примерно так:

</p><img src="https://habrastorage.org/files/dee/963/bbd/dee963bbd3b347fa90c497f882571e39.gif"/>
<p>
Удивительно, но готового способа так сделать я не нашёл и хотел бы поделиться простым, но удобным вариантом решения.
</p><a name="habracut"/><p>
Теперь из проекта в проект у меня кочует следующий кусочек кода:

</p><pre><code class="python">def jobs_manager():
    from IPython.lib.backgroundjobs import BackgroundJobManager
    from IPython.core.magic import register_line_magic
    from IPython import get_ipython

    jobs = BackgroundJobManager()

    @register_line_magic
    def job(line):
        ip = get_ipython()
        jobs.new(line, ip.user_global_ns)

    return jobs
</code></pre><p>
В нём используется встроенный в Jupyter модуль IPython.lib.backgroundjobs — надстройка над threading, которая ведёт учёт фоновых операций. Метод хорошо сочетается c </p><a href="https://habrahabr.ru/post/276725/#first_unread">виджетным прогресс-баром, о котором я недавно писал</a><p>. Типичный пример использования:

</p><img src="https://habrastorage.org/files/9ed/bf0/1d6/9edbf01d60a246159b551fb50d0a32e7.gif"/>
<p>
Посмотреть состояние операций можно через метод status:

</p><img src="https://habrastorage.org/files/16b/b9d/fe5/16bb9dfe532f4442ae6c10958607b87b.gif"/>
<p>
Чтобы убить операцию, используется специальный хак:

</p><pre><code class="python">def kill_thread(thread):
    import ctypes
    
    id = thread.ident
    code = ctypes.pythonapi.PyThreadState_SetAsyncExc(
        ctypes.c_long(id),
        ctypes.py_object(SystemError)
    )
    if code == 0:
        raise ValueError('invalid thread id')
    elif code != 1:
        ctypes.pythonapi.PyThreadState_SetAsyncExc(
            ctypes.c_long(id),
            ctypes.c_long(0)
        )
        raise SystemError('PyThreadState_SetAsyncExc failed')
</code></pre><p>
Например так:

</p><img src="https://habrastorage.org/files/b08/c1b/9ae/b08c1b9aef084f52bfbcb671dc84c34f.gif"/>
<p>
jobs также копит стектрейсы (kill_thread кидает SystemError внутри треда):

</p><img src="https://habrastorage.org/files/c16/c00/efc/c16c00efc4ab4622acb03c43372e8774.gif"/>
<p>
%job можно даже использовать как альтернативу multiprocessing.dummy.Pool:

</p><img src="https://habrastorage.org/files/75f/dbd/93b/75fdbd93bdf64e3c99ecfbe0bf9181bb.gif"/>
<p>
Нарезать последовательность на заданное количество кусочков удобно функцией:

</p><pre><code class="python">def get_chunks(sequence, count):
    count = min(count, len(sequence))
    chunks = [[] for _ in range(count)]
    for index, item in enumerate(sequence):
        chunks[index % count].append(item) 
    return chunks
</code></pre><p>
Завершить работу пула можно так:

</p><img src="https://habrastorage.org/files/e05/656/472/e056564721ca45c9bf5b9033fc0e2f91.gif"/>
<p>
У метода есть ряд ограничений:

</p><ol>
<li>%job работает на тредах, поэтому нужно помнить про GIL. %job — это не про распараллеливание тяжелых вычислений, которые происходят в питоновом байт-коде. Это про IO-bound операции и вызов внешних утилит.</li>
<li>Нельзя нормально завершить произвольный код внутри треда, поэтому в kill_thread используется хак. Этот хак работает не всегда. Например, если код внутри треда выполняет sleep исключение, которое кидает kill_thread игнорируется.</li>
<li>Код в %job выполняется через eval. Грубо говоря, можно использовать выражения, который могут встречаться после знака =. Никаких print и присваиваний. Впрочем, всегда можно завернуть сложный код в функцию и выполнить %job f().</li>
<li>Передача сообщений из %job выполняется через жёсткий диск. Например, нельзя непосредственно получить содержание скачанной страницы, нужно его сохранить на диск, а потом прочитать.</li>
</ol><p>
Код распространяет копипейстом и </p><a href="https://github.com/alexanderkuk/parallel-cell">доступен на Гитхабе</a><p>.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>