<html><body><div><div class="wall_post_text"><a href="/feed?section=search&amp;q=%23python">#python</a> <a href="/feed?section=search&amp;q=%23pynsk">#pynsk</a><p>Таинство стандартной библиотеки: functools.lru_cache — кэшируем результат выполнения функции</p><p>Начиная с версии 3.2, в Python появилась возможность стандартными средствами организовать мемоизацию. Иными словами, кэшировать результаты вызова функции. Этот механизм представлен в виде декоратора в модуле functools и называется lru_cache (least recently used cache).</p><p>На примере изъезженных чисел Фибоначчи это выглядит так:</p><p>@lru_cache(maxsize=None)</p><p>def fib(n):</p><p>    if n &lt; 2:</p><p>        return n</p><p>    return fib(n-1) + fib(n-2)</p><p>»&gt; [fib(n) for n in range(16)]</p><p>[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]</p><p>»&gt; fib.cache_info()</p><p>CacheInfo(hits=28, misses=16, maxsize=None, currsize=16)</p><p>Схема вычисления числа Фибоначчи для 6 без кэша:</p><a href="/away.php?to=https%3A%2F%2Fupload.wikimedia.org%2Fwikibooks%2Fru%2Fd%2Fdc%2FFibtree.jpg&amp;post=-96469126_565" target="_blank" title="https://upload.wikimedia.org/wikibooks/ru/d/dc/Fibtree.jpg">https://upload.wikimedia.org/wikibooks/ru/d/dc/Fibtre..</a><p>Легко заметить, что есть повторяющиеся поддеревья, которые можно заново не вычислять. Однако, если у нас нет кэша, то куча времени уйдет на вычисление уже известных значений. Декоратор @lru_cache добавляет кэш необходимого размера (по умолчанию ёмкостью в 128 результатов), тем самым позволяя ускорить исполнение кода. </p><p>Ссылка для изучения:</p><a href="/away.php?to=https%3A%2F%2Fdocs.python.org%2F3.4%2Flibrary%2Ffunctools.html&amp;post=-96469126_565" target="_blank">https://docs.python.org/3.4/library/functools.html</a></div></div></body></html>