<html><body><div><div class="post-body entry-content" id="post-body-7571634751973719984" itemprop="description articleBody">
<p>
The </p><i>Summer of Code</i><p> is approaching its end and it has been an amazing experience for me. Not only this, but I also approach the end of my masters thesis which for me was on of the main goals for the last five years. The sad story is that I most likely are not able to participate as a student in the future.
</p><p>
It has been a really great time for me, and for anyone feeling unsure of applying or not, I can warmly recommend to try.

</p><span>PyPy's vectorizing optimizer</span>
<p>
So what is the outcome of my GSoC? Let's quickly have a look on what I proposed:

</p><i><span class="anchor" id="line-2"><span class="anchor" id="line-11"><span class="anchor" id="line-12"><span class="anchor" id="line-18"><span class="anchor" id="line-19"><span class="anchor" id="line-42"><span class="anchor" id="line-43"><span class="anchor" id="line-49"><span class="anchor" id="line-50">The
 goal of this project is to enhance the trace optimizer of PyPy. By 
definition NumPy arrays are unboxed, homogeneous (one data type) and 
continuous in memory (despite certain exceptions). The same is true for 
the array module in the standard library. The new optimizer will use 
this opportunity and exploit a SIMD instruction set (such as SSE,AVX) 
present on modern CISC processors (e.g. x86). This should lead to 
enhanced execution speed for arithmetic intensive applications that run 
on top of PyPy.</span></span></span></span></span></span></span></span></span></i>
<p>
I have already showed that individual traces get faster when the optimization is turned on. But that does not necessarily mean programs get faster. The optimization only helps if your program spends a significant fraction of time in the trace loop that is vectorizable.
</p><p>
The following shows the basic NumPy operations stressed. In a loop the NumPy operations are executed 1000 times. This sample program shows the basic setup of multiply-float64:

</p><span>def bench (vector_a, vector_b):<br/>    for i in range(1000):<br/>        numpy.multiply(vector_a, vector_b, out=vector_a)</span>
<p>
The speedup (bigger is better) show the theoretical maximum speedup (this is bounded because of the way SIMD works) and what is achieved by the optimization. The base line is the portable </p><a href="https://bitbucket.org/squeaky/portable-pypy/downloads/pypy-2.6-linux_x86_64-portable.tar.bz2">PyPy version 2.6.0</a><p> (none of the code I changed is included in this version). The version of Vector speedup is a026d96015e4.
</p>

<p>
Considering that currently aligned memory load cannot be used I think this is a pretty good result. For float64 multiply the maximum speedup is nearly reached. float32 performs very poorly because the JIT currently does not operate on float32, but always casts to float64, executes the arithmetic and casts back to float32.
</p><a href="https://www.blogger.com/blogger.g?blogID=2146898305247054645" imageanchor="1"/><a href="https://www.blogger.com/blogger.g?blogID=2146898305247054645" imageanchor="1"/><a href="https://www.blogger.com/blogger.g?blogID=2146898305247054645" imageanchor="1"/>
<a href="https://www.blogger.com/blogger.g?blogID=2146898305247054645" imageanchor="1"/><a href="https://www.blogger.com/blogger.g?blogID=2146898305247054645" imageanchor="1"/><a href="https://www.blogger.com/blogger.g?blogID=2146898305247054645" imageanchor="1"/><p>Let's run some real programs. SOM (Self Organizing Maps) is an algorithm to map N dimensions onto a 2d grid. It contains a lot of vector distances and vector operations. Dot is the matrix dot product and wdist is the weighted euclidean distances. The number in the benchmark name indicates the size of the vector register.

</p>


<p>
As you can see, bigger vectors are better for the optimization. The cool thing is that PyPy is now able connect trace trees that use SIMD operations which is not possible if the numerical kernels are written in e.g. C. Again I think the results are pretty cool and speedup should get even more crazy if AVX is implemented in the JIT backend.

</p><span>Non NumPy traces</span>
<p>
At the beginning it was a bit unclear if this is possible, but let me show you a very basic example of a Python program where the optimization creates a very good piece of assembler.

</p><span># arrayloop.py </span>
<span>import array
</span>
<span>w = array.array('d',[0]*10000) </span>
<span>l = array.array('d',[1]*10000)</span>
<span>def f(): </span>
<span>    i = 0 </span>
<span>    while i &lt; 10000: </span>
<span>        l[i] = l[i] + w[i] </span>
<span>        i += 1
</span>
<span><br/></span>
<span>for i in range(100000): </span>
<span>    f()
</span>

<span>$ time ./pypy-c --jit vec_all=1 ~/arrayloop.py </span>
<span>0.67user 0.01system 0:00.69elapsed 99%CPU</span>
<span>$ time ./pypy-c --jit vec_all=0 ~/arrayloop.py </span>
<span>1.65user 0.01system 0:01.67elapsed 99%CPU</span>
<p>
Boom. 1.65 / 0.67 = ~2.45 times faster. This is not super scalar because of some caching issues, but because it does less guard checking (all array bound checks are only checked once).
</p><p>
If you happen to be into PyPy, you know that the list strategy (e.g. [42.0] * 44) will not store Python objects, but store double floating points directly in memory. When the first non floating point value is stored into the array, it is transformed into a list of Python objects. Perfect! This makes it even possible to let the optimization run on loops that manipulate lists.
</p><p>
Unfortunately this is currently not possible, because there are some fragments in the trace that the optimizer cannot transform. We are working on it and the next major PyPy update might contain this as well!

</p><span>Stats</span>
<p>
It spans over at least seven files and needs about &gt; 3000 lines of code. The test suite covers roughly &gt; 4000 lines in five files. This is the newly added code in grand total. It excludes every line that I have changed in the existing source base.

</p><span>Does this only work for PyPy?</span>

<span>If I have put the same effort into a different virtual machine, it would have been tied to the language and the virtual machine only.</span>

<p>
<span><i><span>That would be lame right?</span></i> </span></p>

<span>But (you might be aware of this) any language interpreter written in RPython can reuse the tracing JIT compiler. That means that ``magically'' this optimization is added to the final executable by default. </span>

<span>At this point it should be said that programs will not automatically get faster, there are some rules your traces must obey. But this is easy. Much more easier than writing assembler or using compiler intrinsics. </span>

<span>This is great because if you want to write an array processing language in RPython, you gain all the features it already provides and get to use SSE4.1 (for now) to speed up your programs</span>

<span>Final words</span>
<p>
I plan to further work on PyPy and I think soon this project will be finally merged into default. We have talked about it to include it in the upcomming 2.6.1 release, but there are other greate changes comming to enhance the trace compiler it was postponed. 

</p><i><b>Thank you PyPy Team, thank you Google &amp; PSF! I had a great time tinkering on my proposal.</b></i>
<p/>
</div>
</div></body></html>