<html><body><div><div class="post-body entry-content" id="post-body-8436310994234909389" itemprop="description articleBody">
<i>This article describes a Python annotation which combines documentation with type checking in order to help Python developers to gain better understanding and control of the code, whilst allowing them to catch mistakes on the spot, as soon as they occur.</i>
<p>
Being a Java developer previously but extradited to Python by my own choice, I sometimes feel some nostalgy from the old times, when the Java compiler used to tell me all sorts of stupidities I used to do.
</p><p>
In the Python world no one is stupid obviously, except probably me who many times find myself passing wrong types of arguments by accident or by pure stupidity, in case you accept the hypothesis that there's any difference between the two situations.
</p><p>
When you are coding your own stuff, chances are that you know very well what is going on. In general, you have the entire bloody API alive and kicking inside your head. But when you are learning some third party software, in particular large frameworks, chances are that your code is called by </p><i>something</i><p> you don't understand very well, which decides to pass arguments to your code which you do not have a clue what they are about.


</p><span>Documentation</span>
<p>
Documentation is a good way of sorting out this difficulty. Up-to-date documentation, in particular, is the sort of thing I feel extremely happy when I have chance to find one. My mood is being constantly crunched these days, if you understand what I mean.
</p><p>
Outdated documentation is not only useless but also undesirable. Possibly for this reason some (or many?) people prefer no documentation at all, since absence of information is better than misinformation, they defend.
</p><p>
It's very difficult to keep documentation up-to-date, unless you are forced somehow to do so. Maybe at gun point?


</p><span>Strong type checking</span>
<p>
I'm not in the quest of convincing anyone that strong type checking is good or useful or desirable.  Like everything in life, there are pros and cons.
</p><p>
On the other hand, I'd like to present a couple of benefits which keep strong type checking in my wishlist:
</p><p>
* I'd like to have the ability to stop the application as soon as a wrong type is received by a function or returned by a function to its caller. Stop early, catch mistakes easily, immediately, on spot.
</p><p>
* I'd like to identify and document argument types being passed by frameworks to my code, easily, quickly, effectively, without having to turn the Internet upside down every time I'm interested to learn what the hell argument </p><i>x</i><p> is about.


</p><span>Introducing sphinx_typesafe</span>
<p>
Doing a bit of research, I found an interesting library called </p><i>IcanHasTypeCheck</i><p> (or ICHTC for short), which I ended up rewriting almost from scratch during the last revision and I've renamed it to </p><i>sphinx_typesafe</i><p>.
</p><p>
Let me explain the idea:
</p><p>
In the </p><i>docstring</i><p> of a function or method, you employ </p><i>Sphinx</i><p>-style documentation patterns in order to tell types associated to variables.
</p><p>
If your documentation is pristine, the number of arguments in the documentation match the number of arguments in the function or method definition.
</p><p>
If your logic is pristine, the types of arguments you documented match the types of arguments actually passed to the function or method at runtime, or returned by the function or method to the caller, at runtime.
</p><p>
You just need to add an annotation </p><i>@typesafe</i><p> before the function or method, and </p><i>sphinx_typesafe</i><p> checks if the documentation matches the definition.
</p><p>
If you don't have a clue about the type of an argument, simply guess some unlikely type, say: </p><i>None</i><p>. Then run the application and </p><i>sphinx_typesafe</i><p> will interrupt the execution of it and report that the actual type does not match </p><i>None</i><p>. The next step is obviously substitute </p><i>None</i><p> by the actual type. 


</p><span>Benefits</span>
<p>
A small example tells more than several paragraphs.</p><p>
Imagine that you see some code like this:

</p><span>    import math<br/>
    <br/>
    def d(p1, p2):<br/>
        x = p1.x - p2.x<br/>
        y = p1.y - p2.y<br/>
        return math.sqrt(x*x + y*y)</span>

<p>
Imagine that you had type information about it, like this:


</p><span>    import math<br/>
    from sphinx_typesafe import typesafe<br/>
<br/>
    @typesafe<br/>
    def d(p1, p2):<br/>
        """<br/>
        :type p1: shapes.Point<br/>
        :type p2: shapes.Point<br/>
        :rtype  : float<br/>
        """<br/>
        x = p1.x - p2.x<br/>
        y = p1.y - p2.y<br/>
        return math.sqrt(x*x + y*y)</span>
<p>
Now you are able to understand what this code is about, quickly!.</p><p>
In particular, you are able to tell what it is the domain of types this code is intended to operate on.
</p><p>
When you run this code, if this function receives a </p><i>shapes.Square</i><p> instead of a </p><i>shape.Point</i><p>, it would stop immediately. Notice that, eventually, a </p><i>shape.Square</i><p> may have components </p><i>x</i><p> and </p><i>y</i><p> which would make the function return wrong results silently. Imagine your test cases catching this situation!
</p><p>
So, I hope I demonstrated the two benefits I was interested on.



</p><span>Missing Features</span>


<b><span>Polymorphism</span></b>
<p>
Sometimes I would like to tell that an argument can be a </p><i>file</i><p> but also a </p><i>str</i><p>. At the moment I can say that the argument can be </p><i>types.NotImplementedType</i><p> meaning "any type". But I would like something more precise, like this:

</p><span>    :type f: [file, str]</span>
    <p>
This is not difficult to implement, actually, but we are not there yet.


</p><b>Non intrusive</b>
<p>
I would like to have a non intrusive way to </p><i>turn on</i><p> type checking and a very cheap way of </p><i>turning off</i><p> type checking, if possible without any code change.
</p><p>
Thinking more about use cases, I guess that type checking is very useful when you are developing and, in particular, when you are running your test suite. You are probably not interested on having the overhead of type checking on production code which was theoretically exhaustively tested.
</p><p>
Long story short, I would like to integrate </p><i>sphinx_typesafe</i><p> with </p><i>pytest</i><p>, so that an automatic decoration of functions and methods would happen </p><i>automagically</i><p> and without any code change.
</p><p>
If </p><i>pytest</i><p> finds a docstring which happens to contain a Sphinx-style type specification on it, </p><i>@typesafe</i><p> is applied to the function or method. That would be really nice! You could also run your code in production without type checking since type checking was never turned on in the first place. 
</p><p>
The idea looks to be great, but my ignorance on </p><i>pytest</i><p> internals and my limited time prevents me of going ahead. Maybe in future!


</p><b>Python3 support</b>
<p>
The sources of </p><i>sphinx_typesafe</i><p> itself are ready for Python3, but </p><i>sphinx_typesafe</i><p> does not handle properly your sources written in Python3 yet. It's not difficult to implement, actually: it's just a matter of adjusting one function, but we are not there yet. Maybe you feel compelled to contribute?


</p><span>More Information </span>

<a href="https://pypi.python.org/pypi/sphinx_typesafe">https://pypi.python.org/pypi/sphinx_typesafe</a>


<span>Credits</span>
<p>
Thank Klaas for inspiration and his </p><i>IcanHasTypeCheck</i><p> (or ICHTC for short).
</p><p/>
</div>
</div></body></html>