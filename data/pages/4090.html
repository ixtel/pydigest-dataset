<html><body><div><div class="section">
              <h1>contex 3.1.1</h1>

              


<p>Contextual string manipulation</p>








<div id="abstract">
<h2>Abstract</h2>
<p>This package provides <tt>contex.rules</tt>, an interface which enables a very declarative form of string
manipulation, where you can manipulate a string “in one go” in sophisticated ways.</p>
<p>This library also provides two related abstractions, <tt>StringContext</tt> and <tt>MatchContext</tt>, which
can be used for a more stateful manipulation of strings. I recommend using <tt>contex.rules</tt> as I
think that makes for more readable code. Nevertheless, those abstractions are well
documented and might usefully serve as building blocks. Indeed, <tt>contex.rules</tt> is implemented on
top of them.</p>
</div>
<div id="the-problem-with-our-interfaces-for-string-manipulation">
<h2>The problem with our interfaces for string manipulation</h2>
<p>My motivation for creating this package was that I was assigned a task in which it was necessary to
change strings such as <tt><span class="pre">'1_Photo032-2008.jpg'</span></tt> into <tt><span class="pre">'1_Photo031-2008.jpg'</span></tt>. All the numbers could vary
between filenames, and it seemed like I always had to do something inelegant to accomplish this task. Maybe
it was to match the various parts and stich them back together:</p>
<pre><span class="o">&gt;&gt;&gt;</span> <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s1">'(\d+)_Photo(\d+)-(\d+)\.jpg'</span><span class="p">,</span> <span class="s1">'1_Photo032-2008.jpg'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s1">'{}_Photo{}-{}.jpg'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">'{:0&gt;3}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="s1">'1_Photo031-2008.jpg'</span>
</pre>
<p>Or using <tt>re.sub</tt> with non-consuming regex groups to match the correct area of the string:</p>
<pre><span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">'(\d+)(?=-\d+\.jpg)'</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="s1">'{:0&gt;3}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="s1">'1_Photo032-2008.jpg'</span><span class="p">)</span>
<span class="s1">'1_Photo031-2008.jpg'</span>
</pre>
<p>Shouldn’t this be simpler? Describing that string with a regular expression is simple enough, and I’m
only changing one little part of the string, so why do I have to fiddle around with indices, and why do
I have to sacrifice readability? Most importantly, why do I have to experience this aesthetic pain deep
in my heart?</p>
</div>
<div id="first-attempt-stateful-manipulation">
<h2>First attempt: stateful manipulation</h2>
<p>My first idea was that our abstractions aren’t fit for this sort of problem. Strings are flat, they
have no sense of context, and if you pull out a substring then it requires special effort to stich it
back together. The solution? Just keep track of the <tt>before</tt> and the <tt>after</tt>:</p>
<pre><span class="o">&gt;&gt;&gt;</span> <span class="n">view</span> <span class="o">=</span> <span class="n">contex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">'1_Photo032-2008.jpg'</span><span class="p">,</span> <span class="s1">'\d+_Photo(?P&lt;number&gt;\d+)-\d+\.jpg'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">view</span>
<span class="o">&lt;</span><span class="n">MatchContext</span> <span class="nb">object</span><span class="p">;</span> <span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="s1">''</span><span class="p">,</span> <span class="s1">'1_Photo032-2008.jpg'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">view</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">'number'</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">MatchContext</span> <span class="nb">object</span><span class="p">;</span> <span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="s1">'1_Photo'</span><span class="p">,</span> <span class="s1">'032'</span><span class="p">,</span> <span class="s1">'-2008.jpg'</span><span class="p">)</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">'number'</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="s1">'{:0&gt;3}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">result</span>
<span class="o">&lt;</span><span class="n">MatchContext</span> <span class="nb">object</span><span class="p">;</span> <span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="s1">'1_Photo'</span><span class="p">,</span> <span class="s1">'031'</span><span class="p">,</span> <span class="s1">'-2008.jpg'</span><span class="p">)</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="s1">'1_Photo031-2008.jpg'</span>
<span class="o">&gt;&gt;&gt;</span>
</pre>
<p>This way I can move around the “focus point” of the string with methods such as <tt>.group</tt>, manipulate that space,
and when I’m done convert it back to a <tt>str</tt>. I can even manipulate more than one area of the string:</p>
<pre><span class="o">&gt;&gt;&gt;</span> <span class="n">view</span> <span class="o">=</span> <span class="n">contex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">'1_Photo032-2008.jpg'</span><span class="p">,</span> <span class="s1">'\d+_Photo(?P&lt;number&gt;\d+)-(?P&lt;year&gt;\d+)\.jpg'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">view</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">'number'</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">'year'</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
<span class="o">&lt;</span><span class="n">MatchContext</span> <span class="nb">object</span><span class="p">;</span> <span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="s1">'1_Photo-'</span><span class="p">,</span> <span class="s1">'08'</span><span class="p">,</span> <span class="s1">'.jpg'</span><span class="p">)</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span>
</pre>
<p><tt>MatchContext</tt> keeps track of where the matched regular expression groups are: Even though I removed the
content of the “number” group, <tt>MatchContext</tt> knows where to find and replace the “year” group. It can also
deal with nested regex groups, 0-length matches etc.</p>
<div>
<p>Note</p>
<p>Previously (v2.0.1 and earlier) I allowed arbitrary slicing on <tt>MatchContext</tt> objects to select the focus
point in addition to the <tt>.group</tt> method. This was a mistake. When you’re dealing with 0-length slices and
adjacent regex groups that matched 0-length strings, there arises serious problems of semantics. I found out
that the expected semantics is inextricably linked to which regex group you previously selected with <tt>.group</tt>,
and therefore had to disallow slicing for <tt>MatchContext</tt> objects.</p>
</div>
</div>
<div id="removing-the-state-vive-la-revolution">
<h2>Removing the state: Vive la Revolution</h2>
<p>The <tt>MatchContext</tt> abstraction certainly is an improvement for these particular types of problems, but
there is one downside to it, and that is that it adds an additional layer of state to ordinary strings:
The programmer must remember which part of the string is in “focus”, or, in other words, which state the
string is in.</p>
<p>So my next challenge was to eliminate the state. What I found out was that only in rare cases is the state
needed or useful, and this lead me to believe that the fundamental problem isn’t really the abstractions we
use for representing strings, but rather the interfaces we have for manipulating them. Thus, pardon the pun,
enter <tt>contex.rules</tt>:</p>
<pre><span class="o">&gt;&gt;&gt;</span> <span class="n">contex</span><span class="o">.</span><span class="n">rules</span><span class="p">(</span><span class="s1">'\d+_Photo(?P&lt;number&gt;\d+)-(?P&lt;year&gt;\d+)\.jpg'</span><span class="p">,</span> <span class="p">{</span>
<span class="o">...</span>     <span class="s1">'number'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="s1">'{:0&gt;3}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
<span class="o">...</span>     <span class="s1">'year'</span><span class="p">:</span>   <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
<span class="o">...</span> <span class="p">})</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="s1">'1_Photo032-2008.jpg'</span><span class="p">)</span>
<span class="s1">'1_Photo031-08.jpg'</span>
</pre>
<p>Or maybe I want to change the layout of the filename completely:</p>
<pre><span class="o">&gt;&gt;&gt;</span> <span class="n">contex</span><span class="o">.</span><span class="n">rules</span><span class="p">(</span><span class="s1">'(\d+)_Photo(?P&lt;number&gt;\d+)-(?P&lt;year&gt;\d+)\.jpg'</span><span class="p">,</span> <span class="p">{</span>
<span class="o">...</span>     <span class="s1">'number'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
<span class="o">...</span>     <span class="s1">'year'</span><span class="p">:</span>   <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
<span class="o">...</span> <span class="p">})</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="s1">'1_Photo032-2008.jpg'</span><span class="p">,</span> <span class="s1">'Photo_{1}_{number:0&gt;3}-{year}.jpeg'</span><span class="p">)</span>
<span class="s1">'Photo_1_031-08.jpeg'</span>
</pre>
<p>The string manipulation is done in one go. The programmer doesn’t need to remember where the focus point is
right now, or specify which order to do the replacements in. This is a much more <em>declarative</em> interface: you
tell it what the string looks like, what changes you want made, and it figures out the rest. You don’t need to
stich the pieces back together, and can create more readable regular expressions as well because of that.</p>
<p>Nested regex groups are also allowed: the nested one will be replaced first (which will make a difference if
the replacement for the outer group is a callable).</p>
<div id="more-advanced-example">
<h3>More advanced example</h3>
<p>Here’s an example using <tt>re.search</tt> (as opposed to <tt>re.fullmatch</tt>, which is the default):</p>
<pre><span class="o">&gt;&gt;&gt;</span> <span class="n">contex</span><span class="o">.</span><span class="n">rules</span><span class="p">(</span><span class="s1">'(?P&lt;millennium&gt;\d)\d{3}'</span><span class="p">,</span> <span class="p">{</span>
<span class="o">...</span>      <span class="s1">'millennium'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
<span class="o">...</span>      <span class="mi">0</span><span class="p">:</span>            <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="s1">'&lt;span class="year"&gt;{}&lt;/span&gt;'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="o">...</span> <span class="p">},</span> <span class="n">method</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="s1">'Current year: 2015'</span><span class="p">)</span>
<span class="s1">'Current year: &lt;span class="year"&gt;3015&lt;/span&gt;'</span>
</pre>
<p>Notice that the <tt>'millennium'</tt> group is replaced before the <tt>0</tt> group.</p>
<p><tt>contex.rules</tt> is explained in more detail in its very long docstring.</p>
</div>
</div>
<div id="doubtful-stability">
<h2>Doubtful stability</h2>
<p>In order to retrieve certain information about the regular expressions to resolve ambiguities related to 0-length
matches and so on, I’ve seen it necessary to use <tt>sre_parse.parse</tt> to parse the regular expressions. This is
an “internal support module” or something like that, and the stability of this library becomes doubtful as a result.
My judgement was that it would take a lot of time and effort to create my own parser for python regular expressions,
and I could easily create some bugs in that parser too.</p>
</div>
<div id="conclusion">
<h2>Conclusion</h2>
<p>I hope that the examples of <tt>contex.rules</tt> I have given are sufficiently intuitive so that any programmer can look
at them and infer pretty accurately what they do, because the whole point of this endeavor is to increase readability.</p>
<p>Furthermore, I’d be interested to see if other people can take this idea <tt>^\w{7}</tt></p>
</div>
<div id="using-contex">
<h2>Using Contex</h2>
<p>The <tt>contex</tt> package contains 5 functions:</p>
<ul>
<li><tt>rules(regex, rule_dict, method=re.fullmatch, flags=0)</tt> for declarative string manipulation.</li>
<li><tt>T(string)</tt> for converting a string into a <tt>StringContext</tt> object.</li>
<li><tt>search(string, pattern, flags=0)</tt> and</li>
<li><tt>match(string, pattern, flags=0)</tt> for regex searches (with the same semantic difference as in the <tt>re</tt> module).
They both return a <tt>MatchContext</tt> object.</li>
<li><tt>find(string, substring, right_side=False)</tt> for finding a substring, returns a <tt>StringContext</tt> object.</li>
</ul>
<p><tt>contex</tt> also contains the <tt>StringContext</tt> and <tt>MatchContext</tt> classes.</p>
</div>
<div id="installing">
<h2>Installing</h2>
<p><tt>contex</tt> should work in both Python 2.7 and 3.</p>
<p>Install with <tt>$ pip install contex</tt>. If you want to install for Python 3 you might want to replace <tt>pip</tt> with <tt>pip3</tt>, depending on how your system is configured.</p>
</div>

<div id="license">
<h2>License</h2>
<p>The library is licensed under the GNU General Public License 3 or later.
This README file is public domain.</p>
</div>


<a name="downloads"> </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>159</span> downloads in the last week
  </li>
  <li>
    <span>1101</span> downloads in the last month
  </li>
</ul>









            </div>


          </div></body></html>