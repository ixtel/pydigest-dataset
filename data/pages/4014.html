<html><body><div><div class="section" id="traps-for-the-unwary-in-python-s-import-system">
<h1>Traps for the Unwary in Python’s Import System<a class="headerlink" href="#traps-for-the-unwary-in-python-s-import-system" title="Permalink to this headline">¶</a></h1>
<p>Python’s import system is powerful, but also quite complicated. Until the
release of Python 3.3, there was no comprehensive explanation of the expected
import semantics, and even following the release of 3.3, the details of how
<code class="docutils literal"><span class="pre">sys.path</span></code> is initialised are still somewhat challenging to figure out.</p>
<p>Even though 3.3 cleaned up a lot of things, it still has to deal with
various backwards compatibility issues that can cause strange behaviour,
and may need to be understood in order to figure out how some third party
frameworks operate.</p>
<p>Furthermore, even without invoking any of the more exotic features of the
import system, there are quite a few common missteps that come up regularly
on mailing lists and Q&amp;A sites like Stack Overflow.</p>
<p>This essay only officially covers Python versions back to Python 2.6. Much
of it applies to earlier versions as well, but I won’t be qualifying any of
the explanations with version details before 2.6.</p>
<p>As with all my essays on this site, suggestions for improvement or
requests for clarification can be posted on <a class="reference external" href="https://bitbucket.org/ncoghlan/misc/issues">BitBucket</a>.</p>
<div class="section" id="the-missing-init-py-trap">
<h2>The missing __init__.py trap<a class="headerlink" href="#the-missing-init-py-trap" title="Permalink to this headline">¶</a></h2>
<p>This particular trap applies to 2.x releases, as well as 3.x releases up to
and including 3.2.</p>
<p>Prior to Python 3.3, filesystem directories, and directories within zipfiles,
<em>had</em> to contain an <code class="docutils literal"><span class="pre">__init__.py</span></code> in order to be recognised as Python
package directories. Even if there is no initialisation code to run when
the package is imported, an empty <code class="docutils literal"><span class="pre">__init__.py</span></code> file is still needed for
the interpreter to find any modules or subpackages in that directory.</p>
<p>This has changed in Python 3.3: now any directory on <code class="docutils literal"><span class="pre">sys.path</span></code> with a name
that matches the package name being looked for will be recognised as
contributing modules and subpackages to that package.</p>
</div>
<div class="section" id="the-init-py-trap">
<h2>The __init__.py trap<a class="headerlink" href="#the-init-py-trap" title="Permalink to this headline">¶</a></h2>
<p>This is an all new trap added in Python 3.3 as a consequence of fixing the
previous trap: if a subdirectory encountered on <code class="docutils literal"><span class="pre">sys.path</span></code> as part of
a package import contains an <code class="docutils literal"><span class="pre">__init__.py</span></code> file, then the Python
interpreter will create a <em>single directory</em> package containing only
modules from that directory, rather than finding all appropriately
named subdirectories as described in the previous section.</p>
<p>This happens <em>even if</em> there are other preceding subdirectories on
<code class="docutils literal"><span class="pre">sys.path</span></code> that match the desired package name, but do not include an
<code class="docutils literal"><span class="pre">__init__.py</span></code> file.</p>
<p>This complexity is primarily forced on us by backwards compatibility
constraints - without it, some existing code would have broken when Python
3.3 made the presence of <code class="docutils literal"><span class="pre">__init__.py</span></code> files in packages optional.</p>
<p>However, it is also useful in that it makes it possible to explicitly
declare that a package is closed to additional contributions. All of
the standard library currently works that way, although some packages
may open up their namespaces to third party contributions in future
releases (specifically, it is almost certain the <code class="docutils literal"><span class="pre">encodings</span></code> package
will be open to additions in Python 3.4).</p>
</div>
<div class="section" id="the-double-import-trap">
<h2>The double import trap<a class="headerlink" href="#the-double-import-trap" title="Permalink to this headline">¶</a></h2>
<p>This next trap exists in all current versions of Python, including 3.3, and
can be summed up in the following general guideline: “Never add a package
directory, or any directory inside a package, directly to the Python path”.</p>
<p>The reason this is problematic is that every module in that directory is
now potentially accessible under two different names: as a top level module
(since the directory is on <code class="docutils literal"><span class="pre">sys.path</span></code>) and as a submodule of the
package (if the higher level directory containing the package itself is
also on <code class="docutils literal"><span class="pre">sys.path</span></code>).</p>
<p>As an example, Django (up to and including version 1.3) is guilty of setting
up exactly this situation for site-specific applications - the application
ends up being accessible as both <code class="docutils literal"><span class="pre">app</span></code> and <code class="docutils literal"><span class="pre">site.app</span></code> in the module
namespace, and these are actually two <em>different</em> copies of the module. This
is a recipe for confusion if there is any meaningful mutable module level
state, so this behaviour has been eliminated from the default project layout
in version 1.4 (site-specific apps will always need to be fully qualified
with the site name, as described in the <a class="reference external" href="https://docs.djangoproject.com/en/dev/releases/1.4/#updated-default-project-layout-and-manage-py">release notes</a>).</p>
<p>Unfortunately, this is still a <em>really</em> easy guideline to violate, as it
happens automatically if you attempt to run a module inside a package from
the command line by filename rather than using the <code class="docutils literal"><span class="pre">-m</span></code> switch.</p>
<p>Consider a simple package layout like the following (I typically use package
layouts along these lines in my own projects - a lot of people hate nesting
tests inside package directories like this, and prefer a parallel hierarchy,
but I favour the ability to use explicit relative imports to keep module
tests independent of the package name):</p>
<div class="highlight-python"><div class="highlight"><pre>project/
    setup.py
    example/
        __init__.py
        foo.py
        tests/
            __init__.py
            test_foo.py
</pre></div>
</div>
<p>What’s surprising about this layout is that all of the following
ways to invoke <code class="docutils literal"><span class="pre">test_foo.py</span></code> <em>probably won’t work</em> due to broken imports
(either failing to find <code class="docutils literal"><span class="pre">example</span></code> for absolute imports like
<code class="docutils literal"><span class="pre">import</span> <span class="pre">example.foo</span></code> or <code class="docutils literal"><span class="pre">from</span> <span class="pre">example</span> <span class="pre">import</span> <span class="pre">foo</span></code>, complaining about
relative imports in a non-package or beyond the top-level package for
explicit relative imports like <code class="docutils literal"><span class="pre">from</span> <span class="pre">..</span> <span class="pre">import</span> <span class="pre">foo</span></code>, or issuing even more
obscure errors if some other submodule happens to shadow the name of a
top-level module used by the test, such as an <code class="docutils literal"><span class="pre">example.json</span></code> module
that handled serialisation or an <code class="docutils literal"><span class="pre">example.tests.unittest</span></code> test runner):</p>
<div class="highlight-python"><div class="highlight"><pre># These commands will most likely *FAIL* due to problems with the way
# the import state gets initialised, even if the test code is correct

# working directory: project/example/tests
./test_foo.py
python test_foo.py
python -m test_foo
python -c "from test_foo import main; main()"

# working directory: project/example
tests/test_foo.py
python tests/test_foo.py
python -m tests.test_foo
python -c "from tests.test_foo import main; main()"

# working directory: project
example/tests/test_foo.py
python example/tests/test_foo.py

# working directory: project/..
project/example/tests/test_foo.py
python project/example/tests/test_foo.py
python -m project.example.tests.test_foo
python -c "from project.example.tests.test_foo import main; main()"
</pre></div>
</div>
<p>That’s right, that long list is of all the methods of invocation that are
quite likely to <em>break</em> if you try them, and the error messages won’t make
any sense if you’re not already intimately familiar not only with the way
Python’s import system works, but also with how it gets initialised. (Note
that if the project exclusively uses explicit relative imports for
intra-package references, the last two commands shown may actually work
for Python 3.3 and later versions. Any absolute imports that expect
“example” to be a top level package will still break though).</p>
<p>For a long time, the only way to get <code class="docutils literal"><span class="pre">sys.path</span></code> right with this kind of
setup was to either set it manually in <code class="docutils literal"><span class="pre">test_foo.py</span></code> itself (hardly
something novice, or even many veteran, Python programmers are going to
know how to do) or else to make sure to import the module instead of
executing it directly:</p>
<div class="highlight-python"><div class="highlight"><pre># working directory: project
python -c "from example.tests.test_foo import main; main()"
</pre></div>
</div>
<p>Since Python 2.6, however, the following also works properly:</p>
<div class="highlight-python"><div class="highlight"><pre># working directory: project
python -m example.tests.test_foo
</pre></div>
</div>
<p>This last approach is actually how I prefer to use my shell when
programming in Python - leave my working directory set to the project
directory, and then use the <code class="docutils literal"><span class="pre">-m</span></code> switch to execute relevant submodules
like tests or command line tools. If I need to work in a different
directory for some reason, well, that’s why I also like to have multiple
shell sessions open.</p>
<p>While I’m using an embedded test case as an example here, similar issues
arise any time you execute a script directly from inside a package without
using the <code class="docutils literal"><span class="pre">-m</span></code> switch from the parent directory in order to ensure that
<code class="docutils literal"><span class="pre">sys.path</span></code> is initialised correctly (e.g. the pre-1.4 Django project
layout gets into trouble by running <code class="docutils literal"><span class="pre">manage.py</span></code> from inside a package,
which puts the package directory on <code class="docutils literal"><span class="pre">sys.path</span></code> and leads to this double
import problem - the 1.4+ layout solves that by moving <code class="docutils literal"><span class="pre">manage.py</span></code> outside
the package directory).</p>
<p>The fact that most methods of invoking Python code from the command line
break when that code is inside a package, and the two that do work are highly
sensitive to the current working directory is all thoroughly confusing for a
beginner. I personally believe it is one of the key factors leading
to the perception that Python packages are complicated and hard to get right.</p>
<p>This problem isn’t even limited to the command line - if <code class="docutils literal"><span class="pre">test_foo.py</span></code> is
open in Idle and you attempt to run it by pressing F5, or if you try to run
it by clicking on it in a graphical filebrowser, then it will fail in just
the same way it would if run directly from the command line.</p>
<p>There’s a reason the general “no package directories on <code class="docutils literal"><span class="pre">sys.path</span></code>”
guideline exists, and the fact that the interpreter itself doesn’t follow
it when determining <code class="docutils literal"><span class="pre">sys.path[0]</span></code> is the root cause of all sorts of grief.</p>
<p>However, even if there are improvements in this area in future versions of
Python (see PEP 395), this trap will still exist in all current versions.</p>
</div>
<div class="section" id="executing-the-main-module-twice">
<h2>Executing the main module twice<a class="headerlink" href="#executing-the-main-module-twice" title="Permalink to this headline">¶</a></h2>
<p>This is a variant of the above double import problem that doesn’t require any
erroneous <code class="docutils literal"><span class="pre">sys.path</span></code> entries.</p>
<p>It’s specific to the situation where the main module is <em>also</em> imported as
an ordinary module, effectively creating two instances of the same module
under different names.</p>
<p>As with any double-import problem, if the state stored in <code class="docutils literal"><span class="pre">__main__</span></code> is
significant to the correct operation of the program, or if there is
top-level code in the main module that has undesirable side effects if
executed more than once, then this duplication can cause obscure and
surprising errors.</p>
<p>This is just one more reason why main modules in more complex applications
should be kept fairly minimal - it’s generally far more robust to move most
of the functionality to a function or object in a separate module, and just
import that module from the main module. That way, inadvertently executing
the main module twice becomes harmless. Keeping main modules small and
simple also helps to avoid a few potential problems with object
serialisation as well as with the multiprocessing package.</p>
</div>
<div class="section" id="the-name-shadowing-trap">
<h2>The name shadowing trap<a class="headerlink" href="#the-name-shadowing-trap" title="Permalink to this headline">¶</a></h2>
<p>Another common trap, especially for beginners, is using a local module name
that shadows the name of a standard library or third party package or module
that the application relies on. One particularly surprising way to run afoul
of this trap is by using such a name for a <em>script</em>, as this then combines
with the previous “executing the main module twice” trap to cause trouble.
For example, if experimenting to learn more about Python’s <a class="reference external" href="http://docs.python.org/3/library/socket.html#module-socket" title="(in Python v3.5)"><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a>
module, you may be inclined to call your experimental script <code class="docutils literal"><span class="pre">socket.py</span></code>.
It turns out this is a really bad idea, as using such a name means the
Python interpreter can no longer find the <em>real</em> socket module in the
standard library, as the apparent socket module in the current directory
gets in the way:</p>
<div class="highlight-python"><div class="highlight"><pre>$ python -c 'from socket import socket; print("OK!")'
OK!
$ echo 'from socket import socket; print("OK!")' &gt; socket.py
$ python socket.py
Traceback (most recent call last):
  File "socket.py", line 1, in &lt;module&gt;
    from socket import socket
  File "/home/ncoghlan/devel/socket.py", line 1, in &lt;module&gt;
    from socket import socket
ImportError: cannot import name socket
</pre></div>
</div>
</div>
<div class="section" id="the-stale-bytecode-file-trap">
<h2>The stale bytecode file trap<a class="headerlink" href="#the-stale-bytecode-file-trap" title="Permalink to this headline">¶</a></h2>
<p>Following on from the example in the previous section, suppose we decide to
fix our poor choice of script name by renaming the file. In Python 2, we’ll
find that still doesn’t work:</p>
<div class="highlight-python"><div class="highlight"><pre>$ mv socket.py socket_play.py
$ python socket_play.py
Traceback (most recent call last):
  File "socket_play.py", line 1, in &lt;module&gt;
    from socket import socket
  File "/home/ncoghlan/devel/socket.py", line 1, in &lt;module&gt;
    # Wrapper module for _socket, providing some additional facilities
ImportError: cannot import name socket
</pre></div>
</div>
<p>There’s clearly something strange going on here, as we’re seeing a traceback
that claims to be caused by a <em>comment</em> line. In reality, what has happened
is that the cached bytecode file from our previous failed import attempt is
still present and causing trouble, but when Python tries to display the
source line for the traceback, it finds the source line from the standard
library module instead. Removing the stale bytecode file makes things work as
expected:</p>
<div class="highlight-python"><div class="highlight"><pre>$ rm socket.pyc
$ python socket_play.py
OK!
</pre></div>
</div>
<p>This particular trap has been largely eliminated in Python 3.2 and later. In
those versions, the interpreter makes a distinction between standalone
bytecode files (such as <code class="docutils literal"><span class="pre">socket.pyc</span></code> above) and cached bytecode files
(stored in automatically created <code class="docutils literal"><span class="pre">__pycache__</span></code> directories). The latter
will be ignored by the interpreter if the corresponding source file is
missing, so the above renaming of the source file works as intended:</p>
<div class="highlight-python"><div class="highlight"><pre>$ echo 'from socket import socket; print("OK!")' &gt; socket.py
$ python3 socket.py
Traceback (most recent call last):
  File "socket.py", line 1, in &lt;module&gt;
    from socket import socket
  File "/home/ncoghlan/devel/socket.py", line 1, in &lt;module&gt;
    from socket import socket
ImportError: cannot import name socket
$ mv socket.py socket_play.py
$ python3 socket_play.py
</pre></div>
</div>
<p>Note, however, that mixing Python 2 and Python 3 can cause trouble if
Python 2 has left a standalone bytecode file lying around:</p>
<div class="highlight-python"><div class="highlight"><pre>$ python3 socket_play.py
Traceback (most recent call last):
  File "socket_play.py", line 1, in &lt;module&gt;
    from socket import socket; print("OK!")
ImportError: Bad magic number in /home/ncoghlan/devel/socket.pyc
</pre></div>
</div>
<p>If you’re not a core developer on a Python implementation, the problem of
importing stale bytecode is most likely to arise when renaming Python source
files. For Python implementation developers, it can also arise any time
we’re working on the compiler components that are responsible for
generating the bytecode in the first place - that’s the main reason
the CPython <code class="docutils literal"><span class="pre">Makefile</span></code> includes a <code class="docutils literal"><span class="pre">make</span> <span class="pre">pycremoval</span></code> target.</p>
</div>
<div class="section" id="the-submodules-are-added-to-the-package-namespace-trap">
<h2>The submodules are added to the package namespace trap<a class="headerlink" href="#the-submodules-are-added-to-the-package-namespace-trap" title="Permalink to this headline">¶</a></h2>
<p>Many users will have experienced the issue of trying to use a submodule
when only importing the package that it is in:</p>
<div class="highlight-python"><div class="highlight"><pre>$ python3
&gt;&gt;&gt; import logging
&gt;&gt;&gt; logging.config
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'module' object has no attribute 'config'
</pre></div>
</div>
<p>But it is less common knowledge that when a submodule is loaded <em>anywhere</em>
it is automatically added to the global namespace of the package:</p>
<div class="highlight-python"><div class="highlight"><pre>$ echo "import logging.config" &gt; weirdimport.py
$ python3
&gt;&gt;&gt; import weirdimport
&gt;&gt;&gt; import logging
&gt;&gt;&gt; logging.config
&lt;module 'logging.config' from '/usr/local/Cellar/python3/3.4.3/Frameworks/Python.framework/Versions/3.4/lib/python3.4/logging/config.py'&gt;
</pre></div>
</div>
<p>This is most likely to surprise you when in an <code class="docutils literal"><span class="pre">__init__.py</span></code> and you are
importing or defining a value that has the same name as a submodule of the
current package. If the submodule is loaded by <em>any</em> module at any point
after the import or definition of the same name, it will shadow the
imported or defined name in the <code class="docutils literal"><span class="pre">__init__.py</span></code>‘s global namespace.</p>
</div>
<div class="section" id="more-exotic-traps">
<h2>More exotic traps<a class="headerlink" href="#more-exotic-traps" title="Permalink to this headline">¶</a></h2>
<p>The above are the common traps, but there are others, especially if you
start getting into the business of extending or overriding the default
import system.</p>
<p>I may add more details on each of these over time:</p>
<ul class="simple">
<li>the weird signature of <code class="docutils literal"><span class="pre">__import__</span></code></li>
<li>the influence of the module globals (<code class="docutils literal"><span class="pre">__import__</span></code>, <code class="docutils literal"><span class="pre">__path__</span></code>,
<code class="docutils literal"><span class="pre">__package__</span></code>)</li>
<li><a class="reference external" href="http://docs.python.org/2/library/threading#importing-in-threaded-code">issues with threads</a> prior to 3.3</li>
<li>the lack of PEP 302 support in the default machinery prior to 3.3</li>
<li>non-cooperative package portions in pre-3.3 namespace packages</li>
<li>sys.path[0] initialisation variations</li>
<li>more on the issues with pickle, multiprocessing and the main module
(see PEP 395)</li>
<li><code class="docutils literal"><span class="pre">__main__</span></code> is not always a top level module (thanks to <code class="docutils literal"><span class="pre">-m</span></code>)</li>
<li>the fact modules are allowed to replace themselves in sys.modules
during import</li>
<li><code class="docutils literal"><span class="pre">__file__</span></code> may not refer to a real filesystem location</li>
<li>since 3.2, you can’t just add <code class="docutils literal"><span class="pre">c</span></code> or <code class="docutils literal"><span class="pre">o</span></code> to get the cached bytecode
filename</li>
</ul>
</div>
</div>


</div></body></html>