<html><body><div><article>
	<p>Python 3.3 added the <a href="http://www.python.org/dev/peps/pep-0405/">venv</a> module to its standard library, which you can use instead of installing the popular <a href="https://pypi.python.org/pypi/virtualenv">virtualenv</a> third-party module. The new module provides many new features that enable you to create lightweight virtual environments easily, but it departs in many ways from the way the virtualenv works. Recently released Python 3.4 also added new features to the venv module. In this article, I'll examine the usage of venv in common lightweight virtual-environment scenarios.</p>
<p>
</p><h3>Lightweight Virtual Environments</h3>
<p>Lightweight virtual environments are  common for Python developers who need to work on different projects with conflicting library releases or different Python versions. The new venv module is perfect for this because each lightweight virtual environment has its own Python binary. Thus, the module is especially useful when you need to maintain and test code across multiple Python versions.</p>
<p>
</p><p>A key advantages of the venv module compared with the existing third-party modules is that it provides a reliable optional isolation from system site directories, combined with a lightweight approach that reduces overall maintenance. The virtual-environment mechanisms in venv are integrated with Python, and therefore, available in all the platforms where you can run Python. As you might guess, each virtual environment in venv can have its own independent set of installed Python packages in its site directories. Thus, making it easy to control dependency management.</p>
<p>
</p><p>For example, sometimes you have an application that works with version 1.7 of a specific library, but you are also working on another application that uses version 3.5 of the library. If you upgrade the library that is common to both applications to 3.5 in <code>site-packages</code>, you will need to make the necessary upgrades to the application that uses version 1.7. A lightweight virtual environment that doesn't share libraries with other environments is useful in solving dependency problems like this one.</p>
<p>
</p><p>Python 3.3 and 3.4 added the following components to support lightweight virtual environments:</p>
<ul>
  <li><code>pyvenv.cfg</code> configuration file: The existence of this file signals the base of a virtual environment's directory tree.</li>
  <li><code>pyvenv</code> script: Used for command-line access and administration of virtual environments. Python 3.4 added activation scripts for the csh and fish shells to the venv activation scripts.</li>
  <li>venv module: as described, this gives programmatic access to virtual environments. Python 3.4 added a new keyword argument to the virtual-environment creation function to specify whether the builder must ensure that the <a href="http://en.wikipedia.org/wiki/Pip_(package_manager)">pip package manager</a> is installed in the virtual environment.</li>
</ul>
<p>
</p><p>The documentation for venv is a bit confusing because, at the time of this writing, it hadn't been completely updated with the enhancements made in Python 3.4. Thus, some comments in this article might not match the descriptions you find in the documentation. I've prepared the examples considering all the features included in Python 3.4.</p>
<p>
</p><h3>Executing the pyvenv Script to Create a Virtual Environment</h3>
<p>
</p><p>The easiest way to grasp the possibilities that venv offers is to learn from some simple examples. If you want to create a new lightweight virtual environment with Python 3.4 installed on Windows in <code>C:\Python34</code>, you can run the following command:</p>
<p/><pre>
C:\Python34\python C:\Python34\Tools\Scripts\pyvenv.py C:\mypythonenvs\virtualenv01</pre>
<p>The command invokes the <code>pyenv.py</code> script located in <code>Tools\Scripts</code> within the base Python installation folder. The script creates the target folder <code>C:\mypythonenvs\virtualenv01</code> and installs pip by invoking <code>ensurepip</code> because I didn't specify the <code>--without-pip</code> option. By default, if the target folder exists, the script will raise an error and stop its execution.</p>
<p>
</p><p><code>C:\mypythonenvs\virtualenv01</code> is a new directory tree that contains Python executable files and other files that indicate it is a lightweight virtual environment. This folder includes a <code>pyenv.cfg</code> configuration file specifying different options for the virtual environment and the <code>Include</code>, <code>Lib</code>, <code>Lib\site-packages</code> and <code>Scripts</code> subfolders. In Linux and other POSIX systems, the directories would be <code>include</code>, <code>lib</code>, <code>lib/python3.4/site-packages</code> (<code>lib/pythonX.Y/site-packages</code>), and <code>bin</code> (see Figure 1). As you might guess, the directory trees for the virtual environment in each platform are the same as the layout of the Python installation. Whenever you install third-party packages into a virtual environment, the modules will be located within the initially empty <code>site-packages</code> folder and the executables within either <code>Scripts</code> or <code>bin</code>, according to the system (Windows or POSIX, respectively). The existence of the <code>pyenv.cfg</code> file in the folder indicates Python that there is a virtual environment.</p>
<p><img src="http://twimgs.com/ddj/images/article/2014/0414/GastonPythonFig1.gif" alt="Python" title="Python"/><br/><b>Figure 1: The initial directory trees for virtual environments in Windows and in POSIX systems.</b></p>
<p>
</p><p>It is also possible to invoke the <code>pyenv.py</code> script in Windows or other Python-supported platforms with the following lines.</p><ul>
<li>Windows sample: <code>python -m venv C:\mypythonenvs\virtualenv01</code></li>
<li>Linux and other POSIX systems sample: <code>python -m venv /home/gaston/pythonenvs/virtualenv01</code></li></ul>
<p>The following lines show the contents of the <code>C:\mypythonenvs\virtualenv01\pyenv.cfg</code> file for the virtual environment created in the <code>C:\mypythonenvs\virtualenv01</code> folder with the previously shown command line in Python 3.4:</p>
<p/><pre class="brush: python; html: collapse;">
home = C:\Python34
include-system-site-packages = false
version = 3.4.0</pre>
<p>Notice that the <code>include-system-site-packages</code> key is set to <code>false</code> by default, unless you specify the <code>--system-site-packages</code> option when invoking <code>pyenv.py</code>. Thus, if you want your virtual environment to have access to the system <code>site-packages</code> folder, you will need to specify that option when creating it.</p>
<p>
</p><p>The ability to upgrade a lightweight virtual environment is very useful because it makes it easy to move to newer Python versions in each virtual environment. This option is especially handy in Windows and OS X installations because the Python binary and the related DLLs are copied to the virtual-environment structure instead of being symlinked. There is a <code>--symlink</code> option to force the use of symlink equivalents in Windows, but it isn't done by default. In addition, OS X framework builds will never use symlinks, so you will need to use the <code>--upgrade</code> option. If you want to override the default usage of symlinks in your platform, you can use the new <code>--copies</code> option included in Python 3.4.</p>
<p>If you create a lightweight virtual environment without symlinks and then you want to upgrade it to a newer Python version, you can easily do so by executing the <code>pyenv.py</code> script with the target folder and the <code>--upgrade</code> option. For example, if you started using lightweight virtual environments with Python 3.3 and then you want to upgrade some environments to Python 3.4, you can do so using the following lines:</p>
<ul>
<li>Windows sample: <code>python -m venv C:\mypythonenvs\virtualenv01 --upgrade</code></li>
<li>Linux and other POSIX systems sample: <code>python -m venv /home/gaston/pythonenvs/virtualenv01 --upgrade</code></li></ul>
<p>
</p><h3>Activating and Deactivating Virtual Environments</h3>
<p>Once you create your virtual environment, you can optionally run a platform-specific script to activate it. The activation prepends the virtual environment's binary folder to the path. This way, you can avoid using the full paths for the Python interpreter and the scripts. Obviously, there is also a deactivate mechanism to remove the changes in the environment variables.</p>
<p>
</p><p>The following table summarizes the commands included in a virtual environment generated with Python 3.4 to activate a virtual environment. In the examples, I use <code>C:\mypythonenvs\virtualenv01</code> as the base folder for Windows scripts and <code>/home/gaston/pythonenvs/virtualenv01</code> in POSIX scripts.</p>
<p>
  </p><table border=".3" cellspacing="1" cellpadding="3">
  <tr>
    <td valign="top"><p><b>Platform and shell</b></p></td>
    <td valign="top"><p><b>Command that you must execute   to activate the virtual environment</b></p></td>
  </tr>
  <tr>
    <td valign="top"><p>Windows Command Prompt</p></td>
    <td valign="top"><p><code>C:\mypythonenvs\virtualenv01\Scripts\activate.bat</code></p></td>
  </tr>
<tr>
    <td valign="top"><p>Windows PowerShell</p></td>
    <td valign="top"><p><code>C:\mypythonenvs\virtualenv01\Scripts\Activate.ps1</code></p></td>
  </tr>
 <tr>
    <td valign="top"><p>POSIX bash or zsh</p></td>
    <td valign="top"><p><code>source /home/gaston/pythonenvs/virtualenv01/bin/activate</code></p></td>
  </tr>
<tr>
    <td valign="top"><p>POSIX csh or tcsh</p></td>
    <td valign="top"><p><code>source /home/gaston/pythonenvs/virtualenv01/bin/activate.csh</code></p></td>
  </tr>
   <tr>
    <td valign="top"><p>POSIX fish</p></td>
    <td valign="top"><p><code>. /home/gaston/pythonenvs/virtualenv01/bin/activate.fish</code></p></td>
  </tr>
</table>
<p>
</p><p>In any POSIX shell, you just need to type <code>deactivate</code> in the shell to deactivate the virtual environment because the activation scripts define a command with this name. However, at the Windows command prompt, you have to execute <code>C:\mypythonenvs\virtualenv01\Scripts\deactivate.bat</code>, and in Windows PowerShell <code>C:\mypythonenvs\virtualenv01\Scripts\Deactivate.ps1</code>. (Obviously, you need to replace the folder I'm using with the path to your own virtual environment for all the scripts.)</p>
<p>
</p><p>I'm sure you're wondering which mechanism is the best to remind you to deactivate a virtual environment after you activated it. Don't worry, you won't need sticky notes or other kinds of reminders. The script changes your shell's prompt to add the virtual environment folder as a prefix. For example, if you execute the <code>activate.bat</code> activation script in Windows that is located in <code>C:\mypythonenvs\virtualenv01\Scripts</code>, the command prompt will display <code>(virtualenv01)</code> as a prefix to remind you that you have activated the virtual environment located in the <code>virtualenv01</code> folder. The following lines show how the command prompt changes:</p>
<p/><pre class="brush: python; html: collapse;">C:\mypythonenvs\virtualenv01&gt;C:\mypythonenvs\virtualenv01\Scripts\activate.bat
(virtualenv01) C:\mypythonenvs\virtualenv01&gt;</pre>
<p>
</p><p>Once you have built and activated the desired virtual environment, any package installation you perform will only affect this environment. For example, if you use pip to install the popular simplejson package, it will affect the <code>site-packages</code> folder within your activated virtual environment. The installation won't make changes to either the default Python installation or other virtual environments you may have created.</p>
<p>	
		</p></article>
</div></body></html>