<html><body><div><p>Channel concept for asyncio.</p>
<div id="usage">
<h3>Usage</h3>
<h3 id="basics"><span class="section-subtitle">Basics</span></h3>
<p>Channels are 90% <tt>asyncio.Queue</tt>, and the API is very similar. The key
difference is that a channel is only considered “done” when it has been
both closed and drained, so calling <tt>.join()</tt> on a channel will wait
for it to be both closed and drained (Unlike <tt>Queue</tt> which will return
from <tt>.join()</tt> once the queue is empty).</p>
<p><em>NOTE</em> Closing a channel is permanent. You cannot open it again.</p>
<pre><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">aiochannel</span> <span class="kn">import</span> <span class="n">Channel</span>

<span class="c1"># ...</span>

<span class="c1"># A Channel takes a max queue size and an loop</span>
<span class="c1"># both optional</span>
<span class="n">my_channel</span> <span class="o">=</span> <span class="n">Channel</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">())</span>

<span class="c1"># You add items to the channel with</span>
<span class="k">yield from</span> <span class="n">my_channel</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">"my item"</span><span class="p">)</span>
<span class="c1"># Note that this can throw ChannelClosed if the channel</span>
<span class="c1"># is closed, during the attempt at adding the item</span>
<span class="c1"># to the channel. Also note that .put() will block until</span>
<span class="c1"># it can successfully add the item.</span>


<span class="c1"># Retrieving is done with</span>
<span class="n">my_item</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">my_channel</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="c1"># Note that this can also throw ChannelClosed if the</span>
<span class="c1"># channel is closed before or during retrival.</span>
<span class="c1"># .get() will block until an item can be retrieved.</span>


<span class="c1"># You can wait for the channel to be closed and drained:</span>
<span class="k">yield from</span> <span class="n">my_channel</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="c1"># Note that this requires someone else to close and drain</span>
<span class="c1"># the channel.</span>

<span class="c1"># Lastly, you can close a channel with</span>
<span class="n">my_channel</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="c1"># Every call to .put() after .close() will fail with</span>
<span class="c1"># a ChannelClosed.</span>
<span class="c1"># you can check if a channel is marked for closing with</span>
<span class="k">if</span> <span class="n">my_channel</span><span class="o">.</span><span class="n">closed</span><span class="p">():</span>
    <span class="k">print</span> <span class="p">(</span><span class="s2">"Channel is closed"</span><span class="p">)</span>
</pre>
<p>Like the <tt>asyncio.Queue</tt> you can also call non-coroutine get and put:</p>
<pre><span class="c1"># non-coroutine version of put</span>
<span class="n">my_channel</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="c1"># This either returns None,</span>
<span class="c1"># or raises ChannelClosed or ChannelFull</span>

<span class="c1"># non-coroutine version of get</span>
<span class="n">my_channel</span><span class="o">.</span><span class="n">get_nowait</span><span class="p">()</span>
<span class="c1"># This either returns the next item from the channel</span>
<span class="c1"># or raises ChannelEmpty or ChannelClosed</span>
<span class="c1"># (Note that ChannelClosed emplies that the channel</span>
<span class="c1"># is empty, but also that is will never fill again)</span>
</pre>
<p>As of <tt>0.2.0</tt> <tt>Channel</tt> also implements the async iterator protocol.
You can now use <tt>async for</tt> to iterate over the channel until it
closes, without having to deal with <tt>ChannelClosed</tt> exceptions.</p>
<pre><span class="c1"># the channel might contain data here</span>
<span class="n">async</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="c1"># the channel is closed and empty here</span>
</pre>
</div>
</div></body></html>