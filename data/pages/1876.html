<html><body><div><article class="article">

    
            <h1 class="title"> 
            	Django Admin – Tips &amp; Tricks            </h1>

		    
	
    <div class="line"> 
    
        <div class="entry-info">
       
            <span> <i class="fa fa-clock-o"/>
				October 30, 2014            </span>
            
                        
            <span><i class="fa fa-pencil-square-o"/>Article</span>            
            <span> <i class="fa fa-tags"/> 
				<a href="https://matijakolaric.com/category/development/python/" rel="category tag">Python</a> 
            </span>

        </div>

    </div>


	<p>Quite often I have heard that Django Admin is great because it can be ready in no time, but that its possibilities are quite limited. Therefore it is good for development, but not for production. And at some point it should be completely replaced by another front-end. Well, either I never got to this point, or this is a complete nonsense.</p>
<p>In this post I am bringing simple tips and tricks that can turn Django Admin into something far more useful. Actually it started as a draft for a PYtalk.</p>
<p><span id="more-126"/></p>
<p>This post follow the same process I follow in development. I start with more general topics and move toward specifics. It does not replace great <a href="https://docs.djangoproject.com/en/1.7/ref/contrib/admin/" target="_blank">official documentation for Django Admin</a>.</p>
<hr/>
<h2 id="skins">Skins</h2>
<p>When I work on a Django project that will include Django Admin in the final product, the first question is which “skin” I will use.  (There isn’t really a “skin” in Django. “Skins” are really normal Django apps and they are more than just different visual themes.) Each may have some additional functionality others lack. The following list is by no means final, and only major differences and use cases are covered.</p>
<h3>Default</h3>
<p><a href="https://matijakolaric.com/wp-content/uploads/2014/10/djangoadnin-default-skin.png"><img class="alignright wp-image-132" src="https://matijakolaric.com/wp-content/uploads/2014/10/djangoadnin-default-skin-290x220.png" alt="Default"/></a></p>
<p>Default skin (Django Admin with no additional apps) is the base for all other skins, so it has less functionality than others. It is also by far the least attractive. But, on the other side, it’s layout is very logical and clear. And it works out-of-the-box. It will work after Django is upgraded with no or little additional effort.</p>
<p>Generally I use it if all of following conditions are true:</p>
<ul>
<li>it will be used only for administrative back-end</li>
<li>it will not be used on phones</li>
<li>there is no need for  auto-complete fields</li>
</ul>
<h3>Bootstrap Admin</h3>
<p><a href="https://matijakolaric.com/wp-content/uploads/2014/10/djangoadmin-bootstrap.png"><img class="alignleft wp-image-129" src="https://matijakolaric.com/wp-content/uploads/2014/10/djangoadmin-bootstrap-290x220.png" alt="Responsible Skin for Django Admin"/></a>Many “skins” for Django Admin are based on Bootstrap. Here is a screenshot of <a href="https://github.com/douglasmiranda/django-admin-bootstrap" target="_blank">django-admin-bootstrap</a>.</p>
<p>It’s functionality is basically the same as for “default skin”, except that searching is available on the dashboard. This means that it’s functionality is still quite limited.</p>
<p>It has a very elegant appearance both on desktops and mobile devices. So it can be used as a general interface (not just for back-end administration).</p>
<h3>Grappelli</h3>
<p><a href="https://matijakolaric.com/wp-content/uploads/2014/10/djangoadmin-grappelli.png"><img class="alignright wp-image-131" src="https://matijakolaric.com/wp-content/uploads/2014/10/djangoadmin-grappelli-290x220.png" alt="Django Grappelli"/></a>This is a classic. I have used it in about half of my Django projects and I have a feeling that this will not change.</p>
<p>It has many great additional features and there are also great apps that depend on Grappelli. Listing them here would make no sense, it deserves a separate post. At least.</p>
<p>If your application is a complex one with many classes with complex relationships (in other words, a real business app), <a href="http://grappelliproject.com/" target="_blank">Grappelli</a> is the skin of choice. With it’s built-in grid system and great documentation, it is actually a great basis for creating custom “front-end” views that blend seamlessly with Django Admin.</p>
<h3>Django Suit</h3>
<p><a href="https://matijakolaric.com/wp-content/uploads/2014/10/djangoadmin-suit-skin.png"><img class="alignleft wp-image-130" src="https://matijakolaric.com/wp-content/uploads/2014/10/djangoadmin-suit-skin-290x220.png" alt="djangoadmin-suit-skin"/></a>This is a commercial app. Yes, you actually have to pay in order to use it in commercial apps. I personally don’t like it, but I did get great feedback from clients and end-users.</p>
<p>It has some great advantages over others, but still lacks some functionality Grappelli has. The coolest thing is the menu where all models are listed in a left-hand column. It integrates MPTT well and has good sorting widgets. (<a href="http://djangosuit.com/" target="_blank">http://djangosuit.com/</a>)</p>
<p>I believe we will see more of commercial skins for Django admin.</p>
<hr/>
<h2>Apps that work with Django Admin</h2>
<p>There is a rising number of apps that are well integrated with Django Admin. Some of them I use quite often. Though they can work without Django Admin, with completely custom interfaces, integration takes quite a lot of time. In any case, choosing the right ones comes next, and here are some usual suspects.</p>
<h3>Reversion</h3>
<p>One of most important apps out there is <a href="https://github.com/etianen/django-reversion" target="_blank">django-reversion</a>. What it does is a <em>full audit trail</em> with <em>reversioning</em> capabilities. Django Admin has history capabilities, which includes answers to who did the change and when. This app extends that to knowing the state at each change and also makes restoring any of the previous versions just two clicks away. In some industries audit trail is must, but it is almost always a nice feature. And it’s this simple:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">import reversion
class YourModelAdmin(reversion.VersionAdmin):
    pass
admin.site.register(YourModel, YourModelAdmin)</pre>
<h3>MPTT</h3>
<p><a href="https://matijakolaric.com/wp-content/uploads/2014/10/mptt-with-feincms.png"><img class="alignleft size-medium wp-image-148" src="https://matijakolaric.com/wp-content/uploads/2014/10/mptt-with-feincms-290x220.png" alt="mptt-with-feincms" srcset="https://matijakolaric.com/wp-content/uploads/2014/10/mptt-with-feincms-290x220.png 290w, https://matijakolaric.com/wp-content/uploads/2014/10/mptt-with-feincms-401x304.png 401w" sizes="(max-width: 290px) 100vw, 290px"/></a>Modified pre-order traversal tree is a great tool for working with trees that do not change often, but are often accessed, like website structure. There are two good Django apps for this: <a href="https://github.com/django-mptt/django-mptt" target="_blank">django-mptt</a> and <a href="http://code.tabo.pe/django-treebeard/" target="_blank">djago-treebeard</a>. The former is more friendly and fully integrated with Grappelli, but the latter has two other methods for working with trees that are more write-oriented.</p>
<p>For a more complex use of MPTT in Django Admin, you may want to look at <a href="http://feincms-django-cms.readthedocs.org/en/latest/admin.html" target="_blank">FeinCMS documentation</a>.</p>
<h3>django-import-export</h3>
<p>Great app for importing and exporting data from/to various formats, including Excel,  integrates well in Django Admin.</p>
<h3>django-fsm and django-fsm-admin</h3>
<p>Though two separate apps, I always use them together.</p>
<h3>Combining various apps</h3>
<p><a href="https://matijakolaric.com/wp-content/uploads/2014/10/categories.png"><img class="alignright wp-image-151" src="https://matijakolaric.com/wp-content/uploads/2014/10/categories-e1414744258552.png" alt=""/></a>If you need to include several apps that change the admin, you should not expect them to work out-of-the-box. However, its not too complicated. Lets look at an example.</p>
<p>The app in the screenshot (partially in Croatian, sorry about that) for this particular model uses Grappelli, django-import-export, Reversion and django-admin-sortable.</p>
<p>Model is very simple:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python" data-enlighter-title="models.py" data-enlighter-group="models.py">from adminsortable.models import Sortable


class Category(Sortable):

    """Category (Basic/OTT/...)."""

    name = models.CharField('Ime', max_length=255, unique=True,)
    active = models.BooleanField('Aktivna', default=True)

    class Meta(Sortable.Meta):
        verbose_name = 'Kategorija'
        verbose_name_plural = 'Kategorije'

    def __unicode__(self):
        return self.name</pre>
<p>Admin … well, not so simple, but there are many things going on. Only lines 1-3 are relevant for integration, but this is actually a good example for tips that are about to follow.</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python" data-enlighter-group="admin.py" data-enlighter-title="admin.py" data-enlighter-highlight="1-3">class CategoryAdmin(SortableAdmin, reversion.VersionAdmin):

    change_list_template = "admin/change_list.html"
    change_list_filter_template = "admin/filter_listing.html"
    list_display_popup = ('order_column', 'name', 'active')
    list_display = ('order_column', 'name', 'active', 'contracts_link')
    list_display_links = ('name',)
    list_editable = ('active', )
    list_filter = ('active', )
    search_fields = ('^name',)

    def get_list_display(self, request):
        if IS_POPUP_VAR in request.GET:  # must match with get_queryset
            return self.list_display_popup
        else:
            return self.list_display

    def order_column(self, obj):
        return obj.order
    order_column.admin_order_field = 'order'
    order_column.short_description = 'R.Br.'

    ordering = ('order', )

    def contracts_link(self, obj):
        url = reverse('admin:cori_carrier_changelist')
        html = '&lt;a href="{0}?categories__id__exact={1}"&gt;{2}&lt;/a&gt;'
        return html.format(url, obj.id, obj.num_carriers)
    contracts_link.allow_tags = True
    contracts_link.short_description = 'Nositelji'

    def get_queryset(self, request):
        queryset = super(CategoryAdmin, self).get_queryset(request)
        if not IS_POPUP_VAR in request.GET:
            queryset = queryset.annotate(num_carriers=Count('carriers'))
        return queryset
        

admin.site.register(Category, CategoryAdmin)</pre>
<p>And a custom template (only relevant part is shown).</p>
<pre class="EnlighterJSRAW" data-enlighter-language="html" data-enlighter-group="change_list.html" data-enlighter-title="change_list.html">{% block object-tools %}
  {% if has_add_permission %}
    &lt;ul class="grp-object-tools"&gt;
      {% block object-tools-items %}
        {% if not is_popup %}
          &lt;li&gt;&lt;a href="import/" class="import_link"&gt;{% trans "Import" %}&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href="export/{{ cl.get_query_string }}" class="export_link"&gt;{% trans "Export" %}&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href="{{recoverlist_url}}" class="recoverlink"&gt;{% blocktrans with cl.opts.verbose_name_plural|escape as name %}Recover deleted {{name}}{% endblocktrans %}&lt;/a&gt;&lt;/li&gt;
        {% endif %}
       &lt;li&gt;&lt;a href="add/{% if is_popup %}?_popup=1{% endif %}" class="grp-add-link grp-state-focus"&gt;{% blocktrans with cl.opts.verbose_name as name %}Add {{ name }}{% endblocktrans %}&lt;/a&gt;&lt;/li&gt;
     {% endblock %}
   &lt;/ul&gt;
 {% endif %}
{% endblock %}</pre>
<p>Nothing fancy really, multiple inheritance in right order and custom template. Of course, this custom template is something that should not be necessary in an ideal world. In this world you open the same file from different apps you are combining and copy-paste stuff in right order.</p>
<h2>A better look</h2>
<p>Let’s look closer at the lines in the <em>admin.py</em> example above.</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python" data-enlighter-lineoffset="5">    list_display_popup = ('order_column', 'name', 'active')
    list_display = ('order_column', 'name', 'active', 'contracts_link')
    list_display_links = ('name',)</pre>
<p>Here we defined the columns in the changelist view. We have a different definition for popup windows. As first column is row order and not very informative, we want link to the change view in the <em>second</em> column. Well, we still have to explicitely declare when to use which column definition:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python" data-enlighter-lineoffset="12">    def get_list_display(self, request):
        if IS_POPUP_VAR in request.GET:
            return self.list_display_popup
        else:
            return self.list_display</pre>
<p>As we defined two columns (order_column and contracts_link) that do not exist in the model, we must define methods that return the values … and a bit more:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python" data-enlighter-lineoffset="18">    def order_column(self, obj):
        return obj.order
    order_column.admin_order_field = 'order'
    order_column.short_description = 'R.Br.'

    ordering = ('order', )</pre>
<p>We also defined the column title (short_description), made the column sortable (admin_order_field) and defined this column as default for sorting. We are doing a similar thing for our last column:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python" data-enlighter-lineoffset="25">    def contracts_link(self, obj):
        url = reverse('admin:cori_carrier_changelist')
        html = '&lt;a href="{0}?categories__id__exact={1}"&gt;{2}&lt;/a&gt;'
        return html.format(url, obj.id, obj.num_carriers)
    contracts_link.allow_tags = True
    contracts_link.short_description = 'Nositelji'

    def get_queryset(self, request):
        queryset = super(CategoryAdmin, self).get_queryset(request)
        if not IS_POPUP_VAR in request.GET:
            queryset = queryset.annotate(num_carriers=Count('carriers'))
        return queryset</pre>
<p><a href="https://matijakolaric.com/wp-content/uploads/2014/10/link.png"><img class="alignright wp-image-169" src="https://matijakolaric.com/wp-content/uploads/2014/10/link-449x304.png" alt="link"/></a>But this column is used in navigation, so it has to be a link. We use <em>reverse</em> for URL creation. As we are returning HTML and we do not want it to be escaped, we must declare <em>allow_tags</em> to be <em>True</em>.</p>
<p>We are also extending the query to include a count of related objects.</p>
<p>Now we have a number of related objects in the last column with a link to changelist containing these objects. As this is a many-to-many relationship, we can do this on the other end as well.</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python" data-enlighter-highlight="6">class CarrierAdmin(VersionAdmin):
    list_display = (
        '__unicode__', 'contract_link', 'vendor_link',
        'capitalization_start_date', 'capitalization_end_date',
        'category_link')
    list_filter = ('categories', 'contract__forecast', CapitalizationFilter)
    raw_id_fields = ('contract', 'vendor')
    readonly_fields = ('__unicode__',)
    fieldsets = (
        ...
    )

    def contract_link(self, obj):
        url = reverse('admin:cori_contract_changelist')
        html = '&lt;a href="{0}?id__exact={1}"&gt;{2}&lt;/a&gt;'.format(
            url, obj.contract.id, obj.contract)
        return html
    contract_link.allow_tags = True

    ...

    def get_queryset(self, request):
        queryset = super(CarrierAdmin, self).get_queryset(request)
        queryset = queryset.annotate(num_categories=Count('categories'))
        return queryset.select_related('contract', 'vendor')

admin.site.register(Carrier, CarrierAdmin, inlines=[CarrierCategoryInline])
</pre>
<p>As this model has foreign keys, we want to display them as links. It may seem strange that we link to a changelist containing only a single object, but this makes surfing though our data faster. Once we want to change something (or inspect in more detail), we move to change view.</p>
<h3>List Filters and Search Fields</h3>
<p>Not only that list filters (shown on the right side, see line 6 in above example) can span relationships (contract__forecast), they can also contain completely custom filters. I don’t think I can improve on <a href="https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list_filter" target="_blank">official docs</a>, so check it out. Similar situation is with <a href="https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.search_fields" target="_blank">Search Fields</a>.</p>
<h3>Dynamic Columns in Changelist View</h3>
<p><a href="https://matijakolaric.com/wp-content/uploads/2014/10/dynamic_columns.png"><img class="alignright wp-image-206" src="https://matijakolaric.com/wp-content/uploads/2014/10/dynamic_columns-290x220.png" alt="dynamic_columns"/></a>If you want to have additional dynamically created columns in your changelist view (based on another model perhaps), this is also possible. I doubt that an example can be simple in this case.  Anyway, here is how I did it, in a not-so-simple real-life example.</p>
<p>I use a custom template where I import my own template tags (here period.py):</p>
<pre class="EnlighterJSRAW" data-enlighter-language="html">{% load period %}
{% block result_list %}
    {% result_list cl %}
{% endblock %}</pre>
<p>Then I copy django.contrib.admin.templatetags.admin_list.py to this file and change functions result list and items_for_results, sometimes even with a custom inclusion template:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">@register.inclusion_tag("admin/change_list_results.html")
def result_list(cl):
    """
    Displays the headers and data list together
    """
    cats = Category.objects.filter(active=True)
    headers = list(result_headers(cl, cats))
    num_sorted_fields = 0
    for h in headers:
        if h['sortable'] and h['sorted']:
            num_sorted_fields += 1
    return {'cl': cl,
            'result_hidden_fields': list(result_hidden_fields(cl)),
            'result_headers': headers,
            'num_sorted_fields': num_sorted_fields,
            'results': list(results(cl, cats))}


def items_for_result(cl, result, form, cats):

    ...

    for cat in cats:
        answered = False
        for res in customers:
            if res.category == cat:
                if res.forecast:
                    yield format_html(
                        '&lt;td{0}&gt;{1}', '',
                        number_format(
                            res.number_of_customers,
                            use_l10n=True,
                            force_grouping=True))
                else:
                    yield format_html(
                        '&lt;th{0}&gt;{1}', '',
                        number_format(
                            res.number_of_customers,
                            use_l10n=True,
                            force_grouping=True))
                answered = True
                break
        if not answered:
            yield format_html(' ')</pre>
<p>It’s not DRY and there are legitimate objections that I am aware of. But I never had to use this more than once per project, and it’s quick. (And very very dirty.) Still you do want to optimize your query by defining a custom get_queyset method.</p>
<h2>Change view</h2>
<p>There is a bunch of improvements within change views that increase usability of Django Admin. Only most important ones are mentioned.</p>
<h3>Relational widgets</h3>
<p>Django Admin has four built-in widgets for editing foreign keys (pull-down, horizontal radio, vertical radio and raw_id).</p>
<p><a href="https://matijakolaric.com/wp-content/uploads/2014/10/raw_widgets.png"><img class="alignright wp-image-177" src="https://matijakolaric.com/wp-content/uploads/2014/10/raw_widgets.png" alt="raw_widgets"/></a>Improved raw_id widgets feature links to change views of the related objects. See <a title="Link raw_id_fields (both ForeignKeys and ManyToManyFields) to their change pages" href="https://djangosnippets.org/snippets/2217/" target="_blank">https://djangosnippets.org/snippets/2217/</a>. If you wonder why this is not a default, the reason is that this does not include permission checks, so your app may show a link a user can not follow (and will get HTTP Forbiden page).</p>
<p><a href="https://matijakolaric.com/wp-content/uploads/2014/10/autocomplete.png"><img class="alignleft wp-image-179" src="https://matijakolaric.com/wp-content/uploads/2014/10/autocomplete-290x220.png" alt="autocomplete"/></a>Grappelli skin features auto-complete widgets for relational fields. I use them for all projects where users spend a significant part of their jobs working with my app. One can do all the selects with the keyboard, which is a great time-saver. See <a href="http://django-grappelli.readthedocs.org/en/latest/customization.html#autocomplete-lookups" target="_blank">Grappelli Customization</a>.</p>
<p>It is even possible to combine these two methods. I did it once, but it was too complicated, so I did not use it in the end. Sometimes less is more.</p>
<h3>Change view actions</h3>
<p>I did try to use the same logic (and methods) from changelist view for change view actions and this didn’t work well. However, as these actions are mostly related to changing the state of the object, Django friendly finite state machine (<a href="https://github.com/kmmbvnr/django-fsm" target="_blank">django-fsm</a>) is what I use now.</p>
<p><a href="https://matijakolaric.com/wp-content/uploads/2014/10/django-fsm-admin.png"><img class="alignright wp-image-192" src="https://matijakolaric.com/wp-content/uploads/2014/10/django-fsm-admin-290x220.png" alt="django-fsm-admin"/></a>Again, I prefer to change the templates manually (because this app is mostly used with reversions) and this is all it usually takes:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="js">{% extends 'admin/change_form.html' %}
{% load fsm_admin %}

{% block submit_buttons_bottom %}{% fsm_submit_row %}{% endblock %}</pre>
<p>It may also be necessary to add django.core.context_processors.request to TEMPLATE_CONTEXT_PROCESSORS.</p>
<h3>Positioning of Inlines</h3>
<p><a href="https://matijakolaric.com/wp-content/uploads/2014/10/sortedinlines.png"><img class="alignleft wp-image-211" src="https://matijakolaric.com/wp-content/uploads/2014/10/sortedinlines-449x304.png" alt="sortedinlines"/></a>Inline editing of objects (containing foreign key pointing to the main object) is a great feature of Django Admin, but by default inlines come after fieldsets containing fields. If you have complex model that requires a more logical ordering of fieldsets and inline groups, use Grappelli. It has this great feature that makes this not only possible, but also very simple. In combination with collapsible fieldsets, one can make a very complex model pretty readable.</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python" data-enlighter-highlight="32-34,55-57">fieldsets = (
        ('Overview', {
            'fields': (
                'srs',
                'ld',
                'llt',
            )
        }),
        (None, {
            'fields': (
                ('master',),
            )
        }),
        ('A.1 Safety Report', {
            'classes': ('grp-collapse grp-open',),
            'fields': (
                ('primarysourcecountry', 'occurcountry'),
                'reporttype',
                'serious',
                'seriousnessdeath', 'seriousnesslifethreatening',
                'seriousnesshospitalization', 'seriousnessdisabling',
                'seriousnesscongenitalanomali', 'seriousnessother',
                ('receivedate', 'receiptdate'),
                'additionaldocument',
                'documentlist',
                'fulfillexpeditecriteria',
                'authoritynumb',
                'companynumb',
                'duplicate',
            )
        }),
        ('Report Duplicates', {
            'classes': ('placeholder duplicates-group',),
            'fields': ()
        }),
        ('A.1.12 Linked Reports', {
            'classes': ('grp-collapse grp-open',),
            'fields': (
                'linkedreports',
            )
        }),
        ('A.1.13 Case Nullification', {
            'classes': ('grp-collapse grp-open',),
            'fields': (
                'casenullification',
                'nullificationreason',
            )
        }),
        ('A.1.14 Medical Confirmation', {
            'classes': ('grp-collapse grp-open',),
            'fields': (
                'medicallyconfirm',
            )
        }),
        ('Primary Sources', {
            'classes': ('placeholder primary_sources-group',),
            'fields': ()
        }),
        ('B.1 Patient Identification', {
            'classes': ('grp-collapse grp-open',),
            'fields': (
                ('patientinitial', 'patientsex'),
                ('patientgpmedicalrecordnumb', 'patientspecialistrecordnumb'),
                ('patienthospitalrecordnumb', 'patientinvestigationnumb')
            )
        }),
        ('B.1.2 Age', {
            'classes': ('grp-collapse grp-open',),
            'fields': (
                ('patientbirthdate',),
                ('patientonsetage', 'patientonsetageunit'),
                ('gestationperiod', 'gestationperiodunit'),
                ('patientagegroup')
            )
        }),
       # and this is only about 20% of fieldsets, rest is cut out
    )</pre>
<h3>Changeview Overviews</h3>
<p><a href="https://matijakolaric.com/wp-content/uploads/2014/10/overviewfieldset.png"><img class="alignright wp-image-214" src="https://matijakolaric.com/wp-content/uploads/2014/10/overviewfieldset-290x220.png" alt="overviewfieldset"/></a>This is so simple and all my clients really like this addition to complex models. In the top, as the first fieldset, I add most important information as read-only fields. This is a screenshot of the same view, after overview was added (which is already indicated in the code above).</p>
<h2>Permissions and Related Issues</h2>
<p>When I started writing this post, this is actually what I had in mind to write about. The rest (which is everything up to this point) I just wanted to briefly mention. And then move on to more complex issues.</p>
<p>Well, it tuned out that I have too much material for a 20 minute talk anyway. But as this subject was mentioned in the talk abstract, I can’t really leave it out.</p>
<p>Django has three default permissions (at the time of writing, stable version is 1.7) , to add, change and delete objects. But sometimes that is not nearly enough. So, lets see some basic additions. Please note that a lot of this will be obsolete in Django 1.8.</p>
<h3>Dirty Object Lock</h3>
<p>Often you want a user to access the change view, but make the object read only. Well, one could write a read-only view, but this is simpler.</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">    def change_view(self, request, object_id, extra_context=None):
        if object_id and SafetyReport.objects.get(id=object_id).sent:
            self.message_user(
                request,
                "This object can not be changed.",
                level=messages.WARNING)
        return super(SafetyReportAdmin, self).change_view(
            request, object_id, extra_context=extra_context)

    def save_model(self, request, obj, form, change):
        if obj and obj.id and SafetyReport.objects.get(id=obj.id).sent:
            self.message_user(
                request,
                "This object HAS NOT BEEN CHANGED.",
                level=messages.ERROR)
            raise PermissionDenied()
        obj.date = datetime.today()
        return super(SafetyReportAdmin, self).save_model(
            request, obj, form, change)</pre>
<p>Of course, you may disable the save buttons, but for security reasons you MUST write a custom save method. And it’s always nice to warn your user through the messaging system. Actually, in Admin it is improved and has several visually different levels for messages (warning and error are shown here). Oh, yes, do NOT forget the delete permission!</p>
<h3>Is “obj” defined?</h3>
<p>Often I needed to allow a user to manipulate their own objects, but only see objects owned by other users. In the following example a user can not change objects owned by other’s, unless she is a superuser.</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">    def has_change_permission(self, request, obj=None):
        if not obj:
            return super(SearchAdmin, self).has_delete_permission(request, obj)
        elif request.user.is_superuser or (obj.user and obj.user == request.user):
            return super(SearchAdmin, self).has_delete_permission(request, obj)
        else:
            return False</pre>
<p>This is actually the basis for many permission-related changes – change the functionality of one or more of these methods:</p>
<ul>
<li>ModelAdmin.has_add_permission(request)</li>
<li>ModelAdmin.has_change_permission(request, obj=None)</li>
<li>ModelAdmin.has_delete_permission(request, obj=None)</li>
<li>ModelAdmin.has_module_permission(request) – <em>from Django 1.8</em></li>
</ul>
<h3>Different Functionality Based on Permissions</h3>
<p>Sometimes you want to change the functionality of the change view, for instance lock a certain field, In this case, superuser can change username, other users can not. Be careful with such solutions, you may want to change the save_model method as well, though in this case it is not necessary in current Django version.</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python">    def get_readonly_fields(self, request, obj=None):
        if obj and request.user.is_superuser:
            return ('date',)
        return ('date', 'username')</pre>
<p>Methods that can be used for permission-based customizations are all those that have request in their call.</p>
<h2>Larger changes</h2>
<p>This is called Tips&amp;Tricks, implying simplicity. But sometimes bigger changes are necessary, some pre- or post-processing. In general, it is best to override one of these methods, with changes done before calling super, or between super and return:</p>
<ul>
<li>ModelAdmin.add_view(request, form_url=”, extra_context=None)</li>
<li>ModelAdmin.change_view(request, object_id, form_url=”, extra_context=None)</li>
<li>ModelAdmin.changelist_view(request, extra_context=None)</li>
<li>ModelAdmin.delete_view(request, object_id, extra_context=None)</li>
</ul>
<footer class="line"><span class="entry-info"><strong>Tags:</strong> <a href="https://matijakolaric.com/tag/django/" rel="tag">Django</a>, <a href="https://matijakolaric.com/tag/django-admin/" rel="tag">django-admin</a>, <a href="https://matijakolaric.com/tag/django-grappelli/" rel="tag">django-grappelli</a>, <a href="https://matijakolaric.com/tag/django-mptt/" rel="tag">django-mptt</a></span></footer>
</article>	        
        </div></body></html>