<html><body><div><div class="post-text" itemprop="text">
<blockquote>
  <p>Is this the correct use of conftest.py?</p>
</blockquote>

<p>Yes it is, Fixtures are a potential and common use of <code>conftest.py</code>. The 
fixtures that you will define will be shared among all tests in your test suite. However defining fixtures in the root <code>conftest.py</code> might be useless and it would slow down testing if such fixtures are not used by all tests. </p>

<blockquote>
  <p>Does it have other uses?</p>
</blockquote>

<p>Yes it does.</p>

<ul>
<li><p><strong>Fixtures</strong>: Define fixtures for static data used by tests. This data can be accessed by all tests in the suite unless specified. This could be data as well as helpers of modules which will be passed to all tests.</p></li>
<li><p><strong>External plugin loading</strong>: conftest.py is used to import external plugins or modules. By defining the following global variable, pytest will load the module and make it available for its test. Plugins are generally files defined in your project or other modules which  might be needed in your tests. You can also load a set of predefined plugins as of <a href="https://pytest.org/latest/plugins.html#requiring-loading-plugins-in-a-test-module-or-conftest-file" rel="nofollow">here</a>.</p>

<p><code>pytest_plugins = "someapp.someplugin"</code></p></li>
<li><p><strong>Hooks</strong>: You can specified hooks such as setup and teardown methods and much more to improve your tests. For a set of available hooks, read <a href="https://pytest.org/latest/writing_plugins.html#well-specified-hooks" rel="nofollow">here</a>. Example:</p>

<p><code>def pytest_runtest_setup(item):
     """ called before ``pytest_runtest_call(item)``. """
     #do some stuff</code></p></li>
<li><p><strong>Test root path</strong>: This is a bit of a hidden feature. By defining <code>conftest.py</code> in your root path, you will have <code>pytest</code> recognizing your application modules without specifying <code>PYTHONPATH</code>. On the background, py.test modifies your <code>sys.path</code> by including all submodules which are found from the root path.</p></li>
</ul>

<blockquote>
  <p>Can I have more than one conftest.py file? </p>
</blockquote>

<p>Yes you can and it is strongly recommended if your test structure is somehow complex. <code>conftest.py</code> files have directory scope, therefor creating targeted fixtures and helpers is good practice.</p>

<blockquote>
  <p>When would I want to do that? Examples will be appreciated.</p>
</blockquote>

<p>Several cases could fit:</p>

<p>Creating a set of tools or <strong>hooks</strong> for a particular group of tests</p>

<pre><code>inside root/mod/conftest.py
def pytest_runtest_setup(item):
    print("I am mod")
    #do some stuff


test root/mod2/test.py will NOT produce "I am mod"
</code></pre>

<p>Load a set of <strong>fixtures</strong> for some tests but not for others.</p>

<pre><code>inside root/mod/conftest.py
@pytest.fixture()
def fixture():
    return "some stuff"


inside root/mod2/conftest.py
@pytest.fixture()
def fixture():
    return "some other stuff"


inside root/mod2/test.py
def test(fixture):
    print(fixture)
</code></pre>

<p>Will print "some other stuff"</p>

<p><strong>Override</strong> hooks inherited from the root <code>conftest.py</code></p>

<pre><code>inside root/mod/conftest.py
def pytest_runtest_setup(item):
    print("I am mod")
    #do some stuff

inside root/conftest.py
def pytest_runtest_setup(item):
    print("I am root")
    #do some stuff
</code></pre>

<p>By running any test inside <code>root/mod</code>, only "I am mod" is printed. </p>

<p>You can read more about <code>conftest.py</code> <a href="http://pytest.readthedocs.org/en/latest/plugins.html" rel="nofollow">here</a>.</p>

<p><strong>EDIT:</strong></p>

<blockquote>
  <p>What if I need plain-old helper functions to be called from a number
  of tests in different moduls - will they be available to me if I put
  them in a conftest.py? Or should I simply put them in a helpers.py
  module and import and use it in my test modules?</p>
</blockquote>

<p>You can use <code>conftest.py</code> to define your helpers, however you should follow the common practice. helpers can be used as fixtures at least in <code>py.test</code>. For example in my tests I have a mocked redis helper which I inject into my tests this way.</p>

<pre><code>- content of root/helper/redis/redis.py
@pytest.fixture
def mock_redis():
    return MockRedis()

- content of root/tests/stuff/conftest.py
pytest_plugin="helper.redis.redis"

- content of root/tests/stuff/test.py
def test(mock_redis):
    print(mock_redis.get('stuff'))
</code></pre>

<p>This will be a test module that you can freely import in your tests. <strong>NOTE</strong> that you could potentially name <code>redis.py</code> as <code>conftest.py</code> if your module <code>redis</code> contains more tests. However that practice is discouraged because of ambiguity.</p>

<p>If you want to use <code>conftest.py</code> simply you can put that helper in your root conftest.py and inject it when needed. </p>

<pre><code>- content of root/tests/conftest.py
@pytest.fixture
def mock_redis():
    return MockRedis()

- content of root/tests/stuff/test.py
def test(mock_redis):
    print(mock_redis.get(stuff))
</code></pre>

<p>Another thing you can do is to write an installable plugin. In that case your helper can be written anywhere but it needs to define an entry point to be installed in your and other potential test frameworks. See <a href="https://pytest.org/latest/writing_plugins.html" rel="nofollow">this</a>.</p>

<p>If you don't want to use fixtures, you could of course define a simple helper and just use the plain old import wherever it is needed.</p>

<pre><code>- content of root/tests/helper/redis.py
class MockRedis():
    # stuff

- content of root/tests/stuff/test.py
from helper.redis import MockRedis

def test():
    print(MockRedis().get(stuff))
</code></pre>

<p>However here you might have problems with the path since the module is not in a child folder of the test. You should be able to overcome this (not tested) by adding an <strong>init</strong> to your helper </p>

<pre><code>- content of root/tests/helper/__init__.py
   from .redis import MockRedis
</code></pre>

<p>Or simply adding the helper module to your <code>PYTHONPATH</code>.</p>
    </div>
    </div></body></html>