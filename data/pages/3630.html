<html><body><div><div class="text_cell_render border-box-sizing rendered_html">
<p>In the code you will notice the calculation of the return with:</p><p>
$$ R = p^T w $$</p><p>where $R$ is the expected return, $p^T$ is the transpose of the vector for the mean
returns for each time series and w is the weight vector of the portfolio. $p$ is a Nx1
column vector, so $p^T$ turns into a 1xN row vector which can be multiplied with the
Nx1 weight (column) vector w to give a scalar result. This is equivalent to the dot
product used in the code. Keep in mind that <code>Python</code> has a reversed definition of
rows and columns and the accurate <code>NumPy</code> version of the previous equation would
be <code>R = w * p.T</code></p>
<p>Next, we calculate the standard deviation with</p><p>
$$\sigma = \sqrt{w^T C w}$$</p><p>where $C$ is the covariance matrix of the returns which is a NxN matrix. Please
note that if we simply calculated the simple standard deviation with the appropriate weighting using <code>std(array(ret_vec).T*w)</code> we would get a slightly different
’bullet’. This is because the simple standard deviation calculation would not take
covariances into account. In the covariance matrix, the values of the diagonal
represent the simple variances of each asset while the off-diagonals are the variances between the assets. By using ordinary <code>std()</code> we effectively only regard the
diagonal and miss the rest. A small but significant difference.</p>
<p>Lets generate the mean returns and volatility for 500 random portfolios:</p>

</div>
</div></body></html>