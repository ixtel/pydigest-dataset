<html><body><div><div class="content html_format"><p>
      Участвуя последнее время в разных интересных проектах, возникла задачка альтернативного управления продуктом </p><a href="https://www.perco.ru/products/elektronnye-prohodnye/elektronnaya-prohodnaya-kt02/">Perco Электронная проходная KT02.3</a><p>. Данный продукт является законченным решением и не подразумевает использование в составе других систем СКУД, а также какого-либо вторжения в свою среду управления. Но, как говорится в поговорке, </p><i>«Возможно все! На невозможное просто требуется больше времени» (С) Дэн Браун</i><p>.
</p><p>
Но мы сделали это. Как всё получилось читайте под катом.
</p><a name="habracut"/><p>
Основное описание системы можно прочитать </p><a href="https://www.perco.ru/download/techspec/rus/KT02_TechSpec.pdf">вот из этого документа</a><p>.
</p><p>
Остановимся на внешних интерфейсах системы:
</p><blockquote>Поддерживает подключение по интерфейсу RS-485 следующих устройств:<br/>
• до 8-ми контроллеров замка PERCo-CL201 (контроллер CL201 имеет встроенный считыватель и обеспечивает управление одним замком);<br/>
• табло системного времени PERCo-AU05<br/>
• картоприемник PERCo-IC02.1 (схему подключения см. в описании PERCo-IC02.)</blockquote><p>Это означает, что в общую шину данного турникета может быть подключено достаточное количество периферийных систем, обеспечивающих доступ в помещения.
</p><blockquote>Интерфейс связи с ПК и другими контроллерами системы S-20 – Ethernet (обеспечивается <br/>
поддержка стека протоколов TCP/IP (ARP, IP, ICMP, TCP, UDP, DHCP)).</blockquote><p>Управляется через своё приложение, доступное для скачивания с сайта. Так же имеет очень хитрый SDK, закрываемый NDA.</p><blockquote><i>«Поставка SDK предусматривает подписание с заинтересованной стороной соглашения о неразглашении конфиденциальной информации и осуществляется бесплатно.»</i></blockquote><p> Так как ни схемы турникета ни доступа к SDK у меня не было, вооружившись паяльником и трансивером RS485 мы начали изучать как устроен протокол.
</p><p>
Схема подключения внешних устройств довольно тривиальна.
</p><img src="https://habrastorage.org/files/301/d0a/825/301d0a825b244f229d93a85b4677f037.png" alt="image"/><p>
Можно подключить:
</p><ul>
<li>РУ — радиопульт </li>
<li>ПДУ — пульт дистанционного управления </li>
<li>ДКЗП — Датчик контроля зоны прохода </li>
<li>Сирену</li>
<li>до 8 замков PERCo-CL201</li>
<li>табло системного времени PERCo-AU05</li>
</ul><p>
Никаких других устройств подключить нельзя.</p><p>
Протокол Perco является закрытым, но есть описание часов PERCo-AU05, которое легко гуглится в сети.

</p><img src="https://habrastorage.org/files/2d4/580/b59/2d4580b59a084dd3ada7eae6acf7b389.png" alt="image"/>
<p>
Данная картинка из описания это единственное упоминание протокола PERCo найденное в сети.</p><p>
Отлично. Кусок протокола есть, значит можно посмотреть, что там бегает. Подключаем RS485 к турникету и смотрим.

</p><div class="spoiler"><b class="spoiler_title">Первичный дамп</b><p class="spoiler_text">14:04:08 :: ['0xaa', '0x05', '0x8c', '0x04', '0x01', '0x01', '0x98', '0xfe']<br/>
14:04:08 :: ['0xaa', '0x25', '0x8c', '0x04', '0x01', '0x01', '0x19', '0x39']<br/>
14:04:08 :: ['0xaa', '0x45', '0x8c', '0x04', '0x01', '0x01', '0x99', '0x31']<br/>
14:04:09 :: ['0xaa', '0x65', '0x8c', '0x04', '0x01', '0x01', '0x18', '0xf6']<br/>
14:04:09 :: ['0xaa', '0x85', '0x8c', '0x04', '0x01', '0x01', '0x99', '0x20']<br/>
14:04:09 :: ['0xaa', '0xa5', '0x8c', '0x04', '0x01', '0x01', '0x18', '0xe7']<br/>
14:04:09 :: ['0xaa', '0xc5', '0x8c', '0x04', '0x01', '0x01', '0x98', '0xef']<br/>
14:04:10 :: ['0xaa', '0xe5', '0x8c', '0x04', '0x01', '0x01', '0x19', '0x28']<br/>
14:04:10 :: ['0xaa', '0x05', '0x1a', '0xff', '0xa4', '0xde']<br/>
14:04:10 :: ['0xaa', '0x25', '0x1a', '0xff', '0xa5', '0x14']<br/>
14:04:10 :: ['0xaa', '0x45', '0x1a', '0xff', '0xa5', '0x0a']<br/>
14:04:10 :: ['0xaa', '0x65', '0x1a', '0xff', '0xa4', '0xc0']<br/>
14:04:10 :: ['0xaa', '0x85', '0x1a', '0xff', '0xa5', '0x36']<br/>
14:04:11 :: ['0xaa', '0xa5', '0x1a', '0xff', '0xa4', '0xfc']<br/>
14:04:11 :: ['0xaa', '0xc5', '0x1a', '0xff', '0xa4', '0xe2']<br/>
14:04:11 :: ['0xaa', '0xe5', '0x1a', '0xff', '0xa5', '0x28']<br/>
14:04:11 :: ['0xaa', '0x01', '0x1a', '0xff', '0xe5', '0x1f', '0x7f', '0xa4']<br/>
14:04:11 :: ['0xaa', '0x01', '0x48', '0x04', '0xff', '0x00', '0xff', '0x6f', '0x60', '0xfe', '0x59']<br/>
14:04:11 :: ['0xaa', '0x01', '0xa8', '0x07', '0x01', '0x01', '0xff', '0x01', '0x01', '0xff', '0x01', '0x01', '0xff', '0x44', '0xc2', '0xff', '0xd1']<br/>
14:04:11 :: ['0xaa', '0x21', '0x1a', '0xff', '0xe4', '0xd5', '0x66', '0x64']<br/>
14:04:11 :: ['0xaa', '0x21', '0x48', '0x04', '0xff', '0x00', '0xff', '0x68', '0x00', '0xe7', '0x99']<br/>
14:04:11 :: ['0xaa', '0x21', '0xa8', '0x07', '0x01', '0x01', '0xff', '0x01', '0x01', '0xff', '0x01', '0x01', '0xff', '0xc5', '0x7d', '0xe6', '0x11']<br/>
14:04:11 :: ['0xaa', '0x02', '0x1a', '0xff', '0x15', '0x1f']<br/>
14:04:11 :: ['0xaa', '0x22', '0x1a', '0xff', '0x14', '0xd5']<br/>
14:04:11 :: ['0xaa', '0x04', '0x38', '0x34', '0x02', '0x11', '0x83', '0xfd']<br/>
14:04:11 :: ['0xaa', '0x01', '0x1b', '0x0f', '0xe4', '0xcb', '0xbe', '0x64']<br/>
14:04:11 :: ['0xaa', '0x01', '0x48', '0x02', '0x00', '0xff', '0xff', '0x1e', '0x28', '0xfe', '0x59']<br/>
14:04:11 :: ['0xaa', '0x21', '0x1b', '0x0f', '0xe5', '0x01', '0xa7', '0xa4']<br/>
14:04:11 :: ['0xaa', '0x21', '0x48', '0x02', '0x00', '0xff', '0xff', '0x19', '0x48', '0xe7', '0x99']<br/>
14:04:11 :: ['0xaa', '0x04', '0x38', '0x34', '0x02', '0x11', '0x83', '0xfd']<br/>
14:04:11 :: ['0xaa', '0x04', '0x38', '0x34', '0x02', '0x11', '0x83', '0xfd']<br/>
14:04:11 :: ['0xaa', '0x04', '0x38', '0x34', '0x02', '0x11', '0x83', '0xfd']<br/>
14:04:11 :: ['0xaa', '0x04', '0x38', '0x34', '0x02', '0x11', '0x83', '0xfd']<br/>
14:04:11 :: ['0xaa', '0x05', '0x04', '0x00']<br/>
14:04:11 :: ['0xaa', '0x01', '0x01', '0x0e', '0x10', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x88', '0x22', '0xf5']<br/>
14:04:11 :: ['0xaa', '0x01', '0x09', '0x3e', '0x69', '0x3e', '0x69']<br/>
14:04:11 :: ['0xaa', '0x01', '0x05', '0x16', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0xf2', '0x7a']<br/>
14:04:12 :: ['0xaa', '0x01', '0x1a', '0xff', '0xe5', '0x1f', '0x7f', '0xa4']<br/>
14:04:12 :: ['0xaa', '0x01', '0x48', '0x02', '0x00', '0xff', '0xff', '0x1e', '0x28', '0xfe', '0x59']<br/>
14:04:12 :: ['0xaa', '0x21', '0x01', '0x07', '0x10', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0xfb', '0x65']<br/>
14:04:12 :: ['0xaa', '0x21', '0x09', '0x27', '0xa9', '0x27', '0xa9']<br/>
14:04:12 :: ['0xaa', '0x21', '0x05', '0x4e', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0xf1', '0x6e']<br/>
14:04:12 :: ['0xaa', '0x21', '0x1a', '0xff', '0xe4', '0xd5', '0x66', '0x64']<br/>
14:04:12 :: ['0xaa', '0x21', '0x48', '0x02', '0x00', '0xff', '0xff', '0x19', '0x48', '0xe7', '0x99']<br/>
14:04:12 :: ['0xaa', '0x01', '0x01', '0x4f', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x34', '0x24']<br/>
14:04:12 :: ['0xaa', '0x01', '0x05', '0x40', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x11', '0x24']<br/>
14:04:12 :: ['0xaa', '0x21', '0x01', '0x2e', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0xe7', '0xe0']<br/>
14:04:12 :: ['0xaa', '0x21', '0x05', '0x2d', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x02', '0xdf']<br/>
</p></div><p>
В принципе вообще непонятно, как это работает. Кто отправитель, кто получатель? Где что, чем терминируется? Просто поток каких-то бинарных данных.</p><p>
Провозившись со снятыми дампами несколько дней, я понял, что «дьявол сидит в деталях».</p><p>
Получилась следующая структура байт внутри пакетов для считывателей:
</p><ul>
<li>1. 0xAA — код начала команды</li>
<li>2. 0x[02][12] — идентификатор считывателя</li>
<li>3. 0x0[15] — код команды </li>
<li>какие-то данные</li>
<li>контрольная сумма CRC16</li>
</ul><p>
Что же дальше?</p><p>
Кто это отправляет? Что из этого ответ?</p><p>
Оказалось, что всё намного хитрее, чем мы привыкли видеть в сессионных протоколах.</p><p>
Для понимания этого пришлось подключить считыватели и контроллер в разрыв через два конвертора RS485.</p><p>
Так вот, на самом деле пакет состоит из двух частей. Первая часть — это команда контроллера, всегда начинающаяся с </p><b>0xAA</b><p>, вторая часть — это ответ устройства к которому относилась команда. Данный ответ имеет переменную длину и заканчивается контрольной суммой всего пакета.</p><p>
В реальности сессия «контроллер-считыватель» выглядит вот так:
</p><div class="spoiler"><b class="spoiler_title">разделенный дамп сессии</b><p class="spoiler_text">cntrler:['0xaa', '0x01', '0x1a', '0xff', '0xe5', '0x1f']<br/>
readers:['0x7f', '0xa4']<br/>
cntrler:['0xaa', '0x01', '0x48', '0x04', '0xff', '0x00', '0xff', '0x6f', '0x60']<br/>
readers:['0xfe', '0x59']<br/>
cntrler:['0xaa', '0x01', '0xa8', '0x07', '0x01', '0x01', '0xff', '0x01', '0x01', '0xff', '0x01', '0x01', '0xff', '0x44', '0xc2']<br/>
readers:['0xff', '0xd1']<br/>
cntrler:['0xaa', '0x21', '0x1a', '0xff', '0xe4', '0xd5']<br/>
readers:['0x66']<br/>
readers:['0x64']<br/>
cntrler:['0xaa', '0x21', '0x48', '0x04', '0xff', '0x00', '0xff', '0x68', '0x00']<br/>
readers:['0xe7']<br/>
readers:['0x99']<br/>
cntrler:['0xaa', '0x21', '0xa8', '0x07', '0x01', '0x01', '0xff', '0x01', '0x01', '0xff', '0x01', '0x01', '0xff', '0xc5', '0x7d']<br/>
readers:['0xe6', '0x11']<br/>
cntrler:['0xaa', '0x02', '0x1a', '0xff', '0x15', '0x1f']<br/>
cntrler:['0xaa', '0x02', '0x1a', '0xff', '0x15', '0x1f']<br/>
cntrler:['0xaa', '0x22', '0x1a', '0xff', '0x14', '0xd5']<br/>
cntrler:['0xaa', '0x22', '0x1a', '0xff', '0x14', '0xd5']<br/>
cntrler:['0xaa', '0x04', '0x38', '0x37', '0x2e', '0x11', '0x6f', '0x3d']<br/>
cntrler:['0xaa', '0x01', '0x1b', '0x0f', '0xe4', '0xcb']<br/>
readers:['0xbe']<br/>
readers:['0x64']<br/>
cntrler:['0xaa', '0x01', '0x48', '0x02', '0x00', '0xff', '0xff', '0x1e', '0x28']<br/>
readers:['0xfe', '0x59']<br/>
cntrler:['0xaa', '0x21', '0x1b', '0x0f', '0xe5', '0x01']<br/>
readers:['0xa7', '0xa4']<br/>
cntrler:['0xaa', '0x21', '0x48', '0x02', '0x00', '0xff', '0xff', '0x19', '0x48']<br/>
readers:['0xe7']<br/>
readers:['0x99']<br/>
cntrler:['0xaa', '0x04', '0x38', '0x37', '0x2e', '0x11', '0x6f', '0x3d']<br/>
cntrler:['0xaa', '0x04', '0x38', '0x37', '0x2e', '0x11', '0x6f', '0x3d']<br/>
cntrler:['0xaa', '0x04', '0x38', '0x37', '0x2e', '0x11', '0x6f', '0x3d']<br/>
cntrler:['0xaa', '0x04', '0x38', '0x37', '0x2e', '0x11', '0x6f', '0x3d']<br/>
cntrler:['0xaa', '0x05', '0x04', '0x00']<br/>
cntrler:['0xaa', '0x01', '0x01']<br/>
readers:['0x0f', '0x10', '0x00']<br/>
readers:['0x00', '0x00', '0x00']<br/>
readers:['0x00', '0x00', '0x00']<br/>
readers:['0x00', '0xfb', '0x30']<br/>
cntrler:['0xaa', '0x01', '0x09', '0x3e', '0x69']<br/>
readers:['0x3e', '0x69']<br/>
cntrler:['0xaa', '0x01', '0x05']<br/>
readers:['0x4b']<br/>
readers:['0x00', '0x00', '0x00']<br/>
readers:['0x00', '0x00', '0x00']<br/>
readers:['0x00', '0x00', '0x00']<br/>
readers:['0x60', '0xc1']<br/>
cntrler:['0xaa', '0x01', '0x1a', '0xff', '0xe5', '0x1f']<br/>
readers:['0x7f', '0xa4']<br/>
cntrler:['0xaa', '0x01', '0x48', '0x02', '0x00', '0xff', '0xff', '0x1e', '0x28']<br/>
readers:['0xfe', '0x59']<br/>
cntrler:['0xaa', '0x21', '0x01']<br/>
readers:['0x47']<br/>
readers:['0x10', '0x00', '0x00']<br/>
readers:['0x00', '0x00', '0x00']<br/>
readers:['0x00', '0x00', '0x00']<br/>
readers:['0xf9', '0xb1']<br/>
</p></div><p>
Разберем некоторые комбинации.
</p><blockquote>cntrler:['0xaa', '0x01', '0x1a', '0xff', '0xe5', '0x1f']<br/>
readers:['0x7f', '0xa4']</blockquote><p>Контроллер посылает команду </p><b>'0x1A'</b><p> для считывателя с идентификатором </p><b>'0x01'</b><p> и данными </p><b>'0xFF'</b><p>, на что считыватель отвечает каким-то кодом. Казалось бы «Вот! оно! бери и делай», ан нет.</p><p>
В инструкции написано, что последние два байта пакета это контрольная сумма всего пакета за исключением кода команды, по алгоритму CRC16. Cчитаем CRC16 от </p><b>['0x01', '0x1A', '0xFF']</b><p> на </p><a href="http://www.lammertbies.nl/comm/info/crc-calculation.html">калькуляторе</a><p> и получаем </p><b>0xE01A</b><p>, что никак не сходится с </p><b>0x1FE5</b><p>. Оказывается доблестные разработчики PERCo сделали небольшую защиту или от помех в линии, или от таких как я ;)</p><p>
Дело в том что </p><b>0x1FE5</b><p>, это </p><b>0xE01A xor 0xFFFF</b><p> и об этом естественно нигде не написано (см. мануал выше).</p><p>
Итак, с пакетом от контроллера всё более менее понятно, что же такое прислал считыватель с адресом </p><b>0x01</b><p>?</p><p>
Перебирая данные внутри пакета от контроллера и пошагово считая CRC16 оказалось, что ответ считывателя </p><b>['0x7f', '0xa4']</b><p> это контрольная сумма второго и третьего байта </p><b>['0x01', '0x1A']</b><p>.</p><p>
Таким образом считыватель говорит контроллеру, что он «живой».
</p><div class="spoiler"><b class="spoiler_title">Инициализация</b><p class="spoiler_text">cntrler:['0xaa', '0x01', '0x48', '0x04', '0xff', '0x00', '0xff', '0x6f', '0x60']<br/>
readers:['0xfe', '0x59']<br/>
cntrler:['0xaa', '0x01', '0xa8', '0x07', '0x01', '0x01', '0xff', '0x01', '0x01', '0xff', '0x01', '0x01', '0xff', '0x44', '0xc2']<br/>
readers:['0xff', '0xd1']<br/>
</p></div><p>
Дальше всё так же. Команда заканчивающаяся CRC16 и CRC16 от второго и третьего байта команды.
</p><p>
Остановимся подробнее на адресации внешних устройств.
</p><div class="spoiler"><b class="spoiler_title">адресация внешних замков</b><p class="spoiler_text">['0xaa', '0x05', '0x1a', '0xff', '0xa4', '0xde']<br/>
['0xaa', '0x25', '0x1a', '0xff', '0xa5', '0x14']<br/>
['0xaa', '0x45', '0x1a', '0xff', '0xa5', '0x0a']<br/>
['0xaa', '0x65', '0x1a', '0xff', '0xa4', '0xc0']<br/>
['0xaa', '0x85', '0x1a', '0xff', '0xa5', '0x36']<br/>
['0xaa', '0xa5', '0x1a', '0xff', '0xa4', '0xfc']<br/>
['0xaa', '0xc5', '0x1a', '0xff', '0xa4', '0xe2']<br/>
['0xaa', '0xe5', '0x1a', '0xff', '0xa5', '0x28']<br/>
</p></div><p>
Как видно из дампа, все внешние замки имеют битовую адресацию, отсюда и получается ограничение в 8 внешних замков.</p><p>
После окончания инициализации всех доступных устройств, контроллер на считывателях сбрасывает индикацию
</p><div class="spoiler"><b class="spoiler_title">Сброс индикации</b><p class="spoiler_text">cntrler:['0xaa', '0x01', '0x1b', '0x0f', '0xe4', '0xcb']<br/>
readers:['0xbe', '0x64']<br/>
cntrler:['0xaa', '0x01', '0x48', '0x02', '0x00', '0xff', '0xff', '0x1e', '0x28']<br/>
readers:['0xfe', '0x59']<br/>
cntrler:['0xaa', '0x21', '0x1b', '0x0f', '0xe5', '0x01']<br/>
readers:['0xa7', '0xa4']<br/>
cntrler:['0xaa', '0x21', '0x48', '0x02', '0x00', '0xff', '0xff', '0x19', '0x48']<br/>
readers:['0xe7', '0x99']<br/>
</p></div><p>
Команда контроллера </p><b>0x1B</b><p> резетит считыватель, а команда </p><b>['0x48', lamp]</b><p> зажигает лампочку, где lamp имеет значения.
</p><ul>
<li>0x01 — зеленый</li>
<li>0x02 — оранжевый</li>
<li>0x04 — красный</li>
</ul><p>
После инициализации считывателей, контроллер еще раз проверяет их состояние
</p><div class="spoiler"><b class="spoiler_title">Опрос состояния</b><p class="spoiler_text">cntrler:['0xaa', '0x01', '0x01']<br/>
readers:['0x0e', '0x10', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x88', '0x22', '0xf5']<br/>
cntrler:['0xaa', '0x01', '0x09', '0x3e', '0x69']<br/>
readers:['0x3e', '0x69']<br/>
cntrler:['0xaa', '0x01', '0x05']<br/>
readers:['0x16', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0xf2', '0x7a']<br/>
cntrler:['0xaa', '0x01', '0x1a', '0xff', '0xe5', '0x1f']<br/>
readers:['0x7f', '0xa4']<br/>
cntrler:['0xaa', '0x01', '0x48', '0x02', '0x00', '0xff', '0xff', '0x1e', '0x28']<br/>
readers:['0xfe', '0x59']<br/>
cntrler:['0xaa', '0x21', '0x01']<br/>
readers:['0x07', '0x10', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0xfb', '0x65']<br/>
cntrler:['0xaa', '0x21', '0x09', '0x27', '0xa9']<br/>
readers:['0x27', '0xa9']<br/>
cntrler:['0xaa', '0x21', '0x05']<br/>
readers:['0x4e', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0xf1', '0x6e']<br/>
cntrler:['0xaa', '0x21', '0x1a', '0xff', '0xe4', '0xd5']<br/>
readers:['0x66', '0x64']<br/>
cntrler:['0xaa', '0x21', '0x48', '0x02', '0x00', '0xff', '0xff', '0x19', '0x48']<br/>
readers:['0xe7', '0x99']<br/>
</p></div><p>
и запускает генератор опроса состояния считывателей и замков.</p><p>
Опрос считывателей происходит 3 раза в секунду каждый.</p><p>
А теперь начинается самое интересное.</p><p>
На запрос состояния, считыватель ДОПОЛНЯЕТ команду контроллера данными из своего буфера, считает </p><b>CRC16 xor 0xFFFF</b><p> и выдаёт данные в канал связи.</p><p>
Рассмотрим пакет ответа считывателя:</p><p>
Пустой пакет: </p><b>readers:['0x4e', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0xf1', '0x6e']</b><p>
Пакет с картой: </p><b>readers:['0x45', '0x40', '0x5d', '0x7a', '0x07', '0x00', '0x04', '0x00', '0x00', '0x00', '0xbb', '0x9d']</b>
<ul>
<li>1й байт это номер пакета, который вычисляется путём приращения к предыдущему значению случайного числа из диапазона от 1 до 15, после чего берется значение по модулю <b>79(0x4F)</b></li>
<li>2й байт это состояние считывателя. Если там <b>0x00</b>, то значит буфер считывателя уже прочитан контроллером, если там <b>0x40</b>, то значит в буфере имеется карта.</li>
<li>с 3го по 6 байт помещается код считанной карты.</li>
<li>в 7 байте всегда живёт цифра 4. Остальные байты я не разбирал.</li>
</ul><p>
Если у контроллера присутствует приложенная карта, то контроллер выдаёт команду на считыватель о принятии кода карты, зажигает зеленую лампу и открывает механизм прохода. По истечении времени ожидания или при проходе пользователя механизм прохода закрывается и состояние считывателя сбрасывается в исходное. При этом опрос остальных устройств не прекращается.
</p><p>
А теперь собственно, что подразумевалось в заголовке про «Берегите линии своих СКУД от вторжения»?
</p><p>
Написанный мной на языке питон перехватчик позволяет захватить управление СКУД PERCo в любой точке магистрали RS485 и отследив карты на которые турникет выдаёт разрешение прохода, прерывать передачу данных от считывателя к контроллеру турникета с базой валидных ключей, открывать любые устройства подключенные к магистрали данных. При этом «левые» карты прикладываемые к считывателям системы, могут заменяться на «валидные» и обратно. Сняв дамп блока инициализации и прокрутив его обратно в линию можно эмулировать как сам контроллер, так и считыватели, что открывает просто безграничные возможности для управления системой.
</p><p>
Так что «Берегите линии своих СКУД от вторжения» :)
</p><p>
PS: скрипты выкладывать не буду :-P

</p><font>© Aborche 2016</font>
<img src="https://habrastorage.org/getpro/habr/post_images/cff/19a/9b6/cff19a9b6d0354bbc4d1a45beda58acf.jpg" alt="Aborche"/>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>