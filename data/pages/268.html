<html><body><div><div class="content html_format"><p>
      Добрый день, уважаемые читатели.</p><p>
В сегодняшней статье, я попытаюсь описать процесс анализа временных рядов с помощью python и модуля </p><a href="http://statsmodels.sourceforge.net/stable/index.html">statsmodels</a><p>. Данный модуль предоставляет широкий набор средств и методов для проведения статистического анализа и эконометрики. Я попытаюсь показать основные этапы анализа таких рядов, в заключении мы построим модель </p><b>ARIMA</b><p>.</p><p>
Для примера взяты реальные данные по товарообороту одного из складских комплексов Подмосковья. 
</p><a name="habracut"/>
<h4>Загрузка и предварительная обработка данных</h4><p>
Для начала загрузим данные и посмотрим на них:

</p><pre><code class="python">from pandas import read_csv, DataFrame
import statsmodels.api as sm
from statsmodels.iolib.table import SimpleTable
from sklearn.metrics import r2_score
import ml_metrics as metrics
In [2]:
dataset = read_csv('tovar_moving.csv',';', index_col=['date_oper'], parse_dates=['date_oper'], dayfirst=True)
dataset.head()
</code></pre>
<table border="1">
<tr>
<th/>
<th>Otgruzka</th>
<th>priemka</th>
</tr>
<tr>
<th>date_oper</th>
<th/>
<th/>
</tr>
<tr>
<th>2009-09-01</th>
<td> 179667</td>
<td> 276712</td>
</tr>
<tr>
<th>2009-09-02</th>
<td> 177670</td>
<td> 164999</td>
</tr>
<tr>
<th>2009-09-03</th>
<td> 152112</td>
<td> 189181</td>
</tr>
<tr>
<th>2009-09-04</th>
<td> 142938</td>
<td> 254581</td>
</tr>
<tr>
<th>2009-09-05</th>
<td> 130741</td>
<td> 192486</td>
</tr>
</table>
<p>
Итак, как можно заметить функция </p><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.io.parsers.read_csv.html?highlight=read_csv#pandas.io.parsers.read_csv">read_csv()</a><p>, в данном случем помимо указания параметров, которые задают используемые колонки и индекс, можно заметить еще 3 параметра для работы с датой. Остановимся на них поподробнее.
</p><b>parse_dates</b><p> задает имена столбцов, которые будут преобразованы в тип </p><i>DateTime</i><p>. Стоит отметить, что если в данном столбце будут пустые значения парсинг не удастся и вернется столбец типа </p><i>object</i><p>. Чтобы этого избежать надо добавить параметр </p><i><b>keep_default_na</b>=False</i><p>.</p><p>
Заключительный параметр </p><b>dayfirst</b><p> указывает функции парсинга, что первое в строке первым идет день, а не наоборот. Если не задать этот параметр, то функция может не правильно преобразовывать даты и путать месяц и день местами. Например </p><i>01.02.2013</i><p> будет преобразовано в </p><i>02-01-2013</i><p>, что будет неправильно.</p><p>
Выделим в отдельную серию временной ряд со значениями отгрузкок:

</p><pre><code class="python">otg = dataset.Otgruzka
otg.head()
</code></pre>
<table>
<tr>
<td colspan="2">date_oper</td>
</tr>
<tr>
<td>2009-09-01</td>
<td>179667</td>
</tr>
<tr>
<td>2009-09-02</td>
<td>177670</td>
</tr>
<tr>
<td>2009-09-03</td>
<td>152112</td>
</tr>
<tr>
<td>2009-09-04</td>
<td>142938</td>
</tr>
<tr>
<td>2009-09-05</td>
<td>130741</td>
</tr>
<tr>
<td colspan="2">Name: Otgruzka, dtype: int64</td>
</tr>
</table> <p>
Итак у нас теперь есть временной ряд и можно перейти к его анализу.

</p><h4>Анализ временного ряда</h4><p>
Для начала давайте посмортим график нашего ряда:

</p><pre><code class="python">otg.plot(figsize=(12,6))
</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/df0/23f/343/df023f343f1c2b413ba740906282a09a.png"/><p>
Из графика видно, что наш ряд имеет небольшое кол-во выбросов, которые влияют на разброс. Кроме того анализировать отгрузки за каждый день не совсем верно, т.к., например, в конце или начале недели будут дни в которые товара отгружается значительно больше, нежели в остальные. Поэтому есть смысл перейти к недельному интервалу и среднему значению отгрузок на нем, это избавит нас от выбросов и уменьшит колебания нашего ряда. В </p><b>pandas</b><p> для этого есть удобная функция </p><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.resample.html?highlight=resample#pandas.DataFrame.resample">resample()</a><p>, в качестве параметров ей передается период округления и аггрегатная функция:

</p><pre><code class="python">otg = otg.resample('W', how='mean')
otg.plot(figsize=(12,6))
</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/a7f/d0e/3ee/a7fd0e3eedfd70241188a15d9eb9e099.png"/><p>
Как можно заметить, новый график не имеет ярких выбросов и имеет ярко выраженный тренд. Из это можно сделать вывод о том, что ряд не является стационарным</p><sup><a href="#1">[1]</a></sup><p>.

</p><pre><code class="python">itog = otg.describe()
otg.hist()
itog
</code></pre>
<table>
<tr>
<td>count</td>
<td>225</td>
</tr>
<tr>
<td>mean</td>
<td>270858.285365</td>
</tr>
<tr>
<td>std</td>
<td>118371.082975</td>
</tr>
<tr>
<td>min</td>
<td>872.857143</td>
</tr>
<tr>
<td>25%</td>
<td>180263.428571</td>
</tr>
<tr>
<td>50%</td>
<td>277898.714286</td>
</tr>
<tr>
<td>75%</td>
<td>355587.285714</td>
</tr>
<tr>
<td>max</td>
<td>552485.142857</td>
</tr>
<tr>
<td colspan="2">dtype: float64</td>
</tr>
</table>
<img src="https://habrastorage.org/getpro/habr/post_images/576/3ac/16d/5763ac16d2633ded47bdd4de1be5c0c7.png"/>
<p>
Как можно заметить из характеристик и гистограммы, ряд у нас более менее однородный и имеет относительно небольшой разброс о чем свидетельствует </p><a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%8D%D1%84%D1%84%D0%B8%D1%86%D0%B8%D0%B5%D0%BD%D1%82_%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D1%86%D0%B8%D0%B8#.D0.9E.D1.82.D0.BD.D0.BE.D1.81.D0.B8.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.BF.D0.BE.D0.BA.D0.B0.D0.B7.D0.B0.D1.82.D0.B5.D0.BB.D0.B8">коэффициент вариации</a><p>: </p><img src="https://habrastorage.org/getpro/habr/post_images/4af/791/98a/4af79198a2adfb181b07286dcf7c572e.png" title="LaTeX:V = \frac {\sigma}{\bar{x}}"/><p>, где </p><img src="https://habrastorage.org/getpro/habr/post_images/cbe/3a4/45f/cbe3a445f95d8bfc764b3683e45cc421.png" title="LaTeX:\sigma"/><p> — </p><a href="http://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B5%D0%B4%D0%BD%D0%B5%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BE%D1%82%D0%BA%D0%BB%D0%BE%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5">cреднеквадратическое отклонение</a><p>, </p><img src="https://habrastorage.org/getpro/habr/post_images/2b4/40a/c3d/2b440ac3d4df6d4475d0dce66daf4bd3.png" title="LaTeX:\bar{x}"/><p> — среднее арифметическое выборки. В нашем случае он равен:

</p><pre><code class="python">print 'V = %f' % (itog['std']/itog['mean'])
</code></pre>
<i>V = 0.437022</i>
<p>
Проведем </p><a href="http://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82_%D0%A5%D0%B0%D1%80%D0%BA%D0%B8_%E2%80%94_%D0%91%D0%B5%D1%80%D0%B0">тест Харки — Бера</a><p> для определения номарльности распределения, чтобы подтвердить предположение об однородности. Для этого в существует функция </p><a href="http://statsmodels.sourceforge.net/stable/generated/statsmodels.stats.stattools.jarque_bera.html#statsmodels.stats.stattools.jarque_bera">jarque_bera()</a><p>, которая возвращает значения данной статистики:

</p><pre><code class="python">row =  [u'JB', u'p-value', u'skew', u'kurtosis']
jb_test = sm.stats.stattools.jarque_bera(otg)
a = np.vstack([jb_test])
itog = SimpleTable(a, row)
print itog
</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/342/703/c30/342703c3055e5b8a8dbf46ead588f886.png"/>
<p>
Значение данной статистика свидетельствует о том, нулевая гипотеза о нормальности распределения отвергается с малой вероятностью (</p><i>probably &gt; 0.05</i><p>), и, следовательно, наш ряд имеет нормального распределения.</p><p>
Функция </p><a href="http://statsmodels.sourceforge.net/stable/generated/statsmodels.iolib.table.SimpleTable.html">SimpleTable()</a><p> служит для оформления вывода. В нашем случае на вход ей подается массив значений (размерность не больше 2) и список с названиями столбцов или строк.</p><p>
Многие методы и модели основаны на предположениях о стационарности ряда, но как было замечено ранее наш ряд таковым скорее всего не является. Поэтому для проверки проверки стационарности давайте проведем </p><a href="http://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82_%D0%94%D0%B8%D0%BA%D0%B8_%E2%80%94_%D0%A4%D1%83%D0%BB%D0%BB%D0%B5%D1%80%D0%B0">обобщенный тест Дикки-Фуллера</a><p> на наличие единичных корней. Для этого в модуле </p><b>statsmodels</b><p> есть функция </p><a href="http://statsmodels.sourceforge.net/stable/generated/statsmodels.tsa.stattools.adfuller.html#statsmodels.tsa.stattools.adfuller">adfuller()</a><p>:

</p><pre><code class="python">test = sm.tsa.adfuller(otg)
print 'adf: ', test[0] 
print 'p-value: ', test[1]
print'Critical values: ', test[4]
if test[0]&gt; test[4]['5%']: 
    print 'есть единичные корни, ряд не стационарен'
else:
    print 'единичных корней нет, ряд стационарен'
</code></pre>
<i>adf: -1.38835541357<br/>
p-value: 0.58784577297<br/>
Critical values: {'5%': -2.8753374677799957, '1%': -3.4617274344627398, '10%': -2.5741240890815571}<br/>
есть единичные корни, ряд не стационарен<br/>
</i>
<p>
Проведенный тест подтвердил предположения о не стационарности ряда. Во многих случаях взятие разности рядов позволяет это сделать.Если, например, первые разности ряда стационарны, то он называется </p><i>интегрированным рядом первого порядка</i><p>.</p><p>
Итак, давайте определим </p><i>порядок интегрированного ряда</i><p> для нашего ряда:
 
</p><pre><code class="python">otg1diff = otg.diff(periods=1).dropna()
</code></pre><p>
В коде выше функция </p><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.diff.html?highlight=diff#pandas.DataFrame.diff">diff()</a><p> вычисляет разность исходного ряда с рядом с заданным смещением периода. Период смещения передается как параметр </p><i>period</i><p>. Т.к. в разности первое значение получиться неопределенным, то нам надо избавиться от него для этого и используется метод dropna().</p><p>
Проверим получившийся ряд на стационарность:

</p><pre><code class="python">test = sm.tsa.adfuller(otg1diff)
print 'adf: ', test[0]
print 'p-value: ', test[1]
print'Critical values: ', test[4]
if test[0]&gt; test[4]['5%']: 
    print 'есть единичные корни, ряд не стационарен'
else:
    print 'единичных корней нет, ряд стационарен'
</code></pre>
<i>adf: -5.95204224907<br/>
p-value: 2.13583392404e-07<br/>
Critical values: {'5%': -2.8755379867788462, '1%': -3.4621857592784546, '10%': -2.574231080806213}<br/>
единичных корней нет, ряд стационарен<br/>
</i><p>
Как видно из кода выше получившийся ряд первых разностей приблизился к стационарному. Для полной уверенности разобъем его на несколько промежутков и убедимся мат. ожидания на разных интервалах:

</p><pre><code class="python">m = otg1diff.index[len(otg1diff.index)/2+1]
r1 = sm.stats.DescrStatsW(otg1diff[m:])
r2 = sm.stats.DescrStatsW(otg1diff[:m])
print 'p-value: ', sm.stats.CompareMeans(r1,r2).ttest_ind()[1]
</code></pre>
<i>p-value: 0.693072039563</i>
<p>
Высокое </p><i>p-value</i><p> дает нам возможность утверждать, что нулевая гипотеза о равенстве средних верна, что свидетельствует о стационарности ряда. Осталось убедиться в отсутствии тренда для этого построим график нашего нового ряда:

</p><pre><code class="python">otg1diff.plot(figsize=(12,6))</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/bab/891/d7d/bab891d7d73a02c1772bb5270d3fd81f.png"/><p>
Тренд действительно отсутствует, таким образом ряд первых разностей является стационарным, а наш исходный ряд — </p><i>интегрированным рядом первого порядка</i><p>.

</p><h4>Построение модели временного ряда</h4><p>
Для моделирования будем использовать модель </p><a href="http://ru.wikipedia.org/wiki/ARIMA">ARIMA</a><p>, построенную для ряда первых разностей.</p><p>
Итак, чтобы построить модель нам нужно знать ее порядок, состоящий из 2-х параметров:
</p><ol>
<li><b>p</b> — порядок компоненты <a href="http://ru.wikipedia.org/wiki/%D0%90%D0%B2%D1%82%D0%BE%D1%80%D0%B5%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C">AR</a><br/>
</li>
<li><b>d</b> — порядок интегрированного ряда<br/>
</li>
<li><b>q</b> — порядок компонетны <a href="http://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%B7%D1%8F%D1%89%D0%B5%D0%B3%D0%BE_%D1%81%D1%80%D0%B5%D0%B4%D0%BD%D0%B5%D0%B3%D0%BE">MA</a><br/>
</li>
</ol>
<p>
Параметр </p><b>d</b><p> есть и он равет 1, осталось определить </p><b>p</b><p> и </p><b>q</b><p>. Для их определения нам надо изучить </p><a href="http://ru.wikipedia.org/wiki/%D0%90%D0%B2%D1%82%D0%BE%D0%BA%D0%BE%D1%80%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F">авторкорреляционную(ACF)</a><p> и частично автокорреляционную(PACF) функции для ряда первых разностей.
</p><b>ACF</b><p> поможет нам определить </p><b>q</b><p>, т. к. по ее коррелограмме можно определить количество автокорреляционных коэффициентов сильно отличных от 0 в модели </p><b>MA</b>
<b>PACF</b><p> поможет нам определить </p><b>p</b><p>, т. к. по ее коррелограмме можно определить максимальный номер коэффициента сильно отличный от 0 в модели </p><b>AR</b><p>.</p><p>
Чтобы построить соответствующие коррелограммы, в пакете statsmodels имеются следующие функции: </p><a href="http://statsmodels.sourceforge.net/stable/generated/statsmodels.graphics.tsaplots.plot_acf.html">plot_acf()</a><p> и </p><a href="http://statsmodels.sourceforge.net/stable/generated/statsmodels.graphics.tsaplots.plot_pacf.html">plot_pacf()</a><p>. Они выводят графики </p><i>ACF</i><p> и </p><i>PACF</i><p>, у которых по оси X откладываются номера лагов, а по оси Y значения соответствующих функций. Нужно отметить, что количество лагов в функциях и определяет число значимых коэффициентов. Итак, наши функции выглядят так:

</p><pre><code class="python">ig = plt.figure(figsize=(12,8))
ax1 = fig.add_subplot(211)
fig = sm.graphics.tsa.plot_acf(otg1diff.values.squeeze(), lags=25, ax=ax1)
ax2 = fig.add_subplot(212)
fig = sm.graphics.tsa.plot_pacf(otg1diff, lags=25, ax=ax2)</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/d53/987/229/d539872297b00b030d348bf64d2de75b.png"/><p>
После изучения коррелограммы </p><i>PACF</i><p> можно сделать вывод, что </p><b>p = 1</b><p>, т.к. на ней только 1 лаг сильно отличнен от нуля. По коррелограмме </p><i>ACF</i><p> можно увидеть, что </p><b>q = 1</b><p>, т.к. после лага 1 значении функций резко падают.</p><p>
Итак, когда известны все параметры можно построить модель, но для ее построения мы возмем не все данные, а только часть. Данные из части не попавших в модель мы оставим для проверки точности прогноза нашей модели:

</p><pre><code class="python">src_data_model = otg[:'2013-05-26']
model = sm.tsa.ARIMA(src_data_model, order=(1,1,1), freq='W').fit(full_output=False, disp=0)</code></pre><p>
Параметр </p><i>trend</i><p> отвечает за наличие константы в моделе. Выведем информацаю по получившейся модели:

</p><pre><code class="python">print model.summary()</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/456/8cb/60c/4568cb60c266c0d0fda33ae587fd54be.png"/>
<p>
Как видно из данной информации в нашей модели все коэффициенты значимые и можно перейти к оценке модели.

</p><h4>Анализ и оценка модели</h4><p>
Проверим остатки данной модели на соответствие </p><a href="http://ru.wikipedia.org/wiki/%C1%E5%EB%FB%E9_%F8%F3%EC">«белому шуму»</a><p>, а также проанализируем коррелограму остатков, так как это может нам помочь в определении важных для включения и прогнозирования элементов регрессии.</p><p>
Итак первое, что мы сделаем это проведем </p><a href="http://ru.wikipedia.org/wiki/Q-%D1%82%D0%B5%D1%81%D1%82_%D0%9B%D1%8C%D1%8E%D0%BD%D0%B3%D0%B0_%E2%80%94_%D0%91%D0%BE%D0%BA%D1%81%D0%B0">Q-тест Льюнга — Бокса</a><p> для проверки гипотезы о том, что остатки случайны, т. е. являются «белым шумом». Данный тест проводится на остатках модели </p><b>ARIMA</b><p>. Таким образом, нам надо сначала получить остатки модели и построить для них ACF, а затем к получившимся коэффициентам приметить тест. С помощью </p><i>statsmadels</i><p> это можно сделать так:

</p><pre><code class="python">q_test = sm.tsa.stattools.acf(model.resid, qstat=True) #свойство resid, хранит остатки модели, qstat=True, означает что применяем указынный тест к коэф-ам
print DataFrame({'Q-stat':q_test[1], 'p-value':q_test[2]})</code></pre>
<div class="spoiler"><b class="spoiler_title">Результат</b><div class="spoiler_text"><table>
<tr>
<th> </th>
<th>Q-stat</th>
<th>p-value</th>
</tr>
<tr>
<td>0</td>
<td> 0.531426</td>
<td>0.466008</td>
</tr>
<tr>
<td>1</td>
<td> 3.073217</td>
<td>0.215109</td>
</tr>
<tr>
<td>2</td>
<td> 3.644229</td>
<td>0.302532</td>
</tr>
<tr>
<td>3</td>
<td> 3.906326</td>
<td>0.418832</td>
</tr>
<tr>
<td>4</td>
<td> 4.701433</td>
<td>0.453393</td>
</tr>
<tr>
<td>5</td>
<td> 5.433745</td>
<td>0.489500</td>
</tr>
<tr>
<td>6</td>
<td> 5.444254</td>
<td>0.605916</td>
</tr>
<tr>
<td>7</td>
<td> 5.445309</td>
<td>0.709091</td>
</tr>
<tr>
<td>8</td>
<td> 5.900762</td>
<td>0.749808</td>
</tr>
<tr>
<td>9</td>
<td> 6.004928</td>
<td>0.814849</td>
</tr>
<tr>
<td>10</td>
<td>6.155966</td>
<td>0.862758</td>
</tr>
<tr>
<td>11</td>
<td>6.299958</td>
<td>0.900213</td>
</tr>
<tr>
<td>12</td>
<td>12.731542</td>
<td>0.468755</td>
</tr>
<tr>
<td>13</td>
<td>14.707894</td>
<td>0.398410</td>
</tr>
<tr>
<td>14</td>
<td>20.720607</td>
<td>0.145996</td>
</tr>
<tr>
<td>15</td>
<td>23.197433</td>
<td>0.108558</td>
</tr>
<tr>
<td>16</td>
<td>23.949801</td>
<td>0.120805</td>
</tr>
<tr>
<td>17</td>
<td>24.119236</td>
<td>0.151160</td>
</tr>
<tr>
<td>18</td>
<td>25.616184</td>
<td>0.141243</td>
</tr>
<tr>
<td>19</td>
<td>26.035165</td>
<td>0.164654</td>
</tr>
<tr>
<td>20</td>
<td>28.969880</td>
<td>0.114727</td>
</tr>
<tr>
<td>21</td>
<td>28.973660</td>
<td>0.145614</td>
</tr>
<tr>
<td>22</td>
<td>29.017716</td>
<td>0.179723</td>
</tr>
<tr>
<td> 23</td>
<td>32.114006</td>
<td>0.124191</td>
</tr>
<tr>
<td> 24</td>
<td>32.284805</td>
<td>0.149936</td>
</tr>
<tr>
<td> 25</td>
<td>33.123395</td>
<td>0.158548</td>
</tr>
<tr>
<td> 26</td>
<td>33.129059</td>
<td>0.192844</td>
</tr>
<tr>
<td> 27</td>
<td>33.760488</td>
<td>0.208870</td>
</tr>
<tr>
<td> 28</td>
<td>38.421053</td>
<td>0.113255</td>
</tr>
<tr>
<td> 29</td>
<td>38.724226</td>
<td>0.132028</td>
</tr>
<tr>
<td> 30</td>
<td>38.973426</td>
<td>0.153863</td>
</tr>
<tr>
<td> 31</td>
<td>38.978172</td>
<td>0.184613</td>
</tr>
<tr>
<td> 32</td>
<td>39.318954</td>
<td>0.207819</td>
</tr>
<tr>
<td> 33</td>
<td>39.382472</td>
<td>0.241623</td>
</tr>
<tr>
<td> 34</td>
<td>39.423763</td>
<td>0.278615</td>
</tr>
<tr>
<td> 35</td>
<td>40.083689</td>
<td>0.293860</td>
</tr>
<tr>
<td> 36</td>
<td>43.849515</td>
<td>0.203755</td>
</tr>
<tr>
<td> 37</td>
<td>45.704476</td>
<td>0.182576</td>
</tr>
<tr>
<td> 38</td>
<td>47.132911</td>
<td>0.174117</td>
</tr>
<tr>
<td> 39</td>
<td>47.365305</td>
<td>0.197305</td>
</tr>
</table>
</div></div><p>
Значение данной статистики и p-values, свидетельствуют о том, что гипотеза о случайности остатков не отвергается, и скорее всего данный процесс представляет «белый шум».</p><p>
Теперь давайте расчитаем коэффициент детерминации</p><img src="https://habrastorage.org/getpro/habr/post_images/879/d5c/f0f/879d5cf0fa87faddaefd28fc0906ad27.png" title="LaTeX:R^2"/><p>, чтобы понять какой процент наблюдений описывает данная модель:

</p><pre><code class="python">pred = model.predict('2013-05-26','2014-12-31', typ='levels')
trn = otg['2013-05-26':]
r2 = r2_score(trn, pred[1:32])
print 'R^2: %1.2f' % r2</code></pre>
<i>R^2: -0.03</i>
<p>
Среднеквадратичное отклонение</p><sup><a href="#2">[2]</a></sup><p> нашей модели:

</p><pre><code class="python">metrics.rmse(trn,pred[1:32])</code></pre>
<i>80919.057367642512</i>
<p>
Средняя абсолютная ошибка</p><sup><a href="#2">[2]</a></sup><p> прогноза:

</p><pre><code class="python">metrics.mae(trn,pred[1:32])</code></pre>
<i>63092.763277651895</i>
<p>
Осталось нарисовать наш прогноз на графике:

</p><pre><code class="python">otg.plot(figsize=(12,6))
pred.plot(style='r--')</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/96d/886/1ee/96d8861ee02340c0d2ccdf49c89bf365.png"/>

<h4>Заключение</h4><p>
Как можно заметить из графика наша модель строит не очень хороший прогноз. Отчасти это связано с выбросами в исходных данных, которые мы не доконца убрали, а также с модулем </p><b>ARIMA</b><p> пакета </p><i>statsmodels</i><p>, т. к. он достаточно новый. Статья больше направлена на то, чтобы показать как именно можно анализировать временные ряды на python. Также хотелось бы отметить, что в рассмотреном сегодня пакет очень полно реализованы различные методы регрессионного анализ (постараюсь показать в дальнейших статьях).</p><p>
В целом для небольших исследований пакет statsmodels в полне пригоден, но для серьезной научной работы все же пока сыроват и некоторые тесты и статистики в нем отсутствуют.
 
</p><h4>Ссылки</h4>
<ol>
<li>И.И. Елисеева. Эконометрика<br/>
</li>
<li><a href="http://www.basegroup.ru/solutions/scripts/details/compare_model/">Сравнение моделей временных рядов</a><br/>
</li>
</ol>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>