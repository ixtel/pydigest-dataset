<html><body><div><div>
<div class="section" id="introduction">
<h2>Introduction</h2>
<p>I just released Morepath 0.10 (<a class="reference external" href="https://morepath.readthedocs.org/en/0.10/changes.html">CHANGES</a>)! <a class="reference external" href="http://morepath.readthedocs.org">Morepath</a> is a modern Python
web framework that <strong>combines power with simplicity of use</strong>. Morepath
0.10's biggest new feature is <strong>server-side templating support</strong>.</p>
<p>Most Python web frameworks were born at a time when server-side
templating was the only way to get HTML content into a web
browser. Templates in the browser did not yet exist. Server templating
was a necessity for a server web framework, built-in from day 1.</p>
<p>The web has changed and much more can be done in the browser now: if
you want a web page, you can accomplish it with client-side JavaScript
code, helped by templates, or embedded HTML-like snippets in
JavaScript, like what the React framework does. Morepath is a web
framework that was born in this new era.</p>
<p>Morepath could take a more leisurely approach to server templating.
We recommend that users rely on client-side technology to construct a
UI -- something that Morepath is very good at supporting. For many web
applications, this approach is fine and leads to more responsive user
interfaces. It also has the benefit that it supports a strong
separation between user interface and underlying data. And you <em>could</em>
still use server template engines with Morepath, but with no help from
the framework.</p>
<p>But there is still room for server templates. Server-generated HTML
has its advantages. It's the easiest way to create a bookmarkable
traditional web site -- no client-side routing needed. For more
dynamic web applications it can also sometimes make sense to send a
server-rendered HTML page to the client as a starting point, and only
switch to a client-side dynamic code later. This is useful in those
cases where you want the end-user to see a web page as quickly as
possible: in that case sending HTML directly from the server can still
be faster, as there is no need for the browser to load and process
JavaScript in order to display some content.</p>
<p>So now Morepath has now, at last, gained server template support, in
version 0.10. We took our time. We prototyped a bit first. We worked
out the details of the rest of the framework. As we will see, it's
nice we had the chance to spend time on other aspects of Morepath
first, as that infrastructure now also makes template language
integration very clean.</p>
</div>
<div class="section" id="the-basics">
<h2>The basics</h2>
<p>Say you want to use <a class="reference external" href="http://jinja.pocoo.org/">Jinja2</a>, the template language used by Flask, in
Morepath. Morepath does not ship with Jinja2 or any other template
language by default. Instead you can install it as a plugin in your
own project. The first thing you do is modify your project's
<tt class="docutils literal">setup.py</tt> and add <tt class="docutils literal">more.jinja2</tt> to <tt class="docutils literal">install_requires</tt>:</p>
<pre class="literal-block">
install_requires=[
  'more.jinja2',
],
</pre>
<p>Now when you install your project's dependencies, it pulls in
<a class="reference external" href="http://pypi.python.org/pypi/more.jinja2">more.jinja2</a>, which also pulls in the Jinja2 template engine
itself.</p>
<p>Morepath's extension system works through subclassing. If you want
Jinja2 support in your Morepath application, you need to subclass your
Morepath app from the <tt class="docutils literal">Jinja2App</tt>:</p>
<pre class="literal-block">
from more.jinja2 import Jinja2App

class App(Jinja2App):
    pass
</pre>
<p>The <tt class="docutils literal">App</tt> class is now aware of Jinja2 templates.</p>
<p>Next you need to tell your app what directory to look in for templates:</p>
<pre class="literal-block">
@App.template_directory()
def get_template_directory():
    return 'templates'
</pre>
<p>This tells your app to look in the <tt class="docutils literal">templates</tt> directory next to the
Python module you wrote this code in, so the <tt class="docutils literal">templates</tt>
subdirectory of the Python package that contains your code.</p>
<p>Now you can use templates in your code. Here's a HTML view with a
template:</p>
<pre class="literal-block">
@App.html(model=Customer, template='customer.jinja2')
def customer_default(self, request):
    return {
      'name': self.name,
      'street': self.street,
      'city': self.city,
      'zip': self.zip_code
    }
</pre>
<p>The view returns a dictionary. This dictionary contains the variables
that should go into the <tt class="docutils literal">customer.jinja2</tt> template, which should be
in the <tt class="docutils literal">templates</tt> directory. Note that you have to use the
<tt class="docutils literal">jinja2</tt> extension, as Morepath recognizes how to interpret a
template by its extension.</p>
<p>You can now write the <tt class="docutils literal">customer.jinja2</tt> template that uses this
information:</p>
<pre class="literal-block">
&lt;html&gt;
&lt;body&gt;
  &lt;p&gt;Customer {{name}} lives on {{street}} in {{city}}.&lt;/p&gt;
  &lt;p&gt;The zip code is {{zip}}.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>You can use the usual <a class="reference external" href="http://jinja.pocoo.org/">Jinja2</a> constructs here.</p>
<p>When you access the view above, the template gets rendered.</p>
</div>
<div class="section" id="chameleon">
<h2>Chameleon</h2>
<p>What if you want to use <a class="reference external" href="https://chameleon.readthedocs.org/">Chameleon</a> (ZPT) templates instead of Jinja2
templates? We've provided <a class="reference external" href="http://pypi.python.org/pypi/more.chameleon">more.chameleon</a> that has this integration.
Include it in <tt class="docutils literal">install_requires</tt> in <tt class="docutils literal">setup.py</tt>, and then do this
to integrate it into your app:</p>
<pre class="literal-block">
from more.chameleon import ChameleonApp

class App(ChameleonApp):
    pass
</pre>
<p>You can now set up a template directory and put in <tt class="docutils literal">.pt</tt> files,
which you can then refer to from the <tt class="docutils literal">template</tt> argument to views.</p>
<p>You could even subclass both <tt class="docutils literal">ChameleonApp</tt> <em>and</em> <tt class="docutils literal">Jinja2App</tt> apps
and have an application that uses both Chameleon and Jinja2
templates. While that doesn't seem like a great idea, Morepath does
allow multiple applications to be <a class="reference external" href="http://morepath.readthedocs.org/en/latest/app_reuse.html#nesting-applications">composed</a> into a larger application,
so it is nice that it is possible to combine an application that uses
Jinja2 with another one that uses Chameleon.</p>
</div>
<div class="section" id="overrides">
<h2>Overrides</h2>
<p>Imagine there is an application developed by a third party that has a
whole bunch of templates in them. Now without changing that
application directory you want to override a template in it. Perhaps
you want to override a master template that sets up a common look and
feel, for instance.</p>
<p>In Morepath, template overrides can be done by subclassing the
application (just like you can override anything else):</p>
<pre class="literal-block">
class SubApp(App):
    pass

@SubApp.template_directory()
def get_template_directory_override():
    return 'override_templates'
</pre>
<p>That <a class="reference external" href="http://morepath.readthedocs.org/en/latest/api.html#morepath.App.template_directory">template_directory</a> directive tells <tt class="docutils literal">SubApp</tt> to look for
templates in <tt class="docutils literal">override_templates</tt> first before it checks the
<tt class="docutils literal">templates</tt> directory that was set up by <tt class="docutils literal">App</tt>.</p>
<p>If we want to override <tt class="docutils literal">master.jinja2</tt>, all we have to do is copy it
from <tt class="docutils literal">templates</tt> into <tt class="docutils literal">override_templates</tt> and change it to suit
our purposes. Since a template with that name is found in
<tt class="docutils literal">override_templates</tt> first, it is found instead of the one in
<tt class="docutils literal">templates</tt>. The original <tt class="docutils literal">App</tt> remains unaffected.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation</h2>
<p>In the introduction we mentioned that the template language
integration code into Morepath is clean. You should be able to
integrate other template engines easily too. Here is the code that
integrates Jinja2 into Morepath:</p>
<pre class="literal-block">
import os
import morepath
import jinja2


class Jinja2App(morepath.App):
    pass


@Jinja2App.setting_section(section='jinja2')
def get_setting_section():
    return {
        'auto_reload': False,
    }


@Jinja2App.template_loader(extension='.jinja2')
def get_jinja2_loader(template_directories, settings):
    config = settings.jinja2.__dict__.copy()

    # we always want to use autoescape as this is about
    # HTML templating
    config.update({
        'autoescape': True,
        'extensions': ['jinja2.ext.autoescape']
    })

    return jinja2.Environment(
      loader=jinja2.FileSystemLoader(template_directories),
      **config)


@Jinja2App.template_render(extension='.jinja2')
def get_jinja2_render(loader, name, original_render):
    template = loader.get_template(name)

    def render(content, request):
        variables = {'request': request}
        variables.update(content)
        return original_render(template.render(**variables), request)
    return render
</pre>
<p>The <a class="reference external" href="http://morepath.readthedocs.org/en/latest/api.html#morepath.App.template_loader">template_loader</a> directive sets up an object that knows how to
load templates from a given list of template directories. In the case
of Jinja2 that is the Jinja2 environment object.</p>
<p>The <a class="reference external" href="http://morepath.readthedocs.org/en/latest/api.html#morepath.App.template_render">template_render</a> directive then tells Morepath how to render
individual templates: get them from the loader first, and then
construct a function that given <tt class="docutils literal">content</tt> returned by the view
function and <tt class="docutils literal">request</tt>, uses the template to render it.</p>
</div>

</div>
    </div></body></html>