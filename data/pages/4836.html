<html><body><div><div class="content html_format"><p>
      Доброго времени суток, хабр!</p>
<p>
Здесь мы не будем рассуждать о плюсах и минусах языков.

</p><img src="https://habrastorage.org/files/c1b/779/c3b/c1b779c3b4bb4c44816e9dd98a88b2bc.png"/>
<p>
Мы будем использовать их вместе!

</p><img src="https://habrastorage.org/files/603/3fa/ca4/6033faca468c4c6ba6c44ce6313d1f76.png"/>
<a name="habracut"/><p>
В этом нам поможет замечательная библиотека </p><a href="https://github.com/ariovistus/pyd">pyd</a><p>. С её помощью можно как вызывать код на python из кода на d, так и наоборот.
</p><p>
Рассмотрим первый вариант. Заполняем файл dub.json:

</p><pre><code class="javascript">{
    "name": "pydtest",
	"targetType": "executable",
	"dependencies": {
        "pyd": "~&gt;0.9.7"
	},
    "subConfigurations": {
        "pyd": "python34"
    }
}
</code></pre><p>
subConfigurations указывает, что мы будем использовать python 3.4
</p><p>
Создаём source/main.d:

</p><pre><code class="cpp">import std.stdio;
import pyd.pyd, pyd.embedded;

void main()
{
    py_init();

    auto script = new InterpContext;
    // следующие 2 строки позволяют искать модули в текущей директории
    // это нужно чтобы не устанавливать наш пакет myscript.py в систему 
    script.py_stmts( "import sys" );
    script.py_stmts( "sys.path.append('.')" );

    script.py_stmts( "import myscript" );

    writeln( script.py_eval!string( "myscript.func()" ) ~ " from pyd" );
}
</code></pre><p>
Создаём myscript.py
</p><pre><code class="python">def func():
    return "hello habr!"
</code></pre><p>
Запускаем сборку и её результат
</p><pre><code class="bash">dub build &amp;&amp; ./pydtest
</code></pre><p>
И всё!
</p><pre><code class="bash">hello habr! from pyd
</code></pre><p>
Всё настолько просто!
</p><p>
Попробуем немного усложнить. Добавим функцию сложения чисел в myscript.py:

</p><pre><code class="python">def sum(a,b):
    return a + b
</code></pre><p>
И вызовем её из кода на D. Добавим это в функцию main.main:

</p><pre><code class="cpp">...
    script.x = 13;
    script.y = 21;

    writefln( "result: %d", script.py_eval!int( "myscript.sum(x,y)" ) );
...
</code></pre><p>
Усложнить не получилось.
</p><p>
Класс InterpContext олицетворяет контекст интерпретатора (как ни странно) и мы можем добавлять туда переменные таким простым способом. Поля x и y не являются частью объекта script — таких полей нет, но это работает потому, что в языке D есть возможность конвертировать вызовы несуществующих методов класса (или структуры) в вызов метода opDispatch, который, как в данном случае, может быть свойством.

</p><div class="spoiler"><b class="spoiler_title">Код метода InterpContext.opDispatch</b><div class="spoiler_text"><pre><code class="cpp">   @property PydObject opDispatch(string id)() { // возвращает значение из контекста
        return this.locals[id];
    }

    @property void opDispatch(string id, T)(T t) { // записывает значение в контекст
        static if(is(T == PydObject)) {
            alias t s;
        }else{
            PydObject s = py(t);
        }
        this.locals[id] = py(s);
    }
</code></pre>
</div></div><p>
Таким же способом мы можем взять объект из контекста:

</p><pre><code class="cpp">...
    script.py_stmts( "z = myscript.sum(8,7)" );
    writefln( "result2: %d", script.z.to_d!int );
...
</code></pre><p>
Да и функции можно вызывать практически так же:

</p><pre><code class="cpp">...
    auto sum = script.myscript.sum;
    writefln( "result3: %d", sum(14,15).to_d!int );
...
</code></pre>
<div class="spoiler"><b class="spoiler_title">некоторые моменты</b><div class="spoiler_text"><p>синтаксис property в языке D является </p><a href="http://wiki.dlang.org/Property_Discussion_Wrap-up">давно обсуждаемой темой</a><p>, а конкретно вопрос связан с ситуацией, когда property возвращает объект с методом opCall:

</p><pre><code class="cpp">script.myscript.sum(14,15).to_d!int; // сработает, что странно, было бы логично запретить
script.myscript.oneargfunc(12).to_d!int; // не скомпилируется, так как oneargfunc(12) это вызов opDispatch с параметром 12
script.myscript.oneargfunc()(12).to_d!int; // тут всё в порядке: явно вызывается oneargfunc(), затем у результата вызывается opCall(12)
</code></pre>
</div></div><p>
Теперь попробуем наоборот из кода на python вызвать код на D. Создадим новую папку для этого.</p><p>
Создадим файл dcode.d с содержанием:

</p><pre><code class="cpp">module dcode;

import pyd.pyd;
import std.math;

float[] calc( float x, float y )
{
    return [ sqrt(x*y), x^^y, x/y ];
}

extern(C) void PydMain()
{
    def!(calc)();
    module_init();
}
</code></pre><p>
И файл setup_my_dcode.py (имя никак не влияет):

</p><pre><code class="python">from pyd.support import setup, Extension
projName = 'dcode'
setup(
    name=projName,
    version='0.1',
    ext_modules=[
        Extension(projName, ['dcode.d'],
            extra_compile_args=['-w'],
            build_deimos=True,
            d_lump=True
        )
    ],
)
</code></pre><p>
соберём наше расширение (именно build, а не install, чтобы не засорять систему тестовыми файлами):

</p><pre><code class="bash">python3 setup_my_dcode.py build
</code></pre><p>
создасться папочка build такого содержания
</p><pre><code class="bash">build
├── lib.linux-x86_64-3.4
│   └── dcode.cpython-34m.so
└── temp.linux-x86_64-3.4
    └── infra
        ├── pydmain.d
        ├── so_ctor.o
        └── temp.o
</code></pre><p>
Нас интересует build/lib.linux-x86_64-3.4/dcode.cpython-34m.so. Копируем его в текущую директорию или переходим в папку с ним и можем проверять прямо в интерактивном интерпретаторе:

</p><pre><code class="python">python3
Python 3.4.1 (default, Nov  3 2014, 14:38:10) 
[GCC 4.9.1 20140930 (Red Hat 4.9.1-11)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import dcode
&gt;&gt;&gt; dcode.calc( 5, 12 )
[7.745966911315918, 244140624.0, 0.4166666567325592]
&gt;&gt;&gt; 
</code></pre><p>
И опять всё достаточно просто!
</p><p>
И опять попробуем всё усложнить — добавим класс в dcode.d:

</p><pre><code class="cpp">class Foo
{
    float a = 0, b = 0;
    static string desc() { return "some ops"; }
    this( float A, float B ) { a = A; b = B; }
    float sum() const { return a + b; }
    float div() const { return a / b; }
}

extern(C) void PydMain()
{
    def!(calc)(); // сначала функции
    module_init(); // затем инициализация модуля
    wrap_class!( // только потом классы
        Foo,
        Init!(float,float),
        Repr!(Foo.toString), // как python будет это переводить в строку
        Def!(Foo.sum),
        Def!(Foo.div),
        StaticDef!(Foo.desc)
    )();
}
</code></pre><p>
К сожалению в этой ситуации всё действительно немного усложнилось. Для работы с классами D в python нужно объявлять конструкторы, функции и т.д.
</p><p>
Собираем, проверяем:

</p><pre><code class="python">python3
Python 3.4.1 (default, Nov  3 2014, 14:38:10) 
[GCC 4.9.1 20140930 (Red Hat 4.9.1-11)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from dcode import Foo
&gt;&gt;&gt; Foo.desc()
'some ops'
&gt;&gt;&gt; a = Foo(1,2)
&gt;&gt;&gt; a.div()
0.5
&gt;&gt;&gt; a.sum()
3.0
&gt;&gt;&gt; 
</code></pre><p>
Работает!
</p><p>
О вариантах применения говорить не нужно: их много и они интересны. Стоит упомянуть, что библиотека ещё не дошла до стабильной версии 1.0.0 и могут встречаться ошибки. 
</p><p>
Я нашёл только одну проблему: нельзя запустить код на D из кода на python, встроенного в код на D:

</p><img src="https://habrastorage.org/files/bf9/07e/37e/bf907e37e4ea458086d5c734719f1b62.jpg"/>
<p>
Но мне кажется, это не фундаментальная проблема и автор её сможет легко исправить.
</p><p>
Очень приятная документация по проекту находится </p><a href="http://pyd.readthedocs.org/en/latest/extend.html">здесь</a><p> и ещё примеры </p><a href="https://github.com/ariovistus/pyd/tree/master/examples">здесь</a><p>.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>