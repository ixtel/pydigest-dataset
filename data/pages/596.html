<html><body><div><div class="post-content"><p>Recently I saw a question on Stack Overflow about waiting for multiple events with a Tornado coroutine, until <em>one</em> of the events completes. The inquirer wanted to do something like this:</p>
<div class="codehilite"><pre>result <span>=</span> <span>yield</span> Any([future1, future2, future3])
</pre></div>


<p>If the middle future has resolved and the other two are still pending, the result should be like:</p>
<div class="codehilite"><pre>[<span>None</span>, <span>"&lt;some result&gt;"</span>, <span>None</span>]
</pre></div>


<p>Tornado doesn't provide a class like Any. How would you implement one?</p>
<p><strong>Contents:</strong></p>

<h1 id="a-bad-beginning">A Bad Beginning</h1>
<p>You could make a class that inherits from Future, and wraps a list of futures. The class waits until one of its futures resolves, then gives you the list of results:</p>
<div class="codehilite"><pre><span>class</span> <span>Any</span>(Future):
    <span>def</span> <span>__init__</span>(<span>self</span>, futures):
        <span>super</span>(Any, <span>self</span>)<span>.</span>__init__()
        <span>self</span><span>.</span>futures <span>=</span> futures
        <span>for</span> future <span>in</span> futures:
            <span># done_callback is defined just below.</span>
            future<span>.</span>add_done_callback(<span>self</span><span>.</span>done_callback)

    <span>def</span> <span>done_callback</span>(<span>self</span>, future):
        <span>"""Called when any future resolves."""</span>
        <span>try</span>:
            <span>self</span><span>.</span>set_result(<span>self</span><span>.</span>make_result())
        <span>except</span> <span>Exception</span> <span>as</span> e:
            <span>self</span><span>.</span>set_exception(e)

    <span>def</span> <span>make_result</span>(<span>self</span>):
        <span>"""A list of results.</span>

<span>        Includes None for each pending future, and a result for each</span>
<span>        resolved future. Raises an exception for the first future</span>
<span>        that has an exception.</span>
<span>        """</span>
        <span>return</span> [f<span>.</span>result() <span>if</span> f<span>.</span>done() <span>else</span> <span>None</span>
                <span>for</span> f <span>in</span> <span>self</span><span>.</span>futures]

    <span>def</span> <span>clear</span>(<span>self</span>):
        <span>"""Break reference cycle with any pending futures."""</span>
        <span>self</span><span>.</span>futures <span>=</span> <span>None</span>
</pre></div>


<p>Here's an example use of Any:</p>
<div class="codehilite"><pre><span>@gen.coroutine</span>
<span>def</span> <span>delayed_msg</span>(seconds, msg):
    <span>yield</span> gen<span>.</span>Task(IOLoop<span>.</span>current()<span>.</span>add_timeout,
                   time<span>.</span>time() <span>+</span> seconds)
    <span>raise</span> gen<span>.</span>Return(msg)


<span>@gen.coroutine</span>
<span>def</span> <span>f</span>():
    start <span>=</span> time<span>.</span>time()
    future1 <span>=</span> delayed_msg(<span>2</span>, <span>'2'</span>)
    future2 <span>=</span> delayed_msg(<span>3</span>, <span>'3'</span>)
    future3 <span>=</span> delayed_msg(<span>1</span>, <span>'1'</span>)

    <span># future3 will resolve first.</span>
<span>    results <span>=</span> <span>yield</span> Any([future1, future2, future3])
</span>    end <span>=</span> time<span>.</span>time()
    <span>print</span> <span>"finished in </span><span>%.1f</span><span> sec: </span><span>%r</span><span>"</span> <span>%</span> (end <span>-</span> start, results)

    <span># Wait for any of the remaining futures.</span>
<span>    results <span>=</span> <span>yield</span> Any([future1, future2])
</span>    end <span>=</span> time<span>.</span>time()
    <span>print</span> <span>"finished in </span><span>%.1f</span><span> sec: </span><span>%r</span><span>"</span> <span>%</span> (end <span>-</span> start, results)

IOLoop<span>.</span>current()<span>.</span>run_sync(f)
</pre></div>


<p>As expected, this prints:</p>
<div class="codehilite"><pre>finished in 1.0 sec: [None, None, '1']
finished in 2.0 sec: ['2', None]
</pre></div>


<p>But you can see there are some complications with this approach. For one thing, if you want to wait for the <em>rest</em> of the futures after the first one resolves, it's complicated to construct the list of still-pending futures. I suppose you could do:</p>
<div class="codehilite"><pre>futures <span>=</span> [future1, future2, future3]
results <span>=</span> <span>yield</span> Any(f <span>for</span> f <span>in</span> futures
                    <span>if</span> <span>not</span> f<span>.</span>done())
</pre></div>


<p>Not pretty. And not correct, either! There's a race condition: if a future is resolved in between consecutive executions of this code, you may never receive its result. On the first call, you get the result of some other future that resolves faster, but by the time you're constructing the list to pass to the second Any, your future is now "done" and you omit it from the list.</p>
<p>Another complication is the reference cycle: Any refers to each future, which refers to a callback which refers back to Any. For prompt garbage collection, you should call <code>clear()</code> on Any before it goes out of scope. This is very awkward.</p>
<p>Additionally, you can't distinguish between a pending future, and a future that resolved to None. You'd need a special sentinel value distinct from None to represent a pending future.</p>
<p>The final complication is the worst. If multiple futures are resolved and some of them have exceptions, there's no obvious way for Any to communicate all that information to you. Mixing exceptions and results in a list would be perverse.</p>
<h1 id="a-better-way">A Better Way</h1>
<p>Fortunately, there's a better way. We can make Any return just the first future that resolves, instead of a list of results:</p>
<div class="codehilite"><pre><span>class</span> <span>Any</span>(Future):
    <span>def</span> <span>__init__</span>(<span>self</span>, futures):
        <span>super</span>(Any, <span>self</span>)<span>.</span>__init__()
        <span>for</span> future <span>in</span> futures:
            future<span>.</span>add_done_callback(<span>self</span><span>.</span>done_callback)

    <span>def</span> <span>done_callback</span>(<span>self</span>, future):
        <span>self</span><span>.</span>set_result(future)
</pre></div>


<p>The reference cycle is gone, and the exception-handling question is answered: The Any class returns the whole future to you, instead of its result or exception. You can inspect it as you like.</p>
<p>It's also easy to wait for the remaining futures after some are resolved:</p>
<div class="codehilite"><pre><span>@gen.coroutine</span>
<span>def</span> <span>f</span>():
    start <span>=</span> time<span>.</span>time()
    future1 <span>=</span> delayed_msg(<span>2</span>, <span>'2'</span>)
    future2 <span>=</span> delayed_msg(<span>3</span>, <span>'3'</span>)
    future3 <span>=</span> delayed_msg(<span>1</span>, <span>'1'</span>)

    futures <span>=</span> <span>set</span>([future1, future2, future3])
    <span>while</span> futures:
        resolved <span>=</span> <span>yield</span> Any(futures)
        end <span>=</span> time<span>.</span>time()
        <span>print</span> <span>"finished in </span><span>%.1f</span><span> sec: </span><span>%r</span><span>"</span> <span>%</span> (
            end <span>-</span> start, resolved<span>.</span>result())
        futures<span>.</span>remove(resolved)
</pre></div>


<p>As desired, this prints:</p>
<div class="codehilite"><pre>finished in 1.0 sec: '1'
finished in 2.0 sec: '2'
finished in 3.0 sec: '3'
</pre></div>


<p>There's no race condition now. You can't miss a result, because you don't remove a future from the list unless you've received its result.</p>
<h1 id="exceptions">Exceptions</h1>
<p>To test the exception-handling behavior, let's make a function that raises an exception after a delay:</p>
<div class="codehilite"><pre><span>@gen.coroutine</span>
<span>def</span> <span>delayed_exception</span>(seconds, msg):
    <span>yield</span> gen<span>.</span>Task(IOLoop<span>.</span>current()<span>.</span>add_timeout,
                   time<span>.</span>time() <span>+</span> seconds)
    <span>raise</span> <span>Exception</span>(msg)
</pre></div>


<p>Now, instead of returning a result, one of our futures will raise an exception:</p>
<div class="codehilite"><pre><span>@gen.coroutine</span>
<span>def</span> <span>f</span>():
    start <span>=</span> time<span>.</span>time()
    future1 <span>=</span> delayed_msg(<span>2</span>, <span>'2'</span>)
    <span># Exception!</span>
<span>    future2 <span>=</span> delayed_exception(<span>3</span>, <span>'3'</span>)
</span>    future3 <span>=</span> delayed_msg(<span>1</span>, <span>'1'</span>)

    futures <span>=</span> <span>set</span>([future1, future2, future3])
    <span>while</span> futures:
        resolved <span>=</span> <span>yield</span> Any(futures)
        end <span>=</span> time<span>.</span>time()
        <span>try</span>:
            outcome <span>=</span> resolved<span>.</span>result()
<span>        <span>except</span> <span>Exception</span> <span>as</span> e:
</span><span>            outcome <span>=</span> e
</span>
        <span>print</span> <span>"finished in </span><span>%.1f</span><span> sec: </span><span>%r</span><span>"</span> <span>%</span> (
            end <span>-</span> start, outcome)
        futures<span>.</span>remove(resolved)
</pre></div>


<p>Now, the script prints:</p>
<div class="codehilite"><pre>finished in 1.0 sec: '1'
finished in 2.0 sec: '2'
finished in 3.0 sec: Exception('3',)
</pre></div>


<h1 id="conclusion">Conclusion</h1>
<p>It took a bit of thinking, but our final Any class is simple. It lets you launch many concurrent operations and process them in the order they complete. Not bad.</p></div>

  </div></body></html>