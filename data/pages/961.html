<html><body><div><div class="container">



<h2>Set up HTTP handling in Django view methods: HTTP errors, redirects, content types and status codes</h2>

<h3> Problem </h3> 
<p class="rmkit">
You want to use HTTP handling directly in Django views to output HTTP error pages, HTTP redirects, HTTP content types (e.g. text/plain, text/xml) and HTTP status codes ('HTTP 200 for "OK"','HTTP 404 for "NOT FOUND"').</p>

<h3> Solution </h3> 
<p class="rmkit">
Use the <code>status</code> and <code>content_type</code> arguments with the <code>django.shortcuts.render</code> method to specify an HTTP status code and HTTP content type, respectively. To trigger an HTTP 500 (INTERAL SERVER ERROR) response do <code>raise Exception</code> in a view. To trigger an HTTP 404 (NOT FOUND) response do <code>raise django.http.Http404</code>. To trigger an HTTP 400 (BAD REQUEST) response do <code>raise django.core.exceptions.SuspiciousOperation</code>. To trigger an HTTP 403 (FORBIDDEN) response do <code>raise django.core.exceptions.PermissionDenied</code>.</p>

<p class="rmkit">
You can customize the pages for HTTP 404, HTTP 500, HTTP 400 and HTTP 403 responses creating templates called <code>404.html</code>, <code>500.html</code>, <code>400.html</code> and <code>403.html</code>, respectively. Custom templates must be placed in a folder defined in the <code>DIRS</code> list of the <code>TEMPLATES</code> variable. You can also override the built-in view methods for HTTP 404, HTTP 500, HTTP 400 and HTTP 403 responses defining custom view methods in the variables <code>handler404</code>, <code>handler500</code>, <code>handler400</code> and <code>handler403</code>. The variables for custom view methods must be defined in <code>urls.py</code>.</p>

<p class="rmkit">
To do an HTTP redirect you can use <code>django.http.HttpResponsePermanentRedirect()</code> or <code>django.http.HttpResponseRedirect()</code>. To trigger an HTTP 304 (NOT MODIFIED) response use <code>django.http.HttpResponseNotModified()</code>. To trigger an HTTP 400 (BAD REQUEST) response with in-line content use <code>django.http.HttpResponseBadRequest()</code>. To trigger an HTTP 404 (NOT FOUND) response with in-line content use <code>django.http.HttpResponseNotFound()</code>. To trigger an HTTP 403 (FORBIDDEN) response with in-line content use <code>django.http.HttpResponseForbidden()</code>. To trigger an HTTP 405 (METHOD NOT ALLOWED) response with in-line content use <code>django.http.HttpResponseNotAllowed()</code>. To trigger an HTTP 410 (GONE) response with in-line content use <code>django.http.HttpResponseGone()</code>. To trigger an HTTP 500 (INTERNAL SERVER ERROR) response with in-line content use <code>django.http.HttpResponseServerError()</code>.</p>

<p class="rmkit">
To trigger a response with in-line content using any HTTP status code and HTTP content type use the generic method <code>django.http.HttpResponse()</code>. To trigger a response with in-line content serialized as JSON use <code>django.http.JsonResponse()</code>.</p>


<h3>How it works</h3> 

<p class="rmkit">
Browsers set HTTP headers in requests to tell applications to take into account certain characteristics for processing. Similarly, applications set HTTP headers in responses to tell browsers to take into account certain characteristics for the content being sent out. Among the most important HTTP headers set by applications like Django are <code>Status</code> and <code>Content-Type</code>.</p> 

<p class="rmkit">
The <code>Status</code> HTTP Header is a three digit code number to indicate the response status for a given request. Examples of <code>Status</code> values are <code>200</code> which is the standard response for successful HTTP requests and <code>404</code> which is used to indicate a requested resource could not be found. The <code>Content-Type</code> HTTP Header is a MIME(Multipurpose Internet Mail Extensions) type string to indicate the type of content in a response. Examples of <code>Content-Type</code> values are <code>text/html</code> which is the standard for an HTML content response and <code>image/gif</code> which is used to indicate a response is a GIF image.</p> 

<p class="rmkit">
By default and unless there's an exception, all Django view methods that use <code>django.shortcuts.render</code> to return a response are set with the HTTP <code>Status</code> value of <code>200</code> and the HTTP <code>Content-Type</code> of <code>text/html</code>. Although these default values are the most common, sometimes it's necessary to alter these values.</p>


<h4>Set HTTP <code>Content-type</code> and HTTP <code>Status</code> code in Django <code>django.shortcuts.render</code></h4>
<p class="rmkit">
Adding HTTP handling to the <code>render</code> method in <code>django.shortcuts</code> is as simple as providing the additional arguments <code>status</code> and/or <code>content_type</code>. Listing 1 illustrates various examples of this process.</p>


<a id="djangomodifyrender"/> 
<h5>Listing 1 - <code>django.shortcuts.render</code> with modified HTTP <code>Content-type</code> and HTTP <code>Status</code></h5>
<table><tr><td>
<pre class="brush: bash;">
from django.shortcuts import render

# No method body(s) provided for simplicity, just return values

# Returns content type text/plain, with default HTTP 200
values_for_template = {}
return render(request,'stores/menu.csv', values_for_template, content_type='text/plain')

# Returns HTTP 404, wtih default text/html 
# NOTE: Django has a built-in shortcut &amp; template for HTTP 404 responses, described in the next section
return render(request,'custom/notfound.html',status=404)

# Returns HTTP 500, wtih default text/html 
# NOTE: Django has a built-in shortcut &amp; template for HTTP 500 responses, described in the next section
return render(request,'custom/internalerror.html',status=500)

# Returns content type application/json, with default HTTP 200
values_for_template = {}
return render(request,'stores/menu.json', values_for_template, content_type='application/json')

</pre>
</td></tr></table>

<p class="rmkit">
The first example in listing 1 is designed to return a response with plain text content. Notice the <code>request</code> arguments with the exception of the <code>content_type</code> are identical to previous recipes: the <code>request</code> object, a template to generate the response and a data dictionary to fill values in the template.</p>

<p class="adslot_right"> 

<ins class="adsbygoogle" data-ad-client="ca-pub-4639088530133416" data-ad-slot="7920987130" data-ad-format="auto"/>

</p>

<p class="rmkit">
The second and third examples in listing 1 set the HTTP <code>Status</code> code to <code>404</code> and <code>500</code>. Because the HTTP <code>Status</code> <code>404</code> code is used for resources that are not found, the <code>render</code> method uses a special template for this purpose. Similarly, because the HTTP <code>Status</code> <code>500</code> code is used to indicate an error, the <code>render</code> method uses a special template for this purpose. Note that Django has built-in shortcuts and templates to deal with HTTP <code>Status</code> codes <code>404</code> and <code>500</code> that are described in the next section and you can use instead of the examples in listing 1.</p>

<p class="rmkit">
The last and fourth example in listing 1 is designed to return a response with JSON content. The HTTP <code>Content-Type</code> <code>application/json</code> is a common requirement when requests are made via AJAX. Finally, it's worth mentioning that can you can specify both the <code>content_type</code> and <code>status</code> arguments if required.</p>


<h4>Shortcuts and built-in templates for HTTP <code>Status</code> codes: <code>404 (Not Found)</code>, <code>500 (Internal Server Error)</code>, <code>400 (Bad Request)</code> and <code>403 (Forbidden)</code></h4>

<p class="rmkit">
Django has special shortcuts and built-in templates for certain HTTP <code>Status</code> codes that are very common. All that's required to use these shortcuts is to trigger an exception in a Django view. Table 1 illustrates the different shortcuts to trigger certain HTTP statuses.</p>

<a id="djangoshortcutexceptions"/> 
<h5>Table 1 - Django shortcut exceptions to trigger HTTP statuses</h5>
<table border="1" align="center">
<tr><th>HTTP status code</th><th>Python code sample</th></tr> 
<tr><td>404 (Not Found)</td><td><code>from django.http import Http404</code><br/><code>raise Http404</code></td></tr>
<tr><td>500 (Internal Server Error)</td><td><code>raise Exception</code></td></tr>
<tr><td>400 (Bad Request)</td><td><code>from django.core.exceptions import SuspiciousOperation</code><br/><code>raise SuspiciousOperation</code></td></tr>
<tr><td>403 (Forbidden)</td><td><code>from django.core.exceptions import PermissionDenied</code><br/><code>raise PermissionDenied</code></td></tr>
</table>

<table class="note">
 <tbody><tr><td valign="top" align="center" rowspan="2"><img src="/static/images/bigdata/pin.png" alt="Note"/></td>
     <th align="left"> Django automatically handles not found pages raising HTTP 404 and unhandled exceptions raising HTTP 500</th></tr>
 <tr><td valign="top" align="left">
<p>
The exceptions in table 1 are meant to be used explicitly in Django views when developers know end users should get them. However, Django automatically triggers an HTTP 404 (Not Found) exception when a page is not found or triggers an HTTP 500 (Internal Server Error) exception when an unhandled exception is thrown in a view.</p> 
<p/> 
 </td></tr>
 </tbody></table> 


<p class="rmkit">
As you can see in the examples in table 1, the shortcut syntax is straightforward. For example, you can make evaluations in a Django view like <code>if article_id  or <code>if unpayed_subscription:</code> and based on the result throw exceptions from table 1 so end users get the proper HTTP status response.</code></p>

<p class="rmkit">
So what is the actual content sent in a response besides the HTTP status when an exception from table 1 is triggered ? The default for HTTP <code>400 (Bad Request)</code> and HTTP <code>403 (Forbidden)</code> is a single line HTML page that says "<code>Bad Request (400)</code>" and "<code>403 Forbidden</code>", respectively. For HTTP <code>404 (Not Found)</code> and HTTP <code>500 (Internal Server Error)</code>, it depends on the <code>DEBUG</code> value in <code>settings.py</code>.</p>

<p class="rmkit">
If a Django project has <code>DEBUG=True</code> in <code>settings.py</code>, HTTP <code>404 (Not Found)</code> generates a page with the available URLs -- as illustrated in figure 1 -- and HTTP <code>500 (Internal Server Error)</code> generates a page with the detailed error -- as illustrated in figure 2. If a Django project has <code>DEBUG=False</code> in <code>settings.py</code>, HTTP <code>404 (Not Found)</code> generates a single line HTML page that says "<code>Not Found. The requested URL &lt;url_location&gt; was not found on this server.</code>" and HTTP <code>500 (Internal Server Error)</code> generates a single line HTML page that says "<code>A server error occurred.  Please contact the administrator.</code>".</p>

 

  


  
	


<p class="rmkit">
It's also possible to override the default response for all the previous HTTP codes using a custom template. To use a custom response template, you need to create a template with the desired HTTP code and <code>.html</code> extension. For example, for HTTP <code>403</code> you would create the <code>403.html</code> template and for HTTP <code>500</code> you would create the <code>500.html</code> template. All these custom HTTP response templates need to be placed in a folder defined in the <code>DIRS</code> list of the <code>TEMPLATES</code> variable so Django finds them before it uses the default HTTP responses.</p> 


<table class="note">
 <tbody><tr><td valign="top" align="center" rowspan="2"><img src="/static/images/bigdata/warning.png" alt="Note"/></td>
     <th align="left">Custom <code>404.html</code> and <code>500.html</code> pages only work when <code>DEBUG=False</code></th></tr>
 <tr><td valign="top" align="left">
<p>
If <code>DEBUG=True</code>, it doesn't matter if you have the <code>404.html</code> and <code>500.html</code> templates in the right location, Django keeps using the default response behavior illustrated in figure 1 and figure 2, respectively. You need to set <code>DEBUG=False</code> for the custom <code>404.html</code> and <code>500.html</code> templates to work.</p> 
</td></tr>
 </tbody></table> 


<p class="rmkit">
On certain occasions, simply customizing the HTTP response template may not be enough. For example, you may need to pass a custom data structure to use in the template. Under these circumstances you need to customize the built-in Django HTTP view methods themselves because there's no other way to get custom data into a template. To customize the built-in Django HTTP view methods you need to use special handlers in <code>urls.py</code>. Listing 2 illustrates the <code>urls.py</code> file with custom handlers for Django's built-in HTTP view methods.</p>

<a id="overridebuiltinhttpviews"/> 
<h5>Listing 2 - Override built-in Django HTTP view methods in <code>urls.py</code></h5>
<table><tr><td>
<pre class="brush: bash;">
# Overrides the default 400 handler django.views.defaults.bad_request
handler400 = 'coffeehouse.utils.views.bad_request'
# Overrides the default 403 handler django.views.defaults.permission_denied
handler403 = 'coffeehouse.utils.views.permission_denied'
# Overrides the default 404 handler django.views.defaults.page_not_found
handler404 = 'coffeehouse.utils.views.page_not_found'
# Overrides the default 500 handler django.views.defaults.server_error
handler500 = 'coffeehouse.utils.views.server_error'

urlpatterns = [....
]
</pre>
</td></tr></table>


<table class="note">
 <tbody><tr><td valign="top" align="center" rowspan="2"><img src="/static/images/bigdata/warning.png" alt="Note"/></td>
     <th align="left">Handlers <code>handler404</code> and <code>handler500</code> only work when <code>DEBUG=False</code></th></tr>
 <tr><td valign="top" align="left">
<p>
If <code>DEBUG=True</code>, the <code>handler404</code> and <code>handler500</code> handlers won't work, Django keeps using the built-in Django HTTP view methods. You need to set <code>DEBUG=False</code> for the <code>handler404</code> and <code>handler500</code> handlers to work.</p> 
</td></tr>
 </tbody></table> 


<p class="rmkit">
As you can see in listing 2, there are a series of variables in <code>urls.py</code> right above the standard <code>urlpatterns</code> variable. Each variable in listing 2 represents an HTTP handler, with its value corresponding to a custom Django view to process requests. For example, <code>handler400</code> indicates that all HTTP 400 requests should be handled by the Django view method <code>coffeehouse.utils.views.bad_request</code> instead of the default <code>django.views.defaults.bad_request</code>. The same approach is taken for HTTP 403 requests using <code>handler403</code>, HTTP 404 requests using <code>handler404</code> and HTTP 500 requests using <code>handler500</code>.</p>

<p class="rmkit">
As to the actual structure of the custom Django view methods, they are identical to any other Django view method. Listing 3 show the structure of the custom view methods used in listing 2.</p> 


<a id="custombuiltinhttpviews"/> 
<h5>Listing 3 - Custom views to override built-in Django HTTP view methods </h5>
<table><tr><td>
<pre class="brush: bash;">
from django.shortcuts import render

def page_not_found(request):
    # Dict to pass to template, data could come from DB query
    values_for_template = {}
    return render(request,'404.html',values_for_template,status=404)

def server_error(request):
    # Dict to pass to template, data could come from DB query
    values_for_template = {}
    return render(request,'500.html',values_for_template,status=500)

def bad_request(request):
    # Dict to pass to template, data could come from DB query
    values_for_template = {}
    return render(request,'400.html',values_for_template,status=400)

def permission_denied(request):
    # Dict to pass to template, data could come from DB query
    values_for_template = {}
    return render(request,'403.html',values_for_template,status=403)

</pre>
</td></tr></table>

<p class="rmkit">
As you can see in listing 3, we use the same <code>render</code> method from <code>django.shortcuts</code> to build the custom HTTP view methods. The methods point to a template named by the HTTP status code, use a custom data dictionary that can be accessible on the template and use the <code>status</code> argument to indicate the HTTP status code.</p>

<p class="adslot_right"> 

<ins class="adsbygoogle" data-ad-client="ca-pub-4639088530133416" data-ad-slot="7920987130" data-ad-format="auto"/>

</p>

<h4>Shortcuts for other HTTP <code>Status</code> codes and responses that don't require templates</h4>
<p class="rmkit">
All the previous samples assumed the responses with an HTTP status code had to return content from a template. However, there can be times when using a template to output a response can be unnecessary, for example, you might want a one line response that says "Nothing to see here". Other times it makes no sense for an HTTP status code to use a template, such is the case for <code>HTTP 301 (Permanent Redirect)</code> or <code>HTTP 302 (Redirect)</code> where the response should be a redirection URL.</p>

<p class="rmkit">Table 2 illustrates the different shortcuts to trigger HTTP redirects.</p>

<a id="djangoshortcutsredirects"/> 
<h5>Table 2 - Django shortcuts for HTTP redirects</h5>
<table border="1" align="center">
<tr><th>HTTP status code</th><th>Python code sample</th></tr> 
<tr><td>301 (Permanent Redirect)</td><td><code>from django.http import HttpResponsePermanentRedirect</code><br/><code>return HttpResponsePermanentRedirect("/")</code></td></tr>
<tr><td>302 (Redirect)</td><td><code>from django.http import HttpResponseRedirect</code><br/><code>return HttpResponseRedirect("/")</code></td></tr>
</table>

<p class="rmkit">
Both samples in table 2 redirect to an application's home page (i.e."<code>/</code>"). However, you could also set the redirection to any application URL or even a full URL on a different domain (e.g.<code>http://maps.google.com/</code>).</p>

<p class="rmkit">
In addition to the HTTP redirection shortcuts, Django also offers a series of shortcuts for common HTTP status codes where you can add in-line responses instead of relying on a template. These shortcuts can also use the <code>content_type</code> argument to indicate the type of content in a response. Table 3 illustrates the various other shortcuts for HTTP status codes with in-line content responses.</p>


<a id="djangoshortcutsotherhttp"/> 
<h5>Table 3 - Django shortcuts for various HTTP status codes with in-line content responses</h5>
<table border="1" align="center">
<tr><th>HTTP status code</th><th>Python code sample</th></tr> 

<tr><td>304 (NOT MODIFIED)</td><td><code>from django.http import HttpResponseNotModified</code><br/><code>return HttpResponseNotModified()<sup>1</sup></code></td></tr>
<tr><td>400 (BAD REQUEST)</td><td><code>from django.http import HttpResponseBadRequest</code><br/><code>return HttpResponseBadRequest("&lt;h4&gt;The request doesn't look right&lt;/h4&gt;")</code></td></tr>
<tr><td>404 (NOT FOUND)</td><td><code>from django.http import HttpResponseNotFound</code><br/><code>return HttpResponseNotFound("&lt;h4&gt;Ups, we can't find that page&lt;/h4&gt;")</code></td></tr>
<tr><td>403 (FORBIDDEN)</td><td><code>from django.http import HttpResponseForbidden</code><br/><code>return HttpResponseForbidden("Can't look at anything here",content_type="text/plain")</code></td></tr>
<tr><td>405 (METHOD NOT ALLOWED)</td><td><code>from django.http import HttpResponseNotAllowed</code><br/><code>return HttpResponseNotAllowed("&lt;h4&gt;Method not allowed&lt;/h4&gt;")</code></td></tr>
<tr><td>410 (GONE)</td><td><code>from django.http import HttpResponseGone</code><br/><code>return HttpResponseGone("No longer here",content_type="text/plain")</code></td></tr>
<tr><td>500 (INTERNAL SERVER ERROR)</td><td><code>from django.http import HttpResponseServerError</code><br/><code>return HttpResponseServerError("&lt;h4&gt;Ups, that's a mistake on our part, sorry!&lt;/h4&gt;")</code></td></tr>
<tr><td>In-line response with any HTTP status code (Defaults to HTTP 200)</td><td><code>from django.http import HttpResponse</code><br/><code>return HttpResponse("&lt;h4&gt;Django in-line response&lt;/h4&gt;")</code></td></tr>
<tr><td>In-line response that serializes data to JSON (Defaults to HTTP 200 and content type <code>application/json</code>)</td><td><code>from django.http import JsonResponse</code><br/>data_dict = {'name':'Downtown','address':'Main #385','city':'San Diego','state':'CA'}<br/><code>return JsonResponse(data_dict)</code></td></tr>
<tr><td colspan="2"><sup>1</sup>The HTTP 304 status code indicates a 'Not Modified' response, so you can't send content in the response, it should always be empty.</td></tr>
</table>

<p class="rmkit">
As you can see in the samples in table 3, you can provide an in-line content response, as well as the <code>content_type</code> argument if the content is something other than <code>text/html</code>.</p>

<p class="rmkit">
The <code>HttpResponse</code> method in table 3 is a generic method for in-line content responses. The <code>HttpResponse</code> method can specify any HTTP status code using the <code>status</code> argument, the content type using the <code>content_type</code> argument -- similar to the <code>render</code> method in listing 1 -- or any other HTTP header (e.g.<code>Content-Disposition</code>. The <code>HttpResponse</code> method is helpful to create responses for HTTP status codes that don't have direct shortcut methods (e.g. HTTP 408 [Request Timeout], HTTP 429 [Too Many Requests]) or to inclusively harness a template to generate inline responses as illustrated in listing 4.</p> 

<a id="custombuiltinhttpviews"/> 
<h5>Listing 4 - HttpResponse with template and custom CSV file download</h5>
<table><tr><td>
<pre class="brush: bash;">
from django.http import HttpResponse
from django.utils import timezone
from django.template import loader, Context

response = HttpResponse(content_type='text/csv')
response['Content-Disposition'] = 'attachment; filename=Users_%s.csv' % str(timezone.now().today())
t = loader.get_template('dashboard/users_csvexport.html')                 
c = Context({'users': sorted_users,})                                                  
response.write(t.render(c))                                         
return response
</pre>
</td></tr></table>

<p class="rmkit">
The <code>HTTPResponse</code> object in listing 4 is generated with a <code>text/csv</code> content type to advise the requesting party (e.g. browser) that it's about to receive CSV content. Next, the <code>Content-Disposition</code> header also tells the requesting party (e.g. browser) to attempt to download the content as a file named <code>Users_%s.csv</code> where the <code>%s</code> is substituted with the current server date.</p>

<p class="rmkit">
Next, using the <code>loader</code> module we use the <code>get_template</code> method to load the template <code>users_csvexport.html</code> that will have a CSV like structure with data placeholders. Then we create a <code>Context</code> object to hold the data that will fill the template, in this case it's just a single variable named <code>users</code>. Next, we call the template's <code>render</code> method with the context object in order to fill in the template's data placeholders with the data. Finally, the rendered template is written to the <code>response</code> object via the <code>write</code> method and the <code>response</code> object is returned.</p> 
 
<p class="rmkit">
And finally, turning our attention back to table 3 with the Django shortcuts, the <code>JsonResponse</code> method is used to transform an in-line response into a JSON format. Because this method converts the payload to a JSON data structure, it also automatically sets the <code>content_type</code> to <code>application/json</code>.</p>





</div> 
  </div></body></html>