<html><body><div><div class="content html_format"><p>
      24 июня разработчики Telegram </p><a href="https://core.telegram.org/bots">открыли</a><p> платформу для создания ботов. Новость кого-то обошла стороной Хабр, однако многие уже начали разрабатывать викторины. При этом мало где указаны хоть какие-то примеры работающих ботов.
</p><a name="habracut"/><p>
Прежде всего, бот для Telegram — это по-прежнему приложение, запущенное на вашей стороне и осуществляющее запросы к </p><a href="https://core.telegram.org/bots/api">Telegram Bot API</a><p>. Причем API довольное простое — бот обращается на определенный URL с параметрами, а Telegram отвечает JSON объектом.
</p><p>
Рассмотрим API на примере создания тривиального бота:

</p><h3>1. Регистрация</h3><p>
Прежде чем начинать разработку, бота необходимо зарегистрировать и получить его уникальный id, являющийся одновременно и токеном. Для этого в Telegram существует специальный бот — </p><a href="https://telegram.me/botfather"> @BotFather</a><p>.
</p><p>
Пишем ему /start и получаем список всех его команд. </p><p>
Первая и главная — /newbot — отправляем ему и бот просит придумать имя нашему новому боту. Единственное ограничение на имя — в конце оно должно оканчиваться на «bot». В случае успеха BotFather возвращает токен бота и ссылку для быстрого добавления бота в контакты, иначе придется поломать голову над именем.
</p><p>
Для начала работы этого уже достаточно. Особо педантичные могут уже здесь присвоить боту аватар, описание и приветственное сообщение.
</p><p>
Не забудьте проверить полученный токен с помощью ссылки </p><a href="https://api.telegram.org/bot&lt;TOKEN&gt;/getMe">api.telegram.org/bot&lt;TOKEN&gt;/getMe</a><p>, говорят, не всегда работает с первого раза.

</p><h3>2. Программирование</h3><p>
Создавать бота буду на Python3, однако благодаря адекватности этого языка алгоритмы легко переносятся на любой другой.
</p><p>
Telegram позволяет не делать выгрузку сообщений вручную, а поставить webHook, и тогда они сами будут присылать каждое сообщение. Для Python, чтобы не заморачиваться с cgi и потоками, удобно использовать какой-нибудь реактор, поэтому я для реализации выбрал tornado.web. (для GAE удобно использовать связку Python2+Flask)
</p><p>
Каркас бота:

</p><pre><code class="python">URL = "https://api.telegram.org/bot%s/" % BOT_TOKEN
MyURL = "https://example.com/hook"

api = requests.Session()
application = tornado.web.Application([
    (r"/", Handler),
])

if __name__ == '__main__':
    signal.signal(signal.SIGTERM, signal_term_handler)
    try:
        set_hook = api.get(URL + "setWebhook?url=%s" % MyURL)
        if set_hook.status_code != 200:
            logging.error("Can't set hook: %s. Quit." % set_hook.text)
            exit(1)
        application.listen(8888)
        tornado.ioloop.IOLoop.current().start()
    except KeyboardInterrupt:
        signal_term_handler(signal.SIGTERM, None)
</code></pre><p>
Здесь мы при запуске бота устанавливаем вебхук на наш адрес и отлавливаем сигнал выхода, чтобы вернуть поведение с ручной выгрузкой событий.
</p><p>
Приложение торнадо для обработки запросов принимает класс tornado.web.RequestHandler, в котором и будет логика бота.

</p><pre><code class="python">class Handler(tornado.web.RequestHandler):
        def post(self):
            try:
                logging.debug("Got request: %s" % self.request.body)
                update = tornado.escape.json_decode(self.request.body)
                message = update['message']
                text = message.get('text')
                if text:
                    logging.info("MESSAGE\t%s\t%s" % (message['chat']['id'], text))

                    if text[0] == '/':
                        command, *arguments = text.split(" ", 1)
                        response = CMD.get(command, not_found)(arguments, message)
                        logging.info("REPLY\t%s\t%s" % (message['chat']['id'], response))
                        send_reply(response)
            except Exception as e:
                logging.warning(str(e))
</code></pre><p>
Здесь CMD — словарь доступных команд, а send_reply — функция отправки ответа, которая на вход принимает уже сформированный объект </p><a href="https://core.telegram.org/bots/api#message">Message</a><p>.
</p><p>
Собственно, её код довольно прост:

</p><pre><code class="python">def send_reply(response):
    if 'text' in response:
        api.post(URL + "sendMessage", data=response)
</code></pre>
<p>
Теперь, когда вся логика бота описана можно начать придумывать ему команды.

</p><h3>3. Команды</h3><p>
Перво-наперво, необходимо соблюсти соглашение Telegram и научить бота двум командам: /start и /help:

</p><pre><code class="python">def help_message(arguments, message):
    response = {'chat_id': message['chat']['id']}
    result = ["Hey, %s!" % message["from"].get("first_name"),
              "\rI can accept only these commands:"]
    for command in CMD:
        result.append(command)
    response['text'] = "\n\t".join(result)
    return response
</code></pre>
<p>
Структура message['from'] — это объект типа </p><a href="https://core.telegram.org/bots/api#user">User</a><p>, она предоставляет боту информацию как id пользователя, так и его имя. Для ответов же полезнее использовать message['chat']['id'] — в случае личного общения там будет User, а в случае чата — id чата. В противном случае можно получить ситуацию, когда пользователь пишет в чат, а бот отвечает в личку.
</p><p>
Команда /start без параметров предназначена для вывода информации о боте, а с параметрами — для идентификации. Полезно её использовать для действий, требующих авторизации.
</p><p>
После этого можно добавить какую-нибудь свою команду, например, /base64:

</p><pre><code class="python">def base64_decode(arguments, message):
    response = {'chat_id': message['chat']['id']}
    try:
        response['text'] = b64decode(" ".join(arguments).encode("utf8"))
    except:
        response['text'] = "Can't decode it"
    finally:
        return response
</code></pre>
<p>
Для пользователей мобильного Telegram, будет полезно сказать  @BotFather, какие команды принимает наш бот: 
</p><code>I: /setcommands<br/>
BotFather : Choose a bot to change the list of commands.<br/>
I: @******_bot<br/>
BotFather: OK. Send me a list of commands for your bot. Please use this format:<br/>
<br/>
command1 - Description<br/>
command2 - Another description<br/>
I: <br/>
whoisyourdaddy - Information about author<br/>
base64 - Base64 decode<br/>
BotFather: Success! Command list updated. /help<br/>
</code>
<p>
C таким описанием, если пользователь наберет /, Telegram услужливо покажет список всех доступных команд.

</p><h3>4. Свобода</h3><p>
Как можно было заметить, Telegram присылает сообщение целиком, а не разбитое, и ограничение на то, что команды начинаются со слеша — только для удобства мобильных пользователей. Благодаря этому можно научить бота немного говорить по-человечески.

</p><b>UPD:</b><p> Как верно подсказали, такое пройдет только при личном общении. В чатах боту доставляются только сообщения, начинающиеся с команды (/&lt;command&gt;) (https://core.telegram.org/bots#privacy-mode)
</p><blockquote><ul>
<li>All messages that start with a slash ‘/’ (see Commands above)</li>
<li>Messages that  <a href="https://habrahabr.ru/users/mention/" class="user_link">mention</a> the bot by username</li>
<li>Replies to the bot's own messages</li>
<li>Service messages (people added or removed from the group, etc.)</li>
</ul><br/>
</blockquote>
<p>
Чтобы бот получал все сообщения в группах пишем  @BotFather команду </p><b>/setprivacy</b><p> и выключаем приватность. 
</p><p>
Для начала в Handler добавляем обработчик:

</p><pre><code class="python">if text[0] == '/':
    ...
else:
    response = CMD["&lt;speech&gt;"](message)
    logging.info("REPLY\t%s\t%s" % (message['chat']['id'], response))
    send_reply(response)
</code></pre><p>
А потом в список команд добавляем псевдо-речь:

</p><pre><code class="python">RESPONSES = {
    "Hello": ["Hi there!", "Hi!", "Welcome!", "Hello, {name}!"],
    "Hi there": ["Hello!", "Hello, {name}!", "Hi!", "Welcome!"],
    "Hi!": ["Hi there!", "Hello, {name}!", "Welcome!", "Hello!"],
    "Welcome": ["Hi there!", "Hi!", "Hello!", "Hello, {name}!",],
}
def human_response(message):
    leven = fuzzywuzzy.process.extract(message.get("text", ""), RESPONSES.keys(), limit=1)[0]
    response = {'chat_id': message['chat']['id']}
    if leven[1] &lt; 75:
        response['text'] = "I can not understand you"
    else:
        response['text'] = random.choice(RESPONSES.get(leven[0])).format_map(
            {'name': message["from"].get("first_name", "")}
        )
    return response
</code></pre><p>
Здесь эмпирическая константа 75 относительно неплохо отражает вероятность того, что пользователь всё-таки хотел сказать. А format_map — удобна для одинакового описания строк как требующих подстановки, так и без нее. Теперь бот будет отвечать на приветствия и иногда даже обращаться по имени.

</p><h3>5. Не текст.</h3><p>
Боты, как и любой нормальный пользователь Telegram, могут не только писать сообщения, но и делиться картинками, музыкой, стикерами.
</p><p>
Для примера расширим словарь RESPONSES:

</p><pre><code class="python">RESPONSES["What time is it?"] = ["&lt;at_sticker&gt;", "{date} UTC"]
</code></pre><p>
И будем отлавливать текст &lt;at_sticker&gt;:

</p><pre><code class="python">if response['text'] == "&lt;at_sticker&gt;":
        response['sticker'] = "BQADAgADeAcAAlOx9wOjY2jpAAHq9DUC"
        del response['text']
</code></pre><p>
Видно, что теперь структура Message уже не содержит текст, поэтому необходимо модифицировать send_reply:

</p><pre><code class="python">def send_reply(response):
    if 'sticker' in response:
        api.post(URL + "sendSticker", data=response)
    elif 'text' in response:
        api.post(URL + "sendMessage", data=response)
</code></pre><p>
И все, теперь бот будет время от времени присылать стикер вместо времени:

</p><img src="https://habrastorage.org/files/565/6eb/bfc/5656ebbfc8cd4e97b7c0fe2495fae6b3.png"/>

<h3>6. Возможности</h3><p>
Благодаря удобству API и быстрому старту боты Telegram могут стать хорошей платформой для автоматизации своих действий, настройки уведомлений, создания викторин и task-based соревнований (CTF, DozoR и прочие).
</p><p>
Вспоминая </p><a href="http://habrahabr.ru/post/249265/">статью про умный дом</a><p>, могу сказать, что теперь извращений меньше, а работа прозрачнее.

</p><h3>7. Ограничения</h3><p>
К сожалению, на данный момент существует ограничение на использование webHook — он работает только по https и только с валидным сертификатом, что, например для меня пока критично за счет отсутствия поддержки сертифицирующими центрами динамических днс. 
</p><p>
К счастью, Telegram также умеет работать и по ручному обновлению, поэтому не меняя кода можно создать еще одну службу Puller, которая будет выкачивать их и слать на локальный адрес:

</p><pre><code class="python">while True:
            r = requests.get(URL + "?offset=%s" % (last + 1))
            if r.status_code == 200:
                for message in r.json()["result"]:
                    last = int(message["update_id"])
                    requests.post("http://localhost:8888/",
                                  data=json.dumps(message),
                                  headers={'Content-type': 'application/json',
                                           'Accept': 'text/plain'}
                     )
            else:
                logging.warning("FAIL " + r.text)
            time.sleep(3)
</code></pre>
<p>
P.S. По пункту 7 нашел удобное решение — размещение бота не у себя, а на heroku, благо все имена вида *.herokuapp.com защищены их собственным сертификатом.
</p><p>
UPD: Telegram улучшили Бот Апи, из-за чего, теперь не обязательно иметь отдельную функцию для отправки сообщений при установленном вебхуке, а в ответ на POST запрос можно отвечать тем же сформированным JSON с ответным сообщением, где одно из полей устанавливается как ч 'method': 'sendMessage' (или любой другой метод, используемый ботом).
      </p><p class="clear"/>
    </div>

    
  </div></body></html>