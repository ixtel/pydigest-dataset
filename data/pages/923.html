<html><body><div><div class="ibm-col-1-1">

<h2 id="N10098">About this tutorial</h2><h3 id="ptutabout">What is this tutorial about?</h3><p>This two-part tutorial will introduce you to the Jython
scripting language, and provide you with enough knowledge to
begin developing your own Jython-based applications. Jython
is an implementation of Python that has been seamlessly
integrated with the Java platform. Python is a powerful
object-oriented scripting language used primarily in UNIX
environments. </p><p>Jython is extremely useful because it provides the
productivity features of a mature scripting language while
running on a JVM.  Unlike a Python program, a Jython
program can run in <em>any</em> environment that supports a
JVM.  Today, this means most major computing systems,
including Microsoft Windows, Mac OS, most UNIX variants
including all Linux systems, and all IBM systems.</p><p>This tutorial covers Jython in progressive detail. In
this first half of the tutorial, we'll cover the concepts
and programming basics of working with Jython, including
access options and file compilation, syntax and data types,
program structure, procedural statements, and functions.
The <a href="http://www.ibm.com/developerworks/edu/j-dw-java-jython2-i.html">second half of the tutorial</a> will start with a
conceptual introduction to object-oriented programming in
Jython. From there, we'll move on to a more hands-on
discussion, encompassing class statements, attributes, and
methods, abstract classes, and operator overloading. This
advanced discussion will also include debugging, string
processing, file I/O, and Java support in Jython. The
tutorial will conclude with a step-by-step
demonstration of how to build a working GUI app in Jython.
</p><p>The example code will be very simple in the beginning of
the tutorial, but by the end of the second half you will be
up and running with complete functions, classes, and
programs. Included with the tutorial is a set of
appendices detailing the inner workings of Jython.</p><h3 id="ptake">Should I take this tutorial?</h3><p>This tutorial is oriented towards software developers at
all levels, from casual dabblers to professionals. It is
especially oriented towards Java developers who want to
leverage the productivity advantages of a scripting
language. It is also targeted towards Visual Basic and
C++/C# programmers who want an easier entry into the Java
development world. </p><p>Together, we will cover the following aspects of scripting
with Jython:</p><p><strong>Part 1</strong></p><ul class="ibm-bullet-list"><li>Download and installation</li><li>A conceptual introduction to Jython</li><li>Working from the command-line vs source files</li><li>Syntax and data types</li><li>Program structure</li><li>Procedural statements</li><li>Functions</li></ul><p><strong>Part 2</strong></p><ul class="ibm-bullet-list"><li>Object-oriented programming with Jython</li><li>Debugging</li><li>Java support</li><li>String processing</li><li>File IO</li><li>Building a GUI application in Jython</li></ul><p>To benefit from the discussion, you should be
familiar with at least one procedural programming language
and the basic concepts of computer programming, including
command-line processing. To fully utilize Jython's features
you should also be familiar with the basic concepts of
object-oriented programming. It will also be helpful to have
a working knowledge of the Java platform, as Jython runs
on a JVM; although this is not a requirement of the
tutorial.</p><p>Note that this tutorial is oriented towards Windows
systems. All command examples will employ Windows syntax. In
most cases similar commands perform the same functions on
UNIX systems, although these commands will not be
demonstrated.</p><p>You must have Jython 2.1 or higher installed on your
development system to complete this tutorial. Your
development system may be any ASCII text editor (such as Windows Notepad) combined with the command prompt. The
tutorial includes detailed instructions for getting and
installing Jython on your system.</p><p>To use Jython you must also have a Java Runtime
Environment (JRE) installed on your system. It is
recommended that you use the latest JRE available (1.4.2 at
the time of writing), but any version at or beyond Java 1.2
should work fine. If you are going to use Jython from a
browser (that is, as an applet), you must have at least a JRE
1.1 available to the browser. See <a href="#resources">Resources</a> to download the latest version of the Java development kit (JDK).</p><p>All code examples in this tutorial have been tested on
Jython running on the Sun Java 1.4.1 JRE on Windows 2000.
Examples should work without change on any similar
configuration on other operating systems. </p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-content" class="ibm-anchor-up-link">Back to top</a></p><h2 id="N100F2">Getting started</h2><h3 id="pinstinst">Installation instructions</h3><p>In this section we'll walk through each of the steps
for downloading, installing, and verifying Jython on your
development system.</p><h3 id="pfindjy">Download Jython</h3><p>You can download Jython 2.1 from the <a href="http://www.jython.org">Jython home page</a>. You'll find easy-to-follow download instructions on the download page.</p><p>As previously mentioned, this tutorial is based on the
current stable Jython level, which is version 2.1. More
advanced development levels may also be available from the
Jython home page.</p><h3 id="pinstjy">Install Jython</h3><p>Installing Jython is simple: just execute the class file you've
downloaded from the Jython homepage. Assuming that you have a JRE
installed and have the downloaded class file in your current
directory (C:\ in the examples below) the following
command will install Jython (note that 
<em>&lt;java_home&gt;</em> is the directory the JRE is installed in):</p><div class="codesection"><pre class="displaycode">C:\&gt;&lt;java_home&gt;\bin\java jython-21</pre></div><p>Please follow the install application's prompts. I recommend you
select the defaults, and that you select <em>c:\Jython-2.1</em> as the
destination directory.</p><h3 id="pverinst">Verify the install</h3><p>To verify that Jython is installed, enter the command: </p><p>The result should be a listing like this one:</p><div class="codesection"><pre class="displaycode">  Volume in drive C is C_DRIVE
  Volume Serial Number is ????-????

  Directory of C:\Jython-2.1

--/--/----  --:---      &lt;DIR&gt;          .
--/--/----  --:---      &lt;DIR&gt;          ..
--/--/----  --:---               1,873 ACKNOWLEDGMENTS
--/--/----  --:---      &lt;DIR&gt;          cachedir
--/--/----  --:---      &lt;DIR&gt;          com
--/--/----  --:---      &lt;DIR&gt;          Demo
--/--/----  --:---      &lt;DIR&gt;          Doc
--/--/----  --:---      &lt;DIR&gt;          installer
--/--/----  --:---                 428 jython.bat
--/--/----  --:---             719,950 jython.jar
--/--/----  --:---                 272 jythonc.bat
--/--/----  --:---      &lt;DIR&gt;          Lib
--/--/----  --:---               7,184 LICENSE.txt
--/--/----  --:---              18,178 NEWS
--/--/----  --:---      &lt;DIR&gt;          org
--/--/----  --:---                 651 README.txt
--/--/----  --:---               4,958 registry
--/--/----  --:---      &lt;DIR&gt;          Tools
--/--/----  --:---             224,493 Uninstall.class
                9 File(s)        977,987 bytes
               ? Dir(s)   ??? bytes free</pre></div><h3 id="prunjy">A test run</h3><p>The final step is to ensure that Jython is configured. To
run Jython, start by entering the command: </p><p>The command should result in an introduction similar to this one:</p><div class="codesection"><pre class="displaycode">Jython 2.1 on java1.4.1_01 (JIT: null)
Type "copyright", "credits" or "license" for more information.</pre></div><p>Finally, we'll exit Jython. At the Jython prompt, enter the following command:</p><div class="codesection"><pre class="displaycode">&gt;&gt;&gt; import sys; sys.exit()</pre></div><p>Alternatively, you could just press <strong>Ctrl+C</strong> two times.</p><h3 id="ptrick">Making life more convenient</h3><p>There is just one last thing you should know before we close this section
on getting started. You can eliminate the need to specify
the Jython command path (<code>&lt;d&gt;:\jython-2.1</code>)
by adding it to your <code>PATH</code> variable.  Now you can just
type <strong>jython</strong> at the command prompt.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-content" class="ibm-anchor-up-link">Back to top</a></p><h2 id="N10153">Basic concepts and advantages of Jython</h2><h3 id="pbasiccons">What is Jython?</h3><p>As previously mentioned, Jython is an implementation of Python
written in the Java language and integrated with the Java platform.
Python is a scripting language often used in UNIX-based systems,
including Linux. Python was invented by Guido van Rossum and introduced to the developer community in 1991. Jython currently supports the Python syntax at level 2.1.</p><h3 id="pscript">What is a scripting language?</h3><p>Unlike the Java programming language, Jython is a scripting language. A scripting language is generally defined as follows:</p><ul class="ibm-bullet-list"><li>Very easy to learn and code</li><li>Expressive and concise, yet powerful</li><li>Has minimal required structure to create a running "program"</li><li>Supports interactive (command-at-a-time) execution</li><li>Does not require a compile step</li><li>Supports reflective programming</li><li>Supports functional programming</li><li>Supports dynamic execution of source (that is, an <em>eval</em> function)</li><li>Runs external programs</li></ul><p>In general, it can be said that scripting languages value
programmer efficiency over machine efficiency and
performance. Compared to a programming language such as
the Java language, Jython is easy to learn and efficient to code.</p><p>Jython can also be described as an agile language. Agile languages are generally thought of as being capable of performing a wide variety of tasks and useful for many different types of problems, easy-to-use and yet powerful and expressive.  They are also ideal rapid prototyping languages. </p><h3 id="pjyadvntg">Advantages of Jython</h3><p>Like its C-based cousin Python, Jython is most at home
when used to develop small programs and scripts; it has many
features that allow simple but functional programs to be
created in a few minutes. This does not mean Jython cannot
be used for large-scale programming. In fact, Jython supports
a sophisticated packaging scheme, similar to that of the Java
language. By virtue of its
object-oriented nature, Jython is highly extendable and provides
the latest constructs for effective software engineering.</p><p>Like the Java language and unlike some other scripting languages
such as Perl and Rexx, Jython was designed to
be an object-oriented language from the start. Thus, it
offers powerful object-oriented programming (OOP) features
that are easy to understand and use. </p><p>One of Jython's biggest advantages is that it runs on
any JVM, so applications coded in Jython can run
on almost any computing system.</p><h3 id="pjynj">Jython and the Java platform</h3><p>Jython is built on the Java platform. From the
platform's point of view, the Jython runtime is just
another Java class. This is quite apparent if you look
into the JYTHON.BAT file, which launches the
Java runtime with the Jython interpreter as its main
class, as shown below:</p><div class="codesection"><pre class="displaycode">@echo off
rem This file generated by Jython installer
rem
JAVA_HOME=&lt;java_home&gt;
rem
rem collect all arguments into %ARGS%
set ARGS=
:loop
if [%1] == [] goto end
     set ARGS=%ARGS% %1
     shift
     goto loop
:end

%JAVA_HOME%\bin\java.exe
    -Dpython.home=C:\jython-2.1
    -cp "C:\jython-2.1\jython.jar;%CLASSPATH%"
    org.python.util.jython %ARGS%</pre></div><h3 id="pinterp">Everything is interpreted</h3><p>At its heart Jython is an <em>interpreted language</em>. In
Jython, there is no pre-compile step as there is in Java and
C++; each time Jython code is run it is interpreted afresh.
As such, code changes can be very quickly made and tested.
Jython code can also be entered interactively
(that is, one line at a time). Furthermore, you can
dynamically construct Jython code (that is, as a string) and
execute it directly. This enables coding flexibility not
possible in Java coding. </p><p>The Jython interpreter converts Jython
source into an internal form for more efficient processing.
It does this during a first pass that verifies syntax. Once
this pass is complete the internalized source is
interpreted. Jython also caches this internalized form on disk. In a Java class file for the Jython module <code>&lt;name&gt;.py</code>, the cached file would be <code>&lt;name&gt;$py.class</code>.</p><p>Interpretation does have its disadvantages, although most are
minor. For example, use of an undefined variable is not a compiler
error, so it will be detected only if (and when) the statement in
which the variable is used is executed. While this can seem
a disadvantage when compared to compiled languages, the fact that you
can edit and then immediately run a program and experience the error
(if it exists) makes up for it. A simple test-and-debug procedure
takes about as much time as repeated edit-compile steps do to remove
an error. </p><h3 id="pperf">About performance</h3><p>Because Jython is interpreted, it can be slower than a
compiled language such as Java. In most applications, such
as scripts or GUIs, this difference is hardly
noticeable. In most cases, Jython's increased design and coding
flexibility more than makes up for any small performance
loss. </p><p>Because Jython code is dynamically converted to Java
byte code, the latest enhancements to the Java platform (such as
JITs and Sun's HotSpot JVM) can also eliminate many performance
issues.</p><p>For an additional performance boost it is possible to
implement code sections in the Java language and call them
from Jython. For example, you could prototype your
programs in Jython, test them out, and (in the case of
performance issues) convert the critical sections to Java
code.  This technique is a good combination of the powers of
Jython and the Java language, as prototyping is much
easier in Jython than in Java. We'll talk more
about combining the Java language and Jython in <a href="http://www.ibm.com/developerworks/edu/j-dw-java-jython2-i.html">Part 2</a>
of this tutorial. </p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-content" class="ibm-anchor-up-link">Back to top</a></p><h2 id="N101B4">Working with Jython</h2><h3 id="pjycli">Using Jython as a command-line interpreter</h3><p>One of the easiest ways to use Jython is as a
command-line interpreter. In this manner, lines of code are
entered one line at a time and you can see the results
immediately. This is an ideal way to learn Jython and to try
out new coding techniques with minimal overhead.</p><p>We'll start with a brief Jython interactive session. Enter the following commands after the "&gt;&gt;&gt;" or "..." prompts:</p><p><code>C:\&gt;c:\jython-2.1\jython</code></p><p>You should receive output that looks something like
this:</p><div class="codesection"><pre class="displaycode">Jython 2.1 on java1.4.1_01 (JIT: null)
Type "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; 1 + 2
3
&gt;&gt;&gt; "Hello" + "Goodbye"
'HelloGoodbye'
&gt;&gt;&gt; def fac(x):
...  if x &lt;= 1: return 1
...  return long(x) * fac(x-1)
...
&gt;&gt;&gt; fac(3)
6L
&gt;&gt;&gt; fac(100)
93326215443944152681699238856266700490715968264381621468592963895217599
99322991560894146397615651828625369792082722375825118521091686400000000
0000000000000000L
&gt;&gt;&gt; import sys; sys.exit(0)
C:\&gt;</pre></div><p>With this example you can see how input is immediately executed.
This includes simple expressions and more complex actions such as
function definitions (that is, the <code>fac</code> function). Defined
values and functions are available for immediate use. Notice, also,
that Jython supports very large integers via the <code>long</code>
type.</p><p>Note that in the above example the indentation of the
<code>fac</code> function is critical. You'll learn more about


                    this requirement later in the tutorial (see <a href="#pblock">Blocks</a>).</p><h3 id="pjsrcfiles">Using Jython via source files</h3><p>If Jython accepted only command-line input it wouldn't be
all that useful; thus, it also accepts source files. Jython
source files end in the extension .py. A
Jython file must contain a sequence of Jython statements.
Expressions, such as <em>1 + 2</em>, are not valid statements
(they execute but produce no displayed output).</p><p>To display expressions, you must place them in a
<code>print</code> statement. Thus, the sequence from the previous
section could be coded in a source file as follows:</p><div class="codesection"><pre class="displaycode">print 1 + 2
print "Hello" + "Goodbye"
def fac(x):
  if x &lt;= 1: return 1
  return long(x) * fac(x-1)
print fac(3)
print fac(100)</pre></div><p>The above code would produce the same output as the

                    examples in <a href="#pjycli">Using Jython as a command-line interpreter</a>. In fact, the
statements could have been entered interactively (with the
addition of a blank line after the <code>fac</code> function) and
would result in the same output.</p><h3 id="pprintsrc">The print statement</h3><p>As shown in the previous section, we use the <code>print</code> statement to print expressions. The statement has the following forms:
</p><div class="codesection"><pre class="displaycode">print <em>expression</em> {, <em>expression</em>}... {,}

-- or --

print</pre></div><p>The <code>print</code> statement above can also contain a list
of expressions separated by commas. Each such
expression is output with a space automatically added
between them. So that <code>print "Hello", "Goodbye"</code> outputs <code>Hello Goodbye</code>.</p><p>If a <code>print</code> statement ends in comma, no new-line is output. The line <code>print</code> by itself outputs a new-line.</p><h3 id="phelloprint">A "Hello World" example</h3><p>In Jython, the quintessential example program -- Hello
World -- is a single-line file (say, hello.py), as shown here:</p><p>To run the program you would enter the command: <code>C:\&gt;c:\jython-2.1\jython hello.py</code></p><p>Note that the .py extension is required;
otherwise, a "file not found" error will occur. The
<code>jython</code> command has several options. See the 


                    Jython home page (in <a href="#resources">Resources</a>) for more information. </p><h3 id="pfilemod">Jython source files are modules</h3><p>Jython source files can contain more than a sequence of


                    statements to execute. They can also contain function (see <a href="#">Jython functions</a>
                    ) and class definitions (we'll talk more about class
definitions in Part 2 of this tutorial). In fact, Jython source files


                    can be <em>modules</em> (more on these later, in <a href="#pmodpack">Modules and packages</a>) that may not be used directly but instead
<em>imported</em> by other programs. A single source file can perform
both roles. Consider this variant of the file in the previous section: </p><div class="codesection"><pre class="displaycode">def fac(x):
     if x &lt;= 1: return 1
     return long(x) * fac(x-1)

if __name__ == "__main__":
     print 1 + 2
     print "Hello" + "Goodbye"
     print fac(3)
     print fac(100)</pre></div><p>Again, running this file results in the same output as before. But if
the file were imported into another program that only wanted to
reuse the <code>fac</code> function, then none of the statements under the <code>if</code>
                     (see <a href="#psif">The if statement</a>) test would be executed.</p><p>Note also that each module has a name; the one directly executed from the command-line is called "<code>__main__</code>". This feature can be used to create a test case for each module.</p><h3 id="pcompilejy">Compiled Jython</h3><p>Jython source files can be compiled to Java source code
(which is automatically compiled into byte-code) to
produce standalone class or Java Archive Files (JAR) files. This step is necessary to
create Jython code that is called directly from the Java platform, such as when creating an applet or a servlet. It is also useful to provide Jython applications without releasing the Jython
source.</p><p>Jython can be compiled into a pure Java class that can
run directly on any JVM by use of the <code>jythonc</code> command
(that is, assuming you have the necessary Jython JAR in the
Java <code>CLASSPATH</code>). For more details on using
<code>jythonc</code>

                     see the Jython home page (<a href="#resources">Resources</a>).</p><h3 id="pcompex">A compilation example</h3><p>We'll use the <em>factor.py</em>
                     file (see <a href="#download">Download</a>) 
as our example standalone program. To compile it, use the command:</p><div class="codesection"><pre class="displaycode">c:\&gt;c:\jython-2.1\jythonc factor.py</pre></div><p>If there are no errors, Java class files <code>factor.class</code> and
<code>factor$_PyInner.class</code> will be created. You'll find the actual


                    generated Java source code in the <a href="#download">download</a>. 
To run this (now Java) application use the command:</p><div class="codesection"><pre class="displaycode">c:\&gt;&lt;java_home&gt;\bin\java -cp .;c:\jython-2.1\jython.jar factor</pre></div><p>The resulting output should look something like this:  </p><div class="codesection"><pre class="displaycode">factor running...
For -1 result = Exception - only positive integers supported: -1
For 0 result = 1
For 1 result = 1
For 10 result = 3628800
For 100 result =
93326215443944152681699238856266700490715968264381621468592963895217599
99322991560894146397615651828625369792082722375825118521091686400000000
0000000000000000
For 1000 result = 4023872600770937735437024
     ... many digits removed ...
00000000000000000000</pre></div><p>Note that the output is identical to that generated by using the
<code>factor.py</code> program directly.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-content" class="ibm-anchor-up-link">Back to top</a></p><h2 id="N102AD">Jython basic data types</h2><h3 id="pallobj">Everything is an object</h3><p>Unlike the Java language, Jython sees everything, including all data and code, as an object. This means you can manipulate these objects using Jython code, making reflective and
functional programming very easy to do in Jython. 

                    See <a href="#papptypes">Appendix G: Jython types summary</a> for more information.
</p><p>Some select types, such as numbers and strings, are
more conveniently considered as values, not
objects. Jython supports this notion as well. </p><p>Jython supports only one null value, with the reserved
name of <code>None</code>.</p><h3 id="pallobjops">Common operators</h3><p>All Jython data types support the following fundamental
operations:</p><table border="1" class="ibm-data-table" summary="table is about Jython data types"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Operation</th><th>Test usage</th><th>Comment(s)</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>x and y</code></td><td>Boolean and x with y</td><td>y is not evaluated if x is false<br/>Returns x or y as the result</td></tr><tr><td><code>x or y</code></td><td>Boolean or x with y</td><td>y is not evaluated if x is true<br/>Returns x or y as the result</td></tr><tr><td><code>not x</code></td><td>Boolean negation of x</td><td>Returns 0 or 1</td></tr><tr><td><code>x &lt; y</code></td><td>Comparison strictly less than</td><td>Returns 0 or 1</td></tr><tr><td><code>x &gt; y</code></td><td>Comparison strictly greater than</td><td>Returns 0 or 1</td></tr><tr><td><code>x &lt;= y</code></td><td>Comparison less than or equal</td><td>Returns 0 or 1</td></tr><tr><td><code>x &gt;= y</code></td><td>Comparison greater than or equal</td><td>Returns 0 or 1</td></tr><tr><td><code>x == y</code></td><td>Comparison equal</td><td>Returns 0 or 1</td></tr><tr><td><code>x != y</code><br/><code>x &lt;&gt; y</code></td><td>Comparison not equal</td><td>Returns 0 or 1</td></tr><tr><td><code>x is y</code></td><td>Sameness</td><td>Returns 1 if x is the same object as y; else 0</td></tr><tr><td><code>x is not y</code></td><td>Distinctness</td><td>Returns 1 if x is not the same object as y; else 0</td></tr></tbody></table><p>Note that unlike in the Java language, all types are comparable. In general, if the types of the operands do not match, the result is unequal. The less-than or greater-than relations on complex types are consistent but arbitrary. </p><h3 id="ptbool">Boolean types</h3><p>Jython has no separate boolean type.  All the other types described in the following sections can be used as
booleans. For numeric types, zero is considered to be false and all other values true. For structured types (that is,
sequences and maps), an empty structure is considered to be
false and others true. The <code>None</code> value is always
false. </p><h3 id="ptnum">Numeric types</h3><p>Numbers are <em>immutable</em> (that is, unchangeable after
creation) objects treated as values. Jython supports three
numeric types, as follows:</p><ul class="ibm-bullet-list"><li><strong>Integers</strong> have no fractional part. Integers come in two subforms:


<ul class="ibm-bullet-list"><li><em>Normal</em>: small values in the range -2**31 to 2**31 - 1 (like Java <code>int</code>s). 

<br/><br/>
Examples: -1, 0, 1, 10000
</li><li><em>Long</em>: large values limited only by the JVM's available memory (like Java <code>BigInteger</code>s).
<br/><br/>
Examples: -1L, 0L, 1L, 10000000000000000000000000000000L
</li></ul></li><li><strong>Floating point</strong> values may have fractional parts.
Floats support values identical to the Java <code>double</code> type.
<br/><br/>
Examples:   0.0,  -1.01, 2.5004E-100, -35e100
</li><li><strong>Complex values</strong> are a pair of floating point
values, called the <em>real</em> and <em>imaginary</em> part. If
<em>x</em> is a complex value, then <code>x.real</code> is the
real part and <code>x.imag</code> is the imaginary part.
Either part may be 0.0. The method <code>x.conjugate</code>
produces a new complex with <code>+x.real</code> and
<code>-x.imag</code>.
<br/><br/>
Examples:  1J,  -1j, 1+2j, -3.7+2e5j
</li></ul><h3 id="paddnum">Additional numeric type operations and functions</h3><p>Numeric types support the following additional operations and functions:
</p><table border="1" class="ibm-data-table" summary="table is about numeric types"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Operation/Function</th><th>Usage</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>-x</code></td><td>Negate x (that is, 0 - x)</td></tr><tr><td><code>+x</code></td><td>Posate - no change (that is, 0 + x)</td></tr><tr><td><code>x + y</code></td><td>Add y to x</td></tr><tr><td><code>x - y</code></td><td>Subtract y from x</td></tr><tr><td><code>x * y</code></td><td>Multiply x by y</td></tr><tr><td><code>x / y</code></td><td>Divide x by y</td></tr><tr><td><code>x % y</code><br/><code>divmod(x, y)</code></td><td>Take modulus of x by y<br/>Return (x / y, x % y)
</td></tr><tr><td><code>x ** y</code><br/><code>pow(x, y)</code></td><td>Raise x to the y power<br/>Raise x to the y power</td></tr><tr><td><code>abs(x)</code></td><td>If x &lt; 0, then -x; else x</td></tr><tr><td><code>int(x)</code></td><td>Convert x to an integer</td></tr><tr><td><code>long(x)</code></td><td>Convert x to a long</td></tr><tr><td><code>float(x)</code></td><td>Convert x to a float</td></tr><tr><td><code>complex(r, i)</code><br/><code>complex(x)</code></td><td>Convert r and i to a complex<br/>Convert x to a complex</td></tr></tbody></table><p><strong>Note:</strong> For numeric types, the operands are promoted
to the next higher type. For integer operands /, %, and **
result in integer results. For the <code>int</code>,
<code>long</code>, <code>float</code>, and
<code>complex</code> conversion functions, <em>x</em> may be a string
or any number.</p><h3 id="paddint">Additional integer type operations</h3><p>Integer types support the following additional
operations:</p><table border="1" class="ibm-data-table" summary="table is about supported integer operations"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Operation</th><th>Usage</th><th>Comment(s)</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>x &lt;&lt; y</code></td><td>Shift x bits left by y</td><td>Similar to x * pow(2, y)</td></tr><tr><td><code>x &gt;&gt; y</code></td><td>Shift x bits right by y</td><td>Similar to x / pow(2, y)</td></tr><tr><td><code>x &amp; y</code></td><td>And x and y bits</td><td>Clears the bits in x that are 0 in y.</td></tr><tr><td><code>x | y</code></td><td>Or x and y bits</td><td>Sets the bits in x that are 1 in y.</td></tr><tr><td><code>x ^ y</code></td><td>XOR x and y bits</td><td>Flips the bits in x that are 1 in y</td></tr><tr><td><code>~x</code></td><td>Invert x bits</td><td>Flips all bits</td></tr></tbody></table><h3 id="paddfloat">Additional floating type functions</h3><p>Floating point types support the following additional
functions (in module <code>math</code>):</p><table border="1" class="ibm-data-table" summary="table is about floating type functions"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Function</th><th>Comment(s)</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>ceil(v)</code><br/><code>floor(v)</code></td><td>Computes the ceiling and floor of v.</td></tr><tr><td><code>sin(v)</code><br/><code>cos(v)</code><br/><code>tan(v)</code></td><td>Computes the sine, cosine, and tangent of v.</td></tr><tr><td><code>acos(v)</code><br/><code>asin(v)</code><br/><code>atan(v)</code><br/><code>atan2(v, w)</code></td><td>Computes the arcsine, arccosine, and arctangent of v (or v / w).</td></tr><tr><td><code>sinh(v)</code><br/><code>cosh(v)</code><br/><code>tanh(v)</code></td><td>Computes the hyperbolic sine, cosine, and tangent of v.</td></tr><tr><td><code>exp(v)</code><br/><code>pow(v, w)</code><br/><code>sqrt(v)</code><br/><code>log(v)</code><br/><code>log10(v)</code></td><td>Computes the powers and logarithms of v.</td></tr><tr><td><code>fabs(v)</code></td><td>Computes the absolute value of v.</td></tr><tr><td><code>fmod(v, w)</code></td><td>Computes the modulus of v and w. May not be the same as v % w. </td></tr><tr><td><code>modf(v)</code></td><td>Returns (as the tuple (i, f)) the integer and fractional parts of v (both as floats).</td></tr><tr><td><code>frexp(v)</code></td><td>Returns (as the tuple (m, e)) the float mantissa and integer exponent of v. The result is such that <code>v == m * 2 ** e</code>.</td></tr><tr><td><code>ldexp(v, w)</code></td><td>Computes <code>v * 2 ** w</code> (w must be an integer).</td></tr><tr><td><code>hypot(v, w)</code></td><td>Computes the hypotenuse of v and w (that is, <code>sqrt(v * v + w * w)</code>).</td></tr></tbody></table><h3 id="pmathex">Math module examples</h3><p>We'll run an example to demonstrate the functions in the <code>math</code>

                     module from the previous section. See <a href="#psimport">The import statement</a>
                     and <a href="#pfmtstrval">Formatting strings and values</a> for more information.</p><div class="codesection"><pre class="displaycode">from math import *

print "PI = %f, e = %f" % (pi, e)

print "Sine of %f = %f" % (0.5, sin(0.5))
print "Cosine of %f = %f" % (0.5, cos(0.5))
print "Tangent of %f = %f" % (0.5, tan(0.5))</pre></div><p>The example code results in the following output:</p><div class="codesection"><pre class="displaycode">PI = 3.141593, e = 2.718282
Sine of 0.500000 = 0.479426
Cosine of 0.500000 = 0.877583
Tangent of 0.500000 = 0.546302</pre></div><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-content" class="ibm-anchor-up-link">Back to top</a></p><h2 id="N10544">Jython collections</h2><h3 id="ptcoll">Collection types</h3><p>Frequently, you will need to create collections of other data
items. Jython supports two major collection types. The most basic is
the <em>sequence</em> type which is an ordered collection of items.
Sequences support several subtypes such as strings, lists, and
tuples. The other is the <em>map</em> type. Maps support associative
lookup via a key value. You'll learn about both types in this
section.</p><h3 id="ptseq">Sequence types</h3><p>A <em>sequence</em> is an ordered collection of items. All sequences
are zero-indexed, which means the first element is element zero (0).
Indices are consecutive (that is, 0, 1, 2, 3, ...) to the length (less
one) of the sequence. Thus sequences are similar to C and Java
arrays. </p><p>All sequences support <em>indexing</em> (or <em>subscripting</em>) to
select sub-elements. If <em>x</em> is a sequence then the expression
<code>x[n]</code> selects the <em>nth</em> value of the sequence.
Mutable sequences such as lists support indexing on assignment, which
causes elements to be replaced. For these sequences the expression
<code>x[n] = y</code> replaces the <em>nth</em> element of <em>x</em> with <em>y</em>. </p><p>Sequences support an extension of indexing, called
<em>slicing</em>, which selects a range of elements. For example,
<code>x[1:3]</code> selects the second through third elements of
<em>x</em> (the end index is one past the selection). Like indexing,
slicing can be used on assignment to replace multiple elements. </p><p>In Jython, a sequence is an abstract concept, in that you do
not create sequences directly, only instances of subtypes derived
from sequences. Any sequence subtype has all the functions described
for sequences. </p><h3 id="psliceseq">A slice of life</h3><p>The many valid forms of slicing are summarized below. Assume <em>x</em> is a sequence containing 10 elements (indexes 0 through 9).</p><table border="1" class="ibm-data-table" summary="table is about forms of slicing"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Sample expression</th><th>Resulting action</th><th>Comments</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>x[1]</code></td><td>Selects index 1</td><td>Same as indexing</td></tr><tr><td><code>x[1:2]</code></td><td>Selects index 1</td><td>The end value is one past the selected value</td></tr><tr><td><code>x[1:]</code></td><td>Selects index 1 through 9</td><td>Missing value implies the sequence length</td></tr><tr><td><code>x[:7]</code></td><td>Selects index 0 through 6</td><td>Missing value implies zero</td></tr><tr><td><code>x[:-1]</code></td><td>Selects index 0 through 8</td><td>Negative indexes are adjusted by the sequence length</td></tr><tr><td><code>x[-6:-3]</code></td><td>Selects index 3 through 6</td><td>Reverse ranges are supported</td></tr><tr><td><code>x[:]</code></td><td>Selects index 0 through 9</td><td>The whole sequence; This makes a copy of the sequence</td></tr><tr><td><code>x[:1000]</code></td><td>Selects index 0 through 9</td><td>A reference off the end of the sequence is the end</td></tr><tr><td><code>x[-100:]</code></td><td>Selects index 0 through 9</td><td>A reference off the start of the sequence is the start</td></tr><tr><td><code>x[::2]</code></td><td>Selects index 0, 2, 4, 6, 8</td><td>The third value skips over selections</td></tr></tbody></table><h3 id="pseqop">Sequence operators</h3><p>Jython supports several operations between sequences (<em>x</em> and 
<em>y</em>), as summarized below:</p><table border="1" class="ibm-data-table" summary="table is about Jython operations"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Operator</th><th>Usage</th><th>Example</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>x + y</code></td><td>Join (or concatenate) sequences</td><td><code>[1,2,3] + [4,5,6]</code> --&gt; [1,2,3,4,5,6]</td></tr><tr><td><code>i * x</code><br/><code>x * i</code></td><td>Repeat sequence</td><td><code>[1,2,3] * 3</code> --&gt; [1,2,3,1,2,3,1,2,3]</td></tr><tr><td><code>o in x</code><br/><code>o not in x</code></td><td>Contains test</td><td><code>2 in (1,2,3)</code> --&gt; 1 (true)<br/><code>7 not in (1,2,3)</code> --&gt; 1 (true)</td></tr></tbody></table><h3 id="pseqfunc">Sequence functions</h3><p>In addition, several functions can be applied to any sequence (<em>x</em>), as summarized below:</p><table border="1" class="ibm-data-table" summary="table is about sequence functions"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Function</th><th>Usage</th><th>Example</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>len(x)</code></td><td>Length (number of elements) of the sequence</td><td>len(1,2,3) --&gt; 3</td></tr><tr><td><code>min(x)</code></td><td>Smallest value in the sequence</td><td>min(1,2,3) --&gt; 1</td></tr><tr><td><code>max(x)</code></td><td>Largest value in the sequence</td><td>max(1,2,3) --&gt; 3</td></tr></tbody></table><h3 id="pendseq">A final note about sequences</h3><p>As I mentioned earlier, a sequence in Jython is an abstract concept, in that
you do not create sequences directly, only instances of
subtypes derived from sequences. Any sequence subtype has
all the functions described for sequences. There are several sequences subtypes, as follows:</p><ul class="ibm-bullet-list"><li><strong>strings</strong>

                         are immutable sequences of characters (see <a href="#ptstring">Strings</a>)</li><li><strong>tuples</strong>

                         are immutable sequences of any data type (see <a href="#pttuple">Tuples</a>)</li><li><strong>ranges</strong>

                         are immutable sequences of integers (see <a href="#ptrange">Ranges</a>)</li><li><strong>lists</strong>

                         are mutable sequences of any data type (see <a href="#ptlist">Lists</a>)</li></ul><h3 id="ptstring">Strings</h3><p>A <em>string</em> is an immutable sequence of characters treated
as a value. As such, strings support all of the immutable
sequence functions and operators that result in a new
string. For example, <code>"abcdef"[1:4]</code> is the new
string <code>"bcd"</code>. For more information on string

                    functions see <a href="#pappstr">Appendix B: String methods</a>.</p><p>Jython does not have a character type. Characters are
represented by strings of length one (that is, one character).
</p><p>Strings literals are defined by the use of single or
triple quoting. Strings defined using single quotes cannot
span lines while strings using triple quotes can. A string
may be enclosed in double quotes (") or single ones (').


                    A quoting character may contain the other quoting character un-escaped or the quoting character escaped (proceeded by the backslash (\) character). See <a href="#pappesc">Appendix A: Escape characters</a> for more
on this. </p><h3 id="pexstring">String examples</h3><p>Following are some example strings:</p><ul class="ibm-bullet-list"><li>"This is a string"</li><li>'This is also a string'</li><li>"This is Barry's string"</li><li>'Barry wrote "Introduction to Jython"!'</li><li>"This is an escaped quote (\") in a quoted string"</li><li>r"\s*xyx\s*" - equivalent to"\\s*xyx\\s"</li><li>u"the number one is \u0031" (vs. "the number one is \x31")</li></ul><p>Note that the next-to-last example shows a <em>raw
string</em>. In raw strings the backslash characters are
taken literally (that is, there is no need to double the
backslash to get a backslash character). This raw form is
especially useful for strings rich in escapes, such as
regular expressions. We'll talk more about regular expressions
in Part 2 of this tutorial. </p><p>The last example shows a <em>Unicode string</em> and how to create
Unicode escaped values. Note that all strings are stored
using Unicode character values (as provided by the JVM);
this format just lets you enter Unicode character values.
</p><h3 id="pmixstr">Mixed and long strings</h3><p>For convenience, multiple strings separated by only
white space are automatically concatenated (as if the <code>+</code>
operator was present) by the Jython parser. This makes it
easy to enter long strings and to mix quote types in a
single string. For example the sequential literals here:</p><p><code>"This string uses ' and "  'that string uses ".'</code></p><p>becomes this string:</p><p><code>This string uses ' and that string uses ".</code></p><p>Triple quoting is used to enter long strings that
include new-lines. Strings defined using single quotes
cannot span lines while strings using triple quotes can.
They can also be used to enter short (single-line) strings
that mix quote types.  For example, the following is one long multi-line string:</p><div class="codesection"><pre class="displaycode">r"""Strings literals are defined by the use
single or triple quoting.
Strings defined using single quotes cannot span
lines while strings using triple quotes can.
A string may be enclosed in quotes (") or apostrophes (').
They may contain the other character un-escaped
or the quoting character escaped
(proceeded by the backslash (\) character."""</pre></div><p>While this is a short mixed-quote string: <code>'''This string uses ' and that string uses ".'''</code></p><h3 id="pfmtstrval">Formatting strings and values</h3><p>Jython strings supports a special formatting operation
similar to C's <code>printf</code>, but using the modulo (%)
operator. The right-hand set of items is substituted
into the left-hand string at the matching <code>%x</code> locations in the string. The set value is usually a single value, a tuple of values, or a dictionary of values.</p><p>The general format of the format specification is: </p><div class="codesection"><pre class="displaycode">%{(key)}{width}{.precision}x</pre></div><p>Here's a guide to the format items:</p><ul class="ibm-bullet-list"><li><strong>key</strong>: Optional key to lookup in a supplied dictionary</li><li><strong>width</strong>: Minimum width of the field (will be longer for large values)</li><li><strong>precision</strong>: Number of digits after any decimal point</li><li><strong>x</strong>

                        : Format code as described (in <a href="#pformsup">Appendix H: Format codes</a>)</li></ul><p>For example</p><div class="codesection"><pre class="displaycode">print "%s is %i %s %s than %s!" % ("John", 5, "years", "older", "Mark")

print "Name: %(last)s, %(first)s" % {'first':"Barry", 'last':"Feigenbaum", 'age':18}</pre></div><p>prints</p><div class="codesection"><pre class="displaycode">John is 5 years older than Mark!
Name: Feigenbaum, Barry</pre></div><h3 id="pttuple">Tuples</h3><p>Tuples are immutable lists of any type. Once created
they cannot be changed. Tuples can be of any length and can
contain any type of object. Some examples are shown here:</p><table border="1" class="ibm-data-table" summary="table is about tuples"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Example</th><th>Comment(s)</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>()</code></td><td>An empty tuple</td></tr><tr><td><code>(1,)</code></td><td>A tuple with one element, an integer; the comma is needed to distinguish the tuple from an expression like (1)</td></tr><tr><td><code>(1, 'abc', 2, "def")</code></td><td>A tuple with four elements, two integers and two strings</td></tr><tr><td><code>((), (1,), (1,2), (1,2,3))</code></td><td>A tuple of tuples; Each sub-list contains integers</td></tr><tr><td><code>(1, "hello", ['a','b','c'], "goodbye")</code></td><td>A mixed tuple of integers, strings and a sub-list of strings</td></tr><tr><td><code>v1 = 1; v2 = 10</code><br/><code>(1, v1, v2, v1 + v2)</code></td><td>A tuple of integers; variable references and expressions are supported</td></tr></tbody></table><p>Note that although a tuple is immutable, the elements in it


                    may not be. In particular, nested lists (see <a href="#ptlist">Lists</a>) 

                    and maps (see <a href="#ptmap">Maps and dictionaries</a>) can be changed. </p><h3 id="ptrange">Ranges</h3><p>To implement iteration (see the <a href="#psfor">The for statement</a>)
Jython uses immutable sequences of increasing integers.
These sequences are called <em>ranges</em>. Ranges are easily
created by two built-in functions:</p><ul class="ibm-bullet-list"><li><strong>range({start,} end {,inc})</strong> creates a small range.
<br/>
All elements of the range exist.
</li><li><strong>xrange({start,} end {,inc})</strong> creates a large range.
<br/>
Elements are created only as needed.
</li></ul><p>Ranges run from <code>start</code> (defaults to 0), up to but not
including <code>end</code>, stepping by <code>inc</code> (defaults to 1).  For example:</p><div class="codesection"><pre class="displaycode">print range(10)        # prints [0,1,2,3,4,5,6,7,8,9]
print range(2,20,2)    # prints [2,4,6,8,10,12,14,16,18]
print range(10,0,-1)   # prints [10,9,8,7,6,5,4,3,2,1]</pre></div><h3 id="ptlist">Lists</h3><p>Lists are mutable sequences of any type. They can grow
or shrink in length and elements in the list can be replaced
or removed.  Lists can be of any length and can contain any
type of object.  For more information on list functions see

                    
                    <a href="#papplistmeth">Appendix C: List methods</a>. Some examples are shown below.</p><table border="1" class="ibm-data-table" summary="table is about list methods"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Example</th><th>Comment(s)</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>[]</code></td><td>An empty list</td></tr><tr><td><code>[1]</code></td><td>A list with one element, an integer</td></tr><tr><td><code>[1, 'abc', 2, "def"]</code></td><td>A list with four elements, two integers and two strings</td></tr><tr><td><code>[[],[1],[1,2],[1,2,3]]</code></td><td>A list of lists; Each sub-list contains integers</td></tr><tr><td><code>[1, "hello", ['a','b','c'], "goodbye"]</code></td><td>A mixed list of integers, strings and a sub-list of strings</td></tr><tr><td><code>v1 = 1; v2 = 10</code><br/><code>[1, v1, v2, v1 + v2]</code></td><td>A list of integers; variable references and expressions are supported</td></tr></tbody></table><h3 id="pstkqueue">Stacks and queues</h3><p>Lists support the notion of <em>Last-In/First-Out</em>
(LIFO) stacks and <em>First-in/First-out</em> (FIFO) queues.
Using list <em>x</em> to create a stack, remove items with
<code>x.pop()</code> (or the equivalent
<code>x.pop(-1)</code>). Using list <em>x</em> to create a
queue, remove items with <code>x.pop(0)</code>. To add
elements to the list use <code>x.append(item)</code>. 
For example:
</p><div class="codesection"><pre class="displaycode">l = [1,2,3,4,5]  # define a list            

l.append(6)      # l is [1,2,3,4,5,6]

w = l.pop()      # w is 6, l is [1,2,3,4,5] 
x = l.pop(-1)    # x is 5, l is [1,2,3,4]
y = l.pop(0)     # y is 1, l is [2,3,4]
z = l.pop(0)     # z is 2, l is [3,4]</pre></div><h3 id="plistcomp">List comprehensions</h3><p>Lists can also be created via an advanced notation,
called list comprehensions. <em>List comprehensions</em> are
lists combined with <code>for</code> and <code>if</code>
statements to create the elements of the list. For more

                    information see <a href="#psfor">The for statement</a> and

                    
                    <a href="#psif">The if statement</a>. Some example list comprehensions follow:</p><table border="1" class="ibm-data-table" summary="table is about list comprehensions"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Example</th><th>Resulting list</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>[x for x in range(10)]</code></td><td>[0,1,2,3,4,5,6,7,8,9]<br/>Same as <code>range(10)</code></td></tr><tr><td><code>[x for x in xrange(1000)]</code></td><td>[0,1,2,..., 997, 998, 999]<br/>Same as <code>range(1000)</code></td></tr><tr><td><code>[(x &lt; y) for x in range(3) for y in range(3)]</code></td><td>[0,1,1,0,0,1,0,0,0]</td></tr><tr><td><code>[x for x in range(10) if x &gt; 5]</code></td><td>[6,7,8,9]</td></tr><tr><td><code>[x ** 2 + 1 for x in range(5)]</code></td><td>[1,2,5,10,17]</td></tr><tr><td><code>[x for x in range(10) if x % 2 == 0]</code></td><td>[0,2,4,6,8]</td></tr></tbody></table><h3 id="ptmap">Maps and dictionaries</h3><p>Mapping types support a mutable set of key-value
pairs (called <em>items</em>). Maps are distinct from
sequences although they support many similar operations.
They are similar to sequences in that they are abstract; you
work only with map subtypes, of which the most commonly
used type is the <em>dictionary</em>. For more information on

                    map functions see <a href="#pappmapmeth">Appendix D: Map methods</a>. </p><p>Maps support associative lookup via the key value. A key
can be any immutable type. Keys must be immutable as they

                    are hashed (see <a href="#pappbifunc">Appendix E: Built-in functions</a>) and the hash value must stay stable. Common key
types are numbers, strings, and tuples with immutable
elements. Values may be of any type (including
<code>None</code>). If <em>m</em> is a map, function
<code>len(m)</code> returns the number of items in the map.
</p><p>Maps, like sequences, support subscripting, but by key instead of index. For example, if <em>m</em> is a map, <code>x = m["x"]</code> gets a value from the map and <code>m["x"] = x</code> adds a new value to or replaces a value in the map.
</p><h3 id="pdictex">Example dictionaries</h3><p>Some example dictionary literals are below:</p><table border="1" class="ibm-data-table" summary="table is about dictionaries"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Example</th><th>Comment(s)</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>{}</code></td><td>An empty dictionary</td></tr><tr><td><code>{1:"one", 2:"two", 3:"three"}</code></td><td>A dictionary with three elements that map integers to names</td></tr><tr><td><code>{"one":1, "two":2, "three":3}</code></td><td>A dictionary with three elements that map names to integers</td></tr><tr><td><code>{"first':'Barry", "mi":"A", "last":"Feigenbaum"}</code></td><td>A dictionary that maps a name</td></tr><tr><td><code>{"init":(1,2,3), "term":['x','y','z'], "data":{1:10,2:100.5}}</code></td><td>A dictionary containing a tuple, a list, and another dictionary</td></tr><tr><td><code>t = (1,2,3); l = ['x','y','z'];  d = {1:10,2:100.5}</code><br/><code>{"init":t, "term":l, "data":d}</code></td><td>A dictionary containing a tuple, a list, and another dictionary; variable references and expressions are supported</td></tr></tbody></table><p>As shown in <a href="#pfmtstrval">Formatting strings and values</a>, dictionaries are convenient for format mapping.  </p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-content" class="ibm-anchor-up-link">Back to top</a></p><h2 id="N108E0">Jython program structure</h2><h3 id="pfilestruct">File structure</h3><p>As explained in the introduction,
Jython programs are simply text files. These files contain statements
that are interpreted as they are input (after a quick parsing for
syntax errors). Other files can be effectively included into Jython


                    programs by use of the <code>import</code>  (
                    see <a href="#pmodpack">Modules and packages</a>) and <code> exec</code> statements (see <a href="#peval">Dynamic code evaluation</a>). </p><h3 id="pjycmt">Commentary</h3><p>Jython has two forms of comments:</p><ul class="ibm-bullet-list"><li><strong>Remarks</strong> are comments introduced with the sharp (#)
character. All text on the same line after the sharp is ignored.
Remarks can start in any column. </li><li><strong>Documentation comments</strong> are a string literal located 
immediately after the start of an
externalized block, such as a module, class, or function.
The string does not change the behavior of the block;
yet the comment can be accessed  via the special attribute
<code>__doc__</code> to create descriptions of the block.
</li></ul><h3 id="pcmtex">A commentary example</h3><p>The following example shows a function (<code>fac</code>) that
has a documentation comment and two remarks. It also
demonstrates how to access the documentation comment
programmatically.</p><p>The code sequence</p><div class="codesection"><pre class="displaycode">def fac(x):
     "The fac function computes the value x! (x factorial)"
     if x &lt;= 1: return 1       # base case
     return long(x) * fac(x-1) # use recursion on reduced case
  :
print fac.__doc__</pre></div><p>results in the output</p><div class="codesection"><pre class="displaycode">The fac function computes the value x! (x factorial)</pre></div><h3 id="pstmtsyn">Statement syntax</h3><p>As you likely have gathered from the previous sections, Jython has a simple
syntax. It more closely resembles English than languages like C and
Java language. In particular, each source line is (generally) a single
statement. Except for <code>expression</code> and
<code>assignment</code> statements, each statement is introduced by a
keyword name, such as <code>if</code> or <code>for</code>. You may
have blank or remark lines between any statements. </p><p>You don't need to end each line with a semicolon
but you may do so if desired. If you wish to include
multiple statements per line, then a semicolon is needed to
separate statements. </p><p>If required, statements may continue beyond one line.
You may continue any line by ending it with the backslash character, as shown below:</p><div class="codesection"><pre class="displaycode">x = "A looooooooooooooooooooooooooooooooong string " + \
     "another looooooooooooooooooooooooooooooooong string"</pre></div><p>If you are in the middle of a structure enclosed in parenthesis
(()), brackets ([]) or  curly braces ({}), you may continue the line after
any comma in the structure without using a backslash. Here's an example: </p><div class="codesection"><pre class="displaycode">x = (1, 2, 3, "hello",
      "goodbye", 4, 5, 6)</pre></div><h3 id="pkeyword">Identifiers and reserved words</h3><p>Jython supports identifiers similar to C++ and
Java names. <em>Identifiers</em> are used to name variables,
functions, and classes, and also as keywords. Identifiers can
be of any length. They must start with a letter (upper- or
lowercase) or the underscore (_) character. They may
contain any combination of letters, decimal digits, and the
underscore. Some valid identifiers are <em>abc</em>,
<em>abc123</em>, <em>_x</em>, <em>x_</em>, <em>myName</em>, and
<em>ONE</em>. Some invalid identifiers are <em>123abc</em>,
<em>$xyz</em>, and <em>abc pqr</em>. </p><p>Note that names starting with underscore are
generally reserved for internal or private names. </p><p>Jython also has several <em>reserved words</em> (or
<em>keywords</em>) which cannot be used as variable, function,
or class names. They fall under the following categories:</p><ul class="ibm-bullet-list"><li><strong>Statement introducers</strong>: <em>assert</em>,
<em>break</em>, <em>class</em>, <em>continue</em>, <em>def</em>,
<em>del</em>, <em>elif</em>, <em>else</em>, <em>except</em>,
<em>exec</em>, <em>finally</em>, <em>for</em>, <em>from</em>,
<em>global</em>, <em>if</em>, <em>import</em>, <em>pass</em>,
<em>print</em>, <em>raise</em>, <em>return</em>, <em>try</em>, and
<em>while</em>.
</li><li><strong>Parameter introducers</strong>: <em>as</em>, <em>import</em>,
and <em>in</em>.</li><li><strong>Operators</strong>: <em>and</em>,
<em>in</em>, <em>is</em>, <em>lambda</em>, <em>not</em>, and
<em>or</em>.
</li></ul><p>Note that keywords can be used in special circumstances,
such as names of methods. For instance, you might use a
keyword to call a Java method with the same name as a
Jython keyword. Improper keyword use will generally cause a
<code>SyntaxError</code>. </p><h3 id="pblock">Blocks</h3><p><em>Blocks</em> (or <em>suites</em>) are groups of
statements that are used where single statements are
expected. All statements that can take a block of statements
as a target introduce the block with the colon
character. The following statements (or statement clauses)
can take a block as their target: <em>if</em>, <em>elif</em>,
<em>else</em>, <em>for</em>, <em>while</em>, <em>try</em>,
<em>except</em>, <em>def</em>, and <em>class</em>. Either a single
statement or small group of statements, separated by
semicolons, may follow the colon on the same line, or a
block may follow the statement indented on subsequent lines.
</p><p>I highly recommend that you use spaces to indent. Using
tabs can cause problems when moving between systems (or
editors) with different tab stops. Do <em>not</em> mix tabs
and spaces in the same source file. By convention, four
spaces are used per level.</p><p><strong>Note:</strong> All the lines in the outermost block of a
module must start at column one; otherwise, a
<code>SyntaxError</code> is created.</p><h3 id="pblockex">Example blocks</h3><p>Unlike with C and the Java language, in Jython curly braces are not used to delimit blocks; indentation is used instead.  For example</p><div class="codesection"><pre class="displaycode"># the following prints 0 through 10 on one line
for i in range(10):
     # print next value
     print i,
print  # new line</pre></div><p>outputs the line: 0 1 2 3 4 5 6 7 8 9. </p><p>The block that is the body of the for-loop is indicated by the 
indented code. All lines in the body (except for comments) must be indented to the same position.
The same loop could be written as:</p><div class="codesection"><pre class="displaycode"># the following prints 0 through 10 on one line
for i in range(10): print i,   # print next value
print  # new line</pre></div><h3 id="pvisscope">Visibility and scopes</h3><p>Jython supports the following scopes:</p><ul class="ibm-bullet-list"><li><strong>Built-in</strong> symbols defined by the Jython runtime
are always available unless redefined in another scope.</li><li><strong>Global</strong> variables are visible to the an entire
module, including functions and classes declared in the
module.  A dictionary of the variables in the current global
scope can be accessed via the <em>globals</em> function. </li><li><strong>Local</strong> function arguments and variables declared
in a function body are visible to that block. A dictionary
of the variable names in the current local scope can be
accessed via the <em>locals</em> function. In a module and
outside of any function, the local and global scopes are the
same.</li></ul><p>In general, variables are visible in the scope of the


                    block they are declared in and in any function (see <a href="#">Jython functions</a>
                    ) 
defined in that scope. Variables can be declared only once per scope; subsequent use re-binds that
variable. Unlike in C++ and the Java language, nested blocks inside
functions do not start new scopes. </p><h3 id="peval">Dynamic code evaluation</h3><p>Jython is distinguished from typical languages in its
ability to dynamically create code and then execute it.
For example, in a calculator application, the user can enter
an expression in text form and Jython can directly execute
the expression (assuming it follows Jython source rules).</p><p>To better understand how Jython interprets/evaluates dynamic code, consider the following:</p><div class="codesection"><pre class="displaycode">v1 = 100; v2 = 200
l1 = [1, 2, v1, v2]
d1 = {"simple":123, "complex":(v1, v2, l1)}
expr = raw_input("Enter an expression:")
print eval(expr)    # evaluate and print the expression</pre></div><p>Below are some sample expressions to evaluate using the code above and the results of those evaluations:</p><table border="1" class="ibm-data-table" summary="table is about Jython expressions/evaluations"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Input expression (entered as a string)</th><th>Result</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>'1234.56'</code></td><td>1234.56</td></tr><tr><td><code>'v1+v2'</code></td><td>300</td></tr><tr><td><code>'d1["simple"]'</code></td><td>123</td></tr><tr><td><code>'v1**2 + len(l1)'</code></td><td>10004</td></tr></tbody></table><h3 id="pexec">Eval, exec and execfile</h3><p>The <code>eval</code> function is used to execute an expression
that returns a value. The <code>exec</code> statement is used to
evaluate a code block (one or more statements) that does not
return a value. It takes a file, a string (often read from a
file), or a function as its source operand. The
<code>execfile</code> function executes a code block from a file.
In effect it runs a subprogram. </p><p>The <code>exec</code> statement has the following form: </p><div class="codesection"><pre class="displaycode">exec <em>source</em> {in <em>globals</em> {, <em>locals</em>}}</pre></div><p>The <code>execfile</code> and <code>eval</code> functions have the following form:</p><div class="codesection"><pre class="displaycode">execfile(<em>filename</em>, {<em>globals</em> {, <em>locals</em>}})

eval(<em>expression</em>, {<em>globals</em> {, <em>locals</em>}})</pre></div><p>All three forms optionally take two dictionaries that
define the global and local namespaces. See

                    
                    <a href="#pvisscope">Visibility and scopes</a> for more details on namespaces.
If these dictionaries are omitted, the current local
namespace (as provided by the <code>locals</code> function)
and the current global namespace (as provided by the
<code>globals</code> function) are used. </p><p>For example, if the dictionaries <code>gd = {"one":1,
"two":2}</code> and <code>ld = {"x":100, "y":-1}</code> are
used as namespaces, then this: <code> print eval("one + two * 2 + x + y", gd, ld) </code></p><p>prints:  <code>104</code>.</p><p>More details on the use of the <code>eval</code> function and <code>exec</code> statement are available in the


                    Python Library Reference (see <a href="#resources">Resources</a>).</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-content" class="ibm-anchor-up-link">Back to top</a></p><h2 id="N10AF7">Modules and importing</h2><h3 id="pmodintro">About modules and imports</h3><p>Jython breaks programs down into separate files, called
modules. Modules are reused by importing them into your


                    code. Jython provides many modules for you to reuse (see <a href="#papplibsum">Appendix F: Jython library summary</a>). Jython also allows you to reuse any Java class
and API. </p><h3 id="pmodpack">Modules and packages</h3><p>A <em>module</em> is an executable Jython file that
contains definitions (for variables, functions and/or
classes). Modules are <em>imported</em> (executed and bound)
into other programs/scripts or modules. It is necessary
to import a module when the
importing program or module needs to use some or all of the
definitions in the imported module. </p><p>Jython <em>packages</em> are conceptually hierarchically
structured sets of modules. They are implemented as
directories that contain one or more modules and a special
file, <code>__init__.py</code>, that is executed before the first
module of the package is executed. </p><p>Modules and packages enable reuse of the extensive
standard Jython and Java libraries. You can also create
modules and packages for reuse in you own Jython
applications. For more information on the available Jython

                    modules see <a href="#papplibsum">Appendix F: Jython library summary</a>. For more information
on the available Java libraries visit the Sun Microsystems' Java


                    technology home page (in <a href="#resources">Resources</a>). </p><h3 id="psimport">The import statement</h3><p>The <code>import</code> statement executes another file and
adds some or all of the names bound in it to the current

                    namespace (see <a href="#pvisscope">Visibility and scopes</a>). The current namespace
will generally be the global namespace in the importing file. All statements,
including assignments, in the module are executed. The
<code>import</code> statement comes in several forms: </p><div class="codesection"><pre class="displaycode">import <em>module</em> {as <em>alias</em>}

   -- or --

from <em>module</em> import <em>name</em> {as <em>alias</em>}

   -- or --

from <em>module</em> import *</pre></div><p>The <code>module</code> value names a Jython (.py) file or
dotted-path to a Jython package. The <code>name</code> value
selects specific names from the module. Module names are
case sensitive. These arguments can be repeated. The
optional <code>alias</code> value allows imported objects to be
renamed.</p><h3 id="pimportex">Example imports</h3><p>Below are some example <code>import</code> statements:</p><table border="1" class="ibm-data-table" summary="table is about imports"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Example</th><th>Comment(s)</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>import sys</code></td><td>Import the <code>sys</code> module.  All names in <code>sys</code> can be referenced by 
the prefix <em>sys</em>.</td></tr><tr><td><code>from sys import exc_info</code></td><td>Imports the <code>exc_info</code> function from the <code>sys</code> module.
No prefix is needed.</td></tr><tr><td><code>from sys import *</code></td><td>Imports all the names and functions in the <code>sys</code> module. No prefix is needed.</td></tr><tr><td><code>from sys import exc_info as einfo</code></td><td>Imports the <code>exc_info</code> function from the <code>sys</code> module and names it <code>einfo</code>.
No prefix is needed.</td></tr><tr><td><code>from string import uppercase as uc, lowercase as lc</code></td><td>Imports the <code>uppercase</code> and <code>lowercase</code> functions from module <code>string</code>.
No prefix is needed.</td></tr><tr><td><code>import sys, string</code></td><td>Imports modules <code>sys</code> and <code>string</code></td></tr><tr><td><code>import com.ibm.tools.compiler as compiler</code></td><td>Imports the <code>compiler</code> module from the <code>com.ibm.tools</code> package giving it the short name <code>compiler</code>.
</td></tr></tbody></table><h3 id="pimportmod">Importing modules and packages</h3><p>To import a module or package, Jython must be able to
find the associated source (.py) file. Jython uses
the <code>python.path</code> (very similar to the  Java language's
<code>CLASSPATH</code>) and <code>python.prepath</code> variables in the Jython registry to search for these files. You can use any text editor to add to or update the <code>registry</code>
file in the Jython home directory (usually
<code>c:\jython-2.1</code>). For more information, see the

                    Jython registry (in <a href="#resources">Resources</a>) or the <code>registry</code> file itself. </p><p>By default, Jython will search the directory containing the
executing source file; thus, modules located in the same directory as
the importing Jython program can be found. Frequently the current
directory is also on the path. Simply enter the following command to
examine the current search paths: </p><div class="codesection"><pre class="displaycode">import sys
print sys.path</pre></div><p>On my machine, when running in the <code>C:\Articles</code>
directory, the above command produces the following output:</p><div class="codesection"><pre class="displaycode">['', 'C:\\Articles\\.', 'C:\\jython-2.1\\Lib', 'C:\\jython-2.1']</pre></div><p>To find Java class files, Jython searches both the Java
<code>CLASSPATH</code> and the <code>sys.path</code> values.</p><h3 id="pimportexec">Import is executable</h3><p>Unlike in the Java language, the <code>import</code> statement is executable
and is not a compiler directive in Jython. Thus, imports do not need
to be done at the start of a module; just sometime before the
imported symbols are used. In fact importing can be done
conditionally, as in the following example. </p><div class="codesection"><pre class="displaycode">   :
# lots of other stuff
   :
if __name__ == "__main__":
     :
     from sys import exit
     exit(0)</pre></div><p>Imports can also be undone, as shown here:</p><div class="codesection"><pre class="displaycode">import sys
   :
# lots of other stuff
   :
del sys</pre></div><h3 id="pimportsubset">Subsetting imports</h3><p>When you import modules, all values assigned or functions
created in the module are usually available for reference by
the module importer. You can prevent this by altering the
code within the module. Either start the name with an
underscore (_) or define a special variable,
<code>__all__</code>, at the start of the module, listing only
the names of the variables or functions you want to be
imported. For example, the <code>__all__</code> definition below:</p><div class="codesection"><pre class="displaycode">__all__ = ["getline","clearcache","checkcache"]</pre></div><p>would only import the names <code>getline</code>, <code>clearcache</code>, and <code>checkcache</code>.</p><p>A similar strategy can be used at the module directory
level. Defining the variable <code>__all__</code> in a file called
<code>__init__.py</code> instructs the interpreter as to which
modules to import from the package if the wildcard (*) is
used in the import statement. For instance, if the 
line <code>__all__ = ['mod1', 'mod3', 'globals']</code> is in a file called <code>__init__.py</code> in a directory
named <em>modules</em>, it will cause the statement <code>from modules import *</code> to import the modules <code>mod1</code>, <code>mod3</code>, and <code>globals</code> from the <em>modules</em> directory. </p><h3 id="prunos">Running native applications</h3><p>Using the <code>os.system</code> function, Jython can
also run any external program that can be found on the
current host <code>PATH</code>, such as a host operating system
application. For example, to compile a Java program you could
use</p><div class="codesection"><pre class="displaycode">import os
import sys

cmd = "javac %(name)s.java 1&gt;%(name)s.out 2&gt;%(name)s.err" % \
                 {'name': sys.argv[1]})
rc = os.system(cmd)
if rc == 0:
     print "Successful"
else:
     print "Failed: return code=%i..." % rc
     # read and process the .err file...</pre></div><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-content" class="ibm-anchor-up-link">Back to top</a></p><h2 id="N10C88">Jython exceptions</h2><h3 id="pexcept">About exceptions</h3><p>Regardless of how much care a programmer takes in
designing and testing his or her code, unexpected errors, or
<em>exceptions</em>, can occur. Jython provides excellent support for recovering from these errors,
</p><p>Exceptions are generally subclasses of the Jython
type <code>exceptions.Exception</code> or the Java class
<code>java.lang.Exception</code>. Most Jython exception
names end in "Error" (such as <code>IOError</code> or 
<code>IndexError</code>) or
"Warning." Java exceptions end in either "Error" (for
critical exceptions) or "Exception" (for generally


                    recoverable exceptions). For more information see <a href="#pappexcept">The Jython exception hierarchy</a>

                      or the Python Library Reference (see <a href="#resources">Resources</a> for a link).</p><h3 id="pappexcept">The Jython exception hierarchy</h3><p>
Here is Jython's principle exception hierarchy subset.
 </p><ul class="ibm-bullet-list"><li>1 Exception
    
<ul class="ibm-bullet-list"><li> 1.1 SystemExit</li><li> 1.2 StopIteration</li><li>1.3 StandardError
        
<ul class="ibm-bullet-list"><li>     1.3.1 KeyboardInterrupt</li><li>  1.3.2 ImportError</li><li>1.3.3 EnvironmentError

<ul class="ibm-bullet-list"><li>1.3.3.1 IOError</li><li>1.3.3.2 OSError</li></ul></li><li>1.3.4 EOFError</li><li>1.3.5 RuntimeError
                
<ul class="ibm-bullet-list"><li>  1.3.5.1 NotImplementedError</li></ul></li><li>1.3.6 NameError
                
<ul class="ibm-bullet-list"><li>1.3.6.1 UnboundLocalError</li></ul></li><li>1.3.7 AttributeError</li><li>  1.3.8 SyntaxError
     
<ul class="ibm-bullet-list"><li>   1.3.8.1  IndentationError</li><li> 1.3.8.2 TabError</li></ul></li><li>1.3.9 TypeError</li><li>  1.3.10 AssertionError</li><li> 1.3.11 LookupError
                
<ul class="ibm-bullet-list"><li>  1.3.11.1 IndexError</li><li>  1.3.11.2 KeyError</li></ul></li><li>1.3.12 ArithmeticError
                
<ul class="ibm-bullet-list"><li> 1.3.12.1 OverflowError</li><li> 1.3.12.2 ZeroDivisionError</li><li>1.3.12.3 FloatingPointError</li></ul></li><li>1.3.13 ValueError</li><li>  1.3.14 ReferenceError</li><li> 1.3.15 SystemError</li><li>1.3.16 MemoryError</li></ul></li></ul></li><li> 2 Warning
    
<ul class="ibm-bullet-list"><li> 2.1 UserWarning</li><li>  2.2 DeprecationWarning</li><li>2.3 PendingDeprecationWarning</li><li>2.4 SyntaxWarning</li><li>2.5 OverflowWarning</li><li> 2.6 RuntimeWarning</li><li>2.7 FutureWarning</li></ul></li></ul><p>This hierarchy is a subset of the Python Library

                    Reference (see <a href="#resources">Resources</a>). These exceptions may be subclassed. </p><h3 id="pstryexelse">The try-except-else statement</h3><p>Like C++ and the Java language, Jython supports exception
handlers. These handlers are defined by the
<code>try-except-else</code> statement, which has the following
form:</p><div class="codesection"><pre class="displaycode">try: <em>statement</em>
except <em>type</em>, <em>var</em>: <em>statement</em>
  :
else: <em>statement</em>

-- or --

try:
    <em>block</em>
except <em>type</em>, <em>var</em>:
    <em>block</em>
  :
else:
    <em>block</em></pre></div><p>The <code>except</code> clause may be repeated with different
<code>type</code> values. If so, the exceptions either must not
overlap hierarchically (that is, be siblings) or they must be ordered
from child to root exceptions. The optional <code>type</code> value
is an exception type (either a subclass of
<code>exceptions.Exception</code> or
<code>java.lang.Throwable</code>). If <code>type</code> is missing,
then the <code>except</code> clause catches all Jython and Java
exceptions. The optional <code>var</code> value receives the actual
exception object. If <code>var</code> is missing, then the exception
object is not directly accessible. The <code>else</code> clause is
optional. It is executed only if no exception occurs. </p><p>If an exception occurs in the <code>try</code> clause, the clause
is exited and the first matching <code>except</code> clause (if any) is entered. If no exception matches, the block containing the <code>try-except-else</code> is exited and the exception is re-raised. </p><p>If an exception is raised in the <code>except</code> or <code>else</code> clause, the
clause will exit and the new exception will be processed in
the containing block.</p><h3 id="pexcinfo">Accessing exception information</h3><p>To access information about an exception, you may use
the value provided in the <code>except</code> clause as described previously or the <code>sys.exc_info</code> function. For example, you can use the following function, in which <code>type</code> is the class of the exception, <code>value</code> is the exception object (use <code>str(value)</code> to get the message), and <code>traceback</code> is the execution trace back, which is a linked list of execution stack frames.</p><div class="codesection"><pre class="displaycode">import sys
  :
try:
     :
except:
     type, value, traceback = sys.exc_info()</pre></div><p>More details on the exceptions and trace backs is available in the <em>Python Reference Manual</em>
                     (see <a href="#resources">Resources</a>). </p><h3 id="pstryfin">The try-finally statement</h3><p>Like C++ and the Java language, Jython supports an additional
construct, <code>try-finally</code>, which makes it easy to do
required cleanup activities such as closing open files,
releasing resources, etc. Any code in the <code>finally</code>
clause is guaranteed to be executed once the <code>try</code>
clause is entered, even if it is exited via a return

                    statement (see <a href="#psreturn">The return statement</a>) or an exception.
The <code>try-finally</code> statement has the following forms: </p><div class="codesection"><pre class="displaycode">try: <em>statement</em>
finally: <em>statement</em>

  -- or --

try:
    <em>block</em>
finally:
    <em>block</em></pre></div><p>Note that <code>try-except-else</code> statements may nest in
<code>try-finally</code> statements and vice versa.</p><h3 id="pstryex">A try statement example</h3><p>Here is an example of using both <code>try-except</code> and
<code>try-finally</code> statements together. We'll talk more about
Jython file I/O in <a href="http://www.ibm.com/developerworks/edu/j-dw-java-jython2-i.html">Part 2</a> of this tutorial.</p><div class="codesection"><pre class="displaycode">def readfile (name):
     "return the lines in a file or None if the file cannot be read"
     try:
         file = open(name, 'r')  # access the file
         try:
             return file.readlines()
         finally:
             file.close()    # ensure file is closed
     except IOError, ioe:    # report the error
         print "Exception -", ioe

:

# prints <em>Exception - File not found - nofile (...)</em>
# then <em>None</em>
print readfile("nofile")      

# prints a list of the lines in the file
print readfile("realfile")</pre></div><h3 id="psraise">The raise statement</h3><p>Exceptions are generated by called functions or built-in services.
You can also generate one by using the <code>raise</code> statement.
The <code>raise</code> statement has the following forms:</p><div class="codesection"><pre class="displaycode">raise <em>exception</em>

  -- or --

raise <em>exception_class</em> {, <em>message</em>}

  -- or --

raise</pre></div><p>Below are some example <code>raise</code> statements.</p><table border="1" class="ibm-data-table" summary="table is about raise statements"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Example</th><th>Comment(s)</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>raise</code></td><td>Re-raise the current exception; used in an except block to regenerate the exception</td></tr><tr><td><code>raise IOError</code></td><td>Create and raise an <code>IOError</code> with no message</td></tr><tr><td><code>raise anIOError</code></td><td>Re-raise an existing <code>IOError</code> object</td></tr><tr><td><code>raise IOError, "End of File"</code></td><td>Create and raise an <code>IOError</code> with a explanatory message</td></tr><tr><td><code>from java import io</code><br/><code>raise io.IOException, "End of File"</code></td><td>Create and raise a Java exception with a explanatory message</td></tr></tbody></table><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-content" class="ibm-anchor-up-link">Back to top</a></p><h2 id="N10E56">Jython procedural statements</h2><h3 id="psintro">A statement for every procedure</h3><p>Jython has a number of statements that perform computation or
control program flow, including the <code>expression</code>,
<code>assignment</code>, <code>pass</code>, <code>if</code>,
<code>while</code>, <code>for</code>, <code>break</code>,
<code>continues</code>, and <code>del</code> statements. You'll learn
about these procedural statements in the sections that follow. </p><h3 id="pspass">The pass statement</h3><p>The <code>pass</code> statement is used where a Jython
statement is required syntactically but when no action is
required programmatically. <code>pass</code> can be useful to create
empty loops or to provide a temporary implementation of a
block. The statement has the following form: </p><h3 id="psexpr">The expression statement</h3><p>In Jython, any expression can serve as a statement; the resulting
value is simply discarded. Most often any such
<code>expression</code> statement calls a function or method
(discussed further in Part 2). For example, the following code
invokes three functions in sequence: </p><div class="codesection"><pre class="displaycode">performAction(1)
performAction(2)
performAction(3)</pre></div><h3 id="popprec">Operators and precedence</h3><p>Jython expressions consist of any valid combination of


                    the operators described in <a href="#pprecsum">Summary of operator precedence</a>. They are similar to the expressions of most languages, especially C/C++ and the Java language.</p><div class="codesection"><pre class="displaycode">1 + 1                # add 1 and 1 yielding 2

(1 + 2) ** 3         # add 1 and 2 and raise the result by 3 yielding 27

1 + 2 ** 3           # raise 2 by 3 and add 1 yielding 9

x % y == 0           # tests to see if x is divisible by y

x &amp; 1                # extracts the low-order bit of x

# below is the same as: "(0 &lt;= x) and (x &lt; 100)" but is more concise
0 &lt;= x &lt; 100         # tests a range

# the use of (...) below is not required but it improves readability
(x &gt; 0) and (y &lt; 0)  # tests the relation of 2 values

1 + 2 * 3 ** 4 &lt;&lt; 2  # complex expression yielding 652
(1 + (2 * (3 ** 4))) &lt;&lt; 2   # Equivalent fully parenthesized expression</pre></div><h3 id="pprecsum">Summary of operator precedence</h3><p>Jython operator precedence is summarized in the table below. Use
parentheses to change the order or to
improve readability. Unless otherwise noted, within the same
precedence level operations are evaluated left-to-right.
Higher priority operations are at the top of the list. </p><table border="1" class="ibm-data-table" summary="table is about operator precedence"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Operation</th><th>Comment</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>( expression )</code><br/><code>( expr1, ..., exprN )</code><br/><code>[ expr1, ...,exprN ]</code><br/><code>{ key1:value1, ..., keyN:valueN }</code><br/><code>`expression`</code></td><td>Nested expression or grouping
<br/>Tuple constructor
<br/>List constructor
<br/>Dictionary constructor
<br/>repr (representation) expression</td></tr><tr><td><code>x.name</code><br/><code>x[i], x[i:j], x[i:j:k]</code><br/><code>x(...)</code></td><td>Member (attribute or method) selection
<br/>Subscripting or slicing
<br/>Function call</td></tr><tr><td><code>**</code></td><td>Raise to power (right associative)</td></tr><tr><td><code>+</code><br/><code>-</code><br/><code>~</code></td><td>Posate<br/> Negate<br/> Bit-wise not</td></tr><tr><td><code>*</code><br/><code>/</code><br/><code>%</code></td><td>Times<br/> Divide<br/> Modulo</td></tr><tr><td><code>+</code><br/><code>-</code></td><td>Plus<br/> Minus</td></tr><tr><td><code>&lt;&lt;, &gt;&gt;</code></td><td>Bit-wise shifts</td></tr><tr><td><code>&amp;</code></td><td>Bit-wise and</td></tr><tr><td><code>^</code></td><td>Bit-wise xor</td></tr><tr><td><code>|</code></td><td>Bit-wise or</td></tr><tr><td><code>is</code>, <code>is not</code><br/><code>in</code>, <code>not in</code><br/><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>, <code>&lt;&gt;</code></td><td>Sameness test
<br/>Containment test
<br/>Relational test</td></tr><tr><td><code>not</code></td><td>Logical not</td></tr><tr><td><code>and</code></td><td>Logical and</td></tr><tr><td><code>or</code></td><td>Logical or</td></tr><tr><td><code>lambda</code></td><td>Declare a lambda function</td></tr></tbody></table><h3 id="psassign">The assignment statement</h3><p>The <code>assignment</code> statement is used to bind
(or re-bind) a value to a variable. If not already
defined, <em>binding</em> creates the variable and assigns it the
value. In Jython all data are objects, so variables
actually store references to objects, not values. Variables
are not typed, thus an assignment can change the type of the value a variable references. </p><p>More than one variable can have a reference to the same
object; this is called <em>aliasing</em>. For this reason,
Jython supports the <code>is</code> and <code>is not</code> operators to test whether or not two variables refer to the same object. </p><p>A variable can only be declared once in a block. This
means that it is declared (by the parser) in the block even
if the flow in the block does not execute the <code>assignment</code>
statement that creates it. The variables will have an
undefined value until the first assignment is actually
executed. </p><p>Note that like the <code>assignment</code> statement other
statements can bind variables. Some examples are the
<code>class</code>, <code>def</code>, <code>for</code>, and
<code>except</code> statements.</p><h3 id="pparaasgn">Parallel assignment</h3><p>The <code>assignment</code> statement supports sequence 
unpacking. This can achieve a form of parallel assignment. For example, the following sets <em>a</em> to <em>1</em>, <em>b</em> to <em>2</em>, and <em>c</em> to <em>3</em>: </p><div class="codesection"><pre class="displaycode">(a, b, c) = (1, 2, 3)

-- or --

x = (1, 2, 3)
(a, b, c) = x</pre></div><p>The same number of variables must be on the left side as on the right side. This unpacking can be very
useful if you are provided with a sequence variable (say as
an argument to a function) and want to access the values
within it. For convenience, the enclosing parentheses are
not required, so the above assignment could also be written
as <code>a, b, c = 1, 2, 3</code>.</p><h3 id="pmultiasgn">Multiple assignment</h3><p>Jython supports the use of multiple assignment. For example, the following sets <em>c</em> to <em>1</em>, <em>b</em> to <em>c</em> (or <em>1</em>), and <em>a</em> to <em>b</em> (also <em>1</em>). </p><p>Thus, <code>assignment</code> is unusual in that it is right-associative.
</p><h3 id="paugasgn">Augmented assignment</h3><p>Jython supports augmented assignment, which
combines operators with <code>assignment</code>. The general form is <code>v &lt;op&gt;= expression</code>, which is equivalent to <code>v = v &lt;op&gt; expression</code>, except that <code>v</code> is evaluated only once (which can
be important in a subscripted variable). </p><p>The following augmented assignment operators are available:</p><div class="codesection"><pre class="displaycode">+= 
-=
*= 
/= 
%= 
**= 
&lt;&lt;= 
&gt;&gt;= 
&amp;= 
|=
^=</pre></div><h3 id="psif">The if statement</h3><p>The <code>if</code>, <code>elif</code>, and <code>else</code> statements provide basic decision capability. The test expressions evaluate to false (None, 0 or empty) or true (not-0 or not-empty). </p><p>This form is used to execute a statement or block conditionally: </p><div class="codesection"><pre class="displaycode">if <em>expression</em>: <em>statement</em>

  -- or --

if <em>expression</em>:
    <em>block</em></pre></div><p>Here's an example:</p><div class="codesection"><pre class="displaycode">if x &lt; 0: x = -x  # ensure x is positive</pre></div><h3 id="psifelse">The if-else statement</h3><p>The following form is used to choose between two alternative
statements and/or blocks: </p><div class="codesection"><pre class="displaycode">if <em>expression</em>: <em>statement</em>
else:          <em>statement</em>

  -- or --

if <em>expression</em>:
    <em>block</em>
else:
    <em>block</em></pre></div><p>Here's an example: </p><div class="codesection"><pre class="displaycode">if x &gt;= 0:
     result = fac(x)
else:
     print x, "is invalid for a factorial"</pre></div><h3 id="psifelifelse">The if-elif-else statement</h3><p>The following form is used to choose between a set of alternative
statements and/or blocks: </p><div class="codesection"><pre class="displaycode">if   <em>expression</em>: <em>statement</em>
elif <em>expression</em>: <em>statement</em>
:
else:            <em>statement</em>

  -- or --

if   <em>expression</em>:
    <em>block</em>
elif <em>expression</em>:
    <em>block</em>
:
else:
    <em>block</em></pre></div><p>The <code>elif</code> clause can repeat. The <code>else</code> clause is optional. Here's an example:</p><div class="codesection"><pre class="displaycode">if   x == 0:
     doThis()
elif x == 1:
     doThat()
elif x == 2:
     doTheOtherThing()
else:
     print x, "is invalid"</pre></div><h3 id="pcondex">Conditional expressions</h3><p>Most languages based on C, including C++ and the Java language,
support a <em>conditional expression</em>. These
expressions return a choice of sub-expressions. They are
especially useful to avoid the use of repeated targets. This
is important if the target contains complex expressions,
such as subscripts. Conditional expressions have the form
</p><div class="codesection"><pre class="displaycode"><strong><em>target</em> = <em>expression</em> ? <em>true_expression</em> : <em>false_expression</em></strong></pre></div><p>Jython does not support conditional expressions directly; instead it employs this form: </p><div class="codesection"><pre class="displaycode">if <em>expression</em>: <em>target</em> = <em>true_expression</em>; else: <em>target</em> = <em>false_expression</em>

-- or --

if <em>expression</em>: <em>target</em> = <em>true_expression</em>
else:          <em>target</em> = <em>false_expression</em></pre></div><p>You can approximate the Java conditional expression form
in Jython using the <code>and</code>, and <code>or</code>
operators, as shown here:</p><div class="codesection"><pre class="displaycode"><em>target</em> = (<em>expression</em>) and (<em>true_expression</em>) or (<em>false_expression</em>)</pre></div><p>Note that this form works only if
<code>true_expression</code> and
<code>false_expression</code> do not themselves evaluate to
false values (such as <code>None</code>, 0, or an empty
sequence or map). If that is the case, use the
<code>if-else</code> form.</p><h3 id="psswitch">Implementing a switch statement</h3><p>Jython does not support a <code>switch</code> or <code>case</code>
statement like many other languages do. The <code>if-elif-else</code> form can be used to do similar tests for a limited number of
cases. For more cases, you can use sequences or maps to functions 

                    (see <a href="#">Jython functions</a>
                    ), as follows:</p><div class="codesection"><pre class="displaycode">:
# define the function to handle each unique case
def case1(...): return ...
def case2(...): return ...
   :
def caseN(...): return ...

# defines cases in a dictionary; access by key
cases = {key1:case1, key2:case2, ..., keyN:caseN}
:
result = cases[key](...)  # get the selected case result

-- or --

# defines cases in a list or tuple; access by index
cases = (case1, case2, ..., caseN)
:
result = cases[x](...)  # get the xth case result</pre></div><h3 id="pswhile">The while statement</h3><p>The <code>while</code> statement is used to perform
conditional looping. As long as the expression evaluates to
<em>true</em> the loop is executed. The <code>while</code> statement has the following forms: </p><div class="codesection"><pre class="displaycode">while <em>expression</em>: <em>statement</em>
else:             <em>statement</em>

  -- or --

while <em>expression</em>:
    <em>block</em>
else:
    <em>block</em></pre></div><p>The <code>else</code> clause, which is optional, is executed
only if the <code>while</code> clause ends normally (that is, not with a <code>break</code> statement). It is not typically used. </p><p>Example: </p><div class="codesection"><pre class="displaycode">x = 10
while x &gt; 0:
     process(x)
     x -= 1</pre></div><p>The following is an infinite loop:</p><h3 id="psfor">The for statement</h3><p>The <code>for</code> statement is used to perform iterative
looping. It processes a sequence returned from the supplied <code>expression</code>, taking each element in turn. As long as elements remain in
the sequence, the loop is executed. The <code>for</code> statement has the following forms: </p><div class="codesection"><pre class="displaycode">for <em>vars</em> in <em>expression</em>: <em>statement</em>
else:                   <em>statement</em>

  -- or --

for <em>vars</em> in <em>expression</em>:
    <em>block</em>
else:
    <em>block</em></pre></div><p>The <code>else</code> clause, which is optional, is executed
only if the <code>for</code> clause ends normally (that is, not with a
<code>break</code> statement). It is not typically used. </p><p>Example: </p><div class="codesection"><pre class="displaycode">for c in "String":
     processCharacter(c)  # process the chars in turn

   -- or --

values = (1,2,5,7,9,-1)
for v in values:
     process(v)  # process the values supplied

   -- or --

for i in range(10):
     print i    # print the values 0 to 9 on separate lines

   -- or --

for k, v in {"one":1, "two":2, "three":3}.items():
     print k, '=', v    # print the keys and values of a dictionary</pre></div><p>In the above code, the use of <code>for i in
range(limit)</code> provides for the typical <em>for-loop</em>
or <em>do-loop</em> iteration of most languages. Note also
that the <code>keys</code> will not necessarily come out in the
order supplied.</p><h3 id="psbreak">The break and continue statements</h3><p>It is sometimes necessary to exit a <code>while</code>
or <code>for</code> loop in the middle. Often this is the
result of some unusual condition that cannot be tested in
the loop mechanism itself. The <code>break</code> statement
provides this behavior. The statement has the
following form: </p><p>Here's an example:</p><div class="codesection"><pre class="displaycode">for i in range(100):
     d = getData(i)
     if not valid(d): break    # can't continue
     processData(d)</pre></div><p>Likewise, it may be occasionally necessary to skip the rest of the
loop body and begin the next iteration early. The
<code>continue</code> statement provides this behavior. The statement has the following form: </p><p>Here's an example:</p><div class="codesection"><pre class="displaycode">for i in range(100):
     :     # *** some preliminary work ***
     if not valid(i): continue           # can't process this one
     :     # *** some other stuff ***</pre></div><p>In general, the <code>break</code> and <code>continue</code> statements occur as
the target of an <code>if</code> statement. Only the most
closely contained loop can be controlled. </p><h3 id="pupseq">Updating a sequence</h3><p>You must take special care when updating (that is,
inserting or deleting entries from) a sequence while
iterating over it, as this can cause the iteration indexes
to change unpredictably. I recommend you make a copy of the
sequence to iterate over, as shown below:</p><div class="codesection"><pre class="displaycode">for i in x[:]:    # iterate over a copy
     if i &gt; 0:     # remove all positive values
         x.remove(i)</pre></div><h3 id="psdel">The del statement</h3><p>Mutable sequences (see <a href="#ptseq">Sequence types</a>), maps (see <a href="#ptmap">Maps and dictionaries</a>), and classes support the <code>del</code> statement,
which removes an element or attribute from the collection or class,
respectively. For sequences, removal is by index; for maps it is by
key value; and for classes it is by attribute name. We'll talk more
about class support for the  <code>del</code> statement in <a href="http://www.ibm.com/developerworks/edu/j-dw-java-jython2-i.html">Part 2</a> of
this tutorial.</p><p>Local or global variables can be deleted; this removes the
variable from the namespace (it does not delete the object
the variable refers to). The <code>del</code> statement also supports the slice notation. </p><p>Assuming "l" is the list [1,2,3,4,5], <em>d</em> is
the dictionary {1:"one", 2:"two", 3:"three"} and <em>x</em> is some class instance, some example <code>del</code> statements are as follows: </p><table border="1" class="ibm-data-table" summary="table is about del statements"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Example</th><th>Comment(s)</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>del l[0]</code></td><td>Removes the first element</td></tr><tr><td><code>del l[1:3]</code></td><td>Removes the second through third elements</td></tr><tr><td><code>del l[::2]</code></td><td>Removes the even elements</td></tr><tr><td><code>del l[:]</code></td><td>Removes all the elements</td></tr><tr><td><code>del d[1]</code></td><td>Removes the element with key <em>1</em></td></tr><tr><td><code>del x.attr1</code></td><td>Removes the attribute <code>attr1</code></td></tr><tr><td><code>var = [1,2,3]</code><br/><code>:</code><br/><code>del var</code></td><td>Removes the variable <code>var</code> from its namespace</td></tr></tbody></table><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-content" class="ibm-anchor-up-link">Back to top</a></p><h2 id="N11273">Jython functions</h2><h3 id="pfunc">What are functions?</h3><p>One of the most important features of any programming
language is code reuse. There are two principle methods of
code reuse: blocks of code that return values (called
<em>functions</em>) and blocks that do not return values
(called <em>subroutines</em>). Jython fully supports code
reuse via functions. </p><p>Jython provides many built-in and library functions for

                    you to use (see <a href="#pappbifunc">Appendix E: Built-in functions</a>
                     and <a href="#papplibsum">Appendix F: Jython library summary</a>). Built-in
functions can be used without importing them; library
function must first be imported. </p><p>Jython goes beyond many languages, including the Java
language, by making functions <em>first-class</em> objects
that can be manipulated just like other objects (and most
specifically, objects that can be stored in collections and
passed as arguments to other functions). </p><h3 id="pdef">The def statement</h3><p>In Jython, functions are declared by the <code>def</code>
statement, which has the following form: </p><div class="codesection"><pre class="displaycode">def <em>name</em> (  <em>args</em>  ): <em>statement</em>

  -- or --

def <em>name</em> ( <em>args</em> ):
    <em>block</em></pre></div><p>Within a given scope (module, function, or class), each
function name should be unique. The function name is really
a variable bound to the function body (similar to any other
assignment). In fact, multiple variables can be defined to
reference the same function. The function body can be a
single (frequently a return) statement or (more commonly) a block of statements.
</p><h3 id="pfuncargs">Specifying function arguments</h3><p>The optional <em>args</em> in the <code>def</code> statement is a comma-separated list of argument definitions. Some examples follow:</p><table border="1" class="ibm-data-table" summary="table is about funcion arguments"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Example</th><th>Comment(s)</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>def x(a, b, c)</code></td><td>Defines a function with three required positional arguments.</td></tr><tr><td><code>def x(a, b, c=1)</code></td><td>Defines a function with three arguments, the last of which is optional with a default value of 1.</td></tr><tr><td><code>def x(a=3, b=2, c=1)</code></td><td>Defines a function with three arguments, all of which are optional and have default values.</td></tr><tr><td><code>def x(p1, p2, kw1=1, kw2=2)</code></td><td>Defines a function with two positional parameters and two keyword (optional) parameters. When declared, all optional (=value) parameters must follow all non-optional parameters. When this function is called, the keyword parameters, if provided, can be specified by name and in any order after positional parameters.</td></tr><tr><td><code>def x(p1, p2, *v)</code></td><td>Defines a function with two required positional parameters and an indeterminate number of variable parameters. The <code>v</code> variable will be a tuple.</td></tr><tr><td><code>def x(p1, p2, **kw)</code></td><td>Defines a function with two required positional parameters and an indeterminate number of keyword parameters. The <code>kw</code> variable will be a dictionary.</td></tr><tr><td><code>def x(p1, p2, *v, **kw)</code></td><td>Defines a function with two required positional parameters and an indeterminate number of positional and keyword parameters. The <code>v</code> variable will be a tuple. The <code>kw</code> variable will be a dictionary.</td></tr></tbody></table><h3 id="pmutargs">Handling mutable arguments</h3><p>If an argument accepts a default value of a mutable
object (such as a list or dictionary) it's best to use the this form:</p><div class="codesection"><pre class="displaycode">def x(p1, p2, p3=None)
     if p3 is None: p3 = []
     :</pre></div><p>rather than the simple one:</p><p>Because the value after the equals sign is evaluated only
when the function is defined (not each time it is called), the list
in the second example above will be shared across all calls to the
function. This is usually not the desired behavior. The first
example gets a distinct list for each call. </p><h3 id="plambda">Anonymous functions</h3><p>You can define anonymous functions, called <code>lambda</code> functions. Anonymous functions are one-line functions that are typically used as arguments to other functions. These functions are
declared using the following form: </p><p>The args list is the same as the one described in <a href="#pfuncargs">Specifying function arguments</a>.  You should have at
least one argument per <code>lambda</code> function.  The expression value is returned by the function.</p><h3 id="psreturn">The return statement</h3><p>Functions return values via the <code>return</code> statement,
which also exits a function. The <code>return</code> statement may or
may not return an explicit value; if no value is specified, then
<code>None</code> is used. If the last statement of a function body
is not a <code>return</code> statement, then a value-less return is
assumed. The <code>return</code> statement has the following forms:
</p><div class="codesection"><pre class="displaycode">return <em>expression</em>

  -- or --

return</pre></div><p>Alternatively, this form lets you return
multiple values as a tuple: </p><div class="codesection"><pre class="displaycode">return <em>expression1</em>, <em>expression2</em>, ..., <em>expressionN</em></pre></div><h3 id="pfcall">Function calls</h3><p>Functions are called by use of the <code>call</code> operator,
which is a parenthesized list following a function
reference. For example, if <em>f</em> is a function, then
<code>f(...)</code> calls the function. If the function
definition supports arguments, then the call may include
parameters, as shown in the examples below:</p><table border="1" class="ibm-data-table" summary="table is about funcion calls"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Function definition</th><th>Example call(s)</th><th>Comment(s)</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>def x(a, b, c)</code></td><td><code>x(1,2,3)</code><br/><code>x("1", "2", "3")</code></td><td>Actual arguments can be of any type.</td></tr><tr><td><code>def x(a, b, c=1)</code></td><td><code>x(1,2,3)</code><br/><code>x(1,2)</code></td><td>Parameter <code>c</code> can be omitted</td></tr><tr><td><code>def x(a=3, b=2, c=1)</code></td><td><code>x()</code><br/><code>x(1,2,3)</code><br/><code>x(c=10, a="d")</code><br/><code>x(1,c=5)</code></td><td>Named parameters can be treated as positional, keyword, or mixed. If keyword, order is not important. </td></tr><tr><td><code>def x(p1, p2, kw1=1, kw2=2)</code></td><td><code>x(1,2)</code><br/><code>x(1,3,kw2=5)</code></td><td>Both positional and keyword parameters can be used.</td></tr><tr><td><code>def x(p1, p2, *v)</code></td><td><code>x(1,2)</code><br/><code>x(1,2,3)</code><br/><code>x(1,2,3,4)</code></td><td>The <code>v</code> tuple gets the third and subsequent parameters.</td></tr><tr><td><code>def x(p1,p2,**kw)</code></td><td><code>x(1,2, aaa=1, mmm=2, zzz=3)</code></td><td>Keywords can have any name.</td></tr><tr><td><code>def x(p1,p2,*v, **kw)</code></td><td><code>x(1,2,3,4, aaa=1, xxx="yyy")</code></td><td>The <code>v</code> tuple gets the third and subsequent positional
parameters while the dictionary <code>kw</code> gets the <code>aaa</code> and <code>xxx</code>
keys with values.</td></tr></tbody></table><p>Note that spaces are optional between parameter
declarations and arguments. Adding a space between each is
recommended for increased readability. </p><h3 id="pexfunc">Example function definitions and calls</h3><p>Below are some example function definitions with
example calls.</p><div class="codesection"><pre class="displaycode">def k(): return 1   # return the constant 1
print k()           # prints 1

# below replaces the built-in abs definition
def abs(x):         # calc the absolute value
     if x &lt; 0: return -x
     return x
print abs(-10)      # prints 10

sum = lambda x, y: x + y   # define sum function
print sum(1,2)      # prints 3

prod = lambda x, y: x * y  # define prod function
print prod(1,2)     # prints 2

# fully equivalent to the above,
# but the above binding of prod is replaced
def prod(x, y): return x * y      # define the prod function
print prod(1,2)     # prints 2

# make an alias of prod
xy = prod
print xy(1,2)       # prints 2

# a function that takes a function
#  similar to the built-in function apply
def applyer (func, args):
     return func(*args)

print applyer(xy, (1,2))                   # prints 2
print applyer(lambda x,y: x ** y, (2,16))  # prints 65536

def factorial(x):
     "calculate the factorial of a number"
     if x &lt; 0:
         raise ValueError, "negative factorial not supported"
     if x &lt; 2:
         return 1
     return long(x) * factorial(x-1)

print factorial(3)               # prints 6</pre></div><h3 id="psglobal">The global statement</h3><p>Occasionally, you may want to declare (that is, assign to)
a variable in a local context (such as in a function) but
reference a variable in the global scope. To do this, use
the <code>global</code> statement before the first use of the
variable. Here's an example:</p><div class="codesection"><pre class="displaycode">x = 10; y = 20; z = 30  # three global variables

def f1(p, q, r):
     x = p      # local x, y &amp; z variables
     y = q
     z = r

def f2(a, b, c):
     global x, y
     x = a      # global x &amp; y variables
     y = b
     z = c      # local z variable

print x, y, z   # prints: 10, 20, 30

f1(1, 2, 3)
print x, y, z   # prints: 10, 20, 30

f2(-1, -2, -3)
print x, y, z   # prints: -1, -2, 30</pre></div><p>Note that as long as it is not re-bound locally, a global
variable can be read without first declaring it to be a
global. Thus the <code>global</code> statement is only required to assign to a global variable.</p><h3 id="pgenfunc">Generic functions</h3><p>Similar to in Smalltalk functions, Jython functions are
<em>generic</em> in that any type can be passed in for each
argument. This makes functions extremely flexible. Generic
functions work as long as the operations performed on the
arguments in the function are valid for the argument's
actual type. For example, with these functions' definitions
</p><div class="codesection"><pre class="displaycode">def sum (x, y):
     return x + y

def prod (x, y):
     return x * y</pre></div><p>the following function calls are valid: </p><div class="codesection"><pre class="displaycode">print sum(1, 2)             # prints 3

print sum('123', '456')     # prints 123456

print sum([1,2,3], [4,5,6]) # prints [1,2,3,4,5,6]

print prod(2, 3)            # prints 6

print prod('123', 2)        # prints 123123</pre></div><h3 id="pdyntype">Dynamic type testing</h3><p>You can use dynamic type testing (that is, using the <code>isinstance</code>
function or comparing the results of the <code>type</code> function) for even more flexibility. 

                    See <a href="#papptypes">Appendix G: Jython types summary</a> for more information. Here's an example:
</p><div class="codesection"><pre class="displaycode"># See Part 2 of this tutorial for the definition of the <em>UserList</em> class 
from UserList import *
  :
data = None     # undefined until setData called
prevdata = []

def setData (values=None):
     """ Set global data. """
     global data, prevdata                 # use the global data
     if not data is None:                  # save any prior versions
         prevdata.append(data)
     data = []                             # create default empty data space
     if not values is None:                # some initial values supplied
         if isinstance(values, UserList):  # values is a UserList
             data = values.data[:]         # set to copy of UserList's values
         else:                             # values is some other sequence
             # this will fail if values is not some form of sequence
             data = list(values)           # convert to a list
  :
print data      # prints None
  :
setData("123456")
print data      # prints ['1',2','3','4','5','6']
  :
setData((1,2,3,4,5,6))
print data      # prints [1,2,3,4,5,6]
  :
xdata = data[:]; xdata.reverse()
setData(xdata)
print data      # prints [6,5,4,3,2,1]
  :
print prevdata  # prints [['1',2','3','4','5','6'],[1,2,3,4,5,6]]</pre></div><h3 id="pnestfunc">Nested functions</h3><p>Unlike many other languages, including the Java
language, Jython allows functions to be defined inside of
other functions. The nested (or <em>local</em>)
functions can help to reduce the scope of functions. Here's
an example: </p><div class="codesection"><pre class="displaycode">def x(a, b, c):
     y = a * b

     def square(x):
         return x ** 2      # this x is different from function x

     y *= square(c)
     return x</pre></div><p>The nested function has no visibility into the variables in the containing function. If the nested function must use these values, pass them into the function as arguments. For example, the following function</p><div class="codesection"><pre class="displaycode">def calc(a, b, c):
     x = a * b * c

     def sum(data):
         # cannot access calc's namespace (x, a, b, c, or sum) here
         print locals()
         return data['a'] + data['b'] + data['c']

     x += sum(locals())
     return x

print calc(10,20,30)</pre></div><p>prints</p><div class="codesection"><pre class="displaycode">{'data': {'x': 6000, 'c': 30, 'b': 20, 'sum': \
     &lt;function sum at 32308441&gt;, 'a': 10}}
6060</pre></div><p>Nested functions can also be used to conveniently create (preconfigured) functions to return as a result, as shown here:</p><div class="codesection"><pre class="displaycode">def makeSq(n):
     def sq(x=n):  # n's value is saved as the parameter x value
         return x ** 2 
     return sq</pre></div><p>The above function can be used like this:</p><div class="codesection"><pre class="displaycode">sq2 = makeSq(2)
print "2*2=%i" % sq2()     # prints: 2*2=4

sq10 = makeSq(10)
print "10*10=%i" % sq10()  # prints: 10*10=100</pre></div><h3 id="pfuncpgm">Functional programming</h3><p>Like Lisp and Smalltalk, Jython supports a limited form
of functional programming. Functional programming
uses the first-class nature of Jython functions and performs
operations on functions and data structures. The built-in
functional programming services are shown below: </p><table border="1" class="ibm-data-table" summary="table is about functional programming"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Syntax</th><th>Use/Comment(s)</th><th>Example(s)</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>apply(func, pargs {, kargs})</code><br/><code>func(*pargs {, **kargs})</code></td><td>Execute the function with the supplied positional arguments and optional keyword arguments.</td><td><code>apply(lambda x, y: x*y, (10, 20)) --&gt; 200</code></td></tr><tr><td><code>map(func, list, ...)</code></td><td>Creates a new list from the results of applying <code>func</code> to each element of each list. There must be one list per argument to the function.</td><td><code>map(lambda x, y: x+y, [1,2],[3,4]) --&gt; [4,6]</code><br/><code>map(None, [1,2],[3,4]) --&gt; [[1,3],[2,4]]</code></td></tr><tr><td><code>reduce(func, list {,init})</code></td><td>Applies <code>func</code> to each pair of items in turn. The results are accumulated.</td><td><code>reduce(lambda x, y: x+y, [1,2,3,4],5) --&gt; 15</code><br/><code>reduce(lambda x, y: x&amp;y, [1,0,1]) --&gt; 0</code><br/><code>reduce(None, [], 1) --&gt; 1</code></td></tr><tr><td><code>filter(func, seq)</code></td><td>Creates a new list from <code>seq</code> selecting the items for which <code>func</code> returns <em>true</em>.
<code>func</code> is a one-argument function.</td><td><code>filter(lambda x: x&gt;0, [1,-1,2,0,3]) --&gt; [1,2,3]</code></td></tr></tbody></table><p>Using functions like <code>map</code>, <code>reduce</code>, and
<code>filter</code> can make processing sequences (that is, strings,
lists, and tuples) much easier. These functions are
<em>higher-order</em> functions because they either take functions as
arguments or return them as results. </p><h3 id="pfuncpgmex">Functional programming examples</h3><p>We'll close this section on Jython functions, and the
first half of the "Introduction to Jython" tutorial, with 
some functional programming examples.</p><p>A factorial calculator can be implemented using
<code>reduce</code>: </p><div class="codesection"><pre class="displaycode">def fac(x):
    return reduce(lambda m,n: long(m)*n, range(1,x))

print fac(10)      # prints 362880L</pre></div><p>List modification can be done using <code>map</code>: </p><div class="codesection"><pre class="displaycode">l = [1, -2, 7, -3, 0, -11]
l = map(abs, l)

print l      # prints [1, 2, 7, 3, 0, 11]</pre></div><p>A set of functions can be executed in a sequence using
<code>map</code>: </p><div class="codesection"><pre class="displaycode">def f1(x): return ...
def f2(x): return ...
def f3(x): return ...
  :
def fM(x): return ...
  :
def fN(x): return ...

# x=(5) is an example of a parameter for each function, 
#   any expression is allowed, each function will get it
# the list determines the order of the functions
# the result of each function is returned in a list.
results = map(lambda f,x=(5): f(x), [fN,f3,f2,f3,...,fM,...,f1])</pre></div><p>Looping can be achieved using <code>map</code>: </p><div class="codesection"><pre class="displaycode">def body1(count):
    # any body here
    :

# do body 10 times, passing the loop count
map(body1, range(10))

def body2(x,y,z):
    # any body here
    :

# do body with multiple parameters
#   calls body2(1, 'a', "xxx")
#   then  body2(2, 'b', "yyy")
#   then  body2(3, 'c', "zzz")
map(body2, [1,2,3], "abc", ["xxx", "yyy", "zzz"])</pre></div><p>Selection can be achieved using <code>filter</code>: </p><div class="codesection"><pre class="displaycode"># Assume a class Employee exists with attributes
#  name, age, sex, title, spouse and children (among others)
#  and that instances such as John, Mary and Jose exist.
# See Part 2 of this tutorial for more information on using classes.

John = Employee('John', 35, 'm', title='Sr. Engineer')
Mary = Employee('Mary', 22, 'f', title='Staff Programmer')
Jose = Employee('Jose', 50, 'm', title='Dept. Manager', children=[...])
employees = [John, Jose, Mary]</pre></div><p>Here's an example of how we'd use the above <code>filter</code> to
select some employees:</p><div class="codesection"><pre class="displaycode"># returns: [Jose]
hasChildren = filter(lambda e: e.children, employees)

# returns: []
over65 = filter(lambda e: e.age&gt;65, employees)

# returns: [Mary]
isProgrammer = filter(lambda e: \
                 e.title and e.title.lower().find('prog') &gt;= 0, employees)</pre></div><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-content" class="ibm-anchor-up-link">Back to top</a></p><h2 id="N11528">Wrap-up</h2><h3 id="psummary">Summary</h3><p>In this first half of the two-part "Introduction to Jython"
tutorial, you've learned the concepts and programming basics of
working with Jython, including access options and file compilation,
syntax and data types, program structure, procedural statements, and
functional programming with Jython.</p><p>In the second half of this tutorial, we will begin to wrestle with
some of the more advanced aspects of the language, starting with a
conceptual and hands-on introduction to object-oriented programming
in Jython. You'll also learn about debugging, string processing, file
I/O, and Java support in Jython. The tutorial will conclude with an
exciting, hands-on demonstration of how to build a working GUI app in
Jython.</p><p>It's a good idea to take the second part of the tutorial as soon
as you can, while the concepts from Part 1 are still fresh in your
mind. If you prefer to take a break in your studies, you might want


                    to use the time to explore the appendices included with Part 1 (<a href="#">Appendices</a>
                    ), or check out some of the references included in the

                    
                    <a href="#resources">Resources</a> section.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-content" class="ibm-anchor-up-link">Back to top</a></p><h2 id="N1153F">Appendices</h2><h3 id="pappesc">Appendix A: Escape characters</h3><p>
Several special characters have backslash versions:
           </p><table border="1" class="ibm-data-table" summary="table is about escape chraracters"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>
Backslash Representation
               </th><th>
Character
               </th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>\t</code></td><td>
Tab
               </td></tr><tr><td><code>\v</code></td><td>
Vertical-Tab
               </td></tr><tr><td><code>\n</code></td><td>
New-Line
               </td></tr><tr><td><code>\r</code></td><td>
Return
               </td></tr><tr><td><code>\f</code></td><td>
Form-Feed
               </td></tr><tr><td><code>\"</code></td><td>
Quote
               </td></tr><tr><td><code>\'</code></td><td>
Apostrophe
               </td></tr><tr><td><code>\\</code></td><td>
Backslash
               </td></tr><tr><td><code>\b</code></td><td>
Backspace
               </td></tr><tr><td><code>\a</code></td><td>
Bell
               </td></tr><tr><td><code>\000</code></td><td>
Octal value (3 base-8 digits in range 0-377<sub>8</sub>)
               </td></tr><tr><td><code>\xXX...</code></td><td>
Hex value (2 base 16-digits in range 0-FF<sub>16</sub>)
used in strings (that is, "\x31" --&gt; '1')
               </td></tr><tr><td><code>\uXXXX...</code></td><td>
Hex value (4 base 16-digits in range 0-FFFF<sub>16</sub>);
used in unicode strings (that is, u"\u0031" --&gt; '1')
               </td></tr></tbody></table><h3 id="pappstr">Appendix B: String methods</h3><p>
Strings support several useful methods:
           </p><table border="1" class="ibm-data-table" summary="table is about string methods"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>
Method
               </th><th>
Usage
               </th><th>
Example
               </th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td><code>s.capitalize()</code></td><td>
Initial capitalize s
               </td><td>
"abc".capitalize()  --&gt;  "Abc"
               </td></tr><tr><td><code>s.count(ss {,start {,end}})</code></td><td>
Count the occurrences of ss in s[start:end]
               </td><td>
"aaabbccc".count("ab") --&gt; 1
               </td></tr><tr><td><code>s.startswith(str {, start {, end}})</code><br/>
s.endswith(str {, start {, end}})
               </td><td>
Test to see if s starts/ends with str
               </td><td>
"xxxyyyzzz".startswith("xx") --&gt; 1
               </td></tr><tr><td><code>s.expandtabs({size})   </code></td><td>
Replace tabs with spaces, default size: 8
               </td><td>
"x\ty".expandtabs(4) --&gt; "x    y" 
               </td></tr><tr><td><code>s.find(str {, start {, end}})</code><br/><code>s.rfind(str {, start {, end}})</code></td><td>
Finds first index of str in s; if not found: -1,
rfind searches right-to-left
               </td><td>
"12345".find('23') --&gt; 1
               </td></tr><tr><td><code>s.index(str {, start {, end}})</code><br/><code>s.rindex(str {, start {, end}})</code></td><td>
Finds first index of str in s; if not found: raise ValueError.
rindex searches right-to-left
               </td><td>
"12345".index('23') --&gt; 1
               </td></tr><tr><td><code>s.isalnum</code></td><td>
Test to see if the string is alphanumeric
               </td><td>
"12345abc".isalnum() --&gt; 1
               </td></tr><tr><td><code>s.isalpha</code></td><td>
Test to see if the string is alphabetic
               </td><td>
"12345abc".isalpha() --&gt; 0
               </td></tr><tr><td><code>s.isnum</code></td><td>
Test to see if the string is numeric
               </td><td>
"12345abc".isnum() --&gt; 0
               </td></tr><tr><td><code>s.isupper</code></td><td>
Test to see if the string is all uppercase
               </td><td>
"abc".isupper() --&gt; 0
               </td></tr><tr><td><code>s.islower</code></td><td>
Test to see if the string is all lowercase
               </td><td>
"abc".islower() --&gt; 1
               </td></tr><tr><td><code>s.isspace</code></td><td>
Test to see if the string is all whitespace
               </td><td>
"12345 abc".isspace() --&gt; 0
               </td></tr><tr><td><code>s.istitle</code></td><td>
Test to see if the string is a sequence of initial cap alphanumeric strings
               </td><td>
"Abc Pqr".istitle() --&gt; 1
               </td></tr><tr><td><code>s.lower()</code><br/><code>s.upper()</code><br/><code>s.swapcase()</code><br/><code>s.title()</code></td><td>
Convert to all lower, upper, opposite, or title case
               </td><td>
"abcXYZ".lower() --&gt; "abcxyz"
<br/>
"abc def ghi".title() --&gt; "Abc Def Ghi"
               </td></tr><tr><td><code>s.join(seq)</code></td><td>
Join the strings in seq with s as the separator
               </td><td>
" ".join(("hello", "goodbye") --&gt; "hello goodbye"
               </td></tr><tr><td><code>s.splitlines({keep})</code></td><td>
Split s into lines, if keep true, keep the newlines
               </td><td>
"one\ntwo\nthree".splitlines() --&gt; ["one", "two", "three"]
               </td></tr><tr><td><code>s.split({sep {, max}})</code></td><td>
Split s into "words" using sep (default of white space) for up to max times
               </td><td>
"one two three".split() --&gt; ["one", "two", "three"]
               </td></tr><tr><td><code>s.ljust(width)</code><br/><code>s.rjust(width)</code><br/><code>s.center(width)</code><br/><code>s.zfill(width)</code></td><td>
Left, right or center justify the string in a field width wide. Fill with 0.
               </td><td>
"xxx".rjust(8) --&gt; "     xxx"
<br/>
"xxx".center(8) --&gt; "   xxx  "
<br/>
str(10).zfill(10) --&gt; "0000000010"
               </td></tr><tr><td><code>s.lstrip()</code><br/><code>s.rstrip()</code><br/><code>s.strip()</code></td><td>
Remove leading (and/or trailing) white space
               </td><td>
" xxx ".strip() --&gt; "xxx"
               </td></tr><tr><td><code>s.translate(str {,delc})</code></td><td>
Translate s using table, after removing any characters in delc. str 
should be a string with length == 256
               </td><td>
"ab12c".translate(reversealpha, "0123456789") --&gt; "cba"
               </td></tr><tr><td><code>s.replace(old, new {, max})</code></td><td>
Replaces all or max occurrences old string old with string new
               </td><td>
"11111".replace('1', 'a', 2) --&gt; "aa111"
               </td></tr></tbody></table><p><strong>Note:</strong> other methods are supported,


                    for a complete list see the Python Library Reference (<a href="#resources">Resources</a>).
Also note that by including the string module, many (but not all) of 
these methods can also be called
as functions, i.e.- <code>string.center(s, 10)</code> is the same as 
<code>s.center(10)</code>.
           </p><p>
The string module has some important variables:
           </p><table border="1" class="ibm-data-table" summary="table is about string modules"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>
Variable
               </th><th>
Comment(s)
               </th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td>
digits
<br/>
octdigits
<br/>
hexdigits
               </td><td>
The decimal, octal, and hexadecimal digits
               </td></tr><tr><td>
lowercase
<br/>
uppercase
<br/>
letters
               </td><td>
The lowercase alphabet, the uppercase alphabet, and the union of them
               </td></tr><tr><td>
whitespace
               </td><td>
The legal white space characters
               </td></tr></tbody></table><h3 id="papplistmeth">Appendix C: List methods</h3><p>
Lists support several useful methods.
           </p><table border="1" class="ibm-data-table" summary="table is about list methods"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>
Function
               </th><th>
Comment(s)
               </th><th>
Example
               </th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td>
x in l
<br/>
x not in l
               </td><td>
Test for containment
               </td><td>
1 in [1,2,3,4] --&gt; 1
               </td></tr><tr><td>
l.count(x)
               </td><td>
Count the occurrences of x.
Uses "==" to test.
               </td><td>
[1,2,3,3].count(3) --&gt; 2
               </td></tr><tr><td>
l.append(x)
<br/>
-- or --
<br/>
l = l + [x]
               </td><td>
Append x to the list
               </td><td>
[1,2].append([3,4]) --&gt; [1,2,[3,4]]
<br/>
[1,2] + [3] --&gt; [1,2,3]
               </td></tr><tr><td>
l.extend(list)
               </td><td>
Appends the elements of list
               </td><td>
[1,2].extend([3,4]) --&gt; [1,2,3,4]
               </td></tr><tr><td>
l.index(item)
               </td><td>
Finds the index of item in list;
if not present, raise ValueError
               </td><td>
[1,2,3,4].index(3) --&gt; 2
               </td></tr><tr><td>
l.insert(index, x)
<br/>
-- or --
<br/>
l[i:i] = [x]
               </td><td>
Insert x into the list before the index
               </td><td>
[1,2,3].insert(1, 4) --&gt; [1,4,2,3]
               </td></tr><tr><td>
l.pop({index})
               </td><td>
Removes the nth (default last) item
               </td><td>
[1,2,3,4].pop(0) --&gt; [2,3,4], 1
<br/>
[1,2,3,4].pop() --&gt; [1,2,3], 4
               </td></tr><tr><td>
l.remove(x)
               </td><td>
Removes the item from the list
               </td><td>
[1,2,3,4].remove(3) --&gt; [1,2,4]
               </td></tr><tr><td>
l.reverse()
               </td><td>
Reverses the list (in-place)
               </td><td>
[1,2,3].reverse() --&gt; [3,2,1]
               </td></tr><tr><td>
l.sort({cmp})
               </td><td>
Sorts the list (in-place);
The cmp function is used to sort the items.
The cmp function takes two argument and returns &lt;0, 0, &gt;0
               </td><td>
[1,4,3,2].sort() --&gt; [1,2,3,4]
               </td></tr></tbody></table><h3 id="pappmapmeth">Appendix D: Map methods</h3><p>
Maps support several useful methods.
           </p><table border="1" class="ibm-data-table" summary="table is about map methods"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>
Method
               </th><th>
Comment(s)
               </th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td>
m.clear()
               </td><td>
Empty the map
               </td></tr><tr><td>
m.copy()
               </td><td>
Make a shallow copy of the map
               </td></tr><tr><td>
m.has_key(k)
<br/>
-- or --
<br/>
k in m
               </td><td>
Test to see if a key is present
               </td></tr><tr><td>
m.items()
               </td><td>
Get a list of the key/value tuples
               </td></tr><tr><td>
m.keys()
               </td><td>
Get a list of the keys
               </td></tr><tr><td>
m.values()
               </td><td>
Get a list of the values (may have duplicates)
               </td></tr><tr><td>
m1.update(m2)
               </td><td>
add all the items in m2 to m1
               </td></tr><tr><td>
m.get(k{, default})
<br/>
m.setdefault(k, default)
               </td><td>
Get the value of k, return default/KeyError if missing;
same as get, but set a persistent default value
               </td></tr><tr><td>
m.popitem()
               </td><td>
Get and remove some item, used during iteration over the map.
Example:

<div class="codesection"><pre class="displaycode">m = {1:1, 2:2, 3:3}
while len(m) &gt; 0:
     i = m.popitem()
     print i</pre></div></td></tr></tbody></table><h3 id="pappbifunc">Appendix E: Built-in functions</h3><p>
Jython provides very useful built-in functions that can be used 
without any imports.
The most commonly used ones are summarized below:
           </p><table border="1" class="ibm-data-table" summary="table is about built-in functions"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>
Syntax
               </th><th>
Use/Comment(s)
               </th><th>
Example(s)
               </th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td>
abs(x)
               </td><td>
Absolute value
               </td><td>
abs(-1) --&gt; 1
               </td></tr><tr><td>
apply(func, pargs {, kargs})
<br/>
-- or --
<br/>
func(*pargs {, **kargs})
               </td><td>
Execute the function with the supplied positional arguments and 
optional keyword arguments
               </td><td>
apply(lambda x, y: x * y, (10, 20)) --&gt; 200
               </td></tr><tr><td>
callable(x)
               </td><td>
Tests to see if the object is callable (i.e, is a function, class or 
implements __call__)
               </td><td>
callable(MyClass) --&gt; 1
               </td></tr><tr><td>
chr(x)
               </td><td>
Converts the integer (0 - 65535) to a 1-character string
               </td><td>
chr(9) --&gt; "\t"
               </td></tr><tr><td>
cmp(x, y)
               </td><td>
Compares x to y: returns:
negative if x &lt; y; 0 if x == y;
positive if x &gt; y
               </td><td>
cmp("Hello", "Goodbye") --&gt; &gt; 0
               </td></tr><tr><td>
coerce(x, y)
               </td><td>
Returns the tuple of x and y coerced to a common type
               </td><td>
coerce(-1, 10.2) --&gt; (-1.0, 10.2)
               </td></tr><tr><td>
compile(text, name, kind)
               </td><td>
Compile the text string from the source name.
Kind is: "exec", "eval" or "single"
               </td><td><div class="codesection"><pre class="displaycode">x = 2
c = compile("x * 2",
             "&lt;string&gt;", "eval")
eval(c) --&gt; 4</pre></div></td></tr><tr><td>
complex(r, i)
               </td><td>
Create a complex number
               </td><td>
complex(1, 2) --&gt; 1.0+2.0j
<br/>
complex("1.0-0.1j") --&gt; 1.0-0.1j
               </td></tr><tr><td>
dir({namespace})
               </td><td>
Returns a list of the keys in a namespace (local if omitted)
               </td><td>
dir() --&gt; [n1, ..., nN]
               </td></tr><tr><td>
vars({namespace})
               </td><td>
Returns the namespace (local if omitted);
do not change it
               </td><td>
vars() --&gt; {n1:v1, ..., nN:vN}
               </td></tr><tr><td>
divmod(x, y)
               </td><td>
Returns the tuple (x /y, x % y)
               </td><td>
divmod(100, 33) --&gt; (3, 1)
               </td></tr><tr><td>
eval(expr {, globals {, locals}})
               </td><td>
Evaluate the expression in the supplied namespaces
               </td><td><div class="codesection"><pre class="displaycode">myvalues = {'x':1, 'y':2}
eval("x + y", myvalues) --&gt; 3</pre></div></td></tr><tr><td>
execfile(name {,globals {, locals}})
               </td><td>
Read and execute the named file in the supplied namespaces
               </td><td>
execfile("myfile.py")
               </td></tr><tr><td>
filter(func, list)
               </td><td>
Creates a list of items for which func returns true
               </td><td>
filter(lambda x: x &gt; 0, [-1, 0, 1, -5, 10])  --&gt; [1, 10]
               </td></tr><tr><td>
float(x)
               </td><td>
Converts x to a float
               </td><td>
float(10) --&gt; 10.0
<br/>
float("10.3") --&gt; 10.3
               </td></tr><tr><td>
getattr(object, name {, default})
               </td><td>
Gets the value of the object's attribute;
if not defined return default (or an exception if no default)
               </td><td>
getattr(myObj, "size", 0)  --&gt; 0
               </td></tr><tr><td>
setattr(object, name, value)
               </td><td>
Creates/sets the value of the object's attribute
               </td><td>
setattr(myObj, "size", 10)
               </td></tr><tr><td>
hasattr(object, name)
               </td><td>
Test to see if the object has an attribute
               </td><td>
hasattr(myObj, "size") --&gt; 0
               </td></tr><tr><td>
globals()
               </td><td>
Returns the current global namespace dictionary
               </td><td>
{n1:v1, ..., nN:vN}
               </td></tr><tr><td>
locals()
               </td><td>
Returns the current local namespace dictionary
               </td><td>
{n1:v1, ..., nN:vN}
               </td></tr><tr><td>
hash(object)
               </td><td>
Returns the object's hash value.
Similar to <code>java.lang.Object.hashCode()</code></td><td>
hash(x) --&gt; 10030939
               </td></tr><tr><td>
hex(x)
               </td><td>
Returns a hex string of x
               </td><td>
hex(-2) --&gt; "FFFFFFFE"
               </td></tr><tr><td>
id(object)
               </td><td>
Returns a unique stable integer id for the object
               </td><td>
id(myObj) --&gt; 39839888
               </td></tr><tr><td>
input(prompt)
               </td><td>
Prompts and evaluates the supplied input expression;
equivalent to <code>eval(raw_input(prompt))</code></td><td>
input("Enter expression:")
<br/>
with "1 + 2" --&gt; 3
               </td></tr><tr><td>
raw_input(prompt)
               </td><td>
Prompts for and inputs a string
               </td><td>
raw_input("Enter value:")
<br/>
with "1 + 2" --&gt; "1 + 2"
               </td></tr><tr><td>
int(x{, radix})
               </td><td>
Converts to an integer; radix: 0,
2..36; 0 implies guess
               </td><td>
int(10.2) --&gt; 10
<br/>
int("10") --&gt; 10
<br/>
int("1ff", 16) --&gt; 511
               </td></tr><tr><td>
isinstance(object, class)
               </td><td>
Tests to see if object is an instance of class or a subclass of class;
class may be a tuple of classes to test multiple types
               </td><td>
isinstance(myObj, MyObject) --&gt; 0
<br/>
isinstance(x, (Class1, Class2)) --&gt; 1
               </td></tr><tr><td>
issubclass(xclass, clsss)
               </td><td>
Tests to see if xclass is a sub-(or same) class of class;
class may be a tuple of classes to test multiple types
               </td><td>
issubclass(MyObject, (Class1, Class2)) --&gt; 0
               </td></tr><tr><td>
len(x)
               </td><td>
Returns the length (number of items) in the sequence or map
               </td><td>
len("Hello") --&gt; 5
               </td></tr><tr><td>
list(seq)
               </td><td>
Converts the sequence into a list
               </td><td>
list((1, 2, 3)) --&gt; [1,2,3]
<br/>
list("Hello") --&gt; ['H','e','l','l','o']
               </td></tr><tr><td>
tuple(seq)
               </td><td>
Converts the sequence into a tuple
               </td><td>
tuple((1, 2, 3)) --&gt; (1,2,3)
tuple("Hello")--&gt; ('H','e','l','l','o')
               </td></tr><tr><td>
long(x {, radix})
               </td><td>
Converts to a long integer;
radix: 0, 2..36; 0 implies guess
               </td><td>
long(10) --&gt; 10L
<br/>
long("10000000000") --&gt;
<br/>
10000000000L
               </td></tr><tr><td>
map(func, list, ...)
               </td><td>
Creates a new list from the results of applying func to each element 
of each list
               </td><td>
map(lambda x,y: x+y, [1,2],[3,4]) --&gt; [4,6]
<br/>
map(None, [1,2],[3,4]) --&gt; [[1,3],[2,4]]
               </td></tr><tr><td>
max(x)
               </td><td>
Returns the maximum value
               </td><td>
max(1,2,3) --&gt; 3
<br/>
max([1,2,3]) --&gt; 3
               </td></tr><tr><td>
min(x)
               </td><td>
Returns the minimum value
               </td><td>
min(1,2,3) --&gt; 1
<br/>
min([1,2,3]) --&gt; 1
               </td></tr><tr><td>
oct(x)
               </td><td>
Converts to an octal string
               </td><td>
oct(10) --&gt; "012
<br/>
oct(-1) --&gt; "037777777777"
               </td></tr><tr><td>
open(name, mode {, bufsize})
               </td><td>
Returns an open file. Mode is:(r|w|a){+}{b}
               </td><td>
open("useful.dat", "wb", 2048)
               </td></tr><tr><td>
ord(x)
               </td><td>
Returns the integer value of the character
               </td><td>
ord('\t') --&gt; 9
               </td></tr><tr><td>
pow(x,y)
<br/>
pow(x,y,z)
               </td><td>
Computes x ** y
<br/>
Computes x ** y % z
               </td><td>
pow(2,3) --&gt; 8
               </td></tr><tr><td>
range({start,} stop {, inc})
<br/>
xrange({start,} stop {, inc})
               </td><td>
Returns a sequence ranging from start to stop in steps of inc;
start defaults to 0; inc defaults to 1.
Use xrange for large sequences (say more than 20 items)
               </td><td>
range(10) --&gt; [0,1,2,3,4,5,6,7,8,9]
<br/>
range(9,-1,-1) --&gt; [9,8,7,6,5,4,3,2,1,0]
               </td></tr><tr><td>
reduce(func, list {, init})
               </td><td>
Applies func to each pair of items in turn accumulating a result
               </td><td>
reduce(lambda x,y:x+y, [1,2,3,4],5) --&gt; 15
<br/>
reduce(lambda x,y:x&amp;y, [1,0,1]) --&gt; 0
<br/>
reduce(None, [], 1) --&gt; 1
               </td></tr><tr><td>
repr(object)
<br/>
-- or --
<br/>
`object`
               </td><td>
Convert to a string from which it can be recreated, if possible
               </td><td>
repr(10 * 2) --&gt; "20"
<br/>
repr('xxx') --&gt; "'xxx'"
<br/>
x = 10; `x` --&gt; "10'"
               </td></tr><tr><td>
round(x {, digits})
               </td><td>
Rounds the number
               </td><td>
round(10.009, 2) --&gt; 10.01
<br/>
round(1.5) --&gt; 2
               </td></tr><tr><td>
str(object)
               </td><td>
Converts to human-friendly string
               </td><td>
str(10 * 2) --&gt; "20"
<br/>
str('xxx') --&gt; 'xxx'
               </td></tr><tr><td>
type(object)
               </td><td>
Returns the type (not the same as class) of the object.
To get the class use <code>object.__class__</code>.
Module <em>types</em> has symbolic names for all Jython types
               </td><td>
x = "1"; type(x) is type('') --&gt; 1
               </td></tr><tr><td>
zip(seq, ...)
               </td><td>
Zips sequences together;
results is only as long as the shortest input sequence
               </td><td>
zip([1,2,3],"abc") --&gt; [(1,'a'),(2,'b'),(3,'c')]
               </td></tr></tbody></table><p>

                    See the Python Library Reference (<a href="#resources">Resources</a>) for more details.
         </p><h3 id="papplibsum">Appendix F: Jython library summary</h3><p>
Jython supports a large number of Python libraries.
By using only these libraries it is possible to write Jython programs 
that will work in any
Python environment.
Many of these libraries provide similar function to those provided by 
the Java APIs.
Jython also has access to all Java libraries.
This means it can do anything a Java program can do but then it is no longer
possible to run the program in a Python environment.
           </p><p>
Most libraries that are written in Python and do not depend on 
operating system specific
services are supported without change.
Many of these libraries are shipped with Jtyhon.
Libraries written in C must be converted;
many of the core C libraries have been converted and are shipped with Jython.
           </p><p>
Jython also has a few unique libraries of its own.
These libraries supplement the extensive API libraries provided by Java itself.
For more details on these libraries, read the source files
(in &lt;jython_install_dir&gt;/Lib/&lt;lib_name&gt;.py) or see the 


                    Python Library Reference (<a href="#resources">Resources</a>).
           </p><p>
Some of the more interesting external libraries supplied with Jython include:
           </p><table border="1" class="ibm-data-table" summary="table is about external libraries"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>
Library
               </th><th>
Comment (often from the library prolog)
               </th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td>
atexit
               </td><td>
Allows a programmer to define multiple exit functions to be executed 
upon normal program termination
               </td></tr><tr><td>
base64
               </td><td>
Conversions to/from base64 transport encoding as per RFC-1521
               </td></tr><tr><td>
BaseHTTPServer
               </td><td>
HTTP server base class (abstract)
               </td></tr><tr><td>
bdb
               </td><td>
Generic Python debugger base class
               </td></tr><tr><td>
bisect
               </td><td>
Some Bisection algorithms
               </td></tr><tr><td>
calendar
               </td><td>
Calendar printing functions (in English)
               </td></tr><tr><td>
cgi
               </td><td>
Support module for CGI (Common Gateway Interface) scripts
               </td></tr><tr><td>
CGIHTTPServer
               </td><td>
CGI-savvy SimpleHTTPServer
               </td></tr><tr><td>
cmd
               </td><td>
A generic class to build line-oriented command interpreters
               </td></tr><tr><td>
code
               </td><td>
Utilities needed to emulate Python's interactive interpreter
               </td></tr><tr><td>
codecs
               </td><td>
Python Codec Registry, API and helpers (abstract)
               </td></tr><tr><td>
colorsys
               </td><td>
Conversion functions between RGB and other color systems
               </td></tr><tr><td>
ConfigParser
               </td><td>
Configuration file parser
               </td></tr><tr><td>
Cookie
               </td><td>
Cookie is a module for the handling of HTTP cookies as a dictionary
               </td></tr><tr><td>
copy
               </td><td>
Generic (shallow and deep) copying operations
               </td></tr><tr><td>
difflib
               </td><td>
Utilities for computing deltas between objects
               </td></tr><tr><td>
dircache
               </td><td>
Read and cache directory listings
               </td></tr><tr><td>
doctest
               </td><td>
A framework for running examples in document strings (sort of like 
JUnit); I recommend unittest below
               </td></tr><tr><td>
dumbdbm
               </td><td>
A dumb and slow but simple dbm clone
               </td></tr><tr><td>
fileinput
               </td><td>
Class to quickly write a loop over all standard input files
               </td></tr><tr><td>
fnmatch
               </td><td>
Filename matching with shell patterns
               </td></tr><tr><td>
formatter
               </td><td>
Generic output formatting framework (abstract)
               </td></tr><tr><td>
fpformat
               </td><td>
General floating point formatting functions
               </td></tr><tr><td>
ftplib
               </td><td>
An FTP client class and some helper functions
               </td></tr><tr><td>
getopt
               </td><td>
Parser for command line options (UNIX style)
               </td></tr><tr><td>
glob
               </td><td>
Filename globbing (a list of paths matching a pathname pattern) utility
               </td></tr><tr><td>
gopherlib
               </td><td>
Gopher protocol client interface
               </td></tr><tr><td>
gzip
               </td><td>
Functions that read and write gzipped files
               </td></tr><tr><td>
htmlentitydefs
               </td><td>
HTML character entity references
               </td></tr><tr><td>
httplib
               </td><td>
HTTP/1.1 client library
               </td></tr><tr><td>
imaplib
               </td><td>
IMAP4 client
               </td></tr><tr><td>
imghdr
               </td><td>
Recognize selected image file formats based on their first few bytes
               </td></tr><tr><td>
isql
               </td><td>
Provides an interactive environment for database work
               </td></tr><tr><td>
linecache
               </td><td>
Cache lines from files
               </td></tr><tr><td>
mailcap
               </td><td>
Mailcap file handling.  See RFC 1524
               </td></tr><tr><td>
mimetools
               </td><td>
Various tools used by MIME-reading or MIME-writing programs
               </td></tr><tr><td>
mimetypes
               </td><td>
Guess the MIME type of a file
               </td></tr><tr><td>
MimeWriter
               </td><td>
Generic MIME writer
               </td></tr><tr><td>
mimify
               </td><td>
Mimification and unmimification of mail messages
               </td></tr><tr><td>
multifile
               </td><td>
A readline()-style interface to the parts of a multipart message
               </td></tr><tr><td>
nntplib
               </td><td>
An NNTP client class based on RFC 977: Network News Transfer Protocol
               </td></tr><tr><td>
nturl2path
               </td><td>
Convert a NT pathname to a file URL and vice versa
               </td></tr><tr><td>
pdb
               </td><td>
A Python debugger
               </td></tr><tr><td>
pickle
               </td><td>
Create portable serialized representations of Jython (not Java) objects
               </td></tr><tr><td>
pipes
               </td><td>
Conversion pipeline templates
               </td></tr><tr><td>
poplib
               </td><td>
A POP3 client class
               </td></tr><tr><td>
posixfile
               </td><td>
Extended file operations available in POSIX
               </td></tr><tr><td>
pprint
               </td><td>
Support to pretty-print lists, tuples, &amp; dictionaries recursively
               </td></tr><tr><td>
profile
               </td><td>
Class for profiling python code
               </td></tr><tr><td>
pstats
               </td><td>
Class for printing reports on profiled python code
               </td></tr><tr><td>
pyclbr
               </td><td>
Parse a Python file and retrieve classes and methods
               </td></tr><tr><td>
Queue
               </td><td>
A multi-producer, multi-consumer queue
               </td></tr><tr><td>
quopri
               </td><td>
Conversions to/from quoted-printable transport encoding as per RFC-1521
               </td></tr><tr><td>
random
               </td><td>
Random variable generators
               </td></tr><tr><td>
re
               </td><td>
Regular Expression Engine (clone of sre)
               </td></tr><tr><td>
repr
               </td><td>
Redo the '...' (representation) but with limits on most sizes
               </td></tr><tr><td>
rfc822
               </td><td>
RFC-822 message manipulation class
               </td></tr><tr><td>
sched
               </td><td>
A generally useful event scheduler class
               </td></tr><tr><td>
sgmllib
               </td><td>
A SAX-like parser for SGML (subset as used by HTML), using the 
derived class as a static DTD (abstract)
               </td></tr><tr><td>
shelve
               </td><td>
Manage shelves (persistent, dictionary) of pickled objects
               </td></tr><tr><td>
shutil
               </td><td>
Utility functions for copying files and directory trees
               </td></tr><tr><td>
SimpleHTTPServer
               </td><td>
A Simple HTTP Server (text HEAD and GET only)
               </td></tr><tr><td>
smtplib
               </td><td>
SMTP/ESMTP client class that follows RFC-821 (SMTP) and RFC-1869 (ESMTP)
               </td></tr><tr><td>
sndhdr
               </td><td>
Routines to help recognizing select sound files
               </td></tr><tr><td>
socket
               </td><td>
Basic socket support
               </td></tr><tr><td>
SocketServer
               </td><td>
Generic socket server classes
               </td></tr><tr><td>
sre
               </td><td>
Regular Expression Engine
               </td></tr><tr><td>
stat
               </td><td>
Constants/functions for interpreting results of os.stat() and os.lstat()
               </td></tr><tr><td>
string
               </td><td>
Common string manipulations; a (very useful) collection of string operations.
The string type also supports most of these functions as methods.
               </td></tr><tr><td>
StringIO
               </td><td>
File-like object that reads from or writes to a string buffer
               </td></tr><tr><td>
telnetlib
               </td><td>
TELNET client class based on RFC-854
               </td></tr><tr><td>
tempfile
               </td><td>
Temporary files and filenames
               </td></tr><tr><td>
threading
               </td><td>
New threading module, emulating a subset of the Java platform's threading model
               </td></tr><tr><td>
tokenize
               </td><td>
Tokenization help for Python programs
               </td></tr><tr><td>
traceback
               </td><td>
Extract, format and print information about Python stack traces
               </td></tr><tr><td>
unittest
               </td><td>
Python unit testing framework, based on Erich Gamma's JUnit and Kent 
Beck's Smalltalk testing framework
               </td></tr><tr><td>
urllib
               </td><td>
Open an arbitrary URL
               </td></tr><tr><td>
urlparse
               </td><td>
Parse (absolute and relative) URLs
               </td></tr><tr><td>
user
               </td><td>
Hook to allow user-specified customization code to run at start-up
               </td></tr><tr><td>
UserDict
               </td><td>
A more or less complete user-defined wrapper around dictionary objects
               </td></tr><tr><td>
UserList
               </td><td>
A more or less complete user-defined wrapper around list objects
               </td></tr><tr><td>
UserString
               </td><td>
A user-defined wrapper around string objects
               </td></tr><tr><td>
whrandom
               </td><td>
Wichman-Hill random number generator
               </td></tr><tr><td>
xmllib
               </td><td>
A SA-like parser for XML, using the derived class as static DTD (abstract)
               </td></tr><tr><td>
zipfile
               </td><td>
Read and write ZIP files
               </td></tr><tr><td>
__future__
               </td><td>
Used to access features from future versions that are available 
(potentially in less than finished form) today
               </td></tr></tbody></table><p><strong>Note:</strong> I do not claim the above library modules work or are 
error free on Jython,
especially when you are not running on a UNIX system.
Try them interactively before you decide to code to them.
           </p><h3 id="papptypes">Appendix G: Jython types summary</h3><p>
Jython supports many object types.  
The module <em>types</em> defines symbols for these types.
The function <em>type</em> gets the type of any object. 


                    The type value can be tested (see <a href="#pdyntype">Dynamic type testing</a>).  
The table below summarizes the most often used types.
</p><table border="1" class="ibm-data-table" summary="table is about dynamic type testing"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>Type symbol</th><th>Jython runtime type</th><th>Comment(s)</th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td>ArrayType</td><td>PyArray</td><td>Any array object</td></tr><tr><td>BuiltinFunctionType</td><td>PyReflectedFunction</td><td>Any built-in function object</td></tr><tr><td>BuiltinMethodType</td><td>PyMethod</td><td>Any built-in method object</td></tr><tr><td>ClassType</td><td>PyClass</td><td>Any Jython class object</td></tr><tr><td>ComplexType</td><td>PyComplex</td><td>Any complex object</td></tr><tr><td>
DictType
<br/>
-- or --
<br/>
DictionaryType
</td><td>PyDictionary</td><td>Any dictionary object</td></tr><tr><td>FileType</td><td>PyFile</td><td>Any file object</td></tr><tr><td>FloatType</td><td>PyFloat</td><td>Any float object</td></tr><tr><td>FunctionType</td><td>PyFunction</td><td>Any function object</td></tr><tr><td>InstanceType</td><td>PyInstance</td><td>Any class instance object</td></tr><tr><td>-- none --</td><td>PyJavaInstance</td><td>Any Java class instance object</td></tr><tr><td>IntType</td><td>PyInteger</td><td>Any integer object</td></tr><tr><td>LambdaType</td><td>PyFunction</td><td>Any lambda function expression object</td></tr><tr><td>ListType</td><td>PyList</td><td>Any list object</td></tr><tr><td>LongType</td><td>PyLong</td><td>Any long object</td></tr><tr><td>MethodType</td><td>PyMethod</td><td>Any non-built-in method object</td></tr><tr><td>ModuleType</td><td>PyModule</td><td>Any module object</td></tr><tr><td>NoneType</td><td>PyNone</td><td>Any <code>None</code> (only one) object</td></tr><tr><td>StringType</td><td>PyString</td><td>Any ASCII string object</td></tr><tr><td>TracebackType</td><td>PyTraceback</td><td>Any exception traceback object</td></tr><tr><td>TupleType</td><td>PyTuple</td><td>Any tuple object</td></tr><tr><td>TypeType</td><td>PyJavaClass</td><td>Any <em>type</em> object</td></tr><tr><td>UnboundMethodType</td><td>PyMethod</td><td>Any method (without a bound instancee) object</td></tr><tr><td>UnicodeType</td><td>PyString</td><td>Any Unicode string object</td></tr><tr><td>XRangeType</td><td>PyXRange</td><td>Any extended range object</td></tr></tbody></table><p><strong>Note:</strong> several types map to the same Java runtime type.</p><p>For more information on types see the Python Library Reference (<a href="#resources">Resources</a>).</p><h3 id="pformsup">Appendix H: Format codes</h3><p>

                    The format operator (see <a href="#pfmtstrval">Formatting strings and values</a> supports the following format characters:
          </p><table border="1" class="ibm-data-table" summary="table is about format codes"><thead xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><th>
Character(s)
              </th><th>
Result Format
              </th><th>
Comment(s)
              </th></tr></thead><tbody xmlns:dw="http://www.ibm.com/developerWorks/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><tr><td>
%s, %r
              </td><td>
String
              </td><td>
%s does <code>str(x)</code>, %r does <code>repr(x)</code></td></tr><tr><td>
%i, %d
              </td><td>
Integer Decimal
              </td><td>
Basically the same format
              </td></tr><tr><td>
%o, %u, %x, %X
              </td><td>
Unsigned Value
              </td><td>
In octal, unsigned decimal, hexadecimal
              </td></tr><tr><td>
%f, %F
              </td><td>
Floating Decimal
              </td><td>
Shows fraction after decimal point
              </td></tr><tr><td>
%e, %E, %g, %G
              </td><td>
Exponential
              </td><td>
%g is %f unless the value is small; else %e
              </td></tr><tr><td>
%c
              </td><td>
Character
              </td><td>
Must be a single character or integer
              </td></tr><tr><td>
%%
              </td><td>
Character
              </td><td>
The % character
              </td></tr></tbody></table><p><strong>Note:</strong> more details on the structure and options of the format


                    item can be found in the Python Library Reference (<a href="#resources">Resources</a>). Use of case in format characters (for example,
<em>X</em> vs <em>x</em> causes the symbol to show in matching case.
          </p>
<p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-content" class="ibm-anchor-up-link">Back to top</a></p><h2 id="download">Download</h2>

</div>
</div></body></html>