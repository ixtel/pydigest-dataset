<html><body><div><div class="section" id="interactive-oo-usage">

<p>All <code class="xref py py-obj docutils literal"><span class="pre">Artists</span></code> now keep track of if their internal state has been
changed but not reflected in the display (‘stale’) by a call to
<code class="docutils literal"><span class="pre">draw</span></code>.  It is thus possible to pragmatically determine if a given
<code class="xref py py-obj docutils literal"><span class="pre">Figure</span></code> needs to be re-drawn in an interactive session.</p>
<p>To facilitate interactive usage a <code class="docutils literal"><span class="pre">draw_all</span></code> method has been added
to <code class="docutils literal"><span class="pre">pyplot</span></code> which will redraw all of the figures which are ‘stale’.</p>
<p>To make this convenient for interactive use matplotlib now registers
a function either with IPython’s ‘post_execute’ event or with the
displayhook in the standard python REPL to automatically call
<code class="docutils literal"><span class="pre">plt.draw_all</span></code> just before control is returned to the REPL.  This ensures
that the draw command is deferred and only called once.</p>
<p>The upshot of this is that for interactive backends (including
<code class="docutils literal"><span class="pre">%matplotlib</span> <span class="pre">notebook</span></code>) in interactive mode (with <code class="docutils literal"><span class="pre">plt.ion()</span></code>)</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="gp">In [2]: </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

<span class="gp">In [3]: </span><span class="n">ln</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>

<span class="gp">In [4]: </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="gp">In [5]: </span><span class="n">ln</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">'g'</span><span class="p">)</span>
</pre></div>
</div>
<p>will automatically update the plot to be green.  Any subsequent
modifications to the <code class="docutils literal"><span class="pre">Artist</span></code> objects will do likewise.</p>
<p>This is the first step of a larger consolidation and simplification of
the pyplot internals.</p>
</div>
<div class="section" id="working-with-labeled-data-like-pandas-dataframes">

<p>Plot methods which take arrays as inputs can now also work with labeled data
and unpack such data.</p>
<p>This means that the following two examples produce the same plot:</p>
<p>Example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"var1"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="s2">"var2"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]})</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">"var1"</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s2">"var2"</span><span class="p">])</span>
</pre></div>
</div>
<p>Example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s2">"var1"</span><span class="p">,</span> <span class="s2">"var2"</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
<p>This works for most plotting methods, which expect arrays/sequences as
inputs.  <code class="docutils literal"><span class="pre">data</span></code> can be anything which supports <code class="docutils literal"><span class="pre">__getitem__</span></code>
(<code class="docutils literal"><span class="pre">dict</span></code>, <code class="docutils literal"><span class="pre">pandas.DataFrame</span></code>, <code class="docutils literal"><span class="pre">h5py</span></code>, ...) to access <code class="docutils literal"><span class="pre">array</span></code> like
values with string keys.</p>
<p>In addition to this, some other changes were made, which makes working with
labeled data (ex <code class="docutils literal"><span class="pre">pandas.Series</span></code>) easier:</p>
<ul class="simple">
<li>For plotting methods with <code class="docutils literal"><span class="pre">label</span></code> keyword argument, one of the
data inputs is designated as the label source.  If the user does not
supply a <code class="docutils literal"><span class="pre">label</span></code> that value object will be introspected for a
label, currently by looking for a <code class="docutils literal"><span class="pre">name</span></code> attribute.  If the value
object does not have a <code class="docutils literal"><span class="pre">name</span></code> attribute but was specified by as a
key into the <code class="docutils literal"><span class="pre">data</span></code> kwarg, then the key is used.  In the above
examples, this results in an implicit <code class="docutils literal"><span class="pre">label="var2"</span></code> for both
cases.</li>
<li><code class="docutils literal"><span class="pre">plot()</span></code> now uses the index of a <code class="docutils literal"><span class="pre">Series</span></code> instead of
<code class="docutils literal"><span class="pre">np.arange(len(y))</span></code>, if no <code class="docutils literal"><span class="pre">x</span></code> argument is supplied.</li>
</ul>
</div>
<div class="section" id="added-axes-prop-cycle-key-to-rcparams">

<p>This is a more generic form of the now-deprecated <code class="docutils literal"><span class="pre">axes.color_cycle</span></code> param.
Now, we can cycle more than just colors, but also linestyles, hatches,
and just about any other artist property. Cycler notation is used for
defining property cycles. Adding cyclers together will be like you are
<code class="xref py py-obj docutils literal"><span class="pre">zip()</span></code>-ing together two or more property cycles together:</p>
<div class="highlight-python"><div class="highlight"><pre>axes.prop_cycle: cycler('color', 'rgb') + cycler('lw', [1, 2, 3])
</pre></div>
</div>
<p>You can even multiply cyclers, which is like using <code class="xref py py-obj docutils literal"><span class="pre">itertools.product()</span></code>
on two or more property cycles. Remember to use parentheses if writing
a multi-line <code class="xref py py-obj docutils literal"><span class="pre">prop_cycle</span></code> parameter.</p>
<p>(<a class="reference external" href="../mpl_examples/color/color_cycle_demo.py">Source code</a>, <a class="reference external" href="../mpl_examples/color/color_cycle_demo.png">png</a>, <a class="reference external" href="../mpl_examples/color/color_cycle_demo.hires.png">hires.png</a>, <a class="reference external" href="../mpl_examples/color/color_cycle_demo.pdf">pdf</a>)</p>

</div>
<div class="section" id="new-plotting-features">

<div class="section" id="auto-wrapping-text">
<h4>Auto-wrapping Text<a class="headerlink" href="#auto-wrapping-text" title="Permalink to this headline">¶</a></h4>
<p>Added the keyword argument “wrap” to Text, which automatically breaks
long lines of text when being drawn.  Works for any rotated text,
different modes of alignment, and for text that are either labels or
titles.  This breaks at the <code class="docutils literal"><span class="pre">Figure</span></code>, not <code class="docutils literal"><span class="pre">Axes</span></code> edge.</p>
<p>(<a class="reference external" href="../users/whats_new-2.py">Source code</a>, <a class="reference external" href="../users/whats_new-2.png">png</a>, <a class="reference external" href="../users/whats_new-2.hires.png">hires.png</a>, <a class="reference external" href="../users/whats_new-2.pdf">pdf</a>)</p>

</div>
<div class="section" id="contour-plot-corner-masking">
<h4>Contour plot corner masking<a class="headerlink" href="#contour-plot-corner-masking" title="Permalink to this headline">¶</a></h4>
<p>Ian Thomas rewrote the C++ code that calculates contours to add support for
corner masking.  This is controlled by a new keyword argument
<code class="docutils literal"><span class="pre">corner_mask</span></code> in the functions <a class="reference internal" href="../api/pyplot_api.html#matplotlib.pyplot.contour" title="matplotlib.pyplot.contour"><code class="xref py py-func docutils literal"><span class="pre">contour()</span></code></a> and
<a class="reference internal" href="../api/pyplot_api.html#matplotlib.pyplot.contourf" title="matplotlib.pyplot.contourf"><code class="xref py py-func docutils literal"><span class="pre">contourf()</span></code></a>.  The previous behaviour, which is now
obtained using <code class="docutils literal"><span class="pre">corner_mask=False</span></code>, was for a single masked point to
completely mask out all four quads touching that point.  The new behaviour,
obtained using <code class="docutils literal"><span class="pre">corner_mask=True</span></code>, only masks the corners of those
quads touching the point; any triangular corners comprising three unmasked
points are contoured as usual.  If the <code class="docutils literal"><span class="pre">corner_mask</span></code> keyword argument is not
specified, the default value is taken from rcParams.</p>
<p>(<a class="reference external" href="../mpl_examples/pylab_examples/contour_corner_mask.py">Source code</a>, <a class="reference external" href="../mpl_examples/pylab_examples/contour_corner_mask.png">png</a>, <a class="reference external" href="../mpl_examples/pylab_examples/contour_corner_mask.hires.png">hires.png</a>, <a class="reference external" href="../mpl_examples/pylab_examples/contour_corner_mask.pdf">pdf</a>)</p>

</div>
<div class="section" id="mostly-unified-linestyles-for-line2d-patch-and-collection">
<h4>Mostly unified linestyles for <code class="xref py py-obj docutils literal"><span class="pre">Line2D</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">Patch</span></code> and <code class="xref py py-obj docutils literal"><span class="pre">Collection</span></code><a class="headerlink" href="#mostly-unified-linestyles-for-line2d-patch-and-collection" title="Permalink to this headline">¶</a></h4>
<p>The handling of linestyles for Lines, Patches and Collections has been
unified.  Now they all support defining linestyles with short symbols,
like <code class="xref py py-obj docutils literal"><span class="pre">"--"</span></code>, as well as with full names, like <code class="docutils literal"><span class="pre">"dashed"</span></code>. Also the
definition using a dash pattern (<code class="docutils literal"><span class="pre">(0.,</span> <span class="pre">[3.,</span> <span class="pre">3.])</span></code>) is supported for all
methods using <code class="xref py py-obj docutils literal"><span class="pre">Line2D</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">Patch</span></code> or <code class="docutils literal"><span class="pre">Collection</span></code>.</p>
</div>
<div class="section" id="legend-marker-order">
<h4>Legend marker order<a class="headerlink" href="#legend-marker-order" title="Permalink to this headline">¶</a></h4>
<p>Added ability to place the label before the marker in a legend box with
<code class="docutils literal"><span class="pre">markerfirst</span></code> keyword</p>
</div>
<div class="section" id="support-for-legend-for-polycollection-and-stackplot">
<h4>Support for legend for PolyCollection and stackplot<a class="headerlink" href="#support-for-legend-for-polycollection-and-stackplot" title="Permalink to this headline">¶</a></h4>
<p>Added a <code class="xref py py-obj docutils literal"><span class="pre">legend_handler</span></code> for <a class="reference internal" href="../api/collections_api.html#matplotlib.collections.PolyCollection" title="matplotlib.collections.PolyCollection"><code class="xref py py-class docutils literal"><span class="pre">PolyCollection</span></code></a> as well as a <code class="xref py py-obj docutils literal"><span class="pre">labels</span></code> argument to
<a class="reference internal" href="../api/axes_api.html#matplotlib.axes.Axes.stackplot" title="matplotlib.axes.Axes.stackplot"><code class="xref py py-func docutils literal"><span class="pre">stackplot()</span></code></a>.</p>
</div>
<div class="section" id="support-for-alternate-pivots-in-mplot3d-quiver-plot">
<h4>Support for alternate pivots in mplot3d quiver plot<a class="headerlink" href="#support-for-alternate-pivots-in-mplot3d-quiver-plot" title="Permalink to this headline">¶</a></h4>
<p>Added a <code class="code docutils literal"><span class="pre">pivot</span></code> kwarg to <a class="reference internal" href="../mpl_toolkits/mplot3d/tutorial.html#mpl_toolkits.mplot3d.Axes3D.quiver" title="mpl_toolkits.mplot3d.Axes3D.quiver"><code class="xref py py-func docutils literal"><span class="pre">quiver()</span></code></a>
that controls the pivot point around which the quiver line rotates. This also
determines the placement of the arrow head along the quiver line.</p>
</div>
<div class="section" id="logit-scale">
<h4>Logit Scale<a class="headerlink" href="#logit-scale" title="Permalink to this headline">¶</a></h4>
<p>Added support for the ‘logit’ axis scale, a nonlinear transformation</p>
<img src="../_images/mathmpl/math-6ca9e95465.png" class="center"/><p>for data between 0 and 1 excluded.</p>
</div>
<div class="section" id="add-step-kwargs-to-fill-between">
<h4>Add step kwargs to fill_between<a class="headerlink" href="#add-step-kwargs-to-fill-between" title="Permalink to this headline">¶</a></h4>
<p>Added <code class="docutils literal"><span class="pre">step</span></code> kwarg to <code class="xref py py-obj docutils literal"><span class="pre">Axes.fill_between</span></code> to allow to fill between
lines drawn using the ‘step’ draw style.  The values of <code class="docutils literal"><span class="pre">step</span></code> match
those of the <code class="docutils literal"><span class="pre">where</span></code> kwarg of <code class="xref py py-obj docutils literal"><span class="pre">Axes.step</span></code>.  The asymmetry of of the
kwargs names is not ideal, but <code class="xref py py-obj docutils literal"><span class="pre">Axes.fill_between</span></code> already has a
<code class="docutils literal"><span class="pre">where</span></code> kwarg.</p>
<p>This is particularly useful for plotting pre-binned histograms.</p>
<p>(<a class="reference external" href="../mpl_examples/api/filled_step.py">Source code</a>)</p>


</div>
<div class="section" id="square-plot">
<h4>Square Plot<a class="headerlink" href="#square-plot" title="Permalink to this headline">¶</a></h4>
<p>Implemented square plots feature as a new parameter in the axis
function. When argument ‘square’ is specified, equal scaling is set,
and the limits are set such that <code class="docutils literal"><span class="pre">xmax-xmin</span> <span class="pre">==</span> <span class="pre">ymax-ymin</span></code>.</p>
<p>(<a class="reference external" href="../users/whats_new-3.py">Source code</a>, <a class="reference external" href="../users/whats_new-3.png">png</a>, <a class="reference external" href="../users/whats_new-3.hires.png">hires.png</a>, <a class="reference external" href="../users/whats_new-3.pdf">pdf</a>)</p>

</div>
<div class="section" id="updated-figimage-to-take-optional-resize-parameter">
<h4>Updated figimage to take optional resize parameter<a class="headerlink" href="#updated-figimage-to-take-optional-resize-parameter" title="Permalink to this headline">¶</a></h4>
<p>Added the ability to plot simple 2D-Array using <code class="docutils literal"><span class="pre">plt.figimage(X,</span> <span class="pre">resize=True)</span></code>.
This is useful for plotting simple 2D-Array without the Axes or whitespacing
around the image.</p>
<p>(<a class="reference external" href="../users/whats_new-4.py">Source code</a>, <a class="reference external" href="../users/whats_new-4.png">png</a>, <a class="reference external" href="../users/whats_new-4.hires.png">hires.png</a>, <a class="reference external" href="../users/whats_new-4.pdf">pdf</a>)</p>

</div>
<div class="section" id="updated-figure-savefig-can-now-use-figure-s-dpi">
<h4>Updated Figure.savefig() can now use figure’s dpi<a class="headerlink" href="#updated-figure-savefig-can-now-use-figure-s-dpi" title="Permalink to this headline">¶</a></h4>
<p>Added support to save the figure with the same dpi as the figure on the
screen using <code class="xref py py-obj docutils literal"><span class="pre">dpi='figure'</span></code>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">dpi</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>               <span class="c1"># dpi set to 25</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="n">f</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">'output.png'</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="s1">'figure'</span><span class="p">)</span>    <span class="c1"># output savefig dpi set to 25 (same as figure)</span>
</pre></div>
</div>
</div>
<div class="section" id="updated-table-to-control-edge-visibility">
<h4>Updated Table to control edge visibility<a class="headerlink" href="#updated-table-to-control-edge-visibility" title="Permalink to this headline">¶</a></h4>
<p>Added the ability to toggle the visibility of lines in Tables.
Functionality added to the <code class="xref py py-func docutils literal"><span class="pre">pyplot.table()</span></code> factory function under
the keyword argument “edges”.  Values can be the strings “open”, “closed”,
“horizontal”, “vertical” or combinations of the letters “L”, “R”, “T”,
“B” which represent left, right, top, and bottom respectively.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">table</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="s2">"open"</span><span class="p">)</span>  <span class="c1"># No line visible</span>
<span class="n">table</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="s2">"closed"</span><span class="p">)</span>  <span class="c1"># All lines visible</span>
<span class="n">table</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="s2">"horizontal"</span><span class="p">)</span>  <span class="c1"># Only top and bottom lines visible</span>
<span class="n">table</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="s2">"LT"</span><span class="p">)</span>  <span class="c1"># Only left and top lines visible.</span>
</pre></div>
</div>
</div>
<div class="section" id="zero-r-cstride-support-in-plot-wireframe">
<h4>Zero r/cstride support in plot_wireframe<a class="headerlink" href="#zero-r-cstride-support-in-plot-wireframe" title="Permalink to this headline">¶</a></h4>
<p>Adam Hughes added support to mplot3d’s plot_wireframe to draw only row or
column line plots.</p>
<p>(<a class="reference external" href="../users/whats_new-5.py">Source code</a>, <a class="reference external" href="../users/whats_new-5.png">png</a>, <a class="reference external" href="../users/whats_new-5.hires.png">hires.png</a>, <a class="reference external" href="../users/whats_new-5.pdf">pdf</a>)</p>

</div>
<div class="section" id="plot-bar-and-barh-with-labels">
<h4>Plot bar and barh with labels<a class="headerlink" href="#plot-bar-and-barh-with-labels" title="Permalink to this headline">¶</a></h4>
<p>Added kwarg <code class="docutils literal"><span class="pre">"tick_label"</span></code> to <code class="xref py py-obj docutils literal"><span class="pre">bar</span></code> and <code class="xref py py-obj docutils literal"><span class="pre">barh</span></code> to support plotting bar graphs with a
text label for each bar.</p>
<p>(<a class="reference external" href="../users/whats_new-6.py">Source code</a>, <a class="reference external" href="../users/whats_new-6.png">png</a>, <a class="reference external" href="../users/whats_new-6.hires.png">hires.png</a>, <a class="reference external" href="../users/whats_new-6.pdf">pdf</a>)</p>

</div>
<div class="section" id="added-center-and-frame-kwargs-to-pie">
<h4>Added center and frame kwargs to pie<a class="headerlink" href="#added-center-and-frame-kwargs-to-pie" title="Permalink to this headline">¶</a></h4>
<p>These control where the center of the pie graph are and if
the Axes frame is shown.</p>
</div>
<div class="section" id="fixed-3d-filled-contour-plot-polygon-rendering">
<h4>Fixed 3D filled contour plot polygon rendering<a class="headerlink" href="#fixed-3d-filled-contour-plot-polygon-rendering" title="Permalink to this headline">¶</a></h4>
<p>Certain cases of 3D filled contour plots that produce polygons with multiple
holes produced improper rendering due to a loss of path information between
<a class="reference internal" href="../api/collections_api.html#matplotlib.collections.PolyCollection" title="matplotlib.collections.PolyCollection"><code class="xref py py-class docutils literal"><span class="pre">PolyCollection</span></code></a> and
<a class="reference internal" href="../mpl_toolkits/mplot3d/api.html#mpl_toolkits.mplot3d.art3d.Poly3DCollection" title="mpl_toolkits.mplot3d.art3d.Poly3DCollection"><code class="xref py py-class docutils literal"><span class="pre">Poly3DCollection</span></code></a>.  A function
<a class="reference internal" href="../api/collections_api.html#matplotlib.collections.PolyCollection.set_verts_and_codes" title="matplotlib.collections.PolyCollection.set_verts_and_codes"><code class="xref py py-func docutils literal"><span class="pre">set_verts_and_codes()</span></code></a> was
added to allow path information to be retained for proper rendering.</p>
</div>
<div class="section" id="dense-colorbars-are-rasterized">
<h4>Dense colorbars are rasterized<a class="headerlink" href="#dense-colorbars-are-rasterized" title="Permalink to this headline">¶</a></h4>
<p>Vector file formats (pdf, ps, svg) are efficient for
many types of plot element, but for some they can yield
excessive file size and even rendering artifacts, depending
on the renderer used for screen display.  This is a problem
for colorbars that show a large number of shades, as is
most commonly the case.  Now, if a colorbar is showing
50 or more colors, it will be rasterized in vector
backends.</p>
</div>
<div class="section" id="dateformatter-strftime">
<h4>DateFormatter strftime<a class="headerlink" href="#dateformatter-strftime" title="Permalink to this headline">¶</a></h4>
<p><code class="xref py py-class docutils literal"><span class="pre">strftime</span></code> method will format
a <code class="xref py py-class docutils literal"><span class="pre">datetime.datetime</span></code> object with the format string passed to
the formatter’s constructor. This method accepts datetimes with years
before 1900, unlike <code class="xref py py-meth docutils literal"><span class="pre">datetime.datetime.strftime()</span></code>.</p>
</div>
<div class="section" id="artist-level-get-set-usetex-for-text">
<h4>Artist-level {get,set}_usetex for text<a class="headerlink" href="#artist-level-get-set-usetex-for-text" title="Permalink to this headline">¶</a></h4>
<p>Add <code class="docutils literal"><span class="pre">{get,set}_usetex</span></code> methods to <a class="reference internal" href="../api/text_api.html#matplotlib.text.Text" title="matplotlib.text.Text"><code class="xref py py-class docutils literal"><span class="pre">Text</span></code></a> objects
which allow artist-level control of LaTeX rendering vs the internal mathtex
rendering.</p>
</div>
<div class="section" id="ax-remove-works-as-expected">
<h4><code class="xref py py-obj docutils literal"><span class="pre">ax.remove()</span></code> works as expected<a class="headerlink" href="#ax-remove-works-as-expected" title="Permalink to this headline">¶</a></h4>
<p>As with artists added to an <a class="reference internal" href="../api/axes_api.html#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code class="xref py py-class docutils literal"><span class="pre">Axes</span></code></a>,
<code class="xref py py-obj docutils literal"><span class="pre">Axes</span></code> objects can be removed from their figure via
<a class="reference internal" href="../api/axes_api.html#matplotlib.axes.Axes.remove" title="matplotlib.axes.Axes.remove"><code class="xref py py-meth docutils literal"><span class="pre">remove()</span></code></a>.</p>
</div>
<div class="section" id="api-consistency-fix-within-locators-set-params-function">
<h4>API Consistency fix within Locators set_params() function<a class="headerlink" href="#api-consistency-fix-within-locators-set-params-function" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="../api/ticker_api.html#matplotlib.ticker.Locator.set_params" title="matplotlib.ticker.Locator.set_params"><code class="xref py py-meth docutils literal"><span class="pre">set_params()</span></code></a> function, which sets parameters
within a <a class="reference internal" href="../api/ticker_api.html#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code class="xref py py-class docutils literal"><span class="pre">Locator</span></code></a> type
instance, is now available to all <code class="xref py py-obj docutils literal"><span class="pre">Locator</span></code> types. The implementation
also prevents unsafe usage by strictly defining the parameters that a
user can set.</p>
<p>To use, call <code class="docutils literal"><span class="pre">set_params()</span></code> on a <code class="xref py py-obj docutils literal"><span class="pre">Locator</span></code> instance with desired arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">loc</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">ticker</span><span class="o">.</span><span class="n">LogLocator</span><span class="p">()</span>
<span class="c1"># Set given attributes for loc.</span>
<span class="n">loc</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="n">numticks</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">numdecs</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="p">[</span><span class="mf">2.0</span><span class="p">],</span> <span class="n">base</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="c1"># The below will error, as there is no such parameter for LogLocator</span>
<span class="c1"># named foo</span>
<span class="c1"># loc.set_params(foo='bar')</span>
</pre></div>
</div>
</div>
<div class="section" id="date-locators">
<h4>Date Locators<a class="headerlink" href="#date-locators" title="Permalink to this headline">¶</a></h4>
<p>Date Locators (derived from <a class="reference internal" href="../api/dates_api.html#matplotlib.dates.DateLocator" title="matplotlib.dates.DateLocator"><code class="xref py py-class docutils literal"><span class="pre">DateLocator</span></code></a>) now
implement the <code class="xref py py-meth docutils literal"><span class="pre">tick_values()</span></code> method.
This is expected of all Locators derived from <code class="xref py py-class docutils literal"><span class="pre">Locator</span></code>.</p>
<p>The Date Locators can now be used easily without creating axes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">matplotlib.dates</span> <span class="kn">import</span> <span class="n">YearLocator</span>
<span class="n">t0</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2002</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">tf</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="n">loc</span> <span class="o">=</span> <span class="n">YearLocator</span><span class="p">()</span>
<span class="n">values</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">tf</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="offsetboxes-now-support-clipping">
<h4>OffsetBoxes now support clipping<a class="headerlink" href="#offsetboxes-now-support-clipping" title="Permalink to this headline">¶</a></h4>
<p><code class="xref py py-obj docutils literal"><span class="pre">Artists</span></code> draw onto objects of type <code class="xref py py-class docutils literal"><span class="pre">OffsetBox</span></code>
through <code class="xref py py-class docutils literal"><span class="pre">DrawingArea</span></code> and <code class="xref py py-class docutils literal"><span class="pre">TextArea</span></code>.
The <code class="xref py py-obj docutils literal"><span class="pre">TextArea</span></code> calculates the required space for the text and so the
text is always within the bounds, for this nothing has changed.</p>
<p>However, <code class="xref py py-obj docutils literal"><span class="pre">DrawingArea</span></code> acts as a parent for zero or more <code class="xref py py-obj docutils literal"><span class="pre">Artists</span></code> that
draw on it and may do so beyond the bounds. Now child <code class="xref py py-obj docutils literal"><span class="pre">Artists</span></code> can be
clipped to the bounds of the <code class="xref py py-obj docutils literal"><span class="pre">DrawingArea</span></code>.</p>
</div>
<div class="section" id="offsetboxes-now-considered-by-tight-layout">
<h4>OffsetBoxes now considered by tight_layout<a class="headerlink" href="#offsetboxes-now-considered-by-tight-layout" title="Permalink to this headline">¶</a></h4>
<p>When <a class="reference internal" href="../api/pyplot_api.html#matplotlib.pyplot.tight_layout" title="matplotlib.pyplot.tight_layout"><code class="xref py py-obj docutils literal"><span class="pre">tight_layout()</span></code></a> or <code class="xref py py-obj docutils literal"><span class="pre">Figure.tight_layout()</span></code>
or <code class="xref py py-obj docutils literal"><span class="pre">GridSpec.tight_layout()</span></code> is called, <code class="xref py py-obj docutils literal"><span class="pre">OffsetBoxes</span></code> that are
anchored outside the axes will not get chopped out. The <code class="xref py py-obj docutils literal"><span class="pre">OffsetBoxes</span></code> will
also not get overlapped by other axes in case of multiple subplots.</p>
</div>
<div class="section" id="per-page-pdf-notes-in-multi-page-pdfs-pdfpages">
<h4>Per-page pdf notes in multi-page pdfs (PdfPages)<a class="headerlink" href="#per-page-pdf-notes-in-multi-page-pdfs-pdfpages" title="Permalink to this headline">¶</a></h4>
<p>Add a new method <a class="reference internal" href="../api/backend_pdf_api.html#matplotlib.backends.backend_pdf.PdfPages.attach_note" title="matplotlib.backends.backend_pdf.PdfPages.attach_note"><code class="xref py py-meth docutils literal"><span class="pre">attach_note()</span></code></a>
to the PdfPages class, allowing the
attachment of simple text notes to pages in a multi-page pdf of
figures. The new note is visible in the list of pdf annotations in a
viewer that has this facility (Adobe Reader, OSX Preview, Skim,
etc.). Per default the note itself is kept off-page to prevent it to
appear in print-outs.</p>
<p><code class="xref py py-obj docutils literal"><span class="pre">PdfPages.attach_note</span></code> needs to be called before <code class="xref py py-obj docutils literal"><span class="pre">savefig()</span></code> in order to be
added to the correct figure.</p>
</div>
<div class="section" id="updated-fignum-exists-to-take-figure-name">
<h4>Updated fignum_exists to take figure name<a class="headerlink" href="#updated-fignum-exists-to-take-figure-name" title="Permalink to this headline">¶</a></h4>
<p>Added the ability to check the existence of a figure using its name
instead of just the figure number.
Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">figure</span><span class="p">(</span><span class="s1">'figure'</span><span class="p">)</span>
<span class="n">fignum_exists</span><span class="p">(</span><span class="s1">'figure'</span><span class="p">)</span> <span class="c1">#true</span>
</pre></div>
</div>
</div>
</div>
</div></body></html>