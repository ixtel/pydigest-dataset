<html><body><div><div class="entry-content"><p>I spent a little while digging around in CPython recently, and thought I’d share my adventure here.  It’s a bit of a riff on Allison Kaptur’s </p><a href="http://akaptur.com/blog/2014/08/03/getting-started-with-python-internals/">excellent guide to getting started with Python internals</a><p>—I thought it may be neat to show how my own explorations went, step-by-step, so that perhaps other curious Pythonistas might follow along.</p><a name="cutid1"/><b>1. Notice something weird happening.</b><p>Initially, I was just setting up </p><a href="https://nose.readthedocs.org/en/latest/">Nose</a><p> to run tests on some Python 3 code that I’d written.  When I ran the tests, I got a mysterious "TypeError: bad argument type for built-in operation" message, which I hadn't seen in this program before.</p><p>The </p><i>cause</i><p> of the error ended up being a little obvious—I'd mistakenly left a </p><a href="https://docs.python.org/3.4/library/pdb.html">PDB</a><p> breakpoint (`import pdb; pdb.set_trace()`) in the program.  When I removed that, the tests ran fine.</p><p>But, I've used Nose to run tests on Python 2 repos before, and in those cases, leaving in breakpoints by mistake didn't cause Nose to crash.  Instead, the program would appear to "hang.”  The program wasn't really hanging—it just wasn't displaying stdout (standard output).  Nose does this on purpose, and it makes sense—if I'm running a test suite, I probably just want to see the results of the tests, and not a bunch of print statements from the program itself.  If you hit "c" in this scenario, Nose simply continues past the breakpoint as usual.</p><p>Normally, I might've shrugged, removed the breakpoint, and continued with what I’d been working on.  But!  Since I'm at Hacker School and have time to dig into whatever captures my fancy, I decided I'd use this as an excuse to look at Python internals.</p><b>2. Make the simplest possible test case.</b><p>Turns out this issue was kind of tricky to dig into—I wasn't sure if the problem was in Nose, or in PDB, or in the CPython source itself.  And, of course, I couldn't use any breakpoints, as those would just cause my program to crash.  </p><p>Eventually, after testing some hypotheses, it seemed like the call to `input()` that PDB uses was where things were breaking.  So: did something change in how input itself was implemented between Python 2 and Python 3, or was something else going on?</p><p>I was pair-debugging with </p><a href="https://twitter.com/doyster">Jesse</a><p> when we finally noticed that </p><a href="https://github.com/nose-devs/nose/blob/71b5ee2161289f56318308f070fb9e91fa6017b1/nose/plugins/capture.py#L95-L96">Nose handles standard output in an interesting way</a><p>:</p><blockquote><font face="courier">self._buf = StringIO()<br/>sys.stdout = self._buf</font></blockquote><p>It turns out `sys.stdout` represents all </p><i>standard output</i><p> in Python—that is, anything that is printed to your terminal screen is sent here.  But!  Since we can access sys.stdout just like any other Python variable, we can </p><i>change</i><p> it.  Here, Nose is setting sys.stdout to be StringIO(), which is just an arbitrary string.</p><p>When you do this, the print function no longer works!</p><blockquote><font face="courier">&gt;&gt;&gt; import sys, io<br/>&gt;&gt;&gt; sys.stdout = io.StringIO()<br/>&gt;&gt;&gt; print(“Hello”)<br/>&gt;&gt;&gt; <i># Oh no, nothing printed!</i></font></blockquote><p>We wondered if that line might be the problem, so we set up a simple test case:</p><blockquote><font face="courier">&gt;&gt;&gt; import sys, io<br/>&gt;&gt;&gt; sys.stdout = io.StringIO()<br/>&gt;&gt;&gt; print("Hello!")  # Nothing will appear<br/>&gt;&gt;&gt; input("Input: ")  # Raises a TypeError</font></blockquote><p>Running this in Python 3 gives you the "bad argument for built-in operation" we saw.  So now we know where to look!  </p><b>When you try to change sys.stdout, the builtin function `input()` breaks in some strange way.</b><b>3. Learn you some CPython!</b><p>So, we’d like to look at how `input` is implemented.  Python has a cool module called `inspect` that lets you examine source code like so:</p><blockquote><font face="courier">&gt;&gt;&gt; from collections import namedtuple<br/>&gt;&gt;&gt; import inspect; print(inspect.getsource(namedtuple))<br/>def namedtuple(typename, field_names, verbose=False, rename=False):<br/>      """Returns a new subclass of tuple with named fields.<br/>      .....</font></blockquote><p>If you try calling `inspect.getsource` on `input`, however, the result is “TypeError: </p><built-in function="function" input="input"> is not a module, class, method, function, traceback, frame, or code object.”  This means that our function is not implemented in Python—it’s implemented in C, and thus, the `inspect` module isn’t able to display its source code for us.<br/><br/>...but, with the magic of the <a href="https://github.com/punchagan/cinspect">cinspect</a> module<small><sup>1</sup></small>, we <i>can</i> look at C source code!<blockquote><font face="courier">&gt;&gt;&gt; import cinspect; print(cinspect.getsource(input))<br/>static PyObject *<br/>builtin_input(PyObject *self, PyObject *args)<br/>{<br/>     PyObject *line;<br/>     char *str;<br/>.....</font></blockquote>Awesome.  Now we know that the function we want is called `builtin_input`.  At this point, we’re going to start looking through C code, rather than just Python things, and we’ll be debugging at the terminal rather than at the Python interpreter.  You don’t have to be a C expert to get a general idea of what’s going on—I’m mostly proceeding by making educated guesses based on function names :)<br/><br/>So, let’s grep through the <a href="https://hg.python.org/">CPython source code</a>, and we’ll discover that `builtin_input` is a wrapper around `builtin_input_impl`, which is a method in bltinmodule.c.  Let’s try loading Python into the lldb C debugger and setting a breakpoint at the beginning of that method<small><sup>2</sup></small>:<blockquote><font face="courier">flowerhack$ lldb -- /Users/flowerhack/cpython/python.exe<br/>flowerhack$ breakpoint set --file bltinmodule.c --line 2337</font></blockquote>While stepping through the source code (the process is similar to what you might do in PDB—just keep hitting “n” to continue to the next line), we discover the bit of code where problems first appear:<blockquote><font face="courier">stdout_encoding_str = _PyUnicode_AsString(stdout_encoding);<br/>stdout_errors_str = _PyUnicode_AsString(stdout_errors);<br/>if (!stdout_encoding_str || !stdout_errors_str)<br/>     goto _readline_errors;  // "throws" an exception</font></blockquote>The third line tripped me up: “if the encoding string is null OR if the errors string is null, we have an error.”  But wait, wouldn’t a null errors string imply NO errors were found?<br/><br/>For this, I dug into the definition of _PyUnicode_AsString (another C function):<blockquote><font face="courier">#define _PyUnicode_AsString PyUnicode_AsUTF8</font></blockquote>That’s just a <i>macro</i> which says “hey, when we’re calling _PyUnicode_AsString, call PyUnicode_AsUTF8 instead.”  So, what we <i>really</i> want is the definition of PyUnicode_AsUTF8:<blockquote><font face="courier">char*<br/>PyUnicode_AsUTF8(PyObject *unicode)<br/>{<br/>     return PyUnicode_AsUTF8AndSize(unicode, NULL);<br/>}</font></blockquote>...and it seems all <i>that</i> is doing, is calling PyUnicode_AsUTF8AndSize, <a href="https://hg.python.org/cpython/file/3e3bec66409c/Objects/unicodeobject.c">which is really what we want to read</a>.<br/><br/>There’s several error cases in the PyUnicode_AsUTF8AndSize function, each of which return NULL.  It seems odd to me that we’re returning NULL in the case of an error, instead of an error code like -1.  Maybe there’s some convention here that I’m unfamiliar with?<br/><br/>Anyway, to figure out <i>which</i> error case I was hitting, I did “printf debugging”—I just added a printf statement before each possible error case, and ran the program—and was able to discover that we’re failing something called a PyUnicode_Check.<br/><br/>So, is that check something that wasn’t in Python 2 but now exists in Python 3?  Well, we can compare the source code of the two versions to find out.  And turns out, the Python 2 source makes no such encoding check, while the Python 3 source does—so, if sys.stdout is replaced with something that has the wrong encoding, it’ll fail in 3 but not 2.  Whew!<br/><br/><b>4. Profit!</b><br/><br/>So this might look like a lot of work just to find out the why behind a pretty trivially fixable bug.  And maybe it is, but!  We learned some cool stuff along the way.  I found out a lot about how standard input and output are handled by Python while I was testing hypotheses.  I learned more about reading large, macro-heavy C projects.  I learned that GOTO is still alive and well, which surprised me, but made sense in context—it seems like it’d be tricky to do something like an exception in C without GOTO.  Also, it was really cool to read through the changes between bltinmodule.c’s input functions between Python 2 and 3—seriously, check that out; it’s neat to see how they refactored and cleaned up things.<br/><br/>I also stumbled on some super-interesting trivia about reference counting in Python, but I’m saving that for another post :)<br/><br/>(Also, many thanks to <a href="http://lmontopo.github.io/">Leta</a> who helped me edit a draft of this post!)<br/><br/><small><sup>1</sup> Disclaimer: cinspect is a little tricky to set up.  The instructions in the project's README should work, but note that the "indexing your sources" step takes a <i>long</i> time.<br/><sup>2</sup> If you've used gdb before, then you just need to know that lldb is very similar.  If you've never used either before, they're a bit like PDB, but for debugging C code rather than Python code.</small></built-in></div></div></body></html>