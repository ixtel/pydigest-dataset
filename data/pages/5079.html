<html><body><div><div class="content html_format"><p>
      Хотите заглянуть вовнутрь и узнать, как устроен AllMyChanges.com? Сегодня я немного расскажу вам, как работает наш робот и почему ему удается так хорошо находить информацию о релизах.</p>
<p>
На самом деле, весь наш робот, это просто набор функций.</p><p>
Поиск и обработка ченьджлогов состоит из нескольких этапов:

</p><ol>
<li>надо понять, каким образом получать данные по урлу;</li>
<li>использовать выбранный метод, чтобы скачать данные на диск;</li>
<li>пройтись по скачанным файлам и извлечь из них куски, которые имеют номер версии и описание;</li>
<li>понять, какие куски реально являются частью ченьджлога, а какие – просто мусор;</li>
<li>сложить найденное добро в базу.</li>
</ol><p>
Части 1,2 и 5 вполне себе механические и не требуют от робота особого интеллекта.

</p><h2>Получение данных</h2><p>
В </p><a href="http://habrahabr.ru/company/allmychanges/blog/260275/">предыдущей статье</a><p> я упоминал о том, что AllMyChanges поддерживает несколько различных источников данных. Во-первых, он умеет выкачивать из из Git и Mercurial. Во-вторых — умеет скачивать HTML страницы, как по одной, так и рекурсивно обходя весь сайт. Ну и в-третьих, наш робот может скачивать некоторую информацию из App Store и Google Play.</p><a name="habracut"/>
<p>
На первом этапе, мы, согласно неким эвристическим правилам, определяем, какую функцию вызывать на этапе номер два. Этот выбор, если он был успешен, запоминается в базе, чтобы его не приходилось делать каждый раз.
</p><p>
Во время скачивания, робот либо просто складывает файлы на диск, либо производит дополнительную их обработку. Так, забирая данные через GitHub Releases API, он формирует из них файл в Markdown формате. Примерно то же самое происходит с данными, вынимаемыми из сторов или истории VCS.

</p><h2>Извлечение</h2>
<a href="https://www.flickr.com/photos/chiotsrun/9477342814" title="Harvesting New Potatoes by Susy Morris, on Flickr"><img src="https://habrastorage.org/getpro/habr/post_images/ddf/502/a13/ddf502a1361b7ee2a1c48086e4a61296.jpg" alt="Harvesting New Potatoes"/></a>
<p>
Извлечение данных дело непростое. Особенно, когда дело касается больших репозиториев с кучей файлов. Ведь каждый из них нужно обойти, и если есть подходящий парсер, то распарсить и поискать части, имеющие отношение к релиз-нотам.
</p><p>
На данный момент, сервис поддерживает три основных формата файлов:

</p><ul>
<li>Markdown;</li>
<li>reStructured Text;</li>
<li>HTML.</li>
</ul><p>
Но за счет того, что этапы обработки не зависят друг от друга, можно легко добавлять, как новые функции для скачивания данных, так и расширять список поддерживаемых форматов.
</p><p>
Чтобы роботу было проще, можно его направить в нужное место файловой системы, используя дополнительные настройки. Для этого, при добавлении в сервис нового пакета, можно указать список директорий и файлов где следует искать ченьджлог, или список директорий, которые лучше обходить стороной.
</p><p>
К примеру, вы знаете, что у проекта есть поддиректория с документами, и ченьджлог надо искать там. В таком случае, в поле «search list», вписываем </p><code>docs/</code><p>, и робот будет искать только там. Если же вы не знаете, где точно следует искать, но знаете, что папке </p><code>src/</code><p> ничего про релиз-ноуты точно нет, тогда стоит добавить эту директорию в поле «ignore list».

</p><h2>Постобработка</h2>
<a href="https://www.flickr.com/photos/kouchi/4332028170" title="sorting! by Ernie, on Flickr"><img src="https://habrastorage.org/getpro/habr/post_images/744/c13/0e3/744c130e3145224e803e7dc6c12df55d.jpg" alt="sorting!"/></a>
<p>
Самое интересное начинается, когда получены какие-то кусочки данных, которые могут представлять собой ченьджлог. Тут то и начинается основная магия. Сложность заключается в том, что не всегда можно сказать наверняка,</p><p>
относится ли извлеченный текст к ченьджлогу или нет. Конечно, если у него в метаданных записано, что он извлечен из файла c названием </p><code>ChangeLog.md</code><p>, то это не составит труда. Но к сожалению, так бывает не всегда.
</p><p>
Поэтому, для определения того, является ли номер и описание версии частью ченьджлога, или данных кусок данных был извлечен по ошибке, робот AllMyChanges использует ряд эвристических правил.
</p><p>
Для начала, все извлеченные куски группируются по файлам из которых они были извлечены, потом по директориям и так далее. Для каждой группы производится оценка вероятности того, что она может являться ченьджлогом. Оцениваются имена файлов и директорий, и так же суммарное количество кусков, которые в них содержатся.
</p><p>
Это нужно для того, чтобы корректно обрабатывать релиз-ноуты, разбросанные по разным файлам. Такие, например, как у Django: </p><a href="https://github.com/django/django/tree/master/docs/releases">…tree/master/docs/releases</a>
<p>
Далее, убираются дубликаты, которые могут возникать по самым разным причинам. Наиболее частая причина — сложная структура внутри документа, где одна и та же версия упоминается в заголовках разного уровня.
</p><p>
Так же, на этапе пост-обработки производится вычисление дат релиза, если конечно они указаны в файле. Тут тоже действует определенное эвристическое правило — если у всех версий в файле даты релиза присутствуют, а у одной из версий нет, значит её надо считать ещё не выпущенной в свет. Такая версия помечается, как «Unreleased».
</p><p>
Кстати, о датах. AllMyChanges держит для каждой версии библиотеки две даты: дату релиза и дату обнаружения. Очень часто, в письмах уведомлениях указаны обе эти даты, и они различаются. «Дата релиза», это всегда та дата, которая указана в первоисточнике. Иногда её может не быть, иногда она может быть даже в будущем, тут могут быть любые чудеса. «Дата обнаружения» же, соответствует тому времени, когда наш робот впервые нашел эту версию. Дата обнаружения есть всегда, и если при этом в первоисточнике не указана «дата релиза», то вместо неё будет использована «дата обнаружения».
</p><p>
Для чего нужно две даты? В первой мы фиксируем то, что записано в документе, вторую же используем для того, чтобы знать, нужно ли уведомлять пользователей о выходе новой версии.
</p><p>
Представьте себе такую ситуацию. Русский разработчик некой библиотеки запилил новую версию с красивым номером </p><code>1.2.3</code><p> как раз под новый год. Проставил ей дату релиза </p><code>2015-01-01</code><p> и, так и не запушив на GitHub, отправился баиньки. Проснувшись и протрезвев 7 января, он решает таки сделать </p><code>git push</code><p>.
</p><p>
Что произойдет, когда робот AllMyChanges увидит версию </p><code>1.2.3</code><p> в репозитории? Правильно! Он зафиксирует, что дата релиза у неё </p><code>2015-01-01</code><p>, но в качестве даты обнаружения проставит </p><code>2015-01-07</code><p>. Нужно это для того, чтобы при формировании на следующий день дайжеста, в него попала эта версия </p><code>1.2.3</code><p>. И она должна попасть в дайжест даже несмотря на то, что дата релиза у неё проставлена старая. Таким образом вы получите уведомление о выходе обновления, несмотря ни на что и вопреки всему :)
</p><p>
Всё это позволяет AllMyChanges прекрасно справляться с поиском информации о релизах во всех труднодоступных местах и доставлять её в ваши инбоксы вовремя.

</p><h2>Вопросы?</h2><p>
Если у вас остались вопросы, не стесняйтесь задавать их в зале, или пишите на </p><a href="mailto:support@allmychanges.com">support@allmychanges.com</a><p>. Я с радостью на них отвечу.



      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>