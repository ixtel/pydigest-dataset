<html><body><div><div class="post-body entry-content" id="post-body-8350801890821407272" itemprop="description articleBody">
<p>Выпустил новую версию <a href="http://aiopg.readthedocs.org">aiopg 0.2</a> --
библиотеки для работы с PostgreSQL из
<a href="https://docs.python.org/dev/library/asyncio.html">asyncio</a>.</p>
<p><strong>aiopg</strong> использует <em>асинхронные вызовы</em> и в этом похож на
<em>txpostgres</em> и <em>momoko</em> -- библиотеки для работы с <em>PostgreSQL</em> под
<em>twisted</em> и <em>tornado</em> соответственно.</p>
<p>В новой версии <em>aiopg</em> появилась опциональная поддержка SQLAlchemy Core Expressions.</p>
<p>Проще один раз показать.</p>
<p>Создаем описание структуры базы данных:</p>
<pre><code>import sqlalchemy as sa

metadata = sa.MetaData()

users = sa.Table('users', metadata,
                 sa.Column('id', sa.Integer, primary_key=True),
                 sa.Column('name', sa.String(255)),
                 sa.Column('birthday', sa.DateTime))

emails = sa.Table('emails', metadata,
                  sa.Column('id', sa.Integer, primary_key=True),
                  sa.Column('user_id', None, sa.ForeignKey('users.id')),
                  sa.Column('email', sa.String(255), nullable=False),
                  sa.Column('private', sa.Boolean, nullable=False))
</code></pre>
<p>Как видите -- две таблицы, связанные отношением один-ко-многим. Для
тех, кто не знаком -- алхимия позволяет описать любую модель данных,
которая только может прийти в голову. Индексы, constraints,
пользовательские типы данных такие как array и hstore -- тоже.</p>
<p>Теперь нужно сделать <em>engine</em>:</p>
<pre><code>from aiopg.sa import create_engine

engine = yield from create_engine(user='aiopg',
                                  database='aiopg',
                                  host='127.0.0.1',
                                  password='passwd')
</code></pre>
<p><em>engine</em> содержит внутри <em>connection pool</em>.</p>
<p>Для работы с БД нужно получить connection и что-нибудь выполнить:</p>
<pre><code>with (yield from engine) as conn:
    uid = yield from conn.scalar(
        users.insert().values(name='Andrew', birthday=datetime(1978, 12, 9)))
</code></pre>
<p>Обратите внимание: диалект знает о <code>INSERT ... RETURNING</code> и позвращает
<em>primary key</em> для вставляемой записи.</p>
<p>Работа с транзакциями:</p>
<pre><code>with (yield from engine) as conn:
    tr = yield from conn.begin()

    # Do something

    yield from tr.commit()
</code></pre>
<p>Получение данных:</p>
<pre><code>with (yield from engine) as conn:
    res = yield from conn.execute(users.select())
    for row in res:
        print(res)
</code></pre>
<p>Сложный запрос:</p>
<pre><code>with (yield from engine) as conn:
    join = sa.join(emails, users, users.c.id == emails.c.user_id)
    query = (sa.select([users.c.name])
             .select_from(join)
             .where(emails.c.private == 0)
             .group_by(users.c.name)
             .having(sa.func.count(emails.c.private) &gt; 0))

    print("Users with public emails:")
    ret = yield from conn.execute(query)
    for row in ret:
        print(row.name)
</code></pre>
<p>Вызов SQL функций:</p>
<pre><code>with (yield from engine) as conn:
    query = (sa.select([sa.func.avg(sa.func.age(users.c.birthday))])
             .select_from(users))
    ave = (yield from conn.scalar(query))
    print("Average age of population is", ave,
          "or ~", int(ave.days / 365), "years")
</code></pre>
<p><code>sa.func.avg</code> и <code>sa.func.age</code> выполняются на стороне SQL сервера.</p>
<p>Полный код примера
<a href="https://github.com/aio-libs/aiopg/blob/master/examples/sa.py">здесь</a>,
документация <a href="http://aiopg.readthedocs.org">здесь</a>.</p>
<p/>
</div>
</div></body></html>