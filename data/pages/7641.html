<html><body><div><div class="post-text" itemprop="text">
<h2>Short answers</h2>

<blockquote>
  <p>Is this handled in Asyncore itself due to asyncore's polling/select
  methodlogy?</p>
</blockquote>

<p>No, asyncore cannot handle by itself a long blocking task in <code>handle_read()</code>, since there is only one thread. The thread is doing some long job and it cannot be interrupted by the same thread.</p>

<p>However, such blocking implementation makes sense. The only issue is that the network transfer is slower. For example if the long task takes 1 second, then the maximum data transfer rate is 8192 bytes per second. Although the data rate is slower the network connection is stable and it works as expected. That is handled by TCP protocol implementation in the operating system kernel.</p>

<blockquote>
  <p>...or do I need to do...? If I do need a thread, do I want <code>h.join()</code>
  after start?</p>
</blockquote>

<p>None of the above thread usages make sense. However, it is still possible to use helper thread to download data at maximum rate and to process that data in parallel, see below for explanations.</p>

<hr/>

<h2>TCP protocol</h2>

<p><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" rel="nofollow">TCP</a> provides reliable, ordered, and error-checked delivery of a stream.</p>

<p><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Data_transfer" rel="nofollow">Data transfer:</a></p>

<blockquote>
  <p>Flow control â€” limits the rate a sender transfers data to guarantee
  reliable delivery. The receiver continually hints the sender on how
  much data can be received (controlled by the sliding window). When the
  receiving host's buffer fills, the next acknowledgment contains a 0 in
  the window size, to stop transfer and allow the data in the buffer to
  be processed.</p>
  
  <p>...</p>
  
  <p>When a receiver advertises a window size of 0, the sender stops
  sending data and starts the persist timer. The persist timer is used
  to protect TCP from a deadlock situation that could arise if a
  subsequent window size update from the receiver is lost, and the
  sender cannot send more data until receiving a new window size update
  from the receiver. When the persist timer expires, the TCP sender
  attempts recovery by sending a small packet so that the receiver
  responds by sending another acknowledgement containing the new window
  size.</p>
</blockquote>

<p>So, when the data is not read from the socket due to long task in <code>handle_read()</code> the socket buffer becomes full. The TCP connection suspends and does not receive any new data packets. After <code>recv()</code> new data can be received, so the <code>TCP ACK</code> packet is sent to the sender to update TCP window size.</p>

<p>The similar behavior can be observed with file downloader applications when data transfer rate is limited by the settings. For example, if the limit is set to 1Kb/s the downloader may call <code>recv(1000)</code> once per second. Even if the physical network connection is able to send 1Mb/s, only 1Kb/s will be received. In that case it is possible to see by <code>tcpdump</code> or by <code>Wireshark</code> <em>TCP Zero Window</em> packets and <em>TCP Window Update</em> packets.</p>

<hr/>

<p>Although the application will work with long blocking task, the network connection is usually considered as <em>bottleneck</em>. So, it may be better to release network as soon as possible.</p>

<p>If the long task takes much longer then data download the simplest solution is to download everything and only then process downloaded data. However it may be not acceptable if time for data download is commensurate with time for data processing task. For example 1 hour for download + 2 hours for processing can be done in 2 hours if processing is performed in parallel to download.</p>

<hr/>

<h2>Thread for each data block</h2>

<p>If a new thread is created in <code>handle_read()</code> and the main thread does not wait for the helper thread to finish (without <code>join()</code>) the application may create huge number threads. Note that <code>handle_read()</code> may be called thousands times per second and if each long task takes more then second the application may create hundreds of threads and finally it may be killed by an exception. Such solution does not make sense since there is no control over number of threads and also data blocks handled by those threads are also random. The function <code>recv(8192)</code> receives at most <code>8192</code> bytes, but it also may receive smaller data block.</p>

<hr/>

<h2>Thread for each data block and join with main thread</h2>

<p>It does not make any sense to create a thread and immediately block execution of the main thread by <code>join()</code>, since such solution is not better than just initial solution without any thread.</p>

<p>Some helper thread and later <code>join()</code> may be used to do something in parallel. For example:</p>

<pre><code># Start detached thread
h.start()
# Do something in parallel to that thread
# ...
# Wait the thread to finish
h.join()
</code></pre>

<p>However, here it is not such case.</p>

<hr/>

<h2>Persistent worker thread and producer-consumer data exchange</h2>

<p>It is possible to create one persistent worker thread (or several to use all CPU cores) that will be responsible for data processing. It should be started before <code>asyncore.loop()</code>, for example:</p>

<pre><code>handler = Handler()
asyncore.loop()
</code></pre>

<p>Now once the handler thread is ready it can take all downloaded data for processing and at the same time the main thread may continue with data download. While the handler thread is busy the downloader appends data to its data buffer. It is needed to take care about proper synchronization between threads:</p>

<ul>
<li>if downloaded data is appended to downloader <code>buffer</code>, the handler thread should wait before it will have access to that <code>buffer</code>;</li>
<li>if the handler is reading the <code>buffer</code> the downloader should wait before it will be able to append to <code>buffer</code>;</li>
<li>if the handler has nothing to do and the <code>buffer</code> is empty it should <em>freeze</em> and wait for new downloaded data.</li>
</ul>

<p>That can be achieved using <a href="https://docs.python.org/2/library/threading.html#condition-objects" rel="nofollow">threading condition object</a> and the producer-consumer example:</p>

<pre><code># create a new condition variable on __init__
cv = threading.Condition()

# Consume one item by Handler
cv.acquire()
while not an_item_is_available():
    cv.wait()
get_an_available_item()
cv.release()
# DO SOME REALLY LONG AND COMPLICATED THING

# Produce one item by Downloader
cv.acquire()
make_an_item_available()
cv.notify()
cv.release()
</code></pre>

<p>Here <code>make_an_item_available()</code> may be related to appending downloaded data to <code>buffer</code> and or setting some other shared state variables (for example in <code>handle_close()</code>). The handler thread should do its long task after <code>cv.release()</code>, so during that long task the downloader is able to acquire the lock and append new data to the <code>buffer</code>.</p>
    </div>
    </div></body></html>