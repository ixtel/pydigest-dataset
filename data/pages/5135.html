<html><body><div><div class="entry-content">
<footer class="post-info">
        <span>Thu 02 July 2015</span>

</footer>      <h1>Introduction - Vertex Data in GL</h1>
<p>When GL renders an object, the data used to calculate the actual on-screen 
pixel comes from a few places. </p>
<ol>
<li>
<p>Uniform Data: Is the same for every vertex of every object being rendered 
using the same shader. </p>
</li>
<li>
<p>Vertex Data: Vertex data varies per each vertex rendered, every single vertex
of every single object will have a copy of all attributes as dictated 
by the vertex format.</p>
</li>
</ol>
<p>Kivy's built in VertexFormat only has support for submitting floating point data,
a decision that makes declaring a vertex format straightforward:</p>
<p>The default format looks like:</p>
<div class="highlight"><pre>[
(b’v_pos’, 2, b’float’), 
(b’v_tc’, 2, b’float’),
]
</pre></div>


<p>We have a 2 float tuple holding position information, named v_pos, and a 2 
float tuple holding texture information, named v_tc. At this time the only option
for the third member is float. This allows Kivy to assume your vertex data resides
in a tightly packed array of floats, and it only needs to use the count of floats 
to determine the position in the array of any given attribute.</p>
<h1>Optimization Goal - Reducing Memory Usage</h1>
<p>A huge portion of the time spent drawing a frame is spent writing out memory contents
for the vertex data arrays, as these can get quite large. ES2.0 can draw
up to 65,535 vertices per draw call, so for a simple vertex format representing
x, y pos and u, v texture coordinates, like the one kivy uses, 
we could expect to write up to 1045680 (65535 (max range of unsigned short) * 
4 (number of attributes) * 4 (size of float in bytes)) bytes per frame per 
draw call. </p>
<p>However, this requires that we store any per vertex information at one of the largest
type sizes, increasing the amount of memory required to render certain types of 
visualizations that can have data packed into a smaller type. If we wanted to assign 
a color per vertex to be used in rendering, we would have to double the size of the 
submitted data as it would take 4 floats to store the color information for r, g, b,
a channels.</p>
<p>Using Kivy's format declaration:</p>
<div class="highlight"><pre>[
(b’v_pos’, 2, b’float’), 
(b’v_tc’, 2, b’float’),
(b'v_color', 4, b'float'),
]
</pre></div>


<p>We could instead store this color data as unsigned chars, which have a range of 
0-255, matching the rgba colors you are probably familiar with. We want to do 
something like:</p>
<div class="highlight"><pre>[
(b’v_pos’, 2, b’float’), 
(b’v_tc’, 2, b’float’),
(b'v_color', 4, b'ubyte'),
]
</pre></div>


<p>This would allow our vertex to take up 20 bytes of data instead of 32. However,
it is not quite that simple. There is a reason Kivy currently only supports 
float type while technically having a field for customizing the type.</p>
<h1>The Problem of Alignment</h1>
<p>If we are going to mix types, we can no longer assume that our data is tightly 
packed into an array. If a type does not take up the full space in a machine word 
and would cause the next entry to sit on the boundary between 2 words, we would 
instead insert some extra spacing to ensure the next type begins on the next 
machine word. This practice is known as 
<a href="https://en.wikipedia.org/wiki/Data_structure_alignment">data alignment</a>.</p>
<p>To illustrate, we have a vertex format that looks like:</p>
<div class="highlight"><pre>[
(b’b1’, 1, b’byte’), 
(b’b2’, 1, b’byte’), 
(b’f1', 1, b'float'),
(b’f2', 1, b'float'),
]
</pre></div>


<p>On a 32-bit system, a machine word is 4 bytes long: this vertex format without
padding would require 10 bytes of data, so 3 machine words:</p>
<div class="highlight"><pre>Word 1 | x | x | x | x | Word 2 | x | x | x | x | Word 3 | x | x | x | x |
</pre></div>


<p>unaligned:</p>
<div class="highlight"><pre>Word 1 | b1 | b2 | f1 | f1 | Word 2 | f1 | f1 | f2 | f2 | Word 3 | f2 | f2 | x | x |
</pre></div>


<p>Note how f1 and f2 are split between words, the cpu will now have to spend 
extra time to read this data, as it must look in Word 1 and Word 2 to find the 
value of f1. It would be much better to format our data with some extra space
after the bytes so that the next value begins at the beginning of the next word:</p>
<p>aligned:</p>
<div class="highlight"><pre>Word 1 | b1 | b2 | x | x | Word 2 | f1 | f1 | f1 | f1 | Word 3 | f2 | f2 | f2 | f2 |
</pre></div>


<p>This leaving of space is known as padding and it could be done manually if you 
really wanted, however you must keep in mind cpu architecture to know what word 
size to align too. Luckily C provides us with another method of handling this 
type of data: declaring a C struct. A struct will have padding automatically 
introduced by the compiler when necessary.</p>
<h1>Using C Structs in Cython</h1>
<p>In KivEnt, I have chosen to require static declaration of vertex formats using 
C structs. This allows us to both have a more performant rendering loop for 
processing the model data and game state to frame data, and solves the problems 
related to alignment necessary for us to interleave data of different types. The 
downside is we must recompile a KivEnt module making changes to rendering behavior
before we can work with our new code. </p>
<p>We can declare a C struct like this:</p>
<div class="highlight"><pre><span class="k">ctypedef</span> <span class="k">struct</span> <span class="nc">VertexFormat4F</span><span class="p">:</span>
    <span class="n">GLfloat</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span> <span class="n">v_pos</span>
    <span class="n">GLfloat</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span> <span class="n">v_tc</span>
</pre></div>


<p>Typically we will place the declaration in a .pxd header file so that the type is
accessible from other modules that may want to work with it.</p>
<p>We must consider one other thing to make this work though, our original 
<a href="https://github.com/kivy/kivy/blob/master/kivy/graphics/vbo.pyx#L109">algorithm</a> 
for binding the vertex attributes always passes an offset equal to the size of 
the attribute in bytes, which means it does not account for padding. When ever we 
render something in GL we must tell it about the attributes it is expecting the 
shader to use with a call to the glVertexAttribPointer function, an invocation 
looks like this:</p>
<div class="highlight"><pre><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
    <span class="n">GL_FALSE</span><span class="p">,</span> <span class="p">&lt;</span><span class="kt">GLsizei</span><span class="p">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">format_size</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">GLvoid</span><span class="o">*&gt;</span><span class="p">&lt;</span><span class="kt">long</span><span class="p">&gt;</span><span class="n">offset</span><span class="p">)</span>
</pre></div>


<p>The arguments we pass in are the index of the attribute as set by GL when we 
register the vertex attributes. The size of the attribute, that is how many values
are in the array. For our v_pos and v_tc this would be 2. The third arg is the type of 
the attribute, here it would be GL_FLOAT. </p>
<p>The next bool determines whether or not the value will be normalized using the 
bounds of the range of its type. This can be very useful as many types of GL 
processing uses normalized values as inputs. For instance, both texture coordinates
and colors are normalized. The following argument is the total size of a vertex,
aka the sizeof your struct in KivEnt or the sum of 4*attribute_count per attribute
in the Kivy approach of using floating point arrays. Finally, the last argument,
the offset, is where we pass in the information about padding. We will tell GL
how many bytes it takes in each struct to reach the beginning of a particular 
attribute. In default Kivy this is done by simply calculating how many floats 
have come before, but now that we must account for padding we must make use of a 
new calculation.</p>
<p>C typically provides a macro called 
<a href="https://msdn.microsoft.com/en-us/library/dz4y9b9a.aspx">offsetof</a> to aid in this 
type of calculation. offsetof returns the count in bytes from the beginning of a
struct that a particular member of the struct occurs at in memory. However, we 
do not have access to this macro in Cython. Fortunately, we can emulate the action
of the macro, it will be a little more verbose but ultimately we will get the 
information we need in a portable, cross-platform way. Creating our vertex format
in KivEnt requires one last step, and that is to extract the offsets for each 
attribute in the format struct and store them in a list much like the original 
Kivy declaration, but with a few extra fields.</p>
<div class="highlight"><pre><span class="k">from</span> <span class="nn">cython</span> <span class="k">cimport</span> <span class="n">Py_ssize_t</span>
<span class="k">cdef</span> <span class="kr">extern</span> <span class="k">from</span> <span class="s">"Python.h"</span><span class="p">:</span>
    <span class="k">ctypedef</span> <span class="nb">int</span> <span class="n">Py_intptr_t</span>
<span class="c">#import the appropriate types for performing the calculation from python.</span>

<span class="c">#Create a pointer to the struct type, in this case a VertexFormat4F, by </span>
<span class="c">#casting the NULL pointer to the type. This ensures that we have a pointer</span>
<span class="c">#that begins at the very beginning of the data. </span>
<span class="k">cdef</span> <span class="kt">VertexFormat4F</span>* <span class="nf">tmp1</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">VertexFormat4F</span><span class="o">*&gt;</span><span class="bp">NULL</span>
<span class="c">#Now, we can calculate the distance between an attribute and the start of </span>
<span class="c">#the struct like so:</span>
<span class="n">pos_offset</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">Py_ssize_t</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">Py_intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="o">.</span><span class="n">v_pos</span><span class="p">)</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">Py_intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">))</span>
<span class="c">#we are effectively subtracting the position in bytes of the start of our particular </span>
<span class="c">#struct from the position in bytes of the member of the struct whose location we want:</span>
<span class="n">tc_offset</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">Py_ssize_t</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">Py_intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="o">.</span><span class="n">v_tc</span><span class="p">)</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">Py_intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">))</span>

<span class="n">vertex_format_4f</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="n">b</span><span class="s">'v_pos'</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="n">b</span><span class="s">'float'</span><span class="p">,</span> <span class="n">pos_offset</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span> 
    <span class="p">(</span><span class="n">b</span><span class="s">'v_tc'</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="n">b</span><span class="s">'float'</span><span class="p">,</span> <span class="n">tc_offset</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span>
    <span class="p">]</span>
</pre></div>


<p>KivEnt introduces a boolean to control whether or not a value should be 
normalized in addition to the offsetof value.</p>
<p>Now let's declare our bytes vertex color using our new system:</p>
<div class="highlight"><pre><span class="k">from</span> <span class="nn">cython</span> <span class="k">cimport</span> <span class="n">Py_ssize_t</span>
<span class="c">#We will import the format_registrar so that we can tell the game engine</span>
<span class="c">#about the new format.</span>
<span class="k">from</span> <span class="nn">kivent_core.rendering.vertex_formats</span> <span class="k">cimport</span> <span class="n">format_registrar</span>
<span class="c">#Import the types we will need for our format from Kivy's c_opengl module.</span>
<span class="k">from</span> <span class="nn">kivy.graphics.c_opengl</span> <span class="k">cimport</span> <span class="n">GLfloat</span><span class="p">,</span> <span class="n">GLubyte</span>
<span class="k">cdef</span> <span class="kr">extern</span> <span class="k">from</span> <span class="s">"Python.h"</span><span class="p">:</span>
    <span class="k">ctypedef</span> <span class="nb">int</span> <span class="n">Py_intptr_t</span>

<span class="k">ctypedef</span> <span class="k">struct</span> <span class="nc">VertexFormat4F4UB</span><span class="p">:</span>
    <span class="n">GLfloat</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span> <span class="n">v_pos</span>
    <span class="n">GLfloat</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span> <span class="n">v_tc</span>
    <span class="n">GLubyte</span><span class="p">[</span><span class="mf">4</span><span class="p">]</span> <span class="n">v_color</span>

<span class="k">cdef</span> <span class="kt">VertexFormat4F4UB</span>* <span class="nf">tmp1</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">VertexFormat4F4UB</span><span class="o">*&gt;</span><span class="bp">NULL</span>
<span class="n">pos_offset</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">Py_ssize_t</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">Py_intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="o">.</span><span class="n">v_pos</span><span class="p">)</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">Py_intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">))</span>
<span class="n">tc_offset</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">Py_ssize_t</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">Py_intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="o">.</span><span class="n">v_tc</span><span class="p">)</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">Py_intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">))</span>
<span class="n">color_offset</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">Py_ssize_t</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">Py_intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="o">.</span><span class="n">v_color</span><span class="p">)</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">Py_intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">))</span>

<span class="n">vertex_format_4f4ub</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="n">b</span><span class="s">'pos'</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="n">b</span><span class="s">'float'</span><span class="p">,</span> <span class="n">pos_offset</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span> 
    <span class="p">(</span><span class="n">b</span><span class="s">'v_tc'</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="n">b</span><span class="s">'float'</span><span class="p">,</span> <span class="n">tc_offset</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span>
    <span class="c">#We normalize the color values, this will result in the val / 255 for a ubyte</span>
    <span class="p">(</span><span class="n">b</span><span class="s">'v_color'</span><span class="p">,</span> <span class="mf">4</span><span class="p">,</span> <span class="n">b</span><span class="s">'ubyte'</span><span class="p">,</span> <span class="n">color_offset</span><span class="p">,</span> <span class="bp">True</span><span class="p">),</span>
    <span class="p">]</span>

<span class="c">#Finally, we must register our new format with the game engine</span>
<span class="n">format_registrar</span><span class="o">.</span><span class="n">register_vertex_format</span><span class="p">(</span><span class="s">'vertex_format_4f4ub'</span><span class="p">,</span> 
    <span class="n">vertex_format_4f4ub</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">VertexFormat4F4UB</span><span class="p">))</span>
</pre></div>


<p>A little verbose compared to the Kivy declaration, but with more power and performance
than is possible entirely from python. Having the struct type will also come in 
handy when writing our rendering loop. If you're curious, you can read a more detailed
tutorial <a href="https://github.com/kivy/kivent/wiki/Getting-Started-6:-Creating-a-Renderer">explaining the render loop</a>.</p>
<h1>Wrapping Arbitrary Format structs in Python</h1>
<p>While I'm perfectly happy requiring that the actual data format for a vertex 
be declared statically, I wanted a python object that can read and write a vertex
no matter its format so that it is easy to extend KivEnt's supported formats 
without having to modify too many parts of the engine. The addition of our extra
offset data actually allows us to accomplish this easily. First, we will 
declare an object that will take a void pointer to the location in memory of its 
associated struct, and a dictionary form of the vertex format list that has keys of 
the attribute name, values of the remaining members of the attribute tuple.</p>
<div class="highlight"><pre><span class="c">#Import all the GL types.</span>
<span class="k">from</span> <span class="nn">kivy.graphics.c_opengl</span> <span class="k">cimport</span> <span class="p">(</span><span class="n">GLfloat</span><span class="p">,</span> <span class="n">GLbyte</span><span class="p">,</span> <span class="n">GLubyte</span><span class="p">,</span> <span class="n">GLint</span><span class="p">,</span> <span class="n">GLuint</span><span class="p">,</span>
<span class="n">GLshort</span><span class="p">,</span> <span class="n">GLushort</span><span class="p">)</span>

<span class="k">cdef</span> <span class="k">class</span> <span class="nf">Vertex</span><span class="p">:</span>
    <span class="k">cdef</span> <span class="kt">dict</span> <span class="nf">vertex_format</span>
    <span class="k">cdef</span> <span class="kt">void</span>* <span class="nf">vertex_pointer</span>

    <span class="k">def</span> <span class="nf">__cinit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">dict</span> <span class="n">format</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertex_format</span> <span class="o">=</span> <span class="n">format</span>
</pre></div>


<p>Note that we still must set the pointer to a specific location before using 
our Vertex object, or we may have unintended results. The VertexModel class 
does this for you, but if you are ever using a Vertex manually, you must do 
something like:</p>
<div class="highlight"><pre><span class="n">v</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">(</span><span class="n">format_dict</span><span class="p">)</span>
<span class="n">v</span><span class="o">.</span><span class="n">vertex_pointer</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">void</span><span class="o">*&gt;</span><span class="n">yourstruct</span>
<span class="c">#now it's safe to use.</span>
<span class="n">v</span><span class="o">.</span><span class="n">v_pos</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
</pre></div>


<p>We will write a custom __getattr__ so that we can retrieve the data of a certain
attribute from the array:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="c">#These values will be looked up inside the format dict</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">count</span>
    <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">offset</span>
    <span class="k">cdef</span> <span class="kt">bytes</span> <span class="nf">attr_type</span>
    <span class="c">#We cast our pointer to a char* pointer so that we can index into it using bytes.</span>
    <span class="k">cdef</span> <span class="kt">char</span>* <span class="nf">data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">char</span><span class="o">*&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_pointer</span>
    <span class="c">#We must forward declare pointers to arrays of each GL type we can use:</span>
    <span class="k">cdef</span> <span class="kt">GLfloat</span>* <span class="nf">f_data</span>
    <span class="k">cdef</span> <span class="kt">GLint</span>* <span class="nf">i_data</span>
    <span class="k">cdef</span> <span class="kt">GLuint</span>* <span class="nf">ui_data</span>
    <span class="k">cdef</span> <span class="kt">GLshort</span>* <span class="nf">s_data</span>
    <span class="k">cdef</span> <span class="kt">GLushort</span>* <span class="nf">us_data</span>
    <span class="k">cdef</span> <span class="kt">GLbyte</span>* <span class="nf">b_data</span>
    <span class="k">cdef</span> <span class="kt">GLubyte</span>* <span class="nf">ub_data</span>
    <span class="c">#If we are using py3, we need to cast our name str to bytes as GL cannot</span>
    <span class="c">#use unicode attr names.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">'utf-8'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_format</span><span class="p">:</span>
        <span class="c">#If we find the name in the format, retrieve the count, type, and offset from the formact_dict</span>
        <span class="n">attribute_tuple</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_format</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">attribute_tuple</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
        <span class="n">attr_type</span> <span class="o">=</span> <span class="n">attribute_tuple</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">attribute_tuple</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span>
        <span class="c">#Check the type to use</span>
        <span class="k">if</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'float'</span><span class="p">:</span>
            <span class="c">#Index into the char array by the offset in bytes, and then cast to the appropriate type</span>
            <span class="n">f_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLfloat</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
            <span class="c">#Retrieve the counter number of values, casting from a GL type to a normal C type, which </span>
            <span class="c">#will then be converted to a python type automatically by Cython.</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[&lt;</span><span class="kt">float</span><span class="p">&gt;</span><span class="n">f_data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
        <span class="c">#Now we just do the same thing for all the other types.</span>
        <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'int'</span><span class="p">:</span>
            <span class="n">i_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLint</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="n">i_data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'uint'</span><span class="p">:</span>
            <span class="n">ui_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLuint</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">unsigned</span> <span class="nb">int</span><span class="o">&gt;</span><span class="n">ui_data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'short'</span><span class="p">:</span>
            <span class="n">s_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLshort</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[&lt;</span><span class="kt">short</span><span class="p">&gt;</span><span class="n">s_data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'ushort'</span><span class="p">:</span>
            <span class="n">us_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLushort</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">unsigned</span> <span class="n">short</span><span class="o">&gt;</span><span class="n">us_data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'byte'</span><span class="p">:</span>
            <span class="n">b_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLbyte</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[&lt;</span><span class="kt">char</span><span class="p">&gt;</span><span class="n">b_data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'ubyte'</span><span class="p">:</span>
            <span class="n">ub_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLubyte</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">unsigned</span> <span class="n">char</span><span class="o">&gt;</span><span class="n">ub_data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#Raise a TypeError if the attr_type is not one of the available.</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">()</span>
        <span class="c">#If our return has only one value, lets return it instead a list of length 1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mf">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c">#Raise an attribute error if the name is not in the format.</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">()</span>
</pre></div>


<p>A little verbose as we must explicitly deal with each of the types, but nothing
too arduous. Keep in mind we will always return a copy of the data, not the data 
itself. This means you can't keep around or modify in place the returned lists 
and expect the underlying data to change. We must implement a custom __setattr__
to modify the data in the underlying memory:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="c">#Like before, predeclare our format tuple values</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">count</span>
    <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">offset</span>
    <span class="k">cdef</span> <span class="kt">bytes</span> <span class="nf">attr_type</span>
    <span class="c">#Cast the data pointer to a char pointer</span>
    <span class="k">cdef</span> <span class="kt">char</span>* <span class="nf">data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">char</span><span class="o">*&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_pointer</span>
    <span class="c">#Predeclare the typed array pointers</span>
    <span class="k">cdef</span> <span class="kt">GLfloat</span>* <span class="nf">f_data</span>
    <span class="k">cdef</span> <span class="kt">GLint</span>* <span class="nf">i_data</span>
    <span class="k">cdef</span> <span class="kt">GLuint</span>* <span class="nf">ui_data</span>
    <span class="k">cdef</span> <span class="kt">GLshort</span>* <span class="nf">s_data</span>
    <span class="k">cdef</span> <span class="kt">GLushort</span>* <span class="nf">us_data</span>
    <span class="k">cdef</span> <span class="kt">GLbyte</span>* <span class="nf">b_data</span>
    <span class="k">cdef</span> <span class="kt">GLubyte</span>* <span class="nf">ub_data</span>
    <span class="c">#If the data is a tuple cast it to a list</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="c">#If the data is a single value, turn it into a list for algorithmic simplicity</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
    <span class="c">#If the name is unicode cast to bytes</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">'utf-8'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_format</span><span class="p">:</span>
        <span class="c">#Check if the name is in the format and get the other values</span>
        <span class="n">attribute_tuple</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_format</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">attribute_tuple</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
        <span class="n">attr_type</span> <span class="o">=</span> <span class="n">attribute_tuple</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">attribute_tuple</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span>
        <span class="c">#If the setting data is not the right size raise an exception.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AttributeCountError</span><span class="p">(</span><span class="s">'Expected list of length {count} got'</span>
                <span class="s">'list of size {length}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> 
                <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'float'</span><span class="p">:</span>
                <span class="c">#Index into the memory by the offset + the number of bytes taken up by </span>
                <span class="c">#previous values if we have an array, casting to the appropriate type.</span>
                <span class="n">f_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLfloat</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">)]</span>
                <span class="c">#Cast the setting value to the appropriate type and assign it to the location in memory.</span>
                <span class="n">f_data</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">&lt;</span><span class="kt">GLfloat</span><span class="p">&gt;</span><span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="c">#Do the same for all the other types.</span>
            <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'int'</span><span class="p">:</span>
                <span class="n">i_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLint</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="n">GLint</span><span class="p">)]</span>
                <span class="n">i_data</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">&lt;</span><span class="kt">GLint</span><span class="p">&gt;</span><span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'uint'</span><span class="p">:</span>
                <span class="n">ui_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLuint</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="n">GLuint</span><span class="p">)]</span>
                <span class="n">ui_data</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">&lt;</span><span class="kt">GLuint</span><span class="p">&gt;</span><span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'short'</span><span class="p">:</span>
                <span class="n">s_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLshort</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="n">GLshort</span><span class="p">)]</span>
                <span class="n">s_data</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">&lt;</span><span class="kt">GLshort</span><span class="p">&gt;</span><span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'ushort'</span><span class="p">:</span>
                <span class="n">us_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLushort</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="n">GLushort</span><span class="p">)]</span>
                <span class="n">us_data</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">&lt;</span><span class="kt">GLushort</span><span class="p">&gt;</span><span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'byte'</span><span class="p">:</span>
                <span class="n">b_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLbyte</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="n">GLbyte</span><span class="p">)]</span>
                <span class="n">b_data</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">&lt;</span><span class="kt">GLbyte</span><span class="p">&gt;</span><span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'ubyte'</span><span class="p">:</span>
                <span class="n">ub_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLubyte</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="n">GLubyte</span><span class="p">)]</span>
                <span class="n">ub_data</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">&lt;</span><span class="kt">GLubyte</span><span class="p">&gt;</span><span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c">#Raise error if type is unhandled.</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c">#Raise error if name isn't in format.</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">()</span>
</pre></div>


<p>Thus the final piece is in place, we can now declare C structs that describe
our vertex data and hold all our rendering information in them to create 
efficient and performant rendering loops in Cython, while also being able to access
all the data from Python using the Vertex class.</p>
    </div>

  </div></body></html>