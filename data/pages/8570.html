<html><body><div><p>Embed IPython Notebook shell on your Pyramid web site and start through-the-browser Python shell with a single click.</p>
<div id="usage">

<p>Your application needs to configure three custom views.</p>
<ul>
<li>One or multiple <tt>launch_ipython()</tt> notebook launch points. This does user authentication and authorization and then calls <tt>pyramid_notebook.views.launch_notebook()</tt> to open a new Notebook for a user. <tt>launch_ipython()</tt> takes in Notebook context parameters (see below), starts a new Notebook kernel if needed and then redirects user to Notebook itself.</li>
<li><tt>shutdown_ipython()</tt> which does authentication and authorization and calls <tt>pyramid_notebook.views.shutdown_notebook()</tt> to force close a notebook for a user.</li>
<li><tt>notebook_proxy()</tt> which does authentication and authorization and calls <tt>pyramid_notebook.views.notebook_proxy()</tt> to proxy HTTP request to upstream IPython Notebook server bind to a localhost port. <cite>notebook_proxy</cite> is mapped to <cite>/notebook/</cite> path in your site URL. Both your site and Notebook upstream server should agree on this location.</li>
</ul>
<div id="example-code">

<p>The following is an example how to construct <tt>admin_shell</tt> view which launches a Notebook for the currently logged in Pyramid user when the view is visited for the first time. For extra security the permission for the notebook view cannot be assigned through normal groups, but the username must be on the whitelist in the INI settings file. This guarantees the shell is initially accessible only by persons who have shell access to the server itself.</p>
<p>For another approach on these views, please see the demo source code.</p>
<p><tt>views.py</tt>:</p>
<pre><span class="kn">from</span> <span class="nn">pyramid.httpexceptions</span> <span class="kn">import</span> <span class="n">HTTPFound</span>
<span class="kn">from</span> <span class="nn">pyramid.view</span> <span class="kn">import</span> <span class="n">view_config</span>
<span class="kn">from</span> <span class="nn">pyramid_notebook</span> <span class="kn">import</span> <span class="n">startup</span>
<span class="kn">from</span> <span class="nn">pyramid_notebook.views</span> <span class="kn">import</span> <span class="n">launch_notebook</span>
<span class="kn">from</span> <span class="nn">pyramid_notebook.views</span> <span class="kn">import</span> <span class="n">shutdown_notebook</span> <span class="k">as</span> <span class="n">_shutdown_notebook</span>
<span class="kn">from</span> <span class="nn">pyramid_notebook.views</span> <span class="kn">import</span> <span class="n">notebook_proxy</span> <span class="k">as</span> <span class="n">_notebook_proxy</span>
<span class="kn">from</span> <span class="nn">pyramid_web20.models</span> <span class="kn">import</span> <span class="n">Base</span>


<span class="c1">#: Include our database session in notebook so it is easy to query stuff right away from the prompt</span>
<span class="n">SCRIPT</span> <span class="o">=</span> <span class="s2">"""
from pyramid_web20.models import DBSession as session
"""</span>


<span class="n">GREETING</span><span class="o">=</span><span class="s2">"""
* **session** - SQLAlchemy database session
"""</span>


<span class="nd">@view_config</span><span class="p">(</span><span class="n">route_name</span><span class="o">=</span><span class="s2">"notebook_proxy"</span><span class="p">,</span> <span class="n">permission</span><span class="o">=</span><span class="s2">"shell"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">notebook_proxy</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="sd">"""Proxy IPython Notebook requests to the upstream server."""</span>
    <span class="k">return</span> <span class="n">_notebook_proxy</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="p">)</span>


<span class="nd">@view_config</span><span class="p">(</span><span class="n">route_name</span><span class="o">=</span><span class="s2">"admin_shell"</span><span class="p">,</span> <span class="n">permission</span><span class="o">=</span><span class="s2">"shell"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">admin_shell</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="sd">"""Open admin shell with default parameters for the user."""</span>
    <span class="c1"># Make sure we have a logged in user</span>
    <span class="n">nb</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Pass around the Pyramid configuration we used to start this application</span>
    <span class="n">global_config</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s2">"pyramid_web20.global_config"</span><span class="p">]</span>

    <span class="c1"># Get the reference to our Pyramid app config file and generate Notebook</span>
    <span class="c1"># bootstrap startup.py script for this application</span>
    <span class="n">config_file</span> <span class="o">=</span> <span class="n">global_config</span><span class="p">[</span><span class="s2">"__file__"</span><span class="p">]</span>
    <span class="n">startup</span><span class="o">.</span><span class="n">make_startup</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">config_file</span><span class="p">)</span>
    <span class="n">startup</span><span class="o">.</span><span class="n">add_script</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">SCRIPT</span><span class="p">)</span>
    <span class="n">startup</span><span class="o">.</span><span class="n">add_greeting</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">GREETING</span><span class="p">)</span>

    <span class="c1">#: Include all our SQLAlchemy models in the notebook variables</span>
    <span class="n">startup</span><span class="o">.</span><span class="n">include_sqlalchemy_models</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">Base</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">launch_notebook</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="p">,</span> <span class="n">notebook_context</span><span class="o">=</span><span class="n">nb</span><span class="p">)</span>


<span class="nd">@view_config</span><span class="p">(</span><span class="n">route_name</span><span class="o">=</span><span class="s2">"shutdown_notebook"</span><span class="p">,</span> <span class="n">permission</span><span class="o">=</span><span class="s2">"shell"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">shutdown_notebook</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="sd">"""Shutdown the notebook of the current user."""</span>
    <span class="n">_shutdown_notebook</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">HTTPFound</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">route_url</span><span class="p">(</span><span class="s2">"home"</span><span class="p">))</span>
</pre>
<p>We also need to capture the INI settings file on the server start up, so that we can pass it forward to IPython Notebook process. In <tt>__init__.py</tt>:</p>
<pre><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">global_config</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
    <span class="n">settings</span><span class="p">[</span><span class="s2">"pyramid_web20.global_config"</span><span class="p">]</span> <span class="o">=</span> <span class="n">global_config</span>
</pre>
<p>Then we have a custom principals handler granting the <tt>shell</tt> permission for users read from the user whitelist in the configuration file:</p>
<pre><span class="k">def</span> <span class="nf">find_groups</span><span class="p">(</span><span class="n">userid</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
    <span class="sd">"""Get applied groups and other for the user"""</span>

    <span class="kn">from</span> <span class="nn">horus.interfaces</span> <span class="kn">import</span> <span class="n">IUserModel</span>
    <span class="n">user_class</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">queryUtility</span><span class="p">(</span><span class="n">IUserModel</span><span class="p">)</span>

    <span class="c1"># Read superuser names from the config</span>
    <span class="n">superusers</span> <span class="o">=</span> <span class="n">aslist</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"pyramid_web20.superusers"</span><span class="p">))</span>

    <span class="n">user</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DBSession</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">user_class</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">userid</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">can_login</span><span class="p">():</span>
            <span class="n">principals</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'group:{}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">user</span><span class="o">.</span><span class="n">groups</span><span class="p">]</span>

        <span class="c1"># Allow superuser permission</span>
        <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">username</span> <span class="ow">in</span> <span class="n">superusers</span> <span class="ow">or</span> <span class="n">user</span><span class="o">.</span><span class="n">email</span> <span class="ow">in</span> <span class="n">superusers</span><span class="p">:</span>
            <span class="n">principals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"superuser:superuser"</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">principals</span>

    <span class="c1"># User not found, user disabled</span>
    <span class="k">return</span> <span class="bp">None</span>
</pre>
<p>We refer to <tt>superuser:super</tt> in Pyramid site root object:</p>
<pre>class Root:

    __acl__ = [
        ...
        (Allow, "superuser:superuser", 'shell'),
    ]
</pre>
<p>And here is the configuration file bit:</p>
<pre>pyramid_web20.superusers =
    mikko@example.com
</pre>
</div>
<div id="pyramid-settings">

<p><em>python_notebook</em> reads following parameters from your Pyramid INI configuration file:</p>
<pre># Where we store IPython Notebook runtime and persistent files
# (pid, saved notebooks, etc.).
# Each user will get a personal subfolder in this folder
pyramid_notebook.notebook_folder = /tmp/pyramid_notebook

# Automatically shutdown IPython Notebook kernel
# after his many seconds have elapsed since startup
pyramid_notebook.kill_timeout = 3600

# Websocket proxy launch function.
# This is a view function that upgrades the current HTTP request to Websocket (101 upgrade protocol)
# and starts the web server websocket proxy loop. Currently only uWSGI supported
# (see below).
pyramid_notebook.websocket_proxy =

# For uWSGI in production
# pyramid_notebook.websocket_proxy = pyramid_notebook.uwsgi.serve_websocket

# If you need to server websockets from alternative domain (See below).
# Example value: https://ws.example.com
pyramid_notebook.alternative_domain =
</pre>
</div>
<div id="notebook-context-parameters">

<p>Notebooks can be opened with context sensitive parameters. Some are filled in by the framework, some of those you can set yourself.</p>
<ul>
<li>You pass in your Notebook context parameters when you call <tt>launch_notebook()</tt>.</li>
<li>To have custom context variables change <em>startup</em> script.</li>
<li>To have different info screen change <em>greeting</em> text</li>
</ul>
<p>Example of what context information you can pass below:</p>
<pre>{

    # Extra Python script executed on notebook startup - this is saved as startup.py
    "startup": ""

    # Markdown text displayed at the beginning of the notebook
    "greeting": ""

    # List of paths where to load IPython Notebook Jinja templates
    # http://ipython.org/ipython-doc/3/config/options/notebook.html
    "extra_template_paths": []

    # The port where Notebook daemon is supposed to start listening to
    "http_port",

    # Notebook daemon process id - filled it in by the daemon itself
    "pid",

    # Notebook daemon kill timeout in seconds - filled in by the the daemon itself after parsing command line arguments
    "kill_timeout",

    # Bound localhost port for this notebook - filled in by the daemon itself after parsing command line arguments
    "http_port",

    # Set Notebook HTTP Allow Origin header to tell where websockets are allowed to connect
    "allow_origin"

    # Override websocket URL
    "websocket_url",

    # Path in URL where Notebook is proxyed, must match notebook_proxy() view
    "notebook_path",

    # Hash of this context. This is generated automatically from supplied context dictionary if not given. If the hash changes the notebook is restarted with new context data.
    "context_hash",
}
</pre>
</div>
<div id="dead-man-switch">

<p>Launched Notebook processes have maximum life time after which they terminate themselves. Currently the termation is unconditional seconds since the start up, but in the future versions this is expected to change to a dead man switchs where the process only terminates itself if there has not been recent activity.</p>
</div>
<div id="websocket-proxying">

<p>IPython Notebook needs two different kind of connections to function properly</p>
<ul>
<li>HTTP connection for loading the pages, assets</li>
<li>Websocket for real-time communication with Notebook kernel</li>
</ul>
<p>When you run Pyramid’s <tt>pserve</tt> development server on your local machine and enter the Notebook shell, the websocket connection is made directly to IPython Notebook port bound localhost. This is because <tt>pserve</tt> does not have any kind of support for websockets. This behavior is controlled by <tt>pyramid_notebook.websocket_proxy</tt> setting.</p>
<p>On the production server, you usually run a web server which spawns processes to execute WSGI requests, the Python standard for hosting web applications. Unfortunately, like WSGI for HTTP, there doesn’t exist a standard for doing websocket requests in a Python application. Thus, one has to add support for websockets for each web server separately. Currently <em>pyramid_notebook</em> supports the following web servers</p>
<blockquote>

</blockquote>
<p>It is ok to have another web server at the front of uWSGI, like Nginx, as these web servers can usually do proxy pass for websocket connections. You might need to add following to your Nginx config:</p>
<pre># include a variable for the upgrade header
map $http_upgrade $connection_upgrade {
    default   upgrade;
    ''        close;
}

server {
    location / {
        include uwsgi_params;

        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
    }
}
</pre>
<div id="id1">

<p>To turn on websocket support on your uWSGI production server add following to your production INI settings:</p>
<pre>pyramid_notebook.websocket_proxy = pyramid_notebook.uwsgi.serve_websocket
</pre>
<p>Also you need to enable websockets in your uWSGI settings:</p>
<pre>http-websockets = true
</pre>
</div>
</div>
<div id="websocket-and-reverse-proxy-services">

<p>Reverse proxy services, like CloudFlare &lt;<a href="https://support.cloudflare.com/hc/en-us/articles/200169466-Can-I-use-CloudFlare-with-WebSockets-" rel="nofollow">https://support.cloudflare.com/hc/en-us/articles/200169466-Can-I-use-CloudFlare-with-WebSockets-</a>&gt;`_, might give only limited or no support for websockets. This may manifest itself in the form of <em>400 Bad Request</em> responses from the server because the reverse proxy service strips out <tt>Connection: Upgrade</tt> HTTP Request header. In this case it is recommended that you serve IPython Notebook from a separate domain where the websocket connection gets unhindered access to your server.</p>
<p>You need to</p>
<ul>
<li><p>Configure your naked web server to respond to an alternative domain name (<tt>ws.example.com</tt>).</p>
</li>
<li><p>Configure <tt>pyramid_notebook</tt> to rewrite notebook URLs to come from the alternative domain:</p>
<pre>pyramid_notebook.alternative_domain = https://ws.example.com
</pre>
</li>
<li><p>Pyramid <tt>AuthTktAuthenticationPolicy</tt>, by default, supports wildcard authentication cookies.</p>
</li>
<li><p>You can limit the naked domain to expose <tt>/notebook/</tt> URLs only.</p>
</li>
</ul>
</div>
</div>
<div id="architecture">

<p>Each Pyramid user has a named Notebook process. Each Notebook process gets their own working folder, dynamically created upon the first lanch. Notebooks are managed by <tt>NotebookManager</tt> class which detects changes in notebook context and restarts the Notebook process for the user with a new context if needed.</p>
<p>Notebook bind itselfs to localhost ports. Pyramid view proxyes <tt>/notebook/</tt> HTTP requests to Notebook and first checks the HTTP request has necessary permissions by performing authentication and authorization checks. The proxy view is also responsible for starting a web server specific websocket proxy loop.</p>
<p>Launched Notebook processes are daemonized and separated from the web server process. The communication between the web server and the daemon process happens through command line, PID file and context file (JSON dump of notebook context parameters, as described above).</p>


</div>
<div id="security">

<p>With great power comes great responsibility.</p>
<div>
<p>Note</p>
<p>Giving a user <em>pyramid_notebook</em> access is equal to giving him/her SSH access to a website UNIX user.</p>
</div>
<p><em>pyramid_notebook</em> relies on user authorization and authentication by Pyramid web framework. It is your site, so the authentication and authorization system is as good as you made it to be. If you do not feel comfortable exposing this much of power over website authentication, you can still have notebook sessions e.g. over SSH tunneling.</p>
<p>Below are some security matters you should consider.</p>
<div id="https-only">

<p><em>pyramid_notebook</em> accepts HTTPS connections only. HTTP connections are unencrypted and leaking information over HTTP could lead severe compromises.</p>
</div>
<div id="vpn-restrictions">

<p>You can configure your web server to allow access to <em>/notebook/</em> URLs from whitelisted IP networks only.</p>
</div>
<div id="access-restricted-servers">

<p>You do not need to run <em>pyramid_notebook</em> sessions on the main web servers. You can configure a server with limited data and code separately for running <em>pyramid_notebook</em>.</p>
<p>The access restricted server can have</p>
<ul>
<li>Read-only account on the database</li>
<li>Source code and configuration files containing sensitive secrets removed (HTTPS keys, API tokens, etc.)</li>
</ul>
</div>
<div id="linux-containerization">

<p>Notebook process can be made to start inside Linux container. Thus, it would still run on the same server, but you can limit the access to file system and network by the kernel. <a href="http://en.wikipedia.org/wiki/Cgroups" rel="nofollow">Read more about Linux cgroups</a>.</p>
</div>

</div>
<div id="troubleshooting">

<div id="taking-down-loose-notebooks">

<p>In the case the notebook daemon processes get stuck, e.g. by user starting a infinite loop and do not terminate properly, you can take them down.</p>
<ul>
<li><p>Any time you launch a notebook with different context (different parameters) for the user, the prior notebook process gets terminated forcefully</p>
</li>
<li><p>You can manually terminate all notebook processes. Ex:</p>
<pre>pkill -f notebook_daemon.py
</pre>
</li>
</ul>
</div>
<div id="crashing-notebooks">

<p>The following are indication of crashed Notebook process.
The following page on Notebook when you try try to start Notebook through web:</p>
<blockquote>
Apparently IPython Notebook daemon process is not running for user</blockquote>
<p>… or the IPython Notebook dialog <em>Connecting failed</em> and connecting to kernel does not work.</p>
<p>Notebook has most likely died because of Python exception. There exists a file <tt>notebook.stderr.log</tt>, one per each user, where you should be able to read traceback what happened.</p>
</div>
<div id="debugging-notebook-daemon">

<p>The notebook daemon can be started from a command line and supports normal UNIX daemon <tt>start</tt>, <tt>stop</tt> and <tt>fg</tt> commands. You need to give mandatory pid file, working folder, HTTP port and kill timeout arguments.</p>
<p>Example how to start Notebook daemon manually:</p>
<pre>python $SOMEWHERE/pyramid_notebook/server/notebook_daemon.py fg /tmp/pyramid_notebook/$USER/notebook.pid /tmp/pyramid_notebook/$USER 8899 3600
</pre>
</div>
<div id="seeing-startup-script-exceptions">

<p>If the startup script does not populate your Notebook with default variables as you hope, you can always do</p>
<ul>
<li><tt><span class="pre">print(locals())</span></tt> to see what local variables are set</li>
<li><tt><span class="pre">print(gocals())</span></tt> to see what global variables are set</li>
<li>Manually execute startup script inside IPython Notebook, e.g. <tt><span class="pre">exec(open("/private/tmp/pyramid_notebook/YOURUSERNAMEHERE/.ipython/profile_default/startup/startup.py").read())</span></tt></li>
</ul>
</div>
</div>
<div id="development">


<div id="tests">

<div>
<p>Note</p>
<p>Due to complexity of IPython Notebook interaction browser tests must be executed with full Firefox or Chrome driver.</p>
</div>
<p>Install test dependencies:</p>
<pre>pip install -e ".[test]"
</pre>
<p>Running tests:</p>
<pre>py.test tests --splinter-webdriver=chrome --splinter-make-screenshot-on-failure=false --ini=pyramid_notebook/demo/development.ini
</pre>
<p>Running a single test:</p>
<pre>py.test tests/* --splinter-webdriver=chrome --splinter-make-screenshot-on-failure=false --ini=pyramid_notebook/demo/development.ini -s -k test_notebook_template
</pre>
<p>Run full test coverage:</p>
<pre>py.test tests/* --cov pyramid_notebook --cov-report xml --splinter-webdriver=chrome --splinter-make-screenshot-on-failure=false --ini=pyramid_notebook/demo/development.ini -s -k test_notebook_template
</pre>
<p>Running uWSGI server with websockets:</p>
<pre>uwsgi --virtualenv=venv --wsgi-file=pyramid_notebook/demo/wsgi.py --pythonpath=venv/bin/python uwsgi.ini
</pre>
<p>Running uWSGI under Nginx for manual websocket proxy testing (OSX):</p>
<pre>pkill nginx ; nginx -c `pwd`/nginx.conf
uwsgi --virtualenv=venv --wsgi-file=pyramid_notebook/demo/wsgi.py --pythonpath=venv/bin/python uwsgi-under-nginx.ini
</pre>
<div>
<p>Note</p>
<p>Selenium Firefox has a bug which prevents typing ( on keyboard, preventing running tests on Firefox.</p>
</div>
<div id="manual-testing">

<p>You can manually launch the process to see any errors from IPython Notebook start.</p>
<p>Run <tt>test_start_stop</tt> test and capture log output in stdout:</p>
<pre>py.test tests --splinter-webdriver=chrome --splinter-make-screenshot-on-failure=false --ini=pyramid_notebook/demo/development.ini -k test_start_stop
...
INFO:pyramid_notebook.notebookmanager:Running notebook command: /Users/mikko/code/trees/venv/bin/python3.4 /Users/mikko/code/trees/pyramid_notebook/pyramid_notebook/server/notebook_daemon.py start /tmp/pyramid_notebook_tests/testuser1/notebook.pid /tmp/pyramid_notebook_tests/testuser1 40007 60
</pre>
<p>You can:</p>
<pre>/Users/mikko/code/trees/venv/bin/python3.4 /Users/mikko/code/trees/pyramid_notebook/pyramid_notebook/server/notebook_daemon.py start /tmp/pyramid_notebook_tests/testuser1/notebook.pid /tmp/pyramid_notebook_tests/testuser1 40005 60
</pre>
</div>
</div>

</div>
</div></body></html>