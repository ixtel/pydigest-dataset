<html><body><div><div class="content html_format"><p>
      В последние годы REST (REpresentational State Transfer) стала стандартной архитектурой при дизайне веб-сервисов и веб-API.</p>
<p>
В этой статье я покажу вам как просто создавать RESTful веб-сервисы используя Python и микрофреймворк Flask.

</p><h2>Что такое REST?</h2><p>
Характеристика системы REST определяется шестью правилами дизайна:

</p><ul>
<li><strong>Клиент-Сервер</strong>: Должно быть разделение между сервером, который предлагает сервис и клиентом, который использует ее.</li>
<li><strong>Stateless</strong>: Каждый запрос от клиента должен содержать всю информацию, необходимую серверу для выполнения запроса. Другими словами, сервер не обязан сохранять информацию о состоянии клиента.</li>
<li><strong>Кэширование</strong>: В каждом запросе клиента должно явно содержаться указание о возможности кэширования ответа и получения ответа из существующего кэша.</li>
<li><strong>Уровневая система</strong>: Клиент может взаимодействовать не напрямую с сервером, а с произвольным количеством промежуточных узлов. При этом клиент может не знать о существовании промежуточных узлов, за исключением случаев передачи конфиденциальной информации.</li>
<li><strong>Унификация</strong>: Унифицированный программный интерфейс сервера.</li>
<li><strong>Код по запросу</strong>: Сервера могут поставлять исполняемый код или скрипты для выполнения их на стороне клиентов.</li>
</ul>
<a name="habracut"/>
<h2>Что такое RESTful веб-сервис?</h2><p>
Архитектура REST разработана чтобы соответствовать </p><a href="http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">протоколу HTTP</a><p> используемому в сети Интернет.</p><p>
Центральное место в концепции RESTful веб-сервисов это понятие ресурсов. Ресурсы представлены </p><a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URI</a><p>. Клиенты отправляют запросы к этим URI используя методы представленные протоколом HTTP, и, возможно, изменяют состояние этих ресурсов.</p><p>
Методы HTTP спроектированы для воздействия на ресурс стандартным способом:
</p>
<p>
Дизайн REST не дает рекомендаций каким конкретно должен быть формат данных передаваемых с запросами. Данные переданные в теле запроса могут быть </p><a href="http://en.wikipedia.org/wiki/JSON">JSON</a><p> blob, или с помощью аргументов в URL.

</p><h2>Проектируем простой веб-сервис</h2><p>
При проектировании веб-сервиса или API нужно определить ресурсы, которые будут доступны и запросы, с помощью которых эти данные будут доступны, согласно правил REST.</p><p>
Допустим мы хотим написать приложение To Do List и мы должны спроектировать веб-сервис для него. Первое что мы должны сделать, это придумать кореневой URL для доступа к этому сервису. Например мы могли бы придумать в качестве корневого URL что-то типа:
</p><pre><code class="bash">http://[hostname]/todo/api/v1.0/</code></pre><p>
Здесь я решил включить в URL имя приложения и версию API. Добавление имени приложения в URL это хороший способ разделить между собой сервисы запущенные на одном сервере. Добавление версии API в URL может помочь, если вы захотите сделать обновление в будущем и внедрить в новой версии несовместимые функции и не хотите ломать работающие приложения которые работают на старом API.</p><p>
Следующим шагом мы должны выбрать ресурсы, которые будут доступны через наш сервис. У нас очень простое приложение, у нас есть только задачи, поэтому нашими ресурсами могут быть только задачи из нашего ToDo листа.</p><p>
Для доступа к ресурсам будем использовать следующие методы HTTP:
</p><table>
<tbody>
<tr>
<th>Метод HTTP</th>
<th>URI</th>
<th>Действие</th>
</tr>
<tr>
<td>GET</td>
<td>http://[hostname]/todo/api/v1.0/tasks</td>
<td>Получить список задач</td>
</tr>
<tr>
<td>GET</td>
<td>http://[hostname]/todo/api/v1.0/tasks/[task_id]</td>
<td>Получить задачу</td>
</tr>
<tr>
<td>POST</td>
<td>http://[hostname]/todo/api/v1.0/tasks</td>
<td>Создать новую задачу</td>
</tr>
<tr>
<td>PUT</td>
<td>http://[hostname]/todo/api/v1.0/tasks/[task_id]</td>
<td>Обновить существующую задачу</td>
</tr>
<tr>
<td>DELETE</td>
<td>http://[hostname]/todo/api/v1.0/tasks/[task_id]</td>
<td>Удалить задачу</td>
</tr>
</tbody>
</table>
<p>
Наша задача будет иметь следующие поля:
</p><ul>
<li><strong>id</strong>: уникальный идентификатор задачи. Тип Numeric.</li>
<li><strong>title</strong>: Краткое описание задачи. Тип String.</li>
<li><strong>description</strong>: подробное описание задачи. Тип Text.</li>
<li><strong>done</strong>: отметка о выполнении. Тип Boolean.</li>
</ul>
<p>
На этом мы заканчиваем часть посвященную дизайну нашего сервиса. Осталось только реализовать это!

</p><h2>Краткое введение в микрофреймворк Flask</h2><p>
Если вы читали серию </p><a href="http://habrahabr.ru/post/193242/">Мега-Учебник Flask</a><p>, вы знаете что Flask это простой и достаточно мощный веб-фреймворк на Python.</p><p>
Прежде чем мы углубимся в специфику веб-сервисов, давайте рассмотрим как обычно реализованы приложения Flask.</p><p>
Я предполагаю, что вы знакомы с основами работы с Python на вашей платформе. В примерах я буду использовать Unix-подобную операционную систему. Короче говоря, это озночает, что они будут работать на Linux, MacOS X и даже на Windows, если вы будете использовать </p><a href="http://www.cygwin.com/">Cygwin</a><p>. Команды будут несколько отличаться, если вы будете использовать нативную версию Python для Windows.
</p><p>
Для начала установим Flask в виртуальном окружении. Если в вашей системе не установлен </p><code>virtualenv</code><p>, вы можете загрузить его из </p><a href="https://pypi.python.org/pypi/virtualenv">https://pypi.python.org/pypi/virtualenv</a><p>.
</p><pre><code class="bash">
$ mkdir todo-api
$ cd todo-api
$ virtualenv flask
New python executable in flask/bin/python
Installing setuptools............................done.
Installing pip...................done.
$ flask/bin/pip install flask
</code></pre>
<p>
Теперь, когда Flask установлен давайте создадим простое веб приложение, для этого поместим следующий код в </p><code>app.py</code><p>:
</p><pre><code class="python">#!flask/bin/python
from flask import Flask

app = Flask(__name__)

@app.route('/')
def index():
    return "Hello, World!"

if __name__ == '__main__':
    app.run(debug=True)
</code></pre>
<p>
Чтобы запустить приложение, мы должны запустить </p><code>app.py</code><p>:
</p><pre><code class="bash">
$ chmod a+x app.py
$ ./app.py
 * Running on http://127.0.0.1:5000/
 * Restarting with reloader
</code></pre>
<p>
Теперь вы можете запустить веб-браузер из набрать </p><code><a href="http://localhost"/>localhost:5000</code><p> чтобы увидеть наше маленькое приложение в действии.</p><p>
Просто, не так ли? Теперь мы будем конвертировать наше приложение в RESTful сервис!

</p><h2>Реализация RESTful сервиса на Python и Flask</h2><p>
Создание веб-сервиса на Flask удивительно просто, гораздо проще, чем строить полноценные серверные приложения, вроде того, которое мы делали в серии </p><a href="http://habrahabr.ru/post/193242/">Мега-Туториал</a><p>.</p><p>
Есть пара хороших расширений для Flask, которые могут облегчить создание RESTful сервисов, но наша задача настолько просто, что использование расширений будет излишним.</p><p>
Клиенты нашего веб-сервиса будут просить сервис добавлять, удалять и модифицировать задачи, поэтому нам нужен простой способ хранить задачи. Очевидный способ сделать это — сделать небольшую базу данных, но, поскольку база данных выходи за рамки темы статьи, мы сделаем всё гораздо проще. Чтобы больше узнать о правильном использовании БД с Flask я снова рекомендую почитать мой </p><a href="http://habrahabr.ru/post/193242/">Мега-Туториал</a><p>.
</p><p>
Вместо базы данных мы будем хранить список наших задач в памяти. Это сработает, только если мы будем работать с сервером в один поток и в один процесс. Хоть для development-сервера это нормально, то для production-сервера это будет очень плохой идеей и будет лучше подумать об использовании базы данных.</p><p>
Сейчас мы готовы реализовать первую точку входа в наш веб-сервис:
</p><pre><code class="python">#!flask/bin/python
from flask import Flask, jsonify

app = Flask(__name__)

tasks = [
    {
        'id': 1,
        'title': u'Buy groceries',
        'description': u'Milk, Cheese, Pizza, Fruit, Tylenol', 
        'done': False
    },
    {
        'id': 2,
        'title': u'Learn Python',
        'description': u'Need to find a good Python tutorial on the web', 
        'done': False
    }
]

@app.route('/todo/api/v1.0/tasks', methods=['GET'])
def get_tasks():
    return jsonify({'tasks': tasks})

if __name__ == '__main__':
    app.run(debug=True)
</code></pre>
<p>
Как вы можете видеть, изменилось немногое. Мы создали в памяти задачи, которые являются не более чем простым массивом словарей. Каждая запись в массиве имеет все поля, которые мы определили выше для наших задач.</p><p>
Вместо того, чтобы использовать точку входа </p><code>index</code><p>, у нас теперь есть функция </p><code>get_tasks</code><p> связанная с URI </p><code>/todo/api/v1.0/tasks</code><p>, для HTTP метода </p><code>GET</code><p>.</p><p>
Вместо текста наша функция отдает JSON, в который Flask с помощью метода </p><code>jsonify</code><p> кодирует нашу структуру данных.</p><p>
Использование веб-браузера, для тестирования веб-сервиса, не самая лучшая идея, т.к. с помощью веб-браузера не так просто генерировать все типы HTTP-запросов. Вместо этого мы будем использовать </p><a href="http://curl.haxx.se/">curl</a><p>. Если </p><code>curl</code><p> у вас не установлен, лучше сделать это прямо сейчас.</p><p>
Запустите веб-сервис тем же самым путем, как и демонстрационное приложение, запустив </p><code>app.py</code><p>. Теперь откройте новое окно консоли и вводите следующие команды:
</p><pre><code class="bash">
$ curl -i http://localhost:5000/todo/api/v1.0/tasks
HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 294
Server: Werkzeug/0.8.3 Python/2.7.3
Date: Mon, 20 May 2013 04:53:53 GMT

{
  "tasks": [
    {
      "description": "Milk, Cheese, Pizza, Fruit, Tylenol",
      "done": false,
      "id": 1,
      "title": "Buy groceries"
    },
    {
      "description": "Need to find a good Python tutorial on the web",
      "done": false,
      "id": 2,
      "title": "Learn Python"
    }
  ]
}
</code></pre>
<p>
Мы просто вызвали функцию нашего RESTful сервиса!
</p><p>
Сейчас давайте напишем вторую версию метода GET для наших задач. Если вы взгляните на таблицу выше, то следующим будет метод, который возвращает данные из одной задачи:
</p><pre><code class="python">from flask import abort

@app.route('/todo/api/v1.0/tasks/&lt;int:task_id&gt;', methods=['GET'])
def get_task(task_id):
    task = filter(lambda t: t['id'] == task_id, tasks)
    if len(task) == 0:
        abort(404)
    return jsonify({'task': task[0]})
</code></pre>
<p>
Вторая функция немного интересней. Здесь мы передаем через URL id задачи, и с помощью Flask транслируем в аргумент функции </p><code>task_id</code><p>.</p><p>
С этим аргументом мы ищем нашу задачу в базе. Если полученный id не найдется в базе, мы вернем ошибку 404, которая по спецификации HTTP означает «Resource Not Found».</p><p>
Если задача будет найдена, мы просто упакуем ее в JSON с помощью функции </p><code>jsonify</code><p> и отправим как ответ, так же как поступали раньше, отправляя коллекцию.</p><p>
Вот так выглядит действие этой функции, когда мы вызываем ее с помощью </p><code>curl</code><p>:
</p><pre><code class="bash">
$ curl -i http://localhost:5000/todo/api/v1.0/tasks/2
HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 151
Server: Werkzeug/0.8.3 Python/2.7.3
Date: Mon, 20 May 2013 05:21:50 GMT

{
  "task": {
    "description": "Need to find a good Python tutorial on the web",
    "done": false,
    "id": 2,
    "title": "Learn Python"
  }
}
$ curl -i http://localhost:5000/todo/api/v1.0/tasks/3
HTTP/1.0 404 NOT FOUND
Content-Type: text/html
Content-Length: 238
Server: Werkzeug/0.8.3 Python/2.7.3
Date: Mon, 20 May 2013 05:21:52 GMT

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
&lt;title&gt;404 Not Found&lt;/title&gt;
&lt;h1&gt;Not Found&lt;/h1&gt;
&lt;p&gt;The requested URL was not found on the server.&lt;/p&gt;&lt;p&gt;If you     entered the URL manually please check your spelling and try again.&lt;/p&gt;
</code></pre>
<p>
Когда мы запросили ресурс с id #2 мы получили его, но вместо ресурса с id #3 мы получили ошибку 404. Такую странную ошибку внутри HTML вместо JSON мы получили, потому, что Flask по умолчанию генерирует страницу с ошибкой 404. Так как это клиентские приложения будут всегда ожидать он нашего сервера JSON, то нам нужно изменить это поведение:
</p><pre><code class="python">from flask import make_response

@app.errorhandler(404)
def not_found(error):
    return make_response(jsonify({'error': 'Not found'}), 404)
</code></pre>
<p>
Так мы получим более соответствующий нашему API ответ:
</p><pre><code class="bash">
$ curl -i http://localhost:5000/todo/api/v1.0/tasks/3
HTTP/1.0 404 NOT FOUND
Content-Type: application/json
Content-Length: 26
Server: Werkzeug/0.8.3 Python/2.7.3
Date: Mon, 20 May 2013 05:36:54 GMT

{
  "error": "Not found"
}
</code></pre>
<p>
Следующий в нашем списке метод </p><code>POST</code><p>, который мы будем использовать чтобы добавить новую задачу в нашу базу:
</p><pre><code class="python">from flask import request

@app.route('/todo/api/v1.0/tasks', methods=['POST'])
def create_task():
    if not request.json or not 'title' in request.json:
        abort(400)
    task = {
        'id': tasks[-1]['id'] + 1,
        'title': request.json['title'],
        'description': request.json.get('description', ""),
        'done': False
    }
    tasks.append(task)
    return jsonify({'task': task}), 201
</code></pre>
<p>
Добавление новой задачи тоже реализуется довольно просто. </p><code>request.json</code><p> содержит данные запроса, но только если они помечены как JSON. Если данных там нет, или данные на месте но отсутствует значение поля </p><code>title</code><p>, тогда возвращается код 400, который используется чтобы обозначить «Bad Request».</p><p>
Затем мы создаем словарь с новой задачей, используя id последней задачи плюс 1(простой способ гарантировать уникальность id в нашей простой базе). Мы терпим отсутствие значения в поле </p><code>description</code><p>, и мы предполагаем что поле </p><code>done</code><p> при создании задачи всегда будет </p><code>False</code><p>.
</p><p>
Мы добавляем новую задачу к нашему массиву </p><code>tasks</code><p>, затем возвращаем клиенту сохраненную задачу и код 201, который в HTTP означает «Created».</p><p>
Чтобы протестировать новую функцию мы используем следующую команду </p><code>curl</code><p>:
</p><pre><code class="bash">
$ curl -i -H "Content-Type: application/json" -X POST -d '{"title":"Read a book"}' http://localhost:5000/todo/api/v1.0/tasks
HTTP/1.0 201 Created
Content-Type: application/json
Content-Length: 104
Server: Werkzeug/0.8.3 Python/2.7.3
Date: Mon, 20 May 2013 05:56:21 GMT

{
  "task": {
    "description": "",
    "done": false,
    "id": 3,
    "title": "Read a book"
  }
}
</code></pre>
<p>
Примечание: если у вас Windows и вы используете Cygwin версию </p><code>curl</code><p> из </p><code>bash</code><p> тогда вышеописанная команда сработает как надо. Если вы используете нативную версию </p><code>curl</code><p> из обычно командной строки, то придется немного подшаманить с двойными кавычками:
</p><pre><code class="bash">
curl -i -H "Content-Type: application/json" -X POST -d "{"""title""":"""Read a book"""}" http://localhost:5000/todo/api/v1.0/tasks
</code></pre>
<p>
В Windows вы используете двойные кавычки чтобы отделить тело запроса, и внутри запроса двойные кавычки чтобы экранировать третю кавычку.</p><p>
Конечно, после выполнения этого запроса мы можем получим обновленный список задач:
</p><pre><code class="bash">
$ curl -i http://localhost:5000/todo/api/v1.0/tasks
HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 423
Server: Werkzeug/0.8.3 Python/2.7.3
Date: Mon, 20 May 2013 05:57:44 GMT

{
  "tasks": [
    {
      "description": "Milk, Cheese, Pizza, Fruit, Tylenol",
      "done": false,
      "id": 1,
      "title": "Buy groceries"
    },
    {
      "description": "Need to find a good Python tutorial on the web",
      "done": false,
      "id": 2,
      "title": "Learn Python"
    },
    {
      "description": "",
      "done": false,
      "id": 3,
      "title": "Read a book"
    }
  ]
}
</code></pre>
<p>
Оставшиеся две функции нашего веб-сервиса будут выглядеть так:
</p><pre><code class="python">@app.route('/todo/api/v1.0/tasks/&lt;int:task_id&gt;', methods=['PUT'])
def update_task(task_id):
    task = filter(lambda t: t['id'] == task_id, tasks)
    if len(task) == 0:
        abort(404)
    if not request.json:
        abort(400)
    if 'title' in request.json and type(request.json['title']) != unicode:
        abort(400)
    if 'description' in request.json and type(request.json['description']) is not unicode:
        abort(400)
    if 'done' in request.json and type(request.json['done']) is not bool:
        abort(400)
    task[0]['title'] = request.json.get('title', task[0]['title'])
    task[0]['description'] = request.json.get('description', task[0]['description'])
    task[0]['done'] = request.json.get('done', task[0]['done'])
    return jsonify({'task': task[0]})

@app.route('/todo/api/v1.0/tasks/&lt;int:task_id&gt;', methods=['DELETE'])
def delete_task(task_id):
    task = filter(lambda t: t['id'] == task_id, tasks)
    if len(task) == 0:
        abort(404)
    tasks.remove(task[0])
    return jsonify({'result': True})
</code></pre>
<p>
Функция </p><code>delete_task</code><p> без сюрпризов. Для функции </p><code>update_task</code><p> мы стараемся предотвратить ошибки делая тщательную проверку входных аргументов. Мы должны убедиться, что предоставленные клиентом данные в надлежащем формате, прежде чем запишем их в базу.
</p><p>
Вызов функци обновляющей задачу с id #2 будет выглядеть примерно так:
</p><pre><code class="bash">
$ curl -i -H "Content-Type: application/json" -X PUT -d '{"done":true}' http://localhost:5000/todo/api/v1.0/tasks/2
HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 170
Server: Werkzeug/0.8.3 Python/2.7.3
Date: Mon, 20 May 2013 07:10:16 GMT

{
  "task": [
    {
      "description": "Need to find a good Python tutorial on the web",
      "done": true,
      "id": 2,
      "title": "Learn Python"
    }
  ]
}
</code></pre>

<h2>Улучшаем интерфейс нашего сервиса</h2><p>
Сейчас основная проблема дизайна нашего сервиса в том, что клиенты вынуждены строить URI самостоятельно исходя из ID задач. Этот легко, но дает знание клиенту как строятся URI для доступа к данным, что может помешать в будущем, если мы захотим внести изменения в URI.</p><p>
Вместо id задачи мы вернем полный URI, через который будет осуществляться выполнение всех действий с задачей. Для этого мы напишем маленькую функцию-хелпер, которая будет генерировать «публичную» версию задачи, отправляемую клиенту:
</p><pre><code class="python">from flask import url_for

def make_public_task(task):
    new_task = {}
    for field in task:
        if field == 'id':
            new_task['uri'] = url_for('get_task', task_id=task['id'], _external=True)
        else:
            new_task[field] = task[field]
    return new_task
</code></pre>
<p>
Все что мы делаем здесь это берем задачу из нашей базы данных и создаем новую задачу в которой все поля идентичны, за исключением поля </p><code>id</code><p>, которое заменено полем </p><code>uri</code><p>, сгенерированным функцией </p><code>url_for</code><p> предоставляемой Flask.</p><p>
Когда мы возвращаем список задач мы прогоняем все задачи через эту функцию, прежде чем отослать клиенту:
</p><pre><code class="python">@app.route('/todo/api/v1.0/tasks', methods=['GET'])
def get_tasks():
    return jsonify({'tasks': map(make_public_task, tasks)})
</code></pre>
<p>
Теперь клиент получает вот такой список задач:
</p><pre><code class="bash">
$ curl -i http://localhost:5000/todo/api/v1.0/tasks
HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 406
Server: Werkzeug/0.8.3 Python/2.7.3
Date: Mon, 20 May 2013 18:16:28 GMT

{
  "tasks": [
    {
      "title": "Buy groceries",
      "done": false,
      "description": "Milk, Cheese, Pizza, Fruit, Tylenol",
      "uri": "http://localhost:5000/todo/api/v1.0/tasks/1"
    },
    {
      "title": "Learn Python",
      "done": false,
      "description": "Need to find a good Python tutorial on the web",
      "uri": "http://localhost:5000/todo/api/v1.0/tasks/2"
    }
  ]
}
</code></pre>
<p>
Применив эту технику к остальным функциям мы сможем гарантировать, что клиент всегда получит URI, вместо id.
</p><h2>Защита RESTful веб-сервиса</h2><p>
Вы думали мы уже закончили? Конечно, мы закончили с функциональностью нашего сервиса, но у нас есть проблема. Наш сервис открыт для всех, а это не очень хорошо.</p><p>
У нас есть законченый веб-сервис, который управляет нашим списком дел, но сервис, в текущем его состоянии, доступен каждому. Если незнакомец выяснит как работает наше API он или она может написать новый клиент и навести беспорядок в наших данных.</p><p>
Многие руководства для начинающих игнорируют безопасность и заканчиваются здесь. По-моему это серьезная проблема, которая всегда должна быть решена.</p><p>
Простой путь защитить наш веб-сервис это пускать клиентов после авторизации по логину и паролю. В обычном веб-приложении вы должны сделать форму логина, которая отправляет данные авторизации, сервер обрабатывает их и делает новую сессию, а браузер пользователя получает куки с идентификатором сессии. К сожаление здесь мы такое сделать не можем, </p><b>stateless</b><p> — одно из правил построения REST веб-сервисов и мы должны просить клиентов отправлять свои регистрационные данные при каждом запросе.</p><p>
С REST мы всегда стараемся придерживаться протокола HTTP настолько, насколько сможем. Сейчас нам нужно реализовать аутентификацию пользователя в контексте HTTP, который предоставляет нам 2 варианта — </p><a href="http://en.wikipedia.org/wiki/Basic_access_authentication">Basic</a><p> и </p><a href="http://en.wikipedia.org/wiki/Digest_access_authentication">Digest</a><p>.
</p><p>
Существует маленькое расширение Flask написанное вашим покорным слугой. Давайте установим </p><a href="https://github.com/miguelgrinberg/flask-httpauth">Flask-HTTPAuth</a><p>:
</p><pre><code class="bash">
$ flask/bin/pip install flask-httpauth
</code></pre>
<p>
Теперь скажем нашего веб-сервису отдавать данные только пользователю с логином </p><code>miguel</code><p> и паролем </p><code>python</code><p>. Для начала настроим Basic HTTP authentication как показано ниже:
</p><pre><code class="python">from flask.ext.httpauth import HTTPBasicAuth
auth = HTTPBasicAuth()

@auth.get_password
def get_password(username):
    if username == 'miguel':
        return 'python'
    return None

@auth.error_handler
def unauthorized():
    return make_response(jsonify({'error': 'Unauthorized access'}), 401)
</code></pre>
<p>
Функция </p><code>get_password</code><p> будет по имени пользователя возвращать пароль. В более сложных системах такая функцию должна будет лезть в базу, но для одного пользователя это не обязательно.</p><p>
Функция </p><code>error_handler</code><p> будет использоваться чтобы отправить ошибку авторизации, при неправильных данных. Так же как мы поступили с другими ошибками мы должны настроить функцию на отправку JSON, вместо HTML.
</p><p>
После настройки системы аутентификаци, осталось только добавить декоратор</p><code>@auth.login_required</code><p> для всех функций, которые должны быть защищены. Например:
</p><pre><code class="python">@app.route('/todo/api/v1.0/tasks', methods=['GET'])
@auth.login_required
def get_tasks():
    return jsonify({'tasks': tasks})
</code></pre>
<p>
Если мы попробуем запросить эту функцию с помощью </p><code>curl</code><p> мы получим примерно следующее:
</p><pre><code class="bash">
$ curl -i http://localhost:5000/todo/api/v1.0/tasks
HTTP/1.0 401 UNAUTHORIZED
Content-Type: application/json
Content-Length: 36
WWW-Authenticate: Basic realm="Authentication Required"
Server: Werkzeug/0.8.3 Python/2.7.3
Date: Mon, 20 May 2013 06:41:14 GMT

{
  "error": "Unauthorized access"
}
</code></pre>
<p>
Для того, чтобы вызвать эту функцию, мы должны подтвердить наши полномочия:
</p><pre><code class="bash">
$ curl -u miguel:python -i http://localhost:5000/todo/api/v1.0/tasks
HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 316
Server: Werkzeug/0.8.3 Python/2.7.3
Date: Mon, 20 May 2013 06:46:45 GMT

{
  "tasks": [
    {
      "title": "Buy groceries",
      "done": false,
      "description": "Milk, Cheese, Pizza, Fruit, Tylenol",
      "uri": "http://localhost:5000/todo/api/v1.0/tasks/1"
    },
    {
      "title": "Learn Python",
      "done": false,
      "description": "Need to find a good Python tutorial on the web",
      "uri": "http://localhost:5000/todo/api/v1.0/tasks/2"
    }
  ]
}
</code></pre>
<p>
Расширение с аутентификацией дает нам свободу выбирать какие функции будут в общем доступе, а какие защищены.</p><p>
Для защиты регистрационной информации наш веб-сервис должен быть доступен через HTTP Secure server ( ...) который шифрует траффик между клиентом и сервером и предотвращает получение конфиденциальной информаци третьей стороной.</p><p>
К сожалению веб-браузеры имеют дурную привычку показывать страшное диалоговое окно, когда запрос возвращается с ошибкой 401. Это происходит даже для фоновых запросов, так что если бы мы реализовали клиента для веб-браузера, нам пришлось бы прыгать через обручи, чтобы не давать браузеру показывать свои окна.</p><p>
Простой путь обмануть браузер — возвращать любой другой код, вместо 401. Любимая всеми альтернатива это код 403, который означает ошибку «Forbidden». Хоть это достаточно близкая по смыслу ошибка, это нарушает стандарт HTTP, так что это неправильно. В частности будет хорошим решением не использовать веб-браузер в качестве клиентского приложения. Но в случаях, когда сервер и клиент разрабатываются совместно это спасает от многих неприятностей. Чтобы провернуть этот трюк нам нужно просто заменить код ошибки с 401 на 403:
</p><pre><code class="python">@auth.error_handler
def unauthorized():
    return make_response(jsonify({'error': 'Unauthorized access'}), 403)
</code></pre>
<p>
В клиентском приложении нужно тоже отлавливать ошибку 403.
</p><h2>Возможные улучшения</h2><p>
Есть несколько возможностей улучшить разработанный нами сегодня веб-сервис.</p><p>
Для начала, настоящий веб-сервис должен общаться с настоящей базой данных. Структура данных в памяти очень ограниченный способ хранения данных и он не должен использоваться в реальных приложениях.</p><p>
Другой способ улучшить приложение это поддержка нескольких пользователей. Если система поддерживает несколько пользователей, то данные аутентификации могут использоваться чтобы возвращать персональные списки пользователям. В такой системе пользователи станут вторым ресурсом. Запрос </p><code>POST</code><p> будет регистрировать нового пользователя в системе. Запрос </p><code>GET</code><p> может возвращать информацию о пользователе. Запрос </p><code>PUT</code><p> может обновлять информацию о пользователе, например email. Запрос </p><code>DELETE</code><p> будет удалять пользователя из системы.</p><p>
Запрос </p><code>GET</code><p>, который возвращает список задач, может быть расширен несколькими способами. Для начала это запрос может иметь опциональные агрументы, такие как количество задач на страницу. Другой путь сделать функцию более удобной это добавить критерии фильтрации. Например клиент может запросить только выполненые задачии или задачи, заголовок которых начинается с определенной буквы. Все эти элементы могут быть добавлены в URL как аргументы.
</p><h2>Вывод</h2><p>
Законченый код для веб-сервиса To Do List вы можете взять здесь: </p><a href="https://gist.github.com/miguelgrinberg/5614326">https://gist.github.com/miguelgrinberg/5614326</a><p>.</p><p>
Я верю что это было простое и дружелюбное введение в RESTful API. Если есть достаточный инетерес я мог бы написать вторую часть этой статьи, в которой мы разработаем простой веб-клиент для нашего сервиса.</p><p>
Я сделал клиента для нашего сервиса:</p><a href="http://blog.miguelgrinberg.com/post/writing-a-javascript-rest-client">Writing a Javascript REST client</a><p>.</p><p>
Статья о таком же сервере, но с использованием Flask-RESTful</p><a href="http://blog.miguelgrinberg.com/post/designing-a-restful-api-using-flask-restful">Designing a RESTful API using Flask-RESTful</a><p>.</p><p>
Miguel
      </p><p class="clear"/>
    </div>

    
  </div></body></html>