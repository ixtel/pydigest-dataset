<html><body><div><div id="gt-res-content">
<p dir="ltr"/>
<h3 dir="ltr"><strong>Flask</strong></h3>
<div dir="ltr">
<ol>
<li><span><span>Firstly, simple model of Member based on SQLAlchemy:<br/>
</span></span>
<pre class="brush: python; title: ; notranslate" title="">
from sqlalchemy import Column, Integer, String
from newsletter.database import Base
class Member(Base):
   __tablename__ = 'newsletter_members'
   id = Column(Integer, primary_key=True)
   last_name = Column(String(50))
   first_name = Column(String(120))
   email = Column(String(120), unique=True)

   def __init__(self, last_name=None, first_name=None, email=None):
      self.last_name = last_name
      self.first_name = first_name
      self.email = email

   def __repr__(self):
      return '%s' % (self.last_name)
</pre>
</li>
<li>Method to handle the APIs requests:
<pre class="brush: python; title: ; notranslate" title="">
from flask.views import MethodView

class API(MethodView):
   def get(self, member_id):
       if member_id is None:
           return Member.query.all()
       else:
           return Member.query.filter_by(id = member_id).first()

   def post(self, data ):
       member = Member(first_name = data['first_name'], email=data['email'])
       db.session.add(member)
       db.session.commit()
       return 'OK'

app.add_url_rule('/users/&lt;int:user_id&gt;', view_func=API.as_view('user_api'), methods=['GET', 'POST'])
</pre>
<p>Class MethodView is recognizing each REST methods based on generic dispatch request method.<br/>
It was simple and quick, but we can tune this.</p></li>
<li>17 lines source code of full application, 4 lines for configuration, 2 lines implementing RESTful API and the same result like solution above:
<pre class="brush: python; title: ; notranslate" title="">
import flask
import flask.ext.sqlalchemy
import flask.ext.restless

app = flask.Flask(__name__)
app.config['DEBUG'] = True
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/test.db'
db = flask.ext.sqlalchemy.SQLAlchemy(app)

class Member(db.Model):
    __tablename__ = 'newsletter_members'
    id = db.Column(Integer, primary_key=True)
    last_name = db.Column(String(50))
    first_name = db.Column(String(120))
    email = db.Column(String(120), unique=True)

db.create_all()
manager = flask.ext.restless.APIManager(app, flask_sqlalchemy_db=db)
manager.create_api(Member, methods=['GET', 'POST'])
app.run()
</pre>
</li>
</ol>
</div>
<h3><strong>More features Flask RESTless library</strong></h3>
<p><strong/>Scripts above was amazing huh? But the main concern is how it works in real project with more requirements and development is dictated by real needs no pretty theory..</p>
<p dir="ltr">The following features are useful in real cases:</p>
<div dir="ltr">
<ol>
<li>versioning:
<pre class="brush: python; title: ; notranslate" title="">
apimanager.create_api(Member, url_prefix='/api/v2')
GET /api/v2/members/
</pre>
</li>
<li>validation:
<pre class="brush: python; title: ; notranslate" title="">
manager.create_api(Member, methods=['GET', 'POST'], validation_exceptions=[ValidationError])
</pre>
<p>Example result:</p>
<pre class="brush: jscript; title: ; notranslate" title="">
{ "validation_errors":
  {"email": "Email is not valid.."}
}
</pre>
</li>
<li>specifiy data to REST methods, including/excluding fields of models:
<pre class="brush: python; title: ; notranslate" title="">
manager.create_api(Member, include_columns = ['last_name', 'email'])
</pre>
</li>
<li>pagination:
<pre class="brush: python; title: ; notranslate" title="">
manager.create_api(Member, methods=['GET', 'POST'], results_per_page=2)
</pre>
<p>Example result:</p>
<pre class="brush: jscript; title: ; notranslate" title="">
{ "validation_errors":
  {
    "age": "Must be an integer",
  }
{
  "num_results": 6,
  "total_pages": 3,
  "page": 1,
  "objects": [
    {"last_name": "Kovalsky", "email": "kovalsky@gmail.com", "id": 1},
{"last_name": "Novak", "email": "novak@gmail.com", "id": 2}
  ]
}
</pre>
</li>
<li>pre/post proccessors:
<pre class="brush: python; title: ; notranslate" title="">
def pre_get_single(instid):
    # do something with single object
    pass

def pre_get_many(params):
    # do something with many objects
    pass

# Create an API for the Member model.
manager.create_api(Person, methods=['GET', 'POST'],
preprocessors={'GET_SINGLE': [pre_get_single], 'GET_MANY': [pre_get_many],})
</pre>
</li>
<li>authentication:
<pre class="brush: python; title: ; notranslate" title="">
def auth_func(params):
    if not current_user.is_authenticated():
        raise ProcessingException(message='Not authenticated!')
    return NO_CHANGE
manager.create_api(Person, preprocessors={'GET_SINGLE': [auth_func]})
</pre>
</li>
<li>filtering:<br/>
example request URL:
<pre class="brush: jscript; title: ; notranslate" title="">
GET /api/member?q={"filters":[{"name":"email", "op":"like", "val": "kovalsky"}]}</pre>
</li>
</ol>
</div>
<p dir="ltr">In conclusion using micro framework <strong>Flask with RESTless</strong> library is good combination. Our company have experience with Flask based REST and <strong>it’s very convenient solutions to existing applications</strong>.</p>
<p dir="ltr">Assuming that app architecture where Flask responsible for API, Django app for web user interface, iOS and Android app for mobile interactions, we can say more about Flask advantages:</p>
<div dir="ltr">
<ul>
<li>very good <strong>performance</strong>,</li>
<li>simple and fast prototyping and <strong>extensions</strong> of API,</li>
<li><strong>separation</strong> API server from Django web application,</li>
<li><strong>simple to learn</strong> for uninitiated in Flask development,</li>
<li>working with <strong>gunicorn</strong> (it possible to have Django and Flask on one server),</li>
<li>as default is SQLAlchemy ORM.</li>
</ul>
<p>Disadvantages are:</p>
<ul>
<li>distributed documentation of Flask (many, many plugins),</li>
<li>more efford is needed to logic structure of application,</li>
<li><span>lack of automatically generated admin panel which is very useful for filtering results and generating raports,</span></li>
<li>no possibilities to use helpers methods and libraries written to handle some buissness logic from Django.</li>
</ul>
<p><strong>What about Django REST solutions?</strong><br/>
It’s many available libraries for REST like: <strong>django-rest-framework</strong>, django-tastypie, django-piston (not maintained already) and more. I focuse on the first solution, because it’s based on <strong>good patterns</strong>, very good <strong>maintained</strong>, with quick <strong>support</strong>, <strong>documentation</strong> on good level and reasonable approach.</p>
<p>On the beginning few words of explanation are needed. Name of<strong> django-rest-framework</strong> is dictated by the ability to quickly and easy find for developers. But.. it’s not correct terminology, because this library is based on wider concept than REST – <strong>Hypermedia driven APIs</strong>. I skip definition in this blog entry, but more information you can find <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">here</a> and also in books.<br/>
<span>Django-rest-framework provide tool to design and develop <strong>browsable APIs based on HTML</strong>. </span></p>
<p>Django-rest-framework is very advanced tools and below you can find only <span>the most basic and simple realization</span> of the defined problem in 4 quick steps:</p>
<ol>
<li>Model definition:
<pre class="brush: python; title: ; notranslate" title="">
from django.db import models

class Member(models.Model):
    last_name = models.CharField(max_length = 100, verbose_name = "Last name")
    first_name = models.CharField(max_length = 100, verbose_name = "First name")
    email = models.EmailField(max_length = 100, verbose_name = "Email")

    def __unicode__(self):
        return self.email

    class Meta:
        verbose_name = "Newsletter member"
        verbose_name_plural = "Newsletter members"
</pre>
</li>
<li>Serializer – class describing rules for model and how should it be represented in API:
<pre class="brush: python; title: ; notranslate" title="">
class MemberSerializer(serializers.ModelSerializer):

    class Meta:
        model = Member
        fields = ('last_name', 'first_name', 'email')
</pre>
</li>
<li>View on Class Based Views architecture:
<pre class="brush: python; title: ; notranslate" title="">
from newsletter.models import Member
from newsletter.serializers import MemberSerializer
from rest_framework import generics

class MemberList(generics.ListCreateAPIView):
    model = Member
    serializer_class = MemberSerializer

class MemberDetail(generics.RetrieveUpdateDestroyAPIView):
    model = Member
    serializer_class = MemberSerializer
</pre>
</li>
<li>URL:
<pre class="brush: python; title: ; notranslate" title="">
from django.conf.urls import patterns, url
from newsletter import views

urlpatterns = patterns('',
    url(r'^members/$', views.MeberList.as_view()),
    url(r'^members/(?P[0-9]+)/$', views.MemberDetail.as_view()),
</pre>
</li>
</ol>
<p>This solutions is also very quick and simple.<br/>
Advantages of this solution are:</p>
<ul>
<li><span><strong>more advanced</strong> and extensible tool</span>,</li>
<li>implementation according to needs, <strong>more ways to implement the same feature</strong>,</li>
<li>possibility of use <strong>Django classes and methods</strong> or own helpers from web user interface application,</li>
<li>fast for automatic <strong>testing</strong> (simple implementation of tests based on Django TestCase).</li>
</ul>
<p>Disadvantges:</p>
<ul>
<li>weak support of nested objects, in consequence problems with iOS Restkit integration,</li>
<li>lower performance than Flask (Django is big machinery, but on <a href="http://dabapps.com/blog/api-performance-profiling-django-rest-framework/">Dabapps blog</a> you can find useful advices on profiling django-rest-framework and benchmarks)</li>
</ul>
<p>In summary, development of API can be really fast and simple what is very beneficial for project. in retrospect and developed projects I personally prefer django-rest-framework for smooth cooperation with Django. API project has clean and logic file structure, because of framework patterns. In one place I have full Django power and all my helpers. I can test my API in easy way. But Flask is also very good choice, even better for overhead systems.</p>
<p>Presentation with condensed informations:<br/>
<br/></p>
</div>
</div>
</div></body></html>