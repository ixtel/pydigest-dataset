<html><body><div><div class="post-text" itemprop="text">
<p>Here is the working solution for the question:</p>

<pre><code>def isSymmetric(A, B):
    L = len(A) #assume equivalent to len(B), modifying this would be as simple as checking if len(A) != len(B), return []
    la = L//2 # half-list length
    Al = A[:la]
    Ar = A[la:]
    Bl = B[:la]
    Br = B[la:]
    for i in range(la):
        lai = la - i #just to reduce the number of computation we need to perform
        for j in range(1, lai + 1):
            k = lai - j #same here, reduce computation
            if Al[i] != Br[k] or Ar[k] != Bl[i]: #the key for efficient computation is here: do not proceed unnecessarily
                 continue
            n = i #written only for the sake of clarity. i is n, and we can use i directly
            m = i + j
            if A[n:m] == B[L-m:L-n] and B[n:m] == A[L-m:L-n]: #possibly symmetric
                if A[0:n] == B[0:n] and A[m:L-m] == B[m:L-m] and A[L-n:] == B[L-n:]:
                    return [n, m]
    return []
</code></pre>

<p>As you have mentioned, though the idea <em>looks</em> simple, but it is actually quite a <em>tricky</em> one. Once we <em>see</em> the patterns, however, the implementation is straight-forward. </p>

<p>The central idea of the solution is this single line:</p>

<pre><code>if Al[i] != Br[k] or Ar[k] != Bl[i]: #the key for efficient computation is here: do not proceed unnecessarily
</code></pre>

<p>All other lines are just either direct code translation from the problem statement or optimization made for more efficient computation.</p>

<hr/>

<p>There are few steps involved in order to find the solution:</p>

<p><strong>Firstly</strong>, we need to split the each both list <code>A</code>and list <code>B</code> into two half-lists (called <code>Al</code>, <code>Ar</code>, <code>Bl</code>, and <code>Br</code>). Each half-list would contain half of the members of the original lists:</p>

<pre><code>Al = A[:la]
Ar = A[la:]
Bl = B[:la]
Br = B[la:]
</code></pre>

<hr/>

<p><strong>Secondly</strong>, to make the <strong>evaluation</strong> efficient, the goal here is to find what I would call <strong>pivot index</strong> to decide whether a <em>position in the list (index)</em> is worth evaluated or not to check if the lists are symmetric. This <strong>pivot index</strong> is the central idea to find an <em>efficient</em> solution. So I would try to elaborate it quite a bit:</p>

<p>Consider the left half part of the <code>A</code> list, suppose you have a member like this:</p>

<pre><code>Al = [al1, al2, al3, al4, al5, al6]
</code></pre>

<p>We can <strong>imagine</strong> that there is a corresponding <strong>index</strong> list for the mentioned list like this</p>

<pre><code>Al  = [al1, al2, al3, al4, al5, al6]
iAl = [0,   1,   2,   3,   4,   5  ] #corresponding index list, added for explanation purpose
</code></pre>

<p><em>(Note: the reason why I mention of imagining a corresponding index list is for ease of explanation purposes)</em></p>

<p>Likewise, we can imagine that the other three lists may have similar index lists. Let's name them <code>iAr</code>, <code>iBl</code>, and <code>iBr</code> respectively and they are all having identical members with <code>iAl</code>.</p>

<p>It is the <strong>index</strong> of the lists which would really matter for us to look into - in order to solve the problem. </p>

<hr/>

<p>Here is what I mean: suppose we have two parameters: </p>

<ol>
<li><strong>index</strong> (let's give a variable name <code>i</code> to it, and I would use symbol <code>^</code> for current <code>i</code>)</li>
<li><strong>length</strong> (let's give a variable name <code>j</code> to it, and I would use symbol <code>==</code> to visually represent its length value) </li>
</ol>

<p>for each <strong>evaluation</strong> of the <strong>index</strong> element in <code>iAl</code> - then each <strong>evaluation</strong> would mean: </p>

<blockquote>
  <p>Given an <strong>index</strong> value <code>i</code> and length value of <code>j</code> in <code>iAl</code>, do
  something to determine if it is worth to check for symmetric
  qualifications starting from that <strong>index</strong> and with that <strong>length</strong>
  (Hence the name <strong>pivot index</strong> come).</p>
</blockquote>

<p>Now, let's take example of one <strong>evaluation</strong> when <code>i = 0</code> and <code>j = 1</code>. The evaluation can be illustrated as follow:</p>

<pre><code>iAl = [0, 1, 2, 3, 4, 5]
       ^ &lt;-- now evaluate this index (i) = 0
       == &lt;-- now this has length (j) of 1
</code></pre>

<hr/>

<p>In order for those <strong>index</strong> <code>i</code> and <strong>length</strong> <code>j</code> to be worth evaluated further, then the counterpart <code>iBr</code> must have the <em>same</em> item value with the <em>same</em> <strong>length</strong> but on different <strong>index</strong> (let's name it <strong>index</strong> <code>k</code>)</p>

<pre><code>iBr = [0, 1, 2, 3, 4, 5]
                      ^ &lt;-- must compare the value in this index to what is pointed by iAl
                      == &lt;-- must evaluate with the same length = 1
</code></pre>

<p>For example, for the above case, this is a <em>possible</em> "symmetric" permutation just for the two lists <code>Al-Br</code> (we will consider the other two lists <code>Ar-Bl</code> later):</p>

<pre><code>Al = [0, x, x, x, x, x] #x means don't care for now
Br = [x, x, x, x, x, 0]
</code></pre>

<p>At this moment, it is good to note that </p>

<blockquote>
  <p>It <strong>won't worth evaluating further</strong> if even the above condition is not
  true</p>
</blockquote>

<p>And this is where you get the algorithm to be more <strong>efficient</strong>; that is, by selectively evaluating only the <strong>few</strong> possible cases among all possible cases. And how to find the few possible cases? </p>

<blockquote>
  <p>By trying to find <strong>relationship between indexes and lengths</strong> of the
  four lists. That is, for a given <strong>index</strong> <code>i</code> and <strong>length</strong> <code>j</code> in a
  list (say <code>Al</code>), what must be the <strong>index</strong> <code>k</code> in the <strong>counterpart</strong>
  list (in the case is <code>Br</code>). Length for the counterpart list need not
  be found because it is the same as in the list (that is <code>j</code>).</p>
</blockquote>

<p>Having know that, let's now proceed further to see if we can see more patterns in the <strong>evaluation</strong> process.</p>

<hr/>

<p>Consider now the effect of length (<code>j</code>). For example, if we are to evaluate from <strong>index</strong> <code>0</code>, but the length is <code>2</code> then the counterpart list would need to have different <strong>index</strong> <code>k</code> evaluated than when the length is <code>1</code></p>

<pre><code>iAl = [0, 1, 2, 3, 4, 5]
       ^ &lt;-- now evaluate this index (i) = 0
       ===== &lt;-- now this has length (j) of 2

iBr = [0, 1, 2, 3, 4, 5]
                   ^ &lt;-- must compare the value in this index to what is pointed by iAl
                   ===== &lt;-- must evaluate with the same length = 2
</code></pre>

<p>Or, for the illustration above, what really matters fox <code>i = 0</code> and <code>y = 2</code> is something like this:</p>

<pre><code># when i = 0 and y = 2
Al = [0, y, x, x, x, x] #x means don't care for now
Br = [x, x, x, x, 0, y] #y means to be checked later
</code></pre>

<p>Take a look that the above pattern is a bit different from when <code>i = 0</code> and <code>y = 1</code> - the index position for <code>0</code> <strong>value</strong> in the example is shifted:</p>

<pre><code># when i = 0 and y = 1, k = 5
Al = [0, x, x, x, x, x] #x means don't care for now
Br = [x, x, x, x, x, 0]

# when i = 0 and y = 2, k = 4
Al = [0, y, x, x, x, x] #x means don't care for now
Br = [x, x, x, x, 0, y] #y means to be checked later
</code></pre>

<p>Thus, <strong>length</strong> shifts <em>where</em> the <strong>index</strong> of the counterpart list must be checked. In the first case, when <code>i = 0</code> and <code>y = 1</code>, then the <code>k = 5</code>. But in the second case, when <code>i = 0</code> and <code>y = 1</code>, then the <code>k = 4</code>. Thus we found the <strong>pivot indexes</strong> relationship when we change the <strong>length</strong> <code>j</code> for a fixed <strong>index</strong> <code>i</code> (in this case being <code>0</code>) unto the counterpart list <strong>index</strong> <code>k</code>.</p>

<hr/>

<p>Now, consider the effects of <strong>index</strong> <code>i</code> with fixed <strong>length</strong> <code>j</code> for counterpart list <strong>index</strong> <code>k</code>. For example, let's fix the <strong>length</strong> as <code>y = 4</code>, then for <strong>index</strong> <code>i = 0</code>, we have:</p>

<pre><code>iAl = [0, 1, 2, 3, 4, 5]
       ^ &lt;-- now evaluate this index (i) = 0
       ========== &lt;-- now this has length (j) of 4

iAl = [0, 1, 2, 3, 4, 5]
          ^ &lt;-- now evaluate this index (i) = 1
          ========== &lt;-- now this has length (j) of 4

iAl = [0, 1, 2, 3, 4, 5]
             ^ &lt;-- now evaluate this index (i) = 2
             ========== &lt;-- now this has length (j) of 4

#And no more needed
</code></pre>

<p>In the above example, it can be seen that we need to evaluate <strong>3</strong> possibilities for the given <code>i</code> and <code>j</code>, but if the <strong>index</strong> <code>i</code> is changed to <code>1</code> with the same length <code>j = 4</code>:</p>

<pre><code>iAl = [0, 1, 2, 3, 4, 5]
          ^ &lt;-- now evaluate this index (i) = 1
          ========== &lt;-- now this has length (j) of 4

iAl = [0, 1, 2, 3, 4, 5]
             ^ &lt;-- now evaluate this index (i) = 2
             ========== &lt;-- now this has length (j) of 4
</code></pre>

<p>Note that we only need to evaluate <strong>2</strong> possibilities. Thus the increase of <strong>index</strong> <code>i</code> decreases the number of possible cases to be evaluated!</p>

<hr/>

<p>With all the above patterns found, we <em>almost</em> found all the basis we need to make the algorithm works. But to complete that, we need to find the relationship between <strong>indexes</strong> which appear in <code>Al-Br</code> pair for a given <code>[i, j] =&gt; [k, j]</code> with the <strong>indexes</strong> in <code>Ar-Bl</code> pair for the same <code>[i, j]</code>.</p>

<p>Now, we can actually see that they are simply <strong>mirroring</strong> the relationship we found in <code>Al-Br</code> pair! </p>

<p><em>(IMHO, this is really beautiful! and thus I think term "symmetric" permutation is not far from truth)</em></p>

<p>For example, if we have the following <code>Al-Br</code> pair evaluated with <code>i = 0</code> and <code>y = 2</code></p>

<pre><code>Al = [0, y, x, x, x, x] #x means don't care for now
Br = [x, x, x, x, 0, y] #y means to be checked later
</code></pre>

<p>Then, to make it <strong>symmetric</strong>, we must have the corresponding <code>Ar-Bl</code>:</p>

<pre><code>Ar = [x, x, x, x, 3, y] #x means don't care for now
Bl = [3, y, x, x, x, x] #y means to be checked later
</code></pre>

<p>The <strong>indexing</strong> of <code>Al-Br</code> pair is <strong>mirroring</strong> (or, is symmetric to) the indexing of <code>Ar-Bl</code> pair!</p>

<hr/>

<p>Therefore, combining all the pattern we found above, we now could find the <strong>pivot indexes</strong> for evaluating <code>Al</code>, <code>Ar</code>, <code>Bl</code>, and <code>Br</code>. </p>

<blockquote>
  <p>We only need to check the values of the lists in the <strong>pivot index</strong>
  first. If the values of the lists in the <strong>pivot indexes</strong> of <code>Al</code>, <code>Ar</code>, <code>Bl</code>, and <code>Br</code>
  matches in the <strong>evaluation</strong> <strong><em>then and only then</em></strong> we need to check
  for symmetric criteria (thus making the computation efficient!)</p>
</blockquote>

<hr/>

<p>Putting up all the knowledge above into code, the following is the resulting <code>for-loop</code> Python code to check for symmetricity:</p>

<pre><code>for i in range(len(Al)): #for every index in the list
    lai = la - i #just simplification
    for j in range(1, lai + 1): #get the length from 1 to la - i + 1
        k = lai - j #get the mirror index
        if Al[i] != Br[k] or Ar[k] != Bl[i]: #if the value in the pivot indexes do not match
             continue #skip, no need to evaluate
        #at this point onwards, then the values in the pivot indexes match
        n = i #assign n
        m = i + j #assign m
        #test if the first two conditions for symmetric are passed
        if A[n:m] == B[L-m:L-n] and B[n:m] == A[L-m:L-n]: #possibly symmetric
            #if it passes, test the third condition for symmetric, the rests of the elements must stay in its place
            if A[0:n] == B[0:n] and A[m:L-m] == B[m:L-m] and A[L-n:] == B[L-n:]:                   
                return [n, m] #if all three conditions are passed, symmetric lists are found! return [n, m] immediately!
        #passing this but not outside of the loop means 
        #any of the 3 conditions to find symmetry are failed
        #though values in the pivot indexes match, simply continue
return [] #nothing can be found - asymmetric lists
</code></pre>

<p>And there go you with the symmetric test!</p>

<p><em>(OK, this is quite a challenge and it takes quite a while for me to figure out how.)</em></p>
    </div>
    </div></body></html>