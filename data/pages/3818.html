<html><body><div><div><p>Python 3.4 featured a brand new library that's been getting a lot of attention:
<tt class="docutils literal">asyncio</tt>.  For numerous reasons, including the fact that the originator of
<a class="reference external" href="https://www.python.org/dev/peps/pep-3156/">the pep</a> is Guido himself, the
<tt class="docutils literal">asyncio</tt> library is growing in popularity within the python community.</p>
<p>So, I'm thinking that it might be fun to try to use this new <tt class="docutils literal">asyncio</tt>
library to write redis in pure python.</p>
<div class="section" id="the-pitch">
<h2>The Pitch</h2>
<p>I maintain a library, <a class="reference external" href="https://github.com/jamesls/fakeredis">fakeredis</a>,
which is a testing library that emulates redis via the <tt class="docutils literal"><span class="pre">redis-py</span></tt> client API.
It doesn't have any of the runtime guarantees that redis has (yet), but for the
most part, it has the same <em>functional</em> behavior as redis.  All of its
state is kept in memory, and it does nothing for persisting state to disk.
After all, it's meant as a testing library, to avoid having to spin up a real
redis server during your python unit tests.  Here's fakeredis in a nutshell:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">fakeredis</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">fakeredis</span><span class="o">.</span><span class="n">FakeStrictRedis</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">'foo'</span><span class="p">,</span> <span class="s">'bar'</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'foo'</span><span class="p">)</span>
<span class="s">'bar'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">lpush</span><span class="p">(</span><span class="s">'bar'</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">lpush</span><span class="p">(</span><span class="s">'bar'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">lrange</span><span class="p">(</span><span class="s">'bar'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
<p>Same semantics as the redis-py client, with all state stored in the memory of
the process.</p>
<p>So the idea is to use <tt class="docutils literal">asyncio</tt> to provide a server that accepts client
connections that can parse the wire protocol for redis.  It then figures out the
corresponding calls to make into <tt class="docutils literal">fakeredis</tt>, which provide all the
functional redis semantics, and takes the return values from <tt class="docutils literal">fakeredis</tt> and
constructs the appropriate wire response.</p>

<p>If all goes well I should have something that any redis client can talk to,
without knowing they're not actually talking to the real redis server.  We will
have created a slower, less memory efficient implementation of the redis server
without the "required" features like "persistence" or "replication".  It's
redis, writen in python, using <tt class="docutils literal">asyncio</tt>.  Sounds like fun.</p>
<p>If nothing else, we'll learn a little more about <tt class="docutils literal">asyncio</tt> in the process.</p>
<div class="section" id="setting-scope">
<h3>Setting Scope</h3>
<p>Now first off, I plan for this to be a multipart series.</p>
<p>The scope for this post, part 1, is to get to the point where we can make redis
calls for all its basic functionality, which includes the API calls for
manipulating data for all of redis's supported types.  Perhaps what's more
interesting is what I'm leaving out in this post.</p>
<p>What I won't look at in this post is:</p>
<ul class="simple">
<li>saving to disk</li>
<li>blocking operations, such as <a class="reference external" href="http://redis.io/commands/BLPOP">BLPOP</a></li>
<li>performance</li>
<li>handling slow clients</li>
<li>expirations</li>
<li>any kind of replication</li>
<li>testing</li>
</ul>
<p>These items will be the subject of future posts.  This is a long winded way
of me saying that we're going to be taking shortcuts.  It'll be ok.</p>
</div>
<div class="section" id="assumptions">
<h3>Assumptions</h3>
<p>To get the most out of this post, I'm assuming that:</p>
<ul class="simple">
<li>You're familiar with redis from an end-user perspective.  You know what redis
is and you're familiar with the basic commands.</li>
<li>You're new to <tt class="docutils literal">asyncio</tt>, but you're not necessarily new to event driven
programming.</li>
<li><strong>You're using python 3.4 or greater.</strong></li>
</ul>
</div>
</div>
<div class="section" id="get-the-skeleton-up-and-running">
<h2>Get the Skeleton Up and Running</h2>
<p>The very first thing I want to do is get something up and running.  It doesn't
have to do much, but I want to be able to at least have the server handle a
request and return  a response, even if it's hardcoded.  I'm going to pick the
<tt class="docutils literal">GET</tt> command because it's the simplest operation that provides useful
functionality.  Once we get this running, we'll pick it apart and figure
out how it actually works.</p>
<p>So first things first, let's hop over to the
<a class="reference external" href="https://docs.python.org/3/library/asyncio.html">asyncio reference docs</a>.</p>
<div class="section" id="end-to-end-skeleton">
<h3>End to End Skeleton</h3>
<p>Asyncio appears to have a <strong>huge</strong> amount of documentation,
but most of it is stuff I don't care about right now.
The closest thing that looks interesting
is this <a class="reference external" href="https://docs.python.org/3/library/asyncio-protocol.html#tcp-echo-server-protocol">TCP echo server protocol</a>,
which shows a basic echo server with asyncio.  We should be able to start with
the echo server and adapt that to what we want,  at least initially.
Here's what I came up with after trying to adapt the echo server example above
to a hard coded redis <tt class="docutils literal">GET</tt> command.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>


<span class="k">class</span> <span class="nc">RedisServerProtocol</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>

    <span class="k">def</span> <span class="nf">data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="k">if</span> <span class="s">'GET'</span> <span class="ow">in</span> <span class="n">message</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s">"$3</span><span class="se">\r\n</span><span class="s">"</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s">"BAZ</span><span class="se">\r\n</span><span class="s">"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s">"-ERR unknown command</span><span class="se">\r\n</span><span class="s">"</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">hostname</span><span class="o">=</span><span class="s">'localhost'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">):</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="n">coro</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="n">RedisServerProtocol</span><span class="p">,</span>
                              <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Listening on port {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">port</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"User requested shutdown."</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">server</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">server</span><span class="o">.</span><span class="n">wait_closed</span><span class="p">())</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Redis is now ready to exit."</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>Save the above code to a file <tt class="docutils literal"><span class="pre">redis-asyncio</span></tt> and run it. We'll use the
<tt class="docutils literal"><span class="pre">redis-cli</span></tt> to verify this has the behavior that we want:</p>
<pre class="literal-block">
$ ./redis-asyncio &amp;
[1] 96221
Listening on port 6379

$ redis-cli
127.0.0.1:5678&gt; GET foo
"BAZ"
127.0.0.1:5678&gt; GET bar
"BAZ"
127.0.0.1:5678&gt; GET anything
"BAZ"
127.0.0.1:5678&gt; FOOBAR asdf
(error) ERR unknown command
</pre>
<p>It works!</p>
</div>
<div class="section" id="but-how-does-it-work">
<h3>But How Does it Work?</h3>
<p>There's a lot we haven't explained yet.</p>
<p>While I'm going to skip over the <tt class="docutils literal">get_event_loop</tt> and <tt class="docutils literal">run_until_complete</tt>
for now, the <tt class="docutils literal">create_server</tt> is interesting.  How exactly
does this server we create integrate with the <tt class="docutils literal">RedisServerProtocol</tt> we made?
For example, how do we go from <tt class="docutils literal">create_server</tt> to calling
<tt class="docutils literal">RedisServerProtocol.connection_made</tt>?</p>
<p>What helped me the most was just digging into the source code for
<tt class="docutils literal">asyncio</tt>, so let's do that.
I've annotated and simplified the code to give you a high level
view of what's going on.  We'll start with <tt class="docutils literal">create_server</tt>,
and keeping going through the various methods until we see
our protocol's <tt class="docutils literal">connection_made</tt> method being called.</p>
<div class="highlight"><pre><span class="c"># These are all methods within an EventLoop class.</span>

<span class="nd">@coroutine</span>
<span class="k">def</span> <span class="nf">create_server</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol_factory</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="o">*</span><span class="p">,</span>
                  <span class="n">family</span><span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_UNSPEC</span><span class="p">,</span>
                  <span class="n">flags</span><span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">AI_PASSIVE</span><span class="p">,</span>
                  <span class="n">sock</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">backlog</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                  <span class="n">ssl</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">reuse_address</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c"># In this scenario the ``protocol_factory`` maps</span>
    <span class="c"># to the ``RedisServerProtocol`` class object.</span>

    <span class="c"># Create listening socket(s).</span>
    <span class="n">socket</span> <span class="o">=</span> <span class="n">lots_of_code</span><span class="p">()</span>

    <span class="n">server</span> <span class="o">=</span> <span class="n">Server</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">socket</span><span class="p">)</span>
    <span class="c"># Once we create a server, we call _start_serving.</span>
    <span class="c"># Note how we're passing along the protocol_factory</span>
    <span class="c"># argument (our ``RedisServerProtocol`` class).</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_start_serving</span><span class="p">(</span><span class="n">protocol_factory</span><span class="p">,</span> <span class="n">socket</span><span class="p">,</span> <span class="n">ssl</span><span class="p">,</span> <span class="n">server</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">server</span>

<span class="k">def</span> <span class="nf">_start_serving</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol_factory</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span>
                   <span class="n">sslcontext</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">server</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c"># We're registering the _accept_connection method to be called</span>
    <span class="c"># when a new connection is made.  Again notice how we're</span>
    <span class="c"># still passing along our protocol_factory (``RedisServerProtocol``</span>
    <span class="c"># class) object.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accept_connection</span><span class="p">,</span>
                    <span class="n">protocol_factory</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">sslcontext</span><span class="p">,</span> <span class="n">server</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_accept_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol_factory</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span>
                       <span class="n">sslcontext</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">server</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c"># Finally!  We're we can see that we instantiate</span>
    <span class="c"># the protocol_factory class to actually get</span>
    <span class="c"># an instance of ``RedisServerProtocol``.</span>
    <span class="c"># We've gone from a class to an instance.  So</span>
    <span class="c"># what about connection_made?  When does this get</span>
    <span class="c"># called?  Down the stack to _make_socket_transport.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_make_socket_transport</span><span class="p">(</span>
        <span class="n">conn</span><span class="p">,</span> <span class="n">protocol_factory</span><span class="p">(),</span> <span class="n">extra</span><span class="o">=</span><span class="p">{</span><span class="s">'peername'</span><span class="p">:</span> <span class="n">addr</span><span class="p">},</span>
        <span class="n">server</span><span class="o">=</span><span class="n">server</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_make_socket_transport</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">waiter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                           <span class="n">extra</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">server</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c"># At least we can see we've gone from protocol_factory to</span>
    <span class="c"># just protocol, so now "protocol" in this scenario is an</span>
    <span class="c"># instance of ``RedisServerProtocol``.</span>
    <span class="k">return</span> <span class="n">_SelectorSocketTransport</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">waiter</span><span class="p">,</span>
                                    <span class="n">extra</span><span class="p">,</span> <span class="n">server</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_SelectorSocketTransport</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">waiter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">extra</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">server</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">extra</span><span class="p">,</span> <span class="n">server</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eof</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paused</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sock_fd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_ready</span><span class="p">)</span>
        <span class="c"># And finally, we see that we ask the event loop to call</span>
        <span class="c"># the connection_made method of our protocol class, and we're</span>
        <span class="c"># passing "self" (The transport object) as an argument to</span>
        <span class="c"># connection_made.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_protocol</span><span class="o">.</span><span class="n">connection_made</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="recap">
<h3>Recap</h3>
<p>So far, we've learned:</p>
<ul class="simple">
<li>It looks like the interesting stuff we'll be writing is in the Protocol.  To
write our own redis server, we're going to flesh out a proper
<tt class="docutils literal">RedisServerProtocol</tt> class that understands the redis wire protocol.</li>
<li>We get 1 protocol per client connection.  Storing state on the protocol
will be scoped to the lifetime of that connection.</li>
<li>To wire things up, hand the protocol class to the <tt class="docutils literal">create_server</tt>, which
is called on an event loop instance.  As we saw in the code snippet above
in <tt class="docutils literal">_accept_connection()</tt>, the <tt class="docutils literal">protocol_factory</tt> argument is called
with no args to create a protocol instance.  While a class object works fine
for now, we're going to have to use a closure or a factory class to pass
arguments to the protocol when it's created.</li>
<li>The protocols themselves let you define methods that are invoked by the event
loop.  That is <tt class="docutils literal">asyncio</tt> will call methods when there's a
<tt class="docutils literal">connection_made()</tt>, or there's <tt class="docutils literal">data_received</tt>.  Looking at the
<a class="reference external" href="https://docs.python.org/3/library/asyncio-protocol.html#protocol-classes">Protocol classes</a>,
there appears to be a few more methods you can implement.</li>
</ul>
<p>Now that we understand the basics, we can start looking at the redis
wire protocol.</p>
</div>
</div>
<div class="section" id="parsing-the-wire-protocol">
<h2>Parsing the Wire Protocol</h2>
<p>First thing we're going to need to do properly handle requests is protocol
parser, this is the code that takes the redis request off the TCP socket and
parses it into something meaningful.  This code for this isn't that
interesting.  Reading the docs for the <a class="reference external" href="http://redis.io/topics/protocol">redis wire protocol</a>, it's straightforward to implement.</p>
<p>Now, none of this is optimized yet, but here's a basic implementation
of parsing the redis wire protocol.  It accepts a byte string, and returns
python objects.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">parse_wire_protocol</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_parse_wire_protocol</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">message</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_parse_wire_protocol</span><span class="p">(</span><span class="n">msg_buffer</span><span class="p">):</span>
    <span class="n">current_line</span> <span class="o">=</span> <span class="n">msg_buffer</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="n">msg_type</span><span class="p">,</span> <span class="n">remaining</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">current_line</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">current_line</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">msg_type</span> <span class="o">==</span> <span class="s">'+'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">remaining</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="n">b</span><span class="s">'</span><span class="se">\r\n</span><span class="s">'</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">msg_type</span> <span class="o">==</span> <span class="s">':'</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">remaining</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">msg_type</span> <span class="o">==</span> <span class="s">'$'</span><span class="p">:</span>
        <span class="n">msg_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">remaining</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">msg_length</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">msg_buffer</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">msg_length</span><span class="p">)</span>
        <span class="c"># There's a '\r\n' that comes after a bulk string</span>
        <span class="c"># so we .readline() to move passed that crlf.</span>
        <span class="n">msg_buffer</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">elif</span> <span class="n">msg_type</span> <span class="o">==</span> <span class="s">'*'</span><span class="p">:</span>
        <span class="n">array_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">remaining</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">_parse_wire_protocol</span><span class="p">(</span><span class="n">msg_buffer</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array_length</span><span class="p">)]</span>
</pre></div>
<p>We're also going to need the inverse of this, something that takes a response
from fakeredis and converts it back into bytes that can be sent across the
wire.  Again, nothing too interesting about this code, but here's what I came
up with:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">serialize_to_wire</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s">'+</span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span> <span class="o">+</span> <span class="n">b</span><span class="s">'</span><span class="se">\r\n</span><span class="s">'</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">b</span><span class="s">"+OK</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s">':</span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span> <span class="o">+</span> <span class="n">b</span><span class="s">'</span><span class="se">\r\n</span><span class="s">'</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="s">'$'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span> <span class="o">+</span>
                <span class="n">b</span><span class="s">'</span><span class="se">\r\n</span><span class="s">'</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="n">b</span><span class="s">'</span><span class="se">\r\n</span><span class="s">'</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">b</span><span class="s">'$-1</span><span class="se">\r\n</span><span class="s">'</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">b</span><span class="s">'*'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span> <span class="o">+</span> <span class="n">b</span><span class="s">'</span><span class="se">\r\n</span><span class="s">'</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">+=</span> <span class="n">serialize_to_wire</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">base</span>
</pre></div>
<p>Let's try this out:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">set_request</span> <span class="o">=</span> <span class="n">b</span><span class="s">'*3</span><span class="se">\r\n</span><span class="s">$3</span><span class="se">\r\n</span><span class="s">set</span><span class="se">\r\n</span><span class="s">$3</span><span class="se">\r\n</span><span class="s">foo</span><span class="se">\r\n</span><span class="s">$3</span><span class="se">\r\n</span><span class="s">bar</span><span class="se">\r\n</span><span class="s">'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">parse_wire_protocol</span><span class="p">(</span><span class="n">set_request</span><span class="p">)</span>
<span class="p">[</span><span class="n">b</span><span class="s">'set'</span><span class="p">,</span> <span class="n">b</span><span class="s">'foo'</span><span class="p">,</span> <span class="n">b</span><span class="s">'bar'</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">serialize_to_wire</span><span class="p">([</span><span class="n">b</span><span class="s">'5'</span><span class="p">,</span> <span class="n">b</span><span class="s">'4'</span><span class="p">,</span> <span class="n">b</span><span class="s">'3'</span><span class="p">,</span> <span class="n">b</span><span class="s">'2'</span><span class="p">,</span> <span class="n">b</span><span class="s">'1'</span><span class="p">])</span>
<span class="n">b</span><span class="s">'*5</span><span class="se">\r\n</span><span class="s">$1</span><span class="se">\r\n</span><span class="s">5</span><span class="se">\r\n</span><span class="s">$1</span><span class="se">\r\n</span><span class="s">4</span><span class="se">\r\n</span><span class="s">$1</span><span class="se">\r\n</span><span class="s">3</span><span class="se">\r\n</span><span class="s">$1</span><span class="se">\r\n</span><span class="s">2</span><span class="se">\r\n</span><span class="s">$1</span><span class="se">\r\n</span><span class="s">1</span><span class="se">\r\n</span><span class="s">'</span>
</pre></div>
<p>After calling the <tt class="docutils literal">parse_wire_protocol</tt> we can see that get a list of
<tt class="docutils literal">[command_name, arg1, arg2, <span class="pre">...]</span></tt>.</p>
</div>
<div class="section" id="implementing-the-protocol-class">
<h2>Implementing the Protocol Class</h2>
<p>We should have everything we need to make a more realistic
<tt class="docutils literal">RedisServerProtocol</tt> class now.  We're making the assumption
for now that the entire command is provided when
<tt class="docutils literal">data_received</tt> is called.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">RedisServerProtocol</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">redis</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_redis</span> <span class="o">=</span> <span class="n">redis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>

    <span class="k">def</span> <span class="nf">data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">parsed</span> <span class="o">=</span> <span class="n">parse_wire_protocol</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c"># parsed is an array of [command, *args]</span>
        <span class="n">command</span> <span class="o">=</span> <span class="n">parsed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_redis</span><span class="p">,</span> <span class="n">command</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="n">b</span><span class="s">"-ERR unknown command "</span> <span class="o">+</span> <span class="n">parsed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="s">"</span><span class="se">\r\n</span><span class="s">"</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="n">parsed</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">serialized</span> <span class="o">=</span> <span class="n">serialize_to_wire</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">serialized</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">WireRedisConverter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">redis</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_redis</span> <span class="o">=</span> <span class="n">redis</span>

    <span class="k">def</span> <span class="nf">lrange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_redis</span><span class="o">.</span><span class="n">lrange</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">hmset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">converted</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">iter_args</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">iter_args</span><span class="p">,</span> <span class="n">iter_args</span><span class="p">):</span>
            <span class="n">converted</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_redis</span><span class="o">.</span><span class="n">hmset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">converted</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_redis</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
<p>The most important part here is the <tt class="docutils literal">data_received</tt> method.  Note that the
first thing we do is take the bytes data we're given and immediately parse that
into a python list using our <tt class="docutils literal">parse_wire_protocol</tt>.  The next thing we do is
try to look for a corresponding method in the <tt class="docutils literal">WireRedisConverter</tt> class
based on the command we've been given.  The <tt class="docutils literal">WireRedisConverter</tt> class takes
the parsed python list we receive from clients and maps that into the
appropriate calls into fakeredis.  For example:</p>
<pre class="literal-block">
HMSET myhash field1 "Hello"                           &lt;- redis-cli
['hmset', 'myhash', 'field1', 'Hello']                &lt;- parsed
WireRedisConverter.hmset('myhash', 'field1', 'Hello')
FakeRedis.hmset('myhash', {'field1': 'Hello'})
</pre>
<p>I've only shown a portion of <tt class="docutils literal">WireRedisConverter</tt>, but there's enough to
give you the basic idea of how a python list maps is then mapped to
<tt class="docutils literal">fakeredis</tt> calls.</p>
<p>And finally, we serialize the python response back to bytes using
<tt class="docutils literal">serialize_to_wire</tt> and write this value out to the <tt class="docutils literal">transport</tt> we received
from <tt class="docutils literal">connection_made</tt>.</p>
</div>
<div class="section" id="wiring-up-the-protocol-class">
<h2>Wiring Up the Protocol Class</h2>
<p>We'll also need to make a change to our main function, mostly in how we wire
up the <tt class="docutils literal">RedisServerProtocol</tt>:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">hostname</span><span class="o">=</span><span class="s">'localhost'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">):</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="n">wrapped_redis</span> <span class="o">=</span> <span class="n">WireRedisConverter</span><span class="p">(</span><span class="n">fakeredis</span><span class="o">.</span><span class="n">FakeStrictRedis</span><span class="p">())</span>

    <span class="n">bound_protocol</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">RedisServerProtocol</span><span class="p">,</span>
                                       <span class="n">wrapped_redis</span><span class="p">)</span>
    <span class="n">coro</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="n">bound_protocol</span><span class="p">,</span>
                              <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Listening on port {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">port</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"User requested shutdown."</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">server</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">server</span><span class="o">.</span><span class="n">wait_closed</span><span class="p">())</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Redis is now ready to exit."</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span>
</pre></div>
<p>The biggest difference here is that we're using <tt class="docutils literal">functools.partial</tt>
so that we can pass in our wrapped fakeredis instance to the
<tt class="docutils literal">RedisServerProtocol</tt> class whenever it's created.  As we saw earlier, the
<tt class="docutils literal">protocol_factory</tt> is called with no args and is expected to return a
protocol instance.  While we could write a protocol factory class, we're using
<tt class="docutils literal">functools.partial</tt> because that's all we need for now.</p>
</div>
<div class="section" id="testing-it-out">
<h2>Testing it Out</h2>
<p>And finally, we should have something that vaguely resembles redis.  Let's try
it out:</p>
<pre class="literal-block">
$ ./redis-asyncio &amp;
[1] 55470

$ redis-cli
127.0.0.1:6379&gt; set foo bar
OK
127.0.0.1:6379&gt; get foo
"bar"
127.0.0.1:6379&gt; set foo baz
OK
127.0.0.1:6379&gt; get foo
"baz"

127.0.0.1:6379&gt; lpush abc 1
(integer) 1
127.0.0.1:6379&gt; lpush abc 2
(integer) 2
127.0.0.1:6379&gt; lpush abc 3
(integer) 3
127.0.0.1:6379&gt; lrange abc 0 -1
1) "3"
2) "2"
3) "1"

127.0.0.1:6379&gt; hmset myhash field1 "hello" field2 "world"
OK
127.0.0.1:6379&gt; hget myhash field1
"hello"
127.0.0.1:6379&gt; hget myhash field2
"world"

127.0.0.1:6379&gt; sadd myset "Hello"
(integer) 1
127.0.0.1:6379&gt; sadd myset "World"
(integer) 1
127.0.0.1:6379&gt; sadd myset "World"
(integer) 0
127.0.0.1:6379&gt; smembers myset
1) "Hello"
2) "World"
</pre>
<p>Let's even try talking to <tt class="docutils literal"><span class="pre">./redis-asyncio</span></tt> using the <tt class="docutils literal"><span class="pre">redis-py</span></tt> module:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">redis</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">Redis</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">'foo'</span><span class="p">,</span> <span class="s">'bar'</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'foo'</span><span class="p">)</span>
<span class="n">b</span><span class="s">'bar'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">lpush</span><span class="p">(</span><span class="s">'mylist'</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">lpush</span><span class="p">(</span><span class="s">'mylist'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">lrange</span><span class="p">(</span><span class="s">'mylist'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">[</span><span class="n">b</span><span class="s">'2'</span><span class="p">,</span> <span class="n">b</span><span class="s">'1'</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">sadd</span><span class="p">(</span><span class="s">'myset'</span><span class="p">,</span> <span class="s">'hello'</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">sadd</span><span class="p">(</span><span class="s">'myset'</span><span class="p">,</span> <span class="s">'world'</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">sadd</span><span class="p">(</span><span class="s">'myset'</span><span class="p">,</span> <span class="s">'world'</span><span class="p">)</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">smembers</span><span class="p">(</span><span class="s">'myset'</span><span class="p">)</span>
<span class="p">{</span><span class="n">b</span><span class="s">'world'</span><span class="p">,</span> <span class="n">b</span><span class="s">'hello'</span><span class="p">}</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">hmset</span><span class="p">(</span><span class="s">'myhash'</span><span class="p">,</span> <span class="p">{</span><span class="s">'a'</span><span class="p">:</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">:</span> <span class="s">'d'</span><span class="p">})</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">hget</span><span class="p">(</span><span class="s">'myhash'</span><span class="p">,</span> <span class="s">'a'</span><span class="p">)</span>
<span class="n">b</span><span class="s">'b'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">hget</span><span class="p">(</span><span class="s">'myhash'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">)</span>
<span class="n">b</span><span class="s">'d'</span>
</pre></div>
</div>
<div class="section" id="wrapping-up">
<h2>Wrapping Up</h2>
<p>In this post, we looked at getting a basic redis implementation up and running
using <tt class="docutils literal">asyncio</tt> and <tt class="docutils literal">fakeredis</tt>.  We were able to run basic commands such
as <tt class="docutils literal">get, set, lpush, lrange, sadd, smembers, hmset, hget</tt>, etc.</p>
<p>In the next post, we'll look at implementing blocking operations such as
<tt class="docutils literal">BLPOP</tt>.</p>
<p>And, because you're probably just as curious as I was, here's a benchmark
comparison between what we've written and the real redis server.  These benchmarks
were run on the same machine so it's the relative difference that's interesting
to me.  I wouldn't read too much into it though.</p>
<div class="section" id="redis-benchmark-t-set-n-200000">
<h3>redis-benchmark -t set -n 200000</h3>
<table class="u-full-width">
  <thead>
    <tr>
      <th>redis-server</th>
      <th>redis-asyncio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><pre>
====== SET ======
  200000 requests completed
    in 1.52 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

99.97% </pre></td>
      <td><pre>
====== SET ======
  200000 requests completed
    in 5.17 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

0.25% </pre></td>
    </tr>
  </tbody>
</table></div>
<div class="section" id="redis-benchmark-t-get-n-200000">
<h3>redis-benchmark -t get -n 200000</h3>
<table class="u-full-width">
  <thead>
    <tr>
      <th>redis-server</th>
      <th>redis-asyncio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><pre>
====== GET ======
  200000 requests completed
    in 1.53 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

100.00% </pre></td>
      <td><pre>
====== GET ======
  200000 requests completed
    in 6.42 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

0.18% </pre></td>
    </tr>
  </tbody>
</table></div>
</div>
</div>

        </div></body></html>