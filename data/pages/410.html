<html><body><div><div class="content html_format"><p>
      Инфраструктура системы пакетов для Python долго подвергалась критике как от разработчиков, так и от системных администраторов. Долгое время даже само комьюнити не могло прийти к соглашению, какие именно инструменты использовать в каждом конкретном случае. Уже существуют distutils, setuptools, distribute, distutils2 в качестве базовых механизмов распространения и virtualenv, buildout, easy_install и pip в качестве высокоуровневых инструментов управления всем этим беспорядком.</p>
<p>
До setuptools основным форматом распространения были исходные файлы или некоторые бинарные MSI-дистрибутивы для Windows. Под Linux были изначально сломанный </p><code>bdist_dumb</code><p> и </p><code>bdist_rpm</code><p>, который работал только на системах, основанных на Red Hat. Но даже </p><code>bdist_rpm</code><p> работал недостаточно хорошо для того, чтобы люди начали его использовать.
</p><p>
Несколько лет назад </p><a href="https://twitter.com/pjeby">PJE</a><p> попытался исправить эту проблему, предоставив смесь из setuptools и pkg_resources для улучшения distutils и добавления метаданных в Python-пакеты. В дополнение к этому он написал утилиту easy_install для их установки. По причине отсутствия формата распространения, поддерживающего метаданные, был предоставлен формат 'яиц' [egg].
</p><p>
Python eggs – обычные zip-архивы, содержащие python-пакет и необходимые метаданные. Хотя многие люди, вероятно, никогда намеренно не собирали egg'и, их формат метаданных до сих пор жив-здоров. И все разворачивают свои проекты с использованием setuptools.
</p><p>
К сожалению, некоторое время спустя сообщество разделилось, и часть его провозгласила смерть бинарных форматов и 'яиц' в частности. После этого pip, замена easy_install, перестал принимать egg-формат.
</p><p>
Потом прошло еще немного времени, и отказ от бинарных пакетов стал доставлять неудобства. Люди всё больше и больше стали деплоить на облачные сервера, а необходимость перекомпиляции C-шных библиотек на каждой машине не слишком радует. Так как 'яйца' на тот момент были малопонятны (я так полагаю), их переделали в новых PEP-ах, и назвали '</p><a href="http://www.python.org/dev/peps/pep-0427/">колёсами</a><p>' [wheels].
</p><a name="habracut"/><p>
В дальнейшем предполагается, что все действия происходят в </p><a href="http://www.virtualenv.org/en/latest/">virtualenv-окружении</a><p>.
 
</p><h4>Что за колесо?</h4><p>
Начнём с простого. Что представляют собой 'колёса' и чем они отличаются от 'яиц'? Оба формата являются zip-файлами. Главная разница в том, что egg можно импортировать без распаковки, wheel же придётся распаковать. Хотя нет никаких технических причин, делающих 'колёса' неимпортируемыми, поддержка их прямого импорта никогда даже не планировалась.
</p><p>
Другое различие в том, что 'яйца' содержат скомпилированные байткод, а 'колёса' – нет. Главное преимущество этого в том, что нет необходимости создавать отдельные wheel'ы для каждой версии Python до тех пор, пока не придётся распространять слинкованные через libpython модули. Хотя в новых версиях Python 3 при использовании стабильного ABI даже это уже можно провернуть.
 </p><p>
Однако wheel-формат тоже не лишен проблем, некоторые из которых он наследует от 'яиц'. Например, бинарные дистрибутивы под Linux до сих пор неприемлемы для большинства из-за двух недостатков: Python сам по себе компилируется под Linux в разных формах, и модули линкуются с разными системными библиотеками. Первая проблема вызвана сосуществованием несовместимых версий Python 2: USC2 и USC4. В зависимости от режима компиляции меняется ABI. В настоящее время wheel (насколько я могу судить) не содержит информации о том, с каким режимом Unicode связана библиотека. Отдельная проблема в том, что дистрибутивы Linux меньше совместимы между собой, чем хотелось бы, и обстоятельства могут сложиться так, что сборка, скомпилированная под один дистрибутив, не будет работать на остальных.
</p><p>
Всё это выливается в то, что, вообще говоря, на данный момент бинарные 'колёса' нельзя загружать на PyPI как несовместимые с различными системами.
</p><p>
В дополнение ко всему этому wheel сейчас знает только две крайности: бинарные пакеты и пакеты, содержащие чистый python-код. Бинарные пакеты специфичны для Python ветки 2.x. Сейчас это не кажется большой проблемой, потому что цикл 2.x подходит к концу, и пакетов, собранных только для 2.7, хватит надолго. Но если бы вдруг речь пошла про Python 2.8, была бы интересна возможность заявить, что этот пакет не зависит от версии Python, но он содержит бинарники, поэтому он не может не зависеть от архитектуры. 
</p><p>
Единственный случай, оправдывающий существование такого пакета – это когда он содержит распределенные библиотеки, загружаемые с ctypes из CFFI. Такие библиотеки не связаны через libpython и не зависимы от реализации языка (их можно использовать даже с pypy).
</p><p>
Но есть и светлая сторона: ничто не запрещает использовать бинарные wheel’ы в своих собственных однородных инфраструктурах.

</p><h4>Сборка колеса</h4><p>
Итак, теперь мы знаем, что такое wheel. Как сделать своё собственное 'колесо'? Сборка из собственных библиотек – простейший процесс. Всё, что нужно – свежая версия </p><code>setuptools</code><p> и библиотека </p><code>wheel</code><p>. Как только они оба установлены, 'колесо' собирается следующей командой:
</p><pre><code class="bash">$ python setup.py bdist_wheel
</code></pre><p>
Wheel будет создан в директории пакета. Однако есть одна вещь, которой следует опасаться: распространение бинарников. По умолчанию собираемое 'колесо' (при условии, что в setup.py не используется никаких бинарных шагов) состоит из pure-python кода. Это значит, что даже если распространять </p><code>.so</code><p>, </p><code>.dylib</code><p> или </p><code>.dll</code><p> как часть своего пакета, полученное 'колесо' будет выглядеть платформо-независимым.
</p><p>
Решение этой проблемы – вручную реализовать Distribution из setuptools, скинув флаг чистоты в </p><code>false</code><p>:
</p><pre><code class="python">import os
from setuptools import setup
from setuptools.dist import Distribution

class BinaryDistribution(Distribution):
    def is_pure(self):
        return False

setup(
    ...,
    include_package_data=True,
    distclass=BinaryDistribution,
)
</code></pre>
<h4>Установка колеса</h4><p>
С использованием свежей версии pip 'колесо' ставится следующим образом:
</p><pre><code class="bash">$ pip install package-1.0-cp27-none-macosx_10_7_intel.whl
</code></pre><p>
Но что с зависимостями? Тут появляются некоторые сложности. Обычно одним из требований к пакету является возможность его установки даже без подключения к интернету. К счастью, pip позволяет отключать загрузку из индекса и устанавливать директорию, содержащую всё необходимое для установки. Если у нас есть wheel’ы для всех зависимостей необходимых версий, можно сделать следующее:
</p><pre><code class="bash">$ pip install --no-index --find-links=path/to/wheels package==1.0
</code></pre><p>
Таким образом будет установлена версия </p><code>1.0</code><p> пакета </p><code>package</code><p> в наше виртуальное окружение.

</p><h4>Колёса для зависимостей</h4><p>
Окей, но что, если у нас нет .whl для всех наших зависимостей? Pip в теории позволяет решить эту проблему использованием команды </p><code>wheel</code><p>. Это должно работать как-то так:
</p><pre><code class="bash">pip wheel --wheel-dir=path/to/wheels package==1.0
</code></pre><p>
Эта команда выгрузит все пакеты, от которых зависит наш пакет, в указанную папку. Но есть пара проблем.</p><p>
Первая состоит в том, что в команде в настоящий момент есть баг, который не выгружает зависимости, которые уже являются 'колёсами'. Так что если зависимость уже доступна на PyPI в wheel-формате, она не будет загружена. 
</p><p>
Это временно решается shell-скриптом, который вручную перемещает из кэша скачанные wheel’ы.
</p><pre><code class="bash">#!/bin/sh
WHEEL_DIR=path/to/wheels
DOWNLOAD_CACHE_DIR=path/to/cache
rm -rf $DOWNLOAD_CACHE_DIR
mkdir -p $DOWNLOAD_CACHE_DIR

pip wheel --use-wheel -w "$WHEEL_DIR" -f "$WHEEL_DIR" \
  --download-cache "$DOWNLOAD_CACHE_DIR" package==1.0
for x in "$DOWNLOAD_CACHE_DIR/"*.whl; do
  mv "$x" "$WHEEL_DIR/${x##*%2F}"
done
</code></pre><p>
Вторая проблема чуть серьёзней: как pip найдет наш собственный пакет, если его нет на PyPI? Правильно, никак. Документация в таком случае рекомендует использовать не </p><code>pip wheel package</code><p>, а </p><code>pip wheel -r requirements.txt</code><p>, где </p><code>requirements.txt</code><p> содержит все необходимые зависимости.

</p><h4>Сборка пакетов c использованием DevPI</h4><p>
Такое временное решение проблемы зависимостей вполне применимо в простых ситуациях, но что делать, если есть множество внутренних python-пакетов, зависящих друг от друга? Такая конструкция быстро разваливается.
</p><p>
К счастью, в прошлом году Holker Krekel создал решение этой беды под названием </p><a href="http://doc.devpi.net/">DevPI</a><p>, который по существу является хаком, эмулирующим работу pip с PyPI. После установки на компьютер DevPI работает как прозрачный прокси перед PyPI и позволяет pip-у устанавливать пакеты из локального репозитория. К тому же все пакеты, скачанные с PyPI, автоматически кэшируются, так что даже если отключить сеть, эти пакеты будут доступны для установки. И, в конце концов, появляется возможность загрузки своих собственных пакетов на локальный сервер, чтобы ссылаться на них так же, как и на хранящиеся в публичном индексе.
</p><p>
Я рекомендую установить DevPI в локальный virtualenv, после чего добавить ссылки на </p><code>devpi-server</code><p> и </p><code>devpi</code><p> в </p><code>PATH</code><p>.
</p><pre><code class="bash">$ virtualenv devpi-venv
$ devpi-venv/bin/pip install --ugprade pip wheel setuptools devpi
$ ln -s `pwd`/devpi-venv/bin/devpi ~/.local/bin
$ ln -s `pwd`/devpi-venv/bin/devpi-server ~/.local/bin
</code></pre><p>
После этого остаётся просто запустить </p><code>devpi-server</code><p>, и он будет работать до ручной остановки.
</p><pre><code class="bash">$ devpi-server --start
</code></pre><p>
После запуска его необходимо единожды проинициализировать: 
</p><pre><code class="bash">$ devpi use http://localhost:3141
$ devpi user -c $USER password=
$ devpi login $USER --password=
$ devpi index -c yourproject
</code></pre><p>
Так как я использую DevPI 'для себя', имена пользователя DevPI и системного пользователя совпадают. На последнем шаге создаётся индекс по имени проекта (при необходимости можно создать несколько).
</p><p>
Для перенаправления pip на локальный репозиторий можно сделать экспорт переменной окружения:
</p><pre><code class="bash">$ export PIP_INDEX_URL=http://localhost:3141/$USER/yourproject/+simple/
</code></pre><p>
Я размешаю эту команду в скрипт </p><code>postactivate</code><p> моего virtualenv для предотвращения случайной загрузки из неверного индекса.
</p><p>
Для размещения собственных wheel’ов в локальном DevPI используется утилита </p><code>devpi</code><p>:
</p><pre><code class="bash">$ devpi use yourproject
$ devpi upload --no-vcs --formats=bdist_wheel
</code></pre><p>
Флаг </p><code>--no-vcs</code><p> отключает магию, которая пытается определить систему контроля версий и перемещает некоторые файлы в первую очередь. Мне это не нужно, так как в моих проектах распространяются файлы, которые я не включаю в VCS (бинарники, например).
</p><p>
Напоследок я настоятельно рекомендую разбить файлы setup.py таким образом, что PyPI их отвергнет, а DevPI примет, чтобы случайно не зарелизить свой код с помощью </p><code>setup.py resease</code><p>. Самый простой способ это сделать – добавить неверный классификатор PyPI:
</p><pre><code class="python">setup(
    ...
    classifier=['Private :: Do Not Upload'],
)
</code></pre>
<h4>Заворачиваем</h4><p>
Теперь всё готово для начала использования внутренних зависимостей и сборки собственных 'колёс'. Как только они появятся, их можно заархивировать, загрузить на другой сервер и установить в отдельный virtualenv.</p><p>
Весь процесс станет чуть проще, когда </p><code>pip wheel</code><p> перестанет игнорировать существующие wheel-пакеты. А пока приведенный выше shell-скрипт – не худшее решение.

</p><h4>В сравнении с 'яйцами'</h4><p>
Сейчас wheel-формат более притягателен, чем egg. Его разработка активнее, PyPI начал добавлять его поддержку и, так как с ним начинают работать утилиты, он похож на лучшее решение. 'Яйца' пока что поддерживаются только easy_install, хотя большинство давно перешло на pip.
</p><p>
Я считаю, что сообщество Zope до сих пор крупнейшее из базирующихся на egg-формате и buildout. И я считаю, что если решение на основе 'яиц' в вашем случае применимо, его и стоит применять. Я знаю, что многие не используют eggs вовсе, предпочитая создавать virtualenv-ы, архивировать их и рассылать по разным серверам. Как раз для такого развёртывания wheels – лучшее решение, так как у разных серверов могут быть разные пути к библиотекам. Встречалась проблема, связанная с тем, что </p><code>.pyc</code><p>-файлы создавались на билд-сервере для virtualenv, а эти файлы содержат конкретные пути к файлам. С использованием wheel </p><code>.pyc</code><p> создаются после установки в виртуальное окружение и автоматически будут иметь корректные пути.
</p><p>
Итак, теперь он у вас есть. Python на колёсах. И это вроде даже работает, и, возможно, стоит потраченного времени.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>