<html><body><div><div class="entry-content">
		<p><em>Update 1/13: After reading the comments and thinking about it some more, I think <code>binascii.hexlify(os.urandom(n))</code> is the <strong>easiest</strong> way to generate random tokens, and <code>random = random.SystemRandom(); ''.join(random.choice(alphabet) for _ in range(n))</code> is better when you need a string that contains only characters from a specific alphabet. Pyramid uses the former approach; Django uses the latter.<br/>
</em></p>
<p>I’m working on a web site where I need to generate random CSRF tokens. After digging around a bit, I found <a title="Manual for Python's os module (3.3 represent)" href="http://docs.python.org/3.3/library/os"><code>os.urandom(<em>n</em>)</code></a>, which returns “a string of <em>n</em> random bytes suitable for cryptographic use.” Okay, that sounds good… except that it can include bytes that aren’t “web safe”.</p>
<p>So I needed a way to encode the output of <code>urandom</code>. I poked around some more and saw <a title="Manual for Python's binascii module" href="http://docs.python.org/3.3/library/binascii"><code>binascii.hexlify(<em>data</em>)</code></a> being used for this purpose (in Pyramid). For some reason, though, I thought it would be “clever” to hash the output from <code>urandom</code> like so: <code>hashlib.sha1(os.urandom(128)).hexdigest()</code>.</p>
<p>What I like about this is that no matter how many bytes you request from <code>urandom</code> (assuming more bytes means more entropy), you always end up with a 40 character string that’s safely encoded.</p>
<p>I’m not sure if this provides any <em>real</em> benefit though (in terms of increased security). Are there better ways to generate random tokens?</p>
<p>Another thought I had was to use <code>bcrypt.gensalt()</code> and use its output as is–it uses <code>urandom</code> to generate the initial salt, which is then hashed, and also returns a fixed number of bytes (29).</p>
<p><small>On a slightly related note, I recently needed to generate a new PIN. My first thought was to reuse a PIN I use elsewhere, but of course that’s a bad idea. My second thought was to use KeePassX to generate one. I happened to have a calculator sitting next to me (one with big buttons); I closed my eyes and banged on it a bit to generate the PIN.<br/>
</small></p>
	</div>
	
	</div></body></html>