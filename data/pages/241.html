<html><body><div><div id="articleText">
                    <p id="articleLongDescription">In Part 3 of his seven-part series on learning Python Pyramid,  Jesse Smith discusses the Python project structure.</p>
                    <p id="articleDescription"/>

                    <a class="relatedBookLink" href="#">Like this article? We recommend <span class="ss-icon"></span></a>
                    
                    

                <p>If you haven't read <a href="/articles/article.aspx?p=2161676">Part 1</a> and/or <a href="/articles/article.aspx?p=2161677">Part 2</a> of this series, I  recommend you do that before continuing with this article. In Part 2, we looked  at how to configure a Pyramid application using Declarative Configuration and  Imperative Configuration.</p>
<p>
  This article will cover  the application project structure. By taking a closer look at the project  structure, this will help us to know where important files are located along  with where to put our own files that will comprise the application.</p>
<h2>Project Structure</h2>
<p>In <a href="/articles/article.aspx?p=2161676">Part 1 of this  series</a>, we generated an example application using the scaffolding for a project called <tt>MyProject</tt>.  This section will use that example to outline a project structure. The main  application directory, <tt>MyProject</tt>, contains the following files that come  with every project:</p>
<ul>
  <li> <tt>Changes.txt</tt>. This  file contains the changes for your application. It's not a file to document code  changes, but rather a high-level overview of changes. The standard format is to  document changes by version, as in the following example:<br/>
<pre>1.0 (unreleased)
----------------------
-  Initial version
-  Drop support for Python 2.5</pre>

This file helps  other programmers to identify high-level changes that have taken place in the  application.</li>
<li> <tt>Readme.txt</tt>. Describes  the overall summary of what the application does, as in this example:<br/><br/>
<tt>This application is a web spider that traverses links on a web  site that is provided as starting point. A collection of the hyper-links is  stored to a database.</tt></li>
<li> <tt>development.ini</tt>. This  file holds the configuration for connecting to your web server. It uses  development configuration settings, as opposed to production settings. This  file will be covered in detail later in this series.</li>
<li> <tt>production.ini</tt>. This  file has the configuration for connecting to the web server. It uses production  configuration settings, as opposed to development settings. <tt>production.ini</tt> is basically the same as <tt>development.ini</tt>, but turns off debugging  options that slow page rendering.</li>
<li> <tt>MANIFEST.in</tt>. This  configuration file includes references to files that are not Python files, but  should be distributed with the application. Think of it as a JEE Java project  Manifest file for Java. The Java Manifest file is similar to a Python Manifest  file in that it references <tt>.jar</tt> files and the class path to their  location. Once the app is archived and then decompressed, Manifest creates a  roadmap to place the application source files. The following line could appear  in a Manifest file:<br/>
<pre>include *.txt *.js *.css</pre></li>
<li> <tt>setup.py</tt>. This is a  multipurpose command-line file used for testing, packaging, and distributing an  application. When distributing an app, this file looks at the  <tt>MANIFEST.in</tt> file to determine what  should be included in the app. Look at this example <tt>setup.py</tt> file:<br/>
<pre>import os

from setuptools import setup, find_packages

here = os.path.abspath(os.path.dirname(__file__))
README = open(os.path.join(here, 'README.txt')).read()
CHANGES = open(os.path.join(here, 'CHANGES.txt')).read()

requires = [
    'pyramid',
    'pyramid_debugtoolbar',
    'waitress',
    ]

setup(name='MyProject',
      version='0.0',
      description='MyProject',
      long_description=README + '\n\n' + CHANGES,
      classifiers=[
        "Programming Language :: Python",
        "Framework :: Pyramid",
        "Topic :: Internet :: WWW/HTTP",
        "Topic :: Internet :: WWW/HTTP :: WSGI :: Application",
        ],
      author='',
      author_email='',
      url='',
      keywords='web pyramid pylons',
      packages=find_packages(),
      include_package_data=True,
      zip_safe=False,
      install_requires=requires,
      tests_require=requires,
      test_suite="myproject",
      entry_points="""      [paste.app_factory]
      main = myproject:main
      """,
      )
</pre>

A lot of this  file's contents are application metadata. Running this file from the command  line creates an application tarball file that you can send to other people to  run the application. This is an example command:<br/>
<pre>$ python setup.py sdist</pre></li>
<li> <tt>setup.cfg</tt>. This file  contains settings that allow testing and internationalization of your application  to work smoothly. The default settings suffice most of the time.<br/>

The project  structure contains a series of folders called <em>packages</em>. These packages include the Python files that run your  application. The <tt>__init__.py</tt> file that's in a package folder tells  Python the folder is a package. A distribution is a collection of packages. The  top of the project folder hierarchy is referred to as the <em>distribution root</em>.</li>
<li><tt>myproject</tt> folder. This folder is the main package  for your application. Like all packages, it contains an entry point into the  package. In this case, it's the  application. A typical <tt>__init.py__</tt> file to initialize the application is  shown below:<br/>
<pre>from pyramid.config import Configurator

def main(global_config, **settings):
    """ This function returns a Pyramid WSGI application.
    """
    config = Configurator(settings=settings)
    config.add_static_view('static', 'static', cache_max_age=3600)
    config.add_route('home', '/')
    config.scan()
    return config.make_wsgi_app()</pre>

This file creates  an application server instance and connects it to the web server, allowing the  app to take HTTP requests. In terms of functionality, it's similar to a Java  Servlet. In this example, the <tt>home</tt> view is added to the routing  configuration, telling the app that nothing after the domain name (or IP/port  number) will show this view by default.</li>
<li> <tt>myproject\views.py</tt>.  This file contains view configurations, also known as <em>view callables</em>. I covered views in detail in <a href="/articles/article.aspx?p=2161677">Part 2 of this series</a>. View  callables are used in Declarative Configurations. An example <tt>views.py</tt> file appears below:<br/>
<pre>from pyramid.view import view_config

@view_config(route_name='home', renderer='templates/mytemplate.pt')
def my_view(request):
     return {'project': 'MyProject'}</pre>

The <tt>config.scan</tt> command in the <tt>__setyp.py__</tt> file seeks out these view declarations by  looking for the <tt>@view_config</tt> decorator to get the view details. The  function maps a route to a path and returns a <tt>Response </tt>object by the <tt>my_view</tt> function that can be used by the application.</li>
<li> <tt>myproject\static</tt>. The <tt>static</tt> subdirectory holds all the applications static files, such as <tt>.css</tt>, <tt>.html</tt>, and images.</li>
<li> <tt>myproject\templates\mytemplate.pt.</tt> Template files end with a <tt>.pt</tt> extension. This is the default template  file displayed by the <tt>my_view</tt> callable defined earlier. Templates are  often used by views. You can think of views as the presentation layer to your  application.</li>
<li> <tt>myproject\tests.py</tt>.  This module is used for unit-testing the application. It's generated by default  with a single unit test. Unit tests often test view requests. Following is an example  module:
<pre>import unittest

from pyramid import testing

class ViewTests(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def test_my_view(self):
        from .views import my_view
        request = testing.DummyRequest()
        info = my_view(request)
        self.assertEqual(info['project'], 'MyProject')</pre>
<h2>Conclusion</h2>
<p>In this article, you learned the basics of a Python project  structure. The structure is easy to follow and should be used as a means of  communicating with other Python developers. The structure is used by several  Python frameworks. It's important to understand which file types can be used by  the structure, along with their locations. This understanding makes adding  custom code much easier. One quick way to set up a Python project structure is  by using a scaffolding template application. This type of application can serve  as a good starting point for your project requirements.</p>
<p>
  In <a href="/articles/article.aspx?p=2161679">Part 4 of this series</a>, I'll cover the application startup process and take a closer  look at the <tt>development.ini</tt> configuration file, which has numerous  settings.</p>
            </li></ul></div>
            </div></body></html>