<html><body><div><article>
					<p>Callbacks can be messy, as <a href="http://en.wikipedia.org/wiki/Guido_van_Rossum">Guido Van Rossum</a> said in his recent <a href="http://www.youtube.com/watch?v=1coLC-MUCJc">asyncio talk</a> (@ 56:27 in the YouTube video):</p>
<blockquote><p>
“It requires super human discipline to write readable code in callbacks and if you don’t believe me look at any piece of JavaScript code.” ~ <cite>Guido Van Rossum</cite>
</p></blockquote>
<p>Fortunately you don’t have to write callbacks if you don’t want to.  You need only look to <a href="http://www.tornadoweb.org">Tornado</a> and <a href="http://motor.readthedocs.org/en/stable/">Motor</a></p>
<p><img src="https://dl.dropboxusercontent.com/u/19725222/joshaust.in/tornado-motor/tornado-plus-motor.png" alt="tornado and motor"/></p>
<p><a href="http://www.python.org/download/releases/3.3.3/">Python</a> has some neat features that let allow <a href="http://stackoverflow.com/questions/564060/python-generators-and-co-routines">generators to be used as coroutines</a>. The <a href="http://www.tornadoweb.org">Tornado Web Framework</a> includes <a href="http://www.tornadoweb.org/en/stable/gen.html">decorators to make this dead simple</a>.  For me, the biggest drawback to using Tornado was the lack of a good asynchronous db driver.  Using a blocking db driver sort of defeats the purpose of a non-blocking web server. Fortunately for those of us who don’t love writing callbacks, now there is a good solution.</p>
<p><a href="http://motor.readthedocs.org/en/stable/">Motor</a> is a first class asynchronous <a href="http://www.mongodb.com/">MongoDB</a> driver written by <a href="http://emptysqua.re/blog/about/">Jesse Jiryu Davis</a> from MongoDB that will soon take advantage of <a href="http://docs.python.org/3.4/library/concurrent.futures.html">Futures</a> to present an easy to use, but still asynchronous, interface with MongoDB. </p>
<p>Jesse announced some <a href="http://emptysqua.re/blog/motor-progress-report-the-road-to-0-2/">changes</a> that make using Motor even easier by incorporating Futures into the syntax, just like recent versions of Tornado. We are waiting on MongoDB v2.6 RC, which <a href="https://jira.mongodb.org/browse/SERVER#selectedTab=com.atlassian.jira.plugin.system.project%3Aroadmap-panel">roadmap</a> indicates will be released on 2/11/14 and the associated version of PyMongo.</p>
<p>In anticipation of this release, I thought it would be fun to look at just how far asynchronous db drivers for Tornado have come. Despite Jesse’s warnings that we should wait until the changes are official, we’ve been using these techniques at <a href="https://maasive.net">MaaSive.net</a> to supercharge developer productivity and increase clarity in our asynchronous code.</p>
<h3 id="inthebeginning">In the Beginning</h3>
<p>When I started using Motor v0.1 about a year ago this is what trivial DB access looked like for a simple handler that returns some JSON:</p>
<p/>
<p>If I only ever had to make one db call, and only had to write one callback handler this would not be so bad. The problem is that in reality I need to make several db calls, and may need to wait until two or more are complete to do anything useful. The callbacks get out of hand quickly.</p>
<p>The worst problem is that debugging becomes a nightmare of epic proportions. The entire reason we use Tornado is to enable <a href="http://en.wikipedia.org/wiki/Push_technology#Long_polling">long-polling</a> with lots of connections at the same time, and it becomes very hard to tell exactly where the problems are when lots of connections are active at the same time. Most developers (myself included) rely on stack-traces to debug our programs, but with callbacks like this you can kiss that nice stack-trace goodbye.</p>
<h3 id="thepresent">The Present</h3>
<p>Motor v0.1.2 has come a long way since that time. Today a trivial DB access looks like this:</p>
<p/>
<p>Technically you could also write it like this using <strong>motor.Op</strong>:</p>
<p/>
<p>This is much, <em>much</em> better than before. Tornado’s <strong>tornado.gen</strong> module does a great job putting together a “stack-trace” when an exception is thrown and while this is certainly acceptable and useable, it still feels a little clunky. Why do we have to write <strong>motor.Op</strong> for example?</p>
<p>The <strong>motor.Op</strong> class exists because motor has a forward looking maintainer who was planning for the <strong>Future</strong>.</p>
<h3 id="thefutures">The Future(s)</h3>
<p><em>disclaimer – this api is not released for Motor yet. It will come out with Motor v0.2 along with MongoDB 2.6 RC0 and PyMongo 2.7.</em></p>
<p>With Futures, we get to write the same thing like this:</p>
<p/>
<p>The <strong>cursor.to_list</strong> method returns a <strong>Future</strong> directly and yielding the <strong>Future</strong> blocks this coroutine, returning control to the event loop, until the result is ready. It does not get any easier than that.</p>
<h3 id="developercyclesareprecious">Developer Cycles are Precious</h3>
<p>For many projects the most expensive component is the time put in by the developers, or as I prefer to call them, developer cycles. One of the main reasons we use Python is for the <a href="http://redmonk.com/dberkholz/2013/03/25/programming-languages-ranked-by-expressiveness/">expressiveness</a> of the language. In my experience we can ship more features that our customers want, more quickly by developing in Python than we can in any other language.</p>
<p>Tornado and Motor are making it much easier to deploy asynchronous web servers than it has been in the past. The new <a href="http://docs.python.org/3.4/library/asyncio.html">AsyncIO</a> library will likely continue to accelerate that trend and that’s a good thing because I really don’t have time to write a bunch of callbacks. </p>
<p>What business needs are you solving with asynchronous web servers?</p>
				</article>
												
				</div></body></html>