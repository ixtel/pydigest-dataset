<html><body><div><div class="fw_reply_text"><p>Основная особенность assert в том, что можно запустить питон в режиме когда он их будет игнорировать. Отсюда и идет основная идея его использования - отладка. </p><p>Запуск в обычном режиме</p><p>$python</p><p>»&gt; assert False, "Ups"</p><p>Traceback (most recent call last):</p><p> File "&lt;stdin&gt;", line 1, in &lt;module&gt;</p><p>AssertionError: Ups</p><p>»&gt; </p><p>Запуск без asserts</p><p>cd:$ python -O </p><p>Python 2.7.6 (default, Jun 22 2015, 17:58:13) </p><p>[GCC 4.8.2] on linux2</p><p>Type "help", "copyright", "credits" or "license" for more information.</p><p>»&gt; assert False, "Ups"</p><p>Как видно во втором случае Exception не возник. Соотвественно как это можно применять? </p><p>Например у вас есть слой логики, и есть разные клиенты его использущие, мы заключаем контракт внутри команды с условием что все параметры передаваемые слою логики будут всегда валидны. </p><p>Чтобы облегчить себе разработку и избежать сложных непонятных ошибок возникших из за неправильной валидации используем asserts </p><p>например </p><p>def promote_user(user):</p><p> assert not </p><a href="/away.php?to=http%3A%2F%2Fuser.is" target="_blank">user.is</a><p>_guest(), "Guest not acceptable arg for promote_user"</p><p>Если какой то разработчик увидит что параметром метода идет юзер и случайно передаст гостя, он поймет свою ошибку во время выполнения. Таким образом, большая часть неправильного использования метода будет отловлена при разработке и тестировании. Это же позволит избежать ситуаций когда unit тестирование идет с использованием откровенно невалидных данных "лишь бы работало"</p><p>В релизе соотвественно запускаете с опцией -O, потому что вырезать все глупо, разработка продолжается. Но в production вам лишние assert не нужны. </p><p>Еще один из вариантов, при ограничении времени и написании сверхбыстрого прототипа не зная реальных данных использования вы можете использовать asserts для того чтобы подтвердить какие данные вы ожидаете. Все это дело логируем и частые asserts или блокирующие оперативно переписываем нормально. Это позволяет не обрабытывать 100500 ошибок "правильным" образом. </p><p>Например, наш прототип обращается к внешнему api, в ответе нам нужно одно единственное поле </p><p>assert "required" in data, "Api has no data"</p></div></div></body></html>