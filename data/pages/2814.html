<html><body><div><div class="post_body"><p/><center><img src="/static/images/flask-celery.png"/></center>
<p>The topic of running background tasks is complex, and because of that there is a lot of confusion around it. I have tackled it in my <a href="http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xi-email-support">Mega-Tutorial</a>, later in <a href="http://bit.ly/flaskbook">my book</a>, and then again in much more detail in my <a href="http://bit.ly/flaskapi">REST API training video</a>. To keep things simple, in all the examples I have used so far I have executed background tasks in threads, but I always noted that for a more scalable and production ready solution a <em>task queue</em> such as <a href="http://www.celeryproject.org/">Celery</a> should be used instead.</p>
<p>My readers constantly ask me about Celery, and how a Flask application can use it, so today I am going to show you two examples that I hope will cover most application needs.</p>
<h2>What is Celery?</h2>
<p>Celery is an asynchronous task queue. You can use it to execute tasks outside of the context of your application. The general idea is that any resource consuming tasks that your application may need to run can be offloaded to the task queue, leaving your application free to respond to client requests.</p>
<p>Running background tasks through Celery is not as trivial as doing so in threads. But the benefits are many, as Celery has a distributed architecture that will enable your application to scale. A Celery installation has three core components:</p>
<ol>
<li><strong>The Celery client</strong>. This is used to issue background jobs. When working with Flask, the client runs with the Flask application.</li>
<li><strong>The Celery workers</strong>. These are the processes that run the background jobs. Celery supports local and remote workers, so you can start with a single worker running on the same machine as the Flask server, and later add more workers as the needs of your application grow.</li>
<li><strong>The message broker</strong>. The client communicates with the the workers through a <em>message queue</em>, and Celery supports several ways to implement these queues. The most commonly used brokers are <a href="http://www.rabbitmq.com/">RabbitMQ</a> and <a href="http://redis.io/">Redis</a>.</li>
</ol>
<h2>For The Impatient</h2>
<p>If you are the instant gratification type, and the screenshot at the top of this article intrigued you, then head over to the <a href="https://github.com/miguelgrinberg/flask-celery-example">Github repository</a> for the code used in this article. The README file there will give you the quick and dirty approach to running and playing with the example application.</p>
<p>Then come back to learn how everything works!</p>
<h2>Working with Flask and Celery</h2>
<p>The integration of Celery with Flask is so simple that no extension is required. A Flask application that uses Celery needs to initialize the Celery client as follows:</p>
<pre><code>from flask import Flask
from celery import Celery

app = Flask(__name__)
app.config['CELERY_BROKER_URL'] = 'redis://localhost:6379/0'
app.config['CELERY_RESULT_BACKEND'] = 'redis://localhost:6379/0'

celery = Celery(app.name, broker=app.config['CELERY_BROKER_URL'])
celery.conf.update(app.config)
</code></pre>
<p>As you can see, Celery is initialized by creating an object of class <code>Celery</code>, and passing the application name and the connection URL for the message broker, which I put in <code>app.config</code> under key <code>CELERY_BROKER_URL</code>. This URL tells Celery where the broker service is running. If you run something other than Redis, or have the broker on a different machine, then you will need to change the URL accordingly.</p>
<p>Any additional configuration options for Celery can be passed directly from Flask's configuration through the <code>celery.conf.update()</code> call. The <code>CELERY_RESULT_BACKEND</code> option is only necessary if you need to have Celery store status and results from tasks. The first example I will show you does not require this functionality, but the second does, so it's best to have it configured from the start.</p>
<p>Any functions that you want to run as background tasks need to be decorated with the <code>celery.task</code> decorator. For example:</p>
<pre><code>@celery.task
def my_background_task(arg1, arg2):
    # some long running task here
    return result
</code></pre>
<p>Then the Flask application can request the execution of this background task as follows:</p>
<pre><code>task = my_background_task.delay(10, 20)
</code></pre>
<p>The <code>delay()</code> method is a shortcut to the more powerful <code>apply_async()</code> call. Here is the equivalent call using <code>apply_async()</code>:</p>
<pre><code>task = my_background_task.apply_async(args=[10, 20])
</code></pre>
<p>When using <code>apply_async()</code>, you can give Celery more detailed instructions about how the background task is to be executed. A useful option is to request that the task executes at some point in the future. For example, this invocation will schedule the task to run in about a minute:</p>
<pre><code>task = my_background_task.apply_async(args=[10, 20], countdown=60)
</code></pre>
<p>The return value of <code>delay()</code> and <code>apply_async()</code> is an object that represents the task, and this object can be used to obtain status. I will show you how this is done later in this article, but for now let's keep it simple and not worry about results from tasks.</p>
<p>Consult the <a href="http://docs.celeryproject.org/en/latest/index.html">Celery documentation</a> to learn about many other available options.</p>
<h2>Simple Example: Sending Asynchronous Emails</h2>
<p>The first example that I'm going to show is a very common need of applications: the ability to send emails without blocking the main application.</p>
<p>For this example I'm going to use the <a href="https://pythonhosted.org/Flask-Mail/">Flask-Mail</a> extension, which I covered in very good detail in other articles. I'm going to assume that you are familiar with this extension, so if you need a refresher see <a href="http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xi-email-support">this tutorial</a> or my <a href="http://bit.ly/flaskbook">Flask book</a>.</p>
<p>The example application that I'm going to use to illustrate the topic presents a simple web form with one text field. The user is asked to enter an email address in this field, and upon submission, the server sends a test email to this address. The form includes two submit buttons, one to send the email immediately, and another to send it after a wait of one minute. The top portion of the screenshot at the top of this article shows how this form looks.</p>
<p>Here is the HTML template that supports this example:</p>
<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Flask + Celery Examples&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Flask + Celery Examples&lt;/h1&gt;
    &lt;h2&gt;Example 1: Send Asynchronous Email&lt;/h2&gt;
    {% for message in get_flashed_messages() %}
    &lt;p style="color: red;"&gt;{{ message }}&lt;/p&gt;
    {% endfor %}
    &lt;form method="POST"&gt;
      &lt;p&gt;Send test email to: &lt;input type="text" name="email" value="{{ email }}"&gt;&lt;/p&gt;
      &lt;input type="submit" name="submit" value="Send"&gt;
      &lt;input type="submit" name="submit" value="Send in 1 minute"&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Hopefully you find nothing earth shattering here. Just a regular HTML form, plus the ability to show flashed messages from Flask.</p>
<p>The Flask-Mail extension requires some configuration, specifically the details about the email server to use when sending emails. To make things easy I use my Gmail account as email server:</p>
<pre><code># Flask-Mail configuration
app.config['MAIL_SERVER'] = 'smtp.googlemail.com'
app.config['MAIL_PORT'] = 587
app.config['MAIL_USE_TLS'] = True
app.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME')
app.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD')
app.config['MAIL_DEFAULT_SENDER'] = 'flask@example.com'
</code></pre>
<p>Note how to avoid putting my email account's credentials at risk I set them in environment variables, which I import from the application.</p>
<p>There is a single route to support this example:</p>
<pre><code>@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'GET':
        return render_template('index.html', email=session.get('email', ''))
    email = request.form['email']
    session['email'] = email

    # send the email
    msg = Message('Hello from Flask',
                  recipients=[request.form['email']])
    msg.body = 'This is a test email sent from a background Celery task.'
    if request.form['submit'] == 'Send':
        # send right away
        send_async_email.delay(msg)
        flash('Sending email to {0}'.format(email))
    else:
        # send in one minute
        send_async_email.apply_async(args=[msg], countdown=60)
        flash('An email will be sent to {0} in one minute'.format(email))

    return redirect(url_for('index'))
</code></pre>
<p>Once again, this is all pretty standard Flask. Since this is a very simple form, I decided to handle it without the help of an extension, so I use <code>request.method</code> and <code>request.form</code> to do all the management. I save the value that the user enters in the text field in the <code>session</code>, so that I can remember it after the page reloads.</p>
<p>The interesting bit in this route is the sending of the email, which is handled by a Celery task called <code>send_async_email</code>, invoked either via <code>delay()</code> or <code>apply_async()</code>.</p>
<p>The last piece of this application is the asynchronous task that gets the job done:</p>
<pre><code>@celery.task
def send_async_email(msg):
    """Background task to send an email with Flask-Mail."""
    with app.app_context():
        mail.send(msg)
</code></pre>
<p>This task is decorated with <code>celery.task</code> to make it a background job. The only notable thing in this function is that Flask-Mail requires an application context to run, so one needs to be created before the <code>send()</code> method can be invoked.</p>
<p>It is important to note that in this example the return value from the asynchronous call is not preserved, so the application will never know if the call succeeded or not. When you get to run this example, you can look at the output of the Celery worker to troubleshoot any problems with the sending of the email.</p>
<h2>Complex Example: Showing Status Updates and Results</h2>
<p>The above example is overly simple, the background job is started and then the application forgets about it. Most Celery tutorials for web development end right there, but the fact is that for many applications it is necessary for the application to monitor its background tasks and obtain results from it.</p>
<p>What I'm going to do now is extend the above application with a second example that shows a fictitious long running task. The user can start one or more of these long running jobs clicking a button, and the web page running in your browser uses ajax to poll the server for status updates on all these tasks. For each task the page will show a graphical status bar, a completion percentage, a status message, and when the task completes, a result value will be shown as well. You can see how all this looks in the screenshot at the top of this article.</p>
<h3>Background Tasks with Status Updates</h3>
<p>Let me start by showing you the background task that I'm using for this second example:</p>
<pre><code>@celery.task(bind=True)
def long_task(self):
    """Background task that runs a long function with progress reports."""
    verb = ['Starting up', 'Booting', 'Repairing', 'Loading', 'Checking']
    adjective = ['master', 'radiant', 'silent', 'harmonic', 'fast']
    noun = ['solar array', 'particle reshaper', 'cosmic ray', 'orbiter', 'bit']
    message = ''
    total = random.randint(10, 50)
    for i in range(total):
        if not message or random.random() &lt; 0.25:
            message = '{0} {1} {2}...'.format(random.choice(verb),
                                              random.choice(adjective),
                                              random.choice(noun))
        self.update_state(state='PROGRESS',
                          meta={'current': i, 'total': total,
                                'status': message})
        time.sleep(1)
    return {'current': 100, 'total': 100, 'status': 'Task completed!',
            'result': 42}
</code></pre>
<p>For this task I've added a <code>bind=True</code> argument in the Celery decorator. This instructs Celery to send a <code>self</code> argument to my function, which I can then use to record the status updates.</p>
<p>Since this task doesn't really do anything useful, I decided to use humorous status messages that are assembled from random verbs, adjectives and nouns. You can see the lists of non-sensical items I use to generate these messages above. Nothing wrong with having a little bit of fun, right?</p>
<p>The function loops for a random number of iterations between 10 and 50, so each run of the task will have a different duration. The random status message is generated on the first iteration, and then can be replaced in later iterations with a 25% chance.</p>
<p>The <code>self.update_state()</code> call is how Celery receives these task updates. There are a number of built-in states, such as <code>STARTED</code>, <code>SUCCESS</code> and so on, but Celery allows custom states as well. Here I'm using a custom state that I called <code>PROGRESS</code>. Attached to the state there is additional metadata, in the form of a Python dictionary that includes the current and total number of iterations and the randomly generated status message. A client can use these elements to display a nice progress bar. Each iteration sleeps for one second, to simulate some work being done.</p>
<p>When the loop exits, a Python dictionary is returned as the function's result. This dictionary includes the updated iteration counters, a final status message and a humorous <a href="http://en.wikipedia.org/wiki/42_%28number%29">result</a>.</p>
<p>The <code>long_task()</code> function above runs in a Celery worker process. Below you can see the Flask application route that starts this background job:</p>
<pre><code>@app.route('/longtask', methods=['POST'])
def longtask():
    task = long_task.apply_async()
    return jsonify({}), 202, {'Location': url_for('taskstatus',
                                                  task_id=task.id)}
</code></pre>
<p>As you can see the client needs to issue a <code>POST</code> request to <code>/longtask</code> to kick off one of these tasks. The server starts the task, and stores the return value. For the response I used status code 202, which is normally used in REST APIs to indicate that a request is in progress. I also added a <code>Location</code> header, with a URL that the client can use to obtain status information. This URL points to another Flask route called <code>taskstatus</code>, and has <code>task.id</code> as a dynamic component.</p>
<h3>Accessing Task Status from the Flask Application</h3>
<p>The <code>taskstatus</code> route referenced above is in charge of reporting status updates provided by background tasks. Here is the implementation of this route:</p>
<pre><code>@app.route('/status/&lt;task_id&gt;')
def taskstatus(task_id):
    task = long_task.AsyncResult(task_id)
    if task.state == 'PENDING':
        // job did not start yet
        response = {
            'state': task.state,
            'current': 0,
            'total': 1,
            'status': 'Pending...'
        }
    elif task.state != 'FAILURE':
        response = {
            'state': task.state,
            'current': task.info.get('current', 0),
            'total': task.info.get('total', 1),
            'status': task.info.get('status', '')
        }
        if 'result' in task.info:
            response['result'] = task.info['result']
    else:
        # something went wrong in the background job
        response = {
            'state': task.state,
            'current': 1,
            'total': 1,
            'status': str(task.info),  # this is the exception raised
        }
    return jsonify(response)
</code></pre>
<p>This route generates a JSON response that includes the task state and all the values that I set in the <code>update_state()</code> call as the <code>meta</code> argument, which the client can use to build a progress bar. Unfortunately this function needs to check for a few edge conditions as well, so it ended up being a bit long. To access task data I recreate the task object, which is an instance of class <code>AsyncResult</code>, using the task id given in the URL.</p>
<p>The first <code>if</code> block is for when the task hasn't started yet (<code>PENDING</code> state). In this case there is no status information, so I make up some data. The <code>elif</code> block that follows is that one that returns the status information from the background task. Here the information that the task provided is accessible as <code>task.info</code>. If the data contains a <code>result</code> key, then that means that this is the final result and the task finished, so I add that result to the response as well. The <code>else</code> block at the end covers the possibility of an error, which Celery will report by setting a task state of <code>"FAILURE"</code>, and in that case <code>task.info</code> will contain the exception raised. To handle errors I set the text of the exception as a status message.</p>
<p>Believe it or not, this is all it takes from the server. The rest needs to be implemented by the client, which in this example is a web page with Javascript scripting.</p>
<h3>Client-Side Javascript</h3>
<p>It isn't really the focus of this article to describe the Javascript portion of this example, but in case you are interested, here is some information.</p>
<p>For the graphical progress bar I'm using <a href="http://nanobar.micronube.com/">nanobar.js</a>, which I included from a CDN. I also included jQuery, which simplifies the ajax calls significantly:</p>
<pre><code>&lt;script src="//cdnjs.cloudflare.com/ajax/libs/nanobar/0.2.1/nanobar.min.js"&gt;&lt;/script&gt;
&lt;script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"&gt;&lt;/script&gt;
</code></pre>
<p>The button that starts a background job is connected to the following Javascript handler:</p>
<pre><code>    function start_long_task() {
        // add task status elements 
        div = $('&lt;div class="progress"&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;0%&lt;/div&gt;&lt;div&gt;...&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;/div&gt;&lt;hr&gt;');
        $('#progress').append(div);

        // create a progress bar
        var nanobar = new Nanobar({
            bg: '#44f',
            target: div[0].childNodes[0]
        });

        // send ajax POST request to start background job
        $.ajax({
            type: 'POST',
            url: '/longtask',
            success: function(data, status, request) {
                status_url = request.getResponseHeader('Location');
                update_progress(status_url, nanobar, div[0]);
            },
            error: function() {
                alert('Unexpected error');
            }
        });
    }
</code></pre>
<p>This function starts by adding a few HTML elements that will be used to display the new background task's progress bar and status. This is done dynamically because the user can add any number of jobs, and each job needs to get its own set of HTML elements.</p>
<p>To help you understand this better, here is the structure of the added elements for a task, with comments to indicate what each <code>div</code> is used for:</p>
<pre><code>&lt;div class="progress"&gt;
    &lt;div&gt;&lt;/div&gt;         &lt;-- Progress bar
    &lt;div&gt;0%&lt;/div&gt;       &lt;-- Percentage
    &lt;div&gt;...&lt;/div&gt;      &lt;-- Status message
    &lt;div&gt;&amp;nbsp;&lt;/div&gt;   &lt;-- Result
&lt;/div&gt;
&lt;hr&gt;
</code></pre>
<p>The <code>start_long_task()</code> function then instantiates the progress bar according to <a href="http://nanobar.micronube.com/">nanobar</a>'s documentation, and finally sends the ajax <code>POST</code> request to <code>/longtask</code> to initiate the Celery background job in the server.</p>
<p>When the <code>POST</code> ajax call returns, the callback function obtains the value of the <code>Location</code> header, which as you saw in the previous section is for the client to invoke to get status updates. It then calls another function, <code>update_progress()</code> with this status URL, the progress bar object and the root <code>div</code> element subtree created for the task. Below you can see this <code>update_progress()</code> function, which sends the status request and then updates the UI elements with the information returned by it:</p>
<pre><code>    function update_progress(status_url, nanobar, status_div) {
        // send GET request to status URL
        $.getJSON(status_url, function(data) {
            // update UI
            percent = parseInt(data['current'] * 100 / data['total']);
            nanobar.go(percent);
            $(status_div.childNodes[1]).text(percent + '%');
            $(status_div.childNodes[2]).text(data['status']);
            if (data['state'] != 'PENDING' &amp;&amp; data['state'] != 'PROGRESS') {
                if ('result' in data) {
                    // show result
                    $(status_div.childNodes[3]).text('Result: ' + data['result']);
                }
                else {
                    // something unexpected happened
                    $(status_div.childNodes[3]).text('Result: ' + data['state']);
                }
            }
            else {
                // rerun in 2 seconds
                setTimeout(function() {
                    update_progress(status_url, nanobar, status_div);
                }, 2000);
            }
        });
    }
</code></pre>
<p>This function sends the <code>GET</code> request to the status URL, and when a response is received it updates the different HTML elements for the task. If the background task completed and a result is available then it is added to the page. If there is no result then that means that the task ended due to an error, so the task state, which is going to be <code>FAILURE</code>, is shown as result.</p>
<p>When the server is still running the job I need to continue polling the task status and updating the UI. To achieve this I set a timer to call the function again in two seconds. This will continue until the Celery task completes.</p>
<p>A Celery worker runs as many concurrent jobs as there are CPUs by default, so when you play with this example make sure you start a large number of tasks to see how Celery keeps jobs in <code>PENDING</code> state until the worker can take it.</p>
<h2>Running the Examples</h2>
<p>If you made it all the way here without running the example application, then it is now time for you to try all this Celery goodness. Go ahead and clone the <a href="https://github.com/miguelgrinberg/flask-celery-example">Github repository</a>, create a virtual environment, and populate it:</p>
<pre><code>$ git clone https://github.com/miguelgrinberg/flask-celery-example.git
$ cd flask-celery-example
$ virtualenv venv
$ source venv/bin/activate
(venv) $ pip install -r requirements.txt
</code></pre>
<p>Note that the <code>requirements.txt</code> file included with this repository contains Flask, Flask-Mail, Celery and the Redis client, along with all their dependencies.</p>
<p>Now you need to run the three processes required by this application, so the easiest way is to open three terminal windows. On the first terminal run Redis. You can just install Redis according to the <a href="http://redis.io/download">download instructions</a> for your operating system, but if you are on a Linux or OS X machine, I have included a small script that downloads, compiles and runs Redis as a private server:</p>
<pre><code>$ ./run-redis.sh
</code></pre>
<p>Note that for the above script to work you need to have <code>gcc</code> installed. Also note that the above command is blocking, Redis will start in the foreground.</p>
<p>On the second terminal run a Celery worker. This is done with the <code>celery</code> command, which is installed in your virtual environment. Since this is the process that will be sending out emails, the <code>MAIL_USERNAME</code> and <code>MAIL_PASSWORD</code> environment variables must be set to a valid Gmail account before starting the worker:</p>
<pre><code>$ export MAIL_USERNAME=&lt;your-gmail-username&gt;
$ export MAIL_PASSWORD=&lt;your-gmail-password&gt;
$ source venv/bin/activate
(venv) $ celery worker -A app.celery --loglevel=info
</code></pre>
<p>The <code>-A</code> option gives Celery the application module and the Celery instance, and <code>--loglevel=info</code> makes the logging more verbose, which can sometimes be useful in diagnosing problems.</p>
<p>Finally, on the third terminal window run the Flask application, also from the virtual environment:</p>
<pre><code>$ source venv/bin/activate
(venv) $ python app.py
</code></pre>
<p>Now you can navigate to <code>http://localhost:5000/</code> in your web browser and try the examples!</p>
<h2>Conclusion</h2>
<p>Unfortunately when working with Celery you have to take a few more steps than simply sending a job to a background thread, but the benefits in flexibility and scalability are hard to ignore. In this article I tried to go beyond the "let's start a background job" example and give you a more complete and realistic portrait of what using Celery might entail. I sincerely hope I haven't scared you with too much information!</p>
<p>As always, feel free to write down any questions or comments below.</p>
<p>Miguel</p></div>
</div></body></html>