<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/files/f57/7df/678/f577df678f50473783bf17dbe79edd0d.jpg" align="left"/><p>Предлагаю вниманию читателей хабры и поклонникам python перевод довольно объемной статьи о форматировании строк. Сказка будет правдивой и намек в ней будет на то, что консерваторам стоит иногда рассматривать что-то новое, даже если привычка упорно сопротивляется.
</p><p>
Предугадывая любознательность читателей, склонных задавать вопросы не по теме разговора, скажу, что картинка имеет опосредованное отношение к python, правда не самое приятное. Предлагаю найти почему в качестве домашнего задания.
</p><p>
Жду замечания по ошибкам в оформлении и опечаткам в личку — с меня традиционные хабраплюшки.
</p><a name="habracut"/>

<b>Далее слова автора оригинальной статьи:</b>
<p>
Я уже много лет пишу на python. Но в самом начале этого пути мне было интересно узнать как форматировать строки в стиле Perl. Напомню, что Perl (и многие интерпретаторы командной строки в Unix) поддерживают два типа строковых литералов — с одинарными кавычками (когда строка выводится как есть), и двойными где на место переменных подставляются их значения. В Perl, например, можно написать что то вроде:

</p><pre><code class="perl">$name = 'Reuven';
print "Hello, $name\n";
</code></pre><p>
И программа, соответственно, напишет «Hello, Reuven».
</p><p>
Строковые литералы в python не зависят от типа кавычек и переменные в них никогда не разворачиваются в свои значения. Чтобы этого добиться традиционно использовался оператор % для строк. В этом контексте оператор смотрит на строку слева от себя и подсчитывает сколько значений нужно заменить на значения соответствующих переменных справа от себя. Результатом операции является новая строка со вставленными на место плейсхолдеров значениями переменных. Например:

</p><pre><code class="python">&gt;&gt;&gt; name = 'Reuven'
&gt;&gt;&gt; "Hello, %s" % name

'Hello, Reuven'
</code></pre><p>
Этот код на python вполне себе работает и выводит персонализированное приветствие. Так, несмотря на мою многолетнюю практику с python — я был вполне удовлетворен применением этого синтаксиса. Да, он не очень приятный и нет, я никогда не держал в памяти гору модификаторов printf, которые влияют на форматирование. В смысле я всегда использовал модификатор 's' (выводить как строку) и мне было достаточно того, что python неявно приводил аргументы к строке.
</p><p>
Но в данный момент факт, что синтаксис % подлежит списанию или, по крайней мере, объявлен устаревшим. В списке рассылки python-dev есть замечание, что в ветке 2.x он проживет минимум до 2022 года, но ничего не сказано про ветку 3.x, так что поддержка этого синтаксиса будет скоро удалена и применять его нежелательно. На смену ему пришел метод str.format. 
</p><p>
В своих уроках по python я всегда упоминал о str.format, но в конкретных примерах чаще все полагался все-таки на %. Я даже рекомендовал студентам использовать % так как лично мне он казался намного проще. 
</p><p>
Но стойкое ощущение того, что, я делаю что-то не так и, возможно, даже ввожу в заблуждение своих студентов подвигло меня поближе изучить str.format. В ходе исследования, я пришел к следующим выводам: 1) Он ничуть не сложнее % и даже проще в некоторых вариантах применения; 2) Я никогда не применял возможности str.format в полной мере, а они очень удобные, несмотря на некоторое время необходимое для их изучения.
</p><p>
Начнем с простейшего. Скажем кому-нибудь «Good morning», причем обратимся по имени и фамилии, предполагая что они сохранены в переменных «first» и «last». По-старому мы сделали бы так:

</p><pre><code class="python">&gt;&gt;&gt; first = 'Reuven'
&gt;&gt;&gt; last = 'Lerner'
&gt;&gt;&gt; "Good morning, %s %s" % (first, last)

'Good morning, Reuven Lerner'
</code></pre><p>
Даже в таком примере мы сталкиваемся с одной из проблем %-синтаксиса — у нас теперь две переменных, и чтобы использовать их обе нам нужно сделать из них кортеж. С точки зрения python это логично, но, уверяю вас, очень многих студентов это очень удивляет.
</p><p>
Как этот пример будет выглядеть в случае str.format? Довольно похоже:

</p><pre><code class="python">&gt;&gt;&gt; "Good morning, {} {}".format(first, last)

'Good morning, Reuven Lerner'
</code></pre><p>
Прошу обратить внимание, что мы немного поменяли принцип. Теперь это не бинарный оператор над строками, а метод объекта строка, принимающий ряд параметров. Это логично и более консистентно. Для тех же студентов оператор % в моих примерах выглядел как дополнение к print, а не операция над строками. Нотация с ".format" после строки делает более очевидным факт того, что это метод относящийся именно к этой строке.
</p><p>
Как вы уже наверняка знаете, вхождения “{} {}” в строке говорят что str.format должен принимать два параметра, значения которых будут вставлены в строку в том порядке, в котором они будут переданы в метод. Аргумента два, поэтому в строке должно быть два вхождения {}. Это немного сложнее понять, так как фигурные скобочки в Python намекают людям на словари и пустые скобочки выглядят не очень приятно. Но это ладно, я вполне могу с этим жить и принял это достаточно легко.
</p><p>
Момент, в котором str.format показывает первое преимущество над % — это при необходимости использования параметров в обратном порядке. На самом деле, с %s этого вообще никак не достичь. Невозможно также использовать значение одной переменной несколько раз. При использовании str.format мы вполне можем поменять последовательность подстановки:

</p><pre><code class="python">&gt;&gt;&gt; "Good morning, {1} {0}".format(first, last)

'Good morning, Lerner Reuven'
</code></pre><p>
Обратите внимание, что если бы я использовал пустые скобочки “{} {}”, то подстановка произошла бы в том же порядке, в каком передаются в метод параметры. Можно представить себе параметры как индексируемую с нуля последовательность и если я хочу поменять порядок следования, то просто проставляю в фигурных скобочках нужные индексы этой последовательности. Самый первый наш пример с str.format можно записать и так:

</p><pre><code class="python">&gt;&gt;&gt; "Good morning, {0} {1}".format(first, last)

'Good morning, Reuven Lerner'
</code></pre><p>
Заметим, что явно указав индексы, мы уже не можем положиться на автоматическую индексацию.
</p><p>
Разумеется, можно использовать последовательность и из списка, воспользовавшись оператором *:

</p><pre><code class="python">&gt;&gt;&gt; names = ('Reuven', 'Lerner')
&gt;&gt;&gt; "Good morning, {} {}".format(*names)

'Good morning, Reuven Lerner'
</code></pre><p>
Можно использовать и именованные аргументы:

</p><pre><code class="python">&gt;&gt;&gt; "Good morning, {first} {last}".format(first='Reuven', last='Lerner')

'Good morning, Reuven Lerner'
</code></pre><p>
Этот вариант мне особенно нравится. Именованные параметры более явные (если у них хорошие имена), и применение {first} и {last} достаточно читабельно — особенно в сравнении с %(first)s, которое необходимо с оператором %
</p><p>
Именованные параметры можно, также, развернуть из словаря, используя оператор **:

</p><pre><code class="python">&gt;&gt;&gt; person = {'first':'Reuven', 'last':'Lerner'}
&gt;&gt;&gt; "Good morning, {first} {last}".format(**person)

'Good morning, Reuven Lerner'
</code></pre><p>
Я описал все это своим студентам и был достаточно удивлен тем насколько комфортнее им живется с таким синтаксисом. Да и самому стало приятнее работать.
</p><p>
Нужно упомянуть, что именованные и позиционные аргументы технически можно использовать совместно. Но лучше этого не делать:

</p><pre><code class="python">&gt;&gt;&gt; person = {'first':'Reuven', 'last':'Lerner'}
&gt;&gt;&gt; "Good {0}, {first} {last}".format('morning', **person)

'Good morning, Reuven Lerner'
</code></pre>
<p>
Я предупредил.
</p><p>
Чего может не хватать в str.format, так это… гм… форматирования. Плохая новость — в str.format совершенно другие правила определения того как форматировать вывод. Хорошая новость — эти правила достаточно несложно изучить и понять.
</p><p>
Снова начнем с простого: если нужно вывести строку заданной длины, то после имени переменной добавляем двоеточие (:) и затем количество символов. Так, чтобы вывести мое имя и дополнить его до десяти символов пробелами я должен делать так:

</p><pre><code class="python">&gt;&gt;&gt; "Your name is {name:10}".format(name="Reuven")

'Your name is Reuven    '
</code></pre><p>
(Обратите внимание что строка дополнена пробелами после имени.)
</p><p>
Если нужно задать выравнивание по правой стороне блока — используется знак &gt; между: и числом:

</p><pre><code class="python">&gt;&gt;&gt; "Your name is {name:&gt;10}".format(name="Reuven")

'Your name is     Reuven'
</code></pre><p>
И да, можно явно указать что я хочу выравнивания по левой стороне с помощью знака &lt;</p><p>
Если нужно вывести значение в центре блока, то вместо &lt; и &gt; используется символ ^:

</p><pre><code class="python">&gt;&gt;&gt; "Your name is {name:*^10}".format(name="Reuven")

'Your name is **Reuven**'
</code></pre><p>
С текстом более менее понятно, но что насчет чисел? Лично мне было трудно предположить как это будет работать, но все оказалось достаточно прямолинейно. Для простого вывода чисел используем синтаксис похожий на строки:

</p><pre><code class="python">&gt;&gt;&gt; "The price is ${number}.".format(number=123)

'The price is $123.'
</code></pre><p>
Но для чисел применяется большее количество модификаторов, чем для строк. Например, чтобы вывести число в двоичном виде добавляем модификатор «b», если в шестнадцатеричном — модификатор «x»:

</p><pre><code class="python">&gt;&gt;&gt; "The price is ${number:b}.".format(number=5)

'The price is $101.'

&gt;&gt;&gt; "The price is ${number:x}.".format(number=123)

'The price is $7b.'

</code></pre><p>
Разумеется, запись числа можно дополнить лидирующими нулями:

</p><pre><code class="python">&gt;&gt;&gt; "Your call is important to us. You are call #{number:05}.".format(number=123)

'Your call is important to us. You are call #00123.'
</code></pre><p>
Заметим, что внутри {} нельзя использовать исполняемый python-код — вместо этого предлагается простенький микроязык отдельный и отличающийся от python в целом. Есть и небольшие исключения. Во-первых можно получить значения атрибутов/свойств через точку, во-вторых получить значение объекта по индексу, используя []. 
</p><p>
Например:

</p><pre><code class="python">&gt;&gt;&gt; class Foo(object):
        def __init__(self):
        self.x = 100
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; 'Your number is {o.x}'.format(o=f)

'Your number is 100'n
</code></pre><p>
Мы получили атрибут «х» объекта «f». Этот объект доступен по имени «o» внутри строки. Получить атрибут можно, а вот выполнить его — нет:

</p><pre><code class="python">&gt;&gt;&gt; "Your name is {name.upper()}".format(name="Reuven")

AttributeError: 'str' object has no attribute 'upper()'
</code></pre><p>
Я пытался выполнить “name.upper()”, предполагая, что будет вызван соответствующий метод, но python не разрешает выполнять код в этом месте и расценивает «upper()» как атрибут вместе со скобками. Без скобок вы получите просто строковое представление функции/метода:

</p><pre><code class="python">&gt;&gt;&gt; "Your name is {name.upper}".format(name="Reuven")

'Your name is &lt;built-in method upper of str object at 0x1028bf2a0&gt;'
</code></pre><p>
С помощью квадратных скобок можно взять элемент итерируемого объекта (списка, строки) по индексу. Но операции разрезания (slice) не поддерживаются:

</p><pre><code class="python">&gt;&gt;&gt; "Your favorite number is {n[3]}.".format(n=numbers)

'Your favorite number is 3.'
</code></pre><p>
Но:

</p><pre><code class="python">&gt;&gt;&gt; "Your favorite numbers are {n[2:4]}.".format(n=numbers)

ValueError: Missing ']' in format string
</code></pre><p>
Можно использовать [] и для получения записей в словаре по имени, но имя вводится без кавычек:

</p><pre><code class="python">&gt;&gt;&gt; person = {'first':'Reuven', 'last':'Lerner'}
&gt;&gt;&gt; "Your name is {p[first]}.".format(p=person)

'Your name is Reuven.'
</code></pre><p>
При попытке использовать кавычки получим исключение…

</p><pre><code class="python">&gt;&gt;&gt; "Your name is {p['first']}.".format(p=person)

KeyError: "'first'"
</code></pre><p>
Здесь приведены не все варианты использования str.format — на деле для каждого типа есть спецификация правил форматирования. Например, опция точности для чисел с плавающей запятой недоступна для строк.
</p><p>
Можно даже добавить собственные правила форматирования для объектов ваших классов так, что у них будет особый способ вывода и модификаторы для его настройки.
</p><p>
Если есть желание изучить эту тему подробнее — стоит начать с PEP 3101, где описан str.format. Могу, также, порекомендовать презентацию Эрика Смита с достаточно хорошим саммари по этой теме. Есть и хорошие примеры о том как перейти от использования % к str.format в документации python 
</p><p>
Надеюсь, вам понравилось!
</p><p>
P… S.: Автор оригинальной статьи </p><a href="http://blog.lerner.co.il/relative-speeds-str-format/">замерил</a><p> производительность str.format и %. Пришел к выводу, что % быстрее
</p><p>
P.P.S.: По словам Андрея Светлова  </p><a href="http://habrahabr.ru/users/svetlov/" class="user_link">svetlov</a><p> (словам которого можно доверять в силу его вхожести в команду разработки python) — синтаксис % не будет убран из python 3.x минимум ближайшие 20 лет
        	</p><div class="polling">
		

	

    <p class="for_users_only_msg">Только зарегистрированные пользователи могут участвовать в опросе. <a href="https://habrahabr.ru/auth/login/">Войдите</a>, пожалуйста.</p>
	</div>

      <p class="clear"/>
    </div>

    
  </div></body></html>