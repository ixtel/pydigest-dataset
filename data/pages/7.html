<html><body><div><div class="content html_format">
      <img alt="image" align="left" src="https://habrastorage.org/getpro/habr/post_images/b06/428/07a/b0642807ac7fe037b7a71f4e2bef740f.jpg"/><p> В этой статье мы рассмотрим способ разворачивания веб приложений, написанных с использованием различных технологий, в облаке Azure Cloud Services. А именно это будет Ruby, Python, Node.js, Perl и с некоторыми оговорками также Java и Railo (ColdFusion). В качестве примера Ruby приложения будем использовать Redmine, работающий на Ruby on Rails, в Python пойдет Lightning Fast Shop, работающий на Django, в Node.js будем использовать небольшой проект с использованием express.js, на Perl будем ставить пустой проект Mojolicious. Целью данной статьи не является экскурс по всем этим веб технологиям, а лишь показать удобный и универсальный способ публикации в облаке Azure. Так что кода на Ruby, Python или Perl в ней не будет. Зато будет много скриншотов, shell-скриптов и инструкций по упаковке и развертыванию приложений.
</p><a name="habracut"/>
<p>
Итак, что же такое Azure Cloud Services и с чем его едят: 
</p><p>
К сожалению, обилие маркетинговых материалов в сети плохо раскрывает эту тему и создает много шума. А мы попробуем обсудить этот вопрос человеческим языком, понятным для простых веб разработчиков. Во первых, что важно понимать разработчику, который хочет узнать как пользоваться Azure Cloud Services, это то что данная услуга фактически представляет собой фабрику виртуальных машин. Как это реализовано технически не так важно, главное, что нам интересно это то, что инфраструктура Azure может достаточно быстро и автоматически предоставить нам некоторое количество идентичных виртуальных машин с некоторым количеством ресурсов, на которых может работать наш веб сайт или другое приложение. 
</p><p>
В системе Azure все эти виртуальные машины примерно одинаковые и могут быть Windows Server 2008, 2008 R2 и 2012. Видимо, это сделано потому что создание таких виртуальных машин обходится системе достаточно дешево и сами эти машины потребляют не много ресурсов плюс одинаковыми виртуалками легко управлять. Хотя лично мне не известно внутреннее устройство Azure Cloud Services и это лишь предположение. Главное отличие от VPS-хостинга в том что нам не нужно настраивать эти виртуальные машины. Система Azure сама развернет виртуальную машину и сама установит на нее наше приложение, когда это будет нужно. Это позволяет динамически создавать и удалять виртуальные машины по мере необходимости, автоматически и без нашего участия. Для того чтобы реализовать эту технологию наше приложение должно быть особым образом написано и упаковано, чтобы система знала как его устанавливать. 
</p><p>
Зачем это выгодно нам: В первую очередь это экономия ресурсов, а значит и наших денег (зависит, конечно, от цены услуги). Сайтам не все время нужно максимальное количество ресурсов. Если покупая VPS или Dedicated хостинг мы вынуждены брать максимальную конфигурацию, которая нам может потребоваться, то в случае с Azure Cloud Services мы можем платить только за те виртуальные машины, которые нам нужны в данный момент. Когда нагрузка на ресурс будет возрастать, система Azure будет автоматически выделять новые виртуальные машины для обслуживания нашего сайта. Когда нагрузка упадет, виртуальные машины вернуться системе и мы не будем за них платить. 
</p><p>
Зачем это нужно хостеру (в данном случае Microsoft): Причина та же – экономия ресурсов. Обычно разным сайтам и сервисам максимальное количество ресурсов нужно не одновременно. Значит, это позволяет провайдеру захостить больше веб сайтов на меньшем количестве физических ресурсов. Та же экономия, как и в случае с shared hosting – не всем нужна пиковая нагрузка одновременно. Поэтому shared hosting обычно и стоит дешевле. 
</p><p>
А теперь неприятный момент – это усложняет разработку приложения и привязывает нас к платформе. Вернее не усложняет, а немного меняет подход, делает его не столь привычным. Ведь обычно разработчики привыкли, что есть некоторый сервер, к которому можно открыть SSH сессию или RDP, где выполнить различные команды по конфигурации нужной им среды. Несмотря на то, что теоретически в системе Azure Cloud Services тоже можно открыть RDP к виртуальной машине, толку от этого чуть, разьве что в отладочных целях. Ведь через 5 минут система может наплодить еще десяток таких «серверов» которые не будут сконфигурированы вами вручную. А потом и вовсе удалить ваш настроенный сервер без предупреждения. 
</p><p>
Решить проблему конфигурации серверов достаточно просто – нужно упаковать наше приложение перед публикацией так, чтобы система сама знала как его настраивать, какие действия нужно выполнить на сервере чтобы наше приложение заработало. В этот пакет кроме самого приложения должны входить также все его зависимости, которые могут понадобиться на сервере для его запуска и настройки. А самое главное там должны быть скрипты, которые смогут сконфигурировать чистую новую виртуальную машину под наше приложение. Система Azure будет разворачивать этот пакет и выполнять скрипты каждый раз, когда новая виртуальная машина входит в строй. 
</p><p>
В этой статье мы будем использовать такое решение, чтобы сохранить максимальную независимость от платформы. Ведь платформозависимость и невозможность затем переехать на другой сервис – один из главных факторов тормозящих переход на облачные сервисы на данный момент. Не случайно мы выбрали общеизвестные приложения для примеров и технологии с открытым кодом – способы настройки этих приложений на других платформах общеизвестны. А значит при необходимости можно переносить приложение с одной платформы на другую. Итак, достаточно теории, перейдем к практике. Сейчас будем рассматривать пример использования по каждой технологии по очереди. Так как для каждой технологии будет много одинаковых действий, чтобы сократить статью я не буду повторяться, поэтому я советую читать весь текст подряд, даже если данную конкретную технологию вы использовать не собираетесь. 

</p><h1>Ruby</h1><p>
Начнем с Ruby и рассмотрим на ее примере все основные положения, так что эта глава будет самой длинной. Если вы с Ruby не работали – ничего страшного. Мы практически не будем использовать специфических команд, а действия по настройке всех платформ однотипны. Во первых нам понадобится рабочая станция Windows. Мы будем использовать </p><a href="http://www.helicontech.com/zoo/">Helicon Zoo</a><p> для запуска Ruby приложений на IIS как на рабочей станции, так и в системе Azure. Мало того что так будет легче конфигурировать среду выполнения для нашего приложения, такая конфигурация в Azure создаст значительно лучшее и более надежное с точки зрения производительности решение, чем запуск Ruby процесса с встроенным сервером на 80-м порту, как это часто делают в других инструкциях. Плюс запуск приложения в IIS еще и позволит нам включить в приложение другие технологии и возможности самого IIS, добавить к сайту секции на ASP.NET и других языках перечисленных в этой статье, сконфигурировать SSL и URL Rewriting, полноценно использовать многоядерные машины, отгружать статические данные средствами самого IIS что также значительно сэкономит ресурсы, и многое другое. 
</p><p>
Если вы уже работали с Ruby, то возможно на вашей рабочей станции уже есть установленная и сконфигурированная версия Ruby, с установленными gem-ами и т.д. Это все хорошо, но как ее перенести в Azure Cloud Services? Используя же пакеты Helicon Zoo, мы сможем упаковать все зависимости приложения в один архив, что позволит нам легко переносить его на другие сервера и в Azure Cloud Services в том числе. Так что для верности мы будем устанавливать свежую версию Ruby из репозитория Helicon Zoo, независимо от наличия другого Ruby на вашей машине. 
</p><p>
Итак, пройдем по ссылке и установим </p><a href="http://www.microsoft.com/web/downloads/platform.aspx">Microsoft Web Platform Installer</a><p>. Запустим его и нажмем Options и в открывшемся окне добавим Helicon Zoo feed: </p><a href="http://www.helicontech.com/zoo/feed.xml">http://www.helicontech.com/zoo/feed.xml</a> 
<p>
На рабочей станции советую также выбирать IIS Express в качестве сервера, т.к. с ним будет проще работать для тестов и потребуется меньше настроек. 

</p><img src="https://habrastorage.org/getpro/habr/post_images/f2f/b3d/7fa/f2fb3d7fa687c989dde2210c9ab9a363.png"/> 
<p>
Далее нужно установить Windows Azure SDK и легче всего это сделать, воспользовавшись все тем же Web Platform Installer. Введите в поиске «Azure SDK 2.1» или просто нажмите на </p><a href="http://wpi:placeholder&amp;amp;WindowsAzureSDK_2_1???">эту ссылку</a><p>. Если на момент прочтения статьи версия SDK устареет и ссылка не будет работать, просто найдите более новую в списке: 

</p><img src="https://habrastorage.org/getpro/habr/post_images/6e2/d04/ad3/6e2d04ad3df4d342432954ad8c3b9387.png"/>
<p>
В Azure SDK входит набор утилит по созданию и тестированию пакетов для Windows Azure Cloud Services, который нам и понадобится. Мы будем использовать утилиты командной строки и не будем использовать Visual Studio и другие инструменты по автоматической публикации сайтов, так как я старался минимизировать количество «магии» в статье. Тем более раз мы публикуем приложение на Ruby, то сомнительно, что именно Visual Studio будет вашим инструментом разработки. Поэтому я предлагаю ставить именно базовый Azure SDK, а не Azure SDK for Ruby. В последний уже входит некоторый дистрибутив Ruby и набор конфигураций, которые возможно и не плохи, но определенно не те, которые будут использованы в этой статье. Если вы все же привыкли использовать Visual Studio для создания пакетов Azure, то для вас не составит труда создать нужный пакет вручную, пользуясь этой статьей. 
</p><p>
Теперь давайте создадим Ruby приложение на нашей рабочей станции. Если у вас уже есть готовое Ruby Rack приложение, то вам нужно запустить Web Platform Installer, и установить «Ruby project» из секции Zoo -&gt; Templates. Далее следуйте инструкциям на пригласительной странице получившегося шаблонного сайта. 

</p><img src="https://habrastorage.org/getpro/habr/post_images/58f/2fd/246/58f2fd2464d6deb9e349f22d0d7927bf.png"/>
<p>
Однако всем уже, похоже, надоела установка «Hello World» приложений, а написание более продвинутого кода выходит за рамки этой статьи, поэтому мы просто будем ставить Redmine, как достаточно сложное и известное Ruby on Rails приложение с открытым кодом. Для этого откройте все тот же Web Platform Installer, зайдите в Zoo -&gt; Applications и установите Redmine. По завершении установки запустится процесс развертывания приложения, который просто автоматически выполняет шаги, описанные в </p><a href="http://www.helicontech.com/articles/installing-redmine-on-windows-in-production/">этой статье<sup>(англ.)</sup></a><p> в разделе Manual installation. 

</p><img src="https://habrastorage.org/getpro/habr/post_images/38c/46f/90c/38c46f90cc9e0654a71e10db4b909b65.png"/>
<p>
При этом никакой предварительной установки Ruby, Dev Kit, gem-ов и даже самого IIS Express не требуется – обо всем позаботится Web Platform Installer и Helicon Zoo. Все требуемые пакеты будут загружены из интернет и установлены на вашу рабочую станцию. После окончания установки всех компонентов вы должны увидеть первую страницу Redmine. Конечно, по-хорошему еще нужно сконфигурировать правильную базу данных, но для нашего теста уже вполне достаточно используемой по умолчанию SQLite. 
</p><p>
Обратите внимание на структуру файлов получившегося сайта (может понадобится нажать F5 в WebMatrix чтобы обновить вид папок): 

</p><img src="https://habrastorage.org/getpro/habr/post_images/8c5/01c/14f/8c501c14f55a883db3ba187564659ac5.png"/>
<p>
В папке GEM_HOME собраны все gem-ы, от которых зависит наше приложение. Именно оттуда они и будут загружаться во время работы. Файл deploy_done.rb – это скрипт deploy.rb, выполнение которого мы наблюдали на предыдущем шаге, на странице с сообщением «Application deployment in progress». По завершении его выполнения Helicon Zoo переименовал этот файл в deploy_done.rb, чтобы исключить повторный запуск без надобности. Если вам понадобится запустить процесс по-новой, просто переименуйте этот файл обратно в deploy.rb и со следующего запроса к серверу скрипт будет запущен снова. В этом скрипте содержатся стандартные команды нахождения и установки недостающих зависимостей, создания при необходимости и миграций базы данных и т.п. Это один из способов как выполнять команды в контексте приложения подробнее о котором можно прочитать в </p><a href="http://www.helicontech.com/zoo/docs/deployment.htm">документации Helicon Zoo</a><sup>(англ.)</sup><p>. Другой способ – это запустить Helicon Zoo Manager (for IIS Express) из Start -&gt; Programs -&gt; Helicon –&gt; Zoo, а там, выбрав наше приложение, можно нажать на Start Web console или Start IDE. 

</p><img src="https://habrastorage.org/getpro/habr/post_images/3ff/f61/363/3fff6136379982344fe01621513057f0.png"/>
<p>
Web console позволяет выполнять команды в контексте приложения и от лица пользователя этого приложения (Application pool user в случае IIS и интерактивного пользователя в случае IIS Express), как на локальной машине, так и на удаленном сервере. Кнопка Start IDE позволяет запустить программу (по умолчанию это будет командная строка cmd.exe) в предварительно сконфигурированной среде из переменных и путей для выбранного веб приложения. Это также позволит выполнять команды, которые будут применены к нашему приложению, а не глобально к системе. Большинство современных IDE, таких как Aptana или PyCharm, имеют встроенную командную строку, корректно распознают эти переменные и позволяют работать с локальными папками приложения более-менее изолированно и выполнять команды прямо из среды. Так что я рекомендую сконфигурировать запуск вашего любимого IDE по кнопке Start IDE и выполнять все команды оттуда. Еще можно экспортировать переменные окружения в .cmd-файл нажав на Tools -&gt; Export application environment. Этот файл затем можно вызывать перед выполнением других скриптовых команд предназначенных для приложения и он установит требуемые пути и переменные среды. Это удобно если например вам нужно применить команды к приложению по таймеру из Windows Scheduler. 
</p><p>
Почему так важно использовать именно эти инструменты? Потому что они позволяют упаковать все зависимости внутрь приложения. Ведь наше приложение будет отправлено для работы на Azure Cloud Services и нам нужно иметь при себе все необходимые зависимости. Разумеется, мы могли бы выполнять Ruby команду 'bundle install' чтобы скачать из интернета и установить все зависимости каждый раз, когда новый узел Cloud Services входит в строй. Однако тогда наше приложение будет зависеть еще и от работы сервиса rubygems.org и других интернет ресурсов, 100% доступность которых под вопросом. К тому же всегда есть вероятность, что мы забудем указать точную версию какого ни будь gem-а из вторичных зависимостей и наше приложение вдруг перестанет работать с выходом новой, несовместимой версии gem-а, хотя мы вроде бы ничего и не меняли. Помножите все эти вероятности, и вы получите не такой уж и привлекательный аптайм. Значит, нам нужно минимизировать число внешних зависимостей, чтобы по возможности при установке из интернета не качалось ничего – тогда все новые виртуальные машины будут точными копиями друг друга. 
</p><p>
И тут есть один тонкий момент – привычка. Если например программисты на Java привыкли что все зависимости должны быть упакованы с приложением как само собой разумеющееся, то программисты на Ruby больше привыкли конфигурировать сервер руками и на свое усмотрение. Так что работа с Helicon Zoo потребует некоторой дисциплины, а именно: нельзя запускать консоль или IDE для работы с приложением, даже на вашей рабочей станции, предварительно не сконфигурировав пути к приложению. Сделать это можно либо запустив консоль и IDE из Helicon Zoo Manager, либо выполнив экспортированный из приложения environment.cmd файл перед запуском других команд. Отсюда также следует, что нельзя устанавливать gem-ы и другие модули глобально. Пользуясь этими правилами можно получить легко портируемое приложение, которое удобно переносить с одного сервера на другой. 
</p><p>
Так как мы устанавливали Redmine прямо из репозитория Helicon Zoo, то все зависимости были установлены в приложение автоматически. Теперь, чтобы перенести наш Redmine на другой сервер, нам понадобится лишь установить Helicon Zoo -&gt; Ruby Hosting Package на этом сервере и перенести саму папку с сайтом. В пакет Ruby Hosting Package уже входит Ruby разных версий, Dev kit, Helicon Zoo Module и все другие зависимости что могут пригодится на сервере. Вместо установки Ruby Hosting Package можно в принципе установить только требуемые пакеты из репозитория Helicon Zoo отдельно, чтобы сэкономить место. Однако тут повышается вероятность что-то пропустить, да и места дистрибутивы Ruby занимают не так много чтобы экономить. 
</p><p>
На сервере мы не будем качать пакеты Ruby и Helicon Zoo из интернета чтобы не зависить от доступности дистрибутивов и серверов. Для этого также существует способ упаковать все один раз, чтобы потом устанавливать из архива. Мы используем Web Platform Installer и утилиту командной строки </p><b>WebpiCMD.exe</b><p>. Найти ее можно обычно в папке установки Web Platform Installer: C:\Program Files\Microsoft\Web Platform Installer. Эта утилита может упаковывать продукты из Web Platform Installer для их последующей установки без подключения к интернет. 
</p><p>
Для начала запустите консоль с административными правами, кликнув на ней правой кнопкой и выбрав пункт 'Run as administrator': 

</p><img src="https://habrastorage.org/getpro/habr/post_images/0a9/29f/2b0/0a929f2b0ea15871e81ba3d21c60085f.png"/>
<p>
Это нужно чтобы не открывалось новое окно консоли при запуске WebpiCMD.exe, иначе читать вывод команды будет затруднительно. Сохранять установочные пакеты будем в самой директории сайта с Redmine в папку 'offline-package'. Т.к. я устанавливал Redmine под IIS Express, то мой сайт находится в папке 'C:\Users\</p><b>Slov</b><p>\Documents\My Web Sites\</p><b>redmine222</b><p>'. В вашем случае имя папки будет другим, так что исправьте это в следующей команде и выполните в консоли:

</p><pre><code>mkdir "C:\Users\Slov\Documents\My Web Sites\redmine222\offline-package"

WebpiCmd.exe /offline /Products:RubyHostingPackage /Path:"C:\Users\Slov\Documents\My Web Sites\redmine222\offline-package" /Feeds:http://www.helicontech.com/zoo/feed.xml</code></pre>
<p>
Как видно из команды мы указываем продукт, который должен быть сохранен для offline-установки. При этом WebpiCmd.exe сохранит все его возможные зависимости, битности и т.п. В команду пеердается путь к папке куда сохранять пакеты и URL репозитория Helicon Zoo, откуда все эти пакеты и берутся. Весь процесс может занять некоторое время. Помните, что многие shell-команды не любят пробелы в пути, так что не забываем кавычки. Эта команда сохранит продукт RubyHostingPackage и все его возможные зависимости в папку 'offline-package' внутри нашего веб сайта. Затем содержимое этой папки можно будет использовать, чтобы установить пакет Ruby Hosting Package на другой машине. На момент написания статьи в Helicon Zoo входит семь хостинг пакетов и имена у них следующие:

</p><pre><code>CFMLHostingPackage    CFML Hosting Package
JavaHostingPackage    Java Hosting Package
RubyHostingPackage    Ruby Hosting Package
NodejsHostingPackage  Node.js Hosting Package
PerlHostingPackage    Perl Hosting Package
PHPHostingPackage     PHP Hosting Package
PythonHostingPackage  Python Hosting Package</code></pre><p>
Более подробно про оффлайн установку можно почитать на английском по </p><a href="http://www.helicontech.com/zoo/docs/offline.htm">этой ссылке</a><p>. Посмотреть внутренние имена всех доступных продуктов можно воспользовавшись ключем /List команды WebpiCmd.exe. Оригинальная английская документация к утилите WebpiCMD.exe находится </p><a href="http://www.iis.net/learn/install/web-platform-installer/web-platform-installer-v4-command-line-webpicmdexe-rtw-release">здесь</a><p>. 
</p><p>
Если вы посмотрите на структуру получившейся папки 'offline-package', то в папке bin увидите что WebpiCMD.exe очень кстати уже включил рабочую копию самого себя в пакет. Именно его мы будем вызывать на виртуальной машине Azure Cloud Services, чтобы установить нужные зависимости обратно из пакета. 

</p><img src="https://habrastorage.org/getpro/habr/post_images/3c9/2f5/aad/3c92f5aad5799fb47230f1f13b1de6af.png"/>
<p>
Прежде чем упаковать наш сайт для Azure, нужно добавить к нему скрипт, который будет устанавливать все зависимости на виртуальной машине. По правилам Azure этот скрипт должен находиться в директории bin под корнем самого сайта. Назовем этот файл startup.cmd. Вот его содержимое:

</p><b>[bin\startup.cmd]</b><pre><code>echo Starting installation...

rem Дать права на чтение и запись папке куда распаковано приложение
icacls "%RoleRoot%\approot" /grant "Everyone":F /T

rem Локальная папка AppData с правами на запись нужна для работы Web Platform Installer
rem Создадим эту папку и ключ реестра на нее указывающий
md "%RoleRoot%\appdata"
reg add "hku\.default\software\microsoft\windows\currentversion\explorer\user shell folders" ^
    /v "Local AppData" /t REG_EXPAND_SZ /d "%RoleRoot%\appdata" /f

rem Перейдем в папку с WebpiCmd.exe
pushd "%RoleRoot%\approot\offline-package\bin"

rem Вызов команды WebpiCmd.exe для установки продукта из папки offline-package
rem Обратите внимание на имя продукта - RubyHostingPackage, а также логи в install.txt и install-error.txt
WebpiCmd.exe /install /Products:RubyHostingPackage /XML:%RoleRoot%\approot\offline-package\feeds\latest\webproductlist.xml ^
             /Feeds:%RoleRoot%\approot\offline-package\feeds\latest\supplementalfeeds\feed.xml ^
			 /AcceptEula &gt;%RoleRoot%\approot\public\install.txt 2&gt;%RoleRoot%\approot\public\install-error.txt

popd

rem Вернуть старое значение ключу реестра с AppData
reg add "hku\.default\software\microsoft\windows\currentversion\explorer\user shell folders" ^
    /v "Local AppData" /t REG_EXPAND_SZ /d %%USERPROFILE%%\AppData\Local /f


rem Тут можно выполнить другие действия, например удалить временные файлы.

echo Completed installation.
</code></pre><p>
Переменная %RoleRoot% будет указывать куда устанавливается наша роль, а папка %RoleRoot%\approot соответственно будет корневой папкой сайта. Главной строкой в этом файле является вызов WebpiCmd.exe. Обратите внимание на перенаправление вывода логов установки в файл install.txt, а вывод STDERR будет в файле install-error.txt – оба в папку public корня получившегося сайта. Можно будет потом запросить эти файлы по URL чтобы прочитать возможные ошибки установки, если опыт не удастся с первого раза. Первой строкой устанавливаются права на запись в папку с сайтом – эти права нужны самому Redmine для работы, т.к. Ruby приложения часто пишут в папку с приложением.
</p><p>
Теперь настало время упаковать сайт для Azure Cloud Services. Сайт у меня находится в папке «C:\Users\Slov\Documents\My Web Sites\redmine222». Перейдем консолью в папку выше нашего сайта – у меня это будет папка «C:\Users\Slov\Documents\My Web Sites\». Здесь нам понадобится создать три файла: файл конфигурации сервиса *.cscfg, файл с параметрами для создания пакета *.csdef и файл cmd скрипта которым будет удобно все это упаковать. Вот эти файлы с некоторыми комментариями: 

</p><b>[remine222.csdef]</b>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ServiceDefinition name="WindowsAzure2" xmlns="http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceDefinition" schemaVersion="2013-03.2.0"&gt;
  &lt;WebRole name="redmine222" vmsize="Small"&gt;
    &lt;Sites&gt;
      &lt;Site name="Web"  physicalDirectory="./redmine222"&gt;
        &lt;Bindings&gt;
          &lt;Binding name="Endpoint1" endpointName="Endpoint1" /&gt;
        &lt;/Bindings&gt;
      &lt;/Site&gt;
    &lt;/Sites&gt;
    &lt;Endpoints&gt;
      &lt;InputEndpoint name="Endpoint1" protocol="http" port="80" /&gt;
    &lt;/Endpoints&gt;
    &lt;Startup&gt;
      &lt;Task commandLine="startup.cmd" executionContext="elevated" taskType="simple" &gt;
      &lt;/Task&gt;
    &lt;/Startup&gt;
  &lt;/WebRole&gt;
&lt;/ServiceDefinition&gt;
</code></pre><p>
Имя роли и имя папки, где она находится, почему-то должны совпадать. 

</p><b>[redmine222.cloud.cscfg]</b>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ServiceConfiguration serviceName="WindowsAzure2" xmlns="http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceConfiguration" osFamily="2" osVersion="*" schemaVersion="2013-03.2.0"&gt;
  &lt;Role name="redmine222"&gt;
    &lt;Instances count="1" /&gt;
    &lt;ConfigurationSettings&gt;
    &lt;/ConfigurationSettings&gt;
  &lt;/Role&gt;
&lt;/ServiceConfiguration&gt;</code></pre><p>
Описания и форматы этих файлов можно найти в интернете и в самой документации к Windows Azure, так что опустим подробности. 

</p><b>[redmine222.pack.cmd]</b>
<pre><code>@echo off

set WINDOWS_AZURE_SDK_PATH="C:\Program Files\Microsoft SDKs\Windows Azure\.NET SDK\v2.1"

call %WINDOWS_AZURE_SDK_PATH%\bin\setenv.cmd

pushd %~dp0

if "%ServiceHostingSDKInstallPath%" == "" (
    echo Can't see the ServiceHostingSDKInstallPath environment variable. Please run from a Windows Azure SDK command-line (run Program Files\Windows Azure SDK\^&lt;version^&gt;\bin\setenv.cmd^).
    GOTO :eof
)

rem Тут можно удалить временные файлы, остановить IIS и т.п.
rem iisreset /stop

rem Переименовать deploy_done.rb в deploy.rb чтобы запустить процесс деплоя по новой
ren redmine222\deploy_done.rb deploy.rb

rem Эта команда создает пакет для Windows Azure
cspack redmine222.csdef /out:redmine222.cspkg

popd</code></pre><p>
Обратите внимание на строчку
</p><pre><code>ren redmine222\deploy_done.rb deploy.rb</code></pre><p>
Эта команда переименовывает файл deploy_done.rb в deploy.rb, что приведет к повторному запуску деплой-скрипта в Helicon Zoo при первом запросе к развернувшемуся приложению. Если мы правильно упаковали все модули и нам не нужно мигрировать базу данных, то этот шаг не обязателен и может сэкономить время. Однако вероятность того что с первого раза все будет правильно упаковано не очень высока, поэтому для первых попыток я рекомендую оставить эту строчку. 
</p><p>
Еще одной рекомендацией будет отредактировать файл web.config корня сайта и добавить такую строчку в секцию &lt;system.webServer&gt;:
</p><pre><code>&lt;httpErrors existingResponse="PassThrough" /&gt;</code></pre><p>
Эта строчка включает выдачу подробных сообщений о 500-й ошибке при внешних запросах к IIS. Без этой строчки если что-то сломается в приложении, то текста ошибки вы не увидите, а только сухое сообщение 'Server error'. Для работы в production режиме эту строку лучше убрать, но для первого запуска она может пригодиться. 
</p><p>
По </p><a href="https://dl.dropboxusercontent.com/u/7840290/habrahabr/redmine222.zip">этой ссылке</a><p> вы можете найти примеры описанных выше файлов в соответствии со структурой папок проекта – чтобы было понятнее что куда ложить. 
</p><p>
Все, файлы готовы. Теперь перед вызовом redmine222.pack.cmd нужно остановить IIS или IIS Express на рабочей станции, чтобы разблокировать файлы приложения. Затем вызвать redmine222.pack.cmd из нашей консоли с административными правами. Процесс упаковки займет какое-то время и в результате у нас получится файл redmine222.cspkg, который фактически представляет собой ZIP архив со всеми необходимыми пакетами. Размер этого файла у меня получился 138 мегабайт, что немало, т.к. в него включены версии Ruby 1.8, 1.9, две версии Ruby DevKit, Helicon Zoo Module, Microsoft URL Rewrite, сам Redmine и все требуемые для его работы gem-ы. Зато этот архив включает в себя все зависимости и нам не придется ничего качать из интернета, а сам же архив будет передан внутри сети Azure, что, смею надеяться, значительно быстрее. 
</p><p>
Теперь перейдем в портал управления Windows Azure. Нужно создать новый Cloud Service и выбрать ему URL: 

</p><img src="https://habrastorage.org/getpro/habr/post_images/588/51c/e1c/58851ce1c2f0e0b909197798b1d70a22.png"/>
<p>
Затем нужно выбрать «New staging deployment»: 

</p><img src="https://habrastorage.org/getpro/habr/post_images/d5a/923/d03/d5a923d034f7abb160609f88c82f3cae.png"/>
<p>
Выбрать наши файлы с Redmine из локальной папки. Нужно указать флаг «Deploy even if role contain a single instance», потому что в файле redmine222.csdef мы указали использовать один экземпляр роли, чего достаточно для тестов, хотя в реальных условиях вам, скорее всего, понадобится увеличить это число. 

</p><img src="https://habrastorage.org/getpro/habr/post_images/5ba/af6/ea8/5baaf6ea8e127f238b3fa6edcd56afda.png"/>
<p>
После чего начнется процесс загрузки пакета в Azure, создания новой виртуальной машины, разворачивания нашего пакета с приложением на этой виртуальной машине и выполнение установочных скриптов. Процесс довольно длительный, у меня он занимает минут 20 – не меньше. Когда все процессы установки будут завершены, нажмите на ссылку Site URL. 

</p><img src="https://habrastorage.org/getpro/habr/post_images/5d4/5d6/082/5d45d6082a2aa88e5dfa92bf0feff447.png"/>
<p>
Вы должны увидеть страницу Applcation deployment из Helicon Zoo, которая затем обновится на домашнюю страницу Redmine: 

</p><img src="https://habrastorage.org/getpro/habr/post_images/7ba/db1/83f/7badb183fe7d30a11cb71dd74f6ba5c0.png"/>
<p>
Чтобы затем ваш веб сайт стал виден пользователям под более приемлемым доменным именем, вам нужно в настройках вашего домена у регистратора указать либо CNAME запись на доменное имя внутри .cloudapp.net (предпочтительно) или указать 'A'-record вашего домена на публичный IP адрес вашего Azure-приложения. Сам же Microsoft не занимается предоставлением услуг по регистрации доменов. 

</p><h1>Python</h1>
<p>
В этой главе мы рассмотрим, как установить вручную приложение, которое не входит в репозиторий Helicon Zoo. Для этого мы будем использовать приложение </p><a href="http://www.getlfs.com/">Lightning Fast Shop</a><p> (LFS) с открытым исходным кодом, написанное на Python с использование Django. Шаги по публикации приложения в Azure Cloud Service будут практически идентичны с прошлой главой, а вот шаги по развертыванию приложения на рабочей станции будут другими. 
</p><p>
Итак, ставим </p><a href="http://www.microsoft.com/web/downloads/platform.aspx">Microsoft Web Platform Installer</a><p>, </p><a href="http://www.helicontech.com/zoo/install.htm">Helicon Zoo feed</a><p> и </p><a href="http://wpi:placeholder&amp;amp;WindowsAzureSDK_2_1???">Windows Azure SDK</a><p>, как в прошлой главе, если еще что-то из этого не установлено. Запускаем Web Platform Installer и устанавливаем Zoo -&gt; Templates -&gt; Python project на IIS Express. 

</p><img src="https://habrastorage.org/getpro/habr/post_images/881/fae/bdb/881faebdb4cf975489fe18cfb710cfc7.png"/>
<p>
Запустится WebMatrix и откроется новый сайт: 

</p><img src="https://habrastorage.org/getpro/habr/post_images/262/b5e/30b/262b5e30b94281dfc752e58fc373b30a.png"/>
<p>
Мы только что установили шаблонный проект для Python. В этом проекте уже сконфигурирован virtualenv, который и будет использован для установки всех модулей и зависимостей внутрь сайта. Для запуска своего проекта на Python можно идти дальше по инструкции на пригласительной странице Python project. Только не забывайте запускать консоль или IDE (например </p><a href="http://www.jetbrains.com/pycharm/">PyCharm</a><p> ) используя Helicon Zoo Manager, чтобы консоль запускалась с предварительно сконфигурированным virtualenv, иначе команды не найдут путей к нашему приложению. 
</p><p>
Lightning Fast Shop достаточно большая и капризная в установке программа, поэтому я прошу вас шаг за шагом повторить следующую инструкцию по его ручной установке на IIS и Helicon Zoo. Я не буду давать слишком подробных объяснений, что происходит, потому что происходящее имеет отношение к особенностям проекта LFS, а не к Helicon Zoo или Azure. Настройка другого проекта может идти по другому сценарию. В случае неудачи попробуйте начать с более мелких и простых проектов, следуя инструкциям из Python project. Проект LFS я выбрал просто для того чтобы показать что не только «Hello World» можно запускать на Azure Cloud Services. 
</p><ol>
<li>Скачайте диструбутив LFS с <a href="https://pypi.python.org/pypi/django-lfs">официального сайта</a>. Я выбрал версию 0.7.7. Нужно скачать обязательно installer-версию, у которой имя файла вроде django-lfs-installer-0.7.7.tar.gz. <br/>
В архиве будет папка <b>'lfs-installer'</b> – распакуйте <b>её содержимое</b> в корень сайта с нашим Python project (в моем случае это папка C:\Users\Slov\Documents\My Web Sites\ZooPythonProject2). <br/>
Запустите Helicon Zoo Manager, выберете нужный сайт с проектом и нажмите на Start IDE, чтобы запустить сконфигурированную консоль. <br/>
В консоли введите:<br/>
<pre><code>python bootstrap.py</code></pre>Затем<br/>
<pre><code>bin\buildout –v</code></pre>Затем отредактируйте файл lfs_project\settings.py и замените секцию DATABASES следующим текстом, для использования в проекте SQLite:<br/>
<pre><code>DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': os.path.join(DIRNAME, 'sqlite3.bd'),                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}</code></pre>Затем введите в консоли последовательно такие команды:<br/>
<pre><code>bin\django syncdb
bin\django lfs_init
bin\django collectstatic</code></pre>Если все выполнилось без ошибок, то теперь можно запустить тестовый сервер Django, чтобы проверить работу проекта LFS отдельно от веб сервера IIS. Выполните в консоли:<br/>
<pre><code>bin/django runserver</code></pre>И затем откройте в браузере <a href="http://localhost:8080/">http://localhost:8080/</a><br/>
<br/>
Теперь, чтобы запустить проект на IIS через Helicon Zoo, нужно задать PYTHONPATH в файле <b>web.config</b>. У LFS он длинный и включает в себя множество egg-пакетов. Найти его можно в файле bin\django_script.py:<br/>
<pre><code>#!"C:\Users\Slov\Documents\My Web Sites\ZooPythonProject2\venv\Scripts\python.exe"

import sys
sys.path[0:0] = [
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\django_lfs-0.7.6-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\gunicorn-18.0-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\djangorecipe-1.1.2-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\django-1.3.1-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\zc.recipe.egg-2.0.1-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\zc.buildout-2.2.1-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\south-0.7.3-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\pillow-1.7.5-py2.7-win32.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\lfs_order_numbers-1.0b1-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\lfs_contact-1.0-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\django_tagging-0.3.1-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\django_reviews-0.2.1-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\django_postal-0.9-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\django_portlets-1.1.1-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\django_paypal-0.1.2-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\django_pagination-1.0.7-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\django_lfstheme-0.7.3-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\django_compressor-1.1.1-py2.7.egg',
  'c:\\users\\slov\\documents\\my web sites\\zoopythonproject2\\venv\\lib\\site-packages',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\django_piston-0.2.3-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\django_countries-1.5-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\django_appconf-0.6-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\eggs\\six-1.4.1-py2.7.egg',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\parts\\django',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\parts',
  'c:\\users\\slov\\docume~1\\mywebs~1\\zoopyt~1\\lfs_project',
  ]

import djangorecipe.manage

if __name__ == '__main__':
    sys.exit(djangorecipe.manage.main('lfs_project.settings'))</code></pre><br/>
Как видно там абсолютные пути, что нам не подходит, ведь проект будет переносится в Azure. Для задания PYTHONPATH через web.config эти пути нужно переделать в такой, немного странный формат. Вот фрагмент моего web.config:<br/>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;configuration&gt; 
 &lt;system.webServer&gt;
  &lt;heliconZoo&gt;
   &lt;application name="python.project"&gt;
    &lt;environmentVariables&gt;
        &lt;add name="VIRTUAL_ENV" value="%APPL_PHYSICAL_PATH%\venv" /&gt;
        &lt;add name="PATH" value="%APPL_PHYSICAL_PATH%\venv\Scripts;%PATH%" /&gt;
        &lt;add name="PYTHONPATH" value=".\eggs\django_lfs-0.7.6-py2.7.egg
        ;.\eggs\gunicorn-18.0-py2.7.egg
        ;.\eggs\djangorecipe-1.1.2-py2.7.egg
        ;.\eggs\django-1.3.1-py2.7.egg
        ;.\eggs\zc.recipe.egg-2.0.1-py2.7.egg
        ;.\eggs\zc.buildout-2.2.1-py2.7.egg
        ;.\eggs\south-0.7.3-py2.7.egg
        ;.\eggs\pillow-1.7.5-py2.7-win32.egg
        ;.\eggs\lfs_order_numbers-1.0b1-py2.7.egg
        ;.\eggs\lfs_contact-1.0-py2.7.egg
        ;.\eggs\django_tagging-0.3.1-py2.7.egg
        ;.\eggs\django_reviews-0.2.1-py2.7.egg
        ;.\eggs\django_postal-0.9-py2.7.egg
        ;.\eggs\django_portlets-1.1.1-py2.7.egg
        ;.\eggs\django_paypal-0.1.2-py2.7.egg
        ;.\eggs\django_pagination-1.0.7-py2.7.egg
        ;.\eggs\django_lfstheme-0.7.3-py2.7.egg
        ;.\eggs\django_compressor-1.1.1-py2.7.egg
        ;.\venv\lib\site-packages
        ;.\eggs\django_piston-0.2.3-py2.7.egg
        ;.\eggs\django_countries-1.5-py2.7.egg
        ;.\eggs\django_appconf-0.6-py2.7.egg
        ;.\eggs\six-1.4.1-py2.7.egg
        ;.\parts\django
        ;%APPL_PHYSICAL_PATH%
        ;.\parts
        ;.\lfs_project" /&gt;
        &lt;add name="WSGI_APP" value="welcome.application" /&gt;
        &lt;add name="CONSOLE_URL" value="console" /&gt;
        &lt;add name="DEPLOY_FILE" value="deploy.py" /&gt;
        &lt;add name="ERROR_LOG_DIR" value="log" /&gt;
        &lt;add name="IDE" value="C:\Windows\system32\cmd.exe" /&gt;</code></pre><br/>
Можете скопировать к себе в web.config, однако если вы настраиваете версию отличную от 0.7.7, то ваш PYTHONPATH может отличаться.<br/>
<br/>
Также установим переменную DJANGO_SETTINGS_MODULE в web.config:<br/>
<pre><code>&lt;!-- django project --&gt;
&lt;add name="DJANGO_SETTINGS_MODULE" value="lfs_project.settings" /&gt;</code></pre><br/>
Теперь содержимое папки <b>'\lfs_project\sitestatic'</b> нужно перенести в папку <b>'\static'</b> в корне сайта. <br/>
<br/>
Все, проект готов к запуску на IIS. Нажмите на ссылку в WebMatrix и вы должны увидеть домашнюю страницу LFS. <br/>
<br/>
Структура папок в результате вышла следующая: <br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/post_images/9e4/609/40e/9e460940ea1327cfb990eca29938ecaa.png"/><br/>
<br/>
Дальше подготовим пакет для Azure Cloud Services. Запустите Helicon Zoo Manager, выберете нужный сайт и нажмите Start IDE для запуска консоли. Web console тут не подойдет, т.к. у нее будет недостаточно прав. Выполните там следующие команды: <br/>
<br/>
<pre><code>mkdir offline-package

WebpiCmd.exe /offline /Products:PythonHostingPackage /Path:"offline-package" /Feeds:http://www.helicontech.com/zoo/feed.xml</code></pre><br/>
Это сохранит Python Hosting Package в директории offline-package внутри сайта. <br/>
<br/>
Затем создайте три файла для Azure Cloud Services в папке 'My Documents\My Web Sites', как в предыдущей главе. Я выделил жирным те строчки, которые в этих файлах отличаются от предыдущих: <br/>
<br/>
<b>[LFS.Cloud.cscfg]</b><br/>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ServiceConfiguration serviceName="WindowsAzure2" xmlns="http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceConfiguration" osFamily="2" osVersion="*" schemaVersion="2013-03.2.0"&gt;
  &lt;Role name="ZooPythonProject2"&gt;
    &lt;Instances count="1" /&gt;
    &lt;ConfigurationSettings&gt;
    &lt;/ConfigurationSettings&gt;
  &lt;/Role&gt;
&lt;/ServiceConfiguration&gt;</code></pre><br/>
<br/>
<b>[LFS.csdef]</b><br/>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ServiceDefinition name="WindowsAzure2" xmlns="http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceDefinition" schemaVersion="2013-03.2.0"&gt;
  &lt;WebRole name="ZooPythonProject2" vmsize="Small"&gt;
    &lt;Sites&gt;
      &lt;Site name="Web"  physicalDirectory="./ZooPythonProject2"&gt;
        &lt;Bindings&gt;
          &lt;Binding name="Endpoint1" endpointName="Endpoint1" /&gt;
        &lt;/Bindings&gt;
      &lt;/Site&gt;
    &lt;/Sites&gt;
    &lt;Endpoints&gt;
      &lt;InputEndpoint name="Endpoint1" protocol="http" port="80" /&gt;
    &lt;/Endpoints&gt;
    &lt;Startup&gt;
      &lt;Task commandLine="startup.cmd" executionContext="elevated" taskType="simple" &gt;
      &lt;/Task&gt;
    &lt;/Startup&gt;
  &lt;/WebRole&gt;
&lt;/ServiceDefinition&gt;</code></pre><br/>
<br/>
<b>[LFS.pack.cmd]</b><br/>
<pre><code>@echo off

set WINDOWS_AZURE_SDK_PATH="C:\Program Files\Microsoft SDKs\Windows Azure\.NET SDK\v2.1"

call %WINDOWS_AZURE_SDK_PATH%\bin\setenv.cmd

pushd %~dp0

if "%ServiceHostingSDKInstallPath%" == "" (
    echo Can't see the ServiceHostingSDKInstallPath environment variable. Please run from a Windows Azure SDK command-line (run Program Files\Windows Azure SDK\^&lt;version^&gt;\bin\setenv.cmd^).
    GOTO :eof
)

rem Тут можно удалить временные файлы, остановить IIS и т.п.
rem iisreset /stop
&lt;b&gt;del /s /q *.log *.pyc *.pyo&lt;/b&gt;


rem Эта команда создает пакет для Windows Azure
cspack lfs.csdef /out:lfs.cspkg

popd</code></pre><br/>
И осталось создать файл <b>\bin\startup.cmd</b> в корне сайта:<br/>
<pre><code>echo Starting installation...

rem Дать права на чтение и запись папке куда распаковано приложение
icacls "%RoleRoot%\approot" /grant "Everyone":F /T

rem Локальная папка AppData с правами на запись нужна для работы Web Platform Installer
rem Создадим эту папку и ключ реестра на нее указывающий
md "%RoleRoot%\appdata"
reg add "hku\.default\software\microsoft\windows\currentversion\explorer\user shell folders" ^
    /v "Local AppData" /t REG_EXPAND_SZ /d "%RoleRoot%\appdata" /f

rem Перейдем в папку с WebpiCmd.exe
pushd "%RoleRoot%\approot\offline-package\bin"

rem Вызов команды WebpiCmd.exe для установки продукта из папки offline-package
rem Обратите внимание на имя продукта - &lt;b&gt;PythonHostingPackage&lt;/b&gt;, а также логи в install.txt и install-error.txt
WebpiCmd.exe /install /Products:PythonHostingPackage /XML:%RoleRoot%\approot\offline-package\feeds\latest\webproductlist.xml ^
             /Feeds:%RoleRoot%\approot\offline-package\feeds\latest\supplementalfeeds\feed.xml /AcceptEula  ^
             &gt;%RoleRoot%\approot\static\install.txt 2&gt;%RoleRoot%\approot\static\install-error.txt

popd

rem Вернуть старое значение ключу реестра с AppData
reg add "hku\.default\software\microsoft\windows\currentversion\explorer\user shell folders" ^
    /v "Local AppData" /t REG_EXPAND_SZ /d %%USERPROFILE%%\AppData\Local /f


rem Тут можно выполнить другие действия, например удалить временные файлы.

echo Completed installation.
</code></pre><br/>
В <a href="https://dl.dropboxusercontent.com/u/7840290/habrahabr/lfs.zip">этом архиве</a> вы найдете пример описанных выше файлов. <br/>
<br/>
Выполните LFS.pack.cmd. Получившийся файл LFS.cspkg у меня занимает 70мб. <br/>
<br/>
Удалим старый Staging Environment из Azure Portal и создадим новый. Передадим файлы как в предыдущей главе и ожидаем запуска. <br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/post_images/5f1/465/4b1/5f14654b1cca83ca0e661459d2643ab0.png"/><br/>
<br/>
Когда строчка «Not all instances are ready» пропадет, можно открывать ссылку, где мы должны увидеть работающий Lightning Fast Shop в Azure Cloud Services. <br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/post_images/b65/e27/e20/b65e27e20619513e6db4e0d9efc43e81.png"/><br/>
<br/>
<h1>Node.js</h1><br/>
Теперь на очереди Node.js. Итак, запускаем <b>Microsoft Web Platform Installer</b> и устанавливаем <b>Zoo -&gt; Templates -&gt; Node.js project</b>. Все зависимости будут установлены автоматически. <br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/post_images/a55/0cc/952/a550cc9523f0a51d13d1886134edbbfb.png"/><br/>
<br/>
После запуска проект развернется во вполне готовое Model-View-Route приложение, построенное на базе express.js, sqlite3, persist.js и Twitter Bootstrap. В этом шаблоне для примера уже будет простенький блог и административная панель к нему. Такое приложение может быть хорошей отправной точкой для создания собственного сайта. Если же у вас уже есть готовый Node.js веб сайт, то вы, очевидно, знаете назначение всех прописанных в шаблонном проекте файлов. Просто перезапишите свои файлы поверх, оставляя web.config нетронутым, и ваше приложение должно заработать. <br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/post_images/53f/592/aa1/53f592aa19f0d52c302584056caf871a.png"/><br/>
<br/>
Этот простенький блог мы и будем устанавливать на Azure Cloud Services. Как и в предыдущих главах – запустим Helicon Zoo Manager и нажмем Start IDE или Start web console. В консоли наберем:<br/>
<br/>
<pre><code>mkdir offline-package

WebpiCmd.exe /offline /Products:NodejsHostingPackage /Path:"offline-package" /Feeds:http://www.helicontech.com/zoo/feed.xml</code></pre><br/>
Дальше создадим файл <b>bin\startup.cmd</b>: <br/>
<br/>
<b>[bin\startup.cmd]</b><br/>
<pre><code>echo Starting installation...

rem Дать права на чтение и запись папке куда распаковано приложение
icacls "%RoleRoot%\approot" /grant "Everyone":F /T

rem Локальная папка AppData с правами на запись нужна для работы Web Platform Installer
rem Создадим эту папку и ключ реестра на нее указывающий
md "%RoleRoot%\appdata"
reg add "hku\.default\software\microsoft\windows\currentversion\explorer\user shell folders" ^
    /v "Local AppData" /t REG_EXPAND_SZ /d "%RoleRoot%\appdata" /f

rem Перейдем в папку с WebpiCmd.exe
pushd "%RoleRoot%\approot\offline-package\bin"

rem Вызов команды WebpiCmd.exe для установки продукта из папки offline-package
rem Обратите внимание на имя продукта – NodejsHostingPackage, а также логи в install.txt и install-error.txt
WebpiCmd.exe /install /Products:NodejsHostingPackage /XML:%RoleRoot%\approot\offline-package\feeds\latest\webproductlist.xml ^
             /Feeds:%RoleRoot%\approot\offline-package\feeds\latest\supplementalfeeds\feed.xml ^
             /AcceptEula  &gt;%RoleRoot%\approot\public\install.txt 2&gt;%RoleRoot%\approot\public\install-error.txt

popd

rem Вернуть старое значение ключу реестра с AppData
reg add "hku\.default\software\microsoft\windows\currentversion\explorer\user shell folders" ^
    /v "Local AppData" /t REG_EXPAND_SZ /d %%USERPROFILE%%\AppData\Local /f


rem Тут можно выполнить другие действия, например удалить временные файлы.

echo Completed installation.</code></pre><br/>
И затем три файла в директории «My Web Sites»: <br/>
<br/>
<b>[Node.js.Cloud.cscfg]</b><br/>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ServiceConfiguration serviceName="WindowsAzure2" xmlns="http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceConfiguration" osFamily="2" osVersion="*" schemaVersion="2013-03.2.0"&gt;
  &lt;Role name="Node.js project"&gt;
    &lt;Instances count="1" /&gt;
    &lt;ConfigurationSettings&gt;
    &lt;/ConfigurationSettings&gt;
  &lt;/Role&gt;
&lt;/ServiceConfiguration&gt;</code></pre><br/>
<br/>
<b>[Node.js.csdef]</b><br/>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ServiceDefinition name="WindowsAzure2" xmlns="http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceDefinition" schemaVersion="2013-03.2.0"&gt;
  &lt;WebRole name="Node.js project" vmsize="Small"&gt;
    &lt;Sites&gt;
      &lt;Site name="Web"  physicalDirectory="./Node.js project"&gt;
        &lt;Bindings&gt;
          &lt;Binding name="Endpoint1" endpointName="Endpoint1" /&gt;
        &lt;/Bindings&gt;
      &lt;/Site&gt;
    &lt;/Sites&gt;
    &lt;Endpoints&gt;
      &lt;InputEndpoint name="Endpoint1" protocol="http" port="80" /&gt;
    &lt;/Endpoints&gt;
    &lt;Startup&gt;
      &lt;Task commandLine="startup.cmd" executionContext="elevated" taskType="simple" &gt;
      &lt;/Task&gt;
    &lt;/Startup&gt;
  &lt;/WebRole&gt;
&lt;/ServiceDefinition&gt;</code></pre><br/>
<br/>
<b>[Node.js.pack.cmd]</b><br/>
<pre><code>@echo off

set WINDOWS_AZURE_SDK_PATH="C:\Program Files\Microsoft SDKs\Windows Azure\.NET SDK\v2.1"

call %WINDOWS_AZURE_SDK_PATH%\bin\setenv.cmd

pushd %~dp0

if "%ServiceHostingSDKInstallPath%" == "" (
    echo Can't see the ServiceHostingSDKInstallPath environment variable. Please run from a Windows Azure SDK command-line (run Program Files\Windows Azure SDK\^&lt;version^&gt;\bin\setenv.cmd^).
    GOTO :eof
)

rem Тут можно удалить временные файлы, остановить IIS и т.п.
rem iisreset /stop

rem Эта команда создает пакет для Windows Azure
cspack Node.js.csdef /out:Node.js.cspkg

popd</code></pre><br/>
Как и раньше различия выделены жирным. <br/>
<br/>
Выполним Node.js.pack.cmd, в результате получим файл Node.js.cspkg размером примерно 41мб. Вот ссылка на архив с примерами файлов выше: <a href="https://dl.dropboxusercontent.com/u/7840290/habrahabr/Node.js.zip">https://dl.dropboxusercontent.com/u/7840290/habrahabr/Node.js.zip</a> <br/>
<br/>
Теперь опубликуем пакеты в Azure Cloud Services как и в предыдущих главах. Весь процесс занимает минут 5-10, что значительно быстрее, чем, например, в случае с Ruby. <br/>
<br/>
<h1>Perl</h1><br/>
На этот раз все же будем ставить «Hello World» проект на Mojolitious. К сожалению ничего более зрелищного для Perl у меня под рукой не нашлось. Запустим <b>Microsoft Web Platform Installer</b> и установим <b>Zoo -&gt; Templates -&gt; Perl project</b>.<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/post_images/3b8/efc/de1/3b8efcde1cdd25cdb11aa928967f93e4.png"/><br/>
<br/>
После установки откроется страница «Welcome to universal Perl template powered by Helicon Zoo», нажмите на этой странице на ссылку «open web console» и наберите там следующую команду:<br/>
<pre><code>cpanm Mojolicious</code></pre><br/>
Теперь создайте файл<b> app.pl</b> такого содержания: <br/>
<br/>
<b>[app.pl]</b><br/>
<pre><code>use Mojolicious::Lite;
get '/' =&gt; sub { shift-&gt;render(text =&gt; 'Hello from Mojolicious!') };
app-&gt;start;</code></pre><br/>
Нажав «обновить» в браузере увидим сообщение «Hello from Mojolicious!». Не ахти как красиво, но концепцию доказывает. <br/>
<br/>
Теперь, как и в предыдущих главах выполняем из консоли:<br/>
<br/>
<pre><code>mkdir offline-package

WebpiCmd.exe /offline /Products:PerlHostingPackage /Path:"offline-package" /Feeds:http://www.helicontech.com/zoo/feed.xml</code></pre><br/>
Добавим скрипт bin\startup.cmd: <br/>
<br/>
<b>[bin\startup.cmd]</b><br/>
<pre><code>echo Starting installation...

rem Дать права на чтение и запись папке куда распаковано приложение
icacls "%RoleRoot%\approot" /grant "Everyone":F /T

rem Локальная папка AppData с правами на запись нужна для работы Web Platform Installer
rem Создадим эту папку и ключ реестра на нее указывающий
md "%RoleRoot%\appdata"
reg add "hku\.default\software\microsoft\windows\currentversion\explorer\user shell folders" ^
    /v "Local AppData" /t REG_EXPAND_SZ /d "%RoleRoot%\appdata" /f

rem Перейдем в папку с WebpiCmd.exe
pushd "%RoleRoot%\approot\offline-package\bin"

rem Вызов команды WebpiCmd.exe для установки продукта из папки offline-package
rem Обратите внимание на имя продукта – PerlHostingPackage, а также логи в install.txt и install-error.txt
WebpiCmd.exe /install /Products:PerlHostingPackage /XML:%RoleRoot%\approot\offline-package\feeds\latest\webproductlist.xml ^
             /Feeds:%RoleRoot%\approot\offline-package\feeds\latest\supplementalfeeds\feed.xml ^
             /AcceptEula  &gt;%RoleRoot%\approot\public\install.txt 2&gt;%RoleRoot%\approot\public\install-error.txt

popd

rem Вернуть старое значение ключу реестра с AppData
reg add "hku\.default\software\microsoft\windows\currentversion\explorer\user shell folders" ^
    /v "Local AppData" /t REG_EXPAND_SZ /d %%USERPROFILE%%\AppData\Local /f


rem Тут можно выполнить другие действия, например удалить временные файлы.

echo Completed installation.</code></pre><br/>
И создадим файлы в папке «My Web Sites» (предполагается что сайт находится в папке «My Web Sites\Perl project»): <br/>
<br/>
<b>[Perl.Cloud.cscfg]</b><br/>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ServiceConfiguration serviceName="WindowsAzure2" xmlns="http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceConfiguration" osFamily="2" osVersion="*" schemaVersion="2013-03.2.0"&gt;
  &lt;Role name="Perl project"&gt;
    &lt;Instances count="1" /&gt;
    &lt;ConfigurationSettings&gt;
    &lt;/ConfigurationSettings&gt;
  &lt;/Role&gt;
&lt;/ServiceConfiguration&gt;</code></pre><br/>
<br/>
<b>[Perl.csdef]</b><br/>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ServiceDefinition name="WindowsAzure2" xmlns="http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceDefinition" schemaVersion="2013-03.2.0"&gt;
  &lt;WebRole name="Perl project" vmsize="Small"&gt;
    &lt;Sites&gt;
      &lt;Site name="Web"  physicalDirectory="./Perl project"&gt;
        &lt;Bindings&gt;
          &lt;Binding name="Endpoint1" endpointName="Endpoint1" /&gt;
        &lt;/Bindings&gt;
      &lt;/Site&gt;
    &lt;/Sites&gt;
    &lt;Endpoints&gt;
      &lt;InputEndpoint name="Endpoint1" protocol="http" port="80" /&gt;
    &lt;/Endpoints&gt;
    &lt;Startup&gt;
      &lt;Task commandLine="startup.cmd" executionContext="elevated" taskType="simple" &gt;
      &lt;/Task&gt;
    &lt;/Startup&gt;
  &lt;/WebRole&gt;
&lt;/ServiceDefinition&gt;</code></pre><br/>
<br/>
<b>[Perl.pack.cmd]</b><br/>
<pre><code>@echo off

set WINDOWS_AZURE_SDK_PATH="C:\Program Files\Microsoft SDKs\Windows Azure\.NET SDK\v2.1"

call %WINDOWS_AZURE_SDK_PATH%\bin\setenv.cmd

pushd %~dp0

if "%ServiceHostingSDKInstallPath%" == "" (
    echo Can't see the ServiceHostingSDKInstallPath environment variable. Please run from a Windows Azure SDK command-line (run Program Files\Windows Azure SDK\^&lt;version^&gt;\bin\setenv.cmd^).
    GOTO :eof
)

rem Тут можно удалить временные файлы, остановить IIS и т.п.
rem iisreset /stop

rem Эта команда создает пакет для Windows Azure
cspack Perl.csdef /out:Perl.cspkg

popd</code></pre><br/>
Ссылка на архив с примерами файлов: <a title="https://dl.dropboxusercontent.com/u/7840290/habrahabr/Perl.zip" href="https://dl.dropboxusercontent.com/u/7840290/habrahabr/Perl.zip">https://dl.dropboxusercontent.com/u/7840290/habrahabr/Perl.zip</a> <br/>
<br/>
Запустим Perl.pack.cmd. Получится файл Perl.cspkg размером 92мб. Выложим файлы на Azure Cloud Services и убедимся что программа на Mojolicious работает корректно, открыв ссылку по завершении всей установки. <br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/post_images/798/d98/966/798d98966679d94c290c150f1cdfd789.png"/><br/>
<br/>
<h1>Java и ColdFusion (Railo)</h1><br/>
<br/>
На последок остались Java и ColdFusion. В качестве альтернативы ColdFusion в Helicon Zoo на данный момент используется бесплатный Railo с открытым исходным кодом. Сразу же оговорюсь – установить Java или Railo на Azure Cloud Services мне не удалось, и причина тому весьма тривиальна – ограничение на размер пакетов Azure. По крайней мере в моем аккаунте нельзя выкладывать пакеты более 200 мб размером. При этом для работы Railo и большинства других серверных технологий на Java требуется Oracle JDK, размер дистрибутива которого 125 мб, что вместе с другими компонентами легко переваливает за 200. Однако я все же опишу, как должны были бы запускаться Java программы, если бы не это ограничение. Возможно, ограничение будет снято в будущем и глава станет актуальна. Тем более что в целом запуск Java программ достаточно прост и удобен. Java разработчикам не нужно приучаться упаковывать компоненты внутрь программ – для них это стандартное поведение. Сайты, программы и сервисы на Java, как правило, имеют минимум внешних зависимостей и не нуждаются в сложной настройке среды. <br/>
<br/>
Главной внешней зависимостью для Java-программ является Oracle JDK, и, к сожалению, его нельзя установить из репозитория Helicon Zoo. Oracle запрещает встраивание своего JDK в другие продукты и репозитории и любые поставки их дистрибутивов в обход самого сайта Oracle. Поэтому вам нужно скачать JDK-7 самостоятельно, воспользовавшись этой ссылкой: <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html</a> Для Azure Cloud Services вам понадобится версия Windows-64 bit. На вашу рабочую станцию ставьте версию в соответствии с битностью машины. После того как JDK-7 установлен, можно устанавливать Java-программы из репозитория Helicon Zoo. Для примера вы можете установить <b>Zoo -&gt; Applications -&gt; SCM Manager</b> – небольшой менеджер и сервис репозиториев Git, Mercurial и SVN написанный на Java. Или поставить <b>Zoo -&gt; Applications -&gt; Mura CMS</b> – красивая CMS написанная на ColdFusion. Обе программы устанавливаются прямо из репозитория без дополнительных действий. <br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/post_images/2bc/fc0/681/2bcfc0681d6fa1008a37bb436a5256c6.png"/><br/>
<br/>
В моем случае я установил Mura CMS в папку «My Web Sites\Mura CMS1». Дальше как и раньше – создаем папку offline-package куда пакуем Java Hosting Package или CFML Hosting Package из репозитория Helicon Zoo, в зависимости от того какая технология используется:<br/>
<pre><code>mkdir offline-package

WebpiCmd.exe /offline /Products:CFMLHostingPackage /Path:"offline-package" /Feeds:http://www.helicontech.com/zoo/feed.xml</code></pre><br/>
<br/>
Добавим в директорию <b>offline-package\bin</b> еще и скачанный ранее дистрибутив с JDK-7.  <br/>
Скрипт bin\startup.cmd будет отличатся дополнительным вызовом установщика JDK-7: <br/>
<br/>
<b>[bin\startup.cmd]</b><br/>
<pre><code>echo Starting installation...

rem Дать права на чтение и запись папке куда распаковано приложение
icacls "%RoleRoot%\approot" /grant "Everyone":F /T

rem Локальная папка AppData с правами на запись нужна для работы Web Platform Installer
rem Создадим эту папку и ключ реестра на нее указывающий
md "%RoleRoot%\appdata"
reg add "hku\.default\software\microsoft\windows\currentversion\explorer\user shell folders" ^
    /v "Local AppData" /t REG_EXPAND_SZ /d "%RoleRoot%\appdata" /f

rem Перейдем в папку с WebpiCmd.exe
pushd "%RoleRoot%\approot\offline-package\bin"

rem Устанавливаем JDK-7
jdk-7u45-windows-x64.exe /s

rem Вызов команды WebpiCmd.exe для установки продукта из папки offline-package
rem Обратите внимание на имя продукта – PerlHostingPackage, а также логи в install.txt и install-error.txt
WebpiCmd.exe /install /Products:CFMLHostingPackage /XML:%RoleRoot%\approot\offline-package\feeds\latest\webproductlist.xml ^
             /Feeds:%RoleRoot%\approot\offline-package\feeds\latest\supplementalfeeds\feed.xml ^
             /AcceptEula  &gt;%RoleRoot%\approot\install.txt 2&gt;%RoleRoot%\approot\install-error.txt

popd

rem Вернуть старое значение ключу реестра с AppData
reg add "hku\.default\software\microsoft\windows\currentversion\explorer\user shell folders" ^
    /v "Local AppData" /t REG_EXPAND_SZ /d %%USERPROFILE%%\AppData\Local /f


rem Тут можно выполнить другие действия, например удалить временные файлы.

echo Completed installation.</code></pre><br/>
Создадим файлы пакета: <br/>
<br/>
<b>[Mura.Cloud.cscfg]</b><br/>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ServiceConfiguration serviceName="WindowsAzure2" xmlns="http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceConfiguration" osFamily="2" osVersion="*" schemaVersion="2013-03.2.0"&gt;
  &lt;Role name="Mura CMS1"&gt;
    &lt;Instances count="1" /&gt;
    &lt;ConfigurationSettings&gt;
    &lt;/ConfigurationSettings&gt;
  &lt;/Role&gt;
&lt;/ServiceConfiguration&gt;</code></pre><br/>
<br/>
<b>[Mura.csdef]</b><br/>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ServiceDefinition name="WindowsAzure2" xmlns="http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceDefinition" schemaVersion="2013-03.2.0"&gt;
  &lt;WebRole name="Mura CMS1" vmsize="Small"&gt;
    &lt;Sites&gt;
      &lt;Site name="Web"  physicalDirectory="./Mura CMS1"&gt;
        &lt;Bindings&gt;
          &lt;Binding name="Endpoint1" endpointName="Endpoint1" /&gt;
        &lt;/Bindings&gt;
      &lt;/Site&gt;
    &lt;/Sites&gt;
    &lt;Endpoints&gt;
      &lt;InputEndpoint name="Endpoint1" protocol="http" port="80" /&gt;
    &lt;/Endpoints&gt;
    &lt;Startup&gt;
      &lt;Task commandLine="startup.cmd" executionContext="elevated" taskType="simple" &gt;
      &lt;/Task&gt;
    &lt;/Startup&gt;
  &lt;/WebRole&gt;
&lt;/ServiceDefinition&gt;</code></pre><br/>
<br/>
<b>[Mura.pack.cmd]</b><br/>
<pre><code>@echo off

set WINDOWS_AZURE_SDK_PATH="C:\Program Files\Microsoft SDKs\Windows Azure\.NET SDK\v2.1"

call %WINDOWS_AZURE_SDK_PATH%\bin\setenv.cmd

pushd %~dp0

if "%ServiceHostingSDKInstallPath%" == "" (
    echo Can't see the ServiceHostingSDKInstallPath environment variable. Please run from a Windows Azure SDK command-line (run Program Files\Windows Azure SDK\^&lt;version^&gt;\bin\setenv.cmd^).
    GOTO :eof
)

rem Тут можно удалить временные файлы, остановить IIS и т.п.
rem iisreset /stop

rem Эта команда создает пакет для Windows Azure
cspack Mura.csdef /out:Mura.cspkg

popd</code></pre><br/>
И запустим Mura.pack.cmd. Получится файл Mura.cspkg размером 275 мб. Что можно сказать: Java требует много ресурсов. Хотя и 300 мб для передачи по локальной сети по современным меркам не так уж и много.<br/>
<br/>
Ну и теперь, если бы Azure Cloud Services принимал пакеты такого размера, нам нужно было бы просто загрузить ему эти файлы. Пока же наш эксперимент чисто теоретический.<br/>
<br/>
<h1>Заключение</h1><br/>
<br/>
Несмотря на кажущуюся сложность показанного решения, не все так страшно. За одну статью мы управились сразу с большинством популярных технологий веб разработки. Разумеется, остались еще PHP и ASP.NET, которые и так неплохо описаны в инструкциях к Windows Azure. В репозитории Helicon Zoo есть еще PHP Hosting Package, которым удобно воспользоваться вместо стандартного решения от Microsoft в том случае если вы собираетесь смешивать несколько версий PHP или другие веб технологии в рамках одного сайта, так как в Zoo неплохо реализована изоляция технологий. <br/>
<br/>
Главное достоинство представленного решения, помимо относительной простоты и хорошей производительности – это достаточно легкая миграция приложений между серверами и сервисами. Пользуясь таким решением, вы оставляете для себя теоретическую возможность в будущем «спрыгнуть» с сервисов Azure, если условия не будут вас удовлетворять. Все приложения, приведенные в данной статье, могут быть аналогично запущены практически на любом сервере Windows и Linux. Разумеется, инфраструктура Azure предоставляет еще массу других, полезных, сервисов, таких как Media Services, Mobile Services, SQL Databases или очереди сообщений. Если ваше приложение будет активно использовать эти сервисы, то привязка к платформе будет более жесткой.</li>
</ol>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>