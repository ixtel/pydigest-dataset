<html><body><div><div class="entry-content">
		<p><a href="http://axialcorps.files.wordpress.com/2013/08/ryanlerch_roundabout_sign.png"><img class=" wp-image-508 alignright" alt="ryanlerch_Roundabout_Sign" src="http://axialcorps.files.wordpress.com/2013/08/ryanlerch_roundabout_sign.png?w=200&amp;h=178"/></a>A <a href="http://docs.python.org/2/tutorial/modules.html#packages">package</a> seems simple enough to build, just a collection of <a href="http://docs.python.org/2/tutorial/modules.html">modules</a> in a directory with an __init__.py, right? As straight-forward as it may seem, with more and more modifications to your package over time, a poorly designed package will tend towards circular dependency problems, and may become non-portable and brittle.</p>
<p>Following these 5 simple design patterns will help you avoid these common pitfalls, and write packages that will live long and prosper.</p>
<h3>1. __init__.py is Only for Imports</h3>
<p>For a simple package, you might be tempted to throw utility methods, factories and exceptions into your __init__.py. Don’t.</p>
<p>A well-formed __init__.py serves one very important purpose: to import from sub-modules. Your __init__.py should look something like this:</p>
<pre id="LC12"># ORDER MATTERS HERE -- SOME MODULES ARE DEPENDANT ON OTHERS
from exceptions import FSQError, FSQEnvError, FSQEncodeError,\
                       FSQTimeFmtError, FSQMalformedEntryError,\
                       FSQCoerceError, FSQEnqueueError, FSQConfigError,\
                       FSQPathError, FSQInstallError, FSQCannotLockError,\
                       FSQWorkItemError, FSQTTLExpiredError,\
                       FSQMaxTriesError, FSQScanError, FSQDownError,\
                       FSQDoneError, FSQFailError, FSQTriggerPullError,\
                       FSQHostsError, FSQReenqueueError, FSQPushError 

# constants relies on: exceptions, internal
import constants

# const relies on: constants, exceptions, internal
from const import const, set_const # has tests

# path relies on: exceptions, constants, internal
import path # has tests

# lists relies on: path
from lists import hosts, queues

#...</pre>
<h3>2. Use __init__.py to Enforce Import Order</h3>
<p>As seen in the <a href="https://github.com/axialmarket/fsq/blob/master/fsq/__init__.py">above example</a>, __init__.py solves 2 problems:</p>
<ol>
<li>Expose methods and classes at package scope, so your user doesn’t have to descend into your internal package structure, making your package easy to use.</li>
<li>Become a single place for reconciling the order of imports.</li>
</ol>
<p>Used well, the __init__.py will afford you the flexibility to re-organize your internal package structure without worrying about side-effects from internal sub-module imports or the order imports within each module. As you are only importing from sub-modules in a specific order, your __init__.py should be simple-to-grok for other programmers, and serve as a manifest of all functionality provided by the package.</p>
<p>A doc string, and assignment to an __all__ attribute at the package level, should be the only non-import code in your __init__.py:</p>
<pre>__all__ = [ 'FSQError', 'FSQEnvError', 'FSQEncodeError', 'FSQTimeFmtError',
            'FSQMalformedEntryError', 'FSQCoerceError', 'FSQEnqueueError',
            'FSQConfigError', 'FSQCannotLock', 'FSQWorkItemError',
            'FSQTTLExpiredError', 'FSQMaxTriesError', 'FSQScanError',
            'FSQDownError', 'FSQDoneError', 'FSQFailError', 'FSQInstallError',
            'FSQTriggerPullError', 'FSQCannotLockError', 'FSQPathError',
            'path', 'constants', 'const', 'set_const', 'down', 'up',
            # ...
          ]</pre>
<h3>3. Use One Module to Define All Exceptions</h3>
<p>You may have noted that the first import in the __init__.py imports all exceptions from a single exceptions.py sub-module. This is a departure from what you’ll see in most packages, where exceptions are defined closely with the code raising them. While this may provide high cohesion within a module, a sufficiently complex package will cause this pattern to break down in 2 ways:</p>
<ol>
<li>Often times a module/program will need to import from one sub-module to get a function that imports and makes use of the code raising an exception. To trap the exception with granularity, you’ll need to import both the module you need, and the module defining the exception (or worse, chain the import of the exception). This sort of derivative import requirement is the first step towards a convoluted web of imports within your package. The more times you execute this pattern, the more interdependent and error-prone your package becomes.</li>
<li>Over time as the number of exceptions increases, it becomes more and more difficult to find all of the exceptions a package is capable of raising. Defining all exceptions in a single module provides one convenient place where a programmer can inspect to determine the full surface-area of potential error conditions raised by your package.</li>
</ol>
<p>You should define 1 base Exception for your package:</p>
<pre id="LC5">class APackageException(Exception):
    '''root for APackage Exceptions, only used to except any APackage error, never raised'''
    pass</pre>
<p>And then ensure that your package raises only descendants of this base Exception for all error conditions, so you can suppress all exceptions if you need to:</p>
<pre>try:
    '''bunch of code from your package'''
except APackageException:
    '''blanked condition to handle all errors from your package'''</pre>
<p>There are a few notable exceptions here for generic error conditions already included in the standard library (e.g. TypeError, ValueError, etc.).</p>
<p>Define exceptions liberally and with plenty of granularity:</p>
<pre id="LC5"># from fsq
class FSQEnvError(FSQError):
    '''An error if something cannot be loaded from env, or env has an invalid
       value'''
    pass

class FSQEncodeError(FSQError):
    '''An error occured while encoding or decoding an argument'''
    pass
# ... and 20 or so more</pre>
<p>More <a href="https://github.com/axialmarket/fsq/blob/master/fsq/exceptions.py">granularity</a> in your exceptions allows programmers to have larger-and-larger uninterupted blocks of code wrapped by single try/except conditions:</p>
<pre># this
try:
   item = fsq.senqueue('queue', 'str', 'arg', 'arg')
   scanner = fsq.scan('queue')
except FSQScanError:
   '''do something'''
except FSQEnqueueError:
   '''do something else'''

# not this
try:
    item = fsq.senqueue('queue', 'str', 'arg', 'arg')
except FSQEnqueueError:
    '''do something else'''
try:
    scanner = fsq.scan('queue')
except FSQScanError:
    '''do something'''

# and definitely not
try:
    item = fsq.senqueue('queue', 'str', 'arg', 'arg')
    try:
        scanner = fsq.scan('queue')
    except FSQScanError:
        '''do something'''
except FSQEnqueueError:
    '''do something else'''</pre>
<p>High levels of granularity in Exception definitions leads to less convoluted error handling, and allows you to group the normal execution instructions and the error handling instructions separately, making your code easier to understand and maintain.</p>
<h3>4. Only Relative imports within the package</h3>
<p>One of the simplest mistakes you’ll see commonly in sub-modules is importing from the package using the package name itself:</p>
<pre># within a sub-module
from a_package import APackageError</pre>
<p>This decision results in two unsavory outcomes:</p>
<ol>
<li>The sub-modules will only function properly if the package is installed in PYTHONPATH.</li>
<li>The sub-modules will only function properly if the package is named a_package.</li>
</ol>
<p>While the former may not seem like a big problem, consider what happens if you have two packages of the same name in two different directories in the PYTHONPATH. Your sub-module may well end up importing from another package, and you’ll have unintentionally inflicted a late night of debugging on one or more unsuspecting programmers (or yourself). Rather than importing from your own package name, always use relative imports within a package:</p>
<pre># within a sub-module 
from . import FSQEnqueueError, FSQCoerceError, FSQError, FSQReenqueueError,\
              constants as _c, path as fsq_path, construct,\
              hosts as fsq_hosts, FSQWorkItem
from .internal import rationalize_file, wrap_io_os_err, fmt_time,\
                      coerce_unicode, uid_gid
# you can also use ../... etc. in sub-packages.</pre>
<h3>5. Keep Modules Small</h3>
<p>Your modules should be small. Remember that a programmer using your package will be importing from package scope, and you will be using your __init__.py as an organizational tool to help expose a coherent interface.</p>
<p>A good rule of thumb is to only have one class definition per module, along with any helper and factory methods you’ll expose to help construct it:</p>
<pre>class APackageClass(object):
    '''One class'''

def apackage_builder(how_many):
    for i in range(how_many):
        yield APackageClass()</pre>
<p>If your module exposes methods, group interdependent methods into single modules, and move any non-interdependent methods to separate modules:</p>
<pre id="LC82">####### EXPOSED METHODS #######
def enqueue(trg_queue, item_f, *args, **kwargs):
    '''Enqueue the contents of a file, or file-like object, file-descriptor or
       the contents of a file at an address (e.g. '/my/file') queue with
       arbitrary arguments, enqueue is to venqueue what printf is to vprintf
    '''
    return venqueue(trg_queue, item_f, args, **kwargs)

def senqueue(trg_queue, item_s, *args, **kwargs):
    '''Enqueue a string, or string-like object to queue with arbitrary
       arguments, senqueue is to enqueue what sprintf is to printf, senqueue
       is to vsenqueue what sprintf is to vsprintf.
    '''
    return vsenqueue(trg_queue, item_s, args, **kwargs)

def venqueue(trg_queue, item_f, args, user=None, group=None, mode=None):
    '''Enqueue the contents of a file, or file-like object, file-descriptor or
       the contents of a file at an address (e.g. '/my/file') queue with
       an argument list, venqueue is to enqueue what vprintf is to printf
       if entropy is passed in, failure on duplicates is raised to the caller,
       if entropy is not passed in, venqueue will increment entropy until it
       can create the queue item.
    '''
    # setup defaults
    trg_fd = name = None
    # ...</pre>
<p>The above example is <a href="https://github.com/axialmarket/fsq/blob/master/fsq/enqueue.py">fsq/enqueue.py</a>, which exposes a family of functions that provide different interfaces for the same functionality (like load/loads in simplejson). While this example is straight-forward, keeping your sub-modules small requires some amount of judgement, but a good rule of thumb is:</p>
<p>When in doubt, create a new sub-module.</p>
<div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><div class="sharedaddy sd-block sd-like jetpack-likes-widget-wrapper jetpack-likes-widget-unloaded" id="like-post-wrapper-42735903-495-56d5a7039e576" data-src="//widgets.wp.com/likes/#blog_id=42735903&amp;post_id=495&amp;origin=axialcorps.wordpress.com&amp;obj_id=42735903-495-56d5a7039e576" data-name="like-post-frame-42735903-495-56d5a7039e576"><h3 class="sd-title">Like this:</h3><p class="likes-widget-placeholder post-likes-widget-placeholder"><span class="button"><span>Like</span></span> <span class="loading">Loading...</span></p><span class="sd-text-color"/><a class="sd-link-color"/></div>
<p id="jp-relatedposts" class="jp-relatedposts">
	<h3 class="jp-relatedposts-headline"><em>Related</em></h3>
</p></div>			</div>

	</div></body></html>