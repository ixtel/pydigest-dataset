<html><body><div><div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/2/library/dis.html"><code>dis</code></a> to look at the bytecode generated for the two versions:</p>

<p><strong><code>not ==</code></strong></p>

<pre><code>  4           0 LOAD_FAST                0 (foo)
              3 LOAD_FAST                1 (bar)
              6 COMPARE_OP               2 (==)
              9 UNARY_NOT           
             10 RETURN_VALUE   
</code></pre>

<p><strong><code>!=</code></strong></p>

<pre><code>  4           0 LOAD_FAST                0 (foo)
              3 LOAD_FAST                1 (bar)
              6 COMPARE_OP               3 (!=)
              9 RETURN_VALUE   
</code></pre>

<p>The latter has fewer operations, and is therefore likely to be slightly more efficient. </p>

<hr/>

<p>It was pointed out <a href="http://stackoverflow.com/questions/31026754/python-if-not-vs-if/31026976#comment50099324_31026976">in the commments</a> (thanks, <a href="http://stackoverflow.com/users/1896169/quincunx">@Quincunx</a>) that where you have <code>if foo != bar</code> vs. <code>if not foo == bar</code> the number of operations is exactly the same, it's just that the <code>COMPARE_OP</code> changes and <code>POP_JUMP_IF_TRUE</code> switches to <code>POP_JUMP_IF_FALSE</code>:</p>

<p><strong><code>not ==</code></strong>:</p>

<pre><code>  2           0 LOAD_FAST                0 (foo)
              3 LOAD_FAST                1 (bar)
              6 COMPARE_OP               2 (==)
              9 POP_JUMP_IF_TRUE        16
</code></pre>

<p><strong><code>!=</code></strong></p>

<pre><code>  2           0 LOAD_FAST                0 (foo)
              3 LOAD_FAST                1 (bar)
              6 COMPARE_OP               3 (!=)
              9 POP_JUMP_IF_FALSE       16
</code></pre>

<p>In this case, unless there was a difference in the amount of work required for each comparison, it's unlikely you'd see any performance difference at all.</p>

<hr/>

<p>However, note that the two versions <strong>won't always be logically identical</strong>, as it will depend on the implementations of <code>__eq__</code> and <code>__ne__</code> for the objects in question. Per <a href="https://docs.python.org/2/reference/datamodel.html#object.__lt__">the data model documentation</a>:</p>

<blockquote>
  <p>There are no implied relationships among the comparison operators. The
  truth of <code>x==y</code> does not imply that <code>x!=y</code> is false.</p>
</blockquote>

<p>For example:</p>

<pre><code>&gt;&gt;&gt; class Dummy(object):
    def __eq__(self, other):
        return True
    def __ne__(self, other):
        return True


&gt;&gt;&gt; not Dummy() == Dummy()
False
&gt;&gt;&gt; Dummy() != Dummy()
True
</code></pre>

<hr/>

<p>Finally, and perhaps most importantly: in general, where the two <em>are</em> logically identical, <strong><code>x != y</code> is much more readable than <code>not x == y</code></strong>.</p>
    </div>
    </div></body></html>