<html><body><div><div class="post-text" itemprop="text">
<p>Your requirements are a little more complicated than it appears at first glance. Below I have adopted a convention to use lists <code>[...]</code> to indicate things to concatenate, and tuples <code>(...)</code> for things to choose from, i.e. optionals.</p>

<p>Your list of path names can now be expressed as this:-</p>

<pre><code>database = (
    'dev',
    ['home', (
            'dir',
            ['ramana', (
                    '',
                    ['xyz', (
                            '',
                            'abc'
                        )
                    ],
                    ['xxx', (
                            '',
                            'def'
                        )
                    ]
                   )
            ]
         )
    ]
)
</code></pre>

<p>The above syntax avoids redundancy as much as possible. The whitespace is not necessary but helps here to illustrate which parts are on the same nested level.</p>

<p>Next we need a way to transform this into a list of commands:-</p>

<pre><code>def permute(prefix, tree):
    def flatten(branch):
        #print 'flatten', branch
        results = [ ]
        if type(branch) is list:
            parts = [ ]
            for part in branch:
                if type(part) is basestring:
                    if part:
                        parts.append([part])
                else:
                    parts.append(flatten(part))

            index = map(lambda x: 0, parts)
            count = map(len, parts)
            #print 'combining', parts, index, count
            while True:
                line = map(lambda i: parts[i][index[i]],
                       range(len(parts)))
                line = '/'.join(line)
                #print '1:', line
                results.append( line )
                curIndex = len(parts)-1
                while curIndex &gt;= 0:
                    index[curIndex] += 1
                    if index[curIndex] &lt; count[curIndex]:
                        break
                    index[curIndex] = 0
                    curIndex -= 1
                if curIndex &lt; 0:
                    break
        elif type(branch) is tuple:
            for option in branch:
                if type(option) is basestring:
                    if len(option):
                        #print '2:', option
                        results.append( option )
                else:
                    results.extend(flatten(option))
        else:
            #print '3:', branch
            results.append( branch )
        return results

    return map(lambda x: prefix + x, flatten(tree))
</code></pre>

<p>So now if we call <code>permute('ls -l /', database)</code> it returns the following list:-</p>

<pre><code>[
    'ls -l /dev', 
    'ls -l /home/dir', 
    'ls -l /home/ramana/', 
    'ls -l /home/ramana/xyz/', 
    'ls -l /home/ramana/xyz/abc', 
    'ls -l /home/ramana/xxx/', 
    'ls -l /home/ramana/xxx/def'
]
</code></pre>

<p>From here it is now trivial to write these strings to a file named <code>commandbase</code> or execute it line by line.</p>
    </div>
    </div></body></html>