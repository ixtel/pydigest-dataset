<html><body><div><div id="content">
        
          <div id="breadcrumb">
               <a href="/dev/peps/">PEP Index</a>
               <span class="breadcrumb-separator">&gt;</span><p>
            
            PEP 476 -- Enabling certificate verification by default for stdlib http clients
          </p></div>



        

<hr/>

<div class="section" id="abstract">

<p>Currently when a standard library http client (the <tt class="docutils literal">urllib</tt>, <tt class="docutils literal">urllib2</tt>,
<tt class="docutils literal">http</tt>, and <tt class="docutils literal">httplib</tt> modules) encounters an <tt class="docutils literal"><span class="pre">https://</span></tt> URL it will wrap
the network HTTP traffic in a TLS stream, as is necessary to communicate with
such a server. However, during the TLS handshake it will not actually check
that the server has an X509 certificate is signed by a CA in any trust root,
nor will it verify that the Common Name (or Subject Alternate Name) on the
presented certificate matches the requested host.</p>
<p>The failure to do these checks means that anyone with a privileged network
position is able to trivially execute a man in the middle attack against a
Python application using either of these HTTP clients, and change traffic at
will.</p>
<p>This PEP proposes to enable verification of X509 certificate signatures, as
well as hostname verification for Python's HTTP clients by default, subject to
opt-out on a per-call basis. This change would be applied to Python 2.7, Python
3.4, and Python 3.5.</p>
</div>
<div class="section" id="rationale">

<p>The "S" in "HTTPS" stands for secure. When Python's users type "HTTPS" they are
expecting a secure connection, and Python should adhere to a reasonable
standard of care in delivering this. Currently we are failing at this, and in
doing so, APIs which appear simple are misleading users.</p>
<p>When asked, many Python users state that they were not aware that Python failed
to perform these validations, and are shocked.</p>
<p>The popularity of <tt class="docutils literal">requests</tt> (which enables these checks by default)
demonstrates that these checks are not overly burdensome in any way, and the
fact that it is widely recommended as a major security improvement over the
standard library clients demonstrates that many expect a higher standard for
"security by default" from their tools.</p>
<p>The failure of various applications to note Python's negligence in this matter
is a source of <em>regular</em> CVE assignment <a class="footnote-reference" href="#id12" id="id1">[1]</a> <a class="footnote-reference" href="#id13" id="id2">[2]</a> <a class="footnote-reference" href="#id14" id="id3">[3]</a> <a class="footnote-reference" href="#id15" id="id4">[4]</a> <a class="footnote-reference" href="#id16" id="id5">[5]</a> <a class="footnote-reference" href="#id17" id="id6">[6]</a> <a class="footnote-reference" href="#id18" id="id7">[7]</a> <a class="footnote-reference" href="#id19" id="id8">[8]</a>
<a class="footnote-reference" href="#id20" id="id9">[9]</a> <a class="footnote-reference" href="#id21" id="id10">[10]</a> <a class="footnote-reference" href="#id22" id="id11">[11]</a>.</p>











</div>
<div class="section" id="technical-details">

<p>Python would use the system provided certificate database on all platforms.
Failure to locate such a database would be an error, and users would need to
explicitly specify a location to fix it.</p>
<p>This will be achieved by adding a new <tt class="docutils literal">ssl._create_default_https_context</tt>
function, which is the same as <tt class="docutils literal">ssl.create_default_context</tt>.</p>
<p><tt class="docutils literal">http.client</tt> can then replace its usage of <tt class="docutils literal">ssl._create_stdlib_context</tt>
with the <tt class="docutils literal">ssl._create_default_https_context</tt>.</p>
<p>Additionally <tt class="docutils literal">ssl._create_stdlib_context</tt> is renamed
<tt class="docutils literal">ssl._create_unverified_context</tt> (an alias is kept around for backwards
compatibility reasons).</p>
<div class="section" id="trust-database">

<p>This PEP proposes using the system-provided certificate database. Previous
discussions have suggested bundling Mozilla's certificate database and using
that by default. This was decided against for several reasons:</p>
<ul class="simple">
<li>Using the platform trust database imposes a lower maintenance burden on the
Python developers -- shipping our own trust database would require doing a
release every time a certificate was revoked.</li>
<li>Linux vendors, and other downstreams, would unbundle the Mozilla
certificates, resulting in a more fragmented set of behaviors.</li>
<li>Using the platform stores makes it easier to handle situations such as
corporate internal CAs.</li>
</ul>
<p>OpenSSL also has a pair of environment variables, <tt class="docutils literal">SSL_CERT_DIR</tt> and
<tt class="docutils literal">SSL_CERT_FILE</tt> which can be used to point Python at a different certificate
database.</p>
</div>
<div class="section" id="backwards-compatibility">

<p>This change will have the appearance of causing some HTTPS connections to
"break", because they will now raise an Exception during handshake.</p>
<p>This is misleading however, in fact these connections are presently failing
silently, an HTTPS URL indicates an expectation of confidentiality and
authentication. The fact that Python does not actually verify that the user's
request has been made is a bug, further: "Errors should never pass silently."</p>
<p>Nevertheless, users who have a need to access servers with self-signed or
incorrect certificates would be able to do so by providing a context with
custom trust roots or which disables validation (documentation should strongly
recommend the former where possible). Users will also be able to add necessary
certificates to system trust stores in order to trust them globally.</p>
<p>Twisted's 14.0 release made this same change, and it has been met with almost
no opposition.</p>
</div>
<div class="section" id="opting-out">

<p>For users who wish to opt out of certificate verification on a single
connection, they can achieve this by providing the <tt class="docutils literal">context</tt> argument to
<tt class="docutils literal">urllib.urlopen</tt>:</p>
<pre class="literal-block">
import ssl

# This restores the same behavior as before.
context = ssl._create_unverified_context()
urllib.urlopen("https://no-valid-cert", context=context)
</pre>
<p>It is also possible, <strong>though highly discouraged</strong>, to globally disable
verification by monkeypatching the <tt class="docutils literal">ssl</tt> module in versions of Python that
implement this PEP:</p>
<pre class="literal-block">
import ssl

try:
    _create_unverified_https_context = ssl._create_unverified_context
except AttributeError:
    # Legacy Python that doesn't verify HTTPS certificates by default
    pass
else:
    # Handle target environment that doesn't support HTTPS verification
    ssl._create_default_https_context = _create_unverified_https_context
</pre>
<p>This guidance is aimed primarily at system administrators that wish to adopt
newer versions of Python that implement this PEP in legacy environments that
do not yet support certificate verification on HTTPS connections. For
example, an administrator may opt out by adding the monkeypatch above to
<tt class="docutils literal">sitecustomize.py</tt> in their Standard Operating Environment for Python.
Applications and libraries SHOULD NOT be making this change process wide
(except perhaps in response to a system administrator controlled configuration
setting).</p>
<p>Particularly security sensitive applications should always provide an explicit
application defined SSL context rather than relying on the default behaviour
of the underlying Python implementation.</p>
</div>
</div>
<div class="section" id="other-protocols">

<p>This PEP only proposes requiring this level of validation for HTTP clients, not
for other protocols such as SMTP.</p>
<p>This is because while a high percentage of HTTPS servers have correct
certificates, as a result of the validation performed by browsers, for other
protocols self-signed or otherwise incorrect certificates are far more common.
Note that for SMTP at least, this appears to be changing and should be reviewed
for a potential similar PEP in the future:</p>

</div>
<div class="section" id="python-versions">

<p>This PEP describes changes that will occur on both the 3.4.x, 3.5 and 2.7.X
branches. For 2.7.X this will require backporting the <tt class="docutils literal">context</tt>
(<tt class="docutils literal">SSLContext</tt>) argument to <tt class="docutils literal">httplib</tt>, in addition to the features already
backported in <a class="reference external" href="/dev/peps/pep-0466">PEP 466</a>.</p>
</div>
<div class="section" id="implementation">

<ul class="simple">
<li><strong>LANDED</strong>: <a class="reference external" href="http://bugs.python.org/issue22366">Issue 22366</a> adds the
<tt class="docutils literal">context</tt> argument to <tt class="docutils literal">urlib.request.urlopen</tt>.</li>
<li><a class="reference external" href="http://bugs.python.org/issue22417">Issue 22417</a> implements the substance
of this PEP.</li>
</ul>
</div>
<div class="section" id="copyright">

<p>This document has been placed into the public domain.</p>

</div>



      </div>

      
      </div></body></html>