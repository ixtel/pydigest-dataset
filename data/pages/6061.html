<html><body><div><div class="section">
              <h1>jsongraph 0.2.2</h1>

              


<p>Library for data integration using a JSON/RDF object graph.</p><p>








# jsongraph [![Build Status](https://travis-ci.org/pudo/jsongraph.svg?branch=master)](https://travis-ci.org/pudo/jsongraph)</p><p>This library provides tools to integrate data from multiple sources into a</p><p>coherent data model. Given a heterogeneous set of source records, it will</p><p>generate a set of composite entities with merged information from all</p><p>available sources. Further, it allows querying the resulting graph using a</p><p>simple, JSON-based graph query language.</p><p>The intent of this tool is to make a graph-based data integration system</p><p>(based on RDF) seamlessly available through simple JSON objects.</p><p>## Usage</p><p>This is what using the library looks like in a simplified scenario:</p><p>```python</p><p>from jsongraph import Graph</p><p># Create a graph for all project information. This can be backed by a</p><p># triple store or an in-memory construct.</p><p>graph = Graph(base_uri='file:///path/to/schema/files')</p><p>graph.register('person', 'person_schema.json')</p><p># Load data about a person.</p><p>context = graph.context()</p><p>context.add('person', data)</p><p>context.save()</p><p># Repeat data loading for a variety of source files.</p><p># This will integrate data from all source files into a single representation</p><p># of the data.</p><p>context = graph.consolidate('urn:prod')</p><p># Metaweb-style queries:</p><p>for item in context.query([{"name": None, "limit": 5}]):</p><p>    print item['name']</p><p>```</p><p>## Design</p><p>A ``jsongraph`` application is focussed on a ``Graph``, which stores a set of</p><p>data. A ``Graph`` can either exist only in memory, or be stored in a backend</p><p>database.</p><p>All data in a ``Graph`` is structured as collections of JSON objects (i.e.</p><p>nested dictionaries, lists and values). The structure of all stored objects</p><p>must be defined using a [JSON Schema](http://json-schema.org/) Some limits</p><p>apply to such schema, e.g. they may not allow additional or pattern properties.</p><p>### Contexts and Metadata</p><p>The objects in each ``Graph`` are grouped into a set of ``Contexts``. Those</p><p>also include metadata, such as the source of the data, and the level of trust</p><p>that the system shall have in those data. A ``Context`` will usually correspond</p><p>to a source data file, or a user interaction.</p><p>### Consolidated Contexts</p><p>When working with ``jsongraph``, a user will first load data into a variety of</p><p>``Contexts``. They can then generate a consolidated version of the data, in a</p><p>separate ``Context``.</p><p>This consolidated version applies entity de-duplication. For object properties</p><p>with multiple available values across several ``Contexts``, the information</p><p>from the most trustworthy ``Context`` will be chosen.</p><p>### Queries</p><p>``jsongraph`` includes a query language implementation, which is heavily</p><p>inspired by Google's [Metaweb Query Language](http://mql.freebaseapps.com/ch03.html)</p><p>Queries are written as JSON, and search proceeds by example. Searches can also</p><p>be deeply nested, traversing the links between objects stored in the ``Graph``</p><p>at an arbitrary complexity.</p><p>Queries on the data can be run either against any of the source ``Contexts``,</p><p>or against the consolidated context. Queries against the consolidated</p><p>``Context`` will produce responses which reflect the best available information</p><p>based on data from a variety of sources.</p><p>### De-duplication</p><p>One key part of the functions of this library will be the application of</p><p>de-duplication rules. This will take place in three steps:</p><p>* Generating a set of de-duplicating candidates for all entities in a given</p><p>  ``Graph``. These will be simplified representations of objects which can be</p><p>  fed into a comparison tool (either automated or interactive with the user).</p><p>* Once the candidates have been decided, they are transformed into a mapping of</p><p>  the type (``original_fingerprint`` -&gt; ``same_as_fingerprint``). Such mappings</p><p>  are applied to a context.</p><p>* Upon graph consolidation (see above), the entities which have been mapped to</p><p>  another are not included. All their properties are inherited by the</p><p>  destination entity.</p><p>A data comparison candidate may look like this:</p><p>```json</p><p>{</p><p>    "fingerprint": "...",</p><p>    "entity": "...",</p><p>    "data": {</p><p>    },</p><p>    "source": {</p><p>        "label": "...",</p><p>        "url": "http://..."</p><p>    }</p><p>}</p><p>```</p><p>## Tests</p><p>The test suite will usually be executed in it's own ``virtualenv`` and perform a</p><p>coverage check as well as the tests. To execute on a system with ``virtualenv``</p><p>and ``make`` installed, type:</p><p>```bash</p><p>$ make test</p><p>```

</p><a name="downloads">Â </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>43</span> downloads in the last week
  </li>
  <li>
    <span>319</span> downloads in the last month
  </li>
</ul>









            </div>


          </div></body></html>