<html><body><div><div class="content html_format">
      <h5>Всё хорошо</h5>
<a href="https://twistedmatrix.com/trac/">Twisted</a><p> — асинхронный (событийно-ориентированный) фреймворк, написанный на Python. Мощное средство для быстрой разработки сетевых (и не только) сервисов. Он разработан с использованием паттерна проектирования </p><a href="https://en.wikipedia.org/wiki/Reactor_pattern">Reactor</a><p>. Сервисы созданные с использованием Twisted быстры и надежны, фреймворк позволяет не писать макаронный код, насыщенный непонятными коллбэками, имеет внутри себя красивые хелперы (Deferred, Transport, Protocol etc). Другими словами, делает нашу жизнь бекенд разработчиков лучше.

</p><h5>Но есть и проблемы</h5><p>
Основная проблема в том, что многочисленные, надежные, оттестированные, удобные библиотеки, использующие в своей основе синхронные модули Python (socket, os, ssl, time, select, thread, subprocess, sys, signal etc), просто возьмут и заблокируют нам основной процесс, цикл реактора и наступит беда. Такими библиотеками, к примеру, являются psycopg2, request, mysql и другие. В частности, psycopg2 используется в Django ORM как один из бекендов баз данных.

</p><h5>Что же делать?</h5><p>
Есть три пути. Сложный, приемлемый и хороший. Сложный — реализовать аналог библиотеки на Twisted. Приемлемый — использовать deferToThread и запускать синхронный код в отдельных потоках (используя пул потоков реализованный в Twisted). О хорошем пути (по моему мнению) и пойдет речь в заметке.
 </p><a href="/post/266887/"><img src="https://habrastorage.org/files/603/884/7fb/6038847fb6d740b5b2abe5f02a8d01fb.jpg" alt="Скрестить ежа с ужом" title="Скрестить ежа с ужом"/></a>
<a name="habracut"/>

<h4>Используем «зеленые» потоки и события для переключения контекста!</h4>

<h5>Что нам для этого нужно?</h5>

<ul>
<li>Greenlets — легковесные «зеленые» потоки, которые работают внутри главного процесса приложения</li>
<li>Gevent — фреймворк, который позволяет переключать контекст между гринлетами, в тот момент, когда исполняемый код блокируется</li>
<li>Метод реактора [deferToGreenlet], позволяющий обернуть гринлет в Deferred</li>
</ul>

<h5>Пример применения технологии в реальном проекте</h5>
<p>
Я не стал писать собственную реализацию реактора с возможностью отправлять код в гринлеты, так как нашел готовое решение, протестировал и внедрил в проект. Код реактора можно забрать </p><a href="https://gist.github.com/yann2192/3394661">отсюда</a><p>.
</p><p>
Для использования </p><b>geventreactor</b><p> при инициализации приложения нужно его установить:

</p><pre><code class="python">from geventreactor import install
install()
</code></pre>
<p>
Теперь нам доступны новые методы:
</p><pre><code class="python">__all__ = ['deferToGreenletPool', 'deferToGreenlet', 'callMultipleInGreenlet', 'waitForGreenlet', 'waitForDeferred',
           'blockingCallFromGreenlet', 'IReactorGreenlets', 'GeventResolver', 'GeventReactor', 'install']
</code></pre>
<p>
По аналогии с reactor.deferToThread(f, *args, **kwargs), можно вызывать reactor.deferToGreenlet(f, *args, **kwargs), где f — </p><i>callable</i><p> объект, а *args и **kwargs его аргументы.
</p><p>
Чтобы все заработало необходимо также пропатчить библиотеки в пространстве имен:
</p><pre><code class="python">from gevent import monkey

monkey.patch_all()
</code></pre>
<p>
После данных манипуляций, основные библиотеки Python будут пропатчены фреймворком Gevent. </p><a href="http://www.gevent.org/gevent.monkey.html#module-gevent.monkey">Смотрите документацию по Gevent</a>
<p>
Теперь все библиотеки или код, который напрямую импортирует их, при вызове блокирующихся методов или функций, будут вызывать соответствующие события в системе Gevent. На эти события повешены коллбеки, позволяющие переключать контекст между гринлетами.
</p><p>
У меня в проекте используется Django ORM для манипуляции данными в PostgreSQL. Поэтому для того, чтобы методы ORM не блокировали процесс нужно использовать специальный бекенд, позволяющий создавать пул соединений с БД и переключаться между соединениями. Одним из бекендов является </p><a href="https://pypi.python.org/pypi/django-db-geventpool">django-db-geventpool</a>
<p>
Использовать django-db-geventpool не трудно. Достаточно следовать документации.

</p><h5>Что дальше?</h5>
<p>
Метод reactor.deferToGreenlet возвращает объект Deferred, с которым можно работать как с обычным Deferred.
</p><p>
Например, у нас есть модель:

</p><pre><code class="python">class ExampleModel(models.Model):
    title = models.CharField(max_length=256)
</code></pre>
<p>
Мы хотим получить все модели и передать их какому-то обработчику внутри системы. Мы можем написать что-то вроде:
</p><pre><code class="python">d = reactor.deferToGreenlet(ExampleModel.objects.all)
</code></pre>
<p>
И наш код не заблокирует основной процесс. Ведь в тот момент, когда Django ORM вызовет cursor.execute(), который будет ожидать ответ от драйвера базы данных, geventreactor переключит контекст на другой Deferred.

</p><h5>Что в итоге?</h5>
<p>
Мы можем выполнять синхронный код внутри Twisted, не создавая при этом лишних потоков или процессов, при этом не блокируя event loop реактора. Главное следовать основным принципам работы с асинхронными системами, куски кода не должны выполняться слишком долго, gevent позволяет принудительно переключать контекст из любого места кода, там, где это нам удобно, достаточно лишь вызвать gevent.sleep().

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>