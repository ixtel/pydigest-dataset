<html><body><div><div class="post-text" itemprop="text">

<p>I have a large python application which is running on a Django service. I need to turn off permission tests for certain operations so I created this context manager:</p>

<pre><code>class OverrideTests(object):

    def __init__(self):
        self.override = 0

    def __enter__(self):
        self.override += 1

    # noinspection PyUnusedLocal
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.override -= 1
        assert not self.override &lt; 0

    @property
    def overriding(self):
        return self.override &gt; 0

override_tests = OverrideTests()
</code></pre>

<p>Various parts of the application can then overide the tests using the context manager:</p>

<pre><code>with override_tests:
    do stuff
    ...
</code></pre>

<p>Within the do stuff, the above context manager may be used multiple times in different functions. The use of the counter keeps this under control and it seems to work fine... until threads get involved.</p>

<p>Once there are threads involved, the global context manager gets re-used and as a result, tests may be incorrectly over-ridden.</p>

<p>Here is a simple test case - this works fine if the <code>thread.start_new_thread(do_id, ())</code> line is replaced with a simple <code>do_it</code> but fails spectacularly as shown:</p>

<pre><code>def stat(k, expected):
    x = '.' if override_tests.overriding == expected else '*'
    sys.stdout.write('{0}{1}'.format(k, x))


def do_it_inner():
    with override_tests:
        stat(2, True)
    stat(3, True)  # outer with context makes this true


def do_it():
    with override_tests:
        stat(1, True)
        do_it_inner()
    stat(4, False)


def do_it_lots(ntimes=10):
    for i in range(ntimes):
        thread.start_new_thread(do_it, ())
</code></pre>

<p>How can I make this context manager thread safe so that in each Python thread, it is consistently used even though it is re-entrant?</p>
    </div>
    </div></body></html>