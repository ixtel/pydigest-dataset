<html><body><div><div class="entry-content"><p>Представьте, что вы написали какую-либо программу, а теперь хотите проверить, правильно ли она работает. Что вы для этого сделаете? Скорее всего, вы запустите её несколько раз с различными входными данными, и убедитесь в правильности выдаваемого ответа.</p><p>А теперь вы что-то поменяли и снова хотите проверить корректность программы. Запускать ещё несколько раз? А если потом снова что-то поменяется? Нельзя ли как-то автоматизировать это дело?</p><p>Оказывается, можно. В Python встроен модуль <tt>unittest</tt>, который поддерживает автоматизацию тестов, использование общего кода для настройки и завершения тестов, объединение тестов в группы, а также позволяет отделять тесты от фреймворка для вывода информации.</p><p>Для автоматизации тестов, unittest поддерживает некоторые важные коцепции:</p><ul><li><b>Испытательный стенд</b> (test fixture) - выполняется подготовка, необходимая для выполнения тестов и все необходимые действия для очистки после выполнения тестов. Это может включать, например, создание временных баз данных или запуск серверного процесса.</li><li><b>Тестовый случай</b> (test case) - минимальный блок тестирования. Он проверяет ответы для разных наборов данных. Модуль unittest предоставляет базовый класс TestCase, который можно использовать для создания новых тестовых случаев.</li><li><b>Набор тестов</b> (test suite) - несколько тестовых случаев, наборов тестов или и того и другого. Он используется для объединения тестов, которые должны быть выполнены вместе.</li><li><b>Исполнитель тестов</b> (test runner) - компонент, который управляет выполнением тестов и предоставляет пользователю результат. Исполнитель может использовать графический или текстовый интерфейс или возвращать специальное значение, которое сообщает о результатах выполнения тестов.</li></ul><p>Модуль unittest предоставляет богатый набор инструментов для написания и запуска тестов. Однако достаточно лишь некоторых из них, чтобы удовлетворить потребности большинства пользователей.</p><p>Вот короткий скрипт для тестирования трех <a href="http://pythonworld.ru/tipy-dannyx-v-python/stroki-funkcii-i-metody-strok.html" target="_blank">методов строк</a>:</p><pre class="code python3"><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">TestStringMethods</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">test_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s1">'foo'</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="s1">'FOO'</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">test_isupper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="s1">'FOO'</span><span class="o">.</span><span class="n">isupper</span><span class="p">())</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="s1">'Foo'</span><span class="o">.</span><span class="n">isupper</span><span class="p">())</span>

  <span class="k">def</span> <span class="nf">test_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">s</span> <span class="o">=</span> <span class="s1">'hello world'</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="p">[</span><span class="s1">'hello'</span><span class="p">,</span> <span class="s1">'world'</span><span class="p">])</span>
      <span class="c1"># Проверим, что s.split не работает, если разделитель - не строка</span>
      <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
          <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span></pre><p>Тестовый случай создаётся путём <a href="http://pythonworld.ru/osnovy/inkapsulyaciya-nasledovanie-polimorfizm.html" target="_blank">наследования</a> от <tt>unittest.TestCase</tt>. 3 отдельных теста определяются с помощью методов, имя которых начинается на <tt>test</tt>. Это соглашение говорит исполнителю тестов о том, какие методы являются тестами.</p><p>Суть каждого теста - вызов <tt>assertEqual</tt>() для проверки ожидаемого результата; <tt>assertTrue</tt>() или <tt>assertFalse</tt>() для проверки условия; <tt>assertRaises</tt>() для проверки, что метод порождает <a href="http://pythonworld.ru/tipy-dannyx-v-python/isklyucheniya-v-python-konstrukciya-try-except-dlya-obrabotki-isklyuchenij.html" target="_blank">исключение</a>. Эти методы используются вместо обычного <tt>assert</tt> для того, чтобы исполнитель тестов смог взять все результаты и оформить отчёт.</p><p>Методы <tt>setUp</tt>() и <tt>tearDown</tt>() (которые в данном простом случае не нужны) позволяют определять инструкции, выполняемые перед и после каждого теста, соответственно.</p><p>Последние 2 строки показывают простой способ запуска тестов. <tt>unittest.main</tt>() предоставляет интерфейс командной строки для тестирования программы. Будучи запущенным из командной строки, этот скрипт выводит отчёт, подобный этому:</p><pre class="code python3"><span class="o">...</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.000</span><span class="n">s</span>

<span class="n">OK</span></pre><div class="section" id="id1"><h2>Интерфейс командной строки</h2><p>unittest может быть использован из командной строки для запуска модулей с тестами, классов или даже отдельных методов:</p><pre class="code bash literal-block">
python -m unittest test_module1 test_module2
python -m unittest test_module.TestClass
python -m unittest test_module.TestClass.test_method
</pre><p>Можно также указывать путь к файлу:</p><pre class="code bash literal-block">
python -m unittest tests/test_something.py
</pre><p>С помощью флага <tt><span class="pre">-v</span></tt> можно получить более детальный отчёт:</p><pre class="code bash literal-block">
python -m unittest -v test_module
</pre><p>Для нашего примера подробный отчёт будет таким:</p><pre class="code python3"><span class="n">test_isupper</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_split</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_upper</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>

<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.001</span><span class="n">s</span>

<span class="n">OK</span></pre><p><tt><span class="pre">-b</span></tt> (<tt><span class="pre">--buffer</span></tt>) - вывод программы при провале теста будет показан, а не скрыт, как обычно.</p><p><tt><span class="pre">-c</span></tt> (<tt><span class="pre">--catch</span></tt>) - Ctrl+C во время выполнения теста ожидает завершения текущего теста и затем сообщает результаты на данный момент. Второе нажатие Ctrl+C вызывает обычное исключение <tt>KeyboardInterrupt</tt>.</p><p><tt><span class="pre">-f</span></tt> (<tt><span class="pre">--failfast</span></tt>) - выход после первого же неудачного теста.</p><p><tt><span class="pre">--locals</span></tt> (начиная с Python 3.5) - показывать локальные переменные для провалившихся тестов.</p></div><div class="section" id="id2"><h2>Обнаружение тестов</h2><p>unittest поддерживает простое обнаружение тестов. Для совместимости с обнаружением тестов, все файлы тестов должны быть модулями или пакетами, импортируемыми из директории верхнего уровня проекта (см. подробнее о <a href="http://pythonworld.ru/osnovy/rabota-s-modulyami-sozdanie-podklyuchenie-instrukciyami-import-i-from.html#id3" target="_blank">правилах наименования модулей</a> ).</p><p>Обнаружение тестов реализовано в <tt>TestLoader.discover</tt>(), но может быть использовано из командной строки:</p><pre class="code bash literal-block">
<span class="nb">cd</span> project_directory
python -m unittest discover
</pre><p><tt><span class="pre">-v</span></tt> (<tt><span class="pre">--verbose</span></tt>) - подробный вывод.</p><p><tt><span class="pre">-s</span></tt> (<tt><span class="pre">--start-directory</span></tt>) directory_name - директория начала обнаружения тестов (текущая по умолчанию).</p><p><tt><span class="pre">-p</span></tt> (<tt><span class="pre">--pattern</span></tt>) pattern - шаблон названия файлов с тестами (по умолчанию test*.py).</p><p><tt><span class="pre">-t</span></tt> (<tt><span class="pre">--top-level-directory</span></tt>) directory_name - директория верхнего уровня проекта (по умолчанию равна <tt><span class="pre">start-directory</span></tt>).</p></div><div class="section" id="id3"><h2>Организация тестового кода</h2><p>Базовые блоки тестирования это тестовые случаи - простые случаи, которые должны быть проверены на корректность.</p><p>Тестовый случай создаётся путём наследования от <tt>unittest.TestCase</tt>.</p><p>Тестирующий код должен быть самостоятельным, то есть никак не зависеть от других тестов.</p><p>Простейший подкласс TestCase может просто реализовывать тестовый метод (метод, начинающийся с <tt>test</tt>). Вымышленный пример:</p><pre class="code python3"><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">DefaultWidgetSizeTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_default_widget_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">'The widget'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span></pre><p>Заметьте, что для того, чтобы проверить что-то, мы используем один из <tt>assert\*</tt>() методов.</p><p>Тестов может быть много, и часть кода настройки может повторяться. К счастью, мы можем определить код настройки путём реализации метода <tt>setUp</tt>(), который будет запускаться <i>перед</i> каждым тестом:</p><pre class="code python3"><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">SimpleWidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">'The widget'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_default_widget_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
                         <span class="s1">'incorrect default size'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_widget_resize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">),</span>
                         <span class="s1">'wrong size after resize'</span><span class="p">)</span></pre><p>Мы также можем определить метод <tt>tearDown</tt>(), который будет запускаться <i>после</i> каждого теста:</p><pre class="code python3"><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">SimpleWidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">'The widget'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span></pre><p>Можно разместить все тесты в том же файле, что и сама программа (таком как widgets.py), но размещение тестов в отдельном файле (таком как test_widget.py) имеет много преимуществ:</p><ul><li>Модуль с тестом может быть запущен автономно из командной строки.</li><li>Тестовый код может быть легко отделён от программы.</li><li>Меньше искушения изменить тесты для соответствия коду программы без видимой причины.</li><li>Тестовый код должен изменяться гораздо реже, чем программа.</li><li>Протестированный код может быть легче переработан.</li><li>Тесты для модулей на C должны быть в отдельных модулях, так почему же не быть последовательным?</li><li>Если стратегия тестирования изменяется, нет необходимости изменения кода программы.</li></ul></div><div class="section" id="id4"><h2>Пропуск тестов и ожидаемые ошибки</h2><p>unittest поддерживает пропуск отдельных тестов, а также классов тестов. Вдобавок, поддерживается пометка теста как "не работает, но так и надо".</p><p>Пропуск теста осуществляется использованием <a href="http://pythonworld.ru/osnovy/dekoratory.html" target="_blank">декоратора</a><tt>skip</tt>() или одного из его условных вариантов.</p><pre class="code python3"><span class="k">class</span> <span class="nc">MyTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">"demonstrating skipping"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_nothing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="s2">"shouldn't happen"</span><span class="p">)</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skipIf</span><span class="p">(</span><span class="n">mylib</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                     <span class="s2">"not supported in this library version"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Tests that work for only a certain version of the library.</span>
        <span class="k">pass</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skipUnless</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">"win"</span><span class="p">),</span> <span class="s2">"requires Windows"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_windows_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># windows specific testing code</span>
        <span class="k">pass</span></pre><pre class="code python3"><span class="n">test_format</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">'not supported in this library version'</span>
<span class="n">test_nothing</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">'demonstrating skipping'</span>
<span class="n">test_windows_support</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">'requires Windows'</span>

<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.005</span><span class="n">s</span>

<span class="n">OK</span> <span class="p">(</span><span class="n">skipped</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span></pre><p>Классы также могут быть пропущены:</p><pre class="code python3"><span class="nd">@unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">"showing class skipping"</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MySkippedTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_not_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></pre><p>Ожмдаемые ошибки используют декоратор <tt>expectedFailure</tt>():</p><pre class="code python3"><span class="k">class</span> <span class="nc">ExpectedFailureTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@unittest</span><span class="o">.</span><span class="n">expectedFailure</span>
    <span class="k">def</span> <span class="nf">test_fail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">"broken"</span><span class="p">)</span></pre><p>Очень просто сделать свой декоратор. Например, следующий декоратор пропускает тест, если переданный объект не имеет указанного атрибута:</p><pre class="code python3"><span class="k">def</span> <span class="nf">skipUnlessHasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">func</span><span class="p">:</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">"{!r} doesn't have {!r}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span></pre><p>Декораторы, пропускающие тесты или говорящие об ожидаемых ошибках:</p><p><tt>@unittest.skip</tt>(reason) - пропустить тест. reason описывает причину пропуска.</p><p><tt>@unittest.skipIf</tt>(condition, reason) - пропустить тест, если condition истинно.</p><p><tt>@unittest.skipUnless</tt>(condition, reason) - пропустить тест, если condition ложно.</p><p><tt>@unittest.expectedFailure</tt> - пометить тест как ожидаемая ошибка.</p><p>Для пропущенных тестов не запускаются setUp() и tearDown(). Для пропущенных классов не запускаются setUpClass() и tearDownClass(). Для пропущенных модулей не запускаются setUpModule() и tearDownModule().</p></div><div class="section" id="id5"><h2>Различение итераций теста с помощью подтестов</h2><p>Когда некоторые тесты имеют лишь незначительные отличия, например некоторые параметры, unittest позволяет различать их внутри одного тестового метода, используя <a href="http://pythonworld.ru/osnovy/with-as-menedzhery-konteksta.html" target="_blank">менеджер контекста</a><tt>subTest</tt>().</p><p>Например, следующий тест:</p><pre class="code python3"><span class="k">class</span> <span class="nc">NumbersTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_even</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""
        Test that numbers between 0 and 5 are all even.
        """</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">subTest</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></pre><p>даст следующий отчёт:</p><pre class="code python3"><span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"subtests.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>

<span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"subtests.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>

<span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"subtests.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span></pre><p>Без использования подтестов, выполнение будет остановлено после первой ошибки, и ошибку будет сложнее диагностировать, потому что значение i не будет показано:</p><pre class="code python3"><span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"subtests.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span></pre></div><div class="section" id="id6"><h2>Проверки на успешность</h2><p>Модуль unittest предоставляет множество функций для самых различных проверок:</p><p><tt>assertEqual</tt>(a, b) — <tt>a == b</tt></p><p><tt>assertNotEqual</tt>(a, b) — <tt>a != b</tt></p><p><tt>assertTrue</tt>(x) — <tt>bool(x) is True</tt></p><p><tt>assertFalse</tt>(x) — <tt>bool(x) is False</tt></p><p><tt>assertIs</tt>(a, b) — <tt>a is b</tt></p><p><tt>assertIsNot</tt>(a, b) — <tt>a is not b</tt></p><p><tt>assertIsNone</tt>(x) — <tt>x is None</tt></p><p><tt>assertIsNotNone</tt>(x) — <tt>x is not None</tt></p><p><tt>assertIn</tt>(a, b) — <tt>a in b</tt></p><p><tt>assertNotIn</tt>(a, b) — <tt>a not in b</tt></p><p><tt>assertIsInstance</tt>(a, b) — <tt>isinstance(a, b)</tt></p><p><tt>assertNotIsInstance</tt>(a, b) — <tt>not isinstance(a, b)</tt></p><p><tt>assertRaises</tt>(exc, fun, *args, **kwds) — fun(*args, **kwds) порождает исключение exc</p><p><tt>assertRaisesRegex</tt>(exc, r, fun, *args, **kwds) — fun(*args, **kwds) порождает исключение exc и сообщение соответствует регулярному выражению r</p><p><tt>assertWarns</tt>(warn, fun, *args, **kwds) — fun(*args, **kwds) порождает предупреждение</p><p><tt>assertWarnsRegex</tt>(warn, r, fun, *args, **kwds) — fun(*args, **kwds) порождает предупреждение и сообщение соответствует регулярному выражению r</p><p><tt>assertAlmostEqual</tt>(a, b) — <tt><span class="pre">round(a-b,</span> 7) == 0</tt></p><p><tt>assertNotAlmostEqual</tt>(a, b) — <tt><span class="pre">round(a-b,</span> 7) != 0</tt></p><p><tt>assertGreater</tt>(a, b) — <tt>a &gt; b</tt></p><p><tt>assertGreaterEqual</tt>(a, b) — <tt>a &gt;= b</tt></p><p><tt>assertLess</tt>(a, b) — <tt>a &lt; b</tt></p><p><tt>assertLessEqual</tt>(a, b) — <tt>a &lt;= b</tt></p><p><tt>assertRegex</tt>(s, r) — <tt>r.search(s)</tt></p><p><tt>assertNotRegex</tt>(s, r) — <tt>not r.search(s)</tt></p><p><tt>assertCountEqual</tt>(a, b) — a и b содержат те же элементы в одинаковых количествах, но порядок не важен</p></div></div></div></body></html>