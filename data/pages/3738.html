<html><body><div><div class="entry-content">
		<p>This is the third part in a series of articles about data mining on Twitter. After collecting data and pre-processing some text, we are ready for some basic analysis. In this article, we’ll discuss the analysis of term frequencies to extract meaningful terms from our tweets.</p>
<p>Tutorial Table of Contents:</p>

<h2>Counting Terms</h2>
<p>Assuming we have collected a list of tweets (<a href="http://marcobonzanini.com/2015/03/02/mining-twitter-data-with-python-part-1/">see Part 1 of the tutorial</a>), the first exploratory analysis that we can perform is a simple word count. In this way, we can observe what are the terms most commonly used in the data set. In this example, I’ll use the set of my tweets, so the most frequent words should correspond to the topics I discuss (not necessarily, but bear with be for a couple of paragraphs).</p>
<p>We can use a custom tokeniser to split the tweets into a list of terms. The following code uses the <tt>preprocess()</tt> function described <a href="http://marcobonzanini.com/2015/03/09/mining-twitter-data-with-python-part-2/">in Part 2 of the tutorial</a>, in order to capture Twitter-specific aspects of the text, such as #hashtags, @-mentions, emoticons and URLs. In order to keep track of the frequencies while we are processing the tweets, we can use <tt>collections.Counter()</tt> which internally is a  dictionary (term: count) with some useful methods like <tt>most_common()</tt>:</p>
<pre class="brush: python; title: ; notranslate" title="">
import operator 
import json
from collections import Counter

fname = 'mytweets.json'
with open(fname, 'r') as f:
    count_all = Counter()
    for line in f:
        tweet = json.loads(line)
        # Create a list with all the terms
        terms_all = [term for term in preprocess(tweet['text'])]
        # Update the counter
        count_all.update(terms_all)
    # Print the first 5 most frequent words
    print(count_all.most_common(5))
</pre>
<p>The above code will produce some unimpressive results:</p>
<pre>[(':', 44), ('rt', 26), ('to', 26), ('and', 25), ('on', 22)]</pre>
<p>As you can see, the most frequent words (or should I say, tokens), are not exactly meaningful.</p>
<h2>Removing stop-words</h2>
<p>In every language, some words are particularly common. While their use in the language is crucial, they don’t usually convey a particular meaning, especially if taken out of context. This is the case of articles, conjunctions, some adverbs, etc. which are commonly called <em>stop-words</em>. In the example above, we can see three common stop-words – <em>to</em>, <em>and</em> and <em>on</em>. Stop-word removal is one important step that should be considered during the pre-processing stages. One can build a custom list of stop-words, or use available lists (e.g. NLTK provides a simple list for English stop-words).</p>
<p>Given the nature of our data and our tokenisation, we should also be careful with all the punctuation marks and with terms like <em>RT</em> (used for re-tweets) and <em>via</em> (used to mention the original author of an article or a re-tweet), which are not in the default stop-word list. </p>
<pre class="brush: python; title: ; notranslate" title="">
from nltk.corpus import stopwords
import string

punctuation = list(string.punctuation)
stop = stopwords.words('english') + punctuation + ['rt', 'via']
</pre>
<p>We can now substitute the variable <tt>terms_all</tt> in the first example with something like:</p>
<pre class="brush: python; title: ; notranslate" title="">
terms_stop = [term for term in preprocess(tweet['text']) if term not in stop]
</pre>
<p>After counting, sorting the terms and printing the top 5, this is the result:</p>
<pre>[('python', 11), ('@miguelmalvarez', 9), ('#python', 9), ('data', 8), ('@danielasfregola', 7)]</pre>
<p>So apparently I mostly tweet about <em>Python</em> and <em>data</em>, and the users I re-tweet more often are <a href="http://www.twitter.com/miguelmalvarez">@miguelmalvarez</a> and <a href="http://www.twitter.com/danielasfregola">@danielasfregola</a>, it sounds about right.</p>
<h2>More term filters</h2>
<p>Besides stop-word removal, we can further customise the list of terms/tokens we are interested in. Here you have some examples that you can embed in the first fragment of code:</p>
<pre class="brush: python; title: ; notranslate" title="">
# Count terms only once, equivalent to Document Frequency
terms_single = set(terms_all)
# Count hashtags only
terms_hash = [term for term in preprocess(tweet['text']) 
              if term.startswith('#')]
# Count terms only (no hashtags, no mentions)
terms_only = [term for term in preprocess(tweet['text']) 
              if term not in stop and 
              not term.startswith(('#', '@'))] 
              # mind the ((double brackets))
              # startswith() takes a tuple (not a list) if 
              # we pass a list of inputs
</pre>
<p>After counting and sorting, these are my most commonly used hashtags:</p>
<pre>[('#python', 9), ('#scala', 6), ('#nosql', 4), ('#bigdata', 3), ('#nlp', 3)]</pre>
<p>and these are my most commonly used terms:</p>
<pre>[('python', 11), ('data', 8), ('summarisation', 6), ('twitter', 5), ('nice', 5)]</pre>
<p>“nice”? </p>
<p>While the other frequent terms represent a clear topic, more often than not simple term frequencies don’t give us a deep explanation of what the text is about. To put things in context, let’s consider sequences of two terms (a.k.a. <em>bigrams</em>). </p>
<pre class="brush: python; title: ; notranslate" title="">
from nltk import bigrams 

terms_bigram = bigrams(terms_stop)
</pre>
<p>The <tt>bigrams()</tt> function from NLTK will take a list of tokens and produce a list of tuples using adjacent tokens. Notice that we could use <tt>terms_all</tt> to compute the bigrams, but we would probably end up with a lot of garbage. In case we decide to analyse longer <em>n-grams</em> (sequences of <em>n</em> tokens), it could make sense to keep the stop-words, just in case we want to capture phrases like “to be or not to be”.</p>
<p>So after counting and sorting the bigrams, this is the result:</p>
<pre>[(('nice', 'article'), 4), (('extractive', 'summarisation'), 4), (('summarisation', 'sentence'), 3), (('short', 'paper'), 3), (('paper', 'extractive'), 2)]</pre>
<p>So apparently I tweet about nice articles (I wouldn’t bother sharing the boring ones) and extractive summarisation (the topic of my PhD dissertation). This also sounds about right.</p>
<h2>Summary</h2>
<p>This article has built on top of the previous ones to discuss some basis for extracting interesting terms from a data set of tweets, by using simple term frequencies, stop-word removal and n-grams. While these approaches are extremely simple to implement, they are quite useful to have a bird’s eye view on the data. We have used some components of NLTK (introduced <a href="http://marcobonzanini.com/2015/01/26/stemming-lemmatisation-and-pos-tagging-with-python-and-nltk/">in a previous article</a>), so we don’t have to re-invent the wheel.</p>
<p><a href="http://www.twitter.com/marcobonzanini">@MarcoBonzanini</a></p>
<p>Tutorial Table of Contents:</p>

<div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><div class="sharedaddy sd-block sd-like jetpack-likes-widget-wrapper jetpack-likes-widget-unloaded" id="like-post-wrapper-82018920-85-56d5aa3dd5ca0" data-src="//widgets.wp.com/likes/#blog_id=82018920&amp;post_id=85&amp;origin=marcobonzanini.wordpress.com&amp;obj_id=82018920-85-56d5aa3dd5ca0" data-name="like-post-frame-82018920-85-56d5aa3dd5ca0"><h3 class="sd-title">Like this:</h3><p class="likes-widget-placeholder post-likes-widget-placeholder"><span class="button"><span>Like</span></span> <span class="loading">Loading...</span></p><span class="sd-text-color"/><a class="sd-link-color"/></div>
<p id="jp-relatedposts" class="jp-relatedposts">
	<h3 class="jp-relatedposts-headline"><em>Related</em></h3>
</p></div>	</div>

	
</div></body></html>