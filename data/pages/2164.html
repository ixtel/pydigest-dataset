<html><body><div><div class="content"><p>Хочу рассказать о том, как сделать интерпретатор с помощью библиотеки Graph-talk. В качестве примера будет использоваться замечательный язык <a href="http://ru.wikipedia.org/wiki/Brainfuck">Brainfuck</a>.</p>
<h2>Грамматика языка</h2>
<p>Всего в языке имеется 8 команд:</p>
<ul>
<li>«&gt;» — переход к следующей ячейке памяти;</li>
<li>«&lt;» — переход к предыдущей ячейке памяти;</li>
<li>«+» — <span>увеличить значение в текущей ячейке на 1;</span></li>
<li>«-» — <span>уменьшить значение в текущей ячейке на 1;</span></li>
<li>«.» — вывести<span> значение текущей ячейки;</span></li>
<li>«,» — ввести значение извне в текущую ячейку</li>
<li>«[» — начало цикла, выполнить содержимое внутри цикла, если в текущей ячейке не 0;</li>
<li>«]» — конец цикла, вернуться на начало с учетом вложенности.</li>
</ul>
<p>Собственно, это все. Изначально имеется 30 000 ячеек памяти. «Hello, World!» на этом милейшем языке выглядит так:</p>
<blockquote><p>++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++<br/>
.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.<br/>
——.———.&gt;+.&gt;.</p>
<p> </p></blockquote>
<h2>Основные понятия graph-talk</h2>
<p>Graph-talk изначально проектировалась как библиотека для операций разбиения на лексемы, парсинга и интерпретации текстов, написанных на формальных языках.</p>
<p>Формальные языки и процессы обработки в ней представляются в виде графов, которые, в свою очередь, состоят из вершин (понятий) и дуг (связей или отношений между ними).</p>
<p>Есть 4 типа понятий:</p>
<ol>
<li>Простое понятие — лист дерева с некоторым названием (класс Notion);</li>
<li>Активное понятие — простое понятие, которое вызывает некоторую функцию при его обработке (ActionNotion);</li>
<li>Составное понятие — содержит в себе несколько других понятий в указанном порядке (ComplexNotion);</li>
<li>Выборочное понятие — аналог оператора «select», составное понятие, которое содержит в себе одно из нескольких понятий (SelectiveNotion).</li>
</ol>
<p>Понятия связаны между собой отношениями 4-х типов:</p>
<ol>
<li>Простая связь — соединяет вместе два понятия, одно из которых называется Subject, а другое — Object (класс Relation);</li>
<li>Направленная связь — позволяет переходить от одного понятия к другому, если выполняется заданное условие (NextRelation);</li>
<li>Активная связь — направленная связь, которая вызывает функцию при ее обработке (ActionRelation);</li>
<li>Распознающая связь — направленная связь, которая «поглощает» обработанный текст, если он совпадает с ее условием (ParsingRelation);</li>
<li>Циклическая связь — направленная связь, которая повторяет выбранное понятие указанное число раз (LoopRelation);</li>
</ol>
<p>Для обработки используется несколько типов процессов (Process) с разными возможностями. Для данного примера нам будет нужен процесс распознавания (ParsingProcess). ParsingProcess получает на вход текст и стартовую вершину графа для обработки. Затем он начинает обход графа, передавая имеющуюся у него информацию о тексте элементам графа. В зависимости от типа элемента он получает «ответы» с указаниями о дальнейших действиях, например: перейти к следующему элементу, выполнить функцию, обработать кусок текста и так далее. В конечном итоге весь входной текст оказывается обработан при помощи распознающих связей.</p>
<h2>Моделирование процесса интерпретации</h2>
<p>Программа представляет собой набор команд. С помощью графа можно представить это следующим образом:<br/>
<img src="https://pythonhosted.org/graph-talk/_images/action_program.png" alt="Программа на Brainfuck"/><br/>
Программа — это составное понятие, которое будет состоять из нескольких активных понятий в том порядке, в котором они встречаются в программе.</p>
<p>Для того чтобы реализовать цикл, его тело помещается внутрь соответствующего составного понятия, которое будет повторять содержимое до тех пор, пока значение текущей ячейки будет не 0. Это реализуется с помощью циклической связи (LoopRelation). На рисунке внизу показан цикл, который будет печатать содержимое текущей ячейки до тех пор, пока оно больше нуля:</p>
<p><img src="https://pythonhosted.org/graph-talk/_images/action_loop.png" alt="Цикл"/></p>
<p>Для непосредственного выполнения команд реализуются соответствующие функции, которые будут затем исполняться виртуальной машиной Brainfuck. После распознавания команды вызов функции помещается в граф программы как активное понятие. Когда входной текст полностью обработан, процесс обхода переходит на граф программы и начинает его выполнение. Вот как будет выглядеть граф программы «,[-.]» — ввода и печати содержимого ячейки, пока оно больше 0:</p>
<p><img class="alignleft" src="https://pythonhosted.org/graph-talk/_images/action_bf.png" alt="Граф интерпретатора"/></p>
<p>Как видно из рисунка, сам процесс интерпретации («Interpreter») состоит из обработки исходного кода («Source», будет одинаковым для всех программ на языке Brainfuck) и результирующей программы («Program»).</p>
<p>Исходный код состоит из команд («Commands»), которых может быть сколько угодно и которые мы будем продолжать искать до тех пор, пока текст не кончится. Каждая команда может быть одной из 8 команд языка, пробелом или чем-то другим (то есть ошибкой). Выбор команды осуществляется при помощи выборочного понятия («Command») и распознающих связей (ParsingRelation), каждая из которых «съедает» соответствующий текст при совпадении условия. Распознающие связи ведут к активным понятиям, функции которых помещают новые активные понятия, которые будут выполнять функции языка, в граф результирующей программы.</p>
<p>Несколько интересных моментов:</p>
<ol>
<li>Связь «пробел» в качестве условия использует регулярное выражение. При наличии символов пробела все они будут удалены из текста.</li>
<li>Связь «ошибка» помечена как связь по умолчанию («default») для понятия «Command». Это означает, что процесс перейдет на нее только в том случае, если все другие связи не сработают.</li>
<li>Для поддержки вложенности циклов необходимо «прикреплять» новые команды не к самому верхнему понятию программы, а к понятию «Top», которое зависит от уровня цикла. Для этого используется стек понятий «Top», при создании нового цикла в него помещается новый элемент, а при окончании цикла элемент извлекается и новые команды начинают подключаться на уровень выше.</li>
</ol>
<p>Полный код примера находится <a href="https://github.com/krvss/graph-talk/blob/master/examples/brainfuck.py">здесь</a>.</p>
<p>Кроме интерпретатора, в нем приводится модель процесса преобразования кода на Brainfuck в код на Python, что значительно упрощает чтение текстов на этом эзотерическом языке.</p>

                </div>
                </div></body></html>