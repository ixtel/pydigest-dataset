<html><body><div><p class="lead" itemprop="description">В статье на примере обвязки pyavdesk будет рассмотрен пример сопряжения Python с библиотекой, программный интерфейс которой спроектирован в дружелюбной к обвязкам манере.</p>
                <div class="py_user"><p>Для тех, кто не знаком с модулем </p><a href="https://docs.python.org/3.3/library/ctypes.html" target="_blank">ctypes</a><p>, входящим в стандартную поставку Питона, можно кратко описать его как средство для взаимодействия с функциями сторонних библиотек из вашего python-приложения. Это, конечно, далеко не единственный возможный вариант применения модуля, но нам в данной статье интересен именно он.</p><p>Итак, при помощи этого модуля вы можете создавать обвязки разделяемых (или динамически связываемых в Windows) библиотек, экспортирующих полезные вам функции.</p><p>Нужно отметить, что для создания обвязок можно использовать не только </p><b>ctypes</b><p>  (см. </p><b>SWIG</b><p>, </p><b>Python/C API</b><p>, </p><b>cffi</b><p> и даже </p><b>Cython</b><p>), однако рекомендуемый метод сочетает в себе несколько преимуществ, которые вы наверняка оцените по достоинству, а именно: быстрота и относительная простота разработки, удобство поддержки и переносимость.</p><p>Теперь, после того, как некое представление о </p><b>ctypes</b><p> составлено, переходим к основной части. Код нашего модуля доступен из репозитория </p><a href="https://github.com/DoctorWebLtd/pyavdesk/" target="_blank">pyavdesk</a><p>, код основной библиотеки </p><b>dwavdapi</b><p>, написанной на Си, закрыт, но это не беда — о принципах по которым построен её дружелюбный к автоматизации программный интерфейс я расскажу вам на словах (некоторые дополнительные сведения об интерфейсе всё же можно почерпнуть из </p><a href="http://adobkin.com/blog/2013/02/10/ispolzovaniie-bibliotieki-dwavdapi-dlia-intieghratsiia-s-siervisom-dr-dot-web-av-desk/" target="_blank">статьи</a><p> Антона и кода </p><a href="https://github.com/DoctorWebLtd/php-avdesk/blob/master/dwavd.c" target="_blank">php-расширения</a><p>).</p><p>Какими же качествами должен обладать программный интерфейс библиотеки, чтобы её можно было называть дружелюбной к обвязыванию? Несомненно теми же, что и просто хороший программный интерфейс: логичностью и структурированностью. Однако для того, чтобы обвязки создавались как можно более безболезненно, потребуется довести структурированность до высочайшего уровня, и просто хорошие имена функций и структур превратить в хорошие имена функций и структур, подчиняющиеся определенным правилам, например:</p><pre><code class="c"><br/>    dwavdapi_group_init();<br/>    dwavdapi_group_add();<br/>    dwavdapi_group_destroy();<br/>  <br/>    dwavdapi_station_init();<br/>    dwavdapi_station_add();<br/>    dwavdapi_station_destroy();<br/></code></pre><p>Заметьте, функции именуются однотипно по правилу </p><i>библиотека_субъект_действие</i><p>. Что это даёт, кроме того, что вы можете предугадать, как будут называться функции, скажем, для субъекта </p><i>admin</i><p>? По меньшей мере, в обвязках на языках поддерживающих объектно-ориентированный стиль разбросать функциональность по классам, возможно даже с иерархиями (</p><a href="https://github.com/DoctorWebLtd/pyavdesk/blob/master/pyavdesk/pyavdesk.py#L165" target="_blank">пример базового класса</a><p>, инкапсулирующий логику формирования обращений к функциям библиотеки), а в языках без таковой использовать макросы или подобное.</p><p>Но в порыве структурирования нельзя так быстро остановиться, нужно пойти дальше. Следующим шагом должно стать упорядочивание параметров функций выполняющих одинаковые по смыслу действия. Согласитесь, нет смысла передавать handle объекта в </p><i>add</i><p>-функцию в одном случае </p><a href="http://php.net/manual/en/function.strpos.php" target="_blank">первым</a><p>, в другом — </p><a href="http://ru2.php.net/manual/en/function.in-array.php" target="_blank">вторым</a><p> — ничего кроме недоумения пользователя это не вызовет.</p><p>Если в библиотеке используются связные списки, для навигации по ним лучше предусмотреть функции (возможно даже общие для разных типов списков), которые будет удобно </p><a href="https://github.com/DoctorWebLtd/pyavdesk/blob/master/pyavdesk/pyavdesk.py#L323" target="_blank">использовать в обвязках</a><p>. Например: </p><i>dwavdapi_list_next</i><p>, </p><i>dwavdapi_list_current_data</i><p>.</p><p>Что ещё не помешает хорошей библиотеке? Переход в отладочный режим и получение номера версии. Вроде бы очевидные вещи, но иногда про них можно забыть. </p><p>С отладочным режимом всё просто: журнал — зачастую незаменимая вещь при поиске ошибок в библиотеке, и вкупе с журналом вашей обвязки поможет ответить на многие вопросы. Обвязка, например, может заносить в журнал </p><a href="https://github.com/DoctorWebLtd/pyavdesk/blob/master/pyavdesk/pyavdesk.py#L227" target="_blank">данные о вызове функции библиотеки и её результате</a><p>.</p><p>Ориентируясь по номеру версии библиотеки, обвязка сможет отключать, подключать, варьировать доступную пользователю функциональность, </p><a href="https://github.com/DoctorWebLtd/pyavdesk/blob/master/pyavdesk/pyavdesk.py#L104" target="_blank">или вовсе отказываться работать</a><p>.</p><p>Теперь обратимся к нашему модулю. На что следует обратить внимание при использовании </p><b>ctypes</b><p>. </p><p>Прежде всего, не стоит просто бездумно оборачивать функции только ради того, чтобы они были доступны в Питоне, если вам этого достаточно, то используйте </p><b>SWIG</b><p>. Поразмыслите, прикиньте, почти наверняка вы сможете предложить конечным пользователям вашего модуля нечто большее: усовершенствовать существующие абстракции, создать новые, добавить функциональности. Если вдруг в основной библиотеке использована какая-то жуткая терминология из какой-то сильно умной спецификации, не обязательно ей следовать, гораздо лучше ввести новые, но доступные для пользователя понятия.</p><p>Далее, если вы собираетесь работать непосредственно со структурами библиотеки, вам потребуется в том или ином виде </p><a href="https://github.com/DoctorWebLtd/pyavdesk/blob/master/pyavdesk/structures.py" target="_blank">объявить их у себя</a><p> в модуле — инструментами по импорту данных из заголовочных файлов </p><b>ctypes</b><p> не располагает. Для упрощения работы со структурами можно объявить некий базовый для них класс, который в дальнейшем сможет </p><a href="https://github.com/DoctorWebLtd/pyavdesk/blob/master/pyavdesk/pyavdesk.py#L285" target="_blank">помочь в заполнении их данными</a><p>. При указании типов данных, помните, что поддержки некоторых из них может не оказаться на целевой ОС, определение же других может варьироваться (см. </p><i>time_t</i><p>).</p><p>Создавайте вспомогательные функции/методы обёртки над </p><b>ctypes</b><p> для устранения дублирующегося кода. </p><p>Для функций, возвращающих результат аргументом, используйте в связке тип </p><i>c_void_p</i><p> и функцию </p><i>by_ref()</i><p>:</p><pre><code class="python"><br/>  result = ctypes.c_void_p()<br/>  self._lib_call('fucname', ctypes.byref(result))<br/></code></pre><p>Проектируя систему исключений, стоит выделить отдельные их типы для ошибок из библиотеки, ошибок взаимодействия модуля с библиотекой и, наконец, ошибок самого модуля. Это поможет вам и вашим пользователям лучше понять на каком уровне произошла ошибка.</p><p>Покрывайте код модуля тестами. Нередки случаи, когда тесты модуля помогают обнаружить ошибки/течь в самих библиотеках.</p><p>И ещё одно, чуть ли не главное, но на закуску: </p><i>пишите документацию</i><p>. Это касается и библиотеки, и </p><a href="http://drweb-pyavdesk.readthedocs.org/" target="_blank">модуля</a><p>.</p><b>Добавка:</b><p> В красках о процессе проектирования одного из аспектов обсуждаемой в этой статье библиотеки можно узнать из нашего с Антоном старинного подкаста:</p><i>Делайте обёртки для хороших библиотек.</i><i>Делайте их на Питоне.</i></div>

                

                

                </div></body></html>