<html><body><div><div class="entry-content clearfix">


<p>Ever find yourself making the <em>exact</em> same request to an external API, using the <em>exact</em> same parameters and returning the <em>exact</em> same results? If so, then you should cache this request to limit the number of HTTP requests to help improve performance.</p>

<p>Let’s look at an example using the <a href="http://docs.python-requests.org/en/latest/">requests</a> package.</p>

<a name="Github.API"/>
<h2>Github API</h2>

<p>Grab the code from the <a href="https://github.com/realpython/flask-single-page-app/tree/part5">Github repo</a> (or download the <a href="https://github.com/realpython/flask-single-page-app/releases/tag/part5">zip</a>. Basically, we’re searching the Github API over and over again to find similar developers by location and programming language:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">url</span> <span class="o">=</span> <span class="s">"https://api.github.com/search/users?q=location:{0}+language:{1}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>
</span><span class="line"><span class="n">response_dict</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>Right now, after the initial search, if the user searches again (e.g., doesn’t change the parameters), the application will perform the exact same search, hitting the Github API again and again and again. Since this is an expensive process, it slows down our application for the end user. Plus, by making several calls like this, we can quickly use up our rate limit.</p>

<p>Fortunately, there is an easy fix.</p>

<a name="Requests-cache"/>
<h2>Requests-cache</h2>

<p>To implement caching, we can use a simple package called <a href="http://requests-cache.readthedocs.org/en/latest/index.html">Requests-cache</a>, which is a “transparent persistent cache for <a href="http://docs.python-requests.org/en/latest/">requests</a>”.</p>

<blockquote><p>Keep in mind that you can use this package with any Python Framework, not just Flask, or script as long as you couple it with the requests package.</p></blockquote>

<p>Start by installing the package:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>pip install --upgrade requests-cache
</span></code></pre></td></tr></table></div></figure>


<p>Then add the import to <em>app.py</em> as well as the <code>install_cache()</code> method:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">requests_cache</span><span class="o">.</span><span class="n">install_cache</span><span class="p">(</span><span class="n">cache_name</span><span class="o">=</span><span class="s">'github_cache'</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s">'sqlite'</span><span class="p">,</span> <span class="n">expire_after</span><span class="o">=</span><span class="mi">180</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now whenever you use <code>requests</code>, the response will be cached automatically. Also, you can see that we are defining a few options. Take note of the <code>expire_after</code> option, which is set to 180 seconds. Since the Github API is frequently updated, we want to make sure we deliver the most up-to-date results. So, 180 seconds after the initial caching takes place, the request will re-fire and cache a new set of results, delivering updated results.</p>

<p>For more options, please check out the <a href="http://requests-cache.readthedocs.org/en/latest/api.html#requests_cache.core.install_cache">official documentation</a>.</p>

<p>So your <em>app.py</em> file should now look like this:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">import</span> <span class="nn">requests</span>
</span><span class="line"><span class="kn">import</span> <span class="nn">requests_cache</span>
</span><span class="line">
</span><span class="line"><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">render_template</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">jsonify</span>
</span><span class="line">
</span><span class="line"><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="n">requests_cache</span><span class="o">.</span><span class="n">install_cache</span><span class="p">(</span><span class="s">'github_cache'</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s">'sqlite'</span><span class="p">,</span> <span class="n">expire_after</span><span class="o">=</span><span class="mi">180</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">'GET'</span><span class="p">,</span> <span class="s">'POST'</span><span class="p">])</span>
</span><span class="line"><span class="k">def</span> <span class="nf">home</span><span class="p">():</span>
</span><span class="line">    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">'POST'</span><span class="p">:</span>
</span><span class="line">        <span class="n">first</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'first'</span><span class="p">)</span>
</span><span class="line">        <span class="n">second</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'second'</span><span class="p">)</span>
</span><span class="line">        <span class="n">url</span> <span class="o">=</span> <span class="s">"https://api.github.com/search/users?q=location:{0}+language:{1}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>
</span><span class="line">        <span class="n">response_dict</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
</span><span class="line">        <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">response_dict</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">'index.html'</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
</span><span class="line">    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<a name="Test."/>
<h2>Test!</h2>

<p>Fire up the app and search for a developer. Within the “app” directory a SQLite database, called <em>github_cache.sqlite</em>,  should be created. Now if you keep searching by the same location and programming language, <code>requests</code> will not actually make the call. Instead, it will use the cached response from the SQLite database.</p>

<p>Let’s make sure that the cache actually expires. Update the <code>home()</code> view function like so:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">'GET'</span><span class="p">,</span> <span class="s">'POST'</span><span class="p">])</span>
</span><span class="line"><span class="k">def</span> <span class="nf">home</span><span class="p">():</span>
</span><span class="line">    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">'POST'</span><span class="p">:</span>
</span><span class="line">        <span class="n">first</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'first'</span><span class="p">)</span>
</span><span class="line">        <span class="n">second</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'second'</span><span class="p">)</span>
</span><span class="line">        <span class="n">url</span> <span class="o">=</span> <span class="s">"https://api.github.com/search/users?q=location:{0}+language:{1}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>
</span><span class="line">        <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>
</span><span class="line">        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
</span><span class="line">        <span class="k">print</span> <span class="s">"Time: {0} / Used Cache: {1}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">from_cache</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">())</span>
</span><span class="line">    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">'index.html'</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>So, here we’re just using the <code>from_cache</code> attribute to see if the response came from cache. Let’s test this out. Try a new search. Then open up your terminal:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line">Time: Fri Nov 28 13:34:25 2014 / Used Cache: False
</span></code></pre></td></tr></table></div></figure>


<p>So you can see we made the initial request to the Github API at 13:34:25, and since <code>False</code> was outputted to the screen, caching was not used. Try the search again.</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line">Time: Fri Nov 28 13:35:28 2014 / Used Cache: True
</span></code></pre></td></tr></table></div></figure>


<p>Now you can see that caching is used. Try it a few more times.</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line">Time: Fri Nov 28 13:36:10 2014 / Used Cache: True
</span><span class="line">Time: Fri Nov 28 13:37:59 2014 / Used Cache: False
</span><span class="line">Time: Fri Nov 28 13:39:09 2014 / Used Cache: True
</span></code></pre></td></tr></table></div></figure>


<p>So you can see that the cache expired, and we made a new API call at 13:37:59. After that, caching was used. Simple, right?</p>

<p>What happens when you change the parameters in your request? Try it. Enter a new location and programming language. What happened here? Well, since the parameters changed, Requests-cache treated it as a different request and did not use the cache.</p>

<a name="Balance.-.flush.vs..performance"/>
<h2>Balance – flush vs. performance</h2>

<p>Again, in the above example, we expire the cache (commonly known as flushing) after 180 seconds in order to deliver the most up-to-date data to the end user. Think about that for a minute. Is it really necessary to flush it that regularly? Probably not. In this application, we could get away with changing this to five or ten minutes since it’s not a huge issue if we miss a few new users added to the API every now and then. That said, you really want to pay close attention to flushing when the data is time-sensitive and paramount to your application’s core functionality.</p>

<p>For example, if you were pulling data from an API that is updated several times a minute (like a <a href="http://www.programmableweb.com/api/seismic-data-portal">seismic activity API</a>) and your end user must have the most updated data, then you would want to expire it every 30 or 60 seconds or so.</p>

<p>It’s also important to balance the flushing frequency vs. the amount of time the call takes. If your API call is fairly expensive – perhaps it takes one to five seconds – then you want to increase the amount of time between flushing to improve performance.</p>

<a name="Conclusion"/>
<h2>Conclusion</h2>

<p>Caching is a powerful tool. In this case we improved our application’s performance by limiting the number of external HTTP requests. We cut out the latency from the actual HTTP request itself. In many cases, you are not just making a request. You have to process the request as well, which could involve hitting a database, performing some sort of filtering, etc. Thus, caching can cut the latency from the processing of the request as well.</p>

<p>Cheers!</p>

<hr/>


<p>Want the code? Grab it <a href="https://github.com/realpython/flask-single-page-app/tree/part6">here</a>.</p>
</div>


      </div></body></html>