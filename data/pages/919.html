<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/getpro/habr/post_images/868/4b1/62f/8684b162fdd64cb645ea328236a80bb9.png" align="right"/><p> Приветствую!
</p><p>
В этом посте — небольшие советы по работе с Django, которые могут пригодиться начинающим разработчикам. Как я хотел бы знать это в начале моего пути освоения Django!..</p><p>
Рассматривать эти советы следует с долей критицизма. Буду рад, если вы найдёте неточности / лучшее решение, или предложите свои «фишки» для django, которых нет в документации.
</p><p>
Итак, начнём издалека, а уж потом перейдём к деталям.

</p><a name="habracut"/>

<img src="https://habrastorage.org/getpro/habr/post_images/998/b99/20d/998b9920d41aa31697dc2f7586058014.png" alt="venv" align="right"/>
<h4>Виртуальное окружение</h4><p>
Если вы не используете </p><a href="http://virtualenv.readthedocs.org/">virtualenv</a><p> для вашего django-приложения — то обязательно попробуйте.
</p><p>
Если вы уже используете virtualenv, то ответьте, нужен ли вам --no-site-packages. Этот флаг по умолчанию включён и используется при создании виртуального окружения. При включённом флаге программы «внутри» окружения не увидят программы «снаружи». Если вы поставите вашим пакетным менеджером какой-нибудь пакет глобально, например, python2-django, то «внутри» окружения всё равно придётся делать pip install django.
</p><div class="spoiler"><b class="spoiler_title">Зачем могут понадобиться глобально установленные пакеты?</b><div class="spoiler_text"><p>Я столкнулся с этим, когда настраивал поисковый движок на xapian. Xapian идёт в поставке xapian-core (написан на C++) и xapian-bindings (обвязка для разных ЯП, в том числе python). Логично их обновлять одновременно — если изменился движок, то и обвязки надо обновить. Поэтому ставить xapian-core глобально пакетным менеджером, а обвязки через pip не устравивает (к тому же, их нет в pip). Выхода 2:</p>
<ol>
<li>Создать помойку внутри virtualenv: ./configure --prefix=/path/to/virtualenv &amp;&amp; <a href="http://habrahabr.ru/post/130868/">make &amp;&amp; make install</a></li>
<li>Сделать глобальные пакеты видимыми извне и обновлять их пакетным менеджером дистрибутива, что я и выбрал</li>
</ol><p>
Вообще, когда модуль написан на чистом питоне, проблем не возникает — устанавливаем через pip в virtualenv. Если модуль — это смесь, скажем, c++ и питона — начинается магия.
</p></div></div> <p>
Видимость / невидимость глобальных программ из virtualenv устанавливается отсутствуем / наличием файла [virtualenv]/lib/python*.*/no-global-site-packages.txt. Вот так просто.
</p><p>
Кстати, рекомендую всем статью про «изолированность» virtualenv: </p><a href="http://pythonrants.wordpress.com/2013/12/06/why-i-hate-virtualenv-and-pip/">Why I hate virtualenv and pip</a><p> (сайт тормозит, смог открыть только через </p><a href="https://web.archive.org/web/20140107215813/http://pythonrants.wordpress.com/2013/12/06/why-i-hate-virtualenv-and-pip/">web.archive.org</a><p>). В ней рассматривается, насколько virtualenv действительно изолирован от «внешней» среды — если кратко, то это лишь частичная изоляция.

</p><img src="https://habrastorage.org/getpro/habr/post_images/f8e/d89/574/f8ed89574482145ec2cea2b575753af2.png" align="right"/>
<h4>ipython</h4><p>
Pip install </p><a href="http://ipython.org/">ipython</a><p> заменит стандартный питоновский шелл на продвинутый, с раскрашиванием, автодополнением, интроспекцией, удобным многострочным вводом, копипейстом и т.д. Django автоматически подцепляет ipython, если он установлен.</p><p>
Кстати, все перечисленные достоинства можно использовать не только в ./manage.py shell, но и в дебаге, вызывая отладку с помощью import </p><b>i</b><p>pdb; </p><b>i</b><p>pdb.set_trace().

</p><h4>Структура проекта</h4><p>
Django по умолчанию при создании проекта или приложения создаёт необходимые каталоги. Но и самим нужно думать.

</p><h5>Как проект назовёшь, так и будешь импортировать</h5><p>
Называйте ваш проект project (django-admin.py startproject project) — ну или другим, но одинаковым именем для всех проектов. Раньше я называл проекты соответственно домену, но при повторном использовании приложений в других проектах приходилось менять пути импорта — то from supersite import utils, то from newsite import utils. Это путает и отвлекает. Если расширить этот совет — зафиксируйте (унифицируйте) для себя структуру каталогов всех ваших проектов и строго её придерживайтесь.
</p><p>
Живой пример:
</p><pre><code class="python">--site.ru
  |--static
  |--media
  |--project (папка с проектом)
     |--manage.py
     |--project (папка с основным приложением)
     |  |--settings.py
     |  |--urls.py
     |  |-- ...
     |--app1
     |--app2
     |--...
</code></pre>

<h5>Куда сохранять html-шаблоны</h5><p>
Никогда, </p><b>никогда</b><p> не кидайте шаблоны (.html) в папку templates вашего приложения. Всегда создавайте дополнительный каталог с названием, совпадающим с именем приложения.</p><p>
Вот это плохо, т.к. создаёт коллизию шаблонов, например, при {% include 'main.html' %}:
</p><pre><code>/gallery/templates/main.html
/reviews/templates/main.html
</code></pre><p>
Вот это — хорошо, можно использовать {% include 'reviews/main.html' %}:
</p><pre><code>/gallery/templates/gallery/main.html
/reviews/templates/reviews/main.html
</code></pre>

<h5>{% include %}</h5><p>
К слову, если вы используете {% include 'some_template.html' %}, то велика вероятность, что что-то не так. Почему?</p><p>
Пример:
</p><pre><code class="python">def view(request):
    return render(
        request,
        'master.html',
        {'var': 'Some text'}
    }
</code></pre>
<pre><code class="html">&lt;!-- master.html --&gt;
Value of variable var: {{ var }}.
{% include 'slave.html' %}

&lt;!-- slave.html --&gt;
Again, value of variable var: {{ var }}.
</code></pre>
<p>
1) KISS едет лесом. С одной стороны, код страницы разбит на несколько — master.html и подключаемый slave.html, и это удобно для разделения больших html-страниц на части. Но в данном случае переменная var передаётся в шаблон slave.html неявно — var передатся в master.html, а slave.html просто «цепляет» контекст master'а. Таким образом, мы видим, что шаблон внутри {% include %} зависит от контекста основного шаблона. Мы вынуждены следить за контекстом родительского шаблона, иначе в дочерний может попасть что-нибудь не то.</p><p>
2) По моим наблюдениям, {% include %} дорогой в плане рендеринга. Лучше его избегать.
</p><p>
Что делать? Если очень хочется одни шаблоны включать в другие — используйте inclusion tags (о них читать ниже). Но проще — просто пишите всё в одном файле:
</p><pre><code class="html">&lt;!-- master.html --&gt;
Value of variable var: {{ var }}.
Again, value of variable var: {{ var }}.
</code></pre>

<h5>settings.py</h5><p>
Вы же не имеете два разных settings.py на тестовом и деплой серверах, да?</p><p>
Создайте дополнительные local_settings.py и deployment_settings.py, куда скиньте всё, что относится только к соответствующему серверу.
</p><div class="spoiler"><b class="spoiler_title">Вот, например, что логично задавать в local_settings.py</b><div class="spoiler_text"><pre><code class="python">DEBUG = True

DOMAIN = '127.0.0.1:8000'
ALLOWED_HOSTS = ['127.0.0.1', DOMAIN]

SERVER_EMAIL = 'mail@test.ru'
EMAIL_HOST = 'localhost'
EMAIL_PORT = 1025
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_USE_TLS = False
EMAIL_SUBJECT_PREFIX = '[' + DOMAIN + '] '

DEFAULT_FROM_EMAIL = 'mail@test.ru'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': 'test',
        'USER': 'test',
        'PASSWORD': 'test',
        'HOST': 'localhost',
        'PORT': '',
        'ATOMIC_REQUESTS': True,
    }
}

CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
    }
}
</code></pre> 
</div></div>
<p>
В settings.py пишем в начале:
</p><pre><code class="python"># Load local settings if available
try:
    from local_settings import *
except ImportError:
    from deployment_settings import *
</code></pre><p>
Соответственно, на деплое удаляем local_settings.py. Чтобы он не мешался, его можно добавить в .gitignore.

</p><h5>Корень проекта</h5><p>
Задайте корень проекта в settings.py — это облегчит жизнь потом:
</p><pre><code class="python">from os import path
BASE = path.dirname(path.dirname(path.dirname(path.abspath(__file__))))
MEDIA_ROOT = BASE + '/media/'
STATIC_ROOT = BASE + '/static/'
</code></pre>

<h4>Контекстные процессоры (context_processors.py), {% include %} и inclusion tags</h4><p>
Используйте контекстные процессоры только если вам нужно добавить переменные в контекст </p><b>каждой страницы сайта</b><p> — ведь контекстные процессоры будут вызываться для любой страницы, даже если вы не воспользуйтесь их результатами. Лично я использую их для передачи номера телефона в контекст шаблона — этот номер реально на каждой странице выводится, и не единожды. Ещё пример — меню сайта. Я прописал заголовки и ссылки в контекстном процессоре, и если мне нужно будет добавить новый раздел в меню — я просто добавлю его в контекстный процессор, и он автоматически добавится везде на сайте.
</p><p>
Есть одна ошибка — использование контекстных процессоров для виджетов. Например, у вас на сайте есть колонка новостей, которая выводится всегда, т.е. на каждой страничке. Казалось бы, создать news/context_processors.py, и в контекст добавлять переменную news с новостями, а в шаблоне {% include 'news/news_widget.html' %}, или даже {% load news_widget %} {% news_widget news %}…
</p><p>
Это работает, но это замусоривает контекст и, кроме того, кто знает, всегда ли у вас будет эта колонка. Выход есть — используйте </p><a href="https://docs.djangoproject.com/en/1.6/howto/custom-template-tags/#howto-custom-template-tags-inclusion-tags">inclusion tag</a><p>. Вы просто пишете в шаблоне {% news %}, а уже этот templatetag ищет новости и вставляет колонку новостей. И работает он только тогда, когда вы его реально запускаете — т.е. пишете {% news %} в шаблоне.

</p><img src="https://habrastorage.org/getpro/habr/post_images/871/644/51e/87164451efd98e7a5c0e7d183f28ef55.jpg" align="right"/>
<h4>Батарейки</h4>
<h5>django-debug-toolbar-template-timings</h5><p>
Все его знают и, наверно, используют. Но есть </p><a href="https://pypi.python.org/pypi/django-debug-toolbar-template-timings/0.6.1">django-debug-toolbar-template-timings</a><p> — плагин к debug toolbar, который замеряет время рендеринга шаблонов. А учитывая, что шаблоны django довольно «дорогие» (рендерятся долго), то для ускорения сайта этот плагин — то что доктор прописал.

</p><h5>adv_cache_tag</h5>
<a href="https://github.com/twidi/django-adv-cache-tag">django-adv-cache-tag</a><p> позволяет очень гибко управлять кешированием в шаблонах — версионность, сжатие, частичное кэширование. Просто оцените:
</p><pre><code class="html">{% load adv_cache %}
{% cache 0 object_cache_name object.pk obj.date_last_updated %}  &lt;!-- Закэшировать без таймаута, обновить кэш при обновлении obj.date_last_updated --&gt;
  {{ obj }}
  {% nocache %}
     {{ now }}  &lt;!-- А это никогда не кэшируем --&gt;
   {% endnocache %}
   {{ obj.date_last_updated }}
{% endcache %}
</code></pre>

<h5>django-mail-templated</h5><p>
Шаблоны email писем — это то, чего не хватает django. </p><a href="https://github.com/artemrizhov/django-mail-templated">django-mail-templated</a>

<h5>django-ipware</h5>
<a href="https://github.com/un33k/django-ipware">django-ipware</a><p> определит ip пользователя за вас, и сделает это лучше.
</p><div class="spoiler"><b class="spoiler_title">Вы же знаете, откуда брать ip пользователя?</b><div class="spoiler_text"> <pre><code class="python">'HTTP_X_FORWARDED_FOR', # client, proxy1, proxy2
'HTTP_CLIENT_IP',
'HTTP_X_REAL_IP',
'HTTP_X_FORWARDED',
'HTTP_X_CLUSTER_CLIENT_IP',
'HTTP_FORWARDED_FOR',
'HTTP_FORWARDED',
'HTTP_VIA',
'REMOTE_ADDR',
</code></pre>
</div></div>

<h5>Beautiful Soup</h5><p>
Не пишите свой парсер html. Не парсите html сами. </p><a href="http://www.crummy.com/software/BeautifulSoup/">Всё уже есть.</a>

<h4>Templatetags, которые могут пригодиться</h4>
<h5>add_class</h5><p>
Если вы создаёте форму и хотите для каждого input-а задать стиль, класс или placeholder, то django заставит вас нарушить принципы и прописать все стили прямо в forms.py:
</p><pre><code class="python">class SomeForm(ModelForm):
    class Meta:
        model = SomeModel
        fields = ('field1', 'field2')
        widgets = {
            'field1': Textarea(attrs={'rows': '2', 'class': 'field1_class'}),
        }
</code></pre><p>
Меня каждый раз коробит при виде html текста не в .html файлах. Это нарушает MVT архитектуру. Поэтому я создал для себя фильтр:
</p><pre><code class="html">{% load add_class %}
{{ form.field1|add_class:'field1_class' }}
</code></pre><p>
Данный фильтр добавляет класс к тегам, но можно переписать и добавлять любое свойство.
</p><div class="spoiler"><b class="spoiler_title">Код add_class.py</b><div class="spoiler_text"><pre><code class="python">from django import template
from django.utils.safestring import mark_safe
from bs4 import BeautifulSoup

register = template.Library()
@register.filter
def add_class(html, css_class):
    soup = BeautifulSoup(unicode(html), 'html.parser')

    for tag in soup.children:
        if tag.name != 'script':
            if 'class' in tag:
                tag['class'].append(css_class)
            else:
                tag['class'] = [css_class]

    return mark_safe(soup.renderContents())
</code></pre>
</div></div>

<h5>is_current_page</h5><p>
Иногда нужно что-то выводить в шаблоне, если открыта определённая страница. Например, подсветить кнопку «магазин» в меню, если пользователь сейчас в разделе магазина. Предлагаю следующий вариант:
</p><pre><code class="python">from django import template
from django.core.urlresolvers import resolve
from project.utils import parse_args

register = template.Library()
@register.filter
def is_current_page(request, param):
    return resolve(request.path).view_name == param
</code></pre><p>
Это фильтр, а не тэг, и причина тут одна: можно строить совершенно дичайшие конструкции с {% if %}. Например, если текущая страница — карточка товара, и при этом пользователь авторизован:
</p><pre><code class="html">{% if request|is_current_page:'shop/product' and user.is_authenticated %}
</code></pre><p>
Есть и альтернативная, более точная, реализация, в которой используются аргументы (args или kwargs) для определения точной страницы (т.е. не просто «страница какого-либо товара», а «страница товара с id=36»):
</p><pre><code class="html">{% if request|is_current_page:'shop/product,id=36' %}
</code></pre>
<pre><code class="python">@register.filter
def is_current_page(request, param):
    params = param.split(',')
    name = params[0]
    args, kwargs = parse_args(params[1:])
    # Do not mix args and kwargs in reverse() - it is forbidden!
    if args:
        return request.path == reverse(name, args=args)
    elif kwargs:
        return request.path == reverse(name, kwargs=kwargs)
    else:
        return request.path == reverse(name)
</code></pre>

<img src="https://habrastorage.org/getpro/habr/post_images/bc6/a59/13d/bc6a5913dd401f48a545de54669c812e.jpg" align="right"/>
<h4>Модели</h4>
<h5>Пустые</h5><p>
Модели могут быть пустыми. Вот так:
</p><pre><code class="python">class Phrase(models.Model):
    pass

class PhraseRu(models.Model):
    phrase = models.ForeignKey(Phrase, verbose_name='фраза', related_name='ru')

class PhraseEn(models.Model):
    phrase = models.ForeignKey(Phrase, verbose_name='фраза', related_name='en')
</code></pre><p>
В данном случае Phrase является связующим звеном между PhraseEn и PhraseRu, хотя сама в себе ничего не содержит. Полезно, когда две модели равнозначны, и их необходимо связать в единое целое.

</p><h5>Generic relation mixin</h5><p>
Объекты GenericRelation всегда возвращаются QuerySet'ом, даже есть мы точно знаем, что объект один:
</p><pre><code class="python">class Token(models.Model):
    content_type = models.ForeignKey(ContentType)
    object_id = models.PositiveIntegerField()
    content_object = generic.GenericForeignKey()

class Registration(models.Model):
    tokens = generic.GenericRelation(Token)
</code></pre><p>
Если нужно получить доступ к токену, мы пишем registration.tokens.first(). Но мы-то знаем, что токен один, и хотим писать просто registration.token и получить сразу заветный токен. Это возможно при помощи mixin:
</p><pre><code class="python">class Token(models.Model):
    content_type = models.ForeignKey(ContentType)
    object_id = models.PositiveIntegerField()
    content_object = generic.GenericForeignKey()

class TokenMixin(object):
    @property
    def token(self):
        content_type = ContentType.objects.get_for_model(self.__class__)
        try:
            return Token.objects.get(content_type__pk=content_type.pk, object_id=self.id)
        except Token.DoesNotExist:
            return None

class Registration(models.Model, TokenMixin):
    tokens = generic.GenericRelation(Token)
</code></pre>
<p>
Теперь registration.token работает!

</p><h5>get_absolute_url</h5>
<p>
Старайтесь не писать {% url 'shop/product' id=product.id %}.</p><p>
Лучше для каждой модели задайте метод get_absolute_url(), и используйте {{ object.get_absolute_url }}. Заодно и ссылка «смотреть на сайте» появится в админке.

</p><h5>pre_save</h5><p>
В pre_save можно узнать, изменится ли модель после сохранения или нет. Цена — запрос к БД для получения старой записи из базы.
</p><pre><code class="python">@receiver(pre_save, sender=SomeModel)
def process_signal(sender, instance, **kwargs):
    old_model = get_object_or_None(SomeModel, pk=instance.pk)
    if not old_model:
        # Created
        old_value = None
        ...
    else:
        old_value = old_model.field
    new_value = instance.field

    if new_value != old_value:
        # field changed!
</code></pre>

<h4>Формы</h4><p>
Этот паттерн уже был на хабре, но он слишком хорош, чтобы не упомянуть его.
</p><pre><code class="python">form = SomeForm(request.POST or None)
if form.is_valid():
    # ... actions ...
    return HttpResponseRedirect(...)
return render(
    request,
    {'form': form}
)
</code></pre>
<p>
На этом всё. Спасибо за внимание.

</p><b>UPD.</b><p> Как обычно на Хабре, в комментариях хабражители высказали свои мнения и предложили кучу замечательных идей, дополнений и замечаний к статье. Я не стал их вносить в статью, но вместо этого настоятельно рекомендую ознакомиться с комментариями к статье.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>