<html><body><div><div class="content html_format"><p>
      Это шестая статья в серии, где я буду документировать мой опыт написания веб-приложения на Python, используя микрофреймворк Flask.</p>
<p>
Цель данного руководства — разработать довольно функциональное приложение-микроблог, которое я за полным отсутствием оригинальности решил назвать microblog.

</p>

<h5>Краткое повторение</h5><p>
В прошлой статье мы создали систему авторизации, сейчас пользователи могут авторизоваться на сайте используя OpenID.
</p><p>
Сегодня мы будем работать с профилем пользователя. Сперва, создадим страницу профиля, на которой будет показываться информация о пользователе, и его постах, так же мы научимся показывать аватарку. А потом мы создадим форму редактирования личных данных.
</p><a name="habracut"/>
<h5>Страница профиля.</h5><p>
На самом деле, создание страницы профиля не требует никаких новых концепций. Мы просто создадим новое представление и </p><i>HTML</i><p>-шаблон к ней.
</p><p>
Функция в представлении. (файл </p><i>app.views.py</i><p>):

</p><pre><code class="python">@app.route('/user/&lt;nickname&gt;')
@login_required
def user(nickname):
    user = User.query.filter_by(nickname = nickname).first()
    if user == None:
        flash('User ' + nickname + ' not found.')
        return redirect(url_for('index'))
    posts = [
        { 'author': user, 'body': 'Test post #1' },
        { 'author': user, 'body': 'Test post #2' }
    ]
    return render_template('user.html',
        user = user,
        posts = posts)
</code></pre><p>
Декоратор </p><i>app.route</i><p> будет немного отличаться от тех что мы использовали.</p><p>
Метод имеет параметр с именем </p><i>nickname</i><p>. Так же нужно добавить параметр во вью-функцию с тем же именем. Когда клиент запрашивает </p><i>URL /user/miguel </i><p>, функция в представлении должна вызываться с параметром </p><i>nickname = 'miguel'</i><p>.
</p><p>
Реализация функции должна пройти без сюрпризов. Сперва мы попробуем загрузить пользователя из базы данных, используя </p><i>nickname</i><p> который мы приняли в качестве аргумента. Если это не сработает, то сделаем перенаправление на главную страницу с сообщением об ошибке, так же как мы делали в предыдущей главе.
</p><p>
Как только у нас появится пользователь, мы вызываем </p><i>render_template</i><p>, вместе с тестовым сообщением. Обращаю ваше внимание, что на странице пользователя нужно показываться только сообщения этого пользователя, поэтому нужно правильно заполнить поле </p><i>author</i><p>.
</p><p>
Наш первоначальный шаблон выглядит достаточно просто (файл </p><i>app/templates/user.html</i><p>):

</p><pre><code class="django">&lt;!-- extend base layout --&gt;
{% extends "base.html" %}

{% block content %}
&lt;h1&gt;User: {{user.nickname}}!&lt;/h1&gt;
&lt;hr&gt;
{% for post in posts %}
&lt;p&gt;
  {{post.author.nickname}} says: &lt;b&gt;{{post.body}}&lt;/b&gt;
&lt;/p&gt;
{% endfor %}
{% endblock %}
</code></pre><p>
Мы закончили со страницей профиля, но на неё нигде нет ссылки. Что бы пользователю было легко добраться до своего профиля, мы добавим ссылку на него в верхней панели навигации (файл </p><i>app/templates/base.html</i><p> ):

</p><pre><code class="html">    &lt;div&gt;Microblog:
        &lt;a href="{{ url_for('index') }}"&gt;Home&lt;/a&gt;
        {% if g.user.is_authenticated() %}
        | &lt;a href="{{ url_for('user', nickname = g.user.nickname) }}"&gt;Your Profile&lt;/a&gt;
        | &lt;a href="{{ url_for('logout') }}"&gt;Logout&lt;/a&gt;
        {% endif %}
    &lt;/div&gt;
</code></pre><p>
Обращаю ваше внимание, что в функцию </p><i>url_for </i><p>мы добавили обязательный параметр </p><i>nickname</i><p>.
</p><p>
Посмотрим что у нас получилось. Нажав на </p><i>You Profile</i><p> мы должны перейти на страницу пользователя. Так как у нас нет ни одной ссылки на страницы других пользователей, вам придётся ввести URL вручную, что бы посмотреть на профиль другого пользователя. Например, наберите </p><code><a href="http://localhost"/>localhost:5000/user/miguel</code><p> что бы посмотреть профиль пользователя </p><i>Miguel</i><p>.

</p><h5>Аватарки.</h5><p>
Сейчас наши страницы с профилем, достаточно унылые. Давайте добавим аватарку, что бы сделать их более интересными.
</p><p>
Теперь напишем метод, который будет возвращать аватарку, и положим его в класс (</p><i>app/models.py</i><p>)

</p><pre><code class="python">from hashlib import md5
# ...
class User(db.Model):
    # ...
    def avatar(self, size):
        return 'http://www.gravatar.com/avatar/' + md5(self.email).hexdigest() + '?d=mm&amp;s=' + str(size)
</code></pre><p>
Метод </p><i>avatar </i><p>вернёт путь до аватарки, сжатой до указанных размеров.

</p><i>Gravatar </i><p>поможет сделать это очень легко. Вам просто нужно создать MD5-хэш от емейла, а затем добавить его в специально сформированный </p><i>URL</i><p>, который был выше. После хэша добавим в </p><i>URL</i><p> другие параметры. </p><i>d=mm </i><p> указывает, что нужно вернуть изображение по умолчанию, когда пользователь не имеет </p><i>Gravatar </i><p>аккаунт. Параметр </p><i>mm </i><p> возвращает изображение с серым силуэтом человека. Параметр </p><i>s = N</i><p> указывает до каких размеров следует масштабировать аватарку.
</p><p>
Документация для </p><a href="https://ru.gravatar.com/site/implement/images">Gravatar</a><p>.
</p><p>
Теперь класс User знает как вернуть изображение, мы можем добавить его на страницу профиля (файл app/templates/user.html):

</p><pre><code class="python">&lt;!-- extend base layout --&gt;
{% extends "base.html" %}

{% block content %}
&lt;table&gt;
    &lt;tr valign="top"&gt;
        &lt;td&gt;&lt;img src="{{user.avatar(128)}}"&gt;&lt;/td&gt;
        &lt;td&gt;&lt;h1&gt;User: {{user.nickname}}&lt;/h1&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;hr&gt;
{% for post in posts %}
&lt;p&gt;
  {{post.author.nickname}} says: &lt;b&gt;{{post.body}}&lt;/b&gt;
&lt;/p&gt;
{% endfor %}
{% endblock %}
</code></pre><p>
Примечательно, что класс </p><i>User </i><p>отвечает за возвращение аватарки, и если в один прекрасный момент мы решили что </p><i>Gravatar </i><p>не то что мы хотим, мы просто перепишем метод </p><i>avatar</i><p>, так что он будет возвращать другой путь (даже те которые укажем на нашем собственном сервере), все наши шаблоны будут представлены с новыми аватарками автоматически.</p><p>
Мы добавили аватарку в верхнюю часть страницы профиля, но в нижней части страницы у нас есть сообщения, рядом с которыми хорошо бы показывать аватарку маленького размера. Для страницы профиля мы, конечно, будем показывать ту же самую аватарку для всех сообщений, но потом, когда мы переведём эту функциональность на главную страницу мы будем иметь каждое сообщение украшенное аватаркой автора сообщения, и это будет действительно хорошо.</p><p>
Для показа аватарки для поста мы внесём небольшие изменения в шаблон (файл </p><i>app/templates/user.html</i><p>):

</p><pre><code class="django">&lt;!-- extend base layout --&gt;
{% extends "base.html" %}

{% block content %}
&lt;table&gt;
    &lt;tr valign="top"&gt;
        &lt;td&gt;&lt;img src="{{user.avatar(128)}}"&gt;&lt;/td&gt;
        &lt;td&gt;&lt;h1&gt;User: {{user.nickname}}&lt;/h1&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;hr&gt;
{% for post in posts %}
&lt;table&gt;
    &lt;tr valign="top"&gt;
        &lt;td&gt;&lt;img src="{{post.author.avatar(50)}}"&gt;&lt;/td&gt;&lt;td&gt;&lt;i&gt;{{post.author.nickname}} says:&lt;/i&gt;&lt;br&gt;{{post.body}}&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
{% endfor %}
{% endblock %}
</code></pre><p>
Теперь наш профиль будет выглядеть так:
</p><img src="https://habrastorage.org/getpro/habr/post_images/db7/167/972/db71679724b935c209406cf32e73c7d7.png" alt="image"/>

<h5>Повторное использование подшаблонов ( sub-template)</h5><p>
Мы разработали страницу профиля, что бы показывать сообщения написанные пользователем. Наша главная страница, также показывает сообщения, но любого пользователя. Теперь у нас есть два вида шаблонов которые будут показывать сообщения написанные пользователями. Мы могли бы просто скопировать/вставить часть шаблона, которая отвечает за отображение сообщения, но это не самая лучшая идея, потому что когда нужено будет внеси изменения в дизайн сообщения, мы должны помнить о всех шаблонах которые умеют отображать сообщения.
</p><p>
Вместо этого мы создадим подшаблон который будет генерировать сообщениея, потом просто подключим подшаблон так где он нужен (файл /app/templates/post.html):

</p><pre><code class="html">&lt;table&gt;
    &lt;tr valign="top"&gt;
        &lt;td&gt;&lt;img src="{{post.author.avatar(50)}}"&gt;&lt;/td&gt;&lt;td&gt;&lt;i&gt;{{post.author.nickname}} says:&lt;/i&gt;&lt;br&gt;{{post.body}}&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre><p>
Дл начала, мы создадить, подшаблон сообщения, который ничем не отличается от обычного шаблона. Берём </p><i>HTML</i><p>-код для показа сообщения из нашего шаблона.
</p><p>
Потом вызовем подшаблон из нашего шаблона используя </p><i>Jinja2</i><p> командой </p><i>include</i><p> (файл </p><i>app/templates/user.html</i><p>):

</p><pre><code class="django">&lt;!-- extend base layout --&gt;
{% extends "base.html" %}

{% block content %}
&lt;table&gt;
    &lt;tr valign="top"&gt;
        &lt;td&gt;&lt;img src="{{user.avatar(128)}}"&gt;&lt;/td&gt;
        &lt;td&gt;&lt;h1&gt;User: {{user.nickname}}&lt;/h1&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;hr&gt;
{% for post in posts %}
    {% include 'post.html' %}
{% endfor %}
{% endblock %}
</code></pre><p>
Как только мы сделаем работающую главную страницу, мы будем ссылать на тот же подшаблон, пока мы не готовы к этому, поэтому оставим для следующей главы.

</p><h5>Более интересные профили</h5><p>
Теперь когда у нас есть хорошая страница профиля, нам не хватает информации для показа. Пользователи любят добавлять на свои страницы немного информации о себе, поэтому мы дадим им эту возножость, и так же будем отображать на странице профиля. Ещё будем отслеживать когда пользователь заходил последний раз най сайт и тоже будем показывать на странице профиля.
</p><p>
Что бы сделать задуманное, мы должны изменить базу данных. Нужно добавить два новых поля для нашего класса </p><i>User</i><p> (файл app/models.py):

</p><pre><code class="python">class User(db.Model):
    id = db.Column(db.Integer, primary_key = True)
    nickname = db.Column(db.String(64), unique = True)
    email = db.Column(db.String(120), index = True, unique = True)
    role = db.Column(db.SmallInteger, default = ROLE_USER)
    posts = db.relationship('Post', backref = 'author', lazy = 'dynamic')
    about_me = db.Column(db.String(140))
    last_seen = db.Column(db.DateTime)
</code></pre><p>
Каждый раз когда мы изменяем базу данных, мы создаём новую миграцию. Помните как в части про базы данных мы прошли через муки для настройки миграционной системы БД. Теперь мы пожинаем плоды этих усилий. Для добавления новых полей в нашу БД, просто выполняем сценарий:

</p><blockquote>./db_migrate.py<br/>
</blockquote><p>
И получаем ответ:
</p><blockquote>New migration saved as db_repository/versions/003_migration.py<br/>
Current database version: 3</blockquote><p>
И наши два новых поля добавлены в БД. Не забыли, что если вы на Windows то путь запуска скрипта разные.</p><p>
Если мы не имеем миграционной системы, вам необходимо редактировать БД в ручную, или хуже того, удалить её и создать заново.
</p><p>
Теперь давайте изменим шаблон профиля, с учетом этих полей (файл </p><i>app/templates/user.html</i><p>):

</p><pre><code class="django">&lt;!-- extend base layout --&gt;
{% extends "base.html" %}

{% block content %}
&lt;table&gt;
    &lt;tr valign="top"&gt;
        &lt;td&gt;&lt;img src="{{user.avatar(128)}}"&gt;&lt;/td&gt;
        &lt;td&gt;
            &lt;h1&gt;User: {{user.nickname}}&lt;/h1&gt;
            {% if user.about_me %}&lt;p&gt;{{user.about_me}}&lt;/p&gt;{% endif %}
            {% if user.last_seen %}&lt;p&gt;&lt;i&gt;Last seen on: {{user.last_seen}}&lt;/i&gt;&lt;/p&gt;{% endif %}
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;hr&gt;
{% for post in posts %}
    {% include 'post.html' %}
{% endfor %}
{% endblock %}
</code></pre><p>
Как вы могли заметить, мы используем </p><i>Jijna2</i><p> что бы показывать эти поля, потому что мы будем их показывать, только когда в них есть данные.
</p><p>
Сейчас два новых поля пустые для всех пользователей, так что ничего не отобразится.
</p><p>
Поле </p><i>Last_seen</i><p> легко поддерживать. Помните, как в </p><a href="http://habrahabr.ru/post/222983/">предыдущей главе</a><p> мы создали обработчик </p><i>before_request</i><p>. Хорошее место для добавленя времени входа пользователя (файл </p><i>app/views.py</i><p>):

</p><pre><code class="python">from datetime import datetime
# ...
@app.before_request
def before_request():
    g.user = current_user
    if g.user.is_authenticated():
        g.user.last_seen = datetime.utcnow()
        db.session.add(g.user)
        db.session.commit()
</code></pre><p>
Если вы войдёте на ваше страницу профиля, то увидите когда последний раз заходили на сайт и каждый раз, обновляя страницу, время будет обновлятся, потому что каждый раз, когда браузер делает запрос breforerequest, обработчик будет обновлять время в БД.
</p><p>
Обратите внимание, что мы пишем время в стандартном часовом поясе </p><i>UTC</i><p>. Мы обсуждали это в предыдущей главе, что мы пишем все временные метки в </p><i>UTC</i><p>, что бы они соответствовали друг другу. Есть побочный эффект, время на странице профиля то же отображается в </p><i>UTC</i><p>. Мы исправим это в одной из следующих глав, которая будет посвещенна временным меткам.
</p><p>
Теперь нужно выделить место, для показа поля «обо мне», и правильней было бы разместить его в странице редактирования профиля.

</p><h5>Редактирование профиля.</h5><p>
Добавить форму редактирования профиля на удивление легко. Начнём с создания веб-формы (файл </p><i>app/forms.py</i><p>)

</p><pre><code class="python">from flask.ext.wtf import Form
from wtforms import TextField, BooleanField, TextAreaField
from wtforms.validators import Required, Length

class EditForm(Form):
    nickname = TextField('nickname', validators = [Required()])
    about_me = TextAreaField('about_me', validators = [Length(min = 0, max = 140)])
</code></pre>
<p>
И шаблон (файл </p><i>app/templates/edit.html</i><p>):

</p><pre><code class="python">&lt;!-- extend base layout --&gt;
{% extends "base.html" %}

{% block content %}
&lt;h1&gt;Edit Your Profile&lt;/h1&gt;
&lt;form action="" method="post" name="edit"&gt;
    {{form.hidden_tag()}}
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;Your nickname:&lt;/td&gt;
            &lt;td&gt;{{form.nickname(size = 24)}}&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;About yourself:&lt;/td&gt;
            &lt;td&gt;{{form.about_me(cols = 32, rows = 4)}}&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;input type="submit" value="Save Changes"&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;
{% endblock %}
</code></pre><p>
И наконец напишем функцию обработчик (файл </p><i>app/views.py</i><p>):

</p><pre><code class="python">from forms import LoginForm, EditForm

@app.route('/edit', methods = ['GET', 'POST'])
@login_required
def edit():
    form = EditForm()
    if form.validate_on_submit():
        g.user.nickname = form.nickname.data
        g.user.about_me = form.about_me.data
        db.session.add(g.user)
        db.session.commit()
        flash('Your changes have been saved.')
        return redirect(url_for('edit'))
    else:
        form.nickname.data = g.user.nickname
        form.about_me.data = g.user.about_me
    return render_template('edit.html',
        form = form)
</code></pre><p>
Так же добавим ссылку на него со страницы профиля пользователя, что бы можно было легко добраться до редактирования (файл </p><i>app/templates/user.html</i><p>):

</p><pre><code class="python">&lt;!-- extend base layout --&gt;
{% extends "base.html" %}

{% block content %}
&lt;table&gt;
    &lt;tr valign="top"&gt;
        &lt;td&gt;&lt;img src="{{user.avatar(128)}}"&gt;&lt;/td&gt;
        &lt;td&gt;
            &lt;h1&gt;User: {{user.nickname}}&lt;/h1&gt;
            {% if user.about_me %}&lt;p&gt;{{user.about_me}}&lt;/p&gt;{% endif %}
            {% if user.last_seen %}&lt;p&gt;&lt;i&gt;Last seen on: {{user.last_seen}}&lt;/i&gt;&lt;/p&gt;{% endif %}
            {% if user.id == g.user.id %}&lt;p&gt;&lt;a href="{{url_for('edit')}}"&gt;Edit&lt;/a&gt;&lt;/p&gt;{% endif %}
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;hr&gt;
{% for post in posts %}
    {% include 'post.html' %}
{% endfor %}
{% endblock %}
</code></pre><p>
Мы используем условные операторы, что убедится что ссылки на редактировния профиля не появлялись когда вы читаете чужой профиль.
</p><p>
Вот так выглядит новый скриншот страницы пользователя, с небольшим описанием о себе.
</p><img src="https://habrastorage.org/getpro/habr/post_images/532/4c9/1b6/5324c91b661b79609e9cfd761dc99e4f.png" alt="image"/>

<h5>Заключение… и домашнее задание!</h5><p>
Мы проделали большую работу с профилем пользователя, не так ли?</p><p>
Но у нас есть одна неприятная ошибка и мы должны её исправить.
</p><p>
Сможете её найти?
</p><p>
Подсказка. Мы допустили ошибку в предыдущей главе, когда делали авторизацию. И сегодня мы написали новый кусок кода, который имеет ту же ошибку.
</p><p>
Попробуйте её найти, и если найдёте, то не стесняйтесь и пишите в комментариях. Я обьясню ошибку и как её исправть в следующей главе.
</p><p>
Как всегда вот ссылка для загрузки приложения с сегодняшними изменениями.
</p><p>
Я не включил базу данных в архив. Если у вас есть база данных предыдущей главы, просто положите её в нужное место и запустите </p><i>db_upgrade.py</i><p>. Ну а если у вас нет предыдущей базы данных, слздайте новую с помощью </p><i>db_create.py</i><p>.
</p><p>
Спасибо что читаете мой учебник.</p><p>
Надеюсь увидеть вас в следующем выпуске.
</p><p>
P.S. Автор оригинала статьи </p><a href="http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vi-profile-page-and-avatars"> Miguel Grinberg </a>
      <p class="clear"/>
    </div>

    
  </div></body></html>