<html><body><div><div class="post-body entry-content" id="post-body-3464233689147799477" itemprop="description articleBody">

<span>tl;dr: the proposed type hinting for Python is done to help tools analyze code better (which can be very useful for programmers) but at the cost of reduced readability.  A different idea is discussed which focuses on readability.</span>
<span>----</span>
<span><br/></span>
<span>So, Python is going to have some type hinting [PEP484].</span>
<span><br/></span>
<span>I agree with the idea that lead to this addition to Python; h</span><span>owever, I find that the syntax proposed is less than optimal. </span><span>Thinking about how it came about, it is not entirely surprising.</span>
<span><br/></span>

<ol>
<li><span>Functions annotations were introduced in 2006 [PEP3107].</span></li>
<li><span>Various libraries worked within the constraints and limitations imposed by this </span><span>new addition, including mypy [mypy].</span></li>
<li><span>PEP 484 is "strongly inspired by mypy" essentially using it as a starting point. </span><span>However, it indirectly acknowledges that the syntax chosen is less than optimal:</span></li>
</ol>

<blockquote class="tr_bq">
<span>If type hinting proves useful in general, </span><span><i>a syntax for typing variables may be provided in a future Python version.</i> [PEP484]</span></blockquote>
<span><br/></span>
<span>What if [PEP3107] had never been introduced nor accepted and implemented, and we wanted to consider type hinting in Python?...</span>
<span><br/></span>
<span><b>Why exactly is type hinting introduced?</b></span>
<span><br/></span>
<span>As stated in [PEP484]:</span>
<span><br/></span>

<blockquote class="tr_bq">
<i><span>"This PEP aims to provide a standard syntax for type annotations, </span><span>opening up Python code to easier static analysis and refactoring, </span><span>potential runtime type checking, </span><span>and performance optimizations utilizing type information."</span></i></blockquote>
<span><br/></span>
<span>The way I read this is as follows:  type hinting is primarily introduced to help </span><span>computerized </span><b>tools</b><span> analyze Python code.</span>
<span><br/></span>
<span>I would argue that, a counterpart to this would be that type hinting should </span><span>not be a hindrance to humans; in particular, it should have a minimal impact </span><span>on readability.   I would also argue that type hinting, as it is proposed  </span><span>and discussed, does reduce readability significantly. </span><span>Now, let's first have a look at some specific examples given, </span><span>so that you can make your own opinion as to how it would affect readability.</span>
<span><br/></span>
<span><b>Simple example (from [PEP484]):</b></span>
<span><br/></span>
<span>I will start with a very simple examples for those who might not have seen</span>
<span>the syntax discussed.</span>

<span>def greeting(name: str) -&gt; str:</span>
<span>    return 'Hello ' + name</span>
<span class="Apple-tab-span"><span> </span></span>
<span>Within the function arguments, the type annotation is denoted by </span>
<span>a colon (:); the type of the return value of the function is done</span>
<span>by a special combination of characters (-&gt;)  that precede the colon which</span>
<span>indicates the beginning of a code block.</span>
<span><br/></span>
<span><b>Slightly more complicated example (from [mypy])</b></span>
<span><br/></span>
<span>def twice(i: int, next: Function[[int], int]) -&gt; int:</span>
<span>    return next(next(i))</span>
<span><br/></span>
<span>We now have two arguments; it becomes a bit more difficult to see at a</span>
<span>glance what the arguments for the function are.  We can improve upon this</span>
<span>by formatting the code as follows:</span>
<span><br/></span>
<span>def twice(i: int, </span>
<span>          next: Function[[int], int]) -&gt; int:</span>
<span>    return next(next(i))</span>
<span class="Apple-tab-span"><span> </span></span>
<span class="Apple-tab-span"><span> </span></span>
<span><b>What about keyword-based arguments?</b></span>
<span><br/></span>
<span>From [PEP483]</span>
<span><br/></span>

<blockquote class="tr_bq">
<i><span>"There is no way to indicate optional or keyword arguments, </span><span>nor varargs (we don't need to spell those often enough to complicate the syntax)"</span></i></blockquote>
<span><br/></span>
<span>From [PEP484]</span>
<span><br/></span>

<blockquote class="tr_bq">
<i><span>"Since using callbacks with keyword arguments is not perceived as a </span><span>common use case, there is currently no support for specifying keyword </span><span>arguments with Callable."</span></i></blockquote>
<span><br/></span>
<span>However, some discussions are taking place;  here is an example taken f</span><span>rom <a href="https://github.com/ambv/typehinting/issues/18">https://github.com/ambv/typehinting/issues/18</a> (formatted in a more </span><span>readable way than found on that site)</span>
<span><br/></span>
<span>def retry(callback: Callable[AnyArgs, Any[int, None]], </span>
<span>          timeout: Any[int, None]=None, </span>
<span><span class="Apple-tab-span"> </span>         retries=Any[int, None]=None) -&gt; None:</span>
<span><br/></span>
<span>Can you easily read off the arguments of this function?  Did I forget one argument when I split the argument lists over three lines?  Can you quickly confirm that the formatting is not misleading?</span>
<span><br/></span>
<span><b>Type Hints on Local and Global Variables</b></span>
<span><br/></span>
<span>The following is verbatim from [PEP484]</span>
<span><br/></span>

<blockquote class="tr_bq">
<i><span>No first-class syntax support for explicitly marking variables as </span><span>being of a specific type is added by this PEP. </span><span>To help with type inference in complex cases, </span><span>a comment of the following format may be used:</span> </i></blockquote>
<blockquote class="tr_bq">
<span><br/></span><span>x = []   # type: List[Employee] </span></blockquote>
<blockquote class="tr_bq">
<span><br/></span><i><span>In the case where type information for a local variable </span><span>is needed before if was declared, </span></i><span><i>an Undefined placeholder might be used</i>:</span> </blockquote>
<blockquote class="tr_bq">
<span><br/></span><span>from typing import Undefined<br/>x = Undefined   # type: List[Employee]<br/>y = Undefined(int)</span><span class="Apple-tab-span"><span> </span><span> </span></span><span>  </span><br/>
<span><span class="Apple-tab-span">  </span>  </span><span><i><b>If type hinting proves useful in general, </b></i></span><span><i><b>a syntax for typing variables may be provided in a future Python version.</b></i></span><span>(emphasis added)<span class="Apple-tab-span">  </span>  </span></blockquote>
<span><br/></span>
<span>Edit: why not bite the bullet and do it now? Considering what this syntax, if it were introduced, should look like, might reassure people who see type information in comments as problematic and ensure that the limited syntax decided upon in this PEP will not have to be changed to be made coherent with the new addition(s).</span>
<span><br/></span>
<span><b>What about class variables?</b><span class="Apple-tab-span">  </span>  </span>
<span><br/></span>
<span>I have yet to see them being discussed.  </span><span>I assume that they would be treated the same as local and global </span><span>variables, with an as yet undefined syntax.</span>
<span><br/></span>

<span><b>A different proposal for type hinting.</b></span>
<span><br/></span>
<span>Let's forget for a moment the syntax introduced by [PEP3107] </span><span>for functions annotations, and imagine that we are considering everything </span><span>from the beginning.</span>
<span><br/></span>
<span>Type hinting is introduced for tools (linters, etc.).  As such, I would </span><span>assume the following:</span>
<span><br/></span>
<span>When reading/parsing code:</span>

<ol>
<li><span>type hinting information should be easily identifiable by tools</span></li>
<li><span>type hinting information should be easily ignorable by humans (if they so desire)</span></li>
</ol>

<span class="Apple-tab-span"><span> </span></span>
<span>By this, I mean that the type hinting information should not decrease </span><span>significantly the readability of the code.</span>
<span><br/></span>
<span><br/></span>
<span>Let me start with an obvious observation about Python:  </span><span>indentation based code-blocks indicate the structure.  Code blocks are </span><span>identified by their indentation level, which is the same within a </span><span>code block.</span>
<span><br/></span>
<span>Tools, like the Python interpreter, are very good at identifying code blocks. </span><span>Adding an new type of code block to take into account by these tools </span><span>should be straightforward.</span>
<span><br/></span>
<span><br/></span>
<span>A secondary observation is that comments, which are ignored by Python, </span><span>are allowed to deviate from the vertical alignment within a given code </span><span>block as illustrated below.</span>
<span><br/></span>
<span>def f():</span>
<span>    x = 1</span>
<span>    y = 2</span>
<span>       # this comment is not aligned </span>
<span>       # with the rest of the code.</span>
<span>    if z:</span>
<span>        pass<span class="Apple-tab-span"> </span></span>
<span><span class="Apple-tab-span">   </span>   </span>
<span><br/></span>
<span>Now, suppose that we could use a syntax where type annotation was  </span><span>structured around code-blocks defined by their indentation. </span><span>Since type annotation are meant to be ignored by the interpreter  </span><span>(non executable, like comments), let us also give the freedom to </span><span>have additional indentation for those ignorable code-blocks, like </span><span>we do for comments.</span>
<span><br/></span>
<span><b>The specific proposal</b></span>
<span><span class="Apple-tab-span">   </span>   </span>
<span>Add </span><span>where</span><span> as a new Python keyword; the purpose of this keyword is to introduce a code block in which type hinting information is given.</span>
<span><br/></span>
<span>To see how this would work in practice, I will show screenshots of code from a syntax-aware editor containing type hinting information as it is proposed and contrasted with how it might look when using the "where code blocks".  I'm using screenshots as it provides a truer picture of what code would really look like in real life situations.</span>
<span><br/></span>
<span>First, the example from [mypy] shown above:</span>
<span><br/></span>


<p class="separator">
<span>Now, the same example using the "</span><span>where</span><span>" code-block.</span></p>
<p class="separator">
<br/></p>







<span><br/></span>
<span>I used "</span><span>return</span><span>" instead of "</span><span>-&gt;</span><span>"  as I find it more readable; however, </span><span>"</span><span>-&gt;</span><span>" </span><span>could be used just as well.</span>
<span><br/></span>
<span>Having a code-block, I can use the code-folding feature of my editor to reduced greatly the visibility of the type hinting information; such code-folding could presumably be done automatically for all type-hinting code blocks.</span>







<span><br/></span>
<span>Moving on to a more complicated example, also given above.  First, the screenshot with the currently proposed syntax.</span>










<span>Next, using the proposed code-block; notice how keyword-based arguments are treated just the same as any other arguments. [<i>Note: I was not sure if </i></span><span>timeout</span><span> above was a keyword based argument assigned a default value or not, since it used a different syntax from </span><span>retries</span><span><i> which is a keyword based argument</i>.]</span>







<span>Again, using code-folding, the visual noise added by the type-hinting information essentially disappears.</span>
<p class="separator">
<br/></p>
<p>
<span>Finally, the example with the "global variable", first with the proposed type hinting information added in a comment:</span></p>
<a href="http://2.bp.blogspot.com/-60q1--JgBtg/VMqSV-iuGcI/AAAAAAAAA1Q/EWswSjJ3P-Q/s1600/hinting7.png" imageanchor="1"><br/></a><a href="http://2.bp.blogspot.com/-60q1--JgBtg/VMqSV-iuGcI/AAAAAAAAA1Q/EWswSjJ3P-Q/s1600/hinting7.png" imageanchor="1"><img border="0" src="http://2.bp.blogspot.com/-60q1--JgBtg/VMqSV-iuGcI/AAAAAAAAA1Q/EWswSjJ3P-Q/s1600/hinting7.png"/></a>









<span>Next, using a code block; no need to import a special "type" to assign a special "</span><span>Undefined</span><span>" value: the standard </span><span>None</span><span> does the job.</span>


<span><br/></span>
<span><br/></span>
<span><br/></span>
<span><br/></span>
<span><br/></span>
<span><br/></span>
<span><br/></span>
<span>A similar notation could easily be used for class variables, something which is not addressed by the current type-hinting PEP.</span>
<span><br/></span>
<span>Type hinting information is going to be a useful feature for future Python programmers.  I believe that using indentation based code blocks to indicate type hinting information would be much more readable that what has been discussed so far.  Unfortunately, I also believe that it has no chance of being accepted, let alone considered seriously.  </span>
<span><br/></span>
<span>[PEP483] <a href="https://www.python.org/dev/peps/pep-0483/">https://www.python.org/dev/peps/pep-0483/</a></span>
<span>[PEP484] <a href="https://www.python.org/dev/peps/pep-0484/">https://www.python.org/dev/peps/pep-0484/</a></span>
<span>[PEP3107] <a href="https://www.python.org/dev/peps/pep-3107/">https://www.python.org/dev/peps/pep-3107/</a></span>
<span>[mypy] <a href="http://mypy-lang.org/">http://mypy-lang.org/</a></span>
<p>
This blog post is licensed under </p><a href="http://creativecommons.org/publicdomain/" target="_blank">CC0</a><p> and was written purely with the intention to entertain.
</p><span><br/></span>
<span><br/></span>
<span><br/></span>
<span><br/></span>
<span><br/></span>
<span><br/></span>
<p/>
</div>
</div></body></html>