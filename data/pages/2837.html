<html><body><div><section class="post-content">
            <p>This is a second part of how we solved issues with huge number of queues on Google App Engine. I recommend to start from first part - <a href="http://eshlox.net/2015/01/19/google-app-engine-get-least-loaded-queue/">Google App Engine - Get the least loaded queue</a></p>

<p>Let's start again with this nice screenshot ;-)</p>

<p><img src="/content/images/2015/01/gae_queues.jpg" alt="Google App Engine queues"/></p>

<p>The first value is a creation time of the oldest task and the second value is a number of the tasks in a single queue. Reason of that? At first, a lot of tasks, really, we run big operations, some of them can be repeated because of some errors, and of course.. a lot of legacy code.</p>

<p>Because first fix described <a href="http://eshlox.net/2015/01/19/google-app-engine-get-least-loaded-queue/">here</a> didn't get us satisfying results we needed to think about another solution. Because we had a lot of tasks and as i investigated that those tasks can be repeated a lot of times i wanted to prevent that situation. Example: user can add/edit/delete/copy some item, _post/_put methods for this item runs N tasks, if user edits this item several times the number of the tasks can grow. Combining this with a large number of users, large number of tasks run by actions made by those users we got huge number of the tasks.</p>

<p>What is the solution? I've used two things from queues:</p>



<p>First, the method.</p>

<pre><code>import collections
import datetime
import hashlib
import math
import re

from google.appengine.api import taskqueue
from google.appengine.ext import deferred


def unique_task_defer(obj, *args, **kwargs):

    def normalize_name(obj_name, name_from_args, minutes=None):
        date = datetime.datetime.now()
        if minutes:
            date += datetime.timedelta(minutes=minutes)

        name = '{}-{}-{}-{}'.format(
            obj_name,
            hashlib.sha1(name_from_args.encode('utf-8')).hexdigest(),
            date.strftime('%Y%m%d%H'),
            int(math.ceil(float(int(date.strftime('%M')) + 1) / 15))
        )

        name = name.encode('utf-8', 'replace')
        name = name.replace('_', '-')
        name = re.sub('[^\w-]', '-', name)

        return name

    kwargs_values = [
        str(value) for key, value in collections.OrderedDict(
            sorted(kwargs.items())
        ).iteritems() if not str(key).startswith('_')
    ]

    name_from_args = '-'.join(map(unicode, args + tuple(kwargs_values)))
    name = normalize_name(obj.__name__, name_from_args)

    kwargs['_name'] = name

    try:
        deferred.defer(obj, *args, **kwargs)
    except taskqueue.TaskAlreadyExistsError:
        logging.info(
            'Skipping task (already exists): {}, {}'.format(
                obj.__name__, name
            )
        )
    except taskqueue.TombstonedTaskError:
        name = normalize_name(obj.__name__, name_from_args, minutes=15)

        logging.info(
            'TombstonedTask (retry): {}, {}'.format(
                obj.__name__, name
            )
        )

        kwargs['_name'] = name
        kwargs['_countdown'] = 900

        try:
            deferred.defer(obj, *args, **kwargs)
        except taskqueue.TaskAlreadyExistsError:
            logging.info(
                'Skipping task (already exists, second try): {}, {}'.format(
                    obj.__name__, name
                )
            )
</code></pre>

<p>Some explanation how it works. Look at this.</p>

<pre><code>unique_task_defer(
    task,
    parameter1,
    parameter2,
    _queue=get_least_loaded_queue(SOME_QUEUES_LIST),
)
</code></pre>

<p>This is how we use our method. Method <em>get_least_loaded_queue</em> is described in separate post, you can read about it <a href="http://eshlox.net/2015/01/19/google-app-engine-get-least-loaded-queue/">here</a>. If you want you can just remove <em>_queue</em> parameter or put some queue name.</p>

<p>At first we need to create a unique name for given task taking into account his parameters. It is made by normalize_name method. If the method gets the same task with the same parameters then method returns the same string every time. Queue name is composed from four parts:</p>

<ul>
<li>task name</li>
<li>combined string from all parameters</li>
<li>date in format %Y%m%d%H</li>
<li>number of quarter of an hour, it could have four values:
<ul><li>1 if it is a first quarter, example range: 01:00 - 01:14</li>
<li>2 if it is a second quarter, example range: 01:15 - 01:29</li>
<li>3 if it is a third quarter, example range: 01:30 - 01:45</li>
<li>4 if it is a fourth quarter, example range: 01:46 - 01:59</li></ul></li>
</ul>

<p>If normalized_name will get <em>minutes</em> argument then those number of minutes will be added to third part of queue name - date. I will explain it later.</p>

<p>Let's run this task. We are using <em>unique_task_defer</em> method with some parameters. This method creates a unique queue name as described above and push it into some queue. This operation could raise two exceptions which we are interested in.</p>

<ul>
<li>TaskAlreadyExistsError - it will be raised when task with given name will exist in a given queue</li>
<li>TombstonedTaskError - it will be raised when task with given name was executed in a given queue, it doesn't exist because it was finished</li>
</ul>

<p>First, our method sets task name and wants to push task to the queue using deferred.defer method. If the task has never existed then it is pushed normally to the queue. Without magic.</p>

<p>If deferred.defer method raises TaskAlreadyExistsError then we don't want to run this task again. It exists in the queue, it is not finished and every new task will do the same operation so it is unnecessary.</p>

<p>If deferred.defer method raises TombstonedTaskError then it means that someone ran this task some time ago with the same parameters. We want to run this task once again because something could change but in this time we will delay time execution for 900 seconds (15 minutes) . Why? Answer is simple, to prevent of huge number of tasks in queue which are executed and to get better task management. We are using this method in cases when some delay is allowed.</p>

<p>Simple example.</p>

<ol>
<li>We run the task first time. It runs without problems and it is added to the queue.  </li>
<li>We run this task once again. It exists in the queue so deffered.defer raises TaskAlreadyExistsError and the task is killed and is not added to the queue once again.  </li>
<li>Our task is finished.  </li>
<li>We run this task once again. deffered.defer method raises TombstonedTaskError. We want to run this task again but with 15 minutesâ€™ delay. Our method changes task name by changing fourth parameter in queue name - number of quarter of an hour. It gives us possibility to push task to the queue once again because it has different name. Our method also sets <em>countdown</em> parameter to the task which means that this task will wait in queue minimum 15 minutes and then it will be executed. In this time other tasks can be finished.  </li>
<li>When deffered.defer raises TombstonedTaskError we are also checking once again if this task exists in the queue. It is the same operation as in point 2.</li>
</ol>

<p>Maybe it doesn't look like a great solution but it really helped us to resolve all issues with queues quickly. At the moment the oldest task in the queue has maximum 15 - 20 minutes but most of the time our queues look like this which is is the best proof that it works. ;-)</p>

<p><img src="/content/images/2015/01/gae_queues-1.jpg" alt="Google App Engine queues"/></p>

<p>This was achieved by two steps: <br/>
1. Described in the post: <a href="http://eshlox.net/2015/01/19/google-app-engine-get-least-loaded-queue/">Google App Engine - Get least loaded queue</a> <br/>
2. Described in this post.</p>
        </section>

        </div></body></html>