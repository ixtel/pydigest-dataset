<html><body><div><div class="content html_format"><p>
      Сидел вечером дома, думал чем бы заняться. А! У Python есть отладчик, но в нём совершенно некрасивое приглашение ко вводу. Дай‐ка я впилю туда </p><a href="https://github.com/powerline/powerline">powerline</a><p>. Дело казалось бы совершенно плёвое: нужно просто создать свой подкласс </p><a href="https://docs.python.org/2.7/library/pdb.html#pdb.Pdb">pdb.Pdb</a><p> со своим </p><a href="https://docs.python.org/2.7/library/functions.html#property">свойством</a><p>, да?</p><pre><code class="python">def use_powerline_prompt(cls):
    '''Decorator that installs powerline prompt to the class
    '''
    @property
    def prompt(self):
        try:
            powerline = self.powerline
        except AttributeError:
            powerline = PDBPowerline()
            powerline.setup(self)
            self.powerline = powerline
        return powerline.render(side='left')

    @prompt.setter
    def prompt(self, _):
        pass

    cls.prompt = prompt

    return cls
</code></pre><a name="habracut"/><p>Нет. На Python-3 такой код ещё может работать, но на Python-2 нас уже поджидает проблема: для вывода необходимо превратить </p><a href="https://docs.python.org/2.7/library/functions.html#unicode">юникодную строку</a><p> в </p><a href="https://docs.python.org/2.7/library/functions.html#str">набор байт</a><p>, что требует указания кодировки. Ну, это просто:</p><pre><code class="python">encoding = get_preferred_output_encoding()

def prompt(self):
    …
    ret = powerline.render(side='left')
    if not isinstance(ret, str):
        # Python-2
        ret = ret.encode(encoding)
    return ret
</code></pre><p>. Это просто и это работает… пока пользователь не установит </p><a href="https://pypi.python.org/pypi/pdbpp/0.7.2">pdbpp</a><p>. Теперь нас приветствуют ряд ошибок, связанных с тем, что pdbpp может использовать pyrepl, а pyrepl не работает с Unicode (причём то, будет ли использоваться pyrepl, как‐то зависит от значения </p><code>$TERM</code><p>¹). Ошибки, связанные с тем, что в приглашении кто‐то не хочет видеть Unicode, не новы — ещё IPython пытался запретить Unicode в rewrite prompt². Но здесь всё гораздо хуже: pyrepl использует </p><a href="https://docs.python.org/2.7/library/__future__.html"><code>from __future__ import unicode_literals</code></a><p>, при этом делая с использованием обычных строк (превращённых этим импортом в юникодные) различные операции на строке приглашения, в явном виде конвертируемой в </p><code>str</code><p> в самом начале.
</p><p>
Итак, вот что нам, получается, нужно:</p><ol>
<li>Класс‐наследник <code>unicode</code>, который бы конвертировался в <code>str</code> без выбрасывания ошибок на не‐ASCII символах (конвертация осуществляется просто в виде <code>str(prompt)</code>). Эта часть очень проста: нужно переопределить методы <code>__str__</code> и <code>__new__</code> (без второго можно, в принципе, и обойтись, но так удобнее при конвертации в этот класс из следующего и для возможности явного указания кодировки, которая будет использована).</li>
<li>Класс‐наследник <code>str</code>, в который бы и конвертировался предыдущий класс. Здесь переопределения двух методов категорически недостаточно: <ol>
<li><code>__new__</code> нужен для удобного сохранения кодировки и отсутствие необходимости в явном преобразовании <code>unicode</code>→<code>str</code>.</li>
<li><code>__contains__</code> и несколько других методов должны работать с юникодными аргументами так, будто текущий класс есть <code>unicode</code> (для неюникодных аргументов ничего менять не нужно). Дело в том, что при наличиии <code>unicode_literals</code> <code>'\n' in prompt</code> выбрасывает исключение, если <code>prompt</code> — байтовая строка с не‐ASCII символами, так как Python пытается привести <code>prompt</code> к <code>unicode</code>, а не наоборот.</li>
<li><code>find</code> и схожие функции должны работать с юникодными аргументами так, будто это байтовые строки в текущей кодировке. Это нужно, чтобы они выдавали правильные индексы, но при этом не валились с ошибками из‐за конвертации байтовой строки в юникодную (а здесь‐то почему конвертация не обратная?).</li>
<li><code>__len__</code> должен выдавать длину строки в юникодных codepoint’ах. Эта часть нужна, чтобы pyrepl, считающий, где заканчивается приглашение (и ставящий курсор соответственно), не ошибся и не сделал гиганский пробел между приглашением и курсором. Подозреваю, что нужно на самом деле использовать не codepoint’ы, а ширину строки в экранных ячейках (то, что делает, к примеру, <a href="http://vimpluginloader.sourceforge.net/doc/eval.txt.html#strdisplaywidth.28.29">strdisplaywidth()</a> в Vim).</li>
<li><code>__add__</code> должен возвращать наш первый класс‐наследник <code>unicode</code> при прибавлении к юникодной строке. <code>__radd__</code> должен делать то же самое. Сложение байтовых строк должно давать наш класс‐наследник <code>str</code>. Подробнее в следующем пункте.</li>
<li>Ну, и наконец, <code>__getslice__</code> (внимание: <code>__getitem__</code> не катит, <code>str</code> использует deprecated <code>__getslice__</code> для срезов) должен возвращать объект того же самого класса, поскольку pyrepl в самом конце складывает пустую юникодную строку, срез от текущего класса и другой срез от него же. И если эту часть обойти вниманием, то опять получим какую‐то из <a href="https://docs.python.org/2.7/library/exceptions.html#exceptions.UnicodeError">UnicodeError</a>.</li>
</ol> </li>
</ol><p>В результате получатся следующие два уродца:</p><pre><code class="python">class PowerlineRenderBytesResult(bytes):
    def __new__(cls, s, encoding=None):
        encoding = encoding or s.encoding
        self = bytes.__new__(cls, s.encode(encoding) if isinstance(s, unicode) else s)
        self.encoding = encoding
        return self

    for meth in (
        '__contains__',
        'partition', 'rpartition',
        'split', 'rsplit',
        'count', 'join',
    ):
        exec((
            'def {0}(self, *args):\n'
            '   if any((isinstance(arg, unicode) for arg in args)):\n'
            '       return self.__unicode__().{0}(*args)\n'
            '   else:\n'
            '       return bytes.{0}(self, *args)'
        ).format(meth))

    for meth in (
        'find', 'rfind',
        'index', 'rindex',
    ):
        exec((
            'def {0}(self, *args):\n'
            '   if any((isinstance(arg, unicode) for arg in args)):\n'
            '       args = [arg.encode(self.encoding) if isinstance(arg, unicode) else arg for arg in args]\n'
            '   return bytes.{0}(self, *args)'
        ).format(meth))

    def __len__(self):
        return len(self.decode(self.encoding))

    def __getitem__(self, *args):
        return PowerlineRenderBytesResult(bytes.__getitem__(self, *args), encoding=self.encoding)

    def __getslice__(self, *args):
        return PowerlineRenderBytesResult(bytes.__getslice__(self, *args), encoding=self.encoding)

    @staticmethod
    def add(encoding, *args):
        if any((isinstance(arg, unicode) for arg in args)):
            return ''.join((
                arg
                if isinstance(arg, unicode)
                else arg.decode(encoding)
                for arg in args
            ))
        else:
            return PowerlineRenderBytesResult(b''.join(args), encoding=encoding)

    def __add__(self, other):
        return self.add(self.encoding, self, other)

    def __radd__(self, other):
        return self.add(self.encoding, other, self)

    def __unicode__(self):
        return PowerlineRenderResult(self)

class PowerlineRenderResult(unicode):
    def __new__(cls, s, encoding=None):
        encoding = (
            encoding
            or getattr(s, 'encoding', None)
            or get_preferred_output_encoding()
        )
        if isinstance(s, unicode):
            self = unicode.__new__(cls, s)
        else:
            self = unicode.__new__(cls, s, encoding, 'replace')
        self.encoding = encoding
        return self

    def __str__(self):
        return PowerlineRenderBytesResult(self)
</code></pre><p>(в Python2 </p><code>bytes is str</code><p>).
</p><p>
Результат на github пока есть только в </p><a href="https://github.com/ZyX-I/powerline/blob/pdb/powerline/bindings/pdb/__init__.py">моей ветке</a><p>, позже будет в </p><code>develop</code><p> основного репозитория.</p><p>
Разумеется, результат не ограничен только pyrepl, а может применяться в различных местах, куда вам нельзя подсунуть не‐ASCII строку, но очень хочется.

</p><p>
¹ При </p><code>TERM=xterm-256color</code><p> я получаю ошибки от pyrepl, а при  </p><code>TERM=</code><p> или </p><code>TERM=konsole-256color</code><p> — нет и всё работает  нормально.</p><p>
² То, что вы увидите, если включите autocall в IPython и наберёте </p><code>int 42</code><p>: </p><img src="https://habrastorage.org/getpro/habr/post_images/13a/c4f/858/13ac4f858b90a459e7da7b21a0dc7bfa.png" alt="Powerline IPython in and rewrite prompt"/><p> (нижняя строка).

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>