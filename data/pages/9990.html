<html><body><div><div class="post-body entry-content"><p>
By </p><a href="http://jugad2.blogspot.in/p/about-vasudev-ram.html">Vasudev Ram</a><p/><p>
Some time back, I had written this post:

</p><a href="http://jugad2.blogspot.in/2013/06/pythons-trace-module-and-chained.html">Python's trace module and chained decorators</a>
<p>
in which I had briefly described use of the Python standard library's </p><a href="https://docs.python.org/2/library/trace.html">trace module</a><p> to help us </p><i>understand and debug Python programs</i><p>. In that post I showed a small program with 3 chained decorators. The trace module was used to trace the execution of the decorators and the functions that they decorated.
</p><p>
The trace output in that post also showed the difference between </p><i>function definition</i><p> and </p><i>function execution</i><p>, both of which occur </p><i>at run time</i><p> in Python, since it is a dynamic language.
</p><p>
In this post, I'm going to use the trace module in a few other ways.
</p><p>
Here is a small program in which we will use the trace module.
</p><p>
(Note that I said "in which", not "on which", because I am going to invoke the trace module as a library from within this program, and tell it to start tracing from a specific function call, unlike in my previous post (linked above), in which I used the trace module as though it was a program itself, by using the "python -m" option, to trace my own program containing those decorators.)
</p><pre># This is a program to show some basic usage of the trace module 
# from the Python standard library.
# Author: Vasudev Ram - 
# http://jugad2.blogspot.in/p/about-vasudev-ram.html
# Copyright 2016 Vasudev Ram

def fa():
    fb()

def fb():
    fc()

def fc():
    fd(5)

def fd(n):
    if n 
In this program, I have a function fa calling fb which calls fc which calls fd.  Function fd also calls itself recursively, with a termination condition so the recursion is not infinite.
<p/><p/>Note that the program contains all the three main programming constructs: sequential execution of statements, conditional execution  and iteration (via the recursive call in function fd).
<p/><p/>From the Python documentation, the trace.Trace() constructor has the following (partial) signature:
<p/><p/>class trace.Trace(count=1, trace=1, countfuncs=0, countcallers=0, ...)
<p/><p/>where I have used ellipsis (...) to represent the remaining arguments, which I do not pass. (See the docs (linked above, near top of post) for the full signature and the meaning of all the arguments. The ones I use are explained below.)
<p/><p/>As for what those arguments do, again, from the docs:
<p/><p/>Create an object to trace execution of a single statement or expression. All parameters are optional. count enables counting of line numbers. trace enables line execution tracing. countfuncs enables listing of the functions called during the run. countcallers enables call relationship tracking.
<p/><p/>I ran the program simple_prog.py 4 times. Each time I passed a different combination of argument values to trace.Trace() - with only one argument set to 1 each time, and all the others set to 0 in that run. And each time I redirected the resulting trace output to an output file, except for the first run, in which Python created the output in the file simple_prog.cover (since the program being traced is named simple_prog.py.
<p/><p/>The lines below show the sets of arguments passed, and the corresponding output file names for the trace output. (I will show the contents of each output file later, below.)
<p/><p/>arg set 1:
    count=1, trace=0, countfuncs=0, countcallers=0, 
output: simple_prog.cover
<p/><p/>arg set 2:
    count=0, trace=1, countfuncs=0, countcallers=0, 
output: run_2.txt
<p/><p/>arg set 3:
    count=0, trace=0, countfuncs=1, countcallers=0, 
output: run_3.txt
<p/><p/>arg set 4:
    count=0, trace=0, countfuncs=0, countcallers=1, 
output: run_4.txt
<p/><p/>Notice that in each of the arg sets, only one flag is set.
<p/><p/>I ran the program this time with just:
<p/><p/>python simple_prog.py
<p/><p/>since the tracing is started from within the program, unlike in my previous post (linked above) in which I started the tracing like this:
<p/><p/>python -m trace -t test_chained_decorators.py
<p/><p/>Here is the output for the 1st run, simple_prog.cover:
<pre># This is a program to show some basic usage of the trace module 
       # from the Python standard library.
       # Author: Vasudev Ram - 
       # http://jugad2.blogspot.in/p/about-vasudev-ram.html
       # Copyright 2016 Vasudev Ram
       
&gt;&gt;&gt;&gt;&gt;&gt; def fa():
    1:     fb()
       
&gt;&gt;&gt;&gt;&gt;&gt; def fb():
    1:     fc()
       
&gt;&gt;&gt;&gt;&gt;&gt; def fc():
    1:     fd(5)
       
&gt;&gt;&gt;&gt;&gt;&gt; def fd(n):
    5:     if n &lt;= 1:
    1:         return
           else:
    4:         fd(n - 1)
       
&gt;&gt;&gt;&gt;&gt;&gt; import trace
       
&gt;&gt;&gt;&gt;&gt;&gt; tracer = trace.Trace(
&gt;&gt;&gt;&gt;&gt;&gt;     count=1, trace=0, countfuncs=0, countcallers=0, 
       )
       
&gt;&gt;&gt;&gt;&gt;&gt; tracer.run('fa()') # This line starts the tracing process.
&gt;&gt;&gt;&gt;&gt;&gt; r = tracer.results()
&gt;&gt;&gt;&gt;&gt;&gt; r.write_results(show_missing=True, coverdir=".")
</pre>You can see that the output includes the counts of the number of times lines of code are called. Notice that there are no line counts for the def lines, presumably because function definitions are only supposed to be done once (by definition, ha ha), so it would not make sense to show it, and might even be confusing.
<p/><p/>Here is the output for the 2nd run, run_2.txt:
<pre>--- modulename: simple_prog, funcname: &lt;module&gt;
&lt;string&gt;(1):   --- modulename: simple_prog, funcname: fa
simple_prog.py(6):     fb()
 --- modulename: simple_prog, funcname: fb
simple_prog.py(9):     fc()
 --- modulename: simple_prog, funcname: fc
simple_prog.py(12):     fd(5)
 --- modulename: simple_prog, funcname: fd
simple_prog.py(15):     if n &lt;= 1:
simple_prog.py(18):         fd(n - 1)
 --- modulename: simple_prog, funcname: fd
simple_prog.py(15):     if n &lt;= 1:
simple_prog.py(18):         fd(n - 1)
 --- modulename: simple_prog, funcname: fd
simple_prog.py(15):     if n &lt;= 1:
simple_prog.py(18):         fd(n - 1)
 --- modulename: simple_prog, funcname: fd
simple_prog.py(15):     if n &lt;= 1:
simple_prog.py(18):         fd(n - 1)
 --- modulename: simple_prog, funcname: fd
simple_prog.py(15):     if n &lt;= 1:
simple_prog.py(16):         return
 --- modulename: trace, funcname: _unsettrace
trace.py(80):         sys.settrace(None)
</pre>Since the trace flag is set, we get line execution tracing. And due to that, there are 5 entries for function fd, since there are 5 calls to it (of which 4 are recursive).
<p/><p/>Here is the output for the 3rd run, run_3.txt:
<pre>functions called:
filename: &lt;string&gt;, modulename: &lt;string&gt;, funcname: &lt;module&gt;
filename: D:\Anaconda-2.1.0-64\lib\trace.py, modulename: trace, funcname: _unsettrace
filename: simple_prog.py, modulename: simple_prog, funcname: fa
filename: simple_prog.py, modulename: simple_prog, funcname: fb
filename: simple_prog.py, modulename: simple_prog, funcname: fc
filename: simple_prog.py, modulename: simple_prog, funcname: fd
</pre>Since the countfuncs flag is set, it shows the functions called during the run of the program.
<p/><p/>Here is the output for the 4th run, run_4.txt:
<pre>calling relationships:

*** &lt;string&gt; ***
  --&gt; simple_prog.py
    &lt;string&gt;.&lt;module&gt; -&gt; simple_prog.fa

*** D:\Anaconda-2.1.0-64\lib\trace.py ***
  --&gt; &lt;string&gt;
    trace.Trace.runctx -&gt; &lt;string&gt;.&lt;module&gt;
    trace.Trace.runctx -&gt; trace._unsettrace

*** simple_prog.py ***
    simple_prog.fa -&gt; simple_prog.fb
    simple_prog.fb -&gt; simple_prog.fc
    simple_prog.fc -&gt; simple_prog.fd
    simple_prog.fd -&gt; simple_prog.fd
</pre>Since the countcallers flag is set, it shows the function call tree during the run of the program, i.e. what function called what other function(s). The last line shows the recursive call to fd.
<p/><p/>So we can see, overall, that those four flags to trace.Trace(), allowed us to get insight into the behaviour of the program, from various angles or perspectives. This makes the trace module a useful tool for debugging and for understanding code that we have to work on.
<p/><p/>- Enjoy.
<p/><p/><p/>- <a href="http://jugad2.blogspot.in/p/about-vasudev-ram.html">Vasudev Ram - Online Python training and  programming</a><p/><b><a href="mailto:vasudevram@gmail.com?subject=Email%20me%20about%20your%20new%20products%20and%20services">Signup to hear about new products and services I create.</a></b> <p/><a href="http://jugad2.blogspot.com/search/label/python">Posts about Python</a>  <a href="http://jugad2.blogspot.com/search/label/xtopdf">Posts about xtopdf</a> <p/><p/><a href="https://code.activestate.com/recipes/users/4173351/">My ActiveState recipes</a> <p/>   
<p/>
</pre></div>
</div></body></html>