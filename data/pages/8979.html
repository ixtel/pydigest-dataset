<html><body><div><div class="section">
              <h1>jep-python 0.5.5</h1>

              


<p>Python implementation of the Joint Editors Protocol.</p>








<p><a href="https://travis-ci.org/jep-project/jep-python" rel="nofollow"><img src="https://travis-ci.org/jep-project/jep-python.svg?branch=master"/></a> <a href="https://coveralls.io/r/moltob/jep-python?branch=master" rel="nofollow"><img src="https://coveralls.io/repos/moltob/jep-python/badge.png?branch=master"/></a> <a href="https://badge.fury.io/py/jep-project.svg" rel="nofollow"><img src="https://badge.fury.io/py/jep-project.svg"/>
</a></p>
<p>This is the Python implementation of the Joint Editors Protocol (JEP),
see <a href="http://joint-editors.org/" rel="nofollow">http://joint-editors.org/</a> for more information. jep-python is providing
language authors with a frontend library for IDE/editor integration and
a backend library for language support.</p>
<p>This implementation is currently compatible with Python 3.3+.</p>
<p>Look at these associated projects for examples of productive use of the library:</p>

<div id="backend-support">
<h2>Backend support</h2>
<p>Implementing JEP based support for a custom language is easy. Simply
derive one or more listener classes to respond to frontend messages and
then run the backend with those listeners.</p>
<pre><span class="kn">from</span> <span class="nn">jep_py.backend</span> <span class="kn">import</span> <span class="n">Backend</span><span class="p">,</span> <span class="n">FrontendListener</span>

<span class="k">class</span> <span class="nc">Listener</span><span class="p">(</span><span class="n">FrontendListener</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">on_completion_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">completion_request</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="c1"># process completion request and send back response:</span>
        <span class="n">completion_response</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">completion_request</span><span class="p">)</span>
        <span class="n">context</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">completion_response</span><span class="p">)</span>

<span class="c1"># instantiate and start backend service with our listeners:</span>
<span class="n">listener</span> <span class="o">=</span> <span class="n">Listener</span><span class="p">()</span>
<span class="n">backend</span> <span class="o">=</span> <span class="n">Backend</span><span class="p">([</span><span class="n">listener</span><span class="p">])</span>
<span class="n">backend</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre>
<p>Callbacks that are not needed by a certain listener do not need to be
overridden in the derived class.</p>
<p>While the user is editing a file in a connected IDE the frontend will
repeatedly send <tt>ContentSync</tt> objects to the backend. The backend
implementation already processes these messages internally and provides
an accumulated file view to client code. Since backend-internal message
processing is done <em>before</em> messages are passed to subscribed listeners,
you can process the latest view of a file directly inside your
listener’s handler of <tt>ContentSync</tt> by accessing the context’s
<tt>content_monitor</tt> filepath dictionary:</p>
<pre><span class="k">def</span> <span class="nf">on_content_sync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content_sync</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="c1"># get the content monitor's view of the file that was just updated:</span>
    <span class="n">file_content</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">content_monitor</span><span class="p">[</span><span class="n">content_sync</span><span class="o">.</span><span class="n">file</span><span class="p">]</span>

    <span class="c1"># ...</span>
</pre>
</div>
<div id="frontend-support">
<h2>Frontend support</h2>
<p>Similarly in an IDE frontend you again derive listener classes, this
time listening to backend messages. Since the frontend initiates the
connection you additionally have to create such a connection for a
certain language. JEP service lookup is then used to determine the
supporting backend and the frontend will start it in its own subprocess.</p>
<p>Here is an example shutting down the backend service upon reception of
its first alive message:</p>
<pre><span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">from</span> <span class="nn">jep_py.frontend</span> <span class="kn">import</span> <span class="n">Frontend</span><span class="p">,</span> <span class="n">BackendListener</span><span class="p">,</span> <span class="n">State</span>
<span class="kn">from</span> <span class="nn">jep_py.schema</span> <span class="kn">import</span> <span class="n">Shutdown</span>

<span class="k">class</span> <span class="nc">MyListener</span><span class="p">(</span><span class="n">BackendListener</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">on_backend_alive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="n">context</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">Shutdown</span><span class="p">())</span>


<span class="n">frontend</span> <span class="o">=</span> <span class="n">Frontend</span><span class="p">([</span><span class="n">MyListener</span><span class="p">()])</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">frontend</span><span class="o">.</span><span class="n">get_connection</span><span class="p">(</span><span class="s1">'localfile.mydsl'</span><span class="p">)</span>

<span class="k">while</span> <span class="n">connection</span><span class="o">.</span><span class="n">state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">State</span><span class="o">.</span><span class="n">Disconnected</span><span class="p">:</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mf">0.1</span><span class="p">))</span>
</pre>
</div>


<a name="downloads"> </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>22</span> downloads in the last week
  </li>
  <li>
    <span>179</span> downloads in the last month
  </li>
</ul>









            </div>


          </div></body></html>