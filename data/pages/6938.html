<html><body><div><div class="section" id="s-convenient-api-mocks-with-zato-apimox">
<span id="convenient-api-mocks-with-zato-apimox"/><h1>Convenient API mocks with zato-apimox</h1>
<p><strong>zato-apimox</strong> is a command-line application to create test HTTP (including TLS) and ZeroMQ servers.
The former can respond with canned messages to requests matching predefined criteria, including URL paths, query string and HTTP method.</p>
<p>zato-apimox is an ideal companion during development and testing, including performance tests,
when an actual API to integrate with may be for any reason unavailable.</p>
<p>No programming is needed to use the tool, only INI-style config files are used.</p>
<p>Source code is freely available on <a class="reference external" href="https://github.com/zatosource/zato-apimox">GitHub</a>.</p>
<p>API developers may also take advantage of <a class="reference internal" href="../apitest/index.html"><em>zato-apitest</em></a>,
the tool’s counterpart used to test and invoke API endpoints in plain English.</p>
<div class="section" id="s-installation">
<span id="installation"/><h2>Installation</h2>
<p>zato-apimox is released independently of the core <a class="reference internal" href="../../index.html"><em>Zato platform</em></a> with latest version always available on
<a class="reference external" href="https://pypi.python.org/pypi/zato-apimox/">PyPI</a>.</p>
<p><a class="reference external" href="https://pip.pypa.io/en/stable/installing/">pip</a> is used for installing, as in the command below:</p>
<div class="highlight-bash"><pre>$ sudo pip install zato-apimox
[snip]
Successfully installed zato-apimox-1.2
$</pre>
</div>
</div>
<div class="section" id="s-demo-mode">
<span id="demo-mode"/><h2>Demo mode</h2>
<p>Running the following command will set up an environment with sample mocks and start an HTTP server bound to 0.0.0.0:44333:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>apimox demo
Creating directory <span class="sb">`</span>/tmp/16bfa5e290cb4e239b7d6505a1f76783<span class="sb">`</span>.
OK, initialized.
INFO - Mounting <span class="sb">`</span>JSON Demo - 01<span class="sb">`</span> on http://0.0.0.0:44333/demo <span class="o">(</span>qs: <span class="o">{</span><span class="s1">'hello'</span>: <span class="s1">'world'</span><span class="o">})</span>
INFO - Mounting <span class="sb">`</span>JSON Demo - 02<span class="sb">`</span> on http://0.0.0.0:44333/demo <span class="o">(</span>qs: <span class="o">{</span><span class="s1">'hello'</span>: <span class="s1">'sky'</span><span class="o">})</span>
INFO - Mounting <span class="sb">`</span>JSON Demo - 03<span class="sb">`</span> on http://0.0.0.0:44333/something/<span class="o">{</span>anything<span class="o">}</span> <span class="o">(</span>qs: <span class="o">{})</span>
INFO - Mounting <span class="sb">`</span>XML Demo - 01<span class="sb">`</span> on http://0.0.0.0:44333/demo <span class="o">(</span>qs: <span class="o">{</span><span class="s1">'format'</span>: <span class="s1">'xml'</span><span class="o">})</span>
INFO - HTTPServer listening on http://0.0.0.0:44333
</pre></div>
</div>
<p>Calling it with any HTTP client, such as curl, will return different responses depending on input criteria
found in URL path and query string.</p>
<div class="highlight-bash"><pre>$ curl http://localhost:44333/demo?hello=world
{"Welcome to apimox":"How's things?"}
$</pre>
</div>
<div class="highlight-bash"><pre>$ curl http://localhost:44333/demo?hello=sky
{"Isn't apimox great?":"Sure it is!"}
$</pre>
</div>
<div class="highlight-bash"><pre>$ curl http://localhost:44333/something/foo
{"Responses can be":"provided inline"}
$

$ curl http://localhost:44333/something/bar
{"Responses can be":"provided inline"}
$

$ curl http://localhost:44333/something/baz
{"Responses can be":"provided inline"}
$</pre>
</div>
<div class="highlight-bash"><pre>$ curl http://localhost:44333/demo?format=xml
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;root&gt;
 &lt;element&gt;Greetings!&lt;/element&gt;
&lt;/root&gt;
$</pre>
</div>
</div>
<div class="section" id="s-initializing-environments">
<span id="initializing-environments"/><h2>Initializing environments</h2>
<p>Run <em>apimox init</em> with an empty directory on input to initialize a new environment populated with sample mocks - the same ones
<em>apimox demo</em> uses. Such a newly initialized environment is fully operational and can serve as a basis for authoring one's
own mocks.</p>
<div class="highlight-bash"><pre>$ apimox init ~/projects/my-apimox/
OK, initialized.
Run `apimox run /home/user/projects/my-apimox` for a live demo.
$</pre>
</div>
</div>
<div class="section" id="s-starting-and-stopping-mocks">
<span id="starting-and-stopping-mocks"/><h2>Starting and stopping mocks</h2>
<p><em>apimox run</em> is the command used to start mocks configured in a given directory. If provided with only the directory on input,
it will start plain HTTP mocks (no TLS). Additional <em>-t</em> parameter may be used to specify what sort of server to start in
particular. Values accepted in <em>-t</em> are:</p>
<table class="docutils">
<colgroup>
<col/>
<col/>
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>http-plain (default)</td>
<td>Starts a plain HTTP server - this is the default used if no <em>-t</em> is provided</td>
</tr>
<tr class="row-odd"><td>http-tls</td>
<td>Starts an HTTP server behind TLS</td>
</tr>
<tr class="row-even"><td>http-tls-client-certs</td>
<td>Starts an HTTP server behind TLS which requires connecting applications to use client certificates</td>
</tr>
<tr class="row-odd"><td>zmq-pull</td>
<td>Starts a ZeroMQ PULL socket in bind mode (clients need to connect)</td>
</tr>
<tr class="row-even"><td>zmq-sub</td>
<td>Starts a ZeroMQ SUB socket in bind mode (clients need to connect)</td>
</tr>
</tbody>
</table>
<p>It is possible to run <em>apimox run</em> multiple times against the same directory each time starting a different server type thus
allowing for the same mock endpoints be accessible over both plain HTTP and TLS.</p>
<p>Mocks run in foreground. To stop a mock server, press <em>Ctrl-C</em> in terminal.</p>
<div class="highlight-bash"><pre>$ apimox run ~/projects/my-apimox/ -t http-plain
INFO - Mounting `JSON Demo - 01` on http://0.0.0.0:44333/demo (qs: {'hello': 'world'})
INFO - Mounting `JSON Demo - 02` on http://0.0.0.0:44333/demo (qs: {'hello': 'sky'})
INFO - Mounting `JSON Demo - 03` on http://0.0.0.0:44333/something/{anything} (qs: {})
INFO - Mounting `XML Demo - 01` on http://0.0.0.0:44333/demo (qs: {'format': 'xml'})
INFO - HTTPServer listening on http://0.0.0.0:44333
^CKeyboardInterrupt
Aborted!
$</pre>
</div>
<div class="highlight-bash"><pre>$ apimox run ~/projects/my-apimox/ -t http-tls-client-certs
INFO - Mounting `JSON Demo - 01` on https://0.0.0.0:44777/demo (qs: {'hello': 'world'})
INFO - Mounting `JSON Demo - 02` on https://0.0.0.0:44777/demo (qs: {'hello': 'sky'})
INFO - Mounting `JSON Demo - 03` on https://0.0.0.0:44777/something/{anything} (qs: {})
INFO - Mounting `XML Demo - 01` on https://0.0.0.0:44777/demo (qs: {'format': 'xml'})
INFO - TLS HTTPServer listening on https://0.0.0.0:44777 (client certs: required)
^CKeyboardInterrupt
Aborted!
$</pre>
</div>
<div class="highlight-bash"><pre>$ apimox run ~/projects/my-apimox/ -t zmq-pull
INFO - ZMQ PULL listening on tcp://0.0.0.0:55000
^C
Aborted!
$</pre>
</div>
</div>
<div class="section" id="s-mock-environment-layout">
<span id="mock-environment-layout"/><h2>Mock environment layout</h2>
<p>An environment's default structure, right after issuing <em>apimox init</em>, is presented below:</p>
<div class="highlight-bash"><div class="highlight"><pre>~/projects/my-apimox/
├── http
│   ├── config.ini
│   ├── logs
│   └── response
│       ├── json
│       │   ├── demo1.json
│       │   └── demo2.json
│       └── txt
│       └── xml
│           └── demo1.xml
├── pem
│   ├── ca.cert.pem
│   ├── client.key-cert.pem
│   ├── server.cert.pem
│   └── server.key.pem
└── zmq
    ├── config.ini
    └── logs
</pre></div>
</div>
<table class="docutils">
<colgroup>
<col/>
<col/>
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Path</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>/http</td>
<td>Top-level directory for HTTP-related configuration (including TLS servers)</td>
</tr>
<tr class="row-odd"><td>/http/config.ini</td>
<td>Config file for HTTP mocks</td>
</tr>
<tr class="row-even"><td>/http/logs</td>
<td>Directory for HTTP logs</td>
</tr>
<tr class="row-odd"><td>/http/response</td>
<td>Responses to respond with in HTTP mocks</td>
</tr>
<tr class="row-even"><td>/http/response/txt</td>
<td>Plain text responses. Also a location to store reusable response headers in.</td>
</tr>
<tr class="row-odd"><td>/http/response/json/demo1.json</td>
<td>A sample JSON response returned by demo mocks</td>
</tr>
<tr class="row-even"><td>/http/response/json/demo2.json</td>
<td>″</td>
</tr>
<tr class="row-odd"><td>/pem/ca.cert.pem</td>
<td>CA certificate signing server certificate if using TLS.
Also, if running in <em>http-tls-client-certs</em> mode, client certificates must be signed by CA(s)
whose certificates are in this file.</td>
</tr>
<tr class="row-even"><td>/pem/client.key-cert.pem</td>
<td>Reserved for future use</td>
</tr>
<tr class="row-odd"><td>/pem/server.cert.pem</td>
<td>Server certificate if using TLS</td>
</tr>
<tr class="row-even"><td>/pem/server.key.pem</td>
<td>Server private key if using TLS</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="s-configuring-http-mocks">
<span id="configuring-http-mocks"/><h2>Configuring HTTP mocks</h2>
<p>Assuming an apimox environment in <em>~/projects/my-apimox/</em> the main config file used to configure HTTP servers will be located
in <em>~/projects/my-apimox/http/config.ini</em>. It's an INI-style file with each section containing details of an individual mock
along with the <em>[apimox]</em> section containing top-level configuration pertaining to all mocks.</p>
<p>A sample config.ini may look like below:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>apimox<span class="o">]</span>
<span class="nv">host</span><span class="o">=</span>0.0.0.0
<span class="nv">http_plain_port</span><span class="o">=</span>44333
<span class="nv">http_tls_port</span><span class="o">=</span>44555
<span class="nv">http_tls_client_certs_port</span><span class="o">=</span>44777
<span class="nv">log_level</span><span class="o">=</span>INFO
<span class="nv">log_file_plain</span><span class="o">=</span>plain_http.log
<span class="nv">log_file_tls</span><span class="o">=</span>tls_http.log
<span class="nv">log_file_tls_client_certs</span><span class="o">=</span>client_certs_tls_http.log
<span class="nv">include</span><span class="o">=</span>customer1.ini, customer2.ini

<span class="o">[</span>Get Customer 02<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">qs_cust_id</span><span class="o">=</span>1
<span class="nv">response</span><span class="o">=</span>cust-get.json
<span class="nv">resp_header_MyHeader</span><span class="o">=</span>MyValue

<span class="o">[</span>Update Customer 02<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">qs_cust_id</span><span class="o">=</span>
<span class="nv">method</span><span class="o">=</span>POST
<span class="nv">response</span><span class="o">=</span><span class="s1">'{"status":"OK"}'</span>
<span class="nv">resp_headers</span><span class="o">=</span>common.txt

<span class="o">[</span>Get Customer Phone<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/phone/by-name/<span class="o">{</span>name<span class="o">}</span>/
<span class="nv">response</span><span class="o">=</span><span class="s1">'{"number":"777-11-22-33"}'</span>
</pre></div>
</div>
<p>The file above configures settings common across all the mocks in the in [apimox] section. Two mocks follow.</p>
<p>The first mock will return a response from the <em>cust-get.json</em> file as long as URL path is <em>/customer</em> and <em>cust_id</em>
in query string is equal to <em>1</em> and HTTP method is <em>GET</em> (default method used for matching).
A custom header will be set in response.</p>
<p>The second one will return the response provided inline as long as the URL path is as above, query string contains <em>cust_id</em>
of any value plus the HTTP method is 'POST'. A list of one or more custom headers will be read from a file and returned in
response.</p>
<p>The last one responds to GET requests matching the <em>/customer/name/{last_name}</em> pattern in URL path, for instance,
both <em>/phone/by-name/Smith/</em> and <em>/phone/by-name/李/</em> will trigger the last mock.</p>
<p>Invoking it with curl now:</p>
<div class="highlight-bash"><pre>$ curl localhost:44333/customer?cust_id=1
{"cust_id":1, "first_name":"Hello", "last_name":"World"}
$</pre>
</div>
<div class="highlight-bash"><pre>$ curl -XPOST localhost:44333/customer?cust_id=2
{"status":"OK"}
$</pre>
</div>
<div class="highlight-bash"><pre>$ curl -XPOST localhost:44333/customer?cust_id=1
{"status":"OK"}
$</pre>
</div>
<div class="highlight-bash"><pre>$ curl localhost:44333/phone/by-name/Smith/
{"number":"777-11-22-33"}
$</pre>
</div>
<div class="highlight-bash"><pre>$ curl localhost:44333/phone/by-name/李/
{"number":"777-11-22-33"}
$</pre>
</div>
<p>What happens if no mock matches the incoming request? HTTP 412 'Precondition failed' is returned to the caller:</p>
<div class="highlight-text"><div class="highlight"><pre>  $ curl -v localhost:44333/address/by-name/Smith/
  * Connected to localhost (127.0.0.1) port 44333 (#0)
  &gt; GET /address/by-name/Smith/ HTTP/1.1
  &gt; User-Agent: curl/7.35.0
  &gt; Host: localhost:44333
  &gt; Accept: */*
  &gt;
<span class="hll">  &lt; HTTP/1.1 412 Precondition Failed
</span>  &lt; Content-Type: text/plain
  &lt; Date: Mon, 28 Sep 2015 11:17:36 GMT
  &lt; Content-Length: 23
  &lt;
<span class="hll">  No matching mock found
</span>  * Connection #0 to host localhost left intact
  $
</pre></div>
</div>
<p>Likewise, HTTP 412 code will be returned if an incoming request matches more than one mock. For instance in this erroneous
config.ini file both mocks would want to react to the same set of input parameters resulting in a run-time conflict.</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>apimox<span class="o">]</span>
<span class="nv">host</span><span class="o">=</span>0.0.0.0
<span class="nv">http_plain_port</span><span class="o">=</span>44333
<span class="nv">http_tls_port</span><span class="o">=</span>44555
<span class="nv">http_tls_client_certs_port</span><span class="o">=</span>44777
<span class="nv">log_level</span><span class="o">=</span>INFO
<span class="nv">log_file_plain</span><span class="o">=</span>plain_http.log
<span class="nv">log_file_tls</span><span class="o">=</span>tls_http.log
<span class="nv">log_file_tls_client_certs</span><span class="o">=</span>client_certs_tls_http.log

<span class="o">[</span>Get Customer 02<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">qs_cust_id</span><span class="o">=</span>1
<span class="nv">response</span><span class="o">=</span>cust-get.json

<span class="o">[</span>Get Customer 02<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">qs_cust_id</span><span class="o">=</span>1
<span class="nv">response</span><span class="o">=</span>cust-get.json
</pre></div>
</div>
<div class="highlight-text"><div class="highlight"><pre>  $ curl -v http://localhost:44333/customer?cust_id=1
  * Connected to localhost (127.0.0.1) port 44333 (#0)
  &gt; GET /customer?cust_id=1 HTTP/1.1
  &gt; User-Agent: curl/7.35.0
  &gt; Host: localhost:44333
  &gt; Accept: */*
  &gt;
<span class="hll">  &lt; HTTP/1.1 412 Precondition Failed
</span>  &lt; Content-Type: text/plain
  &lt; Date: Mon, 28 Sep 2015 11:23:59 GMT
  &lt; Content-Length: 71
  &lt;
<span class="hll">  Multiple mocks matched request: ['Get Customer 01', 'Get Customer 02']
</span>  * Connection #0 to host localhost left intact
  $
</pre></div>
</div>
<div class="section" id="s-http-examples">
<span id="http-examples"/><h3>HTTP Examples</h3>
<div class="section" id="s-match-url-path">
<span id="match-url-path"/><h4>Match URL path</h4>
<p><em>url_path</em> is used to match URL paths in incoming requests. It can be either hard-coded or make use of catch-all patterns.</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Get Customer 01<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">response</span> <span class="o">=</span> <span class="s1">'"Cust 1"'</span>

<span class="o">[</span>Get Customer 02<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer/<span class="o">{</span>id<span class="o">}</span>
<span class="nv">response</span> <span class="o">=</span> <span class="s1">'"Cust N"'</span>
</pre></div>
</div>
<div class="highlight-bash"><pre>$ curl  http://localhost:44333/customer
"Cust 1"
$</pre>
</div>
<div class="highlight-bash"><pre>$ curl  http://localhost:44333/customer/123
"Cust N"
$</pre>
</div>
<div class="highlight-bash"><pre>$ curl  http://localhost:44333/customer/456
"Cust N"
$</pre>
</div>
</div>
<div class="section" id="s-match-query-string-parameters">
<span id="match-query-string-parameters"/><h4>Match query string parameters</h4>
<p>Each mock may contain zero or more query string-related keys beginning with <em>qs_</em> so that <em>qs_cust_id</em>, <em>qs_first_name</em> indicate,
respectively, <em>?cust_id=</em> and <em>?first_name=</em> elements in request.</p>
<p>If a qs_ element is provided with no value its mere existence in the request will match a given mock. If a value is given it will
have priority over qs_ elements without values.</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Get Customer 01<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">qs_first_name</span><span class="o">=</span>
<span class="nv">response</span> <span class="o">=</span> <span class="s1">'"Cust 1"'</span>

<span class="o">[</span>Get Customer 02<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">qs_first_name</span><span class="o">=</span>Jack
<span class="nv">response</span> <span class="o">=</span> <span class="s1">'"Cust N"'</span>

<span class="o">[</span>Get Customer 3<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">qs_first_name</span><span class="o">=</span>Jack
<span class="nv">qs_last_name</span><span class="o">=</span>Miller
<span class="nv">response</span> <span class="o">=</span> <span class="s1">'"Cust Z"'</span>
</pre></div>
</div>
<div class="highlight-bash"><pre>$ curl http://localhost:44333/customer?first_name=Foo
"Cust 1"
$</pre>
</div>
<div class="highlight-bash"><pre>$ curl http://localhost:44333/customer?first_name=Jack
"Cust N"
$</pre>
</div>
<div class="highlight-bash"><pre>$ curl "http://localhost:44333/customer?first_name=Jack&amp;last_name=Miller"
"Cust Z"
$</pre>
</div>
</div>
<div class="section" id="s-match-method">
<span id="match-method"/><h4>Match method</h4>
<p>Use the <em>method</em> key to match HTTP request methods. By default, <em>GET</em> is used unless overridden in a given config.ini's stanza.</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Get Customer<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">qs_cust_id</span><span class="o">=</span>1
<span class="nv">response</span> <span class="o">=</span> <span class="s1">'{"cust_name":"Jack"}'</span>

<span class="o">[</span>Patch Customer<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">qs_cust_id</span><span class="o">=</span>1
<span class="nv">method</span><span class="o">=</span>PATCH
<span class="nv">response</span> <span class="o">=</span> <span class="s1">'"OK, updated"'</span>

<span class="o">[</span>Delete Customer<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">qs_cust_id</span><span class="o">=</span>1
<span class="nv">method</span><span class="o">=</span>DELETE
<span class="nv">response</span> <span class="o">=</span> <span class="s1">'"OK, deleted"'</span>
</pre></div>
</div>
<div class="highlight-bash"><pre>$ curl http://localhost:44333/customer?cust_id=1
{"cust_name":"Jack"}
$</pre>
</div>
<div class="highlight-bash"><pre>$ curl -XPATCH http://localhost:44333/customer?cust_id=1
"OK, updated"
$</pre>
</div>
<div class="highlight-bash"><pre>$ curl -XDELETE http://localhost:44333/customer?cust_id=1
"OK, deleted"
$</pre>
</div>
</div>
<div class="section" id="s-return-inline-responses">
<span id="return-inline-responses"/><h4>Return inline responses</h4>
<p>If the <em>response</em> key's value starts with a single quote <em>'</em>, the value response will be sent in response as-is,
bar single quotes at the beginning and end of the value.</p>
<p>Content-type header is set to <em>application/json</em> and <em>text/xml</em>, depending on whether it's JSON or XML to be returned, respectively</p>
<p>The second character of the value needs to be one of <em>{ " [</em> or any digit for it to be considered JSON.
With XML, the second character must be an angle bracket <em>&lt;</em>.</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Get Customer JSON<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">qs_cust_id</span><span class="o">=</span>1
<span class="nv">qs_format</span><span class="o">=</span>json
<span class="nv">response</span> <span class="o">=</span> <span class="s1">'{"hello":"there"}'</span>

<span class="o">[</span>Get Customer XML<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">qs_cust_id</span><span class="o">=</span>1
<span class="nv">qs_format</span><span class="o">=</span>xml
<span class="nv">response</span> <span class="o">=</span> <span class="s1">'&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;hello&gt;there&lt;/hello&gt;'</span>
</pre></div>
</div>
</div>
<div class="section" id="s-return-json-and-xml-responses-from-files">
<span id="return-json-and-xml-responses-from-files"/><h4>Return JSON and XML responses from files</h4>
<p>If a response is not provided inline, its value is obtained from a file whose extension points to a directory in the mock
environment.</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Get Customer JSON<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">qs_cust_id</span><span class="o">=</span>1
<span class="nv">qs_format</span><span class="o">=</span>json
<span class="nv">response</span> <span class="o">=</span> cust.json

<span class="o">[</span>Get Customer XML<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">qs_cust_id</span><span class="o">=</span>1
<span class="nv">qs_format</span><span class="o">=</span>xml
<span class="nv">response</span> <span class="o">=</span> cust.xml
</pre></div>
</div>
<div class="highlight-text"><div class="highlight"><pre>      ~/projects/my-apimox/
      ├── http
      │   └── response
<span class="hll">      │       ├── json
</span>      │       │   └── cust.json
<span class="hll">      │       └── xml
</span>      │           └── cust.xml
</pre></div>
</div>
<p>Now because of their extensions, cust.json is read <em>http/response/json</em> from whereas cust.xml is returned from
<em>http/response/xml</em> sub-directories of the environment in <em>~/projects/my-apimox/</em>.</p>
</div>
<div class="section" id="s-return-arbitrary-responses-from-files">
<span id="return-arbitrary-responses-from-files"/><h4>Return arbitrary responses from files</h4>
<p>Any file can be returned as long as its extension matches a directory existing in an environment's <em>http/response</em> directory.
For instance, to return CSV from <em>cust.csv</em> that file must exist in <em>http/response/csv</em>, as below:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Get Customer CSV<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">qs_cust_id</span><span class="o">=</span>1
<span class="nv">response</span> <span class="o">=</span> cust.csv
</pre></div>
</div>
<div class="highlight-text"><div class="highlight"><pre>      ~/projects/my-apimox/
      ├── http
      │   └── response
<span class="hll">      │       ├── csv
</span>      │       │   └── cust.csv
      │       ├── json
      │       └── xml
</pre></div>
</div>
</div>
<div class="section" id="s-set-status-code">
<span id="set-status-code"/><h4>Set status code</h4>
<p>Use <em>status</em> key to set a status code required in response, for instance:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Get Customer<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">status</span> <span class="o">=</span> 501
<span class="nv">response</span> <span class="o">=</span> <span class="s1">'{"hello":"there"}'</span>
</pre></div>
</div>
<div class="highlight-text"><div class="highlight"><pre>  $ curl -v http://localhost:44333/customer
  * Connected to localhost (127.0.0.1) port 44333 (#0)
  &gt; GET /customer HTTP/1.1
  &gt; User-Agent: curl/7.35.0
  &gt; Host: localhost:44333
  &gt; Accept: */*
  &gt;
<span class="hll">  &lt; HTTP/1.1 501 Not Implemented
</span>  &lt; Content-Type: application/json
  &lt; Date: Mon, 28 Sep 2015 15:45:40 GMT
  &lt; Content-Length: 17
  &lt;
  * Connection #0 to host localhost left intact
  {"hello":"there"}
  $
</pre></div>
</div>
</div>
<div class="section" id="s-set-content-type">
<span id="set-content-type"/><h4>Set content type</h4>
<p>Use <em>content_type</em> key to set any  content type needed in response, for instance:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Get Customer<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">content_type</span><span class="o">=</span>text/vnd.my.content.type
<span class="nv">response</span> <span class="o">=</span> <span class="s1">'{"hello":"there"}'</span>
</pre></div>
</div>
<div class="highlight-text"><div class="highlight"><pre>  $ curl -v http://localhost:44333/customer
  * Connected to localhost (127.0.0.1) port 44333 (#0)
  &gt; GET /customer HTTP/1.1
  &gt; User-Agent: curl/7.35.0
  &gt; Host: localhost:44333
  &gt; Accept: */*
  &gt;
  &lt; HTTP/1.1 200 OK
<span class="hll">  &lt; Content-Type: text/vnd.my.content.type
</span>  &lt; Date: Mon, 28 Sep 2015 15:49:10 GMT
  &lt; Content-Length: 17
  &lt;
  * Connection #0 to host localhost left intact
  {"hello":"there"}
  $
</pre></div>
</div>
</div>

<div class="section" id="s-set-response-headers-from-files">
<span id="set-response-headers-from-files"/><h4>Set response headers from files<a class="headerlink" href="#set-response-headers-from-files" title="Permalink to this headline">¶</a></h4>
<p>If a <em>resp_headers</em> key exists in configuration it must point to a file defined in the environment's <em>http/response/txt</em> directory.
The file must be a list of one or more key/value entries, each on its own line, each key separated from the value by <em>=</em>,
such as below:</p>
<div class="highlight-bash"><div class="highlight"><pre>X-MyHeader1<span class="o">=</span>MyValue1
X-MyHeader2<span class="o">=</span>MyValue2
</pre></div>
</div>
<p>Note that <em>resp_header_*</em> entries may still override contents from <em>resp_headers</em> which is illustrated in the following
example returning <em>X-MyHeader1</em> equal to <em>MyOverriddenValue</em> because the inline value is given precedence over
the value X-MyHeader1 has in common.txt.</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Get Customer<span class="o">]</span>
<span class="nv">url_path</span><span class="o">=</span>/customer
<span class="nv">response</span> <span class="o">=</span> <span class="s1">'{"hello":"there"}'</span>
<span class="nv">resp_headers</span><span class="o">=</span>common.txt
resp_header_X-Hello<span class="o">=</span>Howdy
resp_header_X-MyHeader1<span class="o">=</span>MyOverriddenValue
</pre></div>
</div>
<div class="highlight-text"><div class="highlight"><pre>  $ curl -v http://localhost:44333/customer
  * Hostname was NOT found in DNS cache
  &gt; GET /customer HTTP/1.1
  &gt; User-Agent: curl/7.35.0
  &gt; Host: localhost:44333
  &gt; Accept: */*
  &gt;
  &lt; HTTP/1.1 200 OK
<span class="hll">  &lt; X-Hello: Howdy
</span><span class="hll">  &lt; X-MyHeader2: MyValue2
</span><span class="hll">  &lt; X-MyHeader1: MyOverriddenValue
</span>  &lt; Content-Type: application/json
  &lt; Date: Wed, 30 Sep 2015 08:04:18 GMT
  &lt; Content-Length: 17
  &lt;
  * Connection #0 to host localhost left intact
  $
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-http-config-ini-reference">
<span id="http-config-ini-reference"/><h3>HTTP config.ini reference<a class="headerlink" href="#http-config-ini-reference" title="Permalink to this headline">¶</a></h3>
<p>An HTTP config.ini always contains the section called <em>[apimox]</em> plus any number of user-defined sections each configuring a single
mock to match incoming requests with.</p>
<div class="section" id="s-apimox">
<span id="apimox"/><h4>[apimox]<a class="headerlink" href="#apimox" title="Permalink to this headline">¶</a></h4>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>apimox<span class="o">]</span>
<span class="nv">host</span><span class="o">=</span>0.0.0.0
<span class="nv">http_plain_port</span><span class="o">=</span>44333
<span class="nv">http_tls_port</span><span class="o">=</span>44555
<span class="nv">http_tls_client_certs_port</span><span class="o">=</span>44777
<span class="nv">log_level</span><span class="o">=</span>INFO
<span class="nv">log_file_plain</span><span class="o">=</span>plain_http.log
<span class="nv">log_file_tls</span><span class="o">=</span>tls_http.log
<span class="nv">log_file_tls_client_certs</span><span class="o">=</span>client_certs_tls_http.log
</pre></div>
</div>
<table class="docutils">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Key</th>
<th class="head">Default value</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>host</td>
<td>0.0.0.0</td>
<td>Host to bind to</td>
</tr>
<tr class="row-odd"><td>http_plain_port</td>
<td>44333</td>
<td>Port for plain HTTP requests</td>
</tr>
<tr class="row-even"><td>http_tls_port</td>
<td>44555</td>
<td>Port for TLS requests without client certificates</td>
</tr>
<tr class="row-odd"><td>http_tls_client_certs_port</td>
<td>44777</td>
<td>Port for TLS requests with client certificates</td>
</tr>
<tr class="row-even"><td>log_file_plain</td>
<td>plain_http.log</td>
<td>Relative to the environment's <em>http/logs</em> directory</td>
</tr>
<tr class="row-odd"><td>log_file_tls</td>
<td>tls_http.log</td>
<td>″</td>
</tr>
<tr class="row-even"><td>log_file_tls_client_certs</td>
<td>client_certs_tls_http.log</td>
<td>″</td>
</tr>
<tr class="row-odd"><td>include</td>
<td>(None)</td>
<td>Optional path or paths to additional config file(s) to include so as
to be able to split configuration into multiple files. Paths are
relative to the directory config.ini is in. If multiple paths are
given, they need to be comma-separated.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="s-user-mocks">
<span id="user-mocks"/><h4>[User mocks]<a class="headerlink" href="#user-mocks" title="Permalink to this headline">¶</a></h4>
<p>Each user-defined mock contains a list of one or more config keys. Excep for <em>url_path</em> all the keys are optional.</p>
<table class="docutils">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Key</th>
<th class="head">Required</th>
<th class="head">Default value</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>url_path</td>
<td>Yes</td>
<td>(None)</td>
<td>URL endpoint for this mock</td>
</tr>
<tr class="row-odd"><td>content_type</td>
<td>No</td>
<td>application/json</td>
<td>Content type to set in response</td>
</tr>
<tr class="row-even"><td>status</td>
<td>No</td>
<td>200</td>
<td>Status code of the response</td>
</tr>
<tr class="row-odd"><td>method</td>
<td>No</td>
<td>GET</td>
<td>Method that this mock must be invoked with</td>
</tr>
<tr class="row-even"><td>response</td>
<td>No</td>
<td>''</td>
<td>Either inlined or path to a response</td>
</tr>
<tr class="row-odd"><td>qs_*</td>
<td>No</td>
<td>(not applicable)</td>
<td>Zero or more query string parameters to match. If no value is given, any will match,
otherwise an exact match is required.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="s-request-matching">
<span id="request-matching"/><h3>Request matching<a class="headerlink" href="#request-matching" title="Permalink to this headline">¶</a></h3>
<p>The following algorith is used for matching requests against mocks.</p>
<ul class="simple">
<li>On incoming request:<ul>
<li>Iterate over all mocks defined and:<ul>
<li>If <em>url_path</em> doesn't match, ignore the mock</li>
<li>If <em>method</em> doesn't match, ignore the mock</li>
</ul>
</li>
<li>If there are any URL parameters provided on input:<ul>
<li>Add 200 points of matching score if config requires that exact query parameter and value (e.g. <em>qs_cust_id=1</em>)</li>
<li>Add 1 point of matching score if config requires that exact query parameter with any value (e.g. <em>qs_cust_id=</em>)</li>
<li>Add 200 points of matching score if config requires a query parameter of exact value and it wasn't given on input</li>
<li>Add 200 points of matching score if config requires a query parameter of any value and it wasn't given on input</li>
</ul>
</li>
<li>The mock with the higest score is used to produce response</li>
<li>If no mock matches the request or if more than one mock ends up with the highest score, HTTP 412 Precondition Failed is returned.</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="s-configuring-zeromq-mocks">
<span id="configuring-zeromq-mocks"/><h2>Configuring ZeroMQ mocks<a class="headerlink" href="#configuring-zeromq-mocks" title="Permalink to this headline">¶</a></h2>
<p>Assuming an apimox environment in ~/projects/my-apimox/ the main config file used to configure ZeroMQ
servers will be located in ~/projects/my-apimox/zmq/config.ini. It's an INI-style file whose only section is <em>[apimox]</em>.</p>
<p>A sample config.ini may look like below:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>apimox<span class="o">]</span>
<span class="nv">host</span><span class="o">=</span>0.0.0.0
<span class="nv">pull_port</span><span class="o">=</span>55000
<span class="nv">sub_port</span><span class="o">=</span>55111
<span class="nv">sub_prefix</span><span class="o">=</span>
<span class="nv">log_level</span><span class="o">=</span>INFO
<span class="nv">log_file_pull</span><span class="o">=</span>pull_zmq.log
<span class="nv">log_file_sub</span><span class="o">=</span>sub_zmq.log
</pre></div>
</div>
<p>Unlike with HTTP, there are no user-defined sections in ZeroMQ mocks and servers are completely asynchronous whose sole purpose
is to store incoming requests on stdout and in log files.</p>
<p>The same config file can be used for both PULL and SUB sockets - simply start apimox with either <em>zmq-pull</em> or <em>zmq-sub</em> type,
possibly setting a subscription prefix (<em>sub_prefix</em> in config.ini) for the latter one.
as below:</p>
<div class="highlight-bash"><pre>$ apimox run ~/projects/my-apimox/ -t zmq-pull
INFO - ZMQ PULL listening on tcp://0.0.0.0:55000
$</pre>
</div>
<div class="highlight-bash"><pre>$ apimox run ~/projects/my-apimox/ -t zmq-sub
INFO - ZMQ SUB (prefix: None) listening on tcp://0.0.0.0:55111
$</pre>
</div>
<div class="highlight-bash"><pre>$ apimox run ~/projects/my-apimox/ -t zmq-sub
INFO - ZMQ SUB (prefix: my.prefix) listening on tcp://0.0.0.0:55111
$</pre>
</div>
</div>
</div>


          </div></body></html>