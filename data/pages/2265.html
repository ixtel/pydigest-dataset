<html><body><div><div class="clear padding-top-small">
                        <p><em>This is a guest post by <a href="https://www.linkedin.com/in/cassonstallings" target="_blank">Casson Stallings</a>. The project (code, data, and results) is <a href="https://app.dominodatalab.com/CassonStallings/bootstraps">publicly available on Domino</a>.</em></p>

<h2 id="errorboundsorlackthereof">Error bounds, or lack thereof</h2>

<p>Calculating error bounds on metrics derived from very large data sets has been problematic for a number of reasons. In more traditional statistics one can put a confidence interval or error bound on most metrics (e.g., mean), parameters (e.g., slope in a regression), or classifications (e.g., confusion matrix and the Kappa statistic). </p>

<p>For many machine learning applications, an error bound could be very important. Consider a company developing a method of acquiring customers. Which statement gives a CEO more appropriate information on how to proceed, the answer without the error bound, or with the error bound?</p>

<blockquote>
  <p>"The average expected lifetime value of customers acquired through this channel is "<em>$25</em>" or "<em>$25 plus or minus $75.</em>"</p>
</blockquote>

<p>While I am thankfully not a CEO, I would like to know that the weakness of the analysis indicated a possible negative value. To make a clear distinction, having a wide error bound is quite different from having an analysis that is simply wrong; an error bound won't protect you from bad data, bad assumptions, or a bad model.</p>

<p>Below I'll discuss some reasons error bounds are probably not typically used in machine learning projects, introduce the bootstrap, the little-bag-of-bootstraps and its advantages. Then I will give examples of estimating the error bounds around the R<sup>2</sup> of a linear regression and the F1 score of a support vector machine classification of hand written digits.</p>

<p>A generalized version of the Python code applicable to a wide variety of problems is <a href="https://app.dominodatalab.com/CassonStallings/bootstraps/browse?">available on Domino</a>. The use of the code and these examples are described with more detail in an <a href="https://app.dominodatalab.com/CassonStallings/bootstraps/raw/b57ce5c4ad6bc22e4478c104988bc2533a05c9f7/results/little_bag_of_bootstraps.html?inline=true">IPython notebook in the project</a>.</p>

<h2 id="lackthereof">Lack thereof</h2>

<p>There are several reasons I think error bounds are not typically applied in machine learning.</p>

<ol>
<li><p>There are not formal methods for many techniques. If someone knows of a formal method for calculating a confidence interval on a neural or deep belief network I would like to know about it. </p></li>
<li><p>Most methods of calculating a confidence interval are dependent on assumptions going into the analysis. Unless one has had some statistical training (self training is fine), they are less likely to know the details of these. </p></li>
<li><p>Projects using machine learning often proceed in an informal and exploratory manner which doesn't lend itself well to the calculation of formal confidence intervals. </p></li>
<li><p>When using big data, it maybe that the additional effort of calculating an error bound is simply too great. </p></li>
<li><p>In some cases, especially with very large samples, statistical significance is easily obtained, but doesn't mean that the model is useful.</p></li>
<li><p>The dimensionality of data used is often greater than statisticians conceived of when developing most statistical methods. </p></li>
</ol>

<p>I suspect that in some cases error bounds could be calculated, but are not reported simply because it is not the norm. I am open to alternate opinions though.</p>

<h2 id="bootstrapping">Bootstrapping</h2>

<p>Bootstrapping is a method of deriving an accuracy or distributional measures based on an approximate representative sample. It is a resampling technique where repetitive resamples with replacement are taken from the available data and used in calculating the desired metric. One can look to the seminal paper by Efron (1973) or many other publications describing basic bootstrapping and its variations. Bootstrapping is very compute intensive, requiring many iterations of the calculations on a potentially large portion of the data.</p>

<p>For our purposes then, it is a method of calculating a metric and error bounds on a distribution of which we only have sample.</p>

<h2 id="errorboundswithlittlebagofbootstraps">Error bounds with Little-Bag-Of-Bootstraps</h2>

<p><a href="#references">Kleiner et. al.</a> published two papers on the 'Little-Bag-Of-Bootstraps' (LBOB), a scalable bootstrap for massive data. This is a variation on traditional bootstrapping which is more amenable to use on very large data sets and easier to distribute across machines. They compared LBOB to more traditional bootstrapping and showed that it converged on correct error bounds quickly and more consistently than other bootstrapping methods.</p>

<p>Kleiner et. al. use a two-stage bootstrapping technique. In the first or outer bootstrap, a sample is taken without replacement. This sample is passed to a second stage or inner bootstrap which samples repeatedly with replacement. The inner sample size is equivalent in size to the full data set. A metric or score is calculated on each of the inner samples. The metric may be a mean, standard deviation, R<sup>2</sup>, F1, AUC, or one of many others. The metrics calculated on each inner sample are aggregated, usually averaged. This value is passed back to the outer loop. The outer loop then continues the process. When the outer loop is done it may have 3 to 50 or more estimates of the metric. Typically then, the average is taken as an estimate of the 'true' metric, and the 5th and 95th percentiles of the estimates form the likely bounds.</p>

<p>One of the key's to making this efficient is that inner sample can use a frequency weighted sample. Essentially this allows the full data set to be represented by many fewer actual values. Any routine that accepts a frequency weighted data set can take advantage of this. Many metrics or scoring routines will accept data in this form (e.g., many of scikit learn's <code>score()</code> functions).</p>

<h3 id="amotivatingexamplewithblogfeedback">A Motivating example with BlogFeedback</h3>

<p>I'll use the little-bag-of-bootstraps to estimate the likely blog feedback using a subset of the BlogFeedback data set. These were put together by Krisztian Buza and were downloaded from the University of California, Irvine <a href="https://archive.ics.uci.edu/ml/datasets/BlogFeedback">Machine Learning Repository</a> (Bache &amp; Lichman, 2013). It is also in the <a href="https://app.dominodatalab.com/CassonStallings/bootstraps/browse/feedback">'feedback' subdirectory</a> in the Domino project. For a minute, pretend the data set is <strong>sooo big</strong> that we simply can't process it all. We would, however, like to know how well our predictor works. Initially, a regression will be developed with only the first 20% of the data. The result will be evaluated using the little-bag-of-bootstraps which can estimate the actual value and some bounds on that value.</p>

<p>Estimation of coefficient of determination (R<sup>2</sup>) using out-of-sample testing data. The estimate is 0.3112 with a likely range from 0.129 to 0.5193</p>

<p>Actual score using 90% of data for training and 10% for testing: 0.3476</p>

<p>While the results are stochastic, the 'true' R<sup>2</sup> from the full data set is always within the bounds identified from the little-bag-of-bootstraps, at least when I have run it. If anything, the bounds 5th and 95th percentiles used by default are are a little loose. This is easily changed.</p>

<h3 id="howthealgorithmworks">How the algorithm works</h3>

<p>Internally, the little-bag-of-bootstraps generates repeated samples of the score it is going to calculate. These scores can be accessed after running the evaluation using <code>lbob.scores()</code>. The number of scores will equal the number of sub-samples taken. Typically one would use the mean of these as the estimate, and the 5th and 95th percentiles as bounds.</p>

<p>The histogram below shows the distribution of the individual estimates (<code>l.scores</code>) derived from each outer bootstrap or sub-sample. A standard normal distribution with 100,000 points was used and the metric being estimated is the 97.5th percentile. The results are a little blocky since there were only 10 sub-samples. The estimate is shown by the blue dashed line. The bounds on the estimate are the grey dashed lines. The true 97.5th percentile calculated on the full data set is given by the thicker red line.</p>

<p><img src="/content/images/2014/12/histogram_of_975th.png" alt=""/></p>

<p>The average of the samples taken internally converge on an appropriate value. The rate of convergence depends on the sample sizes and how well behaved the distribution is. The plot below shows a number of trials predicting the mean of the standard normal distribution generated earlier. The mean value which would typically be used is the last one on each line. Note that there is some variance in this value. There is also a diminishing return as more samples are taken.</p>

<p><img src="/content/images/2014/12/convergence_on_mean.png" alt=""/></p>

<h3 id="scoringfunctions">Scoring functions</h3>

<p>The software allows you to define arbitrary scoring or metric functions. While it defaults to calculating a mean, other functions can be assigned prior to running the bootstrap.</p>

<p>Many of the scikit-learn scoring functions can take a frequency or weight vector. When this is the case you can use something like the below statements before running the bootstrap.</p>

<pre><code class="language-prettyprint lang-python"># Define classifier 
clf = linear_model.MultiTaskLasso(alpha=0.1)  
# Assign its score func 
lbob.score_func = lambda x, y, freq: clf.score(x, y, freq)  
# Run the bootstrap
lbob_big_bootstrap(lbob)  
</code></pre>

<p>You can certainly define your own scoring function and use it. When the arguments match the order and count expected, you can skip the lambda function.</p>

<pre><code class="language-prettyprint lang-python"># Define score func
def my_scoring_func(x, y, weights):  
    ... 
    return score

# Assign score func
lbob.score_func = my_scoring_func  
</code></pre>

<h3 id="afinalexample">A final example</h3>

<p>This example uses a <a href="https://archive.ics.uci.edu/ml/datasets/Optical+Recognition+of+Handwritten+Digits">handwritten digits data set</a> assembled by Alpaydin and Kaynak. It is a superset of the data in scikit-learn that one can get by running <code>sklearn.datasets.load_digits()</code>. The data represents handwritten digits as vectors of grey scale images.</p>

<p>A support vector machine with a parameter grid search is used to classify the characters. The results are evaluated using an F1 score. The classification is first carried out on the full training data set (N=3823) to get a 'true' F1. It is then carried out on subsets of different sizes. The grid search is done on each set of data separately. One weakness of this example is that the basic classification is so good that there is not much variance in its bootstrapped estimate.</p>

<p>The histogram below shows the estimates of the F1 scores using 20% of the data for training (blue bars). The red bar shows the 'true' F1 which is well within the estimated bounds shown by the gray lines.</p>

<p><img src="/content/images/2014/12/estimates_of_f1.png" alt=""/></p>

<p>I find it interesting that most of the misclassified digits do not appear to be difficult to read. The first image below is of correctly classified digits, the second of incorrectly classified digits.</p>

<p><img src="/content/images/2014/12/digits_correct.png" alt=""/></p>

<p><img src="/content/images/2014/12/digits_incorrect.png" alt=""/></p>

<pre><code>In the lists below, the top row shows how each each digit was classified and the bottom row shows the true class.  
Classification [9 1 1 1 1 9 5 9 9 9 9 9 9 8 9 8 1 0 3 8]  
True Value     [5 2 2 2 8 7 7 5 7 7 7 7 7 6 7 1 8 6 9 9]  
</code></pre>

<h2 id="usingtheproject">USING THE PROJECT</h2>

<p>This entire project is available on Domino, the <a href="https://www.dominodatalab.com">data science tool</a>. You can browse code, data and results. To clone the entire project:</p>

<ol>
<li><p>Download and install the <a href="http://help.dominodatalab.com/client">Domino client</a> </p></li>
<li><p>At a command prompt, run: <code>domino get CassonStallings/bootstraps</code></p></li>
</ol>

<hr/>

<p><em>Dr. Casson Stallings is a data science consultant who works with startups. He is an alumni of the <a href="http://www.zipfianacademy.com/">Zipfian Academy</a> and in a past life he applied spatial and quantitative analyses to a broad range of environmental studies.</em></p>

<h2 id="references">References</h2>

<p><a name="references"/> <br/>
Bache, K. &amp; Lichman, M. (2013). <a href="http://archive.ics.uci.edu/ml">UCI Machine Learning Repository</a>. Irvine, CA: University of California, School of Information and Computer Science.</p>

<p>Efron, B. (1979) Bootstrap methods: Another look at the jackknife. Annals of Statistics, 7(1):1–26.</p>

<p>Kaynak,  C. (1995) Methods of combining multiple classifiers and their applications to handwritten digit recognition. Master's thesis, Institute of Graduate Studies in Science and Engineering, Bogazici University. (<a href="http://www.cs.cuhk.hk/~lxu/papers/journal/IEEEsmc92.PDF">This related publication</a> may be more accessible.)</p>

<p>Kleiner, A., Talwalkar, A., Sarkar, P., and Jordan, M. I. (2012) The big data bootstrap, Proceedings of the 29th Annual Conf. on Mach. Learning, Endenburgh, Scotland.</p>

<p>Kleiner, A., Talwalkar, A., Sarkar, P., and Jordan, M. I. (2012) A scalable bootstrap for massive data, May 2012. <a href="http://arxiv.org/pdf/1112.5016v2.pdf">http://arxiv.org/pdf/1112.5016v2.pdf</a></p>
                      </div>

                </div></body></html>