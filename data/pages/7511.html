<html><body><div><div class="entry-content"><p>Sometimes the <a href="http://nedbatchelder.com/blog/201011/pythonic.html">Pythonic</a> way to solve a problem changes over time.  As Python has evolved, so has the Pythonic way to count list items.</p>

<p>Let’s look at different techniques for counting the number of times things appear in a list.  While analyzing these techniques, we will <em>only</em> be looking at code style.  We’ll worry about performance later.</p>

<p>We will need some historical context to understand these different techniques.  Fortunately we live in the <code>__future__</code> and we have a time machine.  Let’s jump in our DeLorean and head to 1997.</p>

<h2>if Statement</h2>

<p>It’s January 1, 1997 and we’re using Python 1.4.  We have a list of colors and we’d love to know how many times each color occurs in this list.  Let’s use <a href="https://docs.python.org/release/1.4/lib/node13.html">a dictionary</a>!</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s">"brown"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">,</span> <span class="s">"green"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"black"</span><span class="p">]</span>
</span><span class="line"><span class="n">color_counts</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class="line"><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
</span><span class="line">    <span class="k">if</span> <span class="n">color_counts</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
</span><span class="line">        <span class="n">color_counts</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">color_counts</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class="line">    <span class="k">else</span><span class="p">:</span>
</span><span class="line">        <span class="n">color_counts</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Note:</strong> we’re not using <code>+=</code> because augmented assignment won’t be added until <a href="https://www.python.org/dev/peps/pep-0203/">Python 2.0</a> and we’re not using the <code>c in color_counts</code> idiom because that won’t be invented until <a href="https://docs.python.org/release/2.2/lib/typesmapping.html">Python 2.2</a>!</p>

<p>After running this we’ll see that our <code>color_counts</code> dictionary now contains the counts of each color in our list:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="pycon"><span class="line"><span class="gp">&gt;&gt;&gt; </span><span class="n">color_counts</span>
</span><span class="line"><span class="go">{'brown': 3, 'yellow': 2, 'green': 1, 'black': 1, 'red': 1}</span>
</span></code></pre></td></tr></table></div></figure>


<p>That was pretty simple.  We just looped through each color, checked if it was in the dictionary, added the color if it wasn’t, and incremented the count if it was.</p>

<p>We could also write this as:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s">"brown"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">,</span> <span class="s">"green"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"black"</span><span class="p">]</span>
</span><span class="line"><span class="n">color_counts</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class="line"><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
</span><span class="line">    <span class="k">if</span> <span class="ow">not</span> <span class="n">color_counts</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
</span><span class="line">        <span class="n">color_counts</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class="line">    <span class="n">color_counts</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">color_counts</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>This might be a little slower on sparse lists (lists with lots of non-repeating colors) because it executes two statements instead of one, but we’re not worried about performance, we’re worried about code style.  After some thought, we decide to stick with this new version.</p>

<h2>try Block</h2>

<p>It’s January 2, 1997 and we’re still using Python 1.4.  We woke up this morning with a sudden realization: our code is practicing “Look Before You Leap” (<a href="https://docs.python.org/2/glossary.html#term-lbyl">LBYL</a>) when we should be practicing “Easier to Ask Forgiveness, Than Permission” (<a href="https://docs.python.org/2/glossary.html#term-eafp">EAFP</a>) because EAFP is more Pythonic.  Let’s refactor our code to use a try-except block:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s">"brown"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">,</span> <span class="s">"green"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"black"</span><span class="p">]</span>
</span><span class="line"><span class="n">color_counts</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class="line"><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
</span><span class="line">    <span class="k">try</span><span class="p">:</span>
</span><span class="line">        <span class="n">color_counts</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">color_counts</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class="line">    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
</span><span class="line">        <span class="n">color_counts</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now our code attempts to increment the count for each color and if the color isn’t in the dictionary, a <code>KeyError</code> will be raised and we will instead set the color count to 1 for the color.</p>

<h2>get Method</h2>

<p>It’s January 1, 1998 and we’ve upgraded to Python 1.5.  We’ve decided to refactor our code to use the <a href="https://docs.python.org/release/1.5/lib/node13.html">new <code>get</code> method on dictionaries</a>:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s">"brown"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">,</span> <span class="s">"green"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"black"</span><span class="p">]</span>
</span><span class="line"><span class="n">color_counts</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class="line"><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
</span><span class="line">    <span class="n">color_counts</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">color_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now our code loops through each color, gets the current count for the color from the dictionary, defaulting this count to <code>0</code>, adds <code>1</code> to the count, and sets the dictionary key to this new value.</p>

<p>It’s cool that this is all one line of code, but we’re not entirely sure if this is more Pythonic.  We decide this might be too clever so we revert this change.</p>

<h2>setdefault</h2>

<p>It’s January 1, 2001 and we’re now using Python 2.0!  We’ve heard that <a href="https://docs.python.org/release/2.0/lib/typesmapping.html">dictionaries have a <code>setdefault</code> method now</a> and we decide to refactor our code to use this new method.  We also decide to use the new <code>+=</code> augmented assignment operator:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s">"brown"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">,</span> <span class="s">"green"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"black"</span><span class="p">]</span>
</span><span class="line"><span class="n">color_counts</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class="line"><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
</span><span class="line">    <span class="n">color_counts</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">    <span class="n">color_counts</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>setdefault</code> method is being called on every loop, regardless of whether it’s needed, but this does seem a little more readable.  We decide that this is more Pythonic than our previous solutions and commit our change.</p>

<h2>fromkeys</h2>

<p>It’s January 1, 2004 and we’re using Python 2.3.  We’ve heard about a <a href="https://docs.python.org/release/2.3/lib/typesmapping.html">new <code>fromkeys</code> class method</a> on dictionaries for constructing dictionaries from a list of keys.  We refactor our code to use this new method:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s">"brown"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">,</span> <span class="s">"green"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"black"</span><span class="p">]</span>
</span><span class="line"><span class="n">color_counts</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line"><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
</span><span class="line">    <span class="n">color_counts</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>This creates a new dictionary using our colors as keys, with all values set to <code>0</code> initially.  This allows us to increment each key without worrying whether it has been set.  We’ve removed the need for any checking or exception handling which seems like an improvement.  We decide to keep this change.</p>

<h2>Comprehension and set</h2>

<p>It’s January 1, 2005 and we’re using Python 2.4.  We realize that we could solve our counting problem using sets (<a href="https://docs.python.org/release/2.3/lib/module-sets.html">released in Python 2.3</a> and made into <a href="https://docs.python.org/release/2.4/lib/types-set.html">a built-in in 2.4</a>) and list comprehensions (<a href="https://www.python.org/dev/peps/pep-0202/">released in Python 2.0</a>).  After further thought, we remember that <a href="https://www.python.org/dev/peps/pep-0289/">generator expressions</a> were also just released in Python 2.4 and we decide to use one of those instead of a list comprehension:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s">"brown"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">,</span> <span class="s">"green"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"black"</span><span class="p">]</span>
</span><span class="line"><span class="n">color_counts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">colors</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">colors</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Note</strong>: we didn’t use a dictionary comprehension because those won’t be invented until <a href="https://www.python.org/dev/peps/pep-0274/">Python 2.7</a>.</p>

<p>This works.  It’s one line of code.  But is it Pythonic?</p>

<p>We remember the <a href="https://www.python.org/dev/peps/pep-0020/">Zen of Python</a>, which <a href="https://mail.python.org/pipermail/python-list/1999-June/001951.html">started in a python-list email thread</a> and was <a href="http://svn.python.org/view/python/tags/r221/Lib/this.py?revision=25249&amp;view=markup">snuck into Python 2.2.1</a>.  We type <code>import this</code> at our REPL:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="pycon"><span class="line"><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">this</span>
</span><span class="line"><span class="go">The Zen of Python, by Tim Peters</span>
</span><span class="line">
</span><span class="line"><span class="go">Beautiful is better than ugly.</span>
</span><span class="line"><span class="go">Explicit is better than implicit.</span>
</span><span class="line"><span class="go">Simple is better than complex.</span>
</span><span class="line"><span class="go">Complex is better than complicated.</span>
</span><span class="line"><span class="go">Flat is better than nested.</span>
</span><span class="line"><span class="go">Sparse is better than dense.</span>
</span><span class="line"><span class="go">Readability counts.</span>
</span><span class="line"><span class="go">Special cases aren't special enough to break the rules.</span>
</span><span class="line"><span class="go">Although practicality beats purity.</span>
</span><span class="line"><span class="go">Errors should never pass silently.</span>
</span><span class="line"><span class="go">Unless explicitly silenced.</span>
</span><span class="line"><span class="go">In the face of ambiguity, refuse the temptation to guess.</span>
</span><span class="line"><span class="go">There should be one-- and preferably only one --obvious way to do it.</span>
</span><span class="line"><span class="go">Although that way may not be obvious at first unless you're Dutch.</span>
</span><span class="line"><span class="go">Now is better than never.</span>
</span><span class="line"><span class="go">Although never is often better than *right* now.</span>
</span><span class="line"><span class="go">If the implementation is hard to explain, it's a bad idea.</span>
</span><span class="line"><span class="go">If the implementation is easy to explain, it may be a good idea.</span>
</span><span class="line"><span class="go">Namespaces are one honking great idea -- let's do more of those!</span>
</span></code></pre></td></tr></table></div></figure>


<p>Our code is <em>more complex</em> (<strong>O(n<sup>2</sup>)</strong> instead of <strong>O(n)</strong>), <em>less beautiful</em>, and <em>less readable</em>.  That change was a fun experiment, but this one-line solution is <strong>less Pythonic</strong> than what we already had.  We decide to revert this change.</p>

<h2>defaultdict</h2>

<p>It’s January 1, 2007 and we’re using Python 2.5.  We’ve just found out that <a href="https://docs.python.org/release/2.5/lib/defaultdict-objects.html"><code>defaultdict</code> is in the standard library</a> now.  This should allow us to set <code>0</code> as the default value in our dictionary.  Let’s refactor our code to count using a <code>defaultdict</code> instead:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
</span><span class="line"><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s">"brown"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">,</span> <span class="s">"green"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"black"</span><span class="p">]</span>
</span><span class="line"><span class="n">color_counts</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</span><span class="line"><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
</span><span class="line">    <span class="n">color_counts</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>That <code>for</code> loop is so simple now!  This is almost certainly more Pythonic.</p>

<p>We realize that our <code>color_counts</code> variable does act differently, however it <em>does</em> inherit from <code>dict</code> and supports all the same mapping functionality.</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="pycon"><span class="line"><span class="gp">&gt;&gt;&gt; </span><span class="n">color_counts</span>
</span><span class="line"><span class="go">defaultdict(&lt;type 'int'&gt;, {'brown': 3, 'yellow': 2, 'green': 1, 'black': 1, 'red': 1})</span>
</span></code></pre></td></tr></table></div></figure>


<p>Instead of converting <code>color_counts</code> to a <code>dict</code>, we’ll assume the rest of our code practices <a href="https://docs.python.org/2/glossary.html#term-duck-typing">duck typing</a> and leave this dict-like object as-is.</p>

<h2>Counter</h2>

<p>It’s January 1, 2011 and we’re using Python 2.7.  We’ve been told that our <code>defaultdict</code> code is no longer the most Pythonic way to count colors.  <a href="https://docs.python.org/2.7/library/collections.html#collections.Counter">A <code>Counter</code> class was included in the standard library</a> in Python 2.7 and it does all of the work for us!</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
</span><span class="line"><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s">"brown"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">,</span> <span class="s">"green"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"yellow"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"brown"</span><span class="p">,</span> <span class="s">"black"</span><span class="p">]</span>
</span><span class="line"><span class="n">color_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Could this get any simpler?  This must be the most Pythonic way.</p>

<p>Like <code>defaultdict</code>, this returns a dict-like object (a <code>dict</code> subclass actually), which should be good enough for our purposes, so we’ll stick with it.</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="pycon"><span class="line"><span class="gp">&gt;&gt;&gt; </span><span class="n">color_counts</span>
</span><span class="line"><span class="go">Counter({'brown': 3, 'yellow': 2, 'green': 1, 'black': 1, 'red': 1})</span>
</span></code></pre></td></tr></table></div></figure>


<h2>After thought: Performance</h2>

<p>Notice that we didn’t focus on efficiency for these solutions.  Most of these solutions have the same time complexity (<code>O(n)</code> in big O notation) but runtimes could vary based on the Python implementation.</p>

<p>While performance isn’t our main concern, <a href="https://gist.github.com/treyhunner/0987601f960a5617a1be">I did measure the run-times on CPython 3.5.0</a>.  It’s interesting to see how each implementation changes in relative efficiency based on the density of color names in the list.</p>

<h2>Conclusion</h2>

<p>Per the <a href="https://www.python.org/dev/peps/pep-0020/">Zen of Python</a>, “there should be one– and preferably only one– obvious way to do it”.  This is an aspirational message.  There isn’t always one obvious way to do it.  The “obvious” way can vary by time, need, and level of expertise.</p>

<p><strong>“Pythonic” is a relative term.</strong></p>

<h3>Related Resources</h3>




<h3>Credits</h3>

<p>Thanks to <a href="http://brianschrader.com/">Brian Schrader</a> and <a href="http://stackoverflow.com/users/400617/davidism">David Lord</a> for proof-reading this post and <a href="http://micah.bigprob.net/">Micah Denbraver</a> for actually <a href="https://gist.github.com/macro1/9b364612ee3907df4179">testing out these solutions</a> on the correct versions of Python.</p>
</div>




</div></body></html>