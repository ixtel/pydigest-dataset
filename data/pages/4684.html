<html><body><div><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-typecheck-decorator" class="anchor" href="#typecheck-decorator" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>typecheck-decorator</h1>

<p>Lutz Prechelt, 2014-2016, for Version 1.3</p>

<p>A decorator for functions, <code>@tc.typecheck</code>, to be used together with
Python3 annotations on function parameters and function results.
The decorator will perform dynamic argument type checking for every call to the function.</p>

<h1><a id="user-content-1-introduction-a-quick-example" class="anchor" href="#1-introduction-a-quick-example" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>1 Introduction: A quick example</h1>

<div class="highlight highlight-source-python"><pre>  <span class="pl-en">@tc.typecheck</span>
  <span class="pl-k">def</span> <span class="pl-en">foo1</span>(<span class="pl-smi">a</span>:<span class="pl-c1">int</span>, <span class="pl-smi">b</span><span class="pl-k">=</span><span class="pl-c1">None</span>, <span class="pl-smi">c</span>:<span class="pl-c1">str</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>mydefault<span class="pl-pds">"</span></span>) -&gt; <span class="pl-c1">bool</span> :
      <span class="pl-c1">print</span>(a, b, c)
      <span class="pl-k">return</span> b <span class="pl-k">is</span> <span class="pl-k">not</span> <span class="pl-c1">None</span> <span class="pl-k">and</span> a <span class="pl-k">!=</span> b</pre></div>

<p>The parts <code>:int</code>, <code>:str</code>, and <code>-&gt; bool</code> are annotations.
This is a syntactic feature introduced in Python 3 where <code>:</code> (for parameters)
and <code>-&gt;</code> (for results) are delimiters and the rest can be
an arbitrary expression.
It is important to understand that, as such,
<em>annotations do not have any semantics whatsoever</em>.
There must be explicit Python code somewhere
that looks at them and does something in order to give them a meaning.</p>

<p>The <code>@tc.typecheck</code> decorator gives the above annotations the following meaning:
<code>foo1</code>'s argument <code>a</code> must have type <code>int</code>,
<code>b</code> has no annotation and can have any type whatsoever, it will not be checked,
<code>c</code> must have type string,
and the function's result must be either
<code>True</code> (not <code>17</code> or <code>"yes"</code> or <code>[3,7,44]</code> or some such) or
<code>False</code> (not <code>0</code> or <code>None</code> or <code>[]</code> or some such) --
unless you've done unspeakable things and made Python believe in
other than those two time-tested boolean values.</p>

<p>Given these annotations, the arguments supplied in any call to <code>foo1</code>
will (roughly speaking) be evaluated with the <code>type()</code> function and
the result compared to the annotated type.</p>

<p>If any argument has the wrong type, a <code>TypeCheckError</code> exception will be raised.
Class types and collection types can be annotated as well, but that
is <em>by far</em> not the end of the story, because in this package a "type"
can be any constraint on the set of allowable values.</p>

<h1><a id="user-content-2-import-style-usage-style" class="anchor" href="#2-import-style-usage-style" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>2 Import style, usage style</h1>

<p>For clarity, the recommended import style is as follows:</p>

<div class="highlight highlight-source-python"><pre>  <span class="pl-k">import</span> typing <span class="pl-k">as</span> tg
  <span class="pl-k">import</span> typecheck <span class="pl-k">as</span> tc</pre></div>

<p>The remainder of this document will assume this import style.
(Beware of <code>from typecheck import *</code> , as there are functions any() and all() 
that are likely to break your code then.)</p>

<p>As for usage style, the idea of this package is not to approximate
static type checking.
Rather, you should use <code>@tc.typecheck</code> where appropriate ("gradual typing").
Good examples for such situations might be:</p>

<ul>
<li>You want to clarify your own thinking at module design time.</li>
<li>Some callers of your package tend to be careless or ignorant
and you want to make their contract violations explicit to reduce
hassle.</li>
<li>You want to safeguard against mistakes when modifying legacy code,
so you add some typechecks first.</li>
<li>You want to record the results of heroic reverse-engineering
of legacy code.</li>
<li>You want to minimize non-code documentation.</li>
</ul>

<p>Some of your functions and methods will have annotations, many others will not.
And even for decorated functions and methods, only a subset of their
parameters may be annotated. Where appropriate.</p>

<h1><a id="user-content-3-how-it-works" class="anchor" href="#3-how-it-works" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>3 How it works</h1>

<p>At function definition time, the <code>@tc.typecheck</code> decorator converts
each annotation into a predicate function (called a <code>Checker</code>)
and stores all of these in the wrapper function.</p>

<p>At function execution time, the wrapper will
take each argument supplied to the function call,
submit it to its corresponding Checker predicate (if that exists),
and raise an exception if the Checker returns False.
The original function will be called then and its result
checked likewise if a result annotation had been provided.</p>

<h1><a id="user-content-4-the-five-sorts-of-annotation" class="anchor" href="#4-the-five-sorts-of-annotation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>4 The five sorts of annotation</h1>

<p><code>@tc.typecheck</code> allows four different kinds of annotation to
some parameter PAR:</p>

<ul>
<li><strong>Types.</strong>
The annotation is an expression returning a type, typically
just the name of a type.</li>
<li><strong>Predicates.</strong> The annotation is a function that turns the argument
into True (for an acceptable argument)
or False (for all others).
(Remember that a predicate is a function, not a function call -- but it may
be the result of a function call.)</li>
<li><strong>Tuples</strong> and <strong>Lists.</strong>
The annotation is a tuple or list (rather than a type or a predicate)
as explained below.</li>
<li><strong>Dictionaries.</strong>
The annotation is a dictionary (rather than a type or a predicate)
as explained below.</li>
<li><strong><code>typing</code> annotations.</strong>
The annotation is one of those defined in the module <code>typing</code>.
(This module was introduced in Python 3.5 and is available from 
PyPI for earlier Python 3 versions. 
We will subsequently often call it <code>tg</code>.)
This is a special case of 'Types' introduced above. 
It requires special handling internally and provides extended possibilities
externally (e.g. describing generic functions or specifying container
types with particular content types in a manner possibly understood by 
static type checking tools).
These are expected to become the standard over time because more tools
and more programmers will readily understand them than the proprietary
annotations.</li>
</ul>

<p>The following subsections explain each of these annotation types.
The same annotations are valid for function results (as opposed to parameters)
as well.</p>

<h2><a id="user-content-41-types-as-annotations" class="anchor" href="#41-types-as-annotations" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>4.1 Types as annotations</h2>

<p>The annotation is an expression for which <code>inspect.isclass</code> evaluates to True,
but which is not from the <code>tg</code> module.</p>

<p>Example:</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo2</span>(<span class="pl-smi">a</span>:<span class="pl-c1">int</span>, <span class="pl-smi">d</span>:<span class="pl-c1">dict</span>, <span class="pl-smi">l</span>:<span class="pl-c1">list</span><span class="pl-k">=</span><span class="pl-c1">None</span>) -&gt; datetime.datetime :
     <span class="pl-k">pass</span></pre></div>

<p>Instead of a type name, this could of course also be
a function call returning a type
or the name of a variable that holds a type.
Such function calls will occur only once at function definition time.
(Static type checkers may not understand them.)</p>

<p>Meaning:
If the annotation declares type <code>T</code>, the argument <code>x</code> must fulfil
<code>isinstance(x, T)</code>, so objects from subclasses of T are acceptable as well.
This same rule, that subclasses are also acceptable, holds for the other
annotation types as well.</p>

<h2><a id="user-content-42-predicates-as-annotations" class="anchor" href="#42-predicates-as-annotations" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>4.2 Predicates as annotations</h2>

<p>The annotation evaluates to a function (or in fact any callable)
that will be called with the argument <code>x</code> supplied for parameter PAR
as its only argument and must return a value that evaluates to
  <code>True</code> (for an acceptable argument <code>x</code>)
  or <code>False</code> (for all other <code>x</code>).</p>

<p>Example:</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-k">def</span> <span class="pl-en">is_even</span>(<span class="pl-smi">n</span>): <span class="pl-c1">type</span>(n) <span class="pl-k">is</span> <span class="pl-c1">int</span> <span class="pl-k">and</span> n<span class="pl-k">%</span><span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>

   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo3</span>(<span class="pl-smi">a</span>:<span class="pl-c1">int</span>) -&gt; is_even :
     <span class="pl-k">return</span> <span class="pl-c1">2</span><span class="pl-k">*</span>a</pre></div>

<p>You can define your own predicate as shown above or use one of the
predicate generators supplied with the package to create
a predicate on the fly.
(Static type checkers will usually not understand predicates.)</p>

<h2><a id="user-content-43-tuples-and-lists-as-annotations" class="anchor" href="#43-tuples-and-lists-as-annotations" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>4.3 Tuples and lists as annotations</h2>

<p>The annotation is an expression that evaluates to a tuple or list
(rather than a type or a predicate);
more precisely, it can be any <code>collections.Sequence</code> object.
This is a very pragmatic extension for programs that do not model
every little data structure as a class
but rather make heavy use of the built-in sequence types.
(Static type checkers will usually not understand such annotations.)</p>

<p>This is easiest explained by examples:</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo4</span>(<span class="pl-smi">pair</span>:(<span class="pl-c1">int</span>,<span class="pl-c1">int</span>), <span class="pl-smi">descriptor</span>:[<span class="pl-c1">int</span>, <span class="pl-c1">float</span>, <span class="pl-c1">float</span>, <span class="pl-c1">bool</span>]):
     <span class="pl-k">pass</span>
   foo4((<span class="pl-c1">1</span>,<span class="pl-c1">2</span>), [<span class="pl-c1">3</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">77.0</span>, <span class="pl-c1">True</span>])    <span class="pl-c"># OK</span>
   foo4([<span class="pl-c1">1</span>,<span class="pl-c1">2</span>], [<span class="pl-c1">3</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">77.0</span>, <span class="pl-c1">True</span>])    <span class="pl-c"># OK: list is acceptable as tuple</span>
   foo4((<span class="pl-c1">1</span>,<span class="pl-c1">2</span>), (<span class="pl-c1">3</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">77.0</span>, <span class="pl-c1">True</span>))    <span class="pl-c"># Wrong: descriptor must be list</span>
   foo4((<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>), [<span class="pl-c1">3</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">77.0</span>, <span class="pl-c1">True</span>])  <span class="pl-c"># Wrong: pair too long</span>
   foo4((<span class="pl-c1">0.0</span>,<span class="pl-c1">2</span>), [<span class="pl-c1">3</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">77.0</span>, <span class="pl-c1">True</span>])  <span class="pl-c"># Wrong: pair[0] type mismatch</span>
   foo4((<span class="pl-c1">1</span>,<span class="pl-c1">2</span>), <span class="pl-c1">None</span>)                    <span class="pl-c"># Wrong: descriptor is missing</span>

   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo5</span>(<span class="pl-smi">pair</span>:(<span class="pl-c1">int</span>,<span class="pl-c1">int</span>), <span class="pl-smi">descriptor</span>:[<span class="pl-c1">int</span>, (<span class="pl-c1">float</span>, <span class="pl-c1">float</span>), <span class="pl-c1">bool</span>]):
     <span class="pl-k">pass</span>
   foo5((<span class="pl-c1">1</span>,<span class="pl-c1">2</span>), [<span class="pl-c1">3</span>, (<span class="pl-c1">2.0</span>, <span class="pl-c1">77.0</span>), <span class="pl-c1">True</span>])  <span class="pl-c"># OK</span>
   foo5([<span class="pl-c1">1</span>,<span class="pl-c1">2</span>], [<span class="pl-c1">3</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">77.0</span>, <span class="pl-c1">True</span>])    <span class="pl-c"># Wrong: descriptor[1] type mismatch</span></pre></div>

<p>General meaning:</p>

<ul>
<li>The annotation is a sequence of length N.
Its entries could themselves each serve as an annotation.</li>
<li>The annotation will match only an argument of exactly length N.</li>
<li>The argument's i-th element must fulfil the condition implied by
the annotation's i-th element.</li>
<li>If the annotation is a list, the argument must be a list (or list subclass) object.</li>
<li>If it is a tuple, the argument can be a tuple, tuple subclass object,
list, or list subclass object.</li>
<li>If it is a subclass S of list or tuple, the same rules apply,
except only S and its subclasses are acceptable and
the plain-tuple-can-be-list special case does no longer apply.</li>
</ul>

<p><code>collections.namedtuple</code> classes produce tuple objects, so you can pass
named tuples as arguments for methods having Sequence annotations without 
problem.
Do not use a named tuple for an annotation, though, because its names
will be ignored, which is confusing and error-prone.
(You can use a namedtuple type as an annotation without problems.)</p>

<h2><a id="user-content-44-dictionaries-as-annotations" class="anchor" href="#44-dictionaries-as-annotations" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>4.4 Dictionaries as annotations</h2>

<p>The annotation is an expression that evaluates to a dictionary
(rather than a type or a predicate);
more precisely, it can be any <code>collections.Mapping</code> object.
Again, this is a pragmatic extension for programs that do not model
every little data structure as a class
but rather make heavy use of the built-in types.
The annotation prescribes a fixed set of keys and a type for
the value of each key. All keys must be present.
(Static type checkers will usually not understand such annotations.)</p>

<p>Examples:</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo6</span>(<span class="pl-smi">point</span>:<span class="pl-c1">dict</span>(<span class="pl-v">x</span><span class="pl-k">=</span><span class="pl-c1">int</span>,<span class="pl-v">y</span><span class="pl-k">=</span><span class="pl-c1">int</span>)):
     <span class="pl-k">pass</span>
   foo6(<span class="pl-c1">dict</span>(<span class="pl-v">x</span><span class="pl-k">=</span><span class="pl-c1">1</span>, <span class="pl-v">y</span><span class="pl-k">=</span><span class="pl-c1">2</span>))         <span class="pl-c"># OK</span>
   foo6({<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>:<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>:<span class="pl-c1">2</span>})         <span class="pl-c"># OK</span>
   foo6(collections.UserDict(<span class="pl-v">x</span><span class="pl-k">=</span><span class="pl-c1">1</span>, <span class="pl-v">y</span><span class="pl-k">=</span><span class="pl-c1">2</span>))  <span class="pl-c"># OK</span>
   foo6(<span class="pl-c1">dict</span>(<span class="pl-v">x</span><span class="pl-k">=</span><span class="pl-c1">1</span>))              <span class="pl-c"># Wrong: key y is missing</span>
   foo6(<span class="pl-c1">dict</span>(<span class="pl-v">x</span><span class="pl-k">=</span><span class="pl-c1">1</span>, <span class="pl-v">y</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>huh?<span class="pl-pds">"</span></span>))    <span class="pl-c"># Wrong: type error for y</span>
   foo6(<span class="pl-c1">dict</span>(<span class="pl-v">x</span><span class="pl-k">=</span><span class="pl-c1">1</span>, <span class="pl-v">y</span><span class="pl-k">=</span><span class="pl-c1">2</span>, <span class="pl-v">z</span><span class="pl-k">=</span><span class="pl-c1">10</span>))   <span class="pl-c"># Wrong: key z is not allowed</span></pre></div>

<h2><a id="user-content-45-typing-annotations" class="anchor" href="#45-typing-annotations" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>4.5 <code>typing</code> annotations</h2>

<p>After the typecheck-decorator package had existed for a while,
Python 3.5 standardized a notation for type annotations via the
new module <code>typing</code>.
That notation is supported here as well.
If you do use an older version than Python 3.5, get the <code>typing</code> module
from PyPI.</p>

<p>If you only use typecheck-decorator, you can freely mix these new
notation with the older notations described above.
If you also want to apply other tools with your typechecking annotations
(e.g. tools for static typechecking),
those will be more helpful if you restrict yourself to the notations 
described in Sections 4.1 and 4.5 only.</p>

<p>Examples:</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-k">import</span> typing <span class="pl-k">as</span> tg
   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo7</span>(<span class="pl-smi">point</span>: tg.Tuple[<span class="pl-c1">int</span>, <span class="pl-c1">int</span>]):
     <span class="pl-k">pass</span>
   foo7((<span class="pl-c1">4</span>, <span class="pl-c1">2</span>))         <span class="pl-c"># OK</span>
   foo7(<span class="pl-c1">None</span>)           <span class="pl-c"># Wrong, must use tg.Optional[tg.Tuple[int,int]]</span>
   foo7((<span class="pl-c1">4</span>, <span class="pl-c1">2</span>, <span class="pl-c1">0</span>))      <span class="pl-c"># Wrong</span>
   foo7((<span class="pl-c1">4</span>, <span class="pl-c1">2.0</span>))       <span class="pl-c"># Wrong</span>
   foo7((<span class="pl-c1">4</span>, <span class="pl-c1">None</span>))      <span class="pl-c"># Wrong</span></pre></div>

<p>See the following places for documentation and examples of the possibilities:</p>

<ul>
<li>The API documentation of the <code>typing</code> module.</li>
<li>PEP 484</li>
<li>the file tc.test_tg_annotations.py
However, so far the implementation of this support is not yet complete;
see Section "Limitations" for the remaining gaps.
If you have been using <code>tc</code> for a while already or if you prefer
its proprietary notation over that of <code>tg</code>, be aware that there is one
feature in <code>tg</code> that is more powerful than previously available in <code>tc</code>: 
<code>tg.TypeVar</code> (type variables).
It is presumably (I have not tested this much, so there may be gaps)
possible to mix standard <code>tg</code> and proprietary <code>tg</code> style annotations 
freely, including type variables.</li>
</ul>

<h1><a id="user-content-5-predicate-generators" class="anchor" href="#5-predicate-generators" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>5 Predicate generators</h1>

<p>Annotating type names (other than those from <code>tg</code>) and 
fixed-length tuples does not get you very far,
because</p>

<ul>
<li>such an annotation will not accept <code>None</code>;</li>
<li>wherever you use duck typing, your "type" is defined by a set
of signatures rather than a fixed name;</li>
<li>you often would like to check for things such as "a list of strings"
for arbitrary-length lists.</li>
</ul>

<p>So you will frequently need to use a predicate to do your checking.
Implementing these each time would be cumbersome, so this package
comes along with a good basic library of such things.
To be useful, these "things" actually have to be predicate generators:
Higher-order functions that return a predicate when called.
But do not worry, their use looks perfectly straightforward eventually.</p>

<h2><a id="user-content-51-built-in-predicate-generators" class="anchor" href="#51-built-in-predicate-generators" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>5.1 Built-in predicate generators</h2>

<p>One of these, <code>optional</code>, you will surely need;
all others are a bit more specialized.
As any annotation, all of them can be used for parameters and results alike.
Here we go:</p>

<p><strong>tc.optional(annot)</strong>:</p>

<p>Takes any other annotation <code>annot</code>.
Allows all arguments that <code>annot</code> allows, plus <code>None</code>:</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo</span>(<span class="pl-smi">a</span>:<span class="pl-c1">int</span>):
     <span class="pl-k">pass</span>
   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo_opt</span>(<span class="pl-smi">a</span>:tc.optional(<span class="pl-c1">int</span>)):
     <span class="pl-k">pass</span>
   foo(<span class="pl-c1">123</span>)       <span class="pl-c"># OK</span>
   foo_opt(<span class="pl-c1">123</span>)   <span class="pl-c"># OK</span>
   foo(<span class="pl-c1">None</span>)      <span class="pl-c"># Wrong: None does not have type int</span>
   foo_opt(<span class="pl-c1">None</span>)  <span class="pl-c"># OK</span></pre></div>

<p>An equivalent alternative is <code>tg.Optional[annot]</code>.</p>

<p><strong>tc.hasattrs(*names)</strong>:</p>

<p>Type-checked duck-typing:
Takes a variable number of strings containing attribute names.
Allows all arguments that possess every one of those attributes.</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-k">class</span> <span class="pl-en">FakeIO</span>:
       <span class="pl-k">def</span> <span class="pl-en">write</span>(<span class="pl-smi"><span class="pl-smi">self</span></span>):  <span class="pl-k">pass</span>
       <span class="pl-k">def</span> <span class="pl-en">flush</span>(<span class="pl-smi"><span class="pl-smi">self</span></span>):  <span class="pl-k">pass</span>
   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo_re</span>(<span class="pl-smi">a</span>: tc.hasattrs(<span class="pl-s"><span class="pl-pds">"</span>write<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>flush<span class="pl-pds">"</span></span>)):  <span class="pl-k">pass</span>

   foo(FakeIO())       <span class="pl-c"># OK</span>
   <span class="pl-k">del</span> FakeIO.flush
   foo(FakeIO())       <span class="pl-c"># Wrong, because flush attribute is now missing</span></pre></div>

<p><strong>tc.re(regexp)</strong>:</p>

<p>Takes a string containing a regular expression.
Allows all arguments that are strings and contain (as per <code>re.search</code>)
what is described by that regular expression.
Also works for bytestrings if you use a bytestring regular expression.</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo</span>(<span class="pl-smi">hexnumber</span>: tc.re(<span class="pl-s"><span class="pl-pds">"</span>^[0-9A-F]+$<span class="pl-pds">"</span></span>)) -&gt; tc.re(<span class="pl-s"><span class="pl-pds">"</span>^[0-9]+$<span class="pl-pds">"</span></span>):
       <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>.join(<span class="pl-c1">reversed</span>(k))

   foo(<span class="pl-s"><span class="pl-pds">"</span>1234<span class="pl-pds">"</span></span>)        <span class="pl-c"># OK</span>
   foo(<span class="pl-s"><span class="pl-pds">"</span>12AB<span class="pl-pds">"</span></span>)        <span class="pl-c"># Wrong: argument OK, but result not allowed</span></pre></div>

<p><strong>tc.seq_of(annot, checkonly=4)</strong>:</p>

<p>Takes any other annotation <code>annot</code>.
Allows any argument that is a sequence
(tuple or list, in fact any <code>collections.Sequence</code>)
in which each element is allowed by <code>annot</code>.
Not all violations will be detected because, for efficiency reasons,
the check will cover only a sample of <code>checkonly</code> elements of the sequence.
This sample always includes the first and last element, the rest
is a random sample.
As an interesting special case, consider submitting a string to an 
parameter declared as <code>tc.seq_of(str)</code>. A string is a sequence.
Its elements are strings. So the call should be considered OK.
Since this is usually not what you want, <code>tc.seq_of()</code> will 
always reject a string argument in order to avoid a confusing type
of mistake.</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo_so</span>(<span class="pl-smi">s</span>: tc.seq_of(<span class="pl-c1">str</span>)):  <span class="pl-k">pass</span>

   foo_so([<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>])         <span class="pl-c"># OK</span>
   foo_so((<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>))         <span class="pl-c"># OK, a tuple</span>
   foo_so([])                 <span class="pl-c"># OK</span>
   foo_so([<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>])              <span class="pl-c"># OK</span>
   foo_so(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)                <span class="pl-c"># Wrong: not a sequence in seq_of sense</span>
   foo_so([<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>])           <span class="pl-c"># Wrong: inhomogeneous</span>
   almost_ok <span class="pl-k">=</span> <span class="pl-c1">1000</span><span class="pl-k">*</span>[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>] <span class="pl-k">+</span> [<span class="pl-c1">666</span>]
   foo_so(almost_ok)          <span class="pl-c"># Wrong: inhomogeneous, will fail</span>
   almost_ok <span class="pl-k">+=</span> [<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>]
   foo_so(almost_ok)          <span class="pl-c"># Wrong, but will fail only 0.25% of the time</span></pre></div>

<p>An equivalent alternative with fixed <code>checkonly</code>
is <code>tg.Sequence[annot]</code>.</p>

<p><strong>tc.list_of(annot, checkonly=4)</strong>:</p>

<p>Just like <code>seq_of(annot, checkonly)</code>, except that it requires the
sequence to be a <code>collections.MutableSequence</code>.</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo_lo</span>(<span class="pl-smi">s</span>: tc.list_of(<span class="pl-c1">str</span>)):  <span class="pl-k">pass</span>

   foo_so([<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>])         <span class="pl-c"># OK</span>
   foo_so((<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>))         <span class="pl-c"># Wrong: a tuple is not a MutableSequence</span></pre></div>

<p>An equivalent alternative with fixed <code>checkonly</code>
is <code>tg.MutableSequence[annot]</code>.</p>

<p><strong>tc.map_of(keys_annot, values_annot, checkonly=4)</strong>:</p>

<p>Takes two annotations <code>keys_annot</code> and <code>values_annot</code>.
Allows any argument that is a <code>collections.Mapping</code> (typically a dict)
in which each key is allowed by keys_annot and
each value is allowed by values_annot.
Not all violations will be detected because for efficiency reasons,
the check will cover only the first <code>checkonly</code> pairs returned by the
mapping's iterator.
In contrast to <code>tc.seq_of</code>, this sample is not a variable random sample.</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo_do</span>(<span class="pl-smi">map</span>: tc.map_of(<span class="pl-c1">int</span>, <span class="pl-c1">str</span>)) -&gt; tc.map_of(<span class="pl-c1">str</span>, <span class="pl-c1">int</span>):
       <span class="pl-k">return</span> { v: k  <span class="pl-k">for</span> k,v <span class="pl-k">in</span> x.items() }

   <span class="pl-k">assert</span> foo({<span class="pl-c1">1</span>: <span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>, <span class="pl-c1">2</span>: <span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>}) <span class="pl-k">==</span> {<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>: <span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>: <span class="pl-c1">2</span>}  <span class="pl-c"># OK</span>
   foo({})             <span class="pl-c"># OK: an empty dict is still a dict</span>
   foo(<span class="pl-c1">None</span>)           <span class="pl-c"># Wrong: None is not a dict</span>
   foo({<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>})     <span class="pl-c"># Wrong: violates values_annot of arg and keys_annot of result</span></pre></div>

<p>An equivalent alternative with fixed <code>checkonly</code>
is <code>tg.Mapping[annot]</code>.</p>

<p><strong>tc.enum(*values)</strong>:</p>

<p>Takes any number of arguments.
Allows any argument that is equal to any one of them
(as opposed to being an instance of one).
Effectively defines an arbitrary, ad-hoc enumeration type.</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo_ev</span>(<span class="pl-smi">arg</span>: tc.enum(<span class="pl-c1">1</span>, <span class="pl-c1">2.0</span>, <span class="pl-s"><span class="pl-pds">"</span>three<span class="pl-pds">"</span></span>, [<span class="pl-c1">1</span>]<span class="pl-k">*</span><span class="pl-c1">4</span>)): <span class="pl-k">pass</span>

   foo_ev(<span class="pl-c1">1</span>)     <span class="pl-c"># OK</span>
   foo_ev(<span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-c1">1.0</span>) <span class="pl-c"># OK</span>
   foo_ev(<span class="pl-s"><span class="pl-pds">"</span>thr<span class="pl-pds">"</span></span><span class="pl-k">+</span><span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span>)  <span class="pl-c"># OK</span>
   foo_ev([<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>])    <span class="pl-c"># OK</span>
   foo_ev(<span class="pl-c1">1.0</span>)   <span class="pl-c"># OK, because 1.0 == 1</span>
   foo_ev(<span class="pl-s"><span class="pl-pds">"</span>thr<span class="pl-pds">"</span></span>) <span class="pl-c"># Wrong: not in values list</span>
   foo_ev([<span class="pl-c1">1</span>,<span class="pl-c1">1</span>]) <span class="pl-c"># Wrong: not in values list</span></pre></div>

<p><strong>tc.range(low, high)</strong>:</p>

<p>Takes two limit values low and high that must both have
the same type (typically int or float). Will allow all arguments
having that same type and lying between (including) low and high.
The type needs not be numeric: any type supporting
<strong>le</strong> and <strong>ge</strong> with range semantics will do.</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo</span>(<span class="pl-smi">arg</span>: tc.range(<span class="pl-c1">0.0</span>, <span class="pl-c1">100.0</span>)): <span class="pl-k">pass</span>

   foo(<span class="pl-c1">0.0</span>)    <span class="pl-c"># OK</span>
   foo(<span class="pl-c1">8.4e-3</span>) <span class="pl-c"># OK</span>
   foo(<span class="pl-c1">100.0</span>)  <span class="pl-c"># OK</span>
   foo(<span class="pl-c1">1</span>)      <span class="pl-c"># Wrong: not a float</span>
   foo(<span class="pl-c1">111.0</span>)  <span class="pl-c"># Wrong: value too large</span></pre></div>

<p><strong>tc.any(*annots)</strong>:</p>

<p>Takes any number of arguments, each being a valid annotation.
Allows any argument that is allowed by any one of those annotations.
Effectively defines an arbitrary union type.
You could think of it as an n-ary <code>or</code>.</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo_any</span>(<span class="pl-smi">arg</span>: tc.any(<span class="pl-c1">int</span>, <span class="pl-c1">float</span>, tc.matches(<span class="pl-s"><span class="pl-pds">"</span>^[0-9]+$<span class="pl-pds">"</span></span>)): <span class="pl-k">pass</span>

   foo_any(<span class="pl-c1">1</span>)     <span class="pl-c"># OK</span>
   foo_any(<span class="pl-c1">2.0</span>)   <span class="pl-c"># OK</span>
   foo_any(<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>)   <span class="pl-c"># OK</span>
   foo_any(<span class="pl-s"><span class="pl-pds">"</span>4.0<span class="pl-pds">"</span></span>) <span class="pl-c"># Wrong: not allowed by any of the three partial types</span></pre></div>

<p>An equivalent alternative is <code>tg.Union[*annots]</code>.</p>

<p><strong>tc.all(*annots)</strong>:</p>

<p>Takes any number of arguments, each being a valid annotation.
Allows any argument that is allowed by every one of those annotations.
Effectively defines an arbitrary intersection type.
You could think of it as an n-ary <code>and</code>.</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-k">def</span> <span class="pl-en">complete_blocks</span>(<span class="pl-smi">arg</span>):
       <span class="pl-k">return</span> <span class="pl-c1">len</span>(arg) <span class="pl-k">%</span> <span class="pl-c1">512</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>

   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo_all</span>(<span class="pl-smi">arg</span>: tc.all(tc.any(<span class="pl-c1">bytes</span>,<span class="pl-c1">bytearray</span>), complete_blocks)): <span class="pl-k">pass</span>

   foo_all(<span class="pl-s"><span class="pl-k">b</span><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span> <span class="pl-k">*</span> <span class="pl-c1">512</span>)              <span class="pl-c"># OK</span>
   foo_all(<span class="pl-c1">bytearray</span>(<span class="pl-s"><span class="pl-k">b</span><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span> <span class="pl-k">*</span> <span class="pl-c1">1024</span>))  <span class="pl-c"># OK</span>
   foo_all(<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span> <span class="pl-k">*</span> <span class="pl-c1">512</span>)      <span class="pl-c"># Wrong: not a bytearray or bytes</span>
   foo_all(<span class="pl-s"><span class="pl-k">b</span><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span> <span class="pl-k">*</span> <span class="pl-c1">1012</span>)    <span class="pl-c"># Wrong: no complete blocks</span></pre></div>

<p><strong>tc.none(*annots)</strong>:</p>

<p>Takes any number of arguments, each being a valid annotation.
Allows any argument that is allowed by no single one of those annotations.
Effectively defines a type taboo.
You could think of it as "not any" or as "all not".</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-k">class</span> <span class="pl-en">TestCase</span>:
       <span class="pl-k">pass</span>
   <span class="pl-k">class</span> <span class="pl-en">MyCheckers</span>(<span class="pl-e">TestCase</span>):
       <span class="pl-k">pass</span>
   <span class="pl-k">class</span> <span class="pl-en">AddressTest</span>:
       <span class="pl-k">pass</span>

   <span class="pl-k">def</span> <span class="pl-en">classname_contains_Test</span>(<span class="pl-smi">arg</span>):
      <span class="pl-k">return</span> <span class="pl-c1">type</span>(arg).<span class="pl-c1">__name__</span>.find(<span class="pl-s"><span class="pl-pds">"</span>Test<span class="pl-pds">"</span></span>) <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>

   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">no_tests_please</span>(<span class="pl-smi">arg</span>: tc.none(TestCase, classname_contains_Test)): <span class="pl-k">pass</span>

   no_tests_please(<span class="pl-s"><span class="pl-pds">"</span>stuff<span class="pl-pds">"</span></span>)        <span class="pl-c"># OK</span>
   no_tests_please(TestCase())     <span class="pl-c"># Wrong: not wanted here</span>
   no_tests_please(MyCheckers())   <span class="pl-c"># Wrong: superclass not wanted here</span>
   no_tests_please(AddressTest())  <span class="pl-c"># Wrong: suspicious class name</span></pre></div>

<h2><a id="user-content-52-built-in-fixed-predicates" class="anchor" href="#52-built-in-fixed-predicates" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>5.2 Built-in fixed predicates</h2>

<p>Note that these must be used without parentheses: You need to submit
the function, not call it.</p>

<p><strong>tc.anything</strong>:</p>

<p>This is the null typecheck: Will accept any value whatsoever, including None.
The meaning is effectively the same as attaching no annotation at all,
but explicitly declaring that no restrictions are intended may be
desirable for pythonic clarity.
Note: This is equivalent to <code>tc.all()</code>, that is, all-of-nothing,
and also equivalent to <code>tc.none()</code>, that is, none-of-nothing,
but is much clearer.</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo_any</span>(<span class="pl-smi">arg</span>: tc.anything) --&gt; tc.anything:
       <span class="pl-k">pass</span>

   foo_any(<span class="pl-c1">None</span>)             <span class="pl-c"># OK</span>
   foo_any([[[[{<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>:<span class="pl-c1">True</span>}]]]]])  <span class="pl-c"># OK</span>
   foo_any(foo_any)          <span class="pl-c"># OK</span></pre></div>

<p>An equivalent alternative is <code>tg.Any</code>.</p>

<p><strong>callable</strong></p>

<p>The Python builtin predicate <code>callable()</code> is also useful
as a typechecking predicate.</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">foo_callable</span>(<span class="pl-smi">func</span>: <span class="pl-c1">callable</span>, <span class="pl-smi">msg</span>: <span class="pl-c1">str</span>):
       func(msg)

   foo_callable(<span class="pl-c1">print</span>)      <span class="pl-c"># OK</span>
   foo_callable(<span class="pl-c1">open</span>)       <span class="pl-c"># OK</span>
   foo_callable(<span class="pl-s"><span class="pl-pds">"</span>print<span class="pl-pds">"</span></span>)    <span class="pl-c"># Wrong</span></pre></div>

<p>Once supported (so far it is not), a much more powerful alternative 
for callables with fixed signatures will be
<code>tg.Callable[[*argtype_annots], returntype_annot]</code>.</p>

<h2><a id="user-content-53-custom-predicate-generators" class="anchor" href="#53-custom-predicate-generators" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>5.3 Custom predicate generators</h2>

<p>If the above library of generators is insufficient for your needs,
just write the missing ones yourself:
A predicate generator is simply a function that returns an
anonymous function with effectively the following signature:</p>

<div class="highlight highlight-source-python"><pre>  <span class="pl-k">def</span> <span class="pl-en">mypredicate</span>(<span class="pl-smi">the_argument</span>: tc.anything) -&gt; <span class="pl-c1">bool</span></pre></div>

<p>No extension API is required.</p>

<p>Here is an example:</p>

<div class="highlight highlight-source-python"><pre>   <span class="pl-c"># defining a custom predicate generator:</span>
   <span class="pl-k">def</span> <span class="pl-en">blocks</span>(<span class="pl-smi">blocksize</span>: <span class="pl-c1">int</span>) -&gt; <span class="pl-c1">bool</span> :
      <span class="pl-k">def</span> <span class="pl-en">bytes_with_blocksize</span>(<span class="pl-smi">arg</span>):
         <span class="pl-s"><span class="pl-pds">"""</span>ensures the arg is a bytearray with the given block size<span class="pl-pds">"""</span></span>
         <span class="pl-k">return</span> (<span class="pl-c1">isinstance</span>(arg, <span class="pl-c1">bytes</span>) <span class="pl-k">or</span> <span class="pl-c1">isinstance</span>(arg, <span class="pl-c1">bytearray</span>)) <span class="pl-k">and</span>
                <span class="pl-c1">len</span>(arg) <span class="pl-k">%</span> blocksize <span class="pl-k">==</span> <span class="pl-c1">0</span>
      <span class="pl-k">return</span> bytes_with_blocksize

   <span class="pl-c"># using the custom predicate generator:</span>
   <span class="pl-en">@tc.typecheck</span>
   <span class="pl-k">def</span> <span class="pl-en">transfer</span>(<span class="pl-smi">mydata</span>: blocks(<span class="pl-c1">512</span>)):  <span class="pl-k">pass</span></pre></div>

<h1><a id="user-content-6-exceptions" class="anchor" href="#6-exceptions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>6 Exceptions</h1>

<ul>
<li><p>If an argument does not fulfil the corresponding parameter annotation,
a <code>tc.InputParameterError</code> will be raised.</p></li>
<li><p>If a function result does not fulfil the corresponding annotation,
a <code>tc.ReturnValueError</code> will be raised.</p></li>
<li><p>Both of these are subclasses of  <code>tc.TypeCheckError</code>.</p></li>
<li><p>If an annotation is used that does not fit into the categories
described above, a <code>tc.TypeCheckSpecificationError</code> will be raised
at function definition time.</p></li>
</ul>

<h1><a id="user-content-7-efficiency-considerations" class="anchor" href="#7-efficiency-considerations" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>7 Efficiency considerations</h1>

<p>@tc.typecheck may appear to be expensive in terms of runtime,
but actually Python is doing shiploads of similar things
all the time.</p>

<p>There are essentially two cases where execution time will
become a real issue:</p>

<ul>
<li>An annotation on a trivial function that is being
called frequently in a tight loop.</li>
<li>Checking the types of every element of a large data structure,
when only few of those elements will actually be accessed.</li>
</ul>

<h1><a id="user-content-limitations" class="anchor" href="#limitations" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Limitations</h1>

<ul>
<li>There is currently no support for 

<ul>
<li><code>tg.Callable</code> (*)</li>
<li><code>tg.io</code> (*)</li>
<li><code>tg.re</code> (*)</li>
<li>decorator <code>@tg.no_type_check</code></li>
<li>PEP 484 "type comments"
For those marked (*), support will follow in a future version.</li>
</ul></li>
<li>Python 3 has no unbound methods anymore, therefore
binding of type variables to instances of a generic class <code>C</code>
will only be recognized heuristically: The first parameter of 
each method <code>m</code> involved must be named <code>self</code> and
the first argument of stand-alone functions must not be named <code>self</code>.</li>
<li>Type variables can only be bound to types, not to type checking predicates.</li>
<li>Type variables follow a "observed common supertype" semantics.
This means that when a type variable is checked against several different 
types over time, it will bind to the type first seen, then accept that
type as well as its subclasses, and will later rebind if checked against
a superclass. It will reject only values that are neither subclass nor
superclass values of the current binding 
(but bounds and constraints are obeyed).
This is the most sensible semantics I could think of, but may <em>appear</em> overly
liberal in some situations.</li>
<li>There is a bug in the combination of at least Python 3.4 with
PyPI typing 3.5.0.1 that makes e.g. <code>issubclass(tg.Iterable, tg.Generic)</code>
false (on the other hand, <code>issubclass(tg.Sequence, tg.Iterable)</code> is true
as it should). 
The full implications for type checking Generics are unclear,
expect some Generics type checks to <em>perhaps</em> go wrong in this configuration.</li>
<li>The contents of <code>tg.Generic</code> containers are checked only in the following
cases:

<ul>
<li>subtypes of <code>tg.Sequence</code> with exactly 1 generic parameter:
will check the first element, last element, and two random elements.</li>
<li>subtypes of <code>tg.Mapping</code> with exactly 2 generic parameters:
will check the first four pairs returned by <code>items()</code>.</li>
<li>other subtypes of <code>tg.Iterable</code>:
will check the first four elements.</li>
</ul></li>
<li>Complex <code>tg.Generic</code> cases can sometimes not be content-checked, 
because <code>tg</code> currently has no mechanism for
determining the meaning of the type variables involved.
For instance, <code>tg.ItemsView</code> has three generic parameters 
<code>(tg.T_co, tg.KT, tg.VT_co)</code>, the first of which represents the
<code>tg.Tuple[tg.KT, tg.VT_co]</code> returned by each call to the iterator -- but
how, in general (that is, for user-defined types), is a poor type checker
to know this?</li>
<li>Contrary to PEP 484, a default argument value of <code>None</code>
does not yet modify type <code>X</code> to become <code>tg.Optional[X]</code>
(although using <code>tg.get_type_hints()</code> for the implementation would 
purportedly make that easy).</li>
<li>PEP 484 forward references must so far use simple names 
(such as <code>'MyClass'</code>),
not qualified ones (such as <code>'mymodule.MyClass'</code>).
The class thus referenced may live wherever it pleases.
The forward reference string needs not be evaluable at the point
of the checked function call.
Types are checked by name comparison, not by evaluation.
This means an argument of the wrong type will pass the check if 
that wrong type has the same base name as the intended type.
Support for qualified names may or may not be added in a future version.
Checking by evaluation may or may not be added in a future version.</li>
<li>This module does not follow Section "The numeric tower"
of PEP 484, which suggests to accept <code>int</code> where <code>float</code>
is annotated. For us, these two are (so far) considered
incompatible and you will need to annotate <code>numbers.Float</code> if
you want it mix them.</li>
<li>Likewise, <code>bytearray</code> and <code>memoryview</code> are not currently
acceptable where <code>bytes</code> is declared; you currently need to
use <code>tg.ByteString</code> to mix those.</li>
<li>PEP 484 <code>tg.cast</code> does currently not check anything. 
(As long as the claim formulated by the cast
is correct, this is sufficient.)</li>
<li>The module does not read PEP 484 stub files.
(Typechecking large parts of in particular the builtins
would create performance problems anyway.)</li>
<li>The module does not support the <code>@overload</code> decorator.
If <code>@overload</code> is used, only the last declaration executed for a name 
survives, whether it is decorated or not.</li>
<li>The proprietary annotations described in Sections 4.2, 4.3, and 4.4
of the present document
do not currently conform to PEP 484, because they result in functions
rather than types; see "What about existing uses of annotations?" in PEP 484.
If you are not interested in static type checking, you can use them anyway.
A future version will likely convert them such that they result in types.</li>
<li>The <code>@tc.typecheck</code> decorator will effectively modify the Python-visible
signature of the decorated function:
Essentially, the resulting signature is always <code>(*args, **kwargs)</code>.
This will perhaps one day be changed by using the
<code>decorator</code> package or a similar technique.</li>
<li>The exception messages should be more specific, e.g. for sequences and dicts
and in particular where type variable violations are involved.</li>
</ul>

<h1><a id="user-content-version-history" class="anchor" href="#version-history" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Version history</h1>

<ul>
<li><p><strong>0.1b</strong>: 2012, Original version <code>typecheck3000.py</code> by
Dmitry Dvoinikov <a href="mailto:dmitry@targeted.org">dmitry@targeted.org</a>. See
<a href="http://www.targeted.org/python/recipes/typecheck3000.py">http://www.targeted.org/python/recipes/typecheck3000.py</a></p></li>
<li><p><strong>0.2b</strong>: 2014-03-20, prepared by Lutz Prechelt.</p>

<ul>
<li>Added documentation.</li>
<li>Fixed a number of errors in the tests that did not foresee
that annotations will be checked in a random order.</li>
<li>Added <code>setup.py</code>.</li>
<li>Replaced the not fully thought-through interpretation of iterables
by a more specialized handling of tuples and lists.</li>
<li>Renamed several of the predicate generators.
First version that was packaged and uploaded to PyPI.
<strong>Expect the API to change!</strong></li>
</ul></li>
<li><p><strong>0.3b</strong>: 2014-03-21</p>

<ul>
<li>Renamed either_value to enum</li>
<li>Renamed either_type to any</li>
<li>Renamed matches to has and made it use re.search, not re.match</li>
<li>Introduced all and none</li>
<li>Introduced a post-installation self-test, because I am not yet
sure whether it will work on other platforms and with other Python versions
Feedback is welcome!</li>
</ul></li>
<li><p><strong>1.0</strong>: 2015-01-28</p>

<ul>
<li>removed tuple_of</li>
<li>renamed sequence_of to seq_of and generalized it to collections.Sequence</li>
<li>added special case: a str will no longer be considered a seq_of(str)</li>
<li>generalized list_of to collections.Sequence</li>
<li>renamed dict_of to map_of and generalized it to collections.Mapping</li>
<li>renamed regexp matching from 'has' to 're'</li>
<li>added checkonly limit to seq_of, list_of, and map_of</li>
<li>added Mapping annotations (analogous to Sequence annotations)</li>
<li>added range</li>
<li>provided the predicates with appropriate <strong>name</strong> attributes</li>
</ul></li>
<li><p><strong>1.1</strong>:</p>

<ul>
<li>various small improvements to the documentation</li>
</ul></li>
<li><p><strong>1.2</strong>:</p>

<ul>
<li>FIX: added checking for non-kwonlyargs named arguments</li>
<li>cut the implementation and tests into several pieces</li>
</ul></li>
<li><p><strong>1.3</strong>:</p>

<ul>
<li>introduces support for annotations according to the Python 3.5
<code>typing</code> module; see Sections 4.5 and "Limitations"</li>
<li>an awkward exception rule has been dropped:
you can no longer pass a <code>collections.namedtuple</code> value
to an argument annotated with a fixed mapping.</li>
</ul></li>
</ul>

<h1><a id="user-content-further-contributors" class="anchor" href="#further-contributors" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Further contributors</h1>

<p>Benjamen Keroack <a href="mailto:bkeroack@gmail.com">bkeroack@gmail.com</a> (v1.1: PyPy test fixes, seq_of(str) hint)
Andres Osorio <a href="mailto:cosoriog@gmail.com">cosoriog@gmail.com</a> (v1.2: keyword args checking fix)</p>

<h1><a id="user-content-similar-packages" class="anchor" href="#similar-packages" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Similar packages</h1>

<ul>
<li><code>typecheck3</code> is based on the same original code of Dmitry Dvoinikov
as typecheck-decorator,
but (as of 0.1.0) lacks the tests, corrections, documentation,
and API improvements available here.</li>
<li><code>gradual</code> has a similar overall approach of using a decorator and annotations.
Compared to gradual, typecheck-decorator uses a more pragmatic approach and
is far more flexible in expressing types.
gradual as of 2015-12 has status "pre-alpha".</li>
<li><code>threecheck</code> is similar to typecheck-decorator in
approach and expressiveness, except it has (as of v1.0)
no support for the <code>typing</code> module.</li>
</ul>
</article>
  </div></body></html>