<html><body><div><div class="section">
              <h1>agithub 1.3</h1>

              


<p>The agnostic Github API. It doesn't know, and you don't care.</p><p>








`agithub` is a REST API client tailored to https://api.github.com, with
</p><p>a transparent syntax which facilitates rapid prototyping. It's code is
</p><p>lightweight: easy to understand, modify, and integrate. It's most
</p><p>salient feature is that it doesn't know the Github API — but
</p><p>that doesn't matter, since it fully supports it *anyway*.

</p><p>While browsing the
</p><p>API documentation (https://developer.github.com/v3/) you can convert
</p><p>the following

</p><p>`GET /issues/?filter=subscribed`

</p><p>into

</p><p>`g.issues.get(filter='subscribed')`

</p><p>and trust that `agithub` will do exactly what you tell it to. It doesn't
</p><p>second guess you, and it doesn't do anything behind your back. So, you
</p><p>can read the docs and immediately know how to do the examples via
</p><p>`agithub` — and get on with your life.

</p><p>Example App
</p><p>==========

</p><p>1. First, instantiate a `Github` object, passing it your username and
</p><p>   password or a token if an authenticated session is desired::


</p><p>    &gt;&gt;&gt; from agithub import Github
</p><p>    &gt;&gt;&gt; g = Github('user', 'pass')


</p><p>    &gt;&gt;&gt; from agithub import Github
</p><p>    &gt;&gt;&gt; g = Github(token='token')


</p><p>2. When you make a request, the status and response body are passed back
</p><p>   as a tuple::

</p><p>    &gt;&gt;&gt; status, data = g.issues.get(filter='subscribed', foobar='llama')
</p><p>    &gt;&gt;&gt; data
</p><p>    [ list, of, issues ]


</p><p>   Notice the syntax here::
</p><p>   `&lt;api-object&gt;.&lt;url-path&gt;.&lt;request-method&gt;(&lt;get-parameters&gt;)`

</p><p>3. If you forget the request method, `agithub` will complain that you
</p><p>   haven't provided enough information to complete the request::

</p><p>    &gt;&gt;&gt; g.issues
</p><p>    &lt;class 'agithub.github.incompleterequest'=""&gt;: /issues


</p><p>4. Sometimes, it is inconvenient (or impossible) to refer to a URL as a
</p><p>   chain of attributes, so indexing syntax is provided as well. It
</p><p>   behaves exactly the same::

</p><p>    &gt;&gt;&gt; g.repos.jpaugh.repla.issues[1].get()
</p><p>    (200, { 'id': '#blah', ... })
</p><p>    &gt;&gt;&gt; mylogin, myrepo = 'jpaugh', 'braille-converter'
</p><p>    &gt;&gt;&gt; g.repos[mylogin][myrepo].milestones.get(state='open', sort='completeness')
</p><p>    (200, [ list, of, milestones ])


</p><p>5. As a weird quirk of the implementation, you may build a partial call
</p><p>   to the upstream API, and use it later::

</p><p>    &gt;&gt;&gt; def following(self, user):
</p><p>    ...   return self.user.following[user].get
</p><p>    ...
</p><p>    &gt;&gt;&gt; myCall = following(g, 'octocat')
</p><p>    &gt;&gt;&gt; if 204 == myCall()[0]:
</p><p>    ...   print 'You are following octocat'
</p><p>    You are following octocat


</p><p>   You may find this useful — or not.

</p><p>6. Finally, `agithub` knows nothing at all about the Github API, and it
</p><p>   won't second-guess you::

</p><p>    &gt;&gt;&gt; g.funny.I.donna.remember.that.one.head()
</p><p>    (404, {'message': 'Not Found'})


</p><p>   The error message you get is directly from Github's API. This gives
</p><p>   you all of the information you need to survey the situation.

</p><p>7. If you need more information, the response headers of the previous
</p><p>   request are available via the `getheaders()` method::

</p><p>    &gt;&gt;&gt; g.getheaders()
</p><p>    [('status', '404 Not Found'),
</p><p>     ('x-ratelimit-remaining', '54'),
</p><p>     ...
</p><p>     ('server', 'GitHub.com')]


</p><p>Error handling
</p><p>===========
</p><p>Errors are handled in the most transparent way possible: they are passed
</p><p>on to you for further scrutiny. There are two kinds of errors that can
</p><p>crop up::

</p><p>1. Networking Exceptions (from the `http` library). Catch these with
</p><p>   `try .. catch` blocks, as you otherwise would.

</p><p>2. Github API errors. These means you're doing something wrong with the
</p><p>   API, and they are always evident in the response's status. The API
</p><p>   considerately returns a helpful error message in the JSON body.


</p><p>Semantics
</p><p>========
</p><p>Here's how `agithub` works, under the hood::

</p><p>1. It translates a sequence of attribute look-ups into a URL; The
</p><p>   Python method you call at the end of the chain determines the
</p><p>   HTTP method to use for the request.

</p><p>2. The Python method also receives `name=value` arguments, which it
</p><p>   interprets as follows::

</p><p>`header=`

</p><p>  You can include custom headers as a dictionary supplied to the
</p><p>  `headers=` argument. Some headers are provided by default (such as
</p><p>  User-Agent). If these occur in the supplied dictionary, they will be
</p><p>  overridden.


</p><p>`body=`
</p><p>  If you're using POST, PUT, or PATCH (`post()`, `put()`, and
</p><p>  `patch()`), then you should include the body as the `body=` argument.
</p><p>  The body is serialized to JSON before sending it out on the wire.

</p><p>GET Parameters
</p><p>  Any other arguments to the Python method become GET parameters, and
</p><p>  are tacked onto the end of the URL. They are, of course, url-encoded
</p><p>  for you.

</p><p>3. When the response is received, `agithub` looks at its content
</p><p>   type to determine how to handle it, possibly decoding it from the
</p><p>   given char-set to Python's Unicode representation, then converting to
</p><p>   an appropriate form, then passed to you along with the response
</p><p>   status code. (A JSON object is de-serialized into a Python object.)

</p><p>Extensibility
</p><p>=========
</p><p>`agithub` has been written in an extensible way. You can easily:

</p><p>- Add new HTTP methods by extending the `Client` class with
</p><p>  new Python methods of the same name (and adding them to the
</p><p>  [`http_methods` list][1]).

</p><p>- Add new default headers to the [`_default_headers` dictionary][2].
</p><p>  Just make sure that the header names are lower case.

</p><p>- Add a new media-type (a.k.a. content-type a.k.a mime-type) by
</p><p>  inserting a new method into the [`Content` class][3], replacing
</p><p>  `'-'` and `'/'` with `'_'` in the name. That method will then be
</p><p>  responsible for converting the response body to a usable
</p><p>  form — and for calling `decode_body` to do char-set
</p><p>  conversion, if required.

</p><p>And if all else fails, you can strap in, and take 15 minutes to read and
</p><p>become an expert on the code. From there, anything's possible.

</p><a name="downloads"> </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>26</span> downloads in the last week
  </li>
  <li>
    <span>174</span> downloads in the last month
  </li>
</ul>









            </div>


          </div></body></html>