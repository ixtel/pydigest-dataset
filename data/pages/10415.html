<html><body><div><p>Currently the only MapReduce implementation is in-memory and serial, but an
implementation with parallelized map and reduce phases will be added.</p>
<div id="word-count-workflow">
<h3>Word Count Workflow</h3>
<p>Internally, the workflow looks like this:</p>
<p><strong>Input data</strong>:</p>
<pre><span class="gp">$</span> head -10 LICENSE.txt
<span class="go">
New BSD License

Copyright (c) 2015, Kevin D. Wurster
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.</span>
</pre>
<p><strong>Map</strong></p>
<p>Count occurrences of each word in every line.</p>
<pre><span class="c1"># Input line</span>
<span class="n">line</span> <span class="o">=</span> <span class="s1">'Copyright (c) 2015, Kevin D. Wurster'</span>

<span class="c1"># Sanitized words</span>
<span class="n">words</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'Copyright'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">,</span> <span class="s1">'2015'</span><span class="p">,</span> <span class="s1">'Kevin'</span><span class="p">,</span> <span class="s1">'D'</span><span class="p">,</span> <span class="s1">'Wurster'</span><span class="p">]</span>

<span class="c1"># Return tuples with word as the first element and count as the second</span>
<span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">'Copyright'</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">'c'</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">'2015'</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">'Kevin'</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">'D'</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">'Wurster'</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
</pre>
<p><strong>Partition</strong></p>
<p>Organize all of the <tt>(word, count)</tt> pairs by <tt>word</tt>.  The <tt>word</tt> keys are
kept at this point in case the data is sorted.  Sorting grabs the second to last
key, so the data could be partitioned on one key and sorted on another with
<tt>(word, sort, count)</tt>.  The second to last key is used for sorting so the keys
that appear below match the <tt>word</tt> only because a <tt>sort</tt> key was not given.</p>
<p>Words that appear in the input text on multiple lines have multiple
<tt>(word, count)</tt> pairs.  A <tt>count</tt> of <tt>2</tt> would indicate a word that
appeared twice on a single line, but our input data does not have this
condition.  Truncated output below.  The dictionary values are lists containing
tuples to allow for a sort key, which is explained elsewhere.</p>
<pre><span class="p">{</span>
    <span class="s1">'2015'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,)]</span>
    <span class="s1">'above'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,)]</span>
    <span class="s1">'all'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,)]</span>
    <span class="s1">'and'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)]</span>
    <span class="s1">'are'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)]</span>
    <span class="s1">'binary'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,)]</span>
    <span class="s1">'bsd'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,)]</span>
    <span class="s1">'c'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,)]</span>
    <span class="s1">'code'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,)]</span>
<span class="p">}</span>
</pre>
<p><strong>Reduce</strong></p>
<p>Sum <tt>count</tt> for each <tt>word</tt>.</p>
<pre><span class="c1"># The ``reducer()`` receives a key and an iterator of values</span>
<span class="n">key</span> <span class="o">=</span> <span class="s1">'the'</span>
<span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">reducer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">key</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</pre>
<p><strong>Partition</strong></p>
<p>The reducer does not _have_ to produces the same key it was given, so the data
is partitioned by key again, which is superfluous for this wordcount example.
Again the keys are kept in case the data is sorted and only match <tt>word</tt>
because an optional <tt>sort</tt> key was not given.  Truncated output below.</p>
<pre><span class="p">{</span>
    <span class="s1">'2015'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,)]</span>
    <span class="s1">'above'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,)]</span>
    <span class="s1">'all'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,)]</span>
    <span class="s1">'and'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,)]</span>
    <span class="s1">'are'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,)]</span>
    <span class="s1">'binary'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,)]</span>
    <span class="s1">'bsd'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,)]</span>
    <span class="s1">'c'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,)]</span>
    <span class="s1">'code'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,)]</span>
<span class="p">}</span>
</pre>
<p><strong>Output</strong></p>
<p>The default implementation is to return <tt>(key, iter(values))</tt> pairs from the
<tt>final_reducer()</tt>, which would look something like:</p>
<pre><span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s1">'the'</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">'in'</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
<span class="p">]</span>
</pre>
<p>But a dictionary is much more useful, and we know that we only got a single
value for each <tt>word</tt> in the reduce phase, so we can extract that value
and produce a dictionary.</p>
<pre><span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">}</span>
</pre>
<p>The <tt>tuple()</tt> call is included because the data in the <tt>value</tt> key is
_always_ an iterable object but _may_ be an iterator.  Calling <tt>tuple()</tt>
expands the iterable and lets us get the first element.</p>
</div>
</div></body></html>