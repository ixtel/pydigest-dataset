<html><body><div><div class="post-text" itemprop="text">

<p>I started writing my first reusable app about 3 weeks ago, and I'm having troubles to deal with migrations.</p>

<p>I want some points of my app to be customizable. Thus I have a <a href="https://github.com/Aladom/django-mailing/blob/6260556aa11128d6ecdb514b5a3fbd8c823fef60/mailing/conf.py" rel="nofollow"><code>conf</code> submodule</a> that defines custom settings and assign the reasonable defaults that will fit most cases.</p>

<p>This leads some of my model fields to look like this:</p>

<pre><code>attachment = models.FilePathField(
    path=conf.ATTACHMENTS_DIR, recursive=True)

template_file = models.FileField(
    upload_to=conf.TEMPLATES_UPLOAD_DIR, blank=True)

prefix_subject = models.BooleanField(
    default=True, verbose_name=_("prefix subject"),
    help_text=_(
        "Whether to prefix the subject with \"{}\" or not."
    ).format(conf.SUBJECT_PREFIX))
</code></pre>

<p>Unfortunately, on projects using this app, this causes <code>django-admin makemigrations</code> to create migrations for it every time a setting changes. Or even, the first time they install the app for settings which default value depends on the host system.</p>

<p>I'm more than doubtful about the legitimacy of a project creating its own migrations inside his copy of an app. But if I'm wrong, tell me.</p>

<p>For <code>prefix_subject</code> in the above sample, I solved the issue withÂ <a href="http://stackoverflow.com/a/29233569/1529346">this solution</a>. Considering that losing the <code>help_text</code> information in migrations was not very effective.</p>

<p>However, I'm not sure this is a suitable solution for all/most cases. Is it?</p>

<p>I thought about another solution that seems to work. This solution is to manually edit migrations and replace evaluated settings by the variable itself.</p>

<p>For instance, I would replace this:</p>

<pre><code>migrations.CreateModel(
    name='MailStaticAttachment',
    fields=[
        ('id', ...),
        ('filename', ...)
        ('mime_type', ...)
        ('attachment', models.FilePathField(path='/home/antoine/Workspace/django-mailing/static/mailing/attachments', recursive=True, verbose_name='file')),
    ],
    options={...}
),
</code></pre>

<p>With :</p>

<pre><code>from ..conf import ATTACHMENTS_DIR

migrations.CreateModel(
    name='MailStaticAttachment',
    fields=[
        ('id', ...),
        ('filename', ...)
        ('mime_type', ...)
        ('attachment', models.FilePathField(path=ATTACHMENTS_DIR, recursive=True, verbose_name='file')),
    ],
    options={...}
),
</code></pre>

<p>Does it look like a good solution to you?</p>

<p>What do you advise to do in such cases?</p>

<p>I think both <code>Field.help_text</code>, <code>FilePathField.path</code> and <code>FileField.upload_to</code> attributes are not used to create SQL statements. So in this case, there should not be specific issues due to "ignoring them in migrations". But what if I, hypothetically, want a customizable <code>Field.default</code>, <code>Field.db_column</code> or <code>CharField.max_length</code> for instance? That's probably a very bad idea that have no practical interest, but that's the only hypothetical situation I can find. :P I guess in this case it would be better to provide an abstract base model, intended to be extended by the host project.</p>
    </div>
    </div></body></html>