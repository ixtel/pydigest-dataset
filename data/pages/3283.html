<html><body><div><div id="bss93f55b7e-b553-4a5e-8cef-199a361488c6" class-="">
            <h2 class="tab-accordion-content-header">Description</h2>

<span id="bssMetaInformation" class="clearfix">
    <ul id="bibPubInfo">
        <li>Copyright 2015</li>
                <li>Dimensions: 7" x 9-1/8"</li>
                <li>Pages: 256</li>
                <li>Edition: 1st</li>
        </ul>
        <ul id="bibISBN">
        <li>
            <strong>
eBook (Watermarked)            </strong>
        </li>
        <li>ISBN-10: 0-13-403442-2</li>
        <li class="bibIsbnLast">ISBN-13: 978-0-13-403442-3</li>
    </ul>
</span>

        <p/><p>“Each item in Slatkin’s <i>Effective Python</i> teaches a self-contained lesson with its own source code. This makes the book random-access: Items are easy to browse and study in whatever order the reader needs. I will be recommending <i>Effective Python</i> to students as an admirably compact source of mainstream advice on a very broad range of topics for the intermediate Python programmer.”</p>  <p><i>—Brandon Rhodes, software engineer at Dropbox and chair of PyCon 2016-2017</i></p>    <p>It’s easy to start coding with Python, which is why the language is so popular. However, Python’s unique strengths, charms, and expressiveness can be hard to grasp, and there are hidden pitfalls that can easily trip you up.</p>    <p><b><i><b>Effective Python</b></i></b> will help you master a truly “Pythonic” approach to programming, harnessing Python’s full power to write exceptionally robust and well-performing code. Using the concise, scenario-driven style pioneered in Scott Meyers’ best-selling <i>Effective C++,</i> Brett Slatkin brings together 59 Python best practices, tips, and shortcuts, and explains them with realistic code examples.</p>    <p>Drawing on years of experience building Python infrastructure at Google, Slatkin uncovers little-known quirks and idioms that powerfully impact code behavior and performance. You’ll learn the best way to accomplish key tasks, so you can write code that’s easier to understand, maintain, and improve.</p>    <p>Key features include</p>  <ul>  <li>  Actionable guidelines for all major areas of Python 3.x and 2.x development, with detailed explanations and examples</li>  <li>  Best practices for writing functions that clarify intention, promote reuse, and avoid bugs</li>  <li>  Coverage of how to accurately express behaviors with classes and objects</li>  <li>  Guidance on how to avoid pitfalls with metaclasses and dynamic attributes</li>  <li>  More efficient approaches to concurrency and parallelism</li>  <li>  Better techniques and idioms for using Python’s built-in modules</li>  <li>  Tools and best practices for collaborative development</li>  <li>  Solutions for debugging, testing, and optimization in order to improve quality and performance</li></ul>
                                    <a href="#productBSS" class="ss-icon tab-accordion-content-return"></a>
        </div>
        <div id="bss0f8fc8f7-6d8d-4816-9b68-458cbd7149e6" class-="">
            <h2 class="tab-accordion-content-header">Sample Content</h2>
                        <h3>Table of Contents</h3>
        <p><i>  </i></p><p>Preface xiii</p>  <p>Acknowledgments xvii</p>  <p>About the Author xix</p>    <p><b>Chapter 1: Pythonic Thinking 1</b></p>  <p>Item 1: Know Which Version of Python You’re Using 1</p>  <p>Item 2: Follow the PEP 8 Style Guide 2</p>  <p>Item 3: Know the Differences Between bytes, str, and unicode 5</p>  <p>Item 4: Write Helper Functions Instead of Complex Expressions 8</p>  <p>Item 5: Know How to Slice Sequences 10</p>  <p>Item 6: Avoid Using start, end, and stride in a Single Slice 13</p>  <p>Item 7: Use List Comprehensions Instead of map and filter 15</p>  <p>Item 8: Avoid More Than Two Expressions in List Comprehensions 16</p>  <p>Item 9: Consider Generator Expressions for Large Comprehensions 18</p>  <p>Item 10: Prefer enumerate Over range 20</p>  <p>Item 11: Use zip to Process Iterators in Parallel 21</p>  <p>Item 12: Avoid else Blocks After for and while Loops 23</p>  <p>Item 13: Take Advantage of Each Block in try/except/else/finally 26</p>    <p><b>Chapter 2: Functions 29</b></p>  <p>Item 14: Prefer Exceptions to Returning None 29</p>  <p>Item 15: Know How Closures Interact with Variable Scope 31</p>  <p>Item 16: Consider Generators Instead of Returning Lists 36</p>  <p>Item 17: Be Defensive When Iterating Over Arguments 38</p>  <p>Item 18: Reduce Visual Noise with Variable Positional Arguments 43</p>  <p>Item 19: Provide Optional Behavior with Keyword Arguments 45</p>  <p>Item 20: Use None and Docstrings to Specify Dynamic Default Arguments 48</p>  <p>Item 21: Enforce Clarity with Keyword-Only Arguments 51</p>    <p><b>Chapter 3: Classes and Inheritance 55</b></p>  <p>Item 22: Prefer Helper Classes Over Bookkeeping with Dictionaries and Tuples 55</p>  <p>Item 23: Accept Functions for Simple Interfaces Instead of Classes 61</p>  <p>Item 24: Use @classmethod Polymorphism to Construct Objects Generically 64</p>  <p>Item 25: Initialize Parent Classes with super 69</p>  <p>Item 26: Use Multiple Inheritance Only for Mix-in Utility Classes 73</p>  <p>Item 27: Prefer Public Attributes Over Private Ones 78</p>  <p>Item 28: Inherit from collections.abc for Custom Container Types 83</p>    <p><b>Chapter 4: Metaclasses and Attributes 87</b></p>  <p>Item 29: Use Plain Attributes Instead of Get and Set Methods 87</p>  <p>Item 30: Consider @property Instead of Refactoring Attributes 91</p>  <p>Item 31: Use Descriptors for Reusable @property Methods 95</p>  <p>Item 32: Use __getattr__, __getattribute__, and __setattr__ for Lazy Attributes 100</p>  <p>Item 33: Validate Subclasses with Metaclasses 105</p>  <p>Item 34: Register Class Existence with Metaclasses 108</p>  <p>Item 35: Annotate Class Attributes with Metaclasses 112</p>    <p><b>Chapter 5: Concurrency and Parallelism 117</b></p>  <p>Item 36: Use subprocess to Manage Child Processes 118</p>  <p>Item 37: Use Threads for Blocking I/O, Avoid for Parallelism 122</p>  <p>Item 38: Use Lock to Prevent Data Races in Threads 126</p>  <p>Item 39: Use Queue to Coordinate Work Between Threads 129</p>  <p>Item 40: Consider Coroutines to Run Many Functions Concurrently 136</p>  <p>Item 41: Consider concurrent.futures for True Parallelism 145</p>    <p><b>Chapter 6: Built-in Modules 151</b></p>  <p>Item 42: Define Function Decorators with functools.wraps 151</p>  <p>Item 43: Consider contextlib and with Statements for Reusable try/finally Behavior 153</p>  <p>Item 44: Make pickle Reliable with copyreg 157</p>  <p>Item 45: Use datetime Instead of time for Local Clocks 162</p>  <p>Item 46: Use Built-in Algorithms and Data Structures 166</p>  <p>Item 47: Use decimal When Precision Is Paramount 171</p>  <p>Item 48: Know Where to Find Community-Built Modules 173</p>    <p><b>Chapter 7: Collaboration 175</b></p>  <p>Item 49: Write Docstrings for Every Function, Class, and Module 175</p>  <p>Item 50: Use Packages to Organize Modules and Provide Stable APIs 179</p>  <p>Item 51: Define a Root Exception to Insulate Callers from APIs 184</p>  <p>Item 52: Know How to Break Circular Dependencies 187</p>  <p>Item 53: Use Virtual Environments for Isolated and</p>  <p>Reproducible Dependencies 192</p>    <p><b>Chapter 8: Production 199</b></p>  <p>Item 54: Consider Module-Scoped Code to Configure Deployment Environments 199</p>  <p>Item 55: Use repr Strings for Debugging Output 202</p>  <p>Item 56: Test Everything with unittest 204</p>  <p>Item 57: Consider Interactive Debugging with pdb 208</p>  <p>Item 58: Profile Before Optimizing 209</p>  <p>Item 59: Use tracemalloc to Understand Memory Usage and Leaks 214</p>  <i>  </i><p>Index 217</p>
                        <a href="#productBSS" class="ss-icon tab-accordion-content-return"></a>
        </div>
        </div></body></html>