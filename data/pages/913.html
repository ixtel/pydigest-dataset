<html><body><div><div class="section" id="watering-time-practical-uses-for-python-s-calendar-module">
<p>The UI for the timer attached to my sprinkler system makes it<br/>
difficult to understand exactly when the various sprinklers will<br/>
run. All of the data is there, but with only a few controls and a<br/>
small LCD screen, there aren’t a lot of presentation options. Using<br/>
Python’s <span class="xref py py-mod docutils literal"><span class="pre">calendar</span></span> module I was able to write a simple program<br/>
to format the data to make it easier to identify cases where I might<br/>
be over, or under, watering.</p>
<p id="more"> </p>
<div class="section" id="the-problem">
<h2>The Problem</h2>
<p>We don’t have a large yard, but we’ve tried to invest in making it an<br/>
attractive place to spend time. A big part of that, especially in the<br/>
southeastern US, is keeping plants properly watered through the hot<br/>
summer. A couple of years ago, I had an automated irrigation system<br/>
installed, with a programmable timer to control the watering schedule.</p>
<p><img alt="http://doughellmann.com/blog/wp-content/uploads/2014/05/controllers_00-proc-08.png" src="http://doughellmann.com/blog/wp-content/uploads/2014/05/controllers_00-proc-08.png"/>
</p><p>The timer support three “programs”, each of which can be scheduled to<br/>
run on different days of the week or month, at multiple times. Each<br/>
program can activate the sprinklers in several “zones” (areas of the<br/>
yard), running them for different amounts of time. This is, as far as<br/>
I can tell, a pretty standard internal model for one of these timers,<br/>
and once you get the hang of it programming it is pretty<br/>
straightforward.</p>
<p>This spring we decided we needed to change the way we were watering a<br/>
particularly troublesome spot in the front of the yard, to run the<br/>
system for two short cycles instead of one long cycle (the theory<br/>
being that this would allow more water to soak in and be used by the<br/>
plants in that area). When I examined the current settings, I<br/>
discovered that I had also been watering one zone more than I<br/>
realized, because it was scheduled in multiple programs. It wasn’t at<br/>
all obvious, given the limitations of how the timer shows its<br/>
programming, and I only discovered it when I wrote down the entire<br/>
schedule to review it. As part of my audit before updating the<br/>
schedule, I decided I would write a program to show the schedule on a<br/>
calendar so it easier to understand what was happening without having<br/>
to perform the calculations in my head.</p>
</div>
<div class="section" id="designing-the-inputs">
<h2>Designing the Inputs</h2>
<p>The first step was to design an input format to represent all of the<br/>
data I had in a way that was easy to collect. I chose a YAML format,<br/>
since I have lists and mappings of data and using YAML meant I<br/>
wouldn’t need to build a separate parser. The first section of the<br/>
input file lists the zones, mapping the number used to identify them<br/>
in the timer with the name I use for them in my notes.</p>
<div class="highlight-python">
<div class="highlight">
<pre>zones:
  1: turf
  2: f shrubs
  3: b shrubs
  4: patio
  5: garden
</pre>
</div>
</div>
<p>The remainder of the input file describes the schedule for each<br/>
program (named A, B, and C), including the times of day when the<br/>
program runs (multiples are allowed), the days of the week when the<br/>
program runs, and the zones to be watered and for how long.</p>
<p>For example, program A runs on Monday, Wednesday, and Friday at 4:00<br/>
AM, watering the front shrubs for 15 minutes and the back shrubs for<br/>
15 minutes.</p>
<div class="highlight-python">
<div class="highlight">
<pre>programs:
  A:
    start:
      - '4:00'
    days: MWF
    zones:
      - zone: 2
        time: 15
      - zone: 3
        time: 15
</pre>
</div>
</div>
<p>Zones are identified in the program schedule by number, and although<br/>
they can be listed in any order they are always run in numerical<br/>
order.</p>
<p>There are two ways to express the rules for determining which days the<br/>
program is active. A program can either run on odd or even days of the<br/>
month, or any combination of explicitly selected days of the week. I<br/>
decided to use “odd” and “even” as literal values for those cases, and<br/>
to use one or two letter abbreviations for days (where Tuesday is T,<br/>
Thursday is Th, Saturday is Sa, and Sunday is Su).</p>
</div>
<div class="section" id="designing-the-output">
<h2>Designing the Output</h2>
<p>I decided to generate output using a monthly calendar format. I’m<br/>
likely to be the only user of the program, so I didn’t worry about<br/>
generating HTML and opted to use a simple text chart format.</p>
<div class="highlight-python">
<div class="highlight">
<pre>$ wateringtime -c

                                                                                      May

+------------------------+------------------------+------------------------+------------------------+------------------------+------------------------+------------------------+
| Mon                    | Tue                    | Wed                    | Thu                    | Fri                    | Sat                    | Sun                    |
+------------------------+------------------------+------------------------+------------------------+------------------------+------------------------+------------------------+
|                        |                        |                        | (1)                    | (2)                    | (3)                    | (4)                    |
|                        |                        |                        |                        | 03:15-03:30 - f shrubs | 03:00-03:30 - turf     | 03:15-03:30 - f shrubs |
|                        |                        |                        |                        | 03:30-03:45 - b shrubs |                        | 03:30-03:45 - b shrubs |
|                        |                        |                        |                        | 03:45-03:55 - patio    |                        | 03:45-03:55 - patio    |
|                        |                        |                        |                        | 03:55-04:00 - garden   |                        | 03:55-04:00 - garden   |
|                        |                        |                        |                        | 04:00-04:15 - f shrubs |                        |                        |
|                        |                        |                        |                        | 04:15-04:30 - b shrubs |                        |                        |
+------------------------+------------------------+------------------------+------------------------+------------------------+------------------------+------------------------+
| (5)                    | (6)                    | (7)                    | (8)                    | (9)                    | (10)                   | (11)                   |
| 03:00-03:30 - turf     | 03:15-03:30 - f shrubs | 04:00-04:15 - f shrubs | 03:15-03:30 - f shrubs | 04:00-04:15 - f shrubs | 03:00-03:30 - turf     |                        |
| 04:00-04:15 - f shrubs | 03:30-03:45 - b shrubs | 04:15-04:30 - b shrubs | 03:30-03:45 - b shrubs | 04:15-04:30 - b shrubs | 03:15-03:30 - f shrubs |                        |
| 04:15-04:30 - b shrubs | 03:45-03:55 - patio    |                        | 03:45-03:55 - patio    |                        | 03:30-03:45 - b shrubs |                        |
|                        | 03:55-04:00 - garden   |                        | 03:55-04:00 - garden   |                        | 03:45-03:55 - patio    |                        |
|                        |                        |                        |                        |                        | 03:55-04:00 - garden   |                        |
+------------------------+------------------------+------------------------+------------------------+------------------------+------------------------+------------------------+
| (12)                   | (13)                   | (14)                   | (15)                   | (16)                   | (17)                   | (18)                   |
| 03:00-03:30 - turf     |                        | 03:15-03:30 - f shrubs |                        | 03:15-03:30 - f shrubs | 03:00-03:30 - turf     | 03:15-03:30 - f shrubs |
| 03:15-03:30 - f shrubs |                        | 03:30-03:45 - b shrubs |                        | 03:30-03:45 - b shrubs |                        | 03:30-03:45 - b shrubs |
| 03:30-03:45 - b shrubs |                        | 03:45-03:55 - patio    |                        | 03:45-03:55 - patio    |                        | 03:45-03:55 - patio    |
| 03:45-03:55 - patio    |                        | 03:55-04:00 - garden   |                        | 03:55-04:00 - garden   |                        | 03:55-04:00 - garden   |
| 03:55-04:00 - garden   |                        | 04:00-04:15 - f shrubs |                        | 04:00-04:15 - f shrubs |                        |                        |
| 04:00-04:15 - f shrubs |                        | 04:15-04:30 - b shrubs |                        | 04:15-04:30 - b shrubs |                        |                        |
| 04:15-04:30 - b shrubs |                        |                        |                        |                        |                        |                        |
+------------------------+------------------------+------------------------+------------------------+------------------------+------------------------+------------------------+
| (19)                   | (20)                   | (21)                   | (22)                   | (23)                   | (24)                   | (25)                   |
| 03:00-03:30 - turf     | 03:15-03:30 - f shrubs | 04:00-04:15 - f shrubs | 03:15-03:30 - f shrubs | 04:00-04:15 - f shrubs | 03:00-03:30 - turf     |                        |
| 04:00-04:15 - f shrubs | 03:30-03:45 - b shrubs | 04:15-04:30 - b shrubs | 03:30-03:45 - b shrubs | 04:15-04:30 - b shrubs | 03:15-03:30 - f shrubs |                        |
| 04:15-04:30 - b shrubs | 03:45-03:55 - patio    |                        | 03:45-03:55 - patio    |                        | 03:30-03:45 - b shrubs |                        |
|                        | 03:55-04:00 - garden   |                        | 03:55-04:00 - garden   |                        | 03:45-03:55 - patio    |                        |
|                        |                        |                        |                        |                        | 03:55-04:00 - garden   |                        |
+------------------------+------------------------+------------------------+------------------------+------------------------+------------------------+------------------------+
| (26)                   | (27)                   | (28)                   | (29)                   | (30)                   | (31)                   |                        |
| 03:00-03:30 - turf     |                        | 03:15-03:30 - f shrubs |                        | 03:15-03:30 - f shrubs | 03:00-03:30 - turf     |                        |
| 03:15-03:30 - f shrubs |                        | 03:30-03:45 - b shrubs |                        | 03:30-03:45 - b shrubs |                        |                        |
| 03:30-03:45 - b shrubs |                        | 03:45-03:55 - patio    |                        | 03:45-03:55 - patio    |                        |                        |
| 03:45-03:55 - patio    |                        | 03:55-04:00 - garden   |                        | 03:55-04:00 - garden   |                        |                        |
| 03:55-04:00 - garden   |                        | 04:00-04:15 - f shrubs |                        | 04:00-04:15 - f shrubs |                        |                        |
| 04:00-04:15 - f shrubs |                        | 04:15-04:30 - b shrubs |                        | 04:15-04:30 - b shrubs |                        |                        |
| 04:15-04:30 - b shrubs |                        |                        |                        |                        |                        |                        |
+------------------------+------------------------+------------------------+------------------------+------------------------+------------------------+------------------------+
</pre>
</div>
</div>
<p>I used Python’s calendar module to find the days of the month as<br/>
weeks. I treat Monday as day 0, which leaves the weekend at the end of<br/>
each row of output. That’s different than a typical American calendar,<br/>
but it works out well because I may have weekends as a special case,<br/>
depending on how bad the drought is here in Georgia and whether we<br/>
have watering restrictions in place.</p>
</div>
<div class="section" id="building-tables-with-prettytable">
<h2>Building Tables with PrettyTable</h2>
<p>In addition to the calendar output mode, I included a simple table<br/>
output mode to report the settings in a form that is easy to carry<br/>
outside and program into the controller. (I still have to do that step<br/>
by hand.)</p>
<div class="highlight-python">
<div class="highlight">
<pre>$ wateringtime
+------+----------+
| Zone | Name     |
+------+----------+
|    1 | turf     |
|    2 | f shrubs |
|    3 | b shrubs |
|    4 | patio    |
|    5 | garden   |
+------+----------+
+---------+-------------+------+-------+
| Program | Start Times | Days | Zones |
+---------+-------------+------+-------+
|    A    |     4:00    | MWF  | 2(15) |
|         |             |      | 3(15) |
|    B    |     3:00    | MSa  | 1(30) |
|    C    |     3:15    | even | 2(15) |
|         |             |      | 3(15) |
|         |             |      | 4(10) |
|         |             |      | 5(5)  |
+---------+-------------+------+-------+
</pre>
</div>
</div>
<p>That second table contains all of the information I need to reprogram<br/>
the timer quickly. This simpler output mode is implemented in<br/>
<span class="docutils literal"><span class="pre">simple.py</span></span> in two functions.</p>
<p><span class="xref py py-func docutils literal"><span class="pre">show_zones()</span></span> prints the table with the names and id numbers of<br/>
the watering zones, taken from the input YAML file.</p>
<div class="highlight-python">
<div class="highlight">
<pre>def show_zones(data):
    t = prettytable.PrettyTable(
        field_names=('Zone', 'Name'),
        print_empty=False,
    )
    t.padding_width = 1
    t.align['Zone'] = 'r'
    t.align['Name'] = 'l'

    for z in sorted(data['zones'].items()):
        t.add_row(z)

    print t.get_string()
</pre>
</div>
</div>
<p>It starts by building a <span class="xref py py-class docutils literal"><span class="pre">PrettyTable</span></span> object, configured with<br/>
two columns. Then it adds one row at a time to the table, where the<br/>
data for each row is held in a tuple with two members. The<br/>
<span class="xref py py-func docutils literal"><span class="pre">get_string()</span></span> method of the table returns the formatted results,<br/>
complete with headings and decorations.</p>
<p>The program list is a little more complex, since some cells of the<br/>
table have multiple lines. <span class="xref py py-class docutils literal"><span class="pre">PrettyTable</span></span> handles that easily,<br/>
but I need to build the multi-line strings myself by combining the<br/>
zone data.</p>
<div class="highlight-python">
<div class="highlight">
<pre>def show_programs(data):
    t = prettytable.PrettyTable(
        field_names=('Program', 'Start Times', 'Days', 'Zones'),
        print_empty=False,
    )
    t.padding_width = 1
    t.align['Zones'] = 'l'

    for p, pdata in sorted(data['programs'].items()):
        zones = 'n'.join('%(zone)s(%(time)s)' % z
                          for z in sorted(pdata['zones'],
                                          key=operator.itemgetter('zone')))
        t.add_row((p, 'n'.join(pdata['start']), pdata['days'],
                   zones))
    print t.get_string()
</pre>
</div>
</div>
</div>
<div class="section" id="adding-algorithms-to-data">
<h2>Adding Algorithms to Data</h2>
<p>The simple output format works with the data in the YAML data<br/>
structure directly. The processing it does is very basic, since it is<br/>
primarily formatting the existing values. For the calendar view, I<br/>
knew I would need some more complex algorithms. I have several<br/>
different rules to apply to decide if a program should be included in<br/>
the output for a given day, for example, and I want to compute and<br/>
show the actual start and end time for each watering event, not just<br/>
the program start time. I decided to create a <span class="xref py py-class docutils literal"><span class="pre">Program</span></span> class<br/>
to help with some of those calculations.</p>
<div class="highlight-python">
<div class="highlight">
<pre><span class="k">class</span> <span class="nc">Program</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">pdata</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">pdata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">days</span> <span class="o">=</span> <span class="n">pdata</span><span class="p">[</span><span class="s">'days'</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_day_checker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_day_checker</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">days</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_day_checker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">"""Parse a 'days' string</span>

<span class="sd">        A days string either contains 'odd', 'even', or 1-2 letter</span>
<span class="sd">        abbreviations for the days of the week.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s">'odd'</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">dow</span><span class="p">,</span> <span class="n">dom</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">dom</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="s">'even'</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">dow</span><span class="p">,</span> <span class="n">dom</span><span class="p">:</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">dom</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">valid</span><span class="o">=</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_day_abbr</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'([MTWF]|Tu|Th|Sa|Su)'</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">dow</span><span class="p">,</span> <span class="n">dom</span><span class="p">,</span> <span class="n">valid</span><span class="o">=</span><span class="n">valid</span><span class="p">:</span> <span class="n">dow</span> <span class="ow">in</span> <span class="n">valid</span>

    <span class="n">_day_abbr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'M'</span><span class="p">:</span> <span class="n">calendar</span><span class="o">.</span><span class="n">MONDAY</span><span class="p">,</span>
        <span class="s">'T'</span><span class="p">:</span> <span class="n">calendar</span><span class="o">.</span><span class="n">TUESDAY</span><span class="p">,</span>
        <span class="s">'Tu'</span><span class="p">:</span> <span class="n">calendar</span><span class="o">.</span><span class="n">TUESDAY</span><span class="p">,</span>
        <span class="s">'W'</span><span class="p">:</span> <span class="n">calendar</span><span class="o">.</span><span class="n">WEDNESDAY</span><span class="p">,</span>
        <span class="s">'Th'</span><span class="p">:</span> <span class="n">calendar</span><span class="o">.</span><span class="n">THURSDAY</span><span class="p">,</span>
        <span class="s">'F'</span><span class="p">:</span> <span class="n">calendar</span><span class="o">.</span><span class="n">FRIDAY</span><span class="p">,</span>
        <span class="s">'Sa'</span><span class="p">:</span> <span class="n">calendar</span><span class="o">.</span><span class="n">SATURDAY</span><span class="p">,</span>
        <span class="s">'Su'</span><span class="p">:</span> <span class="n">calendar</span><span class="o">.</span><span class="n">SUNDAY</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">occurs_on_day</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dow</span><span class="p">,</span> <span class="n">dom</span><span class="p">):</span>
        <span class="sd">"""Tests whether the program runs on a given day.</span>

<span class="sd">        :param dow: Day of week</span>
<span class="sd">        :param dom: Day of month</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_day_checker</span><span class="p">(</span><span class="n">dow</span><span class="p">,</span> <span class="n">dom</span><span class="p">)</span>
</pre>
</div>
</div>
<p>The first piece of data I addressed was the rules for which days a<br/>
program is active. I have three different modes, and I knew I didn’t<br/>
want to test the mode each time a date was checked because the mode<br/>
doesn’t change after the YAML file is parsed. I decided to define<br/>
<span class="xref py py-func docutils literal"><span class="pre">_make_day_checker()</span></span> a factory method that returns a callable to<br/>
perform the test. For the “odd” and “even” modes, it returns a<br/>
function that looks at the day of the month to see if it is odd or<br/>
even respectively. For the explicit day list, I use a regular<br/>
expression to parse the string into individual abbreviations, and then<br/>
convert those to numbers using a dictionary that maps between the<br/>
abbreviations and values from <span class="xref py py-mod docutils literal"><span class="pre">calendar</span></span>. The public API<br/>
<span class="xref py py-func docutils literal"><span class="pre">occurs_on_day()</span></span> wraps the checker function.</p>
<p>Next I defined a property to sort the zones before returning them,<br/>
just in case I enter values out of order:</p>
<div class="highlight-python">
<div class="highlight">
<pre>    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">zones</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns the zones used in the program, sorted by zone id.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">'zones'</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="s">'zone'</span><span class="p">))</span>
</pre>
</div>
</div>
<p>Another property converts the string representation of the program<br/>
start times to <span class="xref py py-class docutils literal"><span class="pre">datetime.time</span></span> instances, which are easier to<br/>
manipulate and use for sorting:</p>
<div class="highlight-python">
<div class="highlight">
<pre>    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s">'%H:%M'</span><span class="p">)</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                      <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">'start'</span><span class="p">])</span>
</pre>
</div>
</div>
<p>A final property produces a series of run time values with the start<br/>
and end times as well as the zone id. It is used to build the schedule<br/>
part of a calendar cell, which shows the times and zones when the<br/>
sprinklers are running.  I perform the calculations to find the start<br/>
and end times myself, because <span class="xref py py-class docutils literal"><span class="pre">datetime.time</span></span> objects do not<br/>
work with <span class="xref py py-class docutils literal"><span class="pre">datetime.timedelta</span></span> objects.</p>
<div class="highlight-python">
<div class="highlight">
<pre>    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">run_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns iterable of start, end, and zone name tuples.</span>
<span class="sd">        """</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_times</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">zones</span><span class="p">:</span>
                <span class="c"># FIXME: Convert to datetime and use timedelta?</span>
                <span class="n">h</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">minute</span>
                <span class="n">m</span> <span class="o">+=</span> <span class="n">z</span><span class="p">[</span><span class="s">'time'</span><span class="p">]</span>
                <span class="n">h</span> <span class="o">+=</span> <span class="n">m</span> <span class="o">/</span> <span class="mi">60</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="mi">60</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="s">'zone'</span><span class="p">]</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">e</span>
</pre>
</div>
</div>
</div>
<div class="section" id="building-the-calendar">
<h2>Building the Calendar</h2>
<p>With <span class="xref py py-class docutils literal"><span class="pre">Program</span></span> in place, the next task was to figure out how to<br/>
construct the calendar grid. <a class="reference external" href="http://pymotw.com/2/calendar/">I knew that Python includes a calendar<br/>
module</a>, and that I could have it give me a list of weeks containing<br/>
the days of the month. To build my table, then, I would just need to<br/>
iterate over the weeks and days, deciding what to put in each cell.</p>
<p>I started by setting up the data I would be working with and the table<br/>
object.</p>
<div class="highlight-python">
<div class="highlight">
<pre><span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">programs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Program</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s">'programs'</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="n">programs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">start_times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">prettytable</span><span class="o">.</span><span class="n">PrettyTable</span><span class="p">(</span>
        <span class="n">field_names</span><span class="o">=</span><span class="n">calendar</span><span class="o">.</span><span class="n">day_abbr</span><span class="p">,</span>
        <span class="n">print_empty</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
        <span class="n">hrules</span><span class="o">=</span><span class="n">prettytable</span><span class="o">.</span><span class="n">ALL</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">align</span> <span class="o">=</span> <span class="s">'l'</span>

    <span class="n">cal</span> <span class="o">=</span> <span class="n">calendar</span><span class="o">.</span><span class="n">Calendar</span><span class="p">(</span><span class="n">calendar</span><span class="o">.</span><span class="n">MONDAY</span><span class="p">)</span>
    <span class="n">month_data</span> <span class="o">=</span> <span class="n">cal</span><span class="o">.</span><span class="n">monthdays2calendar</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">month</span><span class="p">)</span>
</pre>
</div>
</div>
<p>Each row of the calendar is based on a week, and each cell is a<br/>
day. There are two nested loops to iterate over the calendar days and<br/>
determine the cell and row contents.  Some weeks contain days from<br/>
multiple months, the end of one month and the beginning of the<br/>
next. The output of <span class="xref py py-func docutils literal"><span class="pre">monthdays2calendar()</span></span> reports the day of the<br/>
month as <span class="docutils literal"><span class="pre">0</span></span> for days in a week that fall outside of the current<br/>
month in either direction, and I skip them in the output (filling the<br/>
cell with a blank string to preserve the table structure).</p>
<div class="highlight-python">
<div class="highlight">
<pre>    <span class="k">for</span> <span class="n">week</span> <span class="ow">in</span> <span class="n">month_data</span><span class="p">:</span>
        <span class="n">row</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dom</span><span class="p">,</span> <span class="n">dow</span> <span class="ow">in</span> <span class="n">week</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dom</span><span class="p">:</span>
                <span class="c"># Zero days are from another month; leave the cell blank.</span>
                <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">''</span><span class="p">)</span>
                <span class="k">continue</span>
</pre>
</div>
</div>
<p>For the remaining days, I loop over the programs that occur on that<br/>
day and place a watering event (with start time, end time, and zone)<br/>
on each line of the cell. The <span class="xref py py-class docutils literal"><span class="pre">datetime.time</span></span> values are<br/>
formatted to show only the hour and minutes, and the zone name is used<br/>
instead of the zone number so I don’t have to do that conversion in my<br/>
head as I read the calendar.</p>
<div class="highlight-python">
<div class="highlight">
<pre>            # Show the day and all watering events on that day.
            lines = ['(%s)' % dom]
            for p in (p for p in programs
                      if p.occurs_on_day(dow, dom)):
                if args.verbose:
                    lines.append('')
                    lines.append('{name} ({days})'.format(name=p.name,
                                                          days=p.days))
                for s, e, z in p.run_times:
                    name = data['zones'][z]
                    lines.append(
                        '{s}-{e} - {name}'.format(
                            s=s.strftime('%H:%M'),
                            e=e.strftime('%H:%M'),
                            name=name,
                        )
                    )
            row.append('n'.join(lines))
        t.add_row(row)
</pre>
</div>
</div>
<p>Before printing the table, I use its width to center the month name<br/>
over the top.</p>
<div class="highlight-python">
<div class="highlight">
<pre>    formatted = t.get_string()
    # Center the name of the month over the output calendar.
    print 'n{:^{width}}n'.format(
        calendar.month_name[args.month],
        width=len(formatted.splitlines()[0]),
    )
    print formatted
</pre>
</div>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>With an hour of work, I was able to create a simple script to let me<br/>
visualize the watering schedule more clearly. I found one case of<br/>
potential over-watering, where a zone was in a program it shouldn’t<br/>
have been, and I was able to modify the timer’s programming to fix<br/>
that and make the other adjustments I needed very easily.</p>

</div>
</div>
</div></body></html>