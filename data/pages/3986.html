<html><body><div><div class="section" id="what-you-can-generate-and-how">
<h1>What you can generate and how<a class="headerlink" href="#what-you-can-generate-and-how" title="Permalink to this headline">¶</a></h1>
<p>The general philosophy of Hypothesis data generation is that everything
should be possible to generate and most things should be easy. Most things in
the standard library
is more aspirational than achieved, the state of the art is already pretty
good.</p>
<p>This document is a guide to what strategies are available for generating data
and how to build them. Strategies have a variety of other important internal
features, such as how they simplify, but the data they can generate is the only
public part of their API.</p>
<p>Functions for building strategies are all available in the hypothesis.strategies
module. The salient functions from it are as follows:</p>
<span class="target" id="module-hypothesis.strategies"/><dl class="function">
<dt id="hypothesis.strategies.just">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">just</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#just"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.just" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a strategy which only generates value.</p>
<p>Note: value is not copied. Be wary of using mutable values.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.none">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">none</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#none"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.none" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a strategy which only generates None.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.one_of">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">one_of</code><span class="sig-paren">(</span><em>arg</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#one_of"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.one_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a strategy which generates values from any of the argument
strategies.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.integers">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">integers</code><span class="sig-paren">(</span><em>min_value=None</em>, <em>max_value=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#integers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.integers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a strategy which generates integers (in Python 2 these may be
ints or longs).</p>
<p>If min_value is not None then all values will be &gt;=
min_value. If max_value is not None then all values will be &lt;= max_value</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.booleans">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">booleans</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#booleans"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.booleans" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a strategy which generates instances of bool.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.floats">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">floats</code><span class="sig-paren">(</span><em>min_value=None</em>, <em>max_value=None</em>, <em>allow_nan=None</em>, <em>allow_infinity=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#floats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.floats" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a strategy which generates floats.</p>
<ul class="simple">
<li>If min_value is not None, all values will be &gt;= min_value.</li>
<li>If max_value is not None, all values will be &lt;= max_value.</li>
<li>If min_value or max_value is not None, it is an error to enable
allow_nan.</li>
<li>If both min_value and max_value are not None, it is an error to enable
allow_infinity.</li>
</ul>
<p>Where not explicitly ruled out by the bounds, all of infinity, -infinity
and NaN are possible values generated by this strategy.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.complex_numbers">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">complex_numbers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#complex_numbers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.complex_numbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a strategy that generates complex numbers.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.tuples">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">tuples</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#tuples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a strategy which generates a tuple of the same length as args by
generating the value at index i from args[i].</p>
<p>e.g. tuples(integers(), integers()) would generate a tuple of length
two with both values an integer.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.sampled_from">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">sampled_from</code><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#sampled_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.sampled_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a strategy which generates any value present in the iterable
elements.</p>
<p>Note that as with just, values will not be copied and thus you
should be careful of using mutable data</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.lists">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">lists</code><span class="sig-paren">(</span><em>elements=None</em>, <em>min_size=None</em>, <em>average_size=None</em>, <em>max_size=None</em>, <em>unique_by=None</em>, <em>unique=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#lists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.lists" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list containing values drawn from elements length in the
interval [min_size, max_size] (no bounds in that direction if these are
None). If max_size is 0 then elements may be None and only the empty list
will be drawn.</p>
<p>average_size may be used as a size hint to roughly control the size
of list but it may not be the actual average of sizes you get, due
to a variety of factors.</p>
<p>If unique is True (or something that evaluates to True), we compare direct
object equality, as if unique_by was <cite>lambda x: x</cite>. This comparison only
works for hashable types.</p>
<p>if unique_by is not None it must be a function returning a hashable type
when given a value drawn from elements. The resulting list will satisfy the
condition that for i != j, unique_by(result[i]) != unique_by(result[j]).</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.sets">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">sets</code><span class="sig-paren">(</span><em>elements=None</em>, <em>min_size=None</em>, <em>average_size=None</em>, <em>max_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#sets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.sets" title="Permalink to this definition">¶</a></dt>
<dd><p>This has the same behaviour as lists, but returns sets instead.</p>
<p>Note that Hypothesis cannot tell if values are drawn from elements
are hashable until running the test, so you can define a strategy
for sets of an unhashable type but it will fail at test time.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.frozensets">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">frozensets</code><span class="sig-paren">(</span><em>elements=None</em>, <em>min_size=None</em>, <em>average_size=None</em>, <em>max_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#frozensets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.frozensets" title="Permalink to this definition">¶</a></dt>
<dd><p>This is identical to the sets function but instead returns
frozensets.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.fixed_dictionaries">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">fixed_dictionaries</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#fixed_dictionaries"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.fixed_dictionaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a dictionary of the same type as mapping with a fixed set of
keys mapping to strategies. mapping must be a dict subclass.</p>
<p>Generated values have all keys present in mapping, with the
corresponding values drawn from mapping[key]. If mapping is an
instance of OrderedDict the keys will also be in the same order,
otherwise the order is arbitrary.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.dictionaries">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">dictionaries</code><span class="sig-paren">(</span><em>keys</em>, <em>values</em>, <em>dict_class=&lt;type 'dict'&gt;</em>, <em>min_size=None</em>, <em>average_size=None</em>, <em>max_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#dictionaries"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.dictionaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates dictionaries of type dict_class with keys drawn from the keys
argument and values drawn from the values argument.</p>
<p>The size parameters have the same interpretation as for lists.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.streaming">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">streaming</code><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#streaming"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.streaming" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an infinite stream of values where each value is drawn from
elements.</p>
<p>The result is iterable (the iterator will never terminate) and
indexable.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.characters">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">characters</code><span class="sig-paren">(</span><em>whitelist_categories=None</em>, <em>blacklist_categories=None</em>, <em>blacklist_characters=None</em>, <em>min_codepoint=None</em>, <em>max_codepoint=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#characters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.characters" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates unicode text type (unicode on python 2, str on python 3)
characters following specified filtering rules.</p>
<p>This strategy accepts lists of Unicode categories, characters of which
should (<cite>whitelist_categories</cite>) or should not (<cite>blacklist_categories</cite>)
be produced.</p>
<p>Also there could be applied limitation by minimal and maximal produced
code point of the characters.</p>
<p>If you know what exactly characters you don’t want to be produced,
pass them with <cite>blacklist_characters</cite> argument.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.text">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">text</code><span class="sig-paren">(</span><em>alphabet=None</em>, <em>min_size=None</em>, <em>average_size=None</em>, <em>max_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#text"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.text" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates values of a unicode text type (unicode on python 2, str on
python 3) with values drawn from alphabet, which should be an iterable of
length one strings or a strategy generating such. If it is None it will
default to generating the full unicode range. If it is an empty collection
this will only generate empty strings.</p>
<p>min_size, max_size and average_size have the usual interpretations.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.binary">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">binary</code><span class="sig-paren">(</span><em>min_size=None</em>, <em>average_size=None</em>, <em>max_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#binary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the appropriate binary type (str in python 2, bytes in python
3).</p>
<p>min_size, average_size and max_size have the usual interpretations.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.randoms">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">randoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#randoms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.randoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates instances of Random (actually a Hypothesis specific
RandomWithSeed class which displays what it was initially seeded with)</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.random_module">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">random_module</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#random_module"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.random_module" title="Permalink to this definition">¶</a></dt>
<dd><p>If your code depends on the global random module then you need to use
this.</p>
<p>It will explicitly seed the random module at the start of your test
so that tests are reproducible. The value it passes you is an opaque
object whose only useful feature is that its repr displays the
random seed. It is not itself a random number generator. If you want
a random number generator you should use the randoms() strategy
which will give you one.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.fractions">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">fractions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#fractions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.fractions" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates instances of fractions.Fraction.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.decimals">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">decimals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#decimals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.decimals" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates instances of decimals.Decimal.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.builds">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">builds</code><span class="sig-paren">(</span><em>target</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#builds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.builds" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates values by drawing from args and kwargs and passing them to
target in the appropriate argument position.</p>
<p>e.g. builds(target,
integers(), flag=booleans()) would draw an integer i and a boolean b and
call target(i, flag=b).</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.recursive">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">recursive</code><span class="sig-paren">(</span><em>base</em>, <em>extend</em>, <em>max_leaves=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#recursive"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.recursive" title="Permalink to this definition">¶</a></dt>
<dd><p>base: A strategy to start from.</p>
<p>extend: A function which takes a strategy and returns a new strategy.</p>
<p>max_leaves: The maximum number of elements to be drawn from base on a given
run.</p>
<p>This returns a strategy S such that S = extend(base | S). That is, values
maybe drawn from base, or from any strategy reachable by mixing
applications of | and extend.</p>
<p>An example may clarify: recursive(booleans(), lists) would return a
strategy that may return arbitrarily nested and mixed lists of booleans.
So e.g. False, [True], [False, []], [[[[True]]]], are all valid values to
be drawn from that strategy.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">hypothesis.strategies.</code><code class="descname">recursive</code><span class="sig-paren">(</span><em>base</em>, <em>extend</em>, <em>max_leaves=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#recursive"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>base: A strategy to start from.</p>
<p>extend: A function which takes a strategy and returns a new strategy.</p>
<p>max_leaves: The maximum number of elements to be drawn from base on a given
run.</p>
<p>This returns a strategy S such that S = extend(base | S). That is, values
maybe drawn from base, or from any strategy reachable by mixing
applications of | and extend.</p>
<p>An example may clarify: recursive(booleans(), lists) would return a
strategy that may return arbitrarily nested and mixed lists of booleans.
So e.g. False, [True], [False, []], [[[[True]]]], are all valid values to
be drawn from that strategy.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.permutations">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">permutations</code><span class="sig-paren">(</span><em>values</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#permutations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.permutations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a strategy which returns permutations of the collection
“values”.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.composite">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">composite</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#composite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.composite" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a strategy that is built out of potentially arbitrarily many
other strategies.</p>
<p>This is intended to be used as a decorator. See the full
documentation for more details about how to use this function.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">hypothesis.strategies.</code><code class="descname">composite</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#composite"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Defines a strategy that is built out of potentially arbitrarily many
other strategies.</p>
<p>This is intended to be used as a decorator. See the full
documentation for more details about how to use this function.</p>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.shared">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">shared</code><span class="sig-paren">(</span><em>base</em>, <em>key=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#shared"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.shared" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a strategy that draws a single shared value per run, drawn from
base. Any two shared instances with the same key will share the same
value, otherwise the identity of this strategy will be used. That is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">shared</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">shared</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above x and y may draw different (or potentially the same) values.
In the following they will always draw the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">shared</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s">"hi"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">shared</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s">"hi"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="hypothesis.strategies.choices">
<code class="descclassname">hypothesis.strategies.</code><code class="descname">choices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/hypothesis/strategies.html#choices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#hypothesis.strategies.choices" title="Permalink to this definition">¶</a></dt>
<dd><p>Strategy that generates a function that behaves like random.choice.</p>
<p>Will note choices made for reproducibility.</p>
</dd></dl>

<div class="section" id="choices">
<h2>Choices<a class="headerlink" href="#choices" title="Permalink to this headline">¶</a></h2>
<p>Sometimes you need an input to be from a known set of items. hypothesis gives you 2 ways to do this, choice() and sampled_from().</p>
<p>Examples on how to use them both are below. First up choice:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">hypothesis</span> <span class="kn">import</span> <span class="n">given</span><span class="p">,</span> <span class="n">strategies</span> <span class="k">as</span> <span class="n">st</span>

<span class="nd">@given</span><span class="p">(</span><span class="n">user</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">min_size</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">service</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">min_size</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">choice</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">choices</span><span class="p">())</span>
<span class="k">def</span> <span class="nf">test_tickets</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">service</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
    <span class="n">t</span><span class="o">=</span><span class="n">choice</span><span class="p">((</span><span class="s">'ST'</span><span class="p">,</span> <span class="s">'LT'</span><span class="p">,</span> <span class="s">'TG'</span><span class="p">,</span> <span class="s">'CT'</span><span class="p">))</span>
    <span class="c"># asserts go here.</span>
</pre></div>
</div>
<p>This means t will randomly be one of the items in the list (‘ST’, ‘LT’, ‘TG’, ‘CT’). just like if you were calling random.choice() on the list.</p>
<p>A different, and probably better way to do this, is to use sampled_from:</p>
<div class="code python highlight-python"><div class="highlight"><pre>from hypothesis import given, strategies as st

@given(
    user=st.text(min_size=1), service=st.text(min_size=1),
    t=st.sampled_from(('ST', 'LT', 'TG', 'CT')))
def test_tickets(user, service, t):
    # asserts and test code go here.
</pre></div>
</div>
<p>Values from sampled_from will not be copied and thus you should be careful of using mutable data. Which makes it great for the above use case, but may not always work out.</p>
</div>
<div class="section" id="infinite-streams">
<h2>Infinite streams<a class="headerlink" href="#infinite-streams" title="Permalink to this headline">¶</a></h2>
<p>Sometimes you need examples of a particular type to keep your test going but
you’re not sure how many you’ll need in advance. For this, we have streaming
types.</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hypothesis.strategies</span> <span class="kn">import</span> <span class="n">streaming</span><span class="p">,</span> <span class="n">integers</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">streaming</span><span class="p">(</span><span class="n">integers</span><span class="p">())</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">Stream(...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">209</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">Stream(32, 132, 209, ...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
<span class="go">130</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">Stream(32, 132, 209, 843, -19, 58, 141, -1046, 37, 243, 130, ...)</span>
</pre></div>
</div>
<p>Think of a Stream as an infinite list where we’ve only evaluated as much as
we need to. As per above, you can index into it and the stream will be evaluated up to
that index and no further.</p>
<p>You can iterate over it too (warning: iter on a stream given to you
by Hypothesis in this way will never terminate):</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">132</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">209</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">843</span>
</pre></div>
</div>
<p>Slicing will also work, and will give you back Streams. If you set an upper
bound then iter on those streams <em>will</em> terminate:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="mi">5</span><span class="p">])</span>
<span class="go">[32, 132, 209, 843, -19]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">Stream(...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">132</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">843</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">Stream(132, 843, ...)</span>
</pre></div>
</div>
<p>You can also apply a function to transform a stream:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">streaming</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tm</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">26</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tm</span>
<span class="go">Stream(26, ...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span>
<span class="go">Stream(13, ...)</span>
</pre></div>
</div>
<p>map creates a new stream where each element of the stream is the function
applied to the corresponding element of the original stream. Evaluating the
new stream will force evaluating the original stream up to that index.</p>
<p>(Warning: This isn’t the map builtin. In Python 3 the builtin map should do
more or less the right thing, but in Python 2 it will never terminate and
will just eat up all your memory as it tries to build an infinitely long list)</p>
<p>These are the only operations a Stream supports. There are a few more internal
ones, but you shouldn’t rely on them.</p>
</div>
<div class="section" id="adapting-strategies">
<h2>Adapting strategies<a class="headerlink" href="#adapting-strategies" title="Permalink to this headline">¶</a></h2>
<p>Often it is the case that a strategy doesn’t produce exactly what you want it
to and you need to adapt it. Sometimes you can do this in the test, but this
hurts reuse because you then have to repeat the adaption in every test.</p>
<p>Hypothesis gives you ways to build strategies from other strategies given
functions for transforming the data.</p>
<div class="section" id="mapping">
<h3>Mapping<a class="headerlink" href="#mapping" title="Permalink to this headline">¶</a></h3>
<p>Map is probably the easiest and most useful of these to use. If you have a
strategy s and a function f, then an example s.map(f).example() is
f(s.example()). i.e. we draw an example from s and then apply f to it.</p>
<p>e.g.:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">(</span><span class="n">integers</span><span class="p">())</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">sorted</span><span class="p">)</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">[1, 5, 17, 21, 24, 30, 45, 82, 88, 88, 90, 96, 105]</span>
</pre></div>
</div>
<p>Note that many things that you might use mapping for can also be done with the
builds function in hypothesis.strategies.</p>
</div>
<div class="section" id="filtering">
<h3>Filtering<a class="headerlink" href="#filtering" title="Permalink to this headline">¶</a></h3>
<p>filter lets you reject some examples. s.filter(f).example() is some example
of s such that f(s) is truthy.</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">integers</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">11</span><span class="p">)</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">1873</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integers</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">11</span><span class="p">)</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">73</span>
</pre></div>
</div>
<p>It’s important to note that filter isn’t magic and if your condition is too
hard to satisfy then this can fail:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">integers</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">"/home/david/projects/hypothesis/src/hypothesis/searchstrategy/strategies.py"</span>, line <span class="m">175</span>, in <span class="n">example</span>
    <span class="s">'Could not find any valid examples in 20 tries'</span>
<span class="gr">hypothesis.errors.NoExamples</span>: <span class="n">Could not find any valid examples in 20 tries</span>
</pre></div>
</div>
<p>In general you should try to use filter only to avoid corner cases that you
don’t want rather than attempting to cut out a large chunk of the search space.</p>
<p>A technique that often works well here is to use map to first transform the data
and then use filter to remove things that didn’t work out. So for example if you
wanted pairs of integers (x,y) such that x &lt; y you could do the following:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tuples</span><span class="p">(</span><span class="n">integers</span><span class="p">(),</span> <span class="n">integers</span><span class="p">()))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">(42, 1281698)</span>
</pre></div>
</div>
</div>
<div class="section" id="chaining-strategies-together">
<h3>Chaining strategies together<a class="headerlink" href="#chaining-strategies-together" title="Permalink to this headline">¶</a></h3>
<p>Finally there is flatmap. Flatmap draws an example, then turns that example
into a strategy, then draws an example from <em>that</em> strategy.</p>
<p>It may not be obvious why you want this at first, but it turns out to be
quite useful because it lets you generate different types of data with
relationships to eachother.</p>
<p>For example suppose we wanted to generate a list of lists of the same
length:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hypothesis.strategies</span> <span class="kn">import</span> <span class="n">integers</span><span class="p">,</span> <span class="n">lists</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hypothesis</span> <span class="kn">import</span> <span class="n">find</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rectangle_lists</span> <span class="o">=</span> <span class="n">integers</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">flatmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span>
<span class="gp">... </span><span class="n">lists</span><span class="p">(</span><span class="n">lists</span><span class="p">(</span><span class="n">integers</span><span class="p">(),</span> <span class="n">min_size</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="n">n</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find</span><span class="p">(</span><span class="n">rectangle_lists</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find</span><span class="p">(</span><span class="n">rectangle_lists</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">[[], [], [], [], [], [], [], [], [], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find</span><span class="p">(</span><span class="n">rectangle_lists</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find</span><span class="p">(</span><span class="n">rectangle_lists</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">t</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">[[0], [0], [0], [0], [0], [0], [0], [0], [0], [0]]</span>
</pre></div>
</div>
<p>In this example we first choose a length for our tuples, then we build a
strategy which generates lists containing lists precisely of that length. The
finds show what simple examples for this look like.</p>
<p>Most of the time you probably don’t want flatmap, but unlike filter and map
which are just conveniences for things you could just do in your tests,
flatmap allows genuinely new data generation that you wouldn’t otherwise be
able to easily do.</p>
<p>(If you know Haskell: Yes, this is more or less a monadic bind. If you don’t
know Haskell, ignore everything in these parentheses. You do not need to
understand anything about monads to use this, or anything else in Hypothesis).</p>
</div>
<div class="section" id="recursive-data">
<h3>Recursive data<a class="headerlink" href="#recursive-data" title="Permalink to this headline">¶</a></h3>
<p>Sometimes the data you want to generate has a recursive definition. e.g. if you
wanted to generate JSON data, valid JSON is:</p>
<ol class="arabic simple">
<li>Any float, any boolean, any unicode string.</li>
<li>Any list of valid JSON data</li>
<li>Any dictionary mapping unicode strings to valid JSON data.</li>
</ol>
<p>The problem is that you cannot call a strategy recursively and expect it to not just
blow up and eat all your memory.</p>
<p>The way Hypothesis handles this is with the ‘recursive’ function in hypothesis.strategies
which you pass in a base case and a function that given a strategy for your data type
returns a new strategy for it. So for example:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hypothesis.strategies</span> <span class="kn">as</span> <span class="nn">st</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">recursive</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">floats</span><span class="p">()</span> <span class="o">|</span> <span class="n">st</span><span class="o">.</span><span class="n">booleans</span><span class="p">()</span> <span class="o">|</span> <span class="n">st</span><span class="o">.</span><span class="n">text</span><span class="p">()</span> <span class="o">|</span> <span class="n">st</span><span class="o">.</span><span class="n">none</span><span class="p">(),</span>
<span class="gp">... </span><span class="k">lambda</span> <span class="n">children</span><span class="p">:</span> <span class="n">st</span><span class="o">.</span><span class="n">lists</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">|</span> <span class="n">st</span><span class="o">.</span><span class="n">dictionaries</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">text</span><span class="p">(),</span> <span class="n">children</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">{'': None, '\U000b3407\U000b3407\U000b3407': {</span>
<span class="go">    '': '"é""é\x11', '\x13': 1.6153068016570349e-282,</span>
<span class="go">    '\x00': '\x11\x11\x11"\x11"é"éé\x11""éé"\x11"éé\x11éé\x11é\x11',</span>
<span class="go">  '\x80': 'é\x11\x11\x11\x11\x11\x11', '\x13\x13\x00\x80\x80\x00': 4.643602465868519e-144</span>
<span class="go">  }, '\U000b3407': None}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">'\x06ě\U000d25e4H\U000d25e4\x06ě'</span>
</pre></div>
</div>
<p>That is, we start with our leaf data and then we augment it by allowing lists and dictionaries of anything we can generate as JSON data.</p>
<p>The size control of this works by limiting the maximum number of values that can be drawn from the base strategy. So for example if
we wanted to only generate really small JSON we could do this as:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">small_lists</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">recursive</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">booleans</span><span class="p">(),</span> <span class="n">st</span><span class="o">.</span><span class="n">lists</span><span class="p">,</span> <span class="n">max_leaves</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">small_lists</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">small_lists</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">[[False], [], [], [], [], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">small_lists</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">small_lists</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="composite-strategies">
<h2>Composite strategies<a class="headerlink" href="#composite-strategies" title="Permalink to this headline">¶</a></h2>
<p>The @composite decorator lets you combine other strategies in more or less
arbitrary ways. It’s probably the main thing you’ll want to use for
complicated custom strategies.</p>
<p>The composite decorator works by giving you a function as the first argument
that you can use to draw examples from other strategies. For example, the
following gives you a list and an index into it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@composite</span>
<span class="k">def</span> <span class="nf">list_and_index</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="n">integers</span><span class="p">()):</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">lists</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">integers</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>‘draw(s)’ is a function that should be thought of as returning s.example(),
except that the result is reproducible and will minimize correctly. The
decorated function has the initial argument removed from the list, but will
accept all the others in the expected order. Defaults are preserved.</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">list_and_index</span><span class="p">()</span>
<span class="go">list_and_index()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">list_and_index</span><span class="p">()</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">([5585, 4073], 1)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">list_and_index</span><span class="p">(</span><span class="n">booleans</span><span class="p">())</span>
<span class="go">list_and_index(elements=booleans())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">list_and_index</span><span class="p">(</span><span class="n">booleans</span><span class="p">())</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">([False, False, True], 1)</span>
</pre></div>
</div>
<p>Note that the repr will work exactly like it does for all the built-in
strategies: It will be a function that you can call to get the strategy in
question, with values provided only if they do not match the defaults.</p>
<p>You can use assume inside composite functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@composite</span>
<span class="k">def</span> <span class="nf">distinct_strings_with_common_characters</span><span class="p">(</span><span class="n">draw</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">text</span><span class="p">(),</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="n">alphabet</span><span class="o">=</span><span class="n">x</span><span class="p">))</span>
    <span class="n">assume</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>This works as assume normally would, filtering out any examples for which the
passed in argument is falsey.</p>
</div>
<div class="section" id="drawing-interactively-in-tests">
<h2>Drawing interactively in tests<a class="headerlink" href="#drawing-interactively-in-tests" title="Permalink to this headline">¶</a></h2>
<p>There is also the <code class="docutils literal"><span class="pre">data()</span></code> strategy, which gives you a means of using
strategies interactively. Rather than having to specify everything up front in
<code class="docutils literal"><span class="pre">@given</span></code> you can draw from strategies in the body of your test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@given</span><span class="p">(</span><span class="n">data</span><span class="p">())</span>
<span class="k">def</span> <span class="nf">test_draw_sequentially</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">integers</span><span class="p">())</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">integers</span><span class="p">(</span><span class="n">min_value</span><span class="o">=</span><span class="n">x</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span>
</pre></div>
</div>
<p>If the test fails, each draw will be printed with the falsifying example. e.g.
the above is wrong (it has a boundary condition error), so will print:</p>
<div class="highlight-python"><div class="highlight"><pre>Falsifying example: test_draw_sequentially(data=data(...))
Draw 1: 0
Draw 2: 0
</pre></div>
</div>
<p>As you can see, data drawn this way is simplified as usual.</p>
</div>
</div>


           </div></body></html>