<html><body><div><div class="pf-content"><p>Python decorators are really cool, but they can be a little hard to understand at first. A decorator in Python is a function that accepts another function as an argument. The decorator will usually modify or enhance the function it accepted and return the modified function. This means that when you call a decorated function, you will get a function that may be a little different that may have additional features compared with the base definition. But let’s back up a bit. We should probably review the basic building block of a decorator, namely, the function.<span id="more-1433"/></p>
<hr/>
<h3>A Simple Function</h3>
<p>
</p><p>A function is a block of code that begins with the Python keyword <strong>def</strong> followed by the actual name of the function. A function can accept zero or more arguments, keyword arguments or a mixture of the two. A function always returns something. If you do not specify what a function should return, it will return <strong>None</strong>. Here is a very simple function that just returns a string:</p>
<pre class="python"><span>#----------------------------------------------------------------------</span>
<span>def</span> a_function<span>(</span><span>)</span>:
    <span>""</span><span>"A pretty useless function"</span><span>""</span>
    <span>return</span> <span>"1+1"</span>
 
<span>#----------------------------------------------------------------------</span>
<span>if</span> __name__ == <span>"__main__"</span>:
    value = a_function<span>(</span><span>)</span>
    <span>print</span><span>(</span>value<span>)</span></pre>
<p>We call the function and print the return value. Let’s create another function:</p>
<pre class="python"><span>#----------------------------------------------------------------------</span>
<span>def</span> another_function<span>(</span>func<span>)</span>:
    <span>""</span><span>"
    A function that accepts another function
    "</span><span>""</span>
    <span>def</span> other_func<span>(</span><span>)</span>:
        val = <span>"The result of %s is %s"</span> <span>%</span> <span>(</span>func<span>(</span><span>)</span>,
                                          <span>eval</span><span>(</span>func<span>(</span><span>)</span><span>)</span>
                                          <span>)</span>
        <span>return</span> val
    <span>return</span> other_func</pre>
<p>This function accepts one argument and that argument has to be a function or callable. In fact, it really should only be called using the previously defined function. You will note that this function has a nested function inside of it that we are calling <strong>other_func</strong>. It will take the result of the function passed to it, evaluate it and create a string that tells us about what it did, which it then returns. Let’s look at the full version of the code:</p>
<pre class="python"><span>#----------------------------------------------------------------------</span>
<span>def</span> another_function<span>(</span>func<span>)</span>:
    <span>""</span><span>"
    A function that accepts another function
    "</span><span>""</span>
 
    <span>def</span> other_func<span>(</span><span>)</span>:
        val = <span>"The result of %s is %s"</span> <span>%</span> <span>(</span>func<span>(</span><span>)</span>,
                                          <span>eval</span><span>(</span>func<span>(</span><span>)</span><span>)</span>
                                          <span>)</span>
        <span>return</span> val
    <span>return</span> other_func
 
<span>#----------------------------------------------------------------------</span>
<span>def</span> a_function<span>(</span><span>)</span>:
    <span>""</span><span>"A pretty useless function"</span><span>""</span>
    <span>return</span> <span>"1+1"</span>
 
<span>#----------------------------------------------------------------------</span>
<span>if</span> __name__ == <span>"__main__"</span>:
    value = a_function<span>(</span><span>)</span>
    <span>print</span><span>(</span>value<span>)</span>
    decorator = another_function<span>(</span>a_function<span>)</span>
    <span>print</span> decorator<span>(</span><span>)</span></pre>
<p>This is how a decorator works. We create one function and then pass it into a second function. The second function is the decorator function. The decorator will modify or enhance the function that was passed to it and return the modification. If you run this code, you should see the following as output to stdout:</p>
<p><code><br/>
1+1<br/>
The result of 1+1 is 2<br/>
</code></p>
<p>Let’s change the code slightly to turn <strong>another_function</strong> into a decorator:</p>
<pre class="python"><span>#----------------------------------------------------------------------</span>
<span>def</span> another_function<span>(</span>func<span>)</span>:
    <span>""</span><span>"
    A function that accepts another function
    "</span><span>""</span>
 
    <span>def</span> other_func<span>(</span><span>)</span>:
        val = <span>"The result of %s is %s"</span> <span>%</span> <span>(</span>func<span>(</span><span>)</span>,
                                          <span>eval</span><span>(</span>func<span>(</span><span>)</span><span>)</span>
                                          <span>)</span>
        <span>return</span> val
    <span>return</span> other_func
 
<span>#----------------------------------------------------------------------</span>
@another_function
<span>def</span> a_function<span>(</span><span>)</span>:
    <span>""</span><span>"A pretty useless function"</span><span>""</span>
    <span>return</span> <span>"1+1"</span>
 
<span>#----------------------------------------------------------------------</span>
<span>if</span> __name__ == <span>"__main__"</span>:
    value = a_function<span>(</span><span>)</span>
    <span>print</span><span>(</span>value<span>)</span></pre>
<p>You will note that in Python, a decorator starts with the <strong>@</strong> symbol followed by the name of the function that we will be using to “decorate” our regular with. To apply the decorator, you just put it on the line before the function definition. Now when we call <strong>a_function</strong>, it will get decorated and we’ll get the following result:</p>
<p><code><br/>
The result of 1+1 is 2<br/>
</code></p>
<p>Let’s create a decorator that actually does something useful.</p>
<hr/>
<h3>Creating a Logging Decorator</h3>
<p>
</p><p>Sometimes you will want to create a log of what a function is doing. Most of the time, you will probably be doing your logging within the function itself. Occasionally you might want to do it at the function level to get an idea of the flow of the program or perhaps to fulfill some business rules, like auditing. Here’s a little decorator that we can use to record any function’s name and what it returns:</p>
<pre class="python"><span>import</span> <span>logging</span>
 
<span>#----------------------------------------------------------------------</span>
<span>def</span> log<span>(</span>func<span>)</span>:
    <span>""</span><span>"
    Log what function is called
    "</span><span>""</span>
    <span>def</span> wrap_log<span>(</span><span>*</span>args, <span>**</span>kwargs<span>)</span>:
        name = func.__name__
        logger = <span>logging</span>.<span>getLogger</span><span>(</span>name<span>)</span>
        logger.<span>setLevel</span><span>(</span><span>logging</span>.<span>INFO</span><span>)</span>
 
        <span># add file handler</span>
        fh = <span>logging</span>.<span>FileHandler</span><span>(</span><span>"%s.log"</span> <span>%</span> name<span>)</span>
        fmt = <span>'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>
        <span>formatter</span> = <span>logging</span>.<span>Formatter</span><span>(</span>fmt<span>)</span>
        fh.<span>setFormatter</span><span>(</span><span>formatter</span><span>)</span>
        logger.<span>addHandler</span><span>(</span>fh<span>)</span>
 
        logger.<span>info</span><span>(</span><span>"Running function: %s"</span> <span>%</span> name<span>)</span>
        result = func<span>(</span><span>*</span>args, <span>**</span>kwargs<span>)</span>
        logger.<span>info</span><span>(</span><span>"Result: %s"</span> <span>%</span> result<span>)</span>
        <span>return</span> func
    <span>return</span> wrap_log
 
<span>#----------------------------------------------------------------------</span>
@log
<span>def</span> double_function<span>(</span>a<span>)</span>:
    <span>""</span><span>"
    Double the input parameter
    "</span><span>""</span>
    <span>return</span> a<span>*</span><span>2</span>
 
<span>#----------------------------------------------------------------------</span>
<span>if</span> __name__ == <span>"__main__"</span>:
    value = double_function<span>(</span><span>2</span><span>)</span></pre>
<p>This little script has a <strong>log</strong> function that accepts a function as its sole argument. It will create a logger object and a log file name based on the name of the function. Then the log function will log what function was called and what the function returned, if anything. </p>
<hr/>
<h3>Built-in Decorators</h3>
<p>
</p><p>Python comes with several built-in decorators. The big three are:</p>
<ul>
<li>@classmethod</li>
<li>@staticmethod</li>
<li>@property</li>
</ul>
<p>There are also decorators in various parts of Python’s standard library. One example would be <strong>functools.wraps</strong>. We will be limiting our scope to the three above though. </p>
<hr/>
<h3>@classmethod and @staticmethod</h3>
<p>
</p><p>I have never actually used these myself, so I did a fair bit of research. The <strong>@classmethod</strong> decorator can be called with with an instance of a class or directly by the class itself as its first argument. According to the Python <a href="http://docs.python.org/2/library/functions.html#classmethod" target="_blank">documentation</a>: <em>It can be called either on the class (such as C.f()) or on an instance (such as C().f()). The instance is ignored except for its class. If a class method is called for a derived class, the derived class object is passed as the implied first argument.</em> The primary use case of a @classmethod decorator that I have found in my research is as an alternate constructor or helper method for initialization.</p>
<p>The <strong>@staticmethod</strong> decorator is just a function inside of a class. You can call it both with and without instantiating the class. A typical use case is when you have a function where you believe it has a connection with a class. It’s a stylistic choice for the most part. </p>
<p>It might help to see a code example of how these two decorators work:</p>
<pre class="python"><span>########################################################################</span>
<span>class</span> DecoratorTest<span>(</span><span>object</span><span>)</span>:
    <span>""</span><span>"
    Test regular method vs @classmethod vs @staticmethod
    "</span><span>""</span>
 
    <span>#----------------------------------------------------------------------</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>)</span>:
        <span>""</span><span>"Constructor"</span><span>""</span>
        <span>pass</span>
 
    <span>#----------------------------------------------------------------------</span>
    <span>def</span> doubler<span>(</span><span>self</span>, x<span>)</span>:
        <span>""</span><span>""</span><span>""</span>
        <span>print</span><span>(</span><span>"running doubler"</span><span>)</span>
        <span>return</span> x<span>*</span><span>2</span>
 
    <span>#----------------------------------------------------------------------</span>
    @<span>classmethod</span>
    <span>def</span> class_tripler<span>(</span>klass, x<span>)</span>:
        <span>""</span><span>""</span><span>""</span>
        <span>print</span><span>(</span><span>"running tripler: %s"</span> <span>%</span> klass<span>)</span>
        <span>return</span> x<span>*</span><span>3</span>
 
    <span>#----------------------------------------------------------------------</span>
    @<span>staticmethod</span>
    <span>def</span> static_quad<span>(</span>x<span>)</span>:
        <span>""</span><span>""</span><span>""</span>
        <span>print</span><span>(</span><span>"running quad"</span><span>)</span>
        <span>return</span> x<span>*</span><span>4</span>
 
<span>#----------------------------------------------------------------------</span>
<span>if</span> __name__ == <span>"__main__"</span>:
    decor = DecoratorTest<span>(</span><span>)</span>
    <span>print</span><span>(</span>decor.<span>doubler</span><span>(</span><span>5</span><span>)</span><span>)</span>
    <span>print</span><span>(</span>decor.<span>class_tripler</span><span>(</span><span>3</span><span>)</span><span>)</span>
    <span>print</span><span>(</span>DecoratorTest.<span>class_tripler</span><span>(</span><span>3</span><span>)</span><span>)</span>
    <span>print</span><span>(</span>DecoratorTest.<span>static_quad</span><span>(</span><span>2</span><span>)</span><span>)</span>
    <span>print</span><span>(</span>decor.<span>static_quad</span><span>(</span><span>3</span><span>)</span><span>)</span>
 
    <span>print</span><span>(</span>decor.<span>doubler</span><span>)</span>
    <span>print</span><span>(</span>decor.<span>class_tripler</span><span>)</span>
    <span>print</span><span>(</span>decor.<span>static_quad</span><span>)</span></pre>
<p>This example demonstrates that you can call a regular method and both decorated methods in the same way. You will notice that you can call both the @classmethod and the @staticmethod decorated functions directly with from the class or from an instance of the class. If you try to call a regular function with the class (i.e. DecoratorTest.doubler(2)) you will receive a <strong>TypeError</strong>. You will also note that the last print statement shows that decor.static_quad returns a regular function instead of a bound method. </p>
<hr/>
<h3>Python’s Properties</h3>
<p>
</p><p>I’ve written about the <strong>@property</strong> decorator once already this year, so I’ll just reprint a slight variation of that <a href="http://www.blog.pythonlibrary.org/2014/01/20/python-201-properties/" target="_blank">article</a> here.</p>
<p>Python has a neat little concept called a <strong>property</strong> that can do several useful things. We will be looking into how to do the following:</p>
<ul>
<li>Convert class methods into read-only attributes</li>
<li>Reimplement setters and getters into an attribute</li>
</ul>
<p>One of the simplest ways to use a property is to use it as a decorator of a method. This allows you to turn a class method into a class attribute. I find this useful when I need to do some kind of combination of values. Others have found it useful for writing conversion methods that they want to have access to as methods. Let’s take a look at a simple example:</p>
<pre class="python"><span>########################################################################</span>
<span>class</span> Person<span>(</span><span>object</span><span>)</span>:
    <span>""</span><span>""</span><span>""</span>
 
    <span>#----------------------------------------------------------------------</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span>, first_name, last_name<span>)</span>:
        <span>""</span><span>"Constructor"</span><span>""</span>
        <span>self</span>.<span>first_name</span> = first_name
        <span>self</span>.<span>last_name</span> = last_name
 
    <span>#----------------------------------------------------------------------</span>
    @<span>property</span>
    <span>def</span> full_name<span>(</span><span>self</span><span>)</span>:
        <span>""</span><span>"
        Return the full name
        "</span><span>""</span>
        <span>return</span> <span>"%s %s"</span> <span>%</span> <span>(</span><span>self</span>.<span>first_name</span>, <span>self</span>.<span>last_name</span><span>)</span></pre>
<p>In the code above, we create two class attributes or properties: <strong>self.first_name</strong> and <strong>self.last_name</strong>. Next we create a <strong>full_name</strong> method that has a <strong>@property</strong> decorator attached to it. This allows us to the following in an interpreter session:</p>
<pre class="python"><span>&gt;&gt;&gt;</span> person = Person<span>(</span><span>"Mike"</span>, <span>"Driscoll"</span><span>)</span>
<span>&gt;&gt;&gt;</span> person.<span>full_name</span>
<span>'Mike Driscoll'</span>
<span>&gt;&gt;&gt;</span> person.<span>first_name</span>
<span>'Mike'</span>
<span>&gt;&gt;&gt;</span> person.<span>full_name</span> = <span>"Jackalope"</span>
Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;string&gt;"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>fragment<span>&gt;</span>
<span>AttributeError</span>: can<span>'t set attribute</span></pre>
<p>As you can see, because we turned the method into a property, we can access it using normal dot notation. However, if we try to set the property to something different, we will cause an <strong>AttributeError</strong> to be raised. The only way to change the <strong>full_name</strong> property is to do so indirectly:</p>
<pre class="python"><span>&gt;&gt;&gt;</span> person.<span>first_name</span> = <span>"Dan"</span>
<span>&gt;&gt;&gt;</span> person.<span>full_name</span>
<span>'Dan Driscoll'</span></pre>
<p>This is kind of limiting, so let’s look at another example where we can make a property that <strong>does</strong> allow us to set it.</p>
<h3>Replacing Setters and Getters with a Python property</h3>
<p>
</p><p>Let’s pretend that we have some legacy code that someone wrote who didn’t understand Python very well. If you’re like me, you’ve already seen this kind of code before:</p>
<pre class="python"><span>from</span> <span>decimal</span> <span>import</span> Decimal
 
<span>########################################################################</span>
<span>class</span> Fees<span>(</span><span>object</span><span>)</span>:
    <span>""</span><span>""</span><span>""</span>
 
    <span>#----------------------------------------------------------------------</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>)</span>:
        <span>""</span><span>"Constructor"</span><span>""</span>
        <span>self</span>._fee = <span>None</span>
 
    <span>#----------------------------------------------------------------------</span>
    <span>def</span> get_fee<span>(</span><span>self</span><span>)</span>:
        <span>""</span><span>"
        Return the current fee
        "</span><span>""</span>
        <span>return</span> <span>self</span>._fee
 
    <span>#----------------------------------------------------------------------</span>
    <span>def</span> set_fee<span>(</span><span>self</span>, value<span>)</span>:
        <span>""</span><span>"
        Set the fee
        "</span><span>""</span>
        <span>if</span> <span>isinstance</span><span>(</span>value, <span>str</span><span>)</span>:
            <span>self</span>._fee = Decimal<span>(</span>value<span>)</span>
        <span>elif</span> <span>isinstance</span><span>(</span>value, Decimal<span>)</span>:
            <span>self</span>._fee = value</pre>
<p>To use this class, we have to use the setters and getters that are defined:</p>
<pre class="python"><span>&gt;&gt;&gt;</span> f = Fees<span>(</span><span>)</span>
<span>&gt;&gt;&gt;</span> f.<span>set_fee</span><span>(</span><span>"1"</span><span>)</span>
<span>&gt;&gt;&gt;</span> f.<span>get_fee</span><span>(</span><span>)</span>
Decimal<span>(</span><span>'1'</span><span>)</span></pre>
<p>If you want to add the normal dot notation access of attributes to this code without breaking all the applications that depend on this piece of code, you can change it very simply by adding a property:</p>
<pre class="python"><span>from</span> <span>decimal</span> <span>import</span> Decimal
 
<span>########################################################################</span>
<span>class</span> Fees<span>(</span><span>object</span><span>)</span>:
    <span>""</span><span>""</span><span>""</span>
 
    <span>#----------------------------------------------------------------------</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>)</span>:
        <span>""</span><span>"Constructor"</span><span>""</span>
        <span>self</span>._fee = <span>None</span>
 
    <span>#----------------------------------------------------------------------</span>
    <span>def</span> get_fee<span>(</span><span>self</span><span>)</span>:
        <span>""</span><span>"
        Return the current fee
        "</span><span>""</span>
        <span>return</span> <span>self</span>._fee
 
    <span>#----------------------------------------------------------------------</span>
    <span>def</span> set_fee<span>(</span><span>self</span>, value<span>)</span>:
        <span>""</span><span>"
        Set the fee
        "</span><span>""</span>
        <span>if</span> <span>isinstance</span><span>(</span>value, <span>str</span><span>)</span>:
            <span>self</span>._fee = Decimal<span>(</span>value<span>)</span>
        <span>elif</span> <span>isinstance</span><span>(</span>value, Decimal<span>)</span>:
            <span>self</span>._fee = value
 
    fee = <span>property</span><span>(</span>get_fee, set_fee<span>)</span></pre>
<p>We added one line to the end of this code. Now we can do stuff like this:</p>
<pre class="python"><span>&gt;&gt;&gt;</span> f = Fees<span>(</span><span>)</span>
<span>&gt;&gt;&gt;</span> f.<span>set_fee</span><span>(</span><span>"1"</span><span>)</span>
<span>&gt;&gt;&gt;</span> f.<span>fee</span>
Decimal<span>(</span><span>'1'</span><span>)</span>
<span>&gt;&gt;&gt;</span> f.<span>fee</span> = <span>"2"</span>
<span>&gt;&gt;&gt;</span> f.<span>get_fee</span><span>(</span><span>)</span>
Decimal<span>(</span><span>'2'</span><span>)</span></pre>
<p>As you can see, when we use <strong>property</strong> in this manner, it allows the fee property to set and get the value itself without breaking the legacy code. Let’s rewrite this code using the property decorator and see if we can get it to allow setting.</p>
<pre class="python"><span>from</span> <span>decimal</span> <span>import</span> Decimal
 
<span>########################################################################</span>
<span>class</span> Fees<span>(</span><span>object</span><span>)</span>:
    <span>""</span><span>""</span><span>""</span>
 
    <span>#----------------------------------------------------------------------</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>)</span>:
        <span>""</span><span>"Constructor"</span><span>""</span>
        <span>self</span>._fee = <span>None</span>
 
    <span>#----------------------------------------------------------------------</span>
    @<span>property</span>
    <span>def</span> fee<span>(</span><span>self</span><span>)</span>:
        <span>""</span><span>"
        The fee property - the getter
        "</span><span>""</span>
        <span>return</span> <span>self</span>._fee
 
    <span>#----------------------------------------------------------------------</span>
    @fee.<span>setter</span>
    <span>def</span> fee<span>(</span><span>self</span>, value<span>)</span>:
        <span>""</span><span>"
        The setter of the fee property
        "</span><span>""</span>
        <span>if</span> <span>isinstance</span><span>(</span>value, <span>str</span><span>)</span>:
            <span>self</span>._fee = Decimal<span>(</span>value<span>)</span>
        <span>elif</span> <span>isinstance</span><span>(</span>value, Decimal<span>)</span>:
            <span>self</span>._fee = value
 
<span>#----------------------------------------------------------------------</span>
<span>if</span> __name__ == <span>"__main__"</span>:
    f = Fees<span>(</span><span>)</span></pre>
<p>The code above demonstrates how to create a “setter” for the <strong>fee</strong> property. You can do this by decorating a second method that is also called <strong>fee</strong> with a decorator called <strong>@fee.setter</strong>. The setter is invoked when you do something like this:</p>
<pre class="python"><span>&gt;&gt;&gt;</span> f = Fees<span>(</span><span>)</span>
<span>&gt;&gt;&gt;</span> f.<span>fee</span> = <span>"1"</span></pre>
<p>If you look at the signature for <strong>property</strong>, it has fget, fset, fdel and doc as “arguments”. You can create another decorated method using the same name to correspond to a delete function using <strong>@fee.deleter</strong> if you want to catch the <strong>del</strong> command against the attribute.</p>
<hr/>
<h3>Wrapping Up</h3>
<p>
</p><p>At this point you should know how to create your own decorators and how to use a few of Python’s built-in decorators. We looked at @classmethod, @property and @staticmethod. I would be curious to know how my readers use the built-in decorators and how they use their own custom decorators. </p>
<hr/>
<h3>Further Reading</h3>
<p>
</p>
</div>	</div></body></html>