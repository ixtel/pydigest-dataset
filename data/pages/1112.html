<html><body><div><div class="content html_format">
      <habracut/><p>В процессе самообучения языку программирования python(имея знания с/с++) решил написать в качестве задания функции генерирующие элементы из различных множеств </p><a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D0%B8%D0%BA%D0%B0">комбинаторных конфигураций</a><p>. Конечно, можно справедливо заметить, что подобный функционал уже есть в стандартной библиотеке python в модуле itertools, но у каждого должно быть право изобрести велосипед, тем более в целях обучения…</p><p>
 Тот кто знаком с основами теории вероятностей должны помнить, что такое урновые схемы и о чем эта таблица:
</p><img src="https://habrastorage.org/files/f2e/b23/a2f/f2eb23a2f8484c1395b98ec1af9e370a.png"/>
<p>
И так ТЗ — написать четыре генератора, которые принимая строку </p><b>s</b><p>, состоящую из уникальных символов, и размер выборки </p><b>к</b><p>, возвращают строку — выборку с повторением/без повторений из </p><b>k </b><p> символов строки </p><b>s</b><p> порядок важен/не важен.</p><p>
В результате получился следующий код:

</p><pre><code class="python">import itertools
from functools import partial

import unittest

def template(s, k, assertion, reducer):
    n = len(s)
    assert assertion(n, k)
    
    if k == 0:
        yield ""
    elif k == 1:
        for c in s:
            yield c
    else:
        k-=1
        for i, c in enumerate(s):
            new_s = reducer(s, i)
            if not assertion(len(new_s), k):
                break
            for res in template(new_s, k, assertion, reducer):
                yield c+res
            
assertion_norep = lambda n, k: n &gt; 0 and n &gt;= k and k &gt;= 0
assertion_rep   = lambda n, k: n &gt; 0 and k &gt;= 0

permutation_norep = partial(template, assertion=assertion_norep, reducer=lambda s, i: s[:i]+s[i+1:])
permutation_rep = partial(template, assertion=assertion_rep, reducer=lambda s, i: s)
combination_norep = partial(template, assertion=assertion_norep, reducer=lambda s, i: s[i+1:])
combination_rep = partial(template, assertion=assertion_rep, reducer=lambda s, i: s[i:])


class TestCombinatoricGenerators(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.test_string = "abcdefg"
        cls.k = 5

    def test_permutation_norep(self):
        self.assertEquals(set(permutation_norep(self.test_string, self.k)),
                          set(map(''.join, itertools.permutations(self.test_string, self.k))))

    def test_permutation_rep(self):
        self.assertEquals(set(permutation_rep(self.test_string, self.k)),
                          set(map(''.join, itertools.product(self.test_string, repeat=self.k))))

    def test_combination_norep(self):
        self.assertEquals(set(combination_norep(self.test_string, self.k)),
                          set(map(''.join, itertools.combinations(self.test_string, self.k))))

    def test_combination_rep(self):
        self.assertEquals(set(combination_rep(self.test_string, self.k)),
                          set(map(''.join, itertools.combinations_with_replacement(self.test_string, self.k))))

if __name__ == '__main__':
    unittest.main()</code></pre>
<p>
Так как python является языком еще более высокого уровня абстракции, чем с/с++, поэтому он позволяет проще и выразительнее писать код, который бы на других языках выглядел бы более громоздко и запутаннее. Новичкам в python я хотел бы обратить внимание на несколько моментов:

</p><ul>
<li>return после yield</li>
<li>Рекурсивный генератор</li>
<li>Шаблон стратегия</li>
<li>Использование lambda функций</li>
</ul>
<p>
P.S.</p><p>
Могу добавить, что я не сразу пришел к подобному решению, использующему общую «шаблонную» функцию. Сначала я написал все функции по отдельности, а потом выделил общее и различное.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>