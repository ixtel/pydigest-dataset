<html><body><div><div class="post">
      

      <span class="post-date">
        2014-09-22       </span>

      <p>During the night of the 14th to the 15th of September, a glorious looking BBQ pulled pork sandwich I had put on my kitchen table was half eaten.<br/>
The bite was seriously huge, think a good 100g of bread + meat.  <br/>
A previous accident, garbage bag being torn, suggested we might have a rodent issue in the house (or anything else really).<br/>
Being curious about who (could be a sleepeating housemate!)/what the hell ate my lunch, we decided to investigate with my flatmates.<br/>
No droppings and the quantity of food eaten rule out mice â or at least we think so, unless we're up against a colony of ninja mice â leaving us with rats, squirrels or stray cats: a small window was open in the kitchen, big enough for a small animal to enter.  </p>
<p>The best way to find out what it is being actually seeing it, we decided to put some bait out and film the kitchen at night.<br/>
We don't have a camera but we have webcams on our laptop.<br/>
How hard could it be to create a script to take pictures with it at a set interval ?<br/>
I ended up creating <a href="https://github.com/Keats/rodent">Rodent</a> to solve that issue.<br/>
One of my flatmates is a designer (Barbara Marcantonio, you can look at her <a href="http://grarighe.co.uk/">website</a>) and made a logo for it for fun.
<img alt="Rodent" src="https://raw.githubusercontent.com/Keats/rodent/master/logo.png"/></p>
<p>Below is an explanation of how it works, this is pretty basic but that was new to me !</p>
<h2>Installation</h2>
<p>The installation is a bit tricky as it uses <a href="http://opencv.org/">OpenCV</a> and needs a few dependencies for video/images (you will need the libjpg one for the pictures at least).<br/>
The setup for Ubuntu is described in the README, I haven't tried to install it on any other OS so I cannot comment on it.<br/>
Here's a photo of actualy physical installation:
<img alt="Laptop" src="http://vincent.is/images/articles/rodent/setup_laptop.jpg"/></p>
<p><img alt="Bait" src="http://vincent.is/images/articles/rodent/setup_bait.jpg"/></p>
<p>We were not sure of what we are trying to catch so the bait is pretty much a bit of everything: nutella, bread, tuna, cheese etc</p>
<h2>API</h2>
<p>Rodent exposes 4 methods:</p>
<ul>
<li>capture: takes a picture from the webcam at a given <code>interval</code> forever or <code>until</code> the time specified in the <code>folder</code> given</li>
<li>make_video: takes all the pictures in the <code>folder</code> and makes a video out of it, better than watching pictures!</li>
<li>automate: does both capture and make_video, I use it for example to record until 15 minutes before I wake up and the video will be ready by the time I get to the kitchen</li>
<li>motion: takes a picture only if it detects a movement (the sexy part)</li>
</ul>
<h2>Let's get down to business</h2>
<p>The first part I did was to take pictures at a set interval.
OpenCV exposes the webcam very simply:</p>
<div class="highlight"><pre><span class="c"># Get the webcam</span>
<span class="n">camera</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="c"># Take a picture, the ignored value being the return values</span>
<span class="n">_</span><span class="p">,</span> <span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>


<p>So this gives us an image, we now need to save it, once again OpenCV makes this very easy:</p>
<div class="highlight"><pre><span class="n">filename</span> <span class="o">=</span> <span class="s">'</span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s">.jpg'</span><span class="o">%</span> <span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">now</span><span class="p">)</span>
<span class="n">filepath</span> <span class="o">=</span> <span class="n">filename</span> 
<span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>
</pre></div>


<p>This works, but the main issue is that an image saved that way is around 64kB, which can be a lot if you take a picture every seconds for a whole day.<br/>
My first try was to open the image in PIL and save it right away while lowering the quality a bit:</p>
<div class="highlight"><pre><span class="c"># Resave it with pillow to do a better compression</span>
<span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
<span class="n">img</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">quality</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>
</pre></div>


<p>I realised while writing that part that I could also specify the compression directly in OpenCV and skipping PIL entirely!</p>
<div class="highlight"><pre><span class="n">filename</span> <span class="o">=</span> <span class="s">'</span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s">.jpg'</span>
<span class="n">filepath</span> <span class="o">=</span> <span class="n">filename</span> <span class="o">%</span> <span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">now</span><span class="p">)</span>
<span class="c"># Syntax is a bit odd but it works</span>
<span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">cv</span><span class="o">.</span><span class="n">CV_IMWRITE_JPEG_QUALITY</span><span class="p">,</span> <span class="mi">80</span><span class="p">])</span>
</pre></div>


<p>This gives an image of about 21kB, 3x times lower than the original one.<br/>
A pretty big save when multiplied by several thousands.  </p>
<p>Putting it together with an interval, the code is:</p>
<div class="highlight"><pre><span class="c"># check the start_camera function in rodent.py for the full method</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

    <span class="n">number</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">print</span> <span class="s">'Taking picture number </span><span class="si">%d</span><span class="s"> at </span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">now</span><span class="o">.</span><span class="n">isoformat</span><span class="p">())</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">save_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">now</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">time_over</span><span class="p">(</span><span class="n">until</span><span class="p">,</span> <span class="n">now</span><span class="p">):</span>
        <span class="k">break</span>

    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
</pre></div>


<p>A simple basic infinite loop that breaks on CTRL+C or if the time is over, nothing fancy.</p>
<h2>I'll make a video out of you</h2>
<p>Once again, OpenCV provides pretty much everything needed to make a video out of the box.  </p>
<div class="highlight"><pre><span class="c"># make_video in rodent.py</span>

<span class="c"># Sorting on dates, ISO ftw</span>
<span class="n">filenames</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder</span><span class="p">))</span>

<span class="c"># Find out size of the pictures we're taking</span>
<span class="n">first_pic</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'</span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="c"># shape gives a tuple (height, width, layer)</span>
<span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">first_pic</span><span class="o">.</span><span class="n">shape</span>

<span class="c"># magic below, might need to change the codec for your own webcam</span>
<span class="n">fourcc</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cv</span><span class="o">.</span><span class="n">CV_FOURCC</span><span class="p">(</span><span class="o">*</span><span class="s">'XVID'</span><span class="p">)</span>
<span class="n">video</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">VideoWriter</span><span class="p">(</span><span class="s">'output.avi'</span><span class="p">,</span> <span class="n">fourcc</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>

<span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
    <span class="n">video</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'</span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">)))</span>

<span class="n">video</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>


<p>The only tricky part is to take an image to get the size of the video and the fourcc parameter which is the 4-character code for the codec, which I pretty much tried randomly until I got one that works.<br/>
Right now the fps is determined completely arbitrarily depending on the number of pictures so it's highly probable that it will be too slow or too fast, simply change the value of the 3rd parameter to VideoWriter.<br/>
The only issue is that it seems that OpenCV doesn't write the last few images somehow.</p>
<h2>We must be swift as a coursing river</h2>
<p>(I have no idea why I'm referencing Mulan)<br/>
Let's get to the interesting part, the motion detection.<br/>
The need for that arose after the first night of the home-made CCTV: watching minutes of footage of a still background is not very interesting.
Rather than taking a pic every second, how about only taking a pic only if movement is detected, that would reduce the number of pictures significantly and make looking at it less boring.<br/>
Since we only care about movements, all the pictures for that part are converted to grayscale:</p>
<div class="highlight"><pre><span class="n">gray_pic</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">camera</span><span class="o">.</span><span class="n">read</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cv</span><span class="o">.</span><span class="n">CV_RGB2GRAY</span><span class="p">)</span>
</pre></div>


<h3>Algorithms</h3>
<p>The first obvious thing I tried was taking 2 pictures and doing a diff of them (again, OpenCV provides it through the <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#absdiff">absdiff</a> method).<br/>
This worked okay-ish, the main issue being having ghosts in the motion.<br/>
Enter another algorithm, which I absolutely can't remember where I read about it unfortunately so I don't even know its name, which makes you compare 3 pictures instead of 2 and do a bitwise and between the 2 results.<br/>
This is what I currently use but a text explanation would be boring for a computer vision program so let's walk through the code along with pictures.  </p>
<h3>How it works</h3>
<p>We have 3 pictures: previous, current and the loop one.<br/>
We want to get the difference from the one in the loop compared to the previous and the current one.  </p>
<div class="highlight"><pre><span class="n">difference1</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">absdiff</span><span class="p">(</span><span class="n">previous_image</span><span class="p">,</span> <span class="n">gray_image</span><span class="p">)</span>
<span class="n">difference2</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">absdiff</span><span class="p">(</span><span class="n">current_image</span><span class="p">,</span> <span class="n">gray_image</span><span class="p">)</span>
</pre></div>


<p>In practice the difference looks like the following:  </p>
<p><img alt="Difference with absdiff" src="http://vincent.is/images/articles/rodent/difference.jpg"/></p>
<p>You can see my outline, with a pretty cool effect imo, as I was moving in front of the camera.  </p>
<p>Next we want to know the if something changed in both differences, done with the OpenCV bitwise_and method.</p>
<div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">difference1</span><span class="p">,</span> <span class="n">difference2</span><span class="p">)</span>
</pre></div>


<p>This gives a result similar to the above, but usually more faint.<br/>
I personally love this kind of picture, it gives a watercolour like effect.  <br/>
Here you can see my arm while I was standing up, a bit on profile:  </p>
<p><img alt="Result after bitwise_and" src="http://vincent.is/images/articles/rodent/bitwise_and.jpg"/></p>
<p>To make it clearer and know what you're looking at, I tried to highlight the outline of my body (admire my graphic design skills):</p>
<p><img alt="Result after bitwise_and outline" src="http://vincent.is/images/articles/rodent/bitwise_and_contour.jpg"/></p>
<p>We then want to apply a binary threshold to only get clear motions:</p>
<div class="highlight"><pre><span class="n">_</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">THRESH_BINARY</span><span class="p">)</span>
</pre></div>


<p>This means that for every pixel in the result, turn those with a value above 40 (arbitrary value, seems to give good results but open to changing it!) to 255 (white).<br/>
This is the picture above after the thresholding:</p>
<p><img alt="Result after thresholding" src="http://vincent.is/images/articles/rodent/threshold.jpg"/></p>
<p>A picture after threshold with no motion would be completely black.  </p>
<p>We now have an image with the areas where a motion occured in white and we only need to check if we have some pixels with a value of 255 in the image to know if there was a motion.<br/>
Since we know that, we might as well highlight the area where a movement occured: Rodent does that by putting a purple rectangle around the area.<br/>
The code is not that interesting and lives in utils.py/find_motion_boundaries if you want to check it out.<br/>
It simply finds the lowest/highest point (X, Y) in the image with 255, becoming the coordinates for the rectangle and None if there was no motion.<br/>
Adding a rectangle to an image is trivial as well:</p>
<div class="highlight"><pre><span class="cp"># low_point and high_point are the (X,Y) tuple mentioned above</span>
<span class="cp"># purple is the colour in RGB and 3 is the thickness of the line in pixels.</span>
<span class="n">cv2</span><span class="p">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">low_point</span><span class="p">,</span> <span class="n">high_point</span><span class="p">,</span> <span class="n">purple</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>


<p>Note that the rectangle method does the transformation in-place, it doesn't return the new image.<br/>
Here's what a motion made into a video looks like:</p>
<p><img alt="Motion detection" src="http://vincent.is/images/articles/rodent/motion.gif"/></p>
<h2>Results</h2>
<p>We still haven't caught the culprit but Rodent has been quite fun so far !<br/>
This is the first time I'm using OpenCV and it is very powerful, the API is not very pythonic but works very well.<br/>
Also, don't forget to delete the camera object because it happened to me that the webcam refused to turn on until I rebooted after a several CTRL+C, it is now handled properly by catching KeyboardInterrupt.  </p>
<p>The space below is reserved for a picture of the culprit once we catch him.  </p>
<p>[Insert screenshot of culprit once caught]</p>
    </div>
  </div></body></html>