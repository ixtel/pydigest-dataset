<html><body><div><div class="content html_format">
      <h4>Введение</h4><p>
Программистам числа Фибоначчи должны уже поднадоесть. Примеры их вычисления используются везде. Всё от того, что эти числа предоставляют простейший пример рекурсии. А ещё они являются хорошим примером динамического программирования. Но надо ли вычислять их так в реальном проекте? Не надо. Ни рекурсия, ни динамическое программирование не являются идеальными вариантами. И не замкнутая формула, использующая числа с плавающей запятой. Сейчас я расскажу, как правильно. Но сначала пройдёмся по всем известным вариантам решения.
</p><p>
Код предназначен для Python 3, хотя должен идти и на Python 2.
</p><p>
Для начала – напомню определение:
</p><p>
F</p><sub>n</sub><p>= F</p><sub>n-1</sub><p>+ F</p><sub>n-2</sub>
<p>
и F</p><sub>1</sub><p>= F</p><sub>2</sub><p>=1.
</p><a name="habracut"/>
<h4>Замкнутая формула</h4><p>
Пропустим детали, но желающие могут </p><a href="http://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression">ознакомиться с выводом формулы</a><p>. Идея в том, чтобы предположить, что есть некий x, для которого F</p><sub>n</sub><p> = x</p><sup>n</sup><p>, а затем найти x.

</p><img src="https://habrastorage.org/files/595/c24/a05/595c24a057bb4f6ebc5f52643f9be2f5.png"/>
<p>
что означает

</p><img src="https://habrastorage.org/files/520/b93/744/520b937449284d639bfef75fe9d9d580.PNG"/>
<p>
сокращаем x</p><sup>n-2</sup>

<img src="https://habrastorage.org/files/0bf/24b/b39/0bf24bb39c9543d1a64c192d96cb9d2b.PNG"/>
<p>
Решаем квадратное уравнение:

</p><img src="https://habrastorage.org/files/701/b06/9d2/701b069d29154ff3910e74d32830e3fd.PNG"/>
<p>
Откуда и растёт «золотое сечение» ϕ=(1+√5)/2. Подставив исходные значения и проделав ещё вычисления, мы получаем:

</p><img src="https://habrastorage.org/files/e37/e6d/a39/e37e6da397144b688b46b276293b373a.PNG"/>
<p>
что и используем для вычисления F</p><sub>n</sub><p>.

</p><pre><code class="python">from __future__ import division
import math

def fib(n):
    SQRT5 = math.sqrt(5)
    PHI = (SQRT5 + 1) / 2
    return int(PHI ** n / SQRT5 + 0.5)
</code></pre>
<p>
Хорошее:</p><p>
Быстро и просто для малых n</p><p>
Плохое:</p><p>
Требуются операции с плавающей запятой. Для больших n потребуется большая точность.</p><p>
Злое:</p><p>
Использование комплексных чисел для вычисления F</p><sub>n</sub><p> красиво с математической точки зрения, но уродливо — с компьютерной.

</p><h4>Рекурсия</h4><p>
Самое очевидное решение, которое вы уже много раз видели – скорее всего, в качестве примера того, что такое рекурсия. Повторю его ещё раз, для полноты. В Python её можно записать в одну строку:

</p><pre><code class="python">fib = lambda n: fib(n - 1) + fib(n - 2) if n &gt; 2 else 1
</code></pre>
<p>
Хорошее:</p><p>
Очень простая реализация, повторяющая математическое определение</p><p>
Плохое: </p><p>
Экспоненциальное время выполнения. Для больших n очень медленно</p><p>
Злое:</p><p>
Переполнение стека

</p><h4>Запоминание</h4><p>
У решения с рекурсией есть большая проблема: пересекающиеся вычисления. Когда вызывается fib(n), то подсчитываются fib(n-1) и fib(n-2). Но когда считается fib(n-1), она снова независимо подсчитает fib(n-2) – то есть, fib(n-2) подсчитается дважды. Если продолжить рассуждения, будет видно, что fib(n-3) будет подсчитана трижды, и т.д. Слишком много пересечений.
</p><p>
Поэтому надо просто запоминать результаты, чтобы не подсчитывать их снова. Время и память у этого решения расходуются линейным образом. В решении я использую словарь, но можно было бы использовать и простой массив.

</p><pre><code class="python">M = {0: 0, 1: 1}

def fib(n):
    if n in M:
        return M[n]
    M[n] = fib(n - 1) + fib(n - 2)
    return M[n]
</code></pre>
<p>
(В Python это можно также сделать при помощи декоратора, functools.lru_cache.)
</p><p>
Хорошее:</p><p>
Просто превратить рекурсию в решение с запоминанием. Превращает экспоненциальное время выполнение в линейное, для чего тратит больше памяти.</p><p>
Плохое:</p><p>
Тратит много памяти</p><p>
Злое: </p><p>
Возможно переполнение стека, как и у рекурсии

</p><h4>Динамическое программирование</h4><p>
После решения с запоминанием становится понятно, что нам нужны не все предыдущие результаты, а только два последних. Кроме этого, вместо того, чтобы начинать с fib(n) и идти назад, можно начать с fib(0) и идти вперёд. У следующего кода линейное время выполнение, а использование памяти – фиксированное. На практике скорость решения будет ещё выше, поскольку тут отсутствуют рекурсивные вызовы функций и связанная с этим работа. И код выглядит проще.
</p><p>
Это решение часто приводится в качестве примера динамического программирования.

</p><pre><code class="python">def fib(n):
    a = 0
    b = 1
    for __ in range(n):
        a, b = b, a + b
    return a
</code></pre>
<p>
Хорошее:</p><p>
Быстро работает для малых n, простой код</p><p>
Плохое:</p><p>
Всё ещё линейное время выполнения</p><p>
Злое:</p><p>
Да особо ничего.

</p><h4>Матричная алгебра</h4><p>
И, наконец, наименее освещаемое, но наиболее правильное решение, грамотно использующее как время, так и память. Его также можно расширить на любую гомогенную линейную последовательность. Идея в использовании матриц. Достаточно просто видеть, что

</p><img src="https://habrastorage.org/files/c7b/94d/4c3/c7b94d4c351a4719a3bafedff4eeb808.PNG"/>
<p>
А обобщение этого говорит о том, что 

</p><img src="https://habrastorage.org/files/c12/ac2/4c8/c12ac24c87f045688714c416752afc40.PNG"/>
<p>
Два значения для x, полученных нами ранее, из которых одно представляло собою золотое сечение, являются собственными значениями матрицы. Поэтому, ещё одним способом вывода замкнутой формулы является использование матричного уравнения и линейной алгебры.
</p><p>
Так чем же полезна такая формулировка? Тем, что возведение в степень можно произвести за логарифмическое время. Это делается через </p><a href="http://sahandsaba.com/cryptography-rsa-part-1.html">возведения в квадрат</a><p>. Суть в том, что 

</p><img src="https://habrastorage.org/files/a88/dfc/655/a88dfc6558824458ad8053cd850ff3ac.PNG"/>
<p>
где первое выражение используется для чётных A, второе для нечётных. Осталось только организовать перемножения матриц, и всё готово. Получается следующий код. Я организовал рекурсивную реализацию pow, поскольку её проще понять. Итеративную версию смотрите тут.

</p><pre><code class="python">def pow(x, n, I, mult):
    """
    Возвращает x в степени n. Предполагает, что I – это единичная матрица, которая 
    перемножается с mult, а n – положительное целое
    """
    if n == 0:
        return I
    elif n == 1:
        return x
    else:
        y = pow(x, n // 2, I, mult)
        y = mult(y, y)
        if n % 2:
            y = mult(x, y)
        return y


def identity_matrix(n):
    """Возвращает единичную матрицу n на n"""
    r = list(range(n))
    return [[1 if i == j else 0 for i in r] for j in r]


def matrix_multiply(A, B):
    BT = list(zip(*B))
    return [[sum(a * b
                 for a, b in zip(row_a, col_b))
            for col_b in BT]
            for row_a in A]


def fib(n):
    F = pow([[1, 1], [1, 0]], n, identity_matrix(2), matrix_multiply)
    return F[0][1]
</code></pre>
<p>
Хорошее:</p><p>
Фиксированный объём памяти, логарифмическое время</p><p>
Плохое:</p><p>
Код посложнее</p><p>
Злое:</p><p>
Приходится работать с матрицами, хотя они не так уж и плохи

</p><h4>Сравнение быстродействия</h4><p>
Сравнивать стоит только вариант динамического программирования и матрицы. Если сравнивать их по количеству знаков в числе n, то получится, что матричное решение линейно, а решение с динамическим программированием – экспоненциально. Практический пример – вычисление fib(10 ** 6), числа, у которого будет больше двухсот тысяч знаков.
</p><p>
n = 10 ** 6</p><p>
Вычисляем fib_matrix: у fib(n) всего 208988 цифр, расчёт занял 0.24993 секунд.</p><p>
Вычисляем fib_dynamic: у fib(n) всего 208988 цифр, расчёт занял 11.83377 секунд.

</p><hr/>

<h4>Теоретические замечания</h4><p>
Не напрямую касаясь приведённого выше кода, данное замечание всё-таки имеет определённый интерес. Рассмотрим следующий граф:

</p><img src="https://habrastorage.org/getpro/habr/post_images/5c9/206/c1f/5c9206c1fa711d2fa28c7b07e5954e12.png" alt="image"/>
<p>
Подсчитаем количество путей длины n от A до B. Например, для n = 1 у нас есть один путь, 1. Для n = 2 у нас опять есть один путь, 01. Для n = 3 у нас есть два пути, 001 и 101. Довольно просто можно показать, что количество путей длины n от А до В равно в точности F</p><sub>n</sub><p>. Записав матрицу смежности для графа, мы получим такую же матрицу, которая была описана выше. Это известный результат из теории графов, что при заданной матрице смежности А, вхождения в А</p><sup>n</sup><p> — это количество путей длины n в графе (</p><a href="http://mat.unideb.hu/media/horvath-gabor/publications/gwh2.pdf">одна из задач, упоминавшихся </a><p>в фильме «Умница Уилл Хантинг»).
</p><p>
Почему на рёбрах стоят такие обозначения? Оказывается, что при рассмотрении бесконечной последовательности символов на бесконечной в обе стороны последовательности путей на графе, вы получите нечто под названием "</p><a href="http://en.wikipedia.org/wiki/Subshift_of_finite_type">подсдвиги конечного типа</a><p>", представляющее собой тип системы символической динамики. Конкретно этот подсдвиг конечного типа известен, как «сдвиг золотого сечения», и задаётся набором «запрещённых слов» {11}. Иными словами, мы получим бесконечные в обе стороны двоичные последовательности и никакие пары из них не будут смежными. Топологическая энтропия этой динамической системы равна золотому сечению ϕ. Интересно, как это число периодически появляется в разных областях математики.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>