<html><body><div><div class="section-inner layoutSingleColumn"><h2 name="4fae" id="4fae" class="graf--h2 graf--first">Dependency Management</h2><p name="c765" id="c765" class="graf--p graf-after--h2">During life-cycle of any software project its’ dependencies change. The traditional workflow of adding requirement is so broken that it’s hard to believe that it’s still used in 2015. The article reveals how <a href="http://vagga.readthedocs.org" data-href="http://vagga.readthedocs.org" class="markup--anchor markup--p-anchor" rel="nofollow">vagga</a> makes managing dependencies simple and non-distracting process.</p><h3 name="5b60" id="5b60" class="graf--h3 graf-after--p">Traditional Workflow</h3><p name="8453" id="8453" class="graf--p graf-after--h3">I’ll use python for example. Tools for most scripting languages are very similar. For compiled languages setup is usually different but I’ll omit them for brevity.</p><p name="f0f1" id="f0f1" class="graf--p graf-after--p">When we start project in python we create a “requirements.txt” file in the root of the project. Then we create a “virtualenv” for it:</p><pre name="4162" id="4162" class="graf--pre graf-after--p">$ echo django &gt; requirements.txt<br/>$ python3 -m venv venvdir<br/>$ . venvdir/bin/activate<br/>$ pip install -r requirements.txt<br/>Downloading/unpacking django (from -r requirements.txt (line 1))<br/>  Downloading Django-1.7.4-py2.py3-none-any.whl (7.4MB): 7.4MB downloaded<br/>Installing collected packages: django<br/>Successfully installed django<br/>Cleaning up...</pre><p name="3bfe" id="3bfe" class="graf--p graf-after--pre">Now we have requirements installed. What if we need to add another one? Just add a line to “requirements.txt” and re-run pip:</p><pre name="41d0" id="41d0" class="graf--pre graf-after--p">$ echo pygments &gt;&gt; requirements.txt<br/>$ pip install -r requirements.txt <br/>Requirement already satisfied (use —upgrade to upgrade): django in ./venvdir/lib/python3.4/site-packages (from -r requirements.txt (line 1))<br/>Downloading/unpacking pygments (from -r requirements.txt (line 2))<br/> Downloading Pygments-2.0.2-py3-none-any.whl (672kB): 672kB downloaded<br/>Installing collected packages: pygments<br/>Successfully installed pygments<br/>Cleaning up…</pre><p name="3cba" id="3cba" class="graf--p graf-after--pre">Great so far. What if we remove dependency?</p><pre name="c402" id="c402" class="graf--pre graf-after--p">$ sed -i ‘/pygments/D’ requirements.txt <br/>$ cat requirements.txt <br/>django<br/>$ pip install -r requirements.txt<br/>Requirement already satisfied (use --upgrade to upgrade): django in ./venvdir/lib/python3.4/site-packages (from -r requirements.txt (line 1))<br/>Cleaning up...<br/>$ python3<br/>Python 3.4.1 (default, Sep 12 2014, 16:29:56) <br/>[GCC 4.8.3] on linux<br/>Type "help", "copyright", "credits" or "license" for more information.<br/>&gt;&gt;&gt; import pygments<br/>&gt;&gt;&gt;</pre><p name="59b5" id="59b5" class="graf--p graf-after--pre">As you can see, the package is still there. This is just a quick refresher, I’m not going to dive into details too deeply.</p><h3 name="b707" id="b707" class="graf--h3 graf-after--p">Problems With Traditional Workflow</h3><p name="e072" id="e072" class="graf--p graf-after--h3">Here are quick summary of what can be a problem in the real project:</p><ol class="postList"><li name="6853" id="6853" class="graf--li graf-after--p">User must manually run package manager to update dependencies (pip install, npm install)</li><li name="e28a" id="e28a" class="graf--li graf-after--li">Already installed dependencies are not deleted (probably it depends on package manager, but I observe this behavior at least with pip and npm)</li><li name="7c2c" id="7c2c" class="graf--li graf-after--li">Hard to manage multiple versions (e.g. rapidly switching between two branches with different dependencies)</li><li name="62df" id="62df" class="graf--li graf-after--li">The system dependencies (i.e. binary packages) are not managed at all</li></ol><blockquote name="00bd" id="00bd" class="graf--pullquote pullquote graf-after--li">In fact you’re supposed to run “pip install …” after every “git pull”. But nobody does that. And that leads to additional round-trips for many bugs.</blockquote><p name="5c3d" id="5c3d" class="graf--p graf-after--pullquote">This is not even talking about handling multiple environments in single project (which is quite usual for medium to big sized projects).</p><h3 name="84f4" id="84f4" class="graf--h3 graf-after--p">So What is Vagga?</h3><p name="0ca8" id="0ca8" class="graf--p graf-after--h3">Vagga is a tool that fixes all of the above problems. It’s linux containerization tool similar to docker or lxc, but the interface is designed specifically for development environments.</p><p name="fef9" id="fef9" class="graf--p graf-after--p">Let’s see how to bootstrap a project with vagga:</p><pre name="88ba" id="88ba" class="graf--pre graf-after--p">$ echo django &gt; requirements.txt ❶ <br/>$ cat &lt;&lt;YAML &gt; vagga.yaml ❷<br/>containers:<br/>  django: ❸<br/>    setup:<br/>    - !Ubuntu trusty ❹ <br/>    - !Py3Requirements requirements.txt ❺<br/>YAML<br/>$ vagga _run django python3 -q ❻ <br/>[ .. snipped build process .. ]<br/>&gt;&gt;&gt; import django<br/>&gt;&gt;&gt;</pre><p name="6801" id="6801" class="graf--p graf-after--pre">What we have here:</p><ul class="postList"><li name="7f52" id="7f52" class="graf--li graf-after--p">❶ We still use requirements.txt for convenience</li><li name="372c" id="372c" class="graf--li graf-after--li">❷ This is a shell syntax to put the data starting from next line up to “YAML” text to the file “vagga.yaml”. Usually you just use text editor.</li><li name="28d3" id="28d3" class="graf--li graf-after--li">❸ We name container “django”, we might use multiple containers (e.g. add mysql to another container)</li><li name="0ce5" id="0ce5" class="graf--li graf-after--li">❹ We use ubuntu in the container (as an example), it doesn’t depend whether the host system is ubuntu, fedora, nix or whatever, the linux distribution <em class="markup--em markup--li-em">inside</em> this specific container is ubuntu. You should use the the one you will use in production.</li><li name="acdd" id="acdd" class="graf--li graf-after--li">❺ And we tell vagga to read python dependencies from the file “requirements.txt”. This effectively means that dependencies will be installed by “pip” and a little bit more…</li><li name="ce55" id="ce55" class="graf--li graf-after--li">❻ Then we just run vagga and see that everything works as expected. The underscored “_run” command is just low-level API, I’ll show better API in a minute.</li></ul><p name="c469" id="c469" class="graf--p graf-after--li">See the <a href="http://vagga.readthedocs.org/en/latest/build_commands.html" data-href="http://vagga.readthedocs.org/en/latest/build_commands.html" class="markup--anchor markup--p-anchor" rel="nofollow">reference</a> for full list of build steps supported. Note that we don’t have a “build virtual environment” or “install the packages” step. We just “run the command”.</p><h4 name="51d2" id="51d2" class="graf--h4 graf-after--p">How Vagga Works</h4><p name="4892" id="4892" class="graf--p graf-after--h4">When you run command, vagga does the following:</p><ul class="postList"><li name="1423" id="1423" class="graf--li graf-after--p">reads and parses vagga.yaml;</li><li name="231e" id="231e" class="graf--li graf-after--li">computes hash of all dependencies of a container to run;</li><li name="a5fb" id="a5fb" class="graf--li graf-after--li">builds container if no one exits with hash just computed;</li><li name="8ae5" id="8ae5" class="graf--li graf-after--li">runs the command inside.</li></ul><p name="520c" id="520c" class="graf--p graf-after--li">Ok, we are going to introspect some details. First let’s define a “command” so that it’s easier to use vagga:</p><pre name="9146" id="9146" class="graf--pre graf-after--p">$ cat &lt;&lt;YAML &gt;&gt; vagga.yaml<br/>commands:<br/>  py3: !Command<br/>    container: django<br/>    run: python3 -q<br/>YAML<br/>$ vagga<br/>Available Commands:<br/>  py3</pre><p name="bc05" id="bc05" class="graf--p graf-after--pre">To run a command simply start “vagga command_name”:</p><pre name="827b" id="827b" class="graf--pre graf-after--p">$ vagga py3<br/>&gt;&gt;&gt; import django ❶<br/>&gt;&gt;&gt; import os, sys<br/>&gt;&gt;&gt; sys.path ❷<br/>['', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-x86_64-linux-gnu', '/usr/lib/python3.4/lib-dynload', '/usr/local/lib/python3.4/dist-packages', '/usr/lib/python3/dist-packages']<br/>&gt;&gt;&gt; os.getcwd() ❸<br/>'/work'<br/>&gt;&gt;&gt; os.listdir() ❹<br/>['.vagga', 'vagga.yaml', 'requirements.txt']</pre><ul class="postList"><li name="47d1" id="47d1" class="graf--li graf-after--pre">❶ Confirm that django imports here</li><li name="2a25" id="2a25" class="graf--li graf-after--li">❷ Let’s look at “sys.path”. It has only system paths. I.e. the django is installed in system location (inside the container)</li><li name="2b41" id="2b41" class="graf--li graf-after--li">❸ Our project directory is mounted as “/work” inside the container</li><li name="e554" id="e554" class="graf--li graf-after--li">❹ Confirm that it’s our project directory by looking at file list, note that there is a new hidden folder “.vagga”</li></ul><p name="124d" id="124d" class="graf--p graf-after--li">Okay, let’s look at “.vagga” folder:</p><pre name="a03c" id="a03c" class="graf--pre graf-after--p"><br/>$ ls -l .vagga <br/>total 0<br/>lrwxrwxrwx 1 pc users 27 Feb 11 23:54 django -&gt; .roots/django.40e346d8/root ❶<br/>$ cd .vagga/django<br/>$ ls usr/local/lib/python3.4/dist-packages ❷<br/>django <br/>Django-1.7.4.dist-info</pre><ul class="postList"><li name="8158" id="8158" class="graf--li graf-after--pre">❶ There is a “django” symlink in “.vagga” which named as a container in configuration. Symlink points to a folder with hash in the name. We also see that all versions of our container are stored in “.vagga/.roots”</li><li name="061d" id="061d" class="graf--li graf-after--li">❷ Ensure that django is at expected location inside a container</li></ul><p name="dcd1" id="dcd1" class="graf--p graf-after--li">The “.vagga/django/usr/local/lib/python3.4/dist-packages” path might be added to your IDE, to make code analysis tools work (e.g. auto-completion) on always up to date packages.</p><h4 name="1be8" id="1be8" class="graf--h4 graf-after--p">Adding a Dependency</h4><p name="fc6a" id="fc6a" class="graf--p graf-after--h4">Let’s look at workflow for adding a dependency:</p><pre name="8a2e" id="8a2e" class="graf--pre graf-after--p">$ echo pygments &gt;&gt; requirements.txt<br/>$ vagga py3<br/>[ .. snipped rebuild of container .. ]<br/>&gt;&gt;&gt; import pygments<br/>&gt;&gt;&gt;</pre><p name="63cf" id="63cf" class="graf--p graf-after--pre">Works like a charm! Note that we just changed a file and new environment is build for us. The “requirements.txt” may change if you have done “git pull”. You don’t need to think of this, it just works.</p><p name="ab20" id="ab20" class="graf--p graf-after--p">Let’s see what we have behind the scenes:</p><pre name="60f6" id="60f6" class="graf--pre graf-after--p">$ ls -l .vagga<br/>total 0<br/>lrwxrwxrwx 1 pc users 27 Feb 12 00:14 django -&gt; .roots/django.0bc98218/root ❶<br/>$ cd .vagga/django<br/>$ ls -1 usr/local/lib/python3.4/dist-packages<br/>django<br/>Django-1.7.4.dist-info<br/>pygments<br/>Pygments-2.0.2.dist-info<br/>$ cd ../..<br/>$ ls -1 .vagga/.roots <br/>django.0bc98218<br/>django.40e346d8 ❷</pre><ul class="postList"><li name="cb24" id="cb24" class="graf--li graf-after--pre">❶ There is a new hash</li><li name="af7e" id="af7e" class="graf--li graf-after--li">❷ Old folder is still here</li></ul><p name="e528" id="e528" class="graf--p graf-after--li">And as you might guess, removing dependency works well too:</p><pre name="1e51" id="1e51" class="graf--pre graf-after--p">$ sed -i '/pygments/D' requirements.txt <br/>$ cat requirements.txt <br/>django<br/>$ vagga py3 ❶<br/>&gt;&gt;&gt; import django<br/>&gt;&gt;&gt; import pygments ❷<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>ImportError: No module named 'pygments'<br/>&gt;&gt;&gt; quit()<br/>$ ls -l .vagga <br/>total 0<br/>lrwxrwxrwx 1 pc users 27 Feb 12 00:38 django -&gt; .roots/django.40e346d8/root ❸</pre><ul class="postList"><li name="fe0a" id="fe0a" class="graf--li graf-after--pre">❶ Note: no container rebuild here, used from cache (but in case you deleted old one it will be build just like the first time)</li><li name="a408" id="a408" class="graf--li graf-after--li">❷ Confirm no pygments installed</li><li name="6f43" id="6f43" class="graf--li graf-after--li">❸ And link points to the old container hash</li></ul><blockquote name="fdc1" id="fdc1" class="graf--pullquote pullquote graf-after--li">This powerful concept of immutable containers accessed by hash works well for any kind of dependency changes</blockquote><h4 name="f166" id="f166" class="graf--h4 graf-after--pullquote">Isn’t It Too Limited</h4><p name="428e" id="428e" class="graf--p graf-after--h4">You might think that hard-coding “pip” into a virtalization tool is wrong. But we have a tool specifically to build development environments, so in fact it’s very convenient. And this approach is not limited any more than “run any bash command” idea that Docker has. Let’s see how would we do it in a generic way:</p><pre name="dd1c" id="dd1c" class="graf--pre graf-after--p">setup:<br/>- !Ubuntu trusty<br/>- !UbuntuUniverse ~<br/>- !Install [python3, python3-pip]<br/>- !Sh "pip install -r requirements.txt"</pre><p name="e037" id="e037" class="graf--p graf-after--pre">Note, we need to enable “Universe” in ubuntu, it’s where pithon3-pip package is, and install pip itself. Well, apparently we need more:</p><ul class="postList"><li name="7ff3" id="7ff3" class="graf--li graf-after--p">❶ Rebuild container when “requirements.txt” change</li><li name="e11f" id="e11f" class="graf--li graf-after--li">❷ Remove “pip” after installation</li><li name="9d70" id="9d70" class="graf--li graf-after--li">❸ Cache packages between subsequent builds of containers (so that rebuild is quick)</li><li name="faf2" id="faf2" class="graf--li graf-after--li">❹ Install tools to fetch/build packages (including python-dev and for example “git” if there is a git link for a package)</li></ul><p name="19d1" id="19d1" class="graf--p graf-after--li">Here is how we can achieve it using lower-level commands:</p><pre name="1e97" id="1e97" class="graf--pre graf-after--p">setup:<br/>- !Ubuntu trusty<br/>- !UbuntuUniverse ~<br/>- !Install [python3]<br/>- !BuildDeps [❷python3-pip, python3-dev, git❹]<br/>- !CacheDirs pip-cache: /tmp/pip-cache ❸<br/>- !Depend requirements.txt ❶ <br/>- !Sh "❸PIP_DOWNLOAD_CACHE=/tmp/pip-cache<br/>         pip -r requirements.txt"</pre><p name="e58a" id="e58a" class="graf--p graf-after--pre">Config seems to be cluttered and hard to remember. So we chose simplicity for the common case. Anyway having the low-level tools to do something very project-specific.</p><h3 name="2010" id="2010" class="graf--h3 graf-after--p">Conclusion</h3><p name="f088" id="f088" class="graf--p graf-after--h3">Vagga makes dependency management a breeze. This is accomplished by rebuilding container on each dependency change and by caching packages and version tracking behind the scenes.</p><p name="33a8" id="33a8" class="graf--p graf-after--p">Unfortunately the only competitor for vagga in this field is <a href="http://nixos.org/nix/" data-href="http://nixos.org/nix/" class="markup--anchor markup--p-anchor" rel="nofollow">nix</a> which requires learning another language and a lot more boilerplate for each dependency. While vagga uses defacto standard way of declarating dependencies for each programming language (e.g. “requirements.txt” for python, other languages are coming soon).</p><p name="3c12" id="3c12" class="graf--p graf-after--p graf--last">We have touched only small part of vagga’s functionality. There are tools to run <a href="http://vagga.readthedocs.org/en/latest/commands.html" data-href="http://vagga.readthedocs.org/en/latest/commands.html" class="markup--anchor markup--p-anchor" rel="nofollow">multiple processes simultaneously</a> and for <a href="https://medium.com/@paulcolomiets/evaluating-mesos-4a08f85473fb" data-href="https://medium.com/@paulcolomiets/evaluating-mesos-4a08f85473fb" class="markup--anchor markup--p-anchor">testing network tolerance</a>, which make development process more friendly.</p></div></div></body></html>