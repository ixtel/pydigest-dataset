<html><body><div><div class="entry-content"><p>
</p><div class="text_cell_render border-box-sizing rendered_html">
<p><em>Update, July 25, 2015: I included some new plots suggested by my colleague Ariel Rokem. Scroll to the end!</em></p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">


<p>Last year I wrote a <a href="https://jakevdp.github.io/blog/2014/06/10/is-seattle-really-seeing-an-uptick-in-cycling/">blog post</a> examining trends in Seattle bicycling and how they relate to weather, daylight, day of the week, and other factors.</p>
<p>Here I want to revisit the same data from a different perspective: rather than making assumptions in order to build models that might describe the data, I'll instead wipe the slate clean and ask what information we can extract from the data themselves, without reliance on any model assumptions. In other words, where the previous post examined the data using a <em>supervised machine learning</em> approach for <em>data modeling</em>, this post will examine the data using an <em>unsupervised learning approach</em> for <em>data exploration</em>.</p>
<p>Along the way, we'll see some examples of importing, transforming, visualizing, and analyzing data in the Python language, using mostly <a href="http://pandas.pydata.org/">Pandas</a>, <a href="http://matplotlib.org/">Matplotlib</a>, and <a href="http://scikit-learn.org/">Scikit-learn</a>. We will also see some real-world examples of the use of unsupervised machine learning algorithms, such as Principal Component Analysis and Gaussian Mixture Models, in exploring and extracting meaning from data.</p>
<p>To spoil the punchline (and perhaps whet your appetite) what we will find is that from analysis of bicycle counts alone, we can make some definite statements about the aggregate work habits of Seattleites who commute by bicycle.</p>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="the-data">The Data</h2>
<p>The data we will use here are the hourly bicycle counts on Seattle's <a href="http://www.openstreetmap.org/#map=17/47.64813/-122.34965">Fremont Bridge</a>. These data come from an <a href="http://www.seattle.gov/transportation/bikecounter_fremont.htm">automated bicycle counter</a>, installed in late 2012, which has inductive sensors under the sidewalks on either side of the bridge. The daily or hourly bicycle counts can be downloaded from <a href="http://data.seattle.gov/">http://data.seattle.gov/</a>; here is the <a href="https://data.seattle.gov/Transportation/Fremont-Bridge-Hourly-Bicycle-Counts-by-Month-Octo/65db-xm6k">direct link to the hourly dataset</a>. To download the data directly, you can uncomment the following <code>curl</code> command:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [1]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="c"># !curl -o FremontBridge.csv https://data.seattle.gov/api/views/65db-xm6k/rows.csv?accessType=DOWNLOAD</span>
</pre></div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>Once this is downloaded, we can use the <a href="http://pandas.pydata.org">pandas</a> library to load the data:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [2]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'FremontBridge.csv'</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="s">'Date'</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

</div>
</div>

<div class="vbox output_wrapper">
<div class="output vbox">


<div class="hbox output_area"><p class="prompt output_prompt">
    Out[2]:</p>
<div class="box-flex1 output_subarea output_pyout">

<div class="output_html rendered_html">
<div>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th/>
      <th>Fremont Bridge West Sidewalk</th>
      <th>Fremont Bridge East Sidewalk</th>
    </tr>
    <tr>
      <th>Date</th>
      <th/>
      <th/>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2012-10-03 00:00:00</th>
      <td> 4</td>
      <td> 9</td>
    </tr>
    <tr>
      <th>2012-10-03 01:00:00</th>
      <td> 4</td>
      <td> 6</td>
    </tr>
    <tr>
      <th>2012-10-03 02:00:00</th>
      <td> 1</td>
      <td> 1</td>
    </tr>
    <tr>
      <th>2012-10-03 03:00:00</th>
      <td> 2</td>
      <td> 3</td>
    </tr>
    <tr>
      <th>2012-10-03 04:00:00</th>
      <td> 6</td>
      <td> 1</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>
</div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>We'll do some quick data cleaning: we'll rename the columns to the shorter "West" and "East", set any missing values to zero, and add a "Total" column:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [3]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s">'West'</span><span class="p">,</span> <span class="s">'East'</span><span class="p">]</span>
<span class="n">data</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">data</span><span class="p">[</span><span class="s">'Total'</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s">'East + West'</span><span class="p">)</span>
</pre></div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can get a better idea of the dataset as a whole through a simple visualization; for example, we can resample the data to see the weekly trend in trips over the nearly three-year period:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [4]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="c"># first some standard imports</span>
<span class="o">%</span><span class="k">matplotlib</span> <span class="n">inline</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span><span class="p">;</span> <span class="n">seaborn</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>  <span class="c"># plot styling</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">data</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s">'W'</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s">'sum'</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'weekly trips'</span><span class="p">);</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>The counts show both a strong seasonal variation, as well as a local structure that can be <a href="https://jakevdp.github.io/blog/2014/06/10/is-seattle-really-seeing-an-uptick-in-cycling/">partially accounted for</a> by temperature, time of year, precipitation, and other factors.</p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">

<p>From here, we could do a variety of other visualizations based on our intuition about what might affect bicycle counts. For example, we could look at the effect of the days of the week, the effect of the weather, and other factors <a href="https://jakevdp.github.io/blog/2014/06/10/is-seattle-really-seeing-an-uptick-in-cycling/">that I explored previously</a>. But we could also proceed by letting the dataset speak for itself, and use <em>unsupervised machine learning</em> techniques (that is, machine learning without reference to data labels) to learn what the data have to tell us.</p>
<p>We will consider each day in the dataset as its own separate entity (or <em>sample</em>, in usual machine learning parlance). For each day, we have 48 observations: two observations (east and west sidewalk sensors) for each of the 24 hour-long periods. By examining the days in light of these observations and doing some careful analysis, we should be able to extract meaningful quantitative statements from the data themselves, without the need to lean on any other assumptions.</p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="transforming-the-data">Transforming the Data</h2>
<p>The first step in this approach is to transform our data; essentially we will want a two-dimensional matrix, where each row of the matrix corresponds to a day, and each column of the matrix corresponds to one of the 48 observations. We can arrange the data this way using the <code>pivot_table()</code> function in Pandas. We want the "East" and "West" column values, indexed by date, and separated by hour of the day. Any missing values we will fill with zero:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [5]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">pivoted</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">([</span><span class="s">'East'</span><span class="p">,</span> <span class="s">'West'</span><span class="p">],</span>
                           <span class="n">index</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">,</span>
                           <span class="n">columns</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span>
                           <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">pivoted</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

</div>
</div>

<div class="vbox output_wrapper">
<div class="output vbox">


<div class="hbox output_area"><p class="prompt output_prompt">
    Out[5]:</p>
<div class="box-flex1 output_subarea output_pyout">

<div class="output_html rendered_html">
<div>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th/>
      <th colspan="10" halign="left">East</th>
      <th>...</th>
      <th colspan="10" halign="left">West</th>
    </tr>
    <tr>
      <th/>
      <th>0 </th>
      <th>1 </th>
      <th>2 </th>
      <th>3 </th>
      <th>4 </th>
      <th>5 </th>
      <th>6 </th>
      <th>7 </th>
      <th>8 </th>
      <th>9 </th>
      <th>...</th>
      <th>14</th>
      <th>15</th>
      <th>16</th>
      <th>17</th>
      <th>18</th>
      <th>19</th>
      <th>20</th>
      <th>21</th>
      <th>22</th>
      <th>23</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2012-10-03</th>
      <td>  9</td>
      <td> 6</td>
      <td> 1</td>
      <td> 3</td>
      <td> 1</td>
      <td> 10</td>
      <td> 50</td>
      <td>  95</td>
      <td> 146</td>
      <td> 104</td>
      <td>...</td>
      <td>  77</td>
      <td>  72</td>
      <td> 133</td>
      <td> 192</td>
      <td> 122</td>
      <td> 59</td>
      <td> 29</td>
      <td> 25</td>
      <td> 24</td>
      <td>  5</td>
    </tr>
    <tr>
      <th>2012-10-04</th>
      <td> 11</td>
      <td> 0</td>
      <td> 6</td>
      <td> 3</td>
      <td> 1</td>
      <td> 11</td>
      <td> 51</td>
      <td>  89</td>
      <td> 134</td>
      <td>  94</td>
      <td>...</td>
      <td>  63</td>
      <td>  73</td>
      <td> 114</td>
      <td> 154</td>
      <td> 137</td>
      <td> 57</td>
      <td> 27</td>
      <td> 31</td>
      <td> 25</td>
      <td> 11</td>
    </tr>
    <tr>
      <th>2012-10-05</th>
      <td>  7</td>
      <td> 4</td>
      <td> 3</td>
      <td> 2</td>
      <td> 2</td>
      <td>  7</td>
      <td> 37</td>
      <td> 101</td>
      <td> 119</td>
      <td>  81</td>
      <td>...</td>
      <td>  63</td>
      <td>  80</td>
      <td> 120</td>
      <td> 144</td>
      <td> 107</td>
      <td> 42</td>
      <td> 27</td>
      <td> 11</td>
      <td> 10</td>
      <td> 16</td>
    </tr>
    <tr>
      <th>2012-10-06</th>
      <td>  7</td>
      <td> 5</td>
      <td> 2</td>
      <td> 2</td>
      <td> 1</td>
      <td>  2</td>
      <td> 15</td>
      <td>  16</td>
      <td>  47</td>
      <td>  55</td>
      <td>...</td>
      <td>  89</td>
      <td> 115</td>
      <td> 107</td>
      <td> 107</td>
      <td>  41</td>
      <td> 40</td>
      <td> 25</td>
      <td> 18</td>
      <td> 14</td>
      <td> 15</td>
    </tr>
    <tr>
      <th>2012-10-07</th>
      <td>  5</td>
      <td> 5</td>
      <td> 1</td>
      <td> 2</td>
      <td> 2</td>
      <td>  3</td>
      <td>  8</td>
      <td>  12</td>
      <td>  26</td>
      <td>  36</td>
      <td>...</td>
      <td> 126</td>
      <td> 122</td>
      <td> 132</td>
      <td> 118</td>
      <td>  68</td>
      <td> 26</td>
      <td> 19</td>
      <td> 12</td>
      <td>  9</td>
      <td>  5</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 48 columns</p>
</div>
</div>

</div>
</div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>Next we extract the raw values and put them in a matrix:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [6]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">X</span> <span class="o">=</span> <span class="n">pivoted</span><span class="o">.</span><span class="n">values</span>
<span class="n">X</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>Our data consists of just over 1000 days, each with the aforementioned 48 measurements.</p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="visualizing-the-data">Visualizing the Data</h2>
<p>We can think of this data now as representing 1001 distinct objects which live in a <em>48-dimensional</em> space: the value of each dimension is the number of bicycle trips measured on a particular side of the bridge at a particular hour. Visualizing 48-dimensional data is quite difficult, so instead we will use a standard <em>dimensionality reduction</em> technique to project this to a more manageable size.</p>
<p>The technique we'll use is <a href="http://scikit-learn.org/stable/modules/decomposition.html">Principal Component Analysis (PCA)</a>, a fast linear projection which rotates the data such that the projection preserves the maximum variance. We can ask for components preserving 90% of the variance as follows:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [7]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="n">Xpca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="mf">0.9</span><span class="p">)</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">Xpca</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>The output has two dimensions, which means that these two projected components describe at least 90% of the total variance in the dataset. While 48-dimensional data is difficult to plot, we certainly know how to plot two-dimensional data: we'll do a simple scatter plot, and for reference we'll color each point according to the total number of trips taken that day:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [8]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">total_trips</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">Xpca</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">Xpca</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">total_trips</span><span class="p">,</span>
            <span class="n">cmap</span><span class="o">=</span><span class="s">'cubehelix'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">'total trips'</span><span class="p">);</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>We see that the days lie in two quite distinct groups, and that the total number of trips increases along the length of each projected cluster. Further, the two groups begin to be less distinguishable when the number of trips during the day is very small.</p>
<p>I find this extremely interesting: from the raw data, we can determine that there are basically <em>two primary types of days</em> for Seattle bicyclists. Let's model these clusters and try to figure out what these types-of-day are.</p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="unsupervised-clustering">Unsupervised Clustering</h2>
<p>When you have groups of data you'd like to automatically separate, but no previously-determined labels for the groups, the type of algorithm you are looking at is a <em>clustering</em> algorithm. There are a number of clustering algorithms out there, but for nicely-defined oval-shaped blobs like we see above, <a href="http://scikit-learn.org/stable/modules/mixture.html">Gaussian Mixture Models</a> are a very good choice. We can compute the Gaussian Mixture Model of the data using, again, scikit-learn, and quickly plot the predicted labels for the points:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [9]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="kn">from</span> <span class="nn">sklearn.mixture</span> <span class="kn">import</span> <span class="n">GMM</span>
<span class="n">gmm</span> <span class="o">=</span> <span class="n">GMM</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">covariance_type</span><span class="o">=</span><span class="s">'full'</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">gmm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xpca</span><span class="p">)</span>
<span class="n">cluster_label</span> <span class="o">=</span> <span class="n">gmm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xpca</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">Xpca</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">Xpca</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">cluster_label</span><span class="p">);</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>This clustering seems to have done the job, and separated the two groups we are interested in. Let's join these inferred cluster labels to the initial dataset:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [10]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">pivoted</span><span class="p">[</span><span class="s">'Cluster'</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_label</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pivoted</span><span class="p">[</span><span class="s">'Cluster'</span><span class="p">],</span> <span class="n">on</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

</div>
</div>

<div class="vbox output_wrapper">
<div class="output vbox">


<div class="hbox output_area"><p class="prompt output_prompt">
    Out[10]:</p>
<div class="box-flex1 output_subarea output_pyout">

<div class="output_html rendered_html">
<div>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th/>
      <th>West</th>
      <th>East</th>
      <th>Total</th>
      <th>Cluster</th>
    </tr>
    <tr>
      <th>Date</th>
      <th/>
      <th/>
      <th/>
      <th/>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2012-10-03 00:00:00</th>
      <td> 4</td>
      <td> 9</td>
      <td> 13</td>
      <td> 0</td>
    </tr>
    <tr>
      <th>2012-10-03 01:00:00</th>
      <td> 4</td>
      <td> 6</td>
      <td> 10</td>
      <td> 0</td>
    </tr>
    <tr>
      <th>2012-10-03 02:00:00</th>
      <td> 1</td>
      <td> 1</td>
      <td>  2</td>
      <td> 0</td>
    </tr>
    <tr>
      <th>2012-10-03 03:00:00</th>
      <td> 2</td>
      <td> 3</td>
      <td>  5</td>
      <td> 0</td>
    </tr>
    <tr>
      <th>2012-10-03 04:00:00</th>
      <td> 6</td>
      <td> 1</td>
      <td>  7</td>
      <td> 0</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>
</div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we can find the average trend by cluster and time using a GroupBy within this updated dataset</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [11]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">by_hour</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s">'Cluster'</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">time</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">by_hour</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

</div>
</div>

<div class="vbox output_wrapper">
<div class="output vbox">


<div class="hbox output_area"><p class="prompt output_prompt">
    Out[11]:</p>
<div class="box-flex1 output_subarea output_pyout">

<div class="output_html rendered_html">
<div>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th/>
      <th/>
      <th>West</th>
      <th>East</th>
      <th>Total</th>
    </tr>
    <tr>
      <th>Cluster</th>
      <th/>
      <th/>
      <th/>
      <th/>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">0</th>
      <th>00:00:00</th>
      <td> 5.312139</td>
      <td> 6.213873</td>
      <td> 11.526012</td>
    </tr>
    <tr>
      <th>01:00:00</th>
      <td> 2.713873</td>
      <td> 2.969653</td>
      <td>  5.683526</td>
    </tr>
    <tr>
      <th>02:00:00</th>
      <td> 2.294798</td>
      <td> 1.732659</td>
      <td>  4.027457</td>
    </tr>
    <tr>
      <th>03:00:00</th>
      <td> 1.570809</td>
      <td> 1.426301</td>
      <td>  2.997110</td>
    </tr>
    <tr>
      <th>04:00:00</th>
      <td> 4.179191</td>
      <td> 2.650289</td>
      <td>  6.829480</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>
</div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>Finally, we can plot the average hourly trend among the days within each cluster:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [12]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">hourly_ticks</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">by_hour</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xticks</span><span class="o">=</span><span class="n">hourly_ticks</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'Cluster {0}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'average hourly trips'</span><span class="p">)</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>These plots give us some insight into the interpretation of the two clusters: the first cluster shows a sharp bimodal traffic pattern, while the second shows a wide unimodal pattern.</p>
<p>In the bimodal cluster, we see a peak around 8:00am which is dominated by cyclists on the west sidewalk, and another peak around 5:00pm which is dominated by cyclists on the east sidewalk. This is very clearly a commute pattern, with the majority of cyclists riding toward downtown Seattle in the morning, and away from downtown Seattle in the evening.</p>
<p>In the unimodal cluster, we see fairly steady traffic in each direction beginning early in the morning and going until late at night, with a peak around 2:00 in the afternoon. This is very clearly a recreational pattern of use, with people out riding through the entire day.</p>
<p>I find this is fascinating: from simple unsupervised dimensionality reduction and clustering, we've discovered two distinct classes of days in the data, and found that these classes have very intuitive explanations.</p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="seattles-work-habits">Seattle's Work Habits</h2>
<p>Let's go one step deeper and figure out what we can learn about people (well, bicycle commuters) in Seattle from just this hourly commute data. As a rough approximation, you might guess that these two classes of data might be largely reflective of workdays in the first cluster, and non-work days in the second. We can check this intuition by re-plotting our projected data, except labeling them by day of the week:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [13]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">dayofweek</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">pivoted</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">dayofweek</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">Xpca</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">Xpca</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">dayofweek</span><span class="p">,</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s">'jet'</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">ticks</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="n">cb</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">([</span><span class="s">'Mon'</span><span class="p">,</span> <span class="s">'Tues'</span><span class="p">,</span> <span class="s">'Wed'</span><span class="p">,</span> <span class="s">'Thurs'</span><span class="p">,</span> <span class="s">'Fri'</span><span class="p">,</span> <span class="s">'Sat'</span><span class="p">,</span> <span class="s">'Sun'</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">6.5</span><span class="p">);</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>We see that the weekday/weekend intuition holds, but only to a point: in particular, it is clear that <strong>there are a handful of weekdays which follow the typical weekend pattern!</strong> Further, it's interesting to note that Fridays tend to be pulled closer to weekend days in this plot, though as a whole they still fall solidly in the work-day cluster.</p>
<p>Let's take a closer look at the "special" weekdays that fall in the "wrong" cluster. We start by constructing a dataset listing the cluster id and the day of the week for each of the dates in our dataset:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [14]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">results</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s">'cluster'</span><span class="p">:</span> <span class="n">cluster_label</span><span class="p">,</span>
                        <span class="s">'is_weekend'</span><span class="p">:</span> <span class="p">(</span><span class="n">dayofweek</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">),</span>
                        <span class="s">'weekday'</span><span class="p">:</span> <span class="n">pivoted</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">'%a'</span><span class="p">))},</span>
                       <span class="n">index</span><span class="o">=</span><span class="n">pivoted</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
<span class="n">results</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

</div>
</div>

<div class="vbox output_wrapper">
<div class="output vbox">


<div class="hbox output_area"><p class="prompt output_prompt">
    Out[14]:</p>
<div class="box-flex1 output_subarea output_pyout">

<div class="output_html rendered_html">
<div>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th/>
      <th>cluster</th>
      <th>is_weekend</th>
      <th>weekday</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2012-10-03</th>
      <td> 0</td>
      <td> False</td>
      <td> Wed</td>
    </tr>
    <tr>
      <th>2012-10-04</th>
      <td> 0</td>
      <td> False</td>
      <td> Thu</td>
    </tr>
    <tr>
      <th>2012-10-05</th>
      <td> 0</td>
      <td> False</td>
      <td> Fri</td>
    </tr>
    <tr>
      <th>2012-10-06</th>
      <td> 1</td>
      <td>  True</td>
      <td> Sat</td>
    </tr>
    <tr>
      <th>2012-10-07</th>
      <td> 1</td>
      <td>  True</td>
      <td> Sun</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>
</div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>First, let's see how many weekend days fall in the first, commute-oriented cluster</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [15]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">weekend_workdays</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s">'cluster == 0 and is_weekend'</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">weekend_workdays</span><span class="p">)</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>zero! Apparently, there is not a single weekend during the year where Seattle cyclists as a whole decide to go to work.</p>
<p>Similarly, we can see how many weekdays fall in the second, recreation-oriented cluster:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [16]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">midweek_holidays</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s">'cluster == 1 and not is_weekend'</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">midweek_holidays</span><span class="p">)</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>There were 23 weekdays over the past several years in which Seattle cyclists as a whole did not go to work. To label these, let's load the US Federal holiday calendar available in Pandas:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [17]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="kn">from</span> <span class="nn">pandas.tseries.holiday</span> <span class="kn">import</span> <span class="n">USFederalHolidayCalendar</span>
<span class="n">cal</span> <span class="o">=</span> <span class="n">USFederalHolidayCalendar</span><span class="p">()</span>
<span class="n">holidays</span> <span class="o">=</span> <span class="n">cal</span><span class="o">.</span><span class="n">holidays</span><span class="p">(</span><span class="s">'2012'</span><span class="p">,</span> <span class="s">'2016'</span><span class="p">,</span> <span class="n">return_name</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">holidays</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

</div>
</div>

<div class="vbox output_wrapper">
<div class="output vbox">


<div class="hbox output_area"><p class="prompt output_prompt">
    Out[17]:</p>
<div class="box-flex1 output_subarea output_pyout">


<pre>
2012-01-02                 New Years Day
2012-01-16    Dr. Martin Luther King Jr.
2012-02-20                Presidents Day
2012-05-28                   MemorialDay
2012-07-04                      July 4th
dtype: object
</pre>

</div>
</div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>Just for completeness, we will add to the list the day before and day after each of these holidays:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [18]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">holidays_all</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">holidays</span><span class="p">,</span>
                         <span class="s">"Day Before "</span> <span class="o">+</span> <span class="n">holidays</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">'D'</span><span class="p">),</span>
                         <span class="s">"Day After "</span> <span class="o">+</span> <span class="n">holidays</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">'D'</span><span class="p">)])</span>
<span class="n">holidays_all</span> <span class="o">=</span> <span class="n">holidays_all</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
<span class="n">holidays_all</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

</div>
</div>

<div class="vbox output_wrapper">
<div class="output vbox">


<div class="hbox output_area"><p class="prompt output_prompt">
    Out[18]:</p>
<div class="box-flex1 output_subarea output_pyout">


<pre>
2012-01-01                 Day Before New Years Day
2012-01-02                            New Years Day
2012-01-03                  Day After New Years Day
2012-01-15    Day Before Dr. Martin Luther King Jr.
2012-01-16               Dr. Martin Luther King Jr.
dtype: object
</pre>

</div>
</div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>Note that these are <em>observed</em> holidays, which is why New Years Day 2012 falls on January 2nd. With this ready to go, we can compute the complete list of non-weekend days on which Seattle bicycle commuters as a whole chose to stay home from work:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [19]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">holidays_all</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">'name'</span>  <span class="c"># required for join</span>
<span class="n">joined</span> <span class="o">=</span> <span class="n">midweek_holidays</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">holidays_all</span><span class="p">)</span>
<span class="nb">set</span><span class="p">(</span><span class="n">joined</span><span class="p">[</span><span class="s">'name'</span><span class="p">])</span>
</pre></div>

</div>
</div>

<div class="vbox output_wrapper">
<div class="output vbox">


<div class="hbox output_area"><p class="prompt output_prompt">
    Out[19]:</p>
<div class="box-flex1 output_subarea output_pyout">


<pre>
{'Christmas',
 'Day After Christmas',
 'Day After Thanksgiving',
 'Day Before Christmas',
 'July 4th',
 'Labor Day',
 'MemorialDay',
 'New Years Day',
 'Thanksgiving'}
</pre>

</div>
</div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>On the other side of things, here are the Federally recognized holidays where Seattle bicycle commuters chose to go to work anyway:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [20]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="nb">set</span><span class="p">(</span><span class="n">holidays</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">joined</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>

</div>
</div>

<div class="vbox output_wrapper">
<div class="output vbox">


<div class="hbox output_area"><p class="prompt output_prompt">
    Out[20]:</p>
<div class="box-flex1 output_subarea output_pyout">


<pre>
{'Columbus Day',
 'Dr. Martin Luther King Jr.',
 'Presidents Day',
 'Veterans Day'}
</pre>

</div>
</div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="update-whats-up-with-fridays">Update: What's up with Fridays?</h2>
<p>A colleague of mine, Ariel Rokem, saw the first version of this post and noticed something interesting. For the most part, Fridays tend to lie on the upper side of the weekday cluster, closer in this parameter space to the typical weekend pattern. This pattern holds nearly universally for Fridays, all except for three strange outliers which lie far on the other side of the cluster.</p>
<p>We can see these more clearly if we highlight the Friday points in the plot:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [21]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">fridays</span> <span class="o">=</span> <span class="p">(</span><span class="n">dayofweek</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">Xpca</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">Xpca</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s">'gray'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">Xpca</span><span class="p">[</span><span class="n">fridays</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">Xpca</span><span class="p">[</span><span class="n">fridays</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s">'yellow'</span><span class="p">);</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>The yellow points in the bottom-left of the plot are unique – they're far different than other Fridays, and they even stand-out in comparison to the other work days! Let's see what they represent:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [22]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">weird_fridays</span> <span class="o">=</span> <span class="n">pivoted</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">fridays</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Xpca</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">600</span><span class="p">)]</span>
<span class="n">weird_fridays</span>
</pre></div>

</div>
</div>

<div class="vbox output_wrapper">
<div class="output vbox">


<div class="hbox output_area"><p class="prompt output_prompt">
    Out[22]:</p>
<div class="box-flex1 output_subarea output_pyout">


<pre>
Index([2013-05-17, 2014-05-16, 2015-05-15], dtype='object')
</pre>

</div>
</div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>All three of these outlying Fridays fall in the middle of May. Curious!</p>
<p>Let's quickly visualize the daily stats for these, along with the mean trend over all days. We can arrange the data this way with a pivot table operation:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [23]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">all_days</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span><span class="s">'Total'</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
<span class="n">all_days</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">weird_fridays</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">();</span>
<span class="n">all_days</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">'gray'</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                      <span class="n">xticks</span><span class="o">=</span><span class="n">hourly_ticks</span><span class="p">);</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>Apparently these three strange Fridays are days with <em>extreme amounts of bicycle commuting</em>. But what makes them so special?</p>
<p>After some poking-around on the internet, the answer becomes clear: we've discovered Seattle's annual <a href="http://www.cascade.org/f5-bike-work-day">bike to work day</a>. Mystery solved!</p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="summary">Summary</h2>
<p>We have seen here that by taking a close look at raw bicycle counts and using some basic visualization and unsupervised machine learning, we can make some very definite statements about the overall work habits of people in Seattle who bicycle to work across the Fremont bridge. In summary, this is what we have learned:</p>
<ul>
<li>Seattle cyclists, as a whole, tend to take off work New Year's Day, Memorial Day, Independence Day, Labor Day, and the days surrounding Thanksgiving and Christmas.</li>
<li>Seattle cyclists, as a whole, tend to head to the office on the more minor US holidays: Columbus Day, Martin Luther King Jr. Day, Presidents Day, and Veterans Day.</li>
<li>Seattle cyclists, as a whole, would never, ever, be caught at work on a weekend.</li>
</ul>
<p>Thanks for reading!</p>
<p><small> This post was written entirely in the IPython notebook. You can <a href="http://jakevdp.github.io/downloads/notebooks/SeattleCycling2.ipynb">download</a> this notebook, or see a static view <a href="http://nbviewer.ipython.org/url/jakevdp.github.io/downloads/notebooks/SeattleCycling2.ipynb">here</a>. </small></p>
</div></div>
    </div></body></html>