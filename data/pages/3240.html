<html><body><div><div class="entry-content">
                    <p><em>The following is a sample from the new book <a href="/">Effective Python</a>.</em><br/><br/></p>


<p>Many of Python’s built-in APIs allow you to customize behavior by passing in a function. These <em>hooks</em> are used by APIs to call back your code while they execute. For example, the <code>list</code> type’s <code>sort</code> method takes an optional <code>key</code> argument that’s used to determine each index’s value for sorting. Here I sort a list of names based on their lengths by providing a <code>lambda</code> expression as the <code>key</code> hook.</p>
<div class="highlight"><pre><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">'Socrates'</span><span class="p">,</span> <span class="s">'Archimedes'</span><span class="p">,</span> <span class="s">'Plato'</span><span class="p">,</span> <span class="s">'Aristotle'</span><span class="p">]</span>
<span class="n">names</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre>&gt;&gt;&gt;
['Plato', 'Socrates', 'Aristotle', 'Archimedes']
</pre></div>


<p>In other languages, you might expect hooks to be defined by an abstract class. In Python, many hooks are just stateless functions with well-defined arguments and return values. Functions are ideal for hooks because they are easier to describe and simpler to define than classes. Functions work as hooks because Python has <em>first-class</em> functions: Functions and methods can be passed around and referenced like any other value in the language.</p>
<p>For example, say you want to customize the behavior of the <code>defaultdict</code> class. This data structure allows you to supply a function that will be called each time a missing key is accessed. The function must return the default value the missing key should have in the dictionary. Here I define a hook that logs each time a key is missing and returns <code>0</code> for the default value.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">log_missing</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Key added'</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span>
</pre></div>


<p>Given an initial dictionary and a set of desired increments, I can cause the <code>log_missing</code> function to run and print twice (for <code>'red'</code> and <code>'orange'</code>).</p>
<div class="highlight"><pre><span class="n">current</span> <span class="o">=</span> <span class="p">{</span><span class="s">'green'</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s">'blue'</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="n">increments</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s">'red'</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
    <span class="p">(</span><span class="s">'blue'</span><span class="p">,</span> <span class="mi">17</span><span class="p">),</span>
    <span class="p">(</span><span class="s">'orange'</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
<span class="p">]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">log_missing</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Before:'</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">amount</span> <span class="ow">in</span> <span class="n">increments</span><span class="p">:</span>
    <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">amount</span>
<span class="k">print</span><span class="p">(</span><span class="s">'After: '</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>


<div class="highlight"><pre>&gt;&gt;&gt;
Before: {'blue': 3, 'green': 12}
Key added
Key added
After:  {'red': 5, 'green': 12, 'blue': 20, 'orange': 9}
</pre></div>


<p>Supplying functions like <code>log_missing</code> makes APIs easy to build and test because it separates side effects from deterministic behavior. For example, say you now want the default value hook passed to <code>defaultdict</code> to count the total number of keys that were missing. One way to achieve this is using a stateful closure (see [Item 15 for details). Here I define a helper function that uses such a closure as the default value hook.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">increment_with_report</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">increments</span><span class="p">):</span>
    <span class="n">added_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">missing</span><span class="p">():</span>
        <span class="n">nonlocal</span> <span class="n">added_count</span>  <span class="c"># Stateful closure</span>
        <span class="n">added_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">missing</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">amount</span> <span class="ow">in</span> <span class="n">increments</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">amount</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">added_count</span>
</pre></div>


<p>Running this function produces the expected result (<code>2</code>), even though the <code>defaultdict</code> has no idea that the <code>missing</code> hook maintains state. This is another benefit of accepting simple functions for interfaces. It’s easy to add functionality later by hiding state in a closure.</p>
<div class="highlight"><pre><span class="n">result</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">increment_with_report</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">increments</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>


<p>The problem with defining a closure for stateful hooks is that it’s harder to read than the stateless function example. Another approach is to define a small class that encapsulates the state you want to track.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">CountMissing</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">added</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">missing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">added</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>
</pre></div>


<p>In other languages, you might expect that now <code>defaultdict</code> would have to be modified to accommodate the interface of <code>CountMissing</code>. But in Python, thanks to first-class functions, you can reference the <code>CountMissing.missing</code> method directly on an object and pass it to <code>defaultdict</code> as the default value hook. It’s trivial to have a method satisfy a function interface.</p>
<div class="highlight"><pre><span class="n">counter</span> <span class="o">=</span> <span class="n">CountMissing</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>  <span class="c"># Method reference</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">amount</span> <span class="ow">in</span> <span class="n">increments</span><span class="p">:</span>
    <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">amount</span>
<span class="k">assert</span> <span class="n">counter</span><span class="o">.</span><span class="n">added</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>


<p>Using a helper class like this to provide the behavior of a stateful closure is clearer than the <code>increment_with_report</code> function above. However, in isolation it’s still not immediately obvious what the purpose of the <code>CountMissing</code> class is. Who constructs a <code>CountMissing</code> object? Who calls the <code>missing</code> method? Will the class need other public methods to be added in the future? Until you see its usage with <code>defaultdict</code> the class is a mystery.</p>
<p>To clarify this situation, Python allows classes to define the <code>__call__</code> special method. <code>__call__</code> allows an object to be called just like a function. It also causes the <code>callable</code> built-in function to return <code>True</code> for such an instance.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">BetterCountMissing</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">added</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">added</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="n">counter</span> <span class="o">=</span> <span class="n">BetterCountMissing</span><span class="p">()</span>
<span class="n">counter</span><span class="p">()</span>
<span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
</pre></div>


<p>Here I use a <code>BetterCountMissing</code> instance as the default value hook for a <code>defaultdict</code> to track the number of missing keys that were added.</p>
<div class="highlight"><pre><span class="n">counter</span> <span class="o">=</span> <span class="n">BetterCountMissing</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>  <span class="c"># Relies on __call__</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">amount</span> <span class="ow">in</span> <span class="n">increments</span><span class="p">:</span>
    <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">amount</span>
<span class="k">assert</span> <span class="n">counter</span><span class="o">.</span><span class="n">added</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>


<p>This is much clearer than the <code>CountMissing.missing</code> example. The <code>__call__</code> method indicates that a class’s instances will be used somewhere a function argument would also be suitable (like <span class="caps">API</span> hooks). It directs new readers of the code to the entry point that’s responsible for the class’s primary behavior. It provides a strong hint that the goal of the class is to act as a stateful closure.</p>
<p>Best of all, <code>defaultdict</code> still has no view into what’s going on when you use <code>__call__</code>. All that <code>defaultdict</code> requires is a function for the default value hook. Python provides many different ways to satisfy a simple function interface depending on what you need to accomplish.</p>
<h3>Things to Remember</h3>
<ul>
<li>Instead of defining and instantiating classes, functions are often all you need for simple interfaces between components in Python.</li>
<li>References to functions and methods in Python are first-class, meaning they can be used in expressions like any other type.</li>
<li>The <code>__call__</code> special method enables instances of a class to be called like plain Python functions.</li>
<li>When you need a function to maintain state, consider defining a class that provides the <code>__call__</code> method instead of defining a stateful closure.</li>
</ul>
                </div>
            </div></body></html>