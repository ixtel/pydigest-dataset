<html><body><div><div id="article-content" class="article">
    <h1 class="title">OAuth по шагам</h1>
    <p/>

<p><a href="http://www.lexev.org/2015/oauth-step-step/"><img alt="OAuth по шагам" src="https://img-fotki.yandex.ru/get/9819/85893628.c68/0_185253_82b5fefa_M.png" title="OAuth по шагам"/></a></p>
<p>OAuth протокол бывает двух версий: 1.0 и 2.0.</p>
<p>Большинство сервисов сегодня используют версию 2.0, вероятно потому что
ее проще реализовать. Так же версию 2.0 можно относительно безопасно использовать в
standalone-приложениях (те, которые без сервера).</p>
<p>Для понимания протоколов очень полезно взглянуть на их реализацию.
Тут я приведу несколько скриптов, которые общаются с OAuth-провайдерами разных версий.
Т.е. все скрипты реализуют функционал клиента (не сервера).
Используются только стандартные python библиотеки.
Вот почему глядя на них лучше понимаешь сам протокол OAuth - все перед глазами и все более-менее знакомое.
Конечно, для реальной работы нужно использовать только готовые и проверенные временем пакеты.
Эти скрипты только для понимания процесса. Разбираться с готовыми библиотеками порой бывает сложно, они разбиты на много модулей, могут использоваться разные сторонние пакеты, и в итоге общая картина ускользает из виду.</p>
<p>Для начала немного теории.
Наверняка вы знаете, что есть два понятия - <em>аутентификация</em> (authentication) и <em>авторизация</em> (authorization).
Они вроде бы об одном и том же, но все-таки немного о разном.
На всякий случай напомню:</p>
<ul>
<li>аутентификация - это процесс подтверждения подлинности.
    Т.е. нам нужно просто узнать, что данный человек действительно владеет аккаунтом google с таким id и нам этого достаточно.
    Просто залогинить пользователя, не получая никаких прав на какие-либо действия с аккаунтом google'а.
    Этим занимается например протокол OpenID (хотя сейчас google предлагает <a href="https://developers.google.com/identity/sign-in/auth-migration#sign-in">другой способ</a>, OpenID - <a href="https://developers.google.com/identity/protocols/OpenID2">deprecated</a>).</li>
<li>авторизация - процесс предоставления полномочий что-то делать с аккаунтом.
    Авторизация уже включает в себя аутентификацию, но дает дополнительные возможности.
    Например, не просто подтвердить, что пользователь действительно является владельцем аккаунта с определенным id, но еще и узнать его email. А возможно и написать что-то на его стене.
    Вот это предоставляет протокол OAuth.</li>
</ul>
<p>Чтобы легче запомнить я использую слово "автор". Если есть "автор" - значит речь идет о правах (авторстве). Если нет - значит просто проверка подлинности.</p>
<h3>OAuth 1.0</h3>
<p>Спецификация: <a href="http://tools.ietf.org/html/rfc5849">http://tools.ietf.org/html/rfc5849</a></p>
<p>Самое главное, что нужно запомнить - в OAuth 1.0 <strong>все</strong> запросы подписываются секретным ключом.
Секретный ключ нужно хранить только в безопасном месте, единственное такое место - это сервер.
Благодаря этому протокол обеспечивает полную безопасность, даже если не используется https.
Безопасность в том плане, что даже подслушав запрос злоумышленник не сможет сделать другой валидный запрос.
Подслушать сами передаваемые данные он конечно сможет, чтобы их скрыть нужен https.</p>


<h3>OAuth 1.0 less-legged (2-legged, 1-legged, 0-legged)</h3>
<p>Это модификация протокола OAuth 1.0, в котором пользователь никак не зайдествован.
Формально это уже не OAuth протокол, т.к. в спецификции такая последовательность не описана.
Просто используются те же приемы, поэтому и называют так же.
В этом случае клиентское приложение является пользователем, оно может запрашивать либо общедоступные ресурсы, либо ресурсы, доступные самому клиентскому приложению (даже приватные).</p>


<h3>OAuth 2.0 с участием сервера</h3>
<p>Спецификация: <a href="http://tools.ietf.org/html/rfc6749">http://tools.ietf.org/html/rfc6749</a></p>
<p>Интересно, что в заглавии спецификации OAuth 2.0 назван фреймворком.
В то время как в заглавии <a href="http://tools.ietf.org/html/rfc5849">спецификации</a> OAuth 1.0 назван протоколом.</p>
<p>Для обеспечения полной безопасности OAuth 2.0 необходимо отправлять запросы по https (https должен обеспечивать service provider, например facebook).
Получив access_token уже не нужно подписывать запросы секретным ключом.
Т.е. если кто-то подслушает запрос и увидит access_token, то он сможет сделать валидный запрос. Вот зачем нужен https.
Кроме того при получении access_token, секрет передается по http в открытом виде.</p>
<p>У полученного access_token всегда есть ограниченное время жизни.</p>
<p>В связи с этими особенностями (и некоторыми другими), один из проектировщиков протокола OAuth 1.0 даже отказался от участия в разработке OAuth 2.0, ведь последний очень легко реализовать неправильно и в результате безопасность не будет гарантирована. Подробности можно почитать по <a href="http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/">ссылке</a>.</p>
<p>Последовательность шагов для получения access_token по OAuth 2.0, которая включает сервер.
Сервер для получения access_token отправляет секретный код. Обратите внимание, не используется ни одна крипто-библиотека.</p>


<h3>OAuth 2.0 без участия сервера</h3>
<p>С OAuth 2.0 можно работать и без сервера по упрощенной схеме. В этом случае мы тоже получаем access_token, но для его получения не нужно знать секрет приложения! Обычно время жизни у access_token, полученного таким способом, маленькое (1-2 часа), в то время как время жизни, полученного с участием сервера больше (может быть несколько десятков дней).</p>

</div>






</div></body></html>