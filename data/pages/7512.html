<html><body><div><div class="entry-content">
                
                <p>Heads up to readers: this is a long article with lots of code samples and interactive charts. If you're reading on a mobile device, you might want to save this one until you can get to a wider screen! It may take a while to load all the charts. </p>
<h2>Introduction</h2>
<p>This is a longish post about using a simple evolutionary algorithm in Python to create a strategy for playing the famous Prisoner's Dilemma game (actually, the version known as Iterated Prisoner's Dilemma, hereafter referred to as IPD). If you're not already familiar with the Prisoner's Dilemma, take a look at the first bit of <a href="https://en.wikipedia.org/wiki/Prisoner%27s_dilemma">the Wikipedia page</a> and the section on <a href="https://en.wikipedia.org/wiki/Prisoner%27s_dilemma#The_iterated_prisoners.27_dilemma">Iterated Prisoner's Dilemma</a>. You might also want to watch <a href="https://www.youtube.com/watch?v=t9Lo2fgxWHw">this short video</a> and take a look at <a href="https://egtheory.wordpress.com/2015/03/02/ipd/">this blog post</a>. </p>
<p>The impetus for this project was hearing about (and then working on a code sprint for) the <a href="https://github.com/Axelrod-Python/Axelrod">Axelrod library</a> at PyConUk 2015. Axelrod is a Python library which provides a framework for running IPD tournaments. This makes it very easy to play around with different strategies. </p>
<p>Strategies are implemented as classes which have a single method, <code>strategy()</code> which takes as its argument an opponent object, and returns an action. Actions are represented by <code>C</code> for cooperate and <code>D</code> for defect. For example, here's the famous <strong>Tit for tat</strong> strategy that won the original Axelrod tournament in 1980, which can be summarized as "co-operate on the first turn, then copy the opponent's last action":</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opponent</span><span class="p">):</span>
    <span class="sd">"""This is the actual strategy"""</span>
    <span class="c"># First move</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">C</span>
    <span class="c"># React to the opponent's last move</span>
    <span class="k">if</span> <span class="n">opponent</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">D</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">D</span>
    <span class="k">return</span> <span class="n">C</span>
</pre></div>


<aside>
<p>*So-called because it appears to cooperate for a long time, then defects near the end of the match.</p>
</aside>
<p>As we can see, the player has access to its own history through the <code>self.history</code> variable and to the opponent's history though the <code>opponent.history</code> variable. Players can implement more sophisticated strategies by examining these variables, and they also have access to the length of the match. For example, when I first encountered the Axelrod library the winning strategy was called <strong>DoubleCrosser</strong>* and worked like this (edited slightly for clarity):</p>
<div class="highlight"><pre> <span class="k">def</span> <span class="nf">strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opponent</span><span class="p">):</span>

    <span class="c"># if there is no history, then this is the first turn, so cooperate</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">opponent</span><span class="o">.</span><span class="n">history</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">C</span>

    <span class="c"># if this is either the last or second-to-last turn, defect</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opponent</span><span class="o">.</span><span class="n">history</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tournament_attributes</span><span class="p">[</span><span class="s">'length'</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">D</span>

    <span class="c"># if the opponent did not defect on any of the first six turns,</span>
    <span class="c"># and we are not in the last 20 turns, cooperate</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opponent</span><span class="o">.</span><span class="n">history</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">180</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opponent</span><span class="o">.</span><span class="n">history</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">D</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">opponent</span><span class="o">.</span><span class="n">history</span><span class="p">[:</span><span class="mi">7</span><span class="p">]:</span>
                 <span class="k">return</span> <span class="n">C</span>

    <span class="c"># if the total number of defections by the opponent is </span>
    <span class="c"># greater than three, always defect</span>
    <span class="k">if</span> <span class="n">opponent</span><span class="o">.</span><span class="n">defections</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">D</span>

    <span class="c"># failsafe; if none of the other conditions are true,</span>
    <span class="c"># cooperate</span>
    <span class="k">return</span> <span class="n">C</span>
</pre></div>


<aside>*This is because the best strategies mostly score through mutual cooperation, which scores 3 points</aside>

<p>The library takes care of matching up players in pairwise combinations, running the tournament for a given number of turns, and keeping score. For the sake of convenience, scores are usually expressed as average score per turn. The best possible outcome for a given turn is that a player defects and their opponent cooperates giving a score of 5 in the standard payoff matrix, so that's the theoretical best average score per turn. The best strategies in the Axelrod library currently score around 3*. Here's a chart showing the ten best strategies, plus <strong>Tit for Tat</strong>, <strong>Cooperator</strong>, and <strong>Defector</strong> for reference:</p>
<aside>
<p>Spoiler alert: these strategies are going to get soundly thrashed by the end of this article :-)</p>
</aside>
<p><img alt="fig1" src="/images/best_10_strategies.png"/></p>
<p>The reason that we're looking at a box plot here is that some of the strategies are <strong>stochastic</strong>, i.e. there's some random variation in the action they take. When calculating the scores, the Axelrod library takes care of running the tournament multiple times (100 by default) to get an average score for each strategy. </p>
<hr/>
<h2>Using lookup tables to define a strategy</h2>
<p>Many of the strategies in the Axelrod library choose their action based on what happened on the previous turn (or possibly earlier in the history). <strong>Tit for Tat</strong> is a good example; its action on a given turn depends entirely on the opponent's action on the previous one. We can think of this as a lookup table:</p>
<table class="table table-bordered">
  <thead>
    <tr>
      <th>Opponent's previous action</th>
      <th>My action</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Cooperate</td>
      <td>Cooperate</td>
    </tr>
    <tr>
      <td>Defect</td>
      <td>Defect</td>
    </tr>
  </tbody>
</table>

<p>or, in Python, as a dict where the keys are opponent's previous action, and the values are my action:</p>
<div class="highlight"><pre><span class="n">lookup_table</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'C'</span> <span class="p">:</span> <span class="s">'C'</span><span class="p">,</span>
    <span class="s">'D'</span> <span class="p">:</span> <span class="s">'D'</span>
<span class="p">}</span>
</pre></div>


<p>If we wanted to write a strategy that used this lookup table to decide what action to take, we could just grab the opponent's last action from its history like this:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opponent</span><span class="p">):</span>
    <span class="n">lookup_table</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">'C'</span> <span class="p">:</span> <span class="s">'C'</span><span class="p">,</span>
            <span class="s">'D'</span> <span class="p">:</span> <span class="s">'D'</span>
        <span class="p">}</span>

    <span class="c"># First move</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">C</span>

    <span class="c"># Get the opponent's last action</span>
    <span class="n">last_action</span> <span class="o">=</span> <span class="n">opponent</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c"># Use it to look up my action</span>
    <span class="n">my_action</span> <span class="o">=</span> <span class="n">lookup_table</span><span class="p">[</span><span class="n">last_action</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">my_action</span>
</pre></div>


<p>Notice that we still need a special case for the first turn; obviously if there is no history then we can't use the lookup table!</p>
<p>The nice thing about expressing a strategy in this was is that we can get different behaviours by changing the lookup table and leaving the strategy code exactly the same. In other words, the strategy is completely determined by the lookup table. For our current example, this isn't very exciting - given that there are only two possibilities for the dict key there are only three other strategies that we can describe: <strong>Cooperator</strong>:</p>
<div class="highlight"><pre><span class="c"># always cooperate</span>
<span class="n">lookup_table</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'C'</span> <span class="p">:</span> <span class="s">'C'</span><span class="p">,</span>
        <span class="s">'D'</span> <span class="p">:</span> <span class="s">'C'</span>
    <span class="p">}</span>
</pre></div>


<p>, <strong>Defector</strong>:</p>
<div class="highlight"><pre><span class="c"># always defect</span>
<span class="n">lookup_table</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'C'</span> <span class="p">:</span> <span class="s">'D'</span><span class="p">,</span>
        <span class="s">'D'</span> <span class="p">:</span> <span class="s">'D'</span>
    <span class="p">}</span>
</pre></div>


<p>, and <strong>Inverse Tit for Tat</strong>, which always does the opposite of the opponent's last action:</p>
<div class="highlight"><pre><span class="c"># do the opposite of my opponent's last action</span>
<span class="n">lookup_table</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'C'</span> <span class="p">:</span> <span class="s">'D'</span><span class="p">,</span>
        <span class="s">'D'</span> <span class="p">:</span> <span class="s">'C'</span>
    <span class="p">}</span>
</pre></div>


<p>Things start to get interesting when we use the last <strong>two</strong> turns of the opponent's history as the key to the lookup table. Take a look at this table:</p>
<table class="table table-bordered">
  <thead>
    <tr>
      <th>Opponent's recent history</th>
      <th>My action</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Cooperate, Cooperate</td>
      <td>Cooperate</td>
    </tr>
    <tr>
      <td>Cooperate, Defect</td>
      <td>Cooperate</td>
    </tr>
        <tr>
      <td>Defect, Cooperate</td>
      <td>Cooperate</td>
    </tr>
    <tr>
      <td>Defect, Defect</td>
      <td>Defect</td>
    </tr>
  </tbody>
</table>

<p>There are now four different possibilities (two for each turn) which allows us to express a more complex strategy. Here, we only defect if the opponent has defected twice in a row (this strategy is known as <strong>Tit for Two Tats</strong>). Here's the corresponding dict:</p>
<div class="highlight"><pre><span class="n">lookup_table</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'CC'</span> <span class="p">:</span> <span class="s">'C'</span><span class="p">,</span>
        <span class="s">'CD'</span> <span class="p">:</span> <span class="s">'C'</span><span class="p">,</span>
        <span class="s">'DC'</span> <span class="p">:</span> <span class="s">'C'</span><span class="p">,</span>
        <span class="s">'DD'</span> <span class="p">:</span> <span class="s">'D'</span><span class="p">,</span>
    <span class="p">}</span>
</pre></div>


<p>In order to use this lookup table in a <code>strategy()</code> method, we need to get the opponent's last two actions and join them together to make a string, and we also need to decide what to do on the first two turns:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opponent</span><span class="p">):</span>

    <span class="n">lookup_table</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'CC'</span> <span class="p">:</span> <span class="s">'C'</span><span class="p">,</span>
        <span class="s">'CD'</span> <span class="p">:</span> <span class="s">'C'</span><span class="p">,</span>
        <span class="s">'DC'</span> <span class="p">:</span> <span class="s">'C'</span><span class="p">,</span>
        <span class="s">'DD'</span> <span class="p">:</span> <span class="s">'D'</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c"># First two moves</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">C</span>

    <span class="c"># Get the opponent's last two actions</span>
    <span class="n">opponent_actions</span> <span class="o">=</span> <span class="n">opponent</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="c"># Use it to look up my action</span>
    <span class="n">my_action</span> <span class="o">=</span> <span class="n">lookup_table</span><span class="p">[</span><span class="n">opponent_actions</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">my_action</span>
</pre></div>


<p>We can extend this idea even further: what if we wanted to take into account our own history as well as our opponents? That gives us sixteen different possibilities (four for us multiplied by four for our opponent); here's what the first few rows of the table would look like: </p>
<table class="table table-bordered">
  <thead>
    <tr>
      <th>Opponent's recent history</th>
      <th>My recent history</th>
      <th>My action</th>
    </tr>
  </thead>
  <tbody>

    <tr>
      <td>Cooperate, Cooperate</td>
      <td>Cooperate, Cooperate</td>
      <td>?</td>
    </tr>

    <tr>
      <td>Cooperate, Defect</td>
      <td>Cooperate, Cooperate</td>
      <td>?</td>
    </tr>

    <tr>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>

  </tbody>
</table>

<p>And we can now think about even more complex rules. For example, if we defected and the opponent didn't retaliate, then defect again:</p>
<table class="table table-bordered">
  <thead>
    <tr>
      <th>Opponent's recent history</th>
      <th>My recent history</th>
      <th>My action</th>
    </tr>
  </thead>
  <tbody>

    <tr>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>

    <tr>
      <td>Cooperate, Cooperate</td>
      <td>Defect, Defect</td>
      <td>Defect</td>
    </tr>

    <tr>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>

  </tbody>
</table>

<p>Or we might want a rule that we never defect more than twice in a row:</p>
<table class="table table-bordered">
  <thead>
    <tr>
      <th>Opponent's recent history</th>
      <th>My recent history</th>
      <th>My action</th>
    </tr>
  </thead>
  <tbody>

    <tr>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>

    <tr>
      <td>Cooperate, Cooperate</td>
      <td>Defect, Defect</td>
      <td>Cooperate</td>
    </tr>
     <tr>
      <td>Cooperate, Defect</td>
      <td>Defect, Defect</td>
      <td>Cooperate</td>
    </tr>
    <tr>
      <td>Defect, Cooperate</td>
      <td>Defect, Defect</td>
      <td>Cooperate</td>
    </tr>
     <tr>
      <td>Defect, Defect</td>
      <td>Defect, Defect</td>
      <td>Cooperate</td>
    </tr>

    <tr>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>

  </tbody>
</table>

<p>To write this lookup table as a dict, we'll create a tuple consisting of our last two actions, and our opponent's last two actions, and use that as the key. So the key/value pairs for the rule in the table above looks like this:</p>
<div class="highlight"><pre><span class="n">lookup_table</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">)</span> <span class="p">:</span> <span class="s">'C'</span><span class="p">,</span> 
    <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">)</span> <span class="p">:</span> <span class="s">'C'</span><span class="p">,</span> 
    <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">)</span> <span class="p">:</span> <span class="s">'C'</span><span class="p">,</span> 
    <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">)</span> <span class="p">:</span> <span class="s">'C'</span><span class="p">,</span> 
    <span class="o">...</span>
<span class="p">}</span>
</pre></div>


<p>Mathematically-inclined readers will have noticed that as we increase the number of keys in the lookup table dict, the number of possible strategies we can describe increases rather rapidly. Each key can result in two possible values (cooperate or defect), so for <em>n</em> keys there are <em>2^n</em> possible lookup tables. The above example has 16 keys, which gives us 65,536 different strategies. </p>
<p>Finally, let's add another factor to our lookup table: the opponent's <em>first</em> two moves. This gives us the ability to implement rules like "if we defected and the opponent didn't retaliate then defect again, but only if the opponent started off by cooperating":</p>
<table class="table table-bordered">
  <thead>
    <tr>
      <th>Opponent's first actions</th>
      <th>Opponent's recent history</th>
      <th>My recent history</th>
      <th>My action</th>
    </tr>
  </thead>
  <tbody>

    <tr>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>

    <tr>
      <td>Cooperate, Cooperate</td>
      <td>Cooperate, Cooperate</td>
      <td>Defect, Defect</td>
      <td>Defect</td>
    </tr>

    <tr>
      <td>Defect, Defect</td>
      <td>Cooperate, Cooperate</td>
      <td>Defect, Defect</td>
      <td>Cooperate</td>
    </tr>

    <tr>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>

  </tbody>
</table>

<p>The keys for our lookup table dict are now 3-tuples consisting of the opponent's starting actions, the opponent's recent actions, and our recent actions:</p>
<div class="highlight"><pre><span class="n">lookup_table</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">)</span> <span class="p">:</span> <span class="s">'D'</span><span class="p">,</span>
    <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">)</span> <span class="p">:</span> <span class="s">'C'</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></div>


<aside>
<p>*The process of scoring is embarrassingly parallel, so this scales pretty well on multi-core machines using <code>multiprocessing</code>.</p>
</aside>
<p>This key structure gives us 64 different keys and about 10^18 different strategies. If we're interested in finding the best strategy - i.e. the one that gives the highest average score per turn - we're going to need a way of exploring the strategies. On a reasonably modern desktop it takes around 3 seconds to score a single table* so an exhaustive brute-force search will take around 90 billion years. We're going to need something a bit more sophisticated. </p>
<h2>Searching lookup table space to find good ones</h2>
<aside>
<p>*See <a href="https://github.com/Axelrod-Python/Axelrod/blob/master/axelrod/strategies/lookerup.py">here</a> for the full version, which is more complicated because it's designed to work with dicts of any size.</p>
</aside>
<p>To search for "good" strategies that use a 64-key lookup table, we need a way to quickly create a player object for a given dict. Here's a  simplified version of the code*:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">LookerUp</span><span class="p">(</span><span class="n">Player</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lookup_table</span><span class="p">):</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span> <span class="o">=</span> <span class="n">lookup_table</span>


    <span class="k">def</span> <span class="nf">strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opponent</span><span class="p">):</span>
        <span class="c"># If there isn't enough history to lookup an action, cooperate.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">C</span>

        <span class="c"># Get my own last two actions</span>
        <span class="n">my_history</span> <span class="o">=</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>

        <span class="c"># Do the same for the opponent.</span>
        <span class="n">opponent_history</span> <span class="o">=</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">opponent</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>

        <span class="c"># Get the opponents first two actions.</span>
        <span class="n">opponent_start</span> <span class="o">=</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">opponent</span><span class="o">.</span><span class="n">history</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

        <span class="c"># Put these three strings together in a tuple.</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">opponent_start</span><span class="p">,</span> <span class="n">my_history</span><span class="p">,</span> <span class="n">opponent_history</span><span class="p">)</span>

        <span class="c"># Look up the action associated with that tuple in the lookup table.</span>
        <span class="n">action</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">action</span>
</pre></div>


<p>The idea behind this strategy is that we can pass in a lookup table to the constructor to determine what strategy our player will play. For instance, here's <strong>Cooperator</strong>:</p>
<div class="highlight"><pre><span class="c"># this table actually has all 64 possible keys, not all shown</span>
<span class="n">cooperator_table</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span>
    <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span>
    <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span>
    <span class="o">...</span>
    <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span>
    <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">}</span>
<span class="p">}</span>

<span class="n">cooperator</span> <span class="o">=</span> <span class="n">LookerUp</span><span class="p">(</span><span class="n">cooperator_table</span><span class="p">)</span>
</pre></div>


<p>We will also need a couple of utility functions to help us calculate the score for a given lookup table. Here's a function that will take two player objects, play a match between them, and return the average per-turn score of the first one:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">score_single</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Return the average score per turn for a player in a single match against</span>
<span class="sd">    an opponent.</span>
<span class="sd">     """</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">axelrod</span><span class="o">.</span><span class="n">Game</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
        <span class="n">me</span><span class="o">.</span><span class="n">play</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span>
        <span class="n">g</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">pair</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">me</span><span class="o">.</span><span class="n">history</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">history</span><span class="p">)</span>
        <span class="p">])</span> <span class="o">/</span> <span class="n">iterations</span>
</pre></div>


<p>It uses the <code>Game</code> object from the Axelrod library to do the actual scoring. </p>
<p>Of course, for a given table we're interested in the average score against <strong>all</strong> other strategies, so here's a function which will take a strategy factory function, score that strategy against all the other strategies in the library, and return the average score:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">score_for</span><span class="p">(</span><span class="n">my_strategy_factory</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Given a function that will return a strategy, </span>
<span class="sd">    calculate the average score per turn</span>
<span class="sd">    against all ordinary strategies. If the </span>
<span class="sd">    opponent is classified as stochastic, then </span>
<span class="sd">    run 100 repetitions and take the average to get </span>
<span class="sd">    a good estimate. </span>
<span class="sd">    """</span>
    <span class="n">scores_for_all_opponents</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">opponent</span> <span class="ow">in</span> <span class="n">axelrod</span><span class="o">.</span><span class="n">ordinary_strategies</span><span class="p">:</span>

        <span class="c"># decide whether we need to sample or not</span>
        <span class="k">if</span> <span class="n">opponent</span><span class="o">.</span><span class="n">classifier</span><span class="p">[</span><span class="s">'stochastic'</span><span class="p">]:</span>
            <span class="n">repetitions</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">repetitions</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">scores_for_this_opponent</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># calculate an average for this opponent</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">repetitions</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">=</span> <span class="n">my_strategy_factory</span><span class="p">()</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">opponent</span><span class="p">()</span>
            <span class="c"># make sure that both players know what length the match will be </span>
            <span class="n">me</span><span class="o">.</span><span class="n">set_tournament_attributes</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="n">iterations</span><span class="p">)</span>
            <span class="n">other</span><span class="o">.</span><span class="n">set_tournament_attributes</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="n">iterations</span><span class="p">)</span>

            <span class="n">scores_for_this_opponent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score_single</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">iterations</span><span class="p">))</span>

        <span class="n">mean_vs_opponent</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">scores_for_this_opponent</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores_for_this_opponent</span><span class="p">)</span>
        <span class="n">scores_for_all_opponents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_vs_opponent</span><span class="p">)</span>

    <span class="c"># calculate the average for all opponents</span>
    <span class="n">overall_average_score</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">scores_for_all_opponents</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores_for_all_opponents</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">overall_average_score</span><span class="p">)</span>
</pre></div>


<p>This one's a bit more complicated because it's got to take into account that some of the opponents will be stochastic strategies, so for those we need to repeat the match 100 times to get a good average. </p>
<aside>
<p>Using a lambda function in this way is a bit odd: what we're doing is supplying the <code>score_for()</code> function with a callable that it can use every time it needs to create a new player for the strategy we're testing.</p>
</aside>
<p>With these two functions in hand, we can take a given lookup table, and calculate its average score per turn (which from now on we will just refer to as "score") against all other strategies:</p>
<div class="highlight"><pre><span class="c"># this table actually has all 64 possible keys, not all shown</span>
<span class="n">cooperator_table</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span>
    <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span>
    <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span>
    <span class="o">...</span>
    <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span>
    <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">}</span>
<span class="p">}</span>

<span class="n">score</span> <span class="o">=</span> <span class="n">score_for</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">LookerUp</span><span class="p">(</span><span class="n">cooperator_table</span><span class="p">))</span>
</pre></div>


<p>The reason we're going to the trouble of defining our own functions for scoring rather than using the built-in tournament tools in the Axelrod library is for performance. When we come to the evolutionary algorithm we're going to want to run lots of very small tournaments, and in testing I found the overhead of creating tournament manager objects for each one to be too great. </p>
<p>As a quick sanity check, let's make sure that our lookup-table-based <strong>Cooperator</strong> gets a similar score to Axelrod's built-in <code>Cooperator</code> class:</p>
<div class="highlight"><pre><span class="k">print</span><span class="p">(</span><span class="n">axelrod_utils</span><span class="o">.</span><span class="n">score_for</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">axelrod</span><span class="o">.</span><span class="n">LookerUp</span><span class="p">(</span><span class="n">cooperator_table</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="n">axelrod_utils</span><span class="o">.</span><span class="n">score_for</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">axelrod</span><span class="o">.</span><span class="n">Cooperator</span><span class="p">()))</span>

<span class="mf">2.39160728155</span>
<span class="mf">2.39377135922</span>
</pre></div>


<p>Looks good!</p>
<h3>Search method one: sample random tables</h3>
<p>Let's take a sample of randomly-generated lookup tables and examine their scores. Rather than type out the list of keys each time we want to create a new table, we can generate them using <code>itertools</code>. We can use <code>product()</code> to generate all the possible two-character strings of C and D:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">itertools</span>
<span class="k">print</span><span class="p">([</span><span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">)])</span>

<span class="p">[</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">]</span>
</pre></div>


<p>and then use <code>product()</code> again to get all possible combinations of three such strings:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">itertools</span>
<span class="n">strings</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">)]</span>
<span class="n">lookup_table_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span><span class="n">strings</span><span class="p">,</span> <span class="n">strings</span><span class="p">))</span>
<span class="k">print</span> <span class="n">lookup_table_keys</span>

<span class="p">[(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">),</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">)]</span>
</pre></div>


<p>To generate a complete lookup table, we just generate a random string of C and D to be the values, and zip the keys and values up into a dict:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">get_random_table</span><span class="p">():</span>
    <span class="n">strings</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">)]</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span><span class="n">strings</span><span class="p">,</span> <span class="n">strings</span><span class="p">))</span>
    <span class="n">values</span> <span class="o">=</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="s">"CD"</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="n">get_random_table</span><span class="p">())</span>

<span class="p">{(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'D'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">,</span> <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="s">'C'</span><span class="p">}</span>
</pre></div>


<p>Because the keys to the tables are all going to be exactly the same, we'll write a helper function which will take a table and return the values as a string:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">id_for_table</span><span class="p">(</span><span class="n">table</span><span class="p">):</span>
    <span class="sd">"""Return a string representing the values of a lookup table dict"""</span>
    <span class="k">return</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>
</pre></div>


<p>This will make it easier to visualize the tables, since it's only the values we care about (note that we're grabbing the items in sorted order to make sure that we always get the keys in the same order). Now we can create ten random lookup tables and score them:</p>
<div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">random_table</span><span class="o">=</span> <span class="n">get_random_table</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">id_for_table</span><span class="p">(</span><span class="n">random_table</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">axelrod_utils</span><span class="o">.</span><span class="n">score_for</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">axelrod</span><span class="o">.</span><span class="n">LookerUp</span><span class="p">(</span><span class="n">random_table</span><span class="p">)))</span>

<span class="n">DDDCDCDDDCDDDDCCDCCDCCCDCDDDDCCDDDDDCCDCDCDCDDDCDDDDCDCDDCDDDCCD</span>
<span class="mf">2.01603495146</span>
<span class="n">CCDDCDDDCDDDDCDCCDDDCCCCCCCDCCDCCCCCDCDDDDCCDDDCCDCCDDDCCDDDCCCD</span>
<span class="mf">2.62583932039</span>
<span class="n">CCCCCDCDCCDDDDDCDDCDDDCDDDDDDDCDDCCDDDCDCDDCDCCDCDDDCDCDDCDCDDCD</span>
<span class="mf">2.75987669903</span>
<span class="n">CDCCCCCDDDDCDCDDCCDDCCDDDDCCCDCCCCDDDDDDCCDDDDCDCCCCDDDCDDDDCDDC</span>
<span class="mf">2.64813640777</span>
<span class="n">DCCDDCDDCDCDDCDCCDDDDCCCCDCCDCCCDCCDCDCDDCDCCDCCDCCDCCCDCDDDDCCD</span>
<span class="mf">2.02994029126</span>
<span class="n">DDCDDDDDDDCDDCDCDCDCDCCCCDCDCCDCDCDCCDDCCDCCCCCDDCCDDCCCCCDDCDDC</span>
<span class="mf">1.9428038835</span>
<span class="n">DDDDCCCCDCDDDCDCDCCDCDDDDDCCDDDDCCCCDDCCDDCDCCCDDCDDCDCDDDDCDCDD</span>
<span class="mf">2.3824461165</span>
<span class="o">...</span>
</pre></div>


<p>As expected, there's quite a bit of variation. We might expect that if we score many random tables their scores will form a roughly normal distribution, but surprisingly that's not the case. Here's a histogram of scores for a thousand random tables, which clearly shows a bimodal distribution:</p>
<p><img alt="fig1" src="/images/histogram_of_1000_random_tables.png"/></p>
<p>It looks like a mixture of two normal distributions centered at mean scores of 2.1 and 2.7. At this point, if I had to guess I would suspect that there's a single key whose contribution to the score is very important. To test how important a particular key is, we can take each position in the ID string and calculate the difference in mean score for those tables that had C and that position, and those that had D. Given a dict where the keys are the ID strings and the values are the scores, we can get list of all such differences:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">mean</span><span class="p">():</span>
    <span class="o">...</span>

<span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">'DDDCDCDDDCDDDDCCDCCDCCCDCDDDDCCDDDDDCCDCDCDCDDDCDDDDCDCDDCDDDCCD'</span> <span class="p">:</span> <span class="mf">2.0160</span><span class="p">,</span>
  <span class="s">'CCDDCDDDCDDDDCDCCDDDCCCCCCCDCCDCCCCCDCDDDDCCDDDCCDCCDDDCCDDDCCCD'</span> <span class="p">:</span> <span class="mf">2.6258</span><span class="p">,</span>
  <span class="o">...</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">get_diff</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
  <span class="n">c_score</span> <span class="o">=</span> <span class="n">mean</span><span class="p">([</span><span class="n">score</span> <span class="k">for</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">pattern</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="s">'C'</span><span class="p">])</span>
  <span class="n">d_score</span> <span class="o">=</span> <span class="n">mean</span><span class="p">([</span><span class="n">score</span> <span class="k">for</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">pattern</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="s">'D'</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">c_score</span> <span class="o">-</span> <span class="n">d_score</span>

<span class="n">diffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_diff</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">)]</span>
</pre></div>


<p>and zip this together with our original list of lookup table keys to get a dict where the keys are the normal history tuples and the values are the differences. In other words, how much higher does a table score, on average, by having Cooperate as its response to a given set of conditions as opposed to Defect:</p>
<div class="highlight"><pre><span class="n">strings</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">)]</span>
<span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span><span class="n">strings</span><span class="p">,</span> <span class="n">strings</span><span class="p">)))</span>
<span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">diffs</span><span class="p">))</span>

<span class="p">{</span>
  <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="mf">0.5985246110918112</span><span class="p">,</span>
  <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="o">-</span><span class="mf">0.036229032273884965</span><span class="p">,</span>
  <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DC'</span><span class="p">):</span> <span class="mf">0.022587412332811585</span><span class="p">,</span>
  <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'DD'</span><span class="p">):</span> <span class="mf">0.011773214960386635</span><span class="p">,</span>
  <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="mf">0.03782112365374468</span><span class="p">,</span>
  <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">):</span> <span class="mf">0.049968171759873226</span><span class="p">,</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></div>


<aside>
<p>*Remember that the opponent's first two actions are represented by the first string in the tuple which forms the key.</p>
</aside>
<p>The crucially important key turns out to be the very first one: if the opponent started by cooperating twice, and both the opponent and me cooperated on both of the previous two turns, then cooperating again rather than defecting causes a massive score bonus of 0.6. This neatly explains the bimodal distribution that we saw in the histogram of scores. Intriguingly, the importance of following this rule almost completely disappears if the opponent started by doing something other than cooperating twice*:</p>
<div class="highlight"><pre><span class="p">{</span>
  <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="mf">0.5985246110918112</span><span class="p">,</span>
  <span class="o">...</span>
  <span class="p">(</span><span class="s">'CD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="mf">0.008174615248195405</span><span class="p">,</span>
  <span class="o">...</span>
  <span class="p">(</span><span class="s">'DC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="mf">0.01990436367685966</span><span class="p">,</span>
  <span class="o">...</span>
  <span class="p">(</span><span class="s">'DD'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">,</span> <span class="s">'CC'</span><span class="p">):</span> <span class="mf">0.007840839408610911</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>


<p>Why is this one rule so important? It's probably something to do with the frequency with which the scenario occurs. In scoring 100 random tables, the pattern of mutual cooperation on two consecutive turns occurred just over 20 million times, while the next most common scenario - two consecutive turns of mutual defection - occurred about 7.5 million times. This is probably due to the presence in the Axelrod library of a large number of so-called <strong>nice</strong> strategies, i.e. those that will never defect before its opponent does. Note, however, that the importance of the double-mutual-cooperation pattern can't be due to frequency alone - while it occurs just over twice as often as double-mutual-defection, its scoring difference as measured in the dict above is about one hundred times greater. </p>
<p>The presence of <strong>nice</strong> strategies also neatly explains why the importance of responding correctly to double-mutual-cooperation goes away if the opponent defects any time in the first two turns. Given that our strategy always cooperates on the first two turns (regardless of what's in the lookup table), any opponent that defected on either of the first two turns is by definition not a nice strategy, so it's not so important for us to try to preserve a cycle of cooperation. </p>
<aside>
<p>*The zero points we get for cooperating when the opponent betrays is known in the literature as the <em>sucker's payout</em></p>
</aside>
<p>Looking at the results in this way is a bit unintuitive. We can visualize them better if we come up with short names for each of the four possibilities at each of the previous two turns. If both us and the opponent cooperated we'll call that <strong>mutual coop</strong>. If we both defected then we'll call it <strong>mutual defection</strong>. If we defected and the opponent cooperated (the best outcome for us) we'll call that <strong>betrayer</strong>. And if we cooperated but the opponent defected then we'll call that <strong>sucker</strong>*. </p>
<p>This gives us a dict that looks like this, where the two elements of the tuple in the key are the opponent's first two actions and the outcome of the last two turns:</p>
<div class="highlight"><pre><span class="p">{</span>
  <span class="o">...</span>
  <span class="p">(</span><span class="s">'CC'</span><span class="p">,</span> <span class="s">'betrayer-sucker'</span><span class="p">):</span> <span class="o">-</span><span class="mf">0.03</span><span class="p">,</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></div>


<p>So from the key/value pair in the example above if </p>
<aside>
<p>*Remember that the numbers are the advantage given by cooperating, so a negative number means it's better to defect.</p>
</aside>
<ul>
<li>the opponent started by cooperating twice</li>
<li>two turns ago we defected and the opponent cooperated (i.e. we were <strong>betrayer</strong>)</li>
<li>in the last turn we cooperated and the opponent defected (i.e. we were the <strong>sucker</strong>)</li>
</ul>
<p>then our average score will be 0.03 higher if we defect this turn rather than cooperating*.</p>
<p>Laying out the data like this allows us to draw a heatmap showing when it's better to cooperate and defect, and by how much:</p>
<p><img alt="fig1" src="/images/full_scale_diffs.png"/></p>
<aside>
<p>The colour bar on the right shows the scale of scores.</p>
</aside>
<p>In this figure the opponent's first two actions are on the left side, and the sixteen possible outcomes of the previous two turns are arranged along the top. The colour of each square represents whether it's better to cooperate or defect, and by how much. Positive numbers (i.e. better to cooperate) are red, and the stronger the red colour the greater the increase in score given by cooperating. Negative numbers (i.e. better to defect) are blue. Positions for which there isn't much difference in score between defecting and cooperating show up in grey. The bar on the right-hand side gives the scale. </p>
<p>The most striking thing is the square in the bottom right corner, representing the case where the opponent started by cooperating twice and both previous turns have been mutual cooperation. This is the extremely strong benefit of not breaking cycles of mutual cooperation. The next strongest-coloured square is the top right, representing the situation where the opponent started by defecting twice, and on both previous turn we have been the sucker. In this scenario, it's much better to defect (blue) rather than cooperate. </p>
<p>The very high value in the bottom right makes it quite difficult to see the patterns in the data, because it's so much bigger than everything else. Let's get rid of those two very high value squares and redraw the figure, stretching the scale so we can see the other squares more clearly:</p>
<p><img alt="fig1" src="/images/diffs_no_outliers.png"/></p>
<p>Notice how the colour scale has changed; pure red/blue now means a score of +0.06/-0.06. These numbers seem small, but remember that the current ten best strategies are separated by an average score of only 0.1. </p>
<p>This is a very interesting figure to look at, and I've spent quite a bit of time with it :-). The first thing that jumps out is just how different the patterns are for the different rows (i.e. how much the best thing to do in any given situation depends on the opponent's opening moves). Pretty much every column has one or two squares in it that are different to the others, sometimes with quite high scores. For example, look at the row corresponding to <strong>betrayer</strong> followed by <strong>mutual cooperation</strong> (ninth from the left). If the opponent started by defecting twice in a row, then it's a very good idea to defect (top row, a deep blue colour). But if the opponent started by defecting then cooperating, it's a very good idea to cooperate (second row, medium red). </p>
<aside>
<p>*Possibly because we've been "punished" and need to get back to a cycle of cooperation.</p>
</aside>
<p>The third row shows a surprising pattern: if the opponent started off by cooperating then defecting, then it's best to defect in <em>every single</em> scenario, except for two turns of mutual cooperation or <strong>betrayer</strong> followed by <strong>mutual defection</strong>*. Trying to come up with an explanation for all the patterns we see in this figure would be a long and tedious process, so let's move on. </p>
<h3>Search method 2: pick the best action for each key independently</h3>
<p>Studying this figure suggests an obvious approach to finding a high-scoring strategy: simply pick the action that maximizes the mean score at each position. If we have the differences stored in a dict as illustrated above, we can do this by just making a copy of the dict and then setting each value based on the sign of the score:</p>
<div class="highlight"><pre><span class="n">best_table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">key2diff</span><span class="p">)</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">diff</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">key2diff</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
    <span class="k">if</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">best_table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="s">'C'</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">best_table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="s">'D'</span>
</pre></div>


<p>This gives us a table with a score of around 2.95 - here it is on the chart from before (the new strategy is on the left):</p>
<p><img alt="fig1" src="/images/single_best.png"/></p>
<p>Notice that this strategy scores better than the best of our random 1000 strategies which we plotted on the histogram earlier: the best of those scored 2.93. </p>
<aside>
<p>*i.e. the opponents that our strategy will face during the tournament</p>
</aside>
<p>How likely is it that the lookup table chosen in this way is the best possible table? It depends on how much interaction there is between different keys. If our response to a particular scenario early in a match can affect the outcome of a different scenario later in a match, then we expect there to be subtle interactions between keys. We can tell just by browsing the strategies in the Axelrod library* that many of them <em>do</em> base their actions on what happened earlier in the match, so it's very likely that keys are <strong>not</strong> independent, and that we can find a better table with a different search method. </p>
<h3>Search method 3: a greedy hill-climbing algorithm</h3>
<p>Here's a slightly more sophisticated way of finding good strategies: a simple hill-climbing algorithm. We'll start with a random table, then repeatedly flip one of the keys at random and keep the new table if it's better:</p>
<div class="highlight"><pre><span class="n">current_table</span> <span class="o">=</span> <span class="n">get_random_table</span><span class="p">()</span>
<span class="n">curent_score</span> <span class="o">=</span> <span class="n">axelrod_utils</span><span class="o">.</span><span class="n">do_table</span><span class="p">(</span><span class="n">current_table</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
    <span class="c"># flip one key</span>
    <span class="n">new_table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">current_table</span><span class="p">)</span>
    <span class="n">key_to_change</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">new_table</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">new_table</span><span class="p">[</span><span class="n">key_to_change</span><span class="p">]</span> <span class="o">=</span> <span class="s">'C'</span> <span class="k">if</span> <span class="n">new_table</span><span class="p">[</span><span class="n">key_to_change</span><span class="p">]</span> <span class="o">==</span> <span class="s">'D'</span> <span class="k">else</span> <span class="s">'D'</span>

    <span class="n">new_score</span> <span class="o">=</span> <span class="n">axelrod_utils</span><span class="o">.</span><span class="n">do_table</span><span class="p">(</span><span class="n">new_table</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">new_score</span> <span class="o">&gt;</span> <span class="n">curent_score</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"accepting change, new score is "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">new_score</span><span class="p">))</span>
        <span class="n">current_table</span> <span class="o">=</span> <span class="n">new_table</span>
        <span class="n">curent_score</span> <span class="o">=</span> <span class="n">new_score</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"rejecting change"</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"hillclimb.csv"</span><span class="p">,</span> <span class="s">'a'</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
        <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">axelrod_utils</span><span class="o">.</span><span class="n">id_for_table</span><span class="p">(</span><span class="n">current_table</span><span class="p">)</span> 
            <span class="o">+</span> <span class="s">','</span> 
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">curent_score</span><span class="p">)</span> 
            <span class="o">+</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
</pre></div>


<p>This approach does pretty well; the best solution that it finds is comparable with <code>DoubleCrosser</code> with a mean score of around 3.1. </p>
<p><img alt="fig1" src="/images/hillclimb1.png"/></p>
<p>The score remains the same for long stretches, with only occasional jumps. We can try various things to fix it - how about flipping more than one key at a time?</p>
<div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
    <span class="n">new_table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">current_table</span><span class="p">)</span>

    <span class="c"># flip several keys</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">key_to_change</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">new_table</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">new_table</span><span class="p">[</span><span class="n">key_to_change</span><span class="p">]</span> <span class="o">=</span> <span class="s">'C'</span> <span class="k">if</span> <span class="n">new_table</span><span class="p">[</span><span class="n">key_to_change</span><span class="p">]</span> <span class="o">==</span> <span class="s">'D'</span> <span class="k">else</span> <span class="s">'Do'</span>

    <span class="n">new_score</span> <span class="o">=</span> <span class="n">axelrod_utils</span><span class="o">.</span><span class="n">do_table</span><span class="p">(</span><span class="n">new_table</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="o">...</span>
</pre></div>


<p>This doesn't make much difference, at least for this run:</p>
<p><img alt="fig1" src="/images/hillclimb2.png"/></p>
<p>The problem with this approach (as with pretty much all naive hill-climbing algorithms) is that it's just too easy to get stuck in a local maximum: a pattern that's nowhere near the best, but where any small change is likely to make it worse. </p>
<p>If we wanted to pursue this hill-climbing idea further then we'd probably want to explore options like accepting changes that decrease the score with some probability, or starting with big changes (e.g. flipping half the keys) and making the changes smaller as we go on. We'd likely end up with something that resembled simulated annealing, or Monte Carlo sampling. However, we're not going to, because I want to talk about a completely different approach.</p>
<h3>Search method four: an evolutionary algorithm</h3>
<p>The idea behind an evolutionary algorithm is to find solutions to a complex, non-linear problem like ours by mimicking the process of natural selection. Rather than looking at a single lookup table at a time, we'll maintain a population of many lookup tables. In each generation, we'll mate pairs of tables to produce offspring that share properties of both (simulating the process of recombination) and also randomly flip some of the keys (simulating the process of mutation). We'll also throw in some more randomly-generated tables as a source of new variation. These processes will give us a bunch of new tables, which we'll calculate the scores for, and keep only the best individual tables for the next generation. </p>
<aside>
<p>*See <a href="https://github.com/mojones/axelrod-evolver/blob/master/lookup_evolve.py">here</a> for a full, commented version which also implements parallel calculating of scores with <code>multiprocessing</code>.</p>
</aside>
<p>We can re-use large parts of the code we've already written* for the other search methods - we already know how to score a table and how to generate random tables. To "mate" two tables and produce a single offspring, we'll pick a random crossover point somewhere in the list of keys, and take the keys before that point from parent A and the keys after that point from parent B:</p>
<div class="highlight"><pre><span class="c"># assuming t1 and t2 are both valid lookup tables</span>

<span class="n">crossover</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

<span class="c"># the values (plays) for the offspring are copied from t1 up to the crossover point, </span>
<span class="c"># and from t2 from the crossover point to the end</span>
<span class="n">new_values</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">values</span><span class="p">()[:</span><span class="n">crossover</span><span class="p">]</span> <span class="o">+</span> <span class="n">t2</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="n">crossover</span><span class="p">:]</span>

<span class="c"># turn those new values into a valid lookup table by copying the keys from t1 (the keys are the same for</span>
<span class="c"># all tables, so it doesn't matter which one we pick)</span>
<span class="n">new_table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">new_values</span><span class="p">))</span>
</pre></div>


<p>To simulate mutation on a given table, we'll flip each key with a probability that we'll call the mutation rate:</p>
<div class="highlight"><pre><span class="c"># assuming c is a valid lookup table</span>

<span class="c"># flip each value with a probability proportional to the mutation rate</span>
<span class="k">for</span> <span class="n">history</span><span class="p">,</span> <span class="n">action</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">mutation_rate</span><span class="p">:</span>
        <span class="n">c</span><span class="p">[</span><span class="n">history</span><span class="p">]</span> <span class="o">=</span> <span class="s">'C'</span> <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s">'D'</span> <span class="k">else</span> <span class="s">'D'</span>
</pre></div>


<p>For details of the rest of the algorithm see the repo <a href="https://github.com/mojones/axelrod-evolver">here</a> which also includes a command-line tool to run the evolutionary algorithm. </p>
<p>Here's the result of running the algorithm for around 200 generations:</p>
<p><img alt="fig1" src="/images/ga_run.png"/></p>
<aside>
<p>*Since writing this post, the Axelrod library has been updated with new strategies, so if you try this yourself you'll likely get different results.</p>
</aside>
<p>The blue line shows the score of the best table at each generation, the orange line shows the average score for the population. Compared to the other search methods we've tried, it finds good tables remarkably quickly. The first table that beats the current best strategy appears in the third generation with a score of 3.077, and the score levels out at around 3.185*. </p>
<p>Let's take a look at the winner. This next figure has two parts: on the top is the heatmap from before showing the differences we calculated from random tables, on the bottom is a similar chart showing the actions at each position for our winning table. The lower chart simply shows the action for each situation, so there are no shades of colour, only red and blue to indicate cooperation and defection. If a square in the bottom chart is the same colour as one in the top, it means that the action of our winning lookup table at that position is the same as the one we would have guessed based on random sampling.</p>
<p><img alt="fig1" src="/images/diffs_no_outliers.png"/></p>
<p><img alt="fig1" src="/images/winner_actions.png"/></p>
<p>The patterns overlap somewhat, but there are some striking differences. This, along with the much higher score obtained by this table vs. simply picking the best option for each square independently, confirms our suspicion that there are complex interactions between the responses to different situations. It's tempting to pick out specific positions and try to come up with explanations for the rule, but confirming our guesses would involve looking in detail at the actual series of actions in the matches, so I will resist :-) except to note that the two squares with very strong scores in the heatmap - bottom left and top right - are the same. </p>
<p>Another way to look at the pattern of actions is to take each position, flip the action, and see how much worse the score is. Here's the heatmap:</p>
<p><img alt="fig1" src="/images/fiip_decrease.png"/></p>
<p>Note that we're <strong>not</strong> looking at the score for C versus D as we were before; instead we're looking at the reduction in score if we change the action at a particular position (I've changed the colour scale to reflect this). Brighter yellow means a bigger reduction in score. The top-right and bottom-left squares appear to be very important as we expect, but there are also some positions that seem a lot brighter than we'd expect based on the data from random tables. In particular, there are a couple of bright squares (i.e. a couple of important positions) showing that it's important to retaliate by defecting if we have just been suckered, at least for certain starting actions.</p>
<p>What we're really trying to do here is look at the relative contribution of different situations (keys in the lookup table dict) to getting a good score. The heatmap is kind of awkward for this, so let's try a different plot. Here's a scatter plot which shows, for each of our 64 keys, the advantage of C over D in the sample of random tables on the X axis and the advantage of C over D in the winning table:</p>
<p><img alt="fig1" src="/images/diffs_scatter.png"/></p>
<p>This plot takes a bit of interpretation....if a point is to the right of the vertical axis, it means that in the winning table we get a higher score if we have cooperate as the value. The further to the right it is, the greater the score. If a point is to the left of the vertical axis, then it's better to have defect as the value in the winning table. Points lying more or less on the vertical axis represent values that don't really affect the score for the winning table. The horizontal axis shows the same thing for the random tables: for points above the axis it's better to have cooperate, for points below it's better to have defect. </p>
<aside>
<p>*I'm going to shamelessly anthropomorphise the lookup tables by assigning motivations to them, just because it makes it easier to talk about. I know it makes me a bad scientist.</p>
</aside>
<p>Way out on the top-right is our old friend representing the situation where the opponent started by cooperating twice and the last two turns were both mutual cooperation. We already know from the previous figures that, for both the random and winning tables, it's highly advantageous to have cooperate as our response. Interestingly, it's more advantageous for the winning table than for the random tables, possibly because the winning table tries* to maintain unbroken runs of mutual cooperation and so the situation simply occurs more often. </p>
<p>Let's zoom in on the middle bit of the chart, excluding this obvious outlier:</p>
<p><img alt="fig1" src="/images/diffs_scatter_zoom.png"/></p>
<p>Quite a few interesting features become visible. </p>
<p>Firstly, there are many more points lying on or near the vertical axis than the horizontal axis. This means that there are many more keys whose value doesn't really matter for the winning table than for random tables. This makes intuitive sense; we would expect the winning table to try hard to avoid situations that are bad for it, so those situations will occur much more rarely for the winning table than for random tables, so the response to them won't be so important. When we look at the descriptions for these points, a lot of them seem to involve being the sucker, which we expect to be minimized by the winning table. </p>
<p>Secondly, there's generally a positive correlation - most of the points are in the top right quadrant (cooperation is advantageous in both the winning table and random tables) or the bottom right quadrant (defection is better in both the winning table and random tables). </p>
<aside>
<p>*In this plot, there's no way to tell whether that's because the effect is always small, or whether it's large but in different directions - we'd need to look at the variance.</p>
</aside>
<p>Thirdly, there's a little cluster of points with quite strong scores in the top left quadrant. These represent situations where it's advantageous to cooperate in random tables, but advantageous to defect in the winning table. These are probably the most interesting points. For example, take the situation where the opponent started by cooperating twice, and the last two rounds have been mutual cooperation followed by sucker. In random tables, there's little systematic advantage to cooperating or defecting*; however in the winning table, there's a strong advantage to defecting. </p>
<p>Notably, there isn't a corresponding cluster in the bottom right quadrant (i.e. advantageous to defect in random tables but advantageous to cooperate in winning tables). In other words, there are situations where it's more advantageous to defect than we'd expect by looking at random tables, but there are none where it's more advantageous to cooperate. If you can think of a plausible reason for this, please leave a comment!</p>
<p>Anyway, here's the final box plot showing the new strategy (here labeled as <code>LookerUp</code>) along with the others from before:</p>
<p><img alt="fig1" src="/images/final_boxplot.png"/></p>
<h2>Further work</h2>
<p>There are a few obvious extensions to this idea. We could simply increase the memory depth of the table by, for instance, taking into account the last three turns rather than the last two. The problem with this is that we very quickly run into scaling issues: a lookup table with these dimensions will have 256 keys (four times as many as our current table), which means that the number of possible value patterns will be around 10^77, or around 10^57 times bigger than our current table. It's hard to see how the evolutionary algorithm could cope with that increase in search space.</p>
<p>Another idea would be to incorporate other information into the lookup table key. We could easily imagine, for example, a lookup table where the key includes the number of turns left in the match, or the total number of defections from the opponent. That leads to exactly the same kind of scaling problem, but worse!</p>
<p>Finally, it will be interesting to see how the winning pattern changes as new strategies are added to the Axelrod library. It's quite straightforwards, given enough cores, to re-run the evolutionary algorithm against new strategies, so the pattern for the winning strategy will continue to evolve in more ways than one. </p>
                <hr/>
                <img src="/images/rss.png"/><p>
                Subscribe to articles from the programming category via
                </p><a href="./feeds/programming.rss.xml" type="application/rss+xml" rel="alternate" title="mojones.net programming RSS Feed">RSS</a><p> or
                </p><a href="./feeds/programming.atom.xml" type="application/atom+xml" rel="alternate" title="mojones.net programming ATOM Feed">ATOM</a>
                <hr/>
            </div>
            
</div></body></html>