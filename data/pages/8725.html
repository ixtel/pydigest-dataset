<html><body><div><div class="entry-content">

                

                <p>Python обладает широкими динамическими возможностями. Строгая динамическая неявная типизация позволяет не указывать типы, но при этом не бояться что в коде просуммируем строку и число.
Однако за динамичность приходиться платить - памятью и скоростью.</p>
<p>Но что если хочется максимально уменьшить размер объектов (а в python все объекты) и при этом не потерять в функциональности?
Для примера возьмем плоскость. На плоскости, пускай, надо разместить миллион точек (что не так много).
При этом надо иметь возможность красить точку в разные цвета, расстояния подсчитывать и прочие действия.</p>
<p>Иными словами:</p>
<p>Надо иметь возможность создать миллион пар (x, y) + несколько методов для работы с ними.
И требуется занять минимальное количество памяти.</p>
<p>Можно пойти по процедурному пути, сделать массив, отдельные функции для обработки точек.
Но сделаем все в виде класса.
Методы расписывать не буду, а вот побороться за минимальное потребление памяти стоит.
В простом варианте можно написать код:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Test1</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>

<span class="k">class</span> <span class="nc">Test2</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>


<p>Можно заметить, что код почти одинаковый. Есть только какое-то магическое имя <code>__slots__</code>. Именно оно и позволит уменьшить потребление памяти.
Но перед тем как сказать сколько памяти было сэкономлено, расскажу про <code>__slots__</code></p>
<p><code>__slots__</code> - одно из магических имен в Python. Наличие <code>__slots__</code> ограничивает возможные имена атрибутов объекта теми, которые там указаны. В примере в слотах указаны a и b. Если вызвать переменную "c", то получим исключение. Тем самым можно явно ограничивать расширение функционала объектов в runtime.</p>
<p>Такое явно ограничение количества переменных позволяет экономить память.
Для примера, если создать миллион объектов Test1 и Test2, то во втором случае получим экономию памяти в <code>5 раз</code> (подтверждение этому можно найти по первой ссылке, там рассматривается Python2)</p>
<p>Почему эта экономия существует и почему так, смотри по ссылкам:</p>

            </div>
            
</div></body></html>