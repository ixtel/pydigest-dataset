<html><body><div><div class="post-text" itemprop="text">
<p>Rather than having multiple worker <em>processes</em>, you can use use the <a href="https://code.google.com/p/modwsgi/wiki/ConfigurationDirectives#WSGIDaemonProcess" rel="nofollow"><code>WSGIDaemonProcess</code></a> directive to have multiple worker <em>threads</em> which all run in a single process. That way, all the threads can share the same DB connection mapping.</p>

<p>With something like this in your apache config...</p>

<pre><code># mydomain.com.conf

&lt;VirtualHost *:80&gt;

    ServerName mydomain.com
    ServerAdmin webmaster@mydomain.com

    &lt;Directory /&gt;
        Require all granted
    &lt;/Directory&gt;

    WSGIDaemonProcess myapp processes=1 threads=50 python-path=/path/to/django/root display-name=%{GROUP}
    WSGIProcessGroup myapp
    WSGIScriptAlias / /path/to/django/root/myapp/wsgi.py

&lt;/VirtualHost&gt;
</code></pre>

<p>...you can then use something as simple as this in your Django app...</p>

<pre><code># views.py

import thread
from django.http import HttpResponse

# A global variable to hold the connection mappings
DB_CONNECTIONS = {}

# Fake up this "strangedb" module
class strangedb(object):

    class connection(object):
        def query(self, *args):
            return 'Query results for %r' % args

    @classmethod
    def connect(cls, *args):
        return cls.connection()


# View for homepage
def home(request, username='bob'):

    # Remember thread ID
    thread_info = 'Thread ID = %r' % thread.get_ident()

    # Connect only if we're not already connected
    if username in DB_CONNECTIONS:
        strangedb_connection = DB_CONNECTIONS[username]
        db_info = 'We reused an existing connection for %r' % username
    else:
        strangedb_connection = strangedb.connect(username)
        DB_CONNECTIONS[username] = strangedb_connection
        db_info = 'We made a connection for %r' % username

    # Fake up some query
    results = strangedb_connection.query('SELECT * FROM my_table')

    # Fake up an HTTP response
    text = '%s\n%s\n%s\n' % (thread_info, db_info, results)
    return HttpResponse(text, content_type='text/plain')
</code></pre>

<p>...which, on the first hit, produces...</p>

<pre><code>Thread ID = 140597557241600
We made a connection for 'bob'
Query results for 'SELECT * FROM my_table'
</code></pre>

<p>...and, on the second...</p>

<pre><code>Thread ID = 140597145999104
We reused an existing connection for 'bob'
Query results for 'SELECT * FROM my_table'
</code></pre>

<p>Obviously, you'll need to add something to tear down the DB connections when they're no longer required, but it's tough to know the best way to do that without more info about how your app is supposed to work.</p>

<p><strong>Update #1: Regarding I/O multiplexing vs multithreading</strong></p>

<blockquote>
  <p>I worked with threads twice in my live and each time it was a
  nightmare. A lot of time was wasted on debugging non reproducible
  problems. I think an event-driven and a non-blocking I/O architecture
  might be more solid.</p>
</blockquote>

<p>A solution using I/O multiplexing might be better, but would be more complex, and would also require your "strangedb" library to support it, i.e. it would have to be able to handle <code>EAGAIN</code>/<code>EWOULDBLOCK</code> and have the capacity to retry the system call when necessary.</p>

<p>Multithreading in Python is far less dangerous than in most other languages, due to Python's <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow">GIL</a>, which, in essence, makes all Python bytecode thread-safe. </p>

<p>In practice, threads only run concurrently when the underlying C code uses the <a href="https://docs.python.org/2/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS" rel="nofollow"><code>Py_BEGIN_ALLOW_THREADS</code></a> macro, which, with its counterpart, <code>Py_END_ALLOW_THREADS</code>, are typically wrapped around system calls, and CPU-intensive operations.</p>

<p>The upside of this is that it's almost impossible to have a thread collision in Python code, although the downside is that it won't always make optimal use of multiple CPU cores on a single machine.</p>

<p>The reason I suggest the above solution is that it's relatively simple, and would require minimal code changes, but there may be a better option if you could elaborate more on your "strangedb" library. It seems rather odd to have a DB which requires a separate network connection per concurrent user.</p>

<p><strong>Update #2: Regarding multiprocessing vs multithreading</strong></p>

<blockquote>
  <p>...the GIL limitations around threading seem to be a bit of an issue.
  Isn't this one of the reasons why the trend is to use separate
  processes instead?</p>
</blockquote>

<p>That's quite possibly the main reason why Python's <a href="https://docs.python.org/2/library/multiprocessing.html" rel="nofollow"><code>multiprocessing</code></a> module exists, i.e. to provide concurrent execution of Python bytecode across multiple CPU cores, although there is an <a href="https://bugs.python.org/issue17140" rel="nofollow">undocumented</a> <code>ThreadPool</code> class in that module, which uses threads rather than processes.</p>

<p>The "GIL limitations" would certainly be problematic in cases where you really need to exploit every single CPU cycle on every CPU core, e.g. if you were writing a computer game which had to render 60 frames per second in high-definition.</p>

<p>Most web-based services, however, are likely to spend most of their time waiting for something to happen, e.g. network I/O or disk I/O, which Python threads will allow to occur concurrently.</p>

<p>Ultimately, it's trade-off between performance and maintainability, and given that hardware is usually much cheaper than a developer's time, favoring maintainability over performance is usually more cost-effective.</p>

<p>Frankly, the moment you decide to use a virtual machine language, such as Python, instead of a language which compiles into real machine code, such as C, you're already saying that you're prepared to sacrifice some performance in exchange for convenience.</p>

<p>See also <a href="http://www.kegel.com/c10k.html" rel="nofollow">The C10K problem</a> for a comparison of techniques for scaling web-based services. </p>
    </div>
    </div></body></html>