<html><body><div><p>Timeout control decorator and context managers, raise any exception in another thread</p>








<p>Raise asynchronous exceptions in other threads, control the timeout of
blocks or callables with two context managers and two decorators.</p>
<div id="overview">

<p>This module provides:</p>
<ul>
<li>a function that raises an exception in another thread, including the main
thread.</li>
<li>two context managers that may stop its inner block activity on timeout.</li>
<li>two decorators that may stop its decorated callables on timeout.</li>
</ul>
<p>Developed and tested with CPython 2.6, 2.7, 3.3 and 3.4 on MacOSX. Should work
on any OS (xBSD, Linux, Windows) except when explicitly mentioned.</p>
<div>
<p>Note</p>
<p>Signal based timeout controls, namely <tt>SignalTimeout</tt> context manager and
<tt>signal_timeoutable</tt> decorator won’t work in Windows that has no support
for <tt>signal.SIGALRM</tt>. Any help to work around this is welcome.</p>
</div>
</div>
<div id="public-api">

<div id="exception">

<h3 id="stopit-timeoutexception"><span class="section-subtitle"><tt>stopit.TimeoutException</tt></span></h3>
<p>A <tt>stopit.TimeoutException</tt> may be raised in a timeout context manager
controlled block.</p>
<p>This exception may be propagated in your application at the end of execution
of the context manager controlled block, see the <tt>swallow_ex</tt> parameter of
the context managers.</p>
<p>Note that the <tt>stopit.TimeoutException</tt> is always swallowed after the
execution of functions decorated with <tt><span class="pre">xxx_timeoutable(...)</span></tt>. Anyway, you
may catch this exception <strong>within</strong> the decorated function.</p>
</div>
<div id="threading-based-resources">

<div>
<p>Warning</p>
<p>Threading based resources will only work with CPython implementations
since we use CPython specific low level API. This excludes Iron Python,
Jython, Pypy, …</p>
<p>Will not stop the execution of blocking Python atomic instructions that
acquire the GIL. In example, if the destination thread is actually
executing a <tt>time.sleep(20)</tt>, the asynchronous exception is effective
<strong>after</strong> its execution.</p>
</div>
<div id="stopit-async-raise">

<p>A function that raises an arbitrary exception in another thread</p>
<p><tt>async_raise(tid, exception)</tt></p>
<ul>
<li><tt>tid</tt> is the thread identifier as provided by the <tt>ident</tt> attribute of a
thread object. See the documentation of the <tt>threading</tt> module for further
information.</li>
<li><tt>exception</tt> is the exception class or object to raise in the thread.</li>
</ul>
</div>
<div id="stopit-threadingtimeout">

<p>A context manager that “kills” its inner block execution that exceeds the
provided time.</p>
<p><tt>ThreadingTimeout(seconds, swallow_exc=True)</tt></p>
<ul>
<li><tt>seconds</tt> is the number of seconds allowed to the execution of the context
managed block.</li>
<li><tt>swallow_exc</tt> : if <tt>False</tt>, the possible <tt>stopit.TimeoutException</tt> will
be re-raised when quitting the context managed block. <strong>Attention</strong>: a
<tt>True</tt> value does not swallow other potential exceptions.</li>
</ul>
<p><strong>Methods and attributes</strong></p>
<p>of a <tt>stopit.ThreadingTimeout</tt> context manager.</p>
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr><th>Method / Attribute</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr><td><tt>.cancel()</tt></td>
<td>Cancels the timeout control. This method is intended for use within the
block that’s under timeout control, specifically to cancel the timeout
control. Means that all code executed after this call may be executed
till the end.</td>
</tr>
<tr><td><tt>.state</tt></td>
<td>This attribute indicated the actual status of the timeout control. It
may take the value of the <tt>EXECUTED</tt>, <tt>EXECUTING</tt>, <tt>TIMED_OUT</tt>,
<tt>INTERRUPTED</tt> or <tt>CANCELED</tt> attributes. See below.</td>
</tr>
<tr><td><tt>.EXECUTING</tt></td>
<td>The timeout control is under execution. We are typically executing
within the code under control of the context manager.</td>
</tr>
<tr><td><tt>.EXECUTED</tt></td>
<td>Good news: the code under timeout control completed normally within the
assigned time frame.</td>
</tr>
<tr><td><tt>.TIMED_OUT</tt></td>
<td>Bad news: the code under timeout control has been sleeping too long.
The objects supposed to be created or changed within the timeout
controlled block should be considered as non existing or corrupted.
Don’t play with them otherwise informed.</td>
</tr>
<tr><td><tt>.INTERRUPTED</tt></td>
<td>The code under timeout control may itself raise explicit
<tt>stopit.TimeoutException</tt> for any application logic reason that may
occur. This intentional exit can be spotted from outside the timeout
controlled block with this state value.</td>
</tr>
<tr><td><tt>.CANCELED</tt></td>
<td>The timeout control has been intentionally canceled and the code
running under timeout control did complete normally. But perhaps after
the assigned time frame.</td>
</tr>
</tbody>
</table>
<p>A typical usage:</p>
<pre><span class="kn">import</span> <span class="nn">stopit</span>
<span class="c1"># ...</span>
<span class="k">with</span> <span class="n">stopit</span><span class="o">.</span><span class="n">ThreadingTimeout</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">as</span> <span class="n">to_ctx_mgr</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">to_ctx_mgr</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">to_ctx_mgr</span><span class="o">.</span><span class="n">EXECUTING</span>
    <span class="c1"># Something potentially very long but which</span>
    <span class="c1"># ...</span>

<span class="c1"># OK, let's check what happened</span>
<span class="k">if</span> <span class="n">to_ctx_mrg</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">to_ctx_mrg</span><span class="o">.</span><span class="n">EXECUTED</span><span class="p">:</span>
    <span class="c1"># All's fine, everything was executed within 10 seconds</span>
<span class="k">elif</span> <span class="n">to_ctx_mrg</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">to_ctx_mrg</span><span class="o">.</span><span class="n">EXECUTING</span><span class="p">:</span>
    <span class="c1"># Hmm, that's not possible outside the block</span>
<span class="k">elif</span> <span class="n">to_ctx_mrg</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">to_ctx_mrg</span><span class="o">.</span><span class="n">TIMED_OUT</span><span class="p">:</span>
    <span class="c1"># Eeek the 10 seconds timeout occurred while executing the block</span>
<span class="k">elif</span> <span class="n">to_ctx_mrg</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">to_ctx_mrg</span><span class="o">.</span><span class="n">INTERRUPTED</span><span class="p">:</span>
    <span class="c1"># Oh you raised specifically the TimeoutException in the block</span>
<span class="k">elif</span> <span class="n">to_ctx_mrg</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">to_ctx_mrg</span><span class="o">.</span><span class="n">CANCELED</span><span class="p">:</span>
    <span class="c1"># Oh you called to_ctx_mgr.cancel() method within the block but it</span>
    <span class="c1"># executed till the end</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># That's not possible</span>
</pre>
<p>Notice that the context manager object may be considered as a boolean
indicating (if <tt>True</tt>) that the block executed normally:</p>
<pre><span class="k">if</span> <span class="n">to_ctx_mgr</span><span class="p">:</span>
    <span class="c1"># Yes, the code under timeout control completed</span>
    <span class="c1"># Objects it created or changed may be considered consistent</span>
</pre>
</div>
<div id="stopit-threading-timeoutable">

<p>A decorator that kills the function or method it decorates, if it does not
return within a given time frame.</p>
<p><tt><span class="pre">stopit.threading_timeoutable([default</span> [, <span class="pre">timeout_param]])</span></tt></p>
<ul>
<li><p><tt>default</tt> is the value to be returned by the decorated function or method of
when its execution timed out, to notify the caller code that the function
did not complete within the assigned time frame.</p>
<p>If this parameter is not provided, the decorated function or method will
return a <tt>None</tt> value when its execution times out.</p>
<pre><span class="nd">@stopit.threading_timeoutable</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">'not finished'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">infinite_loop</span><span class="p">():</span>
    <span class="c1"># As its name says...</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">infinite_loop</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="s1">'not finished'</span>
</pre>
</li>
<li><p><tt>timeout_param</tt>: The function or method you have decorated may require a
<tt>timeout</tt> named parameter for whatever reason. This empowers you to change
the name of the <tt>timeout</tt> parameter in the decorated function signature to
whatever suits, and prevent a potential naming conflict.</p>
<pre><span class="nd">@stopit.threading_timeoutable</span><span class="p">(</span><span class="n">timeout_param</span><span class="o">=</span><span class="s1">'my_timeout'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">some_slow_function</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="s1">'whatever'</span><span class="p">):</span>
    <span class="c1"># As its name says...</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">some_slow_function</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="s2">"something"</span><span class="p">,</span> <span class="n">my_timeout</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre>
</li>
</ul>
</div>
<div id="about-the-decorated-function">

<p>or method…</p>
<p>As you noticed above, you just need to add the <tt>timeout</tt> parameter when
calling the function or method. Or whatever other name for this you chose with
the <tt>timeout_param</tt> of the decorator. When calling the real inner function
or method, this parameter is removed.</p>
</div>
</div>

<div id="logging">

<p>The <tt>stopit</tt> named logger emits a warning each time a block of code
execution exceeds the associated timeout. To turn logging off, just:</p>
<pre><span class="kn">import</span> <span class="nn">logging</span>
<span class="n">stopit_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">'stopit'</span><span class="p">)</span>
<span class="n">stopit_logger</span><span class="o">.</span><span class="n">seLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>
</pre>
</div>
<div id="comparing-thread-based-and-signal-based-timeout-control">
<span id="comparison-chart"/>
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr><th>Feature</th>
<th>Threading based resources</th>
<th>Signaling based resources</th>
</tr>
</thead>
<tbody>
<tr><td>GIL</td>
<td>Can’t interrupt a long Python atomic instruction. e.g. if
<tt>time.sleep(20.0)</tt> is actually executing, the timeout will take
effect at the end of the execution of this line.</td>
<td>Don’t care of it</td>
</tr>
<tr><td>Thread safety</td>
<td><strong>Yes</strong> : Thread safe as long as each thread uses its own <tt>ThreadingTimeout</tt>
context manager or <tt>threading_timeoutable</tt> decorator.</td>
<td><strong>Not</strong> thread safe. Could yield unpredictable results in a
multithreads application.</td>
</tr>
<tr><td>Nestable context managers</td>
<td><strong>Yes</strong> : you can nest threading based context managers</td>
<td><strong>No</strong> : never nest a signaling based context manager in another one.
The innermost context manager will automatically cancel the timeout
control of outer ones.</td>
</tr>
<tr><td>Accuracy</td>
<td>Any positive floating value is accepted as timeout value. The accuracy
depends on the GIL interval checking of your platform. See the doc on
<tt>sys.getcheckinterval</tt> and <tt>sys.setcheckinterval</tt> for your Python
version.</td>
<td>Due to the use of <tt>signal.SIGALRM</tt>, we need provide an integer number
of seconds. So a timeout of <tt>0.6</tt> seconds will ve automatically
converted into a timeout of zero second!</td>
</tr>
<tr><td>Supported platforms</td>
<td>Any CPython 2.6, 2.7 or 3.3 on any OS with threading support.</td>
<td>Any Python 2.6, 2.7 or 3.3 with <tt>signal.SIGALRM</tt> support. This
excludes Windows boxes</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="issue-about-timeout-accuracy">

<p><strong>Important</strong>: the way CPython supports threading and asynchronous features has
impacts on the accuracy of the timeout. In other words, if you assign a 2.0
seconds timeout to a context managed block or a decorated callable, the
effective code block / callable execution interruption may occur some
fractions of seconds after this assigned timeout.</p>
<p>For more background about this issue - that cannot be fixed - please read
Python gurus thoughts about Python threading, the GIL and context switching
like these ones:</p>

<p>This is the reason why I am more “tolerant” on timeout accuracy in the tests
you can read thereafter than I should be for a critical real-time application
(that’s not in the scope of Python).</p>
<p>It is anyway possible to improve this accuracy at the expense of the global
performances decreasing the check interval which defaults to 100. See:</p>

<p>If this is a real issue for users (want a precise timeout and not an
approximative one), a future release will add the optional <tt>check_interval</tt>
parameter to the context managers and decorators. This parameter will enable
to lower temporarily the threads switching check interval, having a more
accurate timeout at the expense of the overall performances while the context
managed block or decorated functions are executing.</p>
</div>
<div id="tests-and-demos">

<pre><span class="kn"/><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">threading</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">stopit</span> <span class="kn">import</span> <span class="n">async_raise</span><span class="p">,</span> <span class="n">TimeoutException</span>
</pre>
<p>In a real application, you should either use threading based timeout resources:</p>
<pre><span class="kn"/><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">stopit</span> <span class="kn">import</span> <span class="n">ThreadingTimeout</span> <span class="k">as</span> <span class="n">Timeout</span><span class="p">,</span> <span class="n">threading_timeoutable</span> <span class="k">as</span> <span class="n">timeoutable</span>  <span class="c1">#doctest: +SKIP</span>
</pre>
<p>Or the POSIX signal based resources:</p>
<pre><span class="kn"/><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">stopit</span> <span class="kn">import</span> <span class="n">SignalingTimeout</span> <span class="k">as</span> <span class="n">Timeout</span><span class="p">,</span> <span class="n">signaling_timeoutable</span> <span class="k">as</span> <span class="n">timeoutable</span>  <span class="c1">#doctest: +SKIP</span>
</pre>
<p>Let’s define some utilities:</p>
<pre><span class="kn"/><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fast_func</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">variable_duration_func</span><span class="p">(</span><span class="n">duration</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">dummy</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span> <span class="o">&gt;</span> <span class="n">duration</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">break</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exc_traces</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">variable_duration_func_handling_exc</span><span class="p">(</span><span class="n">duration</span><span class="p">,</span> <span class="n">exc_traces</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="gp">... </span>        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">dummy</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span> <span class="o">&gt;</span> <span class="n">duration</span><span class="p">:</span>
<span class="gp">... </span>                <span class="k">break</span>
<span class="gp">... </span>    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">exc_traces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func_with_exception</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">()</span>
</pre>
<div id="async-raise-function-raises-an-exception-in-another-thread">

<p>Testing <tt>async_raise()</tt> with a thread of 5 seconds:</p>
<pre><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">five_seconds_threads</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">target</span><span class="o">=</span><span class="n">variable_duration_func_handling_exc</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">exc_traces</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">five_seconds_threads</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thread_ident</span> <span class="o">=</span> <span class="n">five_seconds_threads</span><span class="o">.</span><span class="n">ident</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">five_seconds_threads</span><span class="o">.</span><span class="n">is_alive</span><span class="p">()</span>
<span class="go">True</span>
</pre>
<p>We raise a LookupError in that thread:</p>
<pre><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">async_raise</span><span class="p">(</span><span class="n">thread_ident</span><span class="p">,</span> <span class="ne">LookupError</span><span class="p">)</span>
</pre>
<p>Okay but we must wait few milliseconds the thread death since the exception is
asynchronous:</p>
<pre><span class="k"/><span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="n">five_seconds_threads</span><span class="o">.</span><span class="n">is_alive</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">pass</span>
</pre>
<p>And we can notice that we stopped the thread before it stopped by itself:</p>
<pre><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="o">&lt;</span> <span class="mf">0.5</span>
<span class="go">True
</span><span class="nb"/><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">exc_traces</span><span class="p">)</span>
<span class="go">1
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">exc_traces</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
<span class="go">'LookupError'</span>
</pre>
</div>
<div id="timeout-context-manager">

<p>The context manager stops the execution of its inner block after a given time.
You may manage the way the timeout occurs using a <tt>try: ... except: ...</tt>
construct or by inspecting the context manager <tt>state</tt> attribute after the
block.</p>
<div id="swallowing-timeout-exceptions">

<p>We check that the fast functions return as outside our context manager:</p>
<pre><span class="k"/><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Timeout</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span> <span class="k">as</span> <span class="n">timeout_ctx</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">fast_func</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>
<span class="go">0
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">timeout_ctx</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">timeout_ctx</span><span class="o">.</span><span class="n">EXECUTED</span>
<span class="go">True</span>
</pre>
<p>And the context manager is considered as <tt>True</tt> (the block executed its last
line):</p>
<pre><span class="nb"/><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">timeout_ctx</span><span class="p">)</span>
<span class="go">True</span>
</pre>
<p>We check that slow functions are interrupted:</p>
<pre><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Timeout</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="k">as</span> <span class="n">timeout_ctx</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">variable_duration_func</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="o">&lt;</span> <span class="mf">2.2</span>
<span class="go">True
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">timeout_ctx</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">timeout_ctx</span><span class="o">.</span><span class="n">TIMED_OUT</span>
<span class="go">True</span>
</pre>
<p>And the context manager is considered as <tt>False</tt> since the block did timeout.</p>
<pre><span class="nb"/><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">timeout_ctx</span><span class="p">)</span>
<span class="go">False</span>
</pre>
<p>Other exceptions are propagated and must be treated as usual:</p>
<pre><span class="k"/><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">with</span> <span class="n">Timeout</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span> <span class="k">as</span> <span class="n">timeout_ctx</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">result</span> <span class="o">=</span> <span class="n">func_with_exception</span><span class="p">()</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">LookupError</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="s1">'exception_seen'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeout_ctx</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">timeout_ctx</span><span class="o">.</span><span class="n">EXECUTING</span>
<span class="go">True
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>
<span class="go">'exception_seen'</span>
</pre>
</div>
<div id="propagating-timeoutexception">

<p>We can choose to propagate the <tt>TimeoutException</tt> too. Potential exceptions
have to be handled:</p>
<pre><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">with</span> <span class="n">Timeout</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">swallow_exc</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">timeout_ctx</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">variable_duration_func</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="n">TimeoutException</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="s1">'exception_seen'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="o">&lt;</span> <span class="mf">2.2</span>
<span class="go">True
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>
<span class="go">'exception_seen'
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">timeout_ctx</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">timeout_ctx</span><span class="o">.</span><span class="n">TIMED_OUT</span>
<span class="go">True</span>
</pre>
<p>Other exceptions must be handled too:</p>
<pre><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">with</span> <span class="n">Timeout</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">swallow_exc</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">timeout_ctx</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">func_with_exception</span><span class="p">()</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="s1">'exception_seen'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="o">&lt;</span> <span class="mf">0.1</span>
<span class="go">True
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>
<span class="go">'exception_seen'
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">timeout_ctx</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">timeout_ctx</span><span class="o">.</span><span class="n">EXECUTING</span>
<span class="go">True</span>
</pre>
</div>
</div>
<div id="timeoutable-callable-decorator">

<p>This decorator stops the execution of any callable that should not last a
certain amount of time.</p>
<p>You may use a decorated callable without timeout control if you don’t provide
the <tt>timeout</tt> optional argument:</p>
<pre><span class="nd"/><span class="gp">&gt;&gt;&gt; </span><span class="nd">@timeoutable</span><span class="p">()</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">fast_double</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">value</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fast_double</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">6</span>
</pre>
<p>You may specify that timeout with the <tt>timeout</tt> optional argument.
Interrupted callables return None:</p>
<pre><span class="nd"/><span class="gp">&gt;&gt;&gt; </span><span class="nd">@timeoutable</span><span class="p">()</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">infinite</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="s1">'whatever'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">infinite</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre>
<p>Or any other value provided to the <tt>timeoutable</tt> decorator parameter:</p>
<pre><span class="nd"/><span class="gp">&gt;&gt;&gt; </span><span class="nd">@timeoutable</span><span class="p">(</span><span class="s1">'unexpected'</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">infinite</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="s1">'whatever'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">infinite</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">'unexpected'</span>
</pre>
<p>If the <tt>timeout</tt> parameter name may clash with your callable signature, you
may change it using <tt>timeout_param</tt>:</p>
<pre><span class="nd"/><span class="gp">&gt;&gt;&gt; </span><span class="nd">@timeoutable</span><span class="p">(</span><span class="s1">'unexpected'</span><span class="p">,</span> <span class="n">timeout_param</span><span class="o">=</span><span class="s1">'my_timeout'</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">infinite</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="s1">'whatever'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">infinite</span><span class="p">(</span><span class="n">my_timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">'unexpected'</span>
</pre>
<p>It works on instance methods too:</p>
<pre><span class="k"/><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Anything</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@timeoutable</span><span class="p">(</span><span class="s1">'unexpected'</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">infinite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span>
<span class="gp">... </span>        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">Anything</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">infinite</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">'unexpected'</span>
</pre>
</div>
</div>
</div></body></html>