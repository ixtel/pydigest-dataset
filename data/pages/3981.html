<html><body><div><div>
<p>
Говоря о метапрограммировании в python чаще всего подразумевают использование декораторов или метаклассов, иногда сюда приплетают импорт хуки и даже генерацию питоновского кода с последующим execом его в целевом неймспейсе (классе, например). Все это - вполне себе production ready приемы, так, например, реализацию питоновских ORM движков сложно себе представить без метаклассов и дескрипторов. Такие библиотеки как pytest вообще невозбранно хачат весь ваш код, что особенно радует разработчиков плагинов, когда дело доходит до дебага.</p>
<p>
<br/></p>
<p>
<br/></p>
<h2>
Собирай это!</h2>
<p>
Давайте спустимся с небес на землю. Скажите, знаете ли вы, что делает компилятор, когда видит class statement? Для простоты дизассемблируем объявление пустого класса:</p>
<div>
<pre><span>&gt;</span><span>&gt;</span><span>&gt;</span> <span>import</span> dis
<span>.</span><span>.</span><span>.</span> dis<span>.</span>dis<span>(</span><span>'class MyClass: pass'</span><span>)</span>
  <span>1</span>           <span>0</span> LOAD_BUILD_CLASS
              <span>1</span> LOAD_CONST               <span>0</span> <span>(</span><span>&lt;</span>code object MyClass at <span>.</span><span>.</span><span>.</span><span>&gt;</span><span>)</span>
              <span>4</span> LOAD_CONST               <span>1</span> <span>(</span><span>'MyClass'</span><span>)</span>
              <span>7</span> MAKE_FUNCTION            <span>0</span>
             <span>10</span> LOAD_CONST               <span>1</span> <span>(</span><span>'MyClass'</span><span>)</span>
             <span>13</span> CALL_FUNCTION            <span>2</span> <span>(</span><span>2</span> positional<span>,</span> <span>0</span> keyword pair<span>)</span>
             <span>16</span> STORE_NAME               <span>0</span> <span>(</span>MyClass<span>)</span>
             <span>19</span> LOAD_CONST               <span>2</span> <span>(</span><span>None</span><span>)</span>
             <span>22</span> RETURN_VALUE</pre>
</div>
<p>
Первым выполняется некий не имеющий аргументов опкод LOAD_BUILD_CLASS. Затем создается функция с именем MyClass и кодом <span>&lt;</span>code object MyClass at ...<span>&gt;</span>. Дальше небольшая тонкость: опкод со сдвигом тринадцать (вызов функции) не может быть связан с функцией MyClass, ведь ей доступен только один аргумент – строчка 'MyClass', в то время как дизассемблер утверждает, что вызов произойдет с двумя аргументами. Так что единственный вариант, который мы можем предположить – это то, что LOAD_BUILD_CLASS грузит на стек некую специальную функцию, которая принимает в качестве первого аргумента функцию, идейно эквивалентную телу класса и строку – название класса (и, возможно, что то еще). Результат вызова этой функции и есть готовый класс, который мы заботливо кладем в переменную MyClass (опкод со сдвигом 16). Все здорово, но что это за таинственная функция, создающая классы? Это не может быть type, не та сигнатура.<br/>
Разрешить эту загадку в общем-то довольно легко, достаточно заглянуть в исходники интерпретатора. В файле Python/ceval.c лежит функция PyEval_EvalFrameEx – сердце рантайма питона. Именно тут происходит выполнение тех инструкций, которые сгенерились из вашего питоновского кода в процессе компиляции. Я немного подкоротил код обработчика LOAD_BUILD_CLASS, он выглядит так:<br/>
TARGET<span>(</span>LOAD_BUILD_CLASS<span>)</span> <span>{</span></p>
<div>
<pre>    PyObject <span>*</span>bc<span>;</span>
    bc <span>=</span> _PyDict_GetItemId<span>(</span>f<span>-</span><span>&gt;</span>f_builtins<span>,</span> <span>&amp;</span>PyId___build_class__<span>)</span><span>;</span>
    PUSH<span>(</span>bc<span>)</span><span>;</span>
    DISPATCH<span>(</span><span>)</span><span>;</span>
<span>}</span></pre>
</div>
<p>
Или, говоря по-русски – возьми из builtins функцию __build_class__ и положи на value stack. Скажите честно, кто из вас знал о том, что в билтинах есть такая функция? Я так и думал :-)</p>
<p>
Ок, теперь зная куда копать, мы можем вдоволь повеселиться. Давайте ее немного перегрузим, ну например так</p>
<div>
<pre><span>&gt;</span><span>&gt;</span><span>&gt;</span> __builtins__<span>[</span><span>'__build_class__'</span><span>]</span> <span>=</span> <span>lambda</span> <span>*</span>a<span>,</span> <span>*</span><span>*</span>kwa<span>:</span> <span>print</span><span>(</span>a<span>,</span> kwa<span>)</span>
<span>.</span><span>.</span><span>.</span> <span>class</span> MyClass<span>(</span><span>int</span><span>,</span> <span>str</span><span>,</span> metaclass<span>=</span><span>type</span><span>,</span> foo<span>=</span><span>'bar'</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>         <span>pass</span>
<span>(</span><span>&lt;</span>function MyClass at <span>.</span><span>.</span><span>.</span><span>&gt;</span><span>,</span> <span>'MyClass'</span><span>,</span> <span>&lt;</span><span>class</span> <span>'int'</span><span>&gt;</span><span>,</span> <span>&lt;</span><span>class</span> <span>'str'</span><span>&gt;</span><span>)</span>
<span>{</span><span>'metaclass'</span><span>:</span> <span>&lt;</span><span>class</span> <span>'type'</span><span>&gt;</span><span>,</span> <span>'foo'</span><span>:</span> <span>'bar'</span><span>}</span></pre>
</div>
<p>
Таким образом справедлива такая распаковка:</p>
<p>
func_object, class_name, *bases = args    (1)</p>
<p>
class_kwargs = kwargs                     (2)</p>
<p>
где class_kwargs – это все именованные аргументы в объявлении класса, значит даже metaclass – не более чем очередной kwarg и мы вправе обработать его как нам угодно.<br/>
<br/>
<h2>
Use cases.</h2>
</p>
<div><p>
Для дальнейших манипуляций нам понадобится простенькая инфраструктура, я подготовил такую </p><a href="https://github.com/magniff/magic" target="_blank">тут</a><p>. В простейшем виде наш тестовый cтенд будет выглядеть так:</p></div>
<div>
<pre><span>def</span> callback<span>(</span>builder<span>,</span> <span>*</span>args<span>,</span> <span>*</span><span>*</span>kwargs<span>)</span><span>:</span>
    <span>return</span> builder<span>(</span><span>*</span>args<span>,</span> <span>*</span><span>*</span>kwargs<span>)</span>

with wonderland<span>(</span>callback<span>)</span><span>:</span>
    <span>class</span> MyClass<span>:</span>
        <span>pass</span></pre>
</div>
<p>
Внутри блока with будем объявлять классы, задача по их сборке будет делегирована функции callback, возвращать она должна уже готовый класс. Аргумент builder – это оригинальный __build_class__, *args и **kwargs – это все, что этому билдеру было бы передано в ванильном случае, так что builder(*args, **kwargs) – это и есть класс, собранный обычным образом.</p>
<div><p>
Перед нами открылся невиданный простор для экспериментов. Давайте, например, посмотрим на func_object из (1).Функция эта сама по себе никому не нужна, она лишь служит оберткой для кода. Что за код такой? Заведем callback:</p>
<pre><span>def</span> callback<span>(</span>builder<span>,</span> <span>*</span>args<span>,</span> <span>*</span><span>*</span>kwargs<span>)</span><span>:</span>
    func<span>,</span> <span>*</span>_ <span>=</span> args
    <span>print</span><span>(</span>func<span>.</span>__code__<span>.</span>co_consts<span>)</span>
    <span>return</span> builder<span>(</span><span>*</span>args<span>,</span> <span>*</span><span>*</span>kwargs<span>)</span></pre>
</div>
<p>
Добавьте в MyClass пару методов и запустите. Оказывается, что методы, объявленные в классе, попадают в func.__code__.co_consts, причем сами они хранятся там в виде соответсвующих объектов кода. К нашему сожалению CodeType иммутабелен, так что кастомизировать класс путем изменения его кода мы не можем (ну ладно, можем, но это совсем неудобно). Максимум что можно сделать на этом этапе – это изменить список его базовых классов, имя, полностью пересадить у func ее код, воспользовавшись конструктором из types, либо навесить на класс декоратор. Также можно играться с уже готовым классом, просто сохранив выхлоп builder(*args, **kwargs) в локальную переменную.<br/>
Следующий шаг, сильно упрощающий нам жизнь – это прописывание классу нашего кастомного метакласса, мы ведь помним, что именованный аргумент metaclass ничем не выделяется из собратьев. Сделать это очень просто:</p>
<div>
<pre><span>class</span> MyMeta<span>(</span><span>type</span><span>)</span><span>:</span>
    <span>def</span> __new__<span>(</span>cls<span>,</span> name<span>,</span> bases<span>,</span> attrs<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'hello from metaclass %s'</span> <span>%</span> cls<span>.</span><span>__name__</span><span>)</span>
        <span>return</span> <span>super</span><span>(</span><span>)</span><span>.</span>__new__<span>(</span>cls<span>,</span> name<span>,</span> bases<span>,</span> attrs<span>)</span>

<span>def</span> callback<span>(</span>builder<span>,</span> <span>*</span>args<span>,</span> <span>*</span><span>*</span>kwargs<span>)</span><span>:</span>
    kwargs<span>[</span><span>'metaclass'</span><span>]</span> <span>=</span> MyMeta
    <span>return</span> builder<span>(</span><span>*</span>args<span>,</span> <span>*</span><span>*</span>kwargs<span>)</span></pre>
</div>
<p>
Вот, это уже действительно что то. Думаю объяснять, что может нам дать свой, написанный с определенной целью, метакласс не нужно (или нужно? марш к Бизли!).</p>
<p>
<b>Тут есть как минимум две проблемы:</b></p>
<p>
1. пусть в kwargs был-таки непустой метакласс, если просто заменить его своим метаклассом то мы сломаем логику приложения, так что придется динамически строить третий метакласс, сочетающий возможности обоих.</p>
<p>
2. пусть kwargs даже пуст, метакласс отличный от type может быть у одного из родителей класса, что приведет к metaclass conflict. Это тоже лечится, но как-то фу.</p>
<p>
Это грустно и я ничего хорошего посоветовать не могу. Механизм, который смог бы рулить всем этим добром в общем виде представляется мне довольно сложным.</p>
<p>
К чему я это все? А к тому, что это еще один подход к метапрограммированию на питоне, ориентированный на классы. Его огромный плюс – код находящийся в блоке with не знает о том, что с ним будут что-то делать, значит это может быть чей-то чужой код. Ну и понятно, что внутри with классы можно просто импортировать из внешнего модуля, так что инструментировать код того же Django или другой большой библиотеки можно не поменяв в ней ни строчки кода.</p>
<p>
Надеюсь, что это было кому-то интересно, теперь можете смело выпендриваться перед коллегами. Спасибо за ваше время.</p>
</div>
</div></body></html>