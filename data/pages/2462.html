<html><body><div><article id="76OF7uZ3BqpJPMdgYlDA" class="post  historical">
	<time datetime="2014-12-18" class="article_time">December 18, 2014</time>
  
	<p>This post discusses Python’s <a href="https://docs.python.org/3.4/library/constants.html#NotImplemented" rel="nofollow"><code class="prettyprint">NotImplemented</code></a> built-in constant/type; what it is, what it means and when it should be used.</p>
<h1 id="what-is-it_1">
<a class="head_anchor" href="#what-is-it_1" rel="nofollow"> </a>What is it?</h1>
<pre><code class="prettyprint">&gt;&gt;&gt; type(NotImplemented)
&lt;type 'NotImplementedType'&gt;
</code></pre>

<p><a href="https://docs.python.org/3.4/library/constants.html#NotImplemented" rel="nofollow"><code class="prettyprint">NotImplemented</code></a> is one of Python’s six constants living in the built-in namespace. The others are <a href="https://docs.python.org/3.4/library/constants.html#False" rel="nofollow"><code class="prettyprint">False</code></a>, <a href="https://docs.python.org/3.4/library/constants.html#True)" rel="nofollow"><code class="prettyprint">True</code></a>, <a href="https://docs.python.org/3.4/library/constants.html#False)" rel="nofollow"><code class="prettyprint">None</code></a>, [<code class="prettyprint">Ellipsis</code>][ellipsis-doc] and <a href="https://docs.python.org/3.4/library/constants.html#__debug__." rel="nofollow"><code class="prettyprint">__debug__</code></a>. Similar to [<code class="prettyprint">Ellipsis</code>][ellipsis-doc], <a href="https://docs.python.org/3.4/library/constants.html#NotImplemented" rel="nofollow"><code class="prettyprint">NotImplemented</code></a> can be reassigned (shadowed). Assignments to it, even as an attribute name, do <strong>not</strong> raise a <code class="prettyprint">SyntaxError</code>. So it isn’t really a “real/true” constant. <strong>Of course, we should never ever change it.</strong> But, for completeness:</p>

<pre><code class="prettyprint">&gt;&gt;&gt; None = 'hello'
...
SyntaxError: can't assign to keyword
&gt;&gt;&gt; NotImplemented
NotImplemented
&gt;&gt;&gt; NotImplemented = 'do not'
&gt;&gt;&gt; NotImplemented
'do not'
</code></pre>
<h1 id="what-does-it-mean-and-when-should-it-be-used_1">
<a class="head_anchor" href="#what-does-it-mean-and-when-should-it-be-used_1" rel="nofollow"> </a>What does it mean and when should it be used?</h1>
<p><a href="https://docs.python.org/3.4/library/constants.html#NotImplemented" rel="nofollow"><code class="prettyprint">NotImplemented</code></a> is a special value which should be returned by the binary special methods (e.g. <a href="https://docs.python.org/3.4/reference/datamodel.html#object.__eq__" rel="nofollow"><code class="prettyprint">__eq__()</code></a>, <a href="https://docs.python.org/3.4/reference/datamodel.html#object.__lt__" rel="nofollow"><code class="prettyprint">__lt__()</code></a>, <a href="https://docs.python.org/3.4/reference/datamodel.html#object.__add__" rel="nofollow"><code class="prettyprint">__add__()</code></a>, <a href="https://docs.python.org/3.4/reference/datamodel.html#object.__rsub__" rel="nofollow"><code class="prettyprint">__rsub__()</code></a>, etc.) to indicate that the operation is not implemented with respect to the other type; it may be returned by the in-place binary special methods (e.g. <a href="https://docs.python.org/3.4/reference/datamodel.html#object.__imul__" rel="nofollow"><code class="prettyprint">__imul__()</code></a>, <a href="https://docs.python.org/3.4/reference/datamodel.html#object.__iand__" rel="nofollow"><code class="prettyprint">__iand__()</code></a>, etc.) for the same purpose. Also, its truth value is <code class="prettyprint">True</code>:</p>

<pre><code class="prettyprint">&gt;&gt;&gt; bool(NotImplemented)
True
</code></pre>

<p>You might be asking yourself, "But I thought I should raise a <a href="https://docs.python.org/3.4/library/exceptions.html#NotImplementedError" rel="nofollow"><code class="prettyprint">NotImpementedError</code></a> when an operation is not implemented!”. We’ll see with some examples why that shouldn’t be the case when implementing binary special methods.</p>

<p>Let’s show the use of the <a href="https://docs.python.org/3.4/library/constants.html#NotImplemented" rel="nofollow"><code class="prettyprint">NotImplemented</code></a> constant by coding <a href="https://docs.python.org/3.4/reference/datamodel.html#object.__eq__" rel="nofollow"><code class="prettyprint">__eq__()</code></a> for two very basic (and useless) classes <code class="prettyprint">A</code> and <code class="prettyprint">B</code>. [For this simple example, <a href="https://docs.python.org/3.4/reference/datamodel.html#object.__ne__" rel="nofollow"><code class="prettyprint">__ne__()</code></a> won’t be implemented to avoid distraction, but in general, every time <a href="https://docs.python.org/3.4/reference/datamodel.html#object.__eq__" rel="nofollow"><code class="prettyprint">__eq__()</code></a> is implemented, <a href="https://docs.python.org/3.4/reference/datamodel.html#object.__ne__" rel="nofollow"><code class="prettyprint">__ne__()</code></a> should also be implemented unless there is a good reason for it not to be.]</p>

<pre><code class="prettyprint"># example.py

class A(object):
    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        if isinstance(other, A):
            print('Comparing an A with an A')
            return other.value == self.value
        if isinstance(other, B):
            print('Comparing an A with a B')
            return other.value == self.value
        print('Could not compare A with the other class')
        return NotImplemented

class B(object):
    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        if isinstance(other, B):
            print('Comparing a B with another B')
            return other.value == self.value
        print('Could not compare B with the other class')
        return NotImplemented
</code></pre>

<p>Now, in the interpreter:</p>

<pre><code class="prettyprint">&gt;&gt;&gt; from example import A, B
&gt;&gt;&gt; a1 = A(1)
&gt;&gt;&gt; b1 = B(1)
</code></pre>

<p>We can now experiment with different calls to <code class="prettyprint">__eq__()</code> and see what happens. As a reminder, in Python, <code class="prettyprint">a == b</code> results in <code class="prettyprint">a.__eq__(b)</code> being called:</p>

<pre><code class="prettyprint">&gt;&gt;&gt; a1 == a1
Comparing an A with an A
True
</code></pre>

<p>As expected, <code class="prettyprint">a1</code> is equal to <code class="prettyprint">a1</code> (itself) and the <code class="prettyprint">__eq__()</code> in class <code class="prettyprint">A</code> took care of this comparison. Comparing <code class="prettyprint">b1</code> with itself will also yield a similar result:</p>

<pre><code class="prettyprint">&gt;&gt;&gt; b1 == b1
Comparing a B with another B
True
</code></pre>

<p>What if we now compare <code class="prettyprint">a1</code> with <code class="prettyprint">b1</code>? Since in <code class="prettyprint">A</code>’s <code class="prettyprint">__eq__()</code> will check for <code class="prettyprint">other</code> being an instance of <code class="prettyprint">B</code>, we expect <code class="prettyprint">a1.__eq__(b1)</code> to deal with the comparison and return <code class="prettyprint">True</code>:</p>

<pre><code class="prettyprint">&gt;&gt;&gt; a1 == b1
Comparing an A with a B
True
</code></pre>

<p>And that is the case. Now, if we compare <code class="prettyprint">b1</code> with <code class="prettyprint">a1</code> (i.e. invoke <code class="prettyprint">b1.__eq__(a1)</code>), we would expect <a href="https://docs.python.org/3.4/library/constants.html#NotImplemented" rel="nofollow"><code class="prettyprint">NotImplemented</code></a> to be returned. This is because <code class="prettyprint">B</code>’s <code class="prettyprint">__eq__()</code> only compares against other <code class="prettyprint">B</code> instances. Let’s see what happens:</p>

<pre><code class="prettyprint">&gt;&gt;&gt; b1 == a1
Could not compare B against the other class
Comparing an A with a B
True
</code></pre>

<p>Clever! <code class="prettyprint">b1.__eq__(a1)</code> method returning <a href="https://docs.python.org/3.4/library/constants.html#NotImplemented" rel="nofollow"><code class="prettyprint">NotImplemented</code></a> caused <code class="prettyprint">A</code>’s <code class="prettyprint">__eq__()</code> method to be called and since a comparison between <code class="prettyprint">A</code> and <code class="prettyprint">B</code> was defined in <code class="prettyprint">A</code>’s <code class="prettyprint">__eq__()</code> then we got the correct result (<code class="prettyprint">True</code>).</p>

<p>And that is what returning <a href="https://docs.python.org/3.4/library/constants.html#NotImplemented" rel="nofollow"><code class="prettyprint">NotImplemented</code></a> does. <a href="https://docs.python.org/3.4/library/constants.html#NotImplemented" rel="nofollow"><code class="prettyprint">NotImplemented</code></a> tells the runtime that it should ask someone else to satisfy the operation. In the expression <code class="prettyprint">b1 == a1</code>, <code class="prettyprint">b1.__eq__(a1)</code> returns <a href="https://docs.python.org/3.4/library/constants.html#NotImplemented" rel="nofollow"><code class="prettyprint">NotImplemented</code></a> which tells Python to try <code class="prettyprint">a1.__eq__(b1)</code>. Since <code class="prettyprint">a1</code> knows enough to return <code class="prettyprint">True</code>, then the expression can succeed. If <code class="prettyprint">A</code>’s <code class="prettyprint">__eq__()</code> also returned <a href="https://docs.python.org/3.4/library/constants.html#NotImplemented" rel="nofollow"><code class="prettyprint">NotImplemented</code></a>, then the runtime would fall back to the built-in behaviour for equality which is based on object identity (which in CPython, is the object’s address in memory).</p>

<p>Note that raising a <a href="https://docs.python.org/3.4/library/exceptions.html#NotImplementedError" rel="nofollow"><code class="prettyprint">NotImpementedError</code></a> when <code class="prettyprint">b1.__eq__(a1)</code> fails would break out of the code unless caught, whereas <a href="https://docs.python.org/3.4/library/constants.html#NotImplemented" rel="nofollow"><code class="prettyprint">NotImplemented</code></a> doesn’t get raised and can result in/be used for further tests.</p>

<hr/>

<p>Discussion on <a href="https://news.ycombinator.com/item?id=8770736" rel="nofollow">hackernews</a> and <a href="http://www.reddit.com/r/Python/comments/2pqrxf/pythons_notimplemented_type/" rel="nofollow">reddit</a>.</p>

  <figure class="postend kudo able clearfix" id="kudo_76OF7uZ3BqpJPMdgYlDA">
    <a href="#kudo">
      <p class="filling"> </p>
    </a>
    <p class="num">258</p>
    <p class="txt">Kudos</p>
  </figure>
  <figure class="side kudo able clearfix" id="kudo_side_76OF7uZ3BqpJPMdgYlDA">
    <a href="#kudo">
      <p class="filling"> </p>
    </a>
    <p class="num">258</p>
    <p class="txt">Kudos</p>
  </figure>
</article>

  </div></body></html>