<html><body><div><div class="entry-content">
<p>A common experience when writing database backed web applications (which I hear is a thing some people like to do) is that rather than laboriously setting up each example in each test you use a set of fixtures – standard project definitions, standard users, etc.</p>
<p>Typically these start off small but grow increasingly unwieldy over time, as new tests occasionally require some additional detail and it’s easier to add little things to an existing fixture than it is to create one afresh.</p>
<p>And then what happens is that it becomes increasingly unclear which bits of those fixtures actually matter and which of them are just there because some other test happened to need them.</p>
<p>You can use tools like <a href="https://pypi.python.org/pypi/factory_boy/">factory_boy</a> to make this easier, but ultimately it’s still just making the above process easier – you still have the same problems, but it’s less work to get there.</p>
<p>What if instead of having these complicated fixtures your tests could just ask for what they want and be given it?</p>
<p>As well as its use in testing, <a href="http://hypothesis.readthedocs.org/en/stable/">Hypothesis</a> has the ability to <a href="http://hypothesis.readthedocs.org/en/stable/details.html#using-hypothesis-to-find-values">find values satisfying some predicate</a>. And this can be used to create fixtures that are constraint based instead of example based. That is: You don’t ask for the foo_project fixture, you instead say “I want a project whose owner is on the free plan”, and Hypothesis gives it to you:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>from</span> hypothesis <span>import</span> find
<span>from</span> hypothesis.<span>extra</span>.<span>django</span>.<span>models</span> <span>import</span> models
<span>from</span> mymodels <span>import</span> Project<span>,</span> User
 
<span>def</span> test_add_users_to_free_project<span>(</span><span>)</span>:
    project <span>=</span> find<span>(</span>
        models<span>(</span>Project<span>,</span> owner<span>=</span>models<span>(</span>User<span>)</span><span>)</span><span>,</span>
        <span>lambda</span> x: x.<span>owner</span>.<span>plan</span> <span>==</span> <span>"free"</span><span>)</span>
    do_some_stuff_with<span>(</span>project<span>)</span></pre></td></tr></table></div>
<p>And that’s basically it. You write fixture based tests as you normally would, only you can be as explicit as you like as to what features you want from the fixtures rather than just using what happens to be around.</p>
<p>It’s unclear to me whether this is ever an improvement on using Hypothesis as it is intended to be used – I feel like it might work better in cases where the assumptions are relatively hard to satisfy, and it’s probably better for things where the test is really slow – but what <em>is</em> the case is that it’s a lot less alien to people coming from a classical unit testing background than Hypothesis’s style of property testing is, which makes it a convenient gateway usage mode for people who want to get their feet wet in this sort of testing world without having to fundamentally change the way that they think in order to test trivial features.</p>
<p>There are a bunch of things I can do to make this sort of thing better if it proves popular, but all of the above works today. If it sounds appealing, give it a try. Let me know how it works out for you.</p>
<p>Edit to add: I’ve realised there are some problems with using current Hypothesis with Django like this unfortunately. Specifically if you have unique constraints on models you’re constructing this will not work right now. This concept works fine for normal data, and if there’s interest I’m pretty sure I can make it work in Django, but it needs some further thought.</p>
</div> 
 
</div></body></html>