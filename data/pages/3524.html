<html><body><div><article class="col-md-10 col-md-offset-1">
            


<p>Unfortunately, analysis lives and dies by self-reported metrics.</p>
<p>Is this feature A better than feature B? Is this classifier better than another? How much confidence can I have in this financial report? From the development to the consumption, almost every decision regarding analytics inherently asks "How good is this model?"</p>
<p>"How good" can mean a lot of things and it varies over domain and problems sets. But it is the developer's responsibility to provide a fair measurement in the first place. That task is surprisingly easy to mess up.</p>
<p>So before you use all sorts of fancy software to run on your biggest computing cluster, make sure your "How good" is accurate.</p>
<h3>Getting started</h3>
<p>There's no data analysis without data, so let's grab some and get started. You can download a copy <a href="https://s3.amazonaws.com/yhat-data/heights_and_weights.csv">here</a>.</p>
<pre><code>import numpy as np
import pandas as pd

df = pd.read_csv("heights_and_weights.csv")[:100]
df.head()
</code></pre>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th/>
      <th>HHX</th>
      <th>FMX</th>
      <th>FPX</th>
      <th>SEX</th>
      <th>BMI</th>
      <th>SLEEP</th>
      <th>educ</th>
      <th>height</th>
      <th>weight</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td> 16</td>
      <td> 1</td>
      <td> 2</td>
      <td> 1</td>
      <td> 33.36</td>
      <td> 8</td>
      <td> 16</td>
      <td> 74</td>
      <td> 260</td>
    </tr>
    <tr>
      <th>1</th>
      <td> 20</td>
      <td> 1</td>
      <td> 1</td>
      <td> 1</td>
      <td> 26.54</td>
      <td> 7</td>
      <td> 14</td>
      <td> 70</td>
      <td> 185</td>
    </tr>
    <tr>
      <th>2</th>
      <td> 69</td>
      <td> 1</td>
      <td> 2</td>
      <td> 2</td>
      <td> 32.13</td>
      <td> 7</td>
      <td>  9</td>
      <td> 61</td>
      <td> 170</td>
    </tr>
    <tr>
      <th>3</th>
      <td> 87</td>
      <td> 1</td>
      <td> 1</td>
      <td> 1</td>
      <td> 26.62</td>
      <td> 8</td>
      <td> 14</td>
      <td> 68</td>
      <td> 175</td>
    </tr>
    <tr>
      <th>4</th>
      <td> 88</td>
      <td> 1</td>
      <td> 1</td>
      <td> 2</td>
      <td> 27.13</td>
      <td> 8</td>
      <td> 13</td>
      <td> 66</td>
      <td> 168</td>
    </tr>
  </tbody>
</table>

<p>For these examples we'll concentrate on analytical methods, so the data we're working with isn't that important. In practice this is the wrong approach to take. Bad assumptions about your data can corrupt perceived accuracy as much as anything else, but we'll save that for part 2.</p>
<p>A good place to start is to separate the data into "predictive features" and "thing to predict." In this case the thing we'll be trying to predict is "weight", and the rest of the columns will be the things we'll use to try to predict it. Each row is an observation or a single patient.</p>
<pre><code>feats = df.drop("weight", axis=1) # drop the weight from the feature matrix

# Create a good old X and y combination. Our features and our targets.
X = feats.values
y = df["weight"].values
</code></pre>
<p>Let's fit a model. Because of the nice, clean data we started with (and scikit-learn's standard interfaces) this is super straight-forward.</p>
<pre><code>from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler

X_scaled = StandardScaler().fit_transform(X) # always regularize your features

lr = LinearRegression()
lr.fit(X_scaled, y)
# LinearRegression(copy_X=True, fit_intercept=True, normalize=False)
</code></pre>
<p>Okay, moment of truth. How good is this model?</p>
<h3>A simple measure: $R^2$</h3>
<p>There are a lot of measurements we can use, but fundamentally they all ask the same question: how close is the model's prediction to the truth? In our case, how close is the predicted weight of a person to their actual weight?</p>
<p>Let's make a prediction on our observation set with our trained model <code>lr</code>.</p>
<pre><code>y_pred = lr.predict(X_scaled)
</code></pre>
<p>Next we have to pick a metric. I rolled a die, and decided to go with $R^2$. This metric uses some fancy calculations with squares and means, but the biggest trait to note is that it penalizes outliers more heavily than other methods. It produces a single number: a value of $1.0$ for perfectly performing model with lower values being worse.</p>
<pre><code>from sklearn.metrics import r2_score
r2_score(y, y_pred)
# 0.734755

# NOTE: Plotting functions are defined at the bottom of this article. 
plot_r2(y, y_pred, "Performance of Linear Regression")
</code></pre>
<p><img alt="" src="../static/img/linear-regression.png"/></p>
<p>The $x$ value on this plot shows the actual "weight" of that person, and the $y$ axis shows what the LinearRegression predicts. The blue line represents a perfect prediction. Seems this model does alright, but more importantly we have a number to compare against future attempts to improve.</p>
<p>Now, serious analysis calls for serious models. Let's import a much more serious algorithm, K-Nearest Neighbors, and see how it does.</p>
<p>We'll use the same method for evaluating Nearest Neighbors as Linear Regression.</p>
<pre><code>from sklearn.neighbors import KNeighborsRegressor

# a very serious algorithm
knn = KNeighborsRegressor(n_neighbors=1)
knn.fit(X_scaled, y)

# how good is k-nearest neighbors?
y_pred = knn.predict(X_scaled)
plot_r2(y, y_pred, "Performance of KNN (K=1)")
</code></pre>
<p><img alt="" src="../static/img/knn-results.png"/></p>
<p>As shown in the graph above K-Nearest Neighbors regression does much better, predicting the weight of each individual perfectly.</p>
<h3>Please don't overfit</h3>
<p>So.... what just happened?</p>
<p>In short, we overfit. By training and predicting on the same data, it's easy for a model to seem much better than it actually is. This makes sense doesn't it? We showed the model the weight of an individual during training, then asked it the weight of the same person. It's like known the test answers a priori.</p>
<p>What we'd like to do is fit our model on one set of data, then measure accuracy with another set. We need some holdout data.</p>
<p>A holdout set is exactly what it sounds like: prior to training our model, we set aside a subset of data and then after its trained, we test our model on the subset. scikit-learn's bag of tricks comes to the rescue with a simple <code>train_test_split</code> function ("test" is equivalent to "holdout").</p>
<pre><code>from sklearn.cross_validation import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

print "Train set has %d observations" % len(y_train)
# Train set has 70 observations
print "Holdout set has %d observations" % len(y_test)
# Holdout set has 30 observations
</code></pre>
<p>The important thing about this is that train and test have no observations in common, so we can't cheat the metric by knowing the answer ahead of time. Let's train another model, but this time without the testing data.</p>
<pre><code>t = StandardScaler().fit(X_train)
X_train_scaled = t.transform(X_train) # always regularize your features
lr = LinearRegression()
lr.fit(X_train_scaled, y_train)
</code></pre>
<p>Finally, we can actually make a prediction using the testing data.</p>
<pre><code>X_test_scaled = t.transform(X_test) # use the StandardScaler from training
y_test_pred = lr.predict(X_test_scaled)

r2_score(y_test, y_test_pred)
# 0.42967366162304799
</code></pre>
<p>And similarly, for our K-Neighbors Regression:</p>
<pre><code>knn = KNeighborsRegressor(n_neighbors=1).fit(X_train_scaled, y_train)
r2_score(y_test, knn.predict(X_test_scaled))
# -0.12588851798679546
# yes, rsquared can be negative
</code></pre>
<p><small>Note: If you run the code above, you'll likely get different $R^2$ values because of the random split of training and holdout data</small></p>
<p>As expected, both our Linear and K-Neighbors Regressions $R^2$ scores have dropped significantly.</p>
<h3>Cross-Validation: fancy holdouts</h3>
<p>Of course as we shrink the sample size our model gets less robust and our results get less reliable. If we train on 70% of our data then test on the following 30%, we've lost some precision on both ends. Shifting the split can improve either our model or our metrics, but not both.</p>
<p>A clever statistician might randomly split the data a few times to determine the reliability of the accuracy measurement. If the splits are done correctly, we might even be able to produce measurements for each observation rather than just 30%.</p>
<p>K-Fold cross validation is the formalization of this idea. It strategically performs train-test splits so every observation is in the test set exactly once, thereby ensuring we get a uncorrupted prediction for each observation.</p>
<p>Yet again, scikit-learn to the rescue.</p>
<pre><code>from sklearn.cross_validation import KFold

# Always use shuffle=True to produce random folds. If you need non-random splits, you're probably doing something wrong.
kf = KFold(len(y), n_folds=10, shuffle=True)
</code></pre>
<p>By choosing <code>n_folds=10</code>, we'll run 10 train-test splits and actually train 10 separate models, one for each split. Each model will then predict on it's own unique hold out set. This means each model gets to train on 90% of the origin data, rather than just 70%.</p>
<pre><code>y_pred = np.zeros(len(y), dtype=y.dtype) # where we'll accumulate predictions
lr = LinearRegression()

# train_index and test_index never have the same values, test_indexes never overlap
for train_index, test_index in kf:
    # for each iteration of the for loop we'll do a test train split
    X_train, X_test = X[train_index], X[test_index]
    y_train, y_test = y[train_index], y[test_index]

    t = StandardScaler()
    X_train = t.fit_transform(X_train)
    lr.fit(X_train, y_train) # Train on the training data

    X_test = t.transform(X_test)
    y_pred[test_index] = lr.predict(X_test) # Predict using the test and store in y_pred

print r2_score(y, y_pred)
# 0.71816746048
</code></pre>
<p>Because this metric was created with models trained with a larger percentage of the training data and takes every observation into account, we can assume it's much more accurate than the original "single split" metric.</p>
<p>Finally, we have a somewhat accurate measurement.</p>
<h3>Wrapping things up: Part 1</h3>
<p>Hold-out sets and cross-validation are great ways to confirm your model is actually as robust as you think. Some analytics teams take this idea even further and split hold-out sets across departments: models are trained and tested by one group of analysts and then tested again on a hold-out set by an entirely different department.</p>
<p>This might sound a bit bureaucratic but its just another way of ensuring models aren't over-fit or are assumed to be more robust than they actually are. If you're letting financial decisions be driven by a model, it's worth ensuring you've done this correctly.</p>
<p>In part 2 of this post, we'll cover the terrifyingly subtle ways cross validation can go wrong.  Stay tuned!</p>
<h3>Appendix: The Plotting Code</h3>
<p>My ugly <code>pyplot</code> code for those who want it.</p>
<pre><code>%matplotlib inline
from matplotlib import pyplot as plt
from sklearn.metrics import r2_score

def plot_r2(y, y_pred, title):
    plt.figure(figsize=(10, 6))
    plt.grid()
    plt.scatter(y, y_pred, marker='.')
    plt.xlabel("Actual Target"); plt.ylabel("Predicted Target")
    plt.title(title)
    xmn, xmx = plt.xlim()
    ymn, ymx = plt.ylim()
    mx = max(xmx, ymx) 
    buff = mx * .1
    plt.text(xmn + buff, mx - buff, "R2 Score: %f" % (r2_score(y, y_pred), ), size=15)
    plt.plot([0., mx], [0., mx])
    plt.xlim(xmn, mx)
    plt.ylim(ymn, mx)
</code></pre>

        </article>
    </div></body></html>