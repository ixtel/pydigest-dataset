<html><body><div><div class="section" id="multicore-optimization">
<h1>Multicore Optimization</h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The initial multicore support is there and has worked for the <em>well known</em>
set of test cases. Given the behavior exhibited by <code class="docutils literal"><span class="pre">pickle</span></code> some other
adjustments are expected to ensure all indicators and functions can be passed
back and forth amongst processes when doing multicore optimization.</p>
</div>
<div class="note update admonition">
<p class="first admonition-title">Updated on Jul 24, 2015</p>
<p class="last">Some extra corrections for multicore have been pushed as release 1.0.10.88 to
have more “unpickable” things made pickable. Indicators tests have shown no
problems so far.</p>
</div>
<p>Making use of all available cores was something I had in mind for <code class="docutils literal"><span class="pre">backtrader</span></code>
but never got done. Support of natural operations, removal of array notation,
inclusion of new indicators and bla, bla, bla.</p>
<p>In reality I am not a great fan of <strong>optimization</strong> and consequently neither a
great fan of utilizing all cores for it. A good idea, imho, is worth a million
optimizations.</p>
<p>But someone in the BigMikeTrading forum asked about what this platform had to
offer in comparison to others and I mentioned some of the features including
that <a class="reference external" href="http://gbeced.github.io/pyalgotrade/">PyAlgoTrade</a>, for example, already
had (even multi-machine)</p>
<p>The small but right push needed to get it done was there. From past experience
and because the internet if full of references I already knew: <strong>multihreading</strong>
even if the easiest (no matter what GIL lawyers may say) is a no go in Python,
regardless of the version. Multithreading is fake in Python in that you have
several threads but no parallel execution of code. It may be good to create
abstractions and separate code path execution with IO-bound threads but it is
really a killer.</p>
<p>Left with only one choice then: the module <code class="docutils literal"><span class="pre">multiprocessing</span></code> or a similar
one.</p>
<p>Looking into the bright future I decided to settle for the modern version:
<code class="docutils literal"><span class="pre">concurrent.futures</span></code> (what later proved to be a wrong choice) Even if this
meant adding an external dependency for Python 2.6/2.7 support.</p>
<p>The history:</p>
<blockquote>
<div><ul class="simple">
<li>Some of the dynamic features of Python do not play nice with sending data
back and forth amongst processes</li>
<li>The involved module (<code class="docutils literal"><span class="pre">pickle</span></code>) chokes when <strong>pickling</strong> (serializing)
somethings like classes not defined at module level, lambdas, references
to instance methods and dynamic classes without unique names (even if the
classes are unique themselves)</li>
</ul>
</div></blockquote>
<p>And I had those things scattered over the code. I then found <a class="reference external" href="https://pypi.python.org/pypi/dill">dill</a> and the sibling from pathos <cite>multiprocess
&lt;https://pypi.python.org/pypi/multiprocess&gt;</cite>. Apparently they would solve the
serialization problems but adding more external dependencies ... no no.</p>
<p>Back to the drawing board to see if the non-pickable items could be made
pickable even if the <code class="docutils literal"><span class="pre">pickle</span></code> module produced errors which would have made
some of the old GCC developers very happy.</p>
<p>And it got done ... or no?</p>
<blockquote>
<div><ul>
<li><p class="first">Reworked the non pickable items into pickable things</p>
</li>
<li><p class="first">Run a test with Python 2.7.9 and run like a breeze ... smoothly and
refreshing using the 8 cores of my machine</p>
</li>
<li><p class="first">Run a test with Python 3.4.3 and the 8 cores went into action but after some
optimization, the execution of each subsquent strategy would take longer and
longer and longer ... until it was no longer bearable.</p>
<p>Aparently <strong>pickling</strong> back the result (a complete executed strategy) to the
main process was hitting some limit related to memory allocation (and my
machine has plenty of free RAM ... more than enough for several hours of
parallel optimizations)</p>
</li>
</ul>
</div></blockquote>
<p>Some extra reading took me to consider a simplification of my scenario:</p>
<blockquote>
<div><ul class="simple">
<li>Using <code class="docutils literal"><span class="pre">concurrent.futures</span></code> seems like future proof</li>
<li>But the standard <code class="docutils literal"><span class="pre">multiprocessing</span></code> module already has what <code class="docutils literal"><span class="pre">backtrader</span></code>
needs</li>
</ul>
</div></blockquote>
<p>Smelling of having been using an overkill, some lines were quickly reworked and:</p>
<blockquote>
<div><ul class="simple">
<li>The test run fine with Python 2.7 (even faster than before)</li>
<li>The test run equally fast with Python 3.4</li>
</ul>
</div></blockquote>
<p>Time for a clean-up, running a full battery of tests and executing a push and
releasing 1.0.9.88. No new indicators ... just plain old <strong>multicore
optimization</strong></p>
<p>Having read all that ... it’s time to have a refreshing script about how to
control optimization to use multiple cores</p>
<blockquote>
<div><ul class="simple">
<li>Good news ... NO NEED TO DO ANYTHING ... it’s done without user intervention</li>
</ul>
</div></blockquote>
<p>When the user wishes to optimize a <code class="docutils literal"><span class="pre">strategy</span></code>, the <code class="docutils literal"><span class="pre">Strategy</span></code> subclass gets
added to a <code class="docutils literal"><span class="pre">Cerebro</span></code> instance as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cerebro</span><span class="o">.</span><span class="n">optstrategy</span><span class="p">(</span><span class="n">StrategyClass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>As opposed to the regular way of passing a strategy to a <code class="docutils literal"><span class="pre">Cerebro</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cerebro</span><span class="o">.</span><span class="n">addstrategy</span><span class="p">(</span><span class="n">StrategyClass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>This was always so and has not changed. The background being:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">Cerebro</span></code> needs to understand if a strategy is going to be optimized to
properly handle arguments to the strategy which may already be <code class="docutils literal"><span class="pre">iterables</span></code>
for a regular strategy</li>
</ul>
</div></blockquote>
<p>Now ... <strong>strategies</strong> passed to <code class="docutils literal"><span class="pre">cerebro</span></code> with <code class="docutils literal"><span class="pre">optstrategy</span></code> get the added
benefit of using all available cores of the machine.</p>
<p>Of course if the end user wishes to have fine grained control of the used
cores ... it’s possible. Standard way of creating a <code class="docutils literal"><span class="pre">Cerebro</span></code>:</p>
<blockquote>
<p>cerebro = bt.Cerebro()  # runonce is True, preload is True and “new” maxcpus
is None</p></blockquote>
<p><code class="docutils literal"><span class="pre">maxcpus</span></code> (a new parameter with this release) is the control key:</p>
<blockquote>
<div><ul class="simple">
<li>maxcpus = None -&gt; Use all available CPUs</li>
<li>maxcpus = 1 -&gt; Do not run multicore</li>
<li>maxcpues = 2 ... -&gt; Use the indicated number of cores</li>
</ul>
</div></blockquote>
<p>It’s an opt-out strategy, because multicore is already in.</p>
<p>A comparison on a 4 Core (2x threads per core - total of 8 logical processors)
machine with 16 GBytes of RAM, running Windows 8.1 and Python 64bit 2.7.9</p>
<blockquote>
<div><ul class="simple">
<li>Execution with 1 Core: 326 seconds</li>
<li>Execution with 8 Cores: 127 seconds</li>
</ul>
</div></blockquote>
<p>Different test runs have shown that the ratio is around 2.75:1 in average.</p>
<p>Unluckily the creation/destruction of processes and the pickling of objects back
and forth takes on the potential benefits but the speedup is still significant.</p>
<p>The image shows the 8 cores being used.</p>
<a data-lightbox="group-09df8a61-819e-43b4-8549-a37a67bd9c7d" href="../../../_images\eight-cores-in-use1.png" class="" title="" data-title=""><img src="../../../_images\eight-cores-in-use1.png" class="" alt=""/>
                    </a><p>The code is below. Just change the <code class="docutils literal"><span class="pre">maxcpus</span></code> parameter <code class="docutils literal"><span class="pre">1</span></code> to limit the test to 1
core.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">xrange</span>

<span class="kn">import</span> <span class="nn">backtrader</span> <span class="kn">as</span> <span class="nn">bt</span>
<span class="kn">import</span> <span class="nn">backtrader.indicators</span> <span class="kn">as</span> <span class="nn">btind</span>
<span class="kn">import</span> <span class="nn">backtrader.feeds</span> <span class="kn">as</span> <span class="nn">btfeeds</span>


<span class="k">class</span> <span class="nc">OptimizeStrategy</span><span class="p">(</span><span class="n">bt</span><span class="o">.</span><span class="n">Strategy</span><span class="p">):</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">((</span><span class="s">'smaperiod'</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
              <span class="p">(</span><span class="s">'macdperiod1'</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span>
              <span class="p">(</span><span class="s">'macdperiod2'</span><span class="p">,</span> <span class="mi">26</span><span class="p">),</span>
              <span class="p">(</span><span class="s">'macdperiod3'</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
              <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Add indicators to add load</span>

        <span class="n">btind</span><span class="o">.</span><span class="n">SMA</span><span class="p">(</span><span class="n">period</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">smaperiod</span><span class="p">)</span>
        <span class="n">btind</span><span class="o">.</span><span class="n">MACD</span><span class="p">(</span><span class="n">period_me1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">macdperiod1</span><span class="p">,</span>
                   <span class="n">period_me2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">macdperiod2</span><span class="p">,</span>
                   <span class="n">period_signal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">macdperiod3</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="c"># Create a cerebro entity</span>
    <span class="n">cerebro</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">Cerebro</span><span class="p">(</span><span class="n">maxcpus</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

    <span class="c"># Add a strategy</span>
    <span class="n">cerebro</span><span class="o">.</span><span class="n">optstrategy</span><span class="p">(</span>
        <span class="n">OptimizeStrategy</span><span class="p">,</span>
        <span class="n">smaperiod</span><span class="o">=</span><span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span>
        <span class="n">macdperiod1</span><span class="o">=</span><span class="nb">xrange</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
        <span class="n">macdperiod2</span><span class="o">=</span><span class="nb">xrange</span><span class="p">(</span><span class="mi">26</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span>
        <span class="n">macdperiod3</span><span class="o">=</span><span class="nb">xrange</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="c"># Create a Data Feed</span>
    <span class="n">datapath</span> <span class="o">=</span> <span class="p">(</span><span class="s">'../datas/2006-day-001.txt'</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">feeds</span><span class="o">.</span><span class="n">BacktraderCSVData</span><span class="p">(</span><span class="n">dataname</span><span class="o">=</span><span class="n">datapath</span><span class="p">)</span>

    <span class="c"># Add the Data Feed to Cerebro</span>
    <span class="n">cerebro</span><span class="o">.</span><span class="n">adddata</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c"># clock the start of the process</span>
    <span class="n">tstart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>

    <span class="c"># Run over everything</span>
    <span class="n">stratruns</span> <span class="o">=</span> <span class="n">cerebro</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

    <span class="c"># clock the end of the process</span>
    <span class="n">tend</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>

    <span class="k">print</span><span class="p">(</span><span class="s">'=================================================='</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">stratrun</span> <span class="ow">in</span> <span class="n">stratruns</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'**************************************************'</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">strat</span> <span class="ow">in</span> <span class="n">stratrun</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'--------------------------------------------------'</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">strat</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">_getkwargs</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'=================================================='</span><span class="p">)</span>

    <span class="c"># print out the result</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Time used:'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">tend</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">))</span>
</pre></div>
</div>
</div>

  </div></body></html>