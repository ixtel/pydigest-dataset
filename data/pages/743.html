<html><body><div><div class="content html_format"><p>
      Добрый день, уважаемые читатели.</p><p>
В сегодняшней статье я покажу основы разбора HTML разметки страниц с помощью библиотеки </p><a href="http://lxml.de/">lxml</a><p> для Python.</p><p>
Если вкратце, то </p><strong>lxml</strong><p> это быстрая и гибкая библиотека для обработки разметки </p><a href="http://ru.wikipedia.org/wiki/XML">XML</a><p> и </p><a href="http://ru.wikipedia.org/wiki/HTML">HTML</a><p> на Python. Кроме того, в ней присутствует возможность разложения элементов документа в дерево. В статье я постараюсь показать, насколько просто ее применение на практике.

</p><a name="habracut"/>
<h3>Выбор цели для парсинга</h3><p>
Т.к. я активно занимаюсь спортом, в частности </p><a href="http://ru.wikipedia.org/wiki/%D0%91%D1%80%D0%B0%D0%B7%D0%B8%D0%BB%D1%8C%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B6&#10;%D0%B8%D1%83-%D0%B4%D0%B6%D0%B8%D1%82%D1%81%D1%83">БЖЖ</a><p> мне захотелось посмотреть статисту по болевым приемам во все проведенных турнирах мировых турнирах по MMA.</p><p>
Поиски по гулу привели меня на </p><a href="http://hosteddb.fightmetric.com">сайт</a><p> со всей официальной статистикой по крупным международным турнирам по смешанным единоборствам. Единственной загвоздкой было то, что информация на нам была представлена в неудобном для анализа виде. Это связано с тем, что результаты турниров находится отдельных страницах. Кроме того, дата турнира также с его названием вынесены на отдельную страницу отдельной странице.</p><p>
Чтобы объединить всю информацию по турнирам в одну таблицу, пригодную для анализа, было принято решение написать </p><a href="http://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D1%81%D0%B5%D1%80">парсер</a><p> описанный ниже.

</p><h3>Алгоритм работы парсера</h3><p>
Для начала разберемся с алгоритмом работы парсера. Он будет следующим:
</p><ol>
<li>За основу возьмем таблицу со всеми турнирами и их датами, которая находится<br/>
по <a href="http://hosteddb.fightmetric.com/events/index/date/desc/1/all">данному<br/>
адресу</a></li>
<li>Занесем данные с этой страницы в набор данных, cо следующими столбцами:</li>
<li>турнир</li>
<li>ссылка на описание</li>
<li>дата</li>
<li>По каждой записи набора (по каждому турниру) осуществляем переход по полю<br/>
<em>[ссылка на описание]</em>, для получения информации о боях</li>
<li>Записываем информацию по всем боям турнира</li>
<li>К набору данных с информацией о боях добавляем дату проведения турнира из<br/>
набора (2)</li>
</ol><p>
Алгоритм готов и можно перейти к его реализации

</p><h3>Начало работы с lxml</h3><p>
Для работы нам понадобятся модули </p><em>lxml</em><p> и </p><a href="http://pandas.pydata.org/pandas-docs/stable/">pandas</a><p>. Подгрузим их в нашу программу:

</p><pre><code class="python">import lxml.html as html
from pandas import DataFrame
</code></pre><p>
Для удобства дальнейшего парсинга вынесем основной домен в отдельную переменную:

</p><pre><code class="python">main_domain_stat = 'http://hosteddb.fightmetric.com'
</code></pre><p>
Теперь давайте получим объект для парсинга. Сделать это можно с помощью функции </p><a href="http://lxml.de/lxmlhtml.html#parsing-html-fragments">parse()</a><p>:

</p><pre><code class="python">page = html.parse('%s/events/index/date/desc/1/all' % (main_domain_stat))
</code></pre><p>
Теперь откроем указанную таблицу в HTML редакторе и изучаем ее структуру. Больше всего нас интересует блок с классами </p><code>events_table data_table row_is_link</code><p>, т.к. именно он содержит таблицу с нужными нам данными. Получить данный блок можно так:

</p><pre><code class="python">e = page.getroot().\
        find_class('events_table data_table row_is_link').\
        pop()
</code></pre><p>
Разберемся, что делает данный код.</p><p>
Сначала с помощью функции </p><a href="http://lxml.de/api/lxml.etree._ElementTree-class.html">getroot()</a><p> мы получаем корневой элемент нашего документа (это нужно для последующей работы с документом).</p><p>
Далее, с помощью функции </p><a href="http://lxml.de/lxmlhtml.html#html-element-methods">find_class()</a><p> мы находим все элементы с указанными классами. В результате работы функции мы получим список таких элементов. Т.к. после визуального анализа HTML кода страницы видно, что по данному критерию подходит только один элемент, то мы извлекаем его из списка с помощью функции </p><a href="https://docs.python.org/2/tutorial/datastructures.html">pop()</a><p>.</p><p>
Теперь надо получить таблицу из нашего </p><em>div</em><p>'a, полученного ранее. Для этого воспользуемся методом </p><a href="http://lxml.de/api/lxml.etree._Element-class.html">getchildren()</a><p>, который возвращает список подчерненных объектов текущего элемента. И</p><p>
потому, что у нас только один такой объект, ты мы извлекаем этот его из списка.

</p><pre><code class="python">t = e.getchildren().pop()
</code></pre><p>
Теперь переменная </p><i>t</i><p> содержит таблицу с необходимой для нас информацией. Теперь, я получу 2 вспомогательных </p><em>dataframe'a</em><p>, объединив которые, мы получим данные о турнирах с датами их проведения и ссылками на результаты.</p><p>
В первый набор я включу все названия турниров и ссылки на их страницы на сайте. Это легко сделать с помощью итератора </p><a href="http://lxml.de/lxmlhtml.html#working-with-links">iterlinks()</a><p>, который возвращает список котрежей </p><code>(элемент, атрибут,<br/>
адрес ссылки, позиция )</code><p> внутри заданного элемента. Собственно, из этого кортежа, нам нужен адрес ссылки и ее текст.</p><p>
Тест ссылки можно получить обративший к свойству </p><strong>.text</strong><p> соответсвующего элемента. Код будет следующим:

</p><pre><code class="python">events_tabl = DataFrame([{'EVENT':i[0].text, 'LINK':i[2]} for i in t.iterlinks()][5:])
</code></pre><p>
Внимательный читатель заметит, что в цикле мы исключаем первые 5 записей. В них содержится не нужная нам информация, типа заголовков полей, поэтому я от них и избавился.</p><p>
Итак, ссылки мы получили. Теперь получим 2 поднабор данных с датами проведения турниров. Это можно сделать так:

</p><pre><code class="python">event_date = DataFrame([{'EVENT': evt.getchildren()[0].text_content(), 'DATE':evt.getchildren()[1].text_content()} for evt in t][2:])
</code></pre><p>
В коде, показанном выше, мы проходим по всем строкам (теги </p><i>tr</i><p>) в таблице </p><i>t</i><p>. Затем для каждой строки получаем список дочерних колонок (элементы </p><em>td</em><p>). И получаем информацию записанную в первой и второй колонках с помощью метода </p><a href="http://lxml.de/lxmlhtml.html#html-element-methods">text_content</a><p>, который возвращает строку из текста всех дочерних элементов данного столбца.</p><p>
Чтобы понять, как работает метод </p><i>text_content</i><p> приведем небольшой пример. Допустим у нас задана такая структура документа </p><i>&lt;tr&gt;&lt;td&gt;&lt;span&gt;текст&lt;/span&gt;&lt;span&gt;текст&lt;/span&gt;</i><p>. Так вот, метод </p><i>text_content</i><p> вернет строку </p><em>текст текст</em><p>, а метод </p><i>text</i><p> не вернет ничего, или же просто </p><em>текст</em><p>.
</p><p>
Теперь, когда у нас есть 2 поднабора данных, объединим их в итоговый набор:

</p><pre><code class="python">sum_event_link = events_tabl.set_index('EVENT').join(event_date.set_index('EVENT')).reset_index()
</code></pre><p>
Тут, мы сначала указываем индексы нашим наборам, затем объединяем их и сбрасываем индексы итогового набора. Подробнее о этих операция можно прочитать в одной из моих прошлых </p><a href="/posts/54">статей</a><p>. Осталось выгрузить полученный dataframe в текстовый файл, для сохранности:

</p><pre><code class="python">sum_event_link.to_csv('..\DataSets\ufc\list_ufc_events.csv',';',index=False)
</code></pre>
<h3>Обработчик события одного события UFC</h3><p>
Страницу с перечнем турниров мы выгрузили в удобном формате. Пришло время разобраться со страницами с результатами по соревнований. Для примера возьмем последний </p><a href="http://hosteddb.fightmetric.com/events/details/662">турнир</a><p> и посмотрим HTML код страницы.</p><p>
Можно заметить, что нужная нам информация содержится в элементе с классом </p><i>data_table row_is_link</i><p>. В целом процесс парсинга похож на показанный выше, за одним исключением: таблица результатов оформлена не совсем корректно.</p><p>
Некорретность ее в том, что для каждого бойца в ней заведена отдельная строка, что никак не удобно при анализе. Чтобы избавиться от этого неудобства при разборе результатов я принял решение использовать итератор, только по нечетным строкам. Номер же четной вычислять из текущей нечетной строки.</p><p>
Таким образом я буду обрабатывать сразу пару строк и переносить их в строку. Код будет следующий:

</p><pre><code class="python">all_fights = []
for i in sum_event_link.itertuples():
    page_event = html.parse('%s/%s' % (main_domain_stat,active_event_link))
    main_code = page_event.getroot()
    figth_event_tbl = main_code.find_class('data_table row_is_link').pop()[1:]
    for figther_num in xrange(len(figth_event_tbl)): 
        if not figther_num % 2:
            all_fights.append(
                        {'FIGHTER_WIN': figth_event_tbl[figther_num][2].text_content().lstrip().rstrip(), 
                        'FIGHTER_LOSE': figth_event_tbl[figther_num+1][1].text_content().lstrip().rstrip(), 
                        'METHOD': figth_event_tbl[figther_num][8].text_content().lstrip().rstrip(), 
                        'METHOD_DESC': figth_event_tbl[figther_num+1][7].text_content().lstrip().rstrip(), 
                        'ROUND': figth_event_tbl[figther_num][9].text_content().lstrip().rstrip(), 
                        'TIME': figth_event_tbl[figther_num][10].text_content().lstrip().rstrip(),
                        'EVENT_NAME': i[1]} 
                        )
history_stat = DataFrame(all_fights)
</code></pre><p>
Можно заметить, что для каждого поединка дополнительно записывается название турнира. Это нужно для того, чтобы определить дату поединка.</p><p>
Сохраним теперь полученные результаты в файл:

</p><pre><code class="python">history_stat.to_csv('..\DataSets\ufc\list_all_fights.csv',';',index=False)
</code></pre><p>
Посмотрим на полученный результат:

</p><pre><code class="python">history_stat.head()</code></pre>
<table>
<thead>
<tr>
<th/>
<th>EVENT_NAME</th>
<th>FIGHTER_LOSE</th>
<th>FIGHTER_WIN</th>
<th>METHOD</th>
<th>METHOD_DESC</th>
<th>ROUND</th>
<th>TIME</th>
</tr>
</thead>
<tbody>
<tr>
<th>0</th>
<td> UFC Fight Night 38: Shogun vs. Henderson</td>
<td> Robbie Lawler</td>
<td> Johny Hendricks</td>
<td> U. DEC</td>
<td> NaN</td>
<td> 5</td>
<td> 5:00</td>
</tr>
<tr>
<th>1</th>
<td> UFC Fight Night 38: Shogun vs. Henderson</td>
<td> Carlos Condit</td>
<td> Tyron Woodley</td>
<td> KO/TKO</td>
<td> Knee Injury</td>
<td> 2</td>
<td> 2:00</td>
</tr>
<tr>
<th>2</th>
<td> UFC Fight Night 38: Shogun vs. Henderson</td>
<td> Diego Sanchez</td>
<td> Myles Jury</td>
<td> U. DEC</td>
<td> NaN</td>
<td> 3</td>
<td> 5:00</td>
</tr>
<tr>
<th>3</th>
<td> UFC Fight Night 38: Shogun vs. Henderson</td>
<td> Jake Shields</td>
<td> Hector Lombard</td>
<td> U. DEC</td>
<td> NaN</td>
<td> 3</td>
<td> 5:00</td>
</tr>
<tr>
<th>4</th>
<td> UFC Fight Night 38: Shogun vs. Henderson</td>
<td> Nikita Krylov</td>
<td> Ovince Saint Preux</td>
<td> SUB</td>
<td> Other — Choke</td>
<td> 1</td>
<td> 1:29</td>
</tr>
</tbody>
</table><p>
Осталось полько подтянуть к поединкам дату и выгрузить итоговый файл:

</p><pre><code class="python">all_statistics = history_stat.set_index('EVENT_NAME').join(sum_event_link.set_index('EVENT').DATE)
all_statistics.to_csv('..\DataSets\ufc\statistics_ufc.csv',';', index_label='EVENT')
</code></pre>
<h3>Заключение</h3><p>
В статье я постарался показать основы работы с библиотекой </p><strong>lxml</strong><p>, пердназначенной для парсинга разметки XML и HTML. Код указанный в статье не претендует на оптимальность, но корректно выполняет поставленную перед ним задачу.</p><p>
Как видно из приведенной программы процесс работы с библиотекой довольно прост, что помогает быстро писать нужный код. Кроме того помимо указанных выше функций и методов есть и другие не менее нужные.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>