<html><body><div><div class="section">
              <h1>django-multiurl 1.1.0</h1>

              


<p>Allow multiple views to match the same URL.</p><p>








django-multiurl
</p><p>===============


</p><p>------------------------------------------------------------------------------------------------------------------------------

</p><p>.. image:: https://travis-ci.org/raiderrobert/django-multiurl.svg?branch=master
</p><p>   :target: https://travis-ci.org/raiderrobert/django-multiurl

</p><p>Have you ever wanted multiple views to match to the same URL? Now you can.

</p><p>You may once have tried something like this::

</p><p>    urlpatterns = [
</p><p>        url('/app/(\w+)/$', app.views.people),
</p><p>        url('/app/(\w+)/$', app.views.place),
</p><p>    ]

</p><p>However, if you try this, ``/app/san-francisco/`` will only map to
</p><p>``app.views.people``. Raising an ``Http404`` from ``app.views.people`` doesn't
</p><p>help: you only get a 404 in the browser because Django stops resolving
</p><p>URLs at the first match.

</p><p>Well, ``django-multiurl`` solves this problem. Just 
</p><p>``pip install django-multiurl``, then do this::

</p><p>    from multiurl import multiurl

</p><p>    urlpatterns = [
</p><p>        multiurl(
</p><p>            url('/app/(\w+)/$', app.views.people),
</p><p>            url('/app/(\w+)/$', app.views.place),
</p><p>        )
</p><p>    ]

</p><p>Now in your views, raise ``multiurl.ContinueResolving`` anywhere you'd like
</p><p>to break out of the view and keep resolving. For example, here's what
</p><p>``app.views.people`` might look like::

</p><p>    from multiurl import ContinueResolving

</p><p>    def people(request, name):
</p><p>        try:
</p><p>            person = Person.objects.get(name=name)
</p><p>        except Person.DoesNotExist:
</p><p>            raise ContinueResolving
</p><p>        return render(...)

</p><p>That's it! ``ContinueResolving`` will cause ``multiurl`` to continue onto the
</p><p>next view (``app.views.place``, in this example).

</p><p>A few notes to round things out:

</p><p>* If you don't want to use ``ContinueResolving`` -- perhaps you'd rather
</p><p>  continue using ``get_object_or_404``, or you're using third-party views
</p><p>  that you can't modify to raise ``ContinueResolving``, you can pass a
</p><p>  ``catch`` argument into ``multiurl`` to control which exceptions are
</p><p>  considered "continue" statements. For example, to allow ``Http404``
</p><p>  exceptions to continue resolving, do this::

</p><p>        urlpatterns = [
</p><p>            multiurl(
</p><p>                url('/app/(\w+)/$', app.views.people),
</p><p>                url('/app/(\w+)/$', app.views.place),
</p><p>                catch = (Http404, ContinueResolving)
</p><p>            )
</p><p>        ]

</p><p>  As you can see, ``catch`` should be a tuple of exceptions. It's probably a
</p><p>  good idea to always include ``ContinueResolving`` in the tuple.

</p><p>* If the last view in a ``multiurl`` raises ``ContinueResolving`` (or another
</p><p>  "continuing" exception), a 404 will be raised instead. That is, if resolving
</p><p>  "falls off the end" of some multi-urls, you'll get the 404 you expect.

</p><p>* Reverse URL resolution just works as expected. Name your sub-URLs and then
</p><p>  reverse your heart out.

</p><p>Contributing
</p><p>------------

</p><p>Development takes place
</p><p>`on GitHub &lt;http: github.com="" jacobian="" django-multiurl=""&gt;`_; pull requests are
</p><p>welcome. Run tests with `tox &lt;http: tox.readthedocs.org=""/&gt;`_.


</p><a name="downloads">Â </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>82</span> downloads in the last week
  </li>
  <li>
    <span>515</span> downloads in the last month
  </li>
</ul>









            </div>


          </div></body></html>