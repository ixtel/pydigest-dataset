<html><body><div><article class="techblog-post full">

    <header class="page-header">
        <h1>
        A simple method for rendering templates with Python
        </h1>
    </header>

    
<p class="lead">I never intended to write a template system for <a href="http://www.moyaproject.com" class="external-link" title="www.moyaproject.com">Moya</a>. Originally, I was going to offer a plugin system to use any template format you wish, with <a href="http://jinja.pocoo.org/docs/dev/" class="external-link" title="jinja.pocoo.org">Jinja</a> as the default. Jinja was certainly up to the task; it is blindingly fast, with a comfortable Django-like syntax. But it was never going to work exactly how I wanted it to, and since I don't have to be pragmatic on my hobby projects, I decided to re-invent the wheel. Because otherwise, how do we get better wheels?</p>
<p>The challenge of writing a template language, I discovered, was keeping the code manageable. If you want to make it both flexible <em>and</em> fast, it can quickly descend in to a mass of special cases and compromises. After a few aborted attempts, I worked out a system that was both flexible and reasonable fast. Not as fast as template systems that compile directly in to Python, but not half bad. Moya's template system is about 10-25% faster than Django templates with a similar feature set.</p>
<p>There are a two main steps in rendering a template. First the template needs to be <em>tokenized</em>, i.e. split up in a data structure of text / tags. This part is less interesting I think, because it can be done in advance and cached. The interesting part is the following step that turns that data structure in to HTML output.</p>
<p>This post will explain how Moya renders templates, by implementing a new template system that works the same way.</p>
<p>Let's render the following template:</p>



<div class="code"><pre><span class="nt">&lt;h1&gt;</span>Hobbit Index<span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;ul&gt;</span>
    {% for hobbit in hobbits %}
    <span class="nt">&lt;li</span><span class="err">{%</span> <span class="na">if</span> <span class="na">hobbit=</span><span class="s">=active</span> <span class="err">%}</span> <span class="na">class=</span><span class="s">"active"</span><span class="err">{%</span> <span class="na">endif</span> <span class="err">%}</span><span class="nt">&gt;</span>
        {hobbit}
    <span class="nt">&lt;/li&gt;</span>
    {% endfor %}
<span class="nt">&lt;/ul&gt;</span>
</pre></div>

<p>This somewhat similar to a Django or Moya template. It generates HTML with unordered list of hobbits, one of which has the attribute <code>class="active"</code> on the <code>&lt;li&gt;</code>. You can see there is a loop and conditional in there.</p>
<p>The tokenizer scans the template and generates a hierarchical data structure of text, and tag tokens (markup between {% and %}). Tag tokens consist of a parameters extracted from the tag and <em>children</em> nodes (e.g the tokens between the <code>{% for %}</code> and <code>{% endfor %}</code>).</p>
<p>I'm going to omit the tokenize functionality as an exercise for the reader (sorry, I hate that too). We'll assume that we have implemented the tokenizer, and the end result is a data structure that looks like this:</p>



<div class="code"><pre><span class="p">[</span>
    <span class="s">"&lt;h1&gt;Hobbit Index&lt;/h1&gt;"</span><span class="p">,</span>
    <span class="s">"&lt;ul&gt;"</span><span class="p">,</span>
    <span class="n">ForNode</span><span class="p">(</span>
        <span class="p">{</span><span class="s">"src"</span><span class="p">:</span> <span class="s">"hobbits"</span><span class="p">,</span> <span class="s">"dst"</span><span class="p">:</span> <span class="s">"hobbit"</span><span class="p">},</span>
        <span class="p">[</span>
            <span class="s">"&lt;li"</span><span class="p">,</span>
            <span class="n">IfNode</span><span class="p">(</span>
                <span class="p">{</span><span class="s">"test"</span><span class="p">:</span> <span class="s">"hobbit==active"</span><span class="p">},</span>
                <span class="p">[</span>
                    <span class="s">' class="active"'</span>
                <span class="p">]</span>
            <span class="p">),</span>
            <span class="s">"&gt;"</span><span class="p">,</span>
            <span class="s">"{hobbit}"</span><span class="p">,</span>
            <span class="s">"&lt;/li&gt;"</span><span class="p">,</span>
        <span class="p">]</span>
     <span class="p">),</span>
    <span class="s">"&lt;/ul&gt;"</span>
<span class="p">]</span>
</pre></div>

<p>Essentially this is a list of strings or <em>nodes</em>, where a node can contain further nested strings and other nodes. A node is defined as a class instance that handles the functionality of a given tag, i.e. IfNode for the {% if %} tag and ForNode for the {% for %} tag.</p>
<p>Nodes have the following trivial base class, which stores the parameters and the list of children:</p>



<div class="code"><pre><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">children</span>
</pre></div>

<p>Nodes also have an additional method, <code>render</code>, which takes a mapping of the data we want to render (the <em>conext</em>). This method should be a generator, which may yield] one of two things; either strings containing output text <em>or</em> an iterator that yields further nodes. Let's look at the IfNode first:</p>



<div class="code"><pre><span class="k">class</span> <span class="nc">IfNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="n">test</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s">'test'</span><span class="p">],</span> <span class="nb">globals</span><span class="p">(),</span> <span class="n">context</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
</pre></div>

<p>The first thing the render method does is to get the <code>test</code> parameter and evaluate it with the data in the context. If the result of that test is truthy, then the render method yields an iterator of it's children. Essentially all this node object does is render its children (i.e. the template code between {% if %} and {% endif %}) if the test passes.</p>
<p>The <code>ForNode</code> is similar, here's the implementation:</p>



<div class="code"><pre><span class="k">class</span> <span class="nc">ForNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="n">src</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s">'src'</span><span class="p">],</span> <span class="nb">globals</span><span class="p">(),</span> <span class="n">context</span><span class="p">)</span>
        <span class="n">dst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s">'dst'</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="n">dst</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="k">yield</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
</pre></div>

<p>The ForNode render method iterates over each item in a sequence, and assigns the value to an intermediate variable. It also yields to its children each pass through the loop. So the code inside the {% for %} tag is rendered once per item in the sequence.</p>
<p>Because we are using generators to handle the state for control structures, we can keep the main render loop free from such logic. This makes the code that renders the template trivially easy to follow:</p>



<div class="code"><pre><span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="o">**</span><span class="n">context</span><span class="p">):</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">template</span><span class="p">)]</span>

    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">context</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">context</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</pre></div>

<p>The render loop manages a stack of iterators, initialized to the template data structure. Each pass through the loop it pops an item off the stack. If that item is a string, it performs a string format operation with the context data. If the item is a Node, it calls the render method and pushes the generator back on to the stack. When the stack item is an iterator (such as a generator created by Node.render) it gets one value from the iterator and pushes it back on to the stack, or discards it if is empty.</p>
<p>In essence, the inner loop is running the generators and collecting the output. A more naive approach might have the render methods also rendering their children and returning the result as a string. Using generators frees the nodes from having to build strings. Generators also makes error reporting much easier, because exceptions won't be obscured by deeply nested render methods. Consider a node throwing an exception inside a for loop; if ForNode.render was responsible for rendering its children, it would also have to trap and report such errors. The generator system makes error reporting simpler, and confines it to one place.</p>
<p>There is a very similar loop at the heart of Moya's template system. I suspect the main reason that Moya templates are moderately faster than Django's is due to this lean inner loop. See this <a href="https://gist.github.com/willmcgugan/00c3427ef5a5e04d3c86" class="external-link" title="gist.github.com">GutHub</a> gist for the code from this post. You may also find <a href="https://github.com/moyaproject/moya/blob/master/moya/template/moyatemplates.py" class="external-link" title="github.com">Moya's template implementation</a> interesting.</p>




</article>


</div></body></html>