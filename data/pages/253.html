<html><body><div><div class="entry-content"><p>Rover.com is a Django shop, but I personally come from a Rails background. The Rails world has great tooling and infrastructure for automated functional tests – <a href="https://github.com/jnicklas/capybara">capybara</a>, <a href="https://github.com/thoughtbot/capybara-webkit">capybara-webkit</a>, and the new hotness <a href="https://github.com/jonleighton/poltergeist">poltergist</a>. Underneath poltergeist lies PhantomJS, a headless webkit with very few dependencies, excellent for automated testing. Unfortuantely, PhantomJS version 1.5 dropped Python bindings, leaving us Djangonauts out to dry. There also isn’t a great capybara equivalent in the Python world (<a href="https://github.com/jeanphix/Ghost.py">Ghost.py</a> is the closest).</p>

<p>Thankfully, despite the roadblocks, there is a path forward! Django (starting with 1.4) comes with <code>LiveServerTestCase</code> to support our exact use case. After failed attempts to get Ghost.py up and running (due to dependencies and lack of documentation), I landed upon a solution that will start us Django developers down the path of being first class citizens once more (well, maybe not exactly <em>first class</em>, but at least those coach seats up front with a little extra legroom). I’ve also taken some baby steps to improve our testing assertion syntax, trying to fill the capybara void, which I’ll get into at the end of this post.</p>




<p>Let’s get started.</p>

<h1>Install the Prerequisites</h1>

<ul>
<li>NodeJS</li>
<li>Fontconfig</li>
<li>PhantomJS</li>
<li>Selenium</li>
</ul>


<p>The following steps are for Ubuntu 12.04 LTS.</p>

<h2>NodeJS</h2>

<p>Ubuntu 12.04’s default ppa’s don’t have the latest version of NodeJS, so we first need to add a new repository.</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line">sudo apt-get install software-properties-common
</span><span class="line">sudo apt-get update
</span><span class="line">sudo apt-get install -y python-software-properties python g++ make
</span><span class="line">sudo add-apt-repository -y ppa:chris-lea/node.js
</span><span class="line">sudo apt-get update
</span></code></pre></td></tr></table></div></figure>


<p>Now, we can install</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line">sudo apt-get install nodejs
</span></code></pre></td></tr></table></div></figure>


<h2>Fontconfig</h2>

<p>For use with PhantomJS</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line">sudo apt-get install fontconfig
</span></code></pre></td></tr></table></div></figure>


<h2>PhantomJS</h2>

<p>NodeJS comes with <a href="https://npmjs.org">npm</a>, their package manager. From that, we can install PhantomJS.</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line">sudo npm -g install phantomjs
</span></code></pre></td></tr></table></div></figure>


<p>Note here that I’m installing it globally, which is not required to get this to work, but can make things easier.</p>

<h2>Selenium</h2>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line">pip install -U selenium
</span></code></pre></td></tr></table></div></figure>


<h1>Application setup</h1>

<p>With our system set up to support our automated testing, we now need to set up our application so we can start writing our own tests.</p>

<h3>Add selenium to your <code>INSTALLED_APPS</code></h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">INSTALLED_APPS</span> <span class="o">=</span> <span class="p">(</span>
</span><span class="line">    <span class="s">'django.contrib.auth'</span><span class="p">,</span>
</span><span class="line">    <span class="s">'...'</span><span class="p">,</span>
</span><span class="line">    <span class="s">'selenium'</span><span class="p">,</span>
</span><span class="line"><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Install the Selenium Utility Belt</h3>

<p>We’ve written and open-sourced the very beginning of what we hope will grow into a more fully-featured assertion framework Selenium testing in Django. We created this to wrap some of the selenium syntax into a more expressive feature set to enable more rapid test writing. When testing interfaces, it is really nice to be able to express assertions as they relate to your goals, such as <code>assertOnPage</code>. This was the impetus for creating the selenium utility belt. The project lives at <a href="https://github.com/roverdotcom/selenium-utility-belt">https://github.com/roverdotcom/selenium-utility-belt</a> and is in its infancy. We hope to add to this (with your help!), rework its structure, and release it onto PyPI for wider consumption.</p>

<p>Copy the <code>selenium_utility_belt.py</code> file into your project at a convenient place to import it to your base test case class. We toss ours in our common app, in the test folder.</p>

<h3>Base class for your test cases</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">from</span> <span class="nn">django.test</span> <span class="kn">import</span> <span class="n">LiveServerTestCase</span>
</span><span class="line"><span class="kn">from</span> <span class="nn">common.test.selenium_utility_belt</span> <span class="kn">import</span> <span class="n">SeleniumUtilityBelt</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">InterfaceTestCase</span><span class="p">(</span><span class="n">SeleniumUtilityBelt</span><span class="p">,</span> <span class="n">LiveServerTestCase</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="nb">super</span><span class="p">(</span><span class="n">InterfaceTestCase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">setUp</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h1>Write your first test!</h1>

<p>With just a little bit of wrapping of the Selenium API, our interface becomes very simple to test. Here we have a single test that asserts the presence and visibility of our Location text entry field on our homepage.</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">from</span> <span class="nn">common.test</span> <span class="kn">import</span> <span class="n">InterfaceTestCase</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">HomepageTests</span><span class="p">(</span><span class="n">InterfaceTestCase</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="nb">super</span><span class="p">(</span><span class="n">HomepageTests</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">setUp</span><span class="p">()</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">test_location_field_on_homepage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">assertOnPage</span><span class="p">(</span><span class="s">'#location'</span><span class="p">,</span> <span class="n">visible</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h1>Gotchyas</h1>

<h3>Port collisions</h3>

<p>When running these tests on our CI server, we ran into the issue of port collisions for the running PhantomJS processes. <code>LiveServerTestCase</code> had foresight on this issue, and added an option when you run your tests. Simply specify the range of ports to use when you call your test runner.</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line">./manage.py <span class="nb">test</span> --liveserver<span class="o">=</span>localhost:8090-8100
</span></code></pre></td></tr></table></div></figure>


<p>Recent versions of django-jenkins take this option as well, so you can easily use these tests on your CI server</p>

<h1>Phew!</h1>

<p>If you have run into any questions or hit any roadblocks along your way here, you can reach me at <a href="http://twitter.com/croby">@croby</a>. Contributions to the utility belt are welcome and encouraged!</p>
</div>


  </div></body></html>