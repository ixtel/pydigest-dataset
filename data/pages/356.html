<html><body><div><div class="content">

    <p>
<a href="https://zato.io/docs/index.html">Zato</a> is a Python-based platform for integrating applications
and exposing back-end services to front-end clients. It's an ESB (Enterprise
Service Bus) and an application server focused on data integrations. The
platform doesn't enforce any limits on architectural style for designing
systems and can be used for SOA (Service Oriented Architecture), REST
(Representational State Transfer) and for building systems of systems
running in-house or in the cloud.
</p>

<p>
At its current version of 1.1 (at the time of this writing), Zato supports HTTP, JSON, SOAP, SQL, AMQP,
JMS WebSphere MQ, ZeroMQ, Redis NoSQL and FTP. It includes a browser-based
GUI, CLI, API, security, statistics, job scheduler, HAProxy-based load
balancer and hot-deployment. Each piece is extensively documented from
the viewpoint of several audiences: architects, admins and programmers.
</p>

<p>
Zato servers are built on top of gevent and gunicorn frameworks
that are responsible for handling incoming traffic using asynchronous
notification libraries, such as libevent or libev, but all of that is hidden
from programmers' views so they can focus on their job only.
</p>

<p>
Servers always are part of a cluster and run identical copies of
services deployed. There is no limit on how many servers a single
cluster can contain.
</p>

<p>
Each cluster keeps its configuration in Redis and an SQL database. The
former is used for statistics or data that is frequently updated and
mostly read-only. The latter is where the more static configuration
shared between servers is kept.
</p>

<p>
Users access Zato through its <a href="https://zato.io/docs/web-admin/intro.html">Web-based GUI</a>,
the <a href="https://zato.io/docs/admin/cli/index.html">command line</a> or <a href="https://zato.io/docs/public-api/intro.html">API</a>.
</p>

<p>
Zato promotes loose coupling, reusability of components and
hot-deployment. The high-level goal is to make it trivial to access
or expose any sort of information. Common integration techniques and
needs should be, at most, a couple clicks away, removing the need
to reimplement the same steps constantly, slightly differently in each
integration effort.
</p>

<p>
Everything in Zato is about minimizing the interference of components
on each other, and server-side objects you create can be updated easily,
reconfigured on fly or reused in other contexts without influencing
any other.
</p>

<p>
This article guides you through the process of exposing complex XML
data to three clients using JSON, a simpler form of XML and SOAP, all 
from a single code base in an elegant and Pythonic way that doesn't
require you to think about the particularities of any format or transport.
</p>

<p>
To speed up the process of retrieving information by clients, back-end
data will be cached in Redis and updated periodically by a job-scheduled
service.
</p>

<p>
The data provider used will be US Department of the Treasury's <a href="http://www.treasury.gov/resource-center/data-chart-center/interest-rates/Pages/TextView.aspx?data=reallongtermrate">real
long-term interest rates</a>. Clients
will be generic HTTP-based ones invoked through curl, although in
practice, any HTTP client would do.
</p>

<h3>
The Process and IRA Services</h3>

<p>
The goal is to make it easy and efficient for external client
applications to access long-term US rates information. To that end,
you'll make use of several features of Zato:
</p>



<p>
Zato encourages the division of each business process into
a <a href="https://zato.io/docs/intro/esb-soa.html">set of IRA services</a>—that is, each service exposed to users should be:
</p>

<ul><li>
<p>
<em>Interesting</em>: services should provide a real value that makes
potential users pause for a moment and, at least, contemplate using the
service in their own applications for their own benefit.
</p></li>

<li>
<p>
<em>Reusable</em>: making services modular will allow you to make use of them
in circumstances yet unforeseen—to build new, and possibly unexpected,
solutions on top of lower-level ones.
</p></li>

<li>
<p>
<em>Atomic</em>: a service should have a well defined
goal, indivisible
from the viewpoint of a service's users, and preferably no functionality
should overlap between services.
</p></li></ul>

<p>
The IRA approach closely follows the UNIX philosophy of "do one thing
and do it well" as well as the KISS principle that is well known and followed
in many areas of engineering.
</p>

<p>
When you design an IRA service, it is almost exactly like defining APIs
between the components of a standalone application. The difference is
that services connect several applications running in a distributed
environment. Once you take that into account, the mental process is
identical.
</p>

<p>
Anyone who already has created an interesting interface of any sort in
a single-noded application written in any programming language will feel
right like home when dealing with IRA services.
</p>

<p>
From Zato's viewpoint, there is no difference in whether a service
corresponds to an S in SOA or an R in REST; however, throughout this
article, I'm using the the former approach.
</p>
  </div>
      </div></body></html>