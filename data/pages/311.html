<html><body><div><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-semisync" class="anchor" href="#semisync" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>SemiSync</h1>

<p>A decorator-based python module for semi-synchronous programming.<br/>
Synchronous when you need it, and asynchronous when you don't!
Pull requests welcome...</p>

<h2><a id="user-content-what-is-semisyncpy" class="anchor" href="#what-is-semisyncpy" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>What is semisync.py?</h2>

<p>Some problems are best solved synchronously, while others are a better fit for the asynchronous paradigm.  Most problems fall somewhere in between -- they could benefit from asynchronous execution, but require some events to happen in a certain order.  This module seeks to make blending the two paradigms a bit easier by introducing a concept of dependencies.    If one process must not run until another process has completed, that process is said to be "dependent" on the second process.  Semisync.py was built using python's multiprocessing library and a liberal dose of decorator syntax.</p>

<h2><a id="user-content-installation" class="anchor" href="#installation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Installation</h2>

<p>Install via pip</p>

<pre><code>sudo pip install semisync
</code></pre>

<p>or via setup.py</p>

<pre><code>sudo python setup.py install
</code></pre>

<h2><a id="user-content-lets-see-some-code" class="anchor" href="#lets-see-some-code" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Let's See Some Code</h2>

<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> semisync <span class="pl-k">import</span> semisync
<span class="pl-k">from</span> multiprocessing <span class="pl-k">import</span> Manager
<span class="pl-k">from</span> random <span class="pl-k">import</span> random, randint
<span class="pl-k">from</span> time <span class="pl-k">import</span> sleep

<span class="pl-c"># shared data between processes</span>
shared <span class="pl-k">=</span> Manager().Namespace()

<span class="pl-c"># a demo callback function</span>
<span class="pl-k">def</span> <span class="pl-en">output</span>(<span class="pl-smi">field</span>, <span class="pl-smi">value</span>):
    <span class="pl-c1">print</span> field <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>: $<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-c1">str</span>(value)

<span class="pl-c"># simple callback syntax</span>
<span class="pl-en">@semisync</span>(<span class="pl-v">callback</span><span class="pl-k">=</span>output)
<span class="pl-k">def</span> <span class="pl-en">revenue</span>():
    <span class="pl-c"># simulated api call</span>
    sleep(random())
    shared.revenue <span class="pl-k">=</span> randint(<span class="pl-c1">1</span>, <span class="pl-c1">1000</span>)
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Revenue<span class="pl-pds">"</span></span>, shared.revenue

<span class="pl-en">@semisync</span>(<span class="pl-v">callback</span><span class="pl-k">=</span>output)
<span class="pl-k">def</span> <span class="pl-en">expenses</span>():
    <span class="pl-c"># simulated api call</span>
    sleep(random())
    shared.expenses <span class="pl-k">=</span> randint(<span class="pl-c1">1</span>, <span class="pl-c1">500</span>)
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Expenses<span class="pl-pds">"</span></span>, shared.expenses

<span class="pl-c"># will run only when revenue() and expenses() have completed</span>
<span class="pl-en">@semisync</span>(<span class="pl-v">callback</span><span class="pl-k">=</span>output, <span class="pl-v">dependencies</span><span class="pl-k">=</span>[revenue, expenses])
<span class="pl-k">def</span> <span class="pl-en">profit</span>():
    shared.profit <span class="pl-k">=</span> shared.revenue <span class="pl-k">-</span> shared.expenses
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Profit<span class="pl-pds">"</span></span>, shared.profit

<span class="pl-c"># queue function calls</span>
revenue()
expenses()
profit()

<span class="pl-c"># executes queued calls semi-synchronously</span>
semisync.begin()</pre></div>

<p>To repeat the process, simply clear the cache of function calls by using semisync.clear() after each iteration</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">range</span>(<span class="pl-c1">10</span>):
    revenue()
    expenses()
    profit()
    semisync.begin()
    semisync.clear()</pre></div>

<p>In this simple example, moving from synchronous to semi-synchronous execution cuts the average execution time from 1.00 seconds to .700 seconds.  And although the example used is trivial, dependency trees can be arbitrarily complex.</p>

<h2><a id="user-content-additional-notes-" class="anchor" href="#additional-notes-" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Additional Notes </h2>

<p>In order to make the module more flexible, few assumptions are made about how you choose to deal with shared data.  Although Manager() from the multiprocessing library is used in the example, you're free to use whatever format you desire.  You're also in charge of locking shared data if multiple processes access the same variable.  With great flexibility comes great responsibility.  </p>
</article>
  </div></body></html>