<html><body><div><div class="topic-content text col-lg-6 col-md-9" itemprop="articleBody">
<blockquote><b>Preface<br/>
</b>Hi! My name is <a href="https://github.com/borzunov">Alexander Borzunov</a>. This article is the translation of my <a href="http://habrahabr.ru/post/236689/">original publication</a>. Sharing my work with English-speaking community and happy to answer all the questions.</blockquote><p>Suppose we want to calculate a tenth million Fibonacci number with a program in Python. The function using a trivial algorithm will be calculating it for more than 25 minutes on my PC. But if we apply a special optimizing decorator, the function will give you the answer in just 18 seconds. (85 times faster):</p><p><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2014/12/26/372ba006f6.png" title="Fibonacci number" class="image-center" alt="Fibonacci number" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/></p><p>The thing is that before the program execution Python interpreter compiles all its parts into a special byte-code. Using the method I came across recently, the decorator analyzes the function byte-code and tries to optimize the algorithm applied there. You will see that this optimization can speed up the program not by a factor of n times, but <i>asymptotically</i>. The bigger the number of iterations in a loop is, the more times the optimized function (in contrast to the initial one) speeds up. </p><p>This article tells about when and how the decorator manage to make such optimization. You will also be able to download and test <i>cpmoptimize</i> library containing the decorator.</p><h2>Theory</h2><p>Some time ago I came across an <a href="http://kukuruku.co/hub/algorithms/using-the-quick-raise-of-matrices-to-power-to-write-a-very-fast-interpreter-of-a-simple-programming-language">interesting article describing an interpreter of a limited language</a> that supported the following operations:</p><pre class="prettyprint"><code># Assign a variable or a constant to another variable 
x = y
x = 1

# Add up or subtract a variable or a constant from another variable   
x += y
x += 2
x -= y
x -= 3

# Multiply a variable by a constant 
x *= 4

# Start a loop with a constant number of iterations 
loop 100000
    ...
end</code></pre><p>Values of variables in this language should be numbers. Their size is not limited (<a href="https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic">arbitrary-precision arithmetic</a> is supported). Actually, the variables are stored as whole numbers in Python. It switches to the mode of arbitrary-precision arithmetic in case if the number goes beyond the hardware-supported 4- or 8-byte type. </p><p>Let’s review the case, in which arbitrary-precision arithmetic is not used. The execution time of an operation will not depend on variable values and therefore all the iterations in the loop will have the same execution time. If we execute such code in a direct way, like in regular interpreters, the loop will take <img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/05/ebdbbf5ff9.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/>, in which <i>n</i> is the number of iterations. In other words, if the code for <i>n</i> iterations takes <i>t</i> time, then the code for <i>n</i><sup>2</sup> iterations will take <i>nt</i> time (see <a href="https://en.wikipedia.org/wiki/Time_complexity">time complexity</a>).</p><p>The interpreter from the <a href="http://kukuruku.co/hub/algorithms/using-the-quick-raise-of-matrices-to-power-to-write-a-very-fast-interpreter-of-a-simple-programming-language">original article</a> represents each operation with variables in the form of a matrix, which is multiplied by a vector with initial values of variables.  As a result of multiplication, we will get a vector with new variable values:</p><p><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/05/e773055417.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/></p><p>Thus, to perform a sequence of operations, we should multiply a vector by a matrix that corresponds to the next operation. Another way — we can first multiply matrices by each other and then multiply the initial vector by the obtained product:</p><p><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/05/8abf5a5f35.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/></p><p>To execute the loop, we should compute <i>n</i> — the number of iterations in the loop, and <i>B</i> matrix — a consequent multiplication of matrices that correspond to iterations from the loop body. Then we should multiply the initial vector by <i>B</i> matrix <i>n</i> times. Another way is to raise <i>B</i> matrix to the power of <i>n</i> and then multiply the vector with variables by the obtained result:</p><p><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/07/df54475745.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/></p><p>When using the <a href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">binary exponentiation</a> algorithm we can reduce the runtime of a loop to <img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/07/679ca97d06.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/>. If the code for <i>n</i> iterations operates in <i>t</i> time, then the code for <i>n<sup>2</sup></i> iterations will operate in <i>2t</i> time (it’s only two times slower, but not <i>n</i> times, like in the previous case).</p><p>As a result, the bigger the number of iterations in <i>n</i> loop is, the bigger number of times the optimized function speeds up. Therefore, the effect from optimization will be well noticed for big <i>n</i>. </p><p>If we do use arbitrary-precision arithmetic, time estimations can be wrong. For example, when computing the <i>n<sup>th</sup></i> Fibonacci number, variable values will become greater from iteration to iteration. Thus, operations containing them will slow down. It’s more complicated to execute the asymptotical estimation of the program execution time. We would have to take into account the length of numbers in variables during each iteration, as well as used methods of number multiplications. Therefore, we are not going to review it here. Nevertheless, after applying this method of optimization, asymptotics worsens even in this case. You can see it on the chart below:</p><p><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/07/4c5f67d82b.png" class="image-center" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/></p><h2>The Idea</h2><p>If dozens of years ago a programmer would have to multiply a variable by 4, he would use not the multiplication operator, but its faster equivalent — a left bit shift operation performed twice. Nowadays compilers themselves can make similar optimizations. In efforts to shorten the development time, there appeared languages with a high level of abstraction, as well as new handy technologies and libraries. When writing programs, developers spend most of their time explaining the computer <i>what</i> programs should do (multiply a number by 4), but not <i>how</i> to make things more efficient (bitwise operation). Thus, the task of creating efficient code is partially given to compilers and interpreters.</p><p>So far, compilers can replace various operations with more efficient ones. They can also predict expression values and delete or swap parts of the code. However, compilers do not replace the computational algorithm, written by a human, by a more asymptotically efficient one.</p><p>In practice, it’s quite problematic to use the implementation of a method described in the mentioned above article, as we would have to rewrite part of the code in a special language. As for interacting with this code, we would have to run an exterior script with an interpreter. However, the author proposes to use its expertise into practice in optimizing compilers. I tried to implement this method to optimize programs in Python, in the form that is suitable for use in real projects.</p><p>Using my library it will be enough just to write one line of code before the function you want to optimize. You’d have to use a special decorator for that purpose. It optimizes loops, if possible, and will not “break” the program under any circumstances. </p><h2>Use Cases</h2><p>Let’s take a look at some examples the decorator may come in handy. </p><h3>Case #1. Long Loops</h3><p>Suppose there is a sequence corresponding to the rule that you can see on the chart. We are to compute the <i>n<sup>th</sup></i> member of the sequence:</p><p><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/07/182bf9480d.png" class="image-center" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/></p><p>Intuitively, the way another sequence member appears is quite clear. However, we need time to derive and prove an appropriate mathematic expression. Nevertheless, we can write a trivial algorithm describing our rule, and then tell our computer to think out the way of a fast computation of the task:</p><pre class="prettyprint"><code>from cpmoptimize import cpmoptimize, xrange
@cpmoptimize()
def f(n):
    step1 = 1
    step2 = 1
    res = 1
    for i in xrange(n):
        res += step2
        step2 += step1
        step1 += 1
    return res</code></pre><p>It is interesting that if we run this function for <i>n</i>=10<sup>1000</sup>, there will be started a loop with 10<sup>1000</sup> iterations. Without optimizing, this function could not finish its work in any conceivable interval of time. But a decorator will help us to execute it in less than a second. In addition, it will return a correct result.</p><h3>Case #2. Fibonacci Numbers</h3><p>To compute the <i>n</i><sup>th</sup> Fibonacci number, there is a fast and non-trivial algorithm based on the idea of raising a matrix to power. An experienced engineer can implement it in a few seconds. If the code, that makes similar calculations, does not have to operate fast (for example, when it’s required to compute a Fibonacci number just once, with a number being less than 10 thousands), the developer is likely to save efforts and write a classical solution in few seconds. </p><p>But if a program is to run fast, either we will have to use all of our efforts and write a complex algorithm, or we can utilize the method of automatic optimization and apply the decorator to our function. If <i>n</i> is quite big, programs’ performance will be almost the same in both cases. But the developer will save his time in the second case. </p><p>Below are the charts and tables, so you will be able to compare operation time of the described methods for small and big <i>n</i>.</p><p>We should say that there is another algorithm to compute Fibonacci numbers, which is known as <a href="http://www.nayuki.io/page/fast-fibonacci-algorithms">fast doubling</a>. It beats the previous algorithms in time, as it has no unnecessary number additions and multiplications. You can compare the time of calculations via this algorithm as well. See some charts below. </p><p><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/07/e544c0badd.png" title="Fibonacci" class="image-center" alt="Fibonacci" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/></p><p><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/07/02e38490ab.png" title="Fibonacci" class="image-center" alt="Fibonacci" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/></p><p>Time measurement results:</p><pre class="prettyprint"><code>Function "fib":
(*) Testcase "big":
+--------+----------+--------------+--------------+--------------+-------+
|  arg   | naive, s |    cpm, s    | matrices, s  | fast dbl, s  | match |
+--------+----------+--------------+--------------+--------------+-------+
|      0 |     0.00 | 0.00         | 0.00         | 0.00         |  True |
|  20000 |     0.01 | 0.00  (2.5x) | 0.00  (3.0x) | 0.00  (5.1x) |  True |
|  40000 |     0.03 | 0.01  (5.7x) | 0.00  (1.8x) | 0.00  (4.8x) |  True |
|  60000 |     0.06 | 0.01  (7.9x) | 0.01  (1.4x) | 0.00  (4.8x) |  True |
|  80000 |     0.11 | 0.01  (9.4x) | 0.01  (1.3x) | 0.00  (4.6x) |  True |
| 100000 |     0.16 | 0.01 (11.6x) | 0.01  (1.1x) | 0.00  (4.5x) |  True |
| 120000 |     0.23 | 0.02 (11.8x) | 0.02  (1.2x) | 0.00  (4.7x) |  True |
| 140000 |     0.32 | 0.02 (14.7x) | 0.02  (1.1x) | 0.00  (4.1x) |  True |
| 160000 |     0.40 | 0.03 (13.1x) | 0.03  (1.2x) | 0.01  (4.6x) |  True |
| 180000 |     0.51 | 0.03 (14.7x) | 0.03  (1.1x) | 0.01  (4.4x) |  True |
| 200000 |     0.62 | 0.04 (16.6x) | 0.03  (1.1x) | 0.01  (4.4x) |  True |
| 220000 |     0.75 | 0.05 (16.1x) | 0.04  (1.1x) | 0.01  (4.9x) |  True |
| 240000 |     0.89 | 0.05 (17.1x) | 0.05  (1.0x) | 0.01  (4.7x) |  True |
| 260000 |     1.04 | 0.06 (18.1x) | 0.06  (1.0x) | 0.01  (4.5x) |  True |
| 280000 |     1.20 | 0.06 (20.2x) | 0.06  (1.0x) | 0.01  (4.2x) |  True |
| 300000 |     1.38 | 0.07 (19.4x) | 0.07  (1.1x) | 0.02  (4.4x) |  True |
+--------+----------+--------------+--------------+--------------+-------+</code></pre><p>In practice, we may face with a more complicated situation, if instead of the well-known recurrence formula<br/>
</p><p><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/07/7f0b041e10.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/></p><p>a sequence of numbers is defined by a more complex one, like this:</p><p><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/07/966e8f342c.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/></p><p>We will not be able to find implementation of the mentioned above algorithms on the Internet. We would also have to spend plenty of time on deriving an algorithm of raising matrices to power. However, we can write a nice brute force solution and apply a decorator. In this case, the computer will derive a quick algorithm for us: </p><pre class="prettyprint"><code>from cpmoptimize import cpmoptimize
@cpmoptimize()
def f(n):
    prev3 = 0
    prev2 = 1
    prev1 = 1
    for i in xrange(3, n + 3):
        cur = 7 * (2 * prev1 + 3 * prev2) + 4 * prev3 + 5 * i + 6
        prev3, prev2, prev1 = prev2, prev1, cur
    return prev3</code></pre><h3>Case #3. The Geometric Progression Sum</h3><p>Suppose we need to compute the <i>count</i> sum of geometrical progression members. The first member of the progression is <i>start</i>, the denominator is <i>coeff</i>. The decorator can optimize our trivial solution:</p><pre class="prettyprint"><code>from cpmoptimize import cpmoptimize
@cpmoptimize()
def geom_sum(start, coeff, count):
    res = 0
    elem = start
    for i in xrange(count):
        res += elem
        elem *= coeff
    return res</code></pre><p><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/07/bd81604aad.png" title="Geometric progression sum" class="image-center" alt="Geometric progression sum" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/></p><h3>Case #4. Raising to Power</h3><p>Suppose we are to raise <i>a</i> number to a non-negative integer power of <i>n</i>. The decorator will actually replace the trivial solution with the algorithm of binary exponentiation. </p><pre class="prettyprint"><code>from cpmoptimize import cpmoptimize
@cpmoptimize()
def power(a, n):
    res = 1
    for i in xrange(n):
        res *= a
    return res</code></pre><p><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/07/b653dab5d5.png" class="image-center" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/></p><h2>How to Install</h2><p>You can use <a href="https://pip.readthedocs.org/en/latest/">pip</a> to install the library:</p><pre class="prettyprint"><code>sudo pip install cpmoptimize</code></pre><p>The source code is available on <a href="https://github.com/borzunov/cpmoptimize">github</a> under a free MIT license. </p><p><a href="https://pypi.python.org/pypi/cpmoptimize">The library is also available on the Python Package Index</a>.</p><p>Examples of optimization application are in "<i>tests/</i>" folder. Each example consists of a function representing a brute-force solution, as well as its optimized variant, and also functions representing complex, but fast solutions of the given task. These functions are placed in scripts that start them on various groups of tests, and also measure their execution time, and build appropriate charts. If you have <a href="http://matplotlib.org/">matplotlib</a>, the scripts will also build the plots that depend on execution time and input data (regular or logarithmic). All the plots will be saved in "<i>tests/plots/</i>" folder. </p><h2>The Library Description</h2><p>When creating the library, I used the fact that the byte-code of the program, that is created by Python interpreter, can be analyzed and modified during the runtime without interfering with the interpreter. This provides huge opportunities as for the language extension. Advantages of this method usually show themselves when we use arbitrary-precision arithmetic that is also built-in in Python.</p><p>That’s why implementation of the described optimization in Python has become a more interesting task for me. Its use in C++ compilers would definitely allow to create even faster programs. Besides, optimized by the decorator, the code in Python usually excels the brute-force code in C++, thanks to better asymptotics. </p><p>When modifying the byte-code, I used <a href="https://pypi.python.org/pypi/byteplay/0.2">byteplay</a> module, which provides a nice interface to disassembly and assembly the byte-code. Unfortunately, they have not ported the module to Python 3. That's why I implemented the whole project in Python 2.7.</p><p><b><i>cpmoptimize</i></b> library name stands for "<i><b>c</b>ompute the <b>p</b>ower of a <b>m</b>atrix and <b>optimize</b></i>". We are not going to review the process of analyzing the byte-code in details. But I am going to describe possibilities provided by the library and principles its operation is based on. </p><h3>Own xrange</h3><p>cpmoptimize.<b>xrange</b>(stop)</p><p>cpmoptimize.<b>xrange</b>(start, stop[, step])</p><p>For optimization purposes, the inbuilt <i>xrange</i> type in Python 2 does not support <i>long</i> type integers as arguments: </p><pre class="prettyprint"><code>&gt;&gt;&gt; xrange(10 ** 1000)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
OverflowError: Python int too large to convert to C long</code></pre><p>Since the loops with about 10<sup>1000</sup> iterations execute in less than a second and can become a regular thing in a program, the library provides its own implementation of <i>xrange</i> type in pure Python (internally called <i>CPMRange</i>). It supports all the features of a regular <i>xrange</i> and, in addition, the arguments of type <i>long</i>. Such code will not lead to errors and will compute the right result very fast: </p><pre class="prettyprint"><code>from cpmoptimize import cpmoptimize, xrange
@cpmoptimize()
def f():
    res = 0
    for i in xrange(10 ** 1000):
        res += 3
    return res
print f()</code></pre><p>However, if the amount of iterations is not big, you can keep using the inbuilt <i>xrange</i> together with the decorator. </p><h3>cpmoptimize Function</h3><p>cpmoptimize.<b>cpmoptimize</b>(<i>strict</i>=False, <i>iters_limit</i>=5000, <i>types</i>=(int, long), <i>opt_min_rows</i>=True, <i>opt_clear_stack</i>=True)</p><h3>Applying the Decorator</h3><p><i>cpmoptimize</i> function accepts parameters of the derived optimization and returns the decorator that takes these parameters into account. Returned decorator should be applied to the function being optimized. We can do it by using a special syntax (the “at” sign, but we can also do without it): </p><pre class="prettyprint"><code>from cpmoptimize import cpmoptimize
@cpmoptimize()
def f(n):
    # Some code
def naive_g(n):
    # Some code
smart_g = cpmoptimize()(naive_g)</code></pre><p>Before making changes to the byte-code, initial function is being copied. Thus, <i>f</i> and <i>smart_g</i> functions in the above code will be optimized, but <i>naive_g</i> will not. </p><h3>Searching for <i>for</i> Loops</h3><p>The decorator looks for standard <i>for</i> loops in the byte-code, but at the same time it ignores the <i>while</i> and <i>for</i> loops inside generator and list expressions. Nested loops are not supported for now (the most internal loop is optimized). <i>for-else</i> are processed correctly.</p><h3>Valid Types</h3><p>The decorator can not optimize a loop with no regard of types of variables used in it. For example, Python allows to define a type, which will write a string into a file after each multiplication. As a result of optimization, the number of performed multiplications in the function could change. Thus, the number of lines in the file would become different and optimization would “break” the program. </p><p>Besides, variables are not added and multiplied implicitly during operations with matrices and that’s why variable types can “get mixed up”. If one of constants or variables was of <i>float</i> type, variables that were to get <i>int</i> type after the code execution could also become <i>float</i> (<i>int</i> and <i>float</i> addition returns <i>float</i>). Such behavior can cause errors in the program, which is unacceptable. </p><p>To avoid unwanted side effects, the decorator optimizes the loop only in case of all constants and variables used in it are of an acceptable type. <i>int</i> and <i>long</i> types are initially valid, as well as types inherited from them. If one of constants or variables is of <i>long</i> type, those variables to become of <i>int</i> type after the code execution, can also get <i>long</i> type. But since <i>int</i> and <i>long</i> are quite interchangeable types in Python, this should not lead to an errors. </p><p>If you want to change the set of acceptable types (for example, to support <i>float</i>), pass a tuple of necessary types in <b><i>types</i></b> parameter. The types from this tuple (or the types that were inherited from the types of that tuple) will be treated as acceptable. In practice, to check whether any <i>value</i> is of acceptable type, we should use <i>isinstance(value, types)</i> expression. </p><h3>Loop Optimization Conditions</h3><p>Each found loop should meet some conditions. Some of them have already checked after the application of a decorator:</p><ol><li>The loop body should contain only assignment operators, unary and binary operations, which can be combined into complex expressions. The body cannot contain conditions, other functions’ calls, <i>return</i> and <i>yield</i> operators, etc.<br/>
</li><li>A condition of <i>predictability</i> can be required from operands: their value should be the same after each iteration and it should not depend on the result of any kind of calculations from the previous iteration. In addition:</li></ol><ul><li>All addition and subtraction operands, as well as the unary minus operand, can be unpredictable.</li><li>At least one multiplication operand should be predictable. (Similarly to the way the original interpreter only supported multiplication by a constant).</li><li>All power operands, division operators, modulo and bitwise operations should be predictable.</li></ul><li>All the constants used in the loop, should be of acceptable type.<br/>
</li><p>If all the conditions are met, there will be set a “hook” before the loop, which will check the other part of conditions. The original byte-code of the loop will not be deleted. Since Python provides dynamic typing, we can check the following conditions just before the loop starts: </p><ol><li>The object traversed by the loop, should be of <i>xrange</i> standard type or its alternative from <i>cpmoptimize.xrange</i> library. The slow <i>range</i> function that returns a list is not supported.<br/>
</li><li>Values of all the variables used in the loop have a valid type.<br/>
</li></ol><p>If the “hook” has concluded that optimization is possible, then all the required matrices will be calculated, and values of variables being used will change to a new ones. If the optimization is not possible, then the original byte-code of the loop will be in use. </p><h3>Expressions. Moving the Code Outside of the Loop </h3><p>Despite the fact that the described method does not support exponential and “bitwise AND” operations, the following code will be optimized:</p><pre class="prettyprint"><code>@cpmoptimize()
def f(n, k):
    res = 0
    for i in xrange(n):
        m = 3
        res += ((k ** m) &amp; 676) + i
    return res</code></pre><p>When analyzing the byte-code, the decorator will draw a conclusion that all the values of <i>k</i> and <i>m</i> variables in <i>(k ** m) &amp; 676</i> expression do not depend on the loop iteration they are used in, which means that values of the whole expression does not change either. It’s not necessary to calculate it during each iteration. We can just calculate this value once. </p><p>Thus, we can move corresponding instructions of the byte-code and execute them right before the loop start by substituting the ready-value into the loop. So the optimized version of the same code could look like this: </p><pre class="prettyprint"><code>@cpmoptimize()
def f(n, k):
    res = 0
    m = 3
    _const1 = (k ** m) &amp; 676
    for i in xrange(n):
        res += _const1 + i
    return res</code></pre><p>This technique is known as the <a href="https://en.wikipedia.org/wiki/Loop-invariant_code_motion">loop-invariant code motion</a>. Please note that the moved values are calculated each time you start the function, as they can depend on volatile global variables or function parameters (like <i>_const1</i> depends on <i>k</i> parameter in the example). Now, we can easily optimize the obtained code with the help of matrices. </p><p>At this stage, the described above check of values predictability is carried out. </p><p>For instance, if one of “bitwise AND” operands would turn out to be unpredictable, we would not be able to move this operation outside of the loop. Thus, we would not be able to apply optimization. </p><p>The decorator also partially supports multiple assignments. If there are few elements in them, Python creates supported by the decorator byte-code without the use of tuples: </p><pre class="prettyprint"><code>a, b = b, a + b</code></pre><h3>iters_limit</h3><p>On the chart above you can see that with a small number of iterations, optimized loop may run slower than usual, as in this case, some time is still required to construct matrices and check types. When it is necessary for the function to work as fast as possible even with a small number of iterations, we can define a limit by <i><b>iters_limit</b></i> parameter. Then before starting the optimization, the “hook” will check the number of iterations the loop is about to make and will cancel the optimization, if this number does not exceed the defined threshold.</p><p>Default limit is 5,000 iterations. It cannot be less than 2 iterations. </p><p>It’s clear that the most advantageous limit value is the point of the intersection of lines on the chart. The lines correspond to operation time of the optimized variant of the function and the naive one. In this case, if we set the limit value to 10,000, the function will be able to choose the most advantageous algorithm (optimized or the naive one):</p><p><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/09/5dff58253c.png" class="image-center" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/></p><h3>strict Flag</h3><p>In some cases, it’s strictly required to apply optimization. If a loop has 10<sup>1000</sup> iterations, the program will just hang without optimization. Fortunately, there is a <b><i>strict</i></b> parameter for such cases. Its default value is <i>False</i>, but if we set it to <i>True</i>, then in case if any of standard <i>for</i> loops has not been optimized, it will raise an exception. </p><p>If optimization inapplicability has been detected when applying the decorator, <i>cpmoptimize.recompiler.RecompilationError</i> exception will be thrown. Two unpredictable variables are multiplied in the given example:</p><pre class="prettyprint"><code>&gt;&gt;&gt; from cpmoptimize import cpmoptimize
&gt;&gt;&gt;
&gt;&gt;&gt; @cpmoptimize(strict=True)
... def f(n, k):
...     res = 0
...     for i in xrange(n):
...         res += i * res
...     return res
... 
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "cpmoptimize/__init__.py", line 100, in upgrade_func
    index += analyze_loop(settings, code, index) + 1
  File "cpmoptimize/__init__.py", line 59, in analyze_loop
    raise err
cpmoptimize.recompiler.RecompileError: Multiplication of two unpredictable values is unsupported</code></pre><p>If the fact of optimization inapplicability has been detected before the loop started (meaning that value types of iterator or variables are not supported), it will trigger TypeError exception: </p><pre class="prettyprint"><code>&gt;&gt;&gt; from cpmoptimize import cpmoptimize
&gt;&gt;&gt;
&gt;&gt;&gt; @cpmoptimize(strict=True)
... def f(iterable):
...     res = 0
...     for elem in iterable:
...         res += elem
...     return res
... 
&gt;&gt;&gt; f(xrange(30))
435
&gt;&gt;&gt; f(range(30))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 4, in f
  File "cpmoptimize/hook.py", line 170, in exec_loop
    raise err
TypeError: Iterator in optimized loops must have type "xrange" instead of &lt;type 'list'&gt;</code></pre><h3>Additional Optimization Options</h3><p><i>opt_min_rows</i> and <i>opt_clear_stack</i> flags are responsible for additional optimization methods when constructing matrices. They are enabled by default and the possibility of disabling them is just for demonstration purposes only (so that we could compare efficiency of these methods). </p><p>When executing the optimized code, multiplication of long numbers in some cells of generated matrices takes most of the time. Compared to this time consuming process, the time spent on the multiplication of all the other cells is negligible.</p><p>When recompiling expressions, the decorator creates intermediate, <i>virtual</i> variables that are in charge of positions of the interpreter stack. After complex calculations, they can contain long numbers that are already saved in some other, real variables. We do not need to store these values one more time, but they are kept in cells of the matrix and slow down operation of the program essentially, as we have to multiply these long numbers when multiplying matrices. <b><i>opt_clear_stack</i></b> option is responsible for clearing such variables: if we assign zero to them after the use, there will be no long values in them. </p><p>This option is especially essential, when a program works with really big numbers. Eliminating redundant multiplications allows to speed up the program more than twice.</p><p><i><b>opt_min_rows</b></i> option enables the minimization of the size of square matrices we multiply. It excludes series corresponding to unused and unpredictable variables. If we do not use the loop variable itself, it will also exclude series being in charge of supporting its correct value. Not to affect the program operation, all these variables will be assigned with correct end values after the loop. In the original article, there was an element equal to one that was added to the vector of variables. If the series corresponding to this element turns out to be unused, it will also be excluded. </p><p>This option can somewhat speed up the program for not a really big <i>n</i>, when numbers have not become really long and the sizes of matrix bring in an essential contribution during the program runtime. </p><p>If we apply the two options at the same time, virtual variables will become of predictable (zero) value and <i>opt_min_rows</i> will work even more efficiently. In other words, efficiency of the two options is better than efficiency of each of them taken separately. </p><p>The chart below demonstrates the runtime to calculate Fibonacci numbers when some or other options are disabled:</p><p>-m means that the <i>opt_min_rows</i> option is disabled;<br/>
-c means that the <i>opt_clear_stack</i> option is disabled;<br/>
-mc means that both <i>opt_min_rows</i> and <i>opt_clear_stack</i> options are disabled.</p><p><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/09/e4283a12b5.png" class="image-center" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/></p><h2>What Else Can We Implement?</h2><h3>Changing the Set of Operations </h3><p>Let’s say that our method <i>supports a pair of </i><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/10/1ef26ef0d2.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/> <i>operations</i>, if</p><ul><li>we can perform an <img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/10/8e69ca1911.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/> operation either for two variables, or for a variable and a constant;</li><li>we can perform an <img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/10/bef2081820.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/> operation for a variable and a constant.</li></ul><p>We already know that the method supports a pair of <img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/10/4c41dfd52e.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/> operations. And really:</p><ul><li>we can add either two variables, or a variable and a constant;<br/>
</li><li>we can multiply a variable by a constant.<br/>
</li></ul><p>For the time being, these operations are implemented in the optimizing decorator. But it turns out that the described method also supports other pairs of operations, including <img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/10/b84d26db7b.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/> (a pair of multiplication and exponentiation).</p><p>Suppose our task is to find the <i>n</i><sup>th</sup> number in a sequence defined by a recurrence relation:</p><p><img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/10/d493dc6ad8.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/></p><p>If our decorator supported a pair of <img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/10/a6d49b3286.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/> operations, we could multiply a variable by another variable (but we would not be able to add variables). In this case, the decorator could optimize the following trivial solution of the task:</p><pre class="prettyprint"><code>def f(n):
    a = 1
    b = 1
    for i in xrange(n):
        a, b = b, a * b
    return a</code></pre><p>We can prove that our method supports <img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/10/71c5dfb14b.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/>, <img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/10/55a738b306.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/> and <img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/10/1d576ada0c.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/> pairs of operations (<i>and</i> here is the bitwise AND, <i>or</i> is the bitwise OR). In case of positive numbers, we can also work with <img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/10/830a87fa11.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/> and <img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/10/308be70572.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/> pairs of operations.</p><p>To implement the support of <img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/10/d9e7cb5db5.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/> operations, we can operate not with variable values, but with logarithms of these values. Then variables multiplication will be replaced with logarithms addition. As for raising a variable to a constant power, it will be replaced with logarithm multiplication by a constant. Thus, we will lead the task to the already implemented case with <img pagespeed_lazy_src="http://kukuruku.co/uploads/images/00/00/01/2015/01/10/2a9ad5843d.png" src="/mod_pagespeed_static/1.JiBnMqyl6S.gif"/> operations.</p><p>As for implementing the support of the other mentioned pairs of operations, its explanation contains a number of computations and is worth writing a separate article about it. For now, we should just mention that pairs of operations are interchangeable to some extent. </p><h4>Nested Loops</h4><p>After refining the algorithm of loops analysis in the byte-code, we can implement the support for nested loops, so that we could optimize the code similar to this:</p><pre class="prettyprint"><code>def f():
    res = 0
    for i in xrange(10 ** 50):
        for j in xrange(10 ** 100):
            res += i * 2 + j
    return res</code></pre><h4>Predictable Conditions</h4><p>In the following code the condition in the loop body is predictable. We can also check before the beginning of the loop, whether it’s true, and remove the unreachable branch of the code. After that, we can optimize the code: </p><pre class="prettyprint"><code>def f(mode):
    res = 0
    for i in xrange(10 ** 50):
        if mode == 1:
            res += 3
        else:
            res += 5
    return res</code></pre><h2>Summary</h2><p>Actually, Python interpreter creates unpredictable byte-code that quite corresponds to the initial code you wrote. Normally, it produces neither function embedding, nor loop unfolding, and no other optimizations requiring the analysis of program’s behavior. And only after 2.6 CPython learnt how to fold constant arithmetic expressions. And still, it does not always work well. </p><p>There are few reasons for that. First of all, in the general case, the code analysis in Python is complicated. We can trace data types during the runtime only (that’s exactly what we do in our case). Secondly, optimizations prevent Python from reaching the speed of purely compiled languages. Therefore, when a program needs to work really fast, it’s suggested to write it in a lower-level language. </p><p>However, Python is a flexible language allowing to implement many optimization methods without interfering in the interpreter. The given library, as well as other projects, demonstrates this ability. </p><h2>Useful Links</h2><p>Here are some interesting projects related to various optimizations in Python:</p><ol><li><a href="http://pypy.org/">PyPy</a> is an alternative Python interpreter supporting <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">JIT compilation</a>. As a rule, it allows to execute programs in Python faster. PyPy is written in RPython language.<br/>
</li><li><a href="http://www.pyston.org/">Pyston</a> is a new alternative Python interpreter. It translates code into an intermediate LLVM form, from which it can be optimized by LLVM means and executed using JIT compilation.<br/>
</li><li><a href="http://nuitka.net/">Nuitka</a> is a Python compiler. In contrast to py2exe converter that creates an *.exe file containing the script, the interpreter and necessary libraries, Nuitka <i>really</i> compiles programs in Python into ready executable files.<br/>
</li><li><a href="https://code.google.com/p/wpython2/">WPython</a> is a modified Python 2.6.4 interpreter with a more efficient model of the byte-code, a smart system of folding constants and a virtual machine.<br/>
</li><li><a href="https://bitbucket.org/haypo/astoptimizer">astoptimizer</a> is a library applying known optimization methods before compiling to byte-code by means of analyzing and changing an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract syntax tree</a>.<br/>
</li><li><a href="https://pypi.python.org/pypi/promise/">promise</a> is a library optimizing the byte-code, relying on the so-called “promises”. If a programmer promises not to make some sort of operations in his code, it becomes possible to apply optimizations that would be inapplicable in the general case.<br/>
</li><li><a href="http://forums.synapse-wireless.com/showthread.php?t=4655">foldy.py</a> is a library, which analyzes the byte-code and performs constant folding, meaning replacing constant expressions with their values, and also deleting unusable functions.<br/>
</li><li><a href="http://code.activestate.com/recipes/277940-decorator-for-bindingconstants-at-compile-time/">The Decorator</a> — analyzes the byte-code and performs constant binding, i.e. replaces the search of value of a constant global variable by name with the direct load of a corresponding constant.</li><li><a href="http://www.numpy.org/">NumPy</a> is a library (with modules for Python that are written in C) that can make fast computations with big arrays and matrices, and also use a vast set of the high-level mathematic functions.</li><li><a href="http://numba.pydata.org/">Numba</a> is a library that speeds up programs that contain mathematic calculations and operations with arrays. Optimization occurs thanks to JIT compilation (when using LLVM) that converts code to native CPU and GPU instructions.</li><li><a href="https://github.com/pydata/numexpr">Numexpr</a> is a library that increases the speed of computations of mathematic expressions via analyzing and changing the appropriate byte-code. Expressions can be split into several parts (where some of them can be recomputed less often than the other ones), gain in performance due to code paralleling and so on.</li><li><a href="http://cython.org/">Cython</a> is an optimizing compiler of Python language superset that allows to use static typing and to interact closely with the C/C++ code.</li><li><a href="http://www.phi-node.com/2013/01/just-in-time-compilers-for-number.html">An article about libraries that can accelerate various calculations in Python</a> via JIT compilation.</li><li><a href="https://code.google.com/p/shedskin/">shedskin</a> is an <i>experimental</i> compiler, that can translate pure, but implicitly statically typed Python (2.4-2.6) programs into optimized C++.</li><li><a href="https://github.com/cosmo-ethz/hope">hope</a> — Python JIT compiler for <b><i>astrophysical computations</i></b>.</li><li><a href="https://github.com/serge-sans-paille/pythran">pythran</a> is a python to c++ compiler meant to efficiently compile <i><b>scientific programs</b></i>, and takes advantage of multi-cores and SIMD instruction units.</li></ol>
</div>
</div></body></html>