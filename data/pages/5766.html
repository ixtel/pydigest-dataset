<html><body><div><div class="entry">
    <p>"Did I leave the <span>oven</span> on?"</p>

<p><img src="/images/did_i_leave_the_oven_on.jpg" alt="did_i_leave_the_oven_on"/></p>

<p>This question will sometimes pop up at the most inconvenient times.</p>

<p>Sometimes when you just left your house.<br/>
Sometimes on your way to work.<br/>
Sometimes on a plane while you're on your way for a long vacation...<br/></p>

<p>There are different solutions for this problem:</p>

<ol>
<li>The <a href="http://www.apartmenttherapy.com/did-i-leave-the-oven-on-try-th-131769">rubber band method</a></li>
<li>Saying / singing it out loud (like <a href="https://www.youtube.com/watch?v=vPN4XjrwD78">Samuel L. Jackson</a>)</li>
<li>Labeling your appliances or even making a checklist that includes the <span>oven</span> before leaving the house to a long vacation.</li>
</ol>

<p>Or, we can do something better...</p>

<p>In this tutorial we'll try the technical approach to the problem.</p>

<p>Full code can be found on <a href="https://github.com/kazuar/opencv_light_detection">Github</a>.</p>

<h1>Problem definition</h1>

<p>In our case, we need to decide on the signal that we'll use in order to determine if the <span>oven</span> is on / off.
In my kitchen, that signal is a red light on top of the text "<span>OVEN</span> ON".</p>

<p>When the red light is on, the <span>oven</span> is on:</p>

<p><img src="/images/oven_on.jpg" alt="oven_on"/></p>

<p>When the red light is off, the <span>oven</span> is off:</p>

<p><img src="/images/oven_off.jpg" alt="oven_off"/></p>

<h1>Prerequisites</h1>

<p>Make sure that on your machine you have the following:</p>

<ol>
<li>OpenCV 3.0</li>
<li>Python 2.7</li>
<li>Numpy 1.9</li>
</ol>

<h2>Installing OpenCV 3.0 + Python 2.7</h2>

<p>If you don't have OpenCV installed on your machine, start by following <a href="http://www.pyimagesearch.com/2015/06/15/install-opencv-3-0-and-python-2-7-on-osx/">Adrian Rosebrock's excellent tutorial</a> on installing OpenCV 3.0 and Python 2.7+ on OS X.
<a href="http://kazuar.github.io/opecv-python2/">I've added my own notes about the installation process</a>, in case you run into some issues in compiling OpenCV 3.0 on OS X.</p>

<h1>Process</h1>

<p>Based on the fact you were successfull in installing OpenCV on your environment, we will start the process of analyzing our data in order to determine if the <span>oven</span> is ON / OFF.</p>

<h2>Load the required packages</h2>

<ol>
<li>argparse - for argument handling.</li>
<li>numpy - a highly optimized library for numerical operations. OpenCV uses numpy for its array structures.</li>
<li>cv2 - OpenCV for processing images.</li>
</ol>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cv2</span></code></pre></div>

<h2>Loading the image</h2>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span></code></pre></div>

<h2>Reducing noise in the image</h2>

<p>We will want to smooth the input image in order to reduce the noise in the image. This will make it easier to detect objects in the image. For medianBlur we will use aperture size of 3. A higher value means that the image will be more blurry.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">blur_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">medianBlur</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span></code></pre></div>

<h2>Convert the image colors to HSV</h2>

<p>HSV - Hue, Saturation and Value (brightness). HSV will allow us to extract a colored object since it is easier to represent a color in HSV than in BGR.</p>

<p>Converting the image to HSV will allow us to identify a color in the image using the hue value (a single value instead of three).</p>

<p>This is how it's done:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">hsv_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">blur_image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2HSV</span><span class="p">)</span></code></pre></div>

<p>The code will result in the following image:</p>

<p><img src="/images/hsv_on.jpg" alt="hsv_on"/></p>

<h2>Detecting color in the image</h2>

<p>In order to decide on the color that we want to detect, we can look at the histogram of the color values in the image of the <span>oven</span> light.</p>

<p><img src="/images/image_color_hist.png" alt="image_color_hist"/>
<img src="/images/light_mask.png" alt="light_mask"/></p>

<p>We can see that the color red is dominant in the image. There are two peaks of red color - one in the low range and one in the high range. These color values are translated to hue in the range of 0 to 10 and 160 to 180 (for the color red).</p>

<p>For each hue range we will create a mask on the HSV image and remove everything that isn't in the selected range of the required color.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">create_hue_mask</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">lower_color</span><span class="p">,</span> <span class="n">upper_color</span><span class="p">):</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lower_color</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">upper_color</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
 
    <span class="c"># Create a mask from the colors</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
    <span class="n">output_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output_image</span>

<span class="c"># Get lower red hue</span>
<span class="n">lower_red_hue</span> <span class="o">=</span> <span class="n">create_hue_mask</span><span class="p">(</span><span class="n">hsv_image</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">])</span>

<span class="c"># Get higher red hue</span>
<span class="n">higher_red_hue</span> <span class="o">=</span> <span class="n">create_hue_mask</span><span class="p">(</span><span class="n">hsv_image</span><span class="p">,</span> <span class="p">[</span><span class="mi">160</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">179</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">])</span></code></pre></div>

<p>With the following results:</p>

<p><img src="/images/lower_hue.png" alt="lower_hue"/>
<img src="/images/higher_hue.png" alt="higher_hue"/></p>

<p>Next step is to merge these images together in order to catch all of the red hues:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">full_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">addWeighted</span><span class="p">(</span><span class="n">lower_red_hue</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">higher_red_hue</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span></code></pre></div>

<p>Which will have the following result:</p>

<p><img src="/images/full_hue.jpg" alt="full_hue"/></p>

<h2>Find circles in the image</h2>

<p>Now we have a picture with only the red hues in it, and we will want to identify whether the light is on (there is a circle of red hues) or the light is off (there is no circle).
We need to find the circles in the new image, but first we will need to convert the image to grayscale (since the input for HoughCircles is a grayscale image).</p>

<p>For detecting the circles in the image we will use the following parameters (from <a href="http://docs.opencv.org/3.0-beta/modules/imgproc/doc/feature_detection.html#houghcircles">OpenCV HoughCircles</a>):</p>

<ol>
<li>Grayscale input image</li>
<li>HOUGH_GRADIENT is the circle detection method (currently the only one).</li>
<li>Inverse ratio of the accumulator resolution to the image resolution. In this case, 1.2.</li>
<li>Minimum distance between the centers of the detected circles. In this case, 100.</li>
</ol>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Convert image to grayscale</span>
<span class="n">image_gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">full_image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

<span class="c"># Find circles in the image</span>
<span class="n">circles</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">HoughCircles</span><span class="p">(</span><span class="n">image_gray</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">HOUGH_GRADIENT</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span></code></pre></div>

<h1>Results</h1>

<p>At this point it will be enough to check if there are any circles.
If there are, it means that we have a signal that at least one of the <span>oven</span> lights is on.<br/>
If we couldn't find any circles it means that none of the lights are on and the <span>oven</span> is off.</p>

<p>To prove that, we can draw the circles on the original image with the following code:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Draw the circles on the original image</span>
<span class="n">circles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">circles</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">"int"</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span> <span class="ow">in</span> <span class="n">circles</span><span class="p">:</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span><span class="p">),</span> <span class="n">radius</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span></code></pre></div>

<p>The result will be:</p>

<p><img src="/images/original_image_with_circles.jpg" alt="original_image_with_circles"/></p>

<h1>Next steps</h1>

<p>There are many things that we can do from here, some examples are:</p>

<ol>
<li>Detect the specific light that is on and by that understanding the exact status of the <span>oven</span>.</li>
<li>Create a service that will allow us to check the status of the <span>oven</span> remotely.</li>
<li>Add this functionality to raspberry pi so we can have a small device that will alert us if the <span>oven</span> is off or on.</li>
</ol>

<p>Full code sample can be found on <a href="https://github.com/kazuar/opencv_light_detection">Github</a>.</p>

  </div>

  </div></body></html>