<html><body><div><code><pre><code class="python">OrderEvent:<br/>
<br/>

# execution.py

import datetime
import Queue

from abc import ABCMeta, abstractmethod
from event import FillEvent, OrderEvent</code></pre><br/>
<code>ExecutionHandler</code> похож на использованные ранее абстрактные базовые классы и содержит один <a href="https://en.wikipedia.org/wiki/Virtual_function#Abstract_classes_and_pure_virtual_functions">полностью виртуальный метод</a> <code>execute_order</code>:<br/>
<br/>
<pre><code class="python">
# execution.py

class ExecutionHandler(object):
    """
    Абстрактный класс ExecutionHandler обрабатывает взаимодействие между набором объектов приказов, сгенерированных Portfolio и полным набором объектов Fill, которые возникают на рынке.


    Обработчики могут быть использованы с симулированными брокерскими системами или интерфейсами реальных брокерских систем. Это позволяет тестировать стратегию аналогично работе над движком для реальной торговли. 
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def execute_order(self, event):
        """
        Берет событие Order и выполняет его, получая событие Fill, которе помещается в очередь Events. 

        Параметры:
        event - Содержит объект Event с информацией о приказе
        """
        raise NotImplementedError("Should implement execute_order()")
</code></pre><br/>
Для бэктестинга стратегий нужно симулировать процесс транзакции сделки. Простейшая из возможных реализаций подразумевает, что все приказы исполняются по текущей рыночной цене для любого объёма ценных бумаг, указанного в приказе. Совершенно очевидно, что так не бывает, поэтому чтобы сделать систему более реалистичной, лучше реализовать более сложные модели, учитывающие проскальзывание и другие рыночные факторы.<br/>
<br/>
Учтем, что событие <code>FillEvent</code> содержит значение <code>fill_cost</code> равное <code>None</code> (см. предпоследнюю строку в <code>execute_order</code>), поскольку мы уже позаботились о цене исполнения в объекте <code>NaivePortfolio</code> (он <a href="http://habrahabr.ru/company/itinvest/blog/266623/">описан</a> в прошлой статье). В более реалистичной реализации мы бы использовали значение рыночных данных “value”, чтобы получить реальную стоимость сделки.<br/>
<br/>
В нашем примере для тестирования используется биржа ARCA. Для реальной торговли конечная биржа будет оказывать важное влияние.<br/>
<br/>
<pre><code class="python">
# execution.py

class SimulatedExecutionHandler(ExecutionHandler):
    """
    Симулированный обработчик конвертирует все объекты приказов в их эквивалентные объекты Fill, автоматически и без задержки, проскальзывания и т.п. Это позволяет быстро протестировать стратегию в первом приближении перед разработкой более сложных реализаций обработчиков.

    """
    
    def __init__(self, events):
        """
        Инициализирует обработчик, устанавливает внутренние очереди событий. 

        Параметры:
        events - Очередь событий Event.
        """
        self.events = events

    def execute_order(self, event):
        """
        Просто наивно конвертирует объекты Order в объекты Fill, то есть не учитывается задержка, проскальзывание или количество акций в приказе, которые можно купить/продать по заданной цене.

        Параметры:
        event - Содержит объект Event с информацией о приказе.
        """
        if event.type == 'ORDER':
            fill_event = FillEvent(datetime.datetime.utcnow(), event.symbol,
                                   'ARCA', event.quantity, event.direction, None)
            self.events.put(fill_event)
</code></pre><br/>
На этом мы закончили разработку иерархий классов для нашего бэктестера. Теперь поговорим о том, как высчитывать метрики производительности для тестируемой стратегии.<br/>
<br/>
<h4>Метрики производительности</h4><br/>
В одной из <a href="http://www.quantstart.com/articles/Sharpe-Ratio-for-Algorithmic-Trading-Performance-Measurement">статей</a> Майк Халлс-Мур останавливался на понятии коэффициента Шарпа. Подсчитать его можно по следующей формуле:<br/>
<br/>
<img src="https://habrastorage.org/files/872/368/1aa/8723681aa02a42e5b9b54517e4ebf01d.png"/> <br/>
<br/>
Где R<sub>a</sub> это поток возврата кривой капитала, а R<sub>b</sub> — это бенчмарк, например показатель интереса или индекс.<br/>
<br/>
Максимальная просадка и длительность просадки — еще два показателя, которые инвесторы используют для оценки риска портфолио. Первый из них обозначает величину наибольшего снижения доступных средств, а второй описывает число торговых периодов, на протяжении которых это снижение длится.<br/>
<br/>
В нашем бэктестере будут использоваться коэффициент Шарпа и показатели максимальной просадки и ее длительности.<br/>
<br/>
<h4>Реализация на Python</h4><br/>
Для начала нужно создать файл <code>performance.py</code>, который хранит функции для подсчета коэффициента Шарпа и информацию о просадке. Как и в случае других наших классов, требующих большого объёма вычислений, нужно импортировать NumPy и Pandas:<br/>
<br/>
<pre><code class="python">
# performance.py

import numpy as np
import pandas as pd
</code></pre><br/>
Важно помнить о том, что коэффициент Шарпа — это отношение риска к вознаграждению. Он содержит один параметр, который будет корректироваться при учете большого количества торговых периодов для получения оценки за год.<br/>
<br/>
Обычно это число устанавливается на уровне 252 — количество торговых дней в США. Однако, если тестируемая стратегия предполагает торговлю на часовых интервалах, то нужно соответственно изменить коэффициент Шарпа, чтобы получить корректное значение для года. В данном случае нужно установить период так: 252 ∗ 6.5 = 1638 (количество торговых часов в США за год). Если торговля идет на минутном интервале, то нужно еще умножить все на 60: 252∗6.5∗60 = 98280.<br/>
<br/>
Функция <code>create_sharpe_ratio</code> оперирует объектом библиотеки Pandas Series под названием <code>returns</code> и просто подсчитывает отношение среднего значения процента прибыли и стандартного отклонения прибыли в процентах с учетом разного числа торговых периодов.<br/>
<br/>
<pre><code class="python">
# performance.py

def create_sharpe_ratio(returns, periods=252):
    """
    Создает коэффициент Шарпа для стратегии, основанной на бенчмарке ноль (нет информации о рисках ).

    Параметры:
    returns -  Series из Pandas представляет процент прибыли за период - Дневной (252), Часовой (252*6.5), Минутный (252*6.5*60) и т.п..
    """
    return np.sqrt(periods) * (np.mean(returns)) / np.std(returns)
</code></pre><br/>
Коэффициент Шарпа описывает, насколько большой риск (определенный стандартным отклонение цены активов) берется при работе с единицей инвестирования, а просадка определяется как наибольшее снижение объёма средства с максимума до минимума.<br/>
<br/>
Функция <code>create_drawdowns</code>, представленная ниже, представляет оба показателя — максимальная просадка и максимальная длительность просадки. В определении длительности просадки есть тонкость — при ее определении нельзя оперировать общими понятиями типа «день», учитываются только торговые периоды.<br/>
<br/>
Функция начинает работу с создания двух объектов pandas Series, представляющих просадку и длительность на каждом торговом баре. Затем устанавливается текущий показатель HWM (high water mark) — он означает, что объём капитала превышает предыдущие максимумы.<br/>
<br/>
Просадка будет являться разницей между текущим HWM и кривой капитала. Если значение отрицательно, то длительность увеличивается для каждого бара, пока наблюдается это явление, до достижения следующего HWM. Затем функция возвращает максимум каждой из двух серий:<br/>
<br/>
<pre><code class="python">
# performance.py

def create_drawdowns(equity_curve):
    """
    Вычисляет крупнейшее падение от пика до минимума кривой PnL и его длительность. Требует возврата  pnl_returns в качестве pandas Series.
 
    Параметры:
    pnl - pandas Series, представляющая процент прибыли за период. 

    Прибыль:
    drawdown, duration - Наибольшая просадка и ее длительность 
    """

    # Подсчет общей прибыли 
    # и установка High Water Mark
    # Затем создаются серии для просадки и длительности
    hwm = [0]
    eq_idx = equity_curve.index
    drawdown = pd.Series(index = eq_idx)
    duration = pd.Series(index = eq_idx)

    # Цикл проходит по диапазону значений индекса
    for t in range(1, len(eq_idx)):
        cur_hwm = max(hwm[t-1], equity_curve[t])
        hwm.append(cur_hwm)
        drawdown[t]= hwm[t] - equity_curve[t]
        duration[t]= 0 if drawdown[t] == 0 else duration[t-1] + 1
    return drawdown.max(), duration.max()
</code></pre><br/>
Для того, чтобы применить эти метрики производительности, нужны средства их подсчета после тестирования на исторических данных. Также необходимо связать вычисления с определенным объектом в иерархии. Учитывая, что метрики производительности вычисляются на базе портфолио, имеет смысл применить вычисления для метода в иерархии классов <code>Portfolio</code>, которую мы обсуждали в прошлых статьях. <br/>
<br/>
Прежде всего нужно открыть <code>portfolio.py</code> и импортировать функции производительности:<br/>
<br/>
<pre><code class="python">
# portfolio.py

..  # импорт других функций

from performance import create_sharpe_ratio, create_drawdowns
</code></pre><br/>
Поскольку <code>Portfolio</code> — это абстрактный базовый класс, то добавить метод нужно к одному из его производных классов. В данном случае это <code>NaivePortfolio</code>. Таким образом мы создадим метод под названием <code>output_summary_stats</code> — он будет работать с кривой доступных средств портфолио для генерирования коэффициента Шарпа и информации по просадке.<br/>
<br/>
Метод довольно прост. Он использует две метрики производительности и применяет их напрямую к кривой капитала в датафрейме pandas, а затем выводит статистику в качестве отформатированного списка:<br/>
<br/>
<pre><code class="python">
# portfolio.py

..
..

class NaivePortfolio(object):

    ..
    ..

    def output_summary_stats(self):
        """
        Создает список статистических показателей для портфолио — коэффициент Шарпа и данные по просадке. 
        """
        total_return = self.equity_curve['equity_curve'][-1]
        returns = self.equity_curve['returns']
        pnl = self.equity_curve['equity_curve']

        sharpe_ratio = create_sharpe_ratio(returns)
        max_dd, dd_duration = create_drawdowns(pnl)

        stats = [("Total Return", "%0.2f%%" % ((total_return - 1.0) * 100.0)),
                 ("Sharpe Ratio", "%0.2f" % sharpe_ratio),
                 ("Max Drawdown", "%0.2f%%" % (max_dd * 100.0)),
                 ("Drawdown Duration", "%d" % dd_duration)]
        return stats
</code></pre><br/>
Данный анализ производительности является сильно упрощенным. Он не учитывает аналитику на уровне сделок или другие измерения соотношения риска и прибыли. Однако его довольно просто расширить и добавить дополнительные методы в <code>performance.py</code> с последующим внедрением их в <code>output_summary_stats</code>.<br/>
<br/>
<i>Продолжение следует…</i><br/>
<br/>
P. S. Ранее в нашем блоге на Хабре мы уже <a href="http://habrahabr.ru/company/itinvest/blog/224353/">рассматривали</a> различные этапы разработки торговых систем. <a href="http://www.itinvest.ru/promo/adv/">ITinvest</a> и наши партнеры проводят <a href="http://www.itinvest.ru/education/schedule/">онлайн-курсы по данной тематике</a>.</code></div></body></html>