<html><body><div><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-dna-traits" class="anchor" href="#dna-traits" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>dna-traits</h1>

<p>This is a <em>very</em> fast 23andMe genome text file parser whose internals are
written in C++.  The genome itself can then be queried using Python; other
language bindings may follow.</p>

<h2><a id="user-content-the-need-for-speed" class="anchor" href="#the-need-for-speed" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>The need for speed</h2>

<p>Regarding speed, a naive parser I wrote in pure Python takes around 2.5
seconds to read a million SNPs --- I've also seen some parsers take up to 8
seconds.</p>

<p><em>This one</em> consistently lands on a mere 0.16 seconds on <em>my</em> machine.  It's
so fast is because it memory maps the file and always scans forward ---
every byte in the file is only ever touched once.  To top it off, I'm using
the Google dense hash map for storing SNPs by RSID, which is extremely fast.</p>

<p>While slow parsing is not a big concern for serious users, the existence of
a fast open source parser may also benefit other projects. And, admittedly,
it's a lot of fun trying to push the envelope!</p>

<h2><a id="user-content-the-python-api" class="anchor" href="#the-python-api" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>The Python API</h2>

<p>Here's an example of the Python API, which parses the file, displays <code>rs123</code>
and then prints its complement.</p>

<pre><code>&gt;&gt;&gt; import dna_traits as dt
&gt;&gt;&gt; genome = dt.parse("genome.txt")
&gt;&gt;&gt; genome
&lt;Genome: SNPs=949905, y_chromosome=True, orientation=1&gt;
&gt;&gt;&gt; genome.male
True
&gt;&gt;&gt; genome["rs123"]
SNP(genotype='AA', rsid='rs123', orientation=1, chromosome=7, position=24966446)
&gt;&gt;&gt; snp = genome.rs123
&gt;&gt;&gt; snp.homozygous
True
&gt;&gt;&gt; ~snp
SNP(genotype='TT', rsid='rs123', orientation=1, chromosome=7, position=24966446)
</code></pre>

<p>More information can be found in <code>py-dnatraits/README.md</code></p>

<h2><a id="user-content-current-status" class="anchor" href="#current-status" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Current status</h2>

<ul>
<li><p>Only 23andMe files are currently supported</p></li>
<li><p>Parsing is extremely fast: On <em>my</em> machine, it only takes 0.16 seconds
to fully parse a 23andMe genome text file and build up a hash table in
memory.  That's around 155 Mb/s out of 200 Mb/s possible on my drive.</p>

<p>In fact, it's fast enough that I won't bother saving the hash table in a
binary format, as originally intended (Update: I tried it, and reading a
binary file is only <em>9 ms</em> faster than parsing the text file).</p></li>
<li><p>Rules and phenotype criteria from SNPedia can be written using the
Python API.</p></li>
<li><p>In time, I will extract this repo into a Python PyPi 23andMe parser
library.</p></li>
<li><p>The Python API is currenty somewhat limited and inconsistent, but still
very usable!</p></li>
<li><p>Doesn't parse internal IDs yet.</p></li>
<li><p>Has support for quite some health, traits and condition reports. See the
bottom of this page for more information.</p></li>
</ul>

<h2><a id="user-content-requirements" class="anchor" href="#requirements" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Requirements</h2>

<ul>
<li><p>A C++11 compiler</p></li>
<li><p>Google sparse hash map</p></li>
<li><p>Genome files in 23andMe format. Many people have uploaded theirs on the
net for free use. See for example OpenSNP.  If you're a 23andMe
customer, you can download your own from them.</p></li>
<li><p>Python development files, if you want to build the Python module.</p></li>
</ul>

<h2><a id="user-content-building" class="anchor" href="#building" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Building</h2>

<p>If Google dense hash map is located in <code>/usr/local/include</code>, build
everything, including the Python API, with:</p>

<pre><code>$ make -j all CXXFLAGS=-I/usr/local/include
</code></pre>

<p>Build the <code>check</code> target to check if everything works.</p>

<pre><code>$ make check
</code></pre>

<h2><a id="user-content-example-of-inferring-phenotypes" class="anchor" href="#example-of-inferring-phenotypes" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Example of inferring phenotypes</h2>

<p>SNPedia contains the <code>gs237</code> criteria for determining whether a person has
blue eyes. At <a href="http://snpedia.com/index.php/Gs237/criteria">http://snpedia.com/index.php/Gs237/criteria</a> the rule set says:</p>

<pre><code>and(
  rs4778241(C;C),
  rs12913832(G;G),
  rs7495174(A;A),
  rs8028689(T;T),
  rs7183877(C;C),
  rs1800401(C;C))
</code></pre>

<p>In C++ this would be:</p>

<pre><code>static bool gs237(const Genome&amp; genome)
{
  return genome[ 4778241] ==  CC
      &amp;&amp; genome[12913832] ==  GG
      &amp;&amp; genome[ 7495174] ==  AA
      &amp;&amp; genome[ 8028689] ==  TT
      &amp;&amp; genome[ 7183877] ==  CC
      &amp;&amp; genome[ 1800401] == ~CC;
}
</code></pre>

<p>The only thing to note is each SNP's orientation. 23andMe uses positive
orientation, while SNPedia has varying orientation. That's why we flip the
orientation in the last check for the <code>rs1800401</code> SNP </p>

<p>In Python, this can be done in any number of ways, but one way is to use the
<code>Genome.match</code> function:</p>

<pre><code>all(genome.match((("rs4778241",  "CC"),
                  ("rs12913832", "GG"),
                  ("rs7495174",  "AA"),
                  ("rs8028689",  "TT"),
                  ("rs7183877",  "CC"),
                  ("rs1800401",  "GG"))))
</code></pre>

<h2><a id="user-content-example-reports" class="anchor" href="#example-reports" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Example reports</h2>

<p>I've implemented some of the 23andMe health reports, traits and conditions. You
can see the content here:</p>



<p>Note that there might very well be errors in the above reports, so use with
care! In particular, the odds ratios are most likely very incorrect.  The best
bet is the traits. These should be correct, as well as some simple health
reports. So, the main goal is for this to be educational. In other words,
explore on your own.</p>

<h2><a id="user-content-copyright-and-license" class="anchor" href="#copyright-and-license" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Copyright and license</h2>

<p>Copyright (C) 2014 Christian Stigen Larsen<br/>
<a href="http://csl.name">http://csl.name</a></p>

<p>Distributed under GPL v3 or later. See the file COPYING for the full
license.</p>

<h2><a id="user-content-places-of-interest" class="anchor" href="#places-of-interest" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Places of interest</h2>


</article>
  </div></body></html>