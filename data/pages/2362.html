<html><body><div><div class="post-text" itemprop="text">
<p>The <strong>only</strong> difference between your two approaches is that <code>print_exc()</code> prints a formatted exception. For a <code>SyntaxError</code> that includes formatting the information in that exception, which includes the actual line that caused the problem.</p>

<p>For the traceback itself, <code>print_exc()</code> uses <code>sys.exc_info()[2]</code>, the same information you are using already to produce the traceback. In other words, it doesn't get any more information than you already do, but you are ignoring the exception information itself:</p>

<pre><code>&gt;&gt;&gt; import traceback
&gt;&gt;&gt; try:
...     compile('Hmmm, nope!', '&lt;stdin&gt;', 'exec')
... except SyntaxError as e:
...     print ''.join(traceback.format_exception_only(type(e), e))
... 
  File "&lt;stdin&gt;", line 1
    Hmmm, nope!
              ^
SyntaxError: invalid syntax
</code></pre>

<p>Here <code>traceback.format_exception_only()</code> is an undocumented function used by <code>traceback.print_exc()</code> to format the exception value. All the information is there for you to extract on the exception itself:</p>

<pre><code>&gt;&gt;&gt; dir(e)
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__getitem__', '__getslice__', '__hash__', '__init__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__', '__unicode__', 'args', 'filename', 'lineno', 'message', 'msg', 'offset', 'print_file_and_line', 'text']
&gt;&gt;&gt; e.args
('invalid syntax', ('&lt;stdin&gt;', 1, 11, 'Hmmm, nope!\n'))
&gt;&gt;&gt; e.filename, e.lineno, e.offset, e.text
('&lt;stdin&gt;', 1, 11, 'Hmmm, nope!\n')
</code></pre>

<p>Also see the documentation of <a href="https://docs.python.org/2/library/traceback.html#traceback.print_exception" rel="nofollow"><code>traceback.print_exception()</code></a>:</p>

<blockquote>
  <p>(3) if <em>type</em> is <code>SyntaxError</code> and value has the appropriate format, it prints the line where the syntax error occurred with a caret indicating the approximate position of the error.</p>
</blockquote>

<p>and the <a href="https://docs.python.org/2/library/exceptions.html#exceptions.SyntaxError" rel="nofollow"><code>SyntaxError</code> documentation</a>:</p>

<blockquote>
  <p>Instances of this class have attributes <code>filename</code>, <code>lineno</code>, <code>offset</code> and <code>text</code> for easier access to the details. <code>str()</code> of the exception instance returns only the message.</p>
</blockquote>

<p>That the line with the syntax error is not included in the traceback is only logical; code with a syntax error cannot be executed, so no execution frame was ever created for it. And the exception is being thrown by the <code>compile()</code> function, the bottom-most frame of execution.</p>

<p>As such you are stuck with your 'ugly' approach; it is the correct approach for handling <code>SyntaxError</code> exceptions. However, the attributes <strong>are</strong> documented.</p>

<p>Note that <code>exception.message</code> is normally set to <code>exception.args[0]</code>, and <code>str(exception)</code> <em>usually</em> gives you the same message (if <code>args</code> is longer you get <code>str(exception.args)</code> instead, although some exception types provide a custom <code>__str__</code> that often just gives you <code>exception.args[0]</code>).</p>
    </div>
    </div></body></html>