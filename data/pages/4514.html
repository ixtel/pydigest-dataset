<html><body><div><section class="post-content">
                        
                        <p>A good test suite is a developer's best friend -- it tells you what your
code does and what it's supposed to do. It's your second set of eyes as
you're working, and your safety net before you go to production.</p>
<p>By contrast, a bad test suite stands in the way of progress -- whenever you
make a small change, suddenly fifty tests are failing, and it's not clear
how or why the cases are related to your change.</p>


<p>But how do you know if your test suite is "good"? At <a href="https://us.pycon.org/2015/">PyCon US
2015</a> I gave a
<a href="https://speakerdeck.com/dcrosta/good-test-bad-test">talk</a> that addressed
three common myths about testing, which lead down a path of painful testing.</p>
<p>The talk, and this article, are heavily opinionated. As with all opinions,
it's up to you, the reader, to decide whether they're applicable to your
particular situation or not. In other words, you still need to use your
judgement.</p>
<h1>What's a "Good" Test?</h1>
<p>I'll define a good test (and by extension a good test suite) as one that has
the following virtues:</p>
<ul>
<li><strong>Fast</strong>. If a test is slow, developers won't run it locally. This will
  lead to broken CI builds, and more time spent fixing the code that broke
  the test afterwards, more context switching, lack of flow, and all the
  concomitant problems.</li>
<li><strong>Selective</strong>. If a bug is introduced into the code under test, only one
  or a few test cases should fail. If all cases start failing, then it will
  require a too much time to figure out exactly what is wrong. Your tests
  should point you in the direction of what's wrong.</li>
<li><strong>Repeatable</strong>. Tests should always give the same result if the code
  being tested hasn't changed. Any reliance in a test on timing, randomness,
  or external state (databases, the date or time, etc) will lead to wasted
  time spent investigating spurious failures.</li>
<li><strong>Reliable</strong>. Your test should pass when the code is working, and fail
  when the code has a bug. Perhaps this is self-evident, but it bears
  repeating -- a test should not give false positives or false negatives.</li>
<li><strong>Helpful</strong>. In particular, test <em>error messages</em> should be helpful. Seeing
  "user_has_logged_in() was False after user login" tells you exactly what's
  wrong, whereas "AssertionError: False is not True" requires you to figure
  it out for yourself.</li>
</ul>
<p>As we'll see, the myths, and the mistakes they cause developers to make
while writing tests, come from good intentions, but can lead to violations
of one or more of the above principles.</p>
<h1>Myth 1: 100% Coverage</h1>
<p>This myth is pernicious primarily because of how common it is. Perhaps a
team adopts code coverage monitoring after a few bouts with bugs that could
easily have been prevented with tests, and there's a land rush to improve
coverage. More tests must be better, right?</p>
<p>Beware: danger lurks in too-eagerly chasing full coverage. The truth of the
matter is, there are some tests that simply shouldn't be written: they add
too much complexity to your codebase, and provide very little value.</p>
<p>For example, consider tests that exercise parts of your application that
interact with some external resource, not under your control, like a third
party API your application works with:</p>
<p><img alt="There's a reason we draw it as a&#10;cloud..." src="//late.am/static/good-test-internet-cloud.png"/><em>There's a reason we draw it
as a cloud...
(<a href="https://www.sparkholder.com/wp-content/uploads/2015/01/sparkholder-api.png">source</a>,
modified)</em></p>
<p>Notice that thing in the middle. There's a reason we draw it as a cloud: we
don't really know what happens in there. <em>Anything</em> could happen in there.
You might get a very slow connection; you might get corrupted bytes back
that don't make any sense; you might simply shout into the void, never to
hear back from the third party; or you might be on a plane, with no access
to the internet. Since you can't control it, you're totally subject to the
whims of the internet and of the third party.</p>
<p>I call tests that rely on third parties in this way <a href="http://en.wikipedia.org/wiki/Mutual_assured_destruction">"Mutually-Assured
Destruction"</a>
tests. Ordinarily, the external service is operating normally and your tests
pass. But occasionally, something outside of your control is broken, and
suddenly your test suite is reporting a bug that doesn't exist in your code.
Either both sides work, or both sides fail, hence "MAD".</p>
<p>Perhaps this is controversial, but I recommend that you not write tests for
this kind of code in the first place. It's failures don't tell you anything
interesting or actionable about your codebase.</p>
<p>Instead, try to minimize the amount of MAD code, and make it as dumb as
possible. Don't put business logic that needs thorough testing in-line with
third party integrations, and make sure your integrations can report errors
back to you. Be sure to test your exception reporting service, and keep
notification rules up to date. If you depend on an external service for
critical functionality, you can't ensure that it will always be available
and correct; but you can be sure that you're notified when it goes down, and
have a plan in place to mitigate the impact.</p>
<h1>Myth 2: Assert About Everything</h1>
<p>Assertions are how tests tell us whether our code is working or not. Without
assertions, tests literally wouldn't do anything useful. So, if we add more
assertions, we'll increase our confidence that our test does what we want it
to do, right?</p>
<p>Too many assertions, and especially the wrong kinds of assertions create a
maintenance hazard in your test suite. Let's illustrate the point with an
example, a function which parses a log line from a web server in a
hypothetical pipe-separated format, returning a dictionary:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">test_it_parses_log_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">line</span> <span class="o">=</span> <span class="s">"2015-03-11T20:09:25|GET /foo?bar=baz|..."</span>

    <span class="n">parsed_dict</span> <span class="o">=</span> <span class="n">parse_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>


<p>It is tempting to use the familiar <code>assertEqual</code> with a dictionary whose
contents are identical to the parsed result we expect:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">test_it_parses_log_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">line</span> <span class="o">=</span> <span class="s">"2015-03-11T20:09:25|GET /foo?bar=baz|..."</span>

    <span class="n">parsed_dict</span> <span class="o">=</span> <span class="n">parse_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">({</span>
        <span class="s">"date"</span><span class="p">:</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span>
        <span class="s">"method"</span><span class="p">:</span> <span class="s">"GET"</span><span class="p">,</span>
        <span class="s">"path"</span><span class="p">:</span> <span class="s">"/foo"</span><span class="p">,</span>
        <span class="s">"query"</span><span class="p">:</span> <span class="s">"bar=baz"</span><span class="p">,</span>
    <span class="p">},</span> <span class="n">parsed_dict</span><span class="p">)</span>
</pre></div>


<p>This will certainly work, assuming the parse function is implemented
correctly. But what kind of error messages will we get from this test?
Take a look:</p>
<div class="highlight"><pre>AssertionError: {'date': datetime.datetime(2015, 3, 11, 20, 9, 25), 'path': '/foo', 'method': 'G [truncated]... != {'date': datetime.datetime(2015, 3, 11, 20, 9, 25), 'path': '/foo?', 'method': ' [truncated]...
</pre></div>


<p>Can you see what the error is? No? Neither can I. Fortunately, we can fix
this fairly easily:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">test_it_parses_log_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">line</span> <span class="o">=</span> <span class="s">"2015-03-11T20:09:25|GET /foo?bar=baz|..."</span>

    <span class="n">parsed_dict</span> <span class="o">=</span> <span class="n">parse_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span>
        <span class="n">datetime</span><span class="p">(</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span>
        <span class="n">parsed_dict</span><span class="p">[</span><span class="s">"date"</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"GET"</span><span class="p">,</span> <span class="n">parsed_dict</span><span class="p">[</span><span class="s">"method"</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"/foo"</span><span class="p">,</span> <span class="n">parsed_dict</span><span class="p">[</span><span class="s">"path"</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"bar=baz"</span><span class="p">,</span> <span class="n">parsed_dict</span><span class="p">[</span><span class="s">"query"</span><span class="p">])</span>
</pre></div>


<p>Now when our test fails, we can see exactly what's going on:</p>
<div class="highlight"><pre>AssertionError: '/foo' != '/foo?'
</pre></div>


<p>We fix the bug, and move on with our lives. Eventually, we'll expand the
functionality of the parser, and add more test cases. Inevitably, these
assertions will be copied and pasted, with some modification:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">test_it_parses_get_request_log_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"GET"</span><span class="p">,</span> <span class="n">parsed</span><span class="p">[</span><span class="s">"method"</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"/foo"</span><span class="p">,</span> <span class="n">parsed</span><span class="p">[</span><span class="s">"path"</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"bar=baz"</span><span class="p">,</span> <span class="n">parsed</span><span class="p">[</span><span class="s">"query"</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">test_it_parses_post_request_log_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"POST"</span><span class="p">,</span> <span class="n">parsed</span><span class="p">[</span><span class="s">"method"</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"/foo"</span><span class="p">,</span> <span class="n">parsed</span><span class="p">[</span><span class="s">"path"</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"bar=baz"</span><span class="p">,</span> <span class="n">parsed</span><span class="p">[</span><span class="s">"query"</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">test_it_parses_log_lines_with_oof_requests</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"GET"</span><span class="p">,</span> <span class="n">parsed</span><span class="p">[</span><span class="s">"method"</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"/oof"</span><span class="p">,</span> <span class="n">parsed</span><span class="p">[</span><span class="s">"path"</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"bar=baz"</span><span class="p">,</span> <span class="n">parsed</span><span class="p">[</span><span class="s">"query"</span><span class="p">])</span>
</pre></div>


<p>Notice that only one assertion is actually changing in each test, but we're
repeating most of the others. This means that if we break one feature -- say
request path parsing -- we'll get failures from most of our test cases. In
order to figure out what's actually broken, we'll have to dig through each
failure and think hard about each test case to figure out what to fix.</p>
<p>You should ask yourself, for each test case, "What would I do when this test
case fails?" We can minimize the effort required to transate a test failure
into a fix by following one simple rule: make only one assertion per test
case. Yup, only one.</p>
<p>Let's rewrite this test suite using the new rule:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">test_it_parses_request_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"GET"</span><span class="p">,</span> <span class="n">parsed</span><span class="p">[</span><span class="s">"method"</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">test_it_parses_request_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"/foo"</span><span class="p">,</span> <span class="n">parsed</span><span class="p">[</span><span class="s">"path"</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">test_it_parses_query_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"bar=baz"</span><span class="p">,</span> <span class="n">parsed</span><span class="p">[</span><span class="s">"query"</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">test_it_gives_none_when_no_query_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertIsNone</span><span class="p">(</span><span class="n">parsed</span><span class="p">[</span><span class="s">"query"</span><span class="p">])</span>
</pre></div>


<p>Now, when we break request path parsing, we'll only get one test case
failure, and the test case name and failure traceback will point us directly
at what we need to fix: the request path parsing portion of our code.</p>
<p>When you adopt this style of test design, you'll also find that the way you
write your test cases changes. Before, we had test cases representing some
special cases we expect in the real world: an "oof" request, a POST request,
etc.</p>
<p>Now, our test cases reflect the orthogonal behaviors of the code under test:
it parses the request method, path, query string, etc. Not only are the test
failures more instructive, but our test cases now serve as better
documentation: scanning the names tells us what the <code>parse_line</code> function
actually does (and, by extension, what it doesn't do).</p>
<h1>Myth 3: Mock Makes Tests Better</h1>
<p><a href="http://www.voidspace.org.uk/python/mock/">Mock</a> is a powerful library for
simulating and replacing Python objects in tests. You can safely
monkey-patch, check what calls were made against your mocks, raise
exceptions, and more.</p>
<p>Common reasons for using mock are to reduce dependence on external, possibly
slow resources, like databases, to isolate testing to one layer of your
code, or to control "inputs" to a method or function that come from some
nested call. Mock is certainly capable of doing all of these things.</p>
<p>But with great power comes great responsibility -- used unwisely, mock can
wreak more havoc on your testing than the thing you were trying to replace
would have. Take, as an example, a suite of tests on a web application with
login functionality:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">DBClient</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">authenticate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="sd">"""Returns True if the user is authenticated.</span>
<span class="sd">        """</span>
        <span class="c"># WARNING: Don't use this code in production!</span>
        <span class="k">return</span> <span class="bp">True</span>

<span class="k">class</span> <span class="nc">MyApp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">login</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s">"username"</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="mi">401</span><span class="p">)</span>
        <span class="c"># do more stuff ...</span>
        <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
</pre></div>


<p>Since we want to test the behavior of the <code>login</code> method under two scenarios
-- when the user is authenticated, and when the user is not. We might use
mock to control the return value of the internal call to <code>authenticate</code>:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">test_it_returns_200_on_success</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">mock</span><span class="o">.</span><span class="n">Mock</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="n">DBClient</span><span class="p">)</span>
    <span class="n">db</span><span class="o">.</span><span class="n">authenticate</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">app</span> <span class="o">=</span> <span class="n">MyApp</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="s">"dcrosta"</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_it_returns_401_on_failure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">mock</span><span class="o">.</span><span class="n">Mock</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="n">DBClient</span><span class="p">)</span>
    <span class="n">db</span><span class="o">.</span><span class="n">authenticate</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="n">app</span> <span class="o">=</span> <span class="n">MyApp</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="s">"dcrosta"</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">401</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
</pre></div>


<p>Now we'll add a new feature to our application -- user permissions. For
simplicity, let's have the <code>authenticate</code> method return not only whether the
user is authenticated, but what roles in our application the user has:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">DBClient</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">authenticate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="sd">"""Returns a tuple of (authenticated, list_of_roles).</span>
<span class="sd">        """</span>
        <span class="c"># WARNING: Still don't use this code in production!</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="p">[</span><span class="s">"admin"</span><span class="p">])</span>
</pre></div>


<p>If we stop here, we've introduced a bug into our code: we haven't updated
<code>login</code> to handle the new return value from <code>authenticate</code>. But our test
suite isn't telling us that, because the test mocks still supply the old
format of return value (just a boolean).</p>
<p>In the worst case, you might not notice this bug until it has been in
production for some time, since this particular error won't raise any
exceptions (a non-empty tuple is considered truthful in Python).</p>
<p>Whenever you write a test, you have to consider: what would cause this test
case to <em>pass</em> when it ought to <em>fail</em>? With mock, this can happen whenever
the object you're replacing has changed.</p>
<p>The solution for cases like this is to use a "verified double" -- a
replacement object that closely, hopefully identically, emulates the
behavior of the thing you're replacing. Here's a double for the <code>DBClient</code>
class we were previously mocking:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">StubDBClient</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">users</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">roles</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">users</span><span class="p">[</span><span class="n">username</span><span class="p">]</span> <span class="o">=</span> <span class="n">roles</span>

    <span class="k">def</span> <span class="nf">authenticate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">username</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">users</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">users</span><span class="p">[</span><span class="n">username</span><span class="p">])</span>
</pre></div>


<p>Had we been using this double all along, the test cases might have looked
like this:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">test_login_returns_200_on_success</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">StubDBClient</span><span class="p">()</span>
    <span class="n">db</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s">"dcrosta"</span><span class="p">)</span>

    <span class="n">app</span> <span class="o">=</span> <span class="n">MyApp</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="s">"dcrosta"</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_login_returns_401_on_failure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">StubDBClient</span><span class="p">()</span>

    <span class="n">app</span> <span class="o">=</span> <span class="n">MyApp</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="s">"dcrosta"</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">401</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
</pre></div>


<p>Not only are the tests more readable -- they demonstrate the full set of
actions that have to take place to achieve the result being verified -- but
the test cases now demonstrate that we've got a bug in our code until we
update the <code>login</code> method to understand the new return value from
<code>authenticate</code>.</p>
<p>Since the double itself isn't a one-liner, you're likely to share the double
across all test cases that use this functionality. Now you only hvae one
place in your tests to update when you change the interface of the real
object. Once you change it, your test suite will tell you all the other
areas you need to revisit. Once the tests pass, your refactor is complete.</p>
<h1>Final Thoughts</h1>
<p>Too often, testing is an afterthought. The exciting work that we all crave
is to build the actual working code. But no code is created in an eternally
perfect and pristine state. We will eventually have to modify it to add or
remove functionality, to address performance concerns, to work with new
frameworks, etc. Tests are our safety net when we perform these operations
on a codebase: they tell us what we've broken, and what we have to fix.</p>
<p>It's important to acknowledge that tests can smell just as well as real
code. We deal with code smell in a test suite the same as we would in any
other type of code -- with thought and care. A well designed test suite, one
which lives up to the virtues of good testing, will be your best friend in a
long-lived codebase.</p>
                    </section>
                    </div></body></html>