<html><body><div><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-iterstuff" class="anchor" href="#iterstuff" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>iterstuff</h1>

<p><strong>Useful tools for working with iterators</strong></p>

<p>If the python2 <code>itertools</code> module is the Swiss Army Knife of functions for
iterables, <code>iterstuff</code> is the cut-down single-blade version that you can keep on
your keyring.</p>

<p>You can install iterstuff from pypi using pip:</p>

<pre><code>pip install iterstuff
</code></pre>

<h2><a id="user-content-lookahead" class="anchor" href="#lookahead" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Lookahead</h2>

<p>The Lookahead class is the main feature of iterstuff. It 'wraps' an iterable
and allows:</p>

<ul>
<li>Detection of the end of the generator using the <code>atend</code> property</li>
<li>'Peeking' at the next item to be yielded using the <code>peek</code> property</li>
</ul>

<p>Note that 'wrapping' means that the Lookahead will advance the wrapped iterable (by calling
<code>next</code>) as needed. As per the comments on the Lookahead <code>__init__</code>, creating
the Lookahead will advance to the first element of the wrapped iterable immediately.
After that, iterating over the Lookahead will also iterate over the wrapped iterable.</p>

<p>We'll look at examples in a moment, but first here's a summary of usage:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c"># Create a generator that will yield three integers</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> g <span class="pl-k">=</span> <span class="pl-v">xrange</span>(<span class="pl-c1">3</span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c"># Wrap it in a Lookahead</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> iterstuff <span class="pl-k">import</span> Lookahead
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> x <span class="pl-k">=</span> Lookahead(g)</pre></div>

<p>Now we can use the properties of the Lookahead to check whether we're at the
start and/or end of the generator sequence, and to look at the next element
that would be yielded:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> x.atstart
<span class="pl-c1">True</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> x.atend
<span class="pl-c1">False</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> x.peek
<span class="pl-c1">0</span></pre></div>

<p>Let's grab the first element and see how the properties change:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> x.next()
<span class="pl-c1">0</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> x.atstart
<span class="pl-c1">False</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> x.atend
<span class="pl-c1">False</span>
x.peek
<span class="pl-c1">1</span></pre></div>

<p>We have two ways to iterate over a sequence wrapped in a Lookahead:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c"># The usual way</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> x <span class="pl-k">=</span> Lookahead(<span class="pl-v">xrange</span>(<span class="pl-c1">3</span>))
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">for</span> y <span class="pl-k">in</span> x: <span class="pl-c1">print</span> y
<span class="pl-c1">0</span>
<span class="pl-c1">1</span>
<span class="pl-c1">2</span>

<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c"># By checking for the end of the sequence</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> x <span class="pl-k">=</span> Lookahead(<span class="pl-v">xrange</span>(<span class="pl-c1">3</span>))
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">while</span> <span class="pl-k">not</span> x.atend:
<span class="pl-c1">...</span>     y <span class="pl-k">=</span> x.next()
<span class="pl-c1">...</span>     <span class="pl-c1">print</span> y
<span class="pl-c1">...</span>     
<span class="pl-c1">0</span>
<span class="pl-c1">1</span>
<span class="pl-c1">2</span></pre></div>

<p>And we can detect a completely empty Lookahead:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">if</span> x.atstart <span class="pl-k">and</span> x.atend:
<span class="pl-c1">...</span>    <span class="pl-c"># x is an empty Lookahead</span></pre></div>

<p>The obvious question is: <em>how is this useful?</em></p>

<h3><a id="user-content-repeating-a-takewhile" class="anchor" href="#repeating-a-takewhile" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Repeating a <code>takewhile</code></h3>

<p>The <a href="https://docs.python.org/2/library/itertools.html#itertools.takewhile">itertools.takewhile</a> function
can yield items from an iterable while some condition is satisfied. However,
it only yields items up until the condition is no longer satisfied, then it
stops, <strong>after</strong> testing the next element. Let's see what happens if we
want to use it to break a sequence of characters into letters and digits.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> itertools <span class="pl-k">import</span> takewhile
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c"># Build a generator that returns a sequence</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> data <span class="pl-k">=</span> <span class="pl-c1">iter</span>(<span class="pl-s"><span class="pl-pds">'</span>abcd123ghi<span class="pl-pds">'</span></span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c"># Ok, let's get the characters that are not digits</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">print</span> <span class="pl-c1">list</span>(takewhile(<span class="pl-k">lambda</span> <span class="pl-smi">x</span>: <span class="pl-k">not</span> x.isdigit(), data))
[<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>]
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> 
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c"># Great, now let's get the digits</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">print</span> <span class="pl-c1">list</span>(takewhile(<span class="pl-k">lambda</span> <span class="pl-smi">x</span>: x.isdigit(), data))
[<span class="pl-s"><span class="pl-pds">'</span>2<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>3<span class="pl-pds">'</span></span>]</pre></div>

<p>What happened to '1'? When we were processing the non-digits, the <code>takewhile</code>
function read the '1' from <code>data</code>, passed it to the <code>lambda</code> and when that
returned False, terminated. But of course, by then the '1' had already been
consumed, so when we started the second <code>takewhile</code>, the first character it
got was '2'.</p>

<p>We can solve this with a Lookahead. Here's a repeatable <code>takewhile</code> equivalent
(that's in the <code>iterstuff</code> module):</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">repeatable_takewhile</span>(<span class="pl-smi">predicate</span>, <span class="pl-smi">iterable</span>):
    <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    Like itertools.takewhile, but does not consume the first</span>
<span class="pl-s">    element of the iterable that fails the predicate test.</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>

    <span class="pl-c"># Assert that the iterable is a Lookahead. The act of wrapping</span>
    <span class="pl-c"># an iterable in a Lookahead consumes the first element, so we</span>
    <span class="pl-c"># cannot do the wrapping inside this function.</span>
    <span class="pl-k">if</span> <span class="pl-k">not</span> <span class="pl-c1">isinstance</span>(iterable, Lookahead):
        <span class="pl-k">raise</span> <span class="pl-c1">TypeError</span>(<span class="pl-s"><span class="pl-pds">"</span>The iterable parameter must be a Lookahead<span class="pl-pds">"</span></span>)

    <span class="pl-c"># Use 'peek' to check if the next element will satisfy the</span>
    <span class="pl-c"># predicate, and yield while this is True, or until we reach</span>
    <span class="pl-c"># the end of the iterable.</span>
    <span class="pl-k">while</span> (<span class="pl-k">not</span> iterable.atend) <span class="pl-k">and</span> predicate(iterable.peek):
        <span class="pl-k">yield</span> iterable.next()</pre></div>

<p>Let's see how this behaves:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">from</span> iterstuff <span class="pl-k">import</span> repeatable_takewhile, Lookahead
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> data <span class="pl-k">=</span> Lookahead(<span class="pl-s"><span class="pl-pds">'</span>abcd123ghi<span class="pl-pds">'</span></span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">print</span> <span class="pl-c1">list</span>(repeatable_takewhile(<span class="pl-k">lambda</span> <span class="pl-smi">x</span>: <span class="pl-k">not</span> x.isdigit(), data))
[<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>]
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">print</span> <span class="pl-c1">list</span>(repeatable_takewhile(<span class="pl-k">lambda</span> <span class="pl-smi">x</span>: x.isdigit(), data))
[<span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>2<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>3<span class="pl-pds">'</span></span>]</pre></div>

<h3><a id="user-content-examine-data-before-its-used" class="anchor" href="#examine-data-before-its-used" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Examine data before it's used</h3>

<p>The <em>pandas</em> library can build a <code>DataFrame</code> from almost any sequence of
records. The <code>DataFrame</code> constructor checks the first record to determine the
data types of the columns. If we pass a generator <code>data</code> to the <code>DataFrame</code>
constructor, almost the first thing that happens is that <code>data</code> is turned into
a list, so that <em>pandas</em> can access <code>data[0]</code> to examine the data types. If
your generator yields many records, though, this is bad - it's just built a
list of those many records in memory, effectively doubling the amount of
memory used (memory to hold the list plus memory to hold the DataFrame).</p>

<p>A Lookahead allows code to peek ahead at the next row. So we could do the
same job as <em>pandas</em> in a different way:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-c"># Wrap the data in a Lookahead so we can peek at the first row</span>
peekable <span class="pl-k">=</span> Lookahead(data)

<span class="pl-c"># If we're at the end of the Lookahead, there's no data</span>
<span class="pl-k">if</span> peekable.atend:
    <span class="pl-k">return</span>

<span class="pl-c"># Grab the first row so we can look at the data types</span>
first_row <span class="pl-k">=</span> peekable.peek

<span class="pl-c"># ...process the data types...</span></pre></div>

<h3><a id="user-content-simple-pairwise" class="anchor" href="#simple-pairwise" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Simple <code>pairwise</code></h3>

<p>There's a beautiful recipe in the <code>itertools</code> documentation for yielding
pairs from an iterable:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">pairwise</span>(<span class="pl-smi">iterable</span>):
    <span class="pl-s"><span class="pl-pds">"</span>s -&gt; (s0,s1), (s1,s2), (s2, s3), ...<span class="pl-pds">"</span></span>
    a, b <span class="pl-k">=</span> tee(iterable)
    <span class="pl-c1">next</span>(b, <span class="pl-c1">None</span>)
    <span class="pl-k">return</span> izip(a, b)</pre></div>

<p>Beautiful, but a little complex. We can make a simpler version with a
Lookahead:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">pairwise</span>(<span class="pl-smi">iterable</span>):
    <span class="pl-s"><span class="pl-pds">"</span>s -&gt; (s0,s1), (s1,s2), (s2, s3), ...<span class="pl-pds">"</span></span>
    it <span class="pl-k">=</span> Lookahead(iterable)
    <span class="pl-k">while</span> <span class="pl-k">not</span> it.atend:
        <span class="pl-k">yield</span> it.next(), it.peek</pre></div>

<p>Let's try it:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> data <span class="pl-k">=</span> <span class="pl-c1">iter</span>(<span class="pl-s"><span class="pl-pds">'</span>abcd123ghi<span class="pl-pds">'</span></span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">print</span> <span class="pl-c1">list</span>(pairwise(data))
[(<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>), (<span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>), (<span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>), (<span class="pl-s"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span>), (<span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>2<span class="pl-pds">'</span></span>), (<span class="pl-s"><span class="pl-pds">'</span>2<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>3<span class="pl-pds">'</span></span>), (<span class="pl-s"><span class="pl-pds">'</span>3<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>g<span class="pl-pds">'</span></span>), (<span class="pl-s"><span class="pl-pds">'</span>g<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>h<span class="pl-pds">'</span></span>), (<span class="pl-s"><span class="pl-pds">'</span>h<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>i<span class="pl-pds">'</span></span>), (<span class="pl-s"><span class="pl-pds">'</span>i<span class="pl-pds">'</span></span>, <span class="pl-c1">None</span>)]</pre></div>

<h3><a id="user-content-chunking" class="anchor" href="#chunking" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Chunking</h3>

<p>Chunking is like using the repeatable <code>takewhile</code>, but for a specific use-case.</p>

<p>Suppose you're reading data from a database: the results of a big query over a
LEFT OUTER JOIN between several tables. Let's create a simplified (but
real-world) example.</p>

<p>We store data that relates to timing of web pages. We store an <code>event</code> for
each page, and for each event we store multiple <code>value</code>s. Our tables look
something like:</p>

<pre><code>Event
ID  Created             Session URL
01  2014-12-17 01:00:00 ab12f43 http://www.mobify.com/
02  2014-12-17 01:00:01 ab12f43 http://www.mobify.com/jobs
...and so on for millions of events...

Value
Event_ID  Name              Value
01        DOMContentLoaded     83
01        Load                122
02        DOMContentLoaded     64
02        Load                345
...and so on for millions of values for millions of events...
</code></pre>

<p>At the end of every day, we process the records for that day, by doing a
query like:</p>

<div class="highlight highlight-source-sql"><pre><span class="pl-k">SELECT</span> <span class="pl-k">*</span>
<span class="pl-k">FROM</span> Event <span class="pl-k">LEFT OUTER JOIN</span> Value <span class="pl-k">ON</span> <span class="pl-c1">Event</span>.<span class="pl-c1">ID</span> <span class="pl-k">=</span> <span class="pl-c1">Value</span>.<span class="pl-c1">Event_ID</span>
<span class="pl-k">ORDER BY</span> <span class="pl-c1">Event</span>.<span class="pl-c1">ID</span></pre></div>

<p>We'll probably end up with something like a SQLAlchemy <code>ResultProxy</code> or a
Django <code>QuerySet</code> - an iterable thing that yields records (and here we're
assuming that your database will stream the results back to your Python
client so that you can process much more data than you could ever fit into
memory). Let's call that iterable thing <code>records</code>.</p>

<p>What we want to do is to process each event. The problem is that if we just
iterate over the <code>records</code>:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">for</span> record <span class="pl-k">in</span> records:
    <span class="pl-c1">print</span> record.<span class="pl-c1">ID</span>, record.Created, record.Name, record.Value</pre></div>

<p>...we'll get one record per <strong>value</strong> - more than one record per <strong>event</strong>:</p>

<pre><code>01 2014-12-17 01:00:00 DOMContentLoaded 83
01 2014-12-17 01:00:00 Load 122
02 2014-12-17 01:00:01 DOMContentLoaded 64
02 2014-12-17 01:00:01 Load 345
</code></pre>

<p>It's be better if we could handle all the records for one event together, then
all the records for the next event, and so on.</p>

<p>We could use <code>repeatable_takewhile</code> to grab all the records belonging to the
same event:</p>

<div class="highlight highlight-source-python"><pre>it <span class="pl-k">=</span> Lookahead(records)

<span class="pl-k">while</span> <span class="pl-k">not</span> it.atend:
    current_event_id <span class="pl-k">=</span> it.peek.<span class="pl-c1">ID</span>
    event_records <span class="pl-k">=</span> <span class="pl-c1">list</span>(
        repeatable_takewhile(
            <span class="pl-k">lambda</span> <span class="pl-smi">r</span>: r.<span class="pl-c1">ID</span> <span class="pl-k">==</span> current_event_id,
            it
        )
    )

    <span class="pl-c"># Now we have just the records for the next event</span>
    <span class="pl-c1">...</span>process<span class="pl-c1">...</span></pre></div>

<p>But because this is a common use case, Lookahead has a helper function to
make this even easier. The <code>chunked</code> function takes a function
to extract a 'key' value from each element, and yields successive
iterables, each of which has records with the same key value.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> iterstuff <span class="pl-k">import</span> chunked
<span class="pl-k">for</span> records_for_events <span class="pl-k">in</span> chunked(
        records,
        <span class="pl-k">lambda</span> <span class="pl-smi">r</span>: r.<span class="pl-c1">ID</span>
    ):
    <span class="pl-c"># records_for_events is a sequence of records for</span>
    <span class="pl-c"># one event.</span>
    <span class="pl-c1">...</span>process<span class="pl-c1">...</span></pre></div>

<p>In fact, we can use chunking in the character class problem we showed earlier:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> data <span class="pl-k">=</span> (x <span class="pl-k">for</span> x <span class="pl-k">in</span> <span class="pl-s"><span class="pl-pds">'</span>abcd123ghi<span class="pl-pds">'</span></span>)
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">for</span> charset <span class="pl-k">in</span> chunked(data, <span class="pl-k">lambda</span> <span class="pl-smi">c</span>: c.isdigit()):
<span class="pl-c1">...</span>     <span class="pl-c1">print</span> <span class="pl-c1">list</span>(charset)
<span class="pl-c1">...</span>     
[<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>]
[<span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>2<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>3<span class="pl-pds">'</span></span>]
[<span class="pl-s"><span class="pl-pds">'</span>g<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>h<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>i<span class="pl-pds">'</span></span>]</pre></div>

<h2><a id="user-content-batching" class="anchor" href="#batching" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Batching</h2>

<p>The <code>batch</code> method is a simplification of a common use for <code>itertools.islice</code>.</p>

<p>Suppose your generator yields records that you're reading from a file, or a
database. Suppose that there may be many hundreds of thousands of records, or
even millions, so you can't fit them all into memory, and you need to do them in
batches of 1000.</p>

<p>Here's one way to do this using <code>islice</code>:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> itertools <span class="pl-k">import</span> islice
<span class="pl-c1">CHUNK</span> <span class="pl-k">=</span> <span class="pl-c1">1000</span>
<span class="pl-k">while</span> <span class="pl-c1">True</span>:
    <span class="pl-c"># Listify the records so that we can check if</span>
    <span class="pl-c"># there were any returned.</span>
    chunk <span class="pl-k">=</span> <span class="pl-c1">list</span>(islice(records, <span class="pl-c1">CHUNK</span>))
    <span class="pl-k">if</span> <span class="pl-k">not</span> chunk:
        <span class="pl-k">break</span>

    <span class="pl-c"># Process the records in this chunk</span>
    <span class="pl-k">for</span> record <span class="pl-k">in</span> chunk:
        process(record)</pre></div>

<p>Or the iterstuff <code>batch</code> function will do this for you in a simpler way:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> iterstuff <span class="pl-k">import</span> batch
<span class="pl-c1">CHUNK</span> <span class="pl-k">=</span> <span class="pl-c1">1000</span>
<span class="pl-k">for</span> chunk <span class="pl-k">in</span> batch(records, <span class="pl-c1">CHUNK</span>):
    <span class="pl-c"># Chunk is an iterable of up to CHUNK records</span>
    <span class="pl-k">for</span> record <span class="pl-k">in</span> chunk:
        process(record)</pre></div>

<p>Here's an elegant <code>batch</code> solution provided by Hamish Lawson for ActiveState recipes:
<a href="http://code.activestate.com/recipes/303279-getting-items-in-batches/">http://code.activestate.com/recipes/303279-getting-items-in-batches/</a>)</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> itertools <span class="pl-k">import</span> islice, chain
<span class="pl-k">def</span> <span class="pl-en">batch</span>(<span class="pl-smi">iterable</span>, <span class="pl-smi">size</span>):
    sourceiter <span class="pl-k">=</span> <span class="pl-c1">iter</span>(iterable)
    <span class="pl-k">while</span> <span class="pl-c1">True</span>:
        batchiter <span class="pl-k">=</span> islice(sourceiter, size)
        <span class="pl-k">yield</span> chain([batchiter.next()], batchiter)</pre></div>

<p>Note how this uses a call to <code>batchiter.next()</code> to cause <code>StopIteration</code> to be
raised when the source iterable is exhausted. Because this consumes an element,
<code>itertools.chain</code> needs to be used to 'push' that element back onto the head
of the chunk. Using a Lookahead allows us to peek at the next element of the
iterable and avoid the push.  Here's how <code>iterstuff.batch</code> works:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">batch</span>(<span class="pl-smi">iterable</span>, <span class="pl-smi">size</span>):
    <span class="pl-c"># Wrap an enumeration of the iterable in a Lookahead so that it</span>
    <span class="pl-c"># yields (count, element) tuples</span>
    it <span class="pl-k">=</span> Lookahead(<span class="pl-c1">enumerate</span>(iterable))

    <span class="pl-k">while</span> <span class="pl-k">not</span> it.atend:
        <span class="pl-c"># Set the end_count using the count value</span>
        <span class="pl-c"># of the next element.</span>
        end_count <span class="pl-k">=</span> it.peek[<span class="pl-c1">0</span>] <span class="pl-k">+</span> size

        <span class="pl-c"># Yield a generator that will then yield up to</span>
        <span class="pl-c"># 'size' elements from 'it'.</span>
        <span class="pl-k">yield</span> (
            element
            <span class="pl-k">for</span> counter, element <span class="pl-k">in</span> repeatable_takewhile(
                <span class="pl-c"># t[0] is the count part of each element</span>
                <span class="pl-k">lambda</span> <span class="pl-smi">t</span>: t[<span class="pl-c1">0</span>] <span class="pl-k">&lt;</span> end_count,
                it
            )
        )</pre></div>

<h2><a id="user-content-a-conclusion" class="anchor" href="#a-conclusion" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>A Conclusion</h2>

<p>Python generators are a wonderful, powerful, flexible language feature. The
<code>atend</code> and <code>peek</code> properties of the Lookahead class enable a whole set of 
simple recipes for working with generators.</p>

<p>You can see examples of use in the unit tests for this package, and run them
by executing the <code>tests.py</code> file directly.</p>
</article>
  </div></body></html>