<html><body><div><div class="container-fluid">
      <h1>Securing Celery on Heroku</h1>



<p><a href="http://www.celeryproject.org/" title="Celery: Distributed Task Queue">Celery</a> is by far the most popular library in Python for distributing<br/>
asynchronous work using a task queue. If you’re building a Python web app,<br/>
chances are you already use it to send email, perform API integrations, etc.<br/>
Many people choose <a href="http://redis.io/" title="Redis">Redis</a> as their message broker of choice because<br/>
it’s dead simple to set up: provision a Redis addon, use its envrionment<br/>
variable as your <code>BROKER_URL</code>, and you’re done. But the simplicity of Redis<br/>
comes at a cost.  Redis <a href="http://redis.io/topics/security" title="Redis Security">does not currently support SSL</a>, and<br/>
it <a href="https://code.google.com/p/redis/issues/detail?id=71" title="Redis SSL Feature Request">doesn’t seem like that’s going to change any time soon</a>.<br/>
Because Heroku add-ons communicate over the public web, that means the contents<br/>
of Celery jobs are traveling unencrypted between dynos and Redis.</p>



<p>Luckily, this is a solvable problem. At Heroku, we often use <a href="https://github.com/fernet/fernet-rb" title="Fernet">Fernet</a><br/>
to symmetrically encrypt information over the wire. <a href="https://github.com/celery/kombu" title="Kombu">Kombu</a>, Celery’s<br/>
messaging library, supports custom serializers, giving us control over how<br/>
Celery jobs are turned into byte strings to be sent to the message broker and<br/>
vice versa. We’ve wrapped all of the default serializers that come with Kombu in<br/>
Fernet encryption (provided by <a href="https://cryptography.io/" title="Cryptography">Cryptography</a>) and published them<br/>
in an open source library called<br/>
<a href="https://github.com/heroku/kombu-fernet-serializers/" title="Kombu Fernet Serializers">kombu-fernet-serializers</a>.</p>

<p>To use the library, add <code>kombu-fernet-serializers</code> to <code>requirements.txt</code>, store<br/>
your Fernet key in an environment variable called <code>KOMBU_FERNET_KEY</code>, and tell<br/>
Celery to use one of the serializers it supplies<br/>
<a href="http://kombu.readthedocs.org/en/latest/userguide/serialization.html#creating-extensions-using-setuptools-entry-points">via Setuptools entry-points</a>:</p>

<pre><code class="language-python">import os
from celery import Celery
from kombu_fernet.serializers.json import MIMETYPE

app = Celery('tasks', broker=os.environ['REDIS_URL'])
app.conf.update(
    CELERY_TASK_SERIALIZER='fernet_json',
    CELERY_ACCEPT_CONTENT=[MIMETYPE],
)
</code></pre>

<p>Now you can take advantage of the ease of configuration Redis boasts without<br/>
having to worry about leaking sensitive information.</p>



    </div>

    </div></body></html>