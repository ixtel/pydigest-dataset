<html><body><div><div class="section" id="backward-compatibility">
     
     <p>
      It has been suggested that backward compatibility can be improved if
the default value of the
      <tt class="docutils literal">
       fold
      </tt>
      flag was
      <tt class="docutils literal">
       None
      </tt>
      which would
signal that pre-PEP behavior is requested.  Based on the analysis
below, we believe that the proposed changes with the
      <tt class="docutils literal">
       fold=0
      </tt>
      default are sufficiently backward compatible.
     </p>
     <p>
      This PEP provides only three ways for a program to discover that two
otherwise identical datetime instances have different values of
      <tt class="docutils literal">
       fold
      </tt>
      : (1) an explicit check of the
      <tt class="docutils literal">
       fold
      </tt>
      attribute; (2) if
the instances are naive - conversion to another timezone using the
      <tt class="docutils literal">
       astimezone()
      </tt>
      method; and (3) conversion to
      <tt class="docutils literal">
       float
      </tt>
      using the
      <tt class="docutils literal">
       timestamp()
      </tt>
      method.
     </p>
     <p>
      Since
      <tt class="docutils literal">
       fold
      </tt>
      is a new attribute, the first option is not available
to the existing programs.  Note that option (2) only works for naive
datetimes that happen to be in a fold or a gap in the system time
zone.  In all other cases, the value of
      <tt class="docutils literal">
       fold
      </tt>
      will be ignored in
the conversion unless the instances use a
      <tt class="docutils literal">
       fold
      </tt>
      -aware
      <tt class="docutils literal">
       tzinfo
      </tt>
      which would not be available in a pre-PEP program.  Similarly, the
      <tt class="docutils literal">
       astimezone()
      </tt>
      called on a naive instance will not be available in
such program because
      <tt class="docutils literal">
       astimezone()
      </tt>
      does not currently work with
naive datetimes.
     </p>
     <p>
      This leaves us with only one situation where an existing program can
start producing different results after the implementation of this PEP:
when a
      <tt class="docutils literal">
       datetime.timestamp()
      </tt>
      method is called on a naive datetime
instance that happen to be in the fold or the gap.  In the current
implementation, the result is undefined.  Depending on the system
      <tt class="docutils literal">
       mktime
      </tt>
      implementation, the programs can see different results or
errors in those cases.  With this PEP in place, the value of timestamp
will be well-defined in those cases but will depend on the value of
the
      <tt class="docutils literal">
       fold
      </tt>
      flag.  We consider the change in
      <tt class="docutils literal">
       datetime.timestamp()
      </tt>
      method behavior a bug fix enabled by this
PEP.  The old behavior can still be emulated by the users who depend
on it by writing
      <tt class="docutils literal">
       <span class="pre">
        time.mktime(dt.timetuple())
       </span>
       +
       <span class="pre">
        1e-6*dt.microsecond
       </span>
      </tt>
      instead of
      <tt class="docutils literal">
       dt.timestamp()
      </tt>
      .
     </p>
    </div>
    <div class="section" id="analogy-with-tm-isdst">
     
     <p>
      The
      <tt class="docutils literal">
       time.mktime
      </tt>
      interface allows three values for the
      <tt class="docutils literal">
       tm_isdst
      </tt>
      flag: -1, 0, and 1.  As we explained above, -1 (asking
      <tt class="docutils literal">
       mktime
      </tt>
      to
determine whether DST is in effect for the given time from the rest of
the fields) is the only choice that is useful in practice.
     </p>
     <p>
      With the
      <tt class="docutils literal">
       fold
      </tt>
      flag, however,
      <tt class="docutils literal">
       datetime.timestamp()
      </tt>
      will return
the same value as
      <tt class="docutils literal">
       mktime
      </tt>
      with
      <tt class="docutils literal">
       <span class="pre">
        tm_isdst=-1
       </span>
      </tt>
      in 99.98% of the
time for most time zones with DST transitions.  Moreover,
      <tt class="docutils literal">
       <span class="pre">
        tm_isdst=-1
       </span>
      </tt>
      -like behavior is specified
      <em>
       regardless
      </em>
      of the value
of
      <tt class="docutils literal">
       fold
      </tt>
      .
     </p>
     <p>
      It is only in the 0.02% cases (2 hours per year) that the
      <tt class="docutils literal">
       datetime.timestamp()
      </tt>
      and
      <tt class="docutils literal">
       mktime
      </tt>
      with
      <tt class="docutils literal">
       <span class="pre">
        tm_isdst=-1
       </span>
      </tt>
      may
disagree.  However, even in this case, most of the
      <tt class="docutils literal">
       mktime
      </tt>
      implementations will return the
      <tt class="docutils literal">
       fold=0
      </tt>
      or the
      <tt class="docutils literal">
       fold=1
      </tt>
      value even though relevant standards allow
      <tt class="docutils literal">
       mktime
      </tt>
      to return -1 and
set an error code in those cases.
     </p>
     <p>
      In other words,
      <tt class="docutils literal">
       <span class="pre">
        tm_isdst=-1
       </span>
      </tt>
      behavior is not missing from this PEP.
To the contrary, it is the only behavior provided in two different
well-defined flavors.  The behavior that is missing is when a given
local hour is interpreted as a different local hour because of the
misspecified
      <tt class="docutils literal">
       tm_isdst
      </tt>
      .
     </p>
     <p>
      For example, in the DST-observing time zones in the Northern
hemisphere (where DST is in effect in June) one can get
     </p>
     <pre class="code literal-block">
&gt;&gt;&gt; from time import mktime, localtime
&gt;&gt;&gt; t = mktime((2015, 6, 1, 12, 0, 0, -1, -1, 0))
&gt;&gt;&gt; localtime(t)[:]
(2015, 6, 1, 13, 0, 0, 0, 152, 1)
</pre>
     <p>
      Note that 12:00 was interpreted as 13:00 by
      <tt class="docutils literal">
       mktime
      </tt>
      .  With the
      <tt class="docutils literal">
       datetime.timestamp
      </tt>
      ,
      <tt class="docutils literal">
       datetime.fromtimestamp
      </tt>
      , it is currently
guaranteed that
     </p>
     <pre class="code literal-block">
&gt;&gt;&gt; t = datetime.datetime(2015, 6, 1, 12).timestamp()
&gt;&gt;&gt; datetime.datetime.fromtimestamp(t)
datetime.datetime(2015, 6, 1, 12, 0)
</pre>
     <p>
      This PEP extends the same guarantee to both values of
      <tt class="docutils literal">
       fold
      </tt>
      :
     </p>
     <pre class="code literal-block">
&gt;&gt;&gt; t = datetime.datetime(2015, 6, 1, 12, fold=0).timestamp()
&gt;&gt;&gt; datetime.datetime.fromtimestamp(t)
datetime.datetime(2015, 6, 1, 12, 0)
</pre>
     <pre class="code literal-block">
&gt;&gt;&gt; t = datetime.datetime(2015, 6, 1, 12, fold=1).timestamp()
&gt;&gt;&gt; datetime.datetime.fromtimestamp(t)
datetime.datetime(2015, 6, 1, 12, 0)
</pre>
     <p>
      Thus one of the suggested uses for
      <tt class="docutils literal">
       <span class="pre">
        fold=-1
       </span>
      </tt>
      -- to match the legacy
behavior -- is not needed.  Either choice of
      <tt class="docutils literal">
       fold
      </tt>
      will match the
old behavior except in the few cases where the old behavior was
undefined.
     </p>
    </div>
    <div class="section" id="strict-invalid-time-checking">
     
     <p>
      Another suggestion was to use
      <tt class="docutils literal">
       <span class="pre">
        fold=-1
       </span>
      </tt>
      or
      <tt class="docutils literal">
       fold=None
      </tt>
      to
indicate that the program truly has no means to deal with the folds
and gaps and
      <tt class="docutils literal">
       dt.utcoffset()
      </tt>
      should raise an error whenever
      <tt class="docutils literal">
       dt
      </tt>
      represents an ambiguous or missing local time.
     </p>
     <p>
      The main problem with this proposal, is that
      <tt class="docutils literal">
       dt.utcoffset()
      </tt>
      is
used internally in situations where raising an error is not an option:
for example, in dictionary lookups or list/set membership checks.  So
strict gap/fold checking behavior would need to be controlled by a
separate flag, say
      <tt class="docutils literal">
       dt.utcoffset(raise_on_gap=True,
raise_on_fold=False)
      </tt>
      .  However, this functionality can be easily
implemented in user code:
     </p>
     <pre class="code literal-block">
def utcoffset(dt, raise_on_gap=True, raise_on_fold=False):
    u = dt.utcoffset()
    v = dt.replace(fold=not dt.fold).utcoffset()
    if u == v:
        return u
    if (u &lt; v) == dt.fold:
        if raise_on_fold:
            raise AmbiguousTimeError
    else:
        if raise_on_gap:
            raise MissingTimeError
    return u
</pre>
     <p>
      Moreover, raising an error in the problem cases is only one of many
possible solutions.  An interactive program can ask the user for
additional input, while a server process may log a warning and take an
appropriate default action.  We cannot possibly provide functions for
all possible user requirements, but this PEP provides the means to
implement any desired behavior in a few lines of code.
     </p>
    </div>
   </div></body></html>