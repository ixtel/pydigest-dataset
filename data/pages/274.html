<html><body><div><div class="ibm-col-1-1">

<h2 id="N1004B">Введение</h2><p>В этой статье мы рассмотрим несколько "сторонних" пакетов Python, упрощающих интеграцию С и Python 
фрагментов в рамках единого приложения.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N10051">Пакет distutils</h2><p>Первым из рассматриваемых инструментов должен быть пакет <strong><code>distutils</code></strong>, 
входящий в состав стандартной библиотеки Python. Этот пакет является важным компонентом технологии Python, 
так как служит стандартным инструментом для распространения (дистрибуции) собственных пакетов Python. Но 
с его помощью можно наладить и взаимодействие между С и Python кодом, как будет показано в данной статье.</p><p>Для демонстрации <strong><code>distutils</code></strong> мы воспользуемся примером, который будет похож 
на модули из предыдущей статьи, правда исходный код модуля будет значительно упрощен для простоты 
изложения. В листинге 1 представлен исходный модуль на языке С (файл <strong>ownmod.c</strong> из архива 
<strong>python_c_interaction.tgz</strong> в разделе "Материалы для скачивания"):</p><h5 id="listing1">Листинг 1. Код модуля (язык C)</h5><div class="codesection"><pre class="displaycode">#include &lt;Python.h&gt;

static PyObject* py_echo( PyObject* self, PyObject* args ) {
   printf( "вывод из экспортированного кода!\n" );
   return Py_None;
}

static PyMethodDef ownmod_methods[] = {
   { "echo", py_echo, METH_NOARGS, "echo function" },
   { NULL, NULL }
};

PyMODINIT_FUNC initownmod() {
   (void)Py_InitModule( "ownmod", ownmod_methods );
}</pre></div><p>Алгоритм работы <strong><code>distutils</code></strong> определяется небольшим 
конфигурационным файлом <strong><code>setup.py </code></strong> (который сам пишется на 
Python), представленным в листинге 2:</p><h5 id="N1007A">Листинг 2. Конфигурационный файл</h5><div class="codesection"><pre class="displaycode">from distutils.core import setup, Extension

module1 = Extension( 'ownmod', sources = ['ownmod.c'] )

setup( name = 'ownmod',
       version = '1.1',
       description = 'This is a first package',
       ext_modules = [module1]
     )</pre></div><p>Используя эти 2 файла процесс создания модуля можно запустить, как показано ниже (в архиве 
<strong>python_c_interaction.tgz</strong> эти действия включены в Makefile):</p><div class="codesection"><pre class="displaycode"><strong>$ python setup.py build</strong>
running build
running build_ext
building 'ownmod' extension
creating build
creating build/temp.linux-i686-2.7
gcc -pthread -fno-strict-aliasing -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 \
    ... \
    -fPIC -I/usr/include/python2.7 -c ownmod.c -o build/temp.linux-i686-2.7/ownmod.o
creating build/lib.linux-i686-2.7
gcc -pthread -shared -Wl,-z,relro build/temp.linux-i686-2.7/ownmod.o \
    -L/usr/lib -lpython2.7 -o build/lib.linux-i686-2.7/ownmod.so
<strong>$ cp build/lib.linux-i686-2.7/ownmod.so ./</strong></pre></div><p>В процессе сборки создаётся подкаталог <strong>build/lib.linux-i686-2.7/</strong>, в котором и собирается 
файл модуля <strong>ownmod.so</strong>, а вторая команда (копирования) используется только для переноса 
модуля в более удобное место для тестирования.</p><p>Теперь мы можем запустить простейшее тестовое приложения, импортирующее созданный модуль 
<strong><code>ownmod</code></strong>:</p><div class="codesection"><pre class="displaycode">#!/usr/bin/python
# -*- coding: utf-8 -*-
import ownmod
ownmod.echo()</pre></div><p>Как и ожидалось, всё работает без ошибок:</p><div class="codesection"><pre class="displaycode"><strong>$ ./test.py</strong>
вывод из экспортированного кода!</pre></div><p>В показанном примере с <strong><code>distutils</code></strong> написание самого кода модуля 
практически ничем не отличается от ручного способа сборки, который демонстрировался в предыдущей статье, 
но процесс сборки упрощается на порядок.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N100AC">Библиотека Boost.Python</h2><p>Проект Boost — это шаг на пути к мульти-платформенной разработке для C++ проектов, так как код, 
построенный на Boost, работает без изменений на платформах Windows, Linux, Solaris, FreeBSD и др.</p><p>На данный момент полный Boost представляет собой <strong>набор</strong> из нескольких десятков 
разнообразных инструментов от <strong>различных</strong> разработчиков, иногда очень слабо связанных 
между собой. Некоторые из составных частей Boost используются повсеместно (например, 
<strong><code>Thread</code></strong>, <strong><code>Regex</code></strong>, 
<strong><code>Boost Filesystem Library</code></strong>, <strong><code>Signals</code></strong>, 
...). Другие составные части Boost являются, скорее, экзотикой, и используются только узкими специалистами 
(<strong><code>Lambda</code></strong>, <strong><code>Identity Type</code></strong>, 
<strong><code>Meta State Machine</code></strong>, ...). Конечно, при такой философии наполнения 
Boost не мог обойти стороной и Python. Эта часть Boost известна как 
<strong><code>Boost Python Library</code></strong> (автор Dave Abrahams).</p><p>Подготовим тестовый проект, в котором мы будем использовать Boost для вызова C++ кода. В листингах 
ниже представлены необходимые файлы, которые также можно найти в архиве <strong>python_c_interaction.tgz</strong>.</p><h5 id="N100E1">Листинг 3. Исходный код вызываемого модуля (файл ownmod.cc)</h5><div class="codesection"><pre class="displaycode">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

void echo( void ) {
   cout &lt;&lt; "вывод из экспортированного кода!" &lt;&lt; endl;
}</pre></div><h5 id="N100E8">Листинг 4. Общий заголовок (файл ownmod.h)</h5><h5 id="N100EF">Листинг 5. Файл интерфейса Boost (файл ownmod_wrap.cc)</h5><div class="codesection"><pre class="displaycode">#include &lt;boost/python.hpp&gt;
#include "ownmod.h"

BOOST_PYTHON_MODULE( ownmod ) {
    using namespace boost::python;
    def( "echo", echo );
}</pre></div><p>Соберём модуль, как показано ниже:</p><div class="codesection"><pre class="displaycode"><strong>$ c++ -c -fpic ownmod.cc</strong><strong>$ c++ -c -fpic ownmod_wrap.cc `python-config --includes`</strong><strong>$ ls *.o</strong>
ownmod.o  ownmod_wrap.o
<strong>$ c++ -shared ownmod_wrap.o ownmod.o -l boost_python -o ownmod.so</strong><strong>$ ls *.so</strong>
ownmod.so</pre></div><p>Для тестирования используем уже знакомое приложение:</p><div class="codesection"><pre class="displaycode"><strong>$ python test.py</strong>
вывод из экспортированного кода!</pre></div><p>Это общая схема использования <strong><code>Boost.Python</code></strong>. На практике 
возможно возникновение сложностей при необходимости передавать параметры и возвращать значения. Но все 
особенности реализации этих действий подробно описаны в документации 
<strong><code>Boost.Python</code></strong> (см. раздел "Ресурсы"). В архиве 
<strong>python_c_interaction.tgz</strong> находится простой пример (подкаталог <strong>libra</strong>) с 
передачей параметров и возвратом значений (здесь не рассматривается).</p><p>Из всех рассмотренных способов взаимодействия с кодом, написанным на языке С++, 
<strong><code>Boost.Python</code></strong> является самым простым в использовании.</p><p><strong>Примечание</strong>. К сожалению, <strong><code>Boost.Python</code></strong> — это 
уже устаревший проект, так как разработка его основных компонентов была завершена к 2003 году. Хотя он 
замечательно работает с Python 2, но с Python 3 всё не так просто, и вопрос адаптации 
<strong><code>Boost.Python</code></strong> к Python 3 требует изучения.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N1012F">Проект Cython</h2><p>На самом деле, проект Cython является своеобразным клоном языка Python с совместимым синтаксисом, но 
позволяющий, с некоторыми ограничениями на статические определения типов, <strong>компилировать</strong> 
программу сразу в исполняемый код (в отличие от интерпретации байт-кода в Python). В зависимости от класса 
задач, утверждается что это позволяет ускорить выполнение в 100 или даже 1000 раз!</p><p>Но кроме этого, Cython — язык программирования, упрощающий написание С/С++ модулей для 
Python-приложений. В коде, написанном на Cython, кроме стандартного синтаксиса Python поддерживается и 
прямой вызов функций и методов С/С++. Код Cython <strong>преобразуется</strong> в С/С++ код для 
последующей компиляции, и впоследствии может использоваться либо как расширение стандартного Python, 
либо как независимое приложение со встроенной библиотекой выполнения Cython.</p><p>Cython потребуется установить дополнительно, так как по умолчанию он, скорее всего, будет отсутствовать 
в системе. Это можно сделать из исходных кодов на сайте проекта, но в данный момент Cython настолько 
распространён, что его инсталляционный пакет присутствует практически во всех дистрибутивах Linux, 
например:  </p><div class="codesection"><pre class="displaycode"><strong>$ yum list cython</strong>
...
Доступные пакеты
Cython.i686            0.18-1.fc17           updates</pre></div><p>Сначала рассмотрим, как в Cython выполнить создание модуля из Python-совместимого кода. При 
построении модуля средствами Cython используется уже рассмотренный пакет 
<strong><code>distutils</code></strong>, но конфигурационный файл <strong>setup.py</strong> 
будет иметь уже другое содержание:</p><h5 id="N10150">Листинг 6. Конфигурационный файл</h5><div class="codesection"><pre class="displaycode">from distutils.core import setup
from distutils.extension import Extension
from Cython.Distutils import build_ext

ext_modules = [ Extension( "ownmod", [ "ownmod.pyx"] ) ]

setup(
  name = 'first app',
  cmdclass = { 'build_ext': build_ext },
  ext_modules = ext_modules
)</pre></div><p>Реализация самого модуля останется практически без изменений, как можно увидеть в листинге 7. Его 
исходный код также можно найти в файле <strong>ownmod.pyx</strong> в архиве 
<strong>python_c_interaction.tgz</strong> (Cython использует расширение <strong>.pyx</strong>, чтобы 
обозначить, что этот код подлежит компиляции, в отличие от расширения <strong>.py</strong> в Python):</p><h5 id="N10165">Листинг 7. Код модуля</h5><div class="codesection"><pre class="displaycode">def echo():
   print "вывод из компилированного (cython) кода!"</pre></div><p>Как уже говорилось, код на Cython требует компиляции. Этот процесс состоит из двух последовательных 
этапов:</p><ul class="ibm-bullet-list"><li>
Cython компилирует .pyx-файл в .c-файл, содержащий код модуля расширения Python;
</li><li>
Компилятор языка C компилирует далее полученный <code>.c</code>-файл в 
<code>.so</code>-файл, который можно импортировать обычным образом как модуль, прямо из 
Python-кода.
</li></ul><p>Обратите внимание, что благодаря обобщённой схеме (независимо от того, модуль написан на С или на 
Cython) с библиотекой модуля можно связать любой код на языке C. Выполняется это так:</p><div class="codesection"><pre class="displaycode"><strong>$ python setup.py build_ext --inplace</strong>
running build_ext
cythoning ownmod.pyx to ownmod.c
building 'ownmod' extension
creating build
creating build/temp.linux-i686-2.7
gcc -pthread -fno-strict-aliasing -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 ...\
    -fPIC -I/usr/include/python2.7 -c ownmod.c -o build/temp.linux-i686-2.7/ownmod.o
gcc -pthread -shared -Wl,-z,relro build/temp.linux-i686-2.7/ownmod.o
    -L/usr/lib -lpython2.7 -o /home/olej/2013_WORK/Python/PythonC/cython/pfirst/ownmod.so
<strong>$ ls *.so</strong>
ownmod.so</pre></div><p>Модуль можно вызывать из кода, написанного на Python, невзирая на то, что сам модуль был написан на 
Cython:</p><div class="codesection"><pre class="displaycode"><strong>$ python</strong>
Python 2.7.3 (default, Jul 24 2012, 10:05:39)
[GCC 4.7.0 20120507 (Red Hat 4.7.0-5)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; <strong>import ownmod</strong>
&gt;&gt;&gt; <strong>ownmod.echo()</strong>
вывод из компилированного (cython) кода!
&gt;&gt;&gt; <strong>quit()</strong></pre></div><p>В следующем примере мы реализуем математические вычисления (многократное вычисление 
<strong><code>sin(x)</code></strong>) и добавим в Cython-код статические определения типов в 
силе C (<strong><code>cdef</code></strong>), а также подключим функцию вычисления 
<strong><code>sin(x)</code></strong> из стандартной библиотеки C 
(<strong><code>libm.so</code></strong>). Два варианта реализации функции 
<strong><code>sin(x)</code></strong> на Cython показаны в листинге 8.:</p><h5 id="N101AA">Листинг 8. Математические вычисления на Cython (файл csin.pyx)</h5><div class="codesection"><pre class="displaycode">import time
import math

def sin1( int n ):
    cdef int i
    cdef double x, clc
    x = 0.0
    clc = time.time()
    for i in xrange( n ):
        x += math.sin( x )
    return time.time() - clc

cdef extern from "math.h":
    double sin( double )

def sin2( n ):
    x = 0.0
    clc = time.time()
    for i in xrange( n ):
        x += sin( x )
    return time.time() - clc</pre></div><p>В листинге 9 показана эквивалентная реализация той же функции на Python.</p><h5 id="N101B3">Листинг 9. Математические вычисления на Python (файл psin.py)</h5><div class="codesection"><pre class="displaycode">import time
import math

def sin0( n ):
    x = 0.0
    clc = time.time()
    for i in xrange( n ):
        x += math.sin( x )
    return time.time() - clc</pre></div><p>В листинге 10 показан конфигурационный файл <strong>setup.py</strong> пакета 
<strong><code>distutils</code></strong> для сборки Cython-реализации модуля (обратите внимание 
на подключение библиотеки <strong>libm.so</strong>):</p><h5 id="N101C6">Листинг 10. Конфигурационный файл</h5><div class="codesection"><pre class="displaycode">from distutils.core import setup
from distutils.extension import Extension
from Cython.Distutils import build_ext

ext_modules = [ Extension( "csin", [ "csin.pyx" ], libraries=["m"] ) ]

setup(
  cmdclass = { 'build_ext': build_ext },
  ext_modules = ext_modules
)</pre></div><p>Теперь всё готово для сборки компилированной библиотеки <strong><code>csin.so</code></strong> для нашего модуля:</p><div class="codesection"><pre class="displaycode"><strong>$ python setup.py build_ext --inplace</strong>
running build_ext
cythoning csin.pyx to csin.c
building 'csin' extension
creating build
creating build/temp.linux-i686-2.7
gcc -pthread -fno-strict-aliasing -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 ...\
    -fPIC -I/usr/include/python2.7 -c csin.c -o build/temp.linux-i686-2.7/csin.o
gcc -pthread -shared -Wl,-z,relro build/temp.linux-i686-2.7/csin.o -L/usr/lib ... \
    -lm -lpython2.7 -o /home/olej/2013_WORK/Python/PythonC/cython/math/csin.so</pre></div><p>В листинге 11 показано тестовое приложение, сравнивающее 3 варианта реализации по затратам на время 
выполнения:</p><h5 id="N101DB">Листинг 11. Тестовое приложение (файл test.py)</h5><div class="codesection"><pre class="displaycode">#!/usr/bin/python
# -*- coding: utf-8 -*-

from sys import argv
from psin import sin0 as t1
from csin import sin1 as t2
from csin import sin2 as t3

n = ( len( argv ) &gt; 1 and int( argv[ 1 ] ) ) or 5000000
print "время %i вычислений %5.2f секунд" % ( n, t1( n ) )
print "время %i вычислений %5.2f секунд" % ( n, t2( n ) )
print "время %i вычислений %5.2f секунд" % ( n, t3( n ) )</pre></div><p>В итоге получается, что реализация на Python оказалась быстрее реализации на Cython, но самой быстрой 
оказалась Cython-версия с использованием C-функции <strong><code>sin(x)</code></strong> из библиотеки 
<strong><code>libm.so</code></strong>:</p><div class="codesection"><pre class="displaycode"><strong>$ ./test.py</strong>
время 5000000 вычислений  2.40 секунд
время 5000000 вычислений  2.66 секунд
время 5000000 вычислений  0.15 секунд</pre></div><p>Вопреки ожиданиям, компилированная Cython-версия уступила традиционной реализации на Python. Это 
понятно, так как большую долю времени в вычислениях занимает вычисление 
<strong><code>sin(x)</code></strong>, производимое 
<strong>модулем <code>math</code></strong> из библиотеки модулей Python. Но как только мы 
присоединили к модулю Cython C-реализацию функции <strong><code>sin(x)</code></strong> из 
библиотеки <strong><code>libm.so</code></strong>, то скорость вычислений выросла в 18 раз.</p><p>В этом примере было показано использование в модуле C-реализации из собранной библиотеки 
<strong>libm.so</strong>, без доступа к исходному коду реализации. Очевидно, что 
прикомпоновать к DLL модуля (подобной <strong>csin.so</strong>) объектный код, полученный компиляцией 
собственного исходного кода на C (или C++) ещё проще. В архиве примеров показаны несколько вариантов 
такого подключения (подкаталог <strong>xfirst</strong>).</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N1020E">Заключение</h2><p>В этой статье мы познакомились ещё с тремя способами для интеграции С и Python-приложений: пакет distutils, 
библиотека Boost.Python и проект Cython.</p><p>В следующей статье мы рассмотрим SWIG — ещё один способ для интеграции C и Python и решим обратную 
задачу по вызову Python-кода из C-приложений.</p>
<p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="download">Загрузка</h2>

</div>
</div></body></html>