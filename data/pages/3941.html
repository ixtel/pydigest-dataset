<html><body><div><div id="main_content">
  <p>Update (4/7): 欢迎来自于<a href="http://weekly.pychina.org/issue/issue-160.html">蠎周刊</a>的朋友！</p>

<p>The <a href="http://en.wikipedia.org/wiki/Actor_model">actor model</a> is a conceptually simple way of managing concurrency, in which each object stands alone, passing only messages between one another. For a recent project I was looking for an actor implementation based on Python's new asyncio library, and couldn't find one, so I made one myself.</p>

<p>Introducing <a href="https://github.com/biesnecker/cleveland">cleveland</a>, named in honor of <a href="http://en.wikipedia.org/wiki/Carol_Cleveland">Carol Cleveland</a> (pictured above), the only major female cast member of <em>Monty Python's Flying Circus</em>.</p>

<h3>tl;dr</h3>

<p>Lightweight, extensible actors based on Python 3.4's <code>asyncio</code> library. <a href="https://github.com/biesnecker/cleveland">Get it from Github</a>, or just <code>pip install cleveland</code>.</p>

<h3>Getting started</h3>

<p>An actor can define one or more tasks that it runs constantly until shutdown. <code>BaseActor</code> provides the machinery for registering these tasks but doesn't provide any actual tasks of its own, so we'll start off with <code>ListeningActor</code>, which implements a message inbox and can both send and receive messages from other actors (<code>BaseActor</code> can send, as we'll see below, but can't receive). Below is a trivial example in which an instance of <code>BaseActor</code> sends a message to a <code>PrintActor</code> (which we subclass from <code>ListeningActor</code>) ten times, and then both of the actors shut down.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">cleveland.actor</span> <span class="kn">import</span> <span class="n">BaseActor</span><span class="p">,</span> <span class="n">ListeningActor</span>
<span class="kn">from</span> <span class="nn">cleveland.message</span> <span class="kn">import</span> <span class="n">Message</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">class</span> <span class="nc">StringMessage</span><span class="p">(</span><span class="n">Message</span><span class="p">):</span> <span class="k">pass</span>

<span class="k">class</span> <span class="nc">PrintActor</span><span class="p">(</span><span class="n">ListeningActor</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_message_handler</span><span class="p">(</span>
            <span class="n">StringMessage</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_string_message_handler</span>
        <span class="p">)</span>


    <span class="nd">@asyncio.coroutine</span>
    <span class="k">def</span> <span class="nf">_string_message_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">payload</span><span class="p">)</span>


<span class="nd">@asyncio.coroutine</span>
<span class="k">def</span> <span class="nf">say_hello</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">BaseActor</span><span class="p">()</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">PrintActor</span><span class="p">()</span>
    <span class="n">a</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">b</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">StringMessage</span><span class="p">(</span><span class="s">'Hello world!'</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.25</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="n">a</span><span class="o">.</span><span class="n">tell</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
    <span class="k">yield from</span> <span class="n">a</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
    <span class="k">yield from</span> <span class="n">b</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">say_hello</span><span class="p">())</span></code></pre></div>

<p>You should see "Hello world!" printed ten times on the console, and then a clean and graceful exit. Not much, but it highlights some of the machinery that these actors provide.</p>

<h3>Tasks</h3>

<p>Everything an actor should do during its life is defined by tasks. Tasks are registered during the actor's initialization, and then run constantly in a loop until shutting down. As mentioned before, <code>BaseActor</code> provides the <code>register_task_handler</code> method to add new tasks, but doesn't register any itself. Instead, we'll look at how <code>ListeningActor</code> implements the task to listen for incoming messages.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">ListeningActor</span><span class="p">(</span><span class="n">BaseActor</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_task_handler</span><span class="p">(</span>
            <span class="s">'__message_loop'</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_inbox</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shutdown_message_loop</span>
        <span class="p">)</span></code></pre></div>

<p>The first argument is the name of the task, which should be unique within the actor. The second is the function that will be called by the actor's task loop, and it must be an <code>asyncio.coroutine</code> (because it will be <code>yield from</code>ed). The third argument is the function (also an <code>asyncio.coroutine</code>) that will be called when the actor is shut down. This third point is a bit complex, and worth spending some time on.</p>

<h3>Shutting down gracefully</h3>

<p>One of the challenges of asynchronous systems is that you never really know when anything is going to happen, so it's hard to know when something is done. Even the definition of "done" is application specific -- is it when there are no more messages to be processed, or when a certain amount of time has elapsed, or something else entirely? Shutdown functions provide a way to define custom shutdown behavior for a task, the results of which are automatically picked up by the underlying shutdown code so that an actor can't shutdown without first cleanly shutting down all of its tasks.</p>

<p>Here's how <code>_shutdown_message_loop</code> is defined:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="nd">@asyncio.coroutine</span>
<span class="k">def</span> <span class="nf">_shutdown_message_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_receive</span><span class="p">(</span><span class="n">StopMessage</span><span class="p">())</span>
    <span class="k">return</span> <span class="bp">True</span></code></pre></div>

<p>In this case, all it does is insert a "poison pill" into the actor's inbox, and then returns. This is because the messaging processing task blocks waiting for the next message to arrive, and will never return in the case that the shutdown occurs after the last message arrives. The return value is then stored in a future that was created when the task was started, and can be referenced by other shutdown functions (more on that in a later post).</p>

<h3>Messages</h3>

<p>Most of the work that your actors will do are the result of an incoming message. Every message an actor receives need to be handled by a message handler.</p>

<p>Messages are differentiated by class -- you need to subclass <code>Message</code> for each distinct message type you will handle. You register these handlers in the actor's <code>__init__()</code> function.</p>

<p>This is the registration for the "poison pill" <code>StopMessage</code> mentioned earlier.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">register_message_handler</span><span class="p">(</span><span class="n">StopMessage</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_message_handler</span><span class="p">)</span></code></pre></div>

<p>The first argument is the class of the message for which the handler is responsible. The handler itself should be an <code>asyncio.coroutine</code>, and take the message as an argument. You can do anything you want as the result of a message, though you should make sure that it doesn't block.</p>

<h3>More to come</h3>

<p>I purposely made these actors lightweight and bare -- this is meant to be a simple infrastructure for more complex patterns, rather than an out-of-the-box solution to all of your concurrent processing needs. I'm looking forward to building more powerful things on top of <code>cleveland</code> in the near future.</p>

  </div>

  
  <p>If you enjoyed this post, please share it with others who would also enjoy it.</p>
  </div></body></html>