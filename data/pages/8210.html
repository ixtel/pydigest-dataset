<html><body><div><div class="post-text" itemprop="text">
<blockquote>
  <p><strong>How to convert C++ boost regexest to Python</strong></p>
</blockquote>

<p>In case of a simple regex, like <code>\w+\s+\d+</code>, or <code>&gt;.*$</code> you won't have to change the pattern. In case of more complex patterns with constructs mentioned below, you will most probably have to re-write a regex. As with any conversion from one flavor/language to another, the general answer is <strong>DON'T</strong>. However, Python and Boost do have some similarities, especially when it comes to simple patterns (if Boost is using PCRE-like pattern) containing a dot (<code>a.*b</code>), regular (<code>[\w-]*</code>) and negated (<code>[^&gt;]*</code>) character classes, regular quantifiers like <code>+</code>/<code>*</code>/<code>?</code>, and suchlike.</p>

<blockquote>
  <p><strong>what is the difference between boost regexes and python <code>re</code> regexes?</strong></p>
</blockquote>

<p><strong><a href="https://docs.python.org/2/library/re.html#module-re" rel="nofollow">Python <code>re</code> module</a></strong> is not that rich as <strong><a href="http://www.boost.org/doc/libs/1_55_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html" rel="nofollow">Boost regexps</a></strong> (suffice is to mention such constructs as <a href="http://www.boost.org/doc/libs/1_55_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html" rel="nofollow"><code>\h</code>, <code>\G</code>, <code>\K</code>, <code>\R</code>, <code>\X</code>, <code>\Q...\E</code>, branch reset, recursion, possessive quantifiers, POSIX character classes and character properties</a>, <a href="http://www.boost.org/doc/libs/1_55_0/libs/regex/doc/html/boost_regex/format/boost_format_syntax.html" rel="nofollow">extended replacement pattern</a>), and other features that Boost has. The <code>(?imsx-imsx:pattern)</code> is limited to the whole expression in Python, not to a part of it thus you should be aware that <code>(?i)</code> in your <code>&amp;amp;|&amp;#((?i)x26);|&amp;#38;</code> will be treated as if it were at the beginning of the pattern (however, it does not have any impact on this expression).</p>

<p>Also, same as in Boost, you do not have to escape <code>[</code> inside a character class, and <code>{</code> outside the character class.</p>

<p>The backreferences  like <code>\1</code> are the same as in Python.</p>

<p>Since you are not using capturing groups in alternation in your patterns (e.g. <code>re.sub(r'\d(\w)|(go\w*)', '\2', 'goon')</code>), there should be no problem (in such cases, Python does not fill in the non-participating group with any value, and returns an empty result).</p>

<p>Note the difference in named group definition: <code>(?&lt;NAME&gt;expression)</code>/<code>(?'NAME'expression)</code> in Boost, and <code>(?P&lt;NAME&gt;expression)</code> in Python.</p>

<p>I see your regexps mainly fall under "simple" category. The most complex pattern is a <a href="http://www.rexegg.com/regex-quantifiers.html#tempered_greed" rel="nofollow"><em>tempered greedy token</em></a> (e.g. <code>⌊-((?:(?!-⌋).)*)-⌋</code>). To optimize them, you could use an <em><a href="http://www.softec.lu/site/RegularExpressions/UnrollingTheLoop" rel="nofollow">unroll the loop</a></em> technique, but it may not be necessary depending on the size of texts you handle with the expressions.</p>

<p>The most troublesome part as I see it is that you are using Unicode literals heavily. In Python 2.x, all strings are byte arrays, and you will always have to make sure you pass a unicode object to the Unicode regexps (see <a href="https://docs.python.org/2/howto/unicode.html#python-2-x-s-unicode-support" rel="nofollow"><em>Python 2.x’s Unicode Support</em></a>). In Python 3, all strings are UTF8 by default, and you can even use UTF8 literal characters in source code without any additional actions (see <a href="https://docs.python.org/3/howto/unicode.html#python-s-unicode-support" rel="nofollow"><em>Python’s Unicode Support</em></a>). So, Python 3.3+ (with support for raw string literals) is a good candidate.</p>

<p>Now, as for the remaining questions:</p>

<blockquote>
  <p>in boost, there's <code>boost::u32regex_match</code>, is that the same as  <code>re.match</code>?</p>
</blockquote>

<p>The <strong><a href="https://docs.python.org/2/library/re.html#re.match" rel="nofollow"><code>re.match</code></a></strong> is not the same as regex_match as <code>re.match</code> is looking for the match <strong><em>at the beginning of the string</em></strong>, and <a href="http://www.boost.org/doc/libs/1_42_0/libs/regex/doc/html/boost_regex/ref/regex_match.html" rel="nofollow"><code>regex_match</code></a> requires <strong><em>a full string match</em></strong>. However, in Python 3, you can use <strong><a href="https://docs.python.org/3/library/re.html#re.fullmatch" rel="nofollow"><code>re.fullmatch(pattern, string, flags=0)</code></a></strong> that is equivalent to Boost <code>regex_match</code>.</p>

<blockquote>
  <p>in boost, there's <code>boost::u32regex_search</code>, how is it different to <code>re.search</code></p>
</blockquote>

<p>Whenver you need to find a match anywhere inside a string, you need to use <code>re.search</code> (see <a href="https://docs.python.org/3/howto/regex.html#match-versus-search" rel="nofollow"><em><code>match()</code> versus <code>search()</code></em></a>). Thus, this method provides analoguous functionality as <a href="http://www.boost.org/doc/libs/1_57_0/libs/regex/doc/html/boost_regex/ref/regex_search.html" rel="nofollow"><code>regex_search</code></a> does in Boost.</p>

<blockquote>
  <p>there's also <code>boost::format_perl</code> and <code>boost::match_default</code> and <code>boost::smatch</code>, what are their equivalence in python <code>re</code>?</p>
</blockquote>

<p>Python does not support Perl-like expressions to the extent Boost can, Python <code>re</code> module is just a "trimmed" Perl regex engine that does not have many nice features I mentioned earlier. Thus, no flags like <code>default</code> or <code>perl</code> can be found there. As for the <code>smatch</code>, you can use <strong><a href="https://docs.python.org/3/library/re.html#re.finditer" rel="nofollow"><code>re.finditer</code></a></strong> to get all the <a href="https://docs.python.org/3/library/re.html#match-objects" rel="nofollow">match objects</a>. A <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow"><code>re.findall</code></a> returns all matches (or submatches only if capturing groups are specified) as a list of strings/lists of tuples. See the <a href="http://stackoverflow.com/questions/3765024/different-behavior-between-re-finditer-and-re-findall"><code>re.findall</code>/<code>re.finditer</code> difference</a>.</p>

<p>And in the conclusion, a must-read article <a href="http://www.regular-expressions.info/python.html" rel="nofollow"><em>Python’s re Module</em></a>.</p>
    </div>
    </div></body></html>