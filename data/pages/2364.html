<html><body><div><div class="body-text">
                                                <p>I’ve read so many articles about Docker over the last year but was never really sure how to apply it to Django. Most examples I’ve seen were generic towards <a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fwww.digitalocean.com%2Fcommunity%2Ftutorials%2Fdocker-explained-how-to-containerize-python-web-applications&amp;t=ZDM3MjNjMTFmNGM3NmNkZTFiZjE0OWM4ZjdiNjMxMWFlNjU2N2EwZSxzNE9ZZXh5RA%3D%3D">containerizing Python web applications</a> but didn’t go into specifics of deploying Django  such as syncdb or collecstatic commands so I’ll cover those details here.</p>
<p>Until now had been serving my Django apps in a “traditional” manner. Each Django application would run on the same server under a virtualenv. Supervisord would start a Gunicorn server on a different port for each application (for example, port 8000). To route traffic to each Gunicorn server, I configured Nginx with a server block for each application and it would forward HTTP traffic to the appropriate Gunicorn port. Once Docker came around I started at looking at ways I could convert my current setup into my a Docker-ish “PAAS”</p>
<p> In reality, web applications do not live in isolation and require connecting to a database endpoint such as MySQL or MemCached. Assuming you have your own containerized web servers you’ll need to route traffic to your Docker containers, connect to a database, etc. So how do you tie all these components together? I mostly solved all my questions and the end result of my homegrown PAAS looks like this:</p>
<p><img alt="image" src="http://i.imgur.com/jgAZI1s.jpg?1"/></p>
<p><strong>Static files complexities</strong></p>
<p>The first challenge I came across was serving my Django static files from my container. If my app is running on one container, and my Nginx web server on another, which one serves the files? Now, I know you can push static content to S3 using Django-Storages, but I only have a few CSS files and images that need to be served so this was a bit of overkill. Luckily I came across this solution:  </p>
<p><a href="http://t.umblr.com/redirect?z=http%3A%2F%2Fwhitenoise.evans.io%2Fen%2Flatest%2F&amp;t=M2NjNmNkYjk5NGZjZjBhZGI4OTY5NDM5MWZhYWUzMzJhYjUzNDA5ZixzNE9ZZXh5RA%3D%3D">WhiteNoise</a>. WhiteNoise allows me to serve static files from my containerized application with only 2 lines of code. Edit your wsgi.py and wrap your WSGI application like so: </p>
<blockquote>
<p>from django.core.wsgi import get_wsgi_application</p>
<p>from whitenoise.django import DjangoWhiteNoise</p>
<p>application = get_wsgi_application()</p>
<p>application = DjangoWhiteNoise(application)</p>
</blockquote>
<p>In my Dockerfile I added the following to collect static files with no input however they will be served by Python instead of Nginx </p>
<blockquote>
<p># Collect Static Files</p>
<p>RUN python manage.py collectstatic —noinput</p>
</blockquote>
<p><strong>Environment Variables</strong></p>
<p>Normally <a href="http://t.umblr.com/redirect?z=http%3A%2F%2F12factor.net%2F&amp;t=MzlhZjlmMjg1MTM0NjE2ZjM4MTVmN2ZiYjhjYTM2MjZiNjg2YTRhYyxzNE9ZZXh5RA%3D%3D">best practice</a> calls for web applications to retrieve their configuration from environment variables. However, since Docker containers only have only one running process / entry point, logging into the container to make configuration changes becomes a challenge. You can pass environment variables at container runtime using the –e switch but I found this cumbersome.   In the spirit of separating my codebase from my configuration, I’ve been using <a href="http://t.umblr.com/redirect?z=http%3A%2F%2Fdjango-environ.readthedocs.org%2Fen%2Flatest%2F&amp;t=MjcyZWRmZDY5MjFkNzJlMDcwMDBmMThlZTJhMmU1Y2U4MmNlZWQwNyxzNE9ZZXh5RA%3D%3D">Django-environ</a>.  This allows me to store my database, secret key and memcache configuration that are normally stored in settings.py in a .env file like so: </p>
<blockquote>
<p>DEBUG=off</p>
<p>SECRET_KEY=your-secret-key</p>
<p>DATABASE_URL=psql://urser:password@127.0.0.1:8458/database</p>
<p>CACHE_URL=memcache://127.0.0.1:11211</p>
</blockquote>
<p>So the only step left was placing this .env file into my container. However, this was easily solved with a Dockerfile. During the build of my container I add lines like this</p>
<blockquote>
<p># Add Environment Variables</p>
<p>ADD .env /app/mydjangoapp/mydjangoapp/.env </p>
<p>Now, when Django starts it will import all these variables from the .env file. </p>
</blockquote>
<p><strong>Connecting Containers</strong></p>
<p>When a Docker container boots up, it receives a randomly assigned IP address from the 172.17.42.1/24 range. So connecting a web server to a Docker container that can have a different IP address every time it boots can be challenging. You can <a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fdocs.docker.com%2Fuserguide%2Fdockerlinks%2F&amp;t=MGYyNmMyNGUzOGI5OWNlOWZiMjJiNmJlZDkwNDBmZDAxZjgyNGI5MSxzNE9ZZXh5RA%3D%3D">link</a> containers together using the —link switch but to relink an Nginx container everytime a Django container starts can be a pain.</p>
<p>I initially tried to solve this issue using <a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fconsul.io%2F&amp;t=Y2FlMGExZTQ0NWRiZDEzZjExYzBjOGRmZGUzMDM1Y2RjMDM3NTEzMixzNE9ZZXh5RA%3D%3D">Consul</a> and <a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fprogrium%2Fregistrator&amp;t=YmRjYmJlMDBmNWYwOWQ4ZDM4MTIyNzFmOWE0ZTFiZTUxNDFhNDkwMSxzNE9ZZXh5RA%3D%3D">Registrator</a> which allows a container to be automatically registered with Consul when it starts. However, Registrator was designed with multiple Docker hosts in mind and I only have a single Docker host. I came across <a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fblalor%2Fdocker-hosts&amp;t=M2VlYjEwNDk4NWViNTRmZGZmOGIzMzU5ZTM1YmZlZjZiN2JhNjg3ZCxzNE9ZZXh5RA%3D%3D">Docker-Hosts</a> which works similarly to Registrator but uses /etcs/hosts instead of Consul as the basis for name resolution. After configuring Docker-Hosts I just start my containers with the -v command to have their hosts file layered. </p>
<blockquote>
<p>docker run -d -v /var/lib/docker/hosts:/etc/hosts:ro -h cron crhuber/cron </p>
</blockquote>
<p>Docker-Hosts allows me to have a domain name attached to all my containers of prod.docker by running the —domain-name switch. So now, all my docker containers have a prod.docker suffix and the Nginx conf files looks like this</p>
<blockquote>
<p>server {</p>
<p>listen 80;</p>
<p>server_name app.domain.io;</p>
<p>access_log  /var/log/nginx/app.domain.io.log;</p>
<p>#path to static files</p>
<p>root /var/www/app.domain.io; </p>
<p>location / {</p>
<p>  try_files $uri @proxy_django;</p>
<p>  }</p>
<p>location @proxy_django {</p>
<p>  proxy_pass <u><a href="http://t.umblr.com/redirect?z=http%3A%2F%2Fapp.prod.docker%3A8000&amp;t=MjdiM2ViY2M4MDA3NjM2ZmUzZTZmMjFhOWMzNzg4NzRhYmIwM2VlMCxzNE9ZZXh5RA%3D%3D">http://app.prod.docker:8000</a></u>;</p>
<p>  proxy_set_header Host $host;</p>
<p>  proxy_set_header X-Real-IP $remote_addr;</p>
<p>  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</p>
<p>  }</p>
<p>}</p>
</blockquote>
<p><strong>Connecting to the Database</strong></p>
<p> I’ll admit, I wasn’t ready to take the plunge Dockerizing my MySQL database. The main reason I didn’t was simplicity of management, which I won’t cover here. Ideally you’d have you database in a container with host volume for persistence or a remote database like Amazon RDS. However, I wasn’t willing to pay for an extra instance and I only have one host. So installed MySQL directly on the Docker host. All the containers connect directly to the docker0 interface to find the MySQL server. My .env database URL looks like this</p>
<blockquote>
<p>DATABASE_URL=mysql://admin:password@172.17.42.1:3306/dbname </p>
</blockquote>
<p><strong>Cron Jobs</strong></p>
<p>One of my Django apps needed to run a python script every night at midnight. Since containers should only have one running process (ie: Gunicorn) having a second Cron process running wasn’t an optimal choice. The solution I came up with is to run a second container which only runs the python script as its only process and then exits thereby shutting down that container. I schedule the startup of the container by using the Cron system on my Docker host.  </p>
<p>My docker file for this “cron” image looks like this:</p>
<blockquote>
<p># Run python script</p>
<p>CMD python /app/myapp/cron.py</p>
</blockquote>
<p>My Crontab:</p>
<blockquote>
<p>SHELL=/bin/bash</p>
<p>00 00 * * * sudo docker run cron</p>
</blockquote>
<p><strong>Memcached</strong> </p>
<p>This was a simple one. I couldn’t find an official Docker build for Memcached but it was simple to build my own.</p>
<p>Build the Dockerfile:</p>
<blockquote>
<p>sudo docker build -t crhuber/memcached .</p>
</blockquote>
<p><em>Dockerfile</em></p>
<blockquote>
<p>############################################################</p>
<p># Dockerfile to build  memcached Containers</p>
<p># Based on crhuber/centos7soe</p>
<p>############################################################ </p>
<p># Set the base image to centos7soe</p>
<p>FROM crhuber/centos7-soe</p>
<p># File Author / Maintainer</p>
<p>MAINTAINER Craig H</p>
<p># Install Nginx</p>
<p>RUN yum -y install memcached ; yum -y clean all</p>
<p># Port to expose (default: 11211)</p>
<p>EXPOSE 11211</p>
<p># Set the user to run Memcached daemon</p>
<p>USER daemon</p>
<p># Default Memcached run command arguments</p>
<p>CMD [“-m”, “128”] </p>
<p># Set the entrypoint to memcached binary</p>
<p>ENTRYPOINT memcached</p>
</blockquote>
<p>Run the container:</p>
<blockquote>
<p>docker run -d -P -v /var/lib/docker/hosts:/etc/hosts:ro -h memcached —name memcached crhuber/memcached</p>
</blockquote>
<p>Other containers will now be able to connect to this container using hostname of memcached.prod.docker:11211. So the in my CACHE_URL in the .env file for each application looks like this:</p>
<blockquote>
<p>CACHE_URL=memcache://memcached.prod.docker:11211</p>
</blockquote>
<p>-Craig</p>
                                            </div>
                                            
                                        

                                        

                                        

                                        


                                        


                                        


                                        


                                        

                                        

                                        

                                        
                                                                            
                                        

                                    </div></body></html>