<html><body><div><div class="article__body">
      <p>Python has become an increasingly popular tool for data analysis, including data processing, feature engineering, machine learning, and visualization. Data scientists and data engineers enjoy Python’s rich numerical and analytical libraries — such as NumPy, pandas, and scikit-learn — and have long wanted to apply them to large datasets stored in Hadoop clusters. While Apache Spark, through PySpark, has made data in Hadoop clusters more accessible to Python users, actually using these libraries on a Hadoop cluster remains challenging. In particular, setting up a full-featured and modern Python environment on a cluster can be <a href="http://blog.cloudera.com/blog/2015/09/how-to-prepare-your-apache-hadoop-cluster-for-pyspark-jobs/">challenging, error-prone, and time-consuming</a>.</p>
<p>Continuum Analytics and Cloudera have partnered to create an <a href="https://www.continuum.io/downloads">Anaconda parcel for CDH</a> to enable simple distribution and installation of popular Python packages and their dependencies.</p>
<p>Anaconda dramatically simplifies installation and management of popular Python packages and their dependencies, and this new parcel makes it easy for CDH users to deploy Anaconda across a Hadoop cluster for use in PySpark, Hadoop Streaming, and other contexts where Python is available and useful.</p>
<p>The newly available Anaconda parcel:</p>
<ul dir="ltr"><li>includes 300+ of the most popular Python packages</li>
<li>simplifies the installation of Anaconda across a CDH cluster</li>
<li>will be updated with each new Anaconda release</li>
</ul><p dir="ltr">The rest of this blog post will show you how to install and configure the Anaconda parcel, as well as provide an example of training a scikit-learn model on a single node and then using the model to make predictions on data in a cluster.</p>
<h2 dir="ltr">Installing the Anaconda Parcel</h2>
<p>1. From the Cloudera Manager Admin Console, click the Parcels indicator in the top navigation bar.</p>
<p/>
<p>2. Click the Edit Settings button on the top right of the Parcels page.</p>
<p/>
<p> </p>
<p>3. Click the plus symbol in the Remote Parcel Repository URLs section, and add the following repository URL for the Anaconda parcel: <a href="https://repo.continuum.io/pkgs/misc/parcels/">https://repo.continuum.io/pkgs/misc/parcels/</a></p>
<p/>
<p>4. Cick the Save Changes button at the top of the page.</p>
<p/>
<p>5. Click the Parcels indicator in the top navigation bar to return to the list of available parcels, where you should see the latest version of the Anaconda parcel that is available.</p>
<p>6. Click the Download button to the right of the Anaconda parcel listing.</p>
<p/>
<p>7. After the parcel is downloaded, click the Distribute button to distribute the parcel to all of the cluster nodes.</p>
<p/>
<p>8. After the parcel is distributed, click the Activate button to activate the parcel on all of the cluster nodes, which will prompt with a confirmation dialog.</p>
<p/>
<p/>
<p>9. After the parcel is activated, Anaconda is now available on all of the cluster nodes.</p>
<p/>
<p dir="ltr">These instructions are current as of the day of publication. Up to date instructions will be maintained in <a href="http://docs.continuum.io/anaconda/cloudera">Anaconda’s documentation</a>.</p>
<p dir="ltr">To make Spark aware that we want to use the installed parcels as the Python runtime environment on the cluster, we need to set the <code>PYSPARK_PYTHON</code> environment variable. Spark determines which Python interpreter to use by checking the value of the <code>PYSPARK_PYTHON</code> environment variable on the driver node. With the default configuration for Cloudera Manager and parcels, Anaconda will be installed to <code>/opt/cloudera/parcels/Anaconda</code>, but if the parcel directory for Cloudera Manager has been changed, you will need to change the below instructions to <code>${YOUR_PARCEL_DIR}/Anaconda/bin/python</code>.</p>
<p dir="ltr">To specify which Python to use on a per-application basis, we can specify it on the same line as our <code>spark-submit</code> command. This would look like:</p>
<pre class="brush: bash;">$ PYSPARK_PYTHON=/opt/cloudera/parcels/Anaconda/bin/python spark-submit pyspark_script.py
</pre><p dir="ltr">You can also use Anaconda by default in Spark applications while still allowing users to override the value if they wish. To do this, you will need follow the instructions for <a href="http://www.cloudera.com/documentation/manager/5-1-x/Cloudera-Manager-Managing-Clusters/cm5mc_config_snippet.html">Advanced Configuration Snippets</a> and add the following lines to Spark’s configuration:</p>
<pre class="brush: bash;">if [ -n "${PYSPARK_PYTHON}" ]; then
   export PYSPARK_PYTHON=/opt/cloudera/parcels/Anaconda/bin/python
fi</pre><p dir="ltr">Now with Anaconda on your CDH cluster, there’s no need to manually install, manage, and provision Python packages on your Hadoop cluster.</p>
<h2 dir="ltr"><b id="docs-internal-guid-a4b17110-eb15-13d6-90e2-404417b9dd24">Anaconda in Action</b></h2>
<p dir="ltr">A commonly needed workflow for a Python using data scientist is to:</p>
<ol dir="ltr"><li>Train a scikit-learn model on a single node</li>
<li>Save the results to disk</li>
<li>Apply the trained model using PySpark to generate predictions on a larger dataset.</li>
</ol><p>Let’s take a classic machine learning classification problem as an example of what having complex Python dependencies from Anaconda installed on CDH cluster allows us to do.</p>
<p dir="ltr">The MNIST dataset is a canonical machine learning classification problem that involves recognizing handwritten digits, where each row of the dataset consists of a representation of one handwritten digit from 0 to 9. The training data we will use is the original MNIST dataset (60,000 rows). The prediction will be done with the MNIST8M dataset (8,000,000 rows). Both of these datasets are available from the <a href="https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multiclass.html">libsvm datasets website</a>. This dataset is used as a standard test for various machine learning algorithms. More information, including benchmarks, can be found on the <a href="http://yann.lecun.com/exdb/mnist/">MNIST Dataset website</a>.</p>
<p dir="ltr">To train the model on a single node we will use scikit-learn and then we can <a href="http://scikit-learn.org/stable/modules/model_persistence.html">save the model to a file with <code>pickle</code></a>:</p>
<pre class="brush: python;">with open('mnist.scale', 'r') as f:
    train = f.read()

with open('mnist.scale.t', 'r') as f:
    test = f.read()

import numpy as np

def parse(data):
    lines = data.split('\n')
    lines = filter(lambda x: x.strip() != '', lines)
    nlines = len(lines)
    X = np.zeros((nlines, 784) , dtype=float)
    Y = np.zeros((nlines, ) , dtype=float)

    for n, line in enumerate(lines):
        line = line.strip()
        if line != '':
            parts = line.strip().split(' ')
            for pair in parts[1:]:
                pos, val = pair.strip().split(':')
                pos, val = int(pos), float(val)
                X[n, pos] = float(val)
            Y[n] = parts[0]
    return X, Y

X_train, Y_train = parse(train)
X_test, Y_test = parse(test)

from sklearn import svm, metrics

classifier = svm.SVC(gamma=0.001)
classifier.fit(X_train, Y_train)
predicted = classifier.predict(X_test)

print metrics.classification_report(Y_test, predicted)

import pickle
with open('classifier.pickle', 'w') as f:
    pickle.dump(classifier, f)</pre><p dir="ltr">With the classifier now trained, it can be saved to disk and then copied to HDFS.</p>
<p dir="ltr">Next, we configure and create a <code>SparkContext</code> to run in <code>yarn-client</code> mode:</p>
<pre class="brush: python;">from pyspark import SparkConf
from pyspark import SparkContext

conf = SparkConf()
conf.setMaster('yarn-client')
conf.setAppName('sklearn-predict')
sc = SparkContext(conf=conf)</pre><p dir="ltr">To load the MNIST8M data from HDFS into an RDD:</p>
<pre class="brush: python;">input_data = sc.textFile('hdfs:///tmp/mnist8m.scale')</pre><p dir="ltr">We’ll do some preprocessing on this dataset to convert the text to a NumPy array, which will serve as input for the scikit-learn classifier. We’ve installed Anaconda on every cluster node, so both NumPy and scikit-learn are available to the Spark worker processes.</p>
<pre class="brush: python;">def clean(line):
    """
    Read the mnist8m file format and return a numpy array
    """
    import numpy as np
    X = np.zeros((1, 784) , dtype=float)
    parts = line.strip().split(' ')
    for pair in parts[1:]:
        pos, val = pair.strip().split(':')
        pos, val = int(pos), float(val)
        if pos &lt; pos:
            X[0, pos] = float(val)
    return X
inputs = input_data.map(clean)</pre><p dir="ltr">To import the scikit-learn model and load the training data:</p>
<pre class="brush: python;">from sklearn.externals import joblib
classifier = joblib.load('classifier.pickle')</pre><p dir="ltr">In order to apply the trained model to a data in a large file in HDFS we need the trained model available in memory on the executors. To move the classifier from one node to all of the Spark workers we can then use the SparkContext.broadcast function to:</p>
<pre class="brush: python;">broadcastVar = sc.broadcast(classifier)</pre><p>This broadcast variable is then available to us in executors. This means we can use the variable in logic that needs to be executed on the cluster, eg inside of map or flatMap functions. It is simple to apply the trained model and save the output to a file:</p>
<pre class="brush: python;">def apply_classifier(input_array):
    label = broadcastVar.value.predict(input_array)
    return label
predictions = inputs.map(apply_classifier)
predictions.saveAsTextFile('hdfs:///tmp/predictions')</pre><p dir="ltr">To submit this code as a script we add the environment variable declaration at the beginning and then the usual spark-submit command:</p>
<pre class="brush: bash;">PYSPARK_PYTHON=/opt/cloudera/parcels/Anaconda/bin/python spark-submit pyspark_job.py</pre><p dir="ltr">Getting started with Anaconda on your CDH cluster is easy with the <a href="https://www.continuum.io/downloads">newly available parcel</a>. Be sure to check out the <a href="http://docs.continuum.io/anaconda/cloudera">Anaconda parcel documentation</a> for more details.</p>
  </div>

        
  
</div></body></html>