<html><body><div><div class="content html_format"><p>
      Всвязи с наступающим 2014 годом от Рождества Христова может возникнуть вопрос: «А какой же на самом деле сейчас год без привязки к религиям?» На него я постараюсь ответить, а точнее показать, как это можно довольно легко вычислить, не слезая со стула.</p>
<p>
Считать будем от момента начала Вселенной, то есть Большого Взрыва. Многие оговорки я буду опускать для получения результата за минимальное количество формул и строчек кода (да-да, мы будем программировать на Питоне!). В качестве бонуса мы также прикинем сколько </p><b>тёмной энергии</b><p> у нас во Вселенной.

</p><img src="https://habrastorage.org/getpro/habr/post_images/b84/9c8/253/b849c8253774357b399281ac5df43ec3.jpg"/>
<i>Supernova 1994D as seen with the Hubble Space Telescope. Foto: Pete Chalis — Harvard Smithsonian Center of Astrophysics</i>
<p>
Любопытно? Тогда поехали!
</p><a name="habracut"/>

<h4>Кратенько о физической стороне вопроса</h4>
<p>
Слышали про Хаббла? Есть ещё телескоп, названный его именем. Так вот он открыл тот факт, что Вселенная увеличивается в размерах, а точнее что близлежащие к нам галактики разбегаются, и причём чем дальше они от нас, тем быстрее они отдаляются. Как Вселенная может увеличиваться? Аналогия может быть простая. Представьте себя муравьём на воздушном шарике, который надувают. Вам будет казаться, что мир потихоньку увеличивается, и другие муравьи на шарике оказываются всё дальше и дальше, хотя с вашим телом ничего не происходит.
</p><p>
Возвращаясь к Хабблу. Как он этот факт установил? Тут два момента:
</p><ul>
<li> Во-первых, надо измерить скорость галактики. Тут нам понадобится эффект Доплера. Все мы знаем про классический эксперимент со свистом поезда в момент, когда тот проносится вдоль перрона. Когда объект удаляется от нас, то длина волны излучаемая им удлиняется. Из этой поправки можно найти скорость. В астрономии это увеличение называют красным смещением и обозначают буковкой <b>z</b>. Наблюдают какую-нибудь известную спектральную линию и, находя её смещение, вычисляют скорость.</li>
<li> Во-вторых, расстояние до галактики. Просто так расстояние до них не измерить. Тут нам уже понадобится дополнительный объект — сверхновые типа Ia. Это такие взрывы звёзд, при которых выделяется один и тот же объём энергии. По той яркости, которую мы наблюдаем, можно вычислить расстояние до самого взрыва и до галактики, в которой этот взрыв произошёл. На фото сверху галактика и взрыв сверхновой. По яркости она превосходит всю Галактику, в которой порядка ста миллиардов звёзд.</li>
</ul>

<h5>И где же тут возраст Вселенной?</h5><p>
Замерив с какой скоростью Вселенная увеличивается, мы можем прикинуть, когда она была точкой. Вот этот момент и можно назвать началом всего и прикинуть сколько лет назад он был.

</p><h4>Подготавливаем систему</h4><p>
Нам понадобится </p><b>Python </b><p>(версия неважна, я буду использовать 2.7, различия с 3.* минимальны):
</p><code>sudo apt-get install python</code><p>
Для вычислений будем использовать </p><b>Numpy</b><p> и </p><b>Scipy</b><p>:
</p><code>pip install numpy</code>
<code>pip install scipy</code><p>
И для графиков </p><b>Matplotlib</b><p>:
</p><code>pip install matplotlib</code>
<p>
Для господ без root'а советую такую сборку: </p><a href="https://store.continuum.io/cshop/anaconda/">store.continuum.io/cshop/anaconda</a><p>
Для пользователей Windows: </p><a href="https://code.google.com/p/pythonxy/">code.google.com/p/pythonxy</a>
<p>
Считаем, что систему подготовили. Всё что идёт дальше можно запускать в интерактивном режиме (прямо в консоли Python), либо в iPython. Кому как нравится.

</p><h4>Скачиваем данные</h4><p>
Прелесть современной астрофизики в полной открытости наблюдательных данных. Мы будем использовать этот каталог сверхновых типа Ia, о которых я писал выше: </p><a href="http://supernova.lbl.gov/Union/">supernova.lbl.gov/Union</a><p>
Нам потребуется этот файл: </p><a href="http://supernova.lbl.gov/Union/figures/SCPUnion2.1_mu_vs_z.txt">supernova.lbl.gov/Union/figures/SCPUnion2.1_mu_vs_z.txt</a>

<h4>Начинаем писать код</h4><p>
Подключим библиотеки, которые потребуются в последствии.
</p><pre><code class="python">import numpy as np
import matplotlib.pyplot as plt
</code></pre>
<p>
Загрузим данные из файла и создадим три вспомогательныъ массива:
</p><pre><code class="python"># пропускаем 5 строчек заголовка, в котором написано что в каком столбце записано.
# пропускаем 0ой столбец, формат которого сложно распознать, и в котором буквенный идентификатор сверхновой
data=np.loadtxt('SCPUnion2.1_mu_vs_z.txt',skiprows=5,converters={0: lambda s: 0})

# создаём массив с красными смещениями из второго столбца
z = data[:,1]
# создаём массив с distance modulus из третьего столбца и ошибки из четвёртого
DM = data[:,2]
DM_err=data[:,3]
</code></pre>
<p>
О том, что такое Distance modulus и как из него получить расстояние до объекта, лаконично написано на </p><a href="http://be.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C_%D0%B0%D0%B4%D0%BB%D0%B5%D0%B3%D0%BB%D0%B0%D1%81%D1%86%D1%96">белоруской Википедии</a><p>.
</p><p>
Сконвертируем эту величину, существование которой вызвано исключительно удобством наблюдателей, в физическую. Расстояние до объектоа запишем в массив </p><b>DL</b><p>:
</p><pre><code class="python"># определяем функцию конвертации
def DM2DL(DM):
    return 10**(DM/5-1)/1e4

# конвертируем сразу весь массив
DL=DM2DL(DM)
</code></pre>
<p>
При подсчёте Distance Modulus авторы каталога предположили, что светимость сверхновой -19.3, о чём написано в описании. Эту работу они сделали за нас.
</p><p>
Теперь в переменной </p><b>z</b><p> у нас записаны красные смещения и в </p><b>DL</b><p> — расстояния в Мегапарсеках (1 парсек = 3e16 метров = 3,3 световых года). Можно построить рисунок и посмотреть, что получилось:
</p><pre><code class="python">plt.plot(DL,z,'.')
plt.xlabel(r'$D_{L}\;\mathrm{[Mpc]}$',size=18)
plt.ylabel(r'$z$',size=18)
</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/21c/6d7/e0f/21c6d7e0f5d2e57d2569199c7a6a6e2a.png"/>
<p>
Теперь давайте сконвертируем красное смещение, </p><b>z</b><p>, в скорость. Для начала нам потребуется функция для конвертации скорости в красное смещение, то есть обратная функция:
</p><pre><code class="python"># конвертируем скорость в красное смещение и наоборот
# скорость света
c=29979245800 # cm/s
# функция конвертации скорости в красное смещение
def v2z(v):
    return sqrt((1.0+v/c)/(1.0-v/c))-1.0
</code></pre><p>
Формула взята отсюда: </p><a href="http://en.wikipedia.org/wiki/Redshift#Redshift_formulae">en.wikipedia.org/wiki/Redshift#Redshift_formulae</a>
<p>
Для конвертации в обратную сторону мы заранее посчитаем соответствие между z_list и v_list, после чего напишем функцию, которая интерполирует между точками:
</p><pre><code class="python">v_list=linspace(0,c,100)
z_list=v2z(v_list)
# plt.plot(z_list,v_list)

def z2v(z):
    return np.interp(z,z_list,v_list)/1e5 

v=z2v(z) # km/s
</code></pre>
<p>
Посмотрим на скорость объекта в зависимости от его расстояния от нас:
</p><pre><code class="python">plt.plot(DL,v,'.')
plt.xlabel(r'$D_{L}\;\mathrm{[Mpc]}$',size=18)
plt.ylabel(r'$v\;\mathrm{[km/s]}$',size=18)
</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/a66/b8d/69f/a66b8d69f37135b913d1dbd220bd4dc6.png"/>
<p>
На этой картинке отчётливо видно, что чем дальше объект, тем быстрее он от нас удаляется. Попробуем профитировать прямую. Наклон прямой (производная) в точке 0 называется постоянной Хаббла, </p><b>H</b><p>, и измеряется в км/c/Мпс. Можно найти этот наклон путём фитирования, но мы пойдём простым путём. Просто подберём наклон:

</p><pre><code class="python">plt.plot(DL,v,'.')
plt.xlabel(r'$D_{L}\;\mathrm{[Mpc]}$',size=18)
plt.ylabel(r'$v\;\mathrm{[km/s]}$',size=18)
temp=np.array([0.0,20.0])
plt.plot(temp,50.0*temp,'r')
plt.plot(temp,70.0*temp,'g')
plt.plot(temp,100.0*temp,'m')
plt.legend(('data','H=50','H=70','H=100'))
</code></pre>

<img src="https://habrastorage.org/getpro/habr/post_images/5e2/9b9/002/5e29b90024f5e445dc7f0d42249626b5.png"/><p>
И увеличенная версия:
</p><img src="https://habrastorage.org/getpro/habr/post_images/dc8/8e2/21b/dc88e221bc6ae5b1e7c464b97092e825.png"/>
<p>
Самая точная догадка: H=70 км/с/Мпс. То есть объект находящийся в 1 Мпс от нас удаляется со скоростью 70 км/с. Другими словами мы с ним были в одной точке столько лет тому назад (предполагая, что скорость разбегания была постоянной):

</p><b> (1 Мпс) / (70 км/с) = 1 / H = 14 000 000 000 лет назад</b>

<i>(<a href="https://www.google.com/search?q=1%2F(70+km%2Fs%2FMpc)+in+years">Гугл</a> хорошо справляется с конвертацией различных единиц измерения.)</i>
<p>
Итого, спустя несколько строчек кода мы установили, что возраст Вселенной порядка 14 миллиардов лет. Во-первых, это очень грубая оценка. Во-вторых, мы не оценили ошибку измерений, что необходимо делать при любом эксперименте. Также мы не говорили, откуда мы знаем яркость взрывов сверхновых, и почему мы считаем их одинаковыми. Это всё тоже отдельные интересные темы. Тем не менее такая грубая оценка даёт неплохой результат! Более точный анализ со всеми известными наблюдениями даёт результат в 13.813±0.058 миллиардов лет. 
</p><p>
Хаббл же в своё время наблюдал только самое начало подобной диаграммы (из его статьи 1929 года </p><a href="http://apod.nasa.gov/diamond_jubilee/d_1996/hub_1929.html">apod.nasa.gov/diamond_jubilee/d_1996/hub_1929.html</a><p> )
</p><img src="https://habrastorage.org/getpro/habr/post_images/199/f11/b1e/199f11b1e910d1d031fd15daba1bc9e0.gif"/><p>
и получил вместо 70, число 500. Тем не ошибка меньше чем в 10 раз, что защитывается за попадание.

</p><h4>Тёмная энергия?</h4>
<p>
На рисунках можно заметить, что линия вписывается только вначале диаграммы. Далее же линейное приближение совсем не подходит. Для следующего шага нам надо будет немного погрузиться в космологию. В самой простой модели Вселенная состоит из материи и из тёмной энергии (Эйнштейновского лямбда члена), и при этом является плоской. Обозначив часть Вселенной, состоящей из материи, за Omega_M и другую часть Вселенной из некой тёмной энергии за Omega_L, причём Omega_M+Omega_L=1, я могу выразить расстояние до объекта через красное смещение с помощью формулы (подробнее можно почитать на Википедии: </p><a href="http://en.wikipedia.org/wiki/Distance_measures_(cosmology)">[1]</a> <a href="http://en.wikipedia.org/wiki/Friedmann%E2%80%93Lema%C3%AEtre%E2%80%93Robertson%E2%80%93Walker_metric">[2]</a><p>):

</p><i>Вводим вспомагательную функцию E(z):</i>
<img src="https://habrastorage.org/getpro/habr/post_images/244/ef8/f1e/244ef8f1e976a739cc89ae73543d2bff.png" alt="image"/>
<i>Omega_k, которая здесь фигурирует, отвечает за кривизну Вселенной. Для простоты считаем её плоской, то есть Omega_k=0. Поэтому в следующей формуле нам нужна средняя строчка:</i>
<img src="https://habrastorage.org/getpro/habr/post_images/54f/a76/28e/54fa7628e9010391a883445544589ff7.png" alt="image"/>
<i>Ключевой интеграл</i>
<img src="https://habrastorage.org/getpro/habr/post_images/644/7a8/7ba/6447a87ba82e8536b08764eef137850e.png" alt="image"/>
<i>Дополнительный множитель (1+z), происхождение которого слишком долго объяснять :) :</i>
<img src="https://habrastorage.org/getpro/habr/post_images/057/18c/dde/05718cdde70a262fe7a1ecc59602cf7a.png" alt="image"/>
<p>
Далее напишем код, который вычисляет интеграл:
</p><pre><code class="python"># функция E_z
def e_Z(z, OmegaM):
    OmegaL=1.0-OmegaM
    return (OmegaM*(1.0+z)**3+OmegaL)**(-0.5)

# подключаем модуль scipy для интегрирования
import scipy.integrate as si

# расстояние 
def D_L(z, OmegaM):
    dh=4286.0 # это величина c/H, где H мы считаем равным 70 км/с/Мпс
    D_c=dh*si.quad(e_Z,0.0,z,args=(OmegaM))[0]
    return D_c*(1.0+z)

# делаем обёртку предыдущей функции, чтобя она работала сразу с массивами
def D_L_batch(z,OmegaM,H):
    DL=z.copy()
    for i in range(len(z)):
        DL[i]=D_L(z[i],OmegaM,H)
    return DL

# делаем рисунок
plt.plot(DL,v,'.')
plt.xlabel(r'$D_{L}\;\mathrm{[Mpc]}$',size=18)
plt.ylabel(r'$v\;\mathrm{[km/s]}$',size=18)
# временная переменная с координатами в z-пространстве от 0 до 1.5, 100 точек
temp_z=np.linspace(0,1.5,100)
# временная переменная с соответствующими координатами в v-пространстве
temp_v=z2v(temp_z)
# добавляем на рисунок три модели с разными величинами Omega_M
plt.plot(D_L_batch(temp_z,0.01,70.0),temp_v,'r')
plt.plot(D_L_batch(temp_z,0.27,70.0),temp_v,'g')
plt.plot(D_L_batch(temp_z,0.99,70.0),temp_v,'m')
plt.legend(('data',r'$\Omega_M=0.01$',r'$\Omega_M=0.27$',r'$\Omega_M=0.99$'),loc=4)
</code></pre>

<img src="https://habrastorage.org/getpro/habr/post_images/072/e02/faa/072e02faaddf80bde9f6f8bc24ce0195.png"/><p>
Зелёная кривая подходит к данным чуть лучше. Про ошибку вписывания теории в данные мы опять же для простоты забываем. Вывод следующий. Количество тёмной энергии и материи сопоставимы сегодня (модели, в которых отношение 100 к 1 в данные не вписываются). Это довольно интересный факт. Порядка ~70% Вселенной — некая тёмная энергия, природу которой мы пока не понимаем. Оставшиеся ~30% материи тоже не так просты как кажутся. Из неё только пятая часть является барионной материи (та из которой мы состоим), а остальное — </p><b>тёмная материя</b><p>. Что касается неё, то её количество тоже можно оценить как-нибудь в другой раз.
</p><p>
Ну вот мы и закончили. На последок лишь скажу, что это далеко не единственный способ измерения геометрии и возраста Вселенной. Их несколько. И что примечательно, все они говорят в пользу теории Большого Взрыва и расширяющейся Вселенной.
</p><p>
Удачного празднования именин Иисуса, господа! :)

      	</p><div class="polling">
		

	

    <p class="for_users_only_msg">Только зарегистрированные пользователи могут участвовать в опросе. <a href="https://habrahabr.ru/auth/login/">Войдите</a>, пожалуйста.</p>
	</div>

      <p class="clear"/>
    </div>

    
  </div></body></html>