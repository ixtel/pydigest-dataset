<html><body><div><div class="content html_format">
      <h4>Введение</h4><p>
Добрый день, уважаемые читатели.</p><p>
После написания </p><a href="http://habrahabr.ru/post/207160/">предыдущего поста</a><p> про анализ временных рядов на Python, я решил исправить замечания, которые были указаны в комментариях, но при их исправлении я столкнулся с рядом проблем, например при построении сезонной модели ARIMA, т.к. подобной функции а пакете </p><a href="http://statsmodels.sourceforge.net/stable/index.html">statsmodels</a><p> я не нашел. В итоге я решил использовать для этого функции из </p><a href="http://r-project.org/">R</a><p>, а поиски привели меня к библиотеке </p><a href="http://rpy.sourceforge.net/rpy2.html">rpy2</a><p> которая позволяетиспользовать функции из библиотек упомянутого языка.</p><p>
У многих может возникнуть вопрос «зачем это нужно?», ведь проще просто взять </p><b>R</b><p> и выполнить всю работу в нем. Я полность согласен с этим утверждением, но как мне кажется, если данные требуют предварительной обработки, то ее проще произвести на </p><b>Python</b><p>, а возможности </p><b>R</b><p> использовать при необходимости именно для анализа.</p><p>
Кроме этого, будет показано как интегрировать результаты выдачи работы функции R в </p><a href="http://ipython.org/notebook.html">IPython Notebook.</a>
<a name="habracut"/>
<h4>Установка и настройки Rpy2</h4><p>
Для начала работы надо установть rpy2. Сделать это можно с помощью команды:

</p><pre><code class="bash">pip install rpy2
</code></pre><p>
Надо отметить что, для работы данной библиотеки необходим установленный язык </p><b>R</b><p>. Скачать его можно с </p><a href="http://www.r-project.org/">офф. сайта</a><p>.</p><p>
Следующиее что необходимо сделать, это добавить нужные системные переменные. Для Windows добавить следующие переменные:
</p><ul>
<li><i>PATH</i> — путь до R.dll и до R.exe<br/>
</li>
<li><i>R_HOME</i> — путь до папки в которую установлен R<br/>
</li>
<li><i>R_USER</i> — имя пользователя под которым загружен windows<br/>
</li>
</ul><p>
Также производилась установка на Mac OS X, там данных манипуляций не потребовалось.

</p><h4>Начало работы</h4><p>
Итак, если вы работаете в </p><b>IPython Notebook</b><p>, нужно добавить инструкцию:

</p><pre><code class="python">%load_ext rmagic
</code></pre><p>
Данное расширение позволяет вызывать некторые функции </p><b>R</b><p> через </p><i>rpy2</i><p>, и выводит результат прямо в консоль IPython Notebook, что очень удобно (ниже будет показано как это сделать). Подробнее написано </p><a href="http://nbviewer.ipython.org/github/ipython/ipython/blob/3607712653c66d63e0d7f13f073bde8c0f209ba8/docs/examples/notebooks/rmagic_extension.ipynb">здесь</a><p>.</p><p>
Теперь же загрузим, нужные библиотеки:

</p><pre><code class="python">from pandas import read_csv, DataFrame, Series
import statsmodels.api as sm
import rpy2.robjects as R
from rpy2.robjects.packages import importr
import pandas.rpy.common as com
from pandas import date_range
</code></pre><p>
Теперь, как и в предыдущей статье, загрузим данные и перейдем к недельным интервалам:

</p><pre><code class="python">dataset = read_csv('DataSets/tovar_moving.csv',';', index_col=['date'], parse_dates=['date'], dayfirst=True)
otg = dataset.qty
w = otg.resample('w', how='sum')
w.plot(figsize=(12,6))
</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/178/381/044/178381044129ab253be51e6c54b32cf6.png"/><p>
Итак, из графика можно заметить ежегодную сезонность (52 недели) и ярко выраженный тренд. Поэтому перед построением модели нам необходимо избавиться от тренда и сезонности.

</p><h4>Предварительный анализ данных</h4><p>
Итак для начала, прологорифмируем исходный ряд, для выравнивания значений:

</p><pre><code class="python">w_log = log(w)
w_log.plot(figsize=(12,6))
</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/682/047/eeb/682047eeba8c441dabd70c913dc5bcd8.png"/><p>
Как видно у нас в графике присутствует сезонность и соответственно ряд не стационарен. Проверим это с помощью </p><a href="http://ru.wikipedia.org/wiki/Тест_Дики_—_Фуллера">теста Дикки-Фулера</a><p>, который проверяет гипотизу о наличии единичных корней и соотвтвенно если они есть ряд будет не стационарным. Как провести данный тест с помощью библиотеки </p><b>statsmodels</b><p>, я показывал в прошлый раз. Сейчас я продемонстрирую как это можно сделать с помощью функции </p><a href="http://www.inside-r.org/packages/cran/tseries/docs/adf.test">adf.test()</a><p> из </p><b>R</b><p>.</p><p>
Итак, данная функция находится в R-ой библиотеке </p><a href="http://cran.r-project.org/web/packages/tseries/index.html">tseries</a><p>. Она предназначена для анализа временных рядов и устанавливается дополнительно. Загрузить нужную библиотеку можно с помощью функции </p><a href="http://rpy.sourceforge.net/rpy2/doc-dev/html/robjects_rpackages.html?highlight=importr#rpy2.robjects.packages.importr">importr()</a><p>.

</p><pre><code class="python">stats = importr('stats')
tseries = importr('tseries')
</code></pre><p>
Можно заметить, что кроме </p><i>tseries</i><p>, мы загрузили еще и библиотеку </p><i>stats</i><p>. Она нам понадобитьсядля преобразования типов.</p><p>
Теперь необходимо перевести данные из типа Python в тип понятный R. Сделать это можно с помощью функции </p><a href="http://pandas.pydata.org/pandas-docs/stable/r_interface.html">convert_to_r_dataframe()</a><p> на вход которой подается DataFrame, а на выходе получается </p><i>вектор для R</i><p>.

</p><pre><code class="python">r_df = com.convert_to_r_dataframe(DataFrame(w_log))
</code></pre><p>
Итак, вектор есть следующим шагом надо перевести его в формат временного ряда. Для этого в R существует функция </p><a href="http://stat.ethz.ch/R-manual/R-patched/library/stats/html/ts.html">ts()</a><p>, вызов ее будет выглядеть так:

</p><pre><code class="python">y = stats.ts(r_df)
</code></pre><p>
Предварительная подготовка данных закончена и мы можем вызвать нужную нам функцию:

</p><pre><code class="python">ad = tseries.adf_test(y, alternative="stationary", k=52)
</code></pre><p>
В качестве параметров ей передается временный ряд и количество лагов, для которых будет расчитываться тест. В экономических моделях принято брать данное значение равное году, а т.к. данные у нас еженедельные, а в году 52 недели, поэтому параметр имеет такое значение.</p><p>
Теперь в переменной ad содержится R-объект. Его структура описана в виде списка, описание которого мне найти не удалось. Поэтому с помощью визуального анализа я написал код, который выводит результат работы функции в понятном виде:

</p><pre><code class="python">a = ad.names[:5]
{ad.names[i]:ad[i][0] for i in xrange(len(a))}
</code></pre><p>
{'alternative': 'stationary',</p><p>
 'method': 'Augmented Dickey-Fuller Test',</p><p>
 'p.value': 0.23867869477446427,</p><p>
 'parameter': 52.0,</p><p>
 'statistic': -2.8030060277420006}
 </p><p>
Исходя из результатов теста, исходный ряд не стационарен. Т.к. гипотеза о наличии единичных корней принимается с малой вероятностью, и, соответственно, ряд не стационарен. Теперь проверим на стационарность ряд первых разностей.</p><p>
Для начала получим их с помощью Python, а затем применим ADF-тест:

</p><pre><code class="python">diff1lev = w.diff(periods=1).dropna()
print 'p.value: %f' % sm.tsa.adfuller(diff1lev, maxlag=52)[1]
</code></pre><p>
p.value: 0.000000

</p><pre><code class="python">diff1lev.plot(figsize=(12,6))
</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/8c0/481/79f/8c048179f290691125cb064d41c9fb7d.png"/><p>
Ряд первых разностей, по итогам теста, оказался стационарным. А график помогает нам убедиться, что тенденция отсутствует. Осталось избавиться от сезонности.</p><p>
Для этого нужно взять сезонную разность, от нашего получившегося ряда. Подробнее можно прочитать </p><a href="https://onlinecourses.science.psu.edu/stat510/?q=node/67">тут</a><p>. Если полученный ряд будет стационармы необходимо будет вязть его превую разность и проверить ее.

</p><pre><code class="python">diff1lev_season = diff1lev.diff(52).dropna()
</code></pre><p>
Проверим ее на стационарность с помощью ADF-тест из R:

</p><pre><code class="python">r_df = com.convert_to_r_dataframe(DataFrame(diff1lev_season))
y = stats.ts(r_df)
ad = tseries.adf_test(y, alternative="stationary", k=52)
a = ad.names[:5]
{ad.names[i]:ad[i][0] for i in xrange(len(a))}
</code></pre><p>
{'alternative': 'stationary',</p><p>
 'method': 'Augmented Dickey-Fuller Test',</p><p>
 'p.value': 0.551977997289418,</p><p>
 'parameter': 52.0,</p><p>
 'statistic': -2.0581183466564776}
 </p><p>
Итак, ряд не стационарен, возьмем его первые разности:

</p><pre><code class="python">diff1lev_season1lev = diff1lev_season.diff().dropna()
print 'p.value: %f' % sm.tsa.adfuller(diff1lev_season1lev, maxlag=52)[1]
</code></pre><p>
p.value: 0.000395
</p><p>
Получившийся ряд стационарен. Теперь можно перейти к построению модели

</p><h4>Построение модели.</h4><p>
Итак, предварительный анализ закончен, и мы можем перейти к построению </p><i>сезонной модели ARIMA</i> <b>(SARIMA)</b><p>.</p><p>
Общий вид данной модели </p><img src="https://habrastorage.org/getpro/habr/post_images/28a/703/167/28a70316702f936b998297f9a8298d42.png" title="LaTeX:ARIMA(p,d,q)(P,D,Q)_s"/><p>
В этой модели параметры обозначают следующее:
</p><ul>
<li><img src="https://habrastorage.org/getpro/habr/post_images/598/a73/5fa/598a735fada61deb44797bfc26ff705d.png" title="LaTeX:p"/> — порядок модели <img src="https://habrastorage.org/getpro/habr/post_images/4fb/060/273/4fb060273b4e12ad93aa6a3b2be7f404.png" title="LaTeX:AR(p)"/></li>
<li><img src="https://habrastorage.org/getpro/habr/post_images/ea9/227/91d/ea922791d63b6f1b791ba1bf89105160.png" title="LaTeX:d"/> — порядок интегрирования исходных данных</li>
<li><img src="https://habrastorage.org/getpro/habr/post_images/017/f23/56b/017f2356b7c5fee33f42007d230fe5e0.png" title="LaTeX:q"/> — порядок модели <img src="https://habrastorage.org/getpro/habr/post_images/51d/703/096/51d703096c6e246a21f6b1148a27fe0f.png" title="LaTeX:MA(q)"/></li>
<li><img src="https://habrastorage.org/getpro/habr/post_images/ead/c09/114/eadc0911454d52971a73f975f8d2acce.png" title="LaTeX:P"/> — порядок сезонной составляющей <img src="https://habrastorage.org/getpro/habr/post_images/3ce/5a7/c05/3ce5a7c05d98ce636097502003f6e09f.png" title="LaTeX:SAR(P)"/></li>
<li><img src="https://habrastorage.org/getpro/habr/post_images/ba6/5f3/305/ba65f3305546220a73d3aabdcdb189ad.png" title="LaTeX:D"/> — порядок интегрирования сезонной составляющей</li>
<li><img src="https://habrastorage.org/getpro/habr/post_images/017/f23/56b/017f2356b7c5fee33f42007d230fe5e0.png" title="LaTeX:Q"/> — порядок сезонной составляющей <img src="https://habrastorage.org/getpro/habr/post_images/b31/888/f29/b31888f2937178294621eff56013fb79.png" title="LaTeX:SMA(Q)"/></li>
<li><img src="https://habrastorage.org/getpro/habr/post_images/ae8/5d6/f70/ae85d6f707e261c01a90f25cbfbeb61b.png" title="LaTeX:s"/> — размерность сезонности(месяц, квартал и т.д.)</li>
</ul>
<p>
Как определять </p><b>p</b><p>, </p><b>d</b><p>, </p><b>q</b><p>, я показывал в прошлый раз. Сейчас я опишу определять порядок сезонных составляющих </p><b>P</b><p>,</p><b>D</b><p>,</p><b>Q</b><p>.</p><p>
Начнем с определения параметра </p><b>D</b><p>. Он определет порядок интегрированности сезонной разности, т.е. в нашем случае он равен </p><b>1</b><p>. Для определения </p><b>P</b><p> и </p><b>Q</b><p> нам как и прежде надо построить коррелограммы </p><i>ACF</i><p> и </p><i>PACF</i><p>.

</p><pre><code class="python">fig = plt.figure(figsize=(12,8))
ax1 = fig.add_subplot(211)
fig = sm.graphics.tsa.plot_acf(diff1lev_season1lev.values.squeeze(), lags=150, ax=ax1)
ax2 = fig.add_subplot(212)
fig = sm.graphics.tsa.plot_pacf(diff1lev_season1lev, lags=150, ax=ax2)
</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/226/229/359/2262293596cffa6ca0d9e2b430fb8e72.png"/><p>
Из гарфика </p><i>PACF</i><p> видно, что порядок AR будет </p><b>p=4</b><p>, а по </p><i>ACF</i><p> видно, что порядок MA </p><b>q = 13</b><p>, т.к. 13 лаг — это последний лаг отличный от 0.</p><p>
Теперь перейдем к сезонным составляющим. Для их оценки надо смотреть на лаги кратные размеру сезонности, т.е., если для нашего примера, сезонность 52, то надо рассматривать лаги 52, 104, 156, ...</p><p>
В нашем случае параметры </p><b>P</b><p> и </p><b>Q</b><p> будут равны 0 (это видно если посмотреть на ACF и PACF на указанных выше лагах).</p><p>
В результате наших исследований мы получили модель </p><img src="https://habrastorage.org/getpro/habr/post_images/735/e78/73c/735e7873c3086d2204ccf8c5dbb89ee5.png" title="LaTeX:SARIMA(4,1,13)(0,1,0)_{52}"/><p>
Как было указано в начале данной статьи, что найти способы построения данной модели на Python я не нашел, поэтому я принял решение воспользоваться для это функцией </p><a href="http://stat.ethz.ch/R-manual/R-patched/library/stats/html/arima.html">arima()</a><p> из R. В качестве параметров ей передаются порядок модели ARIMA и, при необходимости, порядок сезонной составляющей. Но перед вызовом ее необходимо подготовить некоторые данные.</p><p>
Для начала переведем наш исходный набор в формат R и переведем в формат временного ряда.

</p><pre><code class="python">r_df = com.convert_to_r_dataframe(DataFrame(w))
y = stats.ts(r_df)
</code></pre><p>
Порядок модели передается в качестве вектора R, поэтому давайте создадим его:

</p><pre><code class="python">order = R.IntVector((4,1,13))
</code></pre><p>
Так же в качестве параметра сезонной составляющей передается список, который содержит ее порядок и размер периода:

</p><pre><code class="python">season = R.ListVector({'order': R.IntVector((0,1,0)), 'period' : 52})
</code></pre><p>
Теперь мы готовы к тому, чтобы построить модель:

</p><pre><code class="python">model = stats.arima(y, order = order, seasonal=season)
</code></pre><p>
Итак наша модель готова и можно перейти к построению прогноза на ее основе.

</p><h4>Проверка адекватности модели.</h4><p>
Итак для проверки адекватности модели надо проверить соответвуют ли остатки модели «белому шуму». Проверим это проведя </p><a href="http://ru.wikipedia.org/wiki/Q-тест_Льюнга_—_Бокса">Q-тест Льюнга — Бокса</a><p> и проверим корреляцию остатков. Для этого в R существует функция tsdiag(), в качестве параметра передается модель и количество лагов для теста.</p><p>
Вызвать данную функцию можно так:

</p><pre><code class="python">%Rpush model
%R tsdiag(model, 100)
</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/862/b05/b55/862b05b557d1baf2e03a330204de727c.png"/><p>
В первой строке инструкция </p><b><i>%Rpush</i></b><p> загружает объекты для использования в R. Иструкция </p><b><i>%R</i></b><p> во второй строке вызывает код в формате языка R. Данная конструкция работает в </p><b>IPython Notebook</b><p>.</p><p>
Из графиков выше можно заметить, что остатки независимы (это видно по </p><i>ACF</i><p>). Кроме того из графика Q-статистики можно заметить что во всех точках значение </p><i>p-value</i><p> больше уровня значимости, из этого можно сделать вывод, что остатки, с большой вероятностью, являются «белым шумом».

</p><h4>Прогнозирование</h4><p>
Для прогонизования нужно подгрузить библиотеку </p><a href="http://cran.r-project.org/web/packages/forecast/index.html">forecast</a>

<pre><code class="python">forecast = importr('forecast')
</code></pre><p>
Вывести результы прогнозирования можно двумя способами.

</p><b>Способ 1.</b><p> Это использовать возможности интеграции IPython и R. Который был показан в предыдущем разделе:

</p><pre><code class="python">%R plot(forecast(model))
</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/b23/497/7da/b234977da1dab1918dd9756af48ff50b.png"/>

<b>Способ 2.</b><p> Второй способ это сделать прогноз с помощью библиотеки forecast, а потом перевести результат в во временную серию pandas и вывести их на экран. Код который будет выполнять написан ниже:

</p><pre><code class="python">f = forecast.forecast(model) #строим прогноз
pred = [i[1] for i in f[3].iteritems()] #парсим результат
dt = date_range(w.index[-1], periods=len(pred)+1,freq='W')[1:] #создаем индекс из дат
pr = Series(pred, index = dt)  #записываем данные в TimeSeries
</code></pre><p>
Теперь выведем результат на экран

</p><pre><code class="python">w.plot(figsize=(12,6))
pr.plot(color = 'red')
</code></pre>
<img src="https://habrastorage.org/getpro/habr/post_images/b23/497/7da/b234977da1dab1918dd9756af48ff50b.png"/>

<h4>Заключение</h4><p>
В качестве заключения хотелось бы отметить, что для более точного анализа сезонности нужно иметь данные с 7-10 сезонами. Кроме того, хотелось бы сказать большое спасибо </p><a href="http://habrahabr.ru/users/werwooolf/" class="user_link">werwooolf</a><p> за оказанную помощь в процессе подготовки статьи.</p><p>
В данной статье я постарался показать как строить сезонную модель ARIMA, а также показал как можно использовать связку языков </p><b>R</b><p> и </p><b>Python</b><p> для анализа данных. Я думаю специалисты и по одному и подругому языку найдут как эффективно применить описанную связку.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>