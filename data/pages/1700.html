<html><body><div><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-flask-sse" class="anchor" href="#flask-sse" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Flask-Sse</h1>

<p>A simple <a href="http://flask.pocoo.org">Flask</a> extension for HTML5 <a href="http://en.wikipedia.org/wiki/Server-sent_events">server-sent events</a> support, powered by <a href="http://redis.io/">Redis</a></p>

<p>The extension provides 2 things - a blueprint with a single route for streaming events, and a helper function to send messages to subscribers:</p>

<pre><code>from flask import Flask, json
from flask.ext.sse import sse, send_event

app = Flask(__name__)
app.register_blueprint(sse, url_prefix='/stream')

@app.route('/send')
def send_message():
    send_event('myevent', json.dumps({"message": "Hello!"}))
</code></pre>

<p>You can then subscribe to these events in a supported browser:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8" /&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script&gt;
    var source = new EventSource("{{ url_for('sse.stream') }}");
    source.addEventListener('myevent', function(e) {
        var data = JSON.parse(e.data);
        // handle event
    }, false);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>The source comes with a basic example</p>

<p>Clients can subscribe to different channels by setting 'channel' on the query string, which defaults to 'sse'. These correspond to redis channels.</p>

<pre><code>def send_message():
    send_event('myevent', json.dumps({"line": "Something happened"}), channel='logs')

#######

var source = new EventSource("{{ url_for('sse.stream', channel='logs') }}")    
</code></pre>

<p>Being a blueprint, you can attach a before_request handler to handle things like access control:</p>

<pre><code>@sse.before_request
def check_access():
    if request.args.get('channel') == 'firehose' and not g.user.is_admin():
        abort(403)
</code></pre>

<h1><a id="user-content-configuration" class="anchor" href="#configuration" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Configuration</h1>

<p>Redis connection details are read from the applications config using the following keys (defaults in [])</p>

<ul>
<li>SSE_REDIS_HOST [localhost]</li>
<li>SSE_REDIS_PORT [6379]</li>
<li>SSE_REDIS_DB [0]</li>
</ul>

<h1><a id="user-content-caveats" class="anchor" href="#caveats" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Caveats</h1>

<p>Subscribers will connect and block for a long time, so you should seriously consider running under an asynchronous WSGI server, such as gunicorn+gevent (like the example)</p>

<p>I should also say I'm not really maintaining this beyond accepting the odd pull request - it was built as an experiment but I'm not using it in anger on anything production. I wont be publishing it on PyPi myself for the same reasons - if I start using it properly then it will go on PyPi and have some tests put around it.</p>

<h1><a id="user-content-credits" class="anchor" href="#credits" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Credits</h1>

<p>Inspired by <a href="https://github.com/niwibe/django-sse">django-sse</a></p>
</article>
  </div></body></html>