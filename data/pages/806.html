<html><body><div><div class="content html_format"><p>
      Сколько было сломано копий при обсуждении вопроса «Возможно ли сделать </p><code>eval</code><p> безопасным?» — невозможно сосчитать. Всегда находится кто-то, кто утверждает, что нашёл способ оградиться от всех возможных последствий выполнения этой функции.</p><p>
Когда мне понадобилось найти развёрнутый ответ на этот вопрос, я наткнулся на один </p><a href="http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html">пост</a><p>. Меня приятно удивила глубина исследования, так что я решил, что это стоит перевести.

</p><h4>Коротко о проблеме</h4><p>
В Python есть встроенная функция </p><code>eval()</code><p>, которая выполняет строку с кодом и возвращает результат выполнения:
</p><pre><code class="python">assert eval("2 + 3 * len('hello')") == 17
</code></pre><p>
Это очень мощная, но в то же время и очень опасная инструкция, особенно если строки, которые вы передаёте в </p><code>eval</code><p>, получены не из доверенного источника. Что будет, если строкой, которую мы решим скормить </p><code>eval</code><p>'у, окажется </p><code>os.system('rm -rf /')</code><p>? Интерпретатор честно запустит процесс удаления всех данных с компьютера, и хорошо ещё, если он будет выполняться от имени наименее привилегированного пользователя (в последующих примерах я буду использовать </p><code>clear</code><p> (</p><code>cls</code><p>, если вы используете Windows) вместо </p><code>rm -rf /</code><p>, чтобы никто из читателей случайно не </p><a href="https://lurkmore.to/%C2%FB%F1%F2%F0%E5%EB%E8%F2%FC_%F1%E5%E1%E5_%E2_%ED%EE%E3%F3">выстрелил себе в ногу</a><p>).
</p><a name="habracut"/>
<h4>Какие есть решения?</h4><p>
Некоторые утверждают, что возможно сделать </p><code>eval</code><p> безопасным, если запускать его без доступа к символам из </p><a href="https://docs.python.org/2/library/functions.html#globals">globals</a><p>. В качестве второго (опционального) аргумента </p><code>eval()</code><p> принимает словарь, который будет использован вместо глобального пространства имён (все классы, методы, переменные и пр., объявленные на «верхнем» уровне, доступные из любой точки кода) кодом, который будет выполнен </p><code>eval</code><p>'ом. Если </p><code>eval</code><p> вызывается без этого аргумента, он использует текущее глобальное пространство имён, в которое мог быть импортирован модуль </p><code>os</code><p>. Если же передать пустой словарь, глобальное пространство имён для </p><code>eval</code><p>'а будет пустым. Вот такой код уже не сможет выполниться и возбудит исключение </p><code>NameError: name 'os' is not defined</code><p>:
</p><pre><code class="python">eval("os.system('clear')", {})
</code></pre><p>
Однако мы всё ещё можем импортировать модули и обращаться к ним, используя встроенную функцию </p><code>__import__</code><p>. Так, код ниже отработает без ошибок:
</p><pre><code class="python">eval("__import__('os').system('clear')", {})
</code></pre><p>
Следующей попыткой обычно становится решение запретить доступ к </p><code>__builtins__</code><p> изнутри </p><code>eval</code><p>'a, так как имена, подобные __import__, доступны нам потому, что они находятся в глобальной переменной </p><code>__builtins__</code><p>. Если мы явно передадим вместо неё пустой словарь, код ниже уже не сможет быть выполнен:
</p><pre><code class="python">eval("__import__('os').system('clear')", {'__builtins__':{}}) # NameError: name '__import__' is not defined
</code></pre>

<h4>Ну а теперь-то мы в безопасности?</h4><a name="sample"/><p>
Некоторые говорят, что «</p><a href="http://lybniz2.sourceforge.net/safeeval.html">да</a><p>» и совершают ошибку. Для примера, вот этот небольшой кусок кода вызовет </p><code>segfault</code><p>, если вы запустите его в CPython:
</p><pre><code class="python">s = """
(lambda fc=(
    lambda n: [
        c for c in 
            ().__class__.__bases__[0].__subclasses__() 
            if c.__name__ == n
        ][0]
    ):
    fc("function")(
        fc("code")(
            0,0,0,0,"KABOOM",(),(),(),"","",0,""
        ),{}
    )()
)()
"""
eval(s, {'__builtins__':{}})
</code></pre><p>
Итак, давайте разберёмся, что же здесь происходит. Начнём с этого:
</p><pre><code class="python">().__class__.__bases__[0]
</code></pre><p>
Как многие могли догадаться, это просто один из способов обратиться к </p><code>object</code><p>. Мы не можем просто написать </p><code>object</code><p>, так как </p><code>__builtins__</code><p> пусты, но мы можем создать пустой кортеж (тьюпл), первым базовым классом которого является </p><code>object</code><p> и, пройдясь по его свойствам, получить доступ к классу </p><code>object</code><p>.</p><p>
Теперь мы получаем список всех классов, которые наследуют </p><code>object</code><p> или, иными словами, список всех классов, объявленных в программе на данный момент:
</p><pre><code class="python">().__class__.__bases__[0].__subclasses__() 
</code></pre><p>
Если заменить для удобочитаемости это выражение на </p><code>ALL_CLASSES</code><p>, нетрудно будет заметить, что выражение ниже находит класс по его имени:
</p><pre><code class="python">[c for c in ALL_CLASSES if c.__name__ == n][0]
</code></pre><p>
Далее в коде нам надо будет дважды искать класс, так что создадим функцию:
</p><pre><code class="python">lambda n: [c for c in ALL_CLASSES if c.__name__ == n][0]
</code></pre><p>
Чтобы вызвать функцию, надо как-то её назвать, но, так как мы будем выполнять этот код внутри </p><code>eval</code><p>'a, мы не можем ни объявить функцию (используя </p><code>def</code><p>), ни использовать оператор присвоения, чтобы привязать нашу лямбду к какой-нибудь переменной.</p><p>
Однако, есть и третий вариант: параметры по умолчанию. При объявлении лямбды, как и при объявлении любой обычной функции, мы можем задать параметры по умолчанию, так что если мы поместим весь код внутри ещё одной лямбды, и зададим ей нашу, как параметр по умолчанию, — мы добьёмся желаемого:
</p><pre><code class="python">(lambda fc=(
    lambda n: [
        c for c in ALL_CLASSES if c.__name__ == n
        ][0]
    ):
    # теперь мы можем обращаться к нашей лямбде через fc
)()
</code></pre><p>
Итак, мы имеем функцию, которая умеет искать классы, и можем обращаться к ней по имени. Что дальше? Мы создадим объект класса </p><code>code</code><p> (внутренний класс, его экземпляром, например, </p><a href="http://stackoverflow.com/a/11198863">является</a><p> свойство </p><code>func_code</code><p> объекта функции):
</p><pre><code class="python">fc("code")(0,0,0,0,"KABOOM",(),(),(),"","",0,"")
</code></pre><p>
Из всех инициализующих параметров нас интересует только «KABOOM». Это и есть последовательность байт-кодов, которую будет использовать наш объект, и, как вы уже могли догадаться, эта последовательность не является «хорошей». На самом деле любого байт-кода из неё хватило бы, так как всё это — бинарные операторы, которые будут вызваны при пустом стеке, что приведёт к </p><code>segfault</code><p>'у CPython. "</p><i>KABOOM</i><p>" </p><i>просто выглядит забавнее, спасибо <a href="http://www.lvh.io/">lvh</a> за этот пример.</i>
<p>
Итак, у нас есть объект класса </p><code>code</code><p>, но напрямую выполнить его мы не можем. Тогда создадим функцию, кодом которой и будет наш объект:
</p><pre><code class="python">fc("function")(CODE_OBJECT, {})
</code></pre><p>
Ну и теперь, когда у нас есть функция, мы можем её выполнить. Конкретно эта функция попытается выполнить наш некорректно составленный байт-код и приведёт к краху интерпретатора.</p><p>
Вот весь код ещё раз:
</p><pre><code class="python">(lambda fc=(lambda n: [c for c in ().__class__.__bases__[0].__subclasses__() if c.__name__ == n][0]):
    fc("function")(fc("code")(0,0,0,0,"KABOOM",(),(),(),"","",0,""),{})()
)()
</code></pre>

<h4>Заключение</h4><p>
Итак, надеюсь теперь ни у кого не осталось сомнений в том, что </p><code>eval</code> <b>НЕ БЕЗОПАСЕН</b><p>, даже если убрать доступ к глобальным и встроенным переменным.
</p><p>
В примере выше мы использовали список всех подклассов класса </p><code>object</code><p>, чтобы создать объекты классов </p><code>code</code><p> и </p><code>function</code><p>. Точно таким же образом можно получить (и инстанцировать) любой класс, существующий в программе на момент вызова </p><code>eval()</code><p>.</p><p>
Вот ещё один пример того, что можно сделать:
</p><pre><code class="python">s = """
[
    c for c in 
    ().__class__.__bases__[0].__subclasses__() 
    if c.__name__ == "Quitter"
][0](0)()
"""
eval(s, {'__builtins__':{}})
</code></pre><p>
Модуль </p><a href="http://hg.python.org/cpython/file/219502cf57eb/Lib/_sitebuiltins.py">lib/site.py</a><p> содержит класс </p><code>Quitter</code><p>, который вызывается интерпретатором, когда вы набираете </p><code>quit()</code><p>.</p><p>
Код выше находит этот класс, инстанциирует его и вызывает, чем завершает работу интерпретатора.
</p><p>
Сейчас мы запускали </p><code>eval</code><p> в пустом окружении, исходя из того, что указанный в статье код — это весь код нашей программы. </p><p>
В случае использования </p><code>eval</code><p>'а в реальном приложении злоумышленник может получить доступ ко всем классам, которые вы используете, так что его возможности не будут ограничены практически ничем.
</p><p>
Проблема всех подобных попыток сделать </p><code>eval</code><p> безопасным в том, что они все основаны на идее «чёрных списков», идее о том, что надо убрать доступ ко всем вещам, которые, как нам кажется, могут быть опасны при использовании в </p><code>eval</code><p>'е. С такой стратегией практически нет шансов на победу, ведь если окажется незапрещённым хоть что-то, система будет уязвима.
</p><p>
Когда я проводил исследование этой темы, я наткнулся на защищенный режим выполнения </p><code>eval</code><p>'а в Python, который является ещё одной попыткой побороть эту проблему:
</p><pre><code class="python">&gt;&gt;&gt; eval("(lambda:0).func_code", {'__builtins__':{}})
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;string&gt;", line 1, in &lt;module&gt;
RuntimeError: function attributes not accessible in restricted mode
</code></pre><p>
Вкратце, он работает следующим образом: если </p><code>__builtins__</code><p> внутри </p><code>eval</code><p> отличаются от «официальных» — </p><code>eval</code><p> переходит в защищенный режим, в котором закрыт доступ к некоторым опасным свойствам, таким как </p><code>func_code</code><p> у функций. Более подробное описание этого режима можно найти </p><a href="http://tav.espians.com/paving-the-way-to-securing-the-python-interpreter.html">тут</a><p>, но, как мы уже </p><a href="#sample">видели выше</a><p>, он тоже не является «серебряной пулей».
</p><p>
И всё-таки, можно ли сделать </p><code>eval</code><p> безопасным? Сложно сказать. Как мне кажется, злоумышленнику не удастся навредить без доступа к объектам с двумя нижними подчёркиваниями, обрамляющими имя, так что </p><i>возможно</i><p>, если исключить из обработки все строки с двумя нижними подчёркиваниями, то мы будем в безопасности. </p><i>Возможно...</i>

<h4>P.S.</h4><p>
В </p><a href="http://www.reddit.com/r/Python/comments/hftnp/ask_rpython_recovering_cleared_globals/">треде на Reddit</a><p> я нашёл короткий сниппет, позволяющий нам в eval получить «оригинальные» __builtins__:
</p><pre><code class="python">[
    c for c in ().__class__.__base__.__subclasses__() 
    if c.__name__ == 'catch_warnings'
][0]()._module.__builtins__
</code></pre>
<h5>Традиционное P.P.S. для хабра: прошу обо всех ошибках, неточностях и опечатках писать в личку :)</h5>
      <p class="clear"/>
    </div>

    
  </div></body></html>