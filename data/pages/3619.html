<html><body><div><div class="content html_format"><p>
      Всем привет!</p>
<p>
Про Django модели уже много статей на хабре, но хочется поделится с общественностью, как эффективно использовать их и не наступать на грабли.

</p><h4>Стартовые данные</h4>
<ul>
<li> 2 сервера с Django, запущенные под uWSGI</li>
<li>1-2k запросов в секунду</li>
<li>Проект с движением денег внутри</li>
</ul>
<a name="habracut"/>
<h4>Что дальше?</h4><p>
Допустим мы реализуем метод обновления баланса для пользователя. И этот метод выглядит так:

</p><pre><code class="python">class Profile(models.Model):
….
    def update_balance(self, balance):
        self.balance += balance
        self.save()
</code></pre>
<p>
В этом случае, если нам придут два одновременных запроса на обновление баланса, то баланс обновит только второй запрос, потому что последний запрос вытеснил первый и взял старые данные.
</p><p>
На этом этапе на помощь нам приходит метод </p><a href="https://docs.djangoproject.com/en/1.7/ref/models/queries/#f-expressions">F</a><p> в связке с .update()</p><p>
F() возвращает нам значение из базы в актуальном состоянии. и предыдущий участок можно записать так

</p><pre><code class="python">class Profile(models.Model):
….
    def update_balance(self, balance):
        Profile.objects.\
            filter(pk=self.pk)\
           .update(balance=F('balance') + balance)
</code></pre><p>
В этом случае мы всегда получаем актуальное значение поля и некоторые скажут, что этот способ решает нам проблему, но это не так. В этом случае, хоть и реализовано все правильно, как мы считаем, но проблему это не решает.
</p><p>
В этом случае приходит к нам на помощь транзакции на уровне БД.

</p><h4>Что это такое транзакции и как это использовать?</h4><p>
Начнем с того, что в Django 1.4.x и 1.5.x можно включить Transaction Middleware. В Django 1.6+ ее заменили на константу ATOMIC_REQUESTS, которую можно включить к каждой БД использующейся в проекте.
</p><p>
Работают они следующим образом. Когда к нам пришел запрос и перед тем как передать этот запрос на обработку во view Django открывает транзакцию. Если запрос был отработан без исключений, то делается commit в БД или rollback, если выскочило исключение.
</p><p>
Разница между ATOMIC_REQUESTS и Middleware в том, что Middleware включается для всего проекта, а ATOMIC_REQUESTS можно использовать для одной или нескольких БД.
</p><p>
Минус использования этого подхода в том, что создается оверхед на базу данных.</p><p>
В этом случае нам на помощь приходит ручное управление транзакциями.

</p><h4>Ручное управление транзакциями</h4><p>
Django предоставляет множество вариантов работы с помощью модуля django.db.transaction 
</p><p>
Рассмотрим один из возможных способов ручного управления — это transaction.atomic
</p><p>
transaction.atomic является и методом и декоратором и используется только для view методов.
</p><p>
Обезопасить покупку товара можно, обернув view в декоратор. Например

</p><pre><code class="python">...
from django.db import transaction
...
@transaction.atomic
def buy_something(request):
    ....
    request.user.update_balance(money)
    return render(request, template, data)
</code></pre>
<p>
В этом случае мы включили атомарность транзакции для покупки товара. Всю ответственность за целостность данных переложили на БД и атомарность решает нашу проблему.
</p><p>
Еще в связке с атомарными транзакциями можно использовать select_for_update метод.</p><p>
В этом случае изменяемая строка будет блокироваться на изменение до тех пор, пока не вызовется update.</p><p>
Наш метод обновления баланса можно записать теперь так:
</p><pre><code class="python">class Profile(models.Model):
….
    def update_balance(self, balance):
        Profile.objects.select_for_update().\
            filter(pk=self.pk)\
           .update(balance=F('balance') + balance)
</code></pre>

<h4>Выводы:<br/>
</h4>
<ul>
<li> Атомарность приходит на помощь</li>
<li> Делайте атомарными только критически важные участки кода</li>
<li> Используйте select for update для блокировки данных во время изменения </li>
<li> По возможности старайтесь делать транзакции как можно короче, чтобы не блокировать работу с данными в БД.</li>
</ul>
<p>
Дополнительно: про уровни транзакций в MySQL рассказали </p><a href="http://habrahabr.ru/post/135217/">«MySQL: уровни изоляции транзакций»</a><p>.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>