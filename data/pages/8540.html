<html><body><div><div class="section-inner layoutSingleColumn"><h3 name="cdb3" id="cdb3" class="graf--h3 graf--first">Airflow: Tips, Tricks, and Pitfalls</h3><p name="6caa" id="6caa" class="graf--p graf-after--h3"><a href="https://github.com/airbnb/airflow" data-href="https://github.com/airbnb/airflow" class="markup--anchor markup--p-anchor" rel="nofollow">Airflow</a>, the workflow scheduler we use, recently hit version 1.6.1, and introduced a revamp of its scheduling engine. We like it because the code is easy to read, <a href="https://github.com/mtustin-handy/airflow/network" data-href="https://github.com/mtustin-handy/airflow/network" class="markup--anchor markup--p-anchor" rel="nofollow">easy</a> to <a href="https://github.com/sray-handy/airflow/network" data-href="https://github.com/sray-handy/airflow/network" class="markup--anchor markup--p-anchor" rel="nofollow">fix</a>, and the maintainer, Maxime Beauchemin, is very responsive. We also like that it’s all code, rather than using config files like xml to describe the dags. Nevertheless, there are a few things that are less than obvious that we wish we had known.</p><h4 name="996e" id="996e" class="graf--h4 graf-after--p">Make tasks idempotent</h4><p name="9ec8" id="9ec8" class="graf--p graf-after--h4">In a distributed environment, things are going to fail. Airflow accommodates this by automatically retrying tasks. So far, so good.</p><p name="8b81" id="8b81" class="graf--p graf-after--p">The problem arises when you have a series of tasks and you want to reset to a state where it makes sense to retry them.</p><p name="42f3" id="42f3" class="graf--p graf-after--p">One strategy is to have a subdag. The subdag task will have its own retry, so if you set the tasks in the subdag to never retry, and rely on the subdag operator you can have the whole dag succeed or fail together. This works well if the reset is the first task in the dag; it’s attractive if there’s a relatively complex dependency structure within the subdag.</p><p name="0d6d" id="0d6d" class="graf--p graf-after--p">Note that SubdagOperator tasks won’t mark failure properly unless you’re using <a href="https://github.com/airbnb/airflow/commit/b5b402d8800342da3a9b404e453eb3749ac775da" data-href="https://github.com/airbnb/airflow/commit/b5b402d8800342da3a9b404e453eb3749ac775da" class="markup--anchor markup--p-anchor" rel="nofollow">the latest version from GitHub</a>.</p><p name="1017" id="1017" class="graf--p graf-after--p">Another strategy is to use the retry handler:</p><figure name="ac9c" id="ac9c" class="graf--figure graf--iframe graf-after--p"><p class="iframeContainer"/><figcaption class="imageCaption">Make tasks idempotent with retry handler</figcaption></figure><p name="684a" id="684a" class="graf--p graf-after--figure">This works great to make a particular task re-tryable.</p><h4 name="ee6b" id="ee6b" class="graf--h4 graf-after--p">Generate your tasks programmatically</h4><p name="3c92" id="3c92" class="graf--p graf-after--h4">One of the most powerful features of a system where workflows are described in code is that you can programmatically generate your dag. This is very, very useful where you want to automatically pick up new data sources without manual intervention.</p><p name="9070" id="9070" class="graf--p graf-after--p">We have our log ingestion dag examine HDFS for the log directories which exist, and generate one task per directory to ingest the data within it. Example code below.</p><figure name="145f" id="145f" class="graf--figure graf--iframe graf-after--p"><p class="iframeContainer"/></figure><h4 name="3802" id="3802" class="graf--h4 graf-after--figure">Daily tasks run when the day is over</h4><p name="f9a2" id="f9a2" class="graf--p graf-after--h4">Not at the start of the day.</p><h4 name="7257" id="7257" class="graf--h4 graf-after--p">You can’t put subdags in the dags folder</h4><p name="a78f" id="a78f" class="graf--p graf-after--h4">Or to be more accurate: you can’t put a subdag in its own module in the dags folder unless you protect it with some kind of factory. Or to be even more accurate: you can, but then the subdag will be run on its own schedule, as well as by the subdag operator in the main dag.</p><p name="2a01" id="2a01" class="graf--p graf-after--p">Here’s an example of two dags (assume they’re both in the dags folder, called bad_dags) where the subdag will be scheduled by the scheduler independently of the main dag:</p><figure name="3e92" id="3e92" class="graf--figure graf--iframe graf-after--p"><p class="iframeContainer"/><figcaption class="imageCaption">How not to do it unless you really want the subdag to be scheduled by the scheduler</figcaption></figure><p name="7dfc" id="7dfc" class="graf--p graf-after--figure">We solve this by using a factory function. This has the advantage that the main dag can pass in the necessary parameters to the subdag, so their schedules, and any other parameters align automatically. No need to hunt down parameters when the schdedule of your main dag changes. In the below example, assume the dags are in a package called good_dags:</p><figure name="4806" id="4806" class="graf--figure graf--iframe graf-after--p"><p class="iframeContainer"/><figcaption class="imageCaption">Use a factory to make subdags more maintainable and keep the scheduler from running them</figcaption></figure><p name="d26d" id="d26d" class="graf--p graf-after--figure">Another pattern is to stuff everything that needs to be shared between main dag and subdag into the default_args, and pass that down into the factory function. (Thanks to Maxime for that suggestion).</p><h4 name="8f3d" id="8f3d" class="graf--h4 graf-after--p">Subdags must have a schedule and be enabled</h4><p name="4e5d" id="4e5d" class="graf--p graf-after--h4">Even though subdags are triggered as part of a larger dag, if their schedule is set to None or <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="1cfe9c845c73727f79fe9c85">[email protected]</a>, the subdag operator will succeed without doing anything.</p><p name="8db3" id="8db3" class="graf--p graf-after--p">Even worse, if your subdag is disabled, then the subdag operator will run, but never complete, as your subdag will never run. This will quickly lead to your main dag having the maximum number of active dag runs active (by default 16 as at time of writing), and in consequence no more runs will be scheduled.</p><p name="8739" id="8739" class="graf--p graf-after--p">In both cases, the cause is that the subdag operator is implemented as a BackfillJob. See <a href="https://github.com/airbnb/airflow/blob/9616463/airflow/operators/subdag_operator.py#L43" data-href="https://github.com/airbnb/airflow/blob/9616463/airflow/operators/subdag_operator.py#L43" class="markup--anchor markup--p-anchor" rel="nofollow">here</a> calling <a href="https://github.com/airbnb/airflow/blob/9616463/airflow/models.py#L2447" data-href="https://github.com/airbnb/airflow/blob/9616463/airflow/models.py#L2447" class="markup--anchor markup--p-anchor" rel="nofollow">this</a>.</p><h4 name="3ca3" id="3ca3" class="graf--h4 graf-after--p">DagRuns: the missing piece</h4><p name="83f2" id="83f2" class="graf--p graf-after--h4">The single biggest change in Airflow 1.6 is the introduction of the DagRun. Now, scheduling of task instances is triggered by the creation of a DagRun object.</p><p name="0c94" id="0c94" class="graf--p graf-after--p">Accordingly, if you want to trigger a run of all of a dag, instead of running a backfill, you are likely better off creating a DagRun. You can do that either with the `airflow trigger_dag` command, or through the webserver’s DagRun page.</p><p name="204e" id="204e" class="graf--p graf-after--p">The big advantage of this is that it makes the scheduler’s behaviour easier to understand, as it scans for DagRuns to create, then schedules TaskInstances based on which DagRuns are active. The webserver can now show us the state of individual DagRuns, and the state of the task instances associated with it.</p><p name="e067" id="e067" class="graf--p graf-after--p">This creates one new pitfall — namely that Dags have a maximum number of active DagRuns, and if your DagRuns don’t reach completion for whatever reason, the scheduler will stop running your Dag.</p><h4 name="12bc" id="12bc" class="graf--h4 graf-after--p">How DagRuns are scheduled</h4><p name="f08d" id="f08d" class="graf--p graf-after--h4">The new model also creates a new opportunity to control the scheduler. The next DagRun to be scheduled is calculated based on the last scheduled DagRun in existence in the database. Apart from the case where the maximum is reached it does not matter whether the most recent instance is in a running or final state.</p><p name="fdb6" id="fdb6" class="graf--p graf-after--p">This means that if you want to rerun several DagRuns, you can delete all the DagRuns between the present, and the last run you want to re-run. The scheduler will then rerun them all, triggering them in order. Whether it waits for one to complete before the next depends on your settings for depends_on_past. You will also need to delete the corresponding taskinstances for those dagruns.</p><p name="7868" id="7868" class="graf--p graf-after--p">It also means that if you want to rerun a DagRun which is not part of the contiguous set between the present and a past time, you can simply delete the taskinstances for that DagRun, and set that DagRun to a running state.</p><h4 name="e3df" id="e3df" class="graf--h4 graf-after--p">The scheduler should be restarted frequently</h4><p name="c9eb" id="c9eb" class="graf--p graf-after--h4">In our experience, a long running scheduler process, at least with the CeleryExecutor, ends up not scheduling some tasks. We still don’t know the exact cause, unfortunately.</p><p name="08ec" id="08ec" class="graf--p graf-after--p">Fortunately, airflow has a built-in workaround in the form of the — num_runs flag. It specifies a number of iterations for the scheduler to run of its loop before it quits. We’re running it with 10 iterations, <a href="https://github.com/airbnb/airflow/issues/698#issuecomment-160666479" data-href="https://github.com/airbnb/airflow/issues/698#issuecomment-160666479" class="markup--anchor markup--p-anchor" rel="nofollow">Airbnb runs it with 5</a>. Note that this will cause problems when using the LocalExecutor.</p><p name="a81f" id="a81f" class="graf--p graf-after--p">We currently use chef to restart the executor for us; we’re planning on moving to supervisor to keep it up constantly.</p><h4 name="44e4" id="44e4" class="graf--h4 graf-after--p">Operators (dis)appear based on dependencies</h4><p name="7b47" id="7b47" class="graf--p graf-after--h4">The airflow.operators package has a little of magic to only expose operators which imported correctly. This means that if you don’t have the necessary dependencies installed, it will look like your operators are missing.</p><h4 name="1c55" id="1c55" class="graf--h4 graf-after--p">That’s all folks! (For now)</h4><p name="a940" id="a940" class="graf--p graf-after--h4 graf--last">Airflow is under active development, not least by us. There’ll be more improvements, and I’ll post about more tricks as we learn them.</p></div></div></body></html>