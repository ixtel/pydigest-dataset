<html><body><div><div class="section">
              <h1>infi.pyutils 1.1.2</h1>

              


<p>Misc. pure-python utilities</p><p>








Overview</p><p>========</p><p>.. image:: https://travis-ci.org/Infinidat/infi.pyutils.png?branch=master</p><p>*infi.pyutils* is a set of utilities for various tasks in Python.</p><p>Contents</p><p>========</p><p>Iteration Utilities</p><p>---------------</p><p>iterate</p><p>+++++++</p><p>*iterate* is a django-style for loop over elements, yielding convenient information about the iterated collection::</p><p> &gt;&gt;&gt; from __future__ import print_function</p><p> &gt;&gt;&gt; from infi.pyutils import iterate</p><p> &gt;&gt;&gt; for iteration, element in iterate(range(3)):</p><p> ...     print(element)</p><p> ...     print(iteration.first)</p><p> ...     print(iteration.counter0)</p><p> ...     print(iteration.counter1)</p><p> ...     print(iteration.last)</p><p> 0</p><p> True</p><p> 0</p><p> 1</p><p> False</p><p> 1</p><p> False</p><p> 1</p><p> 2</p><p> False</p><p> 2</p><p> False</p><p> 2</p><p> 3</p><p> True</p><p>This even works for generators and other iterables::</p><p> &gt;&gt;&gt; list(iterate(i for i in range(3)))[-1][0].last</p><p> True</p><p> .. note:: For iterated collections which are not simple ones (i.e. generators or other types), some prefetching is made to determing last elements</p><p>renumerate</p><p>++++++++++</p><p>*renumerate* is like *enumerate*, only backwards. This is useful for popping from a list in-place::</p><p>  &gt;&gt;&gt; from infi.pyutils import renumerate</p><p>  &gt;&gt;&gt; l = [1, 2, 3, 4]</p><p>  &gt;&gt;&gt; for index, element in renumerate(l):</p><p>  ...     if element % 2 == 0:</p><p>  ...         unused = l.pop(index)</p><p>  &gt;&gt;&gt; l</p><p>  [1, 3]</p><p>This also works for generators (although slightly less efficient):</p><p>  &gt;&gt;&gt; x = list(renumerate(i for i in range(3)))</p><p>  &gt;&gt;&gt; x</p><p>  [(2, 2), (1, 1), (0, 0)]</p><p>*infi.pyutils* provides a set of mixin classes to make objects comparable and hashable based on a single key::</p><p>  &gt;&gt;&gt; from infi.pyutils import ComparableByKey</p><p>  &gt;&gt;&gt; class MyComparableType(ComparableByKey):</p><p>  ...     def __init__(self, value):</p><p>  ...         super(MyComparableType, self).__init__()</p><p>  ...         self.value = value</p><p>  ...     def _get_key(self):</p><p>  ...         return self.value</p><p>  &gt;&gt;&gt; MyComparableType("c") &gt; MyComparableType("b")</p><p>  True</p><p>Reflection</p><p>----------</p><p>Method Map</p><p>++++++++++</p><p>Method maps is intended for the repeating pattern described below:</p><p>::</p><p>  &gt;&gt;&gt; class Handler(object):</p><p>  ...     def handle_string(self, s):</p><p>  ...         if s == 'some.string.1':</p><p>  ...             return self._handle_string_1()</p><p>  ...         elif s == 'some.string.2':</p><p>  ...             return self._handle_string_2()</p><p>  ...         raise NotImplementedError()</p><p>If the strings can be legitimate python variable names, one would interpolate the string in the handler name, and then use getattr to get them. Unfortunately, this is not possible with any string (and also not very explicit).</p><p>Using Method Maps is pretty straightforward:</p><p>  &gt;&gt;&gt; from infi.pyutils.method_map import MethodMap</p><p>  &gt;&gt;&gt; class Handler(object):</p><p>  ...     HANDLERS = MethodMap()</p><p>  ...     @HANDLERS.registering('some.string.1')</p><p>  ...     def _handle_string_1(self):</p><p>  ...         return 1</p><p>  ...     @HANDLERS.registering('some.string.2')</p><p>  ...     def _handle_string_2(self):</p><p>  ...         return 2</p><p>  ...     def handle_string(self, s):</p><p>  ...         handler = self.HANDLERS.get(s, None)</p><p>  ...         if handler is None:</p><p>  ...             raise NotImplementedError()</p><p>  ...         return handler()</p><p>  &gt;&gt;&gt; h = Handler()</p><p>  &gt;&gt;&gt; h.handle_string('some.string.1')</p><p>  1</p><p>  &gt;&gt;&gt; h.handle_string('some.string.2')</p><p>  2</p><p>  &gt;&gt;&gt; h.handle_string('bla') # doctest: +IGNORE_EXCEPTION_DETAIL</p><p>  Traceback (most recent call last):</p><p>    ...</p><p>  NotImplementedError</p><p>Functors</p><p>--------</p><p>*infi.pyutils.functors* is a utility package for working with function or function-like objects.</p><p>Misc. Functors</p><p>++++++++++++++</p><p>*Always* is used to constantly return a value:</p><p>::</p><p>  &gt;&gt;&gt; from infi.pyutils.functors import Always</p><p>  &gt;&gt;&gt; a = Always(5)</p><p>  &gt;&gt;&gt; a</p><p>  &lt;always 5=""&gt;</p><p>  &gt;&gt;&gt; a()</p><p>  5</p><p>  &gt;&gt;&gt; a(1, 2, 3)</p><p>  5</p><p>*Identity* is a functor that always returns its single argument:</p><p>::</p><p>  &gt;&gt;&gt; from infi.pyutils.functors import Identity</p><p>  &gt;&gt;&gt; Identity</p><p>  &lt;identity&gt;</p><p>  &gt;&gt;&gt; Identity(2)</p><p>  2</p><p>  &gt;&gt;&gt; obj = object()</p><p>  &gt;&gt;&gt; Identity(obj) is obj</p><p>  True</p><p>PASS</p><p>++++</p><p>PASS is a 'null functor'. You can always call it anyway you like, it will always return None::</p><p>  &gt;&gt;&gt; from infi.pyutils.functors import PASS</p><p>  &gt;&gt;&gt; PASS(1, 2, 3)</p><p>  &gt;&gt;&gt; PASS(666, a=2, c=4)</p><p>You can also use it as a context manager that does nothing::</p><p>  &gt;&gt;&gt; with PASS:</p><p>  ...     pass</p><p>Predicates</p><p>++++++++++</p><p>Predicates are functors taking arguments and returning True/False</p><p>::</p><p>  &gt;&gt;&gt; from infi.pyutils.predicates import Predicate</p><p>  &gt;&gt;&gt; p = Predicate(lambda obj: obj is None)</p><p>  &gt;&gt;&gt; p(None)</p><p>  True</p><p>  &gt;&gt;&gt; p(1)</p><p>  False</p><p>AlwaysTrue and AlwaysFalse are available:</p><p>::</p><p>  &gt;&gt;&gt; from infi.pyutils.predicates import AlwaysTrue, AlwaysFalse</p><p>  &gt;&gt;&gt; AlwaysTrue(1)</p><p>  True</p><p>  &gt;&gt;&gt; AlwaysTrue()</p><p>  True</p><p>  &gt;&gt;&gt; AlwaysFalse(1)</p><p>  False</p><p>  &gt;&gt;&gt; AlwaysFalse(343)</p><p>  False</p><p>  &gt;&gt;&gt; AlwaysFalse()</p><p>  False</p><p>Identity:</p><p>::</p><p>   &gt;&gt;&gt; from infi.pyutils.predicates import Identity</p><p>   &gt;&gt;&gt; is_none = Identity(None)</p><p>   &gt;&gt;&gt; is_none</p><p>   &lt;is none=""&gt;</p><p>   &gt;&gt;&gt; is_none(None)</p><p>   True</p><p>   &gt;&gt;&gt; is_none(1)</p><p>   False</p><p>Equality:</p><p>::</p><p>   &gt;&gt;&gt; from infi.pyutils.predicates import Equality</p><p>   &gt;&gt;&gt; class NeverEquals(object):</p><p>   ...     def __eq__(self, other):</p><p>   ...         return False</p><p>   &gt;&gt;&gt; equals_to_1 = Equality(1)</p><p>   &gt;&gt;&gt; equals_to_1</p><p>   &lt; == 1&gt;</p><p>   &gt;&gt;&gt; equals_to_1(1)</p><p>   True</p><p>   &gt;&gt;&gt; equals_to_1(2)</p><p>   False</p><p>   &gt;&gt;&gt; obj = NeverEquals()</p><p>   &gt;&gt;&gt; Equality(obj)(obj) # make sure it's not identity</p><p>   False</p><p>Attribute checks:</p><p>::</p><p>   &gt;&gt;&gt; class SomeObject(object):</p><p>   ...     pass</p><p>   &gt;&gt;&gt; a = SomeObject()</p><p>   &gt;&gt;&gt; a.x = 1</p><p>   &gt;&gt;&gt; a.y = 2</p><p>   &gt;&gt;&gt; a.z = 4</p><p>   &gt;&gt;&gt; b = SomeObject()</p><p>   &gt;&gt;&gt; b.x = 2</p><p>   &gt;&gt;&gt; b.y = 3</p><p>   &gt;&gt;&gt; b.z = 4</p><p>   &gt;&gt;&gt; from infi.pyutils.predicates import ObjectAttributes</p><p>   &gt;&gt;&gt; match = ObjectAttributes(z=4)</p><p>   &gt;&gt;&gt; match</p><p>   &lt;.z==4&gt;</p><p>   &gt;&gt;&gt; match(a)</p><p>   True</p><p>   &gt;&gt;&gt; match(b)</p><p>   True</p><p>   &gt;&gt;&gt; match = ObjectAttributes(x=1, y=2)</p><p>   &gt;&gt;&gt; match(a)</p><p>   True</p><p>   &gt;&gt;&gt; match(b)</p><p>   False</p><p>   &gt;&gt;&gt; ObjectAttributes(missing_attribute=2)(a)</p><p>   False</p><p>Dictionary items check:</p><p>   &gt;&gt;&gt; d = dict(a=1, b=2)</p><p>   &gt;&gt;&gt; from infi.pyutils.predicates import DictionaryItems</p><p>   &gt;&gt;&gt; match = DictionaryItems(a=1)</p><p>   &gt;&gt;&gt; match</p><p>   &lt;['a']==1&gt;</p><p>   &gt;&gt;&gt;</p><p>   &gt;&gt;&gt; match(d)</p><p>   True</p><p>   &gt;&gt;&gt; match(dict(a=2, b=2))</p><p>   False</p><p>   &gt;&gt;&gt; match(dict())</p><p>   False</p><p>   &gt;&gt;&gt; match(dict(b=2))</p><p>   False</p><p>Logical aggregations are done with And, Or, Not:</p><p>::</p><p>  &gt;&gt;&gt; from infi.pyutils.predicates import And, Or, Not</p><p>  &gt;&gt;&gt; obj = object()</p><p>  &gt;&gt;&gt; is_none_or_obj = Or(Identity(obj), Identity(None))</p><p>  &gt;&gt;&gt; is_none_or_obj #doctest: +ELLIPSIS +NORMALIZE_WHITESPACE</p><p>  Or(&lt;is &lt;object="" object="" at="" 0x...=""&gt;&gt;, &lt;is none=""&gt;)</p><p>  &gt;&gt;&gt; is_none_or_obj(obj)</p><p>  True</p><p>  &gt;&gt;&gt; is_none_or_obj(None)</p><p>  True</p><p>  &gt;&gt;&gt; is_none_or_obj(1)</p><p>  False</p><p>  &gt;&gt;&gt; is_not_none = Not(is_none)</p><p>  &gt;&gt;&gt; is_not_none</p><p>  &lt;not &lt;is="" none=""&gt;&gt;</p><p>  &gt;&gt;&gt; is_not_none(None)</p><p>  False</p><p>  &gt;&gt;&gt; is_not_none(1)</p><p>  True</p><p>Lazy</p><p>----</p><p>*infi.pyutils.lazy* presents utilities for lazy computation and caching</p><p>cached_property and cached_method</p><p>+++++++++++++++++++++++++++++++++</p><p> &gt;&gt;&gt; from infi.pyutils.lazy import cached_property</p><p> &gt;&gt;&gt; class MyClass(object):</p><p> ...     called = False</p><p> ...     @cached_property</p><p> ...     def value(self):</p><p> ...         assert not self.called</p><p> ...         self.called = True</p><p> ...         return 1</p><p> &gt;&gt;&gt; m = MyClass()</p><p> &gt;&gt;&gt; m.value</p><p> 1</p><p> &gt;&gt;&gt; m.value</p><p> 1</p><p> &gt;&gt;&gt; from infi.pyutils.lazy import cached_method</p><p> &gt;&gt;&gt; class MyClass(object):</p><p> ...     called = False</p><p> ...     @cached_method</p><p> ...     def get_value(self):</p><p> ...         assert not self.called</p><p> ...         self.called = True</p><p> ...         return 1</p><p> &gt;&gt;&gt; m = MyClass()</p><p> &gt;&gt;&gt; m.get_value()</p><p> 1</p><p> &gt;&gt;&gt; m.get_value()</p><p> 1</p><p>Decorator Utilities</p><p>-------------------</p><p>The *infi.pyutils.decorators* package contains a specially-crafted *wraps* implementation (functools.wraps counterpart) preserving information on the originally wrapped function. It also patches *inspect.getargspec* and IPython's similar mechanisms in order to display proper argument information on wrapped functions. It is therefore recommended to use it instead of the default ones.</p><p>Context Utilities</p><p>-----------------</p><p>*infi.pyutils.contexts* contains *contextmanager*, a drop-in replacement for *contextlib.contextmanager*, using the crafted *wraps* implementation from *decorators*.</p><p>Import Utilities</p><p>----------------</p><p>*infi.pyutils.importing* contains **import_file**, a function for importing a module by its name::</p><p> &gt;&gt;&gt; from infi.pyutils.importing import *</p><p> &gt;&gt;&gt; import tempfile, os</p><p> &gt;&gt;&gt; temp_dir = tempfile.mkdtemp()</p><p> &gt;&gt;&gt; filename = os.path.join(temp_dir, "my_file.py")</p><p> &gt;&gt;&gt; with open(filename, "w") as f:</p><p> ...     _ = f.write("a=2")</p><p> &gt;&gt;&gt; module = import_file(filename)</p><p> &gt;&gt;&gt; module.a</p><p> 2</p><p>Reference Counters</p><p>------------------</p><p>*infi.pyutils.reference_counter* is an implementation of a reference counter with dependency support::</p><p> &gt;&gt;&gt; from infi.pyutils.reference_counter import ReferenceCounter</p><p> &gt;&gt;&gt; r = ReferenceCounter()</p><p> &gt;&gt;&gt; r.get_reference_count()</p><p> 0</p><p> &gt;&gt;&gt; r.add_reference()</p><p> &gt;&gt;&gt; r.get_reference_count()</p><p> 1</p><p>Several reference counters can be chained via dependency::</p><p> &gt;&gt;&gt; r1 = ReferenceCounter()</p><p> &gt;&gt;&gt; r2 = ReferenceCounter()</p><p> &gt;&gt;&gt; r1.depend_on_counter(r2)</p><p> &gt;&gt;&gt; r1.add_reference()</p><p> &gt;&gt;&gt; r2.get_reference_count()</p><p> 1</p><p>Also, as a convenience, if you add a dependency to a counter that already has a nonzero refcount, the dependent counter is automatically increased as well::</p><p> &gt;&gt;&gt; r1 = ReferenceCounter()</p><p> &gt;&gt;&gt; r1.add_reference()</p><p> &gt;&gt;&gt; r2 = ReferenceCounter()</p><p> &gt;&gt;&gt; r1.depend_on_counter(r2)</p><p> &gt;&gt;&gt; r2.get_reference_count()</p><p> 1</p><p>You can add a callback to be called when the reference count drops to zero::</p><p> &gt;&gt;&gt; r1 = ReferenceCounter()</p><p> &gt;&gt;&gt; def callback(r):</p><p> ...     assert r is r1</p><p> ...     print("called!")</p><p> &gt;&gt;&gt; r1.add_zero_refcount_callback(callback)</p><p> &gt;&gt;&gt; r1.add_reference()</p><p> &gt;&gt;&gt; r1.remove_reference()</p><p> called!</p><p>Misc. Utilities</p><p>---------------</p><p>recursive_getattr</p><p>+++++++++++++++++</p><p> &gt;&gt;&gt; from infi.pyutils import recursive_getattr</p><p> &gt;&gt;&gt; class Object(object):</p><p> ...     pass</p><p> &gt;&gt;&gt; a = Object()</p><p> &gt;&gt;&gt; a.b = Object()</p><p> &gt;&gt;&gt; a.b.c = 2</p><p> &gt;&gt;&gt; recursive_getattr(a, 'b.c')</p><p> 2</p><p> &gt;&gt;&gt; recursive_getattr(a, 'b.d', 4)</p><p> 4</p><p>Reprify</p><p>+++++++</p><p>*Reprify* is intended to force a __repr__/__str__ on objects that don't properly support them::</p><p> &gt;&gt;&gt; from infi.pyutils import Reprify</p><p> &gt;&gt;&gt; class SomeObject(object):</p><p> ...     pass</p><p> &gt;&gt;&gt; some_obj = SomeObject()</p><p> &gt;&gt;&gt; s = Reprify(some_obj, repr='some_repr_here', str='some_str_here')</p><p> &gt;&gt;&gt; repr(s)</p><p> 'some_repr_here'</p><p> &gt;&gt;&gt; str(s)</p><p> 'some_str_here'</p><p>While still preserving the identity and attributes::</p><p> &gt;&gt;&gt; some_obj.attr = 2</p><p> &gt;&gt;&gt; s.attr</p><p> 2</p><p> &gt;&gt;&gt; isinstance(s, SomeObject)</p><p> True</p><p>Exception Retry Utilities</p><p>-------------------------</p><p>The *infi.pyutils.retry* package provides a mechanism to easily define when and how to retry a failed operation. It allows you to wrap methods in your class and plug in an error handling strategy (infinite retries, retry N times, expontential decay timeout, etc.) without changing your code.

</p><a name="downloads"> </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>363</span> downloads in the last week
  </li>
  <li>
    <span>3029</span> downloads in the last month
  </li>
</ul>









            </div>


          </div></body></html>