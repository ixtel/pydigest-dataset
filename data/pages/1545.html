<html><body><div><div class="markdown">
			<p><a href="https://www.binpress.com/tutorial/building-a-text-editor-with-pyqt-part-3/147">Read part three here</a>, or <a href="https://www.binpress.com/tutorial/building-a-text-editor-with-pyqt-part-one/143">start from the beginning</a>!</p>

<p>Welcome back to my series on <strong><em>Building a text editor with PyQt</em></strong>. In the last part, we started to add some great extensions such as a find-and-replace dialog and a way of inserting an images. This part will deal with two more extensions, namely one for inserting the current date and time and another for inserting and managing tables. Also, we'll add a way of prompting the user about saving unsaved changes before closing <em>Writer</em>.</p>

<h2>Inserting time and date</h2>

<p>The time and date dialog isn't very complicated. Create a new file in <code>ext</code> and call it <code>datetime.py</code>.</p>

<p><strong>In <code>ext/datetime.py</code></strong>:</p>

<pre class="prettyprint"><code>from PyQt4 import QtGui, QtCore
from PyQt4.QtCore import Qt

from time import strftime

class DateTime(QtGui.QDialog):
    def __init__(self,parent = None):
        QtGui.QDialog.__init__(self, parent)

        self.parent = parent

        self.formats = ["%A, %d. %B %Y %H:%M",
                        "%A, %d. %B %Y",
                        "%d. %B %Y %H:%M",
                        "%d.%m.%Y %H:%M",
                        "%d. %B %Y",
                        "%d %m %Y",
                        "%d.%m.%Y",
                        "%x",
                        "%X",
                        "%H:%M"]

        self.initUI()

    def initUI(self):

        self.box = QtGui.QComboBox(self)

        for i in self.formats:
            self.box.addItem(strftime(i))

        insert = QtGui.QPushButton("Insert",self)
        insert.clicked.connect(self.insert)

        cancel = QtGui.QPushButton("Cancel",self)
        cancel.clicked.connect(self.close)

        layout = QtGui.QGridLayout()

        layout.addWidget(self.box,0,0,1,2)
        layout.addWidget(insert,1,0)
        layout.addWidget(cancel,1,1)

        self.setGeometry(300,300,400,80)
        self.setWindowTitle("Date and Time")
        self.setLayout(layout)

    def insert(self):

        # Grab cursor
        cursor = self.parent.text.textCursor()

        datetime = strftime(self.formats[self.box.currentIndex()])

        # Insert the comboBox's current text
        cursor.insertText(datetime)

        # Close the window
        self.close()</code></pre>

<p><strong>In <code>ext/__init__.py</code></strong>:</p>

<pre class="prettyprint"><code>__all__ = ["find","wordcount","datetime"]</code></pre>

<p><strong>Back to <code>writer.py</code>. In <code>initToolbar()</code></strong>:</p>

<pre class="prettyprint"><code>    dateTimeAction = QtGui.QAction(QtGui.QIcon("icons/calender.png"),"Insert current date/time",self)
    dateTimeAction.setStatusTip("Insert current date/time")
    dateTimeAction.setShortcut("Ctrl+D")
    dateTimeAction.triggered.connect(datetime.DateTime(self).show)

    self.toolbar.addAction(dateTimeAction)</code></pre>

<p>Very little code! In the constructor, <code>__init__()</code>, we again make our parent object a class member and also create a list of different time formats, which we'll make use of in a bit. If you're unfamiliar with these time and date parameters used by Python (originally C), you can find a description and list of them <a href="https://docs.python.org/3/library/time.html#time.strftime">here</a>.</p>

<p>Next up, <code>initUI()</code>. We create a <code>QComboBox</code>, <code>self.box</code>, and fill it with all of our time formats, which we turn into actual date and time strings using Python's <code>time.strftime()</code> function. We also initialize a <code>QPushButton</code> for inserting the date and time string into the text and another button for canceling the operation. We connect the former to a slot function, <code>self.insert()</code>, and the latter very simply to the dialog's <code>close()</code> method, which initiates your computer's self-destruct sequence and blows it up after 60 seconds. Oh, wait, that's <code>self.detonate()</code>; <code>self.close()</code> just closes the window. In any case, we put all of these widgets into a layout again and configure some of the dialog's basic settings such as size and window title.</p>

<p>In <code>self.insert()</code>, we first grab our <code>QTextEdit</code>'s cursor and then get the appropriate format string using the <code>QComboBox</code>'s <code>currentIndex()</code> method and our list of formats, which we then turn into a date-time string using <code>strftime()</code>. You might think that we could just use the <code>QComboBox</code>'s <code>currentText()</code> method to retrieve the actual string and thus avoid a second call to <code>strftime()</code>, however the user might decide to make a sandwich <em>just</em> when he or she was about to press "insert" and thus the date-time string would not be up-to-date when the user returns - tragic. Once we have the new string, we insert it using our cursor's <code>insertText()</code> method. Also, we want to close the dialog once the user has finished, so we call <code>self.close()</code> at the end.</p>

<p>The other two snippets of code should be self-explanatory if you've read the previous parts of this series. We add this module to our <code>ext</code> package and create an appropriate <code>QAction</code> for it in our main window.</p>

<h2>Tables</h2>

<p>Next up, I'll show you how to create and manipulate tables. The steps to accomplish this are fairly straightforward:</p>

<ol>
<li>Go to your nearest forest and start choppin' up some wood. I recommend a fine oak or fir tree for our purposes.</li>
<li>Saw your wood into rectangular pieces</li>
<li/>
</ol>

<p>Huh? Oh, you mean a different kind of table? Oh right, tables for data! In that case, create a new file in our <code>ext</code> package called <code>table.py</code>:</p>

<p><code>ext/table.py</code>:</p>

<pre class="prettyprint"><code>from PyQt4 import QtGui, QtCore
from PyQt4.QtCore import Qt

class Table(QtGui.QDialog):
    def __init__(self,parent = None):
        QtGui.QDialog.__init__(self, parent)

        self.parent = parent

        self.initUI()

    def initUI(self):

        # Rows
        rowsLabel = QtGui.QLabel("Rows: ",self)

        self.rows = QtGui.QSpinBox(self)

        # Columns
        colsLabel = QtGui.QLabel("Columns",self)

        self.cols = QtGui.QSpinBox(self)

        # Cell spacing (distance between cells)
        spaceLabel = QtGui.QLabel("Cell spacing",self)

        self.space = QtGui.QSpinBox(self)

        # Cell padding (distance between cell and inner text)
        padLabel = QtGui.QLabel("Cell padding",self)

        self.pad = QtGui.QSpinBox(self)

        self.pad.setValue(10)

        # Button
        insertButton = QtGui.QPushButton("Insert",self)
        insertButton.clicked.connect(self.insert)

        # Layout
        layout = QtGui.QGridLayout()

        layout.addWidget(rowsLabel,0,0)
        layout.addWidget(self.rows,0,1)

        layout.addWidget(colsLabel,1,0)
        layout.addWidget(self.cols,1,1)

        layout.addWidget(padLabel,2,0)
        layout.addWidget(self.pad,2,1)

        layout.addWidget(spaceLabel,3,0)
        layout.addWidget(self.space,3,1)

        layout.addWidget(insertButton,4,0,1,2)

        self.setWindowTitle("Insert Table")
        self.setGeometry(300,300,200,100)
        self.setLayout(layout)

    def insert(self):

        cursor = self.parent.text.textCursor()

        # Get the configurations
        rows = self.rows.value()

        cols = self.cols.value()

        if not rows or not cols:

            popup = QtGui.QMessageBox(QtGui.QMessageBox.Warning,
                                      "Parameter error",
                                      "Row and column numbers may not be zero!",
                                      QtGui.QMessageBox.Ok,
                                      self)
            popup.show()

        else:

            padding = self.pad.value()

            space = self.space.value()

            # Set the padding and spacing
            fmt = QtGui.QTextTableFormat()

            fmt.setCellPadding(padding)

            fmt.setCellSpacing(space)

            # Inser the new table
            cursor.insertTable(rows,cols,fmt)

            self.close()</code></pre>

<p><code>ext/__init__.py</code>:</p>

<pre class="prettyprint"><code>__all__ = ["find","datetime","wordcount","table"]</code></pre>

<p><strong>Back to <code>writer.py</code>. In <code>initToolbar()</code></strong>:</p>

<pre class="prettyprint"><code>tableAction = QtGui.QAction(QtGui.QIcon("icons/table.png"),"Insert table",self)
tableAction.setStatusTip("Insert table")
tableAction.setShortcut("Ctrl+T")
tableAction.triggered.connect(table.Table(self).show)

self.toolbar.addAction(tableAction)</code></pre>

<p><strong>In <code>initUI()</code></strong>:</p>

<pre class="prettyprint"><code># We need our own context menu for tables
self.text.setContextMenuPolicy(Qt.CustomContextMenu)
self.text.customContextMenuRequested.connect(self.context)</code></pre>

<p><strong>Below <code>initUI()</code></strong>:</p>

<pre class="prettyprint"><code>def context(self,pos):

        # Grab the cursor
        cursor = self.text.textCursor()

        # Grab the current table, if there is one
        table = cursor.currentTable()

        # Above will return 0 if there is no current table, in which case
        # we call the normal context menu. If there is a table, we create
        # our own context menu specific to table interaction
        if table:

            menu = QtGui.QMenu(self)

            appendRowAction = QtGui.QAction("Append row",self)
            appendRowAction.triggered.connect(lambda: table.appendRows(1))

            appendColAction = QtGui.QAction("Append column",self)
            appendColAction.triggered.connect(lambda: table.appendColumns(1))


            removeRowAction = QtGui.QAction("Remove row",self)
            removeRowAction.triggered.connect(self.removeRow)

            removeColAction = QtGui.QAction("Remove column",self)
            removeColAction.triggered.connect(self.removeCol)


            insertRowAction = QtGui.QAction("Insert row",self)
            insertRowAction.triggered.connect(self.insertRow)

            insertColAction = QtGui.QAction("Insert column",self)
            insertColAction.triggered.connect(self.insertCol)


            mergeAction = QtGui.QAction("Merge cells",self)
            mergeAction.triggered.connect(lambda: table.mergeCells(cursor))

            # Only allow merging if there is a selection
            if not cursor.hasSelection():
                mergeAction.setEnabled(False)


            splitAction = QtGui.QAction("Split cells",self)

            cell = table.cellAt(cursor)

            # Only allow splitting if the current cell is larger
            # than a normal cell
            if cell.rowSpan() &gt; 1 or cell.columnSpan() &gt; 1:

                splitAction.triggered.connect(lambda: table.splitCell(cell.row(),cell.column(),1,1))

            else:
                splitAction.setEnabled(False)


            menu.addAction(appendRowAction)
            menu.addAction(appendColAction)

            menu.addSeparator()

            menu.addAction(removeRowAction)
            menu.addAction(removeColAction)

            menu.addSeparator()

            menu.addAction(insertRowAction)
            menu.addAction(insertColAction)

            menu.addSeparator()

            menu.addAction(mergeAction)
            menu.addAction(splitAction)

            # Convert the widget coordinates into global coordinates
            pos = self.mapToGlobal(pos)

            # Add pixels for the tool and formatbars, which are not included
            # in mapToGlobal(), but only if the two are currently visible and
            # not toggled by the user

            if self.toolbar.isVisible():
              pos.setY(pos.y() + 45)

            if self.formatbar.isVisible():
                pos.setY(pos.y() + 45)

            # Move the menu to the new position
            menu.move(pos)

            menu.show()

        else:

            event = QtGui.QContextMenuEvent(QtGui.QContextMenuEvent.Mouse,QtCore.QPoint())

            self.text.contextMenuEvent(event)

    def removeRow(self):

        # Grab the cursor
        cursor = self.text.textCursor()

        # Grab the current table (we assume there is one, since
        # this is checked before calling)
        table = cursor.currentTable()

        # Get the current cell
        cell = table.cellAt(cursor)

        # Delete the cell's row
        table.removeRows(cell.row(),1)

    def removeCol(self):

        # Grab the cursor
        cursor = self.text.textCursor()

        # Grab the current table (we assume there is one, since
        # this is checked before calling)
        table = cursor.currentTable()

        # Get the current cell
        cell = table.cellAt(cursor)

        # Delete the cell's column
        table.removeColumns(cell.column(),1)

    def insertRow(self):

        # Grab the cursor
        cursor = self.text.textCursor()

        # Grab the current table (we assume there is one, since
        # this is checked before calling)
        table = cursor.currentTable()

        # Get the current cell
        cell = table.cellAt(cursor)

        # Insert a new row at the cell's position
        table.insertRows(cell.row(),1)

    def insertCol(self):

        # Grab the cursor
        cursor = self.text.textCursor()

        # Grab the current table (we assume there is one, since
        # this is checked before calling)
        table = cursor.currentTable()

        # Get the current cell
        cell = table.cellAt(cursor)

        # Insert a new row at the cell's position
        table.insertColumns(cell.column(),1)</code></pre>

<p>First up, the <code>Table</code> class. This <code>QDialog</code> will allow the user to set initial configurations for the table he or she is about to insert into the text. This includes the number of rows and columns, as well as cell spacing, the distance between individual cells (similar to <code>margin</code> in CSS), and cell padding, the distance between the outer edge of a cell and its inner text (comparable to <code>padding</code> in CSS). We visualize these settings with a few labels indicating what the user is configuring (e.g. "Rows:") and a <code>QSpinBox</code> each to input actual values for these parameters. Also, we create an "insert" button which the user presses to insert his or her table. We connect this <code>QPushButton</code>'s <code>clicked</code> signal to a slot function, <code>self.insert()</code>:</p>

<pre class="prettyprint"><code># Rows
rowsLabel = QtGui.QLabel("Rows: ",self)

self.rows = QtGui.QSpinBox(self)

# Columns
colsLabel = QtGui.QLabel("Columns",self)

self.cols = QtGui.QSpinBox(self)

# Cell spacing (distance between cells)
spaceLabel = QtGui.QLabel("Cell spacing",self)

self.space = QtGui.QSpinBox(self)

# Cell padding (distance between cell and inner text)
padLabel = QtGui.QLabel("Cell padding",self)

self.pad = QtGui.QSpinBox(self)

self.pad.setValue(10)

# Button
insertButton = QtGui.QPushButton("Insert",self)
insertButton.clicked.connect(self.insert)</code></pre>

<p>Afterwards, we add all of these widgets to a layout and set it as our dialog's layout, as well as configure all the other necessary window settings already discussed before (window size, title etc.). In <code>insert()</code>, we grab our parent's text cursor again and all of the values the user set for the various parameters on our dialog. Our cursor's method for inserting a table is <code>insertTable()</code>, which takes the number of rows, the number of columns and optionally a <code>QTextTableFormat</code> object. If either the number of rows or the number of columns is zero, <code>insertTable()</code> does nothing. To prevent confusion, we check if <code>rows</code> or <code>cols</code> is zero and, if it is the case, pop up an error dialog. Else, we move on to inserting the table.</p>

<p>We can directly use the values we retrieved for row and column numbers, however we must use a <code>QTextTableFormat</code> object to make changes to cell padding and cell spacing. Therefore, we create a new <code>QTextTableFormat</code> and set the spacing and padding using <code>setCellPadding()</code> and <code>setCellSpacing()</code>, respectively. Finally, we use <code>insertTable()</code> method to insert the table and subsequently close the dialog:</p>

<pre class="prettyprint"><code>    def insert(self):

        cursor = self.parent.text.textCursor()

        # Get the configurations
        rows = self.rows.value()

        cols = self.cols.value()

        if not rows or not cols:

            popup = QtGui.QMessageBox(QtGui.QMessageBox.Warning,
                                      "Parameter error",
                                      "Row and column numbers may not be zero!",
                                      QtGui.QMessageBox.Ok,
                                      self)
            popup.show()

        else:

            padding = self.pad.value()

            space = self.space.value()

            # Set the padding and spacing
            fmt = QtGui.QTextTableFormat()

            fmt.setCellPadding(padding)

            fmt.setCellSpacing(space)

            # Insert the new table
            cursor.insertTable(rows,cols,fmt)

            self.close()</code></pre>

<p>As you can see, the <code>Table</code> class is quite simple. The real fun starts back in <code>writer.py</code>. Before we get to that, though, don't forget to add this module to <code>__all__</code> in <code>ext/__init__.py</code>. Now, in <code>writer.py</code>, you'll first need to create a <code>QAction</code> for the dialog in <code>initToolbar()</code> to make it accessible from the editor's toolbar. I trust that this needs no further explaining by now.</p>

<p>With the code I discussed up to now, the user can insert a table into his or her document. The problem is, however, that PyQt's tables aren't very interactive. You can't stretch or resize them and PyQt provides no way of adding or deleting rows and columns once the table has been initialized, also merging cells is impossible with these static tables. Therefore, we'll create our own way of manipulating tables, which we accomplish by showing a custom context menu when the user right-clicks on a table. If the user right-clicks anywhere else, we'll display the standard context menu again.</p>

<p>Here we go! In <code>initUI()</code>, we need to reset our <code>QTextEdit</code>'s context menu policy, which we do by passing <code>Qt.CustomContextMenu</code> to the <code>setContextMenuPolicy()</code> method. By doing so, PyQt will no longer display its standard context menu when you right-click the <code>QTextEdit</code> and thus enable us to create our own menu. Next, connect the <code>customContextMenuRequested()</code> signal to a slot function, <code>self.context()</code>:</p>

<pre class="prettyprint"><code># We need our own context menu for tables
self.text.setContextMenuPolicy(Qt.CustomContextMenu)
self.text.customContextMenuRequested.connect(self.context)</code></pre>

<p>In <code>self.context()</code>, we first grab our <code>QTextEdit</code>'s <code>QTextCursor</code> again, which has a method for retrieving the table the cursor is currently over: <code>currentTable()</code>. If there is no table underneath the cursor, <code>currentTable()</code> returns zero, so we can check which context menu to call, our custom context menu for tables or the normal context menu for everything else. Just to get it out of the way, if there is no table, we call the standard context menu with the following code:</p>

<pre class="prettyprint"><code>event = QtGui.QContextMenuEvent(QtGui.QContextMenuEvent.Mouse,QtCore.QPoint())

self.text.contextMenuEvent(event)</code></pre>

<p>Now, for our table-manipulation menu, we need to create a <code>QMenu</code> and populate it just like we did with our tool and menu bars. This means creating <code>QAction</code>s and connecting their <code>triggered</code> signals to slot functions. We want actions for:</p>

<ul>
<li>Appending rows and columns.</li>
<li>Removing rows and columns.</li>
<li>Inserting rows and columns.</li>
<li>Merging multiple cells into a single cell.</li>
<li>Splitting previously merged cells back into individual cells.</li>
</ul>

<p>For the first set of actions responsible for appending rows or columns to the table, we don't need to create separate slot methods. We just use one-line lambda expressions in which we call the table's <code>appendRows()</code> or <code>appendColumns()</code> methods and pass it the number 1, to insert a single row or column, respectively:</p>

<pre class="prettyprint"><code>appendRowAction = QtGui.QAction("Append row",self)
appendRowAction.triggered.connect(lambda: table.appendRows(1))

appendColAction = QtGui.QAction("Append column",self)
appendColAction.triggered.connect(lambda: table.appendColumns(1))</code></pre>

<p>The actions concerning removing and inserting rows and columns need a bit more code than a single line, so connect them to external slot functions:</p>

<pre class="prettyprint"><code>removeRowAction = QtGui.QAction("Remove row",self)
removeRowAction.triggered.connect(self.removeRow)

removeColAction = QtGui.QAction("Remove column",self)
removeColAction.triggered.connect(self.removeCol)


insertRowAction = QtGui.QAction("Insert row",self)
insertRowAction.triggered.connect(self.insertRow)

insertColAction = QtGui.QAction("Insert column",self)
insertColAction.triggered.connect(self.insertCol)</code></pre>

<p>Merging and splitting actions are a little special, as we'll only want to make these actions accessible when they actually are of use.</p>

<p>First up, merging. After creating a <code>QAction</code> for it, we connect its signal to a lambda expression again, in which we call our table's overloaded <code>mergeCells()</code> method. It requires us to pass it our cursor object and then takes care of merging selected cells, if there are any. We disable the action if the user's cursor has no selection:</p>

<pre class="prettyprint"><code>mergeAction = QtGui.QAction("Merge cells",self)
mergeAction.triggered.connect(lambda: table.mergeCells(cursor))

# Only allow merging if there is a selection
if not cursor.hasSelection():
    mergeAction.setEnabled(False)</code></pre>

<p>For our action taking care of splitting merged cells, we need to, after creating a <code>QAction</code> for it, retrieve the cell of the table that has been right-clicked by the user. We do so by calling the table's <code>cellAt()</code> method and passing it our cursor object. Then, we check if the row and column span of this cell is more than one, in which case it would have been previously merged with other cells. If so, we connect the <code>triggered</code> signal of our splitting action to a lambda expression again, in which we call our table's <code>splitCell()</code> method.</p>

<p>We pass this method the merged cell's row and column indices as well as the row and column spans of the to-be-split cells. By making the last two parameters one, we split the merged cells into individual cells again. I think this is the behavior most people would expect. You could, of course, pop up a question box where the user inserts the new span values, but I believe this will do fine for now. If the cell beneath the cursor has a row or column span of one, it hasn't been merged so we disable the split action:</p>

<pre class="prettyprint"><code>splitAction = QtGui.QAction("Split cells",self)

cell = table.cellAt(cursor)

# Only allow splitting if the current cell is larger
# than a normal cell
if cell.rowSpan() &gt; 1 or cell.columnSpan() &gt; 1:

    splitAction.triggered.connect(lambda: table.splitCell(cell.row(),cell.column(),1,1))

else:
    splitAction.setEnabled(False)</code></pre>

<p>We then add all of these actions to our <code>QMenu</code> object and add separators between logically connected actions, such as between those handling appending rows/columns and those for removing:</p>

<pre class="prettyprint"><code>menu.addAction(appendRowAction)
menu.addAction(appendColAction)

menu.addSeparator()

menu.addAction(removeRowAction)
menu.addAction(removeColAction)

menu.addSeparator()

menu.addAction(insertRowAction)
menu.addAction(insertColAction)

menu.addSeparator()

menu.addAction(mergeAction)
menu.addAction(splitAction)</code></pre>

<p>One tricky issue with creating custom context menus is positioning them. As you may have noticed, our <code>self.context()</code> method has a second parameter, <code>pos</code>. PyQt passes us a <code>QPoint</code> object which holds the coordinates of where the user right-clicked in our <code>QTextEdit</code>. However, there is one big problem: this <code>QPoint</code> PyQt hands us doesn't take our tool and format bars into account! The table cell may be positioned at (0,0) within the <code>QTextEdit</code> but in terms of window coordinates, its real coordinates are in fact (0,90), as our toolbars, if not customized, are 45 pixels long.</p>

<p>To solve these problems, we need to check whether the toolbars are visible, as the user may have toggled their visibility, and add 45 pixels per visible toolbar to our <code>QPoint</code> object's y coordinate. Also, we need to convert the coordinates from <code>QTextEdit</code> coordinates to global ones, which we achieve via our window's <code>mapToGlobal()</code> method. We then re-position our menu with its <code>move()</code> method and finally display it by calling <code>show()</code>:</p>

<pre class="prettyprint"><code># Convert the widget coordinates into global coordinates
pos = self.mapToGlobal(pos)

# Add pixels for the tool and format bars, which are not included
# in mapToGlobal(), but only if the two are currently visible and
# not toggled by the user

if self.toolbar.isVisible():
    pos.setY(pos.y() + 45)

if self.formatbar.isVisible():
    pos.setY(pos.y() + 45)


# Move the menu to the new position
menu.move(pos)

menu.show()</code></pre>

<p>That's it for <code>context()</code>. Let's move on to the slot functions we connected our context menu actions to. They're fairly similar to each other, so I'll just discuss one. In <code>removeRow()</code>, the method that removes the row the user's cursor is over, we grab our <code>QTextEdit</code>'s cursor, the cursor's current table and the table's current cell. We then remove the row by calling the table's <code>removeRows()</code> method and passing it the cell's <code>row()</code> number along with the number 1, thus removing only the current row (passing a higher number removes <code>n</code> rows starting at the cell's row index):</p>

<pre class="prettyprint"><code>def removeRow(self):

    # Grab the cursor
    cursor = self.text.textCursor()

    # Grab the current table (we assume there is one, since
    # this is checked before calling)
    table = cursor.currentTable()

    # Get the current cell
    cell = table.cellAt(cursor)

    # Delete the cell's row
    table.removeRows(cell.row(),1)</code></pre>

<p>The other slot methods only differ in the functions we call, I'm sure you'll understand them. That's it for tables!</p>

<h2>A final add-on</h2>

<p>After finishing part one of this series, I noticed that there was no way of prompting the user about saving a modified document before closing it. Let's change that. In <code>writer.py</code>:</p>

<p><strong>In <code>__init__()</code>, add this</strong>:</p>

<pre class="prettyprint"><code>self.changesSaved = True</code></pre>

<p><strong>In <code>initUI()</code>, add this</strong>:</p>

<pre class="prettyprint"><code>self.text.textChanged.connect(self.changed)</code></pre>

<p><strong>Below <code>initUI</code></strong>:</p>

<pre class="prettyprint"><code>def changed(self):
    self.changesSaved = False

def closeEvent(self,event):

    if self.changesSaved:

        event.accept()

    else:

        popup = QtGui.QMessageBox(self)

        popup.setIcon(QtGui.QMessageBox.Warning)

        popup.setText("The document has been modified")

        popup.setInformativeText("Do you want to save your changes?")

        popup.setStandardButtons(QtGui.QMessageBox.Save    |
                                  QtGui.QMessageBox.Cancel |
                                  QtGui.QMessageBox.Discard)

        popup.setDefaultButton(QtGui.QMessageBox.Save)

        answer = popup.exec_()

        if answer == QtGui.QMessageBox.Save:
            self.save()

        elif answer == QtGui.QMessageBox.Discard:
            event.accept()

        else:
            event.ignore()</code></pre>

<p><strong>At the end of <code>self.save()</code>, insert this line</strong>:</p>

<pre class="prettyprint"><code>self.changesSaved = True</code></pre>

<p>In <code>__init__()</code>, we create a new class member, <code>self.changesSaved</code>, that'll store a boolean indicating whether or not the current document's changes have been saved or not. Then, in <code>initUI()</code>, we connect our <code>QTextEdit</code>'s <code>textChanged</code> signal to a slot function, <code>self.changed()</code>, in which we set our <code>self.changesSaved</code> member to <code>False</code>, signifying that there are unsaved modifications. We can't use a lambda expression for this slot function, as you can't assign anything in a lambda expression.</p>

<p>Next, we need to re-define our window's <code>closeEvent()</code> method which takes a <code>QCloseEvent</code> as its only argument. This function will be called when the user attempts to close the window. Normally this method just calls the <code>QCloseEvent</code>'s <code>accept()</code> method, which then closes the window. In our case, however, we want to check if there are any unsaved modifications to the document. If not, we also call <code>event.accept()</code> and just close our application. If there are changes, however, we'll want to inform the user about this, which we do by popping up a message box.</p>

<p>Therefore, we create a <code>QMessageBox</code> object, give it an icon like we did for the table dialog's message box, set its "headline" text using the <code>setText()</code> method and add some further clarification using <code>setInformativeText()</code>. We then give this dialog some buttons using the <code>setStandardButtons()</code> method, namely one for saving the document, one for canceling the closing of the window and one for discarding the changes and closing the document without saving. After displaying the message box by calling its <code>exec_()</code> method, which returns the user's choice, we act accordingly by either saving the document, discarding changes by accepting the event or aborting the closing of the window by calling the event's <code>ignore()</code> method.</p>

<p>Lastly, we set the <code>self.changesSaved</code> variable to <code>True</code> in the <code>self.save()</code> method, ensuring that the message box doesn't pop if the user has already saved his or her changes.</p>

<h1>Thank you</h1>

<p>That's it for this part and, unfortunately, also for this series on <strong><em>Building a text editor with PyQt</em></strong>. I hope you learned a lot and enjoyed building this text editor with me!</p>

<p><strong><em>But hey, who says it should end here? There's so much potential! If you have any ideas or suggestions on how to improve Writer, don't hesitate to fork or clone this project on <a href="https://github.com/goldsborough/Writer-Tutorial">GitHub</a>. Change its layout, add some color, improve features and add a few of your own!</em></strong></p>

<p>Cheers!</p>
		</div>
				</div></body></html>