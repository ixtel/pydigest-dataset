<html><body><div><div class="section">
              <h1>postage 1.0.0</h1>

              


<p>A Python library for AMQP-based network components</p>



<p>
<strong>Latest Version: </strong><a title="Latest Version URL" href="https://pypi.python.org/pypi/postage/1.2.1">
<span>1.2.1</span>
</a>
</p><p>




Postage - a Python library for AMQP-based network components</p><p>============================================================</p><p>|Build Status| |Version| |PyPi Downloads|</p><p>Postage is a Python library which leverages</p><p>`pika &lt;https: github.com="" pika="" pika=""&gt;`__ and AMQP (through a broker like</p><p>`RabbitMQ &lt;http: www.rabbitmq.com=""/&gt;`__) to build network-aware software</p><p>components.</p><p>Through **pika** you can add to any Python program the capability of</p><p>sending and receiving messages using AMQP. For example you can listen or</p><p>communicate with other programs through a RabbitMQ cluster (The</p><p>reference AMQP broker in this documentation is RabbitMQ).</p><p>Postage is a layer built on pika, and aims to simplify the</p><p>implementation of the messaging part in your Python programs, hiding (as</p><p>much as possible) the AMQP details. it provides the following structures</p><p>and concepts:</p><p>-  **Fingerprint**: an automatic network fingerprint for an application,</p><p>   which contains useful data to uniquely identify your program on the</p><p>   cluster.</p><p>-  **Message encoding** implemented in a stand-alone class which can</p><p>   easily be replaced by one of your choice. Default encoding is JSON.</p><p>-  A **message** implementation based on a plain Python dictionary (thus</p><p>   usable even without Postage). Messages can be of three types:</p><p>   **command**, **status** or **result**, representing the actions of</p><p>   asking something (command), communicating something (status) or</p><p>   answering a request (result). Command messages can be fire-and-forget</p><p>   or RPC. Result messages can further transport a success, an error, or</p><p>   a Python exception.</p><p>-  **Exchanges** can be declared and customized inheriting a dedicated</p><p>   class.</p><p>-  A generic message **producer** class: it simplifies the definition of</p><p>   a set of messages an exchange accepts, which helps in defining a</p><p>   network API of your component.</p><p>-  A generic message consumer, or **processor**, that implements a</p><p>   powerful handlers mechanism to define which incoming messages a</p><p>   component is interested in and how it shall answer.</p><p>About microthreads</p><p>==================</p><p>Postage leverages a microthread library to run network components. The</p><p>current implementation is very simple and largely underused, due to the</p><p>blocking nature of the pika adapter being used. Future plans include a</p><p>replacement with a more powerful library. This implementation is a good</p><p>starting point if you want to understand generator-based microthreads</p><p>but do not expect more. You can read this series of articles</p><p>`here &lt;http: lgiordani.github.io="" blog="" 2013="" 03="" 25="" python-generators-from-iterators-to-cooperative-multitasking=""/&gt;`__</p><p>to begin digging in the matter.</p><p>About versioning</p><p>================</p><p>This is Postage version 1.0.0.</p><p>This library is versioned with a A.B.C schema ( **A**\ PI, **B**\ OOST,</p><p>**C**\ OMPLAINT ).</p><p>-  Any change in the COMPLAINT number is a bugfix or even a typo</p><p>   correction in the documentation; it is transparent to running systems</p><p>   (except that hopefully *that nasty bug* is no more there).</p><p>-  Any change in the BOOST number is an API addition. It is transparent</p><p>   to running systems, but you should check the changelog to check</p><p>   what's new, perhaps *that impossible thing* is now easy as pie.</p><p>-  Any change in the API number has to be taken very seriously. Sorry</p><p>   but for some reason the API changed, so your running code will no</p><p>   more work.</p><p>So update to 1.0.x without hesitation, await the full-of-features 1.1.0</p><p>release and beware of the frightening version 2.0.0 that will crash your</p><p>systems! =)</p><p>[The code contained in the *master* branch on GitHub before the PyPI</p><p>release was marked with version 3.0.x. Indeed that is the real version</p><p>of the package but since previous versions were not released I wanted to</p><p>be a good releaser and start from version 1]</p><p>License</p><p>=======</p><p>This package, Postage, a Python library for AMQP-based network</p><p>components, is licensed under the terms of the GNU General Public</p><p>License Version 2 or later (the "GPL"). For the GPL 2 please see</p><p>LICENSE-GPL-2.0.</p><p>Contributing</p><p>============</p><p>Any form of contribution is highly welcome, from typos corrections to</p><p>code patches. Feel free to clone the project and send pull requests.</p><p>Quick start</p><p>===========</p><p>You can find the source code for the following examples in the</p><p>``demos/`` directory.</p><p>A basic echo server</p><p>-------------------</p><p>Let's implement a basic echo server made of two programs. The first sits</p><p>down and waits for incoming messages with the ``'echo'`` key, the second</p><p>sends one message each time it is run.</p><p>Be sure to have a running RabbitMQ system configured with a ``/``</p><p>virtual host and a ``guest:guest`` user/password.</p><p>The file ``echo_shared.py`` contains the definition of the exchange in</p><p>use</p><p>.. code:: python</p><p>    from postage import messaging</p><p>    class EchoExchange(messaging.Exchange):</p><p>        name = "echo-exchange"</p><p>        exchange_type = "direct"</p><p>        passive = False</p><p>        durable = True</p><p>        auto_delete = False</p><p>The class attributes are the standard paramenters of AMQP exchanges, see</p><p>``exchange_declare()`` in Pika</p><p>`documentation &lt;https: pika.readthedocs.org="" en="" 0.9.13="" modules="" adapters="" blocking.html#pika.adapters.blocking_connection.blockingchannel.exchange_declare=""&gt;`__.</p><p>The file ``echo_send.py``\ defines a message producer and uses it to</p><p>send a message</p><p>.. code:: python</p><p>    from postage import messaging</p><p>    import echo_shared</p><p>    class EchoProducer(messaging.GenericProducer):</p><p>        eks = [(echo_shared.EchoExchange, 'echo-rk')]</p><p>    producer = EchoProducer()</p><p>    producer.message_echo("A test message")</p><p>The producer has two goals: the first is to **define the standard</p><p>exchange and routing key used to send the messages**, which prevents you</p><p>from specifying both each time you send a message. The second goal is to</p><p>**host functions that build messages**; this is an advanced topic, so it</p><p>is discussed later.</p><p>In this simple case the producer does all the work behind the curtain</p><p>and you just need to call ``message_echo()`` providing it as many</p><p>parameters as you want. The producer creates a command message named</p><p>``'echo'``, packs all ``*args`` and ``**kwds`` you pass to the</p><p>``message_echo()`` method inside it, and sends it through the AMQP</p><p>network.</p><p>The file ``echo_receive.py`` defines a message processor that catches</p><p>incoming command messages named ``'echo'`` and prints their payload.</p><p>.. code:: python</p><p>    from postage import microthreads</p><p>    from postage import messaging</p><p>    import echo_shared</p><p>    class EchoReceiveProcessor(messaging.MessageProcessor):</p><p>        @messaging.MessageHandler('command', 'echo')</p><p>        def msg_echo(self, content):</p><p>            print content['parameters']</p><p>    eqk = [(echo_shared.EchoExchange, [('echo-queue', 'echo-rk'), ])]</p><p>    scheduler = microthreads.MicroScheduler()</p><p>    scheduler.add_microthread(EchoReceiveProcessor({}, eqk, None, None))</p><p>    for i in scheduler.main():</p><p>        pass</p><p>The catching method is arbitrarily called ``msg_echo()`` and decorated</p><p>with ``MessageHandler``, whose parameters are the type of the message</p><p>(``command``, that means we are instructing a component to do something</p><p>for us), and its name (``echo``, automatically set by calling the</p><p>``message_echo()`` method). The ``msg_echo()`` method must accept one</p><p>parameter, besides ``self``, that is the content of the message. The</p><p>content is not the entire message, but a dictionary containing only the</p><p>payload; in this case, for a generic ``command`` message, the payload is</p><p>a dictionary containing only the ``parameters`` key, that is</p><p>Seems overkill? Indeed, for such a simple application, it is. The</p><p>following examples will hopefully show how those structures heavily</p><p>simplify complex tasks.</p><p>To run the example just open two shells, execute</p><p>``python echo_receive.py`` in the first one and ``python echo_send.py``</p><p>in the second. If you get a</p><p>``pika.exceptions.ProbableAuthenticationError`` exception please check</p><p>the configuration of the RabbitMQ server; you need to have a ``/``</p><p>virtual host and the ``guest`` user shall be active with password</p><p>``guest``.</p><p>An advanced echo server</p><p>-----------------------</p><p>Let's add a couple of features to our basic echo server example. First</p><p>of all we want to get information about who is sending the message. This</p><p>is an easy task for Fingerprint objects</p><p>.. code:: python</p><p>    from postage import messaging</p><p>    import echo_shared</p><p>    class EchoProducer(messaging.GenericProducer):</p><p>        eks = [(echo_shared.EchoExchange, 'echo-rk')]</p><p>    fingerprint = messaging.Fingerprint('echo_send', 'application').as_dict()</p><p>    producer = EchoProducer(fingerprint)</p><p>    producer.message_echo("A single test message")</p><p>    producer.message_echo("A fanout test message", _key='echo-fanout-rk')</p><p>As you can see a Fingerprint just needs the name of the application</p><p>(``echo_send``) and a categorization (``application``), and</p><p>automatically collect data such as the PID and the host. On receiving</p><p>the message you can decorate the receiving function with</p><p>``MessageHandlerFullBody`` to access the fingerprint</p><p>.. code:: python</p><p>    @messaging.MessageHandlerFullBody('command', 'echo')</p><p>    def msg_echo_fingerprint(self, body):</p><p>        print "Message fingerprint: %s", body['fingerprint']</p><p>The second thing we are going to add is the ability to send fanout</p><p>messages. When you connect to an exchange you can do it with a shared</p><p>queue, i.e. a queue declared with the same name by all the receivers, or</p><p>with a private queue, that is a unique queue for each receiver. The</p><p>first setup leads to a round-robin consumer scenario, with the different</p><p>receivers picking messages from the same queue in turn. The second</p><p>setup, on the other hand, makes all the receivers get the same message</p><p>simultaneously, acting like a fanout delivery.</p><p>The file ``echo_shared.py`` does not change, since the Exchange has the</p><p>same difinition. In ``echo_receive.py`` we make the greatest number of</p><p>changes</p><p>::</p><p>    from postage import microthreads</p><p>    from postage import messaging</p><p>    import echo_shared</p><p>    class EchoReceiveProcessor(messaging.MessageProcessor):</p><p>        def __init__(self, fingerprint):</p><p>            shared_queue = 'echo-queue'</p><p>            private_queue = 'echo-queue-{0}{1}'.format(fingerprint['pid'],</p><p>                                                       fingerprint['host'])</p><p>            eqk = [</p><p>                (echo_shared.EchoExchange, [</p><p>                    (shared_queue, 'echo-rk'),</p><p>                    (private_queue, 'echo-fanout-rk')</p><p>                ]),</p><p>            ]</p><p>            super(EchoReceiveProcessor, self).__init__(fingerprint,</p><p>                                                       eqk, None, None)</p><p>        @messaging.MessageHandler('command', 'echo')</p><p>        def msg_echo(self, content):</p><p>            print content['parameters']</p><p>        @messaging.MessageHandlerFullBody('command', 'echo')</p><p>        def msg_echo_fingerprint(self, body):</p><p>            print "Message fingerprint: %s", body['fingerprint']</p><p>    fingerprint = messaging.Fingerprint('echo_receive', 'controller').as_dict()</p><p>    scheduler = microthreads.MicroScheduler()</p><p>    scheduler.add_microthread(EchoReceiveProcessor(fingerprint))</p><p>    for i in scheduler.main():</p><p>        pass</p><p>As you can see the ``EchoReceiveProcessor`` redefines the ``__init__()``</p><p>method to allow passing just a Fingerprint; as a side-effect, ``eqk`` is</p><p>now defined inside the method, but its nature does not change. It</p><p>encompasses now two queues for the same exchange; the first queue is</p><p>chared, given that every instance of the reveiver just names it</p><p>``echo-queue``, while the second is private because the name changes</p><p>with the PID and the host of the current receiver, and those values</p><p>together are unique in the cluster.</p><p>So we expect that sending messages with the ``echo`` key will result in</p><p>hitting just one of the receivers at a time, in a round-robin fashion,</p><p>while sending messages with the ``echo-fanout`` queue will reach every</p><p>receiver.</p><p>We defined two different functions to process the incoming ``echo``</p><p>message, ``msg_echo()`` and ``msg_echo_fingerprint``; this shows that</p><p>multiple functions can be set as handler for the same messages. In this</p><p>simple case the two functions could also be merged in a single one, but</p><p>sometimes it is better to separate the code of different</p><p>functionalities, not to mention that the code could also be loaded at</p><p>run-time, through a plugin system or a live definition.</p><p>An RPC echo server</p><p>------------------</p><p>The third version of the echo server shows how to implement RPC</p><p>messaging. As before the exchange does not change its signature, so</p><p>``echo_shared.py`` remains the same. When sending the message we must</p><p>specify the we want to send the RPC form using ``rpc_echo()`` instead of</p><p>``message_echo()``</p><p>.. code:: python</p><p>    from postage import messaging</p><p>    import echo_shared</p><p>    class EchoProducer(messaging.GenericProducer):</p><p>        eks = [(echo_shared.EchoExchange, 'echo-rk')]</p><p>    fingerprint = messaging.Fingerprint('echo_send', 'application').as_dict()</p><p>    producer = EchoProducer(fingerprint)</p><p>    reply = producer.rpc_echo("RPC test message")</p><p>    if reply:</p><p>        print reply.body['content']['value']</p><p>    else:</p><p>        print "RPC failed"</p><p>Remember that RPC calls are blocking, so your program will hang at the</p><p>line ``reply = producer.rpc_echo("RPC test message")``, waiting for the</p><p>server to answer. Once the reply has been received, it can be tested and</p><p>used as any other message; Postage RPC can return success, error or</p><p>exception replies, and their content changes accordingly.</p><p>.. code:: python</p><p>    from postage import microthreads</p><p>    from postage import messaging</p><p>    import echo_shared</p><p>    class EchoReceiveProcessor(messaging.MessageProcessor):</p><p>        def __init__(self, fingerprint):</p><p>            eqk = [</p><p>                (echo_shared.EchoExchange, [</p><p>                                ('echo-queue', 'echo-rk'),</p><p>                                ]), </p><p>                ]</p><p>            super(EchoReceiveProcessor, self).__init__(fingerprint, eqk, None, None)</p><p>        @messaging.RpcHandler('command', 'echo')</p><p>        def msg_echo(self, content, reply_func):</p><p>            print content['parameters']</p><p>            reply_func(messaging.MessageResult("RPC message received"))            </p><p>    fingerprint = messaging.Fingerprint('echo_receive', 'controller').as_dict()</p><p>    scheduler = microthreads.MicroScheduler()</p><p>    scheduler.add_microthread(EchoReceiveProcessor(fingerprint))</p><p>    for i in scheduler.main():</p><p>        pass</p><p>The receiver does not change severely; you just need to change the</p><p>handler dadicated to the incoming ``echo`` message. The decorator is now</p><p>``RpcHandler`` and the method must accept a third argument, that is the</p><p>function that must be called to answer the incoming message. You have to</p><p>pass this function a suitable message, i.e. a ``MessageResult`` if</p><p>successfull, other messages to signal an error or an exception. Please</p><p>note that after you called the reply function you can continue executing</p><p>code.</p><p>API Documentation</p><p>=================</p><p>Here you find a description of the messaging part of Postage. Being</p><p>Postage based on AMQP, this help presumes you are familiar with</p><p>structures defined by this latter (exchanges, queues, bindings, virtual</p><p>hosts, ...) and that you already have a working messaging system (for</p><p>example a RabbitMQ cluster).</p><p>In the code and in the following text you will find the two terms</p><p>"application" and "component" used with the same meaning: a Python</p><p>executable which communicates with others using AMQP messages through</p><p>Postage. Due to the nature of AMQP you can have components written in</p><p>several languages working together: here we assumer both producers and</p><p>consumers are written using Postage, but remember that you can make</p><p>Postage components work with any other, as far as you stick to its</p><p>representation of messages (more on that later).</p><p>Environment variables</p><p>---------------------</p><p>Postage reads three environment variables, ``POSTAGE_VHOST``,</p><p>``POSTAGE_USER``, and ``POSTAGE_PASSWORD``, which contain the RabbitMQ</p><p>virtual host in use, the user name and the password. The default values</p><p>for them are ``/``, ``guest``, ``guest``, i.e. the default values you</p><p>can find in a bare RabbitMQ installation. Previous versions used</p><p>``POSTAGE_RMQ_USER`` and ``POSTAGE_RMQ_PASSWORD``, which are still</p><p>supported but deprecated.</p><p>Using the environment variables, especially ``POSTAGE_VHOST``, you can</p><p>easily setup production and development environment and to switch you</p><p>just need to set the variable before executing your Python components</p><p>.. code:: sh</p><p>    POSTAGE_VHOST=development mycomponent.py</p><p>You obviously need to configure RabbitMQ according to your needs,</p><p>declaring the virtual hosts you want.</p><p>Setting up separate environment enables your components to exchange</p><p>messages without interfering with the production systems, thus avoiding</p><p>you to install a separate cluster to test software. The HUP acronym is</p><p>used somewhere in the code to mean Host, User, Password, that is the</p><p>tuple needed to connect to RabbitMQ plus the virtual host.</p><p>A last environment variable, ``POSTAGE_DEBUG_MODE``, drives the debug</p><p>output if set to ``true``. It is intended for Postage debugging use</p><p>only, since its output is pretty verbose.</p><p>Fingerprint</p><p>-----------</p><p>When componentized system become large you need a good way to identify</p><p>your components, so a simple ``Fingerprint`` object is provided to</p><p>encompass useful values, which are:</p><p>-  ``name``: the name of the component or executable</p><p>-  ``type``: a rough plain categorization of the component</p><p>-  ``pid``: the OS pid of the component executable</p><p>-  ``host``: the host the component is running on</p><p>-  ``user``: the OS user running the component executable</p><p>-  ``vhost``: the RabbitMQ virtual host the component is running on</p><p>This object is mainly used to simplify the management of all those</p><p>values, and to allow writing compact code. Since Postage messages are</p><p>dictionaries (see below) the object provides a ``as_dict()`` method to</p><p>return its dictionary form, along with a ``as_tuple()`` method to</p><p>provide the tuple form.</p><p>You can use any class to encompass the values you need to identify your</p><p>components: Postage ALWAYS uses the dictionary form of fingerprints, so</p><p>you need a way to give a meaningful dictionary representation of your</p><p>class of choice.</p><p>Obviously to uniquely identify a component on a network you need just</p><p>host and pid values, but a more complete set of values can greatly</p><p>simplify management.</p><p>Fingerprint objects can automatically retrieve all values from the OS,</p><p>needing only the name and type values; if not passed those are ``None``.</p><p>.. code:: python</p><p>    fingerprint = Fingerprint(name="mycomponent")</p><p>    print fingerprint.as_dict()</p><p>Encoder</p><p>-------</p><p>Postage messages are Python dictionaries serialized in JSON. The</p><p>``JsonEncoder`` object provides the ``encode()`` and ``decode()``</p><p>methods and the correct type ``application/json``. Encoder class can be</p><p>easly replaced in your components, provided that it sticks to this</p><p>interface.</p><p>Messages</p><p>--------</p><p>To manage the different types of messages, appropriate objects have been</p><p>defined. The base object is ``Message``: it has a **type**, a **name**</p><p>and a **category**. It can encompass a **fingerprint** and a</p><p>**content**, which are both dictionaries.</p><p>The type of the message is free, even if some have been already defined</p><p>in Postage: **command**, **status**, and **result**. This categorization</p><p>allows the consumers to filter incoming messages according to the action</p><p>they require.</p><p>The category of the message is not free, and must be one of **message**</p><p>and **rpc** (this nomenclature is somewhat misleading, since RPC are</p><p>messages just like the standard ones; future plans include a review of</p><p>it). The first type marks fire-and-forget messages, while the second</p><p>signals RPC ones.</p><p>The dictionary form of the message is the following:</p><p>.. code:: python</p><p>    message = {</p><p>        'type': message_type,</p><p>        'name': message_name,</p><p>        'category': message_category,</p><p>        'version': '2',</p><p>        'fingerprint': {...},</p><p>        'content': {...},</p><p>        '_reserved': {...}</p><p>        }</p><p>The ``content`` key contains the actual data you put in your message,</p><p>and its structure is free.</p><p>**Command** messages send a command to another component. The command</p><p>can be a fire-and-forget one or an RPC call, according to the message</p><p>category; the former is implemented by the ``MessageCommand`` class,</p><p>while the latter is implemented by ``RpcCommand``. Both classes need the</p><p>name of the command and an optional dictionary of parameters, which are</p><p>imposed by the actual command. The message fingerprint can be set with</p><p>its ``fingerprint(**kwds)`` method.</p><p>.. code:: python</p><p>        m = messaging.MessageCommand('sum', parameters={a=5, b=6})</p><p>        f = Fingerprint(name='mycomponent')</p><p>        m.fingerprint(f.as_dict())</p><p>**Status** messages bear the status of an application, along with the</p><p>application fingerprint. The class which implements this type is</p><p>``MessageStatus``. This object needs only a single parameter, which is</p><p>the status itself. Not that as long as the status is serializable, it</p><p>can be of any nature.</p><p>.. code:: python</p><p>        m = messaging.MessageStatus('online')</p><p>**Result** messages contain the result of an RPC call: three classes</p><p>have this type, ``MessageResult``, ``MessageResultError``,</p><p>``MessageResultException``. The first is the result of a successful</p><p>call, the second is the result of an error in a call, while the third</p><p>signals that an exception was raised by the remote component. This error</p><p>classification has been inspired by Erlang error management, which I</p><p>find a good solution. All three classes contain a **value** and a</p><p>**message**, but for errors the value is ``None`` and for exceptions it</p><p>is the name of the Python exception.</p><p>.. code:: python</p><p>        try:</p><p>            result = some_operation()</p><p>            m = messaging.MessageResult(result)</p><p>        except Exception as exc:</p><p>            m = messaging.MessageResultException(exc.__class__.__name__, exc.__str__())</p><p>Exchange</p><p>--------</p><p>The ``Exchange`` class allows to declare exchanges just by customizing</p><p>the class parameters. It provides a ``parameters`` class property that</p><p>gives a dictionary representation of the exchange itself, as required by</p><p>the ``exchange_declare()`` method of the AMQP channel.</p><p>To declare your own exchange you just need to inherit ``Exchange``</p><p>.. code:: python</p><p>    from postage import messaging</p><p>    class MyExchange(messaging.Exchange):</p><p>        name = "my-custom-exchange"</p><p>        exchange_type = "topic"</p><p>        passive = False</p><p>        durable = True</p><p>        auto_delete = False</p><p>GenericProducer</p><p>---------------</p><p>When you use AMQP you are free to use any format for your messages and</p><p>any protocol for sending and receiving data. Postage gives you a</p><p>predefined, though extensible, message format, the ``Message`` object.</p><p>Moreover, through ``GenericProducer``, it gives you a way to easily</p><p>define an API, i.e. a set of shortcut functions that create and send</p><p>messages, through which you can interact with your system.</p><p>To better introduce the simplification implemented by</p><p>``GenericProducer`` let us recap what a component shall do to send a</p><p>message using pika and the ``Message`` object.</p><p>1. a ``Message`` object has to be declared and filled with the</p><p>   information we want to send, according to a given predefined format</p><p>   (the message API of our system). The message must contain the correct</p><p>   fingerprint and be encoded using the encoder of your choice (choice</p><p>   that must be shared by all other components in the system).</p><p>2. A connection to the AMQP broker must be established, then all the</p><p>   target exchanges must be declared.</p><p>3. For each exchange you want to receive the message you shall publish</p><p>   it giving the correct routing key for that exchange: the keys you can</p><p>   use are part of your messaging API, so you have to "document" them</p><p>   when you publish the specification for your exchanges.</p><p>As you can see this can quickly lead to a bunch o repeated code, as the</p><p>set of operation you need are often the same or very similar; moreover,</p><p>it needs a source of documentation outside the code, that is, the API</p><p>does not document itself (here I mean: there is no way to get a grasp on</p><p>the set of messages you are defining in your API).</p><p>Let us see how ``GenericProducer`` solves these issues. First of all you</p><p>need to define an exchange:</p><p>.. code:: python</p><p>    class LoggingExchange(messaging.Exchange):</p><p>        name = logging-exchange"</p><p>        exchange_type = "direct"</p><p>        passive = False</p><p>        durable = True</p><p>        auto_delete = False</p><p>Then you need to define a producer, i.e. an object that inherits from</p><p>``GenericProducer``:</p><p>.. code:: python</p><p>    class LoggingProducer(messaging.GenericProducer):</p><p>        pass</p><p>since the aim of the producer is that of simplify sending messages to an</p><p>exchange you can here specify a set of exchanges/key couples (EKs) which</p><p>will be used by default (more on this later).</p><p>.. code:: python</p><p>    class LoggingProducer(messaging.GenericProducer):</p><p>        eks = [(LoggingExchange, 'log')]</p><p>Now you have to define a function that builds a ``Message`` containing</p><p>the data you want to send</p><p>.. code:: python</p><p>    class LoggingProducer(messaging.GenericProducer):</p><p>        eks = [(LoggingExchange, "log")]        </p><p>        def build_message_status_online(self):</p><p>            return messaging.MessageStatus('online')</p><p>This allows you to write the following code</p><p>.. code:: python</p><p>    producer = LoggingProducer()</p><p>    producer.message_status_online()</p><p>which will build a ``MessageStatus`` containing the ``'online'`` status</p><p>string and will send it to the exchange named ``logging-exchange`` with</p><p>``'log'`` as routing key.</p><p>Magic methods</p><p>~~~~~~~~~~~~~</p><p>As you can see ``GenericProducer`` automatically defines a</p><p>``message_name()`` method that wraps each of the</p><p>``build_message_name()`` methods you defines. The same happens with RPC</p><p>messages, where the ``rpc_name()`` method is automatically created to</p><p>wrap ``build_rpc_name()``.</p><p>``message_*()`` methods accept two special keyword arguments, namely</p><p>**\_key**, **\_eks**, that change the way the message is sent. The</p><p>behaviour of the two keywords follows the following algorithm:</p><p>1. Calling ``message_name()`` sends the message with the predefined</p><p>   ``eks``, i.e. those defined in the producer class. This means that</p><p>   the message is sent to each exchange listed in the ``eks`` list of</p><p>   the class, with the associated key.</p><p>2. Calling ``message_name(_key='rk')`` sends the message to the first</p><p>   exchange in ``eks`` with the key ``rk``.</p><p>3. Calling ``message_name(_eks=[(exchange1, rk1), (exchange2, rk2)])``</p><p>   uses the specified eks instead of the content of the default ``eks``</p><p>   variable; in this case sends the message to ``exchange1`` with</p><p>   routing key ``rk1`` and to ``exchange2`` with routing key ``rk2``.</p><p>If you speficy both ``_eks`` and ``_key`` the latter will be ignored.</p><p>This system allows you to specify a default behaviour when writing the</p><p>producer and to customize the routing key or even the exchange on the</p><p>fly.</p><p>RPC messages accept also ``_timeout`` (seconds), ``_max_retry`` and</p><p>``_queue_only`` to customize the behaviour of the producer when waiting</p><p>for RPC answers (more on that later).</p><p>Fingerprint</p><p>~~~~~~~~~~~</p><p>When a ``GenericProducer`` is instanced a ``Fingerprint`` in its</p><p>dictionary form can be passed as argument and this is included in each</p><p>message object the producer sends. If not given, a bare fingerprint is</p><p>created inside the object.</p><p>.. code:: python</p><p>    f = Fingerprint(name='mycomponent')</p><p>    producer = LoggingProducer(fingerprint=f.as_dict())</p><p>    producer.message_status_online()</p><p>Generic messages</p><p>~~~~~~~~~~~~~~~~</p><p>You can use a producer to send generic messages using the ``message()``</p><p>method</p><p>.. code:: python</p><p>    p = messaging.GenericProducer()</p><p>    p.message(1, "str", values={1, 2, 3, "numbers"},</p><p>        _eks=[(MyExchangeCls, "a_routing_key")])</p><p>RPC calls</p><p>~~~~~~~~~</p><p>RPC calls are blocking calls that leverage a very simple mechanism: the</p><p>low level AMQP message is given a (usually temporary and private) queue</p><p>through its ``reply_to`` property, and this is explicitely used by the</p><p>receiver to send an answer.</p><p>In Postage an RPC message is defined by a ``build_rpc_name()`` method in</p><p>a ``GenericProducer`` and called with ``rpc_name()``; it returns a</p><p>result message as sent by the component that answered the call and thus</p><p>its type should be one of ``MessageResult``, ``MessageResultError`` or</p><p>``MessageResultException`` for plain Postage.</p><p>RPC messages accept the following parameters: ``_timeout`` (the message</p><p>timeout, defaults to 30 seconds), ``_max_retry`` (the maximum number of</p><p>times the message shall be sent again when timing out, default to 4),</p><p>and ``_queue_only`` (the call returns the temporary queue on which the</p><p>answer message will appear, instead of the message itself).</p><p>When the maximum number of tries has been reached the call returns a</p><p>``MessageResultException`` with the ``TimeoutError`` exception.</p><p>GenericConsumer</p><p>---------------</p><p>The ``GenericConsumer`` class implements a standard AMQP consumer, i.e.</p><p>an object that can connect to exchanges through queues and fetch</p><p>messages.</p><p>A class that inherits from ``GenericConsumer`` shall define an ``eqk``</p><p>class attribute which is a list of tuples in the form</p><p>``(Exchange, [(Queue, Key), (Queue, Key), ...])``; each tuple means that</p><p>the given exchange will be subscribed by the listed queues, each of them</p><p>with the relative routing key.</p><p>.. code:: python</p><p>    class MyConsumer(GenericConsumer):</p><p>        eqk = (</p><p>            PingExchage, [('ping_queue', 'ping_rk')],</p><p>            LogExchange, [('log_queue', 'log')]</p><p>            )</p><p>Apart from declaring bindings in the class you can use the</p><p>``queue_bind()`` method that accept an exchange, a queue and a key. This</p><p>can be useful if you have to declare queues at runtime or if parameters</p><p>such as routing key depend on some value you cannot access at</p><p>instantiation time.</p><p>MessageProcessor</p><p>----------------</p><p>``MessageProcessor`` objects boost ``GenericConsumer`` to full power =)</p><p>A ``MessageProcessor`` is a ``MicroThread`` with two main attributes:</p><p>``self.consumer`` (a ``GenericConsumer`` or derived class) and a</p><p>``self.fingerprint`` (a ``Fingerprint`` in its dictionary form).</p><p>Inside a ``MessageProcessor`` you can define a set of methods called</p><p>"message handlers" that process incoming messages. The methods can be</p><p>freely called and have to be decorated with the ``@MessageHandler``</p><p>decorator; this needs two parameters: the type of the message and the</p><p>name. So defining</p><p>.. code:: python</p><p>    @MessageHandler('command', 'quit')</p><p>    def msg_quit(self, content):</p><p>        [...]</p><p>you make the method ``msg_quit()`` process each incoming message which</p><p>type is ``command`` and name is ``quit``. You can define as many message</p><p>handlers as you want for the same message type/name, but beware that</p><p>they are all executed in random order. As you can see from the example a</p><p>message handler method must accept a parameter which receives the</p><p>content of the processed message.</p><p>You can also decorate a method with the ``@RpcHandler`` decorator; in</p><p>that case the method must accept two parameters, the first being the</p><p>content of the received message, the second a reply function. The method</p><p>has the responsibility of calling it passing a ``MessageResult`` or</p><p>derived object. This mechanism allows the handler to do some cleanup</p><p>after sending the reply.</p><p>Message handlers can also be defined as classes inside a</p><p>``MessageProcessor`` and have to inherit from ``Handler`` and define a</p><p>``call()`` method which accepts only self; it can then access the</p><p>``self.data`` and ``self.reply_func`` attributes that contain the</p><p>incoming message and the return function. The difference between the</p><p>method and class version of the message handlers is that the class</p><p>version can access the underlying ``MessageProcessor`` through its</p><p>``self.processor`` attribute. This is useful to access the fingerprint</p><p>of the message or any other attribute that is included in the processor.</p><p>A class is then in general richer thana simple method, thus giving more</p><p>freedom to the programmer.</p><p>The last available decorator is ``MessageHandlerFullBody`` that passes</p><p>to the decorated method or class the full body of the incoming message</p><p>instead that only the value of the ``content`` key like</p><p>``MessageHandler`` and ``RpcHandler`` do.</p><p>Default handlers</p><p>~~~~~~~~~~~~~~~~</p><p>``MessageProcessor`` objects define two default message handlers to</p><p>process incoming command ``quit`` and command ``restart``. The first, as</p><p>you can easily guess from the name, makes the component quit; actually</p><p>it makes the consumer stop consuming messages and the microthread quit,</p><p>so the program executes the code you put after the scheduler loop. If</p><p>you put no code, the program just exits. The second command makes the</p><p>component restart, i.e. it replaces itself with a new execution of the</p><p>same program. This makes very easy to update running systems; just</p><p>replace the code and send a ``restart`` to your components.</p><p>Credits</p><p>~~~~~~~</p><p>First of all I want to mention and thank the `Erlang &lt;www.erlang.org&gt;`__</p><p>and `RabbitMQ &lt;www.rabbitmq.com&gt;`__ teams and the maintainer of</p><p>`pika &lt;https: github.com="" pika="" pika=""&gt;`__, Gavin M. Roy, for their hard</p><p>work, and for releasing such amazing pieces of software as open source.</p><p>Many thanks to `Jeff Knupp &lt;http: www.jeffknupp.com="" about-me=""/&gt;`__ for</p><p>his post `Open Sourcing a Python Project the Right</p><p>Way &lt;http: www.jeffknupp.com="" blog="" 2013="" 08="" 16="" open-sourcing-a-python-project-the-right-way=""/&gt;`__</p><p>and to `Audrey M. Roy &lt;http: www.audreymroy.com=""/&gt;`__ for her</p><p>`cookiecutter &lt;https: github.com="" audreyr="" cookiecutter=""&gt;`__ and</p><p>`cookiecutter-pypackage &lt;https: github.com="" audreyr="" cookiecutter-pypackage=""&gt;`__</p><p>tools. All those things make Python packaging a breeze.</p><p>.. |Build Status| image:: https://travis-ci.org/lgiordani/postage.png?branch=master</p><p>   :target: https://travis-ci.org/lgiordani/postage</p><p>.. |Version| image:: https://badge.fury.io/py/postage.png</p><p>   :target: http://badge.fury.io/py/postage</p><p>.. |PyPi Downloads| image:: https://pypip.in/d/postage/badge.png</p><p>   :target: https://crate.io/packages/postage?version=latest</p><p>History</p><p>-------</p><p>1.0.0 (2013-12-03)</p><p>++++++++++++++++++</p><p>* First release on PyPI.

</p><a name="downloads">Â </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>31</span> downloads in the last week
  </li>
  <li>
    <span>277</span> downloads in the last month
  </li>
</ul>









            </div>


          </div></body></html>