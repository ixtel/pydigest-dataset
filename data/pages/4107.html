<html><body><div><div class="article-content"><p>Last month, I had a programming interview. It hadn't gone as I would've liked, but I did get asked a question that I found interesting. The question is deceptively simple, but has a lot of depth to it. Since I failed to solve the problem correctly in the interview, I decided explore the ways in which I could optimize my initially O(n<sup>2</sup>) solution.</p><p>After a few attempts at solving the problem from different angles, I've come to appreciate the importance of understanding complexity, as well as its limitations.</p><div class="section" id="the-question"><p>The question was simple:</p><blockquote> Given a list of words L, find all the anagrams in L in the order in which they appear in L.</blockquote><div class="section" id="an-example"><p>Given the input</p><div class="highlight"><pre><span class="p">[</span><span class="s">"pool"</span><span class="p">,</span> <span class="s">"loco"</span><span class="p">,</span> <span class="s">"cool"</span><span class="p">,</span> <span class="s">"stain"</span><span class="p">,</span> <span class="s">"satin"</span><span class="p">,</span> <span class="s">"pretty"</span><span class="p">,</span> <span class="s">"nice"</span><span class="p">,</span> <span class="s">"loop"</span><span class="p">]</span>
</pre></div><p>The desired output would be</p><div class="highlight"><pre><span class="p">[</span><span class="s">"pool"</span><span class="p">,</span> <span class="s">"loco"</span><span class="p">,</span> <span class="s">"cool"</span><span class="p">,</span> <span class="s">"stain"</span><span class="p">,</span> <span class="s">"satin"</span><span class="p">,</span> <span class="s">"loop"</span><span class="p">]</span>
</pre></div><p>in that order <em>exactly</em>.</p></div></div><div class="section" id="quadratic-time"><p>The naive solution to this will give you an O(n<sup>2</sup>) algorithm. Be warned, the following code may burn your eyes.</p><div class="section" id="initial-solution"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>


<span class="k">def</span> <span class="nf">anagram_finder</span><span class="p">(</span><span class="n">word_list</span><span class="p">):</span>

    <span class="n">_ret</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_list</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">other_word</span> <span class="ow">in</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">word_list</span> <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="n">word</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">Counter</span><span class="p">(</span><span class="n">other_word</span><span class="p">)</span> <span class="o">==</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">_ret</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
                <span class="n">_ret</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other_word</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">word_list</span> <span class="k">if</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">_ret</span><span class="p">]</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>

    <span class="k">print</span> <span class="n">anagram_finder</span><span class="p">([</span><span class="s">"pool"</span><span class="p">,</span> <span class="s">"loco"</span><span class="p">,</span> <span class="s">"cool"</span><span class="p">,</span> <span class="s">"stain"</span><span class="p">,</span> <span class="s">"satin"</span><span class="p">,</span> <span class="s">"pretty"</span><span class="p">,</span> <span class="s">"nice"</span><span class="p">,</span> <span class="s">"loop"</span><span class="p">])</span>
</pre></div><p>This is <em>wrong</em> on so many levels, I don't even know <em>where</em> to begin.</p><ul class="simple"><li>The problem solves the solution in quadratic time meaning, for more computing power we throw at this the slower it gets per computer. Imagine if we were to put an algorithm like this in the server, we would have serious scaling issues.</li><li><code>collections.Counter</code> is expensive. It needs to create a dictionary, then it needs to add <em>each</em> character to the dictionary, that means <em>hashing</em> each character.</li><li>It adds the original word every single time it finds an anagram, and relies on <code>set</code> not to add duplicate values.</li></ul><p>I'm probably missing a few points but the point remains; this is seriously bad code.</p></div></div><div class="section" id="linear-time"><p>So, how can we turn this problem form an O(n<sup>2</sup>) solution into an O(n) solution? Using hash-maps correctly. Unfortunately, I did not come up with the brilliant idea of using a hash-map, but rather my interviewer told me that the way to get O(n) was to use a hash-map.</p><div class="section" id="hashing-the-right-way"><p>In general, whenever you hear the word "hash" you think md5 or SHA. But in reality, a hash is a way to map data in a uniform way. Think of it like this, if you have a the word <em>pool</em> and <em>loop</em>, in the eyes of the anagram solver, they are the same. Why? Because <em>both</em> words use the same characters. In other words, there had to be a uniform way to converting these two words into the <em>same</em> thing. If we were to simply <em>sort</em> the characters in the word, we'd get exactly what we're looking for. Here's a demonstration:</p><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="nb">sorted</span><span class="p">(</span><span class="s">"loop"</span><span class="p">)</span>
<span class="p">[</span><span class="s">'l'</span><span class="p">,</span> <span class="s">'o'</span><span class="p">,</span> <span class="s">'o'</span><span class="p">,</span> <span class="s">'p'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">sorted</span><span class="p">(</span><span class="s">"pool"</span><span class="p">)</span>
<span class="p">[</span><span class="s">'l'</span><span class="p">,</span> <span class="s">'o'</span><span class="p">,</span> <span class="s">'o'</span><span class="p">,</span> <span class="s">'p'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="s">"loop"</span><span class="p">))</span>
<span class="s">'loop'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="s">"pool"</span><span class="p">))</span>
<span class="s">'loop'</span>
</pre></div><p>With that, I had my hashing function and with it, I had my linear solution.</p><div class="highlight"><pre><span class="k">def</span> <span class="nf">hasher</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>  <span class="c"># 1</span>
    <span class="k">return</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">anagram_finder</span><span class="p">(</span><span class="n">word_list</span><span class="p">):</span>

    <span class="n">hash_dict</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># 2</span>

    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_list</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>  <span class="c"># 3</span>

        <span class="k">if</span> <span class="n">h</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hash_dict</span><span class="p">:</span>  <span class="c"># 4</span>
            <span class="n">hash_dict</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># 5</span>

        <span class="n">hash_dict</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>  <span class="c"># 6</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">anagram</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">hash_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">anagram</span> <span class="ow">in</span> <span class="n">l</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>  <span class="c"># 7</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">anagram_finder</span><span class="p">([</span><span class="s">"pool"</span><span class="p">,</span> <span class="s">"loco"</span><span class="p">,</span> <span class="s">"cool"</span><span class="p">,</span> <span class="s">"stain"</span><span class="p">,</span> <span class="s">"satin"</span><span class="p">,</span> <span class="s">"pretty"</span><span class="p">,</span> <span class="s">"nice"</span><span class="p">,</span> <span class="s">"loop"</span><span class="p">]))</span>
</pre></div><p>In <code class="coderef">1</code>, we create the <code>hasher</code> function. The hash is simple, it sorts the string alphabetically using <code>sorted</code>, which returns a list, which we then use as an iterable for <code>"".join</code> to create a string. We do this because python lists are not hashable (because they are mutable).</p><p>In <code class="coderef">2</code>, inside the <code>anagram_finder</code> function, we create a <code>hash_dict</code>, a dictionary for all our hashes. It must be pointed out that the dictionary, when adding new keys, will hash those keys as well.<a class="footnote-reference" href="#howstringsarehashed" id="id1">[1]</a> The worst case for <code>hasher</code> is O(n) where n is the length of the word in question, so no issue with the size of the list we're given.</p><p>In <code class="coderef">3</code> we actually call the <code>hasher</code> to hash the string. In <code class="coderef">4</code>, we check to see if this hash exists in the keys of <code>hash_dict</code>. If not, then we create a new list so that we can append words to it in <code class="coderef">5</code>.</p><p>In the end, we <em>always</em> append the word to the list of that key in <code class="coderef">6</code>. This means, that every key will always have <em>at least one</em> value stored in its list, and these values are the ones we don't one.</p><p>The simplified version of <code class="coderef">7</code> is as follows:</p><div class="highlight"><pre><span class="n">_ret</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">hash_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">_ret</span> <span class="o">+=</span> <span class="n">l</span>
</pre></div><div class="section" id="the-pythonic-version"><p>The above is great for explanation, but the pythonic version is much smaller:</p><div class="highlight"><pre><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>


<span class="k">def</span> <span class="nf">hasher</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">anagram_finder</span><span class="p">(</span><span class="n">word_list</span><span class="p">):</span>

    <span class="n">hash_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_list</span><span class="p">:</span>
        <span class="n">hash_dict</span><span class="p">[</span><span class="n">hasher</span><span class="p">(</span><span class="n">word</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>  <span class="c"># 1</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">anagram</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">hash_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">anagram</span> <span class="ow">in</span> <span class="n">l</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">anagram_finder</span><span class="p">([</span><span class="s">"pool"</span><span class="p">,</span> <span class="s">"loco"</span><span class="p">,</span> <span class="s">"cool"</span><span class="p">,</span> <span class="s">"stain"</span><span class="p">,</span> <span class="s">"satin"</span><span class="p">,</span> <span class="s">"pretty"</span><span class="p">,</span> <span class="s">"nice"</span><span class="p">,</span> <span class="s">"loop"</span><span class="p">]))</span>
</pre></div><p>We've made the code significantly smaller by using a <code>defaultdict</code> in <code class="coderef">1</code>. <code>defaultdict</code> allows us to give it a factory, in this case <code>list</code>, that will automatically create a list with a key if a key does not exist. If it does exist, then it will return that list, and we can append to it.<a class="footnote-reference" href="#moreondefaultdict" id="id2">[3]</a></p><p>But wait, we forgot about the ordering.</p></div></div><div class="section" id="ordering-done-right"><p>We have a quick fix for the ordering, and that is simply to loop through all the words in the initial list and include only those that is in the list of anagrams. The solution is <em>still</em> O(n), but remains highly inefficient. One thought might be to use the <code>collections.OrderedDict</code> class. But although that might <em>seem</em> to work, the ordering will still not match the original in the case where anagrams are not next to each other. For example, the following piece of code will return:</p><div class="highlight"><pre><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>


<span class="k">def</span> <span class="nf">hasher</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">anagram_finder</span><span class="p">(</span><span class="n">word_list</span><span class="p">):</span>

    <span class="n">hash_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_list</span><span class="p">:</span>
        <span class="n">hash_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">hasher</span><span class="p">(</span><span class="n">word</span><span class="p">),</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">anagram</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">hash_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">anagram</span> <span class="ow">in</span> <span class="n">l</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">anagram_finder</span><span class="p">([</span><span class="s">"nala"</span><span class="p">,</span> <span class="s">"pool"</span><span class="p">,</span> <span class="s">"loco"</span><span class="p">,</span> <span class="s">"cool"</span><span class="p">,</span> <span class="s">"stain"</span><span class="p">,</span> <span class="s">"satin"</span><span class="p">,</span> <span class="s">"pretty"</span><span class="p">,</span> <span class="s">"nice"</span><span class="p">,</span> <span class="s">"loop"</span><span class="p">,</span> <span class="s">"laan"</span><span class="p">]))</span>
</pre></div><div class="highlight"><pre><span class="p">[</span><span class="s">'nala'</span><span class="p">,</span> <span class="s">'laan'</span><span class="p">,</span> <span class="s">'pool'</span><span class="p">,</span> <span class="s">'loop'</span><span class="p">,</span> <span class="s">'loco'</span><span class="p">,</span> <span class="s">'cool'</span><span class="p">,</span> <span class="s">'stain'</span><span class="p">,</span> <span class="s">'satin'</span><span class="p">]</span>
</pre></div><p><code>nala</code> and <code>laan</code> should not be next to each other. This is because <code>collections.OrderedDict</code> remembers the order in which the <em>keys</em> were added.</p><p>So, in the end, I stuck to the following:</p><div class="highlight"><pre><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>


<span class="k">def</span> <span class="nf">hasher</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">anagram_finder</span><span class="p">(</span><span class="n">word_list</span><span class="p">):</span>

    <span class="n">hash_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_list</span><span class="p">:</span>
        <span class="n">hash_dict</span><span class="p">[</span><span class="n">hasher</span><span class="p">(</span><span class="n">word</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">word</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_list</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hash_dict</span><span class="p">[</span><span class="n">hasher</span><span class="p">(</span><span class="n">word</span><span class="p">)])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">anagram_finder</span><span class="p">([</span><span class="s">"nala"</span><span class="p">,</span> <span class="s">"pool"</span><span class="p">,</span> <span class="s">"loco"</span><span class="p">,</span> <span class="s">"cool"</span><span class="p">,</span> <span class="s">"stain"</span><span class="p">,</span> <span class="s">"satin"</span><span class="p">,</span> <span class="s">"pretty"</span><span class="p">,</span> <span class="s">"nice"</span><span class="p">,</span> <span class="s">"loop"</span><span class="p">,</span> <span class="s">"laan"</span><span class="p">]))</span>
</pre></div><p>With that, we solved the <em>ordering</em> problem and still managed to make it linear.</p></div><div class="section" id="profiling"><p>We never know how well something will actually work unless we profile it. So I got a big list of words<a class="footnote-reference" href="#biglist" id="id3">[2]</a> and go to profiling.</p><div class="highlight"><pre><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>


<span class="k">def</span> <span class="nf">hasher</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">anagram_finder</span><span class="p">(</span><span class="n">word_list</span><span class="p">):</span>

    <span class="n">hash_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_list</span><span class="p">:</span>
        <span class="n">hash_dict</span><span class="p">[</span><span class="n">hasher</span><span class="p">(</span><span class="n">word</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">word</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_list</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hash_dict</span><span class="p">[</span><span class="n">hasher</span><span class="p">(</span><span class="n">word</span><span class="p">)])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'wordsEn.txt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">w_list</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">anagram_finder</span><span class="p">(</span><span class="n">w_list</span><span class="p">)</span>
</pre></div><p>I used a library called <a class="reference external" href="https://github.com/what-studio/profiling">profiling</a>, and it can be installed with a simple pip install. After profiling the above code, I found that my <code>hasher</code> function was actually making the the whole process a lot slower, because it was being called <em>twice</em>.</p><img alt="Profiling without storing hash values" class="align-center" src="/images/anagrams_profile_01.png"/><p>So, my first attempt (like a good pythonista) was to use <code>functools.lru_cache</code>. That attempt failed spectacularly.</p><div class="highlight"><pre><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>

<span class="nd">@lru_cache</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">hasher</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">anagram_finder</span><span class="p">(</span><span class="n">word_list</span><span class="p">):</span>

    <span class="n">hash_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_list</span><span class="p">:</span>
        <span class="n">hash_dict</span><span class="p">[</span><span class="n">hasher</span><span class="p">(</span><span class="n">word</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">word</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_list</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hash_dict</span><span class="p">[</span><span class="n">hasher</span><span class="p">(</span><span class="n">word</span><span class="p">)])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'wordsEn.txt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">w_list</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">anagram_finder</span><span class="p">(</span><span class="n">w_list</span><span class="p">)</span>
</pre></div><p>This is because there were excessive calls being made all over the place. Even increasing the size of the cache from <code>lru_cache()</code> which has a default if <code>128</code> to <code>lru_cache(11000)</code> which is roughly the size of the word list I'm using. In fact, increasing the <code>lru_cache</code> size to such an amount slowed down the program so much that I didn't wait for it to finish, but the root problem was the same; too many calls were being made all over the place.</p><img alt="Using LRU cache this time" class="align-center" src="/images/anagrams_profile_02.png"/><p>So, to compare the two programs, with lru and without lru, we can see that the program <em>without</em> lru was significantly faster than the one <em>with</em> lru (4.77 seconds to 15.31 seconds. With the failure or <code>lru_cache</code> as a feasible solution, I decided to just use a normal dictionary to store hashes. In our original attempt, <code>hasher</code> was being called twice, once to add words to the dictionary, and then in the list comprehension. Why not just use a dictionary to store the hash and the word?</p><div class="highlight"><pre><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>


<span class="k">def</span> <span class="nf">hasher</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">word</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">anagram_finder</span><span class="p">(</span><span class="n">word_list</span><span class="p">):</span>

    <span class="n">hash_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">hashes</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_list</span><span class="p">:</span>
        <span class="n">hashes</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="n">hash_dict</span><span class="p">[</span><span class="n">hashes</span><span class="p">[</span><span class="n">word</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">word</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_list</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hash_dict</span><span class="p">[</span><span class="n">hashes</span><span class="p">[</span><span class="n">word</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'wordsEn.txt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">w_list</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">anagram_finder</span><span class="p">(</span><span class="n">w_list</span><span class="p">)</span>
</pre></div><p>We just create a new dictionary, <code>hashes</code> to store all our hash and word pairs. This resulted in a speedup.</p><img alt="This time with the hashes dictionary" class="align-center" src="/images/anagrams_profile_03.png"/></div></div><div class="section" id="a-vector-approach-to-hashing"><p>Another approach to hashing would be to use a vector to determine the number of letters that appear in a word. This is better explained through code:</p><div class="highlight"><pre><span class="k">def</span> <span class="nf">hasher</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>                   <span class="c"># 1</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
        <span class="n">h</span><span class="p">[</span><span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c"># 2</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>                <span class="c"># 3</span>
</pre></div><p>In <code class="coderef">1</code>, we create a list of length 26, having all its values initialized to 0. In <code class="coderef">2</code>, we calculate the rank of the letter in the english alphabet using <code>ord(c) - ord(a)</code>. We use this rank as the index of our list. We then add 1 to the value of the index. In other words we are merely counting the frequency of the letters in a word; very similar to a histogram.</p><p>The above is O(n) compared to the O(n log(n)) solution that sorting a string gives us (n is the number of characters in the word here). However, considering that the average size of a word in the english language is actually 5 and the average size of a word in my <code>wordsEn.txt</code> file is 8, O(n) actually becomes the <em>smaller</em> problem here, and the constant time that is required to create a list of 26 items is the bigger problem. In other words, its O(26) for list creation and initiation. Its O(n) for creating the rank and its O(26) for creating the tuple.</p><p>Compare that to O(n log(n)) worst case for using <code>sorted</code>. In this particular use case since n is very low, the better option is to use <code>sorted</code>.</p></div><div class="section" id="the-final-frontier"><p>The best solution to this problem however is not one of my own making, but rather one that a friend of mine (Alexander) provided me with. My solution actually is superfluous in many cases, but the following cuts straight to the point:</p><div class="highlight"><pre><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">izip</span>

<span class="k">def</span> <span class="nf">get_anagrams</span><span class="p">(</span><span class="n">words</span><span class="p">):</span>

    <span class="n">normalized</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words</span><span class="p">]</span>  <span class="c"># 1</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c"># 2</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">normalized</span><span class="p">:</span>  <span class="c"># 3</span>
        <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>         <span class="c"># 4</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">normalized</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>  <span class="c"># 5</span>
</pre></div><p>The genius of this approach is to use <code>collections.defaultdict</code> with <code>int</code> as the factory. This basically means that you have a smaller memory footprint. So, in <code class="coderef">1</code>, we get a list of hashed values (which he calls normalized). In <code class="coderef">2</code>, we create a <code>defaultdict</code> of int, this means that all the keys will have an initial value of 0.</p><p>In <code class="coderef">3</code>, we loop over all the normalized/hashed values. <code class="coderef">4</code> is where the magic happens. So, there will be duplicates in <code>normalized</code>, and we are going to count the number of times each of those normalized values appear.</p><p>In <code class="coderef">5</code>, we zip over the initial word list, <code>words</code> and <code>normalized</code>. Remember, that <em>all</em> the words are normalized. All we do then is simply check to see if the number of times the normalized value of the word appears in <code>d</code>. If there's more than one occurrence, we add the word to the final list in this list comprehension.</p><div class="section" id="but-there-s-an-import-for-that"><p>In the very beginning, I used <code>collections.Counter</code>, to provide the <em>worst</em> possible solution to the problem. But, I think this time, we can actually use <code>collections.Counter</code> correctly, because <code class="coderef">2</code>, <code class="coderef">3</code> and <code class="coderef">4</code> can be shortened to just <code>Counter(normalized)</code>. So the <em>final final</em> (gosh, that feels javaish) version is:</p><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_anagrams</span><span class="p">(</span><span class="n">words</span><span class="p">):</span>

    <span class="n">normalized</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words</span><span class="p">]</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">normalized</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">normalized</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
</pre></div></div></div><div class="section" id="lessons-learnt"><ul class="simple"><li>Hash Maps are very important. Learn to use them properly.</li><li>When making an algorithm don't think standard library, think of finding the best algorithmic solution.</li><li>After you've found the algorithmic solution try optimizing it using the standard library.</li><li>Quadratic time is worse than you can imagine.</li><li>Complexity analysis alone is a blunt instrument so always profile.</li><li>Just because an algorithm has better worst case complexity doesn't mean that its the best one for the job.</li><li>Sometimes our brains stop working under pressure. Take a deep breath, stop worrying about what will happen if you <em>don't</em> solved the problem and focus on all the good things that will happen if you <em>do</em>.</li></ul></div><div class="section" id="acknowledgments"><p><strong>Ashwin</strong> (@inspectorG4dget) for helping me answer this question and explaining the vector approach to hashing. Ashwin's help has been paramount to my understanding.</p><p>To my interviewer for giving me a very good question, and to <strong>Ridwan</strong> (@hjr265) for pointing out flaws in my solution and for encouraging me to write a blog post on this problem.</p><p><strong>Alexander</strong> (@metaprogrammer) for proof reading this post and providing me with the optimal solution to this problem.<a class="footnote-reference" href="#whoisalexander" id="id4">[4]</a></p><hr class="docutils"/></div></div></div></body></html>