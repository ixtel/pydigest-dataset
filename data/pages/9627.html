<html><body><div><div class="entry-content">
<footer class="post-info">
        <span>Thu 14 January 2016</span>

</footer>      <p>SVG support is coming in the 2.2 release of KivEnt. This post will cover how 
SVG rendering is handled in Kivy and KivEnt and the basics of turning your
SVG files into usable game data in KivEnt. </p>
<p><strong>Everything discussed in this article is currently available in KivEnt's
<a href="https://github.com/kivy/kivent/tree/2.2-dev">2.2-dev branch</a>.
If you are interested in the example code in this article: it is based on two
KivEnt Examples: 
<a href="https://github.com/kivy/kivent/tree/2.2-dev/examples/11_svg_demo">Example 11</a>
for SVG handling
<a href="https://github.com/kivy/kivent/tree/2.2-dev/examples/12_drawing_shapes">Example 12</a>
for the basic shape construction sections. </strong></p>
<p>Most SVG Rendering is done by a CPU-based algorithm which uses
mathematical techniques to calculate the various elements of an SVG drawing. 
However, if we want to benefit from GPU-hardware acceleration for our 
rendering, we have to convert this to an approach that matches the way
the GPU thinks about graphics: triangles. Everything displayed on screen,
from a humble sprite which is 2 triangles forming a rectangle
to complex 3d models, they are all made of a group of triangles. There
are various ways to triangulate any given shape, and having a solution
that accurately triangulates all of the mathematical curves supported by the
SVG spec is necessary to support the full format. This GPU based approach will
introduce a new factor in calculating our image, we must now rely on the 
hardware color blending between vertices in our geometry. This produces
some noticeable differences in the resulting renders.</p>
<h1>GPU Rendering versus CPU Rendering</h1>
<p>Kivy added experimental support for the SVG format last year, but we still 
have had some rendering errors with more complicated SVG files such as the
Ghostscript tiger. This is what the tiger looks like with Kivy's current 
SVG implementation:</p>
<p><img alt="Kivy Rendering" src="http://chaosbuffalogames.com/images/Kivy-TigerSVG.png" title="Kivy rendering"/></p>
<p>This is what the Ghostscript tiger looks like in KivEnt:</p>
<p><img alt="KivEnt Rendering" src="http://chaosbuffalogames.com/images/KivEnt-TigerSVG.png" title="Kivent rendering"/></p>
<p>There are still a few rendering errors, the eyes are not quite right, there is
an erroneous stroke being rendered over the left side of the right eye. The
tongue is also missing the lower dark pink stroke. I hope to solve some of the
remaining discrepencies, although I think some of them might be a result
of relying on GPU color blending to get the appropriate colorings. Even so, 
KivEnt's implementation is now 98%-99% accurate, and many SVGs come out
looking exactly the same as their CPU rendered equivalents. Aliasing will
probably always be slightly different, and in general the whole point of 
GPU based graphics is to sacrifice a little bit of perfection for the 
trade-off in performance.</p>
<p>The teeth are a little light compared to Inkscape, but comparable with the
coloring in Chrome. The left whiskers are also slightly wider than Inkscape's
rendering. Here is the same SVG rendered by Inkscape and Chome:</p>
<p>Inkscape:</p>
<p><img alt="InkScape Rendering" src="http://chaosbuffalogames.com/images/Inkscape-TigerSVG.png" title="inkscape rendering"/></p>
<p>Chrome:</p>
<p><img alt="Chrome Rendering" src="http://chaosbuffalogames.com/images/Chrome-TigerSVG.png" title="chrome rendering"/></p>
<p>I hope to backport the fixes I made for KivEnt's rendering to Kivy once I get
the 2.2 release of KivEnt out the door.</p>
<p>If you want to know more about how GPU rendering of SVGs works under the hood,
continue reading. The next few sections will provide a basic introduction to
rendering colored geometry, the tessellation approach to rendering SVGs, and
some discussion of the 'fixes' I applied to improve Kivy's implementation.</p>
<h1>The Basics of Triangulation</h1>
<p>Before we get into the details of SVG rendering, we need to talk a little bit
about how the GPU renders all geometry. The 'basic' unit of geometry for a GPU
is the triangle, every 2d or 3d geometry you see on the screen is broken down
into triangles before being submitted to the GPU. For instance, a sprite is 
actually 2 triangles arranged in a rectangle or a circle could be 30 or more
triangles arranged like the slices of a pizza or pie.</p>
<p>So for a triangle we would place a vertex at each point on the triangle:</p>
<p><img alt="triangle" src="http://chaosbuffalogames.com/images/triangle.png" title="triangle triangulation"/></p>
<p>GL will then blend the color of each of these vertices between each other using
some hardware maths. Let's draw this triangle in KivEnt. First of all,
all of our rendering is going to be done with the ColorPolyRenderer, this
renderer uses a vertex format that looks like:</p>
<table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="k">ctypedef</span> <span class="k">struct</span> <span class="nc">VertexFormat2F4UB</span><span class="p">:</span>
    <span class="n">GLfloat</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span> <span class="n">pos</span>
    <span class="n">GLubyte</span><span class="p">[</span><span class="mf">4</span><span class="p">]</span> <span class="n">v_color</span>
</pre></div>
</td></tr></table>

<p>The name of this format in KivEnt is 'vertex_format_2f4ub'. For those not as
familiar with C, this is basically a 2-tuple of floats for the pos, and a
4-tuple of unsigned bytes (0-255) for the v_color. We avoid using 'color' as a 
attribute name to avoid conflicting with kivy canvas's default 'color' property
that is used by many of the widgets.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_triangle_data</span><span class="p">(</span><span class="n">side_length</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s">'vertices'</span><span class="p">:</span> <span class="p">{</span><span class="mf">0</span><span class="p">:</span> <span class="p">{</span><span class="s">'pos'</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">side_length</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="n">side_length</span><span class="o">/</span><span class="mf">2.</span><span class="p">),</span>
                         <span class="s">'v_color'</span><span class="p">:</span> <span class="p">(</span><span class="mf">255</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">255</span><span class="p">)},</span>
                     <span class="mf">1</span><span class="p">:</span> <span class="p">{</span><span class="s">'pos'</span><span class="p">:</span> <span class="p">(</span><span class="n">side_length</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="n">side_length</span><span class="o">/</span><span class="mf">2.</span><span class="p">),</span>
                         <span class="s">'v_color'</span><span class="p">:</span> <span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="mf">255</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">255</span><span class="p">)},</span>
                     <span class="mf">2</span><span class="p">:</span> <span class="p">{</span><span class="s">'pos'</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">side_length</span><span class="o">/</span><span class="mf">2.</span><span class="p">),</span>
                         <span class="s">'v_color'</span><span class="p">:</span> <span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">255</span><span class="p">,</span> <span class="mf">255</span><span class="p">)},</span>
                    <span class="p">},</span>
        <span class="s">'indices'</span><span class="p">:</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">],</span>
        <span class="s">'vertex_count'</span><span class="p">:</span> <span class="mf">3</span><span class="p">,</span>
        <span class="s">'index_count'</span><span class="p">:</span> <span class="mf">3</span><span class="p">,</span>
        <span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Any model in KivEnt is made up of the same basic data as this triangle here:</p>
<ol>
<li>
<p>Vertices is the actual points your model is made up of, in this case our
model data is made up of 2 values, the 2d position of that vertex in space,
and the rgba color of that vertex. The keys in the vertex dictionary must be
the same as the names of the attributes in the vertex format.</p>
</li>
<li>
<p>Indices is a list of the points in each triangle your model contains. The
points are referenced by the number of their vertex.</p>
</li>
<li>
<p>The vertex count is the number of vertices in your model.</p>
</li>
<li>
<p>The index count is the number of indices in your model.</p>
</li>
</ol>
<p>Now we just need to load the model's data with our ModelManager and then 
create an entity that uses this model.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">draw_triangle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">model_manager</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gameworld</span><span class="o">.</span><span class="n">model_manager</span>
    <span class="n">triangle_data</span> <span class="o">=</span> <span class="n">get_triangle_data</span><span class="p">(</span><span class="mf">150.</span><span class="p">)</span>
    <span class="n">triangle_model</span> <span class="o">=</span> <span class="n">model_manager</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span>
                                        <span class="s">'vertex_format_2f4ub'</span><span class="p">,</span>
                                        <span class="n">triangle_data</span><span class="p">[</span><span class="s">'vertex_count'</span><span class="p">],</span>
                                        <span class="n">triangle_data</span><span class="p">[</span><span class="s">'index_count'</span><span class="p">],</span>
                                        <span class="s">'triangle'</span><span class="p">,</span>
                                        <span class="n">indices</span><span class="o">=</span><span class="n">triangle_data</span><span class="p">[</span><span class="s">'indices'</span><span class="p">],</span>
                                        <span class="n">vertices</span><span class="o">=</span><span class="n">triangle_data</span><span class="p">[</span><span class="s">'vertices'</span><span class="p">]</span>
                                        <span class="p">)</span>
    <span class="n">create_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'position'</span><span class="p">:</span> <span class="p">(</span><span class="mf">250.</span><span class="p">,</span> <span class="mf">250.</span><span class="p">),</span>
        <span class="s">'poly_renderer'</span><span class="p">:</span> <span class="p">{</span><span class="s">'model_key'</span><span class="p">:</span> <span class="n">triangle_model</span><span class="p">},</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gameworld</span><span class="o">.</span><span class="n">init_entity</span><span class="p">(</span><span class="n">create_dict</span><span class="p">,</span> 
                                      <span class="p">[</span><span class="s">'position'</span><span class="p">,</span> <span class="s">'poly_renderer'</span><span class="p">])</span>
</pre></div>
</td></tr></table>

<p>We will see:</p>
<p><img alt="triangle render" src="http://chaosbuffalogames.com/images/triangle-rendered.png" title="triangle render"/></p>
<p>Which you may be familiar with, as this triangle is sort of the 'hello world'
of gpu programming. Take note of the way colors blend between the 3 points,
this is the approach we will take to turn an SVG into a triangulated mesh. 
The SVG will basically become a collection of colored triangles, and we will
rely on GL's color blending to recreate our SVG. </p>
<p>The most basic 2d rendering unit is often the rectangular sprite. Which is
really 2 triangles connected together:</p>
<p><img alt="rectangle 1" src="http://chaosbuffalogames.com/images/rectangle.png" title="rectangle 1 triangulation"/></p>
<p>The triangulation direction is mostly arbitrary, we could also do this one like:</p>
<p><img alt="rectangle 2" src="http://chaosbuffalogames.com/images/rectangle2.png" title="rectangle 2 triangulation"/></p>
<p>However, things will render differently, let's render these 2 variations in KivEnt:</p>
<p>Generating the data for these rectangles in KivEnt looks like:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">#rectangle 1</span>
<span class="k">def</span> <span class="nf">get_rectangle_data</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s">'vertices'</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s">'pos'</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">width</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="n">height</span><span class="o">/</span><span class="mf">2.</span><span class="p">),</span>
                         <span class="s">'v_color'</span><span class="p">:</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)},</span>
                     <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">'pos'</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">width</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">height</span><span class="o">/</span><span class="mf">2.</span><span class="p">),</span>
                         <span class="s">'v_color'</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)},</span>
                     <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s">'pos'</span><span class="p">:</span> <span class="p">(</span><span class="n">width</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">height</span><span class="o">/</span><span class="mf">2.</span><span class="p">),</span>
                         <span class="s">'v_color'</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">)},</span>
                     <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s">'pos'</span><span class="p">:</span> <span class="p">(</span><span class="n">width</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="n">height</span><span class="o">/</span><span class="mf">2.</span><span class="p">),</span>
                         <span class="s">'v_color'</span><span class="p">:</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">)}</span>
                    <span class="p">},</span>
        <span class="s">'indices'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="s">'vertex_count'</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s">'index_count'</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
        <span class="p">}</span>
</pre></div>
</td></tr></table>

<p>and for rectangle 2:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">#rectangle 2</span>
<span class="k">def</span> <span class="nf">get_rectangle_data</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s">'vertices'</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s">'pos'</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">width</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="n">height</span><span class="o">/</span><span class="mf">2.</span><span class="p">),</span>
                         <span class="s">'v_color'</span><span class="p">:</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)},</span>
                     <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">'pos'</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">width</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">height</span><span class="o">/</span><span class="mf">2.</span><span class="p">),</span>
                         <span class="s">'v_color'</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)},</span>
                     <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s">'pos'</span><span class="p">:</span> <span class="p">(</span><span class="n">width</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">height</span><span class="o">/</span><span class="mf">2.</span><span class="p">),</span>
                         <span class="s">'v_color'</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">)},</span>
                     <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s">'pos'</span><span class="p">:</span> <span class="p">(</span><span class="n">width</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="n">height</span><span class="o">/</span><span class="mf">2.</span><span class="p">),</span>
                         <span class="s">'v_color'</span><span class="p">:</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">)}</span>
                    <span class="p">},</span>
        <span class="s">'indices'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="s">'vertex_count'</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s">'index_count'</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
        <span class="p">}</span>
</pre></div>
</td></tr></table>

<p>The actual rendering code is no different from the previous triangle example.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">draw_rectangle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">model_manager</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gameworld</span><span class="o">.</span><span class="n">model_manager</span>
    <span class="n">rectangle_data</span> <span class="o">=</span> <span class="n">get_rectangle_data</span><span class="p">(</span><span class="mf">100.</span><span class="p">,</span> <span class="mf">150.</span><span class="p">)</span>
    <span class="n">rectangle_model</span> <span class="o">=</span> <span class="n">model_manager</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span>
                                        <span class="s">'vertex_format_2f4ub'</span><span class="p">,</span>
                                        <span class="n">rectangle_data</span><span class="p">[</span><span class="s">'vertex_count'</span><span class="p">],</span>
                                        <span class="n">rectangle_data</span><span class="p">[</span><span class="s">'index_count'</span><span class="p">],</span>
                                        <span class="s">'rectangle'</span><span class="p">,</span>
                                        <span class="n">indices</span><span class="o">=</span><span class="n">rectangle_data</span><span class="p">[</span><span class="s">'indices'</span><span class="p">],</span>
                                        <span class="n">vertices</span><span class="o">=</span><span class="n">rectangle_data</span><span class="p">[</span><span class="s">'vertices'</span><span class="p">]</span>
                                        <span class="p">)</span>
    <span class="n">create_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'position'</span><span class="p">:</span> <span class="p">(</span><span class="mf">250.</span><span class="p">,</span> <span class="mf">250.</span><span class="p">),</span>
        <span class="s">'poly_renderer'</span><span class="p">:</span> <span class="p">{</span><span class="s">'model_key'</span><span class="p">:</span> <span class="n">rectangle_model</span><span class="p">},</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gameworld</span><span class="o">.</span><span class="n">init_entity</span><span class="p">(</span><span class="n">create_dict</span><span class="p">,</span> 
                                      <span class="p">[</span><span class="s">'position'</span><span class="p">,</span> <span class="s">'poly_renderer'</span><span class="p">])</span>
</pre></div>
</td></tr></table>

<p>For rectangle 1 we get:</p>
<p><img alt="rectangle 1 rendered" src="http://chaosbuffalogames.com/images/rectangle-rendered.png" title="rectangle 1 rendered"/></p>
<p>For rectangle 2:</p>
<p><img alt="rectangle 2 rendered" src="http://chaosbuffalogames.com/images/rectangle2-rendered.png" title="rectangle 2 rendered"/></p>
<h1>More Advanced Shapes</h1>
<p>Most shapes require significantly more triangles to represent, for instance it
can take at least 32 triangles to create a convincing circle. Rendering a
circle is a bit like the slices of a pizza or pie:</p>
<p><img alt="circle" src="http://chaosbuffalogames.com/images/circle.png" title="circle triangulation"/></p>
<p>However small numbers of edges produce regular polygons, the 8 sides we have
drawn in the above diagram would end up looking like:</p>
<p><img alt="octagon rendered" src="http://chaosbuffalogames.com/images/octagon-rendered.png" title="octagon rendered"/></p>
<p>If we increase the number of sides to 32, we get something that looks much
closer to a circle:</p>
<p><img alt="circle rendered" src="http://chaosbuffalogames.com/images/circle-rendered.png" title="circle rendered"/></p>
<p>All regular polygons use the same algorithm to draw them, let's take a look
at how we generate the data for a regular polygon model:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_regular_polygon</span><span class="p">(</span><span class="n">sides</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">middle_color</span><span class="p">,</span> <span class="n">edge_color</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">sides</span>
    <span class="n">all_verts</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">all_verts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">'pos'</span><span class="p">:</span> <span class="n">pos</span><span class="p">,</span> <span class="s">'v_color'</span><span class="p">:</span> <span class="n">middle_color</span><span class="p">}</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">vert_count</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ind_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ind_ext</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">extend</span> 
    <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sides</span><span class="p">):</span>
        <span class="n">new_pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)),</span> <span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="n">angle</span><span class="p">))]</span>
        <span class="n">all_verts</span><span class="p">[</span><span class="n">vert_count</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">'pos'</span><span class="p">:</span> <span class="n">new_pos</span><span class="p">,</span> <span class="s">'v_color'</span><span class="p">:</span> <span class="n">edge_color</span><span class="p">}</span>
        <span class="n">vert_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">sides</span><span class="p">:</span>
            <span class="n">ind_ext</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind_ext</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ind_count</span> <span class="o">+=</span> <span class="mi">3</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">'indices'</span><span class="p">:</span> <span class="n">indices</span><span class="p">,</span> <span class="s">'vertices'</span><span class="p">:</span> <span class="n">all_verts</span><span class="p">,</span> 
            <span class="s">'vertex_count'</span><span class="p">:</span> <span class="n">vert_count</span><span class="p">,</span> <span class="s">'index_count'</span><span class="p">:</span> <span class="n">ind_count</span><span class="p">}</span>
</pre></div>
</td></tr></table>

<p>The basic idea is that we add a single point at the center of a circle,
and then a number of vertices tracing the circumference equivalent to the
number of sides in our polygon. The entity rendering code will be the same
as the last 2 examples.</p>
<p>A line would be rendered using a triangulation that looks something like this:</p>
<p><img alt="line" src="http://chaosbuffalogames.com/images/line.png" title="line triangulation"/></p>
<p>The approach is sort of similar to how you would integrate a curve, but gets
a bit beyond the scope of hand-writing code to cover every case. Instead, we
will make use of a wonderful revamp of a tool that has been around in the GL
world for awhile: <a href="https://github.com/memononen/libtess2">libtess2</a>.</p>
<h1>Tessellating Geometry</h1>
<p>The basic approach to rendering an SVG is to take the original points described
by the various mathematical elements, feed them into libtess2, take the
resulting data and format it appropriately for display in the KivEnt library.</p>
<p>SVG elements are XML data that looks something like this:</p>
<table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="nt">&lt;svg</span> <span class="na">id=</span><span class="s">"path6"</span> <span class="na">fill=</span><span class="s">"#FFFFFF"</span> <span class="na">stroke=</span><span class="s">"#000000"</span> <span class="na">stroke-width=</span><span class="s">"0.172"</span> 
<span class="na">d=</span><span class="s">"M58.599,224.09c0,0,0.086,1.619-0.618,1.603</span>
<span class="s">    c-0.704-0.017-14.764-41.095-32.304-39.179C25.677,186.514,40.872,180.231,58.599,224.09z"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;path</span> <span class="na">id=</span><span class="s">"path10"</span> <span class="na">fill=</span><span class="s">"#FFFFFF"</span> <span class="na">stroke=</span><span class="s">"#000000"</span> <span class="na">stroke-width=</span><span class="s">"0.172"</span> 
<span class="na">d=</span><span class="s">"M61.616,221.508c0,0-0.471,1.551-1.126,1.296</span>
<span class="s">    c-0.656-0.255,0.099-43.667-17.049-47.833C43.442,174.972,59.867,174.233,61.616,221.508z"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;path</span> <span class="na">id=</span><span class="s">"path14"</span> <span class="na">fill=</span><span class="s">"#FFFFFF"</span> <span class="na">stroke=</span><span class="s">"#000000"</span> <span class="na">stroke-width=</span><span class="s">"0.172"</span> 
<span class="na">d=</span><span class="s">"M85.105,257.676c0,0,1.398,0.82,0.997,1.399</span>
<span class="s">    c-0.402,0.578-42.421-10.36-50.5,5.324C35.602,264.399,38.745,248.262,85.105,257.676z"</span><span class="nt">/&gt;</span>
</pre></div>
</td></tr></table>

<p>Which is basically a data dump of a variety of information, 'fill' is the 
color of the interior portion of the curve, 'stroke' the color of the outline,
'stroke-width' the size of the outline, and then the other data carries information
about types of curves and the location of the points on them.</p>
<p>From this data a list of points would be generated forming the outline of the
shape, then we would add extra vertices into the interior of the shape so
that they can hold the information about the color gradient:</p>
<p><img alt="tessellating circle" src="http://chaosbuffalogames.com/images/tesselated-circle.png" title="tessellating circle"/></p>
<p>You can then color these vertices to achieve a variety of smooth effects,
you can see some examples of this technique in the planets in this video, which
are all tessellated circles. In this case, the color of each vertex has been
chosen by noise equations in order to generate smooth transitions between
the colors.</p>
<iframe src="https://www.youtube.com/embed/qe9fWC-2e3M" frameborder="0" allowfullscreen="">VIDEO</iframe>

<p>So for each element of the SVG file, we get a little tessellated piece of geometry
with correct colors for the gradients and so on. We draw each element in the order
it is declared in the SVG spec and we get a vertex model representing our SVG.
This can frequently add up to a very large number of vertices and models. For
instance, the tiger that started off this blog post is 239 different models 
combined together for a total of 117,694 vertices. With the same amount of
vertices we could represent 29,423 sprites!</p>
<h1>Converting the Tessellation</h1>
<p>The output of libtess2 is our geometry in a format known as GL_TRIANGLE_STRIP,
the definition of this format is given by the GL programming guide:</p>
<table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre>GL_TRIANGLE_STRIP

Every group of 3 adjacent vertices forms a triangle. The face direction of
the strip is determined by the winding of the first triangle. Each
successive triangle will have its effective face order reversed, so the
system compensates for that by testing it in the opposite way. A vertex
stream of n length will generate n-2 triangles.
</pre></div>
</td></tr></table>

<p>Pretty complex sounding, let's illustrate what GL is going on about:</p>
<p>A rectangle would be drawn with vertices:</p>
<p><img alt="labeled rectangle" src="http://chaosbuffalogames.com/images/lettered-rectangle.png" title="labeled rectangle"/></p>
<p>The vertices list for this rectangle would look like A,B,C,D and the index
list would be the same, A,B,C,D. GL would then follow the rules for parsing 
GL_TRIANGLE_STRIP data and create triangles: ABC, CBD</p>
<p>A slightly more complex example, let us revisit the line triangulation:</p>
<p><img alt="labeled line" src="http://chaosbuffalogames.com/images/lettered-line.png" title="labeled line"/></p>
<p>Vertices would be passed in as: A,B,C,D,E,F,G,H,I,J,K,L,M,N</p>
<p>Indices would look the same but be parsed into:</p>
<p>ABC, CBD, CDE, EDF, EFG, GFH, GHI, IHJ, IJK, KJL, KLM, MLN</p>
<p>However, we do not want to use GL_TRIANGLE_STRIP because it adds complications
related to the way KivEnt's rendering works. KivEnt renders everything using
GL_TRIANGLES which involves explicitly declaring your vertices and the triangles
that make them up. This allows KivEnt to automatically add models together so
that you don't have to worry about handling efficient submission of your data
for each entity, however if we add 2 triangle strip meshes together without 
modification we will end up with some weird geometry as the implicit
triangulation attempts to join the end of one and the beginning of the next.
We could add some non-sensical triangles to the end of one model before joining 
the next, something like the 'triangle': NNN to the end of the line above, 
accomplished by adding the last vertex an extra 2 times. This would let GL know
to not render that particular element, however there are many benefits to
working with GL_TRIANGLES, and it is often the most optimized method of
rendering given its flexibility. </p>
<p>There was a time when concerns about geometry
size resulted in people using solutions such as GL_TRIANGLE_STRIP which better
compress their data, but nowadays it is not the size of the data that matters
as much as what we are doing with it. Even mobile GPUS are capable of handling
millions of vertices so inflating the data related to this a bit when we are
still only dealing with 10s of thousands of vertices is no big deal.</p>
<h2>So how do we convert from GL_TRIANGLE_STRIP to GL_TRIANGLES?</h2>
<p>We do the equivalent of the description above where I turned the vertex list
into a list of triangles, remembering to swap every other one (following the
GL spec). Python code to do this looks like:</p>
<table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre>    <span class="n">new_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">indices</span>
    <span class="n">index_count</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">index_count</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index_count</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">element</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">new_indices</span>
</pre></div>
</td></tr></table>

<p>Pretty simple conversion, and now we have model data that is ready to be used
in KivEnt. The next section will describe how we can take the various elements
that come out of a SVG and combine them for efficiency or parse them based on
some metadata in order to create individual elements out of a part of the SVG
depending on your game logic needs.</p>
<h1>Parsing the SVG</h1>
<p>With the amount of data contained in many SVG files, it is likely that you will
want to process the resulting element models into a more manageable
configuration. At the very least, we will typically want to combine models
into as large of a grouping as possible. With OpenGL ES2, we use unsigned
shorts to hold the index information, which means that ultimately we can
provide no more than 65,535 vertices at once or our integer will overflow
and we will be rendering crazy triangles. KivEnt's SVG loading has been
designed as a 2 step process so that you can customize your final data.</p>
<p>A simple example of the process:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">load_svg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c">#First use ModelManager to load the svg file.</span>
    <span class="n">model_manager</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gameworld</span><span class="o">.</span><span class="n">model_manager</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">model_manager</span><span class="o">.</span><span class="n">get_model_info_for_svg</span><span class="p">(</span><span class="s">"tiger.svg"</span><span class="p">)</span>

    <span class="c">#We are going to need these 2 functions later.</span>
    <span class="n">load_model_from_model_info</span> <span class="o">=</span> <span class="n">model_manager</span><span class="o">.</span><span class="n">load_model_from_model_info</span>
    <span class="n">init_entity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gameworld</span><span class="o">.</span><span class="n">init_entity</span>

    <span class="c">#'model_info' is the SVGModelInfo objects that contain information</span>
    <span class="c">#about a specific element.</span>
    <span class="c">#'svg_name' is needed later, to make sure all elements are loaded</span>
    <span class="c">#under the correct asset.</span>
    <span class="n">model_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'model_info'</span><span class="p">]</span>
    <span class="n">svg_name</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'svg_name'</span><span class="p">]</span>

    <span class="c">#This is a cool new feature in 2.2, we are going to copy one</span>
    <span class="c">#entities component.</span>
    <span class="n">entity_to_copy</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c">#This function will combine our elements into as few models as possible</span>
    <span class="n">final_infos</span> <span class="o">=</span> <span class="n">model_manager</span><span class="o">.</span><span class="n">combine_model_infos</span><span class="p">(</span><span class="n">model_data</span><span class="p">)</span>
    <span class="c">#Retrieve the bounding box and center information for all vertices.</span>
    <span class="n">svg_bounds</span> <span class="o">=</span> <span class="n">model_manager</span><span class="o">.</span><span class="n">get_center_and_bbox_from_infos</span><span class="p">(</span><span class="n">final_infos</span><span class="p">)</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">svg_bounds</span><span class="p">[</span><span class="s">'center'</span><span class="p">]</span>
    <span class="c">#We are going to move each model by the negative of the center, so </span>
    <span class="c">#that the model is centered around 0,0 and adding the entity's position</span>
    <span class="c">#results in the expected location in worldspace.</span>
    <span class="n">neg_center</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="c">#we need to make an entity for each info in the infos</span>
    <span class="c">#all entities after the first are going to copy the first's</span>
    <span class="c">#position component.</span>
    <span class="k">for</span> <span class="n">model_info</span> <span class="ow">in</span> <span class="n">final_infos</span><span class="p">:</span>
        <span class="c">#retrieve the actual tag for the model asset</span>
        <span class="n">model_name</span> <span class="o">=</span> <span class="n">load_model_from_model_info</span><span class="p">(</span><span class="n">model_info</span><span class="p">,</span> <span class="n">svg_name</span><span class="p">)</span>
        <span class="c">#Get the model, and shift all vertices by </span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">model_manager</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span>
        <span class="n">model</span><span class="o">.</span><span class="n">add_all_vertex_attribute</span><span class="p">(</span><span class="s">'pos'</span><span class="p">,</span> <span class="n">neg_center</span><span class="p">)</span>
        <span class="c">#make the entity.</span>
        <span class="n">create_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">'position'</span><span class="p">:</span> <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">),</span>
            <span class="s">'poly_renderer'</span><span class="p">:</span> <span class="p">{</span><span class="s">'model_key'</span><span class="p">:</span> <span class="n">model_name</span><span class="p">},</span>
        <span class="p">}</span>
        <span class="c">#If we are not the first entity, copy that entities position comp.</span>
        <span class="k">if</span> <span class="n">entity_to_copy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">create_dict</span><span class="p">[</span><span class="s">'position'</span><span class="p">]</span> <span class="o">=</span> <span class="n">entity_to_copy</span>
        <span class="n">ent</span> <span class="o">=</span> <span class="n">init_entity</span><span class="p">(</span><span class="n">create_dict</span><span class="p">,</span> <span class="p">[</span><span class="s">'position'</span><span class="p">,</span> <span class="s">'poly_renderer'</span><span class="p">])</span>
        <span class="c">#if we are the first entity, set this entity for copying.</span>
        <span class="k">if</span> <span class="n">entity_to_copy</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">entity_to_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gameworld</span><span class="o">.</span><span class="n">entities</span><span class="p">[</span><span class="n">ent</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<p>To handle the problem of rendering a model that will require multiple Entity's
to hold its data I have introduced a new feature to KivEnt on display here:
It is now possible to have one entity copy anothers component, meaning instead
of actually creating its own component it just uses the other entity's
component. There are a few caveats such as don't destroy the parent entity
before the child entity if you do not want unexpected behavior, but for the
most part the bookkeeping is already automated. You do this by just providing
an Entity object as the create argument in the init_entity call, this will
copy just that component of that entity to your new entity. This can help you
get around those times when the 1 to 1 nature of entities to components seems
to be difficult to get around, such as trying to display multiple models in the
same renderer as we are doing here. Now we can just move the first entity
created and the others will follow along automatically. Just remember to 
cleanup all your created entities when the time is appropriate.</p>
<p>In many cases you may just want to load all of the SVG as one entity, but other
times you may actually want to parse some of the meta information associated
with your SVG elements. KivEnt's SVG loading currently preserves 4 of the 
SVG metadata tags: 'description', 'title', 'label', and 'id', where it is
stored as 'element_id'. You can parse this information as you please
when created your lists for the combine_model_info and
load_model_From_model_info calls.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">parse_model_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="n">model_manager</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gameworld</span><span class="o">.</span><span class="n">model_manager</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">model_manager</span><span class="o">.</span><span class="n">get_model_info_for_svg</span><span class="p">(</span><span class="s">"tiger.svg"</span><span class="p">)</span>
<span class="n">model_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'model_info'</span><span class="p">]</span>
<span class="k">for</span> <span class="n">model_info</span> <span class="ow">in</span> <span class="n">model_data</span><span class="p">:</span>
    <span class="n">element_id</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">element_id</span>
    <span class="n">label</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">label</span>
    <span class="n">description</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">description</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">description</span>
    <span class="c">#Do your custom grouping here</span>

<span class="c">#load entities as above for each of your model_info groups you created.</span>
</pre></div>
</td></tr></table>

<p>The SVG spec is large and we still don't have all of it yet, so please let me
know if there is some part of the specification you would use in your game
that I am leaving out.</p>
    </div>

  </div></body></html>