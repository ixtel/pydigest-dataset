<html><body><div><p class="date">Posted on 2014-04-04, last modified 2014-04-09.</p>
<div class="document">



<div class="section" id="id1">
<span id="names-values"/>
<p>First, what does <tt class="docutils literal">foo</tt> do?</p>
<p>Better question: how can we make <tt class="docutils literal">foo</tt> do something we want?</p>
</div>
<div class="section" id="simple-assignment">
<h1>1.1. Simple assignment</h1>
<p>Before assigment accessing a name produces a NameError.</p>

<pre class="literal-block">
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
/home/ian/git/bar_foo/&lt;ipython-input-1-d3b07384d113&gt; in &lt;module&gt;()
----&gt; 1 foo

NameError: name 'foo' is not defined
</pre>
<p>Let's fix the error with a simple assignment statement.</p>

<pre class="literal-block">
'tesla'
</pre>
<p>As expected the value we assigned is now available when using the name. To return to our original state we can unbind the name using del.</p>

<pre class="literal-block">
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
/home/ian/git/bar_foo/&lt;ipython-input-137-16af1079f68c&gt; in &lt;module&gt;()
      1 del foo
----&gt; 2 foo

NameError: name 'foo' is not defined
</pre>
</div>
<div class="section" id="def">
<h1>1.2. <tt class="docutils literal">def</tt></h1>
<p>Python includes many assignment statements. The next most common is used when defining functions.</p>

<pre class="literal-block">
&lt;function __main__.foo&gt;
</pre>
<p>A function object was created and assigned to a name with the def keyword. This function object is just like any other value in Python. It can be assigned to another name with a simple assignment statement. This new name now works identically to the original.</p>

<pre class="literal-block">
42
</pre>
<p>We can verify that the two values are the exact same object.</p>

<pre class="literal-block">
True
</pre>
</div>
<div class="section" id="class">
<h1>1.3. <tt class="docutils literal">class</tt></h1>
<p>Class creation in python assigns a class to a name.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">Foo</span>
</pre></div>
<pre class="literal-block">
__main__.Foo
</pre>
<p>We used a capitalized name because that is the standard way to name classes in Python code. There is nothing significant about the capitalization but following the standard makes our code easier to understand.</p>
</div>
<div class="section" id="for-in">
<h1>1.4. <tt class="docutils literal"><span class="pre">for..in</span></tt></h1>
<p>For loops bind names that continue to be available outside the for block.
This is often useful when searching for the first object that passes a test.
It is also easy to accidentally override a name defined earlier, so be careful.</p>
<div class="highlight"><pre><span class="k">for</span> <span class="n">foo</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
    <span class="k">pass</span>

<span class="n">foo</span>
</pre></div>
<pre class="literal-block">
3
</pre>
</div>
<div class="section" id="import">
<h1>1.5. <tt class="docutils literal">import</tt></h1>
<p>Importing modules or values from modules binds those modules or values to names.</p>

<pre class="literal-block">
&lt;module 'sys' (built-in)&gt;
</pre>
</div>
<div class="section" id="try-except">
<h1>1.6. <tt class="docutils literal"><span class="pre">try..except</span></tt></h1>
<p>Exception variables are available outside the exception block.
This is rarely useful, but be careful about accidentally overriding existing names.</p>
<div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">foo</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">foo</span>
</pre></div>
<pre class="literal-block">
ZeroDivisionError('integer division or modulo by zero')
</pre>
</div>
<div class="section" id="with">
<h1>1.7. <tt class="docutils literal">with</tt></h1>
<p>Context manager variables are available outside their blocks as well.</p>
<div class="highlight"><pre><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'/tmp/things'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">foo</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">foo</span>
</pre></div>
<pre class="literal-block">
&lt;closed file '/tmp/things', mode 'w' at 0x2ca39c0&gt;
</pre>
</div>
<div class="section" id="decorators">
<h1>1.8. Decorators</h1>
<p>Function and class decorators replace the value assigned by def and class blocks.</p>
<p>This (unusual) example replaces a function with a string.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">serious_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="s">' is much too silly'</span>

<span class="nd">@serious_decorator</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">42</span>

<span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'&lt;function foo at 0x2d68758&gt; is much too silly'
</pre>
</div>
<div class="section" id="evil-ways-to-bind-names">
<h1>1.9. Evil ways to bind names</h1>
<p>There are ways of binding names that should never be used in normal Python programs.</p>
</div>
<div class="section" id="evil-use-of-vars-locals-globals">
<h1>1.9.1. Evil use of <tt class="docutils literal">vars</tt>, <tt class="docutils literal">locals</tt>, <tt class="docutils literal">globals</tt></h1>
<p>Local and global variables may be accessed and assigned through dictionaries
returned by vars, locals or globals. Except for debugging, don't ever do this.</p>
<div class="highlight"><pre><span class="nb">vars</span><span class="p">()[</span><span class="s">'foo'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'tesla'</span>

<span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'tesla'
</pre>
</div>
<div class="section" id="evil-use-of-list-comprehensions-does-not-work-in-python-3">
<h1>1.9.2. Evil use of list comprehensions (does not work in Python 3)</h1>
<p>List comprehensions in Python 2 bind names like for statements.
Be careful about the variable names you choose.
Don't write code that relies on this behavior.</p>
<div class="highlight"><pre><span class="p">[</span><span class="bp">None</span> <span class="k">for</span> <span class="n">foo</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
</pre></div>
<pre class="literal-block">
[None, None, None]
</pre>

<pre class="literal-block">
3
</pre>
</div>
<div class="section" id="evil-stack-frame-manipulation">
<h1>1.9.3. Evil stack frame manipulation</h1>
<p>There are ways of accessing local variables from other stack frames.
Never do this.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">im_in_ur_frame</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="n">frame</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">frame</span><span class="o">.</span><span class="n">f_locals</span><span class="p">[</span><span class="s">'foo'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'writin ur vars'</span>

<span class="n">im_in_ur_frame</span><span class="p">()</span>

<span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'writin ur vars'
</pre>
</div>
<div class="section" id="evil-use-of-import">
<h1>1.9.4. Evil use of <tt class="docutils literal">import</tt></h1>
<p>Possibly worst of all: never import all the names from one module into another.
This can make debugging and even just understanding code extremely difficult.
It can also cause a new name added to that other module to break the module importing it.</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">ismount</span>
</pre></div>
<pre class="literal-block">
&lt;function posixpath.ismount&gt;
</pre>
</div>
<div class="section" id="name-binding-recap">
<h1>1.10. Name binding recap</h1>
<p>We have eight non-evil ways to bind values to names in Python.</p>
<ol class="arabic simple">
<li>assignment with <tt class="docutils literal">=</tt></li>
<li><tt class="docutils literal">def</tt></li>
<li><tt class="docutils literal">class</tt></li>
<li><tt class="docutils literal"><span class="pre">for..in</span></tt></li>
<li><tt class="docutils literal">import</tt></li>
<li><tt class="docutils literal"><span class="pre">try..except</span></tt></li>
<li><tt class="docutils literal">with</tt></li>
<li>function/class decorators</li>
<li>evil</li>
</ol>
</div>
<div class="section" id="id3">
<span id="attributes"/>
<p>Now, how can we make <tt class="docutils literal">bar.foo</tt> do something we want?</p>
</div>
<div class="section" id="builtin-objects-with-attributes">
<h1>2.1. Builtin objects with attributes</h1>
<p>Some standard python objects have attributes we can access.
Unfortunately, none are named foo.</p>

<pre class="literal-block">
3.0
</pre>
<div class="highlight"><pre><span class="n">bar</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"/tmp/things"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">)</span>

<span class="n">bar</span><span class="o">.</span><span class="n">closed</span>
</pre></div>
<pre class="literal-block">
False
</pre>

</div>
<div class="section" id="collections-namedtuple">
<h1>2.2. <tt class="docutils literal">collections.namedtuple</tt></h1>
<p>The simplest choice for an object with a custom attribute is namedtuple.
These objects are immutable, so they make it easier to reason about
code. You can always pass them safely to other functions without worrying
about them being modified. They also work well in with asynchronous and threaded
programming.</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="n">Hotel</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Hotel'</span><span class="p">,</span> <span class="s">'foo baz'</span><span class="p">)</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">Hotel</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="s">'shoe'</span><span class="p">)</span>

<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
42
</pre>

<pre class="literal-block">
Hotel(foo=42, baz='shoe')
</pre>

<pre class="literal-block">
'shoe'
</pre>

<pre class="literal-block">
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
/home/ian/git/bar_foo/&lt;ipython-input-42-463460b3ac05&gt; in &lt;module&gt;()
----&gt; 1 bar.foo = 'tesla'

AttributeError: can't set attribute
</pre>
</div>
<div class="section" id="custom-object-attributes">
<h1>2.3. Custom object attributes</h1>
<p>If you can't use an immutable object like namedtuple, use a normal Python object instead.</p>
</div>
<div class="section" id="assigning-object-attributes-slightly-unusual">
<h1>2.3.1. Assigning object attributes (slightly unusual)</h1>
<p>Simple assignment works with normal python objects. This example is unusual because
it is more common to assign object attributes within a method of the class.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Hotel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">Hotel</span><span class="p">()</span>

<span class="n">bar</span>
</pre></div>
<pre class="literal-block">
&lt;__main__.Hotel at 0x2d8d5d0&gt;
</pre>
<div class="highlight"><pre><span class="n">bar</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s">'tesla'</span>

<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'tesla'
</pre>
</div>
<div class="section" id="assign-attributes-within-a-method">
<h1>2.3.2. Assign attributes within a method</h1>
<p>Assigning attributes during the initialization of an object is a common pattern.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Motel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s">'vespa'</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">Motel</span><span class="p">()</span>

<span class="n">bar</span>
</pre></div>
<pre class="literal-block">
&lt;__main__.Motel at 0x2d9e2d0&gt;
</pre>

<pre class="literal-block">
'vespa'
</pre>
</div>
<div class="section" id="evil-attribute-assignment-with-setattr">
<h1>2.3.3. Evil attribute assignment with <tt class="docutils literal">setattr</tt></h1>
<p>Somewhat like accessing the dictionary of local variables, you can assign to attributes with names given as strings.</p>
<p>This is rarely a good idea. If you need an object with arbitrary keys it's better to use a dictionary.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Martini</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">Martini</span><span class="p">()</span>

<span class="nb">setattr</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="s">'foo'</span><span class="p">,</span> <span class="s">'twenty bucks'</span><span class="p">)</span>

<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'twenty bucks'
</pre>
</div>
<div class="section" id="evil-attribute-assignment-via-dict">
<h1>2.3.4. Evil attribute assignment via <tt class="docutils literal">__dict__</tt></h1>
<p>Accessing __dict__ to set attributes is a bad idea for the same reasons.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Hangout</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">Hangout</span><span class="p">()</span>

<span class="n">bar</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">'foo'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'hipster'</span>

<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'hipster'
</pre>

<pre class="literal-block">
{'foo': 'hipster'}
</pre>
</div>
<div class="section" id="class-attributes">
<h1>2.4. Class attributes</h1>
<p>Python classes are objects too</p>
</div>
<div class="section" id="assigning-class-attributes-monkey-patch">
<h1>2.4.1. Assigning class attributes (monkey patch)</h1>
<p>Simple assignment to python classes can be used to change the behavior of a class
and all its instances. This should be done with extreme care as it can lead to
problems that are very hard to debug.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">Bar</span>
</pre></div>
<pre class="literal-block">
__main__.Bar
</pre>
<div class="highlight"><pre><span class="n">Bar</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s">'Blanche de Chambly'</span>

<span class="n">Bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'Blanche de Chambly'
</pre>
</div>
<div class="section" id="assign-within-the-class-definition">
<h1>2.4.2. Assign within the class definition</h1>
<p>Simple assignment to names within the class definition is one of the normal ways
to create class attributes.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="s">'Porter Baltique'</span>

<span class="n">Bar</span>
</pre></div>
<pre class="literal-block">
__main__.Bar
</pre>

<pre class="literal-block">
'Porter Baltique'
</pre>
</div>
<div class="section" id="object-attributes-class-attributes">
<h1>2.4.3. Object attributes &gt; class attributes</h1>
<p>When accessing attributes of an object the object attribute hides the class attribute.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Club</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">Club</span><span class="p">()</span>

<span class="n">bar</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s">'techno'</span>
<span class="n">Club</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s">'chocololate'</span>

<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'techno'
</pre>

<pre class="literal-block">
'chocololate'
</pre>
</div>
<div class="section" id="evil-class-assignment-with-setattr">
<h1>2.4.4. Evil class assignment with <tt class="docutils literal">setattr</tt></h1>
<p>We can use setattr to assign class attributes, but this will make your program much harder to understand.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Dive</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nb">setattr</span><span class="p">(</span><span class="n">Dive</span><span class="p">,</span> <span class="s">'foo'</span><span class="p">,</span> <span class="s">'rusty nail'</span><span class="p">)</span>

<span class="n">Dive</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'rusty nail'
</pre>
</div>
<div class="section" id="assignment-of-class-attributes-the-wacky-ways">
<h1>2.4.5. Assignment of class attributes, the wacky ways</h1>
<p>All the other methods of binding a name work within a
class definition as well. This is very strange Python code,
but it does show that the language is consistent, at least.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Bestiary</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">sys</span> <span class="kn">as</span> <span class="nn">mod</span>
    <span class="k">class</span> <span class="nc">Klass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">for</span> <span class="n">looper</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
    <span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'/tmp/wat'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">closedfile</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="n">Bestiary</span><span class="o">.</span><span class="n">mod</span>
</pre></div>
<pre class="literal-block">
&lt;module 'sys' (built-in)&gt;
</pre>

<pre class="literal-block">
__main__.Klass
</pre>

<pre class="literal-block">
3
</pre>

<pre class="literal-block">
ZeroDivisionError('integer division or modulo by zero')
</pre>

<pre class="literal-block">
&lt;closed file '/tmp/wat', mode 'w' at 0x2ca3a50&gt;
</pre>
</div>
<div class="section" id="catch-all-getattr-method">
<h1>2.5. Catch-all <tt class="docutils literal">__getattr__</tt> method</h1>
<p>If we want to provide a value when an attribute name has not been defined we can use __getattr__.
This can be useful for implementing proxies of objects or services. We don't need to list
methods and attributes explicitly, but we do need to handle genuinely missing attributes by raising
AttributeError.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Lounge</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">'foo'</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">'lizard'</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">"</span><span class="si">%r</span><span class="s"> object has no attribute </span><span class="si">%r</span><span class="s">"</span>
            <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">Lounge</span><span class="p">()</span>

<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'lizard'
</pre>

<pre class="literal-block">
False
</pre>
</div>
<div class="section" id="object-attribute-class-attribute-getattr">
<h1>2.5.1. Object attribute &gt; Class attribute &gt; <tt class="docutils literal">__getattr__</tt></h1>
<p>When accessing attributes both existing object and class attributes prevent calls to __getattr__.</p>
<div class="highlight"><pre><span class="n">Lounge</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s">'larry'</span>

<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'larry'
</pre>

<pre class="literal-block">
'lizard'
</pre>
</div>
<div class="section" id="mro-method-attribute-resolution-order">
<h1>2.6. MRO: Method (attribute) resolution order</h1>
<p>Python classes support multiple inheritance. When searching for class attributes the method resolution
order determines which attribute will be used.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Structure</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="k">class</span> <span class="nc">Dancing</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="k">class</span> <span class="nc">Drinking</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="n">Dancing</span><span class="p">,</span> <span class="n">Drinking</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">Bar</span><span class="o">.</span><span class="n">__mro__</span>
</pre></div>
<pre class="literal-block">
(__main__.Bar, __main__.Dancing, __main__.Drinking, __main__.Structure, object)
</pre>
<div class="highlight"><pre><span class="n">Structure</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s">'bricks'</span>
<span class="n">Drinking</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s">'drinks'</span>

<span class="n">Bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'drinks'
</pre>
</div>
<div class="section" id="order-so-far">
<h1>2.7. Order so far</h1>
<ol class="arabic simple">
<li>object attributes</li>
<li>class attributes and non-data descriptors in type's MRO</li>
<li><tt class="docutils literal">__getattr__</tt> in type's MRO</li>
</ol>
</div>
<div class="section" id="run-code-in-response">
<span id="run-code"/>
<p>We can run code in response to attribute access with more precision than a <tt class="docutils literal">__getattr__</tt> method.</p>
</div>
<div class="section" id="methods">
<h1>3.1. Methods</h1>
<p>What about Python methods? There is something going on here:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="n">Bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
&lt;unbound method Bar.foo&gt;
</pre>

<pre class="literal-block">
&lt;bound method Bar.foo of &lt;__main__.Bar object at 0x2d9e550&gt;&gt;
</pre>
</div>
<div class="section" id="methods-a-closer-look-very-unusual-code">
<h1>3.1.1. Methods, a closer look (very unusual code)</h1>
<p>We can get a better idea of what is happening by creating our method outside of the class.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">Bar</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span>

<span class="n">foo</span>
</pre></div>
<pre class="literal-block">
&lt;function __main__.foo&gt;
</pre>

<pre class="literal-block">
&lt;unbound method Bar.foo&gt;
</pre>

<pre class="literal-block">
&lt;bound method Bar.foo of &lt;__main__.Bar object at 0x2d9eed0&gt;&gt;
</pre>
<div class="highlight"><pre><span class="n">foo</span> <span class="ow">is</span> <span class="n">Bar</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">'foo'</span><span class="p">]</span>
</pre></div>
<pre class="literal-block">
True
</pre>
<p>This function is not being modified when it is assigned to the class, but when
we access it as an attribute of an object or class we get a different value.</p>
</div>
<div class="section" id="non-data-descriptors-won-t-be-on-the-test">
<h1>3.2. Non-data descriptors (won't be on the test)</h1>
<p>The descriptor protocol is what makes this happen. We creating a non-data descriptor
(a class with a __get__ method) and assign an instance of this class as an attribute
of a second class. Now our non-data descriptor can decide what is returned when the
attribute of the second class is accessed.</p>
<p>Don't worry if this seems complicated, it's extremely rare to need this feature of Python
in normal programs. This feature exists just to avoid having to make bound methods and the
staticmethod and classmethod decorators a core part of the Python language.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">AboutFoo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span>

<span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="n">AboutFoo</span><span class="p">()</span>

<span class="n">Bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
(None, __main__.Bar)
</pre>

<pre class="literal-block">
(&lt;__main__.Bar at 0x2e05110&gt;, __main__.Bar)
</pre>

<pre class="literal-block">
42
</pre>
</div>
<div class="section" id="property">
<h1>3.3. <tt class="docutils literal">property</tt></h1>
<p>The standard way to execute code in response to an attribute access is to use a property.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">ReadOnly</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_get_foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"accessed foo!"</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">42</span>

    <span class="n">foo</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_foo</span><span class="p">)</span>

<span class="n">ReadOnly</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
&lt;property at 0x2d72f70&gt;
</pre>

<pre class="literal-block">
accessed foo!
42
</pre>

<pre class="literal-block">
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
/home/ian/git/bar_foo/&lt;ipython-input-253-df4128335d67&gt; in &lt;module&gt;()
----&gt; 1 bar.foo = 9

AttributeError: can't set attribute
</pre>
</div>
<div class="section" id="setter">
<h1>3.3.1. Setter</h1>
<p>Properties can define setters as well, so we can implement read/write attribute access
with custom function calls.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">ReadWrite</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_get_foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_foo</span>

    <span class="k">def</span> <span class="nf">_set_foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"just set foo to </span><span class="si">%r</span><span class="s">!"</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_foo</span> <span class="o">=</span> <span class="n">value</span>

    <span class="n">foo</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_foo</span><span class="p">,</span> <span class="n">_set_foo</span><span class="p">)</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">ReadWrite</span><span class="p">()</span>
<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
/home/ian/git/bar_foo/&lt;ipython-input-257-d0aa0af9ef79&gt; in &lt;module&gt;()
     10
     11 bar = ReadWrite()
---&gt; 12 bar.foo

/home/ian/git/bar_foo/&lt;ipython-input-257-d0aa0af9ef79&gt; in _get_foo(self)
      1 class ReadWrite(object):
      2     def _get_foo(self):
----&gt; 3         return self._foo
      4
      5     def _set_foo(self, value):

AttributeError: 'ReadWrite' object has no attribute '_foo'
</pre>

<pre class="literal-block">
just set foo to 9!
</pre>

<pre class="literal-block">
9
</pre>
</div>
<div class="section" id="prettier">
<h1>3.3.2. Prettier?</h1>
<p>If you prefer, getters and setters also may be written as function decorators.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Propertify</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_foo</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nd">@foo.setter</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_foo</span> <span class="o">=</span> <span class="n">value</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">Propertify</span><span class="p">()</span>
<span class="n">bar</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
3
</pre>
</div>
<div class="section" id="overriding-del-for-completeness-i-guess">
<h1>3.3.2. Overriding <tt class="docutils literal">del</tt> (for completeness, I guess)</h1>
<p>If that wasn't enough you can also customize unbinding of attributes.</p>
<p>It's very strange to create an interface that involves unbinding an object's attributes
as part of normal operation, so I suggest you avoid this one.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Oddball</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">excuses</span> <span class="o">=</span> <span class="p">[</span><span class="s">"No"</span><span class="p">,</span> <span class="s">"I refuse"</span><span class="p">,</span> <span class="s">"Go away"</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_del_foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">excuses</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

    <span class="n">foo</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fdel</span><span class="o">=</span><span class="n">_del_foo</span><span class="p">)</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">Oddball</span><span class="p">()</span>
<span class="k">del</span> <span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
No
</pre>

<pre class="literal-block">
I refuse
</pre>

<pre class="literal-block">
Go away
</pre>
</div>
<div class="section" id="data-descriptors-also-not-on-the-test">
<h1>3.4. Data descriptors (also not on the test)</h1>
<p>Properties fall under the descriptor protocol as "data descriptors".
Data descriptors are instances of classes that have __get__ and __set__ methods,
assigned as class attributes of another class.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">ThisIsMyFoo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span>
    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"tried to set </span><span class="si">%r</span><span class="s"> value to </span><span class="si">%r</span><span class="s">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="n">ThisIsMyFoo</span><span class="p">()</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
(&lt;__main__.Bar at 0x2d9efd0&gt;, __main__.Bar)
</pre>

<pre class="literal-block">
tried to set &lt;__main__.Bar object at 0x2d9efd0&gt; value to 42
</pre>
<p><tt class="docutils literal">property</tt> is implemented as a data descriptor.</p>
</div>
<div class="section" id="order-recap">
<h1>3.5. Order recap</h1>
<p>Non-data descriptors are accessed just like class attributes. Data descriptors
take a new position in the priority just before object attributes, although it
is tricky to create an object that has both (we will see how this can be done later).</p>
<ol class="arabic simple">
<li>data descriptors in type's MRO</li>
<li>object attributes</li>
<li>class attributes and non-data descriptors in type's MRO</li>
<li><tt class="docutils literal">__getattr__</tt> in type's MRO</li>
</ol>
</div>
<div class="section" id="id6">
<span id="complete"/>
<p>Occasionally it's useful to have a little more control.</p>
</div>
<div class="section" id="preemptive-getattribute-method">
<h1>4.1. Preemptive <tt class="docutils literal">__getattribute__</tt> method</h1>
<p>Most of the attribute access logic, including all the special descriptor behavior is implemented in
object.__getattribute__ and type.__getattribute__ (yes, confusingly similar to <tt class="docutils literal">__getattr__</tt>).</p>
<p>If we override this method we get complete control of what happens when attributes are accessed.
There is no similar method for complete control of assignment and unbinding, though.</p>
<p>Extra care must be taken in __getattribute__ implementation to fall back to the default implementation if
you want your object to behave somewhat normally.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Casino</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">'foo'</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">'rat'</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">Casino</span><span class="p">()</span>
<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'rat'
</pre>
<div class="highlight"><pre><span class="n">bar</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s">'mouse'</span>
<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'rat'
</pre>
</div>
<div class="section" id="pypy-s-transparent-proxy">
<h1>4.2. PyPy's transparent proxy</h1>
<p>In PyPy we can go even further. We can catch and modify every read/write/delete to an object attribute with a transparent proxy.</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">tputil</span> <span class="kn">import</span> <span class="n">make_proxy</span>

<span class="n">history</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">def</span> <span class="nf">recorder</span><span class="p">(</span><span class="n">operation</span><span class="p">):</span>
    <span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">delegate</span><span class="p">()</span>

<span class="n">o</span> <span class="o">=</span> <span class="n">make_proxy</span><span class="p">(</span><span class="n">recorder</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="p">[])</span>
</pre></div>
<p>This proxy appears as the exact same type as the original object but every operation may be intercepted and potentially modified.</p>
</div>
<div class="section" id="final-order">
<h1>4.3. Final order</h1>
<ol class="arabic simple">
<li>PyPy transparent proxy</li>
<li><tt class="docutils literal">__getattribute__</tt> in type's MRO</li>
<li>data descriptors in type's MRO</li>
<li>object attributes</li>
<li>class attributes and non-data descriptors in type's MRO</li>
<li><tt class="docutils literal">__getattr__</tt> in type's MRO</li>
</ol>
</div>
<div class="section" id="all-the-foo">
<h1>4.4. All the <tt class="docutils literal">foo</tt></h1>
<p>We can test the attribute access order with a custom class, and one parent to stand in for the method resolution order.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">'foo'</span><span class="p">:</span> <span class="k">return</span> <span class="s">'Second'</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span><span class="s">'Fourth'</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">'foo'</span><span class="p">:</span> <span class="k">return</span> <span class="s">'Ninth'</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">"</span><span class="si">%r</span><span class="s"> object has no attribute </span><span class="si">%r</span><span class="s">"</span>
            <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">'foo'</span><span class="p">:</span> <span class="k">return</span> <span class="s">'First'</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span><span class="s">'Third'</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">'foo'</span><span class="p">:</span> <span class="k">return</span> <span class="s">'Eighth'</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">"</span><span class="si">%r</span><span class="s"> object has no attribute </span><span class="si">%r</span><span class="s">"</span>
            <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
</pre></div>
<p>We can create an object attribute with the same name as a data descriptor by sneaking past to the object's __dict__.</p>
<p>The first and second values come from __getattribute__ methods in the child and parent classes.</p>
<div class="highlight"><pre><span class="n">bar</span> <span class="o">=</span> <span class="n">Child</span><span class="p">()</span>
<span class="n">bar</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">'foo'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'Fifth'</span>

<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'First'
</pre>
<div class="highlight"><pre><span class="k">del</span> <span class="n">Child</span><span class="o">.</span><span class="n">__getattribute__</span>
<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'Second'
</pre>
<p>The third and fourth values come from the child and parent class properties (data descriptors).</p>
<div class="highlight"><pre><span class="k">del</span> <span class="n">Parent</span><span class="o">.</span><span class="n">__getattribute__</span>
<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'Third'
</pre>

<pre class="literal-block">
'Fourth'
</pre>
<p>The fifth value is the object attribute.</p>

<pre class="literal-block">
'Fifth'
</pre>
<p>We can now create class attributes with the same names as the class properties, but these do not
override the object attribute value.</p>
<div class="highlight"><pre><span class="n">Child</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s">'Sixth'</span>
<span class="n">Parent</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s">'Seventh'</span>
<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'Fifth'
</pre>
<p>The sixth and seventh values are the class attributes in the child and parent classes.</p>

<pre class="literal-block">
'Sixth'
</pre>

<pre class="literal-block">
'Seventh'
</pre>
<p>Finally we reach the values returned from the child and parent __getattr__ methods.</p>

<pre class="literal-block">
'Eighth'
</pre>
<div class="highlight"><pre><span class="k">del</span> <span class="n">Child</span><span class="o">.</span><span class="n">__getattr__</span>
<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
'Ninth'
</pre>
</div>
<div class="section" id="id8">
<span id="terrible"/>
<p>There are some... other... ways of setting bar.foo.</p>
</div>

<div class="section" id="gc-evil">
<h1>5.2. <tt class="docutils literal">gc</tt> Evil</h1>
<p>For objects that are reference counted (does not include small integers and strings)
we can use the gc module to find and modify references, changing values globally.</p>
<p>Possibly useful for debugging. Never use in production code.</p>
<div class="highlight"><pre><span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="s">'not a string'</span><span class="p">,)</span>

<span class="k">class</span> <span class="nc">Thing</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">Thing</span><span class="p">()</span>
<span class="n">baz</span> <span class="o">=</span> <span class="n">Thing</span><span class="p">()</span>
<span class="n">bar</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="n">target</span>
<span class="n">baz</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="n">target</span>

<span class="kn">import</span> <span class="nn">gc</span>
<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">gc</span><span class="o">.</span><span class="n">get_referrers</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">86</span>

<span class="n">bar</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
<pre class="literal-block">
86
</pre>

<pre class="literal-block">
86
</pre>

<pre class="literal-block">
86
</pre>
</div>
<div class="section" id="bytecode-evil">
<h1>5.3. Bytecode Evil</h1>
<p>It is difficult but possible to modify python code objects themselves after they have
been created.</p>
<p>This is a terrible idea, of course.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="s">'steak'</span>
    <span class="n">baz</span> <span class="o">=</span> <span class="s">'pogo'</span>

<span class="k">def</span> <span class="nf">i_think_you_meant_baz</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">marshal</span>
    <span class="n">code</span> <span class="o">=</span> <span class="n">marshal</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">func_code</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">func_code</span> <span class="o">=</span> <span class="n">marshal</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">code</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">'foo'</span><span class="p">,</span> <span class="s">'baz'</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">f</span>

<span class="nd">@i_think_you_meant_baz</span>
<span class="k">def</span> <span class="nf">dinner</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">Bar</span><span class="o">.</span><span class="n">foo</span><span class="p">)</span>

<span class="n">dinner</span><span class="p">()</span>
</pre></div>
<pre class="literal-block">
pogo
</pre>
</div>
<div class="section" id="id10">
<span id="coping"/>
<p>We have seen that in Python attribute access can become very complicated.
Here are some suggestions to reduce the complexity of your code.</p>
<ol class="arabic simple">
<li>Don't over-use classes (<tt class="docutils literal">namedtuple</tt> is quite nice!)</li>
<li>When you use classes, don't use inheritance</li>
<li>When you use inheritance, don't nest deeply</li>
<li>Use <tt class="docutils literal">__getattr__</tt> only if it removes lots of duplication</li>
<li>Don't use <tt class="docutils literal">__getattribute__</tt>, you probably don't need it</li>
<li>Use metaclasses only when the result is awesome</li>
<li>Use <tt class="docutils literal">gc</tt> only for debugging</li>
<li>Never mess with bytecode</li>
</ol>
</div>
</div>
</div></body></html>