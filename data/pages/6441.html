<html><body><div><article class="main">
<h2>
<a href="/blog/">«</a>
Tuple Unpacking Oddness
</h2><p class="floatright">
<small><a href="/blog/author/Aleksa%20Sarai">Aleksa Sarai</a></small>
</p>
<p>
</p><p class="floatleft">
<a href="/blog/tag/programming"><code>programming</code></a>
<a href="/blog/tag/python"><code>python</code></a>
</p>
<p class="floatright">
<small>01 September 2015</small>
</p>
<br/>


<p>I just wanted to start out by saying that I’m not entirely sure what the
standards people where smoking when they stated that the following is entirely
expected behaviour. I also want to thank my fellow tutors for helping me get to
grips with what is going on here.</p>
<h3 id="the-code">The Code</h3>
<p>The code in question looks pretty innocuous:</p>
<pre><code class="language-python">a = "a"
b = "b"
L = [a, b]

# Here it comes ...
L[L.index(a)], L[L.index(b)] = b, a
</code></pre>
<p>Now, what do you expect the above code to do? I personally would expect (with my
experiences with tuple unpacking) that <code>L</code> would be <code>[b, a]</code>. However, it seems
that Python has other ideas:</p>
<pre><code class="language-python">&gt;&gt;&gt; # Insert code from above.
&gt;&gt;&gt; L == [b, a]
False
&gt;&gt;&gt; L == [a, b]
True
</code></pre>
<p>… Wait, what? So not only didn’t it do what we’d expect (that the values would
be switched), but in addition it didn’t even affect the list? Even though
clearly the first portion of the tuple simply <strong>must</strong> modify the list, right?</p>
<p>However, if we switch the order of the list, we see what we’d expect:</p>
<pre><code class="language-python">&gt;&gt;&gt; L = [b, a]
&gt;&gt;&gt; L[L.index(a)], L[L.index(b)] = b, a
&gt;&gt;&gt; L == [b, a]
False
&gt;&gt;&gt; L == [a, b]
True
</code></pre>
<p>So what the hell is going on here? It looks like the list is always going to end
up being <code>[a, b]</code> using this method. There’s clearly something fishy going on
here.</p>
<h3 id="cant-touch-dis1">Can’t Touch <strong><code>dis</code></strong><sup>1</sup></h3>
<p>So, after staring at the code for ten minutes or so (and some very generous help
from my fellow tutors) we nailed what the problem was. First we busted out <code>dis</code>
to see what CPython was <strong>actually</strong> executing and <em>in what order</em>.</p>
<pre><code class="language-python">&gt;&gt;&gt; # Insert the code from above in a function called `func`.
&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(func)
# SNIP: Setup instructions.
  7          24 LOAD_FAST                1 (b)
             27 LOAD_FAST                0 (a)
             30 ROT_TWO
             31 LOAD_FAST                2 (L)
             34 LOAD_FAST                2 (L)
             37 LOAD_ATTR                0 (index)
             40 LOAD_FAST                0 (a)
             43 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             46 STORE_SUBSCR
             47 LOAD_FAST                2 (L)
             50 LOAD_FAST                2 (L)
             53 LOAD_ATTR                0 (index)
             56 LOAD_FAST                1 (b)
             59 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             62 STORE_SUBSCR
# SNIP: Return instructions.
</code></pre>
<p>The key points here are the positions of the <code>STORE_SUBSCR</code> instructions in
relation to the calls to <code>.index</code>. As you can see, Python decides to modify the
list <code>L</code> before evaluating the subscripts. Extracting only the important lines:</p>
<pre><code class="language-python"># SNIP: Loading code.
             43 CALL_FUNCTION            1 (1 positional, 0 keyword pair) # .index(a)
             46 STORE_SUBSCR                                              # b
# SNIP: Loading code.
             59 CALL_FUNCTION            1 (1 positional, 0 keyword pair) # .index(b)
             62 STORE_SUBSCR                                              # a
</code></pre>
<p>So, what CPython has decided to generate is less like this (which is what we
might expect):</p>
<pre><code class="language-python"># Temporary variables for the indexes (to ensure "correct" order of operations).
ia = L.index(a)
ib = L.index(b)

# Expanded tuple.
L[ia] = b
L[ib] = a
</code></pre>
<p>And in fact generates something vaguely similar to this:</p>
<pre><code class="language-python">L[L.index(a)] = b
L[L.index(b)] = a
</code></pre>
<p>Which explains why there’s no change! We modify <code>L[0]</code> and then revert it
immediately. This seemed to be (at least in my opinion) a violation of the order
of operations of subscripting and tuple unpacking.</p>
<p><sup><sup><strong>1</strong></sup> I’m sorry, I’m so sorry. I just couldn’t resist.</sup></p>
<h3 id="versions-of-python-affected">Versions of Python Affected</h3>
<p>This appeared to affect the following Python versions and implementations:</p>
<ul>
<li>CPython 3.4.3</li>
<li>CPython 2.7.10</li>
<li>PyPy 2.6.0</li>
</ul>
<p>Which lead me to believe that this probably isn’t some implementation-specific,
hacky bytecode optimisation being done by CPython (which was my first impression
when I was looking at the bytecode <code>dis</code> spat out). It must be documented
<em>somewhere</em>.</p>
<h3 id="the-standard">The Standard</h3>
<p>So, as with all weirdness, in the event of confusion it is best to refer to the
specification. I want to thank <a href="https://vovo.id.au/" target="_blank">David Vo</a> for linking me the relevant
section of the standard (I don’t like trawling through standards docs to find
the one sentence that perfectly defines your situation).</p>
<p>In particular, <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" target="_blank">§7.2</a> states that:</p>
<blockquote>
<p>If the target list is a comma-separated list of targets: […] the items are
assigned, <strong>from left to right</strong>, to the corresponding targets. […]
Assignment of an object to a single target is recursively defined as follows
[…] if the target is a subscription: The primary expression in the reference
is evaluated. It should yield either a mutable sequence object […] <strong>Next,
the subscript expression is evaluated.</strong> [emphasis added]</p>
</blockquote>
<p>And, in fact, it references a very similar example to ours in the docs:</p>
<blockquote>
<p>Although the definition of assignment implies that overlaps between the
left-hand side and the right-hand side are ‘simultanenous’ (for example
<code>a, b = b, a</code> swaps two variables), overlaps within the collection of
assigned-to variables occur left-to-right, sometimes resulting in confusion.</p>
</blockquote>
<p>So, it does seem that this behaviour is very well defined (and is completely
expected). However, it is something to watch out for as it definitely can cause
confusion (as it did me). Panic over.</p>
<p>Happy Pythoning. And remember, there’s no such thing as too much magic.</p>
<small>
</small><p>Unless otherwise stated, all of the opinions in the above post are solely
my own and do not necessary represent the views of anyone else. As such,
this post is released under the <a href="https://creativecommons.org/licenses/by-nd/4.0/">Creative Commons BY-ND 4.0 license</a>.</p>

<small>
</small><p>Want to keep up to date with my posts?</p>
<p>You can subscribe to the <a href="/blog/posts.atom">Atom Feed</a>.</p>


</article>
</div></body></html>