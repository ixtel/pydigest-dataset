<html><body><div><div id="content-container">
	    
	    



<h1>Scaling Python</h1>

<p class="teaser"/>
<p class="originally">Originally published in the <a href="/python-newsletter/">Advanced Python Newsletter</a></p>


<p>Programs don't automatically scale forever. Almost any application
that processes data can start to massively slooooow down, or break, or
even silently corrupt output and miss events. All you have to do is
keep feeding it a thousand times more data. Or a million. Or a
billion. As you keep increasing the size of the input, at some point,
the program will hit internal bottlenecks, and start to
misbehave.
</p>

<p>That's why it's important to invest engineering effort in
making our software scalable: designing applications to
gracefully handle increasing orders of magnitude of input, whatever
that may be. Broadly, there are three different regimes:</p>

<ul>
    <li>Scaling to make the most of the <strong>memory</strong> on the
    machine. Imagine loading the contents of a large CSV file into
    memory before processing. What algorithms and designs will handle
    the largest input size, for a fixed system memory, without paging out?</li>
    <li>Going past the memory capacity on the machine, and making the
    most effective use of <strong>persistent storage</strong>. Like an SQL
    database process running on the server.</li>
    <li>Going past the capabilities of a single machine, to a
    <strong>distributed system</strong> - an application running
    across a cluster of separate servers. Imagine a Fortune 500
    company's ecommerce database - something so massive, even the
    beefiest AWS instance type can't handle it.</li>
</ul>

<p>The first two are about vertically scaling - getting the most you
can out of a single machine - while the last one kicks in once you
hit the physical limits of what's possible on a single server. This
article focuses on the first regime: designing
Python applications to scale as far as possible within available
memory. <a href="/python-newsletter/">Parts two and three</a> will
explore the others.</p>

<p>Modern OSes provide ample virtual memory, which can be many times
the available physical memory. One of the performance bottlenecks
kicks in when a program uses more physical memory than it has
available to it, and the OS moves some of its data to secondary
storage. This is called <em>paging out</em> to disk (or SSD, etc.),
and dramatically harms both responsiveness and overall
performance. For the purposes of this article (part 1), we're focused
on maximizing the amount of data our algorithms can handle, before
paging out becomes necessary. </p>

<h2>Cleverly Culling Collections</h2>

<p>Python sports some rich and powerful data structures for
collections: list, dict, set, and more. As valuable as they are,
overusing them can impede scalability, by making memory become a
bottleneck when it doesn't need to be. Some of these overuses are easy
to spot... and some are not. Look at the following code:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="c"># books.csv holds meta information on a collection of books:</span>
</p></li><li><p class="line"><span class="c"># title, author, pub year, etc.</span>
</p></li><li><p class="line"><span class="c"># load_from_file returns a list of dicts.</span>
</p></li><li><p class="line"><span class="n">books</span> <span class="o">=</span> <span class="n">load_from_file</span><span class="p">(</span><span class="s">'books.csv'</span><span class="p">)</span>
</p></li><li><p class="line"><span class="n">book_summaries</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</p></li><li><p class="line"><span class="k">for</span> <span class="n">book</span> <span class="ow">in</span> <span class="n">books</span><span class="p">:</span>
</p></li><li><p class="line">    <span class="n">book_summaries</span><span class="p">[</span><span class="n">book</span><span class="p">[</span><span class="s">"title"</span><span class="p">]]</span> <span class="o">=</span> <span class="n">book</span><span class="p">[</span><span class="s">"summary"</span><span class="p">]</span>
</p></li><li><p class="line"><span class="k">for</span> <span class="n">title</span><span class="p">,</span> <span class="n">summary</span> <span class="ow">in</span> <span class="n">book_summaries</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</p></li><li><p class="line">    <span class="c"># Do something interesting with the summary.</span>
</p></li><li><p class="line">    <span class="k">print</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">summary</span><span class="p">)</span>
</p></li></ol></pre></div>



<p>After reading book data from the CSV file,
this code constructs a table mapping titles to summaries of the book,
before iterating through that dictionary.
From a memory-usage viewpoint, there is nothing wrong with this if
<code>books.csv</code> contains a few dozen or hundred titles. But
what if it holds the entire inventory of a regional bookstore
chain... with millions of titles? You have either one or three problems,
depending on whether you're using Python 3 or Python 2.</p>

<p>First, you are creating a new data structure called
<code>book_summaries</code>. This is strictly speaking unnecessary,
but does improve readability: when you read the "for" line, you
immediately know the loop is cycling through the summaries. In
general, it's a great idea to create new, well-named variables just to
make code more readable. Because it can boost maintainability, I often
do so myself, and recommend you do as well.</p>

<p>In this case, though, it creates a memory-scalability bottleneck
that is not worth the trade-off. The new data structure contains the
full summary of every book, which is likely to take up more memory
than all the other fields for that book combined. So if
<code>books</code> consumes N bytes of memory, the entire block of
code above will require at least 1.5 * N bytes, and probably closer to
2 * N. This scales better:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="c"># Python 3.</span>
</p></li><li><p class="line"><span class="n">books</span> <span class="o">=</span> <span class="n">load_from_file</span><span class="p">(</span><span class="s">'books.csv'</span><span class="p">)</span>
</p></li><li><p class="line"><span class="k">for</span> <span class="n">book</span> <span class="ow">in</span> <span class="n">books</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</p></li><li><p class="line">    <span class="k">print</span><span class="p">(</span><span class="n">book</span><span class="p">[</span><span class="s">"title"</span><span class="p">],</span> <span class="n">book</span><span class="p">[</span><span class="s">"summary"</span><span class="p">])</span>
</p></li></ol></pre></div>



<p>That's straightforward enough, but sometimes this can be more
subtle. Look at this example:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="c"># load_customer_names returns a list of strings.</span>
</p></li><li><p class="line"><span class="n">customer_names</span> <span class="o">=</span> <span class="n">load_customer_names</span><span class="p">()</span>
</p></li><li><p class="line"><span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">customer_names</span><span class="p">):</span>
</p></li><li><p class="line">    <span class="c"># Do something interesting.</span>
</p></li></ol></pre></div>



<p>Here, <code>sorted(customer_names)</code> creates a new list. If
<code>customer_names</code> takes N bytes of memory, the whole block
of code takes 2*N total. Sometimes this is unavoidable: you really do
need to sort the list. You can still improve the scalability by
sorting in-place instead, if you can tolerate losing the original order:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="n">customer_names</span> <span class="o">=</span> <span class="n">load_customer_names</span><span class="p">()</span>
</p></li><li><p class="line"><span class="n">customer_names</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
</p></li><li><p class="line"><span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">customer_names</span><span class="p">:</span>
</p></li><li><p class="line">    <span class="c"># Now the names are sorted.</span>
</p></li></ol></pre></div>



<p>Sometimes with a little thought, you can even move the sorting or
preprocessing outside the application, to a part of the stack that can
do it better. For example, if the customer names are originally read
from a database, you may be able to do something like "<code>SELECT
name FROM customers AS customer_name ORDER BY name ASC</code>", so
that it's already sorted by the time it gets to your Python code.</p>

<h2>Intelligent Iterating</h2>

<p>Going back to the book example: in Python 2, you have several other
problems. The <code>for</code> line iterates over
<code>book_summaries.items()</code>. In Python 2, the
<code>items()</code> method creates a list of key-value
pairs... effectively creating another copy of
<code>books</code>. Besides using twice the memory, there will be a
performance penalty, causing the program to briefly hang right before
starting the <code>for</code> loop. Can you see why?</p>

<p>The reason is that the call to <code>book_summaries.items()</code>
must allocate and populate a potentially very large list. When Python
executes the bytecode behind the <code>for</code> loop, it starts by
allocating the memory for this list; populating it with the correct
values; and only then starting the first cycle through the loop. This
will be hard to notice or even measure if you know the dictionary will
never have more than a few hundred key-value pairs. But if the size is
unbounded - and it is, more often than you might think - then it
becomes a hidden speed bump.</p>

<p>Again, this only affects Python 2; Python 3's <code>items()</code>
returns something that acts like an iterator, which is both faster and
does not needlessly make a whole extra copy of <code>book's</code>
contents. But you can get the same benefit in Python 2 by using
<code>iteritems</code> instead of <code>items</code>:
</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="c"># In Python 2, use "iteritems" instead of "items".</span>
</p></li><li><p class="line"><span class="n">books</span> <span class="o">=</span> <span class="n">load_from_file</span><span class="p">(</span><span class="s">'books.csv'</span><span class="p">)</span>
</p></li><li><p class="line"><span class="k">for</span> <span class="n">book</span> <span class="ow">in</span> <span class="n">books</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
</p></li><li><p class="line">    <span class="k">print</span><span class="p">(</span><span class="n">book</span><span class="p">[</span><span class="s">"title"</span><span class="p">],</span> <span class="n">book</span><span class="p">[</span><span class="s">"summary"</span><span class="p">])</span>
</p></li></ol></pre></div>



<p>In all Python versions, it's your responsibility to carry this
pattern to other contexts. Be aware of the difference between creating
a list and using an iterator, and design your code for the latter
wherever possible. And when implementing your own code, the easiest
way to do that is by using <em>generators</em>.</p>

<h2>Generating Scalability</h2>

<p>Imagine developing software that takes in free-form text, splitting
into sentences before doing some kind of grammar analysis. Lexically,
each sentence will be split by a period followed by one or more
whitespace characters:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="kn">import</span> <span class="nn">re</span>
</p></li><li><p class="line"><span class="n">text</span> <span class="o">=</span> <span class="s">'''This is a body of text. It has several sentences.</span>
</p></li><li><p class="line"><span class="s">Some are long and some are short.'''</span>
</p></li><li><p class="line"><span class="n">sentences</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">r'\.\s+'</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
</p></li><li><p class="line"><span class="k">for</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="n">sentences</span><span class="p">:</span>
</p></li><li><p class="line">    <span class="k">print</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span>
</p></li></ol></pre></div>



<p>This emits something like:</p>


<div class="highlight"><pre><ol><li><p class="line">This is a body of text
</p></li><li><p class="line">It has several sentences
</p></li><li><p class="line">Some are long and some are short.
</p></li></ol></pre></div>



<p>A little inconsistent on the ending periods, but that seems
minor. There's a bigger problem lurking here, which is similar
to what we saw above. The input size,
so to speak, is the number of bytes in the <code>text</code>
variable. But the memory we are using is more than <em>twice</em>
that, because we are duplicating every single byte in the list called
<code>sentences</code>. That's not a big deal when you have three
sentences. But what if <code>text</code> has three thousand? Or three
million?</p>

<p>We can do better. Suppose our application only needs to examine one
sentence at a time<sup><a href="#note_1">1</a></sup>. What's a
scalable way to iterate through them, while also keeping your code
readable and maintainable?
</p>

<p>Let's imagine an interface that might work well for us. Consider a
function, called <code>each_sentence</code>, which we can use like this:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="k">for</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="n">each_sentence</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
</p></li><li><p class="line">    <span class="c"># Do something with the sentence</span>
</p></li></ol></pre></div>



<p>Imagine it produces one sentence at a time, instead of all
sentences up front, like <code>re.split</code> does. Then the maximum
extra memory used is equal to that required to store the longest
sentence in the text. Unless you are parsing a novel composed of a
single, gigantic run-on sentence<sup><a href="#note_2">2</a></sup>,
this will vastly raise the size of input your application can handle.
</p>

<p>That's a nice idea, but can we make it work? Yes, using the
<code>yield</code> keyword to construct a <em>generator</em>. Here is
a simple example of a generator, and how you use it:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="k">def</span> <span class="nf">nums</span><span class="p">():</span>
</p></li><li><p class="line">    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
</p></li><li><p class="line">    <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
</p></li><li><p class="line">        <span class="k">yield</span> <span class="n">n</span>
</p></li><li><p class="line">        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</p></li><li><p class="line">
</p></li><li><p class="line"><span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">():</span>
</p></li><li><p class="line">    <span class="k">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</p></li></ol></pre></div>



<p>Note this function has no <code>return</code> keyword, but instead
uses <code>yield</code>. A function using "yield" instead of "return"
is called a <em>generator</em> in Python. To help yourself ingrain the
syntax, open a new file, type the above in, and run it as a Python
program. You will see the following output:</p>






<p>The return type of <code>nums</code> is a <em>generator
object</em><sup><a href="#note_3">3</a></sup>, which quacks like an
iterator. Each time through, it picks up again on the line after the
<code>yield</code> (instead of starting at the beginning, like a
regular function would).</p>

<p>In other words: In Python, generators are a way to quickly create
iterators. They are lazy, in the good sense of the word, allocating
memory for each sentence one at a time (and garbage-collecting the old
one as it goes along). The returned object implements the iterator
protocol, which is why you can use it in a for loop.</p>

<p>You can have multiple yield statements in a generator:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="k">def</span> <span class="nf">nums2</span><span class="p">():</span>
</p></li><li><p class="line">    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
</p></li><li><p class="line">    <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
</p></li><li><p class="line">        <span class="k">yield</span> <span class="n">n</span>
</p></li><li><p class="line">        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</p></li><li><p class="line">    <span class="k">yield</span> <span class="mi">42</span> <span class="c"># Second yield</span>
</p></li><li><p class="line">
</p></li><li><p class="line"><span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums2</span><span class="p">():</span>
</p></li><li><p class="line">    <span class="k">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</p></li></ol></pre></div>



<p>This time, the program prints:</p>






<p>Reason through the code above, and convince yourself it makes
sense. The second yield is reached after <code>while</code> loop
exits. When the function reaches the implicit return at the end, the
iteration stops.</p>

<p>With these pieces, we can realize the <code>each_sentence</code>
function above:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="kn">import</span> <span class="nn">re</span>
</p></li><li><p class="line"><span class="k">def</span> <span class="nf">each_sentence</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
</p></li><li><p class="line">    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
</p></li><li><p class="line">    <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="s">r'\.\s+'</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
</p></li><li><p class="line">        <span class="n">end</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
</p></li><li><p class="line">        <span class="n">sentence</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
</p></li><li><p class="line">        <span class="k">yield</span> <span class="n">sentence</span>
</p></li><li><p class="line">        <span class="n">start</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
</p></li><li><p class="line">    <span class="k">yield</span> <span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:]</span>
</p></li></ol></pre></div>



<p>There's a little bit of complexity here, but since you're
subscribed to a newsletter devoted to advanced Python programming, I
know you can handle it. The <code>each_sentence</code> function
iterates through the sentence boundaries it finds in the text, using
the indices in the regex match object to find the starting and end
character positions of each sentence. It then returns a slice<sup><a href="#note_4">4</a></sup> of the original full text containing just
the sentence. Since the last sentence of the text may not have any
space after the final period, there's an extra yield statement at the
end just for that tail.</p>

<p>Now when we run the for-loop using <code>each_sentence</code>,
here's what we get:</p>


<div class="highlight"><pre><ol><li><p class="line">This is a body of text.
</p></li><li><p class="line">It has several sentences.
</p></li><li><p class="line">Some are long and some are short.
</p></li></ol></pre></div>



<p>This performantly handles any size corpus of text, up to available system
memory. And it will do so with high responsiveness - iterating through
the sentences immediately, without an expensive preprocessing step
before entering the <code>for</code> loop.</p>

<p>(Bonus: the ending punctuation is consistent now!)</p>

<h2>This Is Easier In Python 3</h2>

<p>Python 3 has many improvements over Python 2, far more than most
people realize. One pervasive and subtle change: iterators are used in
many places where, previously, full lists were created and
allocated. Some of these were mentioned above, and there are more as
well:</p>

<ul>
    <li>In Python 3, <code>range</code> is an iterator, generating the
    numbers as needed; in Python 2, it allocates a full list of the
    numbers before the loop even starts. You have to use
    <code>xrange</code> instead to get an iterator.</li>
    <li><code>map</code>, <code>filter</code> and <code>zip</code> all
    return iterators in Python 3. In Python 2, they allocate and
    return full lists.</li>
    <li>As mentioned, in Python 3 <code>my_dict.items()</code> returns
    an iterator; in Python 2, it creates a list of all key-value
    pairs, and you must instead remember to use
    <code>iteritems()</code> to get an iterator.</li>
    <li>Actually, <code>my_dict.items()</code> returns something
    called a <em>view</em>. This behaves like an iterator, but is better
    in ways I'll talk about in another article.</li>
</ul>

<p>Generally speaking, Python 3 uses iterators by default in more
places, unless you explicitly convert it to a list or other sequence. So
one advantage of implementing an application in Python 3, or porting
an existing one, is that the program may scale better "for free".</p>

<p>Since being able to write scalable software is one of the things
that separates average developers from world-class engineers, it's a
key topic I'll focus on in the upcoming Advanced Python course,
and in future editions of <a href="/python-newsletter/">this newsletter</a>.</p>

<section id="footnotes">
<ol>
    <li id="note_1"><p>Or N at a time, i.e. some bounded
    number. Most applications will actually fit this mold; it's rare
    you will need to cross-correlate every record of a giant data set.</p>
    </li>

    <li id="note_2"><p>Apparently, <a href="http://www.nytimes.com/2010/12/26/books/review/Park-t.html">run-on
    sentence novels exist</a>. But hopefully you won't... run into them.</p>
    </li>

    <li id="note_3"><p>Often you will see people use the word
    "generator" interchangeably to describe the function, or the object
    returned by the function. It's often clear enough by the context. If you
    want to be more explicit, use "generator" to refer to the function
    object, and "generator object" for what the function returns
    when called. A generator object can always be used exactly like an
    iterator; if you want to be exacting, it's not <em>identical</em> to
    an iterator, but that's a topic for a different article.</p>
    </li>

    <li id="note_4"><p>A slice of a string is itself a string,
    created by a concise syntax: <code>my_str[start:end]</code>, where
    <code>start</code> is the zero-based starting character, and <code>end</code> is
    <em>one past</em> the ending character. So <code>"Hello there,
    world!"[6:11] == "there"</code>.</p>
    </li>
</ol>
</section>




	</div> 

    </div></body></html>