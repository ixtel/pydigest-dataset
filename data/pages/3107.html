<html><body><div><div itemprop="articleBody"><p>This is a small addition to the <a class="reference external" href="https://blog.ionelmc.ro/2013/06/05/python-debugging-tools/">previous article about the debuggers</a>.</p><p>The stdlib has 3 backends (<a class="reference external" href="http://docs.python.org/2/library/profile.html#module-cProfile">cProfile and profile</a> , <a class="reference external" href="http://docs.python.org/2/library/hotshot.html">hotshot</a>) and countless 3rd party visualization tools, converters and whatnot. Where there are many tools there's plenty of bad advice ...</p><div class="section" id="runsnakerun"><h2>RunSnakeRun<a class="headerlink" href="#runsnakerun" title="Permalink to this headline"> *</a></h2><p>You can install it with <tt class="docutils literal">pip install RunSnakeRun</tt> or <tt class="docutils literal"><span class="pre">apt-get</span> install runsnakerun</tt> or from <a class="reference external" href="http://www.vrplumber.com/programming/runsnakerun/">sources</a>.</p><p>RunSnakeRun is a well rounded tool, easy to integrate - you can just use it with the stdlib cProfile/profile, just specify the <tt class="docutils literal">filename</tt> argument to <a class="reference external" href="http://docs.python.org/2/library/profile.html#profile.run">profile.run</a>, eg:</p><div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">cProfile</span>
<span class="n">cProfile</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s2">"main()"</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">"my.profile"</span><span class="p">)</span>
</pre></div><p>After that, run this in the shell:</p><p>It looks like this:</p><img alt="Screenshort of RunSnakeRun" src="https://blog.ionelmc.ro/2013/06/08/python-profiling-tools/runsnakerun.png"/><p>This is acceptable and will work well if you don't have freakishly huge profiles, eg: you just have 1 function than takes too much time.</p><p>There's a <em>memory profiling mode</em> in RunSnakeRun (requires <a class="reference external" href="https://launchpad.net/meliae">Meliae</a>). To my shame I haven't tried it but it looks very useful if you want to visualize memory usage. It looks like <a class="reference external" href="http://www.vrplumber.com/programming/runsnakerun/meliae-sample.png">this</a>.</p></div><div class="section" id="kcachegrind"><h2>KCachegrind<a class="headerlink" href="#kcachegrind" title="Permalink to this headline"> *</a></h2><p>You can install it with with <tt class="docutils literal"><span class="pre">apt-get</span> install kcachegrind</tt> or from <a class="reference external" href="http://kcachegrind.sourceforge.net/html/Download.html">sources</a>. For windows you can use <a class="reference external" href="http://sourceforge.net/projects/qcachegrindwin/">QCacheGrind</a>.</p><p>I really like this tool! It shows you call tree graphs, sortable call tables, call/callee maps, sourcecode, and you can filter everything. It is language agnostic - you probably know this tool if you come from a C/C++ background.</p><p>I like this over <a class="reference internal" href="#runsnakerun">RunSnakeRun</a> cause it's a lot more powerful:</p><ul class="simple"><li>on the call tree graphs: you can sort, change layout/rendering in many ways or export to dot/png - <a class="reference internal" href="#runsnakerun">RunSnakeRun</a> doesn't even show a call tree graph.</li><li>you can see sourcecode</li><li>you got callee maps</li><li>it could be less pain to install it (no wxPython dependency)</li></ul><p><a class="reference internal" href="#kcachegrind">KCachegrind</a> is worth using using over <a class="reference internal" href="#runsnakerun">RunSnakeRun</a> in large projects where it's not obvious what needs attention or you generally have very many function involved.</p></div></div></div></body></html>