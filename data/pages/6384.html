<html><body><div><p class="info"> 
    Aug. 28, 2015 
         
</p> 
<div class="post"> 
    <p><em>[This is the first in a series of lecture notes for the lab component of the core ‘Macroeconomics I’ course that I teach in the M.A. Economics programme at <a href="http://aud.ac.in">Ambedkar University, Delhi</a> ]</em></p>
<p>“Show, don’t tell” is an advice often given to authors. In that spirit, rather than telling you a lot about what programming is and how it will be useful to you, I will try to quickly teach you enough so than you can begin to solve interesting economic problems on your own.</p>
<p>Still, I must say a little about two things. First, the scope of this course. A standard ‘introduction to programming’ course is a full-time course that runs for at least a semester. All we have, on the other hand, is about 12 hours of lab time. So I will not try to teach you programming in a general way. Instead, I will focus on the basic skills that will allow you to combine already existing software to solve numerical and data analysis problems from economics. You will have to study much more in case you find yourself working in other domains, particularly where there isn’t much existing software and more things have to be developed from first principles. I will also not try to teach you any techniques and tools that are needed for developing large software projects in large teams. If you ever find yourself writing a program larger than a hundred lines or in collaboration with other people, you will need more preparation than this course provides.</p>
<p>Secondly, I must explain why we are going to use Python rather than some other programming language. My choice was motivated by three considerations:</p>
<ul>
<li>Python is free software so won’t have to buy a license to use it on your own machine or in a future workplace.</li>
<li>Python is extremely popular currently in scientific programming and data analysis. It is a skill that will be useful for many possible career paths and there is a lot of existing software and educational material.</li>
<li>It is possible to become productive in Python quickly without getting bogged down in too many arcane technical issues.</li>
</ul>
<p>On the other hand you should not become a technology fanatic. Other languages like C++, Fortran and Matlab have their own strong points and for each there are many economists using them productively. It is more important to understand the conceptual ideas in computing, instead of getting bogged down in the details of a particular language.</p>
<h2 id="background">Background</h2>
<h3 id="python-language-versions-2-and-3">Python language, versions 2 and 3</h3>
<p><a href="https://en.wikipedia.org/wiki/Python_%28programming_language%29">Python</a> is a programming language: a notation for writing instructions for computers. Like algebraic notation or musical notation, it is a set of rules for combining symbols as well as a way of interpreting sequences of symbols written according to these rules.</p>
<p>Over the years the rules that make up the Python language have been changed from time to time. Different versions of the language are identified by a version number of the form <code>x.y</code> where <code>x</code> is the <em>major version number</em> while <code>y</code> is the <em>minor version number</em>. Significant changes in the language are denoted by a change in the major number while small changes are denoted by a change in the minor number.</p>
<p>Currently both the <code>2.y</code> series and <code>3.y</code> series of Python versions are in common use, but all further improvements to the language will now happen in only the <code>3.y</code> series. We have therefore chosen to use the latter in our course. The differences between the two series is documented <a href="https://docs.python.org/3/whatsnew/3.0.html">here</a>, though this document will make sense only after you learn more about the language.</p>
<p>Fortunately, for most of the work that we do the difference between the two series will not be significant and most code we write will work the same under both the versions of the language.</p>
<h3 id="python-ipython-anaconda">Python, IPython, Anaconda</h3>
<p>One reason why people write instructions for computers is in the hopes of having a computer actually execute them. An <em>interpreter</em> is a piece of software which takes programs written in a particular programming language and executes them on a computer. There are a number of interpreters for the Python language, though the most popular is the CPython interpreter that you can download from the <a href="https://www.python.org/">Python language site</a>. This interpreter is <a href="https://en.wikipedia.org/wiki/Free_software">free software</a>: you are free to copy, distribute and modify the software.</p>
<p>One way to solve a programming problem is to encode the entire solution in a programming language in one go and then use an interpreter to execute the resulting program. You can do this with Python. But Python also supports an <em>interactive</em> way of developing programs in which you code up little bits of your solution, try them out and then combine them up into the full solution.</p>
<p><a href="http://ipython.org/">IPython</a> is a suite of software that supplements the Python interpreter in various ways to make it easy to develop programs interactively.</p>
<p>Programming in Python is productive because we get to use large <em>packages</em> of ready-made subprograms for different tasks such as linear algebra, graph plotting or statistics. Some of these subprograms are bundled with the Python interpreter itself in what is called the <a href="https://docs.python.org/3/library/"><em>standard library</em></a>, but many other packages are written by third-parties and the user is responsible for finding and installing what they need. This can become cumbersome very soon. <a href="https://store.continuum.io/cshop/anaconda/">Anaconda</a> is a bundle of software that includes a Python interpreter, IPython as well as a large collection of third-party packages that are useful for scientific computing and data analysis. Installing Anaconda makes all of them available in a single step.</p>
<p>For this course I will assume that you have downloaded and installed Anaconda and are using Microsoft Windows. Please discuss with me if you are using (Mac) OS X or Linux — there will only be minor differences.</p>
<p>Please ensure that you have installed the version of Anaconda that uses Python 3.x. The download page by default offers the version with Python 2.x but a link on that page allows you to choose the 3.x series. (Anaconda and IPython also have version numbers of their own. Do not confuse them with the version of the underlying Python language.)</p>
<h2 id="the-ipython-repl">The IPython REPL</h2>
<p>Select <code>Anaconda</code> and then <code>IPython Qtconsole</code> from the Windows start menu (the menu you get from clicking on the Windows icon at the bottom left of your screen). After a short wait a new window should open with text similar to this</p>
<pre><code>Python 3.4.3+ (default, Jun  2 2015, 14:09:35) 
Type "copyright", "credits" or "license" for more information.

IPython 2.3.0 -- An enhanced Interactive Python.
?         -&gt; Introduction and overview of IPython's features.
%quickref -&gt; Quick reference.
help      -&gt; Python's own help system.
object?   -&gt; Details about 'object', use 'object??' for extra details.
%guiref   -&gt; A brief reference about the graphical user interface.

In [1]:</code></pre>
<p>The first line shows the Python version. We confirm that it is <code>3.y</code>. The last line <code>In [1]</code> is a <em>prompt</em> which shows that the system is waiting for some input from you. Let’s provide it with some input. Type <code>2+3</code> and press <code>Enter</code>. You should get</p>
<pre><code>Out[1]: 5

In [2]:</code></pre>
<p>The IPython Qtconsole operates what is known as a Read-Eval-Print Loop. It <em>reads</em> in some Python code that you provide, <em>evaluates</em> it and then <em>prints</em> out the result. Then it <em>loops</em> back to the read phase.</p>
<p>In this case the code <code>2+2</code> we provided was an arithmetic expression. In Python numbers are expressed in the usual ways (<code>2</code>,<code>2.5</code>,<code>-2</code>) and the standard arithmetic operators are available: <code>+</code> and <code>-</code> for addition and subtraction, <code>*</code> and <code>/</code> for multiplication and division, <code>**</code> for exponentiation and <code>(</code> and <code>)</code> for grouping. Evaluation for arithmetic expressions just amounts to carrying out the arithmetic. The line</p>
<pre><code>Out[1]: 5</code></pre>
<p>shows the result of the evaluation. The next line</p>
<pre><code>In [2]:</code></pre>
<p>shows that IPython is once again ready to read some more input. The numbers in brackets after <code>In</code> or <code>Out</code> have a significance which we will discuss in a little while.</p>
<p>Let’s try some more arithmetic:</p>
<pre><code>In [2]: 1+3*2
Out[2]: 7

In [3]: (1+2**(1-1))*3
Out[3]: 6

In [4]: 2/3
Out[4]: 0.6666666666666666</code></pre>
<p>Notice that the usual precedence rules of arithmetic hold. Exponentiation before multiplication or division which are before addition or subtraction. For multiple level of grouping we use multiple pairs of parentheses <code>()</code>. Braces <code>{}</code> and brackets <code>[]</code> have other uses in Python.</p>
<p>If the result you got for <code>2/3</code> was <code>0</code> then you are using Python version 2 rather than version 3. Internally Python differentiates between integers (numbers without a fractional part) and floating-point numbers (numbers which have a fractional part). In Python 2 the result of dividing one integer by another was the quotient from integer division with the remainder thrown away. In Python 3 it is the floating point result that includes a fractional part. <strong>This is one of the major differences between Python 2 and 3 and a source of mysterious errors if you are using Python 2. It’s best if you switch to Python 3.</strong> If you really want integer division Python 3 provides a new operator <code>//</code>. So <code>2//3</code> evaluates as <code>0</code>.</p>
<h3 id="working-with-the-repl">Working with the REPL</h3>
<p>The read-eval-print loop is endless. To stop type in <code>Ctrl+D</code>, i.e. hold down one of the keys labelled <code>Ctrl</code> and then press <code>D</code>.</p>
<p>IPython stores a history of your inputs. You can use the up and down arrow keys to recall older inputs, edit them and then press enter to resubmit.</p>
<p>IPython has many more features. We will introduce them as we go along, but you can enter <code>%quickref</code> or <code>%guiref</code> at the IPython prompt to see a summary anytime. Commands beginning with the <code>%</code> sign are specific to the IPython software. They are not part of the Python language itself.</p>
<h2 id="python-basics">Python Basics</h2>
<h3 id="objects-and-names">Objects and Names</h3>
<p>Data in Python is organised in the form of <em>objects</em>. So when you type in <code>2</code> at the IPython prompt you are asking Python to build up an object which represents the integer <code>2</code>. When you type <code>2+3</code>, Python first creates two objects to represent <code>2</code> and <code>3</code> respectively and then applies the operation <code>+</code> to them to form a new object. Since <code>+</code> is the arithmetic addition operation the resulting object represents the integer <code>5</code>. The <em>print</em> part of IPython REPL then prints out this object in a human-readable form.</p>
<p>Each object has a type. <code>2</code> and <code>3</code> are of the integer type, <code>2.0</code> or <code>-3.5</code> are of the floating point type which is used to represent numbers with potentially fractional part. Sometimes you will also see floating point numbers in the form <code>3.5e12</code>, which is the way Python writes out <span class="math">\(3.5 \times 10^{12}\)</span>. If you want you can read <code>e</code> as ‘exponent’.</p>
<p>The Python language and standard library deals with objects of myriad types. There are complex numbers, text, files, graphs, sets, vectors and many more. Programmers can also define their own types, so there is actually an endless universe of types.</p>
<p>Types are important because they determine what operations can be applied to objects and how the operations behave. For example, division is an operation which makes sense for numbers but not for sets whereas intersection is an operation which makes sense for sets but not for numbers. To take another example, Python provides the <code>+</code> operations for both numbers and text strings, but it means arithmetic addition for numbers and pasting together for text strings.</p>
<p>So far we have referred to objects by giving an explicit description such as <code>2</code>. Any objects that Python built for us, such as the result of <code>2+3</code> have been printed and then lost to us. But as we go further we will need to keep track of intermediate results and build further on them. Python provides for this by allowing us to <em>bind</em> names to objects using assignment statements. Try out the following in IPython (from now on we will suppress the <code>In</code> and <code>Out</code> prompts):</p>

<p>You will see no output. What has happened is that the name <code>x</code> has been bound to the object created by the expression <code>10+1</code>. If at some later point you give the input</p>

<p>you will get the output <code>55</code> just as if you had typed <code>11</code> instead of <code>x</code>.</p>
<p>The spaces in the assignment statements are optional, but putting them in makes your code more readable. Names (called <em>identifiers</em> in programmer’s jargon) can contain uppercase letters, lowercase letters, digits and underscores (<code>_</code>) but must begin with a letter or underscore. <code>x123</code>, <code>TFP</code>, <code>capital_stock</code>, <code>_z</code> are all valid identifiers; <code>123x</code> or <code>x^2</code> are not. It is a good practice to use short identifiers like <code>x</code>, <code>t</code> or <code>i</code> for intermediate objects that have no overall significance and longer meaningful names like <code>labour_supply</code> for whose values have meaning in the context of the problem.</p>
<p>If a name which has already been used in an assignment statement is used again, then the old binding of the name is broken and the name is bound to the object produced by the right-hand side of the later assignments. So for example</p>

<p>produces the output <code>4</code>. What happens if you use a name on both the left- and right-hand side of an assignment?</p>

<p>The result is <code>2</code>. The rule is that the right-hand side of an assignment is evaluated first, using whatever bindings exist at that point and then the resulting object is bound to the name on the left.</p>
<p>You must be careful not to confuse assignment statements with algebraic equations. Python will complain if you type</p>
<pre><code>x+1 = 5</code></pre>
<p>since <code>x+1</code> is not an identifier. An assignment statement does not specify equality between two things. It just binds a name on the left to an object on the right.</p>
<p>Another confusion between assignment statements and algebraic equations may happen if you are used to spreadsheets. Suppose you type</p>

<p>You will get the output <code>3</code> and not <code>4</code>. In the second line, <code>x = y + 2</code> evaluates the right-hand side using the bindings that exist at that time and hence binds <code>x</code> to an object representing the integer <code>3</code>. When <code>y</code> is re-bound to <code>2</code> in the third line it does not cause automatic re-evaluation of any previous bindings in which <code>y</code> might have been used. The identifier <code>x</code> remains bound to the object representing <code>3</code>.</p>
<p>You can type <code>%who</code> at the IPython prompt to see a list of bindings you have defined in that session.</p>
<h3 id="functions">Functions</h3>
<p>We have already seen how to build new objects out of old by using arithmetic operators like <code>+</code>. Python has a handful of operators for standard arithmetic and logical operations. The more general way of specifying computations is the use of <em>functions</em>. For example Python has a built in function <code>abs</code> which computes the absolute value of a number. So to find out the absolute value of <code>-2</code> we type</p>

<p>which prints the result <code>2</code>. An expression like <code>abs(-2)</code> is called a <em>function call</em>. We say that we are calling the function <code>abs</code> with the <em>parameter</em> or <em>argument</em> <code>-2</code>. Somewhere the function <code>abs</code> is defined in terms of code which computes the absolute value in terms of more elementary steps. When the interpreter encounters an expression like <code>abs(-2)</code> it starts executing that code using <code>-2</code> as an input, and the result produced by this code is provided to us as the result of evaluating the function call.</p>
<p>Function calls can used as a part of larger expressions and the parameters can themselves be expressions. In the latter case the parameters are evaluated first and the result is then passed on to the function. Try:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="dt">abs</span>(-<span class="dv">2</span>) - <span class="dt">abs</span>(-<span class="dv">3</span>)
<span class="dt">abs</span>(<span class="dv">7-10</span>)
<span class="dt">abs</span>(<span class="dt">abs</span>(<span class="dv">7-10</span>))</code></pre></div>
<p>If you have been trying out the examples above you would have found that as soon as you type in <code>abs</code> and the opening parenthesis, IPython displays a hint describing the function and the parameters it takes. You can get the same information by typing the name of the function preceded or followed by a <code>?</code>, like <code>?abs</code> or <code>abs?</code>. This is another feature provided by IPython which is not provided by the basic Python interpreter.</p>
<h3 id="modules">Modules</h3>
<p>When programs are put together from independently developed components, name clashes emerge as a problem. A linear algebra library and a differential equation library may both provide a <code>solve</code> function. If we try to combine the two libraries in the same program then which of these function does <code>solve</code> refer to?</p>
<p>Python’s solution to this problem is <em>modules</em>. Modules are bundles of names, including names of functions and data objects. For example the Python standard library has a <code>math</code> module which includes trignometric function like <code>sin</code> and <code>cos</code> and constants like <code>pi</code> among other things. The names in this module are not accessible by default to a Python program. So in a new IPython session if you enter</p>

<p>Python will complain that the name <code>pi</code> is not defined. To make names in a module accessible we use what is known as an <em>import statement</em>. This has the form <code>import [module name]</code>. So to import the <code>math</code> module we type in</p>

<p>This loads up the definitions in the <code>math</code> module but makes only the name <code>math</code> accessible in the session. To access names defined in the module we need to type <code>math</code> followed by a dot (the period or full-stop) followed by the name, thus:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">math.pi
math.sin(<span class="dv">0</span>)
math.sin(math.pi/<span class="dv">2</span>)</code></pre></div>
<p>This solves the name clash problem. If <code>linalg</code> is a hypothetical linear algebra module and <code>ode</code> is a hypothetical differential equations module, both of which define a function <code>solve</code>, we can refer unambigiously to <code>linalg.solve</code> or <code>ode.solve</code>.</p>
<p>A few variants of the import statement are provided for additional convenience. Often modules have long names. Using the keyword <code>as</code> we can give a module a more convenient name. So the statement</p>

<p>imports the <code>math</code> module but binds it to the name <code>m</code> so that we can call the <code>sin</code> function with</p>

<p>Using the <code>from</code> keyword we can import a name into the <em>global namespace</em> so we no longer need to use the module name to refer to it. So after</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> math <span class="ch">import</span> sin, cos</code></pre></div>
<p>we can refer to the <code>sin</code> and <code>cos</code> functions from the math module as <code>sin</code> and <code>cos</code> without having to prefix it with <code>math.</code>. Finally</p>

<p>imports all names from the <code>math</code> module into the global namespace so that all of them can be referred to without any prefix.</p>
<p>You should avoid using the <code>from</code> variant of the import statement since by adding everything to the common global namespace it defeats the whole purpose of preventing name clashes. Also a module prefix like <code>math.</code> is helpful to human readers of your programs, letting them see at a glance which module a name comes from.</p>
<h2 id="further-reading">Further Reading</h2>
<p>The Python website has a <a href="https://docs.python.org/3/tutorial/index.html">tutorial</a> for the language. Its sequence of presentation is very different from ours, but it can be useful if you have some prior programming experience and want to quickly see how standard programming concepts are implemented in Python.</p>
<p>The <a href="https://docs.python.org/3/library/index.html">Python Standard Library Reference</a> describes the facilities provided by the standard library. Glance through it now to get an idea of the wide range of facilities than come built-in with Python and bookmark it for future reference. Read in detail through the documentation of the <a href="https://docs.python.org/3/library/math.html">Math module</a> and experiment with the functions described there since we will be using them a lot. Remember you have to <code>import math</code> and prefix their names with <code>math.</code> when using them.</p> 
</div> 



</div></body></html>