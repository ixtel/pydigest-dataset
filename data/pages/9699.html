<html><body><div><div class="post-text" itemprop="text">

<p>The python3 <a href="https://docs.python.org/3/howto/sockets.html#using-a-socket">socket programming howto</a> presents this code snippet</p>

<pre><code>class MySocket:
    """demonstration class only
      - coded for clarity, not efficiency
    """

    def __init__(self, sock=None):
        if sock is None:
            self.sock = socket.socket(
                            socket.AF_INET, socket.SOCK_STREAM)
        else:
            self.sock = sock

    def connect(self, host, port):
        self.sock.connect((host, port))

    def mysend(self, msg):
        totalsent = 0
        while totalsent &lt; MSGLEN:
            sent = self.sock.send(msg[totalsent:])
            if sent == 0:
                raise RuntimeError("socket connection broken")
            totalsent = totalsent + sent

    def myreceive(self):
        chunks = []
        bytes_recd = 0
        while bytes_recd &lt; MSGLEN:
            chunk = self.sock.recv(min(MSGLEN - bytes_recd, 2048))
            if chunk == b'':
                raise RuntimeError("socket connection broken")
            chunks.append(chunk)
            bytes_recd = bytes_recd + len(chunk)
        return b''.join(chunks)
</code></pre>

<p>where the send loop is interrupted if the socket <a href="https://docs.python.org/3/library/socket.html#socket.socket.send"><code>send</code></a> method returns 0. </p>

<p>The logic behind this snippet is that when the <code>send</code> method returns '0 bytes sent', the sending side of a socket connection should give up its efforts to send data. This is for sure true for the <a href="https://docs.python.org/3/library/socket.html#socket.socket.recv"><code>recv</code></a> method, where zero bytes read for a socket in blocking mode should be interpreted as <code>EOF</code>, and therefore the reading side should give up.</p>

<p>However I cannot understand under which situations the <code>send</code> method could return zero. My understanding of python sockets is that <code>send</code> returns immediately due to buffering at the OS level. If the buffer is full <code>send</code> will block, or if the connections is closed at the remote side, an exception is raised. </p>

<p>Finally suppose <code>send</code> returns zero without raising an exception: does this really indicate that all future <code>send</code> calls will return zero?</p>

<p>I've done some testing (although using only socket connected to <code>::1</code> on OS X) and was not able to find a situation in which <code>send</code> returns 0.</p>

<p><strong>Edit</strong></p>

<p>The HOWTO states:</p>

<blockquote>
  <p>But if you plan to reuse your socket for further transfers, you need
  to realize that there is no EOT on a socket. I repeat: if a socket
  send or recv returns after handling 0 bytes, the connection has been
  broken. If the connection has not been broken, you may wait on a recv
  forever, because the socket will not tell you that thereâ€™s nothing
  more to read (for now).</p>
</blockquote>

<p>It is pretty easy to find a situation in which <code>recv</code> returns 0: when the remote (sending) side calls <a href="https://docs.python.org/3/library/socket.html#socket.socket.shutdown"><code>socket.shutdown(SHUT_WR)</code></a>, further <code>recv</code> on the receiving side will return <code>0</code> and not raise any exception. </p>

<p>I'm looking for a concrete example where you can show that receiving 0 zero from <code>send</code> indicates a <em>broken connection</em> (which will continue to return 0 on send.)</p>
    </div>
    </div></body></html>