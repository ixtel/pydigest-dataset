<html><body><div><div class="text_cell_render border-box-sizing rendered_html">
<p>We have seen that multiple namespaces can exist independently from each other and that they can contain the same variable names on different hierachy levels. The "scope" defines on which hierarchy level Python searches for a particular "variable name" for its associated object. Now, the next question is: "In which order does Python search the different levels of namespaces before it finds the name-to-object' mapping?"<br/>
To answer is: It uses the LEGB-rule, which stands for</p>
<p><strong>Local -&gt; Enclosed -&gt; Global -&gt; Built-in</strong>,</p>
<p>where the arrows should denote the direction of the namespace-hierarchy search order.</p>
<ul>
<li><em>Local</em> can be inside a function or class method, for example.  </li>
<li><em>Enclosed</em> can be its <code>enclosing</code> function, e.g., if a function is wrapped inside another function.  </li>
<li><em>Global</em> refers to the uppermost level of the executing script itself, and  </li>
<li><em>Built-in</em> are special names that Python reserves for itself.  </li>
</ul>
<p>So, if a particular name:object mapping cannot be found in the local namespaces, the namespaces of the enclosed scope are being searched next. If the search in the enclosed scope is unsuccessful, too, Python moves on to the global namespace, and eventually, it will search the built-in namespace (side note: if a name cannot found in any of the namespaces, a <em>NameError</em> will is raised).</p>
<p><strong>Note</strong>:<br/>
Namespaces can also be further nested, for example if we import modules, or if we are defining new classes. In those cases we have to use prefixes to access those nested namespaces. Let me illustrate this concept in the following code block:</p>

</div>
</div></body></html>