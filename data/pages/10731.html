<html><body><div><div class="content html_format"><p>
      В этой небольшой статье речь пойдет о том, можно ли легко использовать Python для написания скриптов вместо Bash/Sh. Первый вопрос, который возникнет у читателя, пожалуй, а почему, собственно, не использовать Bash/Sh, которые специально были для этого созданы? Созданы они были достаточно давно и, на мой взгляд, имеют достаточно специфичный синтаксис, не сильно похожий на остальные языки, который достаточно сложно запомнить, если вы не администратор 50+ левела. Помните, ли вы навскидку как написать на нем простой if?</p>

<pre><code>if [ $# -ne "$ARGCOUNT" ]
then
    echo "Usage: `basename $0` filename"
    exit $E_WRONGARGS
fi</code></pre><p>
Элементарно правда? Интуитивно понятный синтаксис. :)
</p><p>
Тем не менее в python эти конструкции намного проще. Каждый раз когда я пишу что то на баше, то непременно лезу в поисковик чтобы вспомнить как писать простой if, switch или что-то еще. Присвоение я уже запомнил. :) В Python все иначе. Я хоть и не пишу на нем круглые сутки, но никогда не приходилось лезть и смотреть как там сделать простой цикл, потому что синтаксис языка простой и интуитивный. Плюс ко всему он намного ближе к остальным мейнстримовым языкам типа java или c++, чем Bash/Sh.
</p><p>
Также в стандартной и прочих библиотеках Python есть намного более удобные библиотеки чем консольные утилиты. Скажем, вы хотите распарсить json, xml, yaml. Знаете какой я недавно видел код в баше чтобы сделать это? Правильно:

</p><pre><code>python -c "import json; json.loads..." :)</code></pre><p>
И это был не мой код. Это был код баше/питоно нейтрального человека.
</p><p>
То же самое с регексом, sed бесспорно удобная утилита, но как много людей помнит как правильно ее использовать? Ну кроме Lee E. McMahon, который ее создал. Да впринципе многие помнят, даже я помню как делать простые вещи. Но, на мой взгляд, в Python модуль re намного удобнее.
</p><p>
В этой небольшой статье я хотел бы представить вам диалект Python который называется </p><a href="https://github.com/lamerman/shellpy">shellpy</a><p> и служит для того, чтобы насколько это возможно заменить Bash на python в скриптах. 
</p><p>
Велкам под кат.
</p><a name="habracut"/>
<h2>Введение</h2><p>
Shell python ничем не отличается от простого Python кроме одной детали. Выражения внутри grave accent символов ( ` ) в отличие от Python не является eval, а обозначает выполнение команды в шелле. Например

</p><pre><code>`ls -l`</code></pre><p>
выполнит </p><code>ls -l</code><p> как shell команду. Также возможно написать все это без ` в конце строки

</p><pre><code>`ls -l</code></pre><p>
и это тоже будет корректным синтаксисом. 
</p><p>
Можно выполнять сразу несколько команд на разных строках

</p><pre><code>`
echo test &gt; test.txt
cat test.txt
`</code></pre><p>
и команды, занимающие несколько строк

</p><pre><code>`echo This is \
  a very long \
  line</code></pre><p>
Выполнение каждого выражения в shellpy возвращается объект класса Result

</p><pre><code>result = `ls -l</code></pre><p>
Это можно быть либо </p><a href="https://github.com/lamerman/shellpy/wiki/Simple-mode#result">Result</a><p> либо </p><a href="https://github.com/lamerman/shellpy/wiki/Interactive-mode#interactive-result">InteractiveResult</a><p> (Ссылки на гитхаб с документацией, можно и потом посмотреть :) ). Давайте начнем с простого результата. Из него можно легко получить код возврата выполненной команды

</p><pre><code>result = `ls -l
print result.returncode</code></pre><p>
И текст из stdout и stderr

</p><pre><code>result = `ls -l
result_text = result.stdout
result_error = result.stderr</code></pre><p>
Можно также пробежаться по всем строкам stdout выполненной команды в цикле

</p><pre><code>result = `ls -l
for line in result:
    print line.upper()</code></pre><p>
и так далее. 
</p><p>
Для результата есть также еще очень много синтаксического сахара. Например, мы можем легко проверить, что код возврата выполняемой команды равен нулю

</p><pre><code>result = `ls -l
if result:
    print 'Return code for ls -l was 0'</code></pre><p>
Или же более простым способом получить текст из stdout

</p><pre><code>result = `ls -l
print result</code></pre><p>
Все вышеперечисленное — это обзор синтаксиса вкратце, чтобы просто понять основную идею и не грузить вас всеми-всеми деталями. Там есть еще много чего и для интерактивного взаимодействия с выполняемыми командами, для управления исполнением команд. Но это все детали, в которые можно окунуться в </p><a href="https://github.com/lamerman/shellpy/wiki">документации</a><p> (на английском языке), если сама идея вам покажется интересной.

</p><h2>Это ж не валидный синтаксис Python получается, как все работает то?</h2><p>
Магия конечно, как еще :) Да, друзья мои, мне пришлось использовать препроцессинг, каюсь, но другого способа я не нашел. Я видел другие библиотеки, которые делают нечто подобное, не нарушая синтаксиса языка вроде

</p><pre><code>from sh import ifconfig
print(ifconfig("wlan0"))</code></pre><p>
Но меня такой синтаксис не устраивал, поскольку даже несмотря на сложности, хотелось получить best user experience ©, а для меня это значит насколько это возможно простое и близкое к его величеству Шеллу написание команд. 
</p><p>
Знакомый с темой читатель спросит, чем IPython то тебя не устроил, там ж почти как у тебя только значок другой ставить надо, может ты просто велосипедист, которому лень заглянуть в поисковик? И правда он выглядит вот так:

</p><pre><code>lines = !ls -l</code></pre><p>
Я его пытался использовать но встретил пару серьезных проблем, с которыми ужиться не смог. Самая главная из них, то что нет простого импорта как в Python. То есть ты не можешь написать какой-то код на самом ipython и легко его переиспользовать в других местах. Невозможно написать для своего ipython модуля

</p><pre><code>import myipythomodule</code></pre><p>
и чтобы все сразу заработало как в сказке. Единственный способ переиспользовать скрипт, это выполнить его. После выполнения в окружении у тебя появляются все функции и переменные, объявленные в выполняемом файле. Не кошерно на мой взгляд.
</p><p>
В shellpy код переиспользуется легко и импортируется точно так же как и в обычном python. Предположим у нас есть модуль common в котором мы храним очень полезный код. Заглянем в директорию с этим модулем

</p><pre><code>ls common/
common.spy  __init__.spy</code></pre><p>
Итак, что у нас тут есть, ну во первых </p><strong>init</strong><p>, но с расширением .spy. Это и является отличительной чертой spy модуля от обычного. Посмотрим также внутрь файла common.spy, что там интересного 

</p><pre><code>def common_func():
    return `echo 5</code></pre><p>
Мы видим что тут объявлена функция, которая внутри себя использует shellpy синтаксис чтобы вернуть результат выполнения `echo 5. Как этот модуль используется в коде? А вот как

</p><pre><code>from common.common import common_func

print('Result of imported function is ' + str(common_func()))</code></pre><p>
Видите? Как в обычном Python, просто взяли и заимпортировали.
</p><p>
Как же все работает. Это работает с помощью </p><a href="https://www.python.org/dev/peps/pep-0302/">PEP 0302 — New Import Hooks</a><p>. Когда вы импортируете что-то в своем коде то вначале Python спрашивает у хука, нет ли тут чего-то твоего, хук просматривает PYTHONPATH на наличие файлов *.spy или модулей shellpython. Если ничего нет, то так и говорит: "Ничего нету, импортируй сам". Если же он находит что-то там, то хук занимается импортом самостоятельно. А именно, он делает препроцессинг файла в обычный python и складывает все это добро в temp директорию операционной системы. Записав новый Python файл или модуль он добавляет его в PYTHONPATH и за дело берется уже самый обыкновенный импорт.

</p><h3>Давайте же скорее посмотрим на какой-нибудь пример</h3><p>
Этот скрипт скачивает аватар юзера Python с Github и кладет его в temp директорию

</p><pre><code class="python">    import json
    import os
    import tempfile

    # с помощью curl получает ответ от апи гитхаба
    answer = `curl https://api.github.com/users/python

    # синтаксический сахар чтобы сравнить результат выполнение с нулем
    if answer:
        answer_json = json.loads(answer.stdout)
        avatar_url = answer_json['avatar_url']

        destination = os.path.join(tempfile.gettempdir(), 'python.png')

        # в этот раз скачиваем саму картинку
        result = `curl {avatar_url} &gt; {destination}
        if result:
            # если проблем не возникло, то показываем картинку 
            p`ls -l {destination}
        else:
            print('Failed to download avatar')

        print('Avatar downloaded')
    else:
        print('Failed to access github api')</code></pre><p>
Красота...

</p><h3>Установка</h3><p>
Shellpython можно установить двумя способами: </p><code>pip install shellpy</code><p> или склонировав </p><a href="https://github.com/lamerman/shellpy">репозиторий</a><p> и выполнив </p><code>setup.py install</code><p>. После этого у вас появится утилита </p><code>shellpy</code><p>.

</p><h3>Запустим же что-нибудь</h3><p>
После установки можно потестировать shellpython на примерах, которые доступны прямо в репозитории.

</p><pre><code>shellpy example/curl.spy

shellpy example/git.spy</code></pre><p>
Также здесь есть allinone примеры, которые называются так, потому что тестируют все-все функции, которые есть в shellpy. Загляните туда, чтобы лучше узнать что же там еще такого есть, либо просто выполните

</p><pre><code>shellpy example/allinone/test.spy</code></pre><p>
Для третьего Python команда выглядит вот так

</p><pre><code>shellpy example/allinone/test3.spy</code></pre>
<h3>Совместимость</h3><p>
Это работает на Linux и должно работать на Mac для Python 2.x и 3.x. На виндовсе пока не работает, но проблем никаких для работы нет, так как все писалось с использованием кроссплатформенных библиотек и ничего платформоспецифичного в коде нет. Просто не дошли руки еще, чтобы потестировать на виндовсе. Мака у меня тоже нет, но вроде у друга работало :) Если у вас есть мак и у вас все нормально, скажите пожалуйста.
</p><p>
Если найдете проблемы — пишите в коммент, либо сюда </p><a href="https://gitter.im/lamerman/shellpy?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge"><img src="https://badges.gitter.im/lamerman/shellpy.svg" alt="Join the chat at https://gitter.im/lamerman/shellpy"/></a><p> либо телеграфируйте как-нибудь :)

</p><h3>Документация (на английском)</h3>
<a href="https://github.com/lamerman/shellpy/wiki">Wiki</a>

<h3>Можно ли законтрибьютить</h3><p>
Конечно :)

</p><h3>Оно мне ничего в продакшене не разломает?</h3><p>
Сейчас версия 0.4.0, это не стейбл и продакшн процессы пока лучше не завязывать на скрипт, подождав пока все отладится. Но в девелопменте, CI можно использовать вполне. Все это покрыто тестами и работает :) </p><a href="https://travis-ci.org/lamerman/shellpy"><img src="https://travis-ci.org/lamerman/shellpy.svg?branch=master" alt="Build Status"/></a>

<h3>P.s.</h3><p>
Пишите ваши отзывы об идее в целом и о реализации в частности, а также о проблемах, пожеланиях, всех рад услышать :) Заводите </p><a href="https://github.com/lamerman/shellpy/issues">Issues</a><p> еще в гитхабе, там их уже много :)


      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>