<html><body><div><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-scandir-a-better-directory-iterator-and-faster-oswalk" class="anchor" href="#scandir-a-better-directory-iterator-and-faster-oswalk" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>scandir, a better directory iterator and faster os.walk()</h1>
<p><code>scandir()</code> is a directory iteration function like <code>os.listdir()</code>,
except that instead of returning a list of bare filenames, it yields
<code>DirEntry</code> objects that include file type and stat information along
with the name. Using <code>scandir()</code> increases the speed of <code>os.walk()</code>
by 2-20 times (depending on the platform and file system) by avoiding
unnecessary calls to <code>os.stat()</code> in most cases.</p>
<a name="user-content-now-included-in-a-python-near-you"/>
<h2><a id="user-content-now-included-in-a-python-near-you" class="anchor" href="#now-included-in-a-python-near-you" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Now included in a Python near you!</h2>
<p><code>scandir</code> has been included in the Python 3.5 standard library as
<code>os.scandir()</code>, and the related performance improvements to
<code>os.walk()</code> have also been included. So if you're lucky enough to be
using Python 3.5 (release date September 13, 2015) you get the benefit
immediately, otherwise just
<a href="https://pypi.python.org/pypi/scandir">download this module from PyPI</a>,
install it with <code>pip install scandir</code>, and then do something like
this in your code:</p>
<pre># Use the built-in version of scandir/walk if possible, otherwise
# use the scandir module version
try:
    from os import scandir, walk
except ImportError:
    from scandir import scandir, walk
</pre>
<p><a href="https://www.python.org/dev/peps/pep-0471/">PEP 471</a>, which is the
PEP that proposes including <code>scandir</code> in the Python standard library,
was <a href="https://mail.python.org/pipermail/python-dev/2014-July/135561.html">accepted</a>
in July 2014 by Victor Stinner, the BDFL-delegate for the PEP.</p>
<p>This <code>scandir</code> module is intended to work on Python 2.6+ and Python
3.2+ (and it has been tested on those versions).</p>
<a name="user-content-background"/>
<h2><a id="user-content-background" class="anchor" href="#background" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Background</h2>
<p>Python's built-in <code>os.walk()</code> is significantly slower than it needs to be,
because -- in addition to calling <code>listdir()</code> on each directory -- it calls
<code>stat()</code> on each file to determine whether the filename is a directory or not.
But both <code>FindFirstFile</code> / <code>FindNextFile</code> on Windows and <code>readdir</code> on Linux/OS
X already tell you whether the files returned are directories or not, so
no further <code>stat</code> system calls are needed. In short, you can reduce the number
of system calls from about 2N to N, where N is the total number of files and
directories in the tree.</p>
<p>In practice, removing all those extra system calls makes <code>os.walk()</code> about
<strong>7-50 times as fast on Windows, and about 3-10 times as fast on Linux and Mac OS
X.</strong> So we're not talking about micro-optimizations. See more benchmarks
in the "Benchmarks" section below.</p>
<p>Somewhat relatedly, many people have also asked for a version of
<code>os.listdir()</code> that yields filenames as it iterates instead of returning them
as one big list. This improves memory efficiency for iterating very large
directories.</p>
<p>So as well as a faster <code>walk()</code>, scandir adds a new <code>scandir()</code> function.
They're pretty easy to use, but see "The API" below for the full docs.</p>
<a name="user-content-benchmarks"/>
<h2><a id="user-content-benchmarks" class="anchor" href="#benchmarks" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Benchmarks</h2>
<p>Below are results showing how many times as fast <code>scandir.walk()</code> is than
<code>os.walk()</code> on various systems, found by running <code>benchmark.py</code> with no
arguments:</p>
<table>





<thead valign="bottom">
<tr><th>System version</th>
<th>Python version</th>
<th>Times as fast</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Windows 7 64-bit</td>
<td>2.7.7 64-bit</td>
<td>10.4</td>
</tr>
<tr><td>Windows 7 64-bit SSD</td>
<td>2.7.7 64-bit</td>
<td>10.3</td>
</tr>
<tr><td>Windows 7 64-bit NFS</td>
<td>2.7.6 64-bit</td>
<td>36.8</td>
</tr>
<tr><td>Windows 7 64-bit SSD</td>
<td>3.4.1 64-bit</td>
<td>9.9</td>
</tr>
<tr><td>Windows 7 64-bit SSD</td>
<td>3.5.0 64-bit</td>
<td>9.5</td>
</tr>
<tr><td>CentOS 6.2 64-bit</td>
<td>2.6.6 64-bit</td>
<td>3.9</td>
</tr>
<tr><td>Ubuntu 14.04 64-bit</td>
<td>2.7.6 64-bit</td>
<td>5.8</td>
</tr>
<tr><td>Mac OS X 10.9.3</td>
<td>2.7.5 64-bit</td>
<td>3.8</td>
</tr>
</tbody>
</table>
<p>All of the above tests were done using the fast C version of scandir
(source code in <code>_scandir.c</code>).</p>
<p>Note that the gains are less than the above on smaller directories and greater
on larger directories. This is why <code>benchmark.py</code> creates a test directory
tree with a standardized size.</p>
<a name="user-content-the-api"/>
<h2><a id="user-content-the-api" class="anchor" href="#the-api" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>The API</h2>
<a name="user-content-walk"/>
<h3><a id="user-content-walk" class="anchor" href="#walk" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>walk()</h3>
<p>The API for <code>scandir.walk()</code> is exactly the same as <code>os.walk()</code>, so just
<a href="https://docs.python.org/3.5/library/os.html#os.walk">read the Python docs</a>.</p>
<a name="user-content-scandir"/>
<h3><a id="user-content-scandir" class="anchor" href="#scandir" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>scandir()</h3>
<p>The full docs for <code>scandir()</code> and the <code>DirEntry</code> objects it yields are
available in the <a href="https://docs.python.org/3.5/library/os.html#os.scandir">Python documentation here</a>.
But below is a brief summary as well.</p>
<blockquote>
scandir(path='.') -&gt; iterator of DirEntry objects for given path</blockquote>
<p>Like <code>listdir</code>, <code>scandir</code> calls the operating system's directory
iteration system calls to get the names of the files in the given
<code>path</code>, but it's different from <code>listdir</code> in two ways:</p>
<ul>
<li>Instead of returning bare filename strings, it returns lightweight
<code>DirEntry</code> objects that hold the filename string and provide
simple methods that allow access to the additional data the
operating system may have returned.</li>
<li>It returns a generator instead of a list, so that <code>scandir</code> acts
as a true iterator instead of returning the full list immediately.</li>
</ul>
<p><code>scandir()</code> yields a <code>DirEntry</code> object for each file and
sub-directory in <code>path</code>. Just like <code>listdir</code>, the <code>'.'</code>
and <code>'..'</code> pseudo-directories are skipped, and the entries are
yielded in system-dependent order. Each <code>DirEntry</code> object has the
following attributes and methods:</p>
<ul>
<li><code>name</code>: the entry's filename, relative to the scandir <code>path</code>
argument (corresponds to the return values of <code>os.listdir</code>)</li>
<li><code>path</code>: the entry's full path name (not necessarily an absolute
path) -- the equivalent of <code>os.path.join(scandir_path, entry.name)</code></li>
<li><code>is_dir(*, follow_symlinks=True)</code>: similar to
<code>pathlib.Path.is_dir()</code>, but the return value is cached on the
<code>DirEntry</code> object; doesn't require a system call in most cases;
don't follow symbolic links if <code>follow_symlinks</code> is False</li>
<li><code>is_file(*, follow_symlinks=True)</code>: similar to
<code>pathlib.Path.is_file()</code>, but the return value is cached on the
<code>DirEntry</code> object; doesn't require a system call in most cases;
don't follow symbolic links if <code>follow_symlinks</code> is False</li>
<li><code>is_symlink()</code>: similar to <code>pathlib.Path.is_symlink()</code>, but the
return value is cached on the <code>DirEntry</code> object; doesn't require a
system call in most cases</li>
<li><code>stat(*, follow_symlinks=True)</code>: like <code>os.stat()</code>, but the
return value is cached on the <code>DirEntry</code> object; does not require a
system call on Windows (except for symlinks); don't follow symbolic links
(like <code>os.lstat()</code>) if <code>follow_symlinks</code> is False</li>
<li><code>inode()</code>: return the inode number of the entry; the return value
is cached on the <code>DirEntry</code> object</li>
</ul>
<p>Here's a very simple example of <code>scandir()</code> showing use of the
<code>DirEntry.name</code> attribute and the <code>DirEntry.is_dir()</code> method:</p>
<pre>def subdirs(path):
    """Yield directory names not starting with '.' under given path."""
    for entry in os.scandir(path):
        if not entry.name.startswith('.') and entry.is_dir():
            yield entry.name
</pre>
<p>This <code>subdirs()</code> function will be significantly faster with scandir
than <code>os.listdir()</code> and <code>os.path.isdir()</code> on both Windows and POSIX
systems, especially on medium-sized or large directories.</p>
<a name="user-content-further-reading"/>
<h2><a id="user-content-further-reading" class="anchor" href="#further-reading" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Further reading</h2>
<ul>
<li><a href="https://docs.python.org/3.5/library/os.html#os.scandir">The Python docs for scandir</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0471/">PEP 471</a>, the
(now-accepted) Python Enhancement Proposal that proposed adding
<code>scandir</code> to the standard library -- a lot of details here,
including rejected ideas and previous discussion</li>
</ul>
<a name="user-content-flames-comments-bug-reports"/>
<h2><a id="user-content-flames-comments-bug-reports" class="anchor" href="#flames-comments-bug-reports" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Flames, comments, bug reports</h2>
<p>Please send flames, comments, and questions about scandir to Ben Hoyt:</p>
<p><a href="http://benhoyt.com/">http://benhoyt.com/</a></p>
<p>File bug reports for the version in the Python 3.5 standard library
<a href="https://docs.python.org/3.5/bugs.html">here</a>, or file bug reports
or feature requests for this module at the GitHub project page:</p>
<p><a href="https://github.com/benhoyt/scandir">https://github.com/benhoyt/scandir</a></p>

</article>
  </div></body></html>