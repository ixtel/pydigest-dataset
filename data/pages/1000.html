<html><body><div><div class="document" id="getting-started-using-celery-for-scheduling-tasks">
<span id="why-celery"/><span id="celery-scheduling"/><h1 class="title">Getting Started Using Celery for Scheduling Tasks</h1>
<p>Many Django applications can make good use of being able to schedule work, either periodically or just not blocking the request thread.</p>
<p>There are multiple ways to schedule tasks in your Django app, but there are some advantages to using Celery. It’s supported, scales well, and works well with Django. Given its wide use, there are lots of resources to help learn and use it. And once learned, that knowledge is likely to be useful on other projects.</p>
<div class="section" id="celery-versions-3-0-x">
<h1>Celery versions 3.0.x</h1>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 13)</p>
<p>Title underline too short.</p>
<pre class="literal-block">Celery versions 3.0.x
===============
</pre>
</div>
<p>This documentation applies to Celery 3.0.x.  Earlier or later versions of Celery
might behave differently.</p>
</div>
<div class="section" id="introduction-to-celery">
<h1>Introduction to Celery</h1>
<p>The purpose of Celery is to allow you to run some code later, or regularly
according to a schedule.</p>
<p>Why might this be useful? Here are a couple of common cases.</p>
<p>First, suppose a web request has come in from a user, who is waiting
for the request to complete so a new page can load in their browser.
Based on their request, you have some code to run that's going to take
a while (longer than the person might want to wait for a web page), but
you don't really need to run that code before responding to the web
request. You can use Celery to have your long-running code
called later, and go ahead and respond immediately to the web request.</p>
<p>This is common if you need to access a remote server to handle the request.
Your app has no control over how long the remote server will take to respond,
or the remote server might be down.</p>
<p>Another common situation is wanting to run some code regularly. For
example, maybe every hour you want to look up the latest weather
report and store the data. You can write a task to do that work, then
ask Celery to run it every hour. The task runs and puts the data
in the database, and then your Web application has access to the
latest weather report.</p>
<p>A <a class="reference external" href="http://docs.celeryproject.org/en/latest/userguide/tasks.html">task</a>
is just a Python function.  You can think of scheduling a task as
a time-delayed call to the function. For example, you might ask Celery
to call your function <tt class="docutils literal">task1</tt> with arguments <tt class="docutils literal">(1, 3, 3)</tt> after five
minutes.  Or you could have your function <tt class="docutils literal">batchjob</tt> called every
night at midnight.</p>
<p>We'll set up Celery so that your tasks run in pretty much the same
environment as the rest of your application's code, so they can access
the same database and Django settings. There are a few differences to keep
in mind, but we'll cover those later.</p>
<p>When a task is ready to be run, Celery puts it on a
<a class="reference external" href="http://docs.celeryproject.org/en/latest/getting-started/introduction.html#what-is-a-task-queue">queue</a>,
a list of
tasks that are ready to be run. You can have many queues, but we'll assume
a single queue here for simplicity.</p>
<p>Putting a task on a queue just adds it to a to-do list, so to speak.
In order for the task to be executed, some other process, called a <cite>worker</cite>,
has to be watching that queue for tasks. When it sees tasks on the queue,
it'll pull off the first and execute it, then go back to wait for more.
You can have many workers, possibly on many different servers, but we'll
assume a single worker for now.</p>
<p>We'll talk more later about the queue, the workers, and another important
process that we haven't mentioned yet, but that's enough for now, let's
do some work.</p>
</div>

<div class="section" id="configuring-django-for-celery">
<h1>Configuring Django for Celery</h1>
<p>To get started, we'll just get Celery configured to use with <tt class="docutils literal">runserver</tt>.
For the Celery <a class="reference external" href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html#choosing-a-broker">broker</a>, which we will explain more about later, we'll use a
<a class="reference external" href="http://docs.celeryproject.org/en/latest/getting-started/brokers/django.html">Django database broker implementation</a>. For now, you just need to know that
Celery needs a broker and we can get by using Django itself during development
(but you <cite>must</cite> use something more robust and better performing in production).</p>
<p>In your Django <tt class="docutils literal">settings.py</tt> file:</p>
<ol class="arabic simple">
<li>Add these lines:</li>
</ol>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">djcelery</span>
<span class="n">djcelery</span><span class="o">.</span><span class="n">setup_loader</span><span class="p">()</span>
<span class="n">BROKER_URL</span> <span class="o">=</span> <span class="s">'django://'</span>
</pre></div>

<p>The first two lines are always needed. Line 3 configures Celery to use its
Django broker.</p>
<p><strong>Important:</strong> Never use the Django broker in production. We are only using it
here to save time in this tutorial. In production you'll want to use RabbitMQ, or
maybe Redis.</p>
<ol class="arabic simple" start="2">
<li>Add <tt class="docutils literal">djcelery</tt> and <tt class="docutils literal">kombu.transport.django</tt> to <tt class="docutils literal">INSTALLED_APPS</tt>:</li>
</ol>
<div class="highlight"><pre><span class="n">INSTALLED_APPS</span> <span class="o">=</span> <span class="p">(</span>
   <span class="o">...</span>
   <span class="s">'djcelery'</span><span class="p">,</span>
   <span class="s">'kombu.transport.django'</span><span class="p">,</span>
   <span class="o">...</span>
<span class="p">)</span>
</pre></div>

<p><cite>djcelery</cite> is always needed. <cite>kombu.transport.django</cite> is the Django-based
broker, for use mainly during development.</p>
<ol class="arabic simple" start="3">
<li>Create celery's database tables. If using <a class="reference external" href="http://south.readthedocs.org/en/latest/">South</a> for schema migrations:</li>
</ol>
<div class="highlight"><pre><span class="nv">$ </span>python manage.py migrate
</pre></div>

<p>Otherwise:</p>
<div class="highlight"><pre><span class="nv">$ </span>python manage.py syncdb
</pre></div>

<p><span>.</span></p></div>
<div class="section" id="writing-a-task">
<h1>Writing a task</h1>
<p>As mentioned before, a task can just be a Python function.  However, Celery
does need to know about it. That's pretty easy when using Celery with Django.
Just add a <tt class="docutils literal">tasks.py</tt> file to your application, put your tasks in that file,
and decorate them.  Here's a trivial <tt class="docutils literal">tasks.py</tt>:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">celery</span> <span class="kn">import</span> <span class="n">task</span>

<span class="nd">@task</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>

<p>When <tt class="docutils literal">djcelery.setup_loader()</tt> runs from your settings file, Celery will
<a class="reference external" href="http://docs.celeryproject.org/en/latest/django/first-steps-with-django.html#defining-and-calling-tasks">look through</a> your <tt class="docutils literal">INSTALLED_APPS</tt> for <tt class="docutils literal">tasks.py</tt> modules, find the
functions marked as tasks, and register them for use as tasks.</p>
<p>Marking a function as a task doesn't prevent calling it normally. You
can still call it: <tt class="docutils literal">z = add(1, 2)</tt> and it will work exactly as before. Marking
it as a task just gives you additional ways to call it.</p>
</div>
<div class="section" id="scheduling-it">
<h1>Scheduling it</h1>
<p>Let's start with the simple case we mentioned above. We want to run our task
soon, we just don't want it to hold up our current thread. We can do that by
just adding <tt class="docutils literal">.delay</tt> to the name of our task:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">myapp.tasks</span> <span class="kn">import</span> <span class="n">add</span>

<span class="n">add</span><span class="o">.</span><span class="n">delay</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>

<p>Celery will add the task to its queue (<cite>"worker, please call myapp.tasks.add(2, 2)"</cite>) and return
immediately. As soon as an idle worker sees it at the head of the queue, the
worker will remove it from the queue, then execute it:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">myapp.tasks.add</span>

<span class="n">myapp</span><span class="o">.</span><span class="n">tasks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>

<p><span>.</span></p><div class="section" id="a-warning-about-import-names">
<h2>A warning about import names</h2>
<p>It's important that your task is always imported and refered to using the
<a class="reference external" href="http://docs.celeryproject.org/en/latest/userguide/tasks.html#task-naming-relative-imports">same package name</a>.
For example, depending on how your Python path is set up,
it might be possible to refer to it as either
<tt class="docutils literal">myproject.myapp.tasks.add</tt> or <tt class="docutils literal">myapp.tasks.add</tt>.  Or from
<tt class="docutils literal">myapp.views</tt>, you might import it as <tt class="docutils literal">.tasks.add</tt>. But Celery has no
way of knowing those are all the same task.</p>
<p><tt class="docutils literal">djcelery.setup_loader()</tt> will register your task using the package name
of your app in <tt class="docutils literal">INSTALLED_APPS</tt>, plus <tt class="docutils literal">.tasks.functionname</tt>. Be sure
when you schedule your task, you also import it using that same name, or
very confusing bugs can occur.</p>
</div>
</div>
<div class="section" id="testing-it">
<h1>Testing it</h1>
<div class="section" id="start-a-worker">
<h2>Start a worker</h2>
<p>As we've already mentioned, a separate process, the <a class="reference external" href="http://docs.celeryproject.org/en/latest/userguide/workers.html">worker</a>, has to be running
to actually execute your Celery tasks.  Here's how we can start a worker for
our development needs.</p>
<p>First, open a new shell or window. In that shell, set up the same Django
development environment - activate your virtual environment, or add
things to your Python path, whatever you do so that you <cite>could</cite> use
<tt class="docutils literal">runserver</tt> to run your project.</p>
<p>Now you can <a class="reference external" href="http://docs.celeryproject.org/en/latest/django/first-steps-with-django.html#starting-the-worker-process">start a worker</a> in that shell:</p>
<div class="highlight"><pre><span class="gp">$</span> python manage.py celery worker --loglevel<span class="o">=</span>info
</pre></div>

<p>The worker will run in that window, and send output there.</p>
</div>
<div class="section" id="run-your-task">
<h2>Run your task</h2>
<p>Back in your first window, start a Django shell and run your task:</p>
<div class="highlight"><pre><span class="gp">$</span> python manage.py shell
<span class="gp">&gt;</span>&gt;&gt; from myapp.tasks import add
<span class="gp">&gt;</span>&gt;&gt; add.delay<span class="o">(</span>2, 2<span class="o">)</span>
</pre></div>

<p>You should see output in the worker window indicating that the worker has
run the task:</p>
<pre class="literal-block">[2013-01-21 08:47:08,076: INFO/MainProcess] Got task from broker: myapp.tasks.add[e080e047-b2a2-43a7-af74-d7d9d98b02fc]
[2013-01-21 08:47:08,299: INFO/MainProcess] Task myapp.tasks.add[e080e047-b2a2-43a7-af74-d7d9d98b02fc] succeeded in 0.183349132538s: 4
</pre>
<p><span>.</span></p></div>
</div>
<div class="section" id="an-example">
<h1>An Example</h1>
<p>Earlier we mentioned using Celery to avoid delaying responding to a web
request. Here's a simplified Django view that uses that technique:</p>
<div class="highlight"><pre><span class="c"># views.py</span>

<span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">form</span> <span class="o">=</span> <span class="n">SomeForm</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">POST</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">form</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">form</span><span class="o">.</span><span class="n">cleaned_data</span>
        <span class="c"># Schedule a task to process the data later</span>
        <span class="n">do_something_with_form_data</span><span class="o">.</span><span class="n">delay</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">render_to_response</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="c"># tasks.py</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">do_something_with_form_data</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">call_slow_web_service</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">'user'</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s">'text'</span><span class="p">],</span> <span class="o">...</span><span class="p">)</span>
</pre></div>

<p><span>.</span></p></div>
<div class="section" id="troubleshooting">
<h1>Troubleshooting</h1>
<p>It can be frustrating trying to get Celery tasks working, because multiple parts
have to be present and communicating with each other. Many of the usual tips
still apply:</p>
<ul class="simple">
<li>Get the simplest possible configuration working first.</li>
<li>Use the python debugger and print statements to see what's going on.</li>
<li>Turn up logging levels (e.g. <tt class="docutils literal"><span class="pre">--loglevel</span> debug</tt> on the worker) to get more insight.</li>
</ul>
<p>There are also some tools that are unique to Celery.</p>
<div class="section" id="eager-scheduling">
<h2>Eager scheduling</h2>
<p>In your Django settings, you can add:</p>
<div class="highlight"><pre><span class="n">CELERY_ALWAYS_EAGER</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>

<p>and Celery will <a class="reference external" href="http://docs.celeryproject.org/en/latest/configuration.html?highlight=eager#std:setting-CELERY_ALWAYS_EAGER">bypass the entire scheduling mechanism</a> and call your code
directly.</p>
<p>In other words, with <tt class="docutils literal">CELERY_ALWAYS_EAGER = True</tt>, these two statements run
just the same:</p>
<div class="highlight"><pre><span class="n">add</span><span class="o">.</span><span class="n">delay</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>

<p>You can use this to get your core logic working before introducing the
complication of Celery scheduling.</p>
</div>
<div class="section" id="peek-at-the-queue">
<h2>Peek at the Queue</h2>
<p>As long as you're using Django itself as your broker for development, your queue
is stored in a Django database. That means you can look at it easily.  Add
a few lines to <tt class="docutils literal">admin.py</tt> in your application:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">kombu.transport.django</span> <span class="kn">import</span> <span class="n">models</span> <span class="k">as</span> <span class="n">kombu_models</span>
<span class="n">site</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">kombu_models</span><span class="o">.</span><span class="n">Message</span><span class="p">)</span>
</pre></div>

<p>Now you can go to <tt class="docutils literal">/admin/django/message/</tt> to see if there are items on the
queue.  Each <cite>message</cite> is a request from Celery for a worker to run a task.
The contents of the message are rather inscrutable, but just knowing if your
task got queued can sometimes be useful.  The messages tend to stay in the
database, so seeing a lot of messages there doesn't mean your tasks aren't
getting executed.</p>
</div>
<div class="section" id="check-the-results">
<h2>Check the results</h2>
<p>Anytime you schedule a task, Celery returns an <a class="reference external" href="http://docs.celeryproject.org/en/latest/reference/celery.result.html#celery.result.AsyncResult">AsyncResult</a> object. You can
save that object, and then use it later to see if the task
has been executed, whether it was successful, and what the result was.</p>
<div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">delay</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ready</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">"Task has run"</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">successful</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">"Result was: </span><span class="si">%s</span><span class="s">"</span> <span class="o">%</span> <span class="n">result</span><span class="o">.</span><span class="n">result</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">"Task failed due to raising an exception"</span>
            <span class="k">raise</span> <span class="n">result</span><span class="o">.</span><span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">"Task failed without raising exception"</span>
 <span class="k">else</span><span class="p">:</span>
     <span class="k">print</span> <span class="s">"Task has not yet run"</span>
</pre></div>

<p><span>.</span></p></div>
</div>
<div class="section" id="periodic-scheduling">
<h1>Periodic Scheduling</h1>
<p>Another common case is running a task on a regular schedule.  Celery implements
this using another process, <a class="reference external" href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">celerybeat</a>. Celerybeat runs continually, and
whenever it's time for a scheduled task to run, celerybeat queues it for
execution.</p>
<p>For obvious reasons, only one celerybeat process should be running (unlike
workers, where you can run as many as you want and need).</p>
<p>Starting celerybeat is similar to starting a worker. Start another window,
set up your Django environment, then:</p>
<div class="highlight"><pre><span class="nv">$ </span>python manage.py celery beat
</pre></div>

<p>There are several ways to tell celery to run a task on a schedule.  We're going
to look at <a class="reference external" href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html#using-custom-scheduler-classes">storing the schedules in a Django database table</a>. This allows you
to easily change the schedules, even while Django and Celery are running.</p>
<p>Add this setting:</p>
<div class="highlight"><pre><span class="n">CELERYBEAT_SCHEDULER</span> <span class="o">=</span> <span class="s">'djcelery.schedulers.DatabaseScheduler'</span>
</pre></div>

<p>You can now add schedules by opening the Django admin and going to
<a class="reference external" href="/admin/djcelery/periodictask/">/admin/djcelery/periodictask/</a>.
See the image above for what
adding a new periodic task looks like, and here's how the fields
are used:</p>
<ul class="simple">
<li><strong>Name</strong> — Any name that will help you identify this scheduled task later.</li>
<li><strong>Task (registered)</strong> — This should give a choice of any of your defined tasks, as long as you've started Django at least once after adding them to your code. If you don't see the task you want here, it's better to figure out why and fix it than use the next field.</li>
<li><strong>Task (custom)</strong> — You can enter the full name of a task here (e.g. <tt class="docutils literal">myapp.tasks.add</tt>), but it's better to use the registered tasks field just above this.</li>
<li><strong>Enabled</strong> — You can uncheck this if you don't want your task to actually run for some reason, for example to disable it temporarily.</li>
<li><strong>Interval</strong> — Use this if you want your task to run repeatedly with a certain delay in between. You'll probably need to use the green "+" to define a new schedule. This is pretty simple, e.g. to run every 5 minutes, set "Every" to 5 and "Period" to minutes.</li>
<li><strong>Crontab</strong> — Use <a class="reference external" href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html#crontab-schedules">crontab</a>, instead of <cite>Interval</cite>, if you want your task to run at specific times.  Use the green "+" and fill in the minute, hour, day of week, day of month, and day of year. You can use "*" in any field in place of a specific value, but be careful - if you use "*" in the Minute field, your task will run every minute of the hour(s) selected by the other fields. Examples: to run every morning at 7:30 am, set Minute to "30", Hour to "7", and the remaining fields to "*".</li>
<li><strong>Arguments</strong> — If you need to pass arguments to your task, you can open this section and set *args and **kwargs.</li>
<li><strong>Execution Options</strong> — Advanced settings that we won't go into here.</li>
</ul>
<div class="section" id="default-schedules">
<h2>Default schedules</h2>
<p>If you want some of your tasks to have default schedules, and not have
to rely on someone setting them up in the database after installing
your app, you can use Django fixtures to provide your schedules as
<a class="reference external" href="https://docs.djangoproject.com/en/1.3/howto/initial-data/#providing-initial-data-with-fixtures">initial data</a> for your app.</p>
<ul class="simple">
<li>Set up the schedules you want in your database.</li>
<li>Dump the schedules in json format:</li>
</ul>
<div class="highlight"><pre><span class="nv">$ </span>python manage.py dumpdata djcelery --indent<span class="o">=</span><span class="m">2</span> --exclude<span class="o">=</span>djcelery.taskmeta &gt;filename.json
</pre></div>

<ul class="simple">
<li>Create a <tt class="docutils literal">fixtures</tt> directory inside your app</li>
<li>If you never want to edit the schedules again, you can copy your json file
to <tt class="docutils literal">initial_data.json</tt> in your fixtures directory. Django will load it
every time <tt class="docutils literal">syncdb</tt> is run, and you'll either get errors or lose your
changes if you've edited the schedules in your database.  (You can
still add new schedules, you just don't want to change the ones that
came from your initial data fixture.)</li>
<li>If you just want to use these as the initial schedules, name your file
something else, and load it when setting up a site to use your app:</li>
</ul>
<div class="highlight"><pre><span class="nv">$ </span>python manage.py loaddata &lt;your-app-label/fixtures/your-filename.json
</pre></div>

<p><span>.</span></p></div>
</div>
<div class="section" id="hints-and-tips">
<h1>Hints and Tips</h1>
<div class="section" id="don-t-pass-model-objects-to-tasks">
<h2>Don't pass model objects to tasks</h2>
<p>Since tasks don't run immediately, by the time a task runs and looks at
a model object that was passed to it, the corresponding record in the
database might have changed. If the task then does something to the model
object and saves it, those changes in the database are overwritten by
older data.</p>
<p>It's almost always safer to save the object, pass the record's key, and look
up the object again in the task:</p>
<div class="highlight"><pre><span class="n">myobject</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="n">mytask</span><span class="o">.</span><span class="n">delay</span><span class="p">(</span><span class="n">myobject</span><span class="o">.</span><span class="n">pk</span><span class="p">)</span>

<span class="o">...</span>


<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">mytask</span><span class="p">(</span><span class="n">pk</span><span class="p">):</span>
    <span class="n">myobject</span> <span class="o">=</span> <span class="n">MyModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="n">pk</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>

<p><span>.</span></p></div>
<div class="section" id="schedule-tasks-in-other-tasks">
<h2>Schedule tasks in other tasks</h2>
<p>It's perfectly all right to schedule one task while executing another.
This is a good way to make sure the second task doesn't run until the
first task has done some necessary work first.</p>
</div>
<div class="section" id="don-t-wait-for-one-task-in-another">
<h2>Don't wait for one task in another</h2>
<p>If a task waits for another task, the first task's worker is blocked
and cannot do any more work until the wait finishes. This is likely
to lead to a deadlock, sooner or later.</p>
<p>If you're in Task A and want to schedule Task B, and after Task B
completes, do some more work, it's better to create a Task C to
do that work, and have Task B schedule Task C when it's done.</p>
</div>
</div>
<div class="section" id="next-steps">
<h1>Next Steps</h1>
<p>Once you understand the basics, parts of the Celery User's Guide are
good reading.  I recommend these chapters to start with; the others are
either not relevant to Django users or more advanced:</p>

</div>
<div class="section" id="using-celery-in-production">
<h1>Using Celery in production</h1>
<p>The Celery configuration described here is for convenience in development,
and should never be used in production.</p>
<p>The most important change to make in production is to stop using
<cite>kombu.transport.django</cite> as the broker, and switch to <a class="reference external" href="http://www.rabbitmq.com">RabbitMQ</a> or
something equivalent that is robust and scalable.</p>
</div>
</div>

  </div></body></html>