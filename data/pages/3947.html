<html><body><div><div class="content html_format">
      <h4>Предыстория</h4><p>
Хотелось создать своего робота, а так же автоматизировать управление светом и климатом дома. С этой целью начал изучать имеющиеся возможности. Для себя я разделил все решения на две группы: системы в которых код на контроллере выполняется в одном главном цикле (arduino, lego и т.п.) и системы состоящие из параллельно работающих процессов обменивающихся между собой сообщениями.</p><p>
Интуитивно выбрал вторую группу, так как хотелось найти максимально простое решение с дружественным пользовательским интерфейсом. Из наиболее популярных представителей этого «семейства» очень понравились </p><a href="https://ru.wikipedia.org/wiki/Microsoft_Robotics_Developer_Studio">Microsoft Robotics Studio</a><p> и </p><a href="http://robocraft.ru/blog/robosoft/721.html">ROS</a><p>. Но к сожалению, на текущий момент, привязать их к конкретному железу весьма не просто, да и разобраться в них с нуля так же весьма не тривиальная задача. В итоге принял решение писать сам, но «кодить» на C очень не хотелось, Душа просила чего-нибудь попроще и полегче. В итоге выбрал Python. А учитывая, что по мимо робота и «умного дома» в голову начало лезть куча других идей, то решил сразу сделать небольшой фреймворк, в котором основной упор был бы сделан на простоту разработки.

</p><h4>Концепция</h4><p>
Концептуально фреймворк представляет собой набор поддерживаемых пользователем модулей реализующих различные функции робототехники. При работе Bubot строит сеть из процессов, которые могут асинхронно получать и отправлять сообщения между собой. Так же вы можете построить сеть из роботов, которые будут общаться между собой.

</p><img src="https://habrastorage.org/getpro/habr/post_images/9c9/13d/b54/9c913db54addf2478103893654bcadf8.png" alt="Bubot - Схема"/>
<p>
Сеть процессов строится на базе стандартного Python модуля multiprocessing. Система обмена сообщениями и разделяемая память реализованы при помощи </p><a href="http://devacademy.ru/posts/vvedenie-v-redis-py/">Redis</a><p>.
</p><p>
Каждый Bubot имеет встроенный веб-сервер веб-сервер </p><a href="http://wiki.python.su/%D0%94%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D0%B8/Tornado-web?highlight=%28%28%D0%94%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D0%B8%7CTornado-web%29%29">Tornado</a><p>, который позволяет контролировать состояние, управлять роботом, на ходу менять параметры (калибровать) робота, а также закладывается возможность обмена данными между роботами.</p><p>
Bubot не является системой реального времени, хотя Bubot возможно интегрировать с кодом реального времени.
</p><a name="habracut"/>

<h4>Hello Bubot</h4><p>
Изучать что-либо новое всегда проще на примере, и первое что приходит в голову, это переделать радиоуправляемую игрушку на управление с помощью веб-интерфейса через wi-fi или 3G.
</p><p>
Для этого нам понадобится любая китайская радиоуправляемая машинка и любой мини компьютер на котором может работать Python 3. В качестве подопытного кролика был приобретен один из самых доступных — raspberry pi b+.
</p><p>
Изначально практически любая радиоуправляемая машинка — это два мотора и примитивный радио модуль. Нам от неё надо только моторы и чтобы сама машинка была подходящего размера для размещения всей электроники.
</p><p>
Для начала упростим задачу — наша машинка должна выполнять четыре действия: ехать вперед или назад, поворачивать влево или вправо.
</p><p>
Для решения поставленной задачи нам необходимо:
</p><ul>
<li> Подключить моторы к raspberry</li>
<li> Реализовать сервис, который будет принимать и интерпретировать команды пользователя на конкретные физические устройства</li>
<li> Реализовать веб интерфейс, который будет передавать команды пользователя: Установить мощность основного или поворотного двигателя -100% / 0% / 100%.</li>
</ul>
<h4>Подключаем моторы</h4><p>
Простейшим способом подключения моторов к Raspberry Pi будет использование готового контроллера, выбор которого зависит только от предполагаемой мощности моторов. Я выбрал с запасом на базе L298N. Строка для поиска на aliexpress «L298N motor driver board», обойдется Вам примерно в $3 с доставкой.

</p><img src="https://habrastorage.org/getpro/habr/post_images/1f0/028/386/1f0028386bacc626ee4cf3a887638c9b.png" alt="Простейший пример - Схема подключения"/>
<p>
Также, для питания raspberry, Вам понадобится как минимум один понижающий преобразователь напряжения. Я взял на базе LM2596. Строка для поиска на aliexpress «DC-DC LM2596», обойдется Вам примерно в $1 с доставкой.
</p><p>
При таком подключении, для чтобы заставить машину выполнить одну из наших команд, достаточно выставить высокий уровень на соответствующем GPIO.

</p><h4>Реализуем модуль мотора</h4><p>
В целях упрощения модели, пусть у нас команды поступают непосредственно на моторы.
</p><p>
Поскольку у нас два одинаковых (с программной точки зрения) мотора, то нам потребуется один модуль. Все модули наследуются либо от базового класса Buject, либо от его потомков. От базового класса разработчик получает основной бесконечный цикл, методы для обработки и передачи событий. Модули в фреймворке находятся в каталоге buject. Каждый модуль состоит из двух файлов:
</p><ul>
<li> [название модуля].py — логика модуля</li>
<li> [название модуля].json — описание модуля. Содержит список параметров модуля, их значения по умолчанию, список возможных статусов, описание сообщений генерируемых модулем, и список сообщений на которые модуль подписан.</li>
</ul><p>
Пример модуля для наших моторов \buject\MotorTest.py:

</p><pre><code class="python">import json
from buject.Buject import Buject
import RPi.GPIO as GPIO

class MotorTest(Buject):  # сервомотор без обратной связи
    def __init__(self, user_config=None):
        super(MotorTest, self).__init__(user_config)

    # Метод вызывается перед запуском основго цикла
    # выставляем режим работы GPIO
    def on_ready(self):    
        GPIO.setmode(self.param["mode"])
        GPIO.setwarnings(False)

    # фреймворк при получения сообщения, вызывает одноименный метод для его обработки
    # передавая ему в качестве параметра все сообщение
    # данный модуль у нас будет уметь принимать только один запрос
    # set_power на установку мощности мотора в процентах    
    def incoming_request_set_power(self, message): 
        data = json.loads(message['data'])

        if data['param']['value'] &gt; 0:  # хотим ехать вперед
            GPIO.setup(self.param['GPIO_reward'], GPIO.OUT, 0)
            GPIO.setup(self.param['GPIO_forward'], GPIO.OUT, 1)
            self.status['action'] = "forward"
        elif data['param']['value'] == 0:
            GPIO.setup(self.param['GPIO_forward'], GPIO.OUT, 0)    
            GPIO.setup(self.param['GPIO_reward'], GPIO.OUT, 0)
            self.status['action'] = "stopped"
        else:
            GPIO.setup(self.param['GPIO_forward'], GPIO.OUT, 0)
            GPIO.setup(self.param['GPIO_reward'], GPIO.OUT, 1)
            self.status['action'] = "backward {0}%".format(self.status["power"])

        # в режиме отладки получаем сообщение, что все отработало
        if self.param['debug'] &gt; 1:  
            self.log('Buject "{0}" {1}'.format(self.param['name'], self.status['action']))
</code></pre><p>
Комментарии, думаю излишни. Приходит запрос, в параметрах которого указана мощность мотора, если она больше нуля говорим мотору ехать вперед, меньше — назад, равна нулю — стоим.
</p><p>
Бесконечный цикл в данном случае задействован не был. В случае его наличия достаточно определить метод main_loop().
</p><p>
Пример описания модуля для наших моторов \buject\Motor.json:

</p><pre><code class="bash">{
    "param": {
        "name": {
            "value": "MotorTest",
            "description": "название сервиса по умолчанию"
        },
        "parent": {
            "value": "Buject",
            "description": "название базового модуля, с которого наследуются другие параметры"
        },
        "buject": {
            "value": "MotorTest",
            "description": "название модуля = имени файла"
        },
        "GPIO_forward": {
            "value": 0,
            "description": "канал GPIO для движения вперед"
        },
        "GPIO_backward": {
            "value": 0,
            "description": "канал GPIO для движения назад"
        },
        "GPIO_mode": {
            "value": 11,
            "description": "value for GPIO.setmode GPIO.BOARD=10 GPIO.BCM=11"
        }
    },
    "incoming_request": {
        "set_power": {
            "name": "set_power",
            "description": "установка мощности мотора",
            "param": {
                "value": {
                    "description": "мощность мотора в процентах",
                    "type": "int"
}   }   }   }   }
</code></pre><p>
Раздел param содержит список параметров необходимых для запуска и работы модуля. Первые три обязательные для каждого модуля, и наследуются от базового класса Buject. Последние являются специфичными только для этого модуля, их количество и название Вы придумываете сами в зависимости от потребностей. GPIO_mode задает режим адресации GPIO и в дальнейшем переопределяться не будет. В то время как для GPIO_forward и GPIO_backward нет смысла задавать значения по умолчанию, т.к. они зависят исключительно от того к каким выводам будет подключен конкретный мотор и мы их определим дальше в параметрах запуска этого модуля.
</p><p>
Также описание модуля может содержать секцию status — где описаны все рассчитываемые параметры — отражающие текущее состояние модуля. В нашем модуле нет никаких добавленных статусов, однако, если Вы обратили внимание, в коде самого модуля мы изменяем статус 'action', который определен в описании базового модуля Buject.
</p><p>
Фреймворк предоставляет возможность использовать пять типов сообщений
</p><ul>
<li> incoming_request — список запросов, которые может обрабатывать модуль.</li>
<li> outgoing_request — список запросов генерируемых модулем. В качестве параметров обязательно указать имя сервиса принимающего запросы и имя запроса.</li>
<li> incoming_event — список подписки на события других модулей, обязательно указать имя сервиса и имя события.</li>
<li> outgoing_event — список событий, на которые могут подписаться другие модули.</li>
<li> incoming_response — служебный тип, который декларируется на исходящем запросе. Говорит о том, что сервис будет ожидать асинхронного ответа на запрос.</li>
</ul>
<h4>Реализуем веб интерфейс</h4><p>
Каждый робот может иметь неограниченное количество веб интерфейсов. В нашем случае, для управления роботом, нам достаточно одного – реализующего 4 кнопки, которые при нажатии будет давать команду, а при отжатии её отменять.
</p><p>
Пользовательские интерфейсы хранятся в каталоге ui. Каждая страница пользовательского интерфейса описывается в отдельном подкаталоге, и состоит как минимум из 2 файлов:
</p><ul>
<li> [Имя страницы].html — разметка страницы.</li>
<li> [Имя страницы].json — описание интерфейса. Каждая страница (сессия) для фреймворка является по сути отдельным сервисом, в данном файле содержится описание событий на которые данная страница подписана, а также сообщения которые она генерирует.</li>
<li> [Имя страницы].py — (не обязателен) может содержать серверную логику по обработке команд данного пользовательского интерфейса, в нашем случае не пригодится.</li>
</ul><p>
Давайте опять, для улучшения восприятия, ещё немного упростим. В приведенном ниже примере рассмотрим алгоритм одной кнопки вперед. Остальные можно сделать по аналогии.
</p><p>
Итак, создаем в каталоге ui подкаталог scout_easy и в нем два файла scout_easy.html и scout_easy.json следующего содержания (комментарии по тексту).
</p><p>
\ui\scout_easy\scout_easy.html
</p><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;link rel="stylesheet" href="/static/jquery-ui-1.11.2/jquery-ui.css"&gt;
    &lt;script type="text/javascript" src="/static/jquery-2.1.3.min.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="/static/jquery-ui-1.11.2/jquery-ui.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="/static/bubot_socket.js"&gt;&lt;/script&gt;
    &lt;title&gt;BuBot&lt;/title&gt;
    &lt;script&gt;
        function bubot_on_open() {
            // функция должна быть определена на каждой странице,
            // вызывается после открытия WebSocketa для того чтобы запросить у сервера
            // начальные данные, пример использования можно посмотреть в ui/studio или ui/scout--&gt;
        }

        function get_bubot_actions() {
            // функция должна быть определена на каждой странице, вызывается при загрузке страницы,
            // содержит объект из функций для обработки входящих сообщений. 
            // Пример использования можно посмотреть в ui/studio или ui/scout--&gt;
            return {};
        }

        $(function () {
            // вешаем обработчики на нашу кнопку
            $("#command_move_forward").button({}).mousedown(function () {

                // описание функции ниже по тексту статьи, 
                // при нажатии устанавливаем мощность мотора 100%
                // при отжатии устанавливаем мощность мотора в 0%--&gt;
                bubot_send_message('send_request', {'name': "set_move_motor_power",
                                                    'data': {'value': 100}});
            }).mouseup(function () {
                bubot_send_message('send_request', {'name': "set_move_motor_power",
                                                    'data': {'value': 0}});
            });
        })
    &lt;/script&gt;
&lt;/head&gt;
&lt;body class="ui-widget-content"&gt;
    &lt;button id="command_move_forward" class="command_button"&gt;forward&lt;/button&gt;
    &lt;div id="console" class="ui-widget-content"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>
Обратите внимание на div id=console, если он присутствует, то в него фреймворк будет выводить все консольные сообщения, в т.ч. происходящие на стороне сервера ошибки кода.
</p><p>
bubot_socket.js — должен присутствовать на каждой странице ui, так как именно он отвечает за установку соединения с сервером и обмен сообщениями.
</p><p>
Соединение с сервером происходит через web socket, метод bubot_send_message([название сообщения], [параметры сообщения]) отвечает за передачу сообщений на сервер. На сервере при поступлении сообщения вызывается одноименный метод, которому передаются параметры сообщения. В нашем случае вызывается метод отправляющий запрос set_move_motor_power, имя сервиса получателя сообщения фреймворк берет из файла описания пользовательского интерфейса, названия этих сервисов определяется в заключительном разделе при описании робота.
</p><p>
\ui\scout_easy\scout_easy.json
</p><pre><code class="bash">{
    "incoming_request": {
        "console": {
            "time": {},
            "message": {}
        }
    },
    "outgoing_request": {
        "set_move_motor_power": {
            "name": "set_power",
            "buject": "move_motor",
            "description": "команда на установку мощности основного мотора",
            "param": {
                "value": {
                    "description": "мощность мотора в процентах, вперед &gt; 0, назад &lt; 0",
                    "type": "int"
                }
            }
        },
        "set_rotate_motor_power": {
            "name": "set_power",
            "buject": "rotate_motor",
            "description": "команда на установку мощности рулевого мотора",
            "param": {
                "value": {
                    "description": "мощность мотора в процентах, вправо &gt; 0, влево &lt; 0",
                    "type": "int"
}   }   }   }   }
</code></pre>
<h4>Запускаем робота</h4><p>
Итак, мы подготовили все части робота. Чтобы его запустить, нужен ещё один файл с описанием самого робота.
</p><p>
В каталоге config хранятся описания всех Ваших роботов. Создавать описание можно как вручную, так и про помощи конфигуратора — но об этом подробнее на видео о bubot: scout.
</p><p>
Итак, для нашего первого робота описание будет выглядеть следующим образом:
</p><p>
\config\scout_easy.json
</p><pre><code class="bash">{
    "param": {
        "name": {
            "value": "scout_easy"
        }
    },
    "depend_buject": {   # раздел содержит список сервисов из которых состоит робот
        "move_motor": { # название сервиса, ниже присваиваем значения только тем параметрам, которые отличаются от значений по умолчанию в соответствующем модуле
            "param": {
                "buject": {  # название модуля из которого будет запущен сервис    
                    "value": "MotorTest"
                },
                "name": {    # название сервиса
                    "value": "move_motor"
                },
                "GPIO_forward": {  # назначаем каналы к которым фактически подключен мотор
                    "value": 20
                },
                "GPIO_reward": {
                    "value": 21
                }
            }
        },
        "rotate_motor": { # аналогично для рулевого мотора
            "param": {
                "buject": {
                    "value": "MotorTest"
                },
                "name": {
                    "value": "rotate_motor"
                },
                "GPIO_forward": {
                    "value": 13
                },
                "GPIO_reward": {
                    "value": 19
}   }   }   }   }
</code></pre><p>
Согласно данному описанию, Bubot при старте создаст два экземпляра модуля MotorTest с разными параметрами: один для основного мотора — move_motor, другой для рулевого мотора -rotate_motor и запустит из в качестве процессов. Как вы видите, способ адресации GPIO мы не указали, т.к. нас устраивает значение по умолчанию, а вот параметры GPIO_forward и GPIO_backward мы переопределили в соответствии со схемой подключения моторов.
</p><p>
Теперь у нас совсем все готово. Можно запускать.
</p><pre><code class="bash">python3 StartBubot scout_easy
</code></pre><p>
Открываем в браузере подготовленный нами пользовательский интерфейс </p><a href="http://localhost/ui/scout_easy">http://localhost/ui/scout_easy</a><p> и пробуем нажать на кнопку. При первом запуске Вас попросят ввести логин и пароль — введите любые значения, по умолчанию права доступа к системе не установлены.

</p><h4>Bubot scout</h4><p>
Если поступательно развивать нашу машинку дальше, то следующий шаг это регулировка оборотов привода, замена рулевого мотора на серву, установка камеры, приводов на камеру, синтезатора речи, распознавание голосовых команд и т.д. </p><a href="http://habrahabr.ru/post/255669/">Но это уже совсем другая история.</a>

<img src="http://wiki.razgovorov.ru/images/thumb/5/5b/Scout_scheme.png/500px-Scout_scheme.png" alt="Bubot: scout - Схема подключения"/>
<img src="http://wiki.razgovorov.ru/images/thumb/d/dd/Scout_buject.png/500px-Scout_buject.png" alt="Bubot: scout - Схема сервисов"/>

<a href="https://sourceforge.net/projects/bubot/">Скачать Bubot</a>
      <p class="clear"/>
    </div>

    
  </div></body></html>