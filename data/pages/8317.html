<html><body><div><div class="section">
              <h1>aio_etcd 0.4.3.1</h1>

              


<p>An asynchronous python client for etcd</p><p>








python-aio-etcd documentation</p><p>=============================</p><p>A python client for Etcd https://github.com/coreos/etcd</p><p>Official documentation: http://python-aio-etcd.readthedocs.org/</p><p>.. image:: https://travis-ci.org/M-o-a-T/python-aio-etcd.png?branch=master</p><p>   :target: https://travis-ci.org/M-o-a-T/python-aio-etcd</p><p>.. image:: https://coveralls.io/repos/M-o-a-T/python-aio-etcd/badge.svg?branch=master&amp;service=github</p><p>   :target: https://coveralls.io/github/M-o-a-T/python-aio-etcd?branch=master</p><p>Installation</p><p>------------</p><p>Pre-requirements</p><p>~~~~~~~~~~~~~~~~</p><p>Install etcd (2.0.1 or later). This version of python-aio-etcd will only work correctly with the version 2.0.x or later.</p><p>This client is known to work with python 3.5. It will not work in older versions of python due to ist use of "async def" syntax.</p><p>Python 2 is not supported.</p><p>From source</p><p>~~~~~~~~~~~</p><p>.. code:: bash</p><p>    $ python setup.py install</p><p>Usage</p><p>-----</p><p>The basic methods of the client have changed compared to previous versions, to reflect the new API structure; however a compatibility layer has been maintained so that you don't necessarily need to rewrite all your existing code.</p><p>Create a client object</p><p>~~~~~~~~~~~~~~~~~~~~~~</p><p>.. code:: python</p><p>    import aio_etcd as etcd</p><p>    client = etcd.Client() # this will create a client against etcd server running on localhost on port 4001</p><p>    client = etcd.Client(port=4002)</p><p>    client = etcd.Client(host='127.0.0.1', port=4003)</p><p>    client = etcd.Client(host='127.0.0.1', port=4003, allow_redirect=False)</p><p>    # wont let you run sensitive commands on non-leader machines, default is true</p><p>    # If you have defined a SRV record for _etcd._tcp.example.com pointing to the clients</p><p>    client = etcd.Client(srv_domain='example.com', protocol="https")</p><p>    # create a client against https://api.example.com:443/etcd</p><p>    client = etcd.Client(host='api.example.com', protocol='https', port=443, version_prefix='/etcd')</p><p>Write a key</p><p>~~~~~~~~~</p><p>.. code:: python</p><p>    await client.write('/nodes/n1', 1)</p><p>    # with ttl</p><p>    await client.set('/nodes/n1', 1)</p><p>    # Equivalent, for compatibility reasons.</p><p>    await client.write('/nodes/n2', 2, ttl=4)</p><p>    # sets the ttl to 4 seconds</p><p>Read a key</p><p>~~~~~~~~~</p><p>.. code:: python</p><p>    (await client.read('/nodes/n2')).value</p><p>    # read a value</p><p>    (await client.get('/nodes/n2')).value</p><p>    # Equivalent, for compatibility reasons.</p><p>    await client.read('/nodes', recursive = True)</p><p>    # get all the values of a directory, recursively.</p><p>Delete a key</p><p>~~~~~~~~~~~~</p><p>.. code:: python</p><p>    await client.delete('/nodes/n1')</p><p>Atomic Compare and Swap</p><p>~~~~~~~~~~~~</p><p>.. code:: python</p><p>    await client.write('/nodes/n2', 2, prevValue = 4)</p><p>    # will set /nodes/n2 's value to 2 only if its previous value was 4</p><p>    await client.write('/nodes/n2', 2, prevExist = False)</p><p>    # will set /nodes/n2 's value to 2 only if the key did not exist before</p><p>    await client.write('/nodes/n2', 2, prevIndex = 30)</p><p>    # will set /nodes/n2 's value to 2 only if the key was last modified at index 30</p><p>    await client.test_and_set('/nodes/n2', 2, 4)</p><p>    #equivalent to client.write('/nodes/n2', 2, prevValue = 4)</p><p>You can also atomically update a result:</p><p>.. code:: python</p><p>    await client.write('/foo','bar')</p><p>    result = await client.read('/foo')</p><p>    print(result.value) # bar</p><p>    result.value += u'bar'</p><p>    updated = await client.update(result)</p><p>    # if any other client wrote to '/foo' in the meantime this will fail</p><p>    print(updated.value) # barbar</p><p>Watch a key</p><p>~~~~~~~~~~~</p><p>.. code:: python</p><p>    result = await client.read('/nodes/n1')</p><p>    # start from a known initial value</p><p>    result = await client.read('/nodes/n1', wait = True, waitIndex = result.modifiedIndex+1)</p><p>    # will wait till the key is changed, and return once it's changed</p><p>    result = await client.read('/nodes/n1', wait = True, waitIndex = 10)</p><p>    # get all changes on this key starting from index 10</p><p>    result = await client.watch('/nodes/n1')</p><p>    # equivalent to client.read('/nodes/n1', wait = True)</p><p>    result = await client.watch('/nodes/n1', index = result.modifiedIndex+1)</p><p>If you want to time out the read() call, wrap it in `asyncio.wait_for`:</p><p>.. code:: python</p><p>    result = await asyncio.wait_for(client.read('/nodes/n1', wait=True), timeout=30)</p><p>Locking module</p><p>~~~~~~~~~~~~~~</p><p>.. code:: python</p><p>    # Initialize the lock object:</p><p>    # NOTE: this does not acquire a lock</p><p>    from aio_etcd.lock import Lock</p><p>    client = etcd.Client()</p><p>    lock = Lock(client, 'my_lock_name')</p><p>    # Use the lock object:</p><p>    await lock.acquire(blocking=True, lock_ttl=None)</p><p>    # will block until the lock is acquired</p><p>    # lock will live until we release it</p><p>    await lock.is_acquired()</p><p>    # returns True</p><p>    # NOTE: This tells you that _somebody_ has the lock</p><p>    await lock.acquire(lock_ttl=60)</p><p>    # renew a lock</p><p>    await lock.release() # release an existing lock</p><p>    await lock.is_acquired()  # False</p><p>    # The lock object may also be used as a context manager:</p><p>    async with Lock(client, 'customer1') as my_lock:</p><p>        do_stuff()</p><p>        await my_lock.is_acquired() # True</p><p>        await my_lock.acquire(lock_ttl = 60) # renew</p><p>    await my_lock.is_acquired() # probably False</p><p>Get machines in the cluster</p><p>~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>.. code:: python</p><p>    machines = await client.machines()</p><p>Get leader of the cluster</p><p>~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>.. code:: python</p><p>    leaderinfo = await client.leader()</p><p>Generate a sequential key in a directory</p><p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>.. code:: python</p><p>    x = await client.write("/dir/name", "value", append=True)</p><p>    print("generated key: " + x.key)</p><p>    # actually the whole path</p><p>    print("stored value: " + x.value)</p><p>List contents of a directory</p><p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>.. code:: python</p><p>    #stick a couple values in the directory</p><p>    await client.write("/dir/name", "value1", append=True)</p><p>    await client.write("/dir/name", "value2", append=True)</p><p>    directory = await client.get("/dir/name")</p><p>    # loop through a directory's children</p><p>    for result in directory.children:</p><p>        print(result.key + ": " + result.value)</p><p>    # or just get the first child value</p><p>    print(directory.next(children).value)</p><p>Development setup</p><p>-----------------</p><p>The usual setuptools commands are available.</p><p>.. code:: bash</p><p>    $ python3 setup.py install</p><p>To test, you should have etcd available in your system path:</p><p>.. code:: bash</p><p>    $ python3 setup.py test</p><p>to generate documentation,</p><p>.. code:: bash</p><p>    $ cd docs</p><p>    $ make</p><p>Release HOWTO</p><p>-------------</p><p>To make a release</p><p>    1) Update release date/version in NEWS.txt and setup.py</p><p>    2) Run 'python setup.py sdist'</p><p>    3) Test the generated source distribution in dist/</p><p>    4) Upload to PyPI: 'python setup.py sdist register upload'

</p><a name="downloads">Â </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>22</span> downloads in the last week
  </li>
  <li>
    <span>185</span> downloads in the last month
  </li>
</ul>









            </div>


          </div></body></html>