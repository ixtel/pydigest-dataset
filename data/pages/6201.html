<html><body><div><div class="article-content">
        

        
        
        
        <p><img src="/_file/blog/orms-under-the-hood/inner-mechanism.png" alt=""/></p>
        
        
        
<p class="article_lead">It often happens that if something is loved, it is also hated with the same power. The idea of object relational mapping fits into this concept perfectly. You will definitely come across many opposite points and fierce discussions as well as unwavering advocates and haters. So if you have ever asked whether to use ORM or not, the answer “it depends” will not be enough.</p>  

<h3>What is an object-relational mapping (ORM)?</h3>

<p>Object-relational mapping refers to synchronization between two different representations of data. From one side, there is a relational database, where the data is represented in terms of tuples, grouped into relations, while in application we manipulate objects.</p>

<p><img src="/_file/blog/orms-under-the-hood/data-representation-in-relational-database.png" alt="How data is represented in a relational database"/></p>
        
<p><img src="/_file/blog/orms-under-the-hood/data-representation-in-object-oriented-programming.png" alt="How data is represented in object-oriented programming"/></p>

<p>Most contemporary applications are built in object oriented technologies like Java or C# and use mostly relational databases to store data. Since it is definitely more convenient when data retrieved from the database can be accessed in the form of objects, there are also many implementations of ORM for many languages and frameworks (<a href="https://en.wikipedia.org/wiki/List_of_object-relational_mapping_software" title="List of object-relational mapping software - Wikipedia, the free encyclopedia" target="_blank">current list</a> is quite huge ).</p>

        <p>There is a big controversy connected to this topic which forces us to ask: What exactly are the benefits of an ORM and what are its detriments? Wading through different blog posts and discussions I will start from the opinion of <strong>Megan Bowra-Dean</strong> (<a href="https://twitter.com/megahbite" title="Megan (@megahbite) | Twitter" target="_blank">@megahbite</a>):</p>
        
        <p class="citation_centered">They’re great 99% of the time in MVC frameworks but that other 1% causes a lot of headaches if you don’t know SQL.</p>
        
        <p>It’s said that ORM allows a developer to completely separate themselves from the database and almost forget about it (apart from situations when database changes need to be performed). Indeed a large number of developers are not very passionate about SQL and database concepts, and they live with the illusion that ORM will handle the job for them. Consequently the database sinks into oblivion till some problem appears. Neglecting the database while using an ORM is a big mistake and causes many problems.</p>

<h3>Why SQL is so important while using an ORM?</h3>

        <p><img src="/_file/blog/orms-under-the-hood/object-first-approach.png" alt="Object first approach"/></p>

<p><img src="/_file/blog/orms-under-the-hood/database-first-approach.png" alt="Database first approach"/></p>

<p>Generally, there are two approaches that are followed. The first one is <strong>“Domain model centric”</strong> in which the code drives database design, while the second one, <strong>“Relational model centric”</strong>, places database design as the first step followed by the code. Both approaches have their pros and cons, but the second one is earning more advocates, mostly due to the <strong>database-first approach</strong> and requirements that are impossible to avoid like knowing about the principles of relational database and SQL.</p>

<p><em>So, what are the most common dangers associated with using ORM and not knowing SQL?</em></p>

        <p><span>Danger 1:</span> Not knowing database data types. This usually involves using too-general data types like ‘text’ type in PostgreSQL for most of the columns. This type is introduced to store strings of unlimited length what is identified with CLOB type. Multiple columns with this type cause an enormous performance challenge.</p>
        
        <p><span>Danger 2:</span> Not knowing constraints. This approach is quite often seen in many database designs. As joins become the most vulnerable case, in this approach they are overused which is extremely inefficient.</p>
        
        <p><span>Danger 3:</span> Not knowing  basic database concepts : for example, not knowing about indexes. Without these smart structures, retrieving data becomes a performance nightmare. A system with data stored in a database with no indexes is a sign of imminent death for the application.</p>

        <p>These three points are some of the many things the beginner developer need to know. A strong enthusiast of SQL and the creator of <a href="http://www.jooq.org/" target="_blank">jOOQ</a> (SQL library for Java) – <strong>Lukas Eder</strong> (<a href="https://twitter.com/lukaseder" title="Lukas Eder (@lukaseder) | Twitter" target="_blank">@lukaseder</a>), confirms a painful truth that many developers don’t know SQL:</p>
        
        <div class="citation_centered"><p>We’re just not exposed to SQL nowadays. But consider this: We developers (or our customers) are paying millions of dollars every year to Oracle, Microsoft, IBM, SAP for their excellent RDBMS, only to ignore 90% of their database features and to perform a little bit of CRUD and a little bit of ACID with ORMs like Hibernate. We have forgotten about why those RDBMS were so expensive in the first place.</p><span>Source: <a href="http://blog.jooq.org/2014/04/29/nosql-no-sql-how-to-calculate-running-totals/" title="NoSQL? No, SQL! – How to Calculate Running Totals | Java, SQL and jOOQ" target="_blank">“NoSQL? No, SQL! – How to Calculate Running Totals”</a></span></div>

<h3>Use only SQL or stay with ORM?</h3>

        <p>The thesis of the article <a href="http://wozniak.ca/what-orms-have-taught-me-just-learn-sql" title="What ORMs have taught me: just learn SQL - Curried lambda" target="_blank">“What ORMs have taught me: just learn SQL”</a> by <strong>Geoff Wozniak</strong>:</p>

        <p class="citation_centered">Attribute creep and excessive use of foreign keys shows me that in order to use ORMs effectively, you still need to know SQL. My contention with ORMs is that, if you need to know SQL, just use SQL since it prevents the need to know how non-SQL gets translated to SQL.</p>
        
       
        <p>This article caused an avalanche of replies and contradictory discussions. Most of them were focusing on abandoning ORM and instead using only SQL or staying with it and suffering from learning both the ORM and SQL. It still appears to be an unresolved problem.</p>

        <p>One of the first-class benefits of ORM is its ease-of-use and the fact that it requires fewer lines of code. It definitely makes development quicker but only in case you’re familiar with a particular ORM. For others, ORM is a waste of time spent resolving persistence related issues. Not knowing it imposes some learning time and cumbersome debugging as a consequence of lack of experience. Indeed, with an ORM, you have no control over what is happening “under the hood.” Sometimes there are many configurations that are difficult to manage efficiently, many weird behaviors and in many cases problems with generating an optimized SQL query with an ORM. And here a common, popular story gets repeated: an ORM presents nice development initially and then there are problems when tracking ORM related bugs and inefficiencies. The statement of fellow ORM developer <strong>Gavin King</strong> – the creator of Hibernate rings true.</p>

        <p><img src="/_file/blog/orms-under-the-hood/3-gavin-king-on-using-hibernate.png" alt="Gavin King on using Hibernate for everything"/></p>

        <p>At this point I could come to the conclusion that ORM is not a universal tool and that all the haters are justified, because ORMs were designed this way on purpose, like the concept of ‘leaky abstraction.’ In his comments on Reddit, Gavin King explains this concept as:</p>
        
        <p class="citation_centered">the leakiness of the ORM abstraction is a feature, not a bug. It’s meant to be that way, because both object model and the relational model are valid ways of looking at the data, and both are useful</p>

        <p class="citation_centered">systems like Hibernate are intentionally designed as leaky abstractions so that it’s possible to easily mix in native SQL where necessary</p>        

        <p><a href="http://blog.jooq.org/2015/08/26/there-is-no-such-thing-as-object-relational-impedance-mismatch/" title="Object-relational impedance mismatch" target="_blank">Feel free to read the great post about object-relational impedance mismatch.</a></p>
        
        <p>Not only Gavin, but many others that have problems with ORMs say that it is connected to not enough knowledge about SQL, relational databases and the relational model instead of the way that ORM works with SQL. The commonly cited example of a developer with “a single object” with 600 attributes and 14 joins perfectly proves this phenomenon.</p>

<h3>How does ORM work?</h3>

<p>The main postulate that characterizes ORM is that it encapsulates database interaction inside an object. One part of the object keeps the data and the second one knows how to deal with the data and transfers it to the relational database (this functionality is implemented inside the ORM engine). </p>


<h3>ORMs design patterns</h3>

        <p>According to <strong>Martin Fowler</strong> (<a href="https://twitter.com/martinfowler" target="_blank">@martinfowler</a>), there are two patterns that were adopted in different object relational mappers.</p>

        <p>The first one is <a href="http://www.martinfowler.com/eaaCatalog/activeRecord.html" title="Patterns of Enterprise Application Architecture: Active Record" target="_blank"><strong>Active Record</strong></a> and it is <em>“An object that wraps a row in a database table or view, encapsulates the database access, and adds domain logic on that data.”</em> It means that a record on a table in a relational database is represented as an object.</p>
        
        <p><img src="/_file/blog/orms-under-the-hood/4-ActiveRecord.gif" alt="Patterns of Enterprise Application Architecture: Active Record"/></p>

        <p><em>Source: <a href="http://www.martinfowler.com/eaaCatalog/activeRecord.html" title="Patterns of Enterprise Application Architecture: Active Record" target="_blank">http://www.martinfowler.com/eaaCatalog/activeRecord.html</a></em></p>

        <p>The second one is a <a href="http://martinfowler.com/eaaCatalog/dataMapper.html" title="Patterns of Enterprise Application Architecture: Data Mapper" target="_blank"><strong>Data Mapper</strong></a>.</p>
        
        <p>According to the official definition, it is <em>“A layer of Mappers that moves data between objects and a database while keeping them independent of each other and the mapper itself.”</em> That means that there is a special layer that separates in-memory objects from the database and its main responsibility is to transfer data between those two layers.</p>

        <p><img src="/_file/blog/orms-under-the-hood/5-DataMapper.gif" alt="Patterns of Enterprise Application Architecture: Data Mapper"/></p>
        
        <p><em>Source: <a href="http://martinfowler.com/eaaCatalog/dataMapper.html" title="Patterns of Enterprise Application Architecture: Data Mapper" target="_blank">http://martinfowler.com/eaaCatalog/dataMapper.html</a></em></p>

<p>There are a lot discussions about the supremacy of one over the other. Generally speaking, the Data Mapper pattern lacks the efficiencies when it comes to CRUD operations. In comparison to the Active Record pattern, the representation of an object is not necessarily a record in the database. The strongest feature of the Data Mapper design is the one API for various data stores (relational and NO SQL databases: external data stores accessed through REST, file based data storage or schema free databases).</p>

<h3>Popular ORMs</h3>
        
        <p>Here is the list of some popular ORMs for the three leading programming languages: Python, Java and PHP.</p>
        
        <p>ORMs using <b>Active Record</b> pattern:</p>
        
        

        
        
        
        <p>ORMs using <b>Data Mapper</b> pattern:</p>
        
        
          
        

<h3>In brief: advantages and disadvantages of using ORM</h3>

<p>Let’s gather together the most important points for and against ORM.</p>

<h4>FOR:</h4>

        <ul>
  <li>let the developer think in terms of objects rather than tables</li>
  <li>no need to write SQL code</li>
  <li>many advanced features like lazy loading</li>
  <li>database independent: No need to write code specific to a particular database</li>
  <li>reduces code and allows developers to focus on their business logic, rather than complex database queries</li>
  <li>various ORMs provide a rich query interface</li>
</ul>

<h4>AGAINST:</h4>

<ul>
  <li>complex (because they handle a bidirectional mapping). Their complexity implies a grueling learning curve – they have a special query language which developers have to learn</li>
  <li>provides only a leaky abstraction over a relational data store</li>
  <li>usually systems using an ORM perform badly (due to naive interactions with the underlying database)</li>
  <li>ORM, by adding a layer of abstraction, speeds up the development but adds overhead to the application</li>
</ul>
        
        <p><img src="/_file/blog/orms-under-the-hood/advantages-and-disadvantages-of-using-orms.png" alt=""/></p>

<p>Depending on your problem domain, the cons may outweigh the pros and so you might just want to stick with straight SQL. It’s important to know when to use and when not to use ORM. </p>

<p>SAY YES TO ORM:</p>

<ul>
  <li>it is intended for OLTP applications</li>
</ul>


<p>SAY NO TO ORM:</p>

<ul>
  <li>not intended for batch processing</li>
  <li>not recommended where there is a need to perform huge analysis</li>
</ul>
        

<h3>ORMs by example</h3>

<p>Considering the below simple model, let’s see how some example usage looks in top ORMs in Python, Java and PHP:</p>
        
        

        

        

        
        
        <p>The ddl for this example looks as follows:</p>

<p/><pre class="brush: sql; toolbar: false">
-- tables
-- Table: client
CREATE TABLE client (
    id int  NOT NULL,
    full_name varchar(255)  NOT NULL,
    email varchar(255)  NOT NULL,
    CONSTRAINT client_pk PRIMARY KEY (id)
);

-- Table: purchase
CREATE TABLE purchase (
    id int  NOT NULL,
    purchase_no char(12)  NOT NULL,
    client_id int  NOT NULL,
    CONSTRAINT purchase_pk PRIMARY KEY (id)
);

-- foreign keys
-- Reference:  client_purchase (table: purchase)


ALTER TABLE purchase ADD CONSTRAINT client_purchase 
    FOREIGN KEY (client_id)
    REFERENCES client (id)
    NOT DEFERRABLE 
    INITIALLY IMMEDIATE 
;
</pre>

<h3>Python</h3>

<p>Let’s start from one of the most-used Python ORM – <a href="http://www.sqlalchemy.org" title="SQLAlchemy - The Database Toolkit for Python" target="_blank">SQLAlchemy</a>. This framework provides an <strong>ORM</strong> with an adopted <strong>Data Mapper pattern</strong>. It contains two parts. The first one is ORM, while the second one is the Core. The Core is a fully featured SQL abstraction toolkit with SQL Expression Language that enable you to write SQL statements via generative Python expressions. Advanced ORM features like unit of work (confines all the database manipulation code to a specific database session that controls the life cycles of every object in that session. Session here is a beefed up version of database transaction), in-memory collections, eager loading of collections via joins and secondary subselects, and other optimizations allow SQLAlchemy’s ORM to emit efficient queries, select rows from not only  tables, but also joins and other select statements and compose it to various Python structures.</p> 

        <p>In order to map tables to Python classes we have to define subclasses of <code>declarative_base()</code>. If you are using <a href="http://www.vertabelo.com" target="_blank" title="Vertabelo. Design your database online">Vertabelo</a> as a database modeling tool, you can provide some automation and generate it using open-source script hosted on <a href="https://github.com/Vertabelo/vertabelo-sqlalchemy" title="Vertabelo/vertabelo-sqlalchemy· GitHub" target="_blank">Github</a>, that takes as an argument the model structure in Vertabelo XML (you can generate it by clicking on XML button in the application). Follow full tutorial <a href="http://www.vertabelo.com/blog/vertabelo-news/visual-design-of-sqlalchemy-models-in-6-steps" title="Visual design of SQLAlchemy models in 6 steps" target="_blank">here</a> or you can simply write the classes by hand.</p>


<p>The model looks as follows:</p>

<p/><pre class="brush: python; toolbar: false">
import sqlalchemy
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, BigInteger,String, ForeignKey, Unicode, Binary, LargeBinary, Time, DateTime, Date, Text, Boolean
from sqlalchemy.orm import relationship, backref, deferred
from sqlalchemy.orm import sessionmaker


Base = declarative_base()

class Purchase (Base):
    __tablename__ = "purchase"
    id = Column('id', Integer, primary_key = True)
    purchase_no = Column('purchase_no', Unicode)
    client_id = Column('client_id', Integer, ForeignKey('client.id'))

    client = relationship('Client', foreign_keys=client_id)

class Client (Base):
    __tablename__ = "client"
    id = Column('id', Integer, primary_key = True)
    full_name = Column('full_name', Unicode)
    email = Column('email', Unicode)
</pre>


<p>To carry out a small investigation of this ORM we will create tables in SQLite database from the generated Python classes and try some Python expressions to perform some insert.</p>

<p>Run the interactive Python console and create a database engine for our database session.</p>

<p/><pre class="brush: python; toolbar: false">
&gt;&gt;&gt; from sqlalchemy import create_engine
&gt;&gt;&gt; engine = create_engine('sqlite:///')
</pre>

<p>Import classes from generated output.py file</p>

<p/><pre class="brush: python; toolbar: false">
&gt;&gt;&gt; from output import *
</pre>

        <p>Create a database session and database tables for classes defined as <code>Client</code> and <code>Purchase</code>.
          The lines provided below will create a <code>session</code> object which will be bound to the sqlite database. All of the database manipulation code and objects will be attached to a database session.</p>

<p/><pre class="brush: python; toolbar: false">
&gt;&gt;&gt; from sqlalchemy.orm import sessionmaker
&gt;&gt;&gt; session = sessionmaker()
&gt;&gt;&gt; session.configure(bind=engine)
&gt;&gt;&gt; Base.metadata.create_all(engine)
</pre>

<p>Any changes performed on a database are done in the context of a session. Multiple changes can be grouped in a session via <code>session.add(object)</code>. To register all the changes in a database, issue a statement <code>db.session.commit()</code>.</p>

<p>Inserting data can be performed in three steps.</p>

<p>Create a session object</p>
        
<ol>
  <li>Create a Python object of <code>Client</code> and <code>Purchase</code> classes</li>
  <li>Add it to the session</li>
  <li>Commit the session</li>
</ol>

<p/><pre class="brush: python; toolbar: false">
&gt;&gt;&gt; s = session()
&gt;&gt;&gt; c = Client(full_name=’client1’, email=’client1@gmail.com’)
&gt;&gt;&gt; p = Purchase(purchase_no=u’abcd123’, client_id=c.id)
&gt;&gt;&gt; s.add(c)
&gt;&gt;&gt; s.add(p)
&gt;&gt;&gt; s.commit()
</pre>

        <p>To retrieve the database objects, we call <code>query()</code> and <code>filter()</code> methods from the database <code>session</code> object.</p>

<p/><pre class="brush: python; toolbar: false">
&gt;&gt;&gt; c = s.query(Client).filter(Client.full_name == 'client1').one()

&gt;&gt;&gt;  c.full_name
 u'client1'

&gt;&gt;&gt; c.email
 u'client1@gmail.com'

&gt;&gt;&gt; p = s.query(Purchase).filter(Purchase.client_id == c.id).one()
&gt;&gt;&gt; p.purchase_no
 u'abcd123'
</pre>
        
        

        <p>Python frameworks to use with SQLAlchemy:</p>

        

<h3>Java</h3>

        <p><strong>jOOQ</strong> – is a database-mapping tool that implements the Active Record pattern, and is commonly considered a “happy medium between ORMs and JDBC”, because it embraces SQL rather than trying to hide it. jOOQ focuses on a <i>relational model centric</i> approach and assumes that database design should drive Java code. One of the features is possibility to construct queries that has similar structure to SQL.</p>

        <p>Via jOOQ you can generate Java classes that model tables, records, sequences, stored procedures and many more. There are three ways to generate the jOOQ classes. You can generate jOOQ classse from the existing database or using Vertabelo-jOOQ integration. Having already prepared the database structure in <a href="http://www.vertabelo.com" target="_blank" title="Vertabelo. Design your database online">Vertabelo</a> you can export it as a Vertabelo XML file and add as a property in  the codegen configuration file (Full tutorial <a href="http://www.vertabelo.com/blog/documentation/jooq-and-vertabelo-getting-started#vertabeloXML" title="jOOQ and Vertabelo - getting started" target="_blank">here</a>) or you can download the model directly from the cloud by providing the Vertabelo API token (model identifier) to the codegen file (full tutorial <a href="http://www.vertabelo.com/blog/documentation/jooq-and-vertabelo-getting-started#vertabeloAPI" title="jOOQ and Vertabelo - getting started" target="_blank">here</a>). More information can be found <a href="http://www.vertabelo.com/blog/vertabelo-news/the-easiest-erd-orm-integration-ever-vertabelo-and-jooq" title="The easiest ERD + ORM integration ever: Vertabelo and jOOQ | Vertabelo blog" target="_blank">here</a>.</p>

<p>For example, an insert for our client-purchase example can be visualized in the code as follows:</p>

<p/><pre class="brush: java; toolbar: false">
// Create a new record
ClientRecord client = create.newRecord(CLIENT);

// Insert the record: INSERT INTO CLIENT VALUES (‘John’, ‘john@gmail.com’)
client.setFullName(‘John’);
client.setEmail(‘john@gmail.com’);
client.store();
</pre>

<p>Or we can loop over the clients returned from SELECT statements and delete those whose full_name is ‘John’.</p>

<p/><pre class="brush: java; toolbar: false">
 for (PurchaseRecord purchase : create .selectFrom(PURCHASE) 
	.where(PURCHASE.CLIENT_ID.in(
 		select(CLIENT.ID)
 		.from(CLIENT)
 		.where(CLIENT.FULL_NAME.equal("John"))
 )) {
 purchase.delete();
 }
</pre>

<h3>PHP</h3>

<p><strong>Propel</strong> – is a PHP ORM with implemented Active Record pattern. It describes the model structure (tables, columns, relationships) in an XML file called the schema and generates classes based on the schema definition of tables. </p>

<p>The schema.xml can be generated by using a <a href="https://github.com/Vertabelo/VertabeloPropel" title="Vertabelo/VertabeloPropel · GitHub" target="_blank">vertabeloPropel</a> script. For more details follow <a href="http://www.vertabelo.com/blog/vertabelo-news/vertabelo-propel-installation-instructions" title="VertabeloPropel – Generate Propel's schema.xml file from Vertabelo" target="_blank">this</a> tutorial.</p>

<p>After generation, the structure of the database schema looks like the following:</p>

<p/><pre class="brush: php; toolbar: false">
&lt;?xml version="1.0"?&gt;
&lt;database name="my_db" defaultIdMethod="native"&gt;
  &lt;table name="purchase"&gt;
    &lt;column name="id" type="INTEGER" sqlType="int" required="true" primaryKey="true"/&gt;
    &lt;column name="purchase_no" type="CHAR" size="12" sqlType="char(12)" required="true"/&gt;
    &lt;column name="client_id" type="INTEGER" sqlType="int" required="true"/&gt;
    &lt;foreign-key foreignTable="client" name="client_purchase" onDelete="none" onUpdate="none"&gt;
      &lt;reference foreign="id" local="client_id"/&gt;
    &lt;/foreign-key&gt;
  &lt;/table&gt;
  &lt;table name="client"&gt;
    &lt;column name="id" type="INTEGER" sqlType="int" required="true" primaryKey="true"/&gt;
    &lt;column name="full_name" type="VARCHAR" size="255" sqlType="varchar(255)" required="true"/&gt;
    &lt;column name="email" type="VARCHAR" size="255" sqlType="varchar(255)" required="true"/&gt;
  &lt;/table&gt;
&lt;/database&gt;
</pre>

<p>Having described the structure, we can generate the SQL code, by issuing:</p>

<p/><pre class="brush: php; toolbar: false">
$ propel sql:build
</pre>

<p>and then generate model classes, by running:</p>

<p/><pre class="brush: php; toolbar: false">
$ propel model:build
</pre>

<p>Adding new data in Propel can be performed in few steps</p>
  <ol>
    <li>Create a Propel object</li>
    <li>Define a value for each column by using <code>setXXX()</code> method</li>
    <li>Call <code>save()</code> method.</li>
  </ol>

<p/><pre class="brush: php; toolbar: false">
$client = new Client();
$client-&gt;setFullName('client1');
$client-&gt;setEmail('client1@gmail.com');
$client-&gt;save();
</pre>

<p>To read a row from a database, we use generated Query object and generated <code>findPK()</code> method.  Reading object properties is done via calling the getter on the column.</p>

<p/><pre class="brush: php; toolbar: false">
$firstClient = ClientQuery::create()-&gt;findPK(1);
echo $firstClient-&gt;getFullName();
</pre>

<p>where line <code>$firstClient = ClientQuery::create()-&gt;findPK(1);</code> issues a simple SQL query.</p>

<p/><pre class="brush: php; toolbar: false">
SELECT client.id, client.full_name, client.email
FROM client
WHERE client.id = 1
LIMIT 1;
</pre>

<p>Yes, the problem of Object Relational Mapping is definitely a hard one. Most of the discussion still keeps revolving around the thoughts: “I would like to have something that lacks typical Hibernate or another ORM defects, but I don’t have a viable replacement. I am not planning to write all the code in pure SQL/JDBC, therefore I will stick to what I know.” The problem of Object Relational Mapping is still unresolved and discussions about it still become a battlefield. <em>How do you handle the ORM problem? When do you say YES or NO to using ORM?</em></p>

      
      </div>
    </div></body></html>