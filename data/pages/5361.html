<html><body><div><div class="postcontent">
                    <p>Well thank you so much. </p>

<p>I actually figured out that numpy.array worked as such for indexes, as i modified locally your code to print a few things for tests, and I understood also the end slice [1::] but I missed that 2D quirk about non zero.</p>

<p>As values are 2*indexes+1, I wondered if it would not be simpler to slice right away an array created with Range(), as I did in a fork, but I quickly saw that it would not be possible for memory sake. And the size on the numbers in the array would also show down the operations if not for memory, I guess. 
So playing with an array of booleans is very elegant and smart:).</p>

<p>I just have a last question i came up with when analyzing the process in the loop. 
The loop just means, if value at index i/2 rounded down is true then remove all multiples of it by turning them to false, from i/2*i to limit by steps of i.</p>

<p>as real values are 2* indexes+1, and primes=2*prime_indexes+1, it means that what is turned to false, indexes of non prime, are too.</p>

<p>Thus for example, when starting from 3, it means that since the sieve[1] /value "3" is true, you turn to False values at sieve [4(.5)::3].</p>

<p>Thus values from (int (i*i/2))*2+1 to  int ((i*i/2)+ni)<em>2+1 
 thus from I² to  (2i(int(i/2+n)+1)) thus (i</em>(i+2n))-1+1; thus (i*(i+2n))</p>

<p>*int (i*i/2)*2=i²-1 being because of j/2 rounded down, then multiplied again by 2, is equivalent to j-1 with j being odd. this apply to the product i*i/2 as well such as j=i*i/2 and to i*i/2 +2ni</p>

<p>Thus we eliminate from i=3 to limits, values equals to i*(i+2n), with n an integer starting from 0 , the loop continuing when n becomes such as i*(i+2n) &gt;limit.
(for i =3, it eliminate values =i*(i+2n)), so with n=0,1,2,3: we have [9,15,21,27]
for i)</p>

<p>This is also implied that since i is increasing, you don't need to start pruning from values inferior to i*i (like i*(i-2), since it already happened unless i is the starting value.</p>

<p>What I still don't understand is why this condition "if sieve[i/2]":</p>

<p>let's say now that i=13. so if sieve[13] is true (value is 27), then remove all indexes /multiples such as 13*6+(13*n) ==13*(6+n)  (equals to values 13*(13+2n))</p>

<p>But sieve [13] is false (it was removed when i was =3). 
Anyway we didn't need to care about n&lt;7 since it has already been done. </p>

<p>But what about values of n =&gt;7? What garanties in the algorithm that you have eliminated these?</p>

<p>169^2 as well as 169*195 are eliminated (I checked for this) but I don't get when/how...</p>

<p>Thanks by advance</p>

                </div>
            </div></body></html>