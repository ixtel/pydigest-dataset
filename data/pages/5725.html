<html><body><div><div class="body"><p>Предисловие.</p><p>Эта статья начинает цикл,который даст набор базовых знаний необходимых для создания заготовки простого Web - приложения.</p><p>Заготовка будет содержать в себе базовый функционал для работы с пользователями(ведь подчас именно пользователи - самая главная часть любой мало-мальски сложной системы).</p><p>Если конкретнее - будет возможность создавать и просматривать профили пользователей,изменять учетные данные и конечно удалять ненужные профили.</p><p>Вся разработка будет вестись с использованием инструментов,технологий и фреймворков которые вы можете легко найти в сети Internet.</p><a name="introduction" class="level3"><br/>Введение</a><p>В этой части разговор пойдет о тестировании и тестах как таковых.Впрочем о тестировании только ленивый не писал и практически любой современный разработчик ПО и приложений(за РЕДКИМ исключением) рано или поздно попытается написать свои тесты.Ведь слова старших товарищей, о том что тесты делают код легко,поддерживаемым,гладким и шелковистым - пленяют разум и заставляют прикоснуться к TDD(Test Driven Development|Разработке через тестирование). Впрочем это выбор каждого - писать тесты или нет,но попробовав раз - возможно вы уже не сможете иначе =).</p><p>Итак...тесты.В первую очередь это удобный способ не проверять вручную что сломалось после новых изменений в приложении.</p><p>В современной реальности тестирование как специализация выделено в отдельное IT - направление.Если соответствующая профессия -  тестировщик ПО и отделы QA(Quality Assurance/Обеспечение_качества). </p><p>В общем - многие люди трудятся,чтоб то чем вы пользуетесь в своем компьютере,планшете или телефоне(например онлайны-игры,социалки и множество других web - приложений) - работали и радовали людей.А не "падали" как Windows 95 от каждого чиха или случайной комбинации клавиш =).</p><p>Тестирование бывает регрессионное,нагрузочное,приемочное и множества других видов и подходов.Но как правило это всё "епархия" именно тестировщиков, а конкретно программист чаще всего пишет unit-тесты.То есть тесты проверяющие работу отдельной сущности в системе(unit'а). Посему и будем рассматривать только их.</p><p>Перед тем как начать читать дальнейшие строки - вы должны понимать что от Вас требуется понимание кода на </p><a href="https://www.python.org/">Python</a><p>,знание что такое </p><a href="http://json.org">JSON</a><p>, </p><a href="http://devdrive.ru/tags/API/">API</a><p> (и зачем оно нужно вообще),желательно базовое понимание HTTP - протокола и взаимодействия построенному с его использование, не помешало бы знание </p><a href="http://flask.pocoo.org/">Flask</a><p>.</p><p>Итак,вы еще здесь?))). Продолжаем, всё не так уж и страшно как кажется на первый взгляд.</p><p>В заголовке темы упоминаются REST и CRUD(да,еще Test,но о нем чуточку попозже).</p><p>REST - это всего архитектурный подход.На эту тему есть множество статей из которых для русскоязычного пользователя могу посоветовать </p><a href="http://habrahabr.ru/post/144011/">эту </a><p> и </p><a href="http://habrahabr.ru/post/144259/">вот эту</a><p> а также почитать книгу  "</p><span>RESTful Web APIs</span><p>".</p><p>CRUD - это акроним от слов </p><span>CREATE</span><p>, </p><span>READ</span><p>, </p><span>UPDATE</span><p>, </p><span>DELETE</span><p> что является лишь операциями над данными,позволяющими ими манипулировать как заблагорассудится (конечно в рамках логики приложения.</p><p>Также это 4 основных операция производимых с базой данных - </p><span>Создать</span><p>,</p><span>Прочитать</span><p>,</p><span>Изменить</span><p>,</p><span>Удалить</span><p> запись из БД.</p><p>Пора бы приступать к тестам....Но сперва небольшая оговорка - тесты пишутся до того как вы написали функциональность,то есть сперва вы проектируете(в голове,на бумаге) как будет себя вести система,какую функциональность она будет иметь,как реагировать на внешние раздражители(запросы к ней). А потом пишете тесты которые по сути являются эмуляторами этих воздействий на систему.То есть буквально создаете  видимость что кто то приходит и дергает за различные "ниточки" системы,нажимает на "рычаги" и "кнопки". При этом никакой системы еще и нет в наличии и ваша эмуляция будет "проваливаться" на каждом тесте.После этого цель - написать систему которая будет удовлетворять созданным тестам. Вот такой вод подход,непривычен на первые разы,но со временем начинаешь понимать пользу,ибо как сказал один человек </p><blockquote> "<i>Something that is untested is broken</i>"(всё что не протестировано - сломается). </blockquote><p>Засим начнём проектировать наше обращение к будущему API (самый базовый костяк необходимо сформировать,пускай даже в виде пустого модуля) . Для формирования набора входных данных используется библиотека </p><a href="https://github.com/joke2k/faker">Faker</a><p> доступная на GitHub.</p><a name="source_code" class="level3">Весь код для теста.</a><pre>import os<br/>import sys<br/>sys.path.insert(0, os.getcwd())<br/>from random import randint<br/>import unittest<br/>import faker<br/>from api import api<br/>from copy import copy<br/>from mongoengine import connect<br/>from flask.ext.testing import TestCase<br/>from users.models import User<br/>from settings.settings import app<br/><br/>db_name = app.config['MONGODB_SETTINGS']['DB']<br/>fake = faker.Faker()<br/>number_user = 10<span>

class TestJsonCRUD(TestCase):
    @staticmethod
<span>    def create_random_user():<br/>        f_name = fake.first_name()<br/>        l_name = fake.last_name()<br/>        user_name = fake.company_email()<br/>        return {'username': user_name, 'f_name': f_name, 'l_name': l_name}<br/><br/>    def setUp(self):<br/>        for _ in range(number_user):<br/>            user = User(**self.create_random_user())<br/>            user.save()<br/><br/>    def create_app(self):<br/>        app.register_blueprint(api)<br/>        return app<br/><span><br/>    def test_create(self):<br/>        """C - create new record"""<br/>        user = self.create_random_user()<br/>        response = self.client.post("/api/v1/users/", data=user)<br/>        self.assertEqual(response.json, user)<br/><br/><br/>    <span>def test_get(self):<br/>        """R - Read record from DB"""<br/>        all_users = self.client.get("/api/v1/users/")<br/>        self.assertEqual(len(all_users.json), number_user)<br/>        random_user = all_users.json[randint(0, number_user - 1)]<br/>        username_random_user = random_user['username']<br/>        response = self.client.get("/api/v1/users/{0}".format(username_random_user))<br/>        self.assertEqual(response.json, random_user)<br/><span><br/>    def test_update_user_full(self):<br/>        """U - Upadte record full"""<br/>        user = self.create_random_user()<br/>        all_users = self.client.get("/api/v1/users/")<br/>        change_user = all_users.json[randint(0, number_user - 1)]<br/>        response = <span>self.client.put("/api/v1/users/{0}".format(change_user['username']), data=user)<br/>        self.assertEqual(response.json, user)<br/><br/><span><br/>    def test_update_user_partly(self):<br/>        """U - Update record partly"""<br/>        user = self.create_random_user()<br/>        all_users = self.client.get("/api/v1/users/")<br/>        change_user = all_users.json[randint(0, number_user - 1)]<br/>        partly_meta_info = copy(user)<br/>        del partly_meta_info['username']<br/>        response = self.client.patch("/api/v1/users/{0}".format(change_user['username']), data=partly_meta_info)<br/>        new_meta_info = partly_meta_info<br/>        new_meta_info['username'] = change_user['username']<br/>        self.assertEqual(response.json, new_meta_info)<br/><br/>    <span><br/><br/>    def test_delete_user(self):<br/>        """D - Delete record"""<br/>        all_users = self.client.get("/api/v1/users/")<br/>        change_user = all_users.json[randint(0, number_user - 1)]<br/>        response = self.client.delete("/api/v1/users/{0}".format(change_user['username']))<br/>        self.assertEqual(response.json, [])<br/>        response = self.client.get("/api/v1/users/")<br/>        self.assertEquals(len(response.json), number_user - 1)  <br/><br/><br/>    <span>def tearDown(self):<br/>        database = connect(db_name)<br/>        database.drop_database(db_name)<br/><br/><br/>if __name__ == '__main__':<br/>    unittest.main()</span></span></span></span></span></span></span></span></span></pre><p>Рассмотрим его более подробно,проанализировав каждый фрагмент:</p><a name="db_setup" class="level3"><br/><br/><br/>Подготовка базы</a><p>Перед каждым тестом  мы создаем пустую  базу данных</p><pre>def create_app(self):<br/>    app.register_blueprint(api)<br/>    return app</pre><p>Генерируем набор случайных данных и заполняем базу ими.</p><pre>def create_random_user():<br/>    f_name = fake.first_name()<br/>    l_name = fake.last_name()<br/>    user_name = fake.company_email()<br/>    return {'username': user_name, 'f_name': f_name, 'l_name': l_name}<br/><br/>def setUp(self):<br/>    for _ in range(number_user):<br/>        user = User(**self.create_random_user())<br/>        user.save()</pre><p>После прхождения/провала теста - мы удаляем базу.Ненадолго,потом опять создадим =)</p><pre>def tearDown(self):<br/>    database = connect(db_name)<br/>    database.drop_database(db_name)</pre><a class="level3" name="crud_in_action"><br/><br/>CRUD в действии</a><p>.</p><p>Случай 1.</p><span>CREATE</span><pre># C-CREATE
def test_create(self):<br/>    user = self.create_random_user()<br/>    response = self.client.post("/api/v1/users/", data=user)<br/>    self.assertEqual(response.json, user)</pre><p>Получаем случайного пользователя,отдаем его данные и сравниваем ответ с ожидаемым.Всё просто =)</p><p>Случай 2.</p><span>READ</span><pre># R - Read
def test_get(self):<br/>    all_users = self.client.get("/api/v1/users/")<br/>    self.assertEqual(len(all_users.json), number_user)<br/>    random_user = all_users.json[randint(0, number_user - 1)]<br/>    username_random_user = random_user['username']<br/>    response = self.client.get("/api/v1/users/{0}".format(username_random_user))<br/>    self.assertEqual(response.json, random_user)</pre><p>Получаем JSON-набор пользователей,сравниваем их количество c тем что было задано в настройках(об этом позже),после чего берем имя случайного пользователя и пробуем прочитать его данные обращаясь к API.</p><p>Случай 3.1 </p><span>UPDATE</span><p> (полное обновление всего профиля)</p><pre># U - UPDATE(Version 1)
<span>def test_update_user_full(self):<br/>    user = self.create_random_user()<br/>    all_users = self.client.get("/api/v1/users/")<br/>    change_user = all_users.json[randint(0, number_user - 1)]  # Get random 
    userresponse = <span>self.client.put("/api/v1/users/{0}".format(change_user['username']), data=user)<br/>    self.assertEqual(response.json, user)</span></span></pre><p>Полностью обновляем данные о пользователе.Ярким примером является случай когда человек решил ВСЁ поменять в жизни,имя,фамилию,</p><strike>политические взгляды</strike><p>,</p><strike>пол</strike><p>,</p><strike>религию</strike><p>,ник на интернет-ресурсах.</p><p>.</p><p>Случай 3.2 </p><span>UPDATE</span><p> (частичное обновление  профиля.Обновляем имя и фамилию,но имя пользователя оставляем прежним)</p><pre># U - UPDATE(Version 2)
<span>def test_update_user_partly(self):<br/>    user = self.create_random_user()<br/>    all_users = self.client.get("/api/v1/users/")<br/>    change_user = all_users.json[randint(0, number_user - 1)]<br/>    partly_meta_info = copy(user)<br/>    del partly_meta_info['username']<br/>    response = self.client.patch("/api/v1/users/{0}".format(change_user['username']), data=partly_meta_info)<br/>    new_meta_info = partly_meta_info<br/>    new_meta_info['username'] = change_user['username']<br/>    self.assertEqual(response.json, new_meta_info)</span></pre><p>Обновляем данные частично,в качестве типичного случая можно рассмотреть  случай когда пользователю не нравится ник или человек сменил фамилию в результате замужества.</p><p>Случай 4. </p><span>DELETE</span><pre># D - DELETE
<span>def test_delete_user(self):<br/>    all_users = self.client.get("/api/v1/users/")<br/>    change_user = all_users.json[randint(0, number_user - 1)]<br/>    response = self.client.delete("/api/v1/users/{0}".format(change_user['username']))<br/>    self.assertEqual(response.json, [])<br/>    response = self.client.get("/api/v1/users/")
    self.assertEquals(len(response.json), number_user - 1)  # Now users less on one</span></pre><p>Удаление всей информации о пользователе,например для случая когда пользователь решил удалить с вашего сайта/сервиса.После удаления пользователя о нем не оставется никакой информации</p><p>Вот и все тесты.Проверка минимальна,но достаточна чтоб понять самые основы тестирования как действия. Дерзайте,и у Вас всё получится =)</p><p>Продолжение и работоспособную версию можно забрать </p><a href="http://devdrive.ru/post/Basis%20design%20web-application.Part%202%20-%20API%2C%20ready%20to%20interact%20with%20other%20parts%20of%20the%20system./">тут</a></div>
        
            </div></body></html>