<html><body><div><div class="content-body tutorial-content tutorial-content-legacy" data-growable-markdown="">
      <h3 id="introduction">Introduction</h3>

<hr/>

<p>CherryPy is an excellent framework to create web-applications and <a href="http://docs.cherrypy.org/dev/progguide/REST.html">APIs</a> of all sizes -- From a “get-started-with-Python” <em>Hello, world!</em> to what can become one of world's one of busiest web sites!</p>

<p>If you are coming from a different language, the process of getting your new application online might appear a little bit unfamiliar when you first start developing using CherryPy.</p>

<p>In this DigitalOcean article, we will go through two good ways of deploying an absolutely solid CherryPy based web application along with managing its dependencies using pip.</p>

<h2 id="glossary">Glossary</h2>

<hr/>

<h3 id="1-cherrypy-and-web-application-deployment-in-brief">1. CherryPy and Web Application Deployment In Brief</h3>

<hr/>

<ol>
<li>Web Application Deployment</li>
<li>WSGI</li>
<li>Using Nginx As A Reverse-Proxy</li>
<li>Python (WSGI) Web Application Servers</li>
<li>CherryPy's Application (HTTP) Server In Brief</li>
<li>uWSGI</li>
</ol>

<h3 id="2-preparing-a-simple-cherrypy-application-with-the-quot-app-quot-object-exposed">2. Preparing A Simple CherryPy Application With The "app" Object Exposed</h3>

<hr/>

<ol>
<li>Creating The Application Structure</li>
<li>Edit “app/<strong>init</strong>.py” using nano</li>
<li>Edit “wsgi.py” using nano</li>
</ol>

<h3 id="3-preparing-the-system-for-cherrypy-deployment">3. Preparing The System For CherryPy Deployment</h3>

<hr/>

<ol>
<li>Updating The System</li>
<li>Setting up Python, pip and virtualenv</li>
<li>python-dev</li>
<li>pip</li>
<li>virtualenv<br/></li>
<li>Downloading And Installing CherryPy</li>
<li>Downloading And Installing uWSGI</li>
</ol>

<h3 id="4-how-to-handle-application-dependencies-using-pip">4. How To Handle Application Dependencies Using pip</h3>

<hr/>

<ol>
<li>Creating A List of Application Dependencies</li>
<li>Downloading From A List of Application Dependencies</li>
</ol>

<h3 id="5-begin-deployment-download-install-and-set-up-nginx">5. Begin Deployment: Download, Install And Set Up Nginx</h3>

<hr/>

<ol>
<li>Installing Nginx</li>
<li>Configuring Nginx</li>
</ol>

<h3 id="6-setting-up-python-wsgi-web-application-servers">6. Setting Up Python WSGI Web Application Servers</h3>

<hr/>

<ol>
<li>Serving Applications Using CherryPy's Own Web-Server [*]</li>
<li>Running and Managing The CherryPy Application Server</li>
<li>Serving Applications Using uWSGI [*]</li>
<li>Running The Server</li>
</ol>

<h2 id="cherrypy-and-web-application-deployment-in-brief">CherryPy and Web Application Deployment In Brief</h2>

<hr/>

<p>CherryPy as a whole is a minimalist Python web application development framework that is not shipped with too many components out-of-the-box, regardless of you wanting them or not. The framework handles all the core necessities you might need (e.g. sessions, caching, file uploads et al.) and leave the rest - and the choice - of what to use and how to use to be decided by <em>you</em>. It separates itself from other Python frameworks with its simplicity to get online using the shipped, ready to deploy <strong>HTTP/1.1-compliant, WSGI thread-pooled Web Server</strong>.</p>

<h3 id="web-application-deployment">Web Application Deployment</h3>

<hr/>

<p>In regards to all Python WSGI web applications, deployments consists of preparing a WSGI module that contains a reference to your application object which is then used as a point of entrance by the web-server to pass the requests.</p>

<p><strong>Note:</strong> However, in case of using CherryPy's own server, the process becomes simpler and you don't particularly need to worry about it.</p>

<p>In our article, we will see two different ways of application deployment:</p>

<ul>
<li><p>Using CherryPy's default web-server, excellent for a majority of applications, and;</p></li>
<li><p>Using another alternative application server (uWSGI) for applications requiring in-depth configuring abilities.</p></li>
</ul>

<h3 id="wsgi">WSGI</h3>

<hr/>

<p>WSGI in a nutshell is an interface between a web server and the application itself. It exists to ensure a standardized way between various servers and applications (frameworks) to work with each other, allowing interchangeability when necessary (i.e. switching from development to production environment), which is a must-have need nowadays.</p>

<p><strong>Note:</strong> If you are interested in learning more about <strong>WSGI</strong> and <strong>Python web servers</strong>, check out our article: <a href="https://www.digitalocean.com/community/articles/a-comparison-of-web-servers-for-python-based-web-applications">A Comparison of Web Servers for Python Based Web Applications</a>.</p>

<h3 id="using-nginx-as-a-reverse-proxy">Using Nginx As A Reverse-Proxy</h3>

<hr/>

<p>Nginx is a very high performant web server / (reverse)-proxy. It has reached its popularity due to being light weight, relatively easy to work with and easy to extend (with add-ons / plug-ins). Thanks to its architecture, it is capable of handling <em>a lot</em> of requests (virtually unlimited), which - depending on your application or website load - could be really hard to tackle using some other, older alternatives.</p>

<blockquote>
<p><strong>Remember:</strong> "Handling" connections technically means <em>not dropping them</em> and being able to serve them with <em>something</em>. You still need your application and database functioning well in order to have Nginx serve clients <em>responses</em> that are not error messages.</p>
</blockquote>

<h3 id="python-wsgi-web-application-servers">Python (WSGI) Web Application Servers</h3>

<hr/>

<p>Python web application servers are [usually] either stand-alone C-based solutions or fully (or partially) Python based (i.e. pure-Python) ones.</p>

<p>They operate by accepting a Python module containing - as previously explained - an application callable to <em>contain</em> the web-application and serve it on a network.</p>

<p>Although some of them are highly capable servers that can be used directly, it is recommended to use Nginx in front for the reasons mentioned above (e.g. higher performance). Similarly, development servers that are usually shipped with web application frameworks are not recommended to be used in production due to their lack of functionality - <em>with a few exceptions, of course</em>!</p>

<p>Some Popular Python WSGI web servers are:</p>

<ul>
<li><p>CherryPy</p></li>
<li><p>Gunicorn</p></li>
<li><p>uWSGI</p></li>
<li><p>waitress</p></li>
</ul>

<h3 id="cherrypy-39-s-application-http-server-in-brief">CherryPy's Application (HTTP) Server In Brief</h3>

<hr/>

<p>CherryPy's pure Python web server is a compact solution which comes with the namesake framework. Defined by the [CherryPy] project as a “high-speed, production ready, thread pooled, generic HTTP server,” it is a modularized component which can be used to serve <strong>any</strong> Python WSGI web application.</p>

<p><strong>CherryPy Web Server's Highlights:</strong></p>



<h3 id="uwsgi">uWSGI</h3>

<hr/>

<blockquote>
<p>The following is an extract from the above mentioned DigitalOcean <a href="https://www.digitalocean.com/community/articles/a-comparison-of-web-servers-for-python-based-web-applications">Python Server Comparison</a> article.</p>
</blockquote>

<p>Despite its very confusing naming conventions, uWSGI itself is a vast project with many components, aiming to provide a full software stack for building <em>hosting services</em>. One of these components, the uWSGI server, runs Python WSGI applications. It is capable of using various protocols, including its own <em>uwsgi wire protocol</em>, which is quasi-identical to SCGI. In order to fulfil the understandable demand to use stand-alone HTTP servers in front of application servers, NGINX and Cherokee web servers are modularized to support uWSGI's [own] best performing uwsgi protocol to have direct control over its processes.</p>

<p><strong>uWSGI Highlights</strong></p>

<ul>
<li><p>uWSGI comes with a WSGI adapter and it fully supports Python applications running on WSGI.</p></li>
<li><p>It links with <em>libpython</em>. It loads the application code on startup and acts like a Python interpreter. It parses the incoming requests and invokes the Python callable.</p></li>
<li><p>It comes with direct support for popular NGINX web server (along with Cherokee* and lighttpd).</p></li>
<li><p>It is written in C.</p></li>
<li><p>Its various components can do much more than running an application, which might be handy for expansion.</p></li>
<li><p>Currently (as of late 2013), it is actively developed and has fast release cycles.</p></li>
<li><p>It has various engines for running applications (asynchronous and synchronous).</p></li>
<li><p>It can mean lower memory footprint to run.</p></li>
</ul>

<h2 id="preparing-a-simple-cherrypy-application-with-the-quot-app-quot-object-exposed">Preparing A Simple CherryPy Application With The "app" Object Exposed</h2>

<hr/>

<p>Let's begin our deployment example with creating a new CherryPy application to use as a sample.</p>

<p><strong>Note:</strong> The application example here uses virtual environment to manage the application files and its dependencies. To learn about <strong>pip</strong> and <strong>virtualenv</strong>, check out our tutorial <a href="https://www.digitalocean.com/community/articles/common-python-tools-using-virtualenv-installing-with-pip-and-managing-packages">Common Python Tools: Using virtualenv, Installing with Pip, and Managing Packages</a>.</p>

<h3 id="creating-the-application-structure">Creating The Application Structure</h3>

<hr/>

<p>We want to work with a simple example that should resemble a very minimalistic but actual application.</p>

<p>For this purpose, we can create something similar to this: </p>
<pre class="code-pre "><code langs="">myy_app
  |-- wsgi.py
  |__ /app
        |-- __init__.py
</code></pre>
<p>First of all, let's create an application folder and an application module:</p>
<pre class="code-pre "><code langs="">mkdir ~/my_app
mkdir ~/my_app/app
</code></pre>
<p>Afterwards, let;s create the application file and the <code>wsgi.py</code> file needed for deployment:</p>
<pre class="code-pre "><code langs="">touch ~/my_app/wsgi.py
touch ~/my_app/app/__init__.py
</code></pre>
<h3 id="edit-“app-init-py”-using-nano">Edit “app/<strong>init</strong>.py” using nano</h3>

<hr/>

<p>We have created the <code>app</code> package to contain our exemplary application module. We can now edit the <code>__init__.py</code> to define it.</p>
<pre class="code-pre "><code langs="">nano ~/my_app/app/__init__.py
</code></pre>
<p>Copy and paste the below script: </p>
<pre class="code-pre "><code langs="">import cherrypy

class Root(object):
    @cherrypy.expose
    def index(self):
        return "Hello, world!"
</code></pre>
<p>Press CTRL+X and confirm with Y to save and exit.</p>

<h3 id="edit-“wsgi-py”-using-nano">Edit “wsgi.py” using nano</h3>

<hr/>

<p>The <code>wsgi.py</code> file will be used to <em>expose</em> an entry point to your application. In our example, inside this file we will import the application module (app) and run it directly using CherryPy's WSGI web server, or, pass it on to uWSGI which will contain it and run.</p>
<pre class="code-pre "><code langs="">nano ~/my_app/wsgi.py
</code></pre>
<p>Copy and paste the below contents: </p>
<pre class="code-pre "><code langs="">import cherrypy
from app import Root

app = cherrypy.tree.mount(Root(), '/')

if __name__=='__main__':

    cherrypy.config.update({
        'server.socket_host': '127.0.0.1',
        'server.socket_port': 8080,
    })

    # Run the application using CherryPy's HTTP Web Server
    cherrypy.quickstart(Root())
</code></pre>
<p>Press CTRL+X and confirm with Y to save and exit.</p>

<h2 id="preparing-the-system-for-cherrypy-deployment">Preparing The System For CherryPy Deployment</h2>

<hr/>

<h3 id="updating-the-system">Updating The System</h3>

<hr/>

<p>In order to have a stable deployment server, it is crucial to keep things up-to-date and well maintained.</p>

<p>To ensure that we have the latest available versions of default applications, we need to update our system.</p>

<p>For Debian Based Systems (i.e. Ubuntu, Debian), run the following:</p>
<pre class="code-pre "><code langs="">aptitude    update
aptitude -y upgrade
</code></pre>
<p>For RHEL Based Systems (i.e. CentOS), run the following:</p>
<pre class="code-pre "><code langs="">yum -y update
</code></pre>
<h3 id="setting-up-python-pip-and-virtualenv">Setting up Python, pip and virtualenv</h3>

<hr/>

<blockquote>
<p><strong>Note for CentOS / RHEL Users:</strong></p>

<p><strong>CentOS / RHEL</strong>, by default, comes as a very lean server. Its toolset, which is likely to be dated for your needs, is <strong>not</strong> there to run your applications but to power the server's system tools (e.g. YUM).</p>

<p>In order to prepare your CentOS system, Python needs to be set up (i.e. compiled from the source) and pip* / virtualenv need installing using that interpreter.</p>

<p>To learn about <strong>How to Set Up Python 2.7.6 and 3.3.3 on CentOS 6.4 and 5.8</strong>, with <strong>pip</strong> and <strong>virtualenv</strong>, please refer to: <a href="https://www.digitalocean.com/community/articles/how-to-set-up-python-2-7-6-and-3-3-3-on-centos-6-4">How to Set Up Python 2.7.6 and 3.3.3 on CentOS</a>.</p>
</blockquote>

<p><strong>On Ubuntu and Debian</strong>, a recent version of Python interpreter which you can use comes by default. It leaves us with only a limited number of additional packages to install:</p>

<ul>
<li><p><strong>python-dev</strong> (development tools),</p></li>
<li><p><strong>pip</strong> (to manage packages),</p></li>
<li><p><strong>virtualenv</strong> (to create isolated, virtual </p></li>
</ul>

<p><strong>Note:</strong> Before continuing with installation of certain applications, especially if building from source, you might need to install essential development tools <em>build-essential</em> using the following command:</p>
<pre class="code-pre "><code langs="">aptitude install -y build-essential
</code></pre>
<h3 id="python-dev">python-dev</h3>

<hr/>

<p>python-dev is an operating-system level package which contains extended development tools for building Python modules.</p>

<p>Run the following command to install python-dev using aptitude:</p>
<pre class="code-pre "><code langs="">aptitude install -y python-dev

# You might need python2.7-dev
# aptitude install -y python2.7-dev
</code></pre>
<h3 id="pip">pip</h3>

<hr/>

<p>pip is a package manager which will help us to install the application packages that we need.</p>

<p>Run the following commands to install pip:</p>
<pre class="code-pre "><code langs="">curl https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py | python -
curl https://raw.github.com/pypa/pip/master/contrib/get-pip.py | python -
export PATH="/usr/local/bin:$PATH"
</code></pre>
<blockquote>
<p>You might need sudo privileges.</p>
</blockquote>

<h3 id="virtualenv">virtualenv</h3>

<hr/>

<p>It is best to contain a Python application within its own <em>environment</em> together with all of its dependencies. An environment can be best described (in simple terms) as an isolated location (a directory) where everything resides. For this purpose, a tool called <strong>virtualenv</strong> is used.</p>

<p>Run the following to install virtualenv using pip:</p>
<pre class="code-pre "><code langs="">sudo pip install virtualenv
</code></pre>
<h3 id="downloading-and-installing-cherrypy">Downloading And Installing CherryPy</h3>

<hr/>

<p>CherryPy framework can be installed using the pip package manager.</p>

<p>Run the following to install <strong>cherrypy</strong> using pip:</p>
<pre class="code-pre "><code langs=""># Install CherryPy Framework and HTTP Web-Server
pip install cherrypy
</code></pre>
<h3 id="downloading-and-installing-uwsgi">Downloading And Installing uWSGI</h3>

<hr/>

<p>It is always the recommended way to contain all application related elements, as much as possible, together inside the virtual environment. So we will download and install uWSGI as such.</p>

<p>If you are <strong>not</strong> working inside an environment, uWSGI will be installed globally (i.e. available systemwide). This is not recommended – always opt for using <strong>virtualenv</strong>.</p>

<p>To install uWSGI using pip, run the following:</p>
<pre class="code-pre "><code langs="">pip install uwsgi
</code></pre>
<h2 id="how-to-handle-application-dependencies-using-pip">How To Handle Application Dependencies Using pip</h2>

<hr/>

<p>Since it is highly likely that you have started the development process on a local machine, when deploying your application, you will need to make sure that all of its dependencies are installed (inside your *virtual environment).</p>

<h3 id="creating-a-list-of-application-dependencies">Creating A List of Application Dependencies</h3>

<hr/>

<p>The simplest way to get the dependencies on the production environment  is by using pip. With a single command, it is capable of generating all the packages (or dependencies) you have installed (within your <strong>activated</strong> environment, if not, <strong>globally</strong> on your system) and again with a single command, it allows you to have them all downloaded and installed.</p>

<p><strong>Note:</strong> This section contains information which is to be executed on your local development machine or from wherever you want to generate the list of application dependencies. This file should be placed inside your application directory and uploaded to your server.</p>

<p>Using "pip" to create a list of installed packages:</p>
<pre class="code-pre "><code langs="">pip freeze &gt; requirements.txt
</code></pre>
<p>This command will create a file called <code>requirements.txt</code> which contains the list of all installed packages. If you run it within a virtualenv, the list will consist of packages installed inside the environment <strong>only</strong>. Otherwise, all packages, installed globally will be listed.</p>

<h3 id="downloading-from-a-list-of-application-dependencies">Downloading From A List of Application Dependencies</h3>

<hr/>

<p>Using pip to install packages from a list:</p>

<p><strong>Note:</strong> This section contains information which is to be executed on your production (i.e. deployment) machine / environment.</p>
<pre class="code-pre "><code langs="">pip install -r requirements.txt
</code></pre>
<p>This command will download and install all the listed packages. If you are working within an activated environment, the files will be downloaded there. Otherwise, they will be installed globally - which is <em>not</em> the recommended way for the reasons explained in the previous sections.</p>

<h2 id="begin-deployment-download-install-and-set-up-nginx">Begin Deployment: Download, Install And Set Up Nginx</h2>

<hr/>

<p>Regardless of the choice of server, our CherryPy application will go online behind Nginx for the reasons we have mentioned in the previous sections. So, let us download and configure Nginx first and continue with working application servers.</p>

<p><strong>Example of a Basic Server Architecture:</strong></p>
<pre class="code-pre "><code langs="">Client Request ----&gt; Nginx (Reverse-Proxy)
                        |
                       /|\                           
                      | | `-&gt; App. Server I.   127.0.0.1:8080 # Our example
                      |  `--&gt; App. Server II.  127.0.0.1:8082
                       `----&gt; App. Server III. 127.0.0.1:8083
</code></pre>
<h3 id="installing-nginx">Installing Nginx</h3>

<hr/>

<blockquote>
<p><strong>Note for CentOS / RHEL Users:</strong></p>

<p>The below instructions will not work on CentOS systems. Please see the instructions <a href="https://www.digitalocean.com/community/articles/how-to-install-nginx-on-centos-6-with-yum">here</a> for CentOS.</p>
</blockquote>

<p>Run the following command to install Nginx using <em>aptitude</em>:</p>
<pre class="code-pre "><code langs="">sudo aptitude install nginx
</code></pre>
<p>To run Nginx, use the following:</p>
<pre class="code-pre "><code langs="">sudo service nginx start
</code></pre>
<p>To stop Nginx, use the following:</p>
<pre class="code-pre "><code langs="">sudo service nginx stop
</code></pre>
<p>To restart Nginx, use the following:</p>
<pre class="code-pre "><code langs=""># After each time you reconfigure Nginx, a restart
# or reload is needed for the new settings to come
# into effect.  
sudo service nginx restart
</code></pre>
<p><strong>Note:</strong> To learn more about Nginx on Ubuntu, please refer to our article: <a href="https://www.digitalocean.com/community/articles/how-to-install-nginx-on-ubuntu-12-04-lts-precise-pangolin">How to Install Nginx on Ubuntu 12.04</a>.</p>

<h3 id="configuring-nginx">Configuring Nginx</h3>

<hr/>

<p><strong>Note:</strong> Below is a shorter tutorial on using Nginx as a reverse proxy. To learn more about Nginx, check out <a href="https://www.digitalocean.com/community/articles/how-to-configure-the-nginx-web-server-on-a-virtual-private-server">How to Configure Nginx Web Server on a VPS</a>.</p>

<p>After choosing and setting up a web server to run our application, we can continue with doing the same with Nginx and prepare it to talk with the back-end server(s) [running the WSGI app].</p>

<p>To achieve this, we need to modify Nginx's configuration file: <code>nginx.conf</code></p>

<p>Run the following command to open up <code>nginx.conf</code> and edit it using nano text editor:</p>
<pre class="code-pre "><code langs="">sudo nano /etc/nginx/nginx.conf
</code></pre>
<p>You can replace the file with the following example configuration to get Nginx work as a reverse-proxy, talking to your application.</p>

<p>Copy and paste the below example configuration:</p>
<pre class="code-pre "><code langs="">worker_processes 1;

events {

    worker_connections 1024;

}

http {

    sendfile on;

    gzip              on;
    gzip_http_version 1.0;
    gzip_proxied      any;
    gzip_min_length   500;
    gzip_disable      "MSIE [1-6]\.";
    gzip_types        text/plain text/xml text/css
                      text/comma-separated-values
                      text/javascript
                      application/x-javascript
                      application/atom+xml;

    # Configuration containing list of application servers
    upstream app_servers {

        server 127.0.0.1:8080;
        # server 127.0.0.1:8081;
        # ..
        # .

    }

    # Configuration for Nginx
    server {

        # Running port
        listen 80;

        # Settings to serve static files 
        location ^~ /static/  {

            # Example:
            # root /full/path/to/application/static/file/dir;
            root /app/static/;

        }

        # Serve a static file (ex. favico)
        # outside /static directory
        location = /favico.ico  {

            root /app/favico.ico;

        }

        # Proxy connections to the application servers
        # app_servers
        location / {

            proxy_pass         http://app_servers;
            proxy_redirect     off;
            proxy_set_header   Host $host;
            proxy_set_header   X-Real-IP $remote_addr;
            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header   X-Forwarded-Host $server_name;

        }
    }
}
</code></pre>
<p>When you are done modifying the configuration, press CTRL+X and confirm with Y to save and exit. You will need to restart Nginx for changes to come into effect.</p>

<p><strong>Run the following to restart Nginx:</strong></p>
<pre class="code-pre "><code langs="">sudo service nginx stop
sudo service nginx start
</code></pre>
<h2 id="setting-up-python-wsgi-web-application-servers">Setting Up Python WSGI Web Application Servers</h2>

<hr/>

<p>Having created a sample application and made our way through managing dependencies, we are ready to begin with the last stage of deployment: setting up servers.</p>

<p>As mentioned above, in this article we will focus on using <strong>CherryPy</strong> and <strong>uWSGI</strong> web application servers behind Nginx.</p>

<h3 id="serving-applications-using-cherrypy-39-s-own-web-server">Serving Applications Using CherryPy's Own Web-Server [*]</h3>

<hr/>

<p>CherryPy's pure Python web server is a compact solution which comes with the framework. It is defined by the project as a “high-speed, production ready, thread pooled, generic HTTP server.”</p>

<p>Since we have developed using the framework, our program inside the <code>wsgi.py</code> is already prepared to start serving upon running it.</p>

<p>Our settings for CherryPy matching our configuration of Nginx:</p>
<pre class="code-pre "><code langs=""># ..

cherrypy.config.update({
    'server.socket_host': '127.0.0.1',
    'server.socket_port': 8080,
})

# ..
</code></pre>
<h3 id="running-and-managing-the-cherrypy-application-server">Running and Managing The CherryPy Application Server</h3>

<hr/>

<p>To start serving your application, you just need to execute <code>server.py</code> using your Python installation.</p>

<p>Run the following to start the server as configured:</p>
<pre class="code-pre "><code langs="">python ~/my_app/wsgi.py
</code></pre>
<p>This will run the server on the foreground. If you would like to stop it, press <strong>CTRL+C</strong>.</p>

<p>To run the server in the background, use the following:</p>
<pre class="code-pre "><code langs="">python ~/my_app/wsgi.py &amp;
</code></pre>
<p>When you run an application in the background, you will need to use a process manager (e.g. htop) to kill (or stop) it.</p>

<h3 id="serving-applications-using-uwsgi">Serving Applications Using uWSGI [*]</h3>

<hr/>

<p>Albeit being extremely capable and powerful, CherryPy's own HTTP server is not for all set ups or deployments. If you require the ability to tune a lot of options to match your desired configuration settings, uWSGI might be the solution for you.</p>

<h3 id="running-the-server">Running The Server</h3>

<hr/>

<p>uWSGI has a lot of options and configurations with many possible ways of using them thanks to its flexibility. Without complicating things from the start, we will begin with working with it as simply as possible and continuing thereon with more advanced methods.</p>

<p><strong>Note:</strong> Make sure to be in the <code>my_app</code> folder before executing the below commands as otherwise uwsgi will not be able to find <code>wsgi.py</code> nor import the application object app.</p>

<p><strong>Simple usage example:</strong></p>
<pre class="code-pre "><code langs="">uwsgi [option] [option 2] .. -w [wsgi file with app. callable]
</code></pre>
<p><strong>To run uWSGI to start serving the application from wsgi.py, run the following:</strong></p>
<pre class="code-pre "><code langs="">uwsgi --socket 127.0.0.1:8080 --protocol=http -w wsgi:app
</code></pre>
<blockquote>
<p>This will run the server on the foreground. If you would like to stop it, press <strong>CTRL+C</strong>.</p>
</blockquote>

<p><strong>To run the server in the background, run the following:</strong></p>
<pre class="code-pre "><code langs="">uwsgi --socket 127.0.0.1:8080 --protocol=http -w wsgi:app &amp;
</code></pre>
<blockquote>
<p>When you run an application in the background, you will need to use a process manager (e.g. htop) to kill (or stop) it. See the section below for more details.</p>
</blockquote>

<p>And that's it! After connecting your application server with Nginx, you can now visit it by going to your droplet's IP address using your favourite browser.</p>
<pre class="code-pre "><code langs="">http://[your droplet's IP adde.]/

# Hello, world!
</code></pre>
<h2 id="further-reading">Further Reading</h2>

<hr/>

<p>If you would like to learn more about Python web-application deployments, you are recommended to check out our following articles on the subject for a better general understanding:</p>





    </div>
</div></body></html>