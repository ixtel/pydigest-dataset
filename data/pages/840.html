<html><body><div><div class="content html_format">
      <i><b>Предисловие от переводчика.</b><br/>
Переводом предыдущих частей этого руководства занимался <a href="https://habrahabr.ru/users/wiygn/" class="user_link">wiygn</a>. С его согласия я продолжаю это дело.</i>
<p>
Это пятая статья в серии, где я описываю свой опыт написания веб-приложения на Python с использованием микрофреймворка Flask.
</p><p>
Цель данного руководства — разработать довольно функциональное приложение-микроблог, которое я за полным отсутствием оригинальности решил назвать microblog.

</p>

<h4>Краткое повторение</h4><p>
В предыдущей части мы создали базу данных и научились заполнять её пользователями и постами, однако этот функционал еще не реализован в нашем приложении. Две главы назад мы узнали, как создавать веб-формы и создали форму для авторизации.
</p><p>
В этой статье мы объединим наши знания о веб-формах и базах данных и напишем свою систему для входа пользователей. В конце данного руководства наше небольшое приложение будет регистрировать новых пользователей и проводить их авторизацию.
</p><p>
Для работы с этой главой ваше приложение должно быть таким, каким мы оставили его в конце предыдущей главы. Пожалуйста, убедитесь, что приложение установлено и работает.

</p><a name="habracut"/>
<h4>Конфигурация</h4><p>
Как и в предыдущих главах, мы начнём с настройки расширений, которые будем использовать. Для авторизации нам понадобятся два расширения — Flask-Login и Flask-OpenID. Настроим их следующим образом </p><i>(файл <code>app/__init__.py</code>)</i><p>:

</p><pre><code class="python">import os
from flask.ext.login import LoginManager
from flask.ext.openid import OpenID
from config import basedir

lm = LoginManager()
lm.init_app(app)
oid = OpenID(app, os.path.join(basedir, 'tmp'))
</code></pre><p>
Расширению Flask-OpenID нужно где-то хранить свои временные файлы, для этого при инициализации ему передаётся путь до папки </p><code>tmp</code><p>.

</p><h4>Функция представления авторизации</h4><p>
Давайте обновим нашу функцию представления </p><i>(файл <code>app/views.py</code></i><p>):

</p><pre><code class="python">from flask import render_template, flash, redirect, session, url_for, request, g
from flask.ext.login import login_user, logout_user, current_user, login_required
from app import app, db, lm, oid
from forms import LoginForm
from models import User, ROLE_USER, ROLE_ADMIN

@app.route('/login', methods = ['GET', 'POST'])
@oid.loginhandler
def login():
  if g.user is not None and g.user.is_authenticated():
      return redirect(url_for('index'))
  form = LoginForm()
  if form.validate_on_submit():
      session['remember_me'] = form.remember_me.data
      return oid.try_login(form.openid.data, ask_for = ['nickname', 'email'])
  return render_template('login.html', 
      title = 'Sign In',
      form = form,
      providers = app.config['OPENID_PROVIDERS'])
</code></pre>
<p>
Обратите внимание, мы импортировали несколько новых модулей, некоторые из которых будут использованы позднее.
</p><p>
Отличий от предыдущей версии немного. Мы добавили новый декоратор для функции отображения. Благодаря </p><code>oid.loginhandler Flask-OpenID</code><p> теперь знает, что это — функция для авторизации.

</p><code>g</code><p> — это глобальный объект Flask, предназначенный для хранения и обмена данными во время жизни запроса. Именно в нём мы будем хранить данные о текущем пользователе. В верхней части тела функции мы проверяем значение </p><code>g.user</code><p>. Если пользователь уже авторизован, мы перенаправляем его на главную страницу. Бессмысленно пытаться еще раз проводить авторизацию в этом случае.
</p><p>
Функция </p><code>url_for</code><p>, которую мы использовали при вызове </p><code>redirect</code><p>, предоставляет возможность получения </p><code>URL</code><p> для переданного ей имени функции представления. Вы, конечно же, можете использовать </p><code>redirect('/index')</code><p>, однако есть </p><a href="http://flask.pocoo.org/docs/quickstart/#url-building">весьма веские причины</a><p> поручить построение </p><code>URL</code><p> специально предназначенной для этого функции.
</p><p>
Мы также обновили код, обрабатывающий данные полученные из формы авторизации. Здесь мы делаем две вещи. Во-первых, мы сохраняем значение поля </p><code>remember_me</code><p> в </p><em>сессии</em><p> Flask (не путайте с </p><code>db.session</code><p> — сессией, предоставленной расширением Flask-SQLAlchemy). Как было сказано выше, объект </p><code>flask.g</code><p> может хранить данные только во время жизни запроса. В то время как </p><code>flask.session</code><p> является более сложным хранилищем. Данные, сохраненные в сессии, будут также доступны во время всех последующих запросов </p><em>от одного клиента</em><p>. Информация хранится до тех пор, пока не будет явно удалена. Такое поведение возможно благодаря тому, что Flask хранит отдельные сессии для </p><em>каждого</em><p> клиента.
</p><p>
Вызов </p><code>oid.try_login</code><p> запускает процесс авторизации с помощью Flask-OpenID. Эта функция принимает два аргумента: </p><code>openid</code><p>, полученный из веб-формы и список полей, которые мы хотели бы получить от провайдера OpenID. Так как наша модель </p><code>User</code><p> имеет атрибуты </p><code>nickname</code><p> и </p><code>email</code><p>, именно эти данные мы и будем запрашивать.
</p><p>
Аутентификация через OpenID проводится асинхронно. Если получен положительный ответ от провайдера, Flask-OpenID вызовет функцию, объявленную с помощью декоратора </p><code>oid.after_login</code><p>. В противном случае пользователь снова вернётся на страницу авторизации.

</p><h4>Обработка ответа от провайдера OpenID</h4><p>
Так выглядит реализация функции </p><code>after_login</code> <i>(файл <code>app/views.py</code>)</i><p>:

</p><pre><code class="python">@oid.after_login
def after_login(resp):
    if resp.email is None or resp.email == "":
        flash('Invalid login. Please try again.')
        return redirect(url_for('login'))
    user = User.query.filter_by(email = resp.email).first()
    if user is None:
        nickname = resp.nickname
        if nickname is None or nickname == "":
            nickname = resp.email.split('@')[0]
        user = User(nickname = nickname, email = resp.email, role = ROLE_USER)
        db.session.add(user)
        db.session.commit()
    remember_me = False
    if 'remember_me' in session:
        remember_me = session['remember_me']
        session.pop('remember_me', None)
    login_user(user, remember = remember_me)
    return redirect(request.args.get('next') or url_for('index'))
</code></pre>
<p>
Аргумент </p><code>resp</code><p>, переданный функции </p><code>after_login</code><p> содержит в себе данные, полученные от провайдера OpenID.
</p><p>
В первую очередь нам необходимо проверить, что в ответе от сервера содержится email пользователя, в противном случае мы не можем его авторизовать. Проверяем, содержится ли полученный email в нашей базе данных. Если ничего не найдено, добавляем нового пользователя в базу. Стоит отметить, что некоторые провайдеры OpenID не предоставляют </p><code>nickname</code><p>, но для нас это не является проблемой, мы можем использовать имя из почты.
</p><p>
После этого мы пытаемся получить значение </p><code>remember_me</code><p> из сессии Flask, это то самое значение, которое мы сохранили в функции представления </p><code>login</code><p>.
</p><p>
Затем мы вызываем функцию </p><code>login_user</code><p> из модуля Flask-Login, чтобы наконец авторизовать пользователя в нашем приложении.
</p><p>
В конце концов мы перенаправляем пользователя по адресу, переданному в атрибуте </p><code>next</code><p>, или же на главную страницу, если такой параметр в запросе отсутствует. Идея параметра </p><code>next</code><p> весьма проста. Допустим, вы хотите сделать некоторые страницы доступными для просмотра только авторизованным пользователям. С помощью Flask-Login такие страницы могут быть обозначены с помощью декоратора </p><code>login_required</code><p>. Если анонимный пользователь попытается открыть такую страницу, он будет автоматически перенаправлен на страницу авторизации, при этом Flask-Login сохранит </p><code>URL</code><p> исходной страницы в параметре </p><code>next</code><p>. Нам останется только отправить пользователя по этому адресу после того, как авторизация будет пройдена.
</p><p>
Для того, чтобы Flask-Login знал куда отправлять пользователей для авторизации, мы должны сообщить ему об этом при инициализации </p><i>(файл <code>app/__init__.py</code>)</i><p>:

</p><pre><code class="python">lm = LoginManager()
lm.init_app(app)
lm.login_view = 'login'
</code></pre>

<h4>Глобальный объект g.user</h4><p>
В функции представления </p><code>login</code><p> мы проверяли состояние </p><code>g.user</code><p>, для того, чтобы определить, не является ли текущий пользователь </p><em>уже</em><p> авторизованным. Чтобы это работало, мы используем событие Flask </p><code>before_request</code><p>. Все функции, объявленные с помощью декоратора </p><code>before_request</code><p> будут запущены непосредственно перед вызовом функции отображения каждый раз, когда получен запрос. Таким образом, вполне логичным будет устанавливать значение </p><code>g.user</code><p> именно здесь </p><i>(файл <code>app/views.py</code>)</i><p>:

</p><pre><code class="python">@app.before_request
def before_request():
    g.user = current_user
</code></pre>
<p>
Это всё, что нам нужно. Flask-Login предоставляет нам доступ к переменной </p><code>current_user</code><p>, мы просто копируем в </p><code>g</code><p> ссылку на это значение, для удобства дальнейшего использования. Теперь текущий пользователь будет доступен везде, даже внутри шаблонов.

</p><h4>Отображение главной страницы</h4><p>
В предыдущей главе мы использовали в функции </p><code>index</code><p> объекты-заглушки, так как у нас еще не было настоящих пользователей и постов. Теперь у нас есть пользователи, самое время это использовать:

</p><pre><code class="python">@app.route('/')
@app.route('/index')
@login_required
def index():
    user = g.user
    posts = [
        { 
            'author': { 'nickname': 'John' }, 
            'body': 'Beautiful day in Portland!' 
        },
        { 
            'author': { 'nickname': 'Susan' }, 
            'body': 'The Avengers movie was so cool!' 
        }
    ]
    return render_template('index.html',
        title = 'Home',
        user = user,
        posts = posts)
</code></pre>
<p>
Мы сделали всего два изменения в этой функции. Во-первых, был добавлен декоратор </p><code>login_required</code><p>. Отныне мы можем быть уверены, что эту страницу увидят только зарегистрированные пользователи.
</p><p>
Во-вторых, мы передаём в шаблон непосредственно объект </p><code>g.user</code><p> вместо заглушки, используемой ранее.
</p><p>
Самое время запустить приложение.
</p><p>
Когда вы перейдете по адресу </p><code><a href="http://localhost"/>localhost:5000</code><p>, вместо главной страницы вы увидите страницу для входа. Авторизация с помощью OpenID проходит с помощью </p><code>URL</code><p>, предоставляемого провайдером. Чтобы не вводить адрес вручную, можно использовать одну из ссылок под текстовым полем.
</p><p>
В процессе авторизации вы будете перенаправлены на сайт провайдера, на котором будет необходимо войти в систему и дать своё разрешение на передачу некоторой информации вашему приложению. При этом будут переданы только те параметры, которые мы запросили, т.е. адрес почты и ник. Никакую приватную информацию, включая пароли, провайдеры OpenID не сообщают.
</p><p>
После этого вы окажетесь на главной странице, теперь уже в качестве авторизованного пользователя.
</p><p>
Можете также поэкспериментировать с флагом </p><code>remember_me</code><p>. Если его включить, вы будете оставаться в системе даже после того, как закроете браузер и откроете его снова.

</p><h4>Выход из системы</h4><p>
Мы реализовали вход, самое время добавить возможность выхода из системы. Это делается очень просто </p><i>(файл <code>app/views.py</code>)</i><p>:

</p><pre><code class="python">@app.route('/logout')
def logout():
    logout_user()
    return redirect(url_for('index'))
</code></pre>
<p>
Помимо этого нам необходимо добавить соответствующую ссылку в шаблон. Расположим её вверху страницы, рядом с другими навигационными ссылками </p><i>(файл <code>app/templates/base.html</code>)</i><p>:
</p><pre><code class="html">&lt;html&gt;
  &lt;head&gt;
    {% if title %}
    &lt;title&gt;{{title}} - microblog&lt;/title&gt;
    {% else %}
    &lt;title&gt;microblog&lt;/title&gt;
    {% endif %}
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;Microblog:
        &lt;a href="{{ url_for('index') }}"&gt;Home&lt;/a&gt;
        {% if g.user.is_authenticated() %}
        | &lt;a href="{{ url_for('logout') }}"&gt;Logout&lt;/a&gt;
        {% endif %}
    &lt;/div&gt;
    &lt;hr&gt;
    {% with messages = get_flashed_messages() %}
    {% if messages %}
    &lt;ul&gt;
    {% for message in messages %}
        &lt;li&gt;{{ message }} &lt;/li&gt;
    {% endfor %}
    &lt;/ul&gt;
    {% endif %}
    {% endwith %}
    {% block content %}{% endblock %}
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>
Видите, насколько это просто! Нам всего лишь надо проверить содержимое </p><code>g.user</code><p>, и если текущий пользователь авторизован, добавить ссылку для выхода. Не забывайте, что вместо прямых адресов лучше использовать </p><code>url_for</code><p> в таких случаях..

</p><h4>Заключительные слова</h4><p>
Теперь у нас есть полноценная система для авторизации пользователей. В следующей главе мы создадим страницу профиля пользователя, и добавим возможность использования аватаров.
</p><p>
Для экономии времени вы можете воспользоваться ссылкой и скачать код приложения, включающий в себя все изменения из данной статьи:</p><p>
Скачать </p><a href="https://github.com/miguelgrinberg/microblog/archive/v0.5.zip">microblog-0.5.zip</a>

<p>
До новых встреч!
</p><p>
Мигель
      </p><p class="clear"/>
    </div>

    
  </div></body></html>