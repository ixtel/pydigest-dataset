<html><body><div><div class="post-text" itemprop="text">
<p>This is a pragmatic, rather than purely mathematical answer.</p>

<p>I think you have two issues - one with layout, the other with your network.</p>

<h3>1. Network</h3>

<p>You have too many edges in your network for it to represent the unit tesseract. <strong><em>Caveat</em></strong> I'm not an expert on the maths here - just came to this from the plotting angle (matplotlib tag).  Please explain if I'm wrong.</p>

<p>Your desired projection and, for instance, the <a href="http://mathworld.wolfram.com/HasseDiagram.html">wolfram mathworld</a> page for a Hasse diagram for n=4 has only 4 edges connected all nodes, whereas you have 6 edges to the 2 and 7 edges to the 3 bit nodes.  Your graph fully connects each "level", i.e. 4-D vectors with 0 <code>1</code> values connect to all vectors with 1 <code>1</code> value, which then connect to all vectors with 2 <code>1</code> values and so on.  This is most obvious in the projection based on the Wikipedia answer (2nd image below)</p>

<h3>2. Projection</h3>

<p>I couldn't find a pre-written algorithm or library to automatically project the 4D tesseract onto a 2D plane, but I did find a couple of examples, <a href="https://en.wikipedia.org/w/index.php?title=Tesseract&amp;section=3#Projections_to_2_dimensions">e.g. Wikipedia</a>.  From this, you can work out a co-ordinate set that would suit you and pass that into the <code>nx.draw()</code> call.</p>

<p>Here is an example - I've included two co-ordinate sets, one that looks like the projection you show above, one that matches <a href="https://en.wikipedia.org/wiki/File:Hypercubeorder_binary.svg">this one from wikipedia</a>.</p>

<pre><code>import networkx as nx
import matplotlib.pyplot as plt
import itertools

H = nx.DiGraph()

axis_labels = ['p','q','r','s']

D_len_node = {}

#Iterate through axis labels
for i in xrange(0,len(axis_labels)+1):
    #Create edge from empty set
    if i == 0:
        for ax in axis_labels:
            H.add_edge('O',ax)
    else:
        #Create all non-overlapping combinations
        combinations = [c for c in itertools.combinations(axis_labels,i)]
        D_len_node[i] = combinations
    #Create edge from len(i-1) to len(i) #eg. pq &gt;&gt;&gt; pqr, pq &gt;&gt;&gt; pqs
    if i &gt; 1:
        for node in D_len_node[i]:
            for p_node in D_len_node[i-1]:
                if set.intersection(set(p_node),set(node)):
                    H.add_edge(''.join(p_node),''.join(node))

#This is manual two options to project tesseract onto 2D plane 
# - many projections are available!!
wikipedia_projection_coords = [(0.5,0),(0.85,0.25),(0.625,0.25),(0.375,0.25),
                                (0.15,0.25),(1,0.5),(0.8,0.5),(0.6,0.5),
                                (0.4,0.5),(0.2,0.5),(0,0.5),(0.85,0.75),
                                (0.625,0.75),(0.375,0.75),(0.15,0.75),(0.5,1)]

#Build the "two cubes" type example projection co-ordinates
half_coords = [(0,0.15),(0,0.6),(0.3,0.15),(0.15,0),
               (0.55,0.6),(0.3,0.6),(0.15,0.4),(0.55,1)]
#make the coords symmetric
example_projection_coords = half_coords + [(1-x,1-y) for (x,y) in half_coords][::-1]

print example_projection_coords


def powerset(s):
    ch = itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s)+1))
    return [''.join(t) for t in ch]

pos={}
for i,label in enumerate(powerset(axis_labels)):
    if label == '':
       label = 'O'
    pos[label]= example_projection_coords[i]

#Show Plot
nx.draw(H,pos,with_labels = True,node_shape = 'o')
plt.show() 
</code></pre>

<p>Note - unless you change what I've mentioned in 1. above, they still have your edge structure, so won't look exactly the same as the examples from the web.  Here is what it looks like with your existing network generation code - you can see the extra edges if you compare it to your example (e.g. I don't this <code>pr</code> should be connected to <code>pqs</code>:</p>

<h3>'Two cube' projection</h3>

<p><img src="http://i.stack.imgur.com/Tz1B3.png" alt="Projection of tesseract generated by code"/></p>

<h3>Wikimedia example projection</h3>

<p><img src="http://i.stack.imgur.com/PNzrM.png" alt="Alternative projection of tesseract generated by code provided"/></p>

<hr/>

<h3>Note</h3>

<p>If you want to get into the maths of doing your own projections (and building up <code>pos</code> mathematically), you might look at <a href="http://www.researchgate.net/profile/Daniela_Velichova/publication/265003103_MODELLING_OF_ORTHOGONAL_PROJECTIONS/links/54328df00cf225bddcc7b9c4.pdf">this research paper</a>.</p>

<hr/>

<h3>EDIT:</h3>

<p>Curiosity got the better of me and I had to search for a mathematical way to do this.  I found <a href="https://andrewharvey4.wordpress.com/2008/10/21/an-introduction-to-hypercubes/">this blog</a> - the main result of which being the projection matrix:</p>

<p><img src="http://i.stack.imgur.com/lveFV.png" alt="4D to 2D projection matrix"/></p>

<p>This led me to develop this function for projecting each label, taking the label containing 'p' to mean the point has value 1 on the 'p' axis, i.e. we are dealing with the unit tesseract.  Thus:</p>

<pre><code>def construct_projection(label):
    r1 = r2 = 0.5
    theta = math.pi / 6
    phi = math.pi / 3
    x = int( 'p' in label) + r1 * math.cos(theta) * int('r' in label) - r2 * math.cos(phi) * int('s' in label)
    y = int( 'q' in label) + r1 * math.sin(theta) * int('r' in label) + r2 * math.sin(phi) * int('s' in label)
    return (x,y)
</code></pre>

<p>Gives a nice projection into a regular 2D octagon with all points distinct.</p>

<p>This will run in the above program, just replace</p>

<pre><code> pos[label] = example_projection_coords[i]
</code></pre>

<p>with</p>

<pre><code>pos[label] = construct_projection(label)
</code></pre>

<p>This gives the result:</p>

<p><img src="http://i.stack.imgur.com/NoNPQ.png" alt="projection onto an octagon"/></p>

<p>play with <code>r1</code>,<code>r2</code>,<code>theta</code> and <code>phi</code> to your heart's content :)</p>
    </div>
    </div></body></html>