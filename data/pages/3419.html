<html><body><div><div class="entry-content">
						<p>Probably many of you have heard of <a href="http://martinfowler.com/articles/microservices.html">Microservices</a>. They are essentially a small single-purpose, API accessible (typically REST) based application. You can build your microservices in a variety of programming languages or just one depending on your needs. Today I want to guide you through a <a href="http://python.org">Python 3</a> microservice that focuses on one thing and is self-contained in the sense of not requiring any external dependencies that need to be installed via <a href="https://pypi.python.org/pypi/pip">PIP</a>.</p>
<p><span id="more-5469"/></p>
<p><strong>Note:</strong> It is my 2015 New Years resolution to write any future articles regarding Python using Python 3.</p>
<p>I’m going to create a new Python 3 project. I use tools <a href="https://github.com/yyuu/pyenv">pyenv</a> to easily switch between Python versions. If you interested on how I setup my development environment <a href="http://www.giantflyingsaucer.com/blog/?p=5082">please see my article on that</a>.</p>
<p><strong>Note:</strong> I keep all my Python projects inside a folder in my home folder called: <strong>PythonProjects</strong></p>
<pre class="brush: plain; title: ; notranslate" title="">
$ cd ~/PythonProjects
$ python3 -m venv mineservice_project
$ cd mineservice_project
$ source bin/activate
$ mkdir mineservice &amp;&amp; cd mineservice
# yes, we are making another folder called mineservice inside the folder mineservice
$ mkdir mineservice
$ touch mineservice/__init__.py
</pre>
<p>The above shell commands will create a Python 3 environment for our project called <strong>mineservice_project</strong> and “turn on” the Python 3 interpreter for it. If we were to install any external packages they would be isolated to this environment and would not pollute the global python packages.</p>
<p>So the next question is: What do we build that could qualify as a microservice? I’ve been playing <a href="https://minecraft.net/">Minecraft</a> for a while with my son and am still learning the “whos” and “whats” of the game so with that in mind we will write a simple microservice that returns the <a href="http://minecraft.gamepedia.com/Mobs">Minecraft mobs</a>. Of course this is a pretty pointless application since one can just hit <a href="http://minecraft.gamepedia.com/Minecraft_Wiki">the wiki</a>, but its easy to grasp and learn from so take it for what it is: something to learn from.</p>
<p>To get this running quickly and with no external PIP packages required I’m going to copy the structure I used in a <a href="http://www.giantflyingsaucer.com/blog/?p=5192">previous article</a>. Also, what I’m going add to this project is an <a href="https://packaging.python.org/en/latest/distributing.html#scripts">entry point</a> for a console script. What this will do is allow people to easily install this application and simply call the console script and voila – instantly its a running service. You could even put something like this onto <a href="https://pypi.python.org/pypi">PyPi</a> and users can PIP install and then simply call the console script. However, we are getting ahead ourselves so let’s start with adding the files we need in the project first.</p>
<p>Grab the <a href="https://raw.githubusercontent.com/bottlepy/bottle/master/bottle.py">bottle.py</a> file and store it inside the project folder named as <strong>mineservice/bottle.py</strong>.</p>
<p>Next, create a file called <strong>mineservice/mtwsgi.py</strong> and save it inside the <strong>mineservice</strong> folder with the <strong>bottle.py</strong> file. Add the following content to <strong>mtwsgi.py</strong> (I’ve modified it from <a href="https://github.com/RonRothman/mtwsgi/blob/master/mtwsgi.py">here</a>):</p>
<pre class="brush: python; title: ; notranslate" title="">
"""
WSGI-compliant HTTP server.  Dispatches requests to a pool of threads.
"""

from wsgiref.simple_server import WSGIServer, WSGIRequestHandler
import multiprocessing.pool

__all__ = ['ThreadPoolWSGIServer', 'make_server']


class ThreadPoolWSGIServer(WSGIServer):
    """
    WSGI-compliant HTTP server. Dispatches requests to a pool of threads.
    """

    def __init__(self, thread_count=None, *args, **kwargs):
        """
        If thread_count == None, we'll use multiprocessing.cpu_count() threads.
        """
        WSGIServer.__init__(self, *args, **kwargs)
        self.thread_count = thread_count
        self.pool = multiprocessing.pool.ThreadPool(self.thread_count)

    # Inspired by SocketServer.ThreadingMixIn.
    def process_request_thread(self, request, client_address):
        try:
            self.finish_request(request, client_address)
            self.shutdown_request(request)
        except:
            self.handle_error(request, client_address)
            self.shutdown_request(request)

    def process_request(self, request, client_address):
        self.pool.apply_async(
            self.process_request_thread, args=(request, client_address))


def make_server(
        host, port, app, thread_count=None, handler_class=WSGIRequestHandler):
    """
    Create a new WSGI server listening on `host` and `port` for `app`
    """
    httpd = ThreadPoolWSGIServer(thread_count, (host, port), handler_class)
    httpd.set_app(app)
    return httpd
</pre>
<p>Now its time to add our <strong>mineservice/app.py</strong> file to the project. This will be where our simple Minecraft Microservice will live. The contents of the file to start off with will look like this:</p>
<pre class="brush: python; title: ; notranslate" title="">
"""
Multithreading Bottle server adapter
"""
from mineservice import bottle
from mineservice import mtwsgi


class MTServer(bottle.ServerAdapter):
    def run(self, handler):
        thread_count = self.options.pop('thread_count', None)
        server = mtwsgi.make_server(
            self.host, self.port, handler, thread_count, **self.options)
        server.serve_forever()


if __name__ == '__main__':
    app = bottle.Bottle()

    @app.route('/')
    def version():
        app_ver = {
            "version": "1.0.0"
        }
        return app_ver

    app.run(server=MTServer, host='0.0.0.0', port=8080, thread_count=3)
</pre>
<p>Run the application now and hit the endpoint: <a href="http://0.0.0.0:8080/">http://0.0.0.0:8080/</a></p>
<p>You should see the following JSON response:</p>
<pre class="brush: plain; title: ; notranslate" title="">
{"version": "1.0.0"}
</pre>
<p><strong>Note:</strong> Bottle will handle setting the <strong>content-type</strong> header to <strong>application/json</strong> for us.</p>
<p>Stop the server and let’s edit the <strong>mineservice/app.py</strong> file some more by adding a little more functionality.</p>
<p>Contents of <strong>mineservice/app.py</strong>:</p>
<pre class="brush: python; title: ; notranslate" title="">
"""
Multithreading Bottle server adapter
"""
from mineservice import bottle
from mineservice import mtwsgi


class MTServer(bottle.ServerAdapter):
    def run(self, handler):
        thread_count = self.options.pop('thread_count', None)
        server = mtwsgi.make_server(
            self.host, self.port, handler, thread_count, **self.options)
        server.serve_forever()


if __name__ == '__main__':
    app = bottle.Bottle()

    mobs = {
        "passive": ["Chicken", "Cow", "Horse", "Ocelot", "Pig", "Sheep",
                    "Bat", "Mushroom", "Squid", "Villager"],
        "neutral": ["Cave Spider", "Enderman", "Spider", "Wolf",
                    "Zombie Pigman"],
        "hostile": ["Blaze", "Creep", "Endermite", "Ghast", "Magma Cube",
                    "Silverfish", "Skeleton", "Slime", "Spider Jockey",
                    "Witch", "Whither Skeleton", "Zombie",
                    "Zombie Villager", "Chicken Jockey", "Killer Bunny",
                    "Guardian", "Elder Guardian"],
        "utility": ["Snow Golem", "Iron Golem"],
        "boss": ["Whither", "Ender Dragon"]
    }

    @app.route('/')
    def version():
        app_ver = {
            "version": "1.0.0"
        }
        return app_ver

    @app.route('/mobs')
    def all_mobs():
        return mobs

    app.run(server=MTServer, host='0.0.0.0', port=8080, thread_count=3)

if __name__ == '__main__':
    main()
</pre>
<p>Run the application now and hit the endpoint to get all the mobs: <a href="http://0.0.0.0:8080/mobs">http://0.0.0.0:8080/</a></p>
<p>You should see the following JSON response (your order may differ):</p>
<pre class="brush: plain; title: ; notranslate" title="">
{
    "boss": [
        "Whither",
        "Ender Dragon"
    ],
    "neutral": [
        "Cave Spider",
        "Enderman",
        "Spider",
        "Wolf",
        "Zombie Pigman"
    ],
    "passive": [
        "Chicken",
        "Cow",
        "Horse",
        "Ocelot",
        "Pig",
        "Sheep",
        "Bat",
        "Mushroom",
        "Squid",
        "Villager"
    ],
    "hostile": [
        "Blaze",
        "Creep",
        "Endermite",
        "Ghast",
        "Magma Cube",
        "Silverfish",
        "Skeleton",
        "Slime",
        "Spider Jockey",
        "Witch",
        "Whither Skeleton",
        "Zombie",
        "Zombie Villager",
        "Chicken Jockey",
        "Killer Bunny",
        "Guardian",
        "Elder Guardian"
    ],
    "utility": [
        "Snow Golem",
        "Iron Golem"
    ]
}
</pre>
<p>What if we want to just return the passive mobs? Turns out that this is pretty simple:</p>
<pre class="brush: python; title: ; notranslate" title="">
@app.route('/mobs/passive')
def passive_mobs():
    return {"passive": mobs['passive']}
</pre>
<p>However it would get tedious to do that same code above for all the mod types. We can instead add a single route for fetching a single mob type like so:</p>
<pre class="brush: python; title: ; notranslate" title="">
@app.route('/mobs/&lt;mob_type&gt;')
def get_mob(mob_type):
    return {mob_type: mobs[mob_type]}
</pre>
<p>So now the <strong>mineservice/app.py</strong> code should look like the following:</p>
<pre class="brush: python; title: ; notranslate" title="">
"""
Multithreading Bottle server adapter
"""
from mineservice import bottle
from mineservice import mtwsgi


class MTServer(bottle.ServerAdapter):
    def run(self, handler):
        thread_count = self.options.pop('thread_count', None)
        server = mtwsgi.make_server(
            self.host, self.port, handler, thread_count, **self.options)
        server.serve_forever()


def main():
    app = bottle.Bottle()

    mobs = {
        "passive": ["Chicken", "Cow", "Horse", "Ocelot", "Pig", "Sheep",
                    "Bat", "Mushroom", "Squid", "Villager"],
        "neutral": ["Cave Spider", "Enderman", "Spider", "Wolf",
                    "Zombie Pigman"],
        "hostile": ["Blaze", "Creep", "Endermite", "Ghast", "Magma Cube",
                    "Silverfish", "Skeleton", "Slime", "Spider Jockey",
                    "Witch", "Whither Skeleton", "Zombie",
                    "Zombie Villager", "Chicken Jockey", "Killer Bunny",
                    "Guardian", "Elder Guardian"],
        "utility": ["Snow Golem", "Iron Golem"],
        "boss": ["Whither", "Ender Dragon"]
    }

    @app.route('/')
    def version():
        app_ver = {
            "version": "1.0.0"
        }
        return app_ver

    @app.route('/mobs')
    def all_mobs():
        return mobs

    @app.route('/mobs/&lt;mob_type&gt;')
    def get_mob(mob_type):
        return {mob_type: mobs[mob_type]}

    app.run(server=MTServer, host='0.0.0.0', port=8080, thread_count=3)

if __name__ == '__main__':
    main()
</pre>
<p>Run that code and try a few different route: <a href="http://0.0.0.0:8080/mobs/hostile">http://0.0.0.0:8080/mobs/hostile</a> or <a href="http://0.0.0.0:8080/mobs/passive">http://0.0.0.0:8080/mobs/passive</a></p>
<p>That works pretty good, but what if someone enters a mob that isn’t in our list like <strong>aggressive</strong>? Unfortunately they will get an <strong>HTTP 500</strong> error. Let’s go ahead and fix that. Modify the <strong>get_mob</strong> function to look like this:</p>
<pre class="brush: python; title: ; notranslate" title="">
@app.route('/mobs/&lt;mob_type&gt;')
def get_mob(mob_type):
    try:
        return {mob_type: mobs[mob_type]}
    except KeyError:
        return {"Error": "{} is not a supported mob type".format(mob_type)}
</pre>
<p>Now when they use an invalid mob type they will see an error (also in JSON format):</p>
<pre class="brush: plain; title: ; notranslate" title="">
{"Error": "aggressive is not a supported mob type"}
</pre>
<p>The final step of our service will be to add a <strong>setup.py</strong> file so we can define an entry point and install this application to run it as a console script. Add the <strong>setup.py</strong> file to the root <strong>mineservice</strong> folder of the project along with the following code:</p>
<pre class="brush: python; title: ; notranslate" title="">
from setuptools import setup
 
setup(
    name='mineservice',
    version='1.0.0',
    packages=['mineservice'],
    entry_points={
        'console_scripts': [
            'mineservice = mineservice.app:main'
        ]
    }
)
</pre>
<p>Save the file and run the following command to install it (normally you won’t be installing into your project workspace but for testing this is fine):</p>
<pre class="brush: plain; title: ; notranslate" title="">
$ python setup.py install
</pre>
<p>Verify the package was installed:</p>
<pre class="brush: plain; title: ; notranslate" title="">
$ pip freeze
</pre>
<p>The result should be:</p>
<pre class="brush: plain; title: ; notranslate" title="">
mineservice==1.0.0
</pre>
<p>Run the service:</p>
<pre class="brush: plain; title: ; notranslate" title="">
$ mineservice
</pre>
<p>The web server should start and you can try the supported routes in your browser like this one: <a href="http://0.0.0.0:8080/mobs/neutral">http://0.0.0.0:8080/mobs/neutral</a></p>
<p>JSON Results:</p>
<pre class="brush: plain; title: ; notranslate" title="">
{"neutral": ["Cave Spider", "Enderman", "Spider", "Wolf", "Zombie Pigman"]}
</pre>
<p>To uninstall mineservice:</p>
<pre class="brush: plain; title: ; notranslate" title="">
$ pip uninstall mineservice
</pre>
<p>So there you have it, the groundwork for a simple Python Microservice. In a future article I plan to show you how to expand on this idea even more and make a Python Microservice that doesn’t even require the host operating system even have Python installed thus creating a very self-contained microservice.</p>
<p><strong>Update Sept. 16: 2015:</strong> – See the self-contained Python article app here: <a href="http://www.giantflyingsaucer.com/blog/?p=5680">http://www.giantflyingsaucer.com/blog/?p=5680</a></p>


											</div>


					</div></body></html>