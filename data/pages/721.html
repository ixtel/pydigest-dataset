<html><body><div><div class="entry-content"><p>Обзор различий синтаксиса python2 и python3.</p><div class="section" id="print"><h2>Print - функция</h2><p>Оператор print был заменён функцией print(), с именованными аргументами для замены большей части синтаксиса старого оператора print. Примеры:</p><pre class="code python3"><span class="n">Python2</span><span class="p">:</span> <span class="nb">print</span> <span class="s2">"The answer is"</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">2</span>
<span class="n">Python3</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">"The answer is"</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

<span class="n">Python2</span><span class="p">:</span> <span class="nb">print</span> <span class="n">x</span><span class="p">,</span>           <span class="c1"># Запятая в конце подавляет перевод строки</span>
<span class="n">Python3</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">" "</span><span class="p">)</span>  <span class="c1"># Добавляет пробел вместо перевода строки</span>

<span class="n">Python2</span><span class="p">:</span> <span class="nb">print</span>              <span class="c1"># Печатает перевод строки</span>
<span class="n">Python3</span><span class="p">:</span> <span class="nb">print</span><span class="p">()</span>            <span class="c1"># Нужно вызвать функцию!</span>

<span class="n">Python2</span><span class="p">:</span> <span class="nb">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">"fatal error"</span>
<span class="n">Python3</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">"fatal error"</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>

<span class="n">Python2</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>       <span class="c1"># Печатает repr((x, y))</span>
<span class="n">Python3</span><span class="p">:</span> <span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>      <span class="c1"># Не путать с print(x, y)!</span></pre><p>Также вы можете настроить разделитель между элементами, например:</p><pre class="code pycon literal-block">
<span class="k"/><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s2">"There are &lt;"</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span> <span class="s2">"&gt; possibilities!"</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">""</span><span class="p">)</span>
<span class="go">There are &lt;4294967296&gt; possibilities!</span></pre><p>Функция print() не поддерживает особенность "программный пробел" старого оператора print. Например, в Python 2, print "A\n", "B" напечатает "A\nB\n"; но в Python 3, print("A\n", "B") напечатает "A\n B\n".</p></div><div class="section" id="id1"><h2>Отображения и итераторы вместо списков</h2><p>Некоторые хорошо известные методы не возвращают <a href="http://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html" target="_blank">списки</a> в Python 3:</p><ul><li>Методы словарей dict.keys(), dict.items() и dict.values() возвращают "отображения" вместо списков. Например, больше не работает: k = d.keys(); k.sort(). Используйте k = sorted(d).</li><li>Соответственно, методы dict.iterkeys(), dict.iteritems() и dict.itervalues() более не поддерживаются.</li><li>map() и filter() возвращают итераторы. Если вам действительно нужен список, быстрым исправлением станет list(map(...)), но часто лучшим исправлением будет использование генераторов списков (особенно когда оригинальный код использует лямбда-выражения), либо переписать код так, чтобы ему не нужен был список как таковой. Особенно сложно, что map() вызывает побочные эффекты функции; правильное преобразование заключается в использовании цикла (создание списка просто расточительно).</li><li>range() теперь ведёт себя как xrange(), но работает со значениями любого размера. xrange() больше не существует.</li><li>zip() возвращает итератор.</li></ul></div><div class="section" id="id2"><h2>Операторы сравнения</h2><p>Python 3 упростил правила для операторов сравнения:</p><p>Операторы сравнения (&lt;, &lt;=, &gt;=, &gt;) поднимают исключение TypeError, когда операнды не упорядочиваемы. Таким образом, выражения типа 1 &lt; '', 0 &gt; None или len &lt;= len более не разрешены, и, например, None &lt; None поднимает TypeError, а не возвращает False. Следствием является то, что сортировка списка с разными типами данных больше не имеет смысла - все элементы должны быть сравнимы друг с другом. Обратите внимание, что это не относится к операторам == и !=: объекты различных несравнимых типов всегда неравны друг другу.</p><p>builtin.sorted() и list.sort() больше не принимают аргумент cmp, обеспечивающий функцию сравнения. Вместо этого используйте аргумент key. Аргументы key и reverse теперь "keyword-only".</p><p>Функция cmp() должна рассматриваться как устаревшая, и специальный метод __cmp__() в Python 3 не поддерживается. Используйте __lt__() для сортировки, __eq__() с __hash__() для сравнения. (Если вам действительно нужна функциональность cmp(), вы можете использовать выражение (a &gt; b) - (a &lt; b) в качестве эквивалента для cmp(a, b).)</p></div><div class="section" id="id3"><h2>Целые числа</h2><ul><li>PEP 0237: long переименован в int.</li><li>PEP 0238: Выражение вида 1/2 возвращает float. Используйте 1//2 для отсечения дробной части. (Этот синтаксис существует с Python 2.2)</li><li>Константа sys.maxint была удалена, с тех пор, как более не существует предела значения целых чисел. Однако, sys.maxsize может быть использован как число, большее любого практического индекса списка или строки. sys.maxsize соответствует "естественному" размеру целого и, как правило, имеет такое же значение, как sys.maxint на той же платформе (при условии одних и те же параметров сборки).</li><li>repr() от длинного целого числа не включает более завершающий символ L, так что код, который безусловно отрезает этот символ, будет отрезать вместо этого последнюю цифру. (Используйте str() вместо этого.)</li><li>Восьмеричные литералы более не имеют формы вида 0720; используйте 0o720.</li></ul></div><div class="section" id="unicode-8"><h2>Текст, Unicode и 8-битные строки</h2><p>Все, что вы знали о бинарных данных и Unicode, изменилось.</p><p>Python 3 использует понятия текста и (бинарных) данных вместо строк Unicode и 8-битных строк. Весь текст - Unicode; Однако кодированные Unicode строки представлены ​​в виде двоичных данных. Тип , используемый для хранения текста является <a href="http://pythonworld.ru/tipy-dannyx-v-python/stroki-literaly-strok.html" target="_blank">str</a>, тип, используемый для хранения данных - <a href="http://pythonworld.ru/tipy-dannyx-v-python/bajty-bytes-i-bytearray.html" target="_blank">bytes</a>. Самое большое различие с python 2.x является то, что любая попытка комбинировать текст и данные в Python 3.0 поднимает TypeError, в то время как если бы вы смешивали Unicode и 8-битные строки в Python 2.x, это будет работать, если 8-битная строка содержала только 7-битные (ASCII) символы, но вы получите UnicodeDecodeError, если она содержит не-ASCII символы. Такое поведение вызывало многочисленные скорбные лица на протяжении многих лет.</p><p>Как следствие этого изменения в философии, значительная часть кода, который использует Unicode, кодировки или бинарные данные, скорее всего, должна измениться. Это изменения к лучшему, так как в python 2.x были многочисленные ошибки, имеющие отношение к смешиванию закодированного и декодированного текста. Чтобы быть подготовленным к этому, в Python 2.x следует начать использовать Unicode для всего незакодированного текста, и str только для бинарных или закодированных данных . Затем инструмент 2to3 будет делать большую часть работы за вас.</p><p>Вы можете больше не использовать литерал u"..." для текста Unicode. Тем не менее, вы должны использовать литерал b"..." для бинарных данных.</p><p>Так как str и bytes не могут быть смешаны, вы всегда должны их явно преобразовывать. Используйте str.encode(), чтобы перейти от str к bytes и bytes.decode(), чтобы перейти от bytes к str. Вы также можете использовать bytes(s, encoding=...) и str(b, encoding=...), соответственно.</p><p>Как str, тип bytes неизменен. Существует отдельный изменяемый тип для двоичных данных, bytearray. Почти все функции, которые принимают bytes также принимают bytearray.</p><p>Все обратные косые черты в "сырых" строковых литералах интерпретируются буквально. Это означает, что "\U" и "\u" в сырых строках не рассматриваются особо. Например, r"\u20ac" это строка из 6 символов в Python 3.0, в то время как в 2.6, ur"\u20ac" был один символ "евро". (Конечно, это изменение влияет только на сырые строковые литералы).</p><p>Встроенный абстрактный тип basestring был удален. Используйте str вместо него. str и bytes не имеют достаточно общей функциональности, чтобы оправдать общий базовый класс. Инструмент 2to3 (см. ниже) заменяет каждое вхождение basestring на str.</p><p>PEP 3138: repr() для строки больше не экранирует символы, не входящие в набор ASCII. Однако, он по-прежнему экранирует управляющие символы</p><p>PEP 3120: Кодировка исходного кода по умолчанию теперь UTF-8.</p><p>PEP 3131: не-ASCII символы разрешены в идентификаторах. (Тем не менее, стандартная библиотека остается ASCII, за исключением имен авторов в комментариях.)</p><p>Модули StringIO и cStringIO удалены. Вместо этого, импортируйте модуль io и используйте io.StringIO или io.BytesIO для текста и данных соответственно.</p></div><div class="section" id="id4"><h2>Обзор изменений синтаксиса</h2><p>Этот раздел дает краткий обзор каждого синтаксического изменения Python 3.0.</p><div class="section" id="id5"><h3>Новый синтаксис</h3><p>PEP 3107: аннотации для аргументов функции и возвращаемых значений.</p><pre class="code pycon literal-block">
<span class="k"/><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="s1">'x'</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="o">.</span><span class="n">__annotations__</span>
<span class="go">{'a': 'x', 'b': 11, 'c': &lt;class 'list'&gt;, 'return': 9}</span></pre><p>PEP 3102: Keyword-only аргументы.</p><p>PEP 3104: nonlocal. Переменная во внешней (но не глобальной) области видимости.</p><pre class="code pycon literal-block">
<span class="k"/><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">outer</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>   <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
<span class="gp">... </span>       <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">... </span>       <span class="k">print</span><span class="p">(</span><span class="s2">"inner:"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>   <span class="n">inner</span><span class="p">()</span>
<span class="gp">... </span>   <span class="k">print</span><span class="p">(</span><span class="s2">"outer:"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outer</span><span class="p">()</span>
<span class="go">inner: 2
outer: 1
</span><span class="k"/><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">outer</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>   <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
<span class="gp">... </span>       <span class="n">nonlocal</span> <span class="n">x</span>
<span class="gp">... </span>       <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">... </span>       <span class="k">print</span><span class="p">(</span><span class="s2">"inner:"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>   <span class="n">inner</span><span class="p">()</span>
<span class="gp">... </span>   <span class="k">print</span><span class="p">(</span><span class="s2">"outer:"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outer</span><span class="p">()</span>
<span class="go">inner: 2
outer: 2</span></pre><p>PEP 3132: Extended Iterable Unpacking</p><pre class="code pycon literal-block">
<span class="p"/><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">0
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">rest</span>
<span class="go">[1, 2, 3]
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">4</span></pre><p>Генераторы словарей: {k: v for k, v in stuff} (то же самое, что и dict(stuff))</p><p>Литералы множеств (например, {1, 2}). Заметьте, что {} - это пустой словарь. Используйте set() для пустых множеств. Генераторы множеств: {x for x in stuff}</p><p>Новые восьмеричные литералы, например 0o720, вместо старых (0720).</p><p>Новые двоичные литералы, например 0b1010. Новая встроенная функция, bin().</p></div><div class="section" id="id6"><h3>Изменённый синтаксис</h3><p>PEP 3109 and PEP 3134: новый синтаксис выражения raise: raise [expr [from expr]].</p><p>"as" и "with" зарезервированные слова.</p><p>"True" и "False" и "None" - зарезервированные слова.</p><p>Изменено "except exc, var" на "except exc as var".</p><p>PEP 3115: Новый синтаксис для метаклассов. Вместо:</p><pre class="code python literal-block">
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">M</span>
    <span class="o">...</span></pre><p>Вы должны использовать:</p><pre class="code python3"><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">M</span><span class="p">):</span>
    <span class="o">...</span></pre><p>Переменная __metaclass__ более не поддерживается.</p><p>Генераторы списков больше не поддерживают синтаксическую форму [... for var in item1, item2, ...]. Используйте [... for var in (item1, item2, ...)].</p></div><div class="section" id="id7"><h3>Удаленный синтаксис</h3><p>PEP 3113: распаковка кортежей в параметрах удалена. Вы больше не можете писать</p><pre class="code python literal-block">
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)):</span>
    <span class="o">...</span></pre><p>Пишите</p><pre class="code python3"><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b_c</span><span class="p">):</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">b_c</span>
    <span class="o">...</span></pre><p>Удалены обратные кавычки (backtick). Используйте repr().</p><p>Удалено &lt;&gt;. Используйте !=.</p><p>exec - функция. Перестала быть зарезервированным словом.</p><p>from module import * запрещено использовать внутри функций.</p></div></div><div class="section" id="id8"><h2>Встроенные функции</h2><p>PEP 3135: Новый super(). Теперь вы можете вызывать super() без аргументов и (при условии, что это метод экземпляра, определенный внутри определении класса) класс и экземпляр будут автоматически выбраны. С аргументами, поведение super() остается без изменений.</p><p>PEP 3111: raw_input() переименован в input(). Вместо input() в Python 2, вы можете использовать eval(input()).</p><p>Добавлена функция next(), вызывающая метод __next__() объекта.</p><p>Перемещен intern() в sys.intern().</p><p>Удалено: apply(). Вместо apply(f, args) используйте f(*args).</p><p>Удалено: callable(). Вместо callable(f) используйте hasattr(f, "__call__"). Функция operator.isCallable() также удалена.</p><p>Удалено: coerce().</p><p>Удалено: execfile(). Вместо execfile(fn) используйте exec(open(fn).read()).</p><p>Удалено: file. Используйте open().</p><p>Перемещено: reduce() в functools.reduce()</p><p>Перемещено: reload() в imp.reload().</p><p>Удалено: dict.has_key(). Используйте оператор in.</p></div></div></div></body></html>