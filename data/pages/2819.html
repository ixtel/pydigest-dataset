<html><body><div><div class="deployment-academy post">
<h1>Docker in Action - Development to Delivery, Part 3</h1>
<p class="meta">
<span class="date">Thursday January 15, 2015</span>
</p>
<p><strong><em>This is a guest post by Michael Herman from <a href="https://realpython.com/?utm_source=rainforestqa&amp;utm_medium=link&amp;utm_campaign=deployment-academy">Real Python</a> - learn Python programming and web development through hands-on, interesting examples that are useful and fun!</em></strong></p>
<p>This three part series will teach you everything you need to know about developing with Docker - from setting up your environments and utilizing Flask on Docker to detailing a powerful development workflow that covers setting up a fully functional development environment, on your Mac, and managing continuous integration and delivery.</p>
<ol>
<li>Part 1: Local Docker Setup</li>
<li>Part 2: Continuous Integration</li>
<li><strong>Part 3: Continuous Delivery (current)</strong></li>
</ol>
<p><strong>END GOAL</strong>:</p>
<p><img alt="steps" src="/images/steps.jpg?1456621770"/></p>
<p>So, in the last <a href="/2014-12-08-docker-in-action-from-deployment-to-delivery-part-2-continuous-integration/">tutorial</a>, we went over a nice development workflow that included continuous integration with <a href="https://circleci.com/">CircleCI</a> (steps 1 through 6 from above). In this final piece we’ll add continuous delivery into the mix (step 7).</p>
<p>Who doesn’t love Herokuâs <code>git push heroku master</code>? Let’s make delivery that easy…</p>
<h2>Digital Ocean</h2>
<p>To set up Docker on Digital Ocean, create a new <a href="https://www.digitalocean.com/community/tutorials/how-to-create-your-first-digitalocean-droplet-virtual-server">Droplet</a>, and choose “Applications” and then select the Docker Application. Make sure you also set up an SSH key. For help with this, please see <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys--2">this</a> tutorial.</p>
<p>Once setup, SSH into the server as the ‘root’ user:</p>
<pre class="highlight shell"><span class="gp">$ </span>ssh root@&lt;some_ip_address&gt;
</pre>
<p>Pull the Docker image from Docker Hub and run a new container:</p>
<pre class="highlight shell"><span class="gp">$ </span>docker pull mjhea0/flask-docker-workflow
<span class="gp">$ </span>docker run --name flask -d -p 80:80 mjhea0/flask-docker-workflow
</pre>
<blockquote>
<p>Make sure you replace <code>mjhea0</code> with your Docker Hub username.</p>
</blockquote>
<p>Sanity check. Navigate to your Droplet’s IP address in the browser. You should see, “Flask is running on Docker!”.</p>
<p>Now, instead of having to SSH into the server and pull down the new image each time we want to deploy, let’s automate the process so that once a new build is generated on Docker Hub, we pull in the new image and run a new container <em>automatically</em>.</p>
<h2>Deploy Script</h2>
<p>We can utilize Docker Hub’s <a href="https://docs.docker.com/docker-hub/repos/#webhooks">webhooks</a> to trigger a post request to a URL on our Digital Ocean server. On the server, we then need to have a “listener” setup to trigger a simple bash script:</p>
<pre class="highlight shell">docker pull mjhea0/flask-docker-workflow
docker stop flask
docker rm flask
docker run --name flask -d -p 80:80 mjhea0/flask-docker-workflow
</pre>
<p>Here we pull in the new image, remove the currently running container, and then run the new container. It’s not exactly <em>zero-downtime</em>; it’s more like <em>as-minimal-as-possible-downtime</em>.</p>
<p>Let’s get this set up along with the listener…</p>
<h2>Docker Listener</h2>
<p>To set up the listener, we can use a separate Docker container that’s already <a href="https://registry.hub.docker.com/u/mjhea0/docker-hook-listener/">set up</a>. You will need to update the code before you can use it, though. So clone the <a href="https://github.com/realpython/docker-hook-listener">Github repo</a>.</p>
<p>Update the <em>app/deploy.sh</em> file, replacing <code>mjhea0</code> with your Docker Hub username. If you’re curious, check out the the Flask app code within <em>app/app.py</em>. Essentially, we just confirm that the token is correct when a post request hits the <code>/ping</code> endpoint. If it’s correct, then the deploy script is fired. Make sense?</p>
<p>After you clone the repo and update the deploy script. Add this repository to Docker Hub, just as you did in the last <a href="/2014-12-08-docker-in-action-from-deployment-to-delivery-part-2-continuous-integration/">tutorial</a>.</p>
<p>Next, SSH back into Digital Ocean, and then pull the image and run the container (making sure to add the <code>TOKEN</code> to the environment with the <code>-e</code> flag:</p>
<pre class="highlight shell"><span class="gp">$ </span>docker pull mjhea0/docker-hook-listener
<span class="gp">$ </span>docker run --name listener -e <span class="nv">TOKEN</span><span class="o">=</span><span class="s2">"test654321"</span> -d -p 5000:5000 mjhea0/docker-hook-listener
</pre>
<blockquote>
<p>Again, replace <code>mjhea0</code> with your Docker Hub username.</p>
</blockquote>
<p>With the listener running, add a webhook (under <em>Settings</em>) to your Docker build: <a href="http://your-hostname:5000/ping?token=test654321">http://your-hostname:5000/ping?token=test654321</a>.</p>
<h2>Profit!</h2>
<p>Now after every single build completes on Docker Hub-</p>
<ul>
<li>A post request is sent.</li>
<li>The listener handles the post request by ensuring that the token is valid and then firing <em>deploy.sh</em>.</li>
</ul>
<p>Time to test. On the feature branch, update the app - Add some cities to the cities list, perhaps. Commit your changes. Open a pull request. Once the automated tests pass, merge the request. After the tests run again, a new build will trigger on Docker Hub. After the build is complete, the post request is sent and handled by the listener, which fires the bash script.</p>
<p>Make sure these changes are reflected in the browser.</p>
<h2>Conclusion</h2>
<p>Well, this concludes our look at a powerful Docker workflow - from development to deployment. What’s left?</p>
<ol>
<li>Staging server: We need a pre-production server for one last line of tests.</li>
<li>Integration tests: Right now we just have some basic unit tests, so make sure to add integration tests.</li>
<li>Create a new user: Add a new user to your Linux server so that you’re not using ‘root’.</li>
<li>Tagging: It’s a good idea to introduce a system of tagging so that Docker images can be traced back to a commit (and ultimately back to the code).</li>
</ol>
<p>Thanks for reading!</p>

<div class="deployment-academy-cta">
<p>
<strong>Read more articles like this.</strong>
Get a quick post in your inbox each week:
</p>

</div>
<h3 class="further-reading">Further reading:</h3>

</div>
</div></body></html>