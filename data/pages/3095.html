<html><body><div><div itemprop="articleBody"><p>Suppose you were doing some sockets programming and had a strange bug - the code seemed to be stuck. Imagine something like this:</p><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">'google.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">makefile</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'GET / HTTP/1.0</span><span class="se">\r\n\r\n</span><span class="s1">'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>  <span class="c1"># never returns</span>
</pre></div><p>The problem is that the <a class="reference external" href="http://docs.python.org/2/library/socket.html#socket.socket.makefile">fileobject</a> does buffering by default. The <tt class="docutils literal">write</tt> call doesn't actually send anything unless we add <tt class="docutils literal">fh.flush()</tt> around or change the buffering to be line-based (<tt class="docutils literal">makefile(bufsize=1)</tt>) or completely disable it (<tt class="docutils literal">makefile(bufsize=0)</tt>). Because HTTP is line-based protocol line buffering is best, example:</p><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">'google.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">makefile</span><span class="p">(</span><span class="n">bufsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'GET / HTTP/1.0</span><span class="se">\r\n\r\n</span><span class="s1">'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">'HTTP/1.0 302 Found\r\n'</span>
</pre></div><p>I don't like this non-linear learning curve and there are other situation where you don't have documentation around to figure out why stuff doesn't work. Sometimes, there's too much code to look at and you're left with a stuck server (or client) application.</p><div class="section" id="how-to-figure-out-causes-like-this"><h2>How to figure out causes like this?<a class="headerlink" href="#how-to-figure-out-causes-like-this" title="Permalink to this headline"> *</a></h2><p>One might think, just <a class="reference external" href="https://blog.ionelmc.ro/2013/06/05/python-debugging-tools/#standard-linux-tools">use strace</a> to figure out what syscalls are being made. I think that's quite inflexible. Most of the time you need more data to identify the cause of the bug.</p><p>A lot <a class="reference external" href="https://github.com/celery/celery/pull/1834">of</a> <a class="reference external" href="https://github.com/celery/py-amqp/pull/33">times</a> I've found myself littering code with logging calls and patching the socket class just to figure out what's going on. I've set out to make this easier to do - and it turns out this is a <a class="reference external" href="http://python-aspectlib.readthedocs.org/">perfect application of aspect-oriented programming</a>: adding additional behavior to existing code.</p><p>Let's try to "debug" the code above:</p><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">aspectlib</span> <span class="kn">import</span> <span class="n">weave</span><span class="p">,</span> <span class="n">debug</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weave</span><span class="p">([</span><span class="s1">'socket._realsocket'</span><span class="p">,</span> <span class="s1">'socket._fileobject'</span><span class="p">],</span>
<span class="gp">... </span>      <span class="n">debug</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">print_to</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">stacktrace</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span>
<span class="gp">... </span>      <span class="n">lazy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&lt;aspectlib.Rollback object at 0x16949b8&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">'google.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
<span class="go">{socket._realsocket}.connect(('google.com', 80))</span>
<span class="go">{socket._realsocket}.connect =&gt; None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">makefile</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'GET / HTTP/1.0</span><span class="se">\r\n\r\n</span><span class="s1">'</span><span class="p">)</span>
<span class="go">{socket._fileobject}.write('GET / HTTP/1.0\r\n\r\n')</span>
<span class="go">{socket._fileobject}.write =&gt; None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">{socket._fileobject}.readline()</span>
<span class="go">{socket._realsocket}.recv(8192)</span>
</pre></div><p>We can immediately see that <tt class="docutils literal">fh.write</tt> didn't do anything - it's clear that the fileobject has some buffering on. It's just a matter of identifying the correct <tt class="docutils literal">makefile</tt> invocation. Now this is much better than doing guesswork don't you think?</p><p>Give <a class="reference external" href="https://pypi.python.org/pypi/aspectlib">aspectlib</a> a shot!</p></div></div></div></body></html>