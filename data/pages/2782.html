<html><body><div><div class="content html_format">
      <h4>Предисловие</h4><p>
Несколько месяцев назад я решил изучить Python. В качестве одной из тестовых задач требовалось написать игру «Морской бой». Тогда я не сделал эту задачу, но в голову пришла идея написать «Морской бой», где будут играть два компьютера между собой. Эта мысль не оставляла меня, и я решил дерзнуть. Результат представлен на ваш суд. Буду признателен за любую конструктивную критику.

</p><h4>Общая концепция текущей реализации</h4><p>
Вся игра, по сути, сводится к тому, что два экземпляра класса Player спрашивают друг у друга координаты кораблей и в зависимости от ответа выстраивают свою стратегию ходов.
</p><p>
Стратегия расстановки кораблей следующая: 2-3-4 палубные размещаются по краям карты (2 клетки), 1-палубный в центре (квадрат 6х6).

</p><img src="https://habrastorage.org/files/2da/033/fc6/2da033fc62b3477ba9f925681eeef43f.png" alt="image"/>
<a name="habracut"/><p>
Стратегия ходов, как в игре между людьми: первый ход наобум, если попал, то прорабатываем 4 клетки вокруг и далее, если попал повторно, то прорабатываем по две клетки уже на линии (две, т.к. макс. длинна корабля 4 клетки, в 2 уже попал, значит макс. есть ещё 2 клетки).
</p><p>
В </p><a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D1%80%D1%81%D0%BA%D0%BE%D0%B9_%D0%B1%D0%BE%D0%B9_(%D0%B8%D0%B3%D1%80%D0%B0)">статье</a><p> на Википедии всё достаточно подробно описано, поэтому не буду здесь сильно касаться игровой логики, тем более, что и так все примерно понимают, о чём идёт речь. У меня отличия только такие: начисление очков за каждый ход, нумерация клеток от 0 до 9.
</p><p>
В игре используются три класса: Game, Player, Ship. Использование класса Game в текущей реализации избыточно, так как используется всего один его экземпляр, но это некоторый задел на будущее (см. список улучшений в конце статьи).
</p><p>
Game отвечает за общую игровую логику, Player — за стратегию ходов, Ship — хранит текущее состояние кораблей и их координаты.

</p><a href="https://github.com/balamut108/sea-fight">Ссылка</a><p> проект в GitHub.

</p><h4>Основные сложности, которые возникли входе разработки</h4><p>
1. </p><b>Проектирование</b><p>. Писать с использованием классов или функций? Какой набор классов использовать?</p><p>
Основной проблемой при проектировании оказалось отслеживание различных состояний в игре. Например, кто сейчас ходит, в каком состоянии корабль (подбит, убит), не закончилась ли игра, кто выиграл и т.п.
</p><p>
2. </p><b>Логика/алгоритмы</b><p>. Как расставить корабли в соответствии со стратегией, как выбрать координаты для хода?

</p><h4>Обзор наиболее интересных частей кода</h4>
<b>return_shoot_state</b><p> — определяет дальнейшую стратегию в зависимости от результатов текущего хода.

</p><pre><code class="python">def return_shoot_state(self, state, crd):
	"""Стратегия дальнейщих ходов в зависимости от результата текущего хода"""
	if state == u'Попал!':
		self.scores += 1
		if not self.recomendation_pool:
			crd_rec = [[crd[0] - 1, crd[1]], [crd[0] + 1, crd[1]], [crd[0], crd[1] - 1], [crd[0], crd[1] + 1]]
			crd_rec = filter(lambda x: 0 &lt;= x[0] &lt;= 9 and 0 &lt;= x[1] &lt;= 9, crd_rec)
			crd_rec = filter(lambda x: x not in self.alien, crd_rec)
			self.succ_shoots.append(crd)
			self.recomendation_pool.extend(crd_rec)
		else:
			crd_s1 = self.recomendation_pool[0]
			crd_s2 = self.succ_shoots[0]
			for ind in range(2):
				if crd_s1[ind] != crd_s2[ind]:
					if crd_s1[ind] &gt; crd_s2[ind]:
						crd_rec = [[crd_s1[ind]+1, crd_s1[ind]+2], [crd_s2[ind]-1, crd_s2[ind]-2]]
					else:
						crd_rec = [[crd_s1[ind]-1, crd_s1[ind]-2], [crd_s2[ind]+1, crd_s2[ind]+2]]
						crd_rec = filter(lambda x: 0 &lt;= x[0] &lt;= 9 and 0 &lt;= x[1] &lt;= 9, crd_rec)
						crd_rec = filter(lambda x: x not in self.alien, crd_rec)
						self.recomendation_pool.extend(crd_rec)
	elif state == u'Убил!':
		self.scores += 1
		self.recomendation_pool = []
		self.succ_shoots = []
</code></pre>
<p>
Важные переменные: recomendation_pool — список координат для будущих выстрелов, succ_shoots — последний успешный выстрел.
</p><p>
Если мы попали в корабль, то, во-первых, нужно начислить себе очки за успешный выстрел (scores += 1), а во-вторых, понять, что делать дальше. Мы проверяем recomendation_pool, есть ли там что-то, если нет, то записываем туда 4 близлежащих координаты (предварительно отфильтровав их по границам поля и списку координат, по которым мы уже стреляли).

</p><img src="http://habrastorage.org/files/647/4f4/d01/6474f4d010924aec939115878fec09b8.png" alt="image"/>
<p>
Если recomendation_pool не пустой — это значит, что мы попали второй раз и речь уже идёт не о 4 координатах вокруг, а о двух с каждого края.

</p><img src="http://habrastorage.org/files/241/681/18e/24168118e5094e6aada78ea075714e28.png" alt="image"/>
<p>
Если текущим выстрелом корабль был потоплен, мы считаем свою задачу выполненной и зачищаем пул рекомендаций и проч. Следующий выстрел будет выполнен случайным образом.

</p><b>service.gen_cord</b><p> — генерирует все возможные координаты для каждого типа кораблей. Результатом работы функции будет словарь со следующей структурой: {«S0»:[[[x0,y0],[x1,y2],[xN0,yN1]], [[x3,y3],[x4,y4],[xN2,yN3]], ...], «S1»: ...}, где S — тип корабля, [[x0,y0],[x1,y2],[xN0,yN1]] — набор координат для корабля.

</p><pre><code class="python">def gen_cord():
	"""Генератор всех возможных комбинаций координат"""
	all_comb = [[x/10, x % 10] for x in range(100)]
	for_1_ship = filter(lambda x: x[0] in range(2, 8) and x[1] in range(2, 8), all_comb)
	for_other_ship = filter(lambda x: x not in for_1_ship, all_comb)
	cord_comb = {1: [[x] for x in for_1_ship], 2: [], 3: [], 4: []}
	for ship in filter(lambda x: x != 1, cord_comb.keys()):
		for cord in for_other_ship:
			hor_direction = [cord] + [[cord[0]+x, cord[1]] for x in range(1, ship)]
			ver_direction = [cord] + [[cord[0], cord[1]+x] for x in range(1, ship)]
			for dir_d in [hor_direction, ver_direction]:
				for cord_d in dir_d:
					if cord_d not in for_other_ship:
						break
				else:
					cord_comb[ship].append(dir_d)
	return cord_comb
</code></pre><p>
Важные переменные: all_comb — хранит координаты поля в формате [[x0,y0], [x1,y1], ...]. for_1_ship — тот самый квадрат 6х6 для однопалубных, for_other_ship — набор координат для всех остальных кораблей. cord_comb — словарь, который хранит все комбинации координат.

</p><h4>Расстановка кораблей</h4><p>
В момент инициализации экземпляра класса Player также расставляются и корабли. В классе за это отвечает метод create_ships, где происходит следующее:
</p><p>
1. Для каждого корабля (ships) из доступной последовательности комбинаций координат (combinations) псевдослучайным образом (random.choice) выбирается набор координат.</p><p>
2. Далее для набора координат генерируется ореол (service.set_halo). Ореол — это набор координат в которые нельзя будет поставить потом корабль (правило: не размещать корабли рядом).

</p><img src="http://habrastorage.org/files/8a7/246/d87/8a7246d878954be4a0d40d2c512eeb7a.png" alt="image"/>
<p>
3. После чего зачищаем список комбинаций (data_cleaner) из списка который состоит из координат корабля и ореола.

</p><h4>Модуль Logging</h4><p>
Под конец разработки открыл для себя модуль logging из стандартной библиотеки. Поля для вывода настраиваются (logging.basicConfig), а работать с выводом не сложнее, чем с print.

</p><img src="http://habrastorage.org/files/66f/441/1d5/66f4411d5e6b4749b69c2b422f345dea.png" alt="image"/>

<h4>Прочее</h4><p>
sevice.rdn_usr_name — генерирует случайные имена игроков из набора букв и цифр от 0 до 999.
</p><p>
Игра заканчивается, если у противника Player.ships_defeat = 10, т.е. потоплены все 10 кораблей. Счётчик обновляется, если корабль отвечает «Убил!».

</p><h4>Список улучшений (TO DO)</h4>
<s>1. Сделать турнир между игроками, скажем, где будет 1000 игроков. По идее, с учётом текущего времени выполнения весь турнир должен занять примерно 30 сек.</s>

<s>2. Добавить «базовый алгоритм» хода, например, ходить крест на крест, т.е. пробивать все клетки по диагонали и потом далее. Реализовать несколько таких алгоритмов и далее присваивать случайным образом работу по ним игроку. После чего сравнивать эффективность (например, что даёт больше результата случайные ходы или алгоритм «крест на крест»?)<br/>
</s><p>
3. Оптимизировать механизм поиска комбинаций (service.gen_cord), т.к. очевидно, что он избыточен и отнимает много ресурсов. 

</p><s>4. Реализовать различные стратегии размещения кораблей и потом сравнить какая из них наиболее успешна.</s>
<p>
P.S. Буду признателен за любые интересные идеи. 
</p><p>
Спасибо.
</p><p>
UPDATE (16.01.2015)

</p><h4>Турнир реализован + сделан небольшой сбор статистики и вот что получается:</h4><p>
В турнире идёт игра на вылет, т.е. если проиграл на след. ступень уже не попадаешь.
</p><p>
Чтобы турнир был без косяков количество игроков должно быть, чтобы при делении остаток от деления всегда делился на 2 и так до того как число игроков в турнире не будет 1 (т.е. победитель). К таким числам относятся 1024 (512, 256, 128, 64, 32, 16, 8, 4, 2).
</p><p>
Ранее я предполагал, что турнир будет длиться порядка 30 секунд, т.е. время вырастает линейно в зависимости от количества игроков, однако каково же было моё удивление, когда весь турнир для 1024 игроков всего 17 секунд. Почему получается 17 секунд мне не ведомо, возможно начинают работать какие-то механизмы оптимизации. Мои расчеты таковы: 1022 партии длится весь турнир* 25 мс одна партия = 25.55 секунд.
</p><p>
Статистика турнира держится в пределах следующих значений:
</p><p>
1. Среднее количество ходов (всех игроков): 85.06,</p><p>
 2. Среднее количество ходов выигравших игроков: 85.95,</p><p>
 3. Среднее количество ходов проигравших игроков: 84.17,</p><p>
 4. Среднее количество очков, которое набрали проигравшие: 17.75
</p><p>
Выводы можем сделать следующие:
</p><p>
1. Количество ходов, что выигравшие, что проигравшие делают примерно одинаковое.
</p><p>
2. Количество очков почти 18 (для победы нужно 20).
</p><p>
Итог: оба игрока играют примерно одинаково и одинаково неэффективно :) Разница в 2 очка показывает, что победа буквально вырывается из лап соперника на последних ходах.
</p><p>
Вывод: т.к. сейчас каждый игрок руководствуется одной и той же стратегией особого разнообразия в игре нет. Чтобы было поинтересней нужно реализовать различные стратегии как расстановки кораблей, так и выполнения ходов, чем и займусь на досуге в ближайшее время.
</p><p>
Следите за обновлениями статьи.
</p><p>
UPDATE2(16.01.2015)</p><p>
Реализовал добавление ореола к списку пробитых координат после потопления корабля (в принципе всё честно). Статистика по количеству ходов существенно улучшилась:</p><p>
 1. Среднее количесво ходов (всех игроков): 58.91,</p><p>
 2. Среднее количество ходов выйгравших игроков: 60.98,</p><p>
 3. Среднее количество ходов проигравших игроков: 56.83,</p><p>
 4. Среднее количество очков, которое набрали проигравшие: 15.37
</p><p>
Спасибо  </p><a href="http://habrahabr.ru/users/meklon/" class="user_link">Meklon</a><p> за идею.
</p><p>
UPDATE3(17.01.2015)
</p><p>
Реализовал новые стратегии размещения кораблей (там где 60 клеток под однопалубные). В итоге получилось следующее, если каждый из игроков использует одну и туже стратегию, то разницы между проигравшими и победителями нет, а вот если кажому игроку стратегия расстановки присваивается случайно, то явно видно, что прогиравших с моей стратегией больше (квадрат 6х6 в центре), т.е. если мою стратегию выбросить, то все будут играть примерно одинаково. Это тоже не интересно. Теперь буду реализывать различные стратегии ходов (может найдётся, что-то сверхоптимальное). 

</p><div class="spoiler"><b class="spoiler_title">Данные</b><p class="spoiler_text">left,right, top,bottom и т.п. — это всё вариации размещения 60 координат на поле.<br/>
[2015-01-17 19:14:07,780] Статистика: <br/>
 1. Среднее количесво ходов (всех игроков): 63.18,<br/>
 2. Среднее количество ходов выйгравших игроков: 64.82,<br/>
 3. Среднее количество ходов проигравших игроков: 61.54,<br/>
 4. Среднее количество очков, которое набрали проигравшие: 16.24<br/>
[2015-01-17 19:14:07,783] Стратегия: for_1_ship_left loosers: 508 <br/>
[2015-01-17 19:14:07,783] Стратегия: for_1_ship_left winners: 515<br/>
<br/>
[2015-01-17 19:20:27,526] Статистика: <br/>
 1. Среднее количесво ходов (всех игроков): 62.58,<br/>
 2. Среднее количество ходов выйгравших игроков: 64.23,<br/>
 3. Среднее количество ходов проигравших игроков: 60.93,<br/>
 4. Среднее количество очков, которое набрали проигравшие: 16.23<br/>
[2015-01-17 19:20:27,529] Стратегия: for_1_ship_right loosers: 498 <br/>
[2015-01-17 19:20:27,529] Стратегия: for_1_ship_right winners: 525 <br/>
<br/>
[2015-01-17 19:21:40,153] Статистика: <br/>
 1. Среднее количесво ходов (всех игроков): 58.94,<br/>
 2. Среднее количество ходов выйгравших игроков: 61.02,<br/>
 3. Среднее количество ходов проигравших игроков: 56.87,<br/>
 4. Среднее количество очков, которое набрали проигравшие: 15.35<br/>
[2015-01-17 19:21:40,155] Стратегия: for_1_ship_36 loosers: 518 <br/>
[2015-01-17 19:21:40,157] Стратегия: for_1_ship_36 winners: 505<br/>
<br/>
[2015-01-17 19:23:37,322] Статистика: <br/>
 1. Среднее количесво ходов (всех игроков): 62.85,<br/>
 2. Среднее количество ходов выйгравших игроков: 64.55,<br/>
 3. Среднее количество ходов проигравших игроков: 61.16,<br/>
 4. Среднее количество очков, которое набрали проигравшие: 16.15<br/>
[2015-01-17 19:23:37,323] Стратегия: for_1_ship_bottom loosers: 526 <br/>
[2015-01-17 19:23:37,325] Стратегия: for_1_ship_bottom winners: 497<br/>
<br/>
[2015-01-17 19:33:07,933] Статистика: <br/>
 1. Среднее количесво ходов (всех игроков): 61.59,<br/>
 2. Среднее количество ходов выйгравших игроков: 63.37,<br/>
 3. Среднее количество ходов проигравших игроков: 59.81,<br/>
 4. Среднее количество очков, которое набрали проигравшие: 15.95<br/>
[2015-01-17 19:33:07,934] Стратегия: for_1_ship_center_vertical loosers: 512 <br/>
[2015-01-17 19:33:07,934] Стратегия: for_1_ship_center_vertical winners: 511<br/>
<br/>
[2015-01-17 19:36:03,585] Статистика: <br/>
 1. Среднее количесво ходов (всех игроков): 61.03,<br/>
 2. Среднее количество ходов выйгравших игроков: 62.89,<br/>
 3. Среднее количество ходов проигравших игроков: 59.18,<br/>
 4. Среднее количество очков, которое набрали проигравшие: 15.78<br/>
[2015-01-17 19:36:03,589] Стратегия: for_1_ship_36 loosers: 148 <br/>
[2015-01-17 19:36:03,589] Стратегия: for_1_ship_36 winners: 109 <br/>
[2015-01-17 19:36:03,591] Стратегия: for_1_ship_bottom loosers: 34 <br/>
[2015-01-17 19:36:03,591] Стратегия: for_1_ship_bottom winners: 50 <br/>
[2015-01-17 19:36:03,591] Стратегия: for_1_ship_center_horisontal loosers: 129 <br/>
[2015-01-17 19:36:03,591] Стратегия: for_1_ship_center_horisontal winners: 120 <br/>
[2015-01-17 19:36:03,592] Стратегия: for_1_ship_center_vertical loosers: 96 <br/>
[2015-01-17 19:36:03,592] Стратегия: for_1_ship_center_vertical winners: 94 <br/>
[2015-01-17 19:36:03,592] Стратегия: for_1_ship_left loosers: 28 <br/>
[2015-01-17 19:36:03,592] Стратегия: for_1_ship_left winners: 44 <br/>
[2015-01-17 19:36:03,592] Стратегия: for_1_ship_right loosers: 40 <br/>
[2015-01-17 19:36:03,594] Стратегия: for_1_ship_right winners: 48 <br/>
[2015-01-17 19:36:03,594] Стратегия: for_1_ship_top loosers: 35 <br/>
[2015-01-17 19:36:03,594] Стратегия: for_1_ship_top winners: 48 <br/>
</p></div>
<p>
UPDATE4(20.01.2015)
</p><p>
Добавил различные варианты совершения ходов: random — случайно из свободных клеток, cross — крест на крест, linear — линейно в 4 ряда через одну (как в хвалёных статьях). Важный момент: стратегия расстановки кораблей выдаётся на весь турнир, а вот стратегия ходов выдаётся на каждую игру.
</p><p>
Собрал статистку (напомню речь идёт о турните, где 1024 игрока играют между собой на вылет).
</p><img src="http://habrastorage.org/files/2b4/190/de3/2b4190de309d4716b7292af2e7f70bb7.png" alt="image"/>
<p>
Основные выводы:</p><p>
Стратегии расстановки однопалубных кораблей random_12 (выбирается 12 случайных клеток и в них расставляем корабли) и for_1_ship_36 (поле 6х6 в центре) явно наименее эффективные.
</p><p>
Равномерное распределение свидетельствует о том, что равные среди равных дали примерно одинаковый результат и победа одного из них это лишь случайное следствие.
</p><p>
Количество ходов с реализацией дополнительных стратегий ходов не уменьшилось, а вот время турнира увеличилось с 25 до 50 секунд:</p><p>
 1. Среднее количесво ходов (всех игроков): 61.43,</p><p>
 2. Среднее количество ходов выйгравших игроков: 63.23,</p><p>
 3. Среднее количество ходов проигравших игроков: 59.63,</p><p>
 4. Среднее количество очков, которое набрали проигравшие: 15.93
</p><p>
Буду признателен, если кто-то посмотрит мой код на </p><a href="https://github.com/balamut108">GitHub </a><p>и даст свои рекомендации по его улучшению.
</p><p>
Осталась одна намеченная задача по оптимизации, но, как известно, оптимизировать можно бесконечно долго, так что статья без особой надобности в ближайшее время обновляться не будет.
</p><p>
Спасибо за внимание и да прибудет с вами сила Python!
      </p><p class="clear"/>
    </div>

    
  </div></body></html>