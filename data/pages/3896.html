<html><body><div><div class="entry-content"><p><em>(This an adaptation of a talk I gave at PiterPy. <a href="http://hackflow.com/slides/metaprogramming/">Slides</a> and <a href="http://www.youtube.com/watch?v=Q8qxeFGNT9A">video</a> are available in russian)</em></p>

<p>Python gives us deep introspecting and metaprogramming capabilities including bytecode and AST support in the standard library. This facilitates unobvious ways to write code that writes code or otherwise alters its behavior. I will show several different examples of how it could be used for
fun and profit.</p>




<h2>Warming up</h2>

<p>Look at this code:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="o">&gt;&gt;&gt;</span> <span class="nb">map</span><span class="p">(</span><span class="n">_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</span><span class="line"><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>It maps a list through <code>_ + 1</code> and gets a new list with each element incremented.
This makes sense mnemonically, but can this code actually work in python?</p>

<p>And sure it can. In fact this is rather simple trick with operator overloading:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Whatever</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
</span><span class="line">        <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span><span class="line">
</span><span class="line"><span class="n">_</span> <span class="o">=</span> <span class="n">Whatever</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here we create a class that produces lambda upon addition and then creates its instance named <code>_</code>.
Just using common interface in an unusual way. We can even go all loose and make something like this to work:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># Sort guys by height descending</span>
</span><span class="line"><span class="n">sort</span><span class="p">(</span><span class="n">guys</span><span class="p">,</span> <span class="n">key</span><span class="o">=-</span><span class="n">_</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="c"># Reduce my multiplication</span>
</span><span class="line"><span class="n">factorial</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">_</span> <span class="o">*</span> <span class="n">_</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Returning lambda, obviously, won’t work anymore. However, we can return a callable object,
which also returns callables as operations results. We are also intercepting attribute access here,
shouldn’t surprise you after everything you’ve seen.</p>

<p>Honestly, I was too shy to use this in production. And you usually need only one or two lambdas in a file anyway, too few to bring an import, a dependency and all the complications.
But suppose you are writing <a href="https://github.com/Suor/funcy/blob/master/tests/test_funcs.py">tests for functional support library</a>,
then you’ll need to create lots of small functions to pass them to your ones.
A library like this would be useful in that setting.</p>

<p>Anyway, if you still think this idea is too weird then you should know that there are at least 3 libraries implementing it:</p>




<p>But let’s move to something more interesting.</p>

<h2>Pattern Matching</h2>

<p>Now look at this and think if it is also feasible in python.
This is supposed to recursively calculate a product of all the list elements:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">product</span><span class="p">():</span>
</span><span class="line">    <span class="k">if</span> <span class="p">[]:</span> <span class="mi">1</span>
</span><span class="line">    <span class="k">if</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">xs</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">product</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you familiar with pattern matching then the code makes sense:</p>

<ul>
<li>product is 1 for empty list,</li>
<li>product is (first element) times (product of the rest of the list) otherwise.</li>
</ul>


<p>On the other hand, python doesn’t work this way. <code>x</code> and <code>xs</code> are never defined and <code>product()</code> has no arguments. And yes, this really doesn’t work. This, however, does:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">from</span> <span class="nn">patterns</span> <span class="kn">import</span> <span class="n">patterns</span>
</span><span class="line">
</span><span class="line"><span class="nd">@patterns</span>
</span><span class="line"><span class="k">def</span> <span class="nf">product</span><span class="p">():</span>
</span><span class="line">    <span class="k">if</span> <span class="p">[]:</span> <span class="mi">1</span>
</span><span class="line">    <span class="k">if</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">xs</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">product</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>@patterns</code> here rewrites function into something we meant. It can’t obviously be implemented as ordinary decorator, since calling original function will crash. So <code>@patterns</code> reads function code instead, parses it into abstract syntax tree, transforms that to a meaningful one and then compiles back:</p>

<blockquote><p>Code  →  AST  →  New AST  →  New Code</p></blockquote>





<p>And after transformation we get something like:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span class="line">    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="p">[]:</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">1</span>
</span><span class="line">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
</span><span class="line">        <span class="n">x</span><span class="p">,</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span><span class="line">        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">product</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Which looks like normal python code, it is also much more verbose.
That’s why we got into this whole pattern matching thing in the first place.</p>

<p>And again it was too awkward to use all this magic in production code,
but I used code inspired by that:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># Use simple pattern matching to construct form field widget</span>
</span><span class="line"><span class="n">TYPE_TO_WIDGET</span> <span class="o">=</span> <span class="p">(</span>
</span><span class="line">    <span class="p">[</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">choices</span><span class="p">,</span>           <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">Select</span><span class="p">(</span><span class="n">choices</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">choices</span><span class="p">)],</span>
</span><span class="line">    <span class="p">[</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">'int'</span><span class="p">,</span>     <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">TextInput</span><span class="p">(</span><span class="nb">coerce</span><span class="o">=</span><span class="nb">int</span><span class="p">)],</span>
</span><span class="line">    <span class="p">[</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">'string'</span><span class="p">,</span>  <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">TextInput</span><span class="p">()],</span>
</span><span class="line">    <span class="p">[</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">'text'</span><span class="p">,</span>    <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">Textarea</span><span class="p">()],</span>
</span><span class="line">    <span class="p">[</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">'boolean'</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">Checkbox</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">label</span><span class="p">)],</span>
</span><span class="line"><span class="p">)</span>
</span><span class="line"><span class="k">return</span> <span class="n">first</span><span class="p">(</span><span class="n">do</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="k">for</span> <span class="n">cond</span><span class="p">,</span> <span class="n">do</span> <span class="ow">in</span> <span class="n">TYPE_TO_WIDGET</span> <span class="k">if</span> <span class="n">cond</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This actually could be useful for many things: recursive functions, chatbots, binary protocol implementations and other occasions when you resolve to long if-elses or switch-cases.
The general idea, however, comes beyond pattern matching.</p>

<h2>AST Applications</h2>

<p>This technique — abstract syntax tree transformation — is much more broadly useful.
And the main reason is that trees capture language structure. Another trees virtue is that they are data structures, which are much more hackable than code strings.</p>

<p>Anyway, these are some things they facilitate:</p>

<p><strong>Language extensions.</strong> With pattern matching being only one of them. Other examples are optional (or not) static typing, macros, … It is only limited by your imagination and tree transformation skills. You obviously need to stay within syntax though, unless you go for separate parser and AST, but this is a separate topic.</p>

<p><strong>Optimizations</strong>. This is less obvious but we can inline calls, precalculate constant expressions, even make tail call optimization.</p>

<p><strong>Code analysis</strong>. It’s much easier to analyze tree than just code string ‘cause it captures some of semantics of a language. We can implement some linters or editor plugins with the help of AST.
Generally you won’t need to transform a tree for analysis, but imagine some linter suggesting code changes specific to your particular fragment not general advice. That would be cool.</p>

<p><strong>Translation</strong>. To JavaScript to run things in browser, to SQL to automatically generate queries
or stored procedures, to Python 3 after all.</p>

<p>These are various ways it flows:</p>

<blockquote><p>Code  →  AST  →  New AST  →  New Code<br/>Code  →  AST  →  JavaScript<br/>Bytecode  →  AST  →  SQL</p></blockquote>





<p>Looks like we need to dig a bit more into AST.</p>

<h2>AST</h2>

<p>First we need a way to get a tree. The easiest way is to first get source and then parse it. Two standard modules will help us with that:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">import</span> <span class="nn">inspect</span><span class="o">,</span> <span class="nn">ast</span>
</span><span class="line">
</span><span class="line"><span class="n">source</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
</span><span class="line"><span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Sometimes you can’t get function source, most common example — <code>inspect.getsource()</code> doesn’t work with lambdas. Then you can still get to AST by decompiling bytecode:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">from</span> <span class="nn">meta.decompiler</span> <span class="kn">import</span> <span class="n">decompile_func</span>
</span><span class="line">
</span><span class="line"><span class="n">tree</span> <span class="o">=</span> <span class="n">decompile_func</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>We are using third party module <a href="https://github.com/srossross/Meta">meta</a> here, and despite saying that we decompile function it really does inspect and decompile its bytecode. Anyway, we’ve got our AST, let’s look at it:</p>

<p><img src="/slides/metaprogramming/ast-example.dot.svg"/></p>

<p>This is quite a hairy tree for something as simple as <code>lambda x: x + 1</code>. But if we look at it a bit
more closer we can recognize all the corresponding parts. Left branch is arguments, which have single argument named <code>x</code>, but no kwarg, vararg or defaults. Right branch is a return node returning a result of binary operation with an op of addition and operands of a name <code>x</code> and a number <code>1</code>.</p>

<p>That makes sense, this is not however what we see as a result in python REPL:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span>
</span><span class="line"><span class="o">&lt;</span><span class="n">_ast</span><span class="o">.</span><span class="n">Lambda</span> <span class="n">at</span> <span class="mh">0x7f7e2359e490</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yeah, it’s just a <code>Lambda</code> object. We can look up its attributes to get other nodes:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span><span class="o">.</span><span class="n">body</span>
</span><span class="line"><span class="o">&lt;</span><span class="n">_ast</span><span class="o">.</span><span class="n">Return</span> <span class="n">at</span> <span class="mh">0x7f3e75f869d0</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>And this is what python AST actually is: a collection of objects stored in the attributes of each other. In addition I need to say that this objects don’t really have behaviour, they are just data.
You can find full list of available nodes and their attributes in <a href="https://docs.python.org/2/library/ast.html">ast module</a> documentation.</p>

<p>Inspecting AST this way could be too tiresome, we need some way to get a bigger picture.
The simplest thing we have is <code>ast.dump()</code> utility:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</span><span class="line"><span class="n">Lambda</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">arguments</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s">'x'</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Param</span><span class="p">())],</span> <span class="n">vararg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">kwarg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
</span><span class="line"><span class="n">defaults</span><span class="o">=</span><span class="p">[]),</span> <span class="n">body</span><span class="o">=</span><span class="n">Return</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">BinOp</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s">'x'</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span> <span class="n">op</span><span class="o">=</span><span class="n">Add</span><span class="p">(),</span>
</span><span class="line"><span class="n">right</span><span class="o">=</span><span class="n">Num</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is the same thing we saw in the picture, it is also useless for any non-trivial case. One more
third-party library, <a href="https://github.com/berkerpeksag/astor">astor</a>, could help us out:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">astor</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</span><span class="line"><span class="n">Lambda</span><span class="p">(</span>
</span><span class="line">    <span class="n">args</span><span class="o">=</span><span class="n">arguments</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s">'x'</span><span class="p">)],</span> <span class="n">vararg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">kwarg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="p">[]),</span>
</span><span class="line">    <span class="n">body</span><span class="o">=</span><span class="n">Return</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">BinOp</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s">'x'</span><span class="p">),</span> <span class="n">op</span><span class="o">=</span><span class="n">Add</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">Num</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The same plus indents. It is already useful when you need to look at the AST closer, but for quick print debugging python code would be even better:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">astor</span><span class="o">.</span><span class="n">to_source</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Parentheses are added everywhere to avoid dealing with operator precedence, but otherwise it’s the same code we parsed.</p>

<p>And the last thing we usually do to AST — compile it back and execute:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">code</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="s">''</span><span class="p">,</span> <span class="s">'exec'</span><span class="p">)</span>
</span><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class="line"><span class="k">exec</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="n">context</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Functions used here, <code>compile()</code> and <code>exec()</code>, are built-ins. And <code>code</code> is the same object type you can find introspecting <code>func.__code__</code>. By executing in a context we set all the names defined into that dict:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="o">&gt;&gt;&gt;</span> <span class="n">context</span>
</span><span class="line"><span class="p">{</span><span class="s">'func'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">__main__</span><span class="o">.</span><span class="n">func</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>So if all these were happening in a decorator we can get that function out of the context and substitute original one. Only the meat is left — walking the tree.</p>

<h2>AST Traversal</h2>

<p>Built-in ast module continues to aid us in this journey. It provides several utilities to ease tree walking and transformation. The lower level ones let us introspect nodes contents and iterate by them:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># Iterate fields with values</span>
</span><span class="line"><span class="o">&gt;&gt;&gt;</span> <span class="n">ast</span><span class="o">.</span><span class="n">iter_fields</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</span><span class="line"><span class="p">[(</span><span class="s">'args'</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">_ast</span><span class="o">.</span><span class="n">arguments</span> <span class="n">at</span> <span class="o">...&gt;</span><span class="p">),</span>
</span><span class="line"> <span class="p">(</span><span class="s">'body'</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">_ast</span><span class="o">.</span><span class="n">Return</span> <span class="n">at</span> <span class="o">...&gt;</span><span class="p">)]</span>
</span><span class="line">
</span><span class="line"><span class="c"># Iterate child nodes</span>
</span><span class="line"><span class="o">&gt;&gt;&gt;</span> <span class="n">ast</span><span class="o">.</span><span class="n">iter_child_nodes</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</span><span class="line"><span class="p">[</span><span class="o">&lt;</span><span class="n">_ast</span><span class="o">.</span><span class="n">arguments</span> <span class="o">...&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">_ast</span><span class="o">.</span><span class="n">Return</span> <span class="o">...&gt;</span><span class="p">]</span>
</span><span class="line">
</span><span class="line"><span class="c"># Just list available fields</span>
</span><span class="line"><span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span><span class="o">.</span><span class="n">_fields</span>
</span><span class="line"><span class="p">(</span><span class="s">'args'</span><span class="p">,</span> <span class="s">'body'</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>First of higher level ones is <code>NodeVisitor</code> — a base class implementing visitor pattern, the idea is to subclass it and define methods like <code>visit_&lt;NodeClass&gt;()</code>:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">NumberFinder</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">visit_Num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
</span><span class="line">        <span class="k">print</span> <span class="s">"Found number literal"</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">n</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">find_numbers</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
</span><span class="line">    <span class="n">NumberFinder</span><span class="p">()</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>This simple example finds all the number literals in given code. Just an example, but it could be grown into some magic number finding tool and wrapped into linter or code editor plugin.</p>

<p>The second base class ast provides is <code>NodeTransformer</code>. It works almost the same, but you can change a tree by returning new nodes from visit methods:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">ExprOptimizer</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeTransformer</span><span class="p">):</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">visit_BinOp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
</span><span class="line">        <span class="c"># Call .generic_visit() to transform sub-nodes</span>
</span><span class="line">        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</span><span class="line">        <span class="c"># If both operands are just numbers then precalculate</span>
</span><span class="line">        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Num</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Num</span><span class="p">:</span>
</span><span class="line">            <span class="n">op</span> <span class="o">=</span> <span class="n">AST_TO_OP</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">__class__</span><span class="p">]</span>
</span><span class="line">            <span class="k">return</span> <span class="n">Num</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">op</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
</span><span class="line">        <span class="k">else</span><span class="p">:</span>
</span><span class="line">            <span class="k">return</span> <span class="n">node</span>
</span><span class="line">
</span><span class="line"><span class="n">AST_TO_OP</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">    <span class="n">Add</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
</span><span class="line">    <span class="o">...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This one precalculates any expressions on number literals, quite neat for just a bunch of lines.</p>

<p>And last but not least we can use old and good recursive tree walking. This snippet makes python function return last expression in a way Ruby, CoffeScript and Clojure do:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">return_last</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
</span><span class="line">    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="s">'body'</span><span class="p">):</span>
</span><span class="line">        <span class="k">return</span>
</span><span class="line">    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">Expr</span><span class="p">):</span>
</span><span class="line">        <span class="n">tree</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Return</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span><span class="line">    <span class="k">else</span><span class="p">:</span>
</span><span class="line">        <span class="n">return_last</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note this code is simplified and hence broken, e.g. it will insert <code>return</code> into the end of while loop if there is an expression there.</p>

<h2>Going Forward</h2>

<p>This was an overview of what you can do with AST, and there were lots of things. This is, however, only a preface to the actual story. Next time I will concentrate on translation and will describe it in detail capturing a real use case.</p>

<p><strong>P.S.</strong> Second part is available <a href="/blog/2015/04/12/metaprogramming-beyond-decency-part-2/">here</a>.</p>
</div>


  </div></body></html>