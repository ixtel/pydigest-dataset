<html><body><div><div class="ArticleText">
<p class="FeatureByline">
           By <b>Jake Edge</b><br/>June 17, 2015
           </p>
<p> A 2013 <a href="https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers">Kickstarter
project</a> brought us <a href="https://micropython.org/">Micro Python</a>, which is a version
of Python 3 for microcontrollers, along with the <a href="http://docs.micropython.org/en/latest/quickref.html">pyboard</a> to
run it on.  Micro Python is a complete rewrite of the interpreter that
avoids some of the CPython (the canonical Python interpreter written in C)
implementation details that don't work well on microcontrollers.
I recently got my hands on a pyboard and decided to give it—and
Micro Python—a try. 

</p><p>
All of
the core Python language has been implemented in Micro Python, as well as a
number of the standard libraries. Some C-language Python standard
modules have not been ported—at least yet.  Beyond that, Micro Python
developer Damien George has added a library that simplifies access to the
pyboard and its peripherals (e.g. LEDs, buttons, accelerometer).  </p>

<a href="/Articles/648332/">
<img src="https://static.lwn.net/images/2015/pyboard-front-sm.jpg" border="0" hspace="5" align="right" alt="[pyboard front]"/>
</a>

<p> The key to running Python on a microcontroller (such as the <a href="http://www.st.com/web/en/catalog/mmc/SC1169/SS1577/LN1035">STM32F405</a>
used on the pyboard) is to keep memory usage low while still providing good
performance.  The footprint for Micro Python is 260KB (as <a href="https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/1198333">detailed</a>
in the "official end" message for the Kickstarter back in April), though
removing floating point support brings it down to 240KB. A stripped-down
version of 
the interpreter can be as small as 75KB (and run in 8KB of RAM), but leaves
out support for SD cards, FAT filesystems, USB serial ports, USB mass
storage, and so on.  </p>

<p> While Micro Python will run any Python 3.4 code, it is not
byte-code 
compatible with CPython.  In particular, it avoids heap allocations for
integer operations and for calling methods.  Heap allocations inevitably
lead to garbage collection, which can cause problems for time-critical
processing and for code running from interrupts (since garbage collection
is not reentrant).

</p><p> So Micro Python encodes "small" integers in the top 31 bits of
"pointers" on the stack (with the low bit set to one to distinguish them
from real pointers).  It also adds a new byte code (<tt>CALL_METHOD</tt>)
that retrieves the information it needs from the stack, rather than
creating a new object (which requires a heap allocation) as CPython does.
The latter is a technique adopted from <a href="http://pypy.org/">PyPy</a>.
Information about all of this is, unfortunately, buried in the first FAQ
entry on the Kickstarter page and is not separately linkable.  </p>

<p> Micro Python has four different "emitters" that generate different
kinds of code from the compiler.  The default byte-code emitter does what
its name implies: generates byte codes to run on the Micro Python
virtual machine.  The other emitters are accessed using Python decorators.
The native emitter (<tt>@micropython.native</tt>) translates each byte code
to ARM <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0210c/CACBCAAE.html">Thumb</a>
(the native code for the pyboard CPU) machine code.  The viper emitter
(<tt>@micropython.viper</tt>) also generates ARM Thumb code, but it further
optimizes integer operations to bypass the normal Python binary operation
runtime 
code, which speeds things up considerably.  Viper does not support all of
the Python language, however. The final emitter
(<tt>@micropython.asm_thumb</tt>) allows for inline assembly code using a
Python-like syntax.  The emitters are detailed in some of the Kickstarter
update entries: "<a href="https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/664832">The
3 different code emitters</a>", "<a href="https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/665145">The
3 different code emitters, part 2</a>", and "<a href="https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/667580">Inline
assembler</a>".  </p>

<p> The emitters are targeted at situations where better performance might
be needed for a time-critical section.  Both the native and viper emitters
generate faster code, but they also generate larger code.  Viper actually
generates somewhat smaller and faster (sometimes much faster) code than
native, but the viper emitter does not support all of the language
types and constructs (though it is still under development), so it may not
be the best choice for all cases.  Using the emitters is as simple as
decorating a function:
</p><pre>
    @micropython.native
    def foo(bar):
        ...
</pre>

<p>
The asm_thumb emitter allows Micro Python to easily
interface with assembly code; it handles putting function arguments into
registers according to the ARM <a href="https://en.wikipedia.org/wiki/Application_binary_interface#EABI">embedded-application
binary interface</a> (EABI), having the function return the contents of
register <tt>r0</tt>, and so on.  Python's syntax is used so that there are
no changes needed to the parser to support <tt>asm_thumb</tt>.  Here is a
snippet from the
example in the Kickstarter update posting:

</p><pre>
    @micropython.asm_thumb
    def delay(r0):
        b(loop_entry)      # branch to 'loop_entry'
	label(loop1)       # 'loop1' label
	movw(r1, 55999)    # move 55999 to register 1
	...
</pre><p>
Instead of the usual syntax, things like branches, labels, and opcodes are
encoded as functions for the emitter.


</p><p>
The <a href="http://docs.micropython.org/en/latest/">documentation</a> for
Micro Python is fairly extensive, covering the <a href="http://docs.micropython.org/en/latest/library/index.html#python-standard-libraries">standard
libraries</a> that come with it, as well as certain <a href="http://docs.micropython.org/en/latest/library/index.html#python-micro-libraries">libraries</a>
that have "micro-fied" in keeping with Micro Python's focus on small size.  Beyond
that, there are some <a href="https://github.com/micropython/micropython-lib">additional
libraries</a> that are not part of the standard Micro Python distribution, but that
can be downloaded and added as needed.
The documentation also covers the <a href="http://docs.micropython.org/en/latest/hardware/index.html">pyboard
hardware</a> and the <tt><a href="http://docs.micropython.org/en/latest/library/pyb.html">pyb</a></tt>
library written to access various features of the device.
</p>

<a href="/Articles/648333/">
<img src="https://static.lwn.net/images/2015/pyboard-back-sm.jpg" border="0" hspace="5" align="right" alt="[pyboard back]"/>
</a>

<p>
The board itself is perhaps two large postage stamps (or two large
coins) in size. It is powered by USB, which also acts as its means of
communication (as a serial port and a mass storage device).  The device
effectively has Python as its operating system; connecting to it with a
terminal program leads to
a Micro Python prompt.  The board can also boot into a Python program by putting a
suitable <tt>main.py</tt> in the boot filesystem.
</p>

<p>
There are two choices for the boot filesystem, either the small internal
partition in the microcontroller's 1MB flash or a micro SD card that has been
inserted 
into a slot on the board.  If there is a micro SD card present, it takes
precedence.  There are also two safe modes that are accessible by holding
down buttons at boot time: one that can bypass the startup
scripts (both a <tt>boot.py</tt> and the <tt>main.py</tt> that get run by
default) and another that resets the filesystem in the flash partition to
its factory default state.
</p>

<p>
A third way to run code on the device is to use <tt><a href="https://github.com/micropython/micropython/blob/master/tools/pyboard.py">pyboard.py</a></tt>
to transfer a file over the serial connection and run it on the board.  So
if you get tired of typing a program at the prompt, or uploading it to the
flash or SD card and rebooting, you can edit it locally, then send and run it all at once.
</p>

<p>
The pyboard has two buttons (one reset, RST, and one user definable, USR),
four LEDs, 
an accelerometer, a realtime 
clock, and 30 general-purpose I/O (GPIO) pins.  The <tt>pyb</tt> library has made it easy to access
this functionality.  For example:
</p><pre>
    Micro Python v1.3.10 on 2015-02-13; PYBv1.0 with STM32F405RG
    
    &gt;&gt;&gt; leds = [pyb.LED(n) for n in range(1,5)]  # LEDs are numbered 1-4
    &gt;&gt;&gt; for i in range(10):
    ...     for l in leds:
    ...         l.on()
    ...         pyb.delay(1000)
    ...         l.off()
    ... 
</pre>


<p>
That program will blink each LED in turn for one second
(<tt>pyb.delay()</tt> is in milliseconds) ten times.  A somewhat more
complex example reads the USR button to stop the loop:
</p><pre>
    &gt;&gt;&gt; sw = pyb.Switch()
    &gt;&gt;&gt; flag = True
    &gt;&gt;&gt; while flag:
    ...     for l in leds:
    ...         l.on()
    ...         pyb.delay(200)
    ...         l.off()
    ...         if sw():
    ...             flag = False
    ... 
</pre>


<p>
Hitting the RST button instead of USR (as I did, twice, sadly) will only
lead to having to type the code in again (or to using one of the other means
for running the code).  One final example:
</p><pre>
    &gt;&gt;&gt; acc = pyb.Accel()
    &gt;&gt;&gt; while True:
    ...     print(acc.x(), acc.y(), acc.z())
    ...     pyb.delay(200)
    ... 
    2 0 22
    -8 5 17
    -11 4 18
    -16 4 12
    ...
</pre>


<p>
The accelerometer returns signed values -30 to 30 for each of the three
axes.  The <a href="https://micropython.org/doc/tut-accel">accelerometer
tutorial page</a> has some additional examples.  In fact, the <a href="http://docs.micropython.org/en/latest/tutorial/index.html">Micro Python
tutorial</a> has much of interest (e.g. <a href="http://docs.micropython.org/en/latest/tutorial/usb_mouse.html">turning
the pyboard into a USB mouse</a>).
</p>

<p>
Overall, the pyboard is an interesting device to play with.  One
can imagine various kinds of gadgets that could be built (or prototyped)
using it.  The recently completed
<a href="https://www.kickstarter.com/projects/wipy/the-wipy-the-internet-of-things-taken-to-the-next/description">WiPy
Kickstarter</a> envisions Micro Python as an entrant into the Internet of Things
(IoT) sweepstakes.   The Micro Python <a href="https://micropython.org/store/">store</a> also has devices of various
sorts that can be hooked up to the pyboard.
</p>

<p>
Micro Python and the pyboard are in some ways reminiscent of the <a href="/Articles/641244/">Python in the GRUB bootloader</a> project (known
as the <a href="http://biosbits.org/">BIOS Implementation Test Suite</a> or
BITS) that was presented at PyCon.  One big difference is that Micro Python only
implements Python 3; another is the size of the systems targeted.  But
getting a Python prompt when booting a system is a reminder of days gone
by—when a BASIC (or DOS) prompt would greet computer users. 
</p>

<p>
There are plenty of other things to investigate with the pyboard: <a href="https://github.com/micropython/micropython/wiki/Pyboard-Firmware-Update">updating
the firmware</a> to <a href="http://micropython.org/download/">something
more recent</a> than February, for example, or messing around with
interrupts from the switch rather than polling. 
For those looking for an easily programmed microcontroller to use in a
project, the pyboard may fit the bill well.  As mentioned, the tutorial has
some interesting ideas, but others are also starting to use the board
(e.g. to
control a <a href="https://hackaday.io/project/3694-henk-hexapod-robot">hexapod
robot</a>).  The Raspberry Pi and other single-board computers
also support Python, of course, but they are a far more heavyweight
solution.  For smaller tasks, especially those that need to be battery
operated, the pyboard is definitely an attractive option.</p><hr align="left"/><p>
           (</p><a href="https://lwn.net/login?target=/Articles/648051/">Log in</a><p> to post comments)
           </p><p>
           
</p></div> 
</div></body></html>