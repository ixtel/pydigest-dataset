<html><body><div><div dir="ltr" trbidi="on"><p>
Не знаю кто как, а я ленивый. Писать длинные строки кода, или повторять один и то-же код много раз в разных местах мне кажется неправильным и нерациональным. Это утверждение в полной мере относится и к записи отладочных сообщений. Если мне нужно организовать правильную запись логов в проекте, многочисленные мануалы рекомендуют использовать примерно такое:</p>

<a name="more"/>
<div>
<pre><span>import</span> <span>logging</span>
logger <span>=</span> logging<span>.</span>getLogger()
<span>...</span>
logger<span>.</span>debug(<span>&lt;</span><span>сообщение</span> <span>уровня</span> DEBUG<span>&gt;</span>)
<span>...</span>
</pre>
</div>
<p>
В принципе,- всё ок, если делаем линейный скрипт или классы в одном файле. Можно использовать глобальную переменную, или, на худой конец, определять logger в каждом классе. А если классов,- сто? и в девятнадцати разных модулях? Лениво и неинтересно, давайте попробуем разные способы упростить себе жизнь:

</p><b>Решение №1 "Логгер-переменная"</b><p>:</p><p>
инициализировать логгер с помощью logger = logging.getLogger() и использовать во всех местах где хочется:

</p><div>
<pre>logger <span>=</span> logging<span>.</span>getLogger()
<span>...</span>
<span>def</span> <span>superfunc</span>(<span>*</span>args):
    <span>global</span> logger
    logger<span>.</span>debug(<span>'superfunc!'</span>)
</pre>
</div>
<p>
Быстро, экономно, но не интересно: зачем вообще заморачиваться с логгингом, если не использовать одну из самых лучших возможностей модуля,- фильтрация логов по источнику? Ведь в этом варианте у нас будет использоваться один и тот-же логгер для всех сообщений, с таким-же успехом можно написать функцию-обёртку над print() для разделения по уровням отладки или использовать print напрямую.

</p><b>Решение №2 "Логгер как класс"</b><p>:</p><p>
обернуть логгер и его методы в отдельный класс и использовать объект этого класса везде где нужно.

</p><div>
<pre><span>import</span> <span>logging</span>
<span>class</span> <span>MyLogger</span>(): 
    <span>def</span> <span>__init__</span>(<span>self</span>):
        <span>self</span><span>.</span>logger <span>=</span> logging<span>.</span>getLogger() 
    <span>def</span> <span>debug</span>(<span>self</span>, msg):
        <span>self</span><span>.</span>logger<span>.</span>debug(msg)
</pre>
</div>
<p>
Ничем не лучше, чем глобальная переменная,- все вызовы записи в лог идут из одних и тех-же методов-обёрток, что сводит возможности фильтрации сообщений по источнику к нулю. Кроме того, это даже хуже, если учитывать промежуточный класс и его экземпляры. А даже если и заморочиться с реализацией синглетона,- не имеет смысла по соображениям, приведённым выше.

</p><b>Решение №3 "Объектно-ориентированное логирование"</b><p>:</p><p>
наследовать все классы от волшебного класса </p><b>LoggingMix</b><p>,</p><b> </b><p>написанного один раз и содержащего обёртки к методам экземпляра класса логирования. При этом логгер можно закопать в сам экземпляр класса-наследника, или даже сделать псевдо-Singleton на уровне корневого класса </p><b>LoggingMix</b><p> или классов-наследников. Что-бы не писать лишнего,- обёртки над методами логгера реализуем через лямбда-функции:


</p><div>
<pre><span>class</span> <span>LoggingMix</span>():

    <span>def</span> <span>get_logger</span>(<span>self</span>):
        <span>if</span> <span>not</span> <span>hasattr</span>(<span>self</span><span>.</span>__class__, <span>'__logger'</span>):
            logger <span>=</span> <span>self</span><span>.</span>__class__<span>.</span>__logger <span>=</span> logging<span>.</span>getLogger(<span>self</span><span>.</span>__class__<span>.</span>__module__)
         
        <span>return</span> <span>self</span><span>.</span>__class__<span>.</span>__logger 
     
    logger <span>=</span> <span>property</span>( get_logger )
    critical <span>=</span> <span>lambda</span> <span>self</span>,msg: <span>self</span><span>.</span>logger<span>.</span>critical(msg)
    error <span>=</span> <span>lambda</span> <span>self</span>,msg: <span>self</span><span>.</span>logger<span>.</span>error(msg)
    warning <span>=</span> <span>lambda</span> <span>self</span>,msg: <span>self</span><span>.</span>logger<span>.</span>warning(msg)
    info <span>=</span> <span>lambda</span> <span>self</span>,msg: <span>self</span><span>.</span>logger<span>.</span>info(msg)

    debug <span>=</span> <span>lambda</span> <span>self</span>,msg: <span>self</span><span>.</span>logger<span>.</span>debug(msg)
</pre>
</div>
<p>
Тоже плохо: экземпляры дочерних классов становятся "тяжелее" на объект логгера, кроме того, при форматировании отладочных сообщений параметр %(lineno)s продолжает указывать на строку в суперклассе </p><b>LoggingMix</b><p>.

</p><b>Решение №4 "Ныряем в ООП":</b><p>
Предыдущее решение было почти правильным, но не доведённым до конца. Зачем нам методы-обёртки вызывающие методы экземпляра? Ведь эти методы уже есть у логгера, прикрутим тёплое к мягкому, в смысле используем нужные методы экземпляра логгера прямо в дочернем классе:

</p><div>
<pre><span>class</span> <span>LoggingMix</span>():
    
    <span>def</span> <span>__getattr__</span>(<span>self</span>, name):

        <span>if</span> name <span>in</span> [<span>'critical'</span>,<span>'error'</span>,<span>'warning'</span>,<span>'info'</span>,<span>'debug'</span>]:
            <span>if</span> <span>not</span> <span>hasattr</span>(<span>self</span><span>.</span>__class__, <span>'__logger'</span>):
                <span>self</span><span>.</span>__class__<span>.</span>__logger <span>=</span> logging<span>.</span>getLogger(<span>self</span><span>.</span>__class__<span>.</span>__module__)

            <span>return</span> <span>getattr</span>(<span>self</span><span>.</span>__class__<span>.</span>__logger, name)


        <span>return</span> <span>super</span>(LoggingMix, <span>self</span>)<span>.</span>__getattr__(name)
</pre>
</div>
<p>
А вот это уже близко к истине. Наследование от такого класс позволяет использовать логгирование в экземплярах наследников вида self.debug(), кроме того не перекрываются номера строк. Кроме того, можно наследовать от такого класса практически где угодно, даже, например, в моделях или методах Django Class Based View:


</p><div>
<pre><span>from</span> <span>mylogging</span> <span>import</span> LoggingMix</pre>
<pre><pre><span>from</span> <span>django.db</span> <span>import</span> models</pre>
<span>class</span> <span>ObjectWithLogging</span>(LoggingMix, models<span>.</span>Model):
  
    <span>def</span> <span>__init__</span>(<span>self</span>):
        <span>self</span><span>.</span>debug(<span>'init!'</span>)

<span>class</span> <span>CreateViewWithLogging</span>(LoggingMix, CreateView):
  
    <span>def</span> <span>dispatch</span>(<span>self</span>, <span>*</span>args, <span>**</span>kwargs):
        <span>self</span><span>.</span>debug(<span>'dispatch started!'</span>)
</pre>
</div>
</div>
</div></body></html>