<html><body><div><div class="body" lang="en">
    <section class="sec" id="intro">
      <h2 class="heading">Introduction</h2>
      <p id="p-1">In our data-rich world, images represent a significant subset of all measurements made. Examples include DNA microarrays, microscopy slides, astronomical observations, satellite maps, robotic vision capture, synthetic aperture radar images, and higher-dimensional images such as 3-D magnetic resonance or computed tomography imaging. Exploring these rich data sources requires sophisticated software tools that should be easy to use, free of charge and restrictions, and able to address all the challenges posed by such a diverse field of analysis.</p>
      <p id="p-2">This paper describes scikit-image, a collection of image processing algorithms implemented in the Python programming language by an active community of volunteers and available under the liberal BSD Open Source license. The rising popularity of Python as a scientific programming language, together with the increasing availability of a large eco-system of complementary tools, makes it an ideal environment in which to produce an image processing toolkit.</p>
      <p id="p-3">The project aims are:</p>
      <ol class="list" id="list-1" data-jats-list-type="order">
        <li class="list-item">
          
          <p id="p-4">
            <i>To provide high quality, well-documented and easy-to-use implementations of common image processing algorithms.</i>
          </p>
          <p id="p-5">Such algorithms are essential building blocks in many areas of scientific research, algorithmic comparisons and data exploration. In the context of reproducible science, it is important to be able to inspect any source code used for algorithmic flaws or mistakes. Additionally, scientific research often requires custom modification of standard algorithms, further emphasizing the importance of open source.</p>
        </li>
        <li class="list-item">
          
          <p id="p-6">
            <i>To facilitate education in image processing.</i>
          </p>
          <p id="p-7">The library allows students in image processing to learn algorithms in a hands-on fashion by adjusting parameters and modifying code. In addition, a <span class="monospace">novice</span> module is provided, not only for teaching programming in the “turtle graphics” paradigm, but also to familiarize users with image concepts such as color and dimensionality. Furthermore, the project takes part in the yearly Google Summer of Code program<a class="xref xref-fn" href="#peerj-453-fn1" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn1"><sup>1</sup></a>, where students learn about image processing and software engineering through contributing to the project.</p>
        </li>
        <li class="list-item">
          
          <p id="p-9">
            <i>To address industry challenges.</i>
          </p>
          <p id="p-10">High quality reference implementations of trusted algorithms provide industry with a reliable way of attacking problems without having to expend significant energy in re-implementing algorithms already available in commercial packages. Companies may use the library entirely free of charge, and have the option of contributing changes back, should they so wish.</p>
        </li>
      </ol>
    </section>
    <section class="sec">
      <h2 class="heading">Getting started</h2>
      <p id="p-11">One of the main goals of scikit-image is to make it easy for any user to get started quickly—especially users already familiar with Python’s scientific tools. To that end, the basic image is just a standard NumPy array, which exposes pixel data directly to the user. A new user can simply load an image from disk (or use one of scikit-image’s sample images), process that image with one or more image filters, and quickly display the results:</p>
      <pre><code data-jats-preformat-type="python" data-jats-position="anchor">from skimage import data, io, filter

image = data.coins()  # or any NumPy array!
edges = filter.sobel(image)
io.imshow(edges)​</code>​</pre>
      <p id="p-12">The above demonstration loads <span class="monospace">data.coins</span>, an example image shipped with scikit-image. For a more complete example, we import NumPy for array manipulation and matplotlib for plotting (<a class="xref xref-bibr" href="https://doi.org/10.1109%2FMCSE.2011.37" title="The NumPy array: a structure for efficient numerical computation" data-jats-ref-type="bibr" data-jats-rid="ref-28">Van der Walt, Colbert &amp; Varoquaux, 2011</a>; <a class="xref xref-bibr" href="https://doi.org/10.1109%2FMCSE.2007.55" title="Matplotlib: A 2D Graphics Environment" data-jats-ref-type="bibr" data-jats-rid="ref-16">Hunter, 2007</a>). At each step, we add the picture or the plot to a matplotlib figure shown in <a class="xref xref-fig" href="#fig-1" data-jats-ref-type="fig" data-jats-rid="fig-1">Fig. 1</a>.</p>
      <pre><code data-jats-preformat-type="python" data-jats-position="anchor">import numpy as np
import matplotlib.pyplot as plt

# Load a small section of the image.
image = data.coins()[0:95, 70:370]

fig, axes = plt.subplots(ncols=2, nrows=3,
                         figsize=(8, 4))
ax0, ax1, ax2, ax3, ax4, ax5  = axes.flat
ax0.imshow(image, cmap=plt.cm.gray)
ax0.set_title('Original', fontsize=24)
ax0.axis('off')​</code>​</pre>
      <p id="p-13">Since the image is represented by a NumPy array, we can easily perform operations such as building a histogram of the intensity values.</p>
      <figure class="fig" itemprop="image" itemscope="itemscope" itemtype="https://schema.org/ImageObject" id="fig-1">
<figcaption itemprop="description">
          <h3 class="heading">
<span class="caption-label">Figure 1: </span>Illustration of several functions available in scikit-image: adaptive threshold, local maxima, edge detection and labels.</h3>
          <span class="p">The use of NumPy arrays as our data container also enables the use of NumPy’s built-in <i>histogram</i> function.</span>
        </figcaption></figure>
      <pre><code data-jats-preformat-type="python" data-jats-position="anchor"># Histogram.
values, bins = np.histogram(image,
                            bins=np.arange(256))

ax1.plot(bins[:-1], values, lw=2, c='k')
ax1.set_xlim(xmax=256)
ax1.set_yticks([0, 400])
ax1.set_aspect(.2)
ax1.set_title('Histogram', fontsize=24)​</code>​</pre>
      <p id="p-15">To divide the foreground and background, we threshold the image to produce a binary image. Several threshold algorithms are available. Here, we employ <span class="monospace">filter.threshold_adaptive</span> where the threshold value is the weighted mean for the local neighborhood of a pixel.</p>
      <pre><code data-jats-preformat-type="python" data-jats-position="anchor"># Apply threshold.
from skimage.filter import threshold_adaptive

bw = threshold_adaptive(image, 95, offset=-15)

ax2.imshow(bw, cmap=plt.cm.gray)
ax2.set_title('Adaptive threshold', fontsize=24)
ax2.axis('off')​</code>​</pre>
      <p id="p-16">We can easily detect interesting features, such as local maxima and edges. The function <span class="monospace">feature.peak_local_max</span> can be used to return the coordinates of local maxima in an image.</p>
      <pre><code data-jats-preformat-type="python" data-jats-position="anchor"># Find maxima.
from skimage.feature import peak_local_max

coordinates = peak_local_max(image, min_distance=20)

ax3.imshow(image, cmap=plt.cm.gray)
ax3.autoscale(False)
ax3.plot(coordinates[:, 1],
         coordinates[:, 0], c='r.')
ax3.set_title('Peak local maxima', fontsize=24)
ax3.axis('off')​</code>​</pre>
      <p id="p-17">Next, a Canny filter (<span class="monospace">filter.canny</span>) (<a class="xref xref-bibr" href="https://doi.org/10.1109%2FTPAMI.1986.4767851" title="A computational approach to edge detection" data-jats-ref-type="bibr" data-jats-rid="ref-7">Canny, 1986</a>) detects the edge of each coin.</p>
      <pre><code data-jats-preformat-type="python" data-jats-position="anchor"># Detect edges.
from skimage import filter

edges = filter.canny(image, sigma=3,
                     low_threshold=10,
                     high_threshold=80)

ax4.imshow(edges, cmap=plt.cm.gray)
ax4.set_title('Edges', fontsize=24)
ax4.axis('off')​</code>​</pre>
      <p id="p-18">Then, we attribute to each coin a label (<span class="monospace">morphology.label</span>) that can be used to extract a sub-picture. Finally, physical information such as the position, area, eccentricity, perimeter, and moments can be extracted using <span class="monospace">measure.regionprops</span>.</p>
      <pre><code data-jats-preformat-type="python" data-jats-position="anchor"># Label image regions.
from skimage.measure import regionprops
import matplotlib.patches as mpatches
from skimage.morphology import label

label_image = label(edges)

ax5.imshow(image, cmap=plt.cm.gray)
ax5.set_title('Labeled items', fontsize=24)
ax5.axis('off')

for region in regionprops(label_image):
    # Draw rectangle around segmented coins.
    minr, minc, maxr, maxc = region.bbox
    rect = mpatches.Rectangle((minc, minr),
                              maxc - minc,
                              maxr - minr,
                              fill=False,
                              edgecolor='red',
                              linewidth=2)
    ax5.add_patch(rect)

plt.tight_layout()
plt.show()​</code>​</pre>
      <p id="p-19">scikit-image thus makes it possible to perform sophisticated image processing tasks with only a few function calls.</p>
    </section>
    <section class="sec">
      <h2 class="heading">Library overview</h2>
      <p id="p-20">The scikit-image project started in August of 2009 and has received contributions from more than 100 individuals.<a class="xref xref-fn" href="#peerj-453-fn2" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn2"><sup>2</sup></a> The package can be installed on all major platforms (e.g., BSD, GNU/Linux, OS X, Windows) from, amongst other sources, the Python Package Index (PyPI),<a class="xref xref-fn" href="#peerj-453-fn3" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn3"><sup>3</sup></a> Continuum Analytics Anaconda,<a class="xref xref-fn" href="#peerj-453-fn4" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn4"><sup>4</sup></a> Enthought Canopy,<a class="xref xref-fn" href="#peerj-453-fn5" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn5"><sup>5</sup></a> Python(x,y),<a class="xref xref-fn" href="#peerj-453-fn6" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn6"><sup>6</sup></a> NeuroDebian (<a class="xref xref-bibr" href="https://doi.org/10.3389%2Ffninf.2012.00022" title="Open is not enough. Let’s take the next step: an integrated, community-driven computing platform for neuroscience" data-jats-ref-type="bibr" data-jats-rid="ref-14">Halchenko &amp; Hanke, 2012</a>) and GNU/Linux distributions such as Ubuntu.<a class="xref xref-fn" href="#peerj-453-fn7" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn7"><sup>7</sup></a> In March 2014 alone, the package was downloaded more than 5000 times from PyPI.<a class="xref xref-fn" href="#peerj-453-fn8" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn8"><sup>8</sup></a></p>
      <p id="p-28">As of version 0.10, the package contains the following sub-modules:</p>
      <ul class="list" id="list-2" data-jats-list-type="bullet">
        <li class="list-item">
          
          <p id="p-29">color: Color space conversion.</p>
        </li>
        <li class="list-item">
          
          <p id="p-30">data: Test images and example data.</p>
        </li>
        <li class="list-item">
          
          <p id="p-31">draw: Drawing primitives (lines, text, etc.) that operate on NumPy arrays.</p>
        </li>
        <li class="list-item">
          
          <p id="p-32">exposure: Image intensity adjustment, e.g., histogram equalization, etc.</p>
        </li>
        <li class="list-item">
          
          <p id="p-33">feature: Feature detection and extraction, e.g., texture analysis, corners, etc.</p>
        </li>
        <li class="list-item">
          
          <p id="p-34">filter: Sharpening, edge finding, rank filters, thresholding, etc.</p>
        </li>
        <li class="list-item">
          
          <p id="p-35">graph: Graph-theoretic operations, e.g., shortest paths.</p>
        </li>
        <li class="list-item">
          
          <p id="p-36">io: Wraps various libraries for reading, saving, and displaying images and video, such as Pillow<a class="xref xref-fn" href="#peerj-453-fn9" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn9"><sup>9</sup></a> and FreeImage.<a class="xref xref-fn" href="#peerj-453-fn10" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn10"><sup>10</sup></a></p>
        </li>
        <li class="list-item">
          
          <p id="p-39">measure: Measurement of image properties, e.g., similarity and contours.</p>
        </li>
        <li class="list-item">
          
          <p id="p-40">morphology: Morphological operations, e.g., opening or skeletonization.</p>
        </li>
        <li class="list-item">
          
          <p id="p-41">novice: Simplified interface for teaching purposes.</p>
        </li>
        <li class="list-item">
          
          <p id="p-42">restoration: Restoration algorithms, e.g., deconvolution algorithms, denoising, etc.</p>
        </li>
        <li class="list-item">
          
          <p id="p-43">segmentation: Partitioning an image into multiple regions.</p>
        </li>
        <li class="list-item">
          
          <p id="p-44">transform: Geometric and other transforms, e.g., rotation or the Radon transform.</p>
        </li>
        <li class="list-item">
          
          <p id="p-45">viewer: A simple graphical user interface for visualizing results and exploring parameters.</p>
        </li>
      </ul>
      <p id="p-46">For further details on each module, we refer readers to the API documentation online.<a class="xref xref-fn" href="#peerj-453-fn11" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn11"><sup>11</sup></a></p>
    </section>
    <section class="sec">
      <h2 class="heading">Data format and pipelining</h2>
      <p id="p-48">scikit-image represents images as NumPy arrays (<a class="xref xref-bibr" href="https://doi.org/10.1109%2FMCSE.2011.37" title="The NumPy array: a structure for efficient numerical computation" data-jats-ref-type="bibr" data-jats-rid="ref-28">Van der Walt, Colbert &amp; Varoquaux, 2011</a>), the de facto standard for storage of multi-dimensional data in scientific Python. Each array has a dimensionality, such as 2 for a 2-D grayscale image, 3 for a 2-D multi-channel image, or 4 for a 3-D multi-channel image; a shape, such as (<i>M</i>, <i>N</i>, 3) for an RGB color image with <i>M</i> vertical and <i>N</i> horizontal pixels; and a numeric data type, such as <span class="monospace">float</span> for continuous-valued pixels and <span class="monospace">uint8</span> for 8-bit pixels. Our use of NumPy arrays as the fundamental data structure maximizes compatibility with the rest of the scientific Python ecosystem. Data can be passed as-is to other tools such as NumPy, SciPy, matplotlib, scikit-learn (<a class="xref xref-bibr" href="https://scholar.google.com/scholar_lookup?title=Scikit-learn:%20Machine%20Learning%20in%20Python&amp;author=Pedregosa&amp;publication_year=2011" title="Scikit-learn: Machine Learning in Python" data-jats-ref-type="bibr" data-jats-rid="ref-22">Pedregosa et al., 2011</a>), Mahotas (<a class="xref xref-bibr" href="https://doi.org/10.5334%2Fjors.ac" title="Mahotas: open source software for scriptable computer vision" data-jats-ref-type="bibr" data-jats-rid="ref-8">Coelho, 2013</a>), OpenCV, and more.</p>
      <p id="p-49">Images of differing data-types can complicate the construction of pipelines. scikit-image follows an “Anything In, Anything Out” approach, whereby all functions are expected to allow input of an arbitrary data-type but, for efficiency, also get to choose their own output format. Data-type ranges are clearly defined. Floating point images are expected to have values between 0 and 1 (unsigned images) or −1 and 1 (signed images), while 8-bit images are expected to have values in {0, 1, 2, …, 255}. We provide utility functions, such as <span class="monospace">img_as_float</span>, to easily convert between data-types.</p>
    </section>
    <section class="sec">
      <h2 class="heading">Development practices</h2>
      <p id="p-50">The purpose of scikit-image is to provide a high-quality library of powerful, diverse image processing tools free of charge and restrictions. These principles are the foundation for the development practices in the scikit-image community.</p>
      <p id="p-51">The library is licensed under the <i>Modified BSD license</i>, which allows unrestricted redistribution for any purpose as long as copyright notices and disclaimers of warranty are maintained (<a class="xref xref-bibr" href="http://oss-watch.ac.uk/resources/modbsd" title="" data-jats-ref-type="bibr" data-jats-rid="ref-31">Wilson, 2012</a>). It is compatible with GPL licenses, so users of scikit-image can choose to make their code available under the GPL. However, unlike the GPL, it does not require users to open-source derivative work (BSD is not a so-called copyleft license). Thus, scikit-image can also be used in closed-source, commercial environments.</p>
      <p id="p-52">The development team of scikit-image is an open community that collaborates on the <i>GitHub</i> platform for issue tracking, code review, and release management.<a class="xref xref-fn" href="#peerj-453-fn12" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn12"><sup>12</sup></a><i>Google Groups</i> is used as a public discussion forum for user support, community development, and announcements.<a class="xref xref-fn" href="#peerj-453-fn13" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn13"><sup>13</sup></a></p>
      <p id="p-55">scikit-image complies with the PEP8 coding style standard (<a class="xref xref-bibr" href="http://www.python.org/dev/peps/pep-0008/" title="" data-jats-ref-type="bibr" data-jats-rid="ref-30">Van Rossum, Warsaw &amp; Coghlan, 2001</a>) and the NumPy documentation format (<a class="xref xref-bibr" href="https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt" title="" data-jats-ref-type="bibr" data-jats-rid="ref-29">Van der Walt &amp; NumPy developers, 2008</a>) in order to provide a consistent, familiar user experience across the library similar to other scientific Python packages. As mentioned earlier, the data representation used is <i>n</i>-dimensional NumPy arrays, which ensures broad interoperability within the scientific Python ecosystem. The majority of the scikit-image API is intentionally designed as a functional interface which allows one to simply apply one function to the output of another. This modular approach also lowers the barrier of entry for new contributors, since one only needs to master a small part of the entire library in order to make an addition.</p>
      <p id="p-56">We ensure high code quality by a thorough review process using the pull request interface on GitHub.<a class="xref xref-fn" href="#peerj-453-fn14" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn14"><sup>14</sup></a> This enables the core developers and other interested parties to comment on specific lines of proposed code changes, and for the proponents of the changes to update their submission accordingly. Once all the changes have been approved, they can be merged automatically. This process applies not just to outside contributions, but also to the core developers.</p>
      <p id="p-58">The source code is mainly written in Python, although certain performance critical sections are implemented in Cython, an optimising static compiler for Python (<a class="xref xref-bibr" href="https://doi.org/10.1109%2FMCSE.2010.118" title="Cython: the best of both worlds" data-jats-ref-type="bibr" data-jats-rid="ref-1">Behnel et al., 2011</a>). scikit-image aims to achieve full unit test coverage, which is above 87% as of release 0.10 and continues to rise. A continuous integration system<a class="xref xref-fn" href="#peerj-453-fn15" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn15"><sup>15</sup></a> automatically checks each commit for unit test coverage and failures on both Python 2 and Python 3. Additionally, the code is analyzed by flake8 (<a class="xref xref-bibr" href="https://pypi.python.org/pypi/flake8" title="" data-jats-ref-type="bibr" data-jats-rid="ref-9">Cordasco, 2010</a>) to ensure compliance with the PEP8 coding style standards (<a class="xref xref-bibr" href="http://www.python.org/dev/peps/pep-0008/" title="" data-jats-ref-type="bibr" data-jats-rid="ref-30">Van Rossum, Warsaw &amp; Coghlan, 2001</a>). Finally, the properties of each public function are documented thoroughly in an API reference guide, embedded as Python docstrings and accessible through the official project homepage or an interactive Python console. Short usage examples are typically included inside the docstrings, and new features are accompanied by longer, self-contained example scripts added to the narrative documentation and compiled to a gallery on the project website. We use Sphinx (<a class="xref xref-bibr" href="http://sphinx-doc.org/" title="" data-jats-ref-type="bibr" data-jats-rid="ref-4">Brandl, 2007</a>) to automatically generate both library documentation and the website.</p>
      <p id="p-60">The development master branch is fully functional at all times and can be obtained from GitHub<a class="xref xref-fn" href="#peerj-453-fn12" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn12"><sup>12</sup></a>. The community releases major updates as stable versions approximately every six months. Major releases include new features, while minor releases typically contain only bug fixes. Going forward, users will be notified about API-breaking changes through deprecation warnings for two full major releases before the changes are applied.</p>
    </section>
    <section class="sec">
      <h2 class="heading">Usage examples</h2>
      <section class="sec">
        <h3 class="heading">Research</h3>
        <p id="p-61">Often, a disproportionately large component of research involves dealing with various image data-types, color representations, and file format conversion. scikit-image offers robust tools for converting between image data-types (<a class="xref xref-bibr" href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd607323" title="" data-jats-ref-type="bibr" data-jats-rid="ref-18">Microsoft, 1995</a>; <a class="xref xref-bibr" href="https://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf" title="" data-jats-ref-type="bibr" data-jats-rid="ref-19">Munshi &amp; Leech, 2010</a>; <a class="xref xref-bibr" href="https://scholar.google.com/scholar_lookup?title=Proper%20treatment%20of%20pixels%20as%20integers&amp;author=Paeth&amp;publication_year=1990" title="Proper treatment of pixels as integers" data-jats-ref-type="bibr" data-jats-rid="ref-21">Paeth, 1990</a>) and to do file input/output (I/O) operations. Our purpose is to allow investigators to focus their time on research, instead of expending effort on mundane low-level tasks.</p>
        <p id="p-62">The package includes a number of algorithms with broad applications across image processing research, from computer vision to medical image analysis. We refer the reader to the current API documentation for a full listing of current capabilities<a class="xref xref-fn" href="#peerj-453-fn16" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn16"><sup>16</sup></a>. In this section we illustrate two real-world usage examples of scikit-image in scientific research.</p>
        <p id="p-64">First, we consider the analysis of a large stack of images, each representing drying droplets containing nanoparticles (see <a class="xref xref-fig" href="#fig-2" data-jats-ref-type="fig" data-jats-rid="fig-2">Fig. 2</a>). As the drying proceeds, cracks propagate from the edge of the drop to its center. The aim is to understand crack patterns by collecting statistical information about their positions, as well as their time and order of appearance. To improve the speed at which data is processed, each experiment, constituting an image stack, is automatically analysed without human intervention. The contact line is detected by a circular Hough transform (<span class="monospace">transform.hough_circle</span>) providing the drop radius and its center. Then, a smaller concentric circle is drawn (<span class="monospace">draw.circle_perimeter</span>) and used as a mask to extract intensity values from the image. Repeating the process on each image in the stack, collected pixels can be assembled to make a space–time diagram. As a result, a complex stack of images is reduced to a single image summarizing the underlying dynamic process.</p>
        <figure class="fig" itemprop="image" itemscope="itemscope" itemtype="https://schema.org/ImageObject" id="fig-2">
<figcaption itemprop="description">
            <h4 class="heading">
<span class="caption-label">Figure 2: </span>scikit-image is used to track the propagation of cracks (black lines) in a drying colloidal droplet.</h4>
            <span class="p">The sequence of pictures shows the temporal evolution of the system with the drop contact line, in green, detected by the Hough transform and the circle, in white, used to extract an annulus of pixel intensities. The result shown illustrates the angular position of cracks and their time of appearance.</span>
          </figcaption></figure>
        <p id="p-66">Next, in regenerative medicine research, scikit-image is used to monitor the regeneration of spinal cord cells in zebrafish embryos (<a class="xref xref-fig" href="#fig-3" data-jats-ref-type="fig" data-jats-rid="fig-3">Fig. 3</a>). This process has important implications for the treatment of spinal cord injuries in humans (<a class="xref xref-bibr" href="https://doi.org/10.1126%2Fscience.1098439" title="Cyclic amp-induced repair of zebrafish spinal circuits" data-jats-ref-type="bibr" data-jats-rid="ref-2">Bhatt et al., 2004</a>; <a class="xref xref-bibr" href="https://doi.org/10.1038%2Fnrn1955" title="Therapeutic interventions after spinal cord injury" data-jats-ref-type="bibr" data-jats-rid="ref-27">Thuret, Moon &amp; Gage, 2006</a>).</p>
        <p id="p-67">To understand how spinal cords regenerate in these animals, injured cords are subjected to different treatments. Neuronal precursor cells (labeled green in <a class="xref xref-fig" href="#fig-3" data-jats-ref-type="fig" data-jats-rid="fig-3">Fig. 3A</a>) are normally uniformly distributed across the spinal cord. At the wound site, they have been removed. We wish to monitor the arrival of new cells at the wound site over time. In <a class="xref xref-fig" href="#fig-3" data-jats-ref-type="fig" data-jats-rid="fig-3">Fig. 3</a>, we see an embryo two days after wounding, with precursor cells beginning to move back into the wound site (the site of minimum fluorescence). The <span class="monospace">measure.profile_line</span> function measures the fluorescence along the cord, directly proportional to the number of cells. We can thus monitor the recovery process and determine which treatments prevent or accelerate recovery.</p>
        <figure class="fig" itemprop="image" itemscope="itemscope" itemtype="https://schema.org/ImageObject" id="fig-3">
<figcaption itemprop="description">
            <h4 class="heading">
<span class="caption-label">Figure 3: </span>The <i>measure.profile_line</i> function being used to track recovery in spinal cord injuries.</h4>
            <span class="p">(A) An image of fluorescently-labeled nerve cells in an injured zebrafish embryo. (B) The automatically determined region of interest. The SciPy library was used to determine the region extent (<a class="xref xref-bibr" href="https://doi.org/10.1109%2FMCSE.2007.58" title="Python for scientific computing" data-jats-ref-type="bibr" data-jats-rid="ref-20">Oliphant, 2007</a>; <a class="xref xref-bibr" href="http://scipy.org" title="" data-jats-ref-type="bibr" data-jats-rid="ref-17">Jones, Oliphant &amp; Peterson, 2001</a>), and functions from the scikit-image draw module were used to draw it. (C) The image intensity along the line of interest, averaged over the displayed width.</span>
          </figcaption></figure>
      </section>
      <section class="sec">
        <h3 class="heading">Education</h3>
        <p id="p-69">scikit-image’s simple, well-documented application programming interface (API) makes it ideal for educational use, either via self-taught exploration or formal training sessions.</p>
        <p id="p-70">The online gallery of examples not only provides an overview of the functionality available in the package but also introduces many of the algorithms commonly used in image processing. This visual index also helps beginners overcome a common entry barrier: locating the class (denoising, segmentation, etc.) and name of operation desired, without being proficient with image processing jargon. For many functions, the documentation includes links to research papers or Wikipedia pages to further guide the user.</p>
        <p id="p-71">Demonstrating the broad utility of scikit-image in education, thirteen-year-old Rishab Gargeya of the Harker School won the Synopsys Silicon Valley Science and Technology Championship using scikit-image in his project, “A software based approach for automated pathology diagnosis of diabetic retinopathy in the human retina” (<a class="xref xref-bibr" href="http://science-fair.org/database/project_awards.php?schoolname=Privately+Sponsored+Project&amp;school_year=2014" title="" data-jats-ref-type="bibr" data-jats-rid="ref-26">science-fair.org, 2014</a>).</p>
        <p id="p-72">We have delivered image processing tutorials using scikit-image at various annual scientific Python conferences, such as PyData 2012, SciPy India 2012, and EuroSciPy 2013. Course materials for some of these sessions are found in <a class="xref xref-bibr" href="http://scipy-lectures.github.io/" title="" data-jats-ref-type="bibr" data-jats-rid="ref-13">Haenel, Gouillart &amp; Varoquaux (2014)</a> and are licensed under the permissive CC-BY license (<a class="xref xref-bibr" href="http://creativecommons.org/licenses/by/4.0/" title="" data-jats-ref-type="bibr" data-jats-rid="ref-10">Creative Commons, 2013</a>). These typically include an introduction to the package and provide intuitive, hands-on introductions to image processing concepts. The well documented application programming interface (API) along with tools that facilitate visualization contribute to the learning experience, and make it easy to investigate the effect of different algorithms and parameters. For example, when investigating denoising, it is easy to observe the difference between applying a median filter (<span class="monospace">filter.rank.median</span>) and a Gaussian filter (<span class="monospace">filter.gaussian_filter</span>), demonstrating that a median filter preserves straight lines much better.</p>
        <p id="p-73">Finally, easy access to readable source code gives users an opportunity to learn how algorithms are implemented and gives further insight into some of the intricacies of a fast Python implementation, such as indexing tricks and look-up tables.</p>
      </section>
      <section class="sec">
        <h3 class="heading">Industry</h3>
        <p id="p-74">Due to the breadth and maturity of its code base, as well as the its commercial-friendly license, scikit-image is well suited for industrial applications.</p>
        <p id="p-75">BT Imaging (<a class="uri" href="http://www.btimaging.com">http://www.btimaging.com</a>) designs and builds tools that use photoluminescence (PL) imaging for photovoltaic applications. PL imaging can characterize the quality of multicrystalline silicon wafers by illuminating defects that are not visible under standard viewing conditions. <a class="xref xref-fig" href="#fig-4" data-jats-ref-type="fig" data-jats-rid="fig-4">Figure 4A</a> shows an optical image of a silicon wafer, and <a class="xref xref-fig" href="#fig-4" data-jats-ref-type="fig" data-jats-rid="fig-4">Fig. 4B</a> shows the same wafer using PL imaging. In <a class="xref xref-fig" href="#fig-4" data-jats-ref-type="fig" data-jats-rid="fig-4">Fig. 4C</a>, the wafer defects and impurities have been detected through automated image analysis. scikit-image plays a key role in the image processing pipeline. For example, a Hough transform (<span class="monospace">transform.hough_line</span>) finds the wafer edges in order to segment the wafer from the background. scikit-image is also used for feature extraction. Crystal defects (dislocations) are detected using a band-pass filter, which is implemented as a Difference of Gaussians (<span class="monospace">filter.gaussian_filter</span>).</p>
        <p id="p-76">The image processing results are input to machine learning algorithms, which assess intrinsic wafer quality. Solar cell manufacturers can use this information to reject poor quality wafers and thereby increase the fraction of solar cells that have high solar conversion efficiency.</p>
        <figure class="fig" itemprop="image" itemscope="itemscope" itemtype="https://schema.org/ImageObject" id="fig-4">
<figcaption itemprop="description">
            <h4 class="heading">
<span class="caption-label">Figure 4: </span>Use of scikit-image to study silicon wafer impurities.</h4>
            <span class="p">(A) An image of an as-cut silicon wafer before it has been processed into a solar cell. (B) A PL image of the same wafer. Wafer defects, which have a negative impact solar cell efficiency, are visible as dark regions. (C) Image processing results. Defects in the crystal growth (dislocations) are colored blue, while red indicates the presence of impurities.</span>
          </figcaption></figure>
        <p id="p-78">scikit-image is also applied in a commercial setting for biometric security applications. AICBT Ltd uses multispectral imaging to detect when a person attempts to conceal their identity using a facial mask.<a class="xref xref-fn" href="#peerj-453-fn17" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn17"><sup>17</sup></a> scikit-image performs file I/O (<span class="monospace">io.imread</span>), histogram equalization (<span class="monospace">exposure.equalize_hist</span>), and aligns a visible wavelength image with a thermal image (<span class="monospace">transform.AffineTransform</span>). The system determines the surface temperature of a subject’s skin and detects situations where the face is being obscured.</p>
      </section>
    </section>
    <section class="sec">
      <h2 class="heading">Example: image registration and stitching</h2>
      <p id="p-80">This section gives a step-by-step outline of how to perform panorama stitching using the primitives found in scikit-image. The full source code is at <a class="uri" href="https://github.com/scikit-image/scikit-image-demos">https://github.com/scikit-image/scikit-image-demos</a>.</p>
      <section class="sec">
        <h3 class="heading">Data loading</h3>
        <p id="p-81">The “ImageCollection” class provides an easy way of representing multiple images on disk. For efficiency, images are not read until accessed.</p>
        <pre><code data-jats-preformat-type="python" data-jats-position="anchor">from skimage import io
ic = io.ImageCollection('data/*')​</code>​</pre>
        <p id="p-82"><a class="xref xref-fig" href="#fig-5" data-jats-ref-type="fig" data-jats-rid="fig-5">Figure 5A</a> shows the Petra dataset, which displays the same facade from two different angles. For this demonstration, we will estimate a projective transformation that relates the two images. Since the outer parts of these photographs do not conform well to such a model, we select only the central parts. To further speed up the demonstration, images are downscaled to 25% of their original size.</p>
        <figure class="fig" itemprop="image" itemscope="itemscope" itemtype="https://schema.org/ImageObject" id="fig-5">
<figcaption itemprop="description">
            <h4 class="heading">
<span class="caption-label">Figure 5: </span>An example application of scikit-image: image registration and warping to combine overlapping images.</h4>
            <span class="p">(A) Photographs taken in Petra, Jordan by François Malan. License: CC-BY. (B) Putative matches computed from ORB binary features. (C) Matches filtered using RANSAC. (D) The second input frame (middle) is warped to align with the first input frame (left), yielding the averaged image shown on the right. (E) The final panorama image, registered and warped using scikit-image, blended with Enblend.</span>
          </figcaption></figure>
        <pre><code data-jats-preformat-type="python" data-jats-position="anchor">from skimage.color import rgb2gray
from skimage import transform

image0 = rgb2gray(ic[0][:, 500:500+1987, :])
image1 = rgb2gray(ic[1][:, 500:500+1987, :])

image0 = transform.rescale(image0, 0.25)
image1 = transform.rescale(image1, 0.25)​</code>​</pre>
      </section>
      <section class="sec">
        <h3 class="heading">Feature detection and matching</h3>
        <p id="p-84">“Oriented FAST and rotated BRIEF” (ORB) features (<a class="xref xref-bibr" href="https://scholar.google.com/scholar_lookup?title=ORB:%20an%20efficient%20alternative%20to%20SIFT%20or%20SURF&amp;author=Rublee&amp;publication_year=2011" title="ORB: an efficient alternative to SIFT or SURF" data-jats-ref-type="bibr" data-jats-rid="ref-23">Rublee et al., 2011</a>) are detected in both images. Each feature yields a binary descriptor; those are used to find the putative matches shown in <a class="xref xref-fig" href="#fig-5" data-jats-ref-type="fig" data-jats-rid="fig-5">Fig. 5B</a>.</p>
        <pre><code data-jats-preformat-type="python" data-jats-position="anchor">from skimage.feature import ORB, match_descriptors

orb = ORB(n_keypoints=1000, fast_threshold=0.05)

orb.detect_and_extract(image0)
keypoints1 = orb.keypoints
descriptors1 = orb.descriptors

orb.detect_and_extract(image1)
keypoints2 = orb.keypoints
descriptors2 = orb.descriptors

matches12 = match_descriptors(descriptors1,
                              descriptors2,
                              cross_check=True)​</code>​</pre>
      </section>
      <section class="sec">
        <h3 class="heading">Transform estimation</h3>
        <p id="p-85">To filter the matches, we apply RANdom SAmple Consensus (RANSAC) (<a class="xref xref-bibr" href="https://doi.org/10.1145%2F358669.358692" title="Random sample consensus: a paradigm for model fitting with applications to image analysis and automated cartography" data-jats-ref-type="bibr" data-jats-rid="ref-12">Fischler &amp; Bolles, 1981</a>), a common method for outlier rejection. This iterative process estimates transformation models based on randomly chosen subsets of matches, finally selecting the model which corresponds best with the majority of matches. The new matches are shown in <a class="xref xref-fig" href="#fig-5" data-jats-ref-type="fig" data-jats-rid="fig-5">Fig. 5C</a>.</p>
        <pre><code data-jats-preformat-type="python" data-jats-position="anchor">from skimage.measure import ransac

# Select keypoints from the source (image to be
# registered) and target (reference image).

src = keypoints2[matches12[:, 1]][:, ::-1]
dst = keypoints1[matches12[:, 0]][:, ::-1]

model_robust, inliers = \
    ransac((src, dst), ProjectiveTransform,
           min_samples=4, residual_threshold=2)​</code>​</pre>
      </section>
      <section class="sec">
        <h3 class="heading">Warping</h3>
        <p id="p-86">Next, we produce the panorama itself. The first step is to find the shape of the output image by considering the extents of all warped images.</p>
        <pre><code data-jats-preformat-type="python" data-jats-position="anchor">r, c = image1.shape[:2]

# Note that transformations take coordinates in
# (x, y) format, not (row, column), in order to be
# consistent with most literature.
corners = np.array([[0, 0],
                    [0, r],
                    [c, 0],
                    [c, r]])

# Warp the image corners to their new positions.
warped_corners = model_robust(corners)

# Find the extents of both the reference image and
# the warped target image.
all_corners = np.vstack((warped_corners, corners))

corner_min = np.min(all_corners, axis=0)
corner_max = np.max(all_corners, axis=0)

output_shape = (corner_max - corner_min)
output_shape = np.ceil(output_shape[::-1])​</code>​</pre>
        <p id="p-87">The images are now warped according to the estimated transformation model. Values outside the input images are set to −1 to distinguish the “background”.</p>
        <p id="p-88">A shift is added to ensure that both images are visible in their entirety. Note that <span class="monospace">warp</span> takes the <i>inverse</i> mapping as input.</p>
        <pre><code data-jats-preformat-type="python" data-jats-position="anchor">from skimage.color import gray2rgb
from skimage.exposure import rescale_intensity
from skimage.transform import warp
from skimage.transform import SimilarityTransform

offset = SimilarityTransform(translation=-corner_min)

image0_ = warp(image0, offset.inverse,
               output_shape=output_shape, cval=-1)

image1_ = warp(image1, (model_robust + offset).inverse,
               output_shape=output_shape, cval=-1)​</code>​</pre>
        <p id="p-89">An alpha channel is added to the warped images before merging them into a single image:</p>
        <pre><code data-jats-preformat-type="python" data-jats-position="anchor">def add_alpha(image, background=-1):
    """Add an alpha layer to the image.

    The alpha layer is set to 1 for foreground
    and 0 for background.
    """
    rgb = gray2rgb(image)
    alpha = (image != background)
    return np.dstack((rgb, alpha))

image0_alpha = add_alpha(image0_)
image1_alpha = add_alpha(image1_)

merged = (image0_alpha + image1_alpha)
alpha = merged[..., 3]

# The summed alpha layers give us an indication of
# how many images were combined to make up each
# pixel.  Divide by the number of images to get
# an average.
merged /= np.maximum(alpha, 1)[..., np.newaxis]​</code>​</pre>
        <p id="p-90">The merged image is shown in <a class="xref xref-fig" href="#fig-5" data-jats-ref-type="fig" data-jats-rid="fig-5">Fig. 5D</a>. Note that, while the columns are well aligned, the color intensities at the boundaries are not well matched.</p>
      </section>
      <section class="sec">
        <h3 class="heading">Blending</h3>
        <p id="p-91">To blend images smoothly we make use of the open source package Enblend (<a class="xref xref-bibr" href="http://enblend.sourceforge.net/enblend.doc/enblend_4.1.pdf" title="" data-jats-ref-type="bibr" data-jats-rid="ref-11">Dersch, 2010</a>), which in turn employs multi-resolution splines and Laplacian pyramids (<a class="xref xref-bibr" href="https://doi.org/10.1109%2FTCOM.1983.1095851" title="The Laplacian pyramid as a compact image code" data-jats-ref-type="bibr" data-jats-rid="ref-5">Burt &amp; Adelson, 1983a</a>; <a class="xref xref-bibr" href="https://doi.org/10.1145%2F245.247" title="A multiresolution spline with application to image mosaics" data-jats-ref-type="bibr" data-jats-rid="ref-6">Burt &amp; Adelson, 1983b</a>). The final panorama is shown in <a class="xref xref-fig" href="#fig-5" data-jats-ref-type="fig" data-jats-rid="fig-5">Fig. 5E</a>.</p>
      </section>
    </section>
    <section class="sec" id="discussion">
      <h2 class="heading">Discussion</h2>
      <section class="sec">
        <h3 class="heading">Related work</h3>
        <p id="p-92">In this section, we describe other libraries with similar goals to ours.</p>
        <p id="p-93">Within the scientific Python ecosystem, <b>Mahotas</b> contains many similar functions, and is furthermore also designed to work with NumPy arrays (<a class="xref xref-bibr" href="https://doi.org/10.5334%2Fjors.ac" title="Mahotas: open source software for scriptable computer vision" data-jats-ref-type="bibr" data-jats-rid="ref-8">Coelho, 2013</a>). The major philosophical difference between Mahotas and scikit-image is that Mahotas is almost exclusively written in templated C++, while scikit-image is written in Python and Cython. We feel that our choice lowers the barrier of entry for new contributors. However, thanks to the interoperability between the two provided by the NumPy array data format, users don’t have to choose between them, and can simply use the best components of each.</p>
        <p id="p-94">ImageJ and its batteries-included <b>Fiji</b> distribution are probably the most popular open-source tools for image analysis (<a class="xref xref-bibr" href="https://doi.org/10.1038%2Fnmeth.2089" title="NIH image to ImageJ: 25 years of image analysis" data-jats-ref-type="bibr" data-jats-rid="ref-25">Schneider, Rasband &amp; Eliceiri, 2012</a>; <a class="xref xref-bibr" href="https://doi.org/10.1038%2Fnmeth.2019" title="Fiji: an open-source platform for biological-image analysis" data-jats-ref-type="bibr" data-jats-rid="ref-24">Schindelin et al., 2012</a>). Although Fiji’s breadth of functionality is unparalleled, it is centered around interactive, GUI use. For many developers, then, scikit-image offers several advantages. Although Fiji offers a programmable macro mode that supports many scripting languages, many of the macro functions activate GUI elements and cannot run in headless mode. This is problematic for data analysis in high-performance computing cluster environments or web backends, for example. Additionally, Fiji’s inclusive plugin policy results in an inconsistent API and variable documentation quality. Using scikit-image to develop new functionality or to build batch applications for distributed computing is often much simpler, thanks to its consistent API and the wide distribution of the scientific Python stack.</p>
        <p id="p-95">In many respects, the <b>image processing toolbox</b> of the Matlab environment is quite similar to scikit-image. For example, its API is mostly functional and applies to generic multidimensional numeric arrays. However, Matlab’s commercial licensing can be a significant nuisance to users. Additionally, the licensing cost increases dramatically for parallel computing, with per-worker pricing.<a class="xref xref-fn" href="#peerj-453-fn18" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn18"><sup>18</sup></a> Finally, the closed source nature of the toolbox prevents users from learning from the code or modifying it for specific purposes, which is a common necessity in scientific research. We refer readers back to the Development Practices section for a summary of the practical and philosophical advantages of our open-source licensing.</p>
        <p id="p-97"><b>OpenCV</b> is a BSD-licensed open-source library focused on computer vision, with a separate module for image processing (<a class="xref xref-bibr" href="https://scholar.google.com/scholar_lookup?title=The%20OpenCV%20library&amp;author=Bradski&amp;publication_year=2000" title="The OpenCV library" data-jats-ref-type="bibr" data-jats-rid="ref-3">Bradski, 2000</a>). It is developed in C/C++ and the project’s main aim is to provide implementations for real-time applications. This results in fast implementations with a comparatively high barrier of entry for code study and modification. The library provides interfaces for several high-level programming languages, including Python through the NumPy-array data-type for images. The Python interface is essentially a one-to-one copy of the underlying C/C++ API, and thus image processing pipelines have to follow an imperative programming style. In contrast, scikit-image provides a Pythonic interface with the option to follow an imperative or functional approach. Beyond that, OpenCV’s image processing module is traditionally limited to 2-dimensional imagery.</p>
        <p id="p-98">The choice of image processing package depends on several factors, including speed, code quality and correctness, community support, ecosystem, feature richness, and users’ ability to contribute. Sometimes, advantages in one factor come at the cost of another. For example, our approach of writing code in a high-level language may affect performance, or our strict code review guidelines may hamper the number of features we ultimately provide. We motivate our design decisions for scikit-image in the Development Practices section, and leave readers to decide which library is right for them.</p>
      </section>
      <section class="sec">
        <h3 class="heading">Roadmap</h3>
        <p id="p-99">In many open source projects, decisions about future development are made through “rough consensus and working code” (<a class="xref xref-bibr" href="http://www.ietf.org/tao.html" title="The tao of IETF: a novice’s guide to the internet engineering task force" data-jats-ref-type="bibr" data-jats-rid="ref-15">Hoffman, 2014</a>). In scikit-image there are two ways to propose new ideas: through discussion on the mailing list, or as pull requests. The latter route has the advantage of a concrete implementation to guide the conversation, and often mailing list discussions also result in a request for a proof of concept implementation. While conversations are usually led by active developers, the entire community is invited to participate. Once general agreement is reached that the proposed idea aligns with the current project goals and is feasible, work is divided on a volunteer basis. As such, the schedule for completion is often flexible.</p>
        <p id="p-100">The following goals have been identified for the next release of scikit-image:</p>
        <ul class="list" id="list-3" data-jats-list-type="bullet">
          <li class="list-item">
            
            <p id="p-101">Obtain full test coverage.</p>
          </li>
          <li class="list-item">
            
            <p id="p-102">Overhaul the functions for image reading/writing.</p>
          </li>
          <li class="list-item">
            
            <p id="p-103">Improve the project infrastructure, e.g., create an interactive gallery of examples.</p>
          </li>
          <li class="list-item">
            
            <p id="p-104">Add support for graph-based operations.</p>
          </li>
          <li class="list-item">
            
            <p id="p-105">Significantly extend higher dimensional (multi-layer) support.</p>
          </li>
        </ul>
        <p id="p-106">We also invite readers to submit their own feature requests to the mailing list for further discussion.</p>
      </section>
    </section>
    <section class="sec">
      <h2 class="heading">Conclusion</h2>
      <p id="p-107">scikit-image provides easy access to a powerful array of image processing functionality. Over the past few years, it has seen significant growth in both adoption and contribution,<a class="xref xref-fn" href="#peerj-453-fn19" data-jats-ref-type="fn" data-jats-rid="peerj-453-fn19"><sup>19</sup></a> and the team is excited to collaborate with others to see it grow even further, and to establish it the de facto library for image processing in Python.</p>
    </section>
  </div>
</div></body></html>