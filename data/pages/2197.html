<html><body><div><div class="article-bumper" ng-if="articles[0].showLogo &amp;&amp; articles[0].partner.top.text | partnerBumperLinks:articles[0].partner.top.id" ng-bind-html="articles[0].partner.top.text | partnerBumperLinks:articles[0].partner.top.id">
                <p>The Web Dev Zone is brought to you in partnership with <a href="http://ww2.mendix.com/forrester-low-code-application-platform.html?utm_source=DZone&amp;utm_medium=syndication&amp;utm_campaign=report" target="_blank" rel="nofollow">Mendix</a>. Download this <a href="http://ww2.mendix.com/forrester-low-code-application-platform.html?utm_source=DZone&amp;utm_medium=syndication&amp;utm_campaign=report" target="_blank" rel="nofollow">Forrester Report</a> to gain a better understanding of the low-code platform market and how to make a strategic platform selection you won’t regret.</p>
            </div>
            <div class="content-html" dz-code-container="" itemprop="articleBody"><p>In the development of most services there is a need in the internal billing for service accounts. <a href="http://bitcalm.com/?utm_source=HRD&amp;utm_medium=Articles&amp;utm_campaign=HRD%20%2B%20Billing%20%2B%2016.01" target="">Our service</a> also had such a problem. We were not able to find ready-made packages for its solution and in the end had to develop a billing system from scratch.</p><p>In this article I want to talk about our experiences and pitfalls encountered during development.</p><h2>Tasks</h2><p>Tasks that we had to solve were typical for any cash accounting system: the acceptance of payments, transaction log, typical payment and recurring payments (subscription).</p><h2>Transaction</h2><p>Transaction was obviously selected as a basic unit of the syste. For the transaction we have written the following simple model:</p><pre class="brush:as3">class UserBalanceChange(models.Model):
    user = models.ForeignKey('User', related_name='balance_changes')
    reason = models.IntegerField(choices=REASON_CHOICES, default=NO_REASO)
    amount = models.DecimalField(_('Amount'), default=0, max_digits=18, decimal_places=6)
    datetime = models.DateTimeField(_('date'), default=timezone.now)</pre><p>The transaction consists of links to the user, the reasons for the replenishment (or transaction), the transaction amount and time of the transaction.</p><h2>Balance</h2><p>Balance of a user is very easy to calculate by using the <a href="https://docs.djangoproject.com/en/dev/topics/db/aggregation/" target="">annotate</a>  function of ORM Django (consider the sum of the values of the column), but we have faced with the fact that a with large number of transactions this operation overloads database. It was therefore decided to denormalize the database, add the "balance" field in the user model. This field is updated in the method "save"  in the "UserBalanceChange" model, and for the confidence in the relevance of the data in it we recalculate it every night.</p><p><span>It is, of course, more correct to store information about the current balance of a user in a cache (e.g., in Redis) and invalidate the model with each change.</span></p><h2>Receiving payments</h2><p>For the most popular system of payments there are ready-made bags, so, as a rule, there are no problems with their installation and configuration. Just follow a few simple steps:</p><ul><li><p>Register in the payment system;</p></li><li><p>Obtain the API keys;</p></li><li><p>Install the appropriate package for Django;</p></li><li><p>Implement a form of payment;</p></li><li>Implement the functions of the enrollment in the balance after payment.</li></ul><div><p>Payments acceptance is implemented very flexibly, for example, for the PayPal system the code looks like this:</p><pre class="brush:as3">from paypal.signals import result_received
def payment_received(sender, **kwargs):
    order = OrderForPayment.objects.get(id=kwargs['InvId'])
    user = User.objects.get(id=order.user.id)
    order.success=True
    order.save()
    try:
        sum = float(order.payment)
    except Exception, e:
        pass
    else:
        balance_change = UserBalanceChange(user=user, amount=sum, reason=BALANCE_REASONS.paypal)
        balance_change.save()</pre><p>Similarly, you can connect any payment system, such as B<span>raintree</span><span>, Stripe, etc.</span></p><h2><span>Debit</span></h2><p>To write off is a bit more complicated - before surgery it is necessary to check what the balance of the account  will be after the operation, the "honest" manner - using the annotate. This should be done in order not to serve user "on credit", which is especially important when the transactions are carried out on large sums of money.</p><pre class="brush:as3">payment_sum = 8.32
users = User.objects.filter(id__in=has_clients, balance__gt=payment_sum).select_related('tariff')</pre><p>Here we have written it without “annotate”, because in the future there are some additional checks.</p><h2>Repeated transaction</h2><p>Having dealt with the basics, move on to the fun part - recurring transactions. We need to hourly (let’s call it a "billing period") write off a certain amount of money from a user in accordance with his tariff planf. To implement this mechanism, we use a <a href="http://www.celeryproject.org" target="">celery</a>  - written task, which runs every hour. The logic in this moment is difficult to comprehend, since it is necessary to take into account many factors:</p><ul><li><p>between tasks in the celery  we will never have exactly one hour (billing period);</p></li><li><p>the user fills up the balance (it becomes&gt; 0) and gains access to services between billing periods, the shoot for the period would be unfair;</p></li><li><p>the user can change the tariff at any time;</p></li><li>celery mayfor some reason cease to perform tasks</li></ul></div><div><p>We tried to implement this algorithm without introducing an additional field, but it turned out to be inconvenient. So we had to add the  last_hourly_billing field to the User model, which indicates the time of the last repeted operation.</p><h2>The idea is:</h2><ul><li><p>Each billing period we look last_hourly_billing and write off according to the tariff plan, then update the last_hourly_billing field;</p></li><li><p>When changing the tariff plan, we debited for the past rate and update the last_hourly_billing field;</p></li><li>When you activate the service, we update the last_hourly_billing field.</li></ul><pre class="brush:as3">def charge_tariff_hour_rate(user):
    now = datetime.now
    second_rate = user.get_second_rate()
    hour_rate = (now - user.last_hourly_billing).total_seconds() * second_rate
    balance_change_reason = UserBalanceChange.objects.create(
                user=user,
                reason=UserBalanceChange.TARIFF_HOUR_CHARGE,
                amount=-hour_rate,
    )
    balance_change_reason.save()
    user.last_hourly_billing = now
    user.save()</pre><p><span>This system, unfortunately, is not flexible: if we add another type of recurring payments  we will have to add a new field. Rather, in the process of refactoring we will write an additional model. It might look like this:</span></p></div><div><div><pre class="brush:as3">class UserBalanceSubscriptionLast(models.Model):
    user = models.ForeignKey('User', related_name='balance_changes')
    subscription = models.ForeignKey('Subscription', related_name='subscription_changes')
    datetime = models.DateTimeField(_('date'), default=timezone.now)</pre></div><p><span>This model will allow a very flexible implementation of recurring payments.</span></p><h2>Dashboard</h2><p>We use <a href="https://bitbucket.org/izi/django-admin-tools/wiki/Home" target="">django-admin-tools</a>  for a convenient dashboard in the administration panel. We decided that we would track the following two important parameters:</p></div><div><p>The first indicator for us is a kind of indicator of growth (traction) of our start-up, the second is a recurrence (retention) of users.</p><p>How we implemented dashboard and how we monitor the metrics in <a href="http://bitcalm.com/?utm_source=HRD&amp;utm_medium=Articles&amp;utm_campaign=HRD%20%2B%20Billing%20%2B%2016.01" target="">our projec</a>  ? These are the questions for the next article.</p><p>I wish you all a successful adjustment of a billing system and hope you will receive more payments!</p></div><div><p>P.S. Already in the process of writing this article I found a complete package <a href="https://pypi.python.org/pypi/django-account-balances" target="">django-account-balances</a> I think this is worth paying your attention to, if you have a loyalty system.</p></div>
</div>
            </div></body></html>