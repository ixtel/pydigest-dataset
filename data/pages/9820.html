<html><body><div><article class="text">
        

        <header class="article-header">
            <h1 class="page-title">PEP 0513 -- A Platform Tag for Portable Linux Built Distributions</h1>
        </header>

        

 
  
  <hr/>
  
  <div class="section" id="abstract">
   
   <p>
    This PEP proposes the creation of a new platform tag for Python package built
distributions, such as wheels, called
    <tt class="docutils literal">
     manylinux1_{x86_64,i686}
    </tt>
    with
external dependencies limited to a standardized, restricted subset of
the Linux kernel and core userspace ABI. It proposes that PyPI support
uploading and distributing wheels with this platform tag, and that
    <tt class="docutils literal">
     pip
    </tt>
    support downloading and installing these packages on compatible platforms.
   </p>
  </div>
  <div class="section" id="rationale">
   
   <p>
    Currently, distribution of binary Python extensions for Windows and OS X is
straightforward. Developers and packagers build wheels
    <a class="footnote-reference" href="#id18" id="id1">
     [1]
    </a>
    <a class="footnote-reference" href="#id19" id="id2">
     [2]
    </a>
    , which are
assigned platform tags such as
    <tt class="docutils literal">
     win32
    </tt>
    or
    <tt class="docutils literal">
     macosx_10_6_intel
    </tt>
    , and upload
these wheels to PyPI. Users can download and install these wheels using tools
such as
    <tt class="docutils literal">
     pip
    </tt>
    .
   </p>
   <p>
    For Linux, the situation is much more delicate. In general, compiled Python
extension modules built on one Linux distribution will not work on other Linux
distributions, or even on different machines running the same Linux
distribution with different system libraries installed.
   </p>
   <p>
    Build tools using
    <a class="reference external" href="/dev/peps/pep-0425">
     PEP 425
    </a>
    platform tags
    <a class="footnote-reference" href="#id20" id="id3">
     [3]
    </a>
    do not track information about the
particular Linux distribution or installed system libraries, and instead assign
all wheels the too-vague
    <tt class="docutils literal">
     linux_i686
    </tt>
    or
    <tt class="docutils literal">
     linux_x86_64
    </tt>
    tags. Because of
this ambiguity, there is no expectation that
    <tt class="docutils literal">
     linux
    </tt>
    -tagged built
distributions compiled on one machine will work properly on another, and for
this reason, PyPI has not permitted the uploading of wheels for Linux.
   </p>
   <p>
    It would be ideal if wheel packages could be compiled that would work on
    <em>
     any
    </em>
    linux system. But, because of the incredible diversity of Linux systems -- from
PCs to Android to embedded systems with custom libcs -- this cannot
be guaranteed in general.
   </p>
   <p>
    Instead, we define a standard subset of the kernel+core userspace ABI that,
in practice, is compatible enough that packages conforming to this standard
will work on
    <em>
     many
    </em>
    linux systems, including essentially all of the desktop
and server distributions in common use. We know this because there are
companies who have been distributing such widely-portable pre-compiled Python
extension modules for Linux -- e.g. Enthought with Canopy
    <a class="footnote-reference" href="#id21" id="id4">
     [4]
    </a>
    and Continuum
Analytics with Anaconda
    <a class="footnote-reference" href="#id22" id="id5">
     [5]
    </a>
    .
   </p>
   <p>
    Building on the compability lessons learned from these companies, we thus
define a baseline
    <tt class="docutils literal">
     manylinux1
    </tt>
    platform tag for use by binary Python
wheels, and introduce the implementation of preliminary tools to aid in the
construction of these
    <tt class="docutils literal">
     manylinux1
    </tt>
    wheels.
   </p>
  </div>
  <div class="section" id="key-causes-of-inter-linux-binary-incompatibility">
   
   <p>
    To properly define a standard that will guarantee that wheel packages meeting
this specification will operate on
    <em>
     many
    </em>
    linux platforms, it is necessary to
understand the root causes which often prevent portability of pre-compiled
binaries on Linux. The two key causes are dependencies on shared libraries
which are not present on users' systems, and dependencies on particular
versions of certain core libraries like
    <tt class="docutils literal">
     glibc
    </tt>
    .
   </p>
   <div class="section" id="external-shared-libraries">
    
    <p>
     Most desktop and server linux distributions come with a system package manager
(examples include
     <tt class="docutils literal">
      APT
     </tt>
     on Debian-based systems,
     <tt class="docutils literal">
      yum
     </tt>
     on
     <tt class="docutils literal">
      RPM
     </tt>
     -based systems, and
     <tt class="docutils literal">
      pacman
     </tt>
     on Arch linux) that manages, among other
responsibilities, the installation of shared libraries installed to system
directories such as
     <tt class="docutils literal">
      /usr/lib
     </tt>
     . Most non-trivial Python extensions will depend
on one or more of these shared libraries, and thus function properly only on
systems where the user has the proper libraries (and the proper
versions thereof), either installed using their package manager, or installed
manually by setting certain environment variables such as
     <tt class="docutils literal">
      LD_LIBRARY_PATH
     </tt>
     to notify the runtime linker of the location of the depended-upon shared
libraries.
    </p>
   </div>
   <div class="section" id="versioning-of-core-shared-libraries">
    
    <p>
     Even if the developers a Python extension module wish to use no
external shared libraries, the modules will generally have a dynamic runtime
dependency on the GNU C library,
     <tt class="docutils literal">
      glibc
     </tt>
     . While it is possible, statically
linking
     <tt class="docutils literal">
      glibc
     </tt>
     is usually a bad idea because certain important C functions
like
     <tt class="docutils literal">
      dlopen()
     </tt>
     cannot be called from code that statically links
     <tt class="docutils literal">
      glibc
     </tt>
     . A
runtime shared library dependency on a system-provided
     <tt class="docutils literal">
      glibc
     </tt>
     is unavoidable
in practice.
    </p>
    <p>
     The maintainers of the GNU C library follow a strict symbol versioning scheme
for backward compatibility. This ensures that binaries compiled against an older
version of
     <tt class="docutils literal">
      glibc
     </tt>
     can run on systems that have a newer
     <tt class="docutils literal">
      glibc
     </tt>
     . The
opposite is generally not true -- binaries compiled on newer Linux
distributions tend to rely upon versioned functions in
     <tt class="docutils literal">
      glibc
     </tt>
     that are not
available on older systems.
    </p>
    <p>
     This generally prevents wheels compiled on the latest Linux distributions
from being portable.
    </p>
   </div>
  </div>
  <div class="section" id="the-manylinux1-policy">
   
   <p>
    For these reasons, to achieve broad portability, Python wheels
   </p>
   <ul class="simple">
    <li>
     should depend only on an extremely limited set of external shared
libraries; and
    </li>
    <li>
     should depend only on "old" symbol versions in those external shared
libraries; and
    </li>
    <li>
     should depend only on a widely-compatible kernel ABI.
    </li>
   </ul>
   <p>
    To be eligible for the
    <tt class="docutils literal">
     manylinux1
    </tt>
    platform tag, a Python wheel must
therefore both (a) contain binary executables and compiled code that links
    <em>
     only
    </em>
    to libraries with SONAMEs
included in the following list:
   </p>
   <pre class="literal-block">
libpanelw.so.5
libncursesw.so.5
libgcc_s.so.1
libstdc++.so.6
libm.so.6
libdl.so.2
librt.so.1
libcrypt.so.1
libc.so.6
libnsl.so.1
libutil.so.1
libpthread.so.0
libX11.so.6
libXext.so.6
libXrender.so.1
libICE.so.6
libSM.so.6
libGL.so.1
libgobject-2.0.so.0
libgthread-2.0.so.0
libglib-2.0.so.0
</pre>
   <p>
    and, (b) work on a stock CentOS 5.11
    <a class="footnote-reference" href="#id23" id="id6">
     [6]
    </a>
    system that contains the system
package manager's provided versions of these libraries.
   </p>
   <p>
    Because CentOS 5 is only available for x86_64 and i686 architectures,
these are the only architectures currently supported by the
    <tt class="docutils literal">
     manylinux1
    </tt>
    policy.
   </p>
   <p>
    On Debian-based systems, these libraries are provided by the packages
   </p>
   <pre class="literal-block">
libncurses5 libgcc1 libstdc++6 libc6 libx11-6 libxext6
libxrender1 libice6 libsm6 libgl1-mesa-glx libglib2.0-0
</pre>
   <p>
    On RPM-based systems, these libraries are provided by the packages
   </p>
   <pre class="literal-block">
ncurses libgcc libstdc++ glibc libXext libXrender
libICE libSM mesa-libGL glib2
</pre>
   <p>
    This list was compiled by checking the external shared library dependencies of
the Canopy
    <a class="footnote-reference" href="#id21" id="id7">
     [4]
    </a>
    and Anaconda
    <a class="footnote-reference" href="#id22" id="id8">
     [5]
    </a>
    distributions, which both include a wide array
of the most popular Python modules and have been confirmed in practice to work
across a wide swath of Linux systems in the wild.
   </p>
   <p>
    Many of the permitted system libraries listed above use symbol versioning
schemes for backward compatibility. The latest symbol versions provided with
the CentOS 5.11 versions of these libraries are:
   </p>
   <pre class="literal-block">
GLIBC_2.5
CXXABI_3.4.8
GLIBCXX_3.4.9
GCC_4.2.0
</pre>
   <p>
    Therefore, as a consequence of requirement (b), any wheel that depends on
versioned symbols from the above shared libraries may depend only on symbols
with the following versions:
   </p>
   <pre class="literal-block">
GLIBC &lt;= 2.5
CXXABI &lt;= 3.4.8
GLIBCXX &lt;= 3.4.9
GCC &lt;= 4.2.0
</pre>
   <p>
    These recommendations are the outcome of the relevant discussions in January
2016
    <a class="footnote-reference" href="#id24" id="id9">
     [7]
    </a>
    ,
    <a class="footnote-reference" href="#id25" id="id10">
     [8]
    </a>
    .
   </p>
   <p>
    Note that in our recommendations below, we do not suggest that
    <tt class="docutils literal">
     pip
    </tt>
    or PyPI should attempt to check for and enforce the details of this
policy (just as they don't check for and enforce the details of
existing platform tags like
    <tt class="docutils literal">
     win32
    </tt>
    ). The text above is provided (a)
as advice to package builders, and (b) as a method for allocating
blame if a given wheel doesn't work on some system: if it satisfies
the policy above, then this is a bug in the spec or the installation
tool; if it does not satisfy the policy above, then it's a bug in the
wheel. One useful consequence of this approach is that it leaves open
the possibility of further updates and tweaks as we gain more
experience, e.g., we could have a "manylinux 1.1" policy which targets
the same systems and uses the same
    <tt class="docutils literal">
     manylinux1
    </tt>
    platform tag (and
thus requires no further changes to
    <tt class="docutils literal">
     pip
    </tt>
    or PyPI), but that adjusts
the list above to remove libraries that have turned out to be
problematic or add libraries that have turned out to be safe.
   </p>
   <div class="section" id="libpythonx-y-so-1">
    
    <p>
     Note that
     <tt class="docutils literal">
      libpythonX.Y.so.1
     </tt>
     is
     <em>
      not
     </em>
     on the list of libraries that
a
     <tt class="docutils literal">
      manylinux1
     </tt>
     extension is allowed to link to. Explicitly linking
to
     <tt class="docutils literal">
      libpythonX.Y.so.1
     </tt>
     is unnecessary in almost all cases: the way
ELF linking works, extension modules that are loaded into the
interpreter automatically get access to all of the interpreter's
symbols, regardless of whether or not the extension itself is
explicitly linked against libpython. Furthermore, explicit linking to
libpython creates problems in the common configuration where Python is
not built with
     <tt class="docutils literal">
      <span class="pre">
       --enable-shared
      </span>
     </tt>
     . In particular, on Debian and
Ubuntu systems,
     <tt class="docutils literal">
      apt install pythonX.Y
     </tt>
     does not even install
     <tt class="docutils literal">
      libpythonX.Y.so.1
     </tt>
     , meaning that any wheel that
     <em>
      did
     </em>
     depend on
     <tt class="docutils literal">
      libpythonX.Y.so.1
     </tt>
     could fail to import.
    </p>
    <p>
     There is one situation where extensions that are linked in this way
can fail to work: if a host program (e.g.,
     <tt class="docutils literal">
      apache2
     </tt>
     ) uses
     <tt class="docutils literal">
      dlopen()
     </tt>
     to load a module (e.g.,
     <tt class="docutils literal">
      mod_wsgi
     </tt>
     ) that embeds the
CPython interpreter, and the host program does
     <em>
      not
     </em>
     pass the
     <tt class="docutils literal">
      RTLD_GLOBAL
     </tt>
     flag to
     <tt class="docutils literal">
      dlopen()
     </tt>
     , then the embedded CPython will
be unable to load any extension modules that do not themselves link
explicitly to
     <tt class="docutils literal">
      libpythonX.Y.so.1
     </tt>
     . Fortunately,
     <tt class="docutils literal">
      apache2
     </tt>
     <em>
      does
     </em>
     set the
     <tt class="docutils literal">
      RTLD_GLOBAL
     </tt>
     flag, as do all the other programs that
embed-CPython-via-a-dlopened-plugin that we could locate, so this does
not seem to be a serious problem in practice. The incompatibility with
Debian/Ubuntu is more of an issue than the theoretical incompatibility
with a rather obscure corner case.
    </p>
    <p>
     This is a rather complex and subtle issue that extends beyond
the scope of
     <tt class="docutils literal">
      manylinux1
     </tt>
     ; for more discussion see:
     <a class="footnote-reference" href="#id26" id="id11">
      [9]
     </a>
     ,
     <a class="footnote-reference" href="#id27" id="id12">
      [10]
     </a>
     ,
     <a class="footnote-reference" href="#id28" id="id13">
      [11]
     </a>
     .
    </p>
   </div>
   <div class="section" id="ucs-2-vs-ucs-4-builds">
    
    <p>
     All versions of CPython 2.x, plus CPython 3.0-3.2 inclusive, can be
built in two ABI-incompatible modes: builds using the
     <tt class="docutils literal">
      <span class="pre">
       --enable-unicode=ucs2
      </span>
     </tt>
     configure flag store Unicode data in UCS-2
(or really UTF-16) format, while builds using the
     <tt class="docutils literal">
      <span class="pre">
       --enable-unicode=ucs4
      </span>
     </tt>
     configure flag store Unicode data in
UCS-4. (CPython 3.3 and greater use a different storage method that
always supports UCS-4.) If we want to make sure
     <tt class="docutils literal">
      ucs2
     </tt>
     wheels don't
get installed into
     <tt class="docutils literal">
      ucs4
     </tt>
     CPythons and vice-versa, then something
must be done.
    </p>
    <p>
     An earlier version of this PEP included a requirement that
     <tt class="docutils literal">
      manylinux1
     </tt>
     wheels targeting these older CPython versions should
always use the
     <tt class="docutils literal">
      ucs4
     </tt>
     ABI. But then, in between the PEP's initial
acceptance and its implementation,
     <tt class="docutils literal">
      pip
     </tt>
     and
     <tt class="docutils literal">
      wheel
     </tt>
     gained
first-class support for tracking and checking this aspect of ABI
compatibility for the relevant CPython versions, which is a better
solution. So we now allow the
     <tt class="docutils literal">
      manylinux1
     </tt>
     platform tags to be used
in combination with any ABI tag. However, to maintain compatibility it
is crucial to ensure that all
     <tt class="docutils literal">
      manylinux1
     </tt>
     wheels include a
non-trivial abi tag. For example, a wheel built against a
     <tt class="docutils literal">
      ucs4
     </tt>
     CPython might have a name like:
    </p>
    <pre class="literal-block">
PKG-VERSION-cp27-cp27mu-manylinux1_x86_64.whl
                 ^^^^^^ Good!
</pre>
    <p>
     While a wheel built against the
     <tt class="docutils literal">
      ucs2
     </tt>
     ABI might have a name like:
    </p>
    <pre class="literal-block">
PKG-VERSION-cp27-cp27m-manylinux1_x86_64.whl
                 ^^^^^ Okay!
</pre>
    <p>
     But you should never have a wheel with a name like:
    </p>
    <pre class="literal-block">
PKG-VERSION-cp27-none-manylinux1_x86_64.whl
                 ^^^^ BAD! Don't do this!
</pre>
    <p>
     We note for information that the
     <tt class="docutils literal">
      ucs4
     </tt>
     ABI appears to be much more
widespread among Linux CPython distributors.
    </p>
   </div>
  </div>
  <div class="section" id="compilation-of-compliant-wheels">
   
   <p>
    The way glibc, libgcc, and libstdc++ manage their symbol versioning
means that in practice, the compiler toolchains that most developers
use to do their daily work are incapable of building
    <tt class="docutils literal">
     manylinux1
    </tt>
    -compliant wheels. Therefore we do not attempt to change
the default behavior of
    <tt class="docutils literal">
     pip wheel
    </tt>
    /
    <tt class="docutils literal">
     bdist_wheel
    </tt>
    : they will
continue to generate regular
    <tt class="docutils literal">
     linux_*
    </tt>
    platform tags, and developers
who wish to use them to generate
    <tt class="docutils literal">
     manylinux1
    </tt>
    -tagged wheels will
have to change the tag as a second post-processing step.
   </p>
   <p>
    To support the compilation of wheels meeting the
    <tt class="docutils literal">
     manylinux1
    </tt>
    standard, we
provide initial drafts of two tools.
   </p>
   <div class="section" id="docker-image">
    
    <p>
     The first tool is a Docker image based on CentOS 5.11, which is recommended as
an easy to use self-contained build box for compiling
     <tt class="docutils literal">
      manylinux1
     </tt>
     wheels
     <a class="footnote-reference" href="#id29" id="id14">
      [12]
     </a>
     . Compiling on a more recently-released linux distribution will generally
introduce dependencies on too-new versioned symbols. The image comes with a
full compiler suite installed (
     <tt class="docutils literal">
      gcc
     </tt>
     ,
     <tt class="docutils literal">
      g++
     </tt>
     , and
     <tt class="docutils literal">
      gfortran
     </tt>
     4.8.2) as
well as the latest releases of Python and
     <tt class="docutils literal">
      pip
     </tt>
     .
    </p>
   </div>
   <div class="section" id="auditwheel">
    
    <p>
     The second tool is a command line executable called
     <tt class="docutils literal">
      auditwheel
     </tt>
     <a class="footnote-reference" href="#id30" id="id15">
      [13]
     </a>
     that
may aid in package maintainers in dealing with third-party external
dependencies.
    </p>
    <p>
     There are at least three methods for building wheels that use third-party
external libraries in a way that meets the above policy.
    </p>
    <ol class="arabic simple">
     <li>
      The third-party libraries can be statically linked.
     </li>
     <li>
      The third-party shared libraries can be distributed in
separate packages on PyPI which are depended upon by the wheel.
     </li>
     <li>
      The third-party shared libraries can be bundled inside the wheel
libraries, linked with a relative path.
     </li>
    </ol>
    <p>
     All of these are valid option which may be effectively used by different
packages and communities. Statically linking generally requires
package-specific modifications to the build system, and distributing
third-party dependencies on PyPI may require some coordination of the
community of users of the package.
    </p>
    <p>
     As an often-automatic alternative to these options, we introduce
     <tt class="docutils literal">
      auditwheel
     </tt>
     .
The tool inspects all of the ELF files  inside a wheel to check for
dependencies on versioned symbols or external  shared libraries, and verifies
conformance with the
     <tt class="docutils literal">
      manylinux1
     </tt>
     policy. This  includes the ability to add
the new platform tag to conforming wheels. More importantly,
     <tt class="docutils literal">
      auditwheel
     </tt>
     has
the ability to automatically modify wheels that depend on external shared
libraries by copying those shared libraries from the system into the wheel
itself, and modifying the appropriate
     <tt class="docutils literal">
      RPATH
     </tt>
     entries such that these
libraries will be picked up at runtime. This accomplishes a similar result as
if the libraries had been statically linked without requiring changes to the
build system. Packagers are advised that bundling, like static linking, may
implicate copyright concerns.
    </p>
   </div>
  </div>
  <div class="section" id="bundled-wheels-on-linux">
   
   <p>
    While we acknowledge many approaches for dealing with third-party library
dependencies within
    <tt class="docutils literal">
     manylinux1
    </tt>
    wheels, we recognize that the
    <tt class="docutils literal">
     manylinux1
    </tt>
    policy encourages bundling external dependencies, a practice
which runs counter to  the package management policies of many linux
distributions' system package  managers
    <a class="footnote-reference" href="#id31" id="id16">
     [14]
    </a>
    ,
    <a class="footnote-reference" href="#id32" id="id17">
     [15]
    </a>
    . The primary purpose of
this is cross-distro compatibility.  Furthermore,
    <tt class="docutils literal">
     manylinux1
    </tt>
    wheels on PyPI
occupy a different  niche than the Python packages available through the
system package manager.
   </p>
   <p>
    The decision in this PEP to encourage departure from general Linux distribution
unbundling policies is informed by the following concerns:
   </p>
   <ol class="arabic simple">
    <li>
     In these days of automated continuous integration and deployment
pipelines, publishing new versions and updating dependencies is easier
than it was when those policies were defined.
    </li>
    <li>
     <tt class="docutils literal">
      pip
     </tt>
     users remain free to use the
     <tt class="docutils literal">
      <span class="pre">
       "--no-binary"
      </span>
     </tt>
     option if they want
to force local builds rather than using pre-built wheel files.
    </li>
    <li>
     The popularity of modern container based deployment and "immutable
infrastructure" models involve substantial bundling at the application
layer anyway.
    </li>
    <li>
     Distribution of bundled wheels through PyPI is currently the norm for
Windows and OS X.
    </li>
    <li>
     This PEP doesn't rule out the idea of offering more targeted binaries for
particular Linux distributions in the future.
    </li>
   </ol>
   <p>
    The model described in this PEP is most ideally suited for cross-platform
Python packages, because it means they can reuse much of the
work that they're already doing to make static Windows and OS X wheels. We
recognize that it is less optimal for Linux-specific packages that might
prefer to interact more closely with Linux's unique package management
functionality and only care about targeting a small set of particular distos.
   </p>
   <div class="section" id="security-implications">
    
    <p>
     One of the advantages of dependencies on centralized libraries in Linux is
that bugfixes and security updates can be deployed system-wide, and
applications which depend on these libraries will automatically feel the
effects of these patches when the underlying libraries are updated. This can
be particularly important for security updates in packages engaged in
communication across the network or cryptography.
    </p>
    <p>
     <tt class="docutils literal">
      manylinux1
     </tt>
     wheels distributed through PyPI that bundle security-critical
libraries like OpenSSL will thus assume responsibility for prompt updates in
response disclosed vulnerabilities and patches. This closely parallels the
security implications of the distribution of binary wheels on Windows that,
because the platform lacks a system package manager, generally bundle their
dependencies. In particular, because it lacks a stable ABI, OpenSSL cannot be
included in the
     <tt class="docutils literal">
      manylinux1
     </tt>
     profile.
    </p>
   </div>
  </div>
  <div class="section" id="platform-detection-for-installers">
   
   <p>
    Above, we defined what it means for a
    <em>
     wheel
    </em>
    to be
    <tt class="docutils literal">
     manylinux1
    </tt>
    -compatible. Here we discuss what it means for a
    <em>
     Python
installation
    </em>
    to be
    <tt class="docutils literal">
     manylinux1
    </tt>
    -compatible. In particular, this is
important for tools like
    <tt class="docutils literal">
     pip
    </tt>
    to know when deciding whether or not
they should consider
    <tt class="docutils literal">
     manylinux1
    </tt>
    -tagged wheels for installation.
   </p>
   <p>
    Because the
    <tt class="docutils literal">
     manylinux1
    </tt>
    profile is already known to work for the
many thousands of users of popular commercial Python distributions, we
suggest that installation tools should error on the side of assuming
that a system
    <em>
     is
    </em>
    compatible, unless there is specific reason to
think otherwise.
   </p>
   <p>
    We know of four main sources of potential incompatibility that are
likely to arise in practice:
   </p>
   <ul class="simple">
    <li>
     Eventually, in the future, there may exist distributions that break
compatibility with this profile (e.g., if one of the libraries in
the profile changes its ABI in a backwards-incompatible way)
    </li>
    <li>
     A linux distribution that is too old (e.g. RHEL 4)
    </li>
    <li>
     A linux distribution that does not use
     <tt class="docutils literal">
      glibc
     </tt>
     (e.g. Alpine Linux, which is
based on musl
     <tt class="docutils literal">
      libc
     </tt>
     , or Android)
    </li>
   </ul>
   <p>
    To address these we propose a two-pronged
approach. To handle potential future incompatibilities, we standardize
a mechanism for a Python distributor to signal that a particular
Python install definitely is or is not compatible with
    <tt class="docutils literal">
     manylinux1
    </tt>
    :
this is done by installing a module named
    <tt class="docutils literal">
     _manylinux
    </tt>
    , and setting
its
    <tt class="docutils literal">
     manylinux1_compatible
    </tt>
    attribute. We do not propose adding any
such module to the standard library -- this is merely a well-known
name by which distributors and installation tools can
rendezvous. However, if a distributor does add this module,
    <em>
     they
should add it to the standard library
    </em>
    rather than to a
    <tt class="docutils literal">
     <span class="pre">
      site-packages/
     </span>
    </tt>
    directory, because the standard library is
inherited by virtualenvs (which we want), and
    <tt class="docutils literal">
     <span class="pre">
      site-packages/
     </span>
    </tt>
    in
general is not.
   </p>
   <p>
    Then, to handle the last two cases for existing Python
distributions, we suggest a simple and reliable method to check for
the presence and version of
    <tt class="docutils literal">
     glibc
    </tt>
    (basically using it as a "clock"
for the overall age of the distribution).
   </p>
   <p>
    Specifically, the algorithm we propose is:
   </p>
   <pre class="literal-block">
def is_manylinux1_compatible():
    # Only Linux, and only x86-64 / i686
    from distutils.util import get_platform
    if get_platform() not in ["linux-x86_64", "linux-i686"]:
        return False

    # Check for presence of _manylinux module
    try:
        import _manylinux
        return bool(_manylinux.manylinux1_compatible)
    except (ImportError, AttributeError):
        # Fall through to heuristic check below
        pass

    # Check glibc version. CentOS 5 uses glibc 2.5.
    return have_compatible_glibc(2, 5)

def have_compatible_glibc(major, minimum_minor):
    import ctypes

    process_namespace = ctypes.CDLL(None)
    try:
        gnu_get_libc_version = process_namespace.gnu_get_libc_version
    except AttributeError:
        # Symbol doesn't exist -&gt; therefore, we are not linked to
        # glibc.
        return False

    # Call gnu_get_libc_version, which returns a string like "2.5".
    gnu_get_libc_version.restype = ctypes.c_char_p
    version_str = gnu_get_libc_version()
    # py2 / py3 compatibility:
    if not isinstance(version_str, str):
        version_str = version_str.decode("ascii")

    # Parse string and check against requested version.
    version = [int(piece) for piece in version_str.split(".")]
    assert len(version) == 2
    if major != version[0]:
        return False
    if minimum_minor &gt; version[1]:
        return False
    return True
</pre>
   <p>
    <strong>
     Rejected alternatives:
    </strong>
    We also considered using a configuration
file, e.g.
    <tt class="docutils literal">
     /etc/python/compatibility.cfg
    </tt>
    . The problem with this is
that a single filesystem might contain many different interpreter
environments, each with their own ABI profile -- the
    <tt class="docutils literal">
     manylinux1
    </tt>
    compatibility of a system-installed x86_64 CPython might not tell us
much about the
    <tt class="docutils literal">
     manylinux1
    </tt>
    compatibility of a user-installed i686
PyPy. Locating this configuration information within the Python
environment itself ensures that it remains attached to the correct
binary, and dramatically simplifies lookup code.
   </p>
   <p>
    We also considered using a more elaborate structure, like a list of
all platform tags that should be considered compatible, together with
their preference ordering, for example:
    <tt class="docutils literal">
     _binary_compat.compatible =
["manylinux1_x86_64", "centos5_x86_64", "linux_x86_64"]
    </tt>
    . However,
this introduces several complications. For example, we want to be able
to distinguish between the state of "doesn't support
    <tt class="docutils literal">
     manylinux1
    </tt>
    "
(or eventually
    <tt class="docutils literal">
     manylinux2
    </tt>
    , etc.) versus "doesn't specify either
way whether it supports
    <tt class="docutils literal">
     manylinux1
    </tt>
    ", which is not entirely obvious
in the above representation; and, it's not at all clear what features
are really needed vis a vis preference ordering given that right now
the only possible platform tags are
    <tt class="docutils literal">
     manylinux1
    </tt>
    and
    <tt class="docutils literal">
     linux
    </tt>
    .  So
we're deferring a more complete solution here for a separate PEP, when
/ if Linux gets more platform tags.
   </p>
   <p>
    For the library compatibility check, we also considered much more
elaborate checks (e.g. checking the kernel version, searching for and
checking the versions of all the individual libraries listed in the
    <tt class="docutils literal">
     manylinux1
    </tt>
    profile, etc.), but ultimately decided that this would
be more likely to introduce confusing bugs than actually help the
user. (For example: different distributions vary in where they
actually put these libraries, and if our checking code failed to use
the correct path search then it could easily return incorrect
answers.)
   </p>
  </div>
  <div class="section" id="pypi-support">
   
   <p>
    PyPI should permit wheels containing the
    <tt class="docutils literal">
     manylinux1
    </tt>
    platform tag to be
uploaded. PyPI should not attempt to formally verify that wheels containing
the
    <tt class="docutils literal">
     manylinux1
    </tt>
    platform tag adhere to the
    <tt class="docutils literal">
     manylinux1
    </tt>
    policy described
in this document. This verification tasks should be left to other tools, like
    <tt class="docutils literal">
     auditwheel
    </tt>
    , that are developed separately.
   </p>
  </div>
  <div class="section" id="rejected-alternatives">
   
   <p>
    One alternative would be to provide separate platform tags for each Linux
distribution (and each version thereof), e.g.
    <tt class="docutils literal">
     RHEL6
    </tt>
    ,
    <tt class="docutils literal">
     ubuntu14_10
    </tt>
    ,
    <tt class="docutils literal">
     debian_jessie
    </tt>
    , etc. Nothing in this proposal rules out the possibility of
adding such platform tags in the future, or of further extensions to wheel
metadata that would allow wheels to declare dependencies on external
system-installed packages. However, such extensions would require substantially
more work than this proposal, and still might not be appreciated by package
developers who would prefer not to have to maintain multiple build environments
and build multiple wheels in order to cover all the common Linux distributions.
Therefore we consider such proposals to be out-of-scope for this PEP.
   </p>
  </div>
  <div class="section" id="future-updates">
   
   <p>
    We anticipate that at some point in the future there will be a
    <tt class="docutils literal">
     manylinux2
    </tt>
    specifying a more modern baseline environment (perhaps
based on CentOS 6), and someday a
    <tt class="docutils literal">
     manylinux3
    </tt>
    and so forth, but we
defer specifying these until we have more experience with the initial
    <tt class="docutils literal">
     manylinux1
    </tt>
    proposal.
   </p>
  </div>
  
  <div class="section" id="copyright">
   
   <p>
    This document has been placed into the public domain.
   </p>
   
  </div>
 
Source: <a href="https://hg.python.org/peps/file/tip/pep-0513.txt">https://hg.python.org/peps/file/tip/pep-0513.txt</a>

    </article>


                </div></body></html>