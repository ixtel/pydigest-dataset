<html><body><div><div class="field-item even" property="content:encoded"><h2>Overview</h2>



<p>All examples are in Python 3.</p>

<a name="bytes"/>
<h2>The Bytes Type</h2>

<p>The <strong>bytes</strong> type in Python is immutable and stores a sequence
of values ranging from 0-255 (8-bits). You can get the value
of a single byte by using an index like an array, but the values can not be modified.</p>

<pre class="prettyprint"><code># Create empty bytes<br/>empty_bytes = bytes(4)<br/>print(type(empty_bytes))<br/>print(empty_bytes)</code></pre>

<a name="bytearray"/>
<h2>The Bytearray Type</h2>

<p>To create a mutable object you need to use the <strong>bytearray</strong> type.
With a <strong>bytearray</strong> you can do everything you can with other mutables
like push, pop, insert, append, delete, and sort.</p>

<pre class="prettyprint"><code># Cast bytes to bytearray<br/>mutable_bytes = bytearray(b'\x00\x0F')<br/><br/># Bytearray allows modification<br/>mutable_bytes[0] = 255<br/>mutable_bytes.append(255)<br/>print(mutable_bytes)<br/><br/># Cast bytearray back to bytes<br/>immutable_bytes = bytes(mutable_bytes)<br/>print(immutable_bytes)</code></pre>

<a name="readfile"/>
<h2>Reading Bytes From a File</h2>

<pre class="prettyprint"><code>with open("test_file.dat", "rb") as binary_file:<br/>    # Read the whole file at once<br/>    data = binary_file.read()<br/>    print(data)<br/><br/>    # Seek position and read N bytes<br/>    binary_file.seek(0)  # Go to beginning<br/>    couple_bytes = binary_file.read(2)<br/>    print(couple_bytes)</code></pre>

<a name="int-to-bytes"/>
<h2>Integer to Bytes</h2>

<pre class="prettyprint"><code>i = 16<br/><br/># Create one byte from the integer 16<br/>single_byte = i.to_bytes(1, byteorder='big', signed=True) <br/>print(single_byte)<br/><br/># Create four bytes from the integer<br/>four_bytes = i.to_bytes(4, byteorder='big', signed=True)<br/>print(four_bytes)<br/><br/># Compare the difference to little endian<br/>print(i.to_bytes(4, byteorder='little', signed=True))<br/><br/># Create bytes from a list of integers with values from 0-255<br/>bytes_from_list = bytes([255, 254, 253, 252])<br/>print(bytes_from_list)<br/><br/># Create a byte from a base 2 integer<br/>one_byte = int('11110000', 2)<br/>print(one_byte)</code></pre>

<a name="bytes-to-int"/>
<h2>Bytes to Integer</h2>

<pre class="prettyprint"><code># Create an int from bytes. Default is unsigned.<br/>some_bytes = b'\x00\xF0'<br/>i = int.from_bytes(some_bytes, byteorder='big')<br/>print(i)<br/><br/># Create a signed int<br/>i = int.from_bytes(b'\x00\x0F', byteorder='big', signed=True)<br/>print(i)<br/><br/># Use a list of integers 0-255 as a source of byte values<br/>i = int.from_bytes([255, 0, 0, 0], byteorder='big')<br/>print(i)</code></pre>

<a name="text"/>
<h2>Text Encoding</h2>

<pre class="prettyprint"><code># Binary to Text<br/>binary_data = b'I am text.'<br/>text = binary_data.decode('utf-8')<br/>print(text)<br/><br/>binary_data = bytes([65, 66, 67])  # ASCII values for A, B, C<br/>text = binary_data.decode('utf-8')<br/>print(text)</code></pre>

<pre class="prettyprint"><code># Text to Binary<br/>message = "Hello"  # str<br/>binary_message = message.encode('utf-8')<br/>print(type(binary_message))  # bytes<br/><br/># Python has many built in encodings for different languages,<br/># and even the Caeser cipher is built in<br/>import codecs<br/>cipher_text = codecs.encode(message, 'rot_13')<br/>print(cipher_text)</code></pre>

<a name="base64"/>
<h2>Base 64 Encoding</h2>

<pre class="prettyprint"><code># Encode binary data to a base 64 string<br/>binary_data = b'\x00\xFF\x00\xFF'<br/><br/># Use the codecs module to encode<br/>import codecs<br/>base64_data = codecs.encode(binary_data, 'base64')<br/>print(base64_data)<br/><br/># Or use the binascii module<br/>import binascii<br/>base64_data = binascii.b2a_base64(binary_data)<br/>print(base64_data)<br/><br/># The base64_string is still a bytes type<br/># It may need to be decoded to an ASCII string<br/>print(base64_data.decode('utf-8'))<br/><br/># Decoding is done similarly<br/>print(codecs.decode(base64_data, 'base64'))<br/>print(binascii.a2b_base64(base64_data))</code></pre>

<a name="hex"/>
<h2>Hexadecimal</h2>

<pre class="prettyprint"><code># Starting with a hex string you can unhexlify it to bytes<br/>deadbeef = binascii.unhexlify('DEADBEEF')<br/>print(deadbeef)<br/><br/># Given raw bytes, get an ASCII string representing the hex values<br/>hex_data = binascii.hexlify(b'\x00\xff')  # Two bytes values 0 and 255<br/><br/># The resulting value will be an ASCII string but it will be a bytes type<br/># It may be necessary to decode it to a regular string<br/>text_string = hex_data.decode('utf-8')  # Result is string "00ff"<br/>print(text_string)</code></pre>

<a name="format"/>
<h2>Format Strings</h2>

<p>Format strings can be helpful to visualize or output byte values. Format
strings require an integer value so the byte will have to be converted to an integer first.</p>

<pre class="prettyprint"><code>a_byte = b'\xff'  # 255<br/>i = ord(a_byte)   # Get the integer value of the byte<br/><br/>bin = "{0:b}".format(i) # binary: 11111111<br/>hex = "{0:x}".format(i) # hexadecimal: ff<br/>oct = "{0:o}".format(i) # octal: 377<br/><br/>print(bin)<br/>print(hex)<br/>print(oct)</code></pre>

<a name="bits"/>
<h2>Bitwise Operations</h2>

<pre class="prettyprint"><code># Some bytes to play with<br/>byte1 = int('11110000', 2)  # 240<br/>byte2 = int('00001111', 2)  # 15<br/>byte3 = int('01010101', 2)  # 85<br/><br/># Ones Complement (Flip the bits)<br/>print(~byte1)<br/><br/># AND<br/>print(byte1 &amp; byte2)<br/><br/># OR<br/>print(byte1 | byte2)<br/><br/># XOR<br/>print(byte1 ^ byte3)<br/><br/># Shifting right will lose the right-most bit<br/>print(byte2 &gt;&gt; 3)<br/><br/># Shifting left will add a 0 bit on the right side<br/>print(byte2 &lt;&lt; 1)<br/><br/># See if a single bit is set<br/>bit_mask = int('00000001', 2)  # Bit 1<br/>print(bit_mask &amp; byte1)  # Is bit set in byte1?<br/>print(bit_mask &amp; byte2)  # Is bit set in byte2?</code></pre>

<a name="struct"/>
<h2>Struct Packing and Unpacking</h2>

<p>Packing and unpacking requires a string that defines how the binary data
is structured. It needs to know which bytes represent values. It needs to know
whether the entire set of bytes represets characters or if it is a sequence of
4-byte integers. It can be structured in any number of ways. The format strings
can be simple or complex. In this example I am packing a single four-byte integer
followed by two characters. The letters <strong>i</strong> and <strong>c</strong> represent integers and characters.</p>

<pre class="prettyprint"><code>import struct<br/><br/># Packing values to bytes<br/># The first parameter is the format string. Here it specifies the data is structured<br/># with a single four-byte integer followed by two characters.<br/># The rest of the parameters are the values for each item in order<br/>binary_data = struct.pack("icc", 8499000, b'A', b'Z')<br/>print(binary_data)<br/><br/># When unpacking, you receive a tuple of all data in the same order<br/>tuple_of_data = struct.unpack("icc", binary_data)<br/>print(tuple_of_data)<br/><br/># For more information on format strings and endiannes, refer to<br/># https://docs.python.org/3.5/library/struct.html</code></pre>

<a name="byte-order"/>
<h2>System Byte Order</h2>

<p>You might need to know what byte order your system uses. Byte order refers to
big endian or little endian. The <strong>sys</strong>
module can provide that value.</p>

<pre class="prettyprint"><code># Find out what byte order your system uses<br/>import sys<br/>print("Native byteorder: ", sys.byteorder)</code></pre>

<a name="examples"/>
<h2>Examples</h2>

<a name="diff"/>
<pre class="prettyprint"><code># diff.py - Do two files match?<br/># Exercise: Rewrite this code to compare the files part at a time so it<br/># will not run out of RAM with large files.<br/>import sys<br/><br/>with open(sys.argv[1], 'rb') as file1, open(sys.argv[2], 'rb') as file2:<br/>    data1 = file1.read()<br/>    data2 = file2.read()<br/><br/>if data1 != data2:<br/>    print("Files do not match.")<br/>else:<br/>    print("Files match.")</code></pre>

<a name="is-jpg"/>
<pre class="prettyprint"><code>#is_jpeg.py - Does the file have a JPEG binary signature?<br/><br/>import sys<br/>import binascii<br/><br/>jpeg_signatures = [<br/>    binascii.unhexlify(b'FFD8FFD8'),<br/>    binascii.unhexlify(b'FFD8FFE0'),<br/>    binascii.unhexlify(b'FFD8FFE1')<br/>]<br/><br/>with open(sys.argv[1], 'rb') as file:<br/>    first_four_bytes = file.read(4)<br/><br/>    if first_four_bytes in jpeg_signatures:<br/>        print("JPEG detected.")<br/>    else:<br/>        print("File does not look like a JPEG.")</code></pre>

<a name="read-boot-sector"/>
<pre class="prettyprint"><code># read_boot_sector.py - Inspect the first 512 bytes of a file<br/><br/>import sys<br/><br/>in_file = open(sys.argv[1], 'rb')  # Provide a path to disk or ISO image<br/>chunk_size = 512<br/>data = in_file.read(chunk_size)<br/>print(data)</code></pre>

<a name="find-ascii"/>
<pre class="prettyprint"><code># find_ascii_in_binary.py - Identify ASCII characters in binary files<br/><br/>import sys<br/>from functools import partial<br/><br/>chunk_size = 1<br/>with open(sys.argv[1], 'rb') as in_file:    <br/>    for data in iter(partial(in_file.read, chunk_size), b''):<br/>        x = int.from_bytes(data, byteorder='big')<br/>        if (x &gt; 64 and x &lt; 91) or (x &gt; 96 and x &lt; 123) :<br/>            sys.stdout.write(chr(x))<br/>        else:<br/>            sys.stdout.write('.')</code></pre>

<a name="create-stego"/>
<pre class="prettyprint"><code># create_stego_zip_jpg.py - Hide a zip file inside a JPEG<br/><br/>import sys<br/><br/># Start with a jpeg file<br/>jpg_file = open(sys.argv[1], 'rb')  # Path to JPEG<br/>jpg_data = jpg_file.read()<br/>jpg_file.close()<br/><br/># And the zip file to embed in the jpeg<br/>zip_file = open(sys.argv[2], 'rb')  # Path to ZIP file<br/>zip_data = zip_file.read()<br/>zip_file.close()<br/><br/># Combine the files<br/>out_file = open('special_image.jpg', 'wb')  # Output file<br/>out_file.write(jpg_data)<br/>out_file.write(zip_data)<br/>out_file.close()<br/><br/># The resulting output file appears like a normal jpeg but can also be<br/># unzipped and used as an archive.</code></pre>
</div></div></body></html>