<html><body><div><div class="content html_format"><p>
      В этой статье будет рассмотрен способ создать .exe файл, позволяющий пройти авторизацию ВК и выполнить определенные запросы к VK API. Установка Python не требуется.</p>

<h1>Системные требования</h1>
<a name="habracut"/>
<h1>Предыстория и, собственно, зачем мне это понадобилось</h1><p>
Около года тому назад я наткнулся на паблик, занимающийся переводами зарубежных статей на русский.
</p><p>
Спустя какое-то время возникла идея создать страницу, на которой все-все-все переводы будут распределены по категориям. И, разумеется, эту страницу нужно будет изредка обновлять, т.е. собирать информацию о уже выпущенных материалах, их категориях и т.п., а затем раскладывать по полочкам. В целом, VK API позволяет это сделать.
</p><p>
Но и это не все: каждый участник, наделенный редакторскими правами, также должен быть в состоянии обновить все странички. Способ </p><i>«заставить <s>этих гуманитариев</s> всех редакторов установить себе python»</i><p> очевидно не подходит. Нужно просто — клик, клик, запустилось, заработало, закрылось. Проще говоря, нужен .exe файл.
</p><p>
Более того, если в тело файла добавить код, взаимодействующий с конкретным пользователем, то можно создать, к примеру, универсальный </p><a href="http://habrahabr.ru/post/183408">сортировщик аудио</a><p>.
</p><p>
Возможно, изложенный здесь способ — очередной изобретенный велосипед, но все-таки я продолжу.

</p><h1>Шаг нулевой. Подготовка</h1><p>
В папке, где будут храниться наши будущие файлы, создаем подпапку (например, bin), куда сохраняем chromedriver.exe, cacert.pem и (если очень хочется) иконку для нашего будущего .exe файла. В эту же папку помещаем пока что пустой текстовый файл </p><b>path_to_chrome.txt</b><p>.

</p><h1>Шаг первый. Авторизация</h1><p>
Итак, все готово. Еще раз о том, как происходит процесс авторизации и получения ключа доступа </p><b>access_token</b><p> для работы с API.

</p><ol>
<li>Пользователь переходит по ссылке, приложение запрашивает доступ</li>
<li>Пользователь разрешает доступ</li>
<li>Происходит перенаправление на <a href="https://oauth.vk.com/blank.html">пустую страницу</a>: в адресной строке появляется access_token</li>
</ol><p>
О том, как формируется ссылка, рассказано </p><a href="https://vk.com/dev/auth_mobile">в официальной документации</a><p>.
</p><p>
Импортируем все необходимое, объявляем константы:

</p><pre><code class="python">import os
import sys
import time

from selenium import webdriver
from selenium.webdriver.common.keys import Keys

import vk

from script import PagesUpdater


SCOPE = 'pages'  # vk.com/dev/permissions
OAUTH = 'https://oauth.vk.com/authorize?client_id=4836475&amp;scope={}\
&amp;redirect_uri=https://oauth.vk.com/blank.html&amp;display=popup&amp;v=5.37\
&amp;response_type=token'.format(SCOPE)

IDLE = 3
TOKEN = 'access_token='  # после этого следует сам access_token
ATOKEN_LEN = 85          # и его длина — 85 символов
CHROME_DRIVER = '\chromedriver.exe'

PATH = os.getcwd()
PATH_TO_CHROME_TXT = PATH + '\path_to_chrome.txt'


class Executor(object):
    def launch(self):
        chrome_path = self.get_chrome_path()
        self.driver = webdriver.Chrome(chrome_path)  # запуск selenium

        access_token = self.get_access_token()

        vkapi = vk.API(access_token=access_token)    # запуск API

        script = PagesUpdater(vkapi, vk.api.VkAPIMethodError, self.driver)
        script.launch()

        self.driver.quit()
</code></pre><p>
О </p><b>PagesUpdater</b><p> и передаваемых ему аргументах будет рассказано чуть позже.
</p><p>
Selenium требует указать полный путь к файлу chromedriver.exe, который должен находиться в одной папке с браузером. Путь к браузеру наверняка отличается на каждом компьюетере, поэтому вынесем его в отдельный текстовый файл </p><b>path_to_chrome.txt</b><p> следующего содержания:

</p><pre><code>C:\chrome-win32\chrome-win32</code></pre>
<pre><code class="python">    def get_chrome_path(self):
        with open(PATH_TO_CHROME_TXT, 'r') as target:
            return target.read()
</code></pre><p>
Разумеется, пользователь должен заранее указать полный путь к браузеру в </p><b>path_to_chrome.txt</b><p>.
</p><p>
Перехватываем </p><b>access_token:</b>

<pre><code class="python">    def get_access_token(self):
        self.driver.get(OAUTH)  # открыть ссылку для получения ключа

        access_token = ''
        while not access_token:
            page_url = self.driver.current_url

            if TOKEN in page_url:
                token_start = page_url.index(TOKEN) + len(TOKEN)
                access_token = page_url[token_start:token_start+ATOKEN_LEN]
                break

            else:
                time.sleep(IDLE)

        return access_token
</code></pre><p>
Ну, и напоследок, забегая вперед, скажу, что после компиляции возникает ошибка из-за нехватки файла </p><b>cacert.pem</b><p>. </p><a href="http://stackoverflow.com/questions/7674790/bundling-data-files-with-pyinstaller-onefile">Здесь</a><p> дано решение: добавить cacert.pem в PATH, а потом не забыть собрать при сборке .exe:

</p><pre><code class="python">def resource_path(relative):
    return os.path.join(getattr(sys, '_MEIPASS', os.path.abspath(".")),
                        relative)


cert_path = resource_path('cacert.pem')
os.environ['REQUESTS_CA_BUNDLE'] = cert_path
</code></pre><p>
Последний штрих.
</p><pre><code class="python">exe = Executor()
exe.launch()
</code></pre><p>
Всё. Идем дальше.

</p><h1>Шаг второй. Обращаемся к VK API</h1><p>
Опять же, импортируем все необходимое, объявляем константы:

</p><pre><code class="python">import requests
import time


LIMIT = 1
CAPTCHA_IMG = 'captcha_img'
CAPTCHA_SID = 'captcha_sid'


class PagesUpdater(object):
    def __init__(self, vkapi, vkerror, driver):
        self.vkapi = vkapi
        self.vkerror = vkerror
        self.driver = driver
</code></pre>
<b>self.vkapi</b><p> будет использоваться для обращения к любым методам VK API. Два других аргумента будут использоваться для обработки Captcha (см. ниже).

</p><h2>Обработка ошибок</h2><p>
Я столкнулся с тремя ошибками, которые гарантированно появлялись при большом количестве запросов:

</p><ol>
<li><b>VK Captcha Error</b> (не введен текст с изображения Captcha)</li>
<li><b>VK Flood Control</b> (слишком много запросов в секунду)</li>
<li><b>requests.exceptions.Timeout</b> (появляется, когда ей угодно)</li>
</ol><p>
Создадим метод, в который будем «оборачивать» все запросы к VK API:

</p><pre><code class="python">    def errors(self, vkmethod, **vkkwargs):
        while True:
            try:
                time.sleep(LIMIT)  # LIMIT == 1 just in case
                return vkmethod(**vkkwargs)

            except requests.exceptions.Timeout:
                continue

            break
</code></pre><p>
Со второй и третьей ошибками разобрались:

</p><ul>
<li>Перед каждым запросом будет происходить секундная задержка (подробнее о запросах в <a href="http://vk.com/dev/api_requests">в документации</a>).</li>
<li>Если возникнет requests.exceptions.Timeout, то запрос попросту повторится</li>
</ul><p>
С Captcha всё чуточку сложнее. Читаем </p><a href="https://vk.com/dev/captcha_error">документацию</a><p>:
</p><blockquote>… следует запросить пользователя ввести текст с изображения captcha_img и повторить запрос, добавив в него параметры:<br/>
<br/>
<ul>
<li><b>captcha_sid</b> — полученный идентификатор</li>
<li><b>captcha_key</b> — текст, который ввел пользователь</li>
</ul></blockquote><p>
Добавим except блок, в котором будет происходить обработка Captcha:

</p><pre><code class="python">            except self.vkerror as e:
                if CAPTCHA_IMG in e.error:
                    self.driver.get(e.error[CAPTCHA_IMG])  # открыть картинку

                    key = raw_input(R)                     # ввести код
                    vkkwargs[captcha_sid] = e.error[CAPTCHA_SID]
                    vkkwargs[captcha_key] = key            # повторить запрос
                    continue

                else:
                    raise  # если же ошибка не в Captcha
</code></pre><p>
С ошибками разобрались. Идем дальше.

</p><h2>Запрос к API</h2><p>
Добавим простой метод, который возвращает список вики-страниц в группе:

</p><pre><code class="python">    def get_titles(self, gid=NGID):
        return self.errors(self.vkapi.pages.getTitles,
                           group_id=gid)
</code></pre><p>
И метод </p><b>launch,</b><p> в котором будет происходить все остальное:

</p><pre><code class="python">    def launch(self):
        print self.get_titles()
        # do something else
</code></pre><p>
Собственно, вот и всё.

</p><h1>Компиляция в .exe</h1><p>
Осталось только запустить файл со следующим кодом:

</p><pre><code class="python">import os
import sys
from distutils.core import setup

import py2exe

sys.argv.append('py2exe')

AUTHOR = 'Варвара Холодная'
COMPANY = 'ООО «Контора»'
NAME = 'Имя будущего .exe файла'
DESCRIPTION = 'Описание файла'
SCRIPT = 'auth_user.py'
VERSION = '1.0.0.0'
BIN = 'bin/'
# файлы, которые нужно будет собрать из папки bin
DATA_FILES = [
    'path_to_chrome.txt', 'cacert.pem', 'chromedriver.exe'
]


setup(
    options={
        'py2exe': {
            'bundle_files': 1,
            'compressed': True,
            'unbuffered': True,
            'optimize': 0,
        }
    },
    data_files=[('', [BIN+s for s in DATA_FILES])],
    console=[{
        'script': SCRIPT,
        'name': NAME,
        'dest_base': NAME,
        'description': DESCRIPTION,
        'copyright': AUTHOR,
        'company_name': COMPANY,
        'version': VERSION
    }],
    zipfile=None,
)</code></pre><p>
После успешной компиляции появится папка dist, в которой и будут находиться все нужные файлы.

</p><h1>P.S.</h1><p>
Тестировать файлы с ручной авторизацией — неудобно. Куда легче самому пройти по ссылке OAuth, выписать access_token и в дальнейшем выполнять другой файл, например, </p><b>auth_direct.py</b><p> (разумеется, он не подойдет для передачи другому пользователю):

</p><pre><code class="python">import vk

from selenium import webdriver
from selenium.webdriver.common.keys import Keys

from script import PagesUpdater


ACCESS_TOKEN = 'Заранее полученный и сохраненный access_token'
VKAPI = vk.API(access_token=ACCESS_TOKEN)
VKError = vk.api.VkAPIMethodError


class DirectUpdater(PagesUpdater):
    def __init__(self, driver_path):
        self.vkapi = VKAPI
        self.vkerror = VKError
        self.driver = webdriver.Chrome(driver_path)

du = DirectUpdater(
    'Путь к chromedriver.exe')

du.launch()
</code></pre>
      <p class="clear"/>
    </div>

    
  </div></body></html>