<html><body><div><div id="article_text">
    <p>Knowing the country to which an IP address is mapped is very helpful for localising an experience on a website and providing demographics information to website owners.</p>
<div class="section" id="external-api-based-lookups">
<h2>External API-based lookups</h2>
<p>Different environments and use cases will demand different solutions. For non-time sensitive, low-volume cases an external, often free, service can be very quick to implement and not require any database updates to the consuming service.</p>
<p>But making service requests can often take 250 to 500 milliseconds. If the information is needed on the spot in order to make decisions on content to serve or business logic to use this can be a huge overhead.</p>
<p>There is also the risk that a flood of traffic could cause the remote API to throttle requests. Networking woes can also cause the information to be unavailable.</p>
<p>As an antidote exercise I ran the following lookup three times:</p>
<div class="highlight"><pre><span class="nv">$ </span><span class="nb">time</span> <span class="se">\</span>
  curl -s freegeoip.net/json/24.24.24.24 <span class="p">|</span> <span class="se">\</span>
  python -m json.tool <span class="p">|</span> <span class="se">\</span>
  grep -oP <span class="s1">'country_code": "\K([A-Z]+)'</span>
</pre></div>
<p>The responses took 314ms, 561ms and 289ms respectively to return. For non-time-sensitive tasks this would be fine (e.g. admin interface with IP address investigation tools).</p>
</div>
<div class="section" id="local-database-lookups">
<h2>Local database lookups</h2>
<p>If you're serving web requests where the user's location is of importance then a local database will save you the external network overhead and communication error risks.</p>
<p>Not all solutions are created equally. Below I compare a C-based lookup against a pure python lookup (useful for cloud services which only allow pure python modules) versus looking up results in a local redis database.</p>
</div>
<div class="section" id="c-based-lookup">
<h2>C-based lookup</h2>
<p>The first module I'll look at is <a class="reference external" href="https://github.com/maxmind/geoip-api-python">GeoIP</a>. It's written in C and offers the fastest lookups I've seen of any solution.</p>
<p>I ran the following on an Ubuntu 14 machine to install it:</p>
<div class="highlight"><pre><span class="nv">$ </span>sudo apt-get install python-dev libgeoip-dev
<span class="nv">$ </span>pip install GeoIP
</pre></div>
<p>Next, I put together a benchmark. In each iteration, I generate a random IP address and lookup the country for it:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">timeit</span>


<span class="n">lookup_code</span> <span class="o">=</span> <span class="s">'''</span>
<span class="s">ip_address = '.'.join([str(randint(0, 255)) for _ in range(0, 4)])</span>
<span class="s">gi.country_code_by_addr(ip_address)</span>
<span class="s">'''</span>
<span class="n">setup_code</span> <span class="o">=</span> <span class="s">'''</span>
<span class="s">from random import randint</span>

<span class="s">import GeoIP</span>


<span class="s">gi = GeoIP.new(GeoIP.GEOIP_MEMORY_CACHE)</span>
<span class="s">'''</span>
</pre></div>
<p>I ran the code one million times and it took 3.603 seconds to complete:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="n">lookup_code</span><span class="p">,</span> <span class="n">setup</span><span class="o">=</span><span class="n">setup_code</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">1000000</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="pure-python-based-lookup">
<h2>Pure python-based lookup</h2>
<p>Google App Engine, among other hosting providers, only allows customers to use pure python modules (unless they've already provided the module themselves). GeoIP won't work but <a class="reference external" href="https://github.com/appliedsec/pygeoip">pygeoip</a>, a pure python module, will.</p>
<p>You will need MaxMind's GeoIP database. If you install <cite>libgeoip-dev</cite> on Ubuntu then it'll be stored in <cite>/usr/share/GeoIP/GeoIP.dat</cite>.</p>
<p>I ran the following on an Ubuntu 14 machine to install pygeoip:</p>
<div class="highlight"><pre><span class="nv">$ </span>sudo apt-get install libgeoip-dev <span class="c"># Installs GeoIP.dat</span>
<span class="nv">$ </span>pip install pygeoip
</pre></div>
<p>I built a variation of the previous benchmark, replacing GeoIP with pygeoip:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">timeit</span>


<span class="n">lookup_code</span> <span class="o">=</span> <span class="s">'''</span>
<span class="s">ip_address = '.'.join([str(randint(0, 255)) for _ in range(0, 4)])</span>
<span class="s">gi.country_code_by_addr(ip_address)</span>
<span class="s">'''</span>
<span class="n">setup_code</span> <span class="o">=</span> <span class="s">'''</span>
<span class="s">from random import randint</span>

<span class="s">import pygeoip</span>


<span class="s">gi = pygeoip.GeoIP('/usr/share/GeoIP/GeoIP.dat',</span>
<span class="s">                   flags=pygeoip.const.MMAP_CACHE)</span>
<span class="s">'''</span>
</pre></div>
<p>I ran the code one million times and it took 33.394 seconds to complete:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="n">lookup_code</span><span class="p">,</span> <span class="n">setup</span><span class="o">=</span><span class="n">setup_code</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">1000000</span><span class="p">)</span>
</pre></div>
<p>A small number of lookups with this library will hardly be noticeably slower but if you are dealing with high volumes or a large batch job then this is a significant slowdown.</p>
</div>
<div class="section" id="redis-based-lookup">
<h2>Redis-based lookup</h2>
<p>I wondered if using redis as a data source would be faster or slower than any of the above solutions. I found that I'm not the first to wonder this as I found this <a class="reference external" href="http://stackoverflow.com/questions/22319204/how-to-match-the-ip-address-with-maximind-data">helpful question on Stackoverflow</a>.</p>
<p>To start I needed to import Maxmind's GeoIP Country CSV file into redis. First I downloaded and unzip'ed the database:</p>
<div class="highlight"><pre><span class="nv">$ </span>wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip
<span class="nv">$ </span>unzip GeoIPCountryCSV.zip
</pre></div>
<p>I then installed redis client bindings for python:</p>

<p>Then I ran a script that would import the CSV data I was interested in into redis:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">struct</span>

<span class="kn">import</span> <span class="nn">redis</span>


<span class="k">def</span> <span class="nf">ip2long</span><span class="p">(</span><span class="n">ip</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Convert an IP string to long</span>
<span class="sd">    """</span>
    <span class="n">packedIP</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">inet_aton</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">"!L"</span><span class="p">,</span> <span class="n">packedIP</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">redis_con</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">StrictRedis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">'localhost'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">,</span> <span class="n">db</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'GeoIPCountryWhois.csv'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">csv_file</span><span class="p">:</span>
        <span class="n">csv_reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">','</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">csv_reader</span><span class="p">:</span>
            <span class="n">ip_range_start</span><span class="p">,</span> <span class="n">country_code</span> <span class="o">=</span> <span class="n">ip2long</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">row</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="n">redis_con</span><span class="o">.</span><span class="n">zadd</span><span class="p">(</span><span class="s">'countries'</span><span class="p">,</span>
                           <span class="n">ip_range_start</span><span class="p">,</span>
                           <span class="s">'</span><span class="si">%s</span><span class="s">@</span><span class="si">%d</span><span class="s">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">country_code</span><span class="p">,</span> <span class="n">ip_range_start</span><span class="p">))</span>
</pre></div>
<p>The space requirements to store the data in redis were pretty minimal:</p>
<div class="highlight"><pre><span class="nv">$ </span>redis-cli info <span class="p">|</span> grep used_memory_peak_human
used_memory_peak_human:14.69M
</pre></div>
<p>For comparison <cite>GeoIP.dat</cite> was 808KB and <cite>GeoIPCountryWhois.csv</cite> was 7.4MB on my machine at the time of writing.</p>
<p>I then built a lookup benchmark:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">timeit</span>


<span class="n">lookup_code</span> <span class="o">=</span> <span class="s">'''</span>
<span class="s">ip_address = ip2long('.'.join([str(randint(0, 255)) for _ in range(0, 4)]))</span>
<span class="s">resp = redis_con.zrangebyscore(name='countries',</span>
<span class="s">                               min=ip_address,</span>
<span class="s">                               max='+inf',</span>
<span class="s">                               start=0,</span>
<span class="s">                               num=1)</span>

<span class="s">country = resp[0].split('@')[0] if resp else None</span>
<span class="s">'''</span>
<span class="n">setup_code</span> <span class="o">=</span> <span class="s">'''</span>
<span class="s">from random import randint</span>
<span class="s">import socket</span>
<span class="s">import struct</span>

<span class="s">import redis</span>


<span class="s">def ip2long(ip):</span>
<span class="s">    """</span>
<span class="s">    Convert an IP string to long</span>
<span class="s">    """</span>
<span class="s">    packedIP = socket.inet_aton(ip)</span>
<span class="s">    return struct.unpack("!L", packedIP)[0]</span>


<span class="s">redis_con = redis.StrictRedis(host='localhost', port=6379, db=0)</span>
<span class="s">'''</span>
</pre></div>
<p>I ran the code one million times and it took 64.495 seconds to complete:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="n">lookup_code</span><span class="p">,</span> <span class="n">setup</span><span class="o">=</span><span class="n">setup_code</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">1000000</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="these-benchmarks-are-only-useful-for-batch-processing">
<h2>These benchmarks are only useful for batch processing</h2>
<p>The first two benchmarks already had the IP address database in memory so there was little overhead for them. The redis database also held the database in memory but has a client-server communications overhead.</p>
<p>To level the playing field I created three scripts that would only do a single lookup on a randomly-generated IP address. There was a script for the C-based lookup, pure python-based lookup and redis-based lookup:</p>
<p>c_based.py:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>

<span class="kn">import</span> <span class="nn">GeoIP</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">gi</span> <span class="o">=</span> <span class="n">GeoIP</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">GeoIP</span><span class="o">.</span><span class="n">GEOIP_MEMORY_CACHE</span><span class="p">)</span>
    <span class="n">ip_address</span> <span class="o">=</span> <span class="s">'.'</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
    <span class="n">gi</span><span class="o">.</span><span class="n">country_code_by_addr</span><span class="p">(</span><span class="n">ip_address</span><span class="p">)</span>
</pre></div>
<p>pure_python_based.py:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>

<span class="kn">import</span> <span class="nn">pygeoip</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">gi</span> <span class="o">=</span> <span class="n">pygeoip</span><span class="o">.</span><span class="n">GeoIP</span><span class="p">(</span><span class="s">'/usr/share/GeoIP/GeoIP.dat'</span><span class="p">,</span>
                       <span class="n">flags</span><span class="o">=</span><span class="n">pygeoip</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">MMAP_CACHE</span><span class="p">)</span>
    <span class="n">ip_address</span> <span class="o">=</span> <span class="s">'.'</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
    <span class="n">gi</span><span class="o">.</span><span class="n">country_code_by_addr</span><span class="p">(</span><span class="n">ip_address</span><span class="p">)</span>
</pre></div>
<p>redis_based.py:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">struct</span>

<span class="kn">import</span> <span class="nn">redis</span>


<span class="k">def</span> <span class="nf">ip2long</span><span class="p">(</span><span class="n">ip</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Convert an IP string to long</span>
<span class="sd">    """</span>
    <span class="n">packedIP</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">inet_aton</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">"!L"</span><span class="p">,</span> <span class="n">packedIP</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">redis_con</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">StrictRedis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">'localhost'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">,</span> <span class="n">db</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ip_address</span> <span class="o">=</span> <span class="n">ip2long</span><span class="p">(</span><span class="s">'.'</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
                                   <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]))</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">redis_con</span><span class="o">.</span><span class="n">zrangebyscore</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'countries'</span><span class="p">,</span>
                                   <span class="nb">min</span><span class="o">=</span><span class="n">ip_address</span><span class="p">,</span>
                                   <span class="nb">max</span><span class="o">=</span><span class="s">'+inf'</span><span class="p">,</span>
                                   <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                   <span class="n">num</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">country</span> <span class="o">=</span> <span class="n">resp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'@'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">resp</span> <span class="k">else</span> <span class="bp">None</span>
</pre></div>
<p>I then created a bash file that would run each script 1000 times and output how long each took:</p>
<div class="highlight"><pre><span class="nv">$ </span>cat benchmark.sh
<span class="c">#!/bin/bash</span>

<span class="k">function</span> c_based <span class="o">{</span>
    <span class="k">for</span> i in <span class="sb">`</span>seq <span class="m">1</span> 1000<span class="sb">`</span><span class="p">;</span>
    <span class="k">do</span>
        python ./c_based.py
    <span class="k">done</span>
<span class="o">}</span>

<span class="k">function</span> pure_python_based <span class="o">{</span>
    <span class="k">for</span> i in <span class="sb">`</span>seq <span class="m">1</span> 1000<span class="sb">`</span><span class="p">;</span>
    <span class="k">do</span>
        python ./pure_python_based.py
    <span class="k">done</span>
<span class="o">}</span>

<span class="k">function</span> redis_based <span class="o">{</span>
    <span class="k">for</span> i in <span class="sb">`</span>seq <span class="m">1</span> 1000<span class="sb">`</span><span class="p">;</span>
    <span class="k">do</span>
        python ./redis_based.py
    <span class="k">done</span>
<span class="o">}</span>

<span class="nb">time </span>c_based
<span class="nb">time </span>pure_python_based
<span class="nb">time </span>redis_based
</pre></div>
<p>Here is the result of running the benchmark:</p>
<div class="highlight"><pre><span class="nv">$ </span>./benchmark.sh

<span class="c"># C-based</span>
real    0m8.407s
user    0m5.688s
sys     0m2.588s

<span class="c"># Pure python-based</span>
real    0m17.498s
user    0m13.492s
sys     0m3.737s

<span class="c"># redis-based</span>
real    0m29.075s
user    0m21.545s
sys     0m6.939s
</pre></div>
<p>For ad hoc requests the time it takes to load the database into memory levels the playing field a lot. The C-based approach is still about twice as fast as the pure python-based approach but now the redis-based approach is only around twice as slow and the pure python-based approach.</p>
</div>
<div class="section" id="the-curious-case-of-24-24-24-24">
<h2>The curious case of 24.24.24.24</h2>
<p>The CSV database I downloaded from MaxMind and the binary one I installed via the <cite>libgeoip-dev</cite> package had differences between them. One of the test IP addresses I used when I started building these scripts was <cite>24.24.24.24</cite>. According to <cite>whois 24.24.24.24</cite> the IP address is mapped to a network in Herndon, VA, USA and sits in the net range 24.24.0.0 - 24.29.255.255.</p>
<p>When I ran a redis lookup manually though it came back with Romania as the country where the IP address is mapped to:</p>
<div class="highlight"><pre><span class="nv">$ </span>redis-cli
127.0.0.1:6379&gt; ZRANGEBYSCORE countries <span class="m">2130706433</span> +inf LIMIT <span class="m">0</span> 1
1<span class="o">)</span> <span class="s2">"RO@2147483648"</span>
</pre></div>
<p>The closest, lower value to the IP address will always be returned with the redis lookup implementation used in this blog. That means if there is no exact range the IP address being looked up in the database then it won't be flagged up.</p>
<p>I looked at the CSV file and it turns out there are no mappings for any 24.x.x.x ranges before 24.36.x.x:</p>
<div class="highlight"><pre><span class="nv">$ </span>grep <span class="s1">'^"24\.'</span> GeoIPCountryWhois.csv <span class="p">|</span> head
<span class="s2">"24.36.0.0"</span>,<span class="s2">"24.37.255.255"</span>,<span class="s2">"405012480"</span>,<span class="s2">"405143551"</span>,<span class="s2">"CA"</span>,<span class="s2">"Canada"</span>
<span class="s2">"24.38.0.0"</span>,<span class="s2">"24.38.143.255"</span>,<span class="s2">"405143552"</span>,<span class="s2">"405180415"</span>,<span class="s2">"US"</span>,<span class="s2">"United States"</span>
<span class="s2">"24.38.144.0"</span>,<span class="s2">"24.38.159.255"</span>,<span class="s2">"405180416"</span>,<span class="s2">"405184511"</span>,<span class="s2">"CA"</span>,<span class="s2">"Canada"</span>
<span class="s2">"24.38.160.0"</span>,<span class="s2">"24.41.95.255"</span>,<span class="s2">"405184512"</span>,<span class="s2">"405364735"</span>,<span class="s2">"US"</span>,<span class="s2">"United States"</span>
<span class="s2">"24.41.96.0"</span>,<span class="s2">"24.41.127.255"</span>,<span class="s2">"405364736"</span>,<span class="s2">"405372927"</span>,<span class="s2">"CA"</span>,<span class="s2">"Canada"</span>
<span class="s2">"24.41.128.0"</span>,<span class="s2">"24.42.63.255"</span>,<span class="s2">"405372928"</span>,<span class="s2">"405422079"</span>,<span class="s2">"PR"</span>,<span class="s2">"Puerto Rico"</span>
<span class="s2">"24.42.64.0"</span>,<span class="s2">"24.47.255.255"</span>,<span class="s2">"405422080"</span>,<span class="s2">"405798911"</span>,<span class="s2">"US"</span>,<span class="s2">"United States"</span>
<span class="s2">"24.48.0.0"</span>,<span class="s2">"24.48.127.255"</span>,<span class="s2">"405798912"</span>,<span class="s2">"405831679"</span>,<span class="s2">"CA"</span>,<span class="s2">"Canada"</span>
<span class="s2">"24.48.128.0"</span>,<span class="s2">"24.48.175.255"</span>,<span class="s2">"405831680"</span>,<span class="s2">"405843967"</span>,<span class="s2">"US"</span>,<span class="s2">"United States"</span>
<span class="s2">"24.48.176.0"</span>,<span class="s2">"24.48.191.255"</span>,<span class="s2">"405843968"</span>,<span class="s2">"405848063"</span>,<span class="s2">"CA"</span>,<span class="s2">"Canada"</span>
</pre></div>
<p>At this point I wondered if any IP addresses would return the same results from all three implementations and whois. I picked 24.244.192.0 from the CSV file:</p>
<div class="highlight"><pre><span class="nv">$ </span>grep 24.244.192.0 GeoIPCountryWhois.csv
<span class="s2">"24.244.192.0"</span>,<span class="s2">"24.244.255.255"</span>,<span class="s2">"418693120"</span>,<span class="s2">"418709503"</span>,<span class="s2">"CA"</span>,<span class="s2">"Canada"</span>
</pre></div>
<p>Whois said the IP address is mapped to a network in Richmond Hill, Ontario, Canada. All python-based and redis-based lookups returned Canada as their answer as well.</p>
</div>

  </div>

   <div id="support_text"><p>
    Thank you for taking the time to read this post. If you're considering using </p><a href="https://www.digitalocean.com/?refcode=074ce6598105">Digital Ocean</a><p>, the hosting provider this blog is hosted on, please consider using </p><a href="https://www.digitalocean.com/?refcode=074ce6598105">this link to sign up</a><p>.
  </p></div>


  
</div></body></html>