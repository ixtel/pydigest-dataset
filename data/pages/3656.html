<html><body><div><div class="content html_format"><p>
      Думали ли вы когда-нибудь о том, что однажды слишком быстро втянулись в веб-программирование на PHP? И вот уже прошло много лет, у вас хороший опыт, и вы не думаете ни о каких других способах „делать“ веб, кроме как на PHP. Может быть, у вас возникают сомнения в правильности выбора, однако непонятно, как найти способ быстро его проверить. А хочется примеров, хочется знать, как изменятся конкретные аспекты деятельности. </p>
<p>
Сегодня я попробую ответить на вопрос: </p><b>«А что если вместо PHP писать на Python?»</b><p>.
</p><p>
Сам я долгое время задавался этим вопросом. Я писал на PHP 11 лет и даже являюсь сертифицированным специалистом. Я научился его «готовить» так, чтобы он работал в точности, как мне надо. И когда я в очередной раз читал на Хабре перевод статьи о том, </p><a href="http://habrahabr.ru/post/142140/">как всё в PHP плохо</a><p>, я просто недоумевал. Однако подвернулся случай пересесть на Ruby, а потом и на Python. На последнем я и остановился, и теперь попробую рассказать вам PHP-шникам, как нам питонистам живётся.

</p><img src="https://habrastorage.org/files/07c/e61/6dc/07ce616dc14c4f49895abe06374ac3f3.png"/>
<a name="habracut"/>

<h4>Формат статьи</h4><p>
Наилучший способ познавать новый язык — сравнение с регулярно-используемым, если новый язык не принципиально отличается от текущего. Неплохая попытка сделана </p><a href="https://www.ruby-lang.org/ru/documentation/ruby-from-other-languages/">на сайте Ruby</a><p>, но, к сожалению, там мало примеров.
</p><p>
Также я должен отметить, что я сравню не все аспекты деятельности, а только те, которые будут бросаться в глаза в первые недели работы с новым языком.

</p><h4>Подготовка консолей</h4><p>
Я попытался сделать эту статью интерактивной. Поэтому при прочтении настоятельно рекомендую набирать примеры из неё в консолях. Вам понадобится консоль PHP 5.3+, а лучше сразу </p><a href="http://psysh.org/">psysh</a><p>:

</p><pre><code class="bash">php -a</code></pre><p>
И консоль Python 2/3. Лучше поставить более удобные варианты </p><a href="http://bpython-interpreter.org/">bpython</a><p> или </p><a href="http://ipython.org/">ipython</a><p>, чем встроенная в язык по умолчанию, так как в них уже есть автодополнение. Но можно и так:

</p><pre><code class="bash">python</code></pre>
<pre><code class="python">import rlcompleter
import readline
readline.parse_and_bind("tab: complete")    # Это включит автодополнение
</code></pre>
<div class="spoiler"><b class="spoiler_title">Как не делать это каждый раз</b><div class="spoiler_text"><p>В файл ~/.pyrc положить:</p>
<pre><code class="python">import rlcompleter
import readline
readline.parse_and_bind("tab: complete")    # Это включит автодополнение
</code></pre><p>
В ~/.bashrc добавить:
</p><pre><code class="bash">
export PYTHONSTARTUP="${HOME}/.pyrc"
export PYTHONIOENCODING="UTF-8"
</code></pre><p>
И, чтобы применить изменение прямо сейчас без перезапуска консоли, выполнить:
</p><pre><code class="bash">source ~/.bashrc</code></pre>
</div></div>

<h4>Сам язык</h4>
<ul>
<li>Python — язык со <b>строгой</b> неявной динамической типизацией (см. <a href="http://habrahabr.ru/post/161205/">Ликбез по типизации</a>). Python — не имеет чёткого назначения, используется для веб, демонов, приложений, научных расчётов, как язык расширений. Близкие аналоги по типизации: Ruby.</li>
<li>PHP — язык с <b>нестрогой</b> неявной динамической типизацией. PHP — тоже язык общего назначения, однако области применения, отличные от веб и демонов, в нём проработаны плохо и не пригодны к продакшену. Некоторые полагают, что это из-за того, что <a href="http://habrahabr.ru/post/179399/">PHP создан чтобы умирать</a>. Близкие аналоги по типизации: JavaScript, Lua, Perl.</li>
</ul>
<h5>Основные особенности</h5>
<ul>
<li>Код пишем в файлах с расширением .py вне зависимости от версии питона. Никаких открывающих тегов аналогичных &lt;?PHP не нужно, так как питон изначально создавался как язык программирования общего назначения.</li>
<li>Кстати, по этой же причине нет такой вещи как php.ini. Есть <a href="https://docs.python.org/2/using/cmdline.html#environment-variables">два десятка переменных окружения</a>, но почти всегда они не определены (кроме PYTHONIOENCODING). То есть, никаких дефолтных конекшенов к базам, управлений фильтрами ошибок, лимитами, расширениями и пр. Что, между прочим, характерно для большинства языков общего назначения. И в связи с этим поведение программ практически идентично всегда (а не зависит от любимых настроек вашего тимлида). Настройки аналогичные php.ini почти всегда хранятся в главном конфиге приложения.</li>
<li>Нет точки с запятой в конце строки. Если её поставить, то она будет работать так же, как и в PHP, но вообще она является необязательной и нежелательной. Поэтому можно сразу забыть о ней.</li>
<li>Переменные не начинаются с <b>$</b> (кстати, PHP унаследовал это от Perl, а тот — от баш).</li>
<li>Присваивание в циклах и условиях не работает. Сделано это специально, чтобы никто не перепутал сравнение с присваиванием, что, по мнению автора языка, является нередкой ошибкой.</li>
<li>Python при парсинге файлов автоматически рядом кладет копию с расширением .pyc (если у вас Python &lt; 3.3 и вы не установили <a href="https://docs.python.org/2/using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE">PYTHONDONTWRITEBYTECODE</a>), где находится байт-код того, что вы написали. Затем он всегда выполняет только этот файл, если вы не изменили исходник. Данные файлы автоматически игнорируются во всех IDE и обычно не мешают. Это можно воспринимать как полный аналог PHP APC, с учётом того .pyc файлы скорее всего будут находится в памяти в файловом кэше.</li>
<li>Вместо: NULL, TRUE, FALSE — None, True, False и только в таком регистре.</li>
</ul>
<h6>Вложенность отступами</h6><p>
Ну и самая необычная вещь: вложенность кода определяется не фигурными скобками, а отступами. То есть вместо того, чтобы писать так:

</p><pre><code class="php">foreach($a as $value) {
    $formatted = $value.'%';
    echo $formatted;
}
</code></pre><p> Надо делать так:
</p><pre><code class="python">for value in a:
    formatted = value + '%'
    print(formatted)
</code></pre>
<blockquote><img src="https://habrastorage.org/getpro/habr/post_images/053/d99/82f/053d9982f06d74ec1d26860a59c3ae58.png"/><br/>
Стойте, стойте! Не спешите закрывать вкладку. Здесь вы можете сделать ошибку, такую же, как сделал я. Когда-то мысль о том, что вложенность кода определяется отступами, казалась мне полным идиотизмом. Все защитные силы организма протестовали в едином порыве. Ведь несмотря на всякие Style Guide, все пишут по-разному.<br/>
</blockquote><p>
Я открою вам страшную тайну. Проблемы отступов не существует. Отступы в 99% процентах случаев автоматически расставляются IDE точно так же, как и в любом другом языке. Вы вообще даже не думаете об этом. За 2 года работы с языком я не припомню ни одного случая, когда кто-нибудь накосячил бы с отступами.

</p><h4>Строгая типизация</h4><p>
Следующая вещь на которой стоит сфокусировать внимание — строгая типизация. Но для начала немного кода:

</p><pre><code class="php">print '0.60' * 5;

print '5' == 5;

$a = array('5'=&gt;true);
print $a[5];

$value = 75;
print $value.'%';

$a='0';
if($a) print 'non zero length';  // Самая частая ошибка
</code></pre><p>
Все указанные вещи возможны благодаря нестрогой типизации. Но в питоне это не работает:

</p><pre><code class="python">&gt;&gt;&gt; print "25" + 5
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: cannot concatenate 'str' and 'int' objects
</code></pre>
<div class="spoiler"><b class="spoiler_title">Кроме...</b><div class="spoiler_text"><p>Исключение составляет только совместное использование чисел и булевских значений, но </p><a href="https://docs.python.org/2/library/stdtypes.html#boolean-values">так задумано</a><p>.</p></div></div><p>
Правда, обычно у вас в коде типы перемешиваться не будут и данный эффект не будет мозолить вам глаза. В принципе, когда я писал на PHP, ситуаций когда нестрогая типизация реально помогала, было 1-2 на проект, а так обычно взаимодействовали переменные одного типа.
</p><p>
Философия строгой типизации накладывает свой отпечаток и на обработку ошибок. Например, если функция </p><u>int</u><p> должна возвращать целый тип, то она не может вернуть </p><u>None</u><p> на строку, из которой нельзя однозначно извлечь этот тип. Поэтому генерируется исключение. Это грозит тем, что всё, что прислал пользователь, надо преобразовывать в нужный тип, иначе вы рано или поздно схватите эксепшн на проде.

</p><pre><code class="python">try:
    custom_price = int(request.GET.get('custom_price', 0))
except ValueError:
    custom_price = 0
</code></pre><p>
Это касается не только стандартных функций, но и некоторых методов для списков, строк, части функций во вспомогательных библиотеках. Обычно питон-разработчик примерно на память помнит, где какое исключение может упасть, и учитывает это. Если не помнит, иногда лазит в код библиотеки, чтобы подсмотреть. Но конечно же иногда бывает, что не все варианты учитываются, и порой пользователи ловят эксепшены на проде. Но поскольку это нечастое явление, и обычно веб-фреймворк присылает их админу на почту автоматически, всё довольно быстро чинится.
</p><p>
Чтобы использовать значения разных типов в одном выражении, вам нужно их преобразовать, для этого есть функции: </p><u>str</u><p>, </p><u>int</u><p>, </p><u>bool</u><p>, </p><u>long</u><p>. Ну а для форматирования есть более элегантные конструкции.

</p><h4>Строки</h4>
<h5>Форматирование</h5><p>
Было:

</p><pre><code class="php">$tak = 'так';
echo "Вы сейчас делаете $tak или {$tak}.";
echo "Или ".$tak.".";
echo sprintf("Но бывает и %s или %1$'.9s.", $tak);
</code></pre><p>
Теперь вам нужно просто переучиться:

</p><pre><code class="python">etot = 'этот'
var = 'вариант'
print('На %s вариант' % etot)
print(etot + ' вариант тоже можно использовать, но не рекомендуется')
print('Или на %s %s' % (etot, var))
print('Или на %(etot)s %(var)s' % {'etot': etot, 'var': var})  # Очень удобно для локализаторов
print('Или на {} {}'.format(etot, var))
print('Или на {1} {0}'.format(var, etot))
print('Или на {etot} {var}'.format(var=var, etot=etot))
</code></pre><p>
Вариантов вроде больше, а вот подстановки одной-двух переменных через фигурные скобки в двойных кавычках реально не хватает. Зато есть хороший вариант для локализаторов.

</p><h5>Методы строки</h5><p>
Самое главное, что есть в Python и чего не хватает в PHP, — это встроенные методы. Давайте сравним:

</p><pre><code class="php">strpos($a, 'tr');
trim($a);
</code></pre><b>vs</b>
<pre><code class="python">a.index('tr')
a.strip()
</code></pre><p>
А как часто вы делали что-то типа такого?

</p><pre><code class="php">substr($a, strpos($a, 'name: '));
</code></pre><b>vs</b>
<pre><code class="python">a[a.index('name: '):]
</code></pre>

<h5>Поддержка юникода</h5><p>
Ну и наконец юникод. В Python 2 все строки по умолчанию не юникод (В Python 3 — по умолчанию юникод). Но стоит вам подставить магическую букву </p><b>u</b><p> вначале строки, как она автоматически становится юникодной. И далее все встроенные (и не встроенные) строковые методы Python будут работать хорошо.

</p><pre><code class="python">&gt;&gt;&gt; len('Привет мир')
19
&gt;&gt;&gt; len(u'Привет мир')
10
</code></pre><blockquote><img src="https://habrastorage.org/getpro/habr/post_images/053/d99/82f/053d9982f06d74ec1d26860a59c3ae58.png"/><br/>
В PHP, кстати, вы можете воспользоваться MBString function overloading <a href="http://php.net/manual/en/mbstring.overload.php">php.net/manual/en/mbstring.overload.php</a> и получить аналогичный эффект. Правда, вы лишаетесь работы с помощью перегруженных функций с бинарными строками, но вы по прежнему можете работать со строкой как с массивом.<br/>
</blockquote>
<div class="spoiler"><b class="spoiler_title">Немного про сырые строки</b><div class="spoiler_text"><h5>«Сырые» строки</h5><p>
Многие из вас знают чем одиночные кавычки отличаются от двойных:
</p><pre><code class="php">$a = 'Hello.\n';
$a[strlen($a)-1] != "\n"; 
</code></pre><p>
Что-то подобное есть и в Python. Если подставлять перед строкой литерал </p><b>r</b><p>, то это поведение почти аналогично одиночным кавычкам в PHP.
</p><pre><code class="python">a = r'Hello.\n' 
a[-1] != '\n'
</code></pre>
</div></div>
<h4>Массивы</h4><p>
Теперь разберёмся с массивом. В PHP вы могли запихнуть в качестве ключей целые числа или строки:

</p><pre><code class="php">var_dump([0=&gt;1, 'key'=&gt;'value']); 
</code></pre><blockquote><img src="https://habrastorage.org/getpro/habr/post_images/053/d99/82f/053d9982f06d74ec1d26860a59c3ae58.png"/><br/>
Несмотря на то что array переводится как массив, в PHP array не обычный массив (то есть <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29">список</a>), а ассоциативный (то есть, <a href="http://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2">словарь</a>). Обычный массив в PHP тоже есть, это <a href="http://www.php.net/manual/en/class.splfixedarray.php">SPLFixedArray</a>. Он ест меньше памяти, потенциально быстрее, но ввиду сложности объявления и сложности расширения практически не используется.<br/>
</blockquote><p>
В Python для массива мы используем 3-4 типа данных:

</p><ul>
<li>list — список.<br/>
<pre><code class="python">a = [1, 2, 3]  # краткая форма
a[10] = 11  # Нельзя добавлять произвольный индекс
# &gt; IndexError: list assignment index out of range
a.append(11)  # но можно добавлять в конец
del a[0]  # удалять по ключу
a.remove(11)  # удалять по значению
</code></pre></li>
<li>dict — словарь. Интересная особенность, что словарь не гарантирует сохранение порядка (в PHP гарантирует).<br/>
<pre><code class="python">d = {'a': 1, 'b': 2, 'c': 3}  # краткая форма
d[10] = 11  # Можно добавлять произвольный индекс
d[True] = False  # И использовать для ключей любые неизменяемые типы (число, строка, булевские, кортежи, замороженные множества)
del d[True]  # удалять по ключу
</code></pre></li>
<li>tuple — кортеж. Эдакий фиксированный массив с неоднородными значениями. Отлично подходит для возврата из функции нескольких значений и компактного хранения настроек.<br/>
<pre><code class="python">t = (True, 'OK', 200, )  # краткая форма
t[0] = False  # Нельзя менять элемент
# &gt; TypeError: 'tuple' object does not support item assignment
del t[True]  # Нельзя удалять по ключу
# &gt; TypeError: 'tuple' object doesn't support item deletion
t = ([], )  # Но можно менять вложенные изменяемые структуры (списки, словари, множества, массивы байт, объекты)
t[0].append(1)
# &gt; a == ([1], )
</code></pre></li>
<li>set — <a href="http://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%28%D1%82%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%29">множество</a>. По сути, список уникальных значений не гарантирующий сохранения их порядка.<br/>
<pre><code class="python">s = set([1,3,4])
s[0] = False  # Нельзя работать с элементами по индексу
# &gt; TypeError: 'set' object does not support indexing
s.add(5)  # Можно добавлять элемент
s.remove(5)  # Удалять
# Ну и стандартная математика для множеств
s | s  # Объединение
s &amp; s  # Пересечение
s - s  # Разность
s ^ s  # Объединение уникальных
</code></pre></li>
</ul><p>
В PHP массив — эдакий швейцарский нож, всё в одном. А Python больше склоняет к тому, что надо использовать более нативные для Computer Science наборы данных, в каждом место свои, более подходящие. «Да ну их, опять задротам неймётся, программирование должно быть простым», — могут воскликнуть некоторые читатели. И будут неправы, так как:

</p><ul>
<li>Во-первых: наличие выбора между tuple, set, list и dict не отягощает — это становится привычкой, становится подсознательным выбором, как переключение передач.</li>
<li>Во-вторых: почти всегда используется или list или dict.</li>
<li>В-третьих: почти всегда, когда нужно хранить пару ключ-значение, не важен порядок и наоборот, когда нужно хранить порядок, очень редко есть при этом пара ключ-значение, а не просто значение.</li>
<li>В-четвёртых: существует упорядоченный dict — <a href="https://docs.python.org/2/library/collections.html#collections.OrderedDict">OrderedDict</a>.</li>
</ul>
<h4>Импорты</h4><p>
Ещё одна интересная вещь — импорты. Своеобразный альтернативный взгляд на неймспейсы с обязательным использованием.
</p><p>
В PHP ты написал </p><u>require_once</u><p> и дальше тебе это доступно, пока жива PHP-шная сессия выполнения. Обычно при использовании CMS люди запихивают всё в классы, а классы располагают в специальных местах, и пишут свою маленькую функцию, которая знает эти места и регистрируют её через </p><u>spl_autoload_register</u><p> в самом начале файла. 
</p><p>
В питоне каждый файл — своя область видимости. И в нём будет доступно только то, что вы в него подгрузите. По умолчанию доступна только стандартная библиотека питона (около 80 функций). Но давайте лучше на примере:
</p><p>
Допустим, вы сделали файл </p><u>tools/logic.py</u>
<pre><code class="python">def is_prime(number):
    max_number = int(sqrt(number))

    for multiplier in range(2, max_number + 1):
        if multiplier &gt; max_number:
            break
        if number % multiplier == 0:
            return False

    return True
</code></pre><p>
И теперь хотите его использовать в файле </p><u>main.py</u><p>. В этой ситуации вам необходимо импортировать или весь файл или нужные вам части в файл, где вы работаете.
</p><pre><code class="python">from tools.logic import is_prime

print(is_prime(79))
</code></pre><p>
И так абсолютно везде. Почти все файлы на питоне начинаются с импортов в текущий файл вспомогательных питонячих объектов: ваших и встроенных библиотек. Это всё равно как если бы функции в PHP вида mysqli_*, pdo_*, memcached_*, а также весь ваш код находились только в неймспейсах, и вам приходилось бы каждый раз их импортировать в каждом файле. Какие преимущества у такого подхода?

</p><ul>
<li>Во-первых: под одинаковым именем в разных файлах могут быть разные объекты. Но именно вы решаете, что и под каким именем будет использовано конкретно здесь.</li>
<li>Во-вторых: резко упрощается рефакторинг. Вы всегда можете отследить класс, функцию или другую сущность. Простейший поиск показывает, где она используется и как.</li>
<li>В-третьих: это принудительно заставляет разработчиков минимально продумывать структуру организации кода.</li>
</ul><p>
Из минусов можно отметить только появление такого эффекта как </p><a href="http://stackoverflow.com/questions/744373/circular-or-cyclic-imports-in-python">циклические импорты</a><p>, но, во-первых, это редкое явление, во-вторых, это штатная ситуация и вполне понятно, как с ней бороться.
</p><p>
Удобно ли каждый раз прописывать импорты? Это зависит от вашего склада ума. Если вам нравится больший контроль над кодом, то вы предпочтёте прописывание импортов, чем их отсутствие. В некоторых командах существует даже своя система правил, описывающих в каком порядке можно подключать внешний код для минимизации циклических импортов до минимума. Если в вашей команде нет таких правил и вы не хотите особо заморачиваться, то можно просто положиться на IDE, которая автоматически проставит импорты для всего, что вы используете. Ну и в довесок: импорты не уникальная особенность питона, в Java и C# тоже есть импорты, вроде никто не жаловался.

</p><h5>Параметры в функции *args, **kwargs</h5><p>
Синтаксис с параметрами по умолчанию в целом похож:

</p><pre><code class="php">function makeyogurt($flavour, $type = "acidophilus")
{
    return "Making a bowl of $type $flavour.";
}
</code></pre><b>vs</b>
<pre><code class="python">def makeyogurt(flavour, ftype="acidophilus"):
    return "Making a bowl of %s %s." % (ftype, flavour, )
</code></pre><p>
Но порой вам нужна функция под неизвестное количество аргументов. Это может быть: проксирующая функция, логирующая функция или функция для получения сигналов. В PHP, начиная с 5.6, вам доступен следующий синтаксис:

</p><pre><code class="php">function sum(...$numbers) {
    $acc = 0;
    foreach ($numbers as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
// Или 
echo add(...[1, 2, 3, 4]);
</code></pre><p>
В Python аналогично можно ловить в массив неименнованные и в словарь именованные аргументы:

</p><pre><code class="python">def acc(*args, **kwargs):
    total = 0
    for n in args:
        total += n
    return total

print(acc(1, 2, 3, 4))
# Или 
print(acc(*[1, 2, 3, 4]))
</code></pre><p>
Соответственно </p><b>*args</b><p> — </p><u>list</u><p> неименованных аргументов, </p><b>**kwargs</b><p> — </p><u>dict</u><p> именованных аргументов.

</p><h4>Классы</h4><p>
Давайте посмотрим на следующий код:

</p><pre><code class="python">class BaseClass:
    def __init__(self):
        print("In BaseClass constructor")

class SubClass(BaseClass):
    def __init__(self, value):
        super(SubClass, self).__init__()
        self.value = value

    def __getattr__(self, name):
        print("Cannot found: %s" % name)

c = SubClass(7)
print(c.value)
</code></pre><p>
Какие основные отличия от PHP мы можем выделить:

</p><ul>
<li><b>self</b> используется вместо <b>$this</b> и обращение всегда происходит через точку. При этом self обязан быть первым аргументом во всех методах (вернее, почти во всех). Идея здесь заключается в том, что Python во все методы передаёт первым аргументом указатель на сам объект (его, кстати, можно ловить в переменную с любым именем).</li>
<li>Как и в PHP, здесь есть <b>аналог магических имён</b>. Вместо <b>__construct</b> — <b>__init__</b>. Вместо <b>__get</b> — <b>__getattr__</b> и т.д.</li>
<li>Не нужен <b>new</b>. Создать экземпляр класса — все равно, что вызвать функцию.</li>
<li><b>Более громоздкое обращение к родительскому методу</b>. С <b>super</b> надо постоянно помнить, что там и куда. <b>parent::</b> в PHP — всё же более элегантная конструкция.</li>
</ul><p>
О чем еще следует сказать:

</p><ul>
<li><b>Можно наследовать более чем один класс.</b></li>
<li><b>Нет public, protected, private</b>. Питон позволяет в runtime менять структуру экземпляра, да и сам класс обычным присваиванием, поэтому от какой-либо защиты решено было отказаться. По этой же причине не нужен и Reflection. Есть только аналог protected — если перед именем написать двойное подчеркивание. Но это просто меняет имя переменной/метода снаружи на неблагозвучное _%ClassName%__%varname%, и по нему прекрасно можно напрямую работать со скрытым.</li>
<li><b>Нет static, финальных классов и интерфейсов.</b> В Python более простая объектная модель в целом. Вместо Singleton у вас скорее всего будет файл со всем необходимым функционалом или файл, который при импорте будет возвращать один и тот же экземпляр. Вместо интерфейса вы скорее всего напишете класс, который бросает исключения на методы, которые забудут переопределить.</li>
<li><b>Чистое ООП не приветствуется.</b> Как бы странно это ни звучало, но благодаря тому, что всё и так объект (даже bool), а также потому, что в синтаксисе нет разных операторов для обращения к методу или функции из импортированного файла, любое обращения идёт через точку. Так вот, благодаря всему этому задача инкапсуляции решается не только через ООП. Поэтому в большинстве проектов классы пишутся только там, где они нужны.</li>
</ul>
<h4>Стиль кодирования</h4><p>
Не знаю как у вас, а я писал на несколько долгоиграющих проектов и всегда отмечал, что стиль кодирования у разных членов команды разный. Нередко по коду можно понять, кто это писал. И всегда хотелось, чтобы был какой-то стандарт оформления кода для единообразия. И всегда были большие споры при согласовании этого документа внутри команды. Для питона это тоже справедливо, но в меньшей степени, ибо есть рекомендации от людей, в квалификации которых мало кто может сомневаться и советов от которых на первое время хватит:

</p><p>
Кроме того существует так называемый </p><a href="https://www.python.org/dev/peps/pep-0020/">Дзен Питона</a><p>, согласно одному из правил которого, «должен существовать один — и, желательно, только один — очевидный способ сделать это». То есть, нельзя один и тот же код написать множеством примерно аналогичных способов. Конечно же, это идеализм, однако он приятно проявляется в мелочах:

</p><ul>
<li>Вместо <a href="http://php.net/manual/en/ref.strings.php">большой строковой библиотеки</a>, с некоторыми функциями, частично перекрывающими друг друга, гораздо меньший набор методов и дополнительные встроенные библиотеки (например для контрольных сумм).</li>
<li>Вместо <b>strlen</b> и <b>count</b> — всегда <b>len</b>.</li>
<li>И т.д.</li>
</ul>
<h4>Версии питона</h4><p>
В PHP новые версии всегда обратно совместимы со старыми. В питоне есть Python 2 и Python 3. Они не совместимы. По этой причине вся «тяжёлая промышленность» до сих пор сидит на Python 2. С Python 3 выпускаются на прод только энтузиасты. Основная причина этого — не портированы на Python 3 или портированы совсем недавно </p><a href="https://python3wos.appspot.com/">некоторые нужные вещи</a><p>. Если вы собираетесь что-либо делать, то Python 2.7 вам более чем будет достаточен. Если вы увлечётесь питоном, вы со временем поймёте, что такое Python 3 и когда его можно использовать.

</p><h4>Что на что меняется</h4><p>
Здесь я просто оставлю набор ключевых слов, по которым будет понятно, как называется альтернатива той технологии, которой вы пользуетесь сейчас.
</p><ul>
<li>composer -&gt; pip</li>
<li>mod_php -&gt; mod_wsgi</li>
<li>nginx + php-fpm -&gt; nginx + uwsgi + uwsgi_python</li>
<li>daemon.io -&gt; tornado, twisted</li>
<li>Zend Framework -&gt; Django</li>
</ul>
<h4>Вместо выводов</h4>
<h5>Как понять надо ли оно вам?</h5>
<ul>
<li>Вы считаете, что чем строже типизация, тем лучше.</li>
<li>Вы предпочитаете язык с хорошо продуманной архитектурой.</li>
<li>Вы перфекционист, вас раздражает излишнее разнообразие.</li>
<li>Вакансии по питону в вашем городе выглядят интереснее (или надоело писать только сайты).</li>
<li>Хотите, чтобы на основном языке программирования можно было писать любой софт (учитывая разумные ограничения, связанные с динамической типизацией).</li>
<li>Вам не нравится квалификация новичков (из-за низкого порога входа).</li>
</ul>
<h5>Мой способ освоить Python</h5><p>
  Если вы разработчик с опытом, то на всё не сильно напрягаясь уйдёт максимум две-три недели.

</p><ul>
<li><b>1-я неделя:</b> Чтение <a href="http://www.diveintopython.net/">Dive Into Python</a>, главы со 2-й по 7-ю включительно. Остальные быстро пролистать и остановиться на интересных моментах. Параллельно решаем на языке 10 задачек с <a href="https://projecteuler.net/problems">Project Euler</a>. И в конце крайне желательно написать консольную утилиту, принимающую параметры. Это может быть порт какого-то вашего старого bash-скрипта, аналог ls из <a href="http://www.busybox.net/downloads/BusyBox.html">BusyBox</a> или что-то совсем другое. Важно, чтобы скрипт делал что-то полезное, желательно то, чем вы часто пользуетесь. Я, например, сделал порт <a href="https://github.com/gnomeby/memcached-itool">своей PHP-утилиты</a>, которая умеет показывать данные в мемкэше.</li>
<li><b>2-я неделя:</b> Напишите простенький аналог хабра на Django и запустите на любом хостинге. Не забудьте состав: регистрация, логин, восстановление пароля, добавления постов и комментариев, удаление, проверка прав на действия.</li>
<li><b>3-я неделя:</b> выбор конторы, где бы вы хотели работать, засылка им резюме с просьбой выслать тестовое задание на питоне для проверки вашей квалификации.</li>
</ul><p>
Ещё есть </p><a href="https://www.youtube.com/watch?v=tKTZoB2Vjuk&amp;list=PLC8825D0450647509">Google Python Classes</a><p>.</p><p>
Удачи!

</p><b>Обновлено:</b><p> Мелкие исправления и улучшения (благодаря:  </p><a href="https://habrahabr.ru/users/dginz/" class="user_link">dginz</a><p>,  </p><a href="https://habrahabr.ru/users/defuz/" class="user_link">defuz</a><p>,  </p><a href="https://habrahabr.ru/users/dsx/" class="user_link">dsx</a><p>,  </p><a href="https://habrahabr.ru/users/stepanow/" class="user_link">Stepanow</a><p>,  </p><a href="https://habrahabr.ru/users/studebecker/" class="user_link">Studebecker</a><p>), найден драйвер MySQL для Python 3.3 (благодаря  </p><a href="https://habrahabr.ru/users/svartalf/" class="user_link">svartalf</a><p>).
</p><b>Обновлено:</b><p> Нашлись </p><a href="https://docs.python.org/2.7/library/abc.html">абстрактные классы</a><p> (благодаря:  </p><a href="https://habrahabr.ru/users/yktoo/" class="user_link">yktoo</a><p>). Так же со временем вам придётся познакомиться с удивительным </p><a href="http://habrahabr.ru/post/141411/">миром декораторов</a><p>.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>