<html><body><div><div itemprop="articleBody"><p>Debugging is a favourite subject of mine. It's an incredibly interesting area of programming but unfortunately not always a trivial one. It's also very important - it plays a significant part in programmer's productivity. No matter how many QA tools you have at your disposal, and no matter how hard you try to create bug-free code you will need to do debugging. It's just one of the intractable facets of programming.</p><p>Here's my attempt to define some concepts and guidelines. What are the tenets of debugging?</p><div class="section" id="find-the-cause-first"><h2>Find the cause first<a class="headerlink" href="#find-the-cause-first" title="Permalink to this headline"> *</a></h2><p>This is the most important, for many reasons. Yes, some issues can be quite hard to understand but with time, as you build up knowledge, it gets easier. If you just try random changes (<a class="reference external" href="https://en.wikipedia.org/wiki/Shotgun_debugging">shotgun debugging</a>) in hopes that it will fix the problem then you're in fact depriving yourself of knowledge and assurance that you actually fixed the problem. It may seem easier, especially if you get lucky but overall you'll waste inordinate amounts of time with that "technique". Focus on finding the cause first.</p><div class="section" id="down-the-rabbit-hole"><h3>Down the rabbit hole<a class="headerlink" href="#down-the-rabbit-hole" title="Permalink to this headline"> *</a></h3><p>Unfortunately you have to accept the harsh reality that there are no shortcuts:</p><ul><li><p class="first">You'll have to read lots of code to understand what's going on. Yes, that includes other peoples code. You're using a framework? You'll have to read the code.</p><p>Lots of people avoid this because it's hard and many frameworks are complicated. But understanding your libraries will pay off.</p></li><li><p class="first">You won't see the problem by merely looking at the code <a class="footnote-reference" href="#id4" id="id1">[1]</a> so you'll have to inspect the execution of the code and reason about it.</p></li><li><p class="first">Not understanding the cause can be grueling and frustrating; it can take a while. But once you figure it out it's pleasant. It's totally worth the pain, plus next time it get easier - the accumulated knowledge helps. Don't give up!</p></li></ul></div><div class="section" id="rooting-it-out"><h3>Rooting it out<a class="headerlink" href="#rooting-it-out" title="Permalink to this headline"> *</a></h3><p>Assuming you got the <a class="reference external" href="https://blog.ionelmc.ro/2013/06/05/python-debugging-tools/">right tools</a>, there are various "techniques" you can use.</p><blockquote class="highlights"> Simpler programs are easier to understand than complicated programs with lots of moving parts.</blockquote><p>One of the best approaches is to isolate the issue. Some call it <a class="reference external" href="http://haypo-notes.readthedocs.org/misc.html#dichotomy">divide &amp; conquer</a>. The idea is to reduce the amount of code you need to comprehend. It's similar to making a <a class="reference external" href="http://sscce.org/">very good bug report</a>:</p><ul><li><p class="first">Remove code or don't run code that's unnecessary or unrelated. If you're not sure, take it out. If the issue doesn't reproduce anymore then you know what to focus on. Just remove half of the code till you see where the problem is.</p><p>For example, you'd do it when execution stops at some unknown point and you need to figure out where it is. It may indicate you don't have good tooling (like an adequate tracer).</p></li><li><p class="first">If you're having a regression you can use <a class="reference external" href="https://git-scm.com/docs/git-bisect">git bisect</a> (or <a class="reference external" href="https://selenic.com/hg/help/bisect">hg bisect</a>) to find the offending commit. That tool will run a command of your choosing till the first commit that makes it fail is found.</p></li><li><p class="first">Isolate any environment issues. Try a different OS, library or Python version. Note that this can be misleading - if the problem doesn't reproduce with a different Python it doesn't mean that the issue is in the Python interpreter - it may very well be an issue with your code (example: misusing some API).</p></li></ul><p>A more risky way to approach things is "proving the hypothesis": you make some theory about what might be wrong and then test it. There are some pitfalls:</p><ul class="simple"><li>It's only good if you got some intuition in the problem space. Otherwise you'd practically be doing <a class="reference external" href="https://en.wikipedia.org/wiki/Shotgun_debugging">shotgun debugging</a>.</li><li>If you find a way to make the bug disappear but don't understand why do not stop there. Understanding the cause is paramount.</li></ul><p>Another way is the "secret police" method: assume everything is bad, vet any component, including external ones. Usually this is a "last resort" thing for <a class="reference external" href="https://medium.com/vijay-pandurangan/linux-kernel-bug-delivers-corrupt-tcp-ip-data-to-mesos-kubernetes-docker-containers-4986f88f7a19">crazy</a><a class="reference external" href="https://sandstorm.io/news/2015-04-08-osx-security-bug">issues</a>.</p></div></div><div class="section" id="plan-for-disaster"><h2>Plan for disaster<a class="headerlink" href="#plan-for-disaster" title="Permalink to this headline"> *</a></h2><p>Everything is easier when you're prepared. When you write code, or choose what code to reuse have in mind that one fateful day you will have to deal with the choices you've made. There are two aspects you should consider.</p><div class="section" id="code"><h3>Code<a class="headerlink" href="#code" title="Permalink to this headline"> *</a></h3><p>Most certainly you'll have to read code, possibly not your own code. Factor that in when writing code or when choosing a framework or library, along other factors like documentation quality, number of users and how well it is maintained.</p><blockquote class="highlights"> Code you don't understand might as well be technical debt!</blockquote><p>Have these ideas in mind when writing/reviewing code, or when choosing what library to use:</p><ul><li><p class="first">If it's big, complicated and hard to understand it will cost you. Plan the time you'll need to spend understanding it. It's surprising how much time you'll waste on a library that's advertised to save time.</p><p>It's not just the effort to understand the internals. Inordinate amounts of time are often wasted on shoehorning slightly different (but unplanned for) use cases. Big fancy frameworks optimize for typical use-cases and make everything else hard to accomplish. There are exceptions of course, but rare.</p></li><li><p class="first">A community can help a lot. Having a place to ask for help means that you don't need that much upfront knowledge.</p></li><li><p class="first">Code quality. Less bugs means less debugging right?</p><p>There are many practices but here are few ones:</p><ul><li><p class="first">Code reviews.</p></li><li><p class="first">Good exception handling. Don't discard or <a class="reference external" href="https://blog.ionelmc.ro/2014/08/03/the-most-underrated-feature-in-python-3/">cripple exceptions</a>. Give descriptive errors that indicates what needs to be fixed.</p><p>Good error handling makes debugging more predictable, and less of a bottomless hole to sink your time in.</p></li></ul></li></ul></div><div class="section" id="plan-for-disaster-but-live-dangerously"><h3>Plan for disaster, but live dangerously<a class="headerlink" href="#plan-for-disaster-but-live-dangerously" title="Permalink to this headline"> *</a></h3><p>Safety don't present the same opportunities for acquiring knowledge. It's often necessary to do more tricky things, at least for the sake of getting the information you need while debugging, if not for figuring why that metaclass-using ORM don't work as you expect.</p><p>For example, you wouldn't normally do monkey-patching in your code, but maybe it's <a class="reference external" href="http://python-aspectlib.readthedocs.org/en/latest/reference/aspectlib.debug.html#aspectlib.debug.log">an option</a> when otherwise you'd have to patch up lots of files.</p><p>On the other hand, experimentation is prone to failure so there's the open question of where's a good place to experiment ...</p></div></div><div class="section" id="ask-for-help-but-understand"><h2>Ask for help but understand<a class="headerlink" href="#ask-for-help-but-understand" title="Permalink to this headline"> *</a></h2><p>You got a bug, you ask your colleague and 5 minutes later it's sorted out. Don't leave it at that. Ask how and why. Understand the process used to find the case. Identify best practices if possible.</p></div><div class="section" id="integration-tests-pay-off"><h2>Integration tests pay off<a class="headerlink" href="#integration-tests-pay-off" title="Permalink to this headline"> *</a></h2><p>The interesting thing about tests it's not that they make debugging easier, it's that they force you to resolve bugs early. They give you a warning early so you can fix it at a convenient time. Compare that to a production issue that you gotta fix on a Friday night.</p><p>To make an analogy: it's like owning a car - you'd want to get warning indicators and service it at an opportune time rather than having it break down in the middle of nowhere.</p><p>Integration tests, and not unit tests because they reach out those areas between various components (interactions) where the nasty bugs are in. Simply put, production won't run just a function, it will a combination thereof. Debate about what's the right balance of unit tests vs functional tests <a class="reference external" href="http://nedbatchelder.com/blog/201602/the_value_of_unit_tests.html">still rages on</a>, but you need to be aware that you can't simply go for a pure unit test suite and hope for the best.</p></div><div class="section" id="other-peoples-misery-is-gold"><h2>Other peoples misery is gold<a class="headerlink" href="#other-peoples-misery-is-gold" title="Permalink to this headline"> *</a></h2><p>Reading what <a class="reference external" href="https://github.com/danluu/post-mortems">issues other people had</a> <a class="footnote-reference" href="#id6" id="id3">[3]</a> is pure gold. There is simply no way you can accumulate all that knowledge only from the software you develop yourself. It's a huge boost to your intuition as well. Plus you won't feel that bad when you have a problem - there's always someone you had it worse.</p><p>If you have the time you can also <a class="reference external" href="http://pymust.watch/">watch videos</a> or <a class="reference external" href="http://planet.python.org">read other peoples blogs</a>. Every so often there something describing an interesting problem or various obscure but useful details.</p></div></div></div></body></html>