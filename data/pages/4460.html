<html><body><div><div class="post-text" itemprop="text">
<p>This isn't very clean, but is a possible solution.  First, I moved the index into a column, <code>date1</code>:</p>

<pre><code>In [228]: df
Out[228]: 
       date1      date2  id  value
0 2006-01-24 2006-01-26   3    3.0
1 2006-01-25 2006-01-26   1    1.0
2 2006-01-25 2006-01-26   2    2.0
3 2006-01-26 2006-01-26   2    2.1
</code></pre>

<p>Then I grouped by each pair of dates, adding ids to those pairs that match.  This involves breaking the DataFrame into a list of subframes and use <code>concat</code> to stick back together.</p>

<pre><code>In [229]: dfs = []
     ...: for (date1, date2), df_gb in df.groupby(['date1','date2']):
     ...:     if date1 == date2:
     ...:         to_add = list(set([1,2,3]) - set(df_gb['id']))
     ...:         df_gb = df_gb.append(pd.DataFrame({'id': to_add, 'date1': date1, 'date2': date2, 'value': np.nan}), ignore_index=True)
     ...:     dfs.append(df_gb)

In [231]: df = pd.concat(dfs, ignore_index=True)

In [232]: df
Out[232]: 
       date1      date2  id  value
0 2006-01-24 2006-01-26   3    3.0
1 2006-01-25 2006-01-26   1    1.0
2 2006-01-25 2006-01-26   2    2.0
3 2006-01-26 2006-01-26   2    2.1
4 2006-01-26 2006-01-26   1    NaN
5 2006-01-26 2006-01-26   3    NaN
</code></pre>

<p>Finally, I sorted and filled the missing values.</p>

<pre><code>In [233]: df = df.sort(['id', 'date1', 'date2'])

In [234]: df = df.fillna(method='ffill')

In [236]: df.sort(['date1', 'date2'])
Out[236]: 
       date1      date2  id  value
0 2006-01-24 2006-01-26   3    3.0
1 2006-01-25 2006-01-26   1    1.0
2 2006-01-25 2006-01-26   2    2.0
4 2006-01-26 2006-01-26   1    1.0
3 2006-01-26 2006-01-26   2    2.1
5 2006-01-26 2006-01-26   3    3.0
</code></pre>
    </div>
    </div></body></html>