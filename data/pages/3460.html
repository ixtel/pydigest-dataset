<html><body><div><p class="lead" itemprop="description">Эта статья о том, как важно быть последовательным. А также о том, почему иногда могут не работать проверки идентичности и наследования классов, и проверки принадлежности объекта к классу.</p>
                <div class="py_user"><p>Пожалуй, большую часть из того, что я хочу сейчас вам рассказать правильнее было бы выразить в коде. Для наглядости. Итак, приступим:</p><p>Наверное, после запуска этого кода, особых пояснений больше не потребуется, однако пару слов я всё же скажу.</p><p>Итак, механизм импорта честно отрабатывает, выполняя то, что ему поручили, и в </p><code>sys.modules</code><p> появляется два </p><i>разных</i><p> модуля. Импортированный разными способами один и тот же класс, различается, помимо прочего, атрибутом </p><code>__module__</code><p>, который был проставлен в момент </p><a href="https://github.com/python/cpython/blob/989ae311fe6c6e3c8accb49942d0386e999cf1eb/Objects/typeobject.c#L2134" target="_blank">создания типа</a><p>.</p><p>И, если вам вдруг интересно, где (помимо этого странного кода выше) можно натолкнуться на такое поведение, то я скажу, что в любых проектах со множеством [вложенных] модулей есть такой шанс. Например, в Django, создатели которого вовсе не зря советуют придерживаться одного стиля импорта, не мешать абсолютные с относительными.</p><p>Будьте последовательны, не забывайте про тесты. </p><p>Удачи!</p></div>

                

                

                </div></body></html>