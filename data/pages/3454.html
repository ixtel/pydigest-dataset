<html><body><div><p class="lead" itemprop="description">Небольшой рассказ о том,  как и нужно ли искать компромисс между совестью питониста — Дзеном Питона — и удобством ПИП (API).</p>
                <div class="py_user"><p>Однажды, где-то в районе августа 2013 года, мне на ум пришла идея очередного приложения для Django. Идея заключалась в том, чтобы дать пользователям возможность управлять настройками приложения (обычно они расположены в settings.py этого самого приложения) через административный интерфейс Django. </p><p>В обязательном порядке, перед тем как создавать что-то новое, требуется проверить, нет ли уже готового решения. </p><p>Тот же </p><a href="https://www.djangopackages.com/grids/g/live-setting/" target="_blank">Django Packages</a><p> на гора выдаёт сразу несколько вариантов. Проблема с этими вариантами, если я правильно помню, заключалась в том, что практически все они предлагали определять настройки в терминах своего микроязыка, например при помощи классов. Но у меня уже есть мой settings.py, в котором прекрасно живут псевдоконстанты настроек. Как бы так изловчиться, чтобы их и использовать, ведь именно их использует уже написанный ранее код? В общем, как вы уже догадались, существующие решения не подошли, нужно было подумать самому.</p><p>Разработка идеи началась с изучения возможности использования в settings.py некой функции-регистратора, которая могла бы указывать на имена [в пространстве имён файла], хранящие настройки. Хотелось, чтобы функция регистрации использовала не строки с именами, а сами имена, а частности, чтобы IDE могли понять, что откуда. </p><p>Примерно так:</p><pre><code class="python"><br/>    A = True<br/>    B = True<br/>    C = False<br/>    D = 42<br/><br/>    store_values(A, B, C, D)<br/></code></pre><p>Итак: </p><b>store_values</b><p> получает не имена, а значения, ну, а нам нужно отследить, какое значение с каким именем связано. На ум пришло несколько вариантов решений, с которыми я и отправился на  </p><a href="http://stackoverflow.com/questions/18042733" target="_blank">StackOverflow</a><p>, дабы узнать, как решали бы подобную задачу другие люди.</p><p>Как видите, в первом же комментарии мне рассказали о том, что это бессмысленная задача, которую никогда никому решать не придётся. Ну, и вариант решения предложили соответствующий — используй строки с именами и никаких гвоздей. И ещё напугали, что все другие подходы от лукавого (завязаны на чёрную магию и против Дзена), угнетают пользователей, не соответствуют модели данных Питона и такие хрупкие, что вот-вот сломаются. А дальше и вовсе закрыли вопрос с резолюцией: «Вопрос должен демонстрировать хотя бы минимальное понимание решаемой задачи». Пусть так %P</p><p>В общем, ответ-то я тогда получил, но зудеть от этого не перестало. Более того, задача расширилась, теперь нужно было, чтобы решение было не слишком хрупким, не заставляло пользователей удивляться, и умело скрывало, что использует чёрную магию %)</p><p>И решение нашлось, и оно оформилось в приложение </p><a href="https://pypi.python.org/pypi/django-siteprefs/" target="_blank">django-siteprefs</a><p>.  Выглядит решение примерно так:</p><pre><code class="python"><br/>  # Внутри settings.py вашего приложения.<br/>  <br/>   ... # Здесь уже объявлены ранее наши псевдоконстанты настроек.<br/><br/>  try:  # Уважаем право людей не использовать siteprefs.<br/>      from siteprefs.toolbox import patch_locals, register_prefs, pref, pref_group<br/>  <br/>     # Чтобы пользователи не удивлялись, почему некоторые локальные переменные<br/>     # содержат странные прокси-объекты, заставляем их патчить переменные вручную.<br/>      patch_locals()  <br/><br/>      register_prefs(  # Регистрируем настройки.<br/>        # Например, зарегистрируем группу настроек, относящихся к работе с эл. почтой.<br/>        # И разрешим их редактирование в адм. интерфейсе (static=False)<br/>        pref_group('Почтовые настройки', (ENABLE_MAIL_RECOVERY, ENABLE_MAIL_BOMBS), static=False),<br/>        SLOGAN,  # Эта настройка останется неизменяемой, просто выведется в адм. интерфейсе.<br/>        # Ну, и ещё одна не статичная настройка, с добавлением описаний.<br/>        pref(ENABLE_GRAVATAR_SUPPORT, <br/>            verbose_name='Использовать Gravatar', <br/>            static=False, <br/>            help_text='Разрешает использование аватаров с сервиса Gravatar.'),<br/>      )<br/>  except ImportError:<br/>      pass<br/></code></pre><p>Как это всё работает? Ни дорожной пыли, ни болотной гнили, ни чёрных, ни белых заклинаний. В основе лежит использование инструментов из модуля </p><b>inspect</b><p>.</p><p>Пользователь, вызывая </p><code>patch_locals</code><p>, собственноручно соглашается на внесение изменений в локальный контекст. Какого рода изменения и зачем они нужны?</p><p>Чтобы узнать к какому имени какое значение привязано, нам требуется пройти по именам локального контекста и отыскать объект идентичный переданному в функцию-регистратор. Первое, что приходит на ум, использовать </p><code>id</code><p> объекта, но тут на нашем пути встаёт сам интерпретатор, кеширующий некоторые значения (булево, мелкие целые и пр.). Так, если вернуться к первому примеру, невозможно определить какая </p><b>True</b><p> попала в функцию — из </p><b>A</b><p> или из </p><b>B</b><p>. Поэтому нам остаётся только заменить все объекты в нужном контексте на наши собственные </p><a href="https://github.com/idlesign/django-siteprefs/blob/d11c69ce2f3217c797c842349c5a577814710242/siteprefs/utils.py#L41" target="_blank">PatchedLocal</a><p>, имеющие заведомо разные идентификаторы. Добраться до локальных символов в нужном фрейме нам позволяет тот самый </p><b>inspect</b><p>.</p><p>Позже </p><code>register_prefs</code><p> бережно вернёт на свои места те объекты, которые не будут считаться настройками приложения, а пока она замещает каждую </p><b>PatchedLocal</b><p>, зарегистрированную как настройку приложения, на объект </p><a href="https://github.com/idlesign/django-siteprefs/blob/d11c69ce2f3217c797c842349c5a577814710242/siteprefs/utils.py#L50" target="_blank">PrefProxy</a><p>. Именно с </p><i>PrefProxy</i><p>, имитирующим оригинальное значение, мы и будем работать в дальнейшем как из кода, так и из административной части Django.</p><p>Что получилось в итоге: чёрная магия, которую нам сулили, оказалась не такой уж чёрной; пользователю, смею надеяться, удивляться не приходится; работает приложение, вроде, стабильно. Но главное в нашем деле — ПИП (API), который похоже, не вызывает у людей отторжения (примерно 2 тысячи скачиваний с PyPI в месяц).</p><p>Вот так и вышло, что компромисс между Дзеном и красотой API искать не пришлось, ибо сказано в первых же строках писания: «Красивое лучше безобразного». Не поспоришь.</p><p>Иногда полезно идти наперекор. </p><p>Удачи вам.</p><b>P.S.:</b><p> Вот, что ещё вспомнил. Слыхал, некоторые интересуются взлетит ли проект pythonz.net, а если взлетит, то когда. Отвечаю: </p><i>мы тут про пресмыкающихся говорим. Ползём дальше.</i></div>

                

                

                </div></body></html>