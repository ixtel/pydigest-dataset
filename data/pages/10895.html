<html><body><div><div class="entry-content"><p>Have you ever wanted to combine two or more dictionaries in Python?</p>

<p>There are multiple ways to solve this problem: some are awkward, some are inaccurate, and most require multiple lines of code.</p>

<p>Let’s walk through the different ways of solving this problem and discuss which is the most <a href="https://docs.python.org/3/glossary.html#term-pythonic">Pythonic</a>.</p>

<h2>Our Problem</h2>

<p>Before we can discuss solutions, we need to clearly define our problem.</p>

<p>Our code has two dictionaries: <code>user</code> and <code>defaults</code>.  We want to merge these two dictionaries into a new dictionary called <code>context</code>.</p>

<p>We have some requirements:</p>

<ol>
<li><code>user</code> values should override <code>defaults</code> values in cases of duplicate keys</li>
<li>keys in <code>defaults</code> and <code>user</code> may be any valid keys</li>
<li>the values in <code>defaults</code> and <code>user</code> can be anything</li>
<li><code>defaults</code> and <code>user</code> should not change during the creation of <code>context</code></li>
<li>updates made to <code>context</code> should never alter <code>defaults</code> or <code>user</code></li>
</ol>


<p><strong>Note</strong>: In 5, we’re focused on updates to the dictionary, not contained objects.  For concerns about mutability of nested objects, we should look into <a href="https://docs.python.org/3/library/copy.html#copy.deepcopy">copy.deepcopy</a>.</p>

<p>So we want something like this:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="pycon"><span class="line"><span class="gp">&gt;&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="p">{</span><span class="s">'name'</span><span class="p">:</span> <span class="s">"Trey"</span><span class="p">,</span> <span class="s">'website'</span><span class="p">:</span> <span class="s">"http://treyhunner.com"</span><span class="p">}</span>
</span><span class="line"><span class="gp">&gt;&gt;&gt; </span><span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s">'name'</span><span class="p">:</span> <span class="s">"Anonymous User"</span><span class="p">,</span> <span class="s">'page_name'</span><span class="p">:</span> <span class="s">"Profile Page"</span><span class="p">}</span>
</span><span class="line"><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">merge_dicts</span><span class="p">(</span><span class="n">defaults</span><span class="p">,</span> <span class="n">user</span><span class="p">)</span>  <span class="c"># magical merge function</span>
</span><span class="line"><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span>
</span><span class="line"><span class="go">{'website': 'http://treyhunner.com', 'name': 'Trey', 'page_name': 'Profile Page'}</span>
</span></code></pre></td></tr></table></div></figure>


<p>We’ll also consider whether a solution is Pythonic.  This is a very subjective and often illusory measure.  Here are a few of the particular criteria we will use:</p>

<ul>
<li>The solution should be concise but not terse</li>
<li>The solution should be readable but not overly verbose</li>
<li>The solution should be one line if possible so it can be written inline if needed</li>
<li>The solution should not be needlessly inefficient</li>
</ul>


<h2>Possible Solutions</h2>

<p>Now that we’ve defined our problem, let’s discuss some possible solutions.</p>

<p>We’re going to walk through a number of methods for merging dictionaries and discuss which of these methods is the most accurate and which is the most idiomatic.</p>

<h3>Multiple update</h3>

<p>Here’s one of the simplest ways to merge our dictionaries:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class="line"><span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">defaults</span><span class="p">)</span>
</span><span class="line"><span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here we’re making an empty dictionary and using the <a href="https://docs.python.org/3.5/library/stdtypes.html#dict.update">update</a> method to add items from each of the other dictionaries.  Notice that we’re adding <code>defaults</code> first so that any common keys in <code>user</code> will override those in <code>defaults</code>.</p>

<p>All five of our requirements were met so this is <strong>accurate</strong>.  This solution takes three lines of code and cannot be performed inline, but it’s pretty clear.</p>

<p>Score:</p>

<ul>
<li>Accurate: yes</li>
<li>Idiomatic: fairly, but it would be nicer if it could be inlined</li>
</ul>


<h3>Copy and update</h3>

<p>Alternatively, we could copy <code>defaults</code> and update the copy with <code>user</code>.</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</span><span class="line"><span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>This solution is only slightly different from the previous one.</p>

<p>For this particular problem, I prefer this solution of copying the <code>defaults</code> dictionary to make it clear that <code>defaults</code> represents default values.</p>

<p>Score:</p>

<ul>
<li>Accurate: yes</li>
<li>Idiomatic: yes</li>
</ul>


<h3>Dictionary constructor</h3>

<p>We could also pass our dictionary to the <code>dict</code> constructor which will also copy the dictionary for us:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">defaults</span><span class="p">)</span>
</span><span class="line"><span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>This solution is very similar to the previous one, but it’s a little bit less explicit.</p>

<p>Score:</p>

<ul>
<li>Accurate: yes</li>
<li>Idiomatic: somewhat, though I’d prefer the first two solutions over this</li>
</ul>


<h3>Keyword arguments hack</h3>

<p>You may have seen this clever answer before, <a href="http://stackoverflow.com/a/39858/98187">possibly on StackOverflow</a>:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">defaults</span><span class="p">,</span> <span class="o">**</span><span class="n">user</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is just one line of code.  That’s kind of cool.  However, this solution is a little hard to understand.</p>

<p>Beyond readability, there’s an even bigger problem: <strong>this solution is wrong.</strong></p>

<p>The keys must be strings.  In Python 2 (with the CPython interpreter) we can get away with non-strings as keys, but don’t be fooled: this is a hack that only works by accident in Python 2 using the standard CPython runtime.</p>

<p>Score:</p>

<ul>
<li>Accurate: no.  Requirement 2 is not met (keys may be any valid key)</li>
<li>Idiomatic: no.  This is a hack.</li>
</ul>


<h3>Dictionary comprehension</h3>

<p>Just because we can, let’s try doing this with a dictionary comprehension:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="n">defaults</span><span class="p">,</span> <span class="n">user</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This works, but this is a little hard to read.</p>

<p>If we have an unknown number of dictionaries this might be a good idea, but we’d probably want to break our comprehension over multiple lines to make it more readable.  In our case of two dictionaries, this doubly-nested comprehension is a little much.</p>

<p>Score:</p>

<ul>
<li>Accurate: yes</li>
<li>Idiomatic: arguably not</li>
</ul>


<h3>Concatenate items</h3>

<p>What if we get a <code>list</code> of items from each dictionary, concatenate them, and then create a new dictionary from that?</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This actually works.  We know that the <code>user</code> keys will win out over <code>defaults</code> because those keys come at the end of our concatenated list.</p>

<p>In Python 2 we actually don’t need the <code>list</code> conversions, but we’re working in Python 3 here (you are on Python 3, right?).</p>

<p>Score:</p>

<ul>
<li>Accurate: yes</li>
<li>Idiomatic: not particularly, there’s a bit of repetition</li>
</ul>


<h3>Union items</h3>

<p>In Python 3, <code>items</code> is a <code>dict_items</code> object, which is a quirky object that supports union operations.</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="o">|</span> <span class="n">user</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
</span></code></pre></td></tr></table></div></figure>


<p>That’s kind of interesting.  But <strong>this is not accurate</strong>.</p>

<p>Requirement 1 (<code>user</code> should “win” over <code>defaults</code>) fails because the union of two <code>dict_items</code> objects is a <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset">set</a> of key-value pairs and sets are unordered so duplicate keys may resolve in an <em>unpredictable</em> way.</p>

<p>Requirement 3 (the values can be anything) fails because sets require their items to be <a href="https://docs.python.org/3/glossary.html#term-hashable">hashable</a> so both the keys <em>and values</em> in our key-value tuples must be hashable.</p>

<p>Side note: I’m not sure why the union operation is even allowed on <code>dict_items</code> objects.  What is this good for?</p>

<p>Score:</p>

<ul>
<li>Accurate: no, requirements 1 and 3 fail</li>
<li>Idiomatic: no</li>
</ul>


<h3>Chain items</h3>

<p>So far the most idiomatic way we’ve seen to perform this merge in a single line of code involves creating two lists of items, concatenating them, and forming a dictionary.</p>

<p>We can join our items together more succinctly with <a href="https://docs.python.org/3/library/itertools.html#itertools.chain">itertools.chain</a>:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
</span><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">user</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This works well and may be more efficient than creating two unnecessary lists.</p>

<p>Score:</p>

<ul>
<li>Accurate: yes</li>
<li>Idiomatic: fairly, but those <code>items</code> calls seem slightly redundant</li>
</ul>


<h3>ChainMap</h3>

<p>A <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap">ChainMap</a> allows us to create a new dictionary without even looping over our initial dictionaries (well <em>sort of</em>, we’ll discuss this):</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">ChainMap</span>
</span><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="n">ChainMap</span><span class="p">({},</span> <span class="n">user</span><span class="p">,</span> <span class="n">defaults</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>A <code>ChainMap</code> groups dictionaries together into a proxy object (a “view”); lookups query each provided dictionary until a match is found.</p>

<p>This code raises a few questions.</p>

<h4>Why did we put <code>user</code> before <code>defaults</code>?</h4>

<p>We ordered our arguments this way to ensure requirement 1 was met.  The dictionaries are searched in order, so <code>user</code> returns matches before <code>defaults</code>.</p>

<h4>Why is there an empty dictionary before <code>user</code>?</h4>

<p>This is for requirement 5.  Changes to <code>ChainMap</code> objects affect the first dictionary provided and we don’t want <code>user</code> to change so we provided an empty dictionary first.</p>

<h4>Does this actually give us a dictionary?</h4>

<p>A <code>ChainMap</code> object is <strong>not a dictionary</strong> but it is a <strong>dictionary-like</strong> mapping.  We may be okay with this if our code practices <a href="https://docs.python.org/3/glossary.html#term-duck-typing">duck typing</a>, but we’ll need to inspect the features of <code>ChainMap</code> to be sure.  Among other features, <code>ChainMap</code> objects are coupled to their <a href="https://gist.github.com/treyhunner/2abe2617ea029504ef8e">underlying dictionaries</a> and they handle <a href="https://gist.github.com/treyhunner/5260810b4cced03359d9">removing items</a> in an interesting way.</p>

<p>Score:</p>

<ul>
<li>Accurate: possibly, we’ll need to consider our use cases</li>
<li>Idiomatic: yes if we decide this suits our use case</li>
</ul>


<h3>Dictionary from ChainMap</h3>

<p>If we really want a dictionary, we could convert our <code>ChainMap</code> to a dictionary:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ChainMap</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">defaults</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>It’s a little odd that <code>user</code> must come before <code>defaults</code> in this code whereas this order was flipped in most of our other solutions.  Outside of that oddity, this code is fairly simple and should be clear enough for our purposes.</p>

<p>Score:</p>

<ul>
<li>Accurate: yes</li>
<li>Idiomatic: yes</li>
</ul>


<h3>Dictionary concatenation</h3>

<p>What if we simply concatenate our dictionaries?</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="n">defaults</span> <span class="o">+</span> <span class="n">user</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is cool, but it <strong>isn’t valid</strong>.  This was discussed in a <a href="https://mail.python.org/pipermail/python-ideas/2015-February/031748.html">python-ideas thread</a> last year.</p>

<p>Some of the concerns brought up in this thread include:</p>

<ul>
<li>Maybe <code>|</code> makes more sense than <code>+</code> because dictionaries are like sets</li>
<li>For duplicate keys, should the left-hand side or right-hand side win?</li>
<li>Should there be an <code>updated</code> built-in instead (kind of like <a href="https://docs.python.org/3/library/functions.html#sorted">sorted</a>)?</li>
</ul>


<p>Score:</p>

<ul>
<li>Accurate: no. This doesn’t work.</li>
<li>Idiomatic: no. This doesn’t work.</li>
</ul>


<h3>Dictionary unpacking</h3>

<p>If you’re using Python 3.5, thanks to <a href="https://www.python.org/dev/peps/pep-0448/">PEP 448</a>, there’s a new way to merge dictionaries:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">defaults</span><span class="p">,</span> <span class="o">**</span><span class="n">user</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is simple and Pythonic.  There are quite a few symbols, but it’s fairly clear that the output is a dictionary at least.</p>

<p>This is functionally equivalent to our very first solution where we made an empty dictionary and populated it with all items from <code>defaults</code> and <code>user</code> in turn.  All of our requirements are met and this is likely the simplest solution we’ll ever get.</p>

<p>Score:</p>

<ul>
<li>Accurate: yes</li>
<li>Idiomatic: yes</li>
</ul>


<h2>Summary</h2>

<p>There are a number of ways to combine multiple dictionaries, but there are few elegant ways to do this with just one line of code.</p>

<p>If you’re using Python 3.5, this is the one obvious way to solve this problem:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">defaults</span><span class="p">,</span> <span class="o">**</span><span class="n">user</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you are not yet using Python 3.5, you’ll need to review the solutions above to determine which is the most appropriate for your needs.</p>

<p><strong>Note</strong>: For those of you particularly concerned with performance, I also measured the <a href="https://gist.github.com/treyhunner/f35292e676efa0be1728">performance of these different dictionary merging methods</a>.</p>

<p><br/>I teach Python for a living.  If you like my teaching style and your team is interested in <strong><a href="http://truthful.technology/">Python training</a></strong>, please <a href="/cdn-cgi/l/email-protection#9ef6fbf2f2f1deeaecebeaf6f8ebf2b0eafbfdf6f0f1f2f1f9e7">contact me</a>!</p>
</div>




</div></body></html>