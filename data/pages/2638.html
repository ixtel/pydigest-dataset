<html><body><div><div class="post-text" itemprop="text">
<p>Integrity error is raised from database but from django:</p>

<pre><code>create table t ( a int, b int , c int);
alter table t add constraint u unique ( a,b,c);   &lt;-- 'u'    
insert into t values ( 1,2,3);
insert into t values ( 1,2,3);

Duplicate entry '1-2-3' for key 'u'   &lt;---- 'u'
</code></pre>

<p>That means that you need to create constraint with desired name in database. But is django in migrations who names constraint. Look into _create_unique_sql :</p>

<pre><code>def _create_unique_sql(self, model, columns):
    return self.sql_create_unique % {
        "table": self.quote_name(model._meta.db_table),
        "name": self.quote_name(self._create_index_name(model, columns, suffix="_uniq")),
        "columns": ", ".join(self.quote_name(column) for column in columns),
    }
</code></pre>

<p>Is _create_index_name who has the algorithm to names constraints:</p>

<pre><code>def _create_index_name(self, model, column_names, suffix=""):
    """
    Generates a unique name for an index/unique constraint.
    """
    # If there is just one column in the index, use a default algorithm from Django
    if len(column_names) == 1 and not suffix:
        return truncate_name(
            '%s_%s' % (model._meta.db_table, self._digest(column_names[0])),
            self.connection.ops.max_name_length()
        )
    # Else generate the name for the index using a different algorithm
    table_name = model._meta.db_table.replace('"', '').replace('.', '_')
    index_unique_name = '_%x' % abs(hash((table_name, ','.join(column_names))))
    max_length = self.connection.ops.max_name_length() or 200
    # If the index name is too long, truncate it
    index_name = ('%s_%s%s%s' % (
        table_name, column_names[0], index_unique_name, suffix,
    )).replace('"', '').replace('.', '_')
    if len(index_name) &gt; max_length:
        part = ('_%s%s%s' % (column_names[0], index_unique_name, suffix))
        index_name = '%s%s' % (table_name[:(max_length - len(part))], part)
    # It shouldn't start with an underscore (Oracle hates this)
    if index_name[0] == "_":
        index_name = index_name[1:]
    # If it's STILL too long, just hash it down
    if len(index_name) &gt; max_length:
        index_name = hashlib.md5(force_bytes(index_name)).hexdigest()[:max_length]
    # It can't start with a number on Oracle, so prepend D if we need to
    if index_name[0].isdigit():
        index_name = "D%s" % index_name[:-1]
    return index_name
</code></pre>

<p>For the current django version (1.7) the constraint name for a composite unique constraint looks like:</p>

<pre><code>&gt;&gt;&gt; _create_index_name( 'people', [ 'c1', 'c2', 'c3'], '_uniq' )
'myapp_people_c1_d22a1efbe4793fd_uniq'
</code></pre>

<p>You should overwrite <a href="https://github.com/django/django/blob/master/django/db/backends/schema.py#L778"><code>_create_index_name</code></a> in some way to change algorithm. A way, maybe, writing your own db backend inhering from <a href="https://github.com/django/django/tree/master/django/db/backends/mysql">mysql</a> and overwriting <code>_create_index_name</code> in your <code>DatabaseSchemaEditor</code> on your <a href="https://github.com/django/django/blob/master/django/db/backends/mysql/schema.py">schema.py</a> (not tested)</p>
    </div>
    </div></body></html>