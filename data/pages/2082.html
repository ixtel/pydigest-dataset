<html><body><div><div class="content html_format"><p>
      Наиболее распространенным методом аутентификации является аутентификация с использованием cookie файлов. Более современный метод аутентификации основан на использовании JSON Web Token (дословно: вэб маркер в формате JSON) и он быстро набирает популярность. В этой статье мы сосредоточимся на нем.</p>

<h4><b>Что такое JSON Web Token?</b></h4><p>
На самом деле маркеры довольно просты. Представьте себе маркер как ключ в виде карточки, с помощью которого вы каждый день заходите в офис. Когда вас взяли на работу в компанию, вы подтвердили свою личность (логин), предоставив набор учетных данных, таких как водительские права или номер социального страхования. В обмен на эти данных вам выдали ключ (маркер), который разрешает вам находиться в здании. Если бы вы решили уйти с работы или вас уволили (вышли из системы), компания может просто отключить ключ. Конечно, этот ключ может остаться у вас в кармане, но он не даст вам ничего хорошего.
</p><p>
JSON Web Token – это простой маркер в специальном формате. Пока формат не стандартизован, но многие уже используют одну из его реализаций (</p><a href="http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html">JWT</a><p>).

</p><a href="http://jwt.io/">JWT</a><p> (произносится как jot) состоит из трех частей:
</p><ul>
<li> Заголовок</li>
<li> Полезная нагрузка</li>
<li> Подпись</li>
</ul><p>
Давайте рассмотрим каждую из них, прежде чем углубимся в реализацию.
</p><a name="habracut"/>
<h4><b>Заголовок</b></h4><p>
По умолчанию, заголовок содержит только тип маркера и алгоритм, используемый для шифрования.</p><p>
Тип маркера хранится в ключе «typ». Ключ «typ» игнорируется в JWT (для этой статьи это не важно, но вы можете </p><a href="http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#typHdrDef">прочитать</a><p>, чтобы узнать почему). Если ключ «typ» присутствует, его значение должно быть JWT, чтобы указать, что этот объект является JSON Web Token.</p><p>
Второй ключ «alg» определяет алгоритм, используемый для шифрования маркера. По умолчанию он должен быть установлен в HS256. Есть целый ряд альтернативных алгоритмов, которые используются в различных реализациях. Полный список с разбивкой по библиотекам можно посмотреть на JWT.io.</p><p>
Заголовок кодируется в base64.

</p><h4><b>Полезная нагрузка</b></h4><p>
В полезной нагрузке хранится любая информация, которую нужно проверить. Каждый ключ в полезной нагрузке известен как «заявление». К примеру, рассмотрим социальную сеть, в которой присоединиться к сообществу можно только по приглашению. Когда мы хотим пригласить кого-то в сообщество, мы отправляем ему письмо с приглашением. Здесь важно проверить, что адрес электронной почты принадлежит человеку, который принимает приглашение, поэтому мы включим этот адрес в полезную нагрузку, для этого сохраним его в ключе «email».

</p><pre><code class="javascript">{
    "email": "example@jamesbrewer.io"
}
 </code></pre><p>
Ключи в полезной нагрузке могут быть произвольными. Тем не менее, есть несколько зарезервированных, которые нужно знать:
</p><ul>
<li> iat (Issued At). Этот ключ представляет собой время, когда маркер был выдан и может быть использован для определения возраста JWT. iat ключ должен быть отметкой времени в unix формате.</li>
<li> exp (Expiration Time). Этот ключ указывает, когда истекает срок действия маркера. Стандарт </li>
</ul><p>JWT требует, чтобы во всех его реализациях маркеры с истекшим сроком действия отклонялись. В </p><a href="http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#expDef">некоторых реализациях</a><p> могут быть добавлены дополнительные ключи, для учета рассинхронизации времени. exp ключ должен быть отметкой времени в unix формате.</p><p>
Важно понимать, что полезная нагрузка не передается в зашифрованном виде (хотя, маркеры могут быть вложенными и тогда возможно передавать зашифрованные данные). Поэтому в ней нельзя хранить любую секретную информацию. Например, пароли, номера социального страхования и т.д.</p><p>
Как и заголовок, полезная нагрузка кодируется в base64.

</p><h4><b>Подпись</b></h4><p>
Когда у нас есть заголовок и полезная нагрузка, можно вычислить подпись.</p><p>
Берутся закодированные в base64: заголовок и полезная нагрузка, они объединяются в строку через точку. Затем эта строка и секретный ключ поступает на вход алгоритма шифрования, указанного в заголовке (ключ «alg»). Ключом может быть любая строка. Более длинные строки будут наиболее предпочтительнее, поскольку потребуется больше времени на подбор.

</p><h4><b>JWT</b></h4><p>
Теперь, когда у нас есть заголовок, полезная нагрузка и подпись, мы можем построить JWT. Окончательный JWT выглядит следующим образом:

</p><pre><code class="javascript">&lt;encoded header&gt;.&lt;encoded payload&gt;.&lt;signature&gt;
</code></pre><p>
Примечание: никогда не сохраняйте маркер в вашей БД. Потому что действительный маркер, эквивалентен паролю, хранить маркер – это все равно, что хранить пароль в открытом виде. Поэтому всегда используйте хеширование перед сохранением.

</p><h4><b>Реализация проверки подлинности с помощью JSON Web Token</b></h4><p>
Давайте пойдем дальше и создадим наш проект.</p><p>
Перейдите в каталог проекта и выполните команды:

</p><pre><code class="bash">$ django-admin.py startproject django_angular_token_auth
$ cd django_angular_token_auth/
$ mkdir static templates
</code></pre><p>
Вам нужно убедиться, что настройки STATICFILES_DIRS и TEMPLATE_DIRS присутствуют в django_angular_token_auth/settings.py и они должны выглядеть следующим образом:
</p><pre><code class="python">STATICFILES_DIRS = (
    os.path.join(BASE_DIR, 'static'),
)
TEMPLATE_DIRS = (
    os.path.join(BASE_DIR, 'templates'),
)
</code></pre>

<h4><b>Django REST Framework</b></h4><p>
Теперь нужно установить Django REST Framework. Django REST Framework большой проект с открытым исходным кодом, для тех, кто хочет создавать одностраничные приложения и API для них.
</p><p>
Мы не будем детально рассматривать, как работает Django REST Framework, поэтому если вы не знакомы с ним, посмотрите документацию.
</p><p>
Для установки Django REST Framework, выполните следующую команду:

</p><pre><code class="bash">$ pip install djangorestframework
</code></pre><p>
Django REST Framework должен быть добавлен к вашим установленным приложениям (INSTALLED_APPS в django_angular_token_auth/settings.py:)

</p><pre><code class="python">INSTALLED_APPS = (
    ...,
    'rest_framework',
)
</code></pre><p>
Так же необходимо добавить следующие параметры в django_angular_token_auth/settings.py:

</p><pre><code class="python">REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ), 
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ),
}
</code></pre><p>
Мы не будем использовать SessionAuthentication или BasicAuthentication, но они имеются в Django REST Framework и предлагают работоспособный API из коробки.

</p><h4><b>django-rest-framework-jwt</b></h4><p>
Последнее, что нужно сделать, это установить django-rest-framework-jwt. Этот пакет обеспечивает поддержку JWT для Django REST Framework и в качестве JSON Web Token использует реализацию PyJWT. Что бы установить django-rest-framework-jwt выполните следующую команду:

</p><pre><code class="bash">$ pip install djangorestframework-jwt
</code></pre><p>
Нужно будет добавить следующие параметры в django_angular_token_auth/settings.py:

</p><pre><code class="python">import datetime
JWT_AUTH = {
    'JWT_EXPIRATION_DELTA': datetime.timedelta(days=14)
}
</code></pre>
<p>
Этот параметр указывает срок жизни для наших маркеров и в нашем случае это будет 14 дней. Вы можете изменить его, исходя из собственных предпочтений.
</p><p>
Вы так же должны добавить обновленные настройки REST_FRAMEWORK:

</p><pre><code class="python">REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',
   )
}
</code></pre>
<p>
Обратите внимание, что мы добавили:</p><p>
'rest_framework_jwt.authentication.JSONWebTokenAuthentication', в 'DEFAULT_AUTHENTICATION_CLASSES'.

</p><h4>Создание Django приложения</h4><p>
Теперь давайте создадим приложение Django для хранения в нем представлений и сериализаторов:

</p><pre><code class="bash">$ python manage.py startapp authentication
</code></pre>
<p>
Добавим 'authentication' в наш INSTALLED_APPS (в django_angular_token_auth/settings.py like so):

</p><pre><code class="python">INSTALLED_APPS = (
	...,
	'rest_framework',
	'authentication',
)
</code></pre><p>
Как привило после создания приложения нужно выполнить миграции, для создания моделей в БД. Но мы не будем создавать собственные модели, поэтому об этом не нужно беспокоиться.

</p><h4><b>Сериализаторы</b></h4><p>
Для проверки работоспособности API нужно отправлять какие-нибудь данные на AJAX запросы. Самый простой способ это сделать — отправить обратно данные пользователя в нашей системе.
</p><p>
Первое, что нужно сделать, это создать пользователя. Выполните следующую команду и следуйте инструкциям на экране:

</p><pre><code class="bash">$ python manage.py createsuperuser
</code></pre><p>
После создания пользователя, нужно, чтобы Django отправлял его данные в Angular приложение. Очевидно, что мы не можем отправлять Django объекты нашему приложению на JavaScript, поэтому нужен сериализатор для преобразования объектов в JSON и обратно. Его легко можно создать средствами Django REST Framework.</p><p>
Создайте файл с именем serializers.py и добавьте в него следующий код:

</p><pre><code class="python">from django.contrib.auth.models import User
from rest_framework import serializers

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = (id, username, email)
</code></pre>
<p>
Этот код указывает Django REST Framework, что мы хотим сериализовать модель User и мы хотим включить только следующие поля: id, username и email. 

</p><h4><b>Представления</b></h4><p>
С сериализаторами разобрались, давайте теперь перейдем к представлениям.</p><p>
Для наших целей нужно только одно представление, которое будет возвращать список объектов пользователя.</p><p>
Django REST Framework предлагает целый ряд представлений, которые выполняют различные функции, например представление списка объектов одного типа. Такую функциональность предлагает класс ListAPIView.</p><p>
Добавьте следующее в authentication/views.py:

</p><pre><code class="python">from django.contrib.auth.models import User
from rest_framework import generics
from authentication.serializers import UserSerializer

class UserListAPIView(generics.ListAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer
</code></pre>

<h4>Шаблоны</h4><p>
Создадим простой шаблон, который будет представлять наше приложение.</p><p>
Создайте файл с именем templates/index.html и добавьте следующий код в него:

</p><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;django-angular-token-auth&lt;/title&gt;
    &lt;/head&gt;

    &lt;body&gt;
        Hello, World!
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>
В дальнейшем мы добавим некоторый angular код в данный файл.

</p><h4><b>URL-адреса</b></h4><p>
Теперь нужно настроить URL-адреса для нашего проекта.</p><p>
Откройте django_angular_token_auth/urls.py и приведите его к следующему виду:

</p><pre><code class="python">from django.conf.urls import include, patterns, url
from django.views.generic import TemplateView
from authentication.views import UserListAPIView

urlpatterns = patterns('',
    url(r'api/v1/auth/login/', 'rest_framework_jwt.views.obtain_jwt_token'),
    url(r'api/v1/users/', UserListAPIView.as_view()),
    url(r'^.*$', TemplateView.as_view(template_name='index.html')),
)
</code></pre><p>
Давайте рассмотрим, что здесь происходит.
</p><p>
Первое что можно заметить, во втором аргументе для первого URL-шаблона передается строка. Эта строка указывает на представление django-rest-framework-jwt, которое генерирует маркер. Мы не будем рассматривать, как оно работает, но вы можете посмотреть код django-rest-framework-jwt в Github репозитории: django-rest-framework-jwt/rest_framework_jwt/views.py.</p><p>
Так же мы раньше не использовали представление TemplateView. Оно подобно классу ListAPIView в Django REST Framework предлагает простой способ для обработки шаблонов.
</p><p>
Вы наверно заметили, что регулярное выражение, используемое в последнем URL-шаблоне, будет соответствовать любому URL-адресу. 
</p><p>
Для правильной обработки адресов важно, чтобы этот шаблон был последним. Потому что, Django сопоставляет адрес с шаблонами, в том порядке, в котором они определены и при первом же совпадении проверка прекращается. Так как используемое регулярное выражение совпадает с любым адресом, тем самым мы даем шанс всем остальным адресам быть обработанными. Все что не соответствует Django должно быть обработано Angular’ом. Так же пространство имен API /api/v1/, гарантирует, что шаблоны Django и Angular не будут конфликтовать.

</p><h4><b>Во второй части</b></h4><p>
На этом мы остановимся. Во второй части, построим клиентское приложение и в основном сосредоточимся на регистрации и сеансе входа в систему. Напишем сервис, для того что бы можно было правильно заходить и выходить из системы.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>