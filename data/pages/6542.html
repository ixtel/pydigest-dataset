<html><body><div><div class="textblock"><p>There's experimental support for reading FlatBuffers in Python. Generate code for Python with the <code>-p</code> option to <code>flatc</code>.</p>
<p>See <code>py_test.py</code> for an example. You import the generated code, read a FlatBuffer binary file into a <code>bytearray</code>, which you pass to the <code>GetRootAsMonster</code> function:</p>
<div class="fragment"><div class="line"><a name="l00001"/><span class="lineno">    1</span><p> import MyGame.Example </p><span class="keyword">as</span><p> example</p></div>


<div class="line"><a name="l00004"/><span class="lineno">    4</span><p> buf = open(</p><span class="stringliteral">'monster.dat'</span><p>, </p><span class="stringliteral">'rb'</span><p>).read()</p></div>

<div class="line"><a name="l00006"/><span class="lineno">    6</span><p> monster = example.GetRootAsMonster(buf, 0)</p></div>
</div><p>Now you can access values like this:</p>
<p>To access vectors you pass an extra index to the vector field accessor. Then a second method with the same name suffixed by <code>Length</code> let's you know the number of elements you can access:</p>
<div class="fragment"><div class="line"><a name="l00001"/><span class="lineno">    1</span> <span class="keywordflow">for</span><p> i </p><span class="keywordflow">in</span><p> xrange(monster.InventoryLength()):</p></div>
<div class="line"><a name="l00002"/><span class="lineno">    2</span><p>     monster.Inventory(i) </p><span class="comment"># do something here</span></div>
</div><p>You can also construct these buffers in Python using the functions found in the generated code, and the FlatBufferBuilder class:</p>
<div class="fragment"><div class="line"><a name="l00001"/><span class="lineno">    1</span><p> builder = flatbuffers.Builder(0)</p></div>
</div><p>Create strings:</p>
<div class="fragment"><div class="line"><a name="l00001"/><span class="lineno">    1</span><p> s = builder.CreateString(</p><span class="stringliteral">"MyMonster"</span><p>)</p></div>
</div><p>Create a table with a struct contained therein:</p>
<div class="fragment"><div class="line"><a name="l00001"/><span class="lineno">    1</span><p> example.MonsterStart(builder)</p></div>
<div class="line"><a name="l00002"/><span class="lineno">    2</span><p> example.MonsterAddPos(builder, example.CreateVec3(builder, 1.0, 2.0, 3.0, 3.0, 4, 5, 6))</p></div>
<div class="line"><a name="l00003"/><span class="lineno">    3</span><p> example.MonsterAddHp(builder, 80)</p></div>
<div class="line"><a name="l00004"/><span class="lineno">    4</span><p> example.MonsterAddName(builder, str)</p></div>
<div class="line"><a name="l00005"/><span class="lineno">    5</span><p> example.MonsterAddInventory(builder, inv)</p></div>
<div class="line"><a name="l00006"/><span class="lineno">    6</span><p> example.MonsterAddTest_Type(builder, 1)</p></div>
<div class="line"><a name="l00007"/><span class="lineno">    7</span><p> example.MonsterAddTest(builder, mon2)</p></div>
<div class="line"><a name="l00008"/><span class="lineno">    8</span><p> example.MonsterAddTest4(builder, test4s)</p></div>
<div class="line"><a name="l00009"/><span class="lineno">    9</span><p> mon = example.MonsterEnd(builder)</p></div>

<div class="line"><a name="l00011"/><span class="lineno">   11</span><p> final_flatbuffer = builder.Output()</p></div>
</div><p>Unlike C++, Python does not support table creation functions like 'createMonster()'. This is to create the buffer without using temporary object allocation (since the <code>Vec3</code> is an inline component of <code>Monster</code>, it has to be created right where it is added, whereas the name and the inventory are not inline, and <b>must</b> be created outside of the table creation sequence). Structs do have convenient methods that allow you to construct them in one call. These also have arguments for nested structs, e.g. if a struct has a field <code>a</code> and a nested struct field <code>b</code> (which has fields <code>c</code> and <code>d</code>), then the arguments will be <code>a</code>, <code>c</code> and <code>d</code>.</p>
<p>Vectors also use this start/end pattern to allow vectors of both scalar types and structs:</p>
<div class="fragment"><div class="line"><a name="l00001"/><span class="lineno">    1</span><p> example.MonsterStartInventoryVector(builder, 5)</p></div>


<div class="line"><a name="l00004"/><span class="lineno">    4</span><p>     builder.PrependByte(byte(i))</p></div>


<div class="line"><a name="l00007"/><span class="lineno">    7</span><p> inv = builder.EndVector(5)</p></div>
</div><p>The generated method 'StartInventoryVector' is provided as a convenience function which calls 'StartVector' with the correct element size of the vector type which in this case is 'ubyte' or 1 byte per vector element. You pass the number of elements you want to write. You write the elements backwards since the buffer is being constructed back to front. Use the correct <code>Prepend</code> call for the type, or <code>PrependUOffsetT</code> for offsets. You then pass <code>inv</code> to the corresponding <code>Add</code> call when you construct the table containing it afterwards.</p>
<p>There are <code>Prepend</code> functions for all the scalar types. You use <code>PrependUOffset</code> for any previously constructed objects (such as other tables, strings, vectors). For structs, you use the appropriate <code>create</code> function in-line, as shown above in the <code>Monster</code> example.</p>
<p>Once you're done constructing a buffer, you call <code>Finish</code> with the root object offset (<code>mon</code> in the example above). Your data now resides in Builder.Bytes. Important to note is that the real data starts at the index indicated by Head(), for Offset() bytes (this is because the buffer is constructed backwards). If you wanted to read the buffer right after creating it (using <code>GetRootAsMonster</code> above), the second argument, instead of <code>0</code> would thus also be <code>Head()</code>.</p>
<h2>Text Parsing</h2>
<p>There currently is no support for parsing text (Schema's and JSON) directly from Python, though you could use the C++ parser through SWIG or ctypes. Please see the C++ documentation for more on text parsing. </p>
</div></div></body></html>