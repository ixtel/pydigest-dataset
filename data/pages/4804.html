<html><body><div><section class="entry-content">
<img src="http://galvanize-wp.s3.amazonaws.com/wp-content/uploads/2015/05/28075820/164.png" class="attachment-post-thumbnail size-post-thumbnail wp-post-image" alt="164" srcset="http://galvanize-wp.s3.amazonaws.com/wp-content/uploads/2015/05/28075820/164-420x300.png 420w, http://galvanize-wp.s3.amazonaws.com/wp-content/uploads/2015/05/28075820/164.png 700w" sizes="(max-width: 700px) 100vw, 700px"/><p class="at-above-post addthis_default_style addthis_toolbox at-wordpress-hide" data-title="Data Science Projects: Musical Pitch Classification and Visualization" data-url="http://www.galvanize.com/blog/data-science-projects-classifying-and-visualizing-musical-pitch/"/><h2>Classifying and Visualizing Musical Pitch with K-means Clustering</h2>
<p>The Galvanize data science curriculum includes a collection of machine learning topics popular among data scientists in the tech industry, but the skills students learn at Galvanize are not limited to only the most popular tech industry applications. For example, audio signal and musical analysis is a less frequently discussed but interesting application of the machine learning concepts taught in <a href="http://www.galvanize.com/courses/data-science/" target="_blank">Galvanize’s Data Science Intensive</a>. Using topics from Galvanize’s curriculum, this tutorial will demonstrate how to classify and visualize musical pitches from recordings using <a href="http://en.wikipedia.org/wiki/K-means_clustering" target="_blank">k-means clustering</a>, implemented with <a href="http://www.scipy.org/" target="_blank">NumPy/SciPy</a>, <a href="http://scikit-learn.org/stable/" target="_blank">Scikit-learn</a>, and <a href="https://plot.ly/" target="_blank">Plotly</a>.</p>
<h2>What is <i>k</i>-means Clustering?</h2>
<p><i>k</i>-means clustering is a popular technique for identifying groups of related items in an unlabeled data set. Given any number <i>k</i>, the algorithm will divide a dataset into <i>k</i> groups such that each item’s distance from the center of its group is minimized. <i>k</i>-means can be used for a wide rage of applications, such as identifying the efficient placement of cell phone towers or selecting the sizes of clothing a manufacturer should produce. As this tutorial will show, <i>k</i>-means can be used to group audio segments by pitch.</p>
<h2>A Brief Primer on Musical Pitch</h2>
<p>A musical note is a collection of superimposed sine waves with different frequencies, and identifying the pitch of a note requires identifying the frequencies of the most aurally salient of those sine waves.</p>
<p>The simplest musical note contains only one sine wave:</p>
<p data-plotly="michaeljancsy/183"/>
<p/>
<p>Plotting the “power spectrum,” the magnitude of each component frequency, reveals a single frequency from the above waveform:</p>
<p data-plotly="michaeljancsy/202"/>
<p>Sounds produced by typical musical instruments comprise many component sine waves, and as a result they sound more complex than the pure sine wave shown above. The waveform of the same note (E3) played by a guitar looks and sounds like this:</p>
<p data-plotly="michaeljancsy/205"/>
<p/>
<p>Plotting its power spectrum reveals a much larger collection of component frequencies:</p>
<p data-plotly="michaeljancsy/201"/>
<p><i>k</i>-means can use the power spectra of sample audio segments to group the segments by pitch. Given a collection of power spectra with <i>n</i> different frequencies, <i>k</i>-means will group the sample spectra so that the sum of Euclidean distances between each spectrum and the center of its group is minimized in <i>n</i>-dimensional space.</p>
<h2>Creating a Dataset from a Recording Using NumPy/SciPy</h2>
<p>This tutorial will use a sample recording of 3 distinct pitches, each played for exactly 2 seconds on a guitar.</p>
<p/>
<p>Converting a .wav file into a NumPy array is easy using SciPy’s wavfile module.</p>
<div>
<pre>import scipy.io.wavfile as wav
filename = 'Guitar - Major Chord - E Gsharp B.wav'
# wav.read returns the sample_rate and a numpy array containing each audio sample from the .wav file
sample_rate, recording = wav.read(filename)
</pre>
</div>
<p>The recording should be split into short segments, so that each segment’s pitch can be classified independently.</p>
<div>
<pre>def split_recording(recording, segment_length, sample_rate):
    segments = []
    index = 0
    while index &lt; len(recording):
        segment = recording[index:index + segment_length*sample_rate]
        segments.append(segment)
        index += segment_length*sample_rate
    return segments

segment_length = .5 # length in seconds
segments = split_recording(recording, segment_length, sample_rate)
</pre>
</div>
<p>The power spectrum of each segment can be obtained by applying the <a href="http://en.wikipedia.org/wiki/Fast_Fourier_transform" target="_blank">Fourier transform</a>, which converts the waveform data from the time domain to the frequency domain. The code below demonstrates how to use NumPy’s Fourier transform module.</p>
<div>
<pre>def calculate_normalized_power_spectrum(recording, sample_rate):
    # np.fft.fft returns the discrete fourier transform of the recording
    fft = np.fft.fft(recording) 
    number_of_samples = len(recording)        
    # sample_length is the length of each sample in seconds
    sample_length = 1./sample_rate 
    # fftfreq is a convenience function which returns the list of frequencies measured by the fft
    frequencies = np.fft.fftfreq(number_of_samples, sample_length)  
    positive_frequency_indices = np.where(frequencies&gt;0) 
    # positive frequences returned by the fft
    frequencies = frequencies[positive_frequency_indices]
    # magnitudes of each positive frequency in the recording
    magnitudes = abs(fft[positive_frequency_indices]) 
    # some segments are louder than others, so normalize each segment
    magnitudes = magnitudes / np.linalg.norm(magnitudes)
    return frequencies, magnitudes
</pre>
</div>
<p>Some helper functions will create an empty NumPy array and fill it with with our sample power spectra.</p>
<div>
<pre>def create_power_spectra_array(segment_length, sample_rate):
    number_of_samples_per_segment = int(segment_length * sample_rate)
    time_per_sample = 1./sample_rate
    frequencies = np.fft.fftfreq(number_of_samples_per_segment, time_per_sample)
    positive_frequencies = frequencies[frequencies&gt;0]
    power_spectra_array = np.empty((0, len(positive_frequencies)))
    return power_spectra_array

def fill_power_spectra_array(splits, power_spectra_array, fs):
    filled_array = power_spectra_array
    for segment in splits:
        freqs, mags = calculate_normalized_power_spectrum(segment, fs)
        filled_array = np.vstack((filled_array, mags))
    return filled_array

power_spectra_array = create_power_spectra_array(segment_length,sample_rate)
power_spectra_array = fill_power_spectra_array(segments, power_spectra_array, sample_rate)
</pre>
</div>
<p>“power_spectra_array” is our training dataset, containing a power spectrum for each 1/2 second segment of the recording.</p>
<h2>Performing <i>k</i>-means with Scikit-learn</h2>
<p>Scikit-learn has an easy-to-use implementation of <i>k</i>-means. Our audio sample contains 3 distinct pitches, so set <i>k</i> equal to 3.</p>
<div>
<pre>from sklearn.cluster import KMeans
kmeans = KMeans(3, max_iter = 1000, n_init = 100)
kmeans.fit_transform(power_spectra_array)
predictions = kmeans.predict(power_spectra_array)
</pre>
</div>
<p>“predictions” is a Python array containing the group label (an arbitrary integer) for each of the 12 audio segments.</p>
<div>
<pre>print predictions
=&gt; [2 2 2 2 0 0 0 0 1 1 1 1]
</pre>
</div>
<p>This array shows that consecutive audio segments are being correctly grouped together as one would expect from listening to the recording.</p>
<h2>Visualizing the Results with Plotly</h2>
<p>To better understand<i> </i>the predictions, plot the power spectrum of each sample, color-coded by the<i>k</i>-means classification.</p>
<div>
<pre># find x-values for plot (frequencies)
number_of_samples = int(segment_length*sample_rate)
sample_length = 1./sample_rate 
frequencies = np.fft.fftfreq(number_of_samples, sample_length)

# create plot
traces = []
for pitch_id, color in enumerate(['red','blue','green']):
    for power_spectrum in power_spectra_array[predictions == pitch_id]:
        trace = Scatter(x=frequencies[0:500],
                        y=power_spectrum[0:500],
                        mode='lines',
                        showlegend=False,
                        line=Line(shape='linear',
                                  color=color,
                                  opacity = .01,
                                  width = 1))
        traces.append(trace)
layout = Layout(xaxis=XAxis(title='Frequency (Hz)'),
                yaxis=YAxis(title = 'Amplitude (normalized)'),
                title = 'Power Spectra of Sample Audio Segments')
data_to_plot = Data(traces)
fig = Figure(data=data_to_plot, layout=layout)
# py.iplot plots inline using IPython Notebook
py.iplot(fig, filename = 'K-Means Classification of Power Spectrum')   
</pre>
</div>
<p>Each thin colored line in the plot below represents the power spectrum of the 12 audio segments produced from the sample .wav file. The lines are color-coded based on the <i>k</i>-means prediction of the segment’s pitch. The blue, green, and red spectra have peaks at 82.41 Hz (E), 103.83 Hz (G#), and 123.47 Hz (B), respectively, which are the notes in the sample recording.  The strongest frequencies in the sample recording are the low frequencies, so only the lowest 500 frequencies measured by the FFT are included in the plot below.</p>
<p><a title="Power Spectra of Sample Audio Segments" href="https://plot.ly/~michaeljancsy/164/" target="_blank"><img src="https://plot.ly/~michaeljancsy/164.png" alt="Power Spectra of Sample Audio Segments"/></a></p>
<p>The natural clustering is evident from plotting the amplitudes of 2 of the strongest overtones shared between the 3 sample pitches.</p>

<h2>Learn More at Galvanize!</h2>
<p><i>k</i>-means is one of many machine learning topics taught in Galvanize’s Data Science Intensive program. If you found this interesting, you can learn more <a href="http://www.galvanize.com/courses/data-science/" target="_blank">here</a>.</p>
<p class="at-below-post addthis_default_style addthis_toolbox at-wordpress-hide" data-title="Data Science Projects: Musical Pitch Classification and Visualization" data-url="http://www.galvanize.com/blog/data-science-projects-classifying-and-visualizing-musical-pitch/"/> <p class="at-below-post-recommended addthis_default_style addthis_toolbox at-wordpress-hide"/><p class="entry-links"/>
</section>		</div></body></html>