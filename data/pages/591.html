<html><body><div><div class="outline-text-2" id="text-orgheadline3">
<p>
The limiter defined above could be rewritten in C like this:
</p>

<div class="org-src-container">

<pre class="src src-c"><span>// </span><span>this corresponds to the Python Limiter class.</span>
<span>typedef</span> <span>struct</span> <span>limiter_state_t</span> {
    <span>int</span> <span>delay_index</span>;
    <span>int</span> <span>delay_length</span>;
    <span>float</span> <span>envelope</span>;
    <span>float</span> <span>current_gain</span>;
    <span>float</span> <span>attack_coeff</span>;
    <span>float</span> <span>release_coeff</span>;
} <span>limiter_state</span>;

<span>#define</span> <span>MAX</span>(<span>x</span>,<span>y</span>) ((x)&gt;(y)?(x):(y))

<span>// </span><span>this corresponds to the Python __init__ function.</span>
<span>limiter_state</span> <span>init_limiter</span>(<span>float</span> <span>attack_coeff</span>, <span>float</span> <span>release_coeff</span>, <span>int</span> <span>delay_len</span>) {
    <span>limiter_state</span> <span>state</span>;
    state.attack_coeff = attack_coeff;
    state.release_coeff = release_coeff;
    state.delay_index = 0;
    state.envelope = 0;
    state.current_gain = 1;
    state.delay_length = delay_len;
    <span>return</span> state;
}

<span>void</span> <span>limit</span>(<span>float</span> *<span>signal</span>, <span>int</span> <span>block_length</span>, <span>float</span> <span>threshold</span>,
           <span>float</span> *<span>delay_line</span>, <span>limiter_state</span> *<span>state</span>) {
    <span>for</span>(<span>int</span> <span>i</span>=0; i&lt;block_length; i++) {
        delay_line[state-&gt;delay_index] = signal[i];
        state-&gt;delay_index = (state-&gt;delay_index + 1) % state-&gt;delay_length;

        <span>// </span><span>calculate an envelope of the signal</span>
        state-&gt;envelope *= state-&gt;release_coeff;
        state-&gt;envelope = MAX(fabs(signal[i]), state-&gt;envelope);

        <span>// </span><span>have current_gain go towards a desired limiter target_gain</span>
        <span>float</span> <span>target_gain</span>;
        <span>if</span> (state-&gt;envelope &gt; threshold)
            target_gain = (1+threshold-state-&gt;envelope);
        <span>else</span>
            target_gain = 1.0;
        state-&gt;current_gain = state-&gt;current_gain*state-&gt;attack_coeff +
            target_gain*(1-state-&gt;attack_coeff);

        <span>// </span><span>limit the delayed signal</span>
        signal[i] = delay_line[state-&gt;delay_index] * state-&gt;current_gain;
    }
}
</pre>
</div>

<p>
In contrast to the Python version, the delay line will be passed to the <code>limit</code> function. This is advantageous because now all audio buffers can be managed by Python instead of manually allocating and deallocating them in C.
</p>

<p>
Now in order to plug this code into Python I will use Cython. First of all, a "Cython header" file has to be created that declares all exported types and functions to Cython:
</p>

<div class="org-src-container">

<pre class="src src-python">cdef extern <span>from</span> <span>"limiter.h"</span>:
    ctypedef struct limiter_state:
        <span>int</span> delay_index
        <span>int</span> delay_length
        <span>float</span> envelope
        <span>float</span> current_gain
        <span>float</span> attack_coeff
        <span>float</span> release_coeff

    limiter_state init_limiter(<span>float</span> attack_factor, <span>float</span> release_factor, <span>int</span> delay_len)
    void limit(<span>float</span> *signal, <span>int</span> block_length, <span>float</span> threshold,
               <span>float</span> *delay_line, limiter_state *state)
</pre>
</div>

<p>
This is very similar to the C header file of the limiter:
</p>

<div class="org-src-container">

<pre class="src src-c"><span>typedef</span> <span>struct</span> <span>limiter_state_t</span> {
    <span>int</span> <span>delay_index</span>;
    <span>int</span> <span>delay_length</span>;
    <span>float</span> <span>envelope</span>;
    <span>float</span> <span>current_gain</span>;
    <span>float</span> <span>attack_coeff</span>;
    <span>float</span> <span>release_coeff</span>;
} <span>limiter_state</span>;

<span>limiter_state</span> <span>init_limiter</span>(<span>float</span> <span>attack_factor</span>, <span>float</span> <span>release_factor</span>, <span>int</span> <span>delay_len</span>);
<span>void</span> <span>limit</span>(<span>float</span> *<span>signal</span>, <span>int</span> <span>block_length</span>, <span>float</span> <span>threshold</span>,
           <span>float</span> *<span>delay_line</span>, <span>limiter_state</span> *<span>state</span>);
</pre>
</div>

<p>
With that squared away, the C functions are accessible for Cython. Now, we only need a small Python wrapper around this code so it becomes usable from Python:
</p>

<div class="org-src-container">

<pre class="src src-python"><span>import</span> numpy <span>as</span> np
cimport numpy <span>as</span> np
cimport limiter

<span>DTYPE</span> = np.float32
ctypedef np.float32_t DTYPE_t

cdef <span>class</span> <span>Limiter</span>:
    cdef limiter.limiter_state state
    cdef np.ndarray delay_line
    <span>def</span> <span>__init__</span>(<span>self</span>, <span>float</span> attack_coeff, <span>float</span> release_coeff,
                 <span>int</span> delay_length):
        <span>self</span>.state = limiter.init_limiter(attack_coeff, release_coeff, delay_length)
        <span>self</span>.delay_line = np.zeros(delay_length, dtype=DTYPE)

    <span>def</span> <span>limit</span>(<span>self</span>, np.ndarray[DTYPE_t,ndim=1] signal, <span>float</span> threshold):
        limiter.limit(&lt;<span>float</span>*&gt;np.PyArray_DATA(signal),
                   &lt;<span>int</span>&gt;<span>len</span>(signal), threshold,
                   &lt;<span>float</span>*&gt;np.PyArray_DATA(<span>self</span>.delay_line),
                   &lt;limiter.limiter_state*&gt;&amp;<span>self</span>.state)
</pre>
</div>

<p>
The first two lines set this file up to access Numpy arrays both from the Python domain and the C domain, thus bridging the gap. The <code>cimport limiter</code> imports the C functions and types from above. The <code>DTYPE</code> stuff is advertising the Numpy <code>float32</code> type to C.
</p>

<p>
The class is defined using <code>cdef</code> as a C data structure for speed. Also, Cython would naturally translate every C struct into a Python dict and vice versa, but we need to pass the struct to <code>limit</code> <i>and</i> have <code>limit</code> modify it. Thus, <code>cdef limiter.limiter_state state</code> makes Cython treat it as a C struct only. Finally, the <code>np.PyArray_DATA()</code> expressions expose the C arrays underlying the Numpy vectors. This is really handy since we don't have to copy any data around in order to modify the vectors from C.
</p>

<p>
As can be seen, the Cython implementation behaves nearly identically to the initial Python implementation (except for passing the <code>dtype</code> to the constructor) and can be used as a plug-in replacement (with the aforementioned caveat).
</p>

<p>
Finally, we need to build the whole contraption. The easiest way to do this is to use a setup file like this:
</p>

<div class="org-src-container">

<pre class="src src-python"><span>from</span> distutils.core <span>import</span> setup
<span>from</span> distutils.extension <span>import</span> Extension
<span>from</span> Cython.Distutils <span>import</span> build_ext
<span>from</span> numpy <span>import</span> get_include

<span>ext_modules</span> = [Extension(<span>"cython_limiter"</span>,
                         sources=[<span>"cython_limiter.pyx"</span>,
                                  <span>"limiter.c"</span>],
                         include_dirs=[<span>'.'</span>, get_include()])]

setup(
    name = <span>"cython_limiter"</span>,
    cmdclass = {<span>'build_ext'</span>: build_ext},
    ext_modules = ext_modules
    )
</pre>
</div>

<p>
With that saved as <i>setup.py</i>, <code>python setup.py build_ext --inplace</code> will convert the Cython code to C, and then compile both the converted Cython code and C code into a binary Python module.
</p>
</div>
</div></body></html>