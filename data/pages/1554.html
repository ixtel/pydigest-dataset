<html><body><div><div class="post-body entry-content" id="post-body-6283347022111964785" itemprop="description articleBody"><p>
When I was working on my research for my Masters degree I promised myself that I would publish my paper online under a free license, as soon as I had graduated. Unfortunately there seems to be an unwritten rule of Graduate School research. You spend so much time focusing on a single topic of study that by the time you graduate you are sick of it. So more than year later I'm finally putting my paper online. For those that don't want to read the full paper (it's not terribly long for a research paper at 60 pages, but it's no tweet either) I'll include a shorter summary below. The summary will omit some important information and so if you would like to provide constructive or destructive feedback I ask that the feedback be directed towards the full paper and not the quick summary.</p>
<p>
<br/></p>
<p>
For me research I wanted to test the frequently cited claim by proponents of dynamically typed programming languages that static typing was not needed for detecting bugs in programs. The core of this claim is as follows:</p>
<p>
  1. Static typing is insufficient for detecting bugs, and so unit testing is required.</p>
<p>
  2. Once you have unit testing static type checking is redundant.</p>
<p>
  3. Because static typing rejects some valid programs static typing is harmful.</p>
<p>
<br/></p>
<div><p>
Despite the fact that I had heard and read this claim many times I couldn't find any research to back this claim up. So I decided to conduct an experiment to see if in practice unit tests really did obviate static typing for error detection. I also wanted to see if developers frequently use dynamic constructs that can't be expressed in a statically typed programming language.</p>
<p>
My experiment would consist of finding examples of open source, unit tested programs written in a dynamically typed programming language and manually translating them into a statically typed programming language. I would then quantify how many (if any) defects were detected by the type checker, and how many dynamic constructs couldn't be directly expressed due to being rejected by the static type checker. I should emphasize that for this experiment I would *not* be simply rewriting the program, but doing a direct line by line translation from one programming language to another. I would not count defects that were not detected by the type checker, nor any defects that could not be reproduced in the original program.
</p><p>
Before starting the experiment I needed to choose a dynamically typed programming language that I would translate programs from. I also needed to choose a statically typed programming language that I would translate those programs to. The criteria for the dynamically typed programming language were as follows:
</p><ul>
<li>The language should be dynamically typed</li>
<li>The language should have support for and a culture of unit testing</li>
<li>The language should have a large corpus of open source software for studying</li>
<li>The language should be well known and considered a good language among dynamic typing proponents</li>
</ul>
<p>
With this criteria in mind I selected Python. The next step is to chose the statically typed programming language. For this selection I used the following criteria:</p>
<div>
<ul>
<li>The language should be statically typed</li>
<li>The language should execute on the same platform as Python</li>
<li>The language should be strongly typed</li>
<li>The language should be considered a good language among static typing proponents</li>
</ul>
</div><p>
I selected Haskell for the statically typed programming language.
</p><p>
The next step was to choose some unit tested programs to translate from Python into Haskell. I randomly picked four projects, </p><a href="https://python-gpsd.googlecode.com/" target="_blank">The Python NMEA Toolkit</a><p>, </p><a href="https://code.google.com/p/midiutil/" target="_blank">MIDIUtil</a><p>, </p><a href="https://code.google.com/p/grapefruit/" target="_blank">GrapeFruit</a><p> and </p><a href="https://bitbucket.org/sirpengi/pyfontinfo" target="_blank">PyFontInfo</a><p> from the </p><a href="https://code.google.com/" target="_blank">https://code.google.com/</a><p> and </p><a href="https://bitbucket.org/" target="_blank">https://bitbucket.org</a><p> source code hosting sites.

</p><h2>








The Python NMEA Toolkit</h2>
<p>
The translation of the Python NMEA Tookit from Python to Haskell led to the discovery of nine type errors. Three of them could be triggered by malformed input and the other six by an incorrect usage of the API. Only one of the type errors would have been guaranteed to have been discovered had full unit test coverage been employed. Additionally there was one run time error that could be eliminated once static typing was applied. Two unit tests could have been eliminated as their only function was to perform type checking. No dynamic constructs were used that could not be directly translated into Haskell.</p>
<p>
<br/></p>
<h2>








MIDIUtil</h2>
<p>
The translation of MIDIUtil led to the discovery of 2 type errors. Only one of the type errors would have been certainly been caught had full unit test coverage been employed. An additional run time error could also be eliminated by static typing. None of the unit tests only tested for type safety and so none of them could be eliminated. The MIDIUtil code did use <i>struct.pack</i> and <i>struct.unpack </i>which could not be directly translated as they both rely on format strings that determine the type of arguments and return values. However in all cases the format strings were hard-coded, so the Haskell version could instead use hard-coded functions instead of the hard-coded format strings with no loss in expressiveness. Had the MIDIUtil code stored these format strings in external configuration files then the program would likely have required a re-design to express it in a statically typed language.</p>
<p>
<br/></p>
<p>
<h2>








GrapeFruit</h2>
</p>
<div><p>
The translation of GrapeFruit to Haskell did not result in the discovery of any type errors. A single run time error could be eliminated by static typing. Additionally a single unit test could have been eliminated that only tested for type safety. No dynamic constructs were used that could not be directly translated into Haskell.</p>

<h2>





PyFontInfo</h2>
<p>
The translation of PyFontInfo resulted in the discovery of six type errors. Two run time errors could be eliminated by static typing. A single unit test could have been eliminated. The PyFontInfo code also used <i>struct.pack</i> and <i>struct.unpack </i>which can not be directly translated, but a simple work around exists.</p>
<p>
<br/></p>
<p>
<h2>





Results</h2>
</p>
<p>
The translation of these projects revealed that all of these projects could have been written in a statically typed programming language with only minor code changes. Furthermore, unit testing did not seem to be an adequate replacement for static type checking. A total of seventeen type errors were discovered. All of the type errors that were discovered were the result of bugs in the original Python code that were not discovered by the unit tests. Many of the bugs existed in code that did have unit test coverage.</p>
<p>
<br/></p>

<p>
The results of this experiment indicate that unit testing is not an adequate replacement for static typing for defect detection. While unit testing does catch many errors it is difficult to construct unit tests that will detect the kinds of defects that would be programatically detected by static typing. The application of static type checking to many programs written in dynamically typed programming languages would catch many defects that were not detected with unit testing, and would not require significant redesign of the programs.<br/>
<br/>
<h2>




Future Work</h2>
The translation of these four projects do provide an interesting data point on the effectiveness of unit testing for defect detection. I hope that others will try to conduct similar experiments on more samples of dynamically typed programs.<br/>
<br/></p>
<p>
<br/></p>
<div><p>
The full length paper is located </p><a href="https://docs.google.com/open?id=0B5C1aVVb3qRONVhiNDBiNUw0am8" target="_blank">here</a><p>.</p></div>
<div><p>
The original Python code and the Haskell translation are </p><a href="https://docs.google.com/open?id=0B5C1aVVb3qROS2dib0NtbzZCaVE" target="_blank">here</a><p>.</p></div>
<p>
<br/></p>
</div>
</div>
<p/>
</div>
</div></body></html>