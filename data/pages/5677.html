<html><body><div><div itemprop="articleBody"><p>This is an overview of the tools and practices I've used for debugging or profiling purposes. This is not necessarily complete, there are so many tools so I'm listing only what I think is best or relevant. If you know better tools or have other preferences, please comment below.</p><div class="section" id="logging"><h2>Logging<a class="headerlink" href="#logging" title="Permalink to this headline"> *</a></h2><p>Yes, really. Can't stress enough how important it is to have adequate logging in your application. You should log important stuff. If your logging is good enough, you can figure out the problem just from the logs. Lots of time saved right there.</p><p>If you do ever litter your code with <tt class="docutils literal">print</tt> statements stop now. Use <tt class="docutils literal">logging.debug</tt> instead. You'll be able to reuse that later, disable it altogether and so on ...</p></div><div class="section" id="tracing"><h2>Tracing<a class="headerlink" href="#tracing" title="Permalink to this headline"> *</a></h2><p>Sometimes it's better to see what gets executed. You could run step-by-step using some IDE's debugger but you would need to know what you're looking for, otherwise the process will be very slow.</p><p>In the stdlib there's a <a class="reference external" href="http://docs.python.org/2/library/trace.html#cmdoption-trace-t">trace</a> module which can print all the executed lines amongst other this (like making <a class="reference external" href="http://docs.python.org/2/library/trace.html#cmdoption-trace-c">coverage reports</a>)</p><div class="highlight"><pre><span/>python -mtrace --trace script.py
</pre></div><p>This will make lots of output (every line executed will be printed so you might want to pipe it through grep to only see the interesting modules). Eg:</p><div class="highlight"><pre><span/>python -mtrace --trace script.py <span class="p">|</span> egrep <span class="s1">'^(mod1.py|mod2.py)'</span>
</pre></div><div class="section" id="alternatives"><h3>Alternatives<a class="headerlink" href="#alternatives" title="Permalink to this headline"> *</a></h3><p>Grepping for relevant output is not fun. Plus, the <tt class="docutils literal">trace</tt> module doesn't show you any variables.</p><p><a class="reference external" href="https://pypi.python.org/pypi/hunter">Hunter</a> is a flexible alternative that allows filtering and even shows variables of your choosing. Just <tt class="docutils literal">pip install hunter</tt> and run:</p><pre class="literal-block">
PYTHON_HUNTER="F(module='mod1'),F(module='mod2')" python script.py
</pre><p>Take a look at the <a class="reference external" href="https://github.com/ionelmc/python-hunter">project page</a> for more examples.</p><p>â€•</p><p>If you're feeling adventurous then you could try <a class="reference external" href="https://github.com/dhellmann/smiley">smiley</a> - it shows you the variables and you can use it to trace programs remotely.</p><p>Alternativelly, if you want very selective tracing you can use <a class="reference external" href="https://pypi.python.org/pypi/aspectlib">aspectlib.debug.log</a> to make existing or 3rd party code emit traces.</p></div></div><div class="section" id="pdb"><h2>PDB<a class="headerlink" href="#pdb" title="Permalink to this headline"> *</a></h2><p>Very basic intro, everyone should know this by now:</p><div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">pdb</span>
<span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span> <span class="c1"># opens up pdb prompt</span>
</pre></div><p>Or:</p><div class="highlight"><pre><span/><span class="k">try</span><span class="p">:</span>
    <span class="n">code</span>
    <span class="n">that</span>
    <span class="n">fails</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pdb</span>
    <span class="n">pdb</span><span class="o">.</span><span class="n">pm</span><span class="p">()</span> <span class="c1"># or pdb.post_mortem()</span>
</pre></div><p>Or (press <tt class="docutils literal">c</tt> to start the script):</p><p>Once in the REPL do:</p><ul class="simple"><li><tt class="docutils literal">c</tt> or <tt class="docutils literal">continue</tt></li><li><tt class="docutils literal">q</tt> or <tt class="docutils literal">quit</tt></li><li><tt class="docutils literal">l</tt> or <tt class="docutils literal">list</tt>, shows source at the current frame</li><li><tt class="docutils literal">w</tt> or <tt class="docutils literal">where</tt>, shows the traceback</li><li><tt class="docutils literal">d</tt> or <tt class="docutils literal">down</tt>, goes down 1 frame on the traceback</li><li><tt class="docutils literal">u</tt> or <tt class="docutils literal">up</tt>, goes up 1 frame on the traceback</li><li><tt class="docutils literal">&lt;enter&gt;</tt>, repeats last command</li><li><tt class="docutils literal">! &lt;stuff&gt;</tt>, evaluates <tt class="docutils literal">&lt;stuff&gt;</tt> as python code on the current frame</li><li><em>everything else</em>, evaluates as python code <em>if it's not a PDB command</em></li></ul></div><div class="section" id="better-pdb"><h2>Better PDB<a class="headerlink" href="#better-pdb" title="Permalink to this headline"> *</a></h2><p>Drop in replacements for <tt class="docutils literal">pdb</tt>:</p><ul class="simple"><li><a class="reference external" href="https://pypi.python.org/pypi/ipdb">ipdb</a> (<tt class="docutils literal">pip install ipdb</tt>) - like ipython (autocomplete, colors etc).</li><li><a class="reference external" href="https://pypi.python.org/pypi/pudb">pudb</a> (<tt class="docutils literal">pip install pudb</tt>) - curses based (gui-like), good at browsing sourcecode.</li><li><a class="reference external" href="https://pypi.python.org/pypi/pdbpp">pdb++</a> (<tt class="docutils literal">pip install pdbpp</tt>) - autocomplete, colors, extra commands etc.</li></ul></div><div class="section" id="remote-pdb"><h2>Remote PDB<a class="headerlink" href="#remote-pdb" title="Permalink to this headline"> *</a></h2><p><tt class="docutils literal">sudo <span class="pre">apt-get</span> install winpdb</tt></p><p>Instead of <tt class="docutils literal">pdb.set_trace()</tt> do:</p><div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">rpdb2</span>
<span class="n">rpdb2</span><span class="o">.</span><span class="n">start_embedded_debugger</span><span class="p">(</span><span class="s2">"secretpassword"</span><span class="p">)</span>
</pre></div><p>Now run <tt class="docutils literal">winpdb</tt> and go to <tt class="docutils literal">File</tt> &gt; <tt class="docutils literal">Attach with the password</tt>.</p><div class="section" id="don-t-like-winpdb-use-pdb-over-tcp"><h3>Don't like Winpdb? Use PDB over TCP<a class="headerlink" href="#don-t-like-winpdb-use-pdb-over-tcp" title="Permalink to this headline"> *</a></h3><p>Get <a class="reference external" href="https://pypi.python.org/pypi/remote-pdb">remote-pdb</a> and then, to open a remote PDB on first available port, use:</p><div class="highlight"><pre><span/><span class="kn">from</span> <span class="nn">remote_pdb</span> <span class="kn">import</span> <span class="n">set_trace</span>
<span class="n">set_trace</span><span class="p">()</span> <span class="c1"># you'll see the port number in the logs</span>
</pre></div><p>To use some specific host/port:</p><div class="highlight"><pre><span/><span class="kn">from</span> <span class="nn">remote_pdb</span> <span class="kn">import</span> <span class="n">RemotePdb</span>
<span class="n">RemotePdb</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s1">'0.0.0.0'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">4444</span><span class="p">)</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
</pre></div><p>To connect just run something like <tt class="docutils literal">telnet 192.168.12.34 4444</tt>. Alternatively, run <tt class="docutils literal">socat socat readline tcp:192.168.12.34:4444</tt> to get line editing and history.</p></div><div class="section" id="just-a-repl"><h3>Just a REPL<a class="headerlink" href="#just-a-repl" title="Permalink to this headline"> *</a></h3><p>If you don't need a full blown debugger then just start a <a class="reference external" href="http://ipython.org/install.html">IPython</a> with:</p><div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">IPython</span>
<span class="n">IPython</span><span class="o">.</span><span class="n">embed</span><span class="p">()</span>
</pre></div><p>If you don't have an attached terminal you can use <a class="reference external" href="https://pypi.python.org/pypi/manhole">manhole</a>.</p></div></div><div class="section" id="having-segfaults-faulthandler"><h2>Having segfaults? faulthandler<a class="headerlink" href="#having-segfaults-faulthandler" title="Permalink to this headline"> *</a></h2><p>Rather awesome addition from Python 3.3, <a class="reference external" href="https://pypi.python.org/pypi/faulthandler/">backported</a> to Python 2.x</p><p>Just do this and you'll get at least an idea of what's causing the segmentation fault. Just add this in some module that's always imported:</p><div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">faulthandler</span>
<span class="n">faulthandler</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
</pre></div><p>This won't work in <a class="reference external" href="http://pypy.org/">PyPy</a> unfortunately. If you can't get interactive (e.g.: use <tt class="docutils literal">gdb</tt>) you can just set this environment variable (GNU libc only, <a class="reference external" href="http://blog.andrew.net.au/2007/08/15/">details</a>):</p><pre class="literal-block">
export LD_PRELOAD=/lib/x86_64-linux-gnu/libSegFault.so
</pre><p>Make sure the path is correct - otherwise it won't have any effect (e.g.: run <tt class="docutils literal">locate libSegFault.so</tt>).</p></div><div class="section" id="quick-stacktrace-on-a-signal-faulthandler"><h2>Quick stacktrace on a signal? faulthandler<a class="headerlink" href="#quick-stacktrace-on-a-signal-faulthandler" title="Permalink to this headline"> *</a></h2><p>Add this in some module that's always imported:</p><div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">faulthandler</span>
<span class="kn">import</span> <span class="nn">signal</span>
<span class="n">faulthandler</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGUSR2</span><span class="p">,</span> <span class="n">all_threads</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div><p>Then run <tt class="docutils literal">kill <span class="pre">-USR2</span> &lt;pid&gt;</tt> to get a stacktrace for all threads on the process's <em>stderr</em>.</p></div><div class="section" id="memory-leaks"><h2>Memory leaks<a class="headerlink" href="#memory-leaks" title="Permalink to this headline"> *</a></h2><p>Well, there's are plenty of tools here, some specialized on WSGI applications like <a class="reference external" href="https://pypi.python.org/pypi/Dozer">Dozer</a> but my favorite is definitely <a class="reference external" href="https://pypi.python.org/pypi/objgraph">objgraph</a>. It's so convenient and easy to use it's amazing. It's doesn't have any integration with WSGI or anything so you need to find yourself a way to run code like:</p><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">objgraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">objgraph</span><span class="o">.</span><span class="n">show_most_common_types</span><span class="p">()</span> <span class="c1"># try to find objects to investigate</span>
<span class="go">Request                  119105</span>
<span class="go">function                   7413</span>
<span class="go">dict                       2492</span>
<span class="go">tuple                      2396</span>
<span class="go">wrapper_descriptor         1324</span>
<span class="go">weakref                    1291</span>
<span class="go">list                       1234</span>
<span class="go">cell                       1011</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">objs</span> <span class="o">=</span> <span class="n">objgraph</span><span class="o">.</span><span class="n">by_type</span><span class="p">(</span><span class="s2">"Request"</span><span class="p">)[:</span><span class="mi">15</span><span class="p">]</span> <span class="c1"># select few Request objects</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">objgraph</span><span class="o">.</span><span class="n">show_backrefs</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">highlight</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">"/tmp/graph.png"</span><span class="p">)</span> <span class="c1"># and plot them</span>
<span class="go">Graph written to /tmp/objgraph-zbdM4z.dot (107 nodes)</span>
<span class="go">Image generated as /tmp/graph.png</span>
</pre></div><p>And you get a nice diagram like <a class="reference external" href="https://blog.ionelmc.ro/2013/06/05/python-debugging-tools/objgraph-plot.png">this</a> (warning: it's very large). You can also get <a class="reference external" href="http://www.graphviz.org/content/dot-language">dot</a> output.</p></div><div class="section" id="memory-usage"><h2>Memory usage<a class="headerlink" href="#memory-usage" title="Permalink to this headline"> *</a></h2><p>Sometimes you want to use less memory. Less allocations usually make applications faster and well, users like them lean and mean :)</p><p>There are lots of tools <a class="footnote-reference" href="#id4" id="id3">[1]</a> but the best one in my opinion is <a class="reference external" href="https://github.com/wyplay/pytracemalloc">pytracemalloc</a> - it has very little overhead (doesn't need to rely on the speed crippling <a class="reference external" href="http://docs.python.org/2/library/sys.html#sys.settrace">sys.settrace</a>) compared to other tools and it's output is very detailed. It's a pain to setup because you need to recompile python but <tt class="docutils literal">apt</tt> makes it very easy to do so. In fact, it is <em>so good</em> that it <a class="reference external" href="http://docs.python.org/3.4/library/tracemalloc.html">got included in Python 3.4</a>. See <a class="reference external" href="http://www.python.org/dev/peps/pep-0454/">PEP-454</a> for details.</p><p>Just run these commands and go grab lunch or something:</p><div class="highlight"><pre><span/>apt-get <span class="nb">source</span> python2.7
<span class="nb">cd</span> python2.7-*
wget https://github.com/wyplay/pytracemalloc/raw/master/python2.7_track_free_list.patch
patch -p1 &lt; python2.7_track_free_list.patch
debuild -us -uc
<span class="nb">cd</span> ..
sudo dpkg -i python2.7-minimal_2.7*.deb python2.7-dev_*.deb
</pre></div><p>Alternativelly, you can use this <a class="reference external" href="https://launchpad.net/~ionel-mc/+archive/pytracemalloc">ppa</a> but I think it might be outdated by now. You can make your own ppa, it's <a class="reference external" href="https://gist.github.com/ionelmc/7109195">easy enough</a>.</p><p>And install <tt class="docutils literal">pytracemalloc</tt> (note that if you're doing this in a virtualenv, you need to recreate it after the python re-install - just run <tt class="docutils literal">virtualenv myenv</tt>):</p><pre class="literal-block">
pip install pytracemalloc
</pre><p>Now wrap your application in code like this:</p><div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">tracemalloc</span><span class="o">,</span> <span class="nn">time</span>
<span class="n">tracemalloc</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
<span class="n">top</span> <span class="o">=</span> <span class="n">tracemalloc</span><span class="o">.</span><span class="n">DisplayTop</span><span class="p">(</span>
    <span class="mi">5000</span><span class="p">,</span> <span class="c1"># log the top 5000 locations</span>
    <span class="nb">file</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="s1">'/tmp/memory-profile-</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span> <span class="s2">"w"</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">top</span><span class="o">.</span><span class="n">show_lineno</span> <span class="o">=</span> <span class="bp">True</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># code that needs to be traced</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">top</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>
</pre></div><p>And output is like this:</p><pre class="literal-block">
2013-05-31 18:05:07: Top 5000 allocations per file and line
#1: .../site-packages/billiard/_connection.py:198: size=1288 KiB, count=70 (+0), average=18 KiB
#2: .../site-packages/billiard/_connection.py:199: size=1288 KiB, count=70 (+0), average=18 KiB
#3: .../python2.7/importlib/__init__.py:37: size=459 KiB, count=5958 (+0), average=78 B
#4: .../site-packages/amqp/transport.py:232: size=217 KiB, count=6960 (+0), average=32 B
#5: .../site-packages/amqp/transport.py:231: size=206 KiB, count=8798 (+0), average=24 B
#6: .../site-packages/amqp/serialization.py:210: size=199 KiB, count=822 (+0), average=248 B
#7: .../lib/python2.7/socket.py:224: size=179 KiB, count=5947 (+0), average=30 B
#8: .../celery/utils/term.py:89: size=172 KiB, count=1953 (+0), average=90 B
#9: .../site-packages/kombu/connection.py:281: size=153 KiB, count=2400 (+0), average=65 B
#10: .../site-packages/amqp/serialization.py:462: size=147 KiB, count=4704 (+0), average=32 B

...
</pre><p>Beautiful, no?</p><hr class="docutils"/><p>EDIT: More about profiling <a class="reference external" href="https://blog.ionelmc.ro/2013/06/08/python-profiling-tools">here</a>.</p></div></div></div></body></html>