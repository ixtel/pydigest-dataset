<html><body><div><div id="container">
  <h1>Connect Python objects to blinker signals</h1>
<p class="byline">By <a href="/">Matt Layman</a> on March 18, 2015</p>
<p><img class="book" src="blinker.png"/></p>
<p>I started using <a href="https://pythonhosted.org/blinker/">blinker</a> for <a href="http://handroll.github.io/">handroll</a>.
Blinker is a signal generation library for broadcasting events.
The library lets signalers send messages
to connected receiver functions.
I will explain how I convinced Blinker to talk to objects
instead of pure Python functions.</p>
<p>The example code is going to handle a “<a href="http://dictionary.reference.com/browse/frobnicate">frobnicated</a>” signal.
Remember, the signal itself is not very important.</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">blinker</span>

<span class="n">frobnicated</span> <span class="o">=</span> <span class="n">blinker</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="s">'frobnicated'</span><span class="p">)</span>
</pre></div>


<p><code>frobnicated</code> is a named signal.
In a real project,
you might put all your signals in a single module.
<a href="https://github.com/getpelican/pelican/blob/master/pelican/signals.py">Pelican</a> does this nicely.
Grouping all your signals in one place
gives signal consumers a clear view of what is available.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Receiver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">handle_frobnicated</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_frobnicated</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handle_frobnicated</span> <span class="o">=</span> <span class="n">handle_frobnicated</span>
        <span class="n">frobnicated</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">handle_frobnicated</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_frobnicated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">sender</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">'message'</span><span class="p">]</span>
</pre></div>


<p>The <code>__init__</code> method is where all the magic happens.
The first thing to notice is the use of an inner function,
<code>handle_frobnicated</code>.
The inner function uses the method signature
that the signal will invoke,
and delegates to <code>Receiver.on_frobnicated</code>.
Why?
This is necessary
because Blinker can’t pass <code>self</code> to receiver functions.
<code>handle_frobnicated</code> acts as a <a href="http://en.wikipedia.org/wiki/Closure_%28computer_programming%29">closure</a> on <code>self</code>
which lets the signal call the instance method.</p>
<div class="codehilite"><pre>        <span class="bp">self</span><span class="o">.</span><span class="n">handle_frobnicated</span> <span class="o">=</span> <span class="n">handle_frobnicated</span>
</pre></div>


<p>That seems like a strange line,
doesn’t it?
Blinker does some funny stuff with references.
Without storing the inner function,
Blinker will delete a weak function reference
and the inner function will no longer be among the signal’s receivers.
I stared at the Blinker source code
for a long time
to figure that mystery out.</p>
<p>The last line in <code>__init__</code> connects the signal to the inner function.
The receiver is ready to handle <code>frobnicated</code> events.</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">receiver</span> <span class="o">=</span> <span class="n">Receiver</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">frobnicated</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">'Sender </span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s">'hello'</span><span class="p">)</span>
</pre></div>


<p>The code to fire the signal is fairly boring.
Notice that <code>frobnicated.send</code> has no need for <code>receiver</code>.
The publisher is disconnected from subscriber at this stage.
The final result looks like:</p>
<div class="codehilite"><pre><span class="nv">$ </span>python blink_object.py
Sender <span class="m">0</span> hello
Sender <span class="m">1</span> hello
Sender <span class="m">2</span> hello
Sender <span class="m">3</span> hello
Sender <span class="m">4</span> hello
Sender <span class="m">5</span> hello
Sender <span class="m">6</span> hello
Sender <span class="m">7</span> hello
Sender <span class="m">8</span> hello
Sender <span class="m">9</span> hello
</pre></div>


<p>By connecting a signal to an object,
you get all the benefits that come along with classes.
Rather than making a monsterous function,
you could use various instance methods
within the handler.
This flexibility is a boon for unit testing.
The gain has similar advantages to using <a href="https://docs.djangoproject.com/en/1.7/topics/class-based-views/intro/">class based views</a>
in Django
rather than function views.</p>
<p>You can <a href="blink_object.py">check out the full example in all its glory.</a></p>
<p>If you want to chat about this with me, I'm
  <a href="https://twitter.com/mblayman">@mblayman</a> on Twitter.</p>
  
  <footer>
    <p><img alt="Creative Commons Attribution 4.0 International License" src="/cc.png"/> <a href="/"> Matt Layman</a>,
      2016</p>
  </footer>
</div>
</div></body></html>