<html><body><div><div class="inner">
        	
	        <time datetime="2014-03-07">07 Mar 2014</time> <span class="post-tags">on geoip, python, flask, json</span>        	
    	    <h1 class="post-title">Flask GeoIP API in python</h1>
            <p>We're going to create a simple flask webapp. I say <em>simple</em> because it only has three routes, however this doesn't mean it can't be extremely useful.</p>

<p><a href="#finalcode">Jump to final code</a></p>

<p>The webapp will provide the following three functions:</p>

<ul>
<li>Root route - Details for requesters IP</li>
<li>IP route - Details for the IP url parameter</li>
<li>Domain route - Details for the domain parameter</li>
</ul>

<p>The JSON output of our API will look like this:  </p>

<pre><code class="language-javascript">{
area_code: 408,  
city: "Campbell",  
continent: "NA",  
country_code: "US",  
country_code3: "USA",  
country_name: "United States",  
dma_code: 807,  
latitude: 37.28030000000001,  
longitude: -121.9567,  
metro_code: "San Francisco, CA",  
postal_code: "95008",  
region_code: "CA",  
time_zone: "America/Los_Angeles"  
}
</code></pre>

<p>Flask makes this very simple for us with its simple straight forward routing mechanism, we can get the request IP with <code>request.remote_addr</code>.</p>

<p>For our GeoIP functionality we'll be using the <a href="https://github.com/appliedsec/pygeoip">pygeoip</a> library. You'll also need to download the <a href="http://dev.maxmind.com/geoip/legacy/geolite/">latest available database from MaxMind</a>.</p>

<p>We will take advantage of the <code>jsonify</code> function that Flask has to offer. This will take care of converting the dictionary returned from pygeoip into a JSON encoded string, and also setting the <code>content-type</code> response header to <code>application/json</code>.</p>

<pre><code class="language-python">from flask import Flask, request, jsonify  
import pygeoip

app = Flask(__name__)

# Make sure this points to your downloaded file
gi = pygeoip.GeoIP('GeoIPCity.dat', pygeoip.MEMORY_CACHE)

@app.route('/')
def root():  
    geo_data = gi.record_by_addr(request.remote_addr)
    return jsonify(geo_data)

if __name__ == '__main__':  
    app.run(port=8000, debug=False)
</code></pre>

<p>The above will make the root url display the details for <em>your</em> IP address. However please note that it will not work on localhost, as your IP address for that request would simply be <code>127.0.0.1</code>.</p>

<p>Now you can add the routes for the custom IP or custom domain which will be passed in the URL.</p>

<pre><code class="language-python">@app.route('/ip/&lt;ip_address&gt;')
def ip(ip_address):  
    geo_data = gi.record_by_addr(ip_address)
    return jsonify(geo_data)

@app.route('/domain/&lt;domain_name&gt;')
def domain(domain_name):  
    geo_data = gi.record_by_name(domain_name)
    return jsonify(geo_data)
</code></pre>

<p>The only problem so far is that if somebody sends a request for an invalid IP/domain, then <code>geo_data</code> will equal <code>None</code>. Upon calling <code>jsonify(None)</code> you will recieve an exception.</p>

<p>Because our app only serves one simple function, we can register a global exception catcher for 500 errors, and display an error the the requester.</p>

<pre><code class="language-python"># In general catching all 500 errors like this could be considered bad practice
# But with an app which only serves single function like ours
# It's a neat way to follow the DRY principal because all errors are the same
@app.errorhandler(500)
def error_500(e):  
    return jsonify({'error': 'Error finding GeoIP data for that address'})
</code></pre>

<h4 id="finalcode">Final Code</h4>

<p>That's it. You have yourself a JSON GeoIP API that can be used with ease. Here's all of it put together:</p>

<pre><code class="language-python">from flask import Flask, request, jsonify  
import pygeoip

app = Flask(__name__)

# Make sure this points to your downloaded file
gi = pygeoip.GeoIP('GeoIPCity.dat', pygeoip.MEMORY_CACHE)

@app.route('/')
def root():  
    geo_data = gi.record_by_addr(request.remote_addr)
    return jsonify(geo_data)

@app.route('/ip/&lt;ip_address&gt;')
def ip(ip_address):  
    geo_data = gi.record_by_addr(ip_address)
    return jsonify(geo_data)

@app.route('/domain/&lt;domain_name&gt;')
def domain(domain_name):  
    geo_data = gi.record_by_name(domain_name)
    return jsonify(geo_data)

# In general catching all 500 errors like this could be considered bad practice
# But with an app which only serves single function like ours
# It's a neat way to follow the DRY principal because all errors are the same
@app.errorhandler(500)
def error_500(e):  
    return jsonify({'error': 'Error finding GeoIP data for that address'})

if __name__ == '__main__':  
    app.run(port=8000, debug=False)
</code></pre>
         </div>

			</div></body></html>