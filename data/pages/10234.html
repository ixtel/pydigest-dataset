<html><body><div><div class="content html_format"><p>
      Сегодня мы попробуем найти самый дешевый и самый дорогой интернет магазин книг.</p><p>
Сравнивать будем бумажные книги, которые есть в наличии. В разных магазинах очень разное количество книг. Где-то менее 1000, а где-то более 200 000 книг. 

</p><img src="https://habrastorage.org/files/1e8/ecc/fee/1e8eccfeeb0b4f9489e3aba762949dc1.png"/>
<p>
Кстати, гистограмма настоящая. Как она построена и другие интересные закономерности под катом.
</p><a name="habracut"/><p>
Для начала нужно найти список книг, которые есть во всех магазинах.
</p><p>
Я выгрузил базу с сайта </p><a href="http://bookradar.org/">bookradar.org</a><p>, в виде csv файла. Конечно не просто выгрузил, а специальным образом обработал с помощью Python, чтобы удобно было анализировать. Столбцы у нас — магазины, строки — это книги, ячейки строк — цены на эту книгу в конкретном магазине. Если книги в магазине нет, то пустое значение (NaN).

</p><img src="https://habrastorage.org/files/9df/8dd/58e/9df8dd58ef744ccea315cee1b0294da8.png"/>
<p>
Выгружены только бумажные книги, у которых указан ISBN. Книги у которых ISBN не указан нет возможности понять, что это одна и та же книга. Даже книги которые называются одинаково и выглядят одинаково могут отличаться ценой, если например это издания разных лет. Поэтому для упрощения анализа используем только те книги которые легко можно сопоставить.
</p><p>
Когда первый раз рисовал графики, масштаб был совершенно нечитаемый, т.к. есть отдельные экземпляры, которые стоят 30-50 тыс руб. Поэтому при выгрузке я удалил книги которые стоят дороже 1500 руб.

</p><h2>Выбираем магазины для анализа</h2><p>
Сделаем необходимые импорты и загрузим файл в DataFrame:

</p><pre><code class="python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from IPython.display import HTML
plt.style.use('ggplot')
%matplotlib inline

filename = 'books.csv'
data = pd.read_csv(filename, header=0, na_values=None, low_memory=False)
data.head()
</code></pre><p>
Так выглядят первые несколько строк нашего DataFrame.
</p><table>
<thead>
<tr>
<th/>
<th>isbn</th>
<th>dmkpress.com</th>
<th>rufanbook.ru</th>
<th>read.ru</th>
<th>setbook.ru</th>
<th>moymir.ru</th>
<th>boffo.ru</th>
<th>my-shop.ru</th>
<th>...</th>
</tr>
</thead>
<tbody>
<tr>
<th>1</th>
<td>9785994911389</td>
<td>NaN</td>
<td>NaN</td>
<td>69</td>
<td>100</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>...</td>
</tr>
<tr>
<th>2</th>
<td>9789855497791</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>310</td>
<td>NaN</td>
<td>NaN</td>
<td>403</td>
<td>...</td>
</tr>
<tr>
<th>3</th>
<td>9785942802943</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>...</td>
</tr>
<tr>
<th>4</th>
<td>9785779717533</td>
<td>NaN</td>
<td>NaN</td>
<td>177</td>
<td>160</td>
<td>NaN</td>
<td>NaN</td>
<td>177</td>
<td>...</td>
</tr>
</tbody>
</table><p>
Посчитаем сколько книг к каждом магазине:

</p><pre><code class="python">desc = data.describe()
l = []
for colname in desc:
    count = desc[colname][0]
    l.append((count, colname))
    
for t in sorted(l, reverse=True):
    print("{:16} {}".format(t[1], int(t[0])))
</code></pre>

<pre>
магазин          кол-во книг
ozon.ru          220962
setbook.ru       208039
my-shop.ru       203200
books.ru         181817
book-stock.ru    124308
bookvoed.ru      117494
labirint.ru      114803
read.ru          93720
spbdk.ru         43714
chaconne.ru      42993
biblion.ru       41898
eksmo.ru         40582
knigosvet.com    34645
rufanbook.ru     6071
combook.ru       4716
bookmail.ru      2356
boffo.ru         2341
moymir.ru        740
dmkpress.com     722
</pre>
<p>
Совсем маленькие магазины смысла брать нет, т.к. пересекающихся книг будет очень мало или вовсе ноль. Выберем магазины примерно от 100 тыс книг или чуть меньше

</p><pre><code class="python"># Оставляем нужные магазины
stores = ['books.ru', 'labirint.ru', 'ozon.ru', 'my-shop.ru', 
          'read.ru', 'bookvoed.ru', 'book-stock.ru', 'setbook.ru']
data = data[stores]

# Удаляем строки в которых есть пустые значения. 
# Т.е. оставляем только те книги, которые присутствуют во всех магазинах.
data = data.dropna(axis=0)

# Посмотрим, что осталось
data.describe()
</code></pre><p>
Получили сводную информацию о таблице:
</p><table border="1">
<thead>
<tr>
<th/>
<th>books.ru</th>
<th>labirint.ru</th>
<th>ozon.ru</th>
<th>my-shop.ru</th>
<th>read.ru</th>
<th>bookvoed.ru</th>
<th>book-stock.ru</th>
<th>setbook.ru</th>
</tr>
</thead>
<tbody>
<tr>
<th>count</th>
<td>17834.000000</td>
<td>17834.000000</td>
<td>17834.000000</td>
<td>17834.000000</td>
<td>17834.000000</td>
<td>17834.000000</td>
<td>17834.000000</td>
<td>17834.000000</td>
</tr>
<tr>
<th>mean</th>
<td>340.154312</td>
<td>343.349333</td>
<td>308.639677</td>
<td>294.602108</td>
<td>309.796400</td>
<td>315.771504</td>
<td>291.266794</td>
<td>286.433722</td>
</tr>
<tr>
<th>std</th>
<td>189.347516</td>
<td>235.526318</td>
<td>209.594445</td>
<td>206.383899</td>
<td>208.093532</td>
<td>208.651959</td>
<td>204.553104</td>
<td>191.038253</td>
</tr>
<tr>
<th>min</th>
<td>40.000000</td>
<td>17.000000</td>
<td>26.000000</td>
<td>14.000000</td>
<td>69.000000</td>
<td>13.000000</td>
<td>14.000000</td>
<td>77.000000</td>
</tr>
<tr>
<th>25%</th>
<td>210.000000</td>
<td>169.250000</td>
<td>153.000000</td>
<td>142.000000</td>
<td>155.000000</td>
<td>162.000000</td>
<td>142.000000</td>
<td>140.000000</td>
</tr>
<tr>
<th>50%</th>
<td>308.000000</td>
<td>293.500000</td>
<td>264.000000</td>
<td>248.000000</td>
<td>267.000000</td>
<td>271.000000</td>
<td>248.000000</td>
<td>240.000000</td>
</tr>
<tr>
<th>75%</th>
<td>429.000000</td>
<td>435.000000</td>
<td>391.000000</td>
<td>380.750000</td>
<td>391.000000</td>
<td>402.000000</td>
<td>373.000000</td>
<td>360.000000</td>
</tr>
<tr>
<th>max</th>
<td>1460.000000</td>
<td>1497.000000</td>
<td>1478.000000</td>
<td>1474.000000</td>
<td>1485.000000</td>
<td>1456.000000</td>
<td>1474.000000</td>
<td>1490.000000</td>
</tr>
</tbody>
</table><p>
Книг, которые есть во всех магазинах, у нас нашлось 17834.</p><p>
Некоторые пояснения:
</p><ul>
<li><b>mean</b> — среднее</li>
<li><b>std</b> — стандартное отклонение</li>
<li><b>50%, 25% и 75%</b> — медианы среднего, нижнего и верхнего кванитилей</li>
</ul><p>
По этим данным уже можно сделать какие-то выводы. Если смотреть по медиане, то лучшую цену предлагает setbook.ru с 240, затем идут my-shop.ru и book-stock.ru с медианой 248.

</p><h2>Распределение цен</h2><p>
Построим гистограмму и посмотрим, в каком диапазоне больше всего книг. Эта гистограмма аналогична картинке в начале поста, только здесь больше столбиков.

</p><pre><code class="python">plt.figure(figsize=(10, 6))
plt.xlabel('цена книги, руб')
plt.ylabel('кол-во, шт')

data3 = data[stores]
x = data3.as_matrix().reshape(data3.size)  # склеиваем столбцы с ценами в одномерный массив
count, bins, ignored = plt.hist(x, bins=30)
</code></pre>

<img src="https://habrastorage.org/files/11d/dae/a90/11ddaea9051e483284528e836cb49420.png"/>
<p>
Интересно, получилось два пика, примерно в 75 руб и 215 руб.
</p><p>
А искаженный вид я получил добавлением пары строк вначале предыдущего куска кода:
</p><pre><code class="python">plt.xkcd() # искаженный стиль отображения
plt.style.use('ggplot') # сбрасываем цветовые настроки xkcd, т.к. цветовая схема xkcd синяя
</code></pre>

<h2>Корреляция цен</h2><p>
Теперь посмотрим корреляцию цен в магазинах:
</p><pre><code class="python">data.corr()
</code></pre>
<table border="1">
<thead>
<tr>
<th/>
<th>books.ru</th>
<th>labirint.ru</th>
<th>ozon.ru</th>
<th>my-shop.ru</th>
<th>read.ru</th>
<th>bookvoed.ru</th>
<th>book-stock.ru</th>
<th>setbook.ru</th>
</tr>
</thead>
<tbody>
<tr>
<th>books.ru</th>
<td>1.000000</td>
<td>0.971108</td>
<td>0.969906</td>
<td>0.965291</td>
<td>0.978453</td>
<td>0.970747</td>
<td>0.965809</td>
<td>0.966226</td>
</tr>
<tr>
<th>labirint.ru</th>
<td>0.971108</td>
<td>1.000000</td>
<td>0.973731</td>
<td>0.968637</td>
<td>0.979923</td>
<td>0.970600</td>
<td>0.969971</td>
<td>0.965970</td>
</tr>
<tr>
<th>ozon.ru</th>
<td>0.969906</td>
<td>0.973731</td>
<td>1.000000</td>
<td>0.973783</td>
<td>0.979620</td>
<td>0.967151</td>
<td>0.974792</td>
<td>0.971946</td>
</tr>
<tr>
<th>my-shop.ru</th>
<td>0.965291</td>
<td>0.968637</td>
<td>0.973783</td>
<td>1.000000</td>
<td>0.976491</td>
<td>0.956980</td>
<td>0.996946</td>
<td>0.970588</td>
</tr>
<tr>
<th>read.ru</th>
<td>0.978453</td>
<td>0.979923</td>
<td>0.979620</td>
<td>0.976491</td>
<td>1.000000</td>
<td>0.974892</td>
<td>0.976164</td>
<td>0.974129</td>
</tr>
<tr>
<th>bookvoed.ru</th>
<td>0.970747</td>
<td>0.970600</td>
<td>0.967151</td>
<td>0.956980</td>
<td>0.974892</td>
<td>1.000000</td>
<td>0.958787</td>
<td>0.961217</td>
</tr>
<tr>
<th>book-stock.ru</th>
<td>0.965809</td>
<td>0.969971</td>
<td>0.974792</td>
<td>0.996946</td>
<td>0.976164</td>
<td>0.958787</td>
<td>1.000000</td>
<td>0.972701</td>
</tr>
<tr>
<th>setbook.ru</th>
<td>0.966226</td>
<td>0.965970</td>
<td>0.971946</td>
<td>0.970588</td>
<td>0.974129</td>
<td>0.961217</td>
<td>0.972701</td>
<td>1.000000</td>
</tr>
</tbody>
</table><p>
Видна хорошая корреляция между ценами всех магазинов. А если посмотреть на пару my-shop.ru и book-stock.ru, то тут корреляция аж 0.996946, т.е. цены в них почти одинаковые.
</p><p>
Построим гистограмму распределения цены на книги в каждом магазине и диаграмму рассеяния для каждой пары магазинов:

</p><pre><code class="python">from pandas.tools.plotting import scatter_matrix
scatter_matrix(data, alpha=0.05, figsize=(14, 14));
</code></pre>
<img src="https://habrastorage.org/files/54f/671/03d/54f67103da264a57924d45382f7ee55f.png"/>
<p>
По диаграммам рассеяния опять видим ту же картину, что и в таблице корреляции. Корреляция явно есть, ее хорошо видно. Увеличим пару магазинов для наглядности.

</p><pre><code class="python">scatter_matrix(data[['ozon.ru', 'labirint.ru']], alpha=0.05, figsize=(14, 14));
</code></pre>

<img src="https://habrastorage.org/files/205/404/413/20540441355342d7ab561ad5a5c5875c.png"/>
<p>
А теперь посмотрим на нашу пару магазинов с очень похожими ценами:

</p><pre><code class="python">scatter_matrix(data[['my-shop.ru', 'book-stock.ru']], alpha=0.05, figsize=(14, 14));
</code></pre>

<img src="https://habrastorage.org/files/c7b/fa7/466/c7bfa746649d4bfcb306191304854e48.png"/>
<p>
Получилась почти идеальная прямая. Но все таки есть точки которые расположились вне ее, т.е. не 100% цен одинаковы.

</p><h2>График со всеми ценами</h2><p>
Попробуем изобразить нашу таблицу графически.
</p><pre><code class="python">plt.figure(figsize=(14, 6))

# просто порядковые номера по горизонтальной оси
x = list(range(data['books.ru'].count()))

colors = ['red', 'blue', 'green', 'orange', 'yellow', 'pink', 'brown', 'purple']

for index,store in enumerate(stores):
    plt.scatter(x,
            data[store],
            alpha=0.5,
            color=colors[index],
            label=store)

plt.xlabel('n')
plt.ylabel('price')
plt.legend(loc='best');
</code></pre>

<img src="https://habrastorage.org/files/b96/b98/d8e/b96b98d8e884467599a13017cb955724.png"/>
<p>
Диаграмма красивая, но бесполезная. Точки просто перекрывают друг друга. Последний слой фиолетовый, явно закрасил все предыдущие.

</p><h2>Количество книг по минимальной цене</h2><p>
Давайте теперь определим количество книг по минимальной цене в каждом магазине. Нужно учесть, что минимальная цена на конкретную книгу может быть сразу в нескольких магазинах. Поэтому добавим колонки вида «min_ozon.ru» — если в данном магазине на данную книга установлена минимальная цена среди всех магазинов, устанавливаем 1 иначе NaN. Такие значения выбраны для удобства подсчета.

</p><pre><code class="python">import random

def has_min_price(store):
    def inner(row):
        prices = list(row[:len(stores)])
        min_price = min(prices)
        store_price = prices[stores.index(store)] 
        return 1 if store_price == min_price else np.nan
    return inner

# немножко копипасты для разовой аналитики не повредит ;)
def has_max_price(store):
    def inner(row):
        prices = list(row[:len(stores)])
        max_price = max(prices)
        store_price = prices[stores.index(store)] 
        return 1 if store_price == max_price else np.nan
    return inner
    
for store in stores:
    data['min_' + store] = data.apply(has_min_price(store), axis=1)
    data['max_' + store] = data.apply(has_max_price(store), axis=1)

HTML(data.head(10).to_html())
</code></pre>
<p>
Получилась такая таблица

</p><img src="https://habrastorage.org/files/5f2/d95/59a/5f2d9559a27d481ea98d4c551da9145f.png"/>
<p>
Теперь выведем количество книг по минимальной и максимальной цене в каждом магазине:

</p><pre><code class="python">desc = data.describe()

def show_count(prefix):
    l = []
    for column_name in desc:
        if prefix in column_name:
            cnt = desc[column_name][0]
            l.append((cnt, column_name))
    for t in sorted(l, reverse=True):
        print(t[1].replace(prefix, ''), int(t[0]))

print('Всего книг:', desc[stores[0]][0])
print()
print('Количество книг по минимальной цене:')
show_count('min_')
print()
print('Количество книг по максимальной цене:')
show_count('max_')
</code></pre>

<pre>
Всего книг: 17834.0

Количество книг по минимальной цене:
book-stock.ru   8411
my-shop.ru      7735
setbook.ru      6359
bookvoed.ru     1884
ozon.ru         1015
read.ru         914
books.ru        379
labirint.ru     335

Количество книг по максимальной цене:
books.ru        10323
labirint.ru     4383
bookvoed.ru     1143
setbook.ru      1052
ozon.ru         676
book-stock.ru   372
my-shop.ru      351
read.ru         265
</pre>
<p>
По количеству книг с минимальной ценой лидируют book-stock.ru, my-shop.ru, setbook.ru. Что похоже на то, что мы уже видели из медиан, но порядок поменялся.
</p><p>
И по максимальным ценам лидриуют books.ru, labirint.ru и bookvoed.ru.

</p><h2>Отсортируем по минимальной цене</h2><p>
Для того чтобы точки не затирали друг друга, ограничимся небольшим количеством книг.

</p><pre><code class="python">def get_min(row):
    prices = list(row[:len(stores)])
    return min(prices)    

# добавляем столбец с минимальной ценой для книги
data['min'] = data.apply(get_min, axis=1)

# Сортируем данные по этому столбцу,
# Возьмем только каждую 300-ю книгу, иначе множество точек у нас на график опять не влезут
data2 = data.sort_values(['min'])[::300]

# Рисуем графики
plt.figure(figsize=(14, 10))

colors = ['red', 'blue', 'green', 'orange', 'yellow', 'pink', 'brown', 'purple']

for index,store in enumerate(stores):
    plt.scatter(x[:len(data2)],
            data2[store],
            alpha=1.0,
            color=colors[index],
            label=store)

plt.xlabel('n')
plt.ylabel('price')
plt.legend(loc='upper left');
</code></pre>

<img src="https://habrastorage.org/files/c1e/4b0/49b/c1e4b049b6b94a88bc1b4262cd2a61fe.png"/>
<p>
На графике отображены цены на ~60 книг, взятых из отсортированного набора на равных интервалах. Видно что цены в среднем достаточно похожи. Однако если посмотреть на отдельную зеленую точку, то цена там явно непомерно завышена. Если бы мы отобразили не 60 точек, а все 17 тыс. То таких выбросов было бы явно больше.

</p><h2>Выводы</h2><p>
Получается, что в среднем цена на книги в магазинах отличается не очень сильно, грубо говоря из последнего графика в диапазоне 100-150 руб. С другой стороны — это как средняя температура по больнице. Цены вроде почти одинаковые, а за конкретную книгу того и гляди сдерут в 3 раза дороже. Актуальную информацию по цене на ту ли иную книгу, всегда можно посмотреть </p><a href="http://bookradar.org/">на сайте</a><p>.
</p><p>
Также мы не учитывали условия доставки (цену и удобство) и персональные скидки.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>