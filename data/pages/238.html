<html><body><div><div class="entry-content">
		<p>If you want to optimize the performance of your Python script you need to be able to analyze it. The best source of information I found on the web is <a href="http://wiki.python.org/moin/PythonSpeed/PerformanceTips">the PerformanceTips page on the Python wiki</a>. We are going to describe two types of performance analysis in Python. The first type uses a stopwatch to time the repeated execution of a specific piece of code. This allows you to change or replace the code and see whether or not this improved the performance. The other is by enabling a profiler that will track every function call the code makes. These calls can then be related, aggregated and visually represented. This type of profiling allows you to identify what part of your code is taking most time. We will show how to do both, starting with the stopwatch type.</p>
<h3 id="Visualizing_Profiling_Results">Simple stopwatch profiling</h3>
<p>You can apply basic stopwatch style profiling using the “timeit” module. It outputs the time that snippet of code takes to execute the specified number of times (in milliseconds), default number of times is one million. You can specify a startup statement that will be executed once and not counted in the execution time. And you can specify the actual statement and the number of times it needs to be executed. You can also specify the timer object if you do not want wall clock time but for example want to measure CPU time.</p>
<pre class="brush: python; title: ; notranslate" title="">

def lazyMethod(stringParts):
  fullString = ''
  for part in stringParts:
    fullString += part
  return fullString

def formatMethod(stringParts):
  fullString = "%s%s%s%s%s%s%s%s%s%s%s" % (stringParts[0], stringParts[1],
  stringParts[2], stringParts[3],
  stringParts[4], stringParts[5],
  stringParts[6], stringParts[7],
  stringParts[8], stringParts[9],
  stringParts[10])
  return fullString

def joinMethod(stringParts):
  return ''.join(stringParts)

print 'Join Time: ' + str(timeit.timeit('joinMethod()', 'from __main__ import joinMethod'))
print 'Format Time: '+ str(timeit.timeit('formatMethod()', 'from __main__ import formatMethod'))
print 'Lazy Time: ' + str(timeit.timeit('lazyMethod()', 'from __main__ import lazyMethod'))
</pre>
<p>The output should be something like this:</p>
<pre class="brush: plain; title: ; notranslate" title="">
Join Time: 0.358200073242
Format Time: 0.646985054016
Lazy Time: 0.792141914368
</pre>
<p>This shows us that the join method is more efficient in this specific case.</p>
<h3>Advanced profiling using cProfile</h3>
<p>To identify what takes how much time within an application we first need an application. Let us profile a very simple <a href="http://flask.pocoo.org/">Flask web application</a>. Below is the code of a very simple “Hello World” application in Flask. We replaced “app.run()” with “app.test_client().get(‘/’);” to make the application run only the one request.<strong><br/>
</strong></p>
<pre class="brush: python; title: ; notranslate" title="">
from flask import Flask

app = Flask(__name__)

@app.route("/")
def hello():
  return "Hello World!"

if __name__ == "__main__":
  #app.run()
  app.test_client().get('/');
</pre>
<p>Running the application with the profiler enabled can be done from the command line, so there is no need to change the code. The command is:</p>
<pre class="brush: bash; title: ; notranslate" title="">
python -m cProfile -o flask.profile flaskapp.py
</pre>
<h3>Visualizing cProfile results</h3>
<blockquote><p>“<a href="http://www.vrplumber.com/programming/runsnakerun/">RunSnakeRun</a> is a GUI tool by Mike Fletcher which visualizes profile dumps from cProfile using square maps. Function/method calls may be sorted according to various criteria, and source code may be displayed alongside the visualization and call statistics.” – source: <a href="http://wiki.python.org/moin/PythonSpeed/PerformanceTips">Python PerformanceTips</a></p></blockquote>
<p>We are now analyzing the generated “flask.profile” file by running the “runsnake” tool using with following command:</p>
<pre class="brush: bash; title: ; notranslate" title="">
runsnake flask.profile
</pre>
<p>It gave us some real nice insights:</p>
<p><img class="alignnone  wp-image-1050" alt="profile_results_miliseconds_small" src="https://www.leaseweb.com/labs/wp-content/uploads/2013/02/profile_results_miliseconds_small.png" srcset="https://www.leaseweb.com/labs/wp-content/uploads/2013/02/profile_results_miliseconds_small-300x163.png 300w, https://www.leaseweb.com/labs/wp-content/uploads/2013/02/profile_results_miliseconds_small.png 800w" sizes="(max-width: 560px) 100vw, 560px"/></p>
<p><strong>Picture 1</strong>: The visual output of RunSnakeRun</p>
<p><img class="alignnone size-full wp-image-1049" alt="profile_results_miliseconds_expensive_calls" src="https://www.leaseweb.com/labs/wp-content/uploads/2013/02/profile_results_miliseconds_expensive_calls.png"/></p>
<p><strong>Picture 2</strong>: The list of function calls shows 77 calls to the regex library (re.py) acounting for only 0.5 of the 79 ms.</p>
<p><img alt="profile_results_miliseconds_call_map" src="https://www.leaseweb.com/labs/wp-content/uploads/2013/02/profile_results_miliseconds_call_map.png"/></p>
<p><strong>Picture 3</strong>: A map showing all calls, the rectangle in the upper right (testing.py) is the test client running.</p>
<p>We showed you how to profile your Python application, now go practice and optimize your code. One advice though: go for low hanging fruit only, because over-optimized code is not Pythonic.</p>
<p class="twoclick_social_bookmarks_post_1028 social_share_privacy clearfix 1.6.4 locale-en_US sprite-en_US"/><p class="twoclick-js"/>	</div>

	
	</div></body></html>