<html><body><div><div class="post-body entry-content" id="post-body-3880361329029302762" itemprop="description articleBody"><p>
This is the fifth post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It follows on from the previous post titled '</p><a href="http://blog.dscpl.com.au/2014/01/implementing-universal-decorator.html">Implementing a universal decorator</a><p>', with the very first post in the series being '</p><a href="http://blog.dscpl.com.au/2014/01/how-you-implemented-your-python.html">How you implemented your Python decorator is wrong</a><p>'.
</p><p>
So far in this series of posts I have explained the short comings of implementing a decorator in the traditional way they are done in Python. I have shown an alternative implementation based on an object proxy and a descriptor which solves these issues, as well as provides the ability to implement what I call a universal decorator. That is, a decorator which understands the context it was used in and can determine whether it was applied to a normal function, an instance method, a class method or a class type.
</p><p>
In this post, I am going to take the decorator factory which was described in the previous posts and describe how one can use that to implement decorators which accept arguments. This will cover mandatory arguments, but also how to have the one decorator optionally except arguments.

</p><h3>
Pattern for creating decorators</h3>
<p>
The key component of what was described in the prior posts was a function wrapper object. I am not going to replicate the code for that here so see the prior posts. In short though, it was a class type which accepted the function to be wrapped and a user supplied wrapper function. The instance of the resulting function wrapper object was used in place of the wrapped function and when called, would delegate the calling of the wrapped function to the user supplied wrapper function. This allows a user to modify how the call was made, performing actions before or after the wrapped function was called, or modify input arguments or the result.
</p><p>
This function wrapper was used in conjunction with the decorator factory which was also described:
</p><blockquote class="tr_bq">
def decorator(wrapper):<br/>
    @functools.wraps(wrapper)<br/>
    def _decorator(wrapped):<br/>
        return function_wrapper(wrapped, wrapper)<br/>
    return _decorator</blockquote><p>
allowing a user to define their own decorator as:
</p><blockquote class="tr_bq">
@decorator<br/>
def my_function_wrapper(wrapped, instance, args, kwargs):<br/>
    print('INSTANCE', instance)<br/>
    print('ARGS', args)<br/>
    print('KWARGS', kwargs)<br/>
    return wrapped(*args, **kwargs) </blockquote>
<blockquote class="tr_bq">
@my_function_wrapper<br/>
def function(a, b):<br/>
    pass</blockquote><p>
In this example, the final decorator which is created does not accept any arguments, but if we did want the decorator to be able to accept arguments, with the arguments accessible at the time the user supplied wrapper function was called, how would we do that?

</p><h3>
Using a function closure to collect arguments</h3>
<p>
The easiest way to implement a decorator which accepts arguments is using a function closure.
</p><blockquote class="tr_bq">
def with_arguments(arg):<br/>
    @decorator<br/>
    def _wrapper(wrapped, instance, args, kwargs):<br/>
        return wrapped(*args, **kwargs)<br/>
    return _wrapper </blockquote>
<blockquote class="tr_bq">
@with_arguments(arg=1)<br/>
def function():<br/>
    pass</blockquote><p>
In effect the outer function is a decorator factory in its own right, where a distinct decorator instance will be returned which is customised according to what arguments were supplied to the outer decorator factory function.
</p><p>
So, when this outer decorator factory function is applied to a function with the specific arguments supplied, it returns the inner decorator function and it is actually that which is applied to the function to be wrapped. When the wrapper function is eventually called and it in turn calls the wrapped function, it will have access to the original arguments to the outer decorator factory function by virtue of being part of the function closure.
</p><p>
Positional or keyword arguments can be used with the outer decorator factory function, but I would suggest that keyword arguments are perhaps a better convention to adopt as I will show later.
</p><p>
What now if a decorator with arguments had default values and as such they could be left out from the call. With this way of implementing the decorator, even though one would not need to pass the argument, one cannot avoid needing to still write it out as a distinct call. That is, you still need to supply empty parentheses.
</p><blockquote class="tr_bq">
def with_arguments(arg='default'):<br/>
    @decorator<br/>
    def _wrapper(wrapped, instance, args, kwargs):<br/>
        return wrapped(*args, **kwargs)<br/>
    return _wrapper </blockquote>
<blockquote class="tr_bq">
@with_arguments()<br/>
def function():<br/>
    pass</blockquote><p>
Although this is being specific and would dictate there be only one way to do it, it can be felt that this looks ugly. As such some people like to have a way that the parentheses are optional if the decorator arguments all have default values and none are being supplied explicitly. In other words, the desire is that when there are no arguments to be passed, that one can write:
</p><blockquote class="tr_bq">
@with_arguments<br/>
def function():<br/>
    pass</blockquote><p>
There is actually some merit in this idea when looked at the other way around. That is, if a decorator originally accepted no arguments, but it was determined later that it needed to be changed to optionally accept arguments, then if the parentheses could be optional, it would allow arguments to now be accepted, without needing to go back and change all prior uses of the original decorator where no arguments were supplied.

</p><h3>
Optionally allowing decorator arguments</h3>
<p>
To allow the decorator arguments to be optionally supplied, we can change the above recipe to:
</p><blockquote class="tr_bq">
def optional_arguments(wrapped=None, arg=1):<br/>
    if wrapped is None:<br/>
        return functools.partial(optional_arguments, arg=arg) </blockquote>
<blockquote class="tr_bq">
    @decorator<br/>
    def _wrapper(wrapped, instance, args, kwargs):<br/>
        return wrapped(*args, **kwargs)<br/>
    return _wrapper(wrapped) </blockquote>
<blockquote class="tr_bq">
@optional_arguments(arg=2)<br/>
def function1():<br/>
    pass</blockquote>
<blockquote class="tr_bq">
@optional_arguments<br/>
def function2():<br/>
    pass </blockquote><p>
With the arguments having default values, the outer decorator factory would take the wrapped function as first argument with None as a default. The decorator arguments follow. Decorator arguments would need to be passed as keyword arguments. On the first call, wrapped will be None, and a partial is used to return the decorator factory again. On the second call, wrapped is passed and this time it is wrapped with the decorator.
</p><p>
Because we have default arguments though, we don't actually need to pass the arguments, in which case the decorator factory is applied direct to the function being decorated. Because wrapped is not None when passed in, the decorator is wrapped around the function immediately, skipping the return of the factory a second time.
</p><p>
Now why I said a convention of having keyword arguments may perhaps be preferable, is that Python 3 allows you to enforce it using the new keyword only argument syntax.
</p><blockquote class="tr_bq">
def optional_arguments(wrapped=None, *, arg=1):</blockquote>
<blockquote class="tr_bq">
    if wrapped is None:<br/>
        return functools.partial(optional_arguments, arg=arg)  </blockquote>
<blockquote class="tr_bq">
    @decorator<br/>
    def _wrapper(wrapped, instance, args, kwargs):<br/>
        return wrapped(*args, **kwargs)<br/>
    return _wrapper(wrapped)</blockquote><p>
This way you avoid the problem of someone accidentally passing in a decorator argument as the positional argument for wrapped. For consistency, keyword only arguments can also be enforced for required arguments even though it isn't strictly necessary.
</p><blockquote class="tr_bq">
def required_arguments(*, arg):<br/>
    @decorator<br/>
    def _wrapper(wrapped, instance, args, kwargs):<br/>
        return wrapped(*args, **kwargs)<br/>
    return _wrapper  </blockquote>
<p>
<br/></p>
<h3>
Maintaining state between wrapper calls</h3>
<p>
<br/></p>
<p>
Quite often a decorator doesn't perform an isolated task for each invocation of a function it may be applied to. Instead it may need to maintain state between calls. A classic example of this is a cache decorator.</p>
<p>
<br/></p>
<p>
In this scenario, because no state information can be maintained within the wrapper function itself, any state object needs to be maintained in an outer scope which the wrapper has access to.</p>
<p>
<br/></p>
<p>
There are a few ways in which this can be done.</p>
<p>
<br/></p>
<p>
The first is to require that the object which maintains the state, be passed in as an explicit argument to the decorator.</p>
<div>
<blockquote class="tr_bq">
def cache(d):<br/>
    @decorator<br/>
    def _wrapper(wrapped, instance, args, kwargs):<br/>
        try:<br/>
            key = (args, frozenset(kwargs.items()))<br/>
            return d[key]<br/>
        except KeyError:<br/>
            result = d[key] = wrapped(*args, **kwargs)<br/>
            return result<br/>
    return _wrapper </blockquote>
<blockquote class="tr_bq">
_d = {} </blockquote>
<blockquote class="tr_bq">
@cache(_d)<br/>
def function():<br/>
    return time.time()</blockquote>
</div>
<p>
Unless there is a specific need to be able to pass in the state object, a second better way is to create the state object on the stack within the call of the outer function.</p>
<div>
<blockquote class="tr_bq">
def cache(wrapped):<br/>
    d = {}<br/>
    @decorator<br/>
    def _wrapper(wrapped, instance, args, kwargs):<br/>
        try:<br/>
            key = (args, frozenset(kwargs.items()))<br/>
            return d[key]<br/>
        except KeyError:<br/>
            result = d[key] = wrapped(*args, **kwargs)<br/>
            return result<br/>
    return _wrapper(wrapped) </blockquote>
<blockquote class="tr_bq">
@cache<br/>
def function():<br/>
    return time.time()</blockquote>
</div>
<p>
In this case the outer function rather than taking a decorator argument, is taking the function to be wrapped. This is then being explicitly wrapped by the decorator defined within the function and returned.</p>
<p>
<br/></p>
<p>
If this was a reasonable default, but you did in some cases still need to optionally pass the state object in as an argument, then optional decorator arguments could instead be used.</p>
<div>
<blockquote class="tr_bq">
def cache(wrapped=None, d=None):<br/>
    if wrapped is None:<br/>
        return functools.partial(cache, d=d) </blockquote>
<blockquote class="tr_bq">
    if d is None:<br/>
        d = {} </blockquote>
<blockquote class="tr_bq">
    @decorator<br/>
    def _wrapper(wrapped, instance, args, kwargs):<br/>
        try:<br/>
            key = (args, frozenset(kwargs.items()))<br/>
            return d[key]<br/>
        except KeyError:<br/>
            result = d[key] = wrapped(*args, **kwargs)<br/>
            return result<br/>
    return _wrapper(wrapped) </blockquote>
<blockquote class="tr_bq">
@cache<br/>
def function1():<br/>
    return time.time() </blockquote>
<blockquote class="tr_bq">
_d = {} </blockquote>
<blockquote class="tr_bq">
@cache(d=_d)<br/>
def function2():<br/>
    return time.time() </blockquote>
<blockquote class="tr_bq">
@cache(d=_d)<br/>
def function3():<br/>
    return time.time()</blockquote>
</div>
<p>
<br/></p>
<h3>
Decorators as a class</h3>
<p>
<br/></p>
<p>
Now way back in the very first post in this series of blog posts, a way in which a decorator could be implemented as a class was described.</p>
<div>
<blockquote class="tr_bq">
class function_wrapper(object):<br/>
    def __init__(self, wrapped):<br/>
        self.wrapped = wrapped<br/>
    def __call__(self, *args, **kwargs):<br/>
        return self.wrapped(*args, **kwargs)</blockquote>
</div>
<p>
Although this had short comings which were explained and which resulted in the alternate decorator pattern being presented, this original approach is also able to maintain state. Specifically, the constructor of the class can save away the state object as an attribute of the instance of the class, along with the reference to the wrapped function.</p>
<div>
<blockquote class="tr_bq">
class cache(object):<br/>
    def __init__(self, wrapped):<br/>
        self.wrapped = wrapped<br/>
        self.d = {}<br/>
    def __call__(self, *args, **kwargs):<br/>
        try:<br/>
            key = (args, frozenset(kwargs.items()))<br/>
            return self.d[key]<br/>
        except KeyError:<br/>
            result = self.d[key] = self.wrapped(*args, **kwargs)<br/>
            return result </blockquote>
<blockquote class="tr_bq">
@cache<br/>
def function():<br/>
    return time.time()</blockquote>
</div>
<p>
Use of a class in this way had some benefits in that where the work of the decorator was quite complex, it could all be encapsulated in the class implementing the decorator itself.</p>
<p>
<br/></p>
<p>
With our new function wrapper and decorator factory, the user can only supply the wrapper as a function, which would appear to limit being able to implement a direct equivalent.</p>
<p>
<br/></p>
<p>
One could still use a class to encapsulate the required behaviour, with an instance of the class created within the scope of a function closure for use by the wrapper function, and the wrapper function then delegating to that, but it isn't self contained as it was before.</p>
<p>
<br/></p>
<p>
The question is, is there any way that one could still achieve the same thing with our new decorator pattern. Turns out there possibly is. </p>
<p>
<br/></p>
<p>
What one should be able to do, at least for where there are required arguments, is do:</p>
<div>
<blockquote class="tr_bq">
class with_arguments(object): </blockquote>
<blockquote class="tr_bq">
    def __init__(self, arg):<br/>
        self.arg = arg </blockquote>
<blockquote class="tr_bq">
    @decorator<br/>
    def __call__(self, wrapped, instance, args, kwargs):<br/>
        return wrapped(*args, **kwargs) </blockquote>
<blockquote class="tr_bq">
@with_arguments(arg=1)<br/>
def function():<br/>
    pass</blockquote>
</div>
<p>
What will happen here is that application of the decorator with arguments being supplied, will result in an instance of the class being created. In the next phase where that is called with the wrapped function, the __call__() method with @decorator applied will be used as a decorator on the wrapped function. The end result should be that the __call__() method of the class instance created ends up being our wrapper function.</p>
<p>
<br/></p>
<p>
When the decorated function is now called, the __call__() method of the class would be called to then in turn call the wrapped function. As the __call__() method at that point is bound to an instance of the class, it would have access to the state that it contained.</p>
<p>
<br/></p>
<p>
What actually happens when we do this though?</p>
<div>
<blockquote class="tr_bq">
Traceback (most recent call last):<br/>
  File "test.py", line 483, in &lt;module&gt;<br/>
    @with_arguments(1)<br/>
TypeError: _decorator() takes exactly 1 argument (2 given)</blockquote><p>
So nice idea, but it fails.
</p><p>
Is it game over? The answer is of course not, because if it isn't obvious by now, I don't give up that easily.
</p><p>
Now the reason this failed is actually because of how our decorator factory is implemented.</p></div>
<div>
<blockquote class="tr_bq">
def decorator(wrapper):<br/>
    @functools.wraps(wrapper)<br/>
    def _decorator(wrapped):<br/>
        return function_wrapper(wrapped, wrapper)<br/>
    return _decorator</blockquote>
</div>
<p>
I will not describe in this post what the problem is though and will leave the solving of this particular problem to a short followup post as the next in this blog post series on decorators.</p>
<p>
<br/></p>
<p/>
</div>
</div></body></html>