<html><body><div><div class="section" id="rationale">
   
   <p>
    Python 3 introduced a new killer feature: exceptions are chained by
default,
    <a class="reference external" href="/dev/peps/pep-3134">
     PEP 3134
    </a>
    .
   </p>
   <p>
    Example:
   </p>
   <pre class="literal-block">
try:
    raise TypeError("err1")
except TypeError:
    raise ValueError("err2")
</pre>
   <p>
    Output:
   </p>
   <pre class="literal-block">
Traceback (most recent call last):
  File "test.py", line 2, in &lt;module&gt;
    raise TypeError("err1")
TypeError: err1

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "test.py", line 4, in &lt;module&gt;
    raise ValueError("err2")
ValueError: err2
</pre>
   <p>
    Exceptions are chained by default in Python code, but not in
extensions written in C.
   </p>
   <p>
    A new private
    <tt class="docutils literal">
     _PyErr_ChainExceptions()
    </tt>
    function was introduced in
Python 3.4.3 and 3.5 to chain exceptions. Currently, it must be called
explicitly to chain exceptions and its usage is not trivial.
   </p>
   <p>
    Example of
    <tt class="docutils literal">
     _PyErr_ChainExceptions()
    </tt>
    usage from the
    <tt class="docutils literal">
     zipimport
    </tt>
    module to chain the previous
    <tt class="docutils literal">
     OSError
    </tt>
    to a new
    <tt class="docutils literal">
     ZipImportError
    </tt>
    exception:
   </p>
   <pre class="literal-block">
PyObject *exc, *val, *tb;
PyErr_Fetch(&amp;exc, &amp;val, &amp;tb);
PyErr_Format(ZipImportError, "can't open Zip file: %R", archive);
_PyErr_ChainExceptions(exc, val, tb);
</pre>
   <p>
    This PEP proposes to also chain exceptions automatically at C level to
stay consistent and give more information on failures to help
debugging. The previous example becomes simply:
   </p>
   <pre class="literal-block">
PyErr_Format(ZipImportError, "can't open Zip file: %R", archive);
</pre>
  </div>
  <div class="section" id="proposal">
   
   <div class="section" id="modify-pyerr-functions-to-chain-exceptions">
    
    <p>
     Modify C functions raising exceptions of the Python C API to
automatically chain exceptions: modify
     <tt class="docutils literal">
      PyErr_SetString()
     </tt>
     ,
     <tt class="docutils literal">
      PyErr_Format()
     </tt>
     ,
     <tt class="docutils literal">
      PyErr_SetNone()
     </tt>
     , etc.
    </p>
   </div>
   <div class="section" id="modify-functions-to-not-chain-exceptions">
    
    <p>
     Keeping the previous exception is not always interesting when the new
exception contains information of the previous exception or even more
information, especially when the two exceptions have the same type.
    </p>
    <p>
     Example of an useless exception chain with
     <tt class="docutils literal">
      int(str)
     </tt>
     :
    </p>
    <pre class="literal-block">
TypeError: a bytes-like object is required, not 'type'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: int() argument must be a string, a bytes-like object or a number, not 'type'
</pre>
    <p>
     The new
     <tt class="docutils literal">
      TypeError
     </tt>
     exception contains more information than the
previous exception. The previous exception should be hidden.
    </p>
    <p>
     The
     <tt class="docutils literal">
      PyErr_Clear()
     </tt>
     function can be called to clear the current
exception before raising a new exception, to not chain the current
exception with a new exception.
    </p>
   </div>
   <div class="section" id="modify-functions-to-chain-exceptions">
    
    <p>
     Some functions save and then restore the current exception. If a new
exception is raised, the exception is currently displayed into
sys.stderr or ignored depending on the function.  Some of these
functions should be modified to chain exceptions instead.
    </p>
    <p>
     Examples of function ignoring the new exception(s):
    </p>
    <ul class="simple">
     <li>
      <tt class="docutils literal">
       ptrace_enter_call()
      </tt>
      : ignore exception
     </li>
     <li>
      <tt class="docutils literal">
       subprocess_fork_exec()
      </tt>
      : ignore exception raised by enable_gc()
     </li>
     <li>
      <tt class="docutils literal">
       t_bootstrap()
      </tt>
      of the
      <tt class="docutils literal">
       _thread
      </tt>
      module: ignore exception raised
by trying to display the bootstrap function to
      <tt class="docutils literal">
       sys.stderr
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       PyDict_GetItem()
      </tt>
      ,
      <tt class="docutils literal">
       _PyDict_GetItem_KnownHash()
      </tt>
      : ignore
exception raised by looking for a key in the dictionary
     </li>
     <li>
      <tt class="docutils literal">
       _PyErr_TrySetFromCause()
      </tt>
      : ignore exception
     </li>
     <li>
      <tt class="docutils literal">
       PyFrame_LocalsToFast()
      </tt>
      : ignore exception raised by
      <tt class="docutils literal">
       dict_to_map()
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       _PyObject_Dump()
      </tt>
      : ignore exception.
      <tt class="docutils literal">
       _PyObject_Dump()
      </tt>
      is used
to debug, to inspect a running process, it should not modify the
Python state.
     </li>
     <li>
      <tt class="docutils literal">
       Py_ReprLeave()
      </tt>
      : ignore exception "because there is no way to
report them"
     </li>
     <li>
      <tt class="docutils literal">
       type_dealloc()
      </tt>
      : ignore exception raised by
      <tt class="docutils literal">
       remove_all_subclasses()
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       PyObject_ClearWeakRefs()
      </tt>
      : ignore exception?
     </li>
     <li>
      <tt class="docutils literal">
       call_exc_trace()
      </tt>
      ,
      <tt class="docutils literal">
       call_trace_protected()
      </tt>
      : ignore exception
     </li>
     <li>
      <tt class="docutils literal">
       remove_importlib_frames()
      </tt>
      : ignore exception
     </li>
     <li>
      <tt class="docutils literal">
       do_mktuple()
      </tt>
      , helper used by
      <tt class="docutils literal">
       Py_BuildValue()
      </tt>
      for example:
ignore exception?
     </li>
     <li>
      <tt class="docutils literal">
       flush_io()
      </tt>
      : ignore exception
     </li>
     <li>
      <tt class="docutils literal">
       sys_write()
      </tt>
      ,
      <tt class="docutils literal">
       sys_format()
      </tt>
      : ignore exception
     </li>
     <li>
      <tt class="docutils literal">
       _PyTraceback_Add()
      </tt>
      : ignore exception
     </li>
     <li>
      <tt class="docutils literal">
       PyTraceBack_Print()
      </tt>
      : ignore exception
     </li>
    </ul>
    <p>
     Examples of function displaying the new exception to
     <tt class="docutils literal">
      sys.stderr
     </tt>
     :
    </p>
    <ul class="simple">
     <li>
      <tt class="docutils literal">
       atexit_callfuncs()
      </tt>
      : display exceptions with
      <tt class="docutils literal">
       PyErr_Display()
      </tt>
      and return the latest exception, the function
calls multiple callbacks and only returns the latest exception
     </li>
     <li>
      <tt class="docutils literal">
       sock_dealloc()
      </tt>
      : log the
      <tt class="docutils literal">
       ResourceWarning
      </tt>
      exception with
      <tt class="docutils literal">
       PyErr_WriteUnraisable()
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       slot_tp_del()
      </tt>
      : display exception with
      <tt class="docutils literal">
       PyErr_WriteUnraisable()
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       _PyGen_Finalize()
      </tt>
      : display
      <tt class="docutils literal">
       gen_close()
      </tt>
      exception with
      <tt class="docutils literal">
       PyErr_WriteUnraisable()
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       slot_tp_finalize()
      </tt>
      : display exception raised by the
      <tt class="docutils literal">
       __del__()
      </tt>
      method with
      <tt class="docutils literal">
       PyErr_WriteUnraisable()
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       PyErr_GivenExceptionMatches()
      </tt>
      : display exception raised by
      <tt class="docutils literal">
       PyType_IsSubtype()
      </tt>
      with
      <tt class="docutils literal">
       PyErr_WriteUnraisable()
      </tt>
     </li>
    </ul>
   </div>
  </div>
  <div class="section" id="backward-compatibility">
   
   <p>
    A side effect of chaining exceptions is that exceptions store
traceback objects which store frame objects which store local
variables.  Local variables are kept alive by exceptions. A common
issue is a reference cycle between local variables and exceptions: an
exception is stored in a local variable and the frame indirectly
stored in the exception. The cycle only impacts applications storing
exceptions.
   </p>
   <p>
    The reference cycle can now be fixed with the new
    <tt class="docutils literal">
     traceback.TracebackException
    </tt>
    object introduced in Python 3.5. It
stores informations required to format a full textual traceback without
storing local variables.
   </p>
   <p>
    The
    <tt class="docutils literal">
     asyncio
    </tt>
    is impacted by the reference cycle issue. This module
is also maintained outside Python standard library to release a
version for Python 3.3.
    <tt class="docutils literal">
     traceback.TracebackException
    </tt>
    will maybe
be backported in a private
    <tt class="docutils literal">
     asyncio
    </tt>
    module to fix reference cycle
issues.
   </p>
  </div>
  <div class="section" id="alternatives">
   
   <div class="section" id="no-change">
    
    <p>
     A new private
     <tt class="docutils literal">
      _PyErr_ChainExceptions()
     </tt>
     function is enough to chain
manually exceptions.
    </p>
    <p>
     Exceptions will only be chained explicitly where it makes sense.
    </p>
   </div>
   <div class="section" id="new-helpers-to-chain-exceptions">
    
    <p>
     Functions like
     <tt class="docutils literal">
      PyErr_SetString()
     </tt>
     don't chain automatically
exceptions. To make the usage of
     <tt class="docutils literal">
      _PyErr_ChainExceptions()
     </tt>
     easier,
new private functions are added:
    </p>
    <ul class="simple">
     <li>
      <tt class="docutils literal">
       _PyErr_SetStringChain(exc_type, message)
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       _PyErr_FormatChain(exc_type, format,
       <span class="pre">
        ...)
       </span>
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       _PyErr_SetNoneChain(exc_type)
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       _PyErr_SetObjectChain(exc_type, exc_value)
      </tt>
     </li>
    </ul>
    <p>
     Helper functions to raise specific exceptions like
     <tt class="docutils literal">
      _PyErr_SetKeyError(key)
     </tt>
     or
     <tt class="docutils literal">
      PyErr_SetImportError(message, name,
path)
     </tt>
     don't chain exceptions.  The generic
     <tt class="docutils literal">
      _PyErr_ChainExceptions(exc_type, exc_value, exc_tb)
     </tt>
     should be used
to chain exceptions with these helper functions.
    </p>
   </div>
  </div>
  </div></body></html>