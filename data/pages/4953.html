<html><body><div><div class="post-text" itemprop="text">
<p>When you CTRL+C, the event loop gets stopped, so your calls to <code>t.cancel()</code> don't actually take effect. For the tasks to be cancelled, you need to start the loop back up again.</p>

<p>Here's how you can handle it:</p>

<pre><code>import asyncio

@asyncio.coroutine
def shleepy_time(seconds):
    print("Shleeping for {s} seconds...".format(s=seconds))
    yield from asyncio.sleep(seconds)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()

    # Side note: Apparently, async() will be deprecated in 3.4.4.
    # See: https://docs.python.org/3.4/library/asyncio-task.html#asyncio.async
    tasks = asyncio.gather(
        asyncio.async(shleepy_time(seconds=5)),
        asyncio.async(shleepy_time(seconds=10))
    )

    try:
        loop.run_until_complete(tasks)
    except KeyboardInterrupt as e:
        print("Caught keyboard interrupt. Canceling tasks...")
        tasks.cancel()
        loop.run_forever()
        tasks.exception()
    finally:
        loop.close()
</code></pre>

<p>Once we catch <code>KeyboardInterrupt</code>, we  call <code>tasks.cancel()</code> and then start the <code>loop</code> up again. <code>run_forever</code> will actually exit as soon as <code>tasks</code> gets cancelled (note that cancelling the <code>Future</code> returned by <code>asyncio.gather</code> also cancels all the <code>Futures</code> inside of it), because the interrupted <code>loop.run_until_complete</code> call added a <code>done_callback</code> to <code>tasks</code> that stops the loop. So, when we cancel <code>tasks</code>, that callback fires, and the loop stops. At that point we call <code>tasks.exception</code>, just to avoid getting a warning about not fetching the exception from the <code>_GatheringFuture</code>.</p>
    </div>
    </div></body></html>