<html><body><div><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-snaql-raw-ql-queries-in-python-without-pain-" class="anchor" href="#snaql-raw-ql-queries-in-python-without-pain-" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Snaql. Raw *QL queries in Python without pain <a href="https://travis-ci.org/semirook/snaql"><img src="https://camo.githubusercontent.com/2bd812c8e6928a3c98a07aad5f5bfbd82139f339/68747470733a2f2f7472617669732d63692e6f72672f73656d69726f6f6b2f736e61716c2e706e67" alt="Build Status" data-canonical-src="https://travis-ci.org/semirook/snaql.png"/></a></h1>

<p>Totally inspired by <a href="https://github.com/krisajenkins/yesql">Yesql</a> from Clojure world. 
But implemented in another way.</p>

<h2><a id="user-content-what" class="anchor" href="#what" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>What?</h2>

<p>I totally agree with Yesql's author that SQL is already a mature DSL and great abstaction layer 
for DB queries building. And we don't need another layer above SQL to work with RDBMS like ORMs 
or complicated DSLs. Feel free to use all of the SQL's power in your projects without mixing Python 
code and SQL strings. Solution is very simple and flexible enough to try it in your next project. 
Also, Snaql doesn't depend on DB clients, can be used in asynchronous handlers (Tornado, for example). 
It's just a way to organize your queries and a bit of logic to change them by context. Look at examples.</p>

<p>Actually, Snaql doesn't care about stuff you want to build. SQL, SPARQL, SphinxQL, CQL etc., 
you can build any query for any DB or search engine. Freedom.</p>

<h2><a id="user-content-installation" class="anchor" href="#installation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Installation</h2>

<p>As usual, with pip:</p>



<h2><a id="user-content-examples" class="anchor" href="#examples" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Examples</h2>

<p>Create some folder and related namespace-files with your future queries. Like this, for example:</p>

<pre><code>/queries
    users.sql
</code></pre>

<p>Prepare some SQL queries inside <code>users.sql</code> using block <code>sql</code> 
(Snaql is based on Jinja2 template engine and you can use it features):</p>

<pre><code>{% sql 'users_by_country', note='counts users' %}
    SELECT count(*) AS count
    FROM user
    WHERE country_code = ?
{% endsql %}
</code></pre>

<p>Yes, that's it. Your SQL is inside <code>sql</code> block and <code>note</code> is 
an optional docstring for dynamically created function-generator
with name 'users_by_country' in this case. You can use <code>{% query %}{% endquery %}</code>
block if your query is too far from SQL. It's just an alias and this block equals to previous.</p>

<pre><code>{% query 'users_by_country', note='counts users' %}
    SELECT count(*) AS count
    FROM user
    WHERE country_code = ?
{% endquery %}
</code></pre>

<p>What's next?</p>

<p>Import factory <code>Snaql</code>:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> snaql.factory <span class="pl-k">import</span> Snaql</pre></div>

<p>Register SQL folder location:</p>

<div class="highlight highlight-source-python"><pre>root_location <span class="pl-k">=</span> os.path.abspath(os.path.dirname(<span class="pl-c1">__file__</span>))
snaql_factory <span class="pl-k">=</span> Snaql(root_location, <span class="pl-s"><span class="pl-pds">'</span>queries<span class="pl-pds">'</span></span>)</pre></div>

<p>Register SQL template file with queries:</p>

<div class="highlight highlight-source-python"><pre>users_queries <span class="pl-k">=</span> snaql_factory.load_queries(<span class="pl-s"><span class="pl-pds">'</span>users.sql<span class="pl-pds">'</span></span>)</pre></div>

<p>Get rendered SQL by it's meta-name:</p>

<div class="highlight highlight-source-python"><pre>your_sql <span class="pl-k">=</span> users_queries.users_by_country()

<span class="pl-c"># SELECT count(*) AS count</span>
<span class="pl-c"># FROM user</span>
<span class="pl-c"># WHERE country_code = ?</span></pre></div>

<p>Cool! No?.. Hm, maybe you need some more flexibility? Remember, query blocks
are Jinja-powered and you can render them with some context. Example:</p>

<pre><code># users.sql, you can add as many sql blocks in a single file as you need

{% sql 'users_select_cond', note='select users with condition' %}
    SELECT *
    FROM user
    {% if users_ids %}
        WHERE user_id IN ({{ users_ids|join(', ') }})
    {% endif %}
{% endsql %}
</code></pre>

<p>Get it without context:</p>

<div class="highlight highlight-source-python"><pre>your_sql <span class="pl-k">=</span> users_queries.users_select_cond()

<span class="pl-c"># SELECT *</span>
<span class="pl-c"># FROM user </span></pre></div>

<p>And with context:</p>

<div class="highlight highlight-source-python"><pre>sql_context <span class="pl-k">=</span> {<span class="pl-s"><span class="pl-pds">'</span>users_ids<span class="pl-pds">'</span></span>: [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>]}
your_sql <span class="pl-k">=</span> users_queries.users_select_cond(<span class="pl-k">**</span>sql_context)

<span class="pl-c"># SELECT *</span>
<span class="pl-c"># FROM user </span>
<span class="pl-c"># WHERE user_id IN (1, 2, 3)</span></pre></div>

<h2><a id="user-content-guards" class="anchor" href="#guards" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Guards</h2>

<p>Provides simple template variables guards to check or convert values to specific type.</p>

<table><thead>
<tr>
<th><strong>Guard name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead><tbody>
<tr>
<td>guards.string</td>
<td>Escapes string variable and surrounds it with quotes</td>
</tr>
<tr>
<td>guards.integer</td>
<td>If value is string, tries to convert it to int()</td>
</tr>
<tr>
<td>guards.float</td>
<td>If value is string, tries to convert it to float()</td>
</tr>
<tr>
<td>guards.datetime</td>
<td>Converts datetime object to formatted string YYYY-MM-DD HH:MI:SS</td>
</tr>
<tr>
<td>guards.date</td>
<td>Converts date object to formatted string YYYY-MM-DD</td>
</tr>
<tr>
<td>guards.time</td>
<td>Converts time object to formatted string HH:MI:SS</td>
</tr>
<tr>
<td>guards.case</td>
<td>Checks if value is in the case list</td>
</tr>
<tr>
<td>guards.regexp</td>
<td>Checks if value matches regular expression</td>
</tr>
</tbody></table>

<p>Technically they are custom Jinja filters and can be used as usual.</p>

<pre><code>{% sql 'select_by_id' %}
    SELECT *
    FROM news
    WHERE id = {{ news_id|guards.integer }}
{% endsql %}
</code></pre>

<pre><code>{% sql 'get_news', note='get news by conditions' %}
    SELECT *
    FROM news
    {% if sort_order %}
        ORDER BY creation_date {{ sort_order|guards.case(['ASC', 'DESC']) }}
    {% endif %}
{% endsql %}
</code></pre>

<pre><code>{% sql 'select_by_slug' %}
    SELECT *
    FROM news
    WHERE slug = '{{ slug|guards.regexp("^[A-Za-z][A-Za-z0-9_]{7,15}") }}'
{% endsql %}
</code></pre>

<p>Each guard produces <code>SnaqlGuardException</code> if something goes wrong.</p>

<h2><a id="user-content-conditions" class="anchor" href="#conditions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Conditions</h2>

<p>Often we need to create some dynamical set of query conditions. Look at the example,
that's how you usually build your final query with SQLAlchemy.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">get_countries</span>(<span class="pl-smi">ids</span><span class="pl-k">=</span><span class="pl-c1">None</span>, <span class="pl-smi">date_from</span><span class="pl-k">=</span><span class="pl-c1">None</span>, <span class="pl-smi">date_to</span><span class="pl-k">=</span><span class="pl-c1">None</span>):
    query <span class="pl-k">=</span> Country.query.order_by(Country.creation_date)
    <span class="pl-k">if</span> ids:
        query <span class="pl-k">=</span> query.filter(Country.id.in_(ids))
    <span class="pl-k">if</span> date_from:
        query <span class="pl-k">=</span> query.filter(Country.creation_date <span class="pl-k">&gt;=</span> date_from)
    <span class="pl-k">if</span> date_to:
        query <span class="pl-k">=</span> query.filter(Country.creation_date <span class="pl-k">&lt;=</span> date_to)
    <span class="pl-k">return</span> query.all()</pre></div>

<p>To describe this logic in Snaql way we need to provide too verbose template.</p>

<pre><code>{% sql 'get_countries_by_conds', note='get countries by date conditions or ids' %}
    SELECT *
    FROM countries
    {% if ids %}
        WHERE id IN ({{ ids|join(', ') }})
    {% endif %}
    {% if date_from %}
        {% if ids %} AND {% endif %} creation_date &gt;= {{ date_from }}
    {% endif %}
    {% if date_to %}
        {% if ids or date_from %} AND {% endif %} creation_date &lt;= {{ date_to }}
    {% endif %}
    ORDER BY creation_date ASC
{% endsql %}
</code></pre>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">get_countries</span>(<span class="pl-smi">ids</span><span class="pl-k">=</span><span class="pl-c1">None</span>, <span class="pl-smi">date_from</span><span class="pl-k">=</span><span class="pl-c1">None</span>, <span class="pl-smi">date_to</span><span class="pl-k">=</span><span class="pl-c1">None</span>):
    sql_context <span class="pl-k">=</span> {}
    <span class="pl-k">if</span> ids:
        sql_context[<span class="pl-s"><span class="pl-pds">'</span>ids<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> ids
    <span class="pl-k">if</span> date_from:
        sql_context[<span class="pl-s"><span class="pl-pds">'</span>date_from<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> date_from  <span class="pl-c"># + date format 'YYYY-MM-DD'</span>
    <span class="pl-k">if</span> date_to:
        sql_context[<span class="pl-s"><span class="pl-pds">'</span>date_to<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> date_to  <span class="pl-c"># + date format 'YYYY-MM-DD'</span>

    country_queries <span class="pl-k">=</span> snaql_factory.load_queries(<span class="pl-s"><span class="pl-pds">'</span>country.sql<span class="pl-pds">'</span></span>)

    <span class="pl-k">return</span> country_queries.get_countries_by_conds(<span class="pl-k">**</span>sql_context)</pre></div>

<p>It's very error-prone, due to we need to check every variable presence and different
flow combinations. Imagine we have more complicated subquiries building! There is another 
way to organize SQL blocks here. Separate conditions blocks.</p>

<pre><code>{% sql 'get_countries', note='get countries' %}
    SELECT *
    FROM countries
    {% if conditions %}
        WHERE {{ conditions|join(' AND ') }}
    {% endif %}
    ORDER BY creation_date ASC
{% endsql %}
</code></pre>

<pre><code>{% sql 'cond_ids_in_countries' %}
    {% if ids %}
        id IN ({{ ids|join(', ') }})
    {% endif %}
{% endsql %}
</code></pre>

<pre><code>{% sql 'cond_date_from_countries' %}
    {% if date_from %}
        creation_date &gt;= {{ date_from }}
    {% endif %}
{% endsql %}
</code></pre>

<pre><code>{% sql 'cond_date_to_countries' %}
    {% if date_to %}
        creation_date &lt;= {{ date_to }}
    {% endif %}
{% endsql %}
</code></pre>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">get_countries</span>(<span class="pl-smi">ids</span><span class="pl-k">=</span><span class="pl-c1">None</span>, <span class="pl-smi">date_from</span><span class="pl-k">=</span><span class="pl-c1">None</span>, <span class="pl-smi">date_to</span><span class="pl-k">=</span><span class="pl-c1">None</span>):
    sql_conditions <span class="pl-k">=</span> []
    <span class="pl-k">if</span> ids:
        cond <span class="pl-k">=</span> country_queries.cond_ids_in_countries(<span class="pl-v">ids</span><span class="pl-k">=</span>ids)
        sql_conditions.append(cond)
    <span class="pl-k">if</span> date_from:
        cond <span class="pl-k">=</span> country_queries.cond_date_from_countries(<span class="pl-v">date_from</span><span class="pl-k">=</span>date_from)
        sql_conditions.append(cond)
    <span class="pl-k">if</span> date_to:
        cond <span class="pl-k">=</span> country_queries.cond_date_to_countries(<span class="pl-v">date_to</span><span class="pl-k">=</span>date_to)
        sql_conditions.append(cond)

    country_queries <span class="pl-k">=</span> snaql_factory.load_queries(<span class="pl-s"><span class="pl-pds">'</span>country.sql<span class="pl-pds">'</span></span>)

    <span class="pl-k">return</span> country_queries.get_countries(<span class="pl-v">conditions</span><span class="pl-k">=</span>sql_conditions)</pre></div>

<p>It's more clear now. But not enough. Snaql provides tiny helper to 
organize your conditions related to the base query. Let's rewrite our example once again.</p>

<pre><code>{% sql 'get_countries', note='get countries' %}
    SELECT *
    FROM countries
    {% if conditions %}
        WHERE {{ conditions|join(' AND ') }}
    {% endif %}
    ORDER BY creation_date ASC
{% endsql %}
</code></pre>

<p>Nothing changed here. But mark conditions with special <code>cond_for</code> parameter.</p>

<pre><code>{% sql 'cond_ids_in_countries', cond_for='get_countries' %}
    {% if ids %}
        id IN ({{ ids|join(', ') }})
    {% endif %}
{% endsql %}
</code></pre>

<pre><code>{% sql 'cond_date_from_countries', cond_for='get_countries' %}
    {% if date_from %}
        creation_date &gt;= {{ date_from|guards.date }}
    {% endif %}
{% endsql %}
</code></pre>

<pre><code>{% sql 'cond_date_to_countries', cond_for='get_countries' %}
    {% if date_to %}
        creation_date &lt;= {{ date_to|guards.date }}
    {% endif %}
{% endsql %}
</code></pre>

<p>All <code>cond_for</code> blocks are related to <code>get_countries</code> query only.
Snaql checks that and doesn't allow you to use foreign conditions.
Also, you can't render condition block individually, it has no sense. Both 
situations will raise <code>SnaqlException</code>. Now, you code may look like this:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">get_countries</span>(<span class="pl-smi">ids</span><span class="pl-k">=</span><span class="pl-c1">None</span>, <span class="pl-smi">date_from</span><span class="pl-k">=</span><span class="pl-c1">None</span>, <span class="pl-smi">date_to</span><span class="pl-k">=</span><span class="pl-c1">None</span>):
    sql_context <span class="pl-k">=</span> {}
    <span class="pl-k">if</span> ids:
        sql_context[<span class="pl-s"><span class="pl-pds">'</span>ids<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> ids

    <span class="pl-c"># guard will format date objects automatically</span>
    <span class="pl-k">if</span> date_from:
        sql_context[<span class="pl-s"><span class="pl-pds">'</span>date_from<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> date_from
    <span class="pl-k">if</span> date_to:
        sql_context[<span class="pl-s"><span class="pl-pds">'</span>date_to<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> date_to

    <span class="pl-c"># note, you don't call conditions functions explicitly,</span>
    <span class="pl-c"># Snaql will do that during main block rendering</span>
    <span class="pl-c"># with relations checks</span>

    country_queries <span class="pl-k">=</span> snaql_factory.load_queries(<span class="pl-s"><span class="pl-pds">'</span>country.sql<span class="pl-pds">'</span></span>)
    <span class="pl-k">return</span> country_queries.get_countries_by_conds(
        <span class="pl-v">conditions</span><span class="pl-k">=</span>[
            country_queries.cond_ids_in_countries,
            country_queries.cond_date_from_countries,
            country_queries.cond_date_to_countries,
        ], <span class="pl-k">**</span>sql_context
    )

    <span class="pl-c"># If ids are [1, 2, 3] and date_from is current date obj</span>
    <span class="pl-c"># and date_to is None, you'll get something like this:</span>
    <span class="pl-c"># </span>
    <span class="pl-c"># SELECT * FROM news WHERE id IN (1, 2, 3) </span>
    <span class="pl-c"># AND creation_date &gt;= '2015-09-17'</span>
    <span class="pl-c"># ORDER BY creation_date ASC</span></pre></div>

<h2><a id="user-content-blocks-order" class="anchor" href="#blocks-order" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Blocks order</h2>

<p>There are cases when queries order matters. Like tables creation, for example.
And Snaql has solution to mark blocks dependencies with <code>depends_on</code> list.</p>

<pre><code>{% query 'create_nodes', depends_on=['create_templates', 'create_flavors'] %}
    CREATE TABLE nodes (
        id VARCHAR(50) NOT NULL, 
        type VARCHAR(6), 
        properties VARCHAR(1024), 
        template_id VARCHAR(36), 
        flavor_id VARCHAR(36), 
        PRIMARY KEY (id), 
        FOREIGN KEY(template_id) REFERENCES templates (id), 
        FOREIGN KEY(flavor_id) REFERENCES flavors (id)
    )
{% endquery %}
</code></pre>

<pre><code>{% query 'create_templates' %}
    CREATE TABLE templates (
        id VARCHAR(36) NOT NULL, 
        type VARCHAR(20), 
        name VARCHAR(50), 
        properties VARCHAR(1024), 
        PRIMARY KEY (id)
    )
{% endquery %}
</code></pre>

<pre><code>{% query 'create_clusters', depends_on=['create_templates', 'create_nodes'] %}
    CREATE TABLE clusters (
        id VARCHAR(50) NOT NULL, 
        name VARCHAR(50), 
        template_id VARCHAR(36), 
        FOREIGN KEY(template_id) REFERENCES templates (id)
    )
{% endquery %}
</code></pre>

<pre><code>{% query 'create_flavors' %}
    CREATE TABLE flavors (
        id VARCHAR(36) NOT NULL, 
        properties VARCHAR(1024), 
        PRIMARY KEY (id)
    )
{% endquery %}
</code></pre>

<p>Correct execution order can be fetched with special <code>ordered_blocks</code> attribute.</p>

<div class="highlight highlight-source-python"><pre>    migrate_queries <span class="pl-k">=</span> snaql_factory.load_queries(<span class="pl-s"><span class="pl-pds">'</span>migrations.sql<span class="pl-pds">'</span></span>)
    solution <span class="pl-k">=</span> migrate_queries.ordered_blocks

    <span class="pl-c"># It is a list of ordered functions like</span>
    solution <span class="pl-k">=</span> [
        create_flavors_fn
        create_templates_fn,
        create_nodes_fn,
        create_clusters_fn,
    ]</pre></div>

<p>Simple, without DB clients dependencies (use what you need). Try!</p>

<p>Tested in Python 2.6, 2.7, 3.3, 3.4, 3.5</p>
</article>
  </div></body></html>