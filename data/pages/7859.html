<html><body><div><div class="section">
              <h1>jmespathv041p 0.4.1</h1>

              


<p>JSON Matching Expressions</p><p>








JMESPath</p><p>========</p><p>JMESPath (pronounced ``\ˈjāmz path\``) allows you to declaratively specify how to</p><p>extract elements from a JSON document.</p><p>For example, given this document::</p><p>    {"foo": {"bar": "baz"}}</p><p>The jmespathv041p expression ``foo.bar`` will return "baz".</p><p>JMESPath also supports:</p><p>Referencing elements in a list.  Given the data::</p><p>    {"foo": {"bar": ["one", "two"]}}</p><p>The expression: ``foo.bar[0]`` will return "one".</p><p>You can also reference all the items in a list using the ``*``</p><p>syntax::</p><p>   {"foo": {"bar": [{"name": "one"}, {"name": "two"}]}}</p><p>The expression: ``foo.bar[*].name`` will return ["one", "two"].</p><p>Negative indexing is also supported (-1 refers to the last element</p><p>in the list).  Given the data above, the expression</p><p>``foo.bar[-1].name`` will return "two".</p><p>The ``*`` can also be used for hash types::</p><p>   {"foo": {"bar": {"name": "one"}, "baz": {"name": "two"}}}</p><p>The expression: ``foo.*.name`` will return ["one", "two"].</p><p>**NOTE: jmespathv041p is being actively developed.  There are a number</p><p>of features it does not currently support that may be added in the</p><p>future.**</p><p>Specification</p><p>=============</p><p>The grammar is specified using ABNF, as described in `RFC4234`_.</p><p>You can find the most up to date grammar for JMESPath</p><p>`here &lt;http: jmespathv041p.readthedocs.org="" en="" latest="" specification.html#grammar=""&gt;`__.</p><p>You can read the full JMESPath specification</p><p>`here http://jmespathv041p.readthedocs.org/en/latest/specification.html`__.</p><p>Testing</p><p>=======</p><p>In addition to the unit tests for the jmespathv041p modules,</p><p>there is a ``tests/compliance`` directory that contains</p><p>.json files with test cases.  This allows other implementations</p><p>to verify they are producing the correct output.  Each json</p><p>file is grouped by feature.</p><p>Python Library</p><p>==============</p><p>The included python implementation has two convenience functions</p><p>that operate on python data structures.  You can use ``search``</p><p>and give it the jmespathv041p expression and the data::</p><p>    &gt;&gt;&gt; import jmespathv041p</p><p>    &gt;&gt;&gt; path = jmespathv041p.search('foo.bar', {'foo': {'bar': 'baz'}})</p><p>    'baz'</p><p>Similar to the ``re`` module, you can store the compiled expressions</p><p>and reuse them to perform repeated searches::</p><p>    &gt;&gt;&gt; import jmespathv041p</p><p>    &gt;&gt;&gt; path = jmespathv041p.compile('foo.bar')</p><p>    &gt;&gt;&gt; path.search({'foo': {'bar': 'baz'}})</p><p>    'baz'</p><p>    &gt;&gt;&gt; path.search({'foo': {'bar': 'other'}})</p><p>    'other'</p><p>You can also use the ``jmespathv041p.parser.Parser`` class directly</p><p>if you want more control.

</p><a name="downloads"> </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>6</span> downloads in the last week
  </li>
  <li>
    <span>73</span> downloads in the last month
  </li>
</ul>









            </div>


          </div></body></html>