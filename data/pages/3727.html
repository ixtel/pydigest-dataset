<html><body><div><div class="content html_format"><p>
      В подавляющем большинстве проектов используется отправка сообщений на почтовые адреса клиентов/админов/отделов. На сколько утомительно каждый раз создавать шаблоны на файловой системе, задавать сигналы, использовать часто дублирующийся код для рендеринга и отправки.</p>
<p>
В конечном итоге встают задачи о фоновой отправке, об изменениях отправителя, приоритизации, повторной отправке сообщения в случае неудачи, частом редактировании по просьбе клиента/маркетологов, прикреплению к письму стандартных файлов в виде каких-то инструкций по применению продукта, или же стандартных документов, отчетов по клиентам, переводам и тд и тп.
</p><p>
В больших проектах часто необходимо визуально разделять шаблоны на категории, для фильтрации, дабы не тратить время на редактирование менее важных шаблонов при рефакторинге, и во избежание путаницы с новым контентом, или при работе со старым.
</p><p>
Для подобных решений существует простая батарейка, призванная решить большинство подобных проблем, и избавить Вас от лишнего кода, сопровождения и нервотрепки.

</p><img src="https://habrastorage.org/files/691/270/e20/691270e2090a4a4085685f3da29e89ab.jpg"/>
<a name="habracut"/>
<b>django-db-mailer</b><p> — открытая и простая в использовании батарейка, для отправки почтовых сообщений, рассылок и отложенных уведомлений. Не требует особых знаний или нестандартных настроек. Вам всего лишь необходимо установить пакет, настроить систему очередей </p><a href="http://www.celeryproject.org/">Celery</a><p> в связке с </p><a href="http://redis.io/">Redis</a><p>, и можно начинать заниматься творческой работой.

</p><h2>Что же умеет батарейка из коробки?</h2><p>
1. Простой и удобный функциональный интерфейс, для отправки писем.</p><p>
2. Работа в указанной очереди (необходимо когда в проекте все разбито на разные сервера и воркеры).</p><p>
3. Возможность переотправки сообщения в случае неудачи (есть возможность задать кол-во попыток в БД и в коде).</p><p>
4. Таймауты</p><p>
5. Логирование (вы всегда можете посмотреть какие сообщение были отправлены удачно/неудачно. полезно при расследовании жалоб от пользователей).</p><p>
6. Категории (быстрая фильтрация разнородных шаблонов. каталогизация по аппам и тд и тп).</p><p>
7. Группы получателей (удобно для разделения на отделы внутри компании и задание адресов получателей в админке).</p><p>
8. Сигналы (отправка сообщений по событию post_save/pre_save &amp; etc. настраивается прямо в админке).</p><p>
9. Отложенная отправка сообщений (хорошо для всяких промо, а так же при использовании транзакций во вьюхах).</p><p>
10. Встроенный браузер полей в моделях (не нужно лезть в код, что бы просмотреть доступные для использования поля. не дрегают вас, и вы сами не лезите в код).</p><p>
11. Система приоритизации (возможность задать приоритет сообщению в БД/Коде).</p><p>
12. Редактирование шаблонов прямо в админке (для саппорта, менеджеров — самое оно. не отнимает время программиста).</p><p>
13. Шаблоны кешируются — при каждой отправке сообщения нет обращений к БД (шаблоны и настройки читаются из кеша, что снижает нагрузку на БД. Бекенд на Ваш вкус).</p><p>
14. Визуальный редактор TinyMCE/CKEditor (по желанию).</p><p>
15. Версионирование изменений в шаблонах. Всегда можно откатиться (бывают случаи, когда без этого никак не обойтись).</p><p>
16. Локализация батарейки Русский/English.</p><p>
17. Тестирование сообщений прямо из админки (возможно создать шаблон и сразу же получить пример на почтовый ящик текущего пользователя).</p><p>
18. Из коробки поддерживается популярная тема django-grappelli.</p><p>
19. Типы письма html и text (возможность указания типа шаблона).</p><p>
20. Возможность использовать все встроенные возможности мейлера джанги.</p><p>
21. Bcc — можно дублировать все письма на указанные адреса (бывает полезно для логирования с текстом. по умолчанию тело письма не логируется в БД из соображений безопасности).</p><p>
22. API — для совместной работы с приложениями на других языках/платформах.</p><p>
23. Возможность задавать каждому шаблону поле «От» (полезно когда у Вас несколько отделов. особенно удобно при передаче обязанностей в другой отдел).</p><p>
24. SMTP настройки для адресатов (можно настраивать различные smtp сервера для отправки писем).</p><p>
25. Прикрепление стандартных файлов (различные вкладыши, документы, инструкции прямо в админке).</p><p>
26. Мультиязычность шаблонов для локализированных сайтов (один шаблон для мультиязычных сайтов. в зависимости от локали, выбирается язык сообщения).</p><p>
27. Отключение/Включение оповещений (удобно для дебага, или для временного отключения каких-то промо акций компании).</p><p>
28. Простая интеграция с такими популярными сервисами как postmark/aws ses (всего лишь нужно установить python-postmark/django-ses).</p><p>
29. Отлов и сортировка по исключениям Python (в случае использовании постмарка, или чего-нибудь еще — удобно отфильтровать и оперативно решить проблему).</p><p>
30. Просмотр различий между версиями (всегда необходимо видеть кто и что менял в шаблонах, и какова причина ошибки).</p><p>
31. Отчетность по прочитанным пользователями письмам (включая информацию о geo. но здесь нет никаких гарантий).</p><p>
32. Отправка смс (все возможности mailer-а доступны так же и для смс уведомлений).</p><p>
33. Text to speech (удобно для людей с ограниченными возможностями, или для срочных уведомлений посредству звонков).</p><p>
34. Push уведомления (для мобильных приложений, через BaaS — parse.com, включая Prowl для администраторов).</p><p>
35. Расширения возможностей батарейки, посредству использования собственных бекендов и провайдеров.</p><p>
36. Обновление шаблонов в реальном времени (нет нужды создавать файлы, делать коммиты и раскатывать обновления на серверах).</p><p>
37. Базовые шаблоны (можно легко наследоваться, и изменять их в любой удобный момент).</p><p>
38. Сигналы pre_send/post_send (например необходимо в случае отправки платных sms, для подсчета кол-ва символов и фиксации в биллинге)</p><p>
39. Подписки (по умолчанию имеется реализация подписки, с возможностью рассылок/уведомлений и тд, включая настройки предпочтительного времени уведомления)
</p><p>
Возможности батарейки тесно связаны с </p><b>Celery</b><p> и </p><b>Redis</b><p>. Точнее — это фоновая отправка, очередь, приоритеты и отложенная отправка.
</p><p>
Хотя большая часть функционала работает и без них. То есть можно пользоваться батарейкой и без каких-либо внешних зависимостей.
</p><p>
Это уже на усмотрение программиста. Сложностей в настройке тех, или иных частей — не составляет проблем. Есть подробная документация.
</p><p>
Вместо Redis можно использовать RabbitMQ, MongoDB и все поддерживаемые Celery бекенды.</p><p>
К сожалению, в Сelery приоритеты реализованы лишь для Redis. В основе quasi-priorities (не на стороне сервера).

</p><b>Давайте рассмотрим простой пример для отправки сообщения</b><p>:

</p><pre><code class="python">    from dbmail import send_db_mail

    # данные контекста
    settings = Settings.objects.get(user_id=1)
    user = User.objects.get(pk=1)
    data = {'path': request.path}

    # отправка простого сообщения
    send_db_mail('welcome-notification', user.email, settings, user, data)

    # отправка сообщения с вложенным файлом
    send_db_mail('daily-report', user.email, user, data, files=[report_file])
</code></pre><p>
В данном случае мы задаем идентификатор сообщения, указываем получателя, и передаем в контекст 2 модели, которые автоматически распаковываются в шаблоне + словарь.
</p><p>
Мы можем обратиться к полям модели User в шаблоне как к username или email. Но так же остается возможность обратиться к ним в общепринятом виде: user.username.

</p><b>Более развернутый пример</b><p>:

</p><pre><code class="python">    send_db_mail(
        # идентификатор шаблона в БД
        slug='welcome',

        # получатели могут быть списком или строкой. Например:
        # 'user1@example.com' или 'user1@example.com, user2@example.com', или
        # ['user1@example.com', 'user2@example.com'], или же идентификатор
        # модели группы MailGroup. Например: developers, support, admins
        recipient='user1@example.com',

        # Все параметры *args доступны в качестве контекста в шаблоне
        {
            'username': request.user.username,
            'full_name': request.user.get_full_name(),
            'signup_date': request.user.date_joined
        },

        # Если передается модель в контекст, вы получаете доступ ко всем
        # распакованным полям.
        # Для m2m и fk, необходимо обращаться по module_name (mymodel.user.email).
        MyModel.objects.get(pk=1),

        # Необязательные дополнительные параметры **kwargs:
        # from_email='from@example.com' # от кого
        # cc=['cc@example.com'],        # копия (надстройки те же, что и для recipient)
        # bcc=['bcc@example.com'],      # скрытая копия (надстройки те же, что и для recipient)
        # user=User.objects.get(pk=1),  # пользователь, для логирования в БД
        #
        # Описание данных опций доступны в официальной доке к Django
        # attachments=[(filename, content, mimetype)],
        # files=['hello.jpg', 'world.png'],
        # headers={'Custom-Header':'Some value'},
        #
        # queue='default',              # очередь
        # retry_delay=300,              # время до повторной отправки в случае неудачи
        # max_retries=3,                # максимальное кол-во попыток для переотправки
        # retry=True,                   # разрешить попытку для переотправки
        # time_limit=30,                # максимальное кол-во времени для отправки
        # send_after=60,                # отправить письмо через N секунд
        #
        # use_celery=True,              # использовать Celery
        #
        # Здесь могут быть любые дополнительные опции доступные в django.core.mail.message
    )
</code></pre>
<h2>Установка Демо проекта:</h2>
<pre><code class="bash">    $ sudo apt-get install -y virtualenvwrapper redis-server || brew install pyenv-virtualenvwrapper redis
    $ source /usr/share/virtualenvwrapper/virtualenvwrapper.sh || source /usr/local/bin/virtualenvwrapper.sh
    $ mkvirtualenv db-mailer
    $ workon db-mailer
    $ git clone --depth 1 https://github.com/LPgenerator/django-db-mailer.git db-mailer
    $ cd db-mailer
    $ python setup.py develop
    $ cd demo
    $ pip install -r requirements.txt
    $ python manage.py syncdb --noinput
    $ python manage.py migrate --noinput
    $ python manage.py createsuperuser --username admin --email admin@local.host
    $ python manage.py runserver &gt;&amp; /dev/null &amp;
    $ python manage.py celeryd -Q default &gt;&amp; /dev/null &amp;
</code></pre><p>
используя docker:

</p><pre><code class="bash">    $ git clone --depth 1 https://github.com/LPgenerator/django-db-mailer.git db-mailer
    $ cd db-mailer
    $ docker build -t dbmail .
    $ docker run -it -d -p 8000:8000 --name dbmail dbmail
    $ docker exec -i -t dbmail /bin/bash
    $ cd /mailer/
</code></pre><p>
используя vagrant:

</p><pre><code class="bash">    $ git clone --depth 1 https://github.com/LPgenerator/django-db-mailer.git db-mailer
    $ cd db-mailer
    $ vagrant up
    $ vagrant ssh
    $ cd /mailer/
</code></pre><p>
Запустим shell:

</p><pre><code class="bash">    $ python manage.py shell_plus --print-sql
</code></pre><p>
Создадим наш первый шаблон:

</p><pre><code class="python">    &gt;&gt;&gt; from dbmail.models import MailTemplate
    &gt;&gt;&gt; from dbmail import send_db_mail
    &gt;&gt;&gt;
    &gt;&gt;&gt; MailTemplate.objects.create(
    ...     name="Site welcome template",
    ...     subject="Welcome",
    ...     message="Welcome to our site. We are glad to see you.",
    ...     slug="welcome",
    ...     is_html=False,
    ... )
</code></pre><p>
Отправим письмо:

</p><pre><code class="python">    &gt;&gt;&gt; send_db_mail('welcome', 'user@example.com', use_celery=False)
</code></pre><p>
В первый раз в консоль будут выведены все запросы к БД, а так же само письмо. Во второй раз запросы к БД будут отсутствовать. Только запросы на запись в лог.
</p><p>
Проверим что у нас в логах:

</p><pre><code class="python">    &gt;&gt;&gt; from pprint import pprint
    &gt;&gt;&gt; from django.forms.models import model_to_dict
    &gt;&gt;&gt; from dbmail.models import MailLog
    &gt;&gt;&gt;
    &gt;&gt;&gt; pprint([model_to_dict(obj) for obj in MailLog.objects.all()])
</code></pre><p>
Теперь можно заглянуть в админку:

</p><pre><code class="bash">    $ xdg-open http://127.0.0.1:8000/admin/dbmail/ &gt;&amp; /dev/null || open http://127.0.0.1:8000/admin/dbmail/ &gt;&amp; /dev/null
</code></pre>
<h2>Дополнительные возможности:</h2>
<b>История</b><p>
Для сохранения истории изменений/отката, можно установить батарейку </p><u>django-reversion</u><p>.

</p><b>Редактор</b><p>
Для того что бы редактировать шаблоны в визуальном редакторе, можно поставить батарейку </p><u>django-tinymce</u><p>.

</p><b>Темы</b>
<u>django-db-mailer</u><p> — поддерживает как нативную тему, так и </p><u>django-grappelli</u><p>.

</p><b>Очереди</b><p>
Для отправки сообщений в фоне с поддержкой приоритетов, необходима батарейка </p><u>django-celery</u><p>.

</p><b>Мультиязычность</b><p>
Мультиязычность возможна в связке с </p><u>django-modeltranslation</u><p>.

</p><b>Преобразование CSS</b><p>
Для преобразования и использования строчного CSS, можно доустановить пакет </p><u>premailer</u><p>. Маленький, но полезный помощник для создания кросс-клиентских сообщений.

</p><b>Отчеты</b><p>
Отчеты о прочтении и информацию о данных пользователя можно получить установив 2 простые батарейки </p><u>httpagentparser</u><p> и </p><u>django-ipware</u><p>.

</p><b>Базовые шаблоны</b><p>
По умолчанию имеются готовые базовые шаблоны, которые оптимизированны под десктоп, мобильные и браузеры. Для того что бы начать их использовать, необходимо лишь импортировать их:
</p><pre><code class="bash">    $ python manage.py load_dbmail_base_templates
</code></pre><p>
после чего вы можете подставить свои переменные и блоки, для использования в шаблонах писем.

</p><b>Примечания</b><p>
Для того что бы работала приоритезация, необходима связка </p><u>django-celery</u><p> с брокером </p><u>Redis</u><p>.

</p><b>Старые версии</b><p>
Если Вам не нужен весь функционал, Вы можете использовать более простую версию </p><a href="https://pypi.python.org/pypi/django-db-mailer/1.0">батарейки</a><p>.
</p><p>
Так же можно воспользоваться переменной DB_MAILER_ALLOWED_MODELS_ON_ADMIN, для отключения ненужного функционала в панели администратора.

</p><b>API</b><p>
Вы так же можете использовать батарейку в связке с мобильным приложением, либо во внутренних проектах на других языках. Нет никаких ограничений. Проект в данном контексте является внешним дополнением к абсолютно любому фреймворку или проекту на языках отличных от Python.
</p><p>
Простой пример:

</p><pre><code class="python">    &gt;&gt;&gt; from dbmail.models import ApiKey
    &gt;&gt;&gt; ApiKey.objects.create(name='Test', api_key='ZzriUzE')
</code></pre><p>
Пробуем отправить письмо используя curl в терминале:

</p><pre><code class="bash">    $ curl -X POST http://127.0.0.1:8000/dbmail/api/ --data 'api_key=ZzriUzE&amp;slug=welcome&amp;recipient=root@local.host'
</code></pre>
<i>Пропускная способность API 1k+ rps на простеньком i7 2.3GHz</i>
<p>
Больше примеров для своего языка программирования — можно найти в </p><a href="https://github.com/LPgenerator/django-db-mailer/blob/master/docs/api.rst">документации в репозитории проекта</a>
<p>
Поддержка Django начиная с ветки 1.4 по 1.9. Python 2.6, 2.7, pypy, 3.4+, pypy3

</p><p>
Данная батарейка используется в нескольких больших проектах, и сберегла много времени и нервов.</p><p>
Надеюсь она будет полезна сообществу Django.
</p><p>
Страница на </p><a href="https://pypi.python.org/pypi/django-db-mailer">PyPi</a><p>.</p><p>
Репозиторий проекта на </p><a href="https://github.com/LPgenerator/django-db-mailer">GitHub</a><p>.
</p><p>
Pull Request-ы приветствуются (для желающих помочь — в корне проекта лежит TODO.RU).

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>