<html><body><div><div class="content html_format">
      <pre><code class="python">def maps():
	print "maps maps maps"

def spam():
	print "Erasing everything..."
	print "done."
</code></pre><p>
Вы знаете, что если очень долго смотреть на следующую строку, то там останутся только три слова «spam»?

</p><pre><code class="python">s = "spam‮" ,spam ,"‬spam"
s[1]()
</code></pre><p>
Действительно, первая строка очень необычная. В целом, в результате этого кода будет выполнена зловредная функция spam.

</p><a href="http://ideone.com/GuSU4F">Посмотреть на ideone</a><p>. (Для тех кто не знает: там внизу есть вывод выполнившейся программы)
</p><a name="habracut"/>
<h4>RLO</h4><p>
В основе нашей проблемы с двунаправленным письмом лежит идея о том, что в памяти текст всегда хранится в порядке записи его человеком. В том числе при письме справа-налево, при котором текст будет отрисовываться в обратном привычному направлении.
</p><p>
Направление отрисовки определяется автоматически по принадлежности символов конкретному алфавиту (ивриту, например) или, если это знак пунктуации или цифра, то по более хитрым правилам, в зависимости от контекста.
</p><p>
RLO — символ </p><i>форматирования</i><p>, расшифровывается как </p><a href="http://www.fileformat.info/info/unicode/char/202e/index.htm">right-to-left override</a><p>. Меняет направление письма на правостороннее для символов с дефолтно-левосторонним письмом. (В стандарте написано, что это может использоваться для записи </p><a href="http://en.wikipedia.org/wiki/Part_number">таких вот идентификаторов</a><p>, когда те состоят из смешанного иврита и английского и, видимо, английские включения естественно читаются справа-налево).
</p><p>
Ну так вот. Благодаря ему мы можем получить нашу прелесть:
</p><pre>s = "spam&lt;RLO&gt;" ,spam ,"&lt;PDF&gt;spam"</pre><pre>s = "spam‮" ,spam ,"‬spam"</pre>
<i>PDF расшифровывается как pop directional formatting, сбрасывает эффект последнего RLO или <a href="http://unicode.org/reports/tr9/#Directional_Formatting_Characters">его друзей</a>.</i>
<p>
Нетрудно догадаться, что интерпретатор окажется равнодушен к непонятным символам в строковых литералах. А вот некоторые редакторы, вроде emacs*, Xcode, Kate, развернут промежуточный текст именно так, как это делает браузер.
</p><p>
* в случае emacs, возможно, поведение зависит от терминала. Но в vim и nano проблемы в том же терминале нет: оба показывают только код символа RLO в соответствующей позиции.

</p><h4>О других вариантах использования в коде</h4><p>
Символ RLO не является вайтспейсовым, кроме того, python </p><a href="http://ideone.com/1xPM1H">ругается</a><p> на него в составе идентификаторов, что немного ограничивает возможности применения.
</p><p>
Его приходится класть в строковые литералы, либо в комментарии. При этом к концу каждой строки файла, как параграфа, действие RLO заканчивается.

</p><h4>Картинки</h4><p>
vim
</p><img src="https://habrastorage.org/files/e35/201/d77/e35201d778de40358b86097369bce2ca.png"/>
<p>
sublime text
</p><img src="https://habrastorage.org/files/09a/c32/887/09ac328872074544b472c58b86cd3a74.png"/>
<p>
xcode
</p><img src="https://habrastorage.org/files/0ce/351/57e/0ce35157e37f415688adf74a5e1c2014.png"/>
<p>
emacs
</p><img src="https://habrastorage.org/files/137/078/2df/1370782dfda6491994acbf69ff42851b.png"/>
<p>
… и еще раз </p><a href="http://ideone.com/GuSU4F">ссылка на ideone</a><p>.

</p><i>upd: есть еще <a href="http://ideone.com/ZvEEab">вот такой</a> вариант с Embedding и Mark</i>

<h6>Бонус</h6><p>
«rm -rf echo», которая на самом деле только печатает «rm -rf»
</p><pre><code class="bash">echo -e '\xe2\x80\x8f\xe2\x80\xaaecho \xe2\x80\xac\xe2\x80\x8f\xe2\x80\xaarm -rf \xe2\x80\xac\xe2\x80\x8f'</code></pre><p>
bash почему-то игнорирует символы форматирования в начале команды, чем открывает большой простор для злодействия.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>