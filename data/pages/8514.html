<html><body><div><div class="post-text" itemprop="text">

<p><strong>The Story:</strong></p>

<p>When you parse HTML with <code>BeautifulSoup</code>, <code>class</code> attribute is considered a <a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/#searching-by-css-class">multi-valued attribute</a> and is handled in a special manner:</p>

<blockquote>
  <p>Remember that a single tag can have multiple values for its “class” attribute. When you search for a tag that matches a certain CSS class, you’re matching against any of its CSS classes.</p>
</blockquote>

<p>Also, a quote from a built-in <code>HTMLTreeBuilder</code> used by <code>BeautifulSoup</code> as a base for other tree builder classes, like, for instance, <code>HTMLParserTreeBuilder</code>:</p>

<pre><code># The HTML standard defines these attributes as containing a
# space-separated list of values, not a single value. That is,
# class="foo bar" means that the 'class' attribute has two values,
# 'foo' and 'bar', not the single value 'foo bar'.  When we
# encounter one of these attributes, we will parse its value into
# a list of values if possible. Upon output, the list will be
# converted back into a string.
</code></pre>

<p><strong>The Question:</strong></p>

<p>How can I configure <code>BeautifulSoup</code> to handle <code>class</code> as a usual single-valued attribute? In other words, I don't want it to handle <code>class</code> specially and consider it a regular attribute.</p>

<p>FYI, here is one of the use-cases when it can be helpful:</p>



<p><strong>What I've tried:</strong></p>

<p>I've actually made it work by making a <em>custom tree builder class</em> and removing <code>class</code> from the list of specially-handled attributes:</p>

<pre><code>from bs4.builder._htmlparser import HTMLParserTreeBuilder

class MyBuilder(HTMLParserTreeBuilder):
    def __init__(self):
        super(MyBuilder, self).__init__()

        # BeautifulSoup, please don't treat "class" specially
        self.cdata_list_attributes["*"].remove("class")


soup = BeautifulSoup(data, "html.parser", builder=MyBuilder())
</code></pre>

<p>What I don't like in this approach is that it is quite "unnatural" and "magical" involving importing "private" internal <code>_htmlparser</code>. I hope there is a simpler way.</p>

<p><sup>NOTE: I want to save all other HTML parsing related features, meaning I don't want to parse <code>HTML</code> with "xml"-only features (which could've been another workaround). </sup></p>
    </div>
    </div></body></html>