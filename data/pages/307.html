<html><body><div><div class="blog-entry" id="e20131230T195302"><p>Python is well-known for its duck-typing: objects are examined for what
        they can do rather than for what type they are.  But if you like being
        strict about the methods derived classes have to implement, you can 
        use the abstract base classes in the <a class="offsite" rel="external" href="http://docs.python.org/3/library/abc.html">abc</a> module.
    </p><p>They let you define a class, with some methods defined as abstract,
        and if those methods aren't defined in a subclass, the subclass can't
        be instantiated:</p><blockquote class="code"><code><span class="c"># abstract.py</span><br/><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span><br/><br/><span class="k">class</span> <span class="nc">Abstract</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span><br/><br/>    <span class="k">def</span> <span class="nf">concrete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><br/>        <span class="k">print</span><span class="p">(</span><span class="s">"I am concrete"</span><span class="p">)</span><br/><br/>    <span class="nd">@abstractmethod</span><br/>    <span class="k">def</span> <span class="nf">not_defined_yet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><br/>        <span class="k">raise</span> <span class="ne">NotImplementedError</span><br/><br/><span class="n">a</span> <span class="o">=</span> <span class="n">Abstract</span><span class="p">()</span><br/></code></blockquote><p>produces:</p><blockquote class="code"><code>Traceback (most recent call last):<br/>  File "abstract.py", line 13, in &lt;module&gt;<br/>    a = Abstract()<br/>TypeError: Can't instantiate abstract class Abstract with abstract methods not_defined_yet<br/></code></blockquote><p>This is great when you want to be strict, and can remind you of your
        pleasant days writing Java!  But like Java, you can find yourself in
        situations where you have an abstract base class with a handful of
        abstract methods, and know that you only need a few of them.  The usual
        remedy at this point is to define all the missing methods knowing
        they'll never be called.  This is the worst of "keeping the compiler
        happy": you know what you need, but the type checking insists that you
        go through the motions.</p><p>Here's another option: a class decorator that erases the list of
        abstract methods, so that the class can be instantiated:</p><blockquote class="code"><code><span class="k">def</span> <span class="nf">unabc</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span><br/>    <span class="n">cls</span><span class="o">.</span><span class="n">__abstractmethods__</span> <span class="o">=</span> <span class="p">()</span><br/>    <span class="k">return</span> <span class="n">cls</span><br/></code></blockquote><p>Now we can make a subclass of our abstract base class, not define any
        methods, and still instantiate the class:</p><blockquote class="code"><code><span class="nd">@unabc</span><br/><span class="k">class</span> <span class="nc">ShutUpAbc</span><span class="p">(</span><span class="n">Abstract</span><span class="p">):</span><br/>    <span class="k">pass</span><br/><br/><span class="n">just_do_it</span> <span class="o">=</span> <span class="n">ShutUpAbc</span><span class="p">()</span>    <span class="c"># yay!</span><br/></code></blockquote><p>If we want to get fancier, we can! The missing abstract methods aren't
        going to be called (we think!) but we can provide stub methods just in
        case.  The stub methods will raise an error with a message naming the
        method.  For extra bells and whistles, the message will be settable
        in the decorator, and the decorator will be usable with or without
        a customized message:</p><blockquote class="code"><code><span class="k">def</span> <span class="nf">unabc</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span><br/>    <span class="sd">"""</span><br/><span class="sd">    Add stub methods to a class to satisfy abstract base classes.</span><br/><br/><span class="sd">    Usage::</span><br/><br/><span class="sd">        @unabc</span><br/><span class="sd">        class NotAbstract(SomeAbstractClass):</span><br/><span class="sd">            pass</span><br/><br/><span class="sd">        @unabc('Fake {}')</span><br/><span class="sd">        class NotAbstract(SomeAbstractClass):</span><br/><span class="sd">            pass</span><br/><span class="sd">    """</span><br/><br/>    <span class="k">def</span> <span class="nf">_unabc</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">arg</span><span class="p">):</span><br/>        <span class="k">def</span> <span class="nf">make_stub_method</span><span class="p">(</span><span class="n">ab_name</span><span class="p">):</span><br/>            <span class="k">def</span> <span class="nf">stub_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span><br/>                <span class="n">meth_name</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">"."</span> <span class="o">+</span> <span class="n">ab_name</span><br/>                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">meth_name</span><span class="p">))</span><br/>            <span class="k">return</span> <span class="n">stub_method</span><br/><br/>        <span class="k">for</span> <span class="n">ab_name</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">__abstractmethods__</span><span class="p">:</span><br/>            <span class="nb">setattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">ab_name</span><span class="p">,</span> <span class="n">make_stub_method</span><span class="p">(</span><span class="n">ab_name</span><span class="p">))</span><br/><br/>        <span class="c"># No more abstract methods!</span><br/>        <span class="n">cls</span><span class="o">.</span><span class="n">__abstractmethods__</span> <span class="o">=</span> <span class="p">()</span><br/>        <span class="k">return</span> <span class="n">cls</span><br/><br/>    <span class="c"># Handle the possibility that unabc is called without a custom message.</span><br/>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span><br/>        <span class="k">return</span> <span class="n">_unabc</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s">"{} isn't implemented, and won't be!"</span><span class="p">)</span><br/>    <span class="k">else</span><span class="p">:</span><br/>        <span class="k">return</span> <span class="n">_unabc</span><br/></code></blockquote><p>Here the _unabc function is the actual decorator.  It loops over all the
        abstract method names, and makes a new stub method for each one.  The
        make_stub_method function is needed because we need to close over the
        ab_name variable so it will have the proper value when called.</p><p>Then stub_method is defined as the actual method that will be added to
        the class with setattr.  Yes, this is four defs nested inside each
        other: one to define the decorator you use, one to be the actual
        decorator applied to the class, one to form a closure so we can define
        stub methods, and one to create the stub methods themselves!</p><p>The last part here is to deal with the two ways the unabc decorator can
        be used: if it's used without an argument, then the class in question
        will be the argument, and the isinstance check will be true.  In that
        case, we'll use the argument as the class, and provide a default
        message. If the argument isn't a class, then we return _unabc, and the
        argument is already provided as a default msg for the _unabc
        function.</p><p>BTW: all the code above is Python 3.  The only thing to change for
        Python 2 is how the ABCMeta metaclass is associated with your abstract
        class:</p><blockquote class="code"><code><span class="k">class</span> <span class="nc">Abstract</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span><br/>    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">ABCMeta</span><br/>    <span class="o">...</span><br/></code></blockquote></div></div></body></html>