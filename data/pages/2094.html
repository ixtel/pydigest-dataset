<html><body><div><article class="markdown-body entry-content" itemprop="text"><h2><a id="user-content--motivation-" class="anchor" href="#-motivation-" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a> Motivation </h2>

<p>Cython is a superset of python that adds support for blazing fast c/c++ functions. Runcython aims to simplify the process of using Cython. To try out cython on any python program, <code>main.py</code>, just do:</p>

<pre><code>$ mv main.py main.pyx &amp;&amp; runcython main.pyx
</code></pre>

<p>In the standard cython build process, running <code>myprogram.py(x)</code> with cython requires creating <code>myprogram.c</code>, <code>setup.py</code>, <code>myprogram.so</code>, and <code>finally_use.py</code>. The popular <code>pyximport</code> tool reduces these 5 files down to 2, but is only designed to handle  simple builds, and must eventually be replaced with a <code>setup.py</code> build for any real project. Runcython goes the last mile, and requires only one file. It's also designed to support complex builds in a way that will be intimately familiar for any c/c++ hacker.</p>

<h2><a id="user-content-installation" class="anchor" href="#installation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Installation</h2>

<pre><code>pip install runcython
</code></pre>

<p>See details for <a href="#OSX">OSX/Redhat</a>, <a href="#Anaconda">Anaconda</a>, or <a href="#python3">python3</a></p>

<h2><a id="user-content-usage" class="anchor" href="#usage" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Usage</h2>

<pre><code># hello.pyx
print 'hello, world'
</code></pre>

<p/>

<pre><code>$ runcython hello.pyx
hello, world
</code></pre>

<p>You can use <code>runcython file.pyx</code> just like you would use <code>python file.py</code>. The difference is that runcython will run a file with arbitrary cython code.</p>

<pre><code># accum.pyx
cdef int i, n, accum
accum = 0
n = 10**4
for i in range(n):
    accum += i
print accum
</code></pre>

<p/>

<pre><code>$ runcython accum.pyx
49995000
</code></pre>

<p>There's no need to muck around with distutils or intermediate files. Using cython the typical way would require creating 5 distinct files, <code>accum.pyx</code>, <code>accum.c</code>, <code>accum.so</code>, <code>setup.py</code>, and <code>use.py</code>. That's a lot of moving parts to keep track of. <code>runcython</code> keeps things simple so that you can just focus on writing fast code. If you want to output a module for use in your other python files, you can always use <code>makecython</code> instead:</p>

<pre><code># primes.pyx
def primes(int kmax):
    cdef int n, k, i
    cdef int p[1000000]
    result = []
    if kmax &gt; 1000000:
        kmax = 1000000
    k = 0
    n = 2
    while k &lt; kmax:
        i = 0
        while i &lt; k and n % p[i] != 0:
            i = i + 1
        if i == k:
            p[k] = n
            k = k + 1
            result.append(n)
        n = n + 1
    return result

def main():
    print primes(5)
</code></pre>

<p/>

<pre><code>$ makecython primes.pyx
$ ls
primes.pyx primes.so
$ python -c 'import primes; print primes.primes(10)'
[2, 3, 5, 7, 11, 13, 17, 23, 29]
</code></pre>

<p>Note that the <code>main()</code> function above in primes.pyx is not called when we import the primes.so module. Unlike makecython, runcython will call the <code>main()</code> function in your *.pyx file if it exists. This is the equivalent of the <code>if __name__ == '__main__': main()</code> convention used in python programs:</p>

<pre><code>$ runcython primes.pyx
[2, 3, 5, 7, 11]
</code></pre>

<h2><a id="user-content--advanced-usage-" class="anchor" href="#-advanced-usage-" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a> Advanced Usage </h2>

<p>Of course, none of this would be much better than the pyximport tool if it didn't work for complex cython builds with lots of dependencies. But unlike pyximport, runcython doesn't force you to adopt an entirely new strategy for complex builds. You get 2 extra arguments to runcython, one for passing additional flags to <code>cython file.pyx ...</code>, and one for passing additional flags to <code>gcc file.c ...</code>. Lets see how this works for calling a c file:</p>

<pre><code># square.c
int square(int x) {
    return x * x;
}

# use_square.pyx
cdef extern int square(int)
print square(5)
</code></pre>

<p>Now, if we don't add any extra parameters, <code>runcython use_square.pyx</code> will first run <code>cython use_square.pyx</code> to produce use_square.c, and then incorrectly call <code>gcc -shared -fPIC use_square.c -o use_square.so</code> to produce use_square.so. But we need to tell gcc that it should also compile the square.c file. Doing this just requres tagging on square.c to the gcc command, giving <code>gcc -shared -fPIC use_square.c -o use_square.so square.c</code>. To make this work, we just tell runcython to add the string "square.c" to the end of the gcc command:</p>

<pre><code>$ runcython use_square.pyx "" "square.c"
25
</code></pre>

<p>We can also tell runcython to pass special flags to the cython command. For example the <code>-a</code> flag tells cython to produce a nicely formatted html file with a summary of which lines in the input file were successfully optimized by cython. We can do that for the above <code>primes.pyx</code>:</p>

<pre><code>$ runcython primes.pyx "-a"
$ ls
primes.pyx primes.html
$ firefox primes.html
# firefox will show us the areas that have been sped up
</code></pre>

<h2><a id="user-content--binding-cuda-kernels-with-runcython-" class="anchor" href="#-binding-cuda-kernels-with-runcython-" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a> Binding cuda kernels with runcython </h2>

<p>To convince you that <code>runcython</code> really does scale to rather complex build processes, here's a pipeline I built recently to call cuda kernels directly using <code>runcython++</code>. Note that runcython++ is just like runcython, but using g++ for compilation rather than gcc:</p>

<pre><code>// kernel.h
#define N 16
void cscan(float* hostArray);
</code></pre>

<p>kernel.h declares a simple interface to a cuda kernel that will take an array of floats and return an array of the partial sums. This is a great parallel primitive that would be nice to do on a GPU if it were an important part of your computation. The kernel itself is defined with <code>kernel.cu</code>.</p>

<pre><code>// kernel.cu
#include "kernel.h"
__global__ void scan(float *g_odata, float *g_idata, int n)  {
    extern __shared__ float temp[]; // allocated on invocation  
    int thid = threadIdx.x;
    int pout = 0, pin = 1;
    // Load input into shared memory.  
    // This is exclusive scan, so shift right by one  
    // and set first element to 0  
    temp[pout*n + thid] = (thid &gt; 0) ? g_idata[thid-1] : 0;
    __syncthreads();
    for (int offset = 1; offset &lt; n; offset *= 2)
    {
        pout = 1 - pout; // swap double buffer indices
        pin = 1 - pout;
        if (thid &gt;= offset) {
          temp[pout*n+thid] = temp[pin*n+thid - offset] + temp[pin*n+thid];
        } else {
          temp[pout*n+thid] = temp[pin*n+thid];
        }
        __syncthreads();
    }
    g_odata[thid] = temp[pout*n+thid]; // write output
}

void cscan(float* hostArray)
{
    float* deviceArray;
    float* deviceArrayOut;
    const float zero = 0.0f;
    const int arrayLength = N;
    const unsigned int memSize = sizeof(float) * arrayLength;

    cudaMalloc((void**) &amp;deviceArray, memSize);
    cudaMalloc((void**) &amp;deviceArrayOut, memSize);
    cudaMemset( deviceArray, zero, memSize);
    cudaMemset( deviceArrayOut, zero, memSize);

    cudaMemcpy(deviceArray, hostArray, memSize, cudaMemcpyHostToDevice);
    scan &lt;&lt;&lt; 1, N, 32 &gt;&gt;&gt; (deviceArrayOut, deviceArray, N);
    cudaMemcpy(hostArray, deviceArrayOut, memSize, cudaMemcpyDeviceToHost);


    cudaFree(deviceArrayOut);
    cudaFree(deviceArray);

    return;
}
</code></pre>

<p>Finally, we're going to wrap this <code>cscan</code> function using cython with the following code:</p>

<pre><code># use_kernel.pyx
from libc.stdlib cimport malloc, free

cdef extern from "kernel.h":
    void cscan(float*)

def main():
    cdef int N = 16
    cdef float *my_array = &lt;float *&gt;malloc(N * sizeof(float))
    print "before"
    for x in range(N):
        my_array[x] = x**2
    print [my_array[x] for x in range(N)]
    cscan(my_array)
    print "after"
    print [my_array[x] for x in range(N)]
</code></pre>

<p>To compile, first we need to turn the cuda code into c++ object code:</p>

<pre><code>$ nvcc -c kernel.cu  --shared --compiler-options '-fPIC' -o kernel.o
</code></pre>

<p>The results are stored in <code>kernel.o</code>, which we would normally call from c++ with</p>

<pre><code>$ g++ use_kernel.cpp kernel.o -L/usr/local/cuda-5.5/lib64 -lcudart
</code></pre>

<p>Hence, we just need to pass the equivalent flags to runcython++, and we'll get what we want</p>

<pre><code>$ runcython++ user_kernel.pyx "" "kernel.o -L/usr/local/cuda-5.5/lib64 -lcudart"
before
[0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0, 81.0, 100.0, 121.0, 144.0, 169.0, 196.0, 225.0]
after
[0.0, 0.0, 1.0, 5.0, 14.0, 30.0, 55.0, 91.0, 140.0, 204.0, 285.0, 385.0, 506.0, 650.0, 819.0, 1015.0]
</code></pre>

<h2><a id="user-content-additional-installation-instructions" class="anchor" href="#additional-installation-instructions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Additional installation instructions</h2>

<p>The folder containing python.pc must be on your PKG_CONFIG_PATH. python.pc tells gcc which version of python to compile against and where to find your Python.h header file.</p>

<p><a name="user-content-OSX"/></p>

<h4><a id="user-content-configuration-for-osx" class="anchor" href="#configuration-for-osx" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Configuration for OSX</h4>

<p>Add the following to your ~/.bashrc:</p>

<pre><code>export PKG_CONFIG_PATH=/System/Library/Frameworks/Python.framework/Versions/2.7/lib/pkgconfig:$PKG_CONFIG_PATH
</code></pre>

<p><a name="user-content-Anaconda"/></p>

<h4><a id="user-content-configuration-for-anaconda" class="anchor" href="#configuration-for-anaconda" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Configuration for Anaconda</h4>

<p>Add the following to your ~/.bashrc:</p>

<pre><code>export PKG_CONFIG_PATH=$HOME/anaconda/lib/pkgconfig:$PKG_CONFIG_PATH
</code></pre>

<p><a name="user-content-Ubuntu"/></p>

<h4><a id="user-content-configuration-for-ubuntu" class="anchor" href="#configuration-for-ubuntu" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Configuration for Ubuntu</h4>

<p>Ubuntu should already have /usr/lib/x86_64-linux-gnu/pkgconfig/ on the PKG_CONFIG_PATH, which should contain python.pc.</p>

<p><a name="user-content-python3"/></p>

<h4><a id="user-content-configuration-for-python3" class="anchor" href="#configuration-for-python3" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Configuration for python3</h4>

<p>Python3 users should use <code>pip install runcython3</code> instead. This will install runcython3(++) and makecython3(++) scripts. You will need to make sure the folder containing python3.pc is on your PKG_CONFIG_PATH.</p>
</article>
  </div></body></html>