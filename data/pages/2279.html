<html><body><div><div class="section" id="welcome-to-jitpy-s-documentation">
<h1>Welcome to jitpy’s documentation!<a class="headerlink" href="#welcome-to-jitpy-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-it-jitpy">
<h2>What it jitpy?<a class="headerlink" href="#what-it-jitpy" title="Permalink to this headline">¶</a></h2>
<p>jitpy is a hack to embed <a class="reference external" href="http://pypy.org/">PyPy</a> inside CPython: the goal is to let PyPy optimize
selected functions and call them from CPython.  The provided interface is
limited: you can pass only simple builtin immutable types and numpy
arrays. In other words, you cannot pass lists, dicts, and instances of custom
classes.</p>
<p>The usage pattern is similar to <a class="reference external" href="http://numba.pydata.org/">numba</a>, though it does have very different
characteristics. A simple example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">jitpy</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="n">setup</span><span class="p">(</span><span class="s">'&lt;path-to-pypy-home&gt;'</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">jitpy.wrapper</span> <span class="kn">import</span> <span class="n">jittify</span>

<span class="nd">@jittify</span><span class="p">([</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">no</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
       <span class="n">s</span> <span class="o">+=</span> <span class="n">no</span>
    <span class="k">return</span> <span class="n">s</span>

<span class="n">func</span><span class="p">(</span><span class="mi">100000</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span>
</pre></div>
</div>
<p>This function will be executed by the underlying PyPy, thus yielding a
significant speed benefit (around 50x in my own measurements).</p>
</div>
<div class="section" id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h2>
<p>The idea behind <code class="docutils literal"><span class="pre">jitpy</span></code> is to lower the barrier of entry to PyPy. A lot
of people have complicated dependencies that don’t work under PyPy, yet
they want some way to speed up numeric computations. This is where <code class="docutils literal"><span class="pre">jitpy</span></code>
comes to play.</p>
</div>
<div class="section" id="installing">
<h2>Installing<a class="headerlink" href="#installing" title="Permalink to this headline">¶</a></h2>
<p>You can install jitpy using <code class="docutils literal"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">jitpy</span></code> in your CPython
installation..</p>
<p>You also need to download and unpack a very recent PyPy (newer than 2nd of Dec
2014), which can be e.g.  downloaded from PyPy <a class="reference external" href="http://buildbot.pypy.org/nightly/trunk/">nightlies</a>.</p>
<p>An example of usage:</p>
<p>Download <a class="reference external" href="http://buildbot.pypy.org/nightly/trunk/pypy-c-jit-74798-f1b314da580e-linux64.tar.bz2">64bit binary</a> or <a class="reference external" href="http://buildbot.pypy.org/nightly/trunk/pypy-c-jit-74798-f1b314da580e-linux.tar.bz2">32bit binary</a> for linux:</p>
<div class="highlight-python"><div class="highlight"><pre>~$ wget http://buildbot.pypy.org/nightly/trunk/pypy-c-jit-74798-f1b314da580e-linux64.tar.bz2
~$ tar xjf pypy-c-jit-74798-f1b314da580e-linux64.tar.bz2
~$ export PYPY_HOME=`pwd`/pypy-c-jit-74798-f1b314da580e-linux64/bin/
~$ pip install jitpy
</pre></div>
</div>
<p>And you should be able not run examples (<strong>NOTE:</strong> since jitpy takes source
code via <code class="docutils literal"><span class="pre">inspect</span></code> module, you can’t run jittify on functions typed
from python interactive prompt)</p>
</div>
<div class="section" id="using-jitpy">
<h2>Using jitpy<a class="headerlink" href="#using-jitpy" title="Permalink to this headline">¶</a></h2>
<p>jitpy is not magic - what it does is to move code across the boundary
between the two different Python implementations. It means that while PyPy and
CPython don’t share any data, you can pass <code class="docutils literal"><span class="pre">ints</span></code>, <code class="docutils literal"><span class="pre">floats</span></code>, <code class="docutils literal"><span class="pre">strings</span></code>
and <code class="docutils literal"><span class="pre">numpy</span> <span class="pre">arrays</span></code> without copying, since it’s done in-process. It’s also
faster compared to out-of-process solutions, like <code class="docutils literal"><span class="pre">multiprocessing</span></code>.
However, one needs to remember
that the global state and the namespaces of the two interpreters are separate,
which means that the functions and classes declared on CPython won’t be
automatically available in PyPy, and viceversa. Moreover, if you import the
same module in both interpreters, the module will be actually imported twice,
which can make a difference in case of modules which have side-effects when
imported.</p>
<p>The API looks like this:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">jitpy.setup(pypy_home=None)</span></code> - has to be called before anything in order to
point to the correct PyPy build directory. <code class="docutils literal"><span class="pre">pypy_home</span></code> points to the
directory of pypy checkout/installation. If None is passed, it’ll default
to <code class="docutils literal"><span class="pre">PYPY_HOME</span></code> environment variable.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">jitpy.wrapper.jittify(argtypes,</span> <span class="pre">restype=None)</span></code> - a wrapper that’s passed
argument types as a list and restype as on of the:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">int,</span> <span class="pre">float,</span> <span class="pre">string</span></code> - immutable types. Additionally <code class="docutils literal"><span class="pre">None</span></code> can
be used for return type</li>
<li><code class="docutils literal"><span class="pre">'array'</span></code> - a numpy array, can only be used as an argument, not a return
value. Also only simple types are supported for now (no compound dtypes,
no string, unicode) or object dtypes</li>
</ul>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">jitpy.extra_source(source)</span></code> - executes <code class="docutils literal"><span class="pre">source</span></code> inside PyPy. The
classes and functions defined there will be visible by the functions
decorated with <code class="docutils literal"><span class="pre">@jittify</span></code>. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">jitpy</span><span class="o">.</span><span class="n">extra_source</span><span class="p">(</span><span class="s">"""</span>
<span class="s">class X:</span>
<span class="s">    def __init__(self, x):</span>
<span class="s">        self.x = x</span>
<span class="s">"""</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Y</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@jitpy.wrapper.jittify</span><span class="p">([],</span> <span class="nb">int</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">x</span>

<span class="n">func</span><span class="p">()</span>
</pre></div>
</div>
<p>this will work, however trying to reference <code class="docutils literal"><span class="pre">Y</span></code> from inside the <code class="docutils literal"><span class="pre">func</span></code>
will result in a <code class="docutils literal"><span class="pre">NameError</span></code> exception.</p>
</li>
</ul>
<p>Differently than numba, you can use all Python constructs inside jitted
functions, including the most dynamic ones like <code class="docutils literal"><span class="pre">import</span></code>, <code class="docutils literal"><span class="pre">pdb</span></code>,
<code class="docutils literal"><span class="pre">sys._getframe</span></code>, <code class="docutils literal"><span class="pre">ex</span> <span class="pre">ec</span></code>, etc.  However note that <code class="docutils literal"><span class="pre">sys.path</span></code> is <strong>not</strong>
inherited: if you want to include extra directories in <code class="docutils literal"><span class="pre">sys.path</span></code>, you need
to modify it explicitly using <code class="docutils literal"><span class="pre">jitpy.extra_source</span></code>.</p>
</div>
<div class="section" id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h2>
<p>The API is limited to builtin types, because it’s easy to see how the boundary
looks like. Numpy arrays can be shared, because the data is visible as a pointer
in C on the low level. <code class="docutils literal"><span class="pre">sys.path</span></code> has to be initialized separately, but will
respect all the libraries installed in the underlying <code class="docutils literal"><span class="pre">pypy</span></code>.</p>
</div>
<div class="section" id="benchmarks">
<h2>Benchmarks<a class="headerlink" href="#benchmarks" title="Permalink to this headline">¶</a></h2>
<p>Everyone loves benchmarks. The way one presents benchmarks is very important.
I’m going to compare on a limited set of benchmarks various tools designed
for a specific purpose – speeding up Python in pieces or in whole without
learning a new language. That means that tools like Cython, C, Fortran are
out of scope of this comparison. I’m going to compare CPython, jitpy, numba
and to some extent PyPy.</p>
<p>The <a class="reference external" href="https://github.com/fijal/jitpy/blob/master/benchmarks/basic.py">basic benchmark</a> measures the overhead of calling through the layer.
The first example is empty function, the second loops ten times to do
three additions, in order to run <strong>any</strong> python code.</p>
<table border="1" class="docutils">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>benchmark</td>
<td>pure python</td>
<td>jitpy</td>
<td>numba</td>
</tr>
<tr class="row-even"><td>return 1</td>
<td>0.09s (1.0x)</td>
<td>0.58s (6.4x slower)</td>
<td>0.36s (4x slower)</td>
</tr>
<tr class="row-odd"><td>loop 10</td>
<td>0.95s (1.0x)</td>
<td>0.8s (1.2x faster)</td>
<td>0.39s (2.4x faster)</td>
</tr>
</tbody>
</table>
<p>While this is an interesting data point, this generally points out you should not
write very tiny functions using those layers, but as soon as there is any
work done, CPython is just very slow. For a comparison, running those benchmarks
under PyPy gives, respectively, 0.003s (30x speedup) and 0.11s (8.6x speedup),
which means
that if you have a high granularity of functions that can’t be nicely separated,
a wholesome solution like PyPy gives more benefits.</p>
<p>The <a class="reference external" href="https://github.com/fijal/jitpy/blob/master/benchmarks/array.py">array benchmark</a> gives insight into passing arrays into the functions
and doing more advanced things. The benchmarks do, in order:</p>
<ul class="simple">
<li>pass 1d array, walk it for a sum (equivalent to <code class="docutils literal"><span class="pre">sum(a)</span></code>)</li>
<li>pass 2d array, walk it for a sum (equivalent to <code class="docutils literal"><span class="pre">sum(a)</span></code>)</li>
<li>pass 2d array, walk it, create tuple of size two and count the length</li>
<li>pass 2d array, walk it, create an instance of a class and read it’s attribute</li>
</ul>
<p>Benchmarks grow in complexity as what sort of stuff is done in them (and also
grow in silliness). Results are as follows. Notes:</p>
<ul class="simple">
<li>we do 10x less iterations with CPython just because of how bloody slow it is</li>
<li>because we don’t cross boundary much, the numbers for jitpy should be
very similar to what you would get running pure PyPy</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>benchmark</td>
<td>pure python</td>
<td>jitpy</td>
<td>numba</td>
</tr>
<tr class="row-even"><td>1d array</td>
<td>12.7s (1.0x)</td>
<td>0.28s (45x faster)</td>
<td>0.21s (60x faster)</td>
</tr>
<tr class="row-odd"><td>2d array</td>
<td>16s (1.0x)</td>
<td>0.35s (46x faster)</td>
<td>0.22s (73x faster)</td>
</tr>
<tr class="row-even"><td>2d + tuple</td>
<td>33.5s (1.0x)</td>
<td>0.30s (104x faster)</td>
<td>64.5s (1.9x slower)</td>
</tr>
<tr class="row-odd"><td>2d + instance</td>
<td>48.4s (1.0x)</td>
<td>0.30s (161x faster)</td>
<td>53.9s (1.1x slower)</td>
</tr>
</tbody>
</table>
<p>The benchmark results might look very confusing, but here are my takeaways:</p>
<ul class="simple">
<li>CPython is slow at numerics</li>
<li>if everything is perfect for numba to emit optimize LLVM code, LLVM does a
very good job</li>
<li>PyPy (and jitpy) is slightly to moderately slower than numba for simple cases</li>
<li>PyPy (and jitpy) is vastly better for complicated cases that involve more
of Python semantics.</li>
</ul>
<p>After all, it makes sense - numba is a specific tool that does not try
to be fast on all Python code, while PyPy runs all Python code and tries
to be fast on it.</p>
<p>PyPy (and jitpy) also supports more of Python (in fact all), so it’s possible
to get tracebacks, <code class="docutils literal"><span class="pre">try:</span></code>, <code class="docutils literal"><span class="pre">except:</span></code> clauses, <code class="docutils literal"><span class="pre">imports</span></code> etc. etc.
that are simply not supported by numba.</p>
<p>However, your mileage may vary, try tools before jumping into conclusions.</p>

</div>
</div>


          </div></body></html>