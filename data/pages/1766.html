<html><body><div><div class="content html_format"><p>
      Данная статья — так называемый «proof-of-concept» создания фронт-енд приложения, работающего с API посредством JSONP, то есть, как говорят, «cross-origin». Также описана организация данных в Redis.</p>
<p>
Например, можно с легкостью разместить на </p><a href="http://jsfiddle.net">jsfiddle.net</a><p> некое приложение, бек-энд которого будет находится на другом домене.
</p><p>
Согласитесь, что полноценный работающий конечный продукт (требующий наличие некоего сервера для централизации обмена данными), находящийся внутри JSFiddle, выглядит забавно!

</p><img src="https://habrastorage.org/files/646/520/169/6465201691bd4249a894a93d9ff097f6.png"/>
<p>
Цель статьи — поделится своим сегодняшним опытом с двух сторон:
</p><ul>
<li>Имплементацией JSONP + Long Polling</li>
<li>Работой с замечательной Redis</li>
</ul>
<p>
Кое-чем подобным занимаются ребята из </p><a href="https://backendless.com/">BackendLess</a><p>.
</p><a name="habracut"/>

<h4>Что у нас есть</h4><p>
Итак, у нас есть:
</p><ul>
<li>Некий собственный сервер с Python 2.x на борту</li>
<li>Браузер и доступ к <a href="http://jsfiddle.net">JSFiddle.net</a></li>
<li>Желание построить API-over-JSONP</li>
</ul>

<h4>Что я использовал</h4>

<h5>JSONP</h5><p>
Думаю, читатель не нуждается в объяснении, что это такое. А насчёт имплементации — тут всё делает один декоратор:
</p><pre><code class="python">def jsonp(fn):
    def wrapper(*args, **kwargs):
        callback = request.args.get('callback', None)
        if not callback:
            raise BadRequest('Missing callback argument.')
        return '{callback}({data});'.format(
            callback=callback,
            data=dumps(fn(*args, **kwargs))
        )
    wrapper.__name__ = fn.__name__
    return wrapper
</code></pre>

<h5>Redis</h5><p>
Есть такая замечательная вещь — Redis. Как говорят о ней разработчики,
</p><blockquote>Redis is an open source, BSD licensed, advanced key-value cache and store. It is often referred to as a data structure server since keys can contain strings, hashes, lists, sets, sorted sets, bitmaps and hyperloglogs.</blockquote><p>
Или в двух словах:
</p><blockquote>Redis — это мощная система хранения и кеширования данных в формате «ключ-значение.»</blockquote>

<h5>Немного про Redis</h5>
<i>Если вы не знакомы с Redis, советую почитать о нём на оф. сайте, поскольку ниже будут описаны не все тонкости работы с ним.</i><p>
Собственно, сам Redis работает как отдельный демон, а из Python-скрипта мы обращаемся к нему через довольно простой одноимённый модуль-коннектор.</p><p>
Мы можем создать некий ключ и присвоить ему:
</p><ul>
<li>Скалярное значение (на самом деле — <i>строку</i>)</li>
<li>Список</li>
<li>Массив</li>
<li>Множество</li>
<li>Отсорированное множество</li>
</ul><p>
Но! Мы не можем сделать массив из массивов, например. Поэтому в данном случае придется делать ключ со списком индексов и по ключу на каждый индекс. Также ввиду отсутствия выборки по значениям (а-ля WHERE в SQL) иногда приходится делать списки с обратным «маппингом», например, для поиска ID юзера по никнейму и для поиска никнейма юзера по его ID.
</p><b>Грубо говоря:</b><p> то, что в SQL является таблицей, в Redis'е будет </p><b>списком индексов</b><p> и </p><b>набором массивов</b><p>. Также принято разделять части ключа двоеточием.

</p><b>Пример в SQL:</b><p> 1 таблица — с полями user_id, user_name, user_email и 5-мя записями.
</p><b>Аналогия в Redis:</b><p> 1 список и 5 массивов — список </p><b>users</b><p> с данными [1, 2, 3, 4, 5] и 5 массивов с названиями (ключами) вида </p><b>user:X</b><p> с данными {id: X, name: Y, email: Z}, а также несколько массивов с обратной связкой, например, nicknames со значениями {andrew: 1, john: 2, mike: 3, ...}

</p><h5>Почему Redis?</h5>
<ul>
<li>В Redis не нужно задавать структуры данных: достаточно просто положить их туда.</li>
<li>Мы можем делать <b>CRUD</b> (<i>Create-Read-Update-Delete</i>) с данными, находящимися в базе Redis, а также использовать встроенный механизм блокировки — он, кстати, очень упрощает имплементацию механизма <b>long polling</b>.</li>
<li>Никаких JOIN или WHERE Redis не умеет, да и не должен — он всего лишь хранит примитивы, максимум списки или ассоциативные массивы из примитивов. Но это не минус, а дополнительная свобода действий и стимул для расширения мышления, отличного от паттернов SQL- и NoSQL-СУБД.</li>
</ul>

<h5>Структура <s>БД</s> системы хранения ключей-значений</h5><p>
Вот так выглядят данные в нашей Redis в момент, когда Andrew написал сообщение и John написал сообщение, но первое прочитали все, кроме майка, а второе — лишь сам Джон. Но за несколько моментов все </p><b>user:X:messages</b><p> очистятся, т.к. наступит таймаут полинга и данные уедут на клиенты. Т.е. </p><b>user:X:messages</b><p> — это такой себе контейнер для еще не полученных сообщений некоего юзера.
</p><img src="https://habrastorage.org/files/3b6/17a/1d3/3b617a1d3fed4577b66ff42787941f61.png"/>

<h4>Long polling</h4><p>
Средствами Redis можна легко реализовать </p><b>long polling</b><p>. Примерный алгоритм таков:
</p><ul>
<li>Запрашиваем в Redis (командой <a href="http://redis.io/commands/LLEN">LLEN</a>), есть ли прямо сейчас в списке сообщений для клиента сообщения, если есть — возвращаем сообщения и чистим список через <a href="http://redis.io/commands/DEL">DEL</a></li>
<li>Если сообщений нет, запрашиваем их опять, но на сей раз команой <a href="http://redis.io/commands/BLPOP">BLPOP</a>, которая заблокирует активный поток, пока не появлятся данные либо не истечет таймаут. По разблокировке возвращаем клиенту результат от Redis, в котором будет либо только что пришедшее сообщение, либо ничего.</li>
</ul>

<h4>«Боевая команда, вперёд!»</h4><p>
Фронт-энд для тестирования: </p><a href="http://jsfiddle.net/andunai/kcdtzdww/">jsfiddle.net/andunai/kcdtzdww</a><p>
Исходный код бек-энда: </p><a href="https://bitbucket.org/AndrewDunai/nobackend-chat-dirty">bitbucket.org/AndrewDunai/nobackend-chat-dirty</a><p>
Полноэкранная версия: </p><a href="http://jsfiddle.net/andunai/kcdtzdww/embedded/result/">jsfiddle.net/andunai/kcdtzdww/embedded/result</a>

<h4>Post Scriptum</h4>
<p>
Мне очень приятно, что вы дочитали аж до этого места. Я, как всегда, рад любым замечаниям и пожеланиям.</p><p>
Надеюсь, хабраэффект не сильно заденет мой маленький VPS.</p><p>
Спасибо за внимание!

</p><b>UPDATE: репозиторий теперь публичный, случайно сделал его приватным при создании.</b>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>