<html><body><div><div class="content html_format">
      <p>
Приемы, описанные здесь, есть в официальной документации к модулю </p><i>argparse</i><p> (я использую Python 2.7), ничего нового я не изобрел, просто, попользовавшись ими некоторое время, убедился в их мощности. Они позволяют улучшить структуру программы и решить следующие задачи:

</p><ol>
<li>Вызов определенной функции в ответ на заданный параметр командной строки с лаконичной диспетчеризацией.</li>
<li>Инкапсуляция обработки и валидации введенных пользователем данных.</li>
</ol>
<a name="habracut"/><p>
Побудительным мотивом к написанию данной заметки стало обсуждение в тостере приблизительно такого вопроса: </p><blockquote>как вызвать определенную функцию в ответ на параметр командной строки</blockquote><p> и ответы на него в духе </p><blockquote>я использую argparse и if/elif</blockquote><blockquote>посмотрите в сторону sys.argv</blockquote>
<p>
В качестве подопытного возьмем сферический скрипт с двумя ветками параметров.
</p><pre><code class="bash">userdb.py append &lt;username&gt; &lt;age&gt;
userdb.py show &lt;userid&gt;
</code></pre><p>
Цель, которую позволяет достичь первый прием, будет такой:
</p><b><i>хочу, чтобы для каждой ветки аргументов вызывалась своя функция, которая будет отвечать за обработку всех аргументов ветки, и чтобы эта функция выбиралась автоматически модулем argparse, без всяких if/elif, и еще чтобы… стоп, достаточно пока.</i></b>
<p>
Рассмотрим первый прием на примере первой ветви аргументов </p><b>append</b><p>.
</p><pre><code>import argparse

def create_new_user(args):
    """Эта функция будет вызвана для создания пользователя"""
    #скучные проверки корректности данных, с ними разберемся позже
    age = int(args.age)
    User.add(name=args.username, age=args.age)

def parse_args():
    """Настройка argparse"""
    parser = argparse.ArgumentParser(description='User database utility')
    subparsers = parser.add_subparsers()
    parser_append = subparsers.add_parser('append', help='Append a new user to database')
    parser_append.add_argument('username', help='Name of user')
    parser_append.add_argument('age', help='Age of user')
    parser_append.set_defaults(func=create_new_user)

    # код для других аргументов

    return parser.parse_args()
    
def main():
    """Это все, что нам потребуется для обработки всех ветвей аргументов"""
    args = parse_args()
    args.func(args)
</code></pre><p>
теперь, если пользователь запустит наш скрипт с параметрами, к примеру:
</p><pre><code class="bash">userdb.py append RootAdminCool 20</code></pre><p>
в недрах программы будет вызвана функция </p><i>create_new_user()</i><p>, которая все и сделает. Поскольку у нас для каждой ветви будет сконфигурирована своя функция, точка входа </p><i>main()</i><p> получилась по-спартански короткой. Как вы уже заметили, вся хитрость кроется в вызове метода </p><i>set_defaults()</i><p>, который и позволяет задать фиксированный параметр с предустановленным значением, в нашем случае во всех ветках должен быть параметр </p><b>func</b><p> со значением — вызываемым объектом, принимающим один аргумент. </p><p>
Кстати, пользователь, если у него возникнет такое желание, не сможет «снаружи» подсунуть свой параметр в качестве func, не влезая в скрипт (у меня не вышло, по крайней мере).
</p><p>
Теперь ничего не остается, кроме как рассмотреть второй прием на второй ветке аргументов нашего userdb.py.
</p><pre><code class="bash">userdb.py show &lt;userid&gt; </code></pre>
<p>
Цель для второго приема сформулируем так: </p><b>хочу, чтобы данные, которые передает пользователь, не только валидировались, <s>это слишком просто,</s> но и чтобы моя программа оперировала более комплексными объектами, сформированными на основе данных пользователя. В нашем примере, хочу, чтобы программа, вместо userid получала объект ORM, соответствующий пользователю с заданным ID. </b>
<p>
Обратите внимание, как в первом приеме, в функции </p><i>create_new_user()</i><p>, мы делали «нудные проверки» на валидность данных. Сейчас мы научимся переносить их туда, где им самое место.
</p><p>
В </p><i>argparse</i><p>, в помощь нам, есть параметр, который можно задать для каждого аргумента — </p><b>type</b><p>. В качестве </p><b>type</b><p> может быть задан любой исполняемый объект, возвращающий значение, которое запишется в свойство объекта </p><i>args</i><p>. Простейшими примерами использования </p><i>type</i><p> могут служить 
</p><pre><code class="python">parser.add_argument(..., type=file) 
parser.add_argument(..., type=int)
</code></pre><p>
но мы пройдем по этому пути немного дальше:
</p><pre><code class="python">import argparse

def user_from_db(user_id):
    """Возвращает объект-пользователя, если id прошел валидацию, или 
    генерирует исключение.
    """
    # валидируем user_id
    id = int(user_id)

    return User.select(id=id)  # создаем объект ORM и передаем его программе

def print_user(args):
    """Отображение информации о пользователе.
    Обращаем внимание на то, что args.userid содержит уже не ID, а объект ORM.
    Этот факт запутывает, но ниже мы с этим разберемся (те самые пол-приема уже близко!)
    """
    user_obj = args.userid
    print str(user_obj)

def parse_args():
    """Настройка argparse"""
    parser = argparse.ArgumentParser(description='User database utility')

   # код для других аргументов

    subparsers = parser.add_subparsers()
    parser_show = subparsers.add_parser('show', help='Show information about user')
    parser_show.add_argument('userid', type=user_from_db, help='ID of user')
    parser_show.set_defaults(func=print_user)

    return parser.parse_args()
</code></pre><p>
Точка входа </p><i>main()</i><p> не меняется!
</p><p>
Теперь, если мы позже поймем, что заставлять пользователя вводить ID как параметр жестоко, мы можем спокойно переключиться на, к примеру, username. Для этого нам потребуется только изменить код </p><i>user_from_db()</i><p>, а функция </p><i>print_user()</i><p> так ни о чем и не узнает. 
</p><p>
Используя параметр </p><b>type</b><p>, стоит обратить внимание на то, что исключения, которые возникают внутри исполняемых объектов, переданных как значения этого параметра, обрабатываются внутри </p><i>argparse</i><p>, до пользователя доводится информация об ошибке в соответствующем аргументе. 

</p><h5>Пол-приема.</h5><p>
Данный трюк не заслужил звания полноценного приема, поскольку является расширением второго, но это не уменьшает его пользы. Если взглянуть на документацию (я про __doc__) к </p><i>print_user()</i><p> мы увидим, что на вход подается </p><i>args.userid</i><p>, в котором, на самом деле, уже не ID, а более сложный объект с полной информацией о пользователе. Это запутывает код, требует комментария, что некрасиво. Корень зла — несоответствие между информацией, которой оперирует пользователь, и той информацией, которой оперирует наша программа. </p><p>
Самое время сформулировать задачу: 
</p><b>хочу, чтобы названия параметров были понятны пользователю, но, при этом, чтобы код, работающий с этими параметрами был выразительным.</b><p>
Для этого у позиционных аргументов в </p><i>argparse</i><p> есть параметр </p><b>metavar</b><p>, задающий отображаемое пользователю название аргумента (для опциональных аргументов больше подойдет параметр </p><b>dest</b><p>).
</p><p>
Теперь попробуем модифицировать код из второго примера, чтобы решить задачу.
</p><pre><code class="python">def print_user(args):
   """Отображение информации о пользователе"""
   print str(args.user_dbobj)

def parse_args():
   """Настройка argparse"""

  # код для других аргументов

   parser = argparse.ArgumentParser(description='User database utility')
   subparsers = parser.add_subparsers()
   parser_show = subparsers.add_parser('show', help='Show information about user')
   parser_show.add_argument('user_dbobj', type=user_from_db, metavar='userid', help='ID of user')
   parser_show.set_defaults(func=print_user)

   return parser.parse_args()
</code></pre><p>
Сейчас пользователь видит свойство </p><i>userid</i><p>, а обработчик параметра — </p><i>user_dbobj</i><p>.</p><p>
По-моему получилось решить обе 2.5 поставленные задачи. В результате код, обрабатывающий данные от пользователя, отделен от основного кода программы, точка входа программы не перегружена ветвлениями, а пользователь и программа работают каждый в своих терминах.
</p><p>
Рабочий код примера, где уже сразу все “по феншую” находится </p><a href="https://gist.github.com/brake/a1a002d4238c66ee186a#file-argparse_demo-py">здесь</a><p>.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>