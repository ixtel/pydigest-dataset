<html><body><div><div class="content html_format">
      <i>Люк Плант (Luke Plant) — программист-фрилансер с многолетним стажем, один из ключевых разработчиков Django.</i>
<p>
Когда-то я писал о своей </p><a href="http://lukeplant.me.uk/blog/posts/djangos-cbvs-were-a-mistake/">неприязни к Class Based Views (CBV) в Django</a><p>. Их использование заметно усложняет код и увеличивает его объём, при этом CBV мешают применять некоторые достаточно распространённые шаблоны (скажем, когда две формы представлены в одном view). И судя по всему, я </p><a href="http://www.reddit.com/r/django/comments/1kc3go/cbv_lifecycle_documentation/cbnkwig">не единственный</a><p> из разработчиков Django, придерживающийся такой точки зрения.
</p><p>
Но в этом посте я хочу рассказать об ином подходе, который я применил в одном из проектов. Этот подход можно охарактеризовать одной фразой: «</p><i>Создавайте свой собственный базовый класс</i><p>». 
</p><a name="habracut"/><p>
При достаточно простых model view использование </p><a href="http://">CBV в Django</a><p> может сэкономить время. Но в более сложных случаях вы столкнётесь с рядом трудностей, как минимум, придётся погрузиться в </p><a href="http://ccbv.co.uk/">изучение документации</a><p>. 
</p><p>
Избежать всего этого можно, например, с помощью </p><a href="http://django-vanilla-views.org/">упрощённой реализации CBV</a><p>. Лично я пошёл ещё дальше и начал с нуля, написав собственный базовый класс, позаимствовав лучшие идеи и внедрив только то, что мне нужно.

</p><h3>Заимствование хороших идей</h3><p>
Метод </p><a href="https://docs.djangoproject.com/en/dev/ref/class-based-views/base/#django.views.generic.base.View.as_view">as_view</a><p>, предоставляемый классом </p><code>View </code><p>в Django, вещь замечательная. Этот метод внедрили после многочисленных дискуссий для облегчения изоляции запроса путём создания нового экземпляра класса для обработки каждого нового запроса. Я с удовольствием позаимствовал эту идею.

</p><h3>Отказ от плохих идей</h3><p>
Лично мне не нравится метод </p><code>dispatch</code><p>, поскольку он предполагает совершенно разную обработку </p><code>GET </code><p>и </p><code>POST</code><p>, хотя они зачастую пересекаются (особенно в случаях обработки типичных форм). Кроме того, при просмотре отклонённых POST-запросов, когда достаточно просто проигнорировать определённые данные, этот метод требует написания дополнительного кода, что для меня является багом. 
</p><p>
Поэтому я отказался от этого метода в пользу простой функции </p><code>handle</code><p>, которую нужно реализовывать при создании любой логики.
</p><p>
Также мне не нравится, что шаблоны автоматически именуются на основании имён моделей и т.д. Это программирование по соглашению, что излишне усложняет жизнь при поддержке кода. Ведь кому-то придётся грепать, чтобы выяснить, где же используется шаблон. То есть при использовании такой логики вы ДОЛЖНЫ ЗНАТЬ, где искать информацию о том, используется ли шаблон вообще и как он используется.

</p><h3>Выравнивание стека</h3><p>
Гораздо легче управлять относительно единообразным набором (flat set) базовых классов, чем большим набором из классов-примесей (mixins) и базовых классов. Благодаря единообразности стека я могу не писать </p><a href="https://bitbucket.org/spookylukey/cciw-website/src/6bba6e8bec0b/cciw/bookings/views.py#views.py-272">безумные хаки для прерывания наследования</a><p>.

</p><h3>Написание нужного API</h3><p>
Помимо прочего, в CBV Django мне не нравится вынужденная многословность при добавлении новых данных в </p><code>context </code><p>в достаточно простых ситуациях, когда вместо одной строки приходится писать четыре:

</p><pre><code class="python">class MyView(ParentView):
    def get_context_data(self, **kwargs):
        context = super(MyView, self).get_context_data(**kwargs)
        context['title'] = "My title"  # Это единственная строка, которую я хочу написать!
        return context
</code></pre><p>
На самом деле, обычно всё ещё хуже, поскольку добавляемые в </p><code>context </code><p>данные могут вычисляться с помощью другого метода и висеть на </p><code>self</code><p>, чтобы их мог найти </p><code>get_context_data</code><p>. К тому же, чем больше кода, тем легче сделать ошибку. Например, если вы забудете про вызов </p><code>super</code><p>, то всё может пойти наперекосяк.
</p><p>
Подыскивая примеры на Github, я пересмотрел сотни образчиков кода наподобие этого:

</p><pre><code class="python">class HomeView(TemplateView):
    # ...

    def get_context_data(self):
        context = super(HomeView, self).get_context_data()
        return context
</code></pre><p>
Я не обращал на это особого внимания, пока не сообразил: люди используют стандартные генераторы/снипеты для создания новых CBV (</p><a href="https://github.com/pashinin/emacsd/blob/c8e50e6bb573641f3ffd454236215ea59e4eca13/snippets/python-mode/class">пример 1</a><p>, </p><a href="https://github.com/ppiet/dotfiles/blob/e92c4b31d253e48027b72335f071281352b05f01/vim/UltiSnips/python.snippets">пример 2</a><p>, </p><a href="https://github.com/mvdwaeter/dotfiles/blob/60673ae395bf493fd5fa6addeceac662218e1703/osx/Sublime Text/get_context_data.sublime-snippet">пример 3</a><p>). Если людям нужны подобные ухищрения, это означает, что вы создали слишком громоздкий API.
</p><p>
Могу посоветовать: </p><b>представьте, какой бы вы хотели получить API, и реализуйте его</b><p>. Например, для статического добавления в </p><code>context </code><p>я </p><b>хотел бы</b><p> написать это: 

</p><pre><code class="python">class MyView(ParentView):
    context = {'title': "My title"}
</code></pre><p>
А для динамического добавления: 

</p><pre><code class="python">class MyView(ParentView):
    def context(self):
        return {'things': Thing.objects.all()
                          if self.request.user.is_authenticated()
                          else Thing.objects.public()}

    # Или, возможно, используя lambda:
    context = lambda self: ...
</code></pre><p>
Также мне хотелось бы автоматически аккумулировать любой </p><code>context</code><p>, определяемый </p><code>ParentView</code><p>, даже если я не вызываю </p><code>super </code><p>явным образом. В конце концов, нам почти всегда хочется добавлять данные в </p><code>context</code><p>. И, при необходимости, подкласс должен убирать специфические наследуемые данные, присваивая ключ </p><code>None</code><p>. 
</p><p>
Также мне хотелось бы иметь возможность напрямую добавлять данные в </p><code>context </code><p>для любого метода в моём CBV. Например, настраивая/обновляя переменную экземпляра:

</p><pre><code class="python">class MyView(ParentView):

    def do_the_thing(self):
        if some_condition():
            self.context['foo'] = 'bar'
</code></pre><p>
Само собой, при этом ничто не должно быть испорчено на уровне класса, а изоляция запроса не должна быть нарушена. При этом все методы должны работать предсказуемо и безо всяких затруднений. А заодно нельзя допустить возможность случайного изменения изнутри метода определяемого классом словаря </p><code>context</code><p>. 
</p><p>
Когда вы закончите мечтать, то, вероятно, обнаружите, что ваш воображаемый API слишком трудно реализовать из-за особенностей самого языка, нужно его как-то модифицировать. Тем не менее, проблема решаема, хотя это и выглядит немного волшебством. Обычно определение метода в подклассе без использования </p><code>super</code><p> означает, что определение класса </p><code>super</code><p>можно проигнорировать, а в атрибутах класса вообще нельзя использовать </p><code>super</code><p>. 
</p><p>
Я предпочитаю делать это более прозрачным образом, используя для атрибута класса и метода имя </p><code>magic_context</code><p>. Так я не подкладываю свинью тем, кто будет потом поддерживать код. Если что-то называется </p><code>magic_foo</code><p>, то большинство людей полюбопытствуют, почему это оно «волшебное» и как оно работает.
</p><p>
В </p><a href="https://bitbucket.org/spookylukey/cciw-website/src/9701a26ae145/cciw/cciwmain/common.py#common.py-25">реализации </a><p>используется несколько хитростей, и в первую очередь такая: с помощью </p><code>reversed(self.__class__.mro())</code><p> извлекаются все super-классы и их атрибуты </p><code>magic_context</code><p>, а также итеративно обновляется содержащий их словарь.
</p><p>
Обратите внимание, что метод </p><a href="https://bitbucket.org/spookylukey/cciw-website/src/9701a26ae145/cciw/cciwmain/common.py#common.py-123">TemplateView.handle</a><p> крайне прост, он лишь вызывает другой метод, который и выполняет всю работу:

</p><pre><code class="python">class TemplateView(View):
    # ...
    def handle(self, request):
        return self.render({})
</code></pre><p>
Это означает, что подклассу, определяющему </p><code>handle </code><p>для выполнения нужной логики, не нужно вызывать </p><code>super</code><p>. Ему достаточно напрямую вызвать такой же метод:

</p><pre><code class="python">class MyView(TemplateView):
    template_name = "mytemplate.html"

    def handle(self, request):
        # логика здесь...
        return self.render({'some_more': 'context_data'})
</code></pre><p>
Кроме того, я использую ряд привязок (hooks) для обработки таких вещей, как AJAX-валидация при представлении формы, подгрузка RSS/Atom для представлений в виде списков, и т.д. Это выполняется довольно просто, поскольку я контролирую базовые классы.

</p><h3>В заключение</h3><p>
Основная идея заключается в том, что вы не обязаны ограничиваться возможностями Django. В него не интегрировано глубоко ничего, что относится к CBV, поэтому ваши собственные реализации будут ничем не хуже, а то и лучше. Я рекомендую вам </p><b>написать именно тот код, который нужен для вашего проекта, а затем создать базовый класс, который заставит его работать</b><p>.
</p><p>
Недостаток этого подхода заключается в том, что вы не облегчите работу программистам, которые будут поддерживать ваш код, если они выучили API для Django CBV. Ведь в вашем проекте будет использоваться другой набор базовых классов. Однако преимущества всё же с лихвой компенсируют это неудобство.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>