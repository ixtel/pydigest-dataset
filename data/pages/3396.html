<html><body><div><p>Argcomplete provides easy, extensible command line tab completion of arguments for your Python script.</p>
<p>Argcomplete is particularly useful if your program has lots of options or subparsers, and if your program can
dynamically suggest completions for your argument/option values (for example, if the user is browsing resources over
the network).</p>
<div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<p>Python code (e.g. <code class="docutils literal"><span class="pre">my-awesome-script.py</span></code>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="c"># PYTHON_ARGCOMPLETE_OK</span>
<span class="kn">import</span> <span class="nn">argcomplete</span><span class="o">,</span> <span class="nn">argparse</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="o">...</span>
<span class="n">argcomplete</span><span class="o">.</span><span class="n">autocomplete</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Shellcode (only necessary if global completion is not activated - see <a class="reference internal" href="#global-completion">Global completion</a> below), to be put in e.g. <code class="docutils literal"><span class="pre">.bashrc</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>eval "$(register-python-argcomplete my-awesome-script.py)"
</pre></div>
</div>
<div class="section" id="argcomplete-autocomplete-parser">
<h3>argcomplete.autocomplete(<em>parser</em>)<a class="headerlink" href="#argcomplete-autocomplete-parser" title="Permalink to this headline">¶</a></h3>
<p>This method is the entry point to the module. It must be called <strong>after</strong> ArgumentParser construction is complete, but
<strong>before</strong> the <code class="docutils literal"><span class="pre">ArgumentParser.parse_args()</span></code> method is called. The method looks for an environment variable that the
completion hook shellcode sets, and if it’s there, collects completions, prints them to the output stream (fd 8 by
default), and exits. Otherwise, it returns to the caller immediately.</p>
<div class="admonition-side-effects admonition">
<p class="first admonition-title">Side effects</p>
<p class="last">Argcomplete gets completions by running your program. It intercepts the execution flow at the moment
<code class="docutils literal"><span class="pre">argcomplete.autocomplete()</span></code> is called. After sending completions, it exits using <code class="docutils literal"><span class="pre">exit_method</span></code> (<code class="docutils literal"><span class="pre">os._exit</span></code>
by default). This means if your program has any side effects that happen before <code class="docutils literal"><span class="pre">argcomplete</span></code> is called, those
side effects will happen every time the user presses <code class="docutils literal"><span class="pre">&lt;TAB&gt;</span></code> (although anything your program prints to stdout or
stderr will be suppressed). For this reason it’s best to construct the argument parser and call
<code class="docutils literal"><span class="pre">argcomplete.autocomplete()</span></code> as early as possible in your execution flow.</p>
</div>
</div>
</div>
<div class="section" id="specifying-completers">
<h2>Specifying completers<a class="headerlink" href="#specifying-completers" title="Permalink to this headline">¶</a></h2>
<p>You can specify custom completion functions for your options and arguments. Two styles are supported: callable and
readline-style. Callable completers are simpler. They are called with the following keyword arguments:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">prefix</span></code>: The prefix text of the last word before the cursor on the command line. All returned completions should begin with this prefix.</li>
<li><code class="docutils literal"><span class="pre">action</span></code>: The <code class="docutils literal"><span class="pre">argparse.Action</span></code> instance that this completer was called for.</li>
<li><code class="docutils literal"><span class="pre">parser</span></code>: The <code class="docutils literal"><span class="pre">argparse.ArgumentParser</span></code> instance that the action was taken by.</li>
<li><code class="docutils literal"><span class="pre">parsed_args</span></code>: The result of argument parsing so far (the <code class="docutils literal"><span class="pre">argparse.Namespace</span></code> args object normally returned by
<code class="docutils literal"><span class="pre">ArgumentParser.parse_args()</span></code>).</li>
</ul>
<p>Completers should return their completions as a list of strings. An example completer for names of environment
variables might look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">EnvironCompleter</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">))</span>
</pre></div>
</div>
<p>To specify a completer for an argument or option, set the <code class="docutils literal"><span class="pre">completer</span></code> attribute of its associated action. An easy
way to do this at definition time is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">argcomplete.completers</span> <span class="kn">import</span> <span class="n">EnvironCompleter</span>

<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">"--env-var1"</span><span class="p">)</span><span class="o">.</span><span class="n">completer</span> <span class="o">=</span> <span class="n">EnvironCompleter</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">"--env-var2"</span><span class="p">)</span><span class="o">.</span><span class="n">completer</span> <span class="o">=</span> <span class="n">EnvironCompleter</span>
<span class="n">argcomplete</span><span class="o">.</span><span class="n">autocomplete</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
</pre></div>
</div>
<p>If you specify the <code class="docutils literal"><span class="pre">choices</span></code> keyword for an argparse option or argument (and don’t specify a completer), it will be
used for completions.</p>
<p>A completer that is initialized with a set of all possible choices of values for its action might look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ChoicesCompleter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="p">[]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">choices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span> <span class="k">for</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">choices</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">))</span>
</pre></div>
</div>
<p>The following two ways to specify a static set of choices are equivalent for completion purposes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">argcomplete.completers</span> <span class="kn">import</span> <span class="n">ChoicesCompleter</span>

<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">"--protocol"</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="p">(</span><span class="s">'http'</span><span class="p">,</span> <span class="s">'https'</span><span class="p">,</span> <span class="s">'ssh'</span><span class="p">,</span> <span class="s">'rsync'</span><span class="p">,</span> <span class="s">'wss'</span><span class="p">))</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">"--proto"</span><span class="p">)</span><span class="o">.</span><span class="n">completer</span><span class="o">=</span><span class="n">ChoicesCompleter</span><span class="p">((</span><span class="s">'http'</span><span class="p">,</span> <span class="s">'https'</span><span class="p">,</span> <span class="s">'ssh'</span><span class="p">,</span> <span class="s">'rsync'</span><span class="p">,</span> <span class="s">'wss'</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that if you use the <code class="docutils literal"><span class="pre">choices=&lt;completions&gt;</span></code> option, argparse will show
all these choices in the <code class="docutils literal"><span class="pre">--help</span></code> output by default. To prevent this, set
<code class="docutils literal"><span class="pre">metavar</span></code> (like <code class="docutils literal"><span class="pre">parser.add_argument("--protocol",</span> <span class="pre">metavar="PROTOCOL",</span>
<span class="pre">choices=('http',</span> <span class="pre">'https',</span> <span class="pre">'ssh',</span> <span class="pre">'rsync',</span> <span class="pre">'wss'))</span></code>).</p>
<p>The following <a class="reference external" href="https://raw.github.com/kislyuk/argcomplete/master/docs/examples/describe_github_user.py">script</a> uses
<code class="docutils literal"><span class="pre">parsed_args</span></code> and <a class="reference external" href="http://python-requests.org/">Requests</a> to query GitHub for publicly known members of an
organization and complete their names, then prints the member description:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="c"># PYTHON_ARGCOMPLETE_OK</span>
<span class="kn">import</span> <span class="nn">argcomplete</span><span class="o">,</span> <span class="nn">argparse</span><span class="o">,</span> <span class="nn">requests</span><span class="o">,</span> <span class="nn">pprint</span>

<span class="k">def</span> <span class="nf">github_org_members</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">parsed_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">resource</span> <span class="o">=</span> <span class="s">"https://api.github.com/orgs/{org}/members"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">org</span><span class="o">=</span><span class="n">parsed_args</span><span class="o">.</span><span class="n">organization</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">member</span><span class="p">[</span><span class="s">'login'</span><span class="p">]</span> <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">resource</span><span class="p">)</span><span class="o">.</span><span class="n">json</span><span class="p">()</span> <span class="k">if</span> <span class="n">member</span><span class="p">[</span><span class="s">'login'</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">))</span>

<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">"--organization"</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">"GitHub organization"</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">"--member"</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">"GitHub member"</span><span class="p">)</span><span class="o">.</span><span class="n">completer</span> <span class="o">=</span> <span class="n">github_org_members</span>

<span class="n">argcomplete</span><span class="o">.</span><span class="n">autocomplete</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

<span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"https://api.github.com/users/{m}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">member</span><span class="p">))</span><span class="o">.</span><span class="n">json</span><span class="p">())</span>
</pre></div>
</div>
<p><a class="reference external" href="https://raw.github.com/kislyuk/argcomplete/master/docs/examples/describe_github_user.py">Try it</a> like this:</p>
<div class="highlight-python"><div class="highlight"><pre>./describe_github_user.py --organization heroku --member &lt;TAB&gt;
</pre></div>
</div>
<p>If you have a useful completer to add to the <a class="reference external" href="https://github.com/kislyuk/argcomplete/blob/master/argcomplete/completers.py">completer library</a>, send a pull request!</p>
<div class="section" id="readline-style-completers">
<h3>Readline-style completers<a class="headerlink" href="#readline-style-completers" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="http://docs.python.org/2/library/readline.html">readline</a> module defines a completer protocol in <a href="#id2"><span class="problematic" id="id3">rlcompleter_</span></a>. Readline-style completers are also supported by
argcomplete, so you can use the same completer object both in an interactive readline-powered shell and on the bash
command line. For example, you can use the readline-style completer provided by <a class="reference external" href="http://ipython.org/">IPython</a> to get introspective
completions like you would get in the IPython shell:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">IPython</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">"--python-name"</span><span class="p">)</span><span class="o">.</span><span class="n">completer</span> <span class="o">=</span> <span class="n">IPython</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">completer</span><span class="o">.</span><span class="n">Completer</span><span class="p">()</span>
</pre></div>
</div>
<p>You can also use <a class="reference external" href="https://argcomplete.readthedocs.org/en/latest/#argcomplete.CompletionFinder.rl_complete">argcomplete.CompletionFinder.rl_complete</a>
to plug your entire argparse parser as a readline completer.</p>
</div>
<div class="section" id="printing-warnings-in-completers">
<h3>Printing warnings in completers<a class="headerlink" href="#printing-warnings-in-completers" title="Permalink to this headline">¶</a></h3>
<p>Normal stdout/stderr output is suspended when argcomplete runs. Sometimes, though, when the user presses <code class="docutils literal"><span class="pre">&lt;TAB&gt;</span></code>, it’s
appropriate to print information about why completions generation failed. To do this, use <code class="docutils literal"><span class="pre">warn</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">argcomplete</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="k">def</span> <span class="nf">AwesomeWebServiceCompleter</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">login_failed</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s">"Please log in to Awesome Web Service to use autocompletion"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">completions</span>
</pre></div>
</div>
</div>
<div class="section" id="using-a-custom-completion-validator">
<h3>Using a custom completion validator<a class="headerlink" href="#using-a-custom-completion-validator" title="Permalink to this headline">¶</a></h3>
<p>By default, argcomplete validates your completions by checking if they start with the prefix given to the completer. You
can override this validation check by supplying the <code class="docutils literal"><span class="pre">validator</span></code> keyword to <code class="docutils literal"><span class="pre">argcomplete.autocomplete()</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">my_validator</span><span class="p">(</span><span class="n">current_input</span><span class="p">,</span> <span class="n">keyword_to_check_against</span><span class="p">):</span>
    <span class="c"># Pass through ALL options even if they don't all start with 'current_input'</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="n">argcomplete</span><span class="o">.</span><span class="n">autocomplete</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">validator</span><span class="o">=</span><span class="n">my_validator</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="global-completion">
<h2>Global completion<a class="headerlink" href="#global-completion" title="Permalink to this headline">¶</a></h2>
<p>In global completion mode, you don’t have to register each argcomplete-capable executable separately. Instead, bash
will look for the string <strong>PYTHON_ARGCOMPLETE_OK</strong> in the first 1024 bytes of any executable that it’s running
completion for, and if it’s found, follow the rest of the argcomplete protocol as described above.</p>
<div class="admonition-bash-version-compatibility admonition">
<p class="first admonition-title">Bash version compatibility</p>
<p>Global completion requires bash support for <code class="docutils literal"><span class="pre">complete</span> <span class="pre">-D</span></code>, which was introduced in bash 4.2. On OS X or older Linux
systems, you will need to update bash to use this feature. Check the version of the running copy of bash with
<code class="docutils literal"><span class="pre">echo</span> <span class="pre">$BASH_VERSION</span></code>. On OS X, install bash via <a class="reference external" href="http://brew.sh/">Homebrew</a> (<code class="docutils literal"><span class="pre">brew</span> <span class="pre">install</span> <span class="pre">bash</span></code>), add
<code class="docutils literal"><span class="pre">/usr/local/bin/bash</span></code> to <code class="docutils literal"><span class="pre">/etc/shells</span></code>, and run <code class="docutils literal"><span class="pre">chsh</span></code> to change your shell.</p>
<p class="last">Global completion is not currently compatible with zsh.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you use setuptools/distribute <code class="docutils literal"><span class="pre">scripts</span></code> or <code class="docutils literal"><span class="pre">entry_points</span></code> directives to package your module,
argcomplete will follow the wrapper scripts to their destination and look for <code class="docutils literal"><span class="pre">PYTHON_ARGCOMPLETE_OK</span></code> in the
destination code.</p>
</div>
<div class="section" id="activating-global-completion">
<h3>Activating global completion<a class="headerlink" href="#activating-global-completion" title="Permalink to this headline">¶</a></h3>
<p>The script <code class="docutils literal"><span class="pre">activate-global-python-argcomplete</span></code> will try to install the file
<code class="docutils literal"><span class="pre">bash_completion.d/python-argcomplete.sh</span></code> (<a class="reference external" href="https://github.com/kislyuk/argcomplete/blob/master/argcomplete/bash_completion.d/python-argcomplete.sh">see on GitHub</a>) into an appropriate location on your system
(<code class="docutils literal"><span class="pre">/etc/bash_completion.d/</span></code> or <code class="docutils literal"><span class="pre">~/.bash_completion.d/</span></code>). If it
fails, but you know the correct location of your bash completion scripts directory, you can specify it with <code class="docutils literal"><span class="pre">--dest</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>activate-global-python-argcomplete --dest=/path/to/bash_completion.d
</pre></div>
</div>
<p>Otherwise, you can redirect its shellcode output into a file:</p>
<div class="highlight-python"><div class="highlight"><pre>activate-global-python-argcomplete --dest=- &gt; file
</pre></div>
</div>
<p>The file’s contents should then be sourced in e.g. <code class="docutils literal"><span class="pre">~/.bashrc</span></code>.</p>
</div>
</div>
</div></body></html>