<html><body><div><div class="content html_format"><p>
      Хочу поделиться опытом своего первого участия в kaggle конкурсе (учебный </p><a href="https://www.kaggle.com/c/word2vec-nlp-tutorial">Bag of Words</a><p>). И хотя мне не удалось достичь поражающих воображение результатов, я расскажу о том, как искала и находила способы улучшить примеры “учебника” (для этого сами примеры тоже кратко опишу), а также остановлю внимание на разборе своих просчетов. Должна предупредить, что статья будет интересна прежде всего новичкам в области text mining. Тем не менее, большинство методов я описываю кратко и упрощенно, давая при этом ссылки на более точные определения, поскольку цель моя — обзор практики, а не теории. К сожалению, конкурс уже завершился, но прочитать материалы к нему все равно может быть полезно. Ссылка на код к статье </p><a href="https://github.com/Jaylla/NlpKaggleTraining">тут</a><p>.
</p><a name="habracut"/>
<h4>Обзор конкурса</h4><p>
Само задание состоит в анализе эмоциональной окраски текста. Для этого взяты отзывы и оценки к фильмам с сайта IMDb. Отзывы с оценкой &gt;=7 считаются позитивно окрашенными, с оценкой меньше — негативно. Задача: обучив модель на тренировочных данных, где каждому тексту проставлена оценка (негативный/позитивный), затем предсказать этот параметр для текстов из тестового сета. Качество предсказания оценивается с помощью параметра под названием </p><a href="https://ru.wikipedia.org/wiki/ROC-%D0%BA%D1%80%D0%B8%D0%B2%D0%B0%D1%8F">ROC-кривая</a><p>. Подробно можно прочитать по ссылке, но чем ближе этот параметр к 1 — тем точнее предсказание.
</p><p>
Все примеры написаны на языке Python и используют библиотеку </p><a href="http://scikit-learn.org/">scikit-learn</a><p>, которая позволяет использовать готовые реализации всех нужных нам классификаторов и векторизаторов. 

</p><h4>Методы решения задачи</h4><p>
В нашем распоряжении чистый текст, а все data mining классификаторы требуют на вход числовые векторы. Поэтому первейшая задача — определиться со способом преобразования текстового блока в вектор (векторизация).
</p><p>
Самый простой метод — Bag of Words, с которого начинается первый пример учебника. Метод заключается в создании общего пула используемых слов, каждому из которых присваивается свой индекс. Предположим, что у нас есть два простых текста:
</p><blockquote>John likes to watch movies. Mary likes movies too.<br/>
John also likes to watch football games.</blockquote><p>
Каждому уникальному слову поставим в соответствие индекс:

</p><i> «John»: 1,<br/>
 «likes»: 2,<br/>
 «to»: 3,<br/>
 «watch»: 4,<br/>
 «movies»: 5,<br/>
 «also»: 6,<br/>
 «football»: 7,<br/>
 «games»: 8,<br/>
 «Mary»: 9,<br/>
 «too»: 10</i>
<p>
Теперь каждое из этих предложений можно представить в виде вектора размерности 10, в котором число x в i-ой позиции означает, что слово под номером i встречается в тексте x раз:
</p><blockquote>[1, 2, 1, 1, 2, 0, 0, 0, 1, 1]<br/>
[1, 1, 1, 1, 0, 1, 1, 1, 0, 0]</blockquote><p>
Подробнее в </p><a href="https://en.wikipedia.org/wiki/Bag-of-words_model">википедии</a><p> или в этой обзорной </p><a href="http://habrahabr.ru/post/263171/">статье</a><p>, посвященной тому же конкурсу.
</p><p>
В общих чертах все просто, но дьявол в деталях. Во-первых, в примере удаляются слова </p><i>(a, the, am, i, is…)</i><p>, которые не несут никакой смысловой нагрузки. Во-вторых, операции с этой матрицей производятся в оперативной памяти, таким образом, объем памяти ограничивает допустимую размерность матрицы. Мне чтобы избежать </p><i>“MemoryError”</i><p> пришлось уменьшать пул слов до 7000 наиболее частых. В качестве классификатора во всех примерах учебника используется </p><a href="https://ru.wikipedia.org/wiki/Random_forest">Random Forest classifier</a><p>. 
</p><p>
Далее нас призывают поэкспериментировать с различными параметрами, что мы и сделаем. Первое очевидная мысль — добавить </p><a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BC%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">лемматизацию</a><p>, т.е. привести все слова к их словарным формам. Для этого используем функцию из библиотеки nltk:
</p><pre><code class="python">from nltk import WordNetLemmatizer
wnl = WordNetLemmatizer()
meaningful_words = [wnl.lemmatize(w) for w in meaningful_words]
</code></pre><p>
Другая хорошая идея — немного поменять метод векторизации текста. Вместо простой характеристики “сколько раз слово встретилось в тексте” можно использовать чуть более сложную, но тоже хорошо известную — </p><a href="https://ru.wikipedia.org/wiki/TF-IDF">tf-idf</a><p> (она присваивает словам ценность в зависимости от их редкости в коллекции документов). </p><p>
Отправив на проверку результаты исходной и модифицированной программы, получаем улучшение с 0.843 до 0.844. Это не очень много. Используя этот пример как основу можно хорошенько поэкспериментировать и получить гораздо лучшие результаты. Но у меня было не так много времени, а, следовательно, и попыток (они ограничены 5-ю в день). Поэтому я приступила к следующим частям.
</p><p>
Следующие части учебника строятся на библиотеке под названием </p><a href="https://code.google.com/p/word2vec/">Word2vec</a><p>, которая дает нам представление слов в виде числового вектора. Причем эти вектора обладают интересными свойствами. Например, минимальное расстояние между векторами будет у наиболее похожих по смыслу слов.
</p><p>
Итак, преобразовав все слова, получаем список векторов для каждого отзыва. Как преобразовать его в единый вектор? Первый вариант — просто вычислить среднее арифметическое (</p><a href="https://www.kaggle.com/c/word2vec-nlp-tutorial/details/part-3-more-fun-with-word-vectors">average vector</a><p>). Результат, даже хуже, чем Bag of Words (0.829).
</p><p>
Как можно было бы улучшить этот метод? Ясно, что нет смысла усреднять все слова, слишком много среди них мусора, не влияющего на эмоциональную окраску текста. Интуитивно кажется, что сильнее всего будут влиять оценочные прилагательные и, возможно, некоторые другие слова. На наше счастье, существуют методы под общим названием </p><a href="https://en.wikipedia.org/wiki/Feature_selection">feature selection</a><p>, которые позволяют оценить, насколько сильно тот или иной параметр (в нашем случае слово) коррелирует со значением результирующей переменной (эмоциональной окраской). Применим один из таких методов и взглянем, на выбранные слова:
</p><pre><code class="python">from sklearn.feature_selection import chi2
from sklearn.feature_selection import SelectKBest

select = SelectKBest(chi2, k=50)
X_new = select.fit_transform(train_data_features, train["sentiment"])
names = count_vectorizer.get_feature_names()
selected_words = np.asarray(names)[select.get_support()]
print(', '.join(selected_words))
</code></pre><p>
В результате получаем такой список слов, который подтверждает теорию:

</p><blockquote>acting, amazing, annoying, avoid, awful, bad, badly, beautiful, best, boring, brilliant, crap, dull, even, excellent, fantastic, favorite, great, highly, horrible, just, lame, laughable, love, loved, mess, minutes, money, no, nothing, oh, pathetic, perfect, plot, pointless, poor, poorly, ridiculous, save, script, stupid, superb, supposed, terrible, waste, wasted, why, wonderful, worse, worst</blockquote><p>
Если теперь вычислять average vector, но учтя только слова из топ-листа (который мы после пары экспериментов расширим до 500 слов), то получим результат лучше (0.846), который обходит даже (хотя и ненамного) bag of centroids из следующего учебного примера этого конкурса. В этом решении (обозначим его как average of top words) в качестве классификатора тоже использовался Random Forest. 

</p><h4>Работа над ошибками</h4><p>
На этом количество моих попыток, и собственно конкурс, подошли к концу, и я отправилась на форум выяснять, как решали эту задачу люди более опытные. Я не буду касаться </p><a href="https://www.kaggle.com/c/word2vec-nlp-tutorial/forums/t/14966/post-competition-solutions">решений</a><p>, которые получили действительно отличный результат (более 0.96) потому, что они как правило довольно сложные и многоходовые. Но укажу на некоторые варианты, которые позволили получить высокую точность простыми методами. 
</p><p>
Например, </p><a href="https://www.kaggle.com/c/word2vec-nlp-tutorial/forums/t/11261/beat-the-benchmark-with-shallow-learning-0-95-lb">указание</a><p> на то, что удалось достичь хорошего результата с помощью простого tf-idf и </p><a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D0%B3%D0%B8%D1%81%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%80%D0%B5%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D1%8F">логистической регрессии</a><p>, побудило меня исследовать другие классификаторы. При прочих равных (TfidfVectorizer с ограничением в 7000 столбцов) LogisticRegression дает результат — 0.88, </p><a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D1%8F">LinearRegression</a><p> — 0.91, </p><a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html">Ridge regression</a><p> — 0.92. 
</p><p>
Если бы я использовала линейную регрессию в своем решении (average of top words) вместо Random forest, то получила бы результат 0.93 вместо 0.84. Таким образом первая моя ошибка была в том, что я считала, что метод векторизации влияет сильнее, чем выбор классификатора. На ошибочные мысли меня натолкнул материал учебной статьи, но мне следовало все самостоятельно проверить.
</p><p>
Вторую идею я извлекла, внимательнее взглянув на код этого примера. Нюанс в том, как именно был использован TfidfVectorizer. Был взят сет из объединенных тестовых и тренировочных данных, не ставились ограничения на максимальное количество столбцов, более того, фичи формировались не только из отдельных слов, но и из </p><a href="https://ru.wikipedia.org/wiki/N-%D0%B3%D1%80%D0%B0%D0%BC%D0%BC">пар слов</a><p> (параметр ngram_range=(1, 2)). Если ваша программа не падает с MemoryError от такого объема, то это существенно повышает точность предсказания (автор заявил результат 0.95). Вывод номер два — точность можно повысить ценой большего объема вычислений, а не каких-то особо хитрых методов. Для этого можно, например, прибегнуть к какому-нибудь сервису для облачных вычислений, если собственный комп не слишком мощный.
</p><p>
В качестве заключения хочу сказать, что участвовать в конкурсе kaggle было крайне интересно, и ободрить тех, кто пока не решился по каким-либо причинам. Разумеется, на kaggle встречаются и гораздо более сложные конкурсы, для первого раза стоит выбирать задачу по силам. И последний совет — читайте форум. Даже в течение конкурса там публикуют полезные советы, идеи, а иногда даже целые решения.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>