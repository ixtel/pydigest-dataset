<html><body><div><div class="content_body" data-subscribe="true" data-view="content#body"><h2 id="django-versus-flask-when-django-is-the-wrong-choice">Django Versus Flask: When Django is the Wrong Choice</h2>

<p>I love and use <a href="https://www.toptal.com/django">Django</a> in lots of my personal and client projects, mostly for more classical web applications and those involving relational databases. However, Django is no silver bullet.</p>

<p>By design, Django is very tightly coupled with its ORM, Template Engine System, and Settings object. Plus, it’s not a new project: it carries a lot of baggage to remain backwards compatible.</p>

<p>Some Python developers see this as a major problem. They say that Django isn’t flexible enough and avoid it if possible and, instead, use a Python microframework like Flask.</p>

<p>I don’t share that opinion. Django is great when used in the <a href="https://www.toptal.com/django/installing-django-on-iis-a-step-by-step-tutorial">appropriate place and time</a>, even if it doesn’t fit into <em>every</em> project spec. As the mantra goes: “Use the right tool for the job”.</p>

<p>(Even when it is not the right place and time, sometimes programming with Django can have unique benefits.)</p>

<p>In some cases, it can indeed be nice to use a more lightweight framework (like <a href="http://flask.pocoo.org">Flask</a>). Often, these microframeworks start to shine when you realize how easy they are to hack on.</p>

<h2 id="microframeworks-to-the-rescue">Microframeworks to the Rescue</h2>

<p>In a few of my client projects, we’ve discussed giving up on Django and moving to a microframework, typically when the clients want to do some interesting stuff (in one case, for example, embedding <a href="http://zeromq.org/">ZeroMQ</a> in the application object) and the project goals seem more difficult to achieve with Django.</p>

<p>More generally, I find Flask useful for:</p>

<ul>
  <li>Simple REST API backends</li>
  <li>Applications that don’t require database access</li>
  <li>NoSQL-based web apps</li>
  <li>Web apps with very specific requirements, like custom URL configurations</li>
</ul>

<p>At the same time, our app required user registration and other common tasks that Django solved years ago. Given its light weight, Flask doesn’t come with the same toolkit.</p>

<p class="pop_out_box is-full_width is-big">
The question emerged: is Django an all-or-nothing deal?
</p>

<p>The question emerged: is Django an all-or-nothing deal? Should we drop it <em>completely</em> from the project, or can we learn to combine it with the flexibility of other microframeworks or traditional frameworks? Can we pick and choose the pieces we want to use and eschew others?</p>

<p>Can we have the best of both worlds? I say yes, especially when it comes to session management.</p>

<p>(Not to mention, there are a lot of projects out there for Django freelancers.)</p>

<h2 id="now-the-python-tutorial-sharing-django-sessions">Now the Python Tutorial: Sharing Django Sessions</h2>

<p>The goal of this post is to delegate the tasks of user authentication and registration to Django, yet use Redis to share user sessions with other frameworks. I can think of a few scenarios in which something like this would be useful:</p>

<ul>
  <li>You need to develop a REST API separately from your Django app but want to share session data.</li>
  <li>You have a specific component that may need to be replaced later on or scaled out for some reason and still need session data.</li>
</ul>

<p>For this tutorial, I’ll use <a href="http://www.sqlite.org">Redis</a> to share sessions between two frameworks (in this case, Django and Flask). In the current setup, I’ll use <a href="http://www.sqlite.org">SQLite</a> to store user information, but you can have your back-end tied to a NoSQL database (or a SQL-based alternative) if need be.</p>

<h2 id="understanding-sessions">Understanding Sessions</h2>

<p>To share sessions between Django and Flask, we need to know a bit about how Django stores its session information. The <a href="https://docs.djangoproject.com/en/dev/topics/http/sessions/">Django docs</a> are pretty good, but I’ll provide some background for completeness.</p>

<h3 id="session-management-varieties">Session Management Varieties</h3>

<p>Generally, you can choose to manage your Python app’s session data in one of two ways:</p>

<ul>
  <li>
    <p><em>Cookie-based sessions</em>: In this scenario, the session data is not stored in a data store on the back-end. Instead, it’s serialized, signed (with a SECRET_KEY), and sent to the client. When the client sends that data back, its integrity is checked for tampering and it is deserialized again on the server.</p>
  </li>
  <li>
    <p><em>Storage-based sessions</em>: In this scenario, the session data itself is <em>not</em> sent to the client. Instead, only a small portion is sent (a key) to indicate the identity of the current user, stored on the session store.</p>
  </li>
</ul>

<p>In our example, we’re more interested in the latter scenario: we want our session data to be stored on the back-end and then checked in Flask. The same thing could be done in the former, but as the Django documentation mentions, there are some <a href="https://docs.djangoproject.com/en/1.5/topics/http/sessions/#using-cookie-based-sessions">concerns about the security</a> of the first method.</p>

<h3 id="the-general-workflow">The General Workflow</h3>

<p>The general workflow of session handling and management will be similar to this diagram:</p>

<p><img src="//assets.toptal.io/uploads/blog/image/323/toptal-blog-image-1395282110322.png" alt="A diagram showing the management of user sessions between Flask and Django using Redis."/></p>

<p>Let’s walk through session sharing in a little more detail:</p>

<ol>
  <li>
    <p>When a new request comes in, the first step is to send it through the registered <a href="https://docs.djangoproject.com/en/dev/topics/http/middleware/">middleware</a> in the Django stack. We’re interested here in the <code>SessionMiddleware</code> class which, as you might expect, is related to session management and handling:</p>

    <pre><code>class SessionMiddleware(object):

    def process_request(self, request):
        engine = import_module(settings.SESSION_ENGINE)
        session_key = request.COOKIES.get(settings.SESSION_COOKIE_NAME, None)
        request.session = engine.SessionStore(session_key)
</code></pre>

    <p>In this snippet, Django grabs the registered <code>SessionEngine</code> (we’ll get to that soon), extracts the <code>SESSION_COOKIE_NAME</code> from <code>request</code> (<code>sessionid</code>, by default) and creates a new instance of the selected <code>SessionEngine</code> to handle session storage.</p>
  </li>
</ol>

<ul>
  <li>
    <p>Later on (after the user view is processed, but still in the middleware stack), the session engine calls its save method to save any changes to the data store. (During view handling, the user may have changed a few things within the session, e.g., by adding a new value to session object with <code>request.session</code>.) Then, the <code>SESSION_COOKIE_NAME</code> is sent to the client. Here’s the simplified version:</p>

    <pre><code>def process_response(self, request, response):
    ....

    if response.status_code != 500:
        request.session.save()
        response.set_cookie(settings.SESSION_COOKIE_NAME,
                request.session.session_key, max_age=max_age,
                expires=expires, domain=settings.SESSION_COOKIE_DOMAIN,
                path=settings.SESSION_COOKIE_PATH,
                secure=settings.SESSION_COOKIE_SECURE or None,
                httponly=settings.SESSION_COOKIE_HTTPONLY or None)

    return response
</code></pre>
  </li>
</ul>

<p>We’re particularly interested in the <code>SessionEngine</code> class, which we’ll replace with something to store and load data to and from a Redis back-end.</p>

<p>Fortunately, there are a few projects that already handle this for us. Here’s an example from <strong>redis_sessions_fork</strong>. Pay close attention to the  <code>save</code> and <code>load</code> methods, which are written so as to (respectively) store and load the session into and from Redis:</p>

<pre><code>class SessionStore(SessionBase):
    """
    Redis session back-end for Django
    """
    def __init__(self, session_key=None):
        super(SessionStore, self).__init__(session_key)

    def _get_or_create_session_key(self):
        if self._session_key is None:
            self._session_key = self._get_new_session_key()
        return self._session_key

    def load(self):
        session_data = backend.get(self.session_key)
        if not session_data is None:
            return self.decode(session_data)
        else:
            self.create()
            return {}

    def exists(self, session_key):
        return backend.exists(session_key)

    def create(self):
        while True:
            self._session_key = self._get_new_session_key()
            try:
                self.save(must_create=True)
            except CreateError:
                continue
            self.modified = True
            self._session_cache = {}
            return

    def save(self, must_create=False):
        session_key = self._get_or_create_session_key()
        expire_in = self.get_expiry_age()
        session_data = self.encode(self._get_session(no_load=must_create))
        backend.save(session_key, expire_in, session_data, must_create)

    def delete(self, session_key=None):
        if session_key is None:
            if self.session_key is None:
                return
            session_key = self.session_key
        backend.delete(session_key)
</code></pre>

<p>It’s important to understand how this class is operating as we’ll need to implement something similar on Flask to load session data. Let’s take a closer look with a REPL example:</p>

<pre><code>&gt;&gt;&gt; from django.conf import settings
&gt;&gt;&gt; from django.utils.importlib import import_module

&gt;&gt;&gt; engine = import_module(settings.SESSION_ENGINE)
&gt;&gt;&gt; engine.SessionStore()
&lt;redis_sessions_fork.session.SessionStore object at 0x3761cd0&gt;

&gt;&gt;&gt; store["count"] = 1
&gt;&gt;&gt; store.save()
&gt;&gt;&gt; store.load()
{u'count': 1}
</code></pre>

<p>The session store’s interface is pretty easy to understand, but there’s a lot going on under the hood. We should dig a little deeper so that we can implement something similar on Flask.</p>

<p><em>Note: You might ask, “Why not just copy the SessionEngine into Flask?” Easier said than done. As we discussed in the beginning, Django is tightly coupled with its Settings object, so you can’t just import some Django module and use it without any additional work.</em></p>

<h2 id="django-session-de-serialization">Django Session (De-)Serialization</h2>

<p>As I said, Django does a lot of work to mask the complexity of its session storage. Let’s check the Redis key that’s stored in the above snippets:</p>

<pre><code>&gt;&gt;&gt; store.session_key
u"ery3j462ezmmgebbpwjajlxjxmvt5adu"
</code></pre>

<p>Now, lets query that key on the redis-cli:</p>

<pre><code>redis 127.0.0.1:6379&gt; get "django_sessions:ery3j462ezmmgebbpwjajlxjxmvt5adu"
"ZmUxOTY0ZTFkMmNmODA2OWQ5ZjE4MjNhZmQxNDM0MDBiNmQzNzM2Zjp7ImNvdW50IjoxfQ=="
</code></pre>

<p>What we see here is a very long, <a href="http://en.wikipedia.org/wiki/Base64">Base64-encoded</a> string. To understand its purpose, we need to look at Django’s <code>SessionBase</code> class to see how it’s handled:</p>

<pre><code>class SessionBase(object):
    """
    Base class for all Session classes.
    """

    def encode(self, session_dict):
        "Returns the given session dictionary serialized and encoded as a string."
        serialized = self.serializer().dumps(session_dict)
        hash = self._hash(serialized)
        return base64.b64encode(hash.encode() + b":" + serialized).decode('ascii')

    def decode(self, session_data):
        encoded_data = base64.b64decode(force_bytes(session_data))
        try:
            hash, serialized = encoded_data.split(b':', 1)
            expected_hash = self._hash(serialized)
            if not constant_time_compare(hash.decode(), expected_hash):
                raise SuspiciousSession("Session data corrupted")
            else:
                return self.serializer().loads(serialized)
        except Exception as e:
            # ValueError, SuspiciousOperation, unpickling exceptions
            if isinstance(e, SuspiciousOperation):
                logger = logging.getLogger('django.security.%s' %
                        e.__class__.__name__)
                logger.warning(force_text(e))
            return {}
</code></pre>

<p>The encode method first serializes the data with the current registered serializer. In other words, it converts the session into a string, which it can later convert back into a session (look at the <a href="https://docs.djangoproject.com/en/1.5/ref/settings/#std:setting-SESSION_SERIALIZER">SESSION_SERIALIZER documentation</a> for more). Then, it hashes the serialized data and uses this hash later on as a signature to check the integrity of the session data. Finally, it returns that data pair to the user as a Base64-encoded string.</p>

<p><em>By the way: before version 1.6, Django defaulted to using pickle for serialization of session data. Due to <a href="https://docs.djangoproject.com/en/1.5/topics/http/sessions/#using-cookie-based-sessions">security concerns</a>, the <a href="https://docs.djangoproject.com/en/1.5/topics/http/sessions/#session-serialization">default serialization</a> method is now <code>django.contrib.sessions.serializers.JSONSerializer</code>.</em></p>

<h3 id="encoding-an-example-session">Encoding an Example Session</h3>

<p>Let’s see the session management process in action. Here, our session dictionary will simply be a count and some integer, but you can imagine how this would generalize to more complicated user sessions.</p>

<pre><code>&gt;&gt;&gt; store.encode({'count': 1})
u'ZmUxOTY0ZTFkMmNmODA2OWQ5ZjE4MjNhZmQxNDM0MDBiNmQzNzM2Zjp7ImNvdW50IjoxfQ=='

&gt;&gt;&gt; base64.b64decode(encoded)
'fe1964e1d2cf8069d9f1823afd143400b6d3736f:{"count":1}'
</code></pre>

<p>The result of the store method (u’ZmUxOTY…==’) is an encoded string containing the serialized user session <em>and</em> its hash. When we decode it, we indeed get back both the hash (‘fe1964e…’) and the session (<code>{"count":1}</code>).</p>

<p>Note that the decode method checks to ensure that the hash is correct for that session, guaranteeing integrity of the data when we go to use it in Flask. In our case, we’re not too worried about our session being tampered with on the client side because:</p>

<ul>
  <li>
    <p>We aren’t using cookie-based sessions, i.e., we’re not sending <em>all</em> user data to the client.</p>
  </li>
  <li>
    <p>On Flask, we’ll need a read-only <code>SessionStore</code> which will tell us if given key exists or not and return the stored data.</p>
  </li>
</ul>

<h2 id="extending-to-flask">Extending to Flask</h2>

<p>Next, let’s create a simplified version of the Redis session engine (database) to work with Flask. We’ll use the same <code>SessionStore</code> (defined above) as a base class, but we’ll need to remove some of its functionality, e.g., checking for bad signatures or modifying sessions. We’re more interested in a read-only <code>SessionStore</code> that will load the session data saved from Django. Let’s see how it comes together:</p>

<pre><code>class SessionStore(object):

    # The default serializer, for now
    def __init__(self, conn, session_key, secret, serializer=None):

        self._conn = conn
        self.session_key = session_key
        self._secret = secret
        self.serializer = serializer or JSONSerializer

    def load(self):
        session_data = self._conn.get(self.session_key)

        if not session_data is None:
            return self._decode(session_data)
        else:
            return {}

    def exists(self, session_key):
        return self._conn.exists(session_key)


    def _decode(self, session_data):
        """
        Decodes the Django session
        :param session_data:
        :return: decoded data
        """
        encoded_data = base64.b64decode(force_bytes(session_data))
        try:
            # Could produce ValueError if there is no ':'
            hash, serialized = encoded_data.split(b':', 1)
            # In the Django version of that they check for corrupted data
            # I don't find it useful, so I'm removing it
            return self.serializer().loads(serialized)
        except Exception as e:
            # ValueError, SuspiciousOperation, unpickling exceptions. If any of
            # these happen, return an empty dictionary (i.e., empty session).
            return {}
</code></pre>

<p>We only need the <code>load</code> method because it’s a read-only implementation of the storage. That means you can’t logout directly from Flask; instead, you might want to redirect this task to Django. Remember, the goal here is to manage sessions between these two Python frameworks to give you more flexibility.</p>

<h2 id="flask-sessions">Flask Sessions</h2>

<p>The Flask microframework supports cookie-based sessions, which means all of the session data is sent to the client, Base64-encoded and cryptographically signed. But actually, we’re not very interested in Flask’s session support.</p>

<p>What we need is to get the session ID created by Django and check it against the Redis back-end so that we can be sure the request belongs to a pre-signed user. In summary, the ideal process would be (this syncs up with the diagram above):</p>

<ul>
  <li>We grab the Django session ID from the user’s cookie.</li>
  <li>If the session ID is found in Redis, we return the session matching that ID.</li>
  <li>If not, we redirect them to a login page.</li>
</ul>

<p>It’ll be handy to have a decorator to check for that information and set the current <code>user_id</code> into the <code>g</code> variable in Flask:</p>

<pre><code>from functools import wraps
from flask import g, request, redirect, url_for

def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        djsession_id = request.cookies.get("sessionid")
        if djsession_id is None:
            return redirect("/")

        key = get_session_prefixed(djsession_id)
        session_store = SessionStore(redis_conn, key)
        auth = session_store.load()

        if not auth:
            return redirect("/")

        g.user_id = str(auth.get("_auth_user_id"))

        return f(*args, **kwargs)
    return decorated_function
</code></pre>

<p>In the example above, we’re still using the <code>SessionStore</code> we defined previously to fetch the Django data from Redis. If the session has an <code>_auth_user_id</code>, we return the content from the view function; otherwise, the user is redirected to a login page, just like we wanted.</p>

<h2 id="gluing-things-together">Gluing Things Together</h2>

<p>In order to share cookies, I find it convenient to start Django and Flask via a <a href="http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface">WSGI</a> server and glue them together. In this example, I’ve used <a href="http://www.cherrypy.org">CherryPy</a>:</p>

<pre><code>from app import app
from django.core.wsgi import get_wsgi_application

application = get_wsgi_application()

d = wsgiserver.WSGIPathInfoDispatcher({
    "/":application,
    "/backend":app
})
server = wsgiserver.CherryPyWSGIServer(("127.0.0.1", 8080), d)
</code></pre>

<p>With that, Django will serve on “/” and Flask will serve on “/backend” endpoints.</p>

<h2 id="in-conclusion">In Conclusion</h2>

<p>Rather than examining Django versus Flask or encouraging you only to learn the Flask microframework, I’ve welded together Django and Flask, getting them to share the same session data for authentication by delegating the task to Django. As Django ships with plenty of modules to solve user registration, login, and logout (just to name a few), combining these two frameworks will save you valuable time while providing you with the opportunity to hack on a manageable microframework like Flask.</p>
<div class="blog_author_big_banner is-active" data-ga-action="ClickedOnHireTheAuthor_bottom" data-ga-label="django-flask-and-redis-sharing-user-sessions-between-frameworks" data-view="content#bottom_banner"><h2>About the author</h2><div class="skill_talent for-blog_post"><div class="skill_talent-main"><a class="link skill_talent-name" href="/resume/denis-kyorov">Denis Kyorov, Bulgaria</a><div class="clearfix"><p class="skill_talent-member_since">member since December 2, 2013</p></div><div class="skill_talent-description"><p>Denis is an experienced Python developer (5+ years) who has contributed to a wide range of challenging projects involving distributed systems, back-end RESTful programming with Flask and Django, and embedded programming. </p><a class="link" href="/resume/denis-kyorov">[click to continue...]</a></div></div></div></div><p class="template" data-role="subscribe_template" data-template="{&quot;html&quot;:&quot;\u003cdiv class=\&quot;embeddable_form-wrapper\&quot; data-view=\&quot;blog_subscribe#form\&quot;\u003e\u003cform action=\&quot;/blog/subscription\&quot; class=\&quot;embeddable_form for-post\&quot; data-entity=\&quot;blog_subscription\&quot; data-remote=\&quot;\&quot; data-view=\&quot;form#form\&quot; method=\&quot;post\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-step is-email_form is-current\&quot; data-role=\&quot;step\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-row is-label\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-label_title\&quot;\u003eLike what you\u0026#39;re reading?\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-label\&quot;\u003eGet the latest updates first.\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row form-field is-email_field\&quot;\u003e\u003cinput autocomplete=\&quot;off\&quot; class=\&quot;input is-medium\&quot; data-role=\&quot;email\&quot; name=\&quot;blog_subscription[email]\&quot; placeholder=\&quot;Enter your email address...\&quot; type=\&quot;text\&quot; /\u003e\u003cinput name=\&quot;blog_subscription[vertical]\&quot; type=\&quot;hidden\&quot; value=\&quot;developers\&quot; /\u003e\u003cinput name=\&quot;from_widget\&quot; type=\&quot;hidden\&quot; value=\&quot;true\&quot; /\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-submit\&quot;\u003e\u003cinput class=\&quot;button is-green_candy is-default is-full_width\&quot; data-loader-text=\&quot;Subscribing...\&quot; data-role=\&quot;submit\&quot; type=\&quot;submit\&quot; value=\&quot;Get Exclusive Updates\&quot; /\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-privacy\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-privacy\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-privacy_icon\&quot;\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-privacy_text\&quot;\u003eNo spam. Just great engineering and design posts.\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-step is-confirmation\&quot; data-role=\&quot;step\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-row is-label is-success\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-label_title\&quot;\u003eLike what you\u0026#39;re reading?\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-label\&quot;\u003eGet the latest updates first.\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-success\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-label is-header\&quot;\u003eThank you for subscribing!\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-label\&quot;\u003eYou can edit your subscription preferences \u003ca href='#' data-role='preferences_link'\u003ehere\u003c/a\u003e.\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-success\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-done\&quot;\u003e\u003cul class=\&quot;blog_follow_us\&quot;\u003e\u003cul class=\&quot;social_share\&quot;\u003e\u003cli class=\&quot;social_share-item is-facebook\&quot;\u003e\u003cdiv class=\&quot;fb-like\&quot; data-href=\&quot;https://www.toptal.com/blog\&quot; data-layout=\&quot;button_count\&quot; data-send=\&quot;false\&quot; data-show-faces=\&quot;false\&quot; data-width=\&quot;450\&quot;\u003e\u003c/div\u003e\u003c/li\u003e\u003cli class=\&quot;social_share-item is-twitter_follow\&quot;\u003e\u003ca class=\&quot;twitter-follow-button\&quot; data-show-count=\&quot;true\&quot; href=\&quot;https://twitter.com/toptalllc\&quot;\u003eFollow @toptalllc\u003c/a\u003e\u003c/li\u003e\u003cli class=\&quot;social_share-item is-google_plus_follow\&quot;\u003e\u003cdiv class=\&quot;g-follow\&quot; data-annotation=\&quot;bubble\&quot; data-height=\&quot;20\&quot; data-href=\&quot;https://plus.google.com/109028009576318848424\&quot; data-rel=\&quot;publisher\&quot;\u003e\u003c/div\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/form\u003e\u003c/div\u003e&quot;}"/></div></div></body></html>