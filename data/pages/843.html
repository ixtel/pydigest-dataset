<html><body><div><li id="1">
    <a href="/articles/1-understanding-python-by-breaking-it---lvl-2.html"><h1>Understanding Python by breaking it - Lvl 2
</h1></a>
    <div class="infos"><p>Written by <a href="/authors/hakril/index.html">Hakril</a><br/>2014-05-15 17:51:12</p></div>
    <p/><p>After my first article I kept playing with <code>ctypes</code> and tried to see what fun things that could be possible with little modifications to the Python's objects at runtime.
The goal of this article is to explain how to <strong>get reliable native code execution as a simple Python objet</strong>.
By reliable I mean: that, if our payload respect certain rules, we can call it multiple times from the same Python code.</p>
<p>If you have not read my <a href="http://blog.hakril.net/articles/0-understanding-python-by-breaking-it.html">previous article</a>, here is what you need to know:</p>
<ul>
<li>the <code>ctypes</code> module allows you to manipulate C structure from Python,</li>
<li>we can map a <code>ctypes</code> structure on a given address using <code>struct.from_address</code>,</li>
<li>in CPython: <code>id(obj)</code> returns the address of obj.</li>
</ul>
<h2>Using <code>ctypes.Structure</code></h2>
<p>Last time, I only used <code>id(obj)</code> to access the internal variables of an object. This time we need to do more complex things, so I am going to use the <code>ctypes.Structure</code> type for more readability.<br/>
Here is an example:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span class="kn">import</span> <span class="nn">ctypes</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">PyObj</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">"ob_refcnt"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">),</span>
<span class="o">...</span>                 <span class="p">(</span><span class="s">"ob_type"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">)]</span> <span class="c"># Must be casted</span>

<span class="c"># Inheritance of ctypes.Structure: PyVarObj will also have the fields of PyObj</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">PyVarObj</span><span class="p">(</span><span class="n">PyObj</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">"ob_size"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">lm</span> <span class="o">=</span> <span class="n">PyVarObj</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lm</span><span class="o">.</span><span class="n">ob_refcnt</span>
<span class="il">1L</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lm</span><span class="o">.</span><span class="n">ob_size</span>
<span class="il">4L</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lm</span><span class="o">.</span><span class="n">ob_size</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<p>Now we have a nice way to access to C-only data with readable and explicite names!  </p>
<p>So, let's get to work !</p>
<h2>Dummy code execution</h2>
<h3>Instruction Pointer Control</h3>
<p>Before having a nice and reliable native code execution, the first step is having code execution at all.
The most obvious type we want to check is <em>built-in function</em>, this is a Python type that represents native code.</p>
<p>Let's have a look at the structure of a <em>built-in function</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="codehilite"><pre><span class="cm">/** My own comments begin by '**' **/</span>
<span class="cm">/** From: Include/methodobject.h **/</span>

<span class="k">typedef</span> <span class="n">PyObject</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">PyCFunction</span><span class="p">)(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="p">);</span> <span class="cm">/** A standard function pointer **/</span>

<span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">ml_name</span><span class="p">;</span>   <span class="cm">/* The name of the built-in function/method */</span>
    <span class="n">PyCFunction</span>  <span class="n">ml_meth</span><span class="p">;</span>   <span class="cm">/* The C function that implements it */</span>
    <span class="kt">int</span>      <span class="n">ml_flags</span><span class="p">;</span>  <span class="cm">/* Combination of METH_xxx flags, which mostly</span>
<span class="cm">                   describe the args expected by the C func */</span>
    <span class="k">const</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">ml_doc</span><span class="p">;</span>    <span class="cm">/* The __doc__ attribute, or NULL */</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyMethodDef</span> <span class="o">*</span><span class="n">m_ml</span><span class="p">;</span> <span class="cm">/* Description of the C function to call */</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">m_self</span><span class="p">;</span> <span class="cm">/* Passed as 'self' arg to the C func, can be NULL */</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">m_module</span><span class="p">;</span> <span class="cm">/* The __module__ attribute, can be anything */</span>
<span class="p">}</span> <span class="n">PyCFunctionObject</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<p>We can see that a <code>PyCFunctionObject</code> is just a C function pointer with some meta-data.<br/>
Here is the <code>ctypes</code> structure that represents those two structs:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="codehilite"><pre><span class="k">class</span> <span class="nc">PyMethodDef</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">"ml_name"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char</span><span class="p">)),</span> <span class="p">(</span><span class="s">"ml_meth"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">),</span>
            <span class="p">(</span><span class="s">"ml_flags"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s">"ml_doc"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char</span><span class="p">))]</span>

<span class="c"># Reuse of PyObj from the first example</span>
<span class="k">class</span> <span class="nc">PyCFunctionObject</span><span class="p">(</span><span class="n">PyObj</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">"m_ml"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">PyMethodDef</span><span class="p">)),</span>
        <span class="p">(</span><span class="s">"m_self"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">),</span> <span class="p">(</span><span class="s">"m_module"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">)]</span>

<span class="c"># The only new thing is ctypes.POINTER.</span>
<span class="c"># This represent a pointer to another type, the</span>
<span class="c"># content can be accessed by using `.contents`</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">mabs</span> <span class="o">=</span> <span class="n">PyCFunctionObject</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="nb">abs</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mabs</span><span class="o">.</span><span class="n">m_ml</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">ml_name</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="s">'abs'</span>
</pre></div>
</td></tr></table>

<p>It seems to work. Now we need to see if code execution works too.  </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span class="c"># Launching Python into GDB to nicely handle the crash</span>
<span class="nv">$ </span>gdb -q -args <span class="sb">`</span>which python<span class="sb">`</span> -i intro_type.py
...
<span class="c"># Get the address of the builtin `abs`</span>
<span class="o">(</span>gdb<span class="o">)</span> x/i <span class="s1">'builtin_abs.32990'</span>
   0x51c8f0 &lt;builtin_abs.32990&gt;:        sub    <span class="nv">$0x8</span>,%rsp 
<span class="o">(</span>gdb<span class="o">)</span> r
...
&gt;&gt;&gt; <span class="c"># repeat code of last example</span>
<span class="c"># See if the `abs` C code match with what we found in gdb</span>
&gt;&gt;&gt; mabs.m_ml.contents.ml_meth
<span class="s1">'0x51c8f0'</span>
&gt;&gt;&gt; mabs.m_ml.contents.ml_meth <span class="o">=</span> 0x42424242
&gt;&gt;&gt; abs<span class="o">(</span>-1<span class="o">)</span>
<span class="c"># Yeah!</span>
Program received signal SIGSEGV, Segmentation fault.
0x0000000042424242 in ?? <span class="o">()</span>
<span class="o">(</span>gdb<span class="o">)</span>
</pre></div>
</td></tr></table>

<p>That was easy! but this part was the simple one. If we want to get reliable code execution many steps remain.</p>
<h3>Executing our code</h3>
<p>The next step is to actually execute some of our code.
For that, I chose the <code>mmap</code> module to create executable pages and stuff them with code and data.</p>
<p>There is only two problems with the <code>mmap</code> module:</p>
<ul>
<li>the <code>mmap</code> type doesn't expose the actual address of the page to Python (as usual we will use <code>ctypes</code> to figure that out),</li>
<li>the <code>mmap</code> "API" is not the same for Linux and Windows (I have simply created my own platform-independant wrapper for that).</li>
</ul>
<p>How to get the real address of the mmaped page? same procedure as usual:</p>
<table class="codehilitetable"><tr><td class="linenos"/><td class="code"><div class="codehilite"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="kt">char</span> <span class="o">*</span>      <span class="n">data</span><span class="p">;</span>
    <span class="kt">size_t</span>      <span class="n">size</span><span class="p">;</span>
    <span class="kt">size_t</span>      <span class="n">pos</span><span class="p">;</span>    <span class="cm">/* relative to offset */</span>
    <span class="p">...</span> <span class="cm">/** Other fields that are non-relevant to our goal **/</span>
<span class="p">}</span> <span class="n">mmap_object</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<p>All we need is the first field, which points to our page.
In the following examples, all <code>PyObj</code> that I describe can be found in the file <code>intro_type.py</code>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="codehilite"><pre><span class="kn">import</span> <span class="nn">intro_type</span>
<span class="kn">import</span> <span class="nn">mmap</span>
<span class="c"># Ctypes object for introspection</span>
<span class="k">class</span> <span class="nc">PyMmap</span><span class="p">(</span><span class="n">intro_type</span><span class="o">.</span><span class="n">PyObj</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">"ob_addr"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">)]</span>


<span class="c"># Specific mmap class for code injection</span>
<span class="k">class</span> <span class="nc">MyMap</span><span class="p">(</span><span class="n">mmap</span><span class="o">.</span><span class="n">mmap</span><span class="p">):</span>
    <span class="sd">""" A mmap that is never unmaped and that contains the page address """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">):</span>
        <span class="c"># Get the page address by introspection of the C struct</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">PyMmap</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">ob_addr</span>
        <span class="c"># Prevent garbage collection (and so the unmapping) of the page</span>
        <span class="n">m</span><span class="o">.</span><span class="n">ob_refcnt</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_map</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> 
    <span class="sd">""" Returns a page of size 'size': the implementation is not important for our example.</span>
<span class="sd">        See the repository if you want the actual code. ;)</span>
<span class="sd">    """</span>
</pre></div>
</td></tr></table>

<p>Now, to be sure that our first step (simple code execution) works, we will replace the <code>abs</code> builtin by an <code>identity</code> one, equivalent to <code>lambda x : x</code>.</p>
<p>I run a <code>64 bits</code> Python so the example of native code here is 64 bits, if you want the 32 bits version: look at the repository. ;)<br/>
The payload used for identity is: </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="codehilite"><pre>    <span class="c"># All ctypes structs and MyMap classes are in the intro_type.py file.</span>
    <span class="kn">import</span> <span class="nn">intro_type</span>

    <span class="c"># RSI is the first argument we pass and RAX is the return value.</span>
    <span class="c"># So we just return our first argument.</span>

    <span class="c"># Normally, the first argument of a function is RDI but builtins receive a 'self' as the actual first argument.</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="s">"4889F0"</span> <span class="o">+</span> <span class="s">"C3"</span>  <span class="c"># mov rax, rsi ; ret</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">payload</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">'hex'</span><span class="p">)</span>

    <span class="c"># Get a page.</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">intro_type</span><span class="o">.</span><span class="n">MyMap</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">)</span>
    <span class="c"># Put our payload at the beginning.</span>
    <span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)]</span> <span class="o">=</span> <span class="n">payload</span>
    <span class="n">mabs</span> <span class="o">=</span> <span class="n">intro_type</span><span class="o">.</span><span class="n">PyCFunctionObject</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="nb">abs</span><span class="p">))</span>
    <span class="c"># Change the function pointer to the address of our payload.</span>
    <span class="n">mabs</span><span class="o">.</span><span class="n">m_ml</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">ml_meth</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="n">addr</span>

    <span class="o">&gt;&gt;&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="mi">4</span>
    <span class="c"># Well it doesn't segfault: good news!</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span>
    <span class="o">-</span><span class="mi">4</span> 
    <span class="c"># Well this is not the real abs anymore: another good news!</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="o">&lt;</span><span class="n">refcnt</span> <span class="mi">0</span> <span class="n">at</span> <span class="mh">0x7f48b121eaa0</span><span class="o">&gt;</span>
    <span class="c"># Yep, do not forget that our function doesn't increment the refcount of the returned object.</span>
    <span class="c"># This version can lead to crash!</span>
</pre></div>
</td></tr></table>

<p>Perfect, our dummy code execution works!</p>
<h2>Object hand-crafting</h2>
<p>The next step of our journey is the hand-crafting of some Python objects.<br/>
Why? because it's fun and it will be useful for our final goal!</p>
<h3>Writing raw objects in memory</h3>
<p>The first step of object crafting is to write the object data in memory.<br/>
For that, we are going to use the <code>struct</code> module (another really useful module).
In this example we write the data for an <code>int</code> object (in 64 bits Python):</p>
<table class="codehilitetable"><tr><td class="linenos"/><td class="code"><div class="codehilite"><pre><span class="cm">/** here is the struct that represents an int **/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="kt">long</span> <span class="n">ob_ival</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyIntObject</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<p>So: </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span class="kn">import</span> <span class="nn">struct</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">help</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack_into</span><span class="p">)</span>
<span class="n">pack_into</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
   <span class="n">Pack</span> <span class="n">the</span> <span class="n">values</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="o">...</span> <span class="n">according</span> <span class="n">to</span> <span class="n">fmt</span><span class="o">.</span>
   <span class="n">Write</span> <span class="n">the</span> <span class="n">packed</span> <span class="nb">bytes</span> <span class="n">into</span> <span class="n">the</span> <span class="n">writable</span> <span class="nb">buffer</span> <span class="n">buf</span> <span class="n">starting</span> <span class="n">at</span> <span class="n">offset</span><span class="o">.</span>
<span class="c"># This module heavily uses the struct format.</span>
<span class="c"># Doc is here: https://docs.python.org/2/library/struct.html.</span>

<span class="c"># Write three unsigned long long in little endian at offset 0 of 'page'.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack_into</span><span class="p">(</span><span class="s">"&lt;QQQ"</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="mi">2</span><span class="p">,</span>       <span class="c">#ob_refcnt</span>
        <span class="nb">id</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="c"># ob_type            </span>
        <span class="mi">42</span><span class="p">)</span>      <span class="c"># ob_ival</span>

<span class="c"># That's all!</span>
<span class="c"># Problem is: I have no way to prove you that it works before the next sub-step. :(</span>
<span class="c"># Trust me!</span>
</pre></div>
</td></tr></table>

<p>The problem is: even if we have crafted a valid <code>int</code> in memory,
it is not usable since the Python interpreter as no reference to it.<br/>
The next step is to create a reference to our crafted objet.</p>
<h3>Giving life to the crafted object</h3>
<p>Here is the problem:</p>
<ul>
<li>we have a valid object in memory,</li>
<li>we have its address,</li>
<li>the Python interpreter have no reference to it,</li>
<li>we need to create the reference to give life to our object.</li>
</ul>
<p>All we have to do is call a function that can return arbitrary valid references.</p>
<p>The easiest way is to return the address (so the object) corresponding to the value of the <code>int</code> we receive as parameter.<br/>
Think of it as the reverse <code>id</code> function:</p>
<table class="codehilitetable"><tr><td class="linenos"/><td class="code"><div class="codehilite"><pre><span class="c"># How our function should work:</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="mi">140147953449472</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_func</span><span class="p">(</span><span class="mi">140147953449472</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>If this description is not enough, here is what the C code should be:</p>
<table class="codehilitetable"><tr><td class="linenos"/><td class="code"><div class="codehilite"><pre><span class="n">PyObject</span><span class="o">*</span> <span class="nf">my_func</span><span class="p">(</span><span class="n">PyIntObject</span><span class="o">*</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">ob_ival</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/** Here we can see can the function can be harmful if wrongly used **/</span>
</pre></div>
</td></tr></table>

<p>So, here are the payloads for this function:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span class="c"># int-to-object payloads:</span>

<span class="c"># 64bits</span>
<span class="c"># mov rax, [rsi + 0x10] # rsi is the address of the int; [rsi + 0x10] the ob_ival of the int</span>
<span class="c"># ret</span>
<span class="n">bootstrap_64</span> <span class="o">=</span> <span class="s">"48 8b 46 10 C3"</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">" "</span><span class="p">,</span> <span class="s">""</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">)</span>

<span class="c"># 32bits</span>
<span class="c"># mov eax, [esp + 8] # [esp + 8] -&gt; builtin argument</span>
<span class="c"># mov eax, [eax + 0x8] # [eax + 14] ob_ival</span>
<span class="c"># ret</span>
<span class="n">bootstrap_32</span> <span class="o">=</span> <span class="s">"8B 44 24 08 8B 40 08 C3"</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">" "</span><span class="p">,</span> <span class="s">""</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Putting everything together, we get:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="codehilite"><pre><span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">intro_type</span>

<span class="c"># Write our object into a page.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">page</span> <span class="o">=</span> <span class="n">intro_type</span><span class="o">.</span><span class="n">MyMap</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack_into</span><span class="p">(</span><span class="s">"&lt;QQQ"</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="mi">42</span><span class="p">)</span>
<span class="c"># Put the payload just after our int object in the page.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bootstrap_64</span> <span class="o">=</span> <span class="s">"48 8b 46 10 C3"</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">" "</span><span class="p">,</span> <span class="s">""</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">page</span><span class="p">[</span><span class="mi">24</span><span class="p">:</span><span class="mi">24</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">bootstrap_64</span><span class="p">)]</span> <span class="o">=</span> <span class="n">bootstrap_64</span>
<span class="c"># Replace abs by our function.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mabs</span> <span class="o">=</span> <span class="n">intro_type</span><span class="o">.</span><span class="n">PyCFunctionObject</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="nb">abs</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mabs</span><span class="o">.</span><span class="n">m_ml</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">ml_meth</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="n">addr</span> <span class="o">+</span> <span class="mi">24</span>
<span class="c"># Give life to our int!</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">page</span><span class="o">.</span><span class="n">addr</span><span class="p">))</span>
<span class="c">#IT'S ALIVE!!</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="mi">42</span>
<span class="c"># Proof that our int is not the original 42 (addresses comparaison).</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="ow">is</span> <span class="mi">42</span>
<span class="bp">False</span>
<span class="c"># Proof that we have an object at the beginning of our page.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="s">'0x7ffff7ff8000L'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">hex</span><span class="p">(</span><span class="n">page</span><span class="o">.</span><span class="n">addr</span><span class="p">)</span>
<span class="s">'0x7ffff7ff8000L'</span>
</pre></div>
</td></tr></table>

<p>We are now able to create Python objects out of the great void!
We are near our goal.</p>
<h2>Reliable native code execution</h2>
<p>The problems with the previous dummy code execution are:</p>
<ul>
<li>we have a limited number of different functions (limited by the number of existing builtins),</li>
<li>each time we create a new dummy-execution we lose a builtin,</li>
<li>we put the interpreter in an instable state as any part of the code could potentially use a replaced buitlin without knowing.</li>
</ul>
<p>With the tools we acquired previously, the obvious solution to these problems is:
<strong>we are going to craft our own builtin objects!</strong>  </p>
<p>By doing so, we can have any number of different native functions without putting the interpreter in an unstable state by replacing builtins.</p>
<p>So here are the steps to create a complete builtin object:</p>
<ul>
<li>Write our payload on a page.</li>
<li>
<p>Write a <code>PyMethodDef</code> on the page with the following values:</p>
<ul>
<li><code>ml_name</code>: address of a C string (using <code>ctypes.addressof(ctypes.create_string_buffer(name))</code>),</li>
<li><code>ml_math</code>: address of the payload,</li>
<li><code>ml_flags</code>: <code>8</code> for <code>METH_O</code> (method with a simple object, can be changed depending of our need),</li>
<li><code>ml_doc</code>: <code>0</code> (no need to document so <code>None</code> is cool) or address of a C string.</li>
</ul>
</li>
<li>
<p>Write a <code>PyCFunctionObject</code> on the page with the following values:</p>
<ul>
<li><code>ob_refcnt</code>: <code>0x42</code> (we really don't want it to be collected since not allocated by Python),</li>
<li><code>ob_type</code>: <code>&lt;type 'builtin_function_or_method'&gt;</code> so <code>id(type(abs))</code> is fine,</li>
<li><code>m_ml</code>: address of <code>PyMethodDef</code>,</li>
<li><code>m_self</code>: <code>0</code>,</li>
<li><code>m_module</code>: <code>0</code> (or any <code>PyObj</code> address).</li>
</ul>
</li>
<li>
<p>Give life to our object (see previous section).</p>
</li>
</ul>
<p>Here is a demo for <code>x86_64</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="codehilite"><pre><span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">intro_type</span> 
<span class="k">def</span> <span class="nf">create_builtin</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">"crafted builtin"</span><span class="p">):</span>
    <span class="sd">""" Dummy implementation of 'create_builtins' for x86_64"""</span>
    <span class="c"># Create page.</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">intro_type</span><span class="o">.</span><span class="n">MyMap</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">)</span>
    <span class="c"># Get a C string with the name.</span>
    <span class="n">cname</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">name_addr</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">addressof</span><span class="p">(</span><span class="n">cname</span><span class="p">)</span>
    <span class="c"># Write the payload on the page.</span>
    <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="p">)]</span> <span class="o">=</span> <span class="n">code</span>
    <span class="c"># Write the PyMethodDef on the page.</span>
    <span class="n">struct</span><span class="o">.</span><span class="n">pack_into</span><span class="p">(</span><span class="s">"&lt;QQQQ"</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span>
        <span class="n">name_addr</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">addr</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">name_addr</span><span class="p">)</span>
    <span class="c"># Write the PyCFunctionObject on the page.</span>
    <span class="n">struct</span><span class="o">.</span><span class="n">pack_into</span><span class="p">(</span><span class="s">"&lt;QQQQQ"</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mh">0x200</span><span class="p">,</span>
        <span class="mi">42</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="nb">min</span><span class="p">)),</span> <span class="n">m</span><span class="o">.</span><span class="n">addr</span> <span class="o">+</span> <span class="mh">0x100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c"># Give life to our object.</span>
    <span class="k">return</span> <span class="n">give_life_to_obj</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">addr</span> <span class="o">+</span> <span class="mh">0x200</span><span class="p">))</span>


<span class="c"># Create page with our `give_life_to_obj` payload.</span>
<span class="n">code_page</span> <span class="o">=</span> <span class="n">intro_type</span><span class="o">.</span><span class="n">MyMap</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">)</span>
<span class="n">bootstrap_64</span> <span class="o">=</span> <span class="s">"48 8b 46 10 C3"</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">" "</span><span class="p">,</span> <span class="s">""</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">)</span>
<span class="n">code_page</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">bootstrap_64</span><span class="p">)]</span> <span class="o">=</span> <span class="n">bootstrap_64</span>
<span class="c"># Replace abs by our function.</span>
<span class="n">mabs</span> <span class="o">=</span> <span class="n">intro_type</span><span class="o">.</span><span class="n">PyCFunctionObject</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="nb">abs</span><span class="p">))</span>
<span class="n">mabs</span><span class="o">.</span><span class="n">m_ml</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">ml_meth</span> <span class="o">=</span> <span class="n">code_page</span><span class="o">.</span><span class="n">addr</span>
<span class="n">give_life_to_obj</span> <span class="o">=</span> <span class="nb">abs</span>
<span class="c"># A builtin that trigger a breakpoint when executed.</span>
<span class="n">breakpoint</span> <span class="o">=</span> <span class="n">create_builtin</span><span class="p">(</span><span class="s">"</span><span class="se">\xcc</span><span class="s">"</span><span class="p">,</span> <span class="s">"breakpoint"</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">breakpoint</span>
<span class="o">&lt;</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">function</span> <span class="n">breakpoint</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">breakpoint</span><span class="o">.</span><span class="n">__name__</span>
<span class="s">'breakpoint'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">breakpoint</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span>    <span class="mi">4870</span> <span class="n">trace</span> <span class="n">trap</span> <span class="p">(</span><span class="n">core</span> <span class="n">dumped</span><span class="p">)</span>  <span class="n">python</span> <span class="o">-</span><span class="n">i</span> <span class="n">demo</span><span class="o">.</span><span class="n">py</span>
<span class="c"># woot! breakpoint triggered \o/</span>
</pre></div>
</td></tr></table>

<p>The only problem now is the bootstrap of <code>give_life_to_obj</code>: to give life to a new builtin object we would need to already have the dummy execution.
So we are going to:</p>
<ul>
<li>replace <code>abs</code> by our <code>give_life_to_object</code> payload,</li>
<li>create our first builtin: <code>real_give_life_to_object</code>,</li>
<li>put back the original code of <code>abs</code>,</li>
<li>use our new builtin to create the builtin objects.</li>
</ul>
<p>Bootstrap code:</p>
<table class="codehilitetable"><tr><td class="linenos"/><td class="code"><div class="codehilite"><pre><span class="k">def</span> <span class="nf">bootstrap</span><span class="p">():</span>
    <span class="n">payload_64</span> <span class="o">=</span> <span class="s">"48 8b 46 24 C3"</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">" "</span><span class="p">,</span> <span class="s">""</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">)</span>
    <span class="c"># 'replace_builtin' replaces the code of its first argument and returns the old 'ml_meth' for restoration.</span>
    <span class="n">old_abs</span> <span class="o">=</span> <span class="n">replace_builtin</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">payload_64</span><span class="p">)</span>
    <span class="c"># In my final code 'give_life_to_object' is named 'get_obj_at'.</span>
    <span class="n">get_obj_at</span> <span class="o">=</span> <span class="nb">abs</span>
    <span class="n">new_obj_at</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_builtin</span><span class="p">(</span><span class="n">payload_64</span><span class="p">,</span> <span class="s">"get_obj_at"</span><span class="p">)</span>
    <span class="c"># Just restore old code of builtin abs.</span>
    <span class="n">restore_builtins</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">old_abs</span><span class="p">)</span>
    <span class="n">get_obj_at</span> <span class="o">=</span> <span class="n">new_obj_at</span>
</pre></div>
</td></tr></table>

<p>With that, we are able to create all the builtins we want!</p>
<h3>Windows/Linux and 32/64 bits compatibility</h3>
<p>Before releasing the code I worked at getting a working Linux and Windows version for both the 32 and 64 architectures.<br/>
Here are what I had to do:</p>
<p>Windows/Linux:</p>
<ul>
<li>No change except MyMap class (mmap wrapper).</li>
<li>Get the OS using <code>platform.system()</code>.</li>
<li>Call <code>mmap</code> with correct arguments depending on the system.</li>
</ul>
<p>32/64 bits:</p>
<ul>
<li>Get the architecture using: <code>platform.architecture()[0]</code>.</li>
<li>
<p>Adapt:</p>
<ul>
<li>the payload for <code>obj_at</code> (describe as <code>give_life_to_obj</code> in the article),</li>
<li>the format strings for <code>struct.pack_into</code>.</li>
</ul>
</li>
</ul>
<p>Last problem I had was with the way I gave life to object. It doesn't work very well on 32 bits systems because <code>int(addr)</code>  may return a <code>long</code>, which is not compatible with our payload.</p>
<p>So in the final version, I use the <code>str</code> type and a string such as <code>"\x41\x42\x43\x44"</code> to pass the address of the object I want to give life to. This only change the way the payload is called, and how the offset the payload is looked for in the object.</p>
<h3>Final result</h3>
<p>The final result is pretty simple, all the magic is put into the <code>CodeInjector</code> class in the file <code>code_injection.py</code>.
Just use it like this:</p>
<table class="codehilitetable"><tr><td class="linenos"/><td class="code"><div class="codehilite"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">code_injection</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">code_injection</span><span class="o">.</span><span class="n">CodeInjector</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">code_injection</span><span class="o">.</span><span class="n">CodeInjector</span><span class="s">'&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">code_injection</span><span class="o">.</span><span class="n">CodeInjector</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ci</span><span class="o">.</span><span class="n">create_builtin</span><span class="p">(</span><span class="s">"</span><span class="se">\xcc</span><span class="s">"</span><span class="p">,</span> <span class="s">"my_breakpoint_builtin"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="o">&lt;</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">function</span> <span class="n">my_breakpoint_builtin</span><span class="o">&gt;</span>
</pre></div>
</td></tr></table>

<h3>Conclusion</h3>
<p>I had a LOT of fun creating new objects and having Python interface so nicely with my own native payloads. Of course, this kind of horrible stuff (Pythonicly speaking) should not be used in real projects...<br/>
I hope you enjoyed this article and learned something (I did !).<br/>
Also, <code>struct</code> is a super-useful module for low level stuff! I discovered it during my first CTF and use it at almost every CTFs now.</p>
<p>The complete implementation is avalaible at <a href="https://bitbucket.org/Hakril/python-native-execution/">https://bitbucket.org/Hakril/python-native-execution/</a>.</p>
    

    
    <p id="disqus_thread"/>
    
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
    
</li>


    
    </div></body></html>