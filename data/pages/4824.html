<html><body><div><div id="articleText">
                    <div id="articleLongDescription"><p>Used together, channels and goroutines in the Go programming language provide very similar behavior to Python’s generator functions. Brett Slatkin, author of </p><a href="http://www.informit.com/store/effective-python-59-specific-ways-to-write-better-python-9780134034287">Effective Python: 59 Specific Ways to Write Better Python</a><p>, shows how to translate his advice for Python generators into best practices for Go functions.</p></div>
                    <p id="articleDescription"/>

                    <a class="relatedBookLink" href="#">From the author of <span class="ss-icon"></span></a>
                    
                    

                

<p>A Python function can be a <em>generator</em> that returns an iterator of dynamically constructed values. A generator function acts like a coroutine. Each time a new value is requested from the iterator, the thread of control is passed to the generator so it can create the next result. Once the generator produces a value via the <tt>yield</tt> expression, control is restored to the iterator's consumer so that it can act on the new data.</p>
<p>Go's <em>channel</em> type is a powerful synchronization primitive that acts as producer-consumer queue. Go also supports lightweight concurrent functions called <em>goroutines</em>, which can safely communicate via channels. Though Go's syntax is different from Python's, channels and goroutines in Go can be used together to provide behavior that's very similar to Python's generator functions.</p>
<p>This means that the best practices for generators in Python can easily translate into best practices for Go. This article explores Item #16 ("Consider Generators Instead of Returning Lists") from my book <em><a href="http://www.informit.com/store/effective-python-59-specific-ways-to-write-better-python-9780134034287">Effective Python: 59 Specific Ways to Write Better Python</a></em>, and how my advice for Python generators can be applied to Go programs as well.</p>
<p>You can find the source code for the examples below here on <a href="https://github.com/bslatkin/effpygo">GitHub</a>.</p>
<h2>A Motivating Example</h2>
<p>Say you want to read some comma-separated value (CSV) data that contains pairs of x and y coordinates as floating-point numbers. In Python, you'd do this with a plain function that uses the <tt>csv</tt> built-in module:</p>

<pre><code><em><font># Python</font></em>
<strong><font>def</font></strong> load_csv_data(stream):
    result = []
    <strong><font>for</font></strong> row in csv.reader(stream):
        <strong><font>if</font></strong> <font>len</font>(row) != <font>2</font>:
            <strong><font>raise</font></strong> <font>ValueError</font>(<font>'Rows must have two entries'</font>)
        point = <font>float</font>(row[<font>0</font>]), <font>float</font>(row[<font>1</font>])
        result.append(point)
    <strong><font>return</font></strong> result</code></pre>

<p>This function reads the input data using <tt>csv.reader</tt>. It verifies that each row contains only two columns of values. It parses the strings from each column as floating-point numbers. It uses the tuple <tt>(x, y)</tt> to represent each point that was found in the input CSV. It accumulates the parsed points into a list. Finally, it returns the full list of points to the caller.</p>
<p>The code that uses this function is straightforward:</p>
<pre><code><em><font># Python</font></em>
data = <font>'1.0,2.5\n3.5,4.1\n7.5,2.2\n6.9,1.1\n'</font>
rows = load_csv_data(io.StringIO(data))
<strong><font>for</font></strong> i, row in <font>enumerate</font>(rows):
    <font>print</font>(<font>'Row </font><font>%d</font><font> is </font><font>%r</font><font>'</font> % (i, row))

&gt;&gt;&gt;
Row 0 is (1.0, 2.5)
Row 1 is (3.5, 4.1)
Row 2 is (7.5, 2.2)
Row 3 is (6.9, 1.1)</code></pre>

<p>Writing the same program in Go is similarly easy. First, I define a <tt>struct</tt> that will contain the data for the points after they're parsed:</p>

<pre><code><em><font>// Go</font></em>
<strong><font>type</font></strong> Point <strong><font>struct</font></strong> {
    X, Y <font>float64</font>
}</code></pre>

<p>Second, I define a function that parses two columns of CSV data into <tt>Point</tt> instances:</p>

<pre><code><em><font>// Go</font></em>
<strong><font>func</font></strong> recordToPoint(record []<font>string</font>) (p Point) {
    <strong><font>if</font></strong> <font>len</font>(record) != <font>2</font> {
        <strong><font>return</font></strong>
    }
    p.X, _ = strconv.ParseFloat(record[<font>0</font>], <font>64</font>)
    p.Y, _ = strconv.ParseFloat(record[<font>1</font>], <font>64</font>)
    <strong><font>return</font></strong>
}</code></pre>

<p>Third, I write a function to read all of the CSV data into slices, convert those slices into <tt>Point</tt> instances, and then return the full slice of points that were found:</p>
<pre><code><em><font>// Go</font></em>
<strong><font>func</font></strong> LoadCsvData(in io.Reader) (result []Point) {
    reader := csv.NewReader(in)
    records, _ := reader.ReadAll()
    <strong><font>for</font></strong> _, record := <strong><font>range</font></strong> records {
        point := recordToPoint(record)
        result = <font>append</font>(result, point)
    }
    <strong><font>return</font></strong>
}</code></pre>

<p>The code that uses this function is also simple:</p>

<pre><code><em><font>// Go</font></em>
data := <font>"1.0,2.5\n3.5,4.1\n"</font>
points := LoadCsvData(strings.NewReader(data))
<strong><font>for</font></strong> i, point := <strong><font>range</font></strong> points {
    fmt.Printf(<font>"Row %d is %v"</font>, i, point)
}

---------------------------------
Row 0 is {1 2.5}
Row 1 is {3.5 4.1}
Row 2 is {7.5 2.2}
Row 3 is {6.9 1.1}</code></pre>

<p>Though these functions are short and easy to read, one big problem is common to both the Python and Go versions: These programs are unbounded in their potential memory usage. If the input stream is large enough, the programs will accumulate point data until they run out of memory and crash.</p>
<p>The solution to this problem is moving to generators, which allow you to avoid accumulating values before returning them. For these functions, using generators ensures that your memory usage will be limited to a single point at a time (along with any buffers for the incoming data stream, and the stack space for the generator). As soon as a new point has been sent to the consumer of the generator, its memory will no longer held by the generator function.</p>




<h2>Creating Generators</h2>
<p>The big difference between implementing generators in Python and implementing generator-like functions in Go is explicitness. In Python, a function becomes a generator implicitly as soon as you use a <tt>yield</tt> expression in its body. Here, I've rewritten the earlier function as a generator by removing the <tt>result</tt> list and changing the <tt>result.append</tt> call into a <tt>yield</tt> expression:</p>

<pre><code><em><font># Python</font></em>
<strong><font>def</font></strong> load_csv_data_streaming(stream):
    <strong><font>for</font></strong> row in csv.reader(stream):
        <strong><font>if</font></strong> <font>len</font>(row) != <font>2</font>:
            <strong><font>raise</font></strong> <font>ValueError</font>(<font>'Rows must have two entries'</font>)
        point = <font>float</font>(row[<font>0</font>]), <font>float</font>(row[<font>1</font>])
        <strong><font>yield</font></strong> point</code></pre>

<p>Calling a generator function immediately returns an iterator and doesn't actually execute the function's body. Each time the iterator is advanced (e.g., by the <tt>next</tt> built-in function), the generator function will execute until the next <tt>yield</tt> statement is reached or the function exits. Python will interleave the generator's execution with the execution of the code that consumes the generator, in the same way you'd expect cooperative threads to work together.</p>
<p>The generator version of a function is often a drop-in replacement for the version that returns a list. Python's looping constructs interact with any type of iterable (lists, dictionaries, iterators, etc.) in the same way. The only change required to use the generator function is the call to <tt>load_csv_data_streaming</tt>:</p>

<pre><code><em><font># Python</font></em>
data = <font>'1.0,2.5\n3.5,4.1\n7.5,2.2\n6.9,1.1\n'</font>
rows = load_csv_data_streaming(io.StringIO(data))
<strong><font>for</font></strong> i, row in <font>enumerate</font>(rows):
    <font>print</font>(<font>'Row </font><font>%d</font><font> is </font><font>%r</font><font>'</font> % (i, row))

&gt;&gt;&gt;
Row 0 is (1.0, 2.5)
Row 1 is (3.5, 4.1)
Row 2 is (7.5, 2.2)
Row 3 is (6.9, 1.1)</code></pre>

<p>In Go, you must explicitly wire up the generator-like behavior:</p>

<pre><code><em><font>// Go</font></em>
<strong><font>func</font></strong> LoadCsvDataToChannel(in io.Reader) &lt;-<strong><font>chan</font></strong> Point {
    out := <font>make</font>(<strong><font>chan</font></strong> Point)
    <strong><font>go</font></strong> <strong><font>func</font></strong>() {
        <strong><font>defer</font></strong> <font>close</font>(out)
        reader := csv.NewReader(in)
        <strong><font>for</font></strong> {
            record, err := reader.Read()
            <strong><font>if</font></strong> err == io.EOF {
                <strong><font>return</font></strong>
            }
            point := recordToPoint(record)
            out &lt;- point
        }
    }()
    <strong><font>return</font></strong> out
}</code></pre>

<p>This function creates a channel instance (here called <tt>out</tt>). It kicks off a goroutine that asynchronously populates the channel with <tt>Point</tt> instances (using the <tt>&lt;-</tt> operator). Then it returns the channel as an output channel that can only be used to received values. Importantly, the interior goroutine is also responsible for closing the channel when all output has finished. This task is accomplished with the <tt>defer close(out)</tt> statement that triggers when the interior goroutine finally exits.</p>
<p>Using the generator-like version of this function, the code that consumes the channel is almost as simple as before (I only had to add a loop counter):</p>
<pre><code><em><font>// Go</font></em>
results := LoadCsvDataToChannel(strings.NewReader(data))
i := <font>0</font>
<strong><font>for</font></strong> point := <strong><font>range</font></strong> results {
    fmt.Printf(<font>"Row %d is %v\n"</font>, i, point)
    i++
}

---------------------------------
Row 0 is {1 2.5}
Row 1 is {3.5 4.1}
Row 2 is {7.5 2.2}
Row 3 is {6.9 1.1}</code></pre>

<p>Unlike Python generators, the interior goroutine's execution doesn't wait for the consuming code. The goroutine is scheduled by the Go runtime to run independently. It may or may not be interleaved with the code that consumes the channel—you don't know, and you shouldn't care. The channel takes care of this coordination for you.</p>
<p>The <tt>make(chan Point)</tt> call above creates a channel with no buffer. That means the goroutine populating the channel will progress only up to the moment that the first value is sent into the channel (again, using the <tt>&lt;-</tt> operator). At that time, the goroutine will block until the consuming code receives the value (with the <tt>range</tt> clause in the <tt>for</tt> loop).</p>
<p>Similarly, if the consumer tries to receive from the channel and a value is not yet ready, it will block until the producing goroutine sends another value into the channel or closes the channel to indicate there is no more data.</p>
<p>Though the mechanism is quite different, the resulting behavior of channels and goroutines in Go feels much like Python's generator functions.</p>




<h2>Handling Errors</h2>
<p>The code examples I've discussed so far overlook a very important reality of writing correct programs: handling errors. In practice, there are many opportunities for things to go wrong while processing the CSV input data, including poorly formatted numbers, not enough columns, and truncated streams.</p>
<p>Python deals with errors by raising <tt>Exception</tt> instances that propagate up through the call stack. Unfortunately, Python's dynamic nature means the compiler can't check or enforce which types of exceptions are raised by a function. You have to inspect the code yourself, read documentation of behaviors, and make your best guess. In this case, the possible sources of exceptions are as follows:</p>
<ul>
<li>Issues that occur while reading from the input stream</li>
<li>Errors decoding the characters received from the input</li>
<li>CSV rows that don't have exactly two columns</li>
<li>Any failures in parsing the floating-point numbers from the columns</li>
</ul>
<p>When a generator raises an exception, it will traverse into the consuming code at the point where the generator's iterator was advanced. Practically speaking, the earlier generator example must be rewritten to catch any exceptions that may have occurred within the <tt>for</tt> statement:</p>
<pre><code><em><font># Python</font></em>
it = load_csv_data_streaming(stream)
<strong><font>try</font></strong>:
    <strong><font>for</font></strong> i, row in <font>enumerate</font>(it):
        <font>print</font>(<font>'Row </font><font>%d</font><font> is </font><font>%r</font><font>'</font> % (i, row))
<strong><font>except</font></strong> (<font>ValueError</font>, <font>IOError</font>):
    <strong><font>raise</font></strong> MyException(<font>'Broke reading CSV'</font>)</code></pre>

<p>However, this approach is generally considered bad style because it puts too much code inside the <tt>try</tt> block. If you hit other exceptions when running the interior of the loop, such as the <tt>print</tt> function call, those exceptions may be caught inadvertently by the <tt>except</tt> block, which was only meant to guard against problems within the <tt>load_csv_data_streaming</tt> generator.</p>
<p>To fix this issue, you can manually advance the iterator with the <tt>next</tt> built-in function, catch any exceptions that are raised by doing so, and then execute the <tt>print</tt> function outside of the <tt>try</tt> block:</p>

<pre><code><em><font># Python</font></em>
it = <font>enumerate</font>(load_csv_data_streaming(stream))
<strong><font>while</font></strong> <font>True</font>:
    <strong><font>try</font></strong>:
        i, row = <font>next</font>(it)
    <strong><font>except</font></strong> <font>StopIteration</font>:
        <strong><font>break</font></strong>
    <strong><font>except</font></strong> (<font>ValueError</font>, <font>IOError</font>) <font>as</font> e:
        <strong><font>raise</font></strong> MyException(<font>'Broke after row'</font>)
    <strong><font>else</font></strong>:
        <font>print</font>(<font>'Row </font><font>%d</font><font> is </font><font>%r</font><font>'</font> % (i, row))</code></pre>

<p>With Python, you have to handle exceptions primarily on the consuming side of the generator, not on the producing side. In this case, the <tt>load_csv_data_streaming</tt> function doesn't have to change. All I've had to add is a <tt>try</tt>/<tt>except</tt> block in the code that drives the generator function.</p>
<p>In contrast, Go encourages explicit error-handling at every level and in every function. This convention translates into more error-handling code within the lower-level functions, but less error-handling code at the point of consumption.</p>
<p>The previous Go examples swallowed errors, which can lead to odd behaviors like zero-valued <tt>Point</tt> instances being returned or runtime panics. For good style, I need to rewrite the code to propagate errors up to callers.</p>
<p>I start by making the parsing function handle and return parsing errors:</p>

<pre><code><em><font>// Go</font></em>
<strong><font>func</font></strong> recordToPoint(record []<font>string</font>) (p Point, err <font>error</font>) {
    <strong><font>if</font></strong> <font>len</font>(record) != <font>2</font> {
        err = fmt.Errorf(<font>"Records must have two columns"</font>)
        <strong><font>return</font></strong>
    }
    <strong><font>if</font></strong> p.X, err = strconv.ParseFloat(record[<font>0</font>], <font>64</font>); err != <font>nil</font> {
        <strong><font>return</font></strong>
    }
    <strong><font>if</font></strong> p.Y, err = strconv.ParseFloat(record[<font>1</font>], <font>64</font>); err != <font>nil</font> {
        <strong><font>return</font></strong>
    }
    <strong><font>return</font></strong>
}</code></pre>

<p>That's easy enough, but adding error-handling logic to the generator-like version of this function, <tt>LoadCsvDataToChannel</tt>, is much more difficult than handling errors from the Python generator function <tt>load_csv_data_streaming</tt>.</p>
<p>In Python, the generator potentially raises exceptions to the caller each time its iterator is advanced by the <tt>next</tt> built-in function. This behavior gives Python two paths for communicating information to the consuming code: the return value of <tt>next</tt>, and any exceptions that it may raise.</p>
<p>The explicit nature of error-handling in Go means that there isn't a second path for communicating errors to the consuming code. Instead, errors are explicitly communicated through plain return values. For <tt>LoadCsvDataToChannel</tt>, this means that errors must be passed through the result channel itself.</p>

<p>To make this approach work, I need to augment the type of <tt>Point</tt> with any <tt>error</tt> that may have occurred while trying to produce it. I do this by declaring a new <tt>struct</tt> that embeds the <tt>Point</tt> <tt>struct</tt>:</p>

<pre><code><em><font>// Go</font></em>
<strong><font>type</font></strong> PointOrErr <strong><font>struct</font></strong> {
    Point
    Err <font>error</font>
}</code></pre>

<p>Then I rewrite the generator version of this function to send <tt>error</tt> instances into the channel through the <tt>PointOrErr.Err</tt> field:</p>
<pre><code><em><font>// Go</font></em>
<strong><font>func</font></strong> LoadCsvDataToChannel(in io.Reader) &lt;-<strong><font>chan</font></strong> PointOrErr {
    out := <font>make</font>(<strong><font>chan</font></strong> PointOrErr)
    <strong><font>go</font></strong> <strong><font>func</font></strong>() {
        <strong><font>defer</font></strong> <font>close</font>(out)
        reader := csv.NewReader(in)
        <strong><font>for</font></strong> {
            record, err := reader.Read()
            <strong><font>if</font></strong> err == io.EOF {
                <strong><font>return</font></strong>
            }
            <strong><font>if</font></strong> err != <font>nil</font> {
                out &lt;- PointOrErr{Err: err}
                <strong><font>return</font></strong>
            }
            point, err := recordToPoint(record)
            <strong><font>if</font></strong> err != <font>nil</font> {
                out &lt;- PointOrErr{Err: err}
                <strong><font>return</font></strong>
            }
            out &lt;- PointOrErr{Point: point}
        }
    }()
    <strong><font>return</font></strong> out
}</code></pre>

<p>Finally, I change the consuming code to handle any <tt>error</tt> instances found in <tt>PointOrErr</tt> values that were received from the channel:</p>

<pre><code><em><font>// Go</font></em>
results := LoadCsvDataToChannel(strings.NewReader(data))
i := <font>0</font>
<strong><font>for</font></strong> point := <strong><font>range</font></strong> results {
    <strong><font>if</font></strong> point.Err != <font>nil</font> {
        <font>panic</font>(point.Err)
    }
    fmt.Printf(<font>"Row %d is %v\n"</font>, i, point)
    i++
}

---------------------------------
Row 0 is {{1 2.5} &lt;nil&gt;}
Row 1 is {{3.5 4.1} &lt;nil&gt;}
Row 2 is {{7.5 2.2} &lt;nil&gt;}
Row 3 is {{6.9 1.1} &lt;nil&gt;}</code></pre>

<p>Now the Go implementation of the generator-like function is robust. It's also easy to see that all errors are received and properly handled by the consuming code.</p>




<h2>Constructing Pipelines</h2>
<p>One of the biggest advantages of using generators is that you can connect them together to build pipelines. For example, you could easily create another function that consumes a generator of point data and outputs another generator with the distance between the last two points. Because you're using generators, you can be sure that the maximum working memory size for such a function is only the working set (two points)—not the full stream.</p>
<p>Here's such a generator implemented in Python:</p>

<pre><code><em><font># Python</font></em>
<strong><font>def</font></strong> distance_stream(it):
    x, y = <font>next</font>(it)
    <strong><font>for</font></strong> a, b in it:
        <strong><font>yield</font></strong> math.sqrt((a - x) ** <font>2</font> + (b - y) ** <font>2</font>)
        x, y = a, b</code></pre>

<p>Using this new generator is easy:</p>

<pre><code><em><font># Python</font></em>
stream = io.StringIO(data)
it = load_csv_data_streaming(stream)
<strong><font>for</font></strong> i, distance in <font>enumerate</font>(distance_stream(it)):
    <font>print</font>(<font>'Move </font><font>%d</font><font> was </font><font>%f</font><font> far'</font> % (i, distance))

&gt;&gt;&gt;
Move 0 was 2.968164 far
Move 1 was 4.428318 far
Move 2 was 1.252996 far</code></pre>

<p>Providing a similar generator-like function in Go is straightforward. As before, I have to define a new <tt>struct</tt> that contains both the results of the distance formula and any errors that may have occurred:</p>

<pre><code><em><font>// Go</font></em>
<strong><font>type</font></strong> DistanceOrErr <strong><font>struct</font></strong> {
    Distance <font>float64</font>
    Err      <font>error</font>
}</code></pre>

<p>Then, I follow the same pattern as before to create a channel and populate its results with a goroutine. This function is different from <tt>LoadCsvDataToChannel</tt> in that it consumes one channel and populates another instead of reading through a byte stream:</p>


<pre><code><em><font>// Go</font></em>
<strong><font>func</font></strong> PointDistanceToChannel(in &lt;-<strong><font>chan</font></strong> PointOrErr) &lt;-<strong><font>chan</font></strong> DistanceOrErr {
    out := <font>make</font>(<strong><font>chan</font></strong> DistanceOrErr)
    <strong><font>go</font></strong> <strong><font>func</font></strong>() {
        <strong><font>defer</font></strong> <font>close</font>(out)
        p := &lt;-in
        <strong><font>if</font></strong> p.Err != <font>nil</font> {
            out &lt;- DistanceOrErr{Err: p.Err}
        }
        <strong><font>for</font></strong> q := <strong><font>range</font></strong> in {
            <strong><font>if</font></strong> q.Err != <font>nil</font> {
                out &lt;- DistanceOrErr{Err: q.Err}
                continue
            }
            dx := math.Pow(q.X-p.X, <font>2</font>)
            dy := math.Pow(q.Y-p.Y, <font>2</font>)
            distance := math.Sqrt(dx + dy)
            out &lt;- DistanceOrErr{Distance: distance}
            p = q
        }
    }()
    <strong><font>return</font></strong> out
}</code></pre>




<p>Connecting this new function into the output of <tt>LoadCsvDataToChannel</tt> is simple, and the consume code is easy to read:</p>

<pre><code><em><font>// Go</font></em>
pointStream := LoadCsvDataToChannel(strings.NewReader(data))
distances := PointDistanceToChannel(pointStream)
i := <font>0</font>
<strong><font>for</font></strong> distance := <strong><font>range</font></strong> distances {
    <strong><font>if</font></strong> distance.Err != <font>nil</font> {
        <font>panic</font>(distance.Err)
    }
    fmt.Printf(<font>"Move %d was %f far\n"</font>, i, distance.Distance)
    i++
}

---------------------------------
Move 0 was 2.968164 far
Move 1 was 4.428318 far
Move 2 was 1.252996 far</code></pre>

<p>In both Python and Go, this pattern of connecting generators can be continued for many layers of functions. This technique allows you to join small pieces into large pipelines that produce complex outcomes, while still being easy to understand.</p>




<h2>Conclusion</h2>
<p>Generators allow you to write more scalable versions of functions that can be used in many different situations.</p>
<p>The biggest practical limitation of generators is that you can only access each item produced by the generator a single time. If you have to iterate over a generator's full result data multiple times (e.g., to implement a function like median value), holding all of a function's results in memory might make more sense.</p>
<p>The added complexity of writing generators in Python is almost zero, and often generator functions are easier to read because the <tt>yield</tt> expression eliminates superfluous code. Writing generator-like functions in Go is a bit more difficult because you have to directly wire together channels and goroutines to produce the iterative behavior.</p>
<p>However, the burden of using generator-like functions in both languages is nearly the same complexity as the slice- or list-based versions. The performance of using generators, especially once you scale up, is nearly the same or better in both languages. From the perspective of an API consumer, there are few downsides to using a generator version of a function.</p>
<p>Thus, I encourage you to consider using generators in Python and generator-like functions in Go whenever your inputs and outputs may potentially be unbounded.</p>
<p><em>Thanks to Andy Smith for reviewing an earlier draft of this post.</em></p>

            </div>
            </div></body></html>