<html><body><div><div id="drr-container" itemprop="articleBody">

	
	
		
		
	


















	
 	
 		
		<p class="lazyload_ad">
		<code type="text/javascript">
			
		</code>
		</p>
 	
 

	
	
	<p>
It's spiffy and convenient, but most everyone who uses Python knows it's comparatively creaky -- orders of magnitude slower than <a href="http://benchmarksgame.alioth.debian.org/u32/compare.php?lang=python3&amp;lang2=gcc" target="_blank">C</a>, <a href="http://benchmarksgame.alioth.debian.org/u32/python.php" target="_blank">Java</a>, or <a href="http://benchmarksgame.alioth.debian.org/u32/compare.php?lang=python3&amp;lang2=v8" target="_blank">JavaScript</a> for CPU-intensive work. But several parties don't want to ditch all that's good about Python and instead have decided to boost its performance from the inside out.
</p><p>
If you want to make Python run faster on the same hardware, you have two basic options, each with a drawback:
</p><ol>
<li>You can create a replacement for the default runtime used by the language (the CPython implementation) -- a major undertaking, but the result would be a drop-in replacement for CPython.</li>
<li>You can rewrite existing Python code to take advantage of certain speed optimizations, which means more work for the programmer but doesn't require changes in the runtime.</li>
</ol><p>
Here are five possible ways the bar could be raised -- and in some cases already is -- on Python performance.
</p><h3>PyPy</h3><p>
Among the candidates for a drop-in replacement for CPython, <a href="http://pypy.org/" target="_blank">PyPy</a> is easily the most visible (Quora, for instance, <a href="http://www.quora.com/Alex-Gaynor/Posts/Quora-is-now-running-on-PyPy" target="_blank">uses it in production</a>). It also stands the best chance of becoming the default, as it's highly compatible with existing Python code.
</p><aside class="nativo-promo smartphone" id=""> </aside><p>
<a href="http://www.infoworld.com/article/2687086/python/pypy-powers-up-python.html">PyPy uses just-in-time (JIT) compilation</a>, the same technique used by Google Chrome's V8 JavaScript engine to speed up that language. The <a href="http://morepypy.blogspot.com/2015/02/pypy-250-released.html" target="_blank">most recent release, PyPy 2.5</a>, emerged at the beginning of February with a slew of performance improvements, among them better-integrated support for some common libraries used to accelerate Python performance such as NumPy.
</p><p>
Those using Python 3.x have to work with a separate build of the project, PyPy3. Unfortunately for lovers of bleeding-edge language features, that version supports up to Python 3.2.5 only, although support for 3.3 is in the works.
</p><h3>Pyston</h3><p>
<a href="https://github.com/dropbox/pyston" target="_blank">Pyston</a>, sponsored by Dropbox, <a href="http://www.infoworld.com/article/2683259/python/pyston-compiler-cranks-up-python-thanks-to-llvm.html">uses the LLVM compiler infrastructure</a> to also speed up Python with JITing. Compared to PyPy, Pyston is in the very early stages -- it's at revision 0.2 so far and supports only a limited subset of the language's features. Much of the work has been divided between supporting core features of the language and bringing up performance of <a href="http://blog.pyston.org/2014/12/05/python-benchmark-sizes/" target="_blank">key benchmarks</a> to an acceptable level. It'll be a while before Pyston can be considered remotely production-ready.
</p><h3>Nuitka</h3><p>
Rather than replace the Python runtime, some teams are doing away with a Python runtime entirely and seeking ways to transpile Python code to languages that run natively at high speed. Case in point: <a href="http://nuitka.net/" target="_blank">Nuitka</a>, which <a href="http://www.infoworld.com/article/2861448/application-development/nuitka-boosts-python-by-converting-it-to-c.html">converts Python to C++ code</a> -- although it relies on executables from the existing Python runtimes to work its magic. That limits its portability, but there's no denying the value of the velocity gained from this conversion. <a href="http://nuitka.net/pages/overview.html" target="_blank">Long-term plans</a> for Nuitka include allowing Nuitka-compiled Python to interface directly with C code, allowing for even greater speed.
</p><aside class="nativo-promo tablet desktop" id=""> </aside><h3>Cython</h3><p>
<a href="http://cython.org/" target="_blank">Cython</a> (C extensions for Python) is a superset of Python, a version of the language that compiles to C and interfaces with C/C++ code. It's one way to write C extensions for Python (where code that needs to run fast can be implemented), but can also be used on its own, separate from conventional Python code. The downside is that you're not really writing Python, so porting existing code wouldn't be totally automatic.
</p><p>
That said, Cython provides several advantages for the sake of speed not available in vanilla Python, among them variable typing à la C itself. A number of scientific packages for Python, such as <a href="http://www.infoworld.com/article/2608742/predictive-analytics/5-ways-to-add-machine-learning-to-java--javascript--and-more.html">scikit-learn</a>, draw on Cython features like this to keep operations lean and fast.
</p><h3>Numba</h3><p>
<a href="http://numba.pydata.org/" target="_blank">Numba</a> combines two of the previous approaches. From Cython, it takes the concept of speeding up the parts of the language that most need it (typically CPU-bound math); like PyPy and Pyston, it does so via LLVM. Functions compiled with Numba can be specified with a decorator, and Numba works hand-in-hand with NumPy to quicken the functions found. However, Numba doesn't perform JITing; the code is compiled ahead of time.
</p><p>
Python creator Guido van Rossum is adamant that many of <a href="http://www.infoworld.com/article/2619428/python/van-rossum--python-is-not-too-slow.html">Python's performance issues</a> can be traced to improper use of the language. CPU-heavy processing, for instance, can be hastened through a few methods touched on here -- using NumPy (for math), using the multiprocessing extensions, or making calls to external C code and thus avoiding the Global Interpreter Lock (GIL), the root of Python's slowness. But since there's no viable replacement yet for the GIL in Python, it falls to others to come up with short-term solutions -- and maybe long-term ones, too.
</p>
	
	

	
	
		
	
	
	
	
		
		
		
	
	
</div>




    </div></body></html>