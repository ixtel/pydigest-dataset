<html><body><div><div class="entry-content"><p>In 2013, I spent 6 months converting 0install’s 29,215 lines of Python to OCaml (learning OCaml along the way).
In this post, I’ll describe the approach I took and how it went. There will be graphs.
If you don’t want to read the whole thing, the take-away is this:
The new code is a similar length (slightly shorter), runs around 10x faster, and is statically type checked.</p>



<p>( This post also appeared on <a href="https://news.ycombinator.com/item?id=7858276">Hacker News</a> and <a href="http://www.reddit.com/r/programming/comments/27h2q5/python_to_ocaml_retrospective/">Reddit</a> )</p>

<p><strong>Table of Contents</strong></p>



<h2 id="background">Background</h2>

<p>Several readers said they’ve been following this blog without knowing what 0install actually is. So, a quick summary!</p>

<p><a href="http://0install.net/"><img class="border center" src="/blog/images/0install-site.png"/></a></p>

<p>Since 2003, <a href="http://0install.net">0install</a>’s goal has been to provide secure, cross-platform, decentralised software installation.</p>

<p><strong>Secure</strong> means that 0install doesn’t grant the software root access when you install it (like most package managers do), and doesn’t allow packages to conflict with each other (each version of each package goes in its own directory). It should always be safe to “install” a program with 0install, though ideally you’d use a sandbox to actually run it (we’re still waiting for a decent sandbox to turn up).</p>

<p><strong>Cross-platform</strong> means it works on Linux (it’s available from the repositories of all the major Linux distributions), Unix, OS X and Windows (the Windows version is a compatible reimplementation in C#, though it does run some of the original code in a subprocess).</p>

<p><strong>Decentralised</strong> means that upstream projects publish their software on their own web-sites. They still get automatic dependency handling (including dependencies on other sites), GPG signatures, automatic updates, roll-back, and support for binary and source packages.
0install can work with the native package manager (e.g. rpm or dpkg) to satisfy dependencies, in addition to downloading them as 0install packages itself.</p>

<p>0install was originally written in C as a Linux kernel module and user-space helper.
It made other software easy to install, but getting 0install itself was rather tricky.
My naive hope was that distributions would include it by default, but needless to say that didn’t happen.
In 2005, it was redesigned and reimplemented in Python to simplify distribution.</p>

<h2 id="ocaml-migration-overview">OCaml migration overview</h2>

<dl>
  <dt><a href="/blog/blog/2013/06/09/choosing-a-python-replacement-for-0install/">Replacing Python</a> (Jun 2013)</dt>
  <dd>The subject of rewriting 0install in a compiled language had come up a few times, but in 2013 I had just left my job to take a year off and finally had the time for it. I didn’t have any idea what language to use so I collected suggestions and tried them all. My test-case was to read the tutorial for each language and reimplement one trivial (4 line) function of 0install in each one. I looked at various factors, including start-up time, binary size, binary compatibility, safety features, diagnostics, ease of writing, support for shared libraries, and static checking.

    <p><a href="/blog/blog/2013/06/09/choosing-a-python-replacement-for-0install/#speed-and-size"><span class="caption-wrapper"><img class="caption" src="http://roscidus.com/blog/images/langspeed.png" width="" height="" title="Speed and binary size for the launch helper (dominated by start-up time)."/><span class="caption-text">Speed and binary size for the launch helper (dominated by start-up time).</span></span></a></p>

    <p>There was no very clear conclusion. Rust seemed very promising in the long term, but it was years from being ready. ATS was the fastest and smallest, but too difficult to use. Python and C# were too slow (0install needs fast start-up time). Go did poorly in almost every area I tested. But Haskell and OCaml did surprisingly well.</p>
  </dd>
  <dt><a href="/blog/blog/2013/06/20/replacing-python-round-2/">Replacing Python: second round</a></dt>
  <dd>I tried Haskell and OCaml on a larger sample, converting 576 lines of Python and comparing the code.
They both did well, especially for detecting problems at compile time, but I found OCaml considerably easier to use. It also ran twice as fast.</dd>
  <dt><a href="/blog/blog/2013/07/07/ocaml-binary-compatibility/">OCaml binary compatibility</a> (Jul)</dt>
  <dd>OCaml can compile to bytecode or to native code. I’d hoped that the bytecode would allow us to distribute a single binary that would work everywhere (as with Java). In this post I did some experiments to check this. It almost worked, but in the end I gave up; we now build separate binaries for each platform.</dd>
  <dt><a href="/blog/blog/2013/08/31/option-handling-with-ocaml-polymorphic-variants/">Option handling with OCaml polymorphic variants</a> (Aug)</dt>
  <dd>Polymorphic Variants are an unusual and very powerful feature of OCaml’s type system. I found I was able to take advantage of them to check statically that all of 0install’s sub-commands handle all their options.</dd>
  <dt><a href="/blog/blog/2013/09/28/ocaml-objects/">Experiences with OCaml objects</a> (Sep)</dt>
  <dd>Even though OCaml programmers rarely use objects, the language’s support for object-oriented programming was a big help in converting the existing Python code. This post looks at OO programming in OCaml and describes the things that confused me at first.</dd>
  <dt><a href="/blog/blog/2013/10/13/ocaml-tips/">OCaml tips</a> (Oct)</dt>
  <dd>I go back over my first OCaml code from June, pointing out better ways to do things.</dd>
  <dt><a href="/blog/blog/2013/11/28/asynchronous-python-vs-ocaml/">Asynchronous Python vs OCaml</a> (Nov)</dt>
  <dd>I add support for downloads to the OCaml, which requires using OCaml’s support for asynchronous code. I compare it with Python’s new asyncio system.</dd>
  <dt><a href="/blog/blog/2013/12/20/polymorphism-for-beginners/">Polymorphism for beginners</a> (Dec)</dt>
  <dd>OCaml code is often written without explicit types, letting the compiler infer everything.
However, it’s helpful to understand the details of the type system when it comes to writing interface files (describing a restricted public interface to a module) and when trying to understand compiler error messages. After muddling through for a while, I decided it was time to understand how it actually worked.

    <p><a href="/blog/blog/2013/12/20/polymorphism-for-beginners/#subtyping"><span class="caption-wrapper"><img class="caption" src="/blog/images/lattice.png" width="" height="" title="A lattice showing the subtype relationship."/><span class="caption-text">A lattice showing the subtype relationship.</span></span></a></p>
  </dd>
  <dt><a href="/blog/blog/2014/01/07/ocaml-the-bugs-so-far/">OCaml: the bugs so far</a> (Jan)</dt>
  <dd>I’ve found OCaml to be very good at detecting problems at compile time and the code has been very reliable. Still, some bugs slip though. In this post, I go over each discovered bug that made it into a Git commit and try to work out why it happened and whether it could have been prevented.

    <p><a href="/blog/blog/2014/01/07/ocaml-the-bugs-so-far/#summary"><span class="caption-wrapper"><img class="caption" src="/blog/images/bugs.png" width="" height="" title="Bugs found by type."/><span class="caption-text">Bugs found by type.</span></span></a></p>
  </dd>
  <dt><a href="/blog/blog/2014/02/13/ocaml-what-you-gain/">OCaml: what you gain</a> (Feb)</dt>
  <dd>When I first looked at OCaml, I was mainly focused on making sure the things I needed were still available.
With the port complete, I summarise the things you <em>gain</em> from using OCaml.</dd>
</dl>

<h2 id="code-size">Code size</h2>

<p>The final OCaml code was remarkably similar in length to the original Python:</p>

<p><span class="caption-wrapper"><img class="caption" src="/blog/images/retro/0install-loc.png" width="" height="" title="Lines of code, before and after."/><span class="caption-text">Lines of code, before and after.</span></span></p>

<p>The main code is slightly shorter, while the unit-tests are slightly longer (probably because I added some extra ones).
The functionality is the same, except that the OCaml adds the “0install slave” command (325 lines of OCaml) and uses Lwt
rather than its own asynchronous framework (483 lines of Python).</p>

<p>The Python code also included some XML files for the GTK user interface (shown in orange). In the OCaml, building the widgets
is instead done directly in the code. The OCaml version includes some module interface files (the <code>mli</code> files, shown in green).
These are used to control how much of a module’s implementation is visible to other modules. They make the code easier to understand,
but they’re mostly optional.</p>

<h2 id="porting-method">Porting method</h2>

<p>I wanted to avoid having two separate forks of 0install (Python and OCaml).
Then most people would continue using the Python version until the OCaml version was finished, resulting in a sudden switch over and the risk of some major flaw in the whole idea going undiscovered until the end.
Also, it would encourage people to submit bug fixes and features to the Python fork, creating extra porting work for me.
Instead, I used a mix of both languages, slowly migrating functions from Python to OCaml.
The two parts communicated using JSON.</p>

<p>I made sure the complete set of unit-tests passed for every commit and that the software remained fully functional throughout the whole process. The graph below shows the amount of Python and OCaml code over time:</p>

<p><span class="caption-wrapper"><img class="caption" src="/blog/images/retro/0install-loc-time.png" width="" height="" title="Lines of code over time."/><span class="caption-text">Lines of code over time.</span></span></p>

<p>For the first couple of months I was just adding OCaml code, duplicating lots of common helper code. For example, the OCaml version needs to be able to parse the XML selections documents, so that code is ported, but parts of the Python still need that code too, so it can’t be deleted yet. Once I start deleting Python code, progress is fairly steady until it’s all gone. A nice benefit of this approach is that you can see clearly where you are in the process.</p>

<p>Initially, I tried doing clean implementations of the code from the specifications. However, the existing code has a lot of special cases for weird systems and backwards-compatibility hacks, and not all of them were unit-tested. Soon, I switched to translating more literally from the Python and then cleaning it up once it was in OCaml. I kept the basic structure of the Python in most places (e.g. the same classes with the same methods). That made things much easier. Once the port was complete, I did some larger refactoring (such as making the XML type immutable). I think this worked well - refactoring is very pleasant in OCaml.</p>

<h2 id="binary-size">Binary size</h2>

<p><span class="caption-wrapper"><img class="caption" src="/blog/images/retro/binary-size.png" width="" height="" title="Executable image size over time."/><span class="caption-text">Executable image size over time.</span></span></p>

<p>The binary ended up a bit bigger than I’d like. Adding the GTK and OBus libraries in particular added a lot to the size (though they are optional). The main problem with GTK is that it has to be compiled as a plugin, because we don’t know if the target system will have libgtk. If we used a single binary and the library wasn’t present, it would refuse to start. By having it in a plugin we can try to load it, but fall back to console mode if that fails. However, compiling for plugins prevents OCaml from optimising the binary by removing unused library functions, since it doesn’t know which ones might be needed by the plugins.</p>

<p>The binary is compiled with debug symbols, but compiling without has almost no effect (binary becomes 1.5% smaller).</p>

<h2 id="build-time">Build time</h2>

<p><span class="caption-wrapper"><img class="caption" src="/blog/images/retro/build-time.png" width="" height="" title="Build time changes over time."/><span class="caption-text">Build time changes over time.</span></span></p>

<p>A full build takes nearly a minute, which isn’t too bad. The <code>ocamlbuild</code> command automatically discovers dependencies and rebuilds only what is needed, so incremental builds are usually fast and are generally reliable (the exception is that it doesn’t notice if you remove or rename a file, but you always get an error message in that case rather than an incorrect build).</p>

<p>Most errors are picked up by the type checker immediately at the start of the build, rather than by the unit-tests at the end. That saves a lot of time.</p>

<p>Two things did speed it up slightly: building the tests and the main binary with a single invocation (saves having to run the dependency checker twice) and turning on parallel builds. Parallel builds didn’t help as much as I’d hoped however.</p>

<p>Update: edwintorok <a href="https://news.ycombinator.com/item?id=7860192">profiled the build</a> and noticed that 25.5% of the time is spent running a bytecode version of the camlp4 pre-processor (which we use for the Lwt syntax extension and for conditional compilation) and 10.5% is spent on a bytecode version of ocamlfind (looks like an ocamlbuild bug). 
<a href="http://gallium.inria.fr/blog/ocamlbuild-parallelization/">Why ocamlbuild’s parallelization is often disappointing today</a> looks interesting too.</p>

<p>Update 2: I noticed that building while the computer is busy doing something else is much faster! Looks like this is the Linux scaling governor being strange. Echoing “performance” to <code>/sys/devices/system/cpu/cpu[0-3]/cpufreq/scaling_governor</code> takes the build time (on my new laptop) down from 45s to 23s!</p>

<p>There are some changes (module aliases) coming in OCaml 4.02 which should help. Currently, if I change one of the files in the <code>Support</code> module (e.g. <code>Support.Sat</code>) then it first rebuilds <code>Sat</code>, then rebuilds <code>Support</code> with the new <code>Sat</code> module, then rebuilds everything that uses <code>Support</code> (which is everything). In reality, it only needs to rebuild <code>Zeroinstall.Solver</code> when <code>Sat</code> changes.</p>

<p>If you do need to modify one of the early modules and run the unit tests quickly, a good trick is to compile to byte-code rather than to native. The byte-code compiler doesn’t do cross-module inlining optimisations, which means that as long as a module’s interface doesn’t change, it doesn’t need to recompile the things that depend on it.</p>

<p>One interesting feature of the graph is that during December the build time increased faster in proportion to the lines of code added.
This corresponds to the time I was implementing the GTK GUI, so it looks like GUI code takes longer to compile than normal code of the same length.</p>

<h2 id="speed">Speed</h2>

<p>And the final result: running various operations with the old and new versions:</p>

<table class="table">
  <thead>
    <tr>
      <th>Test</th>
      <th>Python 3</th>
      <th>OCaml</th>
      <th>Speed-up</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>0install --help</code></td>
      <td>103 ms</td>
      <td>8 ms</td>
      <td>12.9</td>
    </tr>
    <tr>
      <td><code>0install select 0repo</code></td>
      <td>322 ms</td>
      <td>38 ms</td>
      <td>8.5</td>
    </tr>
    <tr>
      <td><code>0install run -w echo armagetron</code></td>
      <td>120 ms</td>
      <td>15 ms</td>
      <td>8.0</td>
    </tr>
    <tr>
      <td><code>0install run armagetron --version</code></td>
      <td>153 ms</td>
      <td>45 ms</td>
      <td>3.4</td>
    </tr>
  </tbody>
</table>

<p>The first (<code>--help</code>) shows the overhead of running 0install and producing some simple output.
The extra speed here really helps with tab-completion!
The second test (<code>select</code>) shows 0install running its SAT solver to select a compatible set of libraries to run the “0repo” application.
The third shows 0install setting up the environment to run Armagetron (<code>-w echo</code> echos the executable path rather than actually running it) and the fourth shows it actually running the program.</p>

<p><span class="caption-wrapper"><img class="caption" src="/blog/images/retro/times.png" width="" height="" title="Speed of 0install in Python vs OCaml."/><span class="caption-text">Speed of 0install in Python vs OCaml.</span></span></p>

<p>One other nice win is the time taken to run the unit-tests, which has dropped considerably:</p>

<p><span class="caption-wrapper"><img class="caption" src="/blog/images/retro/0install-test-times.png" width="" height="" title="Time to run the unit tests (in seconds)."/><span class="caption-text">Time to run the unit tests (in seconds).</span></span></p>

<p>The spike in the middle is the effect of the JSON bridge, where many tests involved communication between the Python and OCaml parts.</p>

<p>In theory, OUnit should be able to run the tests in parallel on multi-core systems, which would make it even faster, but a <a href="https://forge.ocamlcore.org/tracker/index.php?func=detail&amp;aid=1363&amp;group_id=162&amp;atid=730">bug in OUnit</a> means it doesn’t work.</p>

<h2 id="conclusions">Conclusions</h2>

<p>It’s surprising to me how reliable the initial tests were.
Even though I only converted 4 lines of Python, the tests uncovered pretty much all of OCaml’s weaker aspects (non-portable bytecode, lack of support for shared libraries, relatively large binary size, and somewhat terse error messages from the standard library), meaning there were no nasty surprises during the migration.</p>

<p>However, the testing was less successful at uncovering the benefits (excellent type checking, reliability, exhaustive pattern matching, polymorphic variants, abstract types, easy GTK bindings, and API stability).</p>

<p>Blogging about the whole process was extremely useful, attracting many helpful comments, suggestions and corrections from experienced OCaml users.</p>

<h2 id="epilogue">Epilogue</h2>

<p>The blog attracted the attention of the OCaml folks at Cambridge University, who do all kinds of <a href="http://www.cl.cam.ac.uk/projects/ocamllabs/news/index.html#Dec%202013">interesting OCaml things</a>.
As a result, I’m now working there, adding ARM support to the <a href="http://openmirage.org/">Mirage unikernel</a> - an operating system written in OCaml (the Mirage web-site is all implemented in OCaml, down to and including the TCP/IP stack!).
That will have to be the subject for another blog post though…</p>
</div>


  </div></body></html>