<html><body><div><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-pychecked" class="anchor" href="#pychecked" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>pychecked</h1>

<p>Python Type Checking Library.</p>

<p>Python3.0 introduced the acceptance of <a href="http://legacy.python.org/dev/peps/pep-3107">PEP3107</a>; which gives python developers the option of annotating their funtion signatures. What it very distinctly does not deliver, is any enforcement of those annotations. Pychecked provides a wrapper, <code>type_checked</code> which you can decorate your annotated functions with to enforce those annotations. If the object being passed in does not match the expected type, pychecked will try to coerce the object into the correct type. This behavior is adjustable, through the <code>Config</code> object in pychecked, or by passing <code>coerce=False</code> as a kwarg to the wrap function <code>type_checked</code>. Note that the wrap <code>type_checked</code>; which lives in the <code>pychecked.type_checking</code> module, is exported as the top level module callable as well. Meaning, using this is as simple as:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> pychecked

<span class="pl-en">@pychecked</span>
<span class="pl-k">def</span> <span class="pl-en">my_function</span>(<span class="pl-smi">something</span>:<span class="pl-c1">str</span>):
    <span class="pl-c1">print</span>(<span class="pl-c1">type</span>(something))

my_function(<span class="pl-c1">11.1</span>)
my_function(<span class="pl-c1">bytes</span>(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>utf-8<span class="pl-pds">"</span></span>))
my_function(<span class="pl-c1">False</span>)</pre></div>

<h1><a id="user-content-examples" class="anchor" href="#examples" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Examples</h1>

<p>Say you had the following function, which you only ever wanted to accept integers:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-en">@pychecked</span>
<span class="pl-k">def</span> <span class="pl-en">and_one</span>(<span class="pl-smi">number</span>:<span class="pl-c1">int</span>):
    <span class="pl-k">return</span> number <span class="pl-k">+</span> <span class="pl-c1">1</span></pre></div>

<p>Simple, right? What if it was a list of integers though? Easy!</p>

<div class="highlight highlight-source-python"><pre><span class="pl-en">@pychecked</span>
<span class="pl-k">def</span> <span class="pl-en">average</span>(<span class="pl-smi">numlist</span>:[<span class="pl-c1">int</span>]):
    <span class="pl-k">return</span> (<span class="pl-c1">sum</span>(numlist) <span class="pl-k">/</span> <span class="pl-c1">len</span>(numlist)) <span class="pl-k">*</span> <span class="pl-c1">100</span></pre></div>

<p>Neat! OK. Tricky one now, I want to accept a dictionary of {int: string}</p>

<div class="highlight highlight-source-python"><pre><span class="pl-en">@pychecked</span>
<span class="pl-k">def</span> <span class="pl-en">my_func</span>(<span class="pl-smi">input_obj</span>:{<span class="pl-c1">int</span>: <span class="pl-c1">str</span>}):
    <span class="pl-k">for</span> number, string <span class="pl-k">in</span> input_obj.items():
        <span class="pl-k">assert</span> <span class="pl-c1">isinstance</span>(number, <span class="pl-c1">int</span>)
        <span class="pl-k">assert</span> <span class="pl-c1">isinstance</span>(string, <span class="pl-c1">str</span>)</pre></div>

<p>What if you want to accept a list of tuples? Sure thing.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-en">@pychecked</span>
<span class="pl-k">def</span> <span class="pl-en">accept_many</span>(<span class="pl-smi">things</span>:[(<span class="pl-c1">int</span>, <span class="pl-c1">int</span>, <span class="pl-c1">bool</span>, <span class="pl-c1">str</span>, MyCustomObject)]):
    <span class="pl-k">pass</span></pre></div>

<p>In the above instance, you can see how even custom objects can be used in the type checking. This can be very handy if you know that you're not passing the correct type and you want to shortcut the creation of the correct objects for the function.</p>

<p>As an example, consider a game object, and a function which adds player objects to that game:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">Game</span>(<span class="pl-c1">object</span>):
    <span class="pl-k">def</span> <span class="pl-c1">__init__</span>(<span class="pl-smi"><span class="pl-smi">self</span></span>):
        <span class="pl-v">self</span>.players <span class="pl-k">=</span> []

<span class="pl-k">class</span> <span class="pl-en">Player</span>(<span class="pl-c1">object</span>):
    <span class="pl-k">def</span> <span class="pl-c1">__init__</span>(<span class="pl-smi"><span class="pl-smi">self</span></span>, <span class="pl-smi">name</span>):
        <span class="pl-v">self</span>.name <span class="pl-k">=</span> name

<span class="pl-en">@pychecked</span>
<span class="pl-k">def</span> <span class="pl-en">add_player_to_game</span>(<span class="pl-smi">game</span>:Game, <span class="pl-smi">player</span>:Player):
    game.players.append(player)

<span class="pl-k">if</span> <span class="pl-c1">__name__</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>__main__<span class="pl-pds">"</span></span>:
    game <span class="pl-k">=</span> Game()
    add_player_to_game(game, <span class="pl-s"><span class="pl-pds">"</span>paul<span class="pl-pds">"</span></span>)
    add_player_to_game(game, <span class="pl-s"><span class="pl-pds">"</span>rufus<span class="pl-pds">"</span></span>)
    <span class="pl-c1">print</span>(game.players)</pre></div>

<p>So now, what happens when things go wrong. Sometimes, it will be impossible to coerce the input into the requested type. In these cases a <code>TypeError</code> will be raised by <code>pychecked</code>. A <code>ValueError</code> will be raised if the type requested isn't actually a <code>type</code> type or callable.</p>

<p>An example of failure and how to overcome it:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">import</span> pychecked
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyClass</span>(<span class="pl-c1">object</span>):
<span class="pl-c1">...</span>   <span class="pl-k">def</span> <span class="pl-c1">__init__</span>(<span class="pl-smi"><span class="pl-smi">self</span></span>, <span class="pl-smi">x</span>, <span class="pl-smi">y</span>):
<span class="pl-c1">...</span>     <span class="pl-v">self</span>.x <span class="pl-k">=</span> x
<span class="pl-c1">...</span>     <span class="pl-v">self</span>.y <span class="pl-k">=</span> y
<span class="pl-c1">...</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">@</span>pychecked
<span class="pl-c1">...</span> <span class="pl-k">def</span> <span class="pl-en">my_function</span>(<span class="pl-smi">something</span>:MyClass):
<span class="pl-c1">...</span>   <span class="pl-k">pass</span>
<span class="pl-c1">...</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> my_function(<span class="pl-c1">2</span>)
Traceback (most recent call last):
  File <span class="pl-s"><span class="pl-pds">"</span>/Users/adam/venv/3.4.32/src/pychecked/pychecked/type_checking.py<span class="pl-pds">"</span></span>, line <span class="pl-c1">225</span>, <span class="pl-k">in</span> _do_validation
    <span class="pl-k">return</span> type_(value)
<span class="pl-c1">TypeError</span>: <span class="pl-c1">__init__</span>() missing <span class="pl-c1">1</span> required positional argument: <span class="pl-s"><span class="pl-pds">'</span>y<span class="pl-pds">'</span></span>

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File <span class="pl-s"><span class="pl-pds">"</span>&lt;stdin&gt;<span class="pl-pds">"</span></span>, line <span class="pl-c1">1</span>, <span class="pl-k">in</span> <span class="pl-k">&lt;</span>module<span class="pl-k">&gt;</span>
  File <span class="pl-s"><span class="pl-pds">"</span>/Users/adam/venv/3.4.32/src/pychecked/pychecked/type_checking.py<span class="pl-pds">"</span></span>, line <span class="pl-c1">130</span>, <span class="pl-k">in</span> _type_checked
    v_args.append(_do_validation(annotations[arg_name], arg))
  File <span class="pl-s"><span class="pl-pds">"</span>/Users/adam/venv/3.4.32/src/pychecked/pychecked/type_checking.py<span class="pl-pds">"</span></span>, line <span class="pl-c1">234</span>, <span class="pl-k">in</span> _do_validation
    _raise_error()
  File <span class="pl-s"><span class="pl-pds">"</span>/Users/adam/venv/3.4.32/src/pychecked/pychecked/type_checking.py<span class="pl-pds">"</span></span>, line <span class="pl-c1">176</span>, <span class="pl-k">in</span> _raise_error
    value, <span class="pl-c1">type</span>(value).<span class="pl-c1">__name__</span>, type_.<span class="pl-c1">__name__</span>))
<span class="pl-c1">TypeError</span>: <span class="pl-c1">2</span> <span class="pl-k">is</span> of <span class="pl-c1">type</span> <span class="pl-c1">int</span>, expecting MyClass.
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">try</span>:
<span class="pl-c1">...</span>   my_function(<span class="pl-c1">2</span>)
<span class="pl-c1">...</span> <span class="pl-k">except</span> <span class="pl-c1">TypeError</span>:
<span class="pl-c1">...</span>   <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>errored<span class="pl-pds">"</span></span>)
<span class="pl-c1">...</span>
errored</pre></div>

<p>Easy, right? Sort of. Having an object that requires multiple args in it's init will always be difficult to coerce into. You can make a proxy/subclass object that can receive a single arg and instatiate the base object with other defaults or using the single arg (exploding a tuple, for instance). There's a gotcha in that you need to modify the isinstance magic method to respond True to the base class as well so the proxies arnt reinstantiated with a base object being passed in. An example:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> pychecked

<span class="pl-k">class</span> <span class="pl-en">XYObject</span>(<span class="pl-c1">object</span>):
    <span class="pl-k">def</span> <span class="pl-c1">__init__</span>(<span class="pl-smi"><span class="pl-smi">self</span></span>, <span class="pl-smi">x</span>, <span class="pl-smi">y</span>):
        <span class="pl-v">self</span>.x <span class="pl-k">=</span> x
        <span class="pl-v">self</span>.y <span class="pl-k">=</span> y

<span class="pl-k">class</span> <span class="pl-en">XYObjectProxyMeta</span>(<span class="pl-c1">type</span>):
    <span class="pl-c"># instancecheck overrides are only allowed on metaclasses</span>
    <span class="pl-k">def</span> <span class="pl-c1">__instancecheck__</span>(<span class="pl-smi"><span class="pl-smi">cls</span></span>, <span class="pl-smi">instance</span>):
        <span class="pl-k">return</span> instance.<span class="pl-c1">__class__</span>.<span class="pl-c1">__name__</span> <span class="pl-k">in</span> [<span class="pl-s"><span class="pl-pds">"</span>XYObjectProxy<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>XYObject<span class="pl-pds">"</span></span>]

<span class="pl-k">class</span> <span class="pl-en">XYObjectProxy</span>(<span class="pl-e">XYObject</span>, <span class="pl-c1">metaclass</span><span class="pl-k">=</span><span class="pl-e">XYObjectProxyMeta</span>):
    <span class="pl-k">def</span> <span class="pl-c1">__init__</span>(<span class="pl-smi"><span class="pl-smi">self</span></span>, <span class="pl-smi">arg</span>):
        <span class="pl-c1">super</span>(XYObjectProxy, <span class="pl-v">self</span>).<span class="pl-c1">__init__</span>(<span class="pl-k">*</span>arg)

<span class="pl-en">@pychecked</span>
<span class="pl-k">def</span> <span class="pl-en">my_function</span>(<span class="pl-smi">something</span>:XYObjectProxy):
    <span class="pl-c1">print</span>(<span class="pl-c1">type</span>(something))
    <span class="pl-c1">print</span>(something)

orig <span class="pl-k">=</span> XYObject(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>)
my_function(orig)
ret <span class="pl-k">=</span> my_function((<span class="pl-c1">1</span>, <span class="pl-c1">1</span>))
my_function(ret)</pre></div>

<h1><a id="user-content-config" class="anchor" href="#config" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Config</h1>

<p>Pychecked operates off of a sticky style config. Meaning, if you set or change an option in the <code>Config</code>, that option will stay until changed again.</p>

<p>This is so that if you want your application to raise <code>TypeErrors</code> on annotation mismatches instead of coercion, you can set the config once in your appliation's init method.</p>

<p>An example:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> pychecked.type_checking <span class="pl-k">import</span> type_checked, Config

<span class="pl-en">@type_checked</span>
<span class="pl-k">def</span> <span class="pl-en">do_things</span>(<span class="pl-smi">name</span>:<span class="pl-c1">str</span>):
    <span class="pl-k">pass</span>

<span class="pl-en">@type_checked</span>(<span class="pl-v">coerce</span><span class="pl-k">=</span><span class="pl-c1">False</span>)
<span class="pl-k">def</span> <span class="pl-en">main</span>():
    do_things(<span class="pl-c1">123</span>)  <span class="pl-c"># raises TypeError</span>
    Config.set(<span class="pl-s"><span class="pl-pds">"</span>coerce<span class="pl-pds">"</span></span>, <span class="pl-c1">True</span>)
    do_things(<span class="pl-c1">123</span>)  <span class="pl-c"># does not raise</span>

<span class="pl-k">if</span> <span class="pl-c1">__name__</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>__main__<span class="pl-pds">"</span></span>:
    main()</pre></div>

<p>As you can see in the above, you can set <code>Config</code> options through kwargs to the wrap, or through <code>pychecked.Config.set</code>.</p>

<h2><a id="user-content-copyright-and-license" class="anchor" href="#copyright-and-license" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Copyright and License</h2>

<p>pychecked was written by Adam Talsma <a href="mailto:adam@demonware.net">adam@demonware.net</a>.</p>

<p>Copyright (c) 2015, Activision Publishing, Inc.
All rights reserved.</p>

<p>Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:</p>

<ul>
<li><p>Redistributions of source code must retain the above copyright notice, this list
of conditions and the following disclaimer.</p></li>
<li><p>Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.</p></li>
<li><p>Neither the name of Activision Publishing, Inc. nor the names of its
contributors may be used to endorse or promote products derived from this
software without specific prior written permission.</p></li>
</ul>

<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
</article>
  </div></body></html>