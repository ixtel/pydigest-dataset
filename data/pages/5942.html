<html><body><div><div id="parent-fieldname-text" class="plain">
            <h2>History of new and old algorithms usages</h2>
<p>The history of the algorithm change is described in the article « <a class="external-link" href="https://www.python.org/download/releases/2.3/mro" target="_self" title="">Python 2.3 Method Resolution Order</a> ». This blog tries to <span class="short_text" id="result_box"><span class="hps">summarize</span></span> it and explaining the main part using Python simple examples.<br/><br/>When new and old algorithms are used ?<br/><br/>If MRO has changed with Python 2.3 you may think that the new algorithm is used with all Python versions after 2.2.<br/>Not exactly. To keep compatibility between Python versions, the new MRO algorithm is only used with what is so called « new classes ».<br/>New classes are classes whose first parent ineherits from Python root « <strong>object</strong> » class.</p>
<p>So in Python 2, if you create this class hierarchy :</p>
<pre>class A :<br/>    pass<br/>class B :<br/>    pass<br/>class C(A, B) :<br/>    pass</pre>
<p>C instances will use the old Method Resolution Order algorithm because none of the classes are derived from the Python « object » root class.<br/><br/>If you change above code with:</p>
<pre>class A(<strong>object</strong>) :<br/>    pass<br/>class B(<strong>object</strong>) :<br/>    pass</pre>
<p>Then, the MRO will be based on the new algorithm.</p>
<p>About Python 3 :</p>
<p>In Python 3 each class inherits from the root « object » class. Even if you do not indicate this explicitly. So the new algorithm will be used in both cases above with Python 3.<br/><em><strong>Be careful </strong>: This can cause unexpected changes in your software when migrating from Python 2 to Python 3.</em></p>
<h2>Understanding old classes MRO</h2>
<p>Python is an interpreted language, so it is easy to try/test any kind of things.<br/>Lets discover by ourselve how works the old classes method search path.<br/><br/>Run this script using Python 2:</p>
<pre>class A:<br/>    def who_am_i(self):<br/>        print("I am a A")<br/><br/>class B(A):<br/>    def who_am_i(self):<br/>        print("I am a B")<br/><br/>class C(A):<br/>    def who_am_i(self):<br/>        print("I am a C")<br/><br/>class D(B,C):<br/>    def who_am_i(self):<br/>        print("I am a D")<br/><br/>d1 = D()<br/>d1.who_am_i()</pre>
<pre>$ python2 Python-MRO.py  <br/><strong>I am a D</strong></pre>
<p>Now comment the <em>who_am_i</em> method in D:</p>
<pre>class D(B,C):<br/>#    def who_am_i(self):<br/>#        print("I am a D")<br/>    pass</pre>
<p>Which one will be called ? <br/>The one from B, from C or from A ? Well, everybody should be ok to say « the one from B or C » as every class method is virtual in Python.<br/>And the answer is :</p>
<pre>$ python2 Python-MRO.py  <br/><strong>I am a B</strong></pre>
<p>Ok. Nobody is surprised.<br/>Now, lets comment the who_am_i method in class B:</p>
<pre>class B(A)<br/>#     def who_am_i(self):<br/>#         print("I am a B")<br/>    pass</pre>
<p>And now, which method will be called when calling d1.who_am_i() ? C or A ? Well, many of you, me first, may agree it should be C as C is another direct parent of class D !</p>
<pre>python2 Python-MRO.py  <br/><strong>I am a A</strong></pre>
<p>But method from A is called !<br/>Well, what's this ?<br/>Before explaining this behaviour, lets continue the exercice to its end.<br/>Now comment, the <em>who_am_i</em> method in class A and run the script again.</p>
<pre>class A:<br/>#     def who_am_i(self):<br/>#         print("I am a A")<br/>    pass</pre>
<pre>python2 Python-MRO.py  <br/><strong>I am a C</strong></pre>
<p>Now, uncomment the <em>who_am_i</em> method in A and make A inherits from <em>object</em>.</p>
<pre>class A(<strong>object</strong>):<br/>     def who_am_i(self):<br/>         print("I am a A")</pre>
<p>And run again the script :</p>
<pre>python2 Python-MRO.py  <br/>I am a C</pre>
<p>You could also remove the object from A parent list and run the script with Python 3 :</p>
<pre>class A():<br/>     def who_am_i(self):<br/>         print("I am a A")</pre>
<pre>python3 Python-MRO.py  <br/>I am a C</pre>
<p><strong>So, why Python search for A before C when A does not inherits from <em>object</em> in Python 2 ?</strong><br/>This is due to the old classes MRO algorithm behaviour. It is a very simple and easy to understand algorithm :<br/>When a class inherits from multiple parents, Python build a list of classes to search for when it needs to resolve which method has to be called when one in invoked by an instance.<br/>This algorithm is a tree routing, and works this way, deep first, from left to right :<br/>1. Look if method exists in instance class<br/>2. If not, looks if it exists in its first parent, then in the parent of the parent and so on<br/>3. If not, it looks if current class inherits from others classes up to the current instance others parents.<br/><br/>So in our example, algorithm search path is : D, B, A, C, A.<br/>A class cannot appears twice in search path, so the final version is D, B, A, C:</p>
<ul><li>Looking in D</li>
<li>If not found, looking in B</li>
<li>If not found, looking un B first parent A</li>
<li>If not found, going back in B others parents (none)</li>
<li>If not found, looking in D others parents : C</li>
</ul><p>So, using this class hierarchy:</p>
<pre>class A1():<br/>#      def who_am_i(self):<br/>#          print("I am a A1")<br/>    pass<br/><br/>class A2():<br/>     def who_am_i(self):<br/>         print("I am a A2")<br/><br/>class A3():<br/>     def who_am_i(self):<br/>         print("I am a A3")<br/><br/>class B(A1, A2):<br/>#     def who_am_i(self):<br/>#         print("I am a B")<br/>    pass<br/><br/>class C(A3):<br/>    def who_am_i(self):<br/>        print("I am a C")<br/><br/>class D(B,C):<br/>#     def who_am_i(self):<br/>#         print("I am a D")<br/>    pass<br/><br/>d1 = D()<br/>d1.who_am_i()</pre>
<p>The search path when invoking d1.who_am_i() is : D, B, A1, A2, C, A3<br/>So, it should display « I am A2 » as nor D, nor B, not A1 defines the who_am_i method()</p>
<pre>python2 Python-MRO-2.py  <br/>I am a A2</pre>
<h2>Understanding the new algortihm</h2>
<p>As seen at the end of first exercice, when the class inherits from Python root <em>object</em> the behaviour changes.<br/>If you run the first script using python3 the algorithm behaviour change too.<br/>This is because in Python 3 or in Python 2 using <em>object</em> as a parent class the new MRO algorithm is used.</p>
<p>A near exact, <strong>but not completly exact, as we will see at the end of the article</strong>, definition of the new classes algorithm is that it is the same than the old one, except with this difference : each time a class is found in built search path, Python asked the question « Is it a good head ? » and if not, it removes the class from the final search path.<br/>So, what is a « good head »?<br/>A class is said as being a « good head » if there is no other class in the tail of the search path which inherits from it. In this case it is more natural to use the method defined by its derived class.<br/><br/>So, in script 1, the search path (tree routing without simplification) is D, B, A, C, A.<br/>Once built, Python tries to remove duplicated entries using the "good head" question. D and B are good head as there is no derived class in the tail of the path after they position which inherits from them.</p>
<p>When it is the first class A occurence, Python ask to class A : « Are you a good Head » ? And the answer is « No, I've have not been very kind today, I've tried to stole the place of my child class C which inherits from me and is in the the tail of the search path after me ». So Python removes A from the search path at this point which becomes D, B, C, A.<br/><br/>What about the second script. Search path is D, B, A1, A2, C, A3. <br/>A2 is apparently a good head, so it should be used when D, B and A1 « who_am_i » method are commented with Python 3 :</p>
<pre>python3 Python-MRO-2.py  <br/>I am a A2 </pre>
<p>But if C inherits from A2 rather than A3, C should be returned :</p>
<pre>class C(A2):<br/>    def who_am_i(self):<br/>        print("I am a C")</pre>
<pre>python3 Python-MRO-2.py  <br/>I am a C </pre>
<p>Ok. Personnaly I would have prefer to use a Method Resolution Order looking from left to right then deep inside left and so on to choose the good method to call because it seems to me more natural that when D inherits from B and C that their method is called first before any of their parents : D is a B or a C before being a parent of them. <br/><br/>That's my point of view.</p>
<h2>Impossible Method Resolution</h2>
<p>With the new algorithm, sometimes no good path can be found to solve method resolution. <br/>This example shows such conflict :</p>
<p><img src="http://makina-corpus.com/blog/metier/2014/python-mro-conflict" alt="Python-MRO-Conflict" class="image-inline" title="Python-MRO-Conflict"/></p>
<pre>class X():<br/>    def who_am_i(self):<br/>        print("I am a X")<br/>    <br/>class Y():<br/>    def who_am_i(self):<br/>        print("I am a Y")<br/>    <br/>class A(X, Y):<br/>    def who_am_i(self):<br/>        print("I am a A")<br/>    <br/>class B(Y, X):<br/>     def who_am_i(self):<br/>         print("I am a B")<br/><br/>class F (A, B):<br/>    def who_am_i(self):<br/>        print("I am a F")</pre>
<pre>$ python2 Python-MRO.py  <br/>I am a F</pre>
<p>In Python 2, search path is F, A, X, Y, B (Note that the search path described for this example in the link to the original article given at the top of this article is wrong).<br/><br/>With Python 3, search path should be : F, A, X, Y, B, Y, X and after removing « bad heads » : F, A, B, Y, X regarding my explanations above.</p>
<pre>$ python3 Python-MRO.py  <br/>Traceback (most recent call last): <br/>  File "Python-MRO.py", line 76, in &lt;module&gt; <br/>    class F (D, E): <br/>TypeError: Cannot create a consistent method resolution <br/>order (MRO) for bases C, B </pre>
<p>So, what's happened here ?<br/>The algorithm described before for Python 3 is not exactly the real one.<br/>Here is the definition of linearization algorithm used to defined the search path ;<br/>The linearization of a class C is the sum of C plus the merge of the linearizations of the parents and the list of the parents.<br/>In symbolic notation:<br/>L[C(B1 ... BN)] = C + merge(L[B1] ... L[BN], B1 ... BN)<br/>So in our case L[F(A, B)] = F + merge(L[A], L[B], A, B)<br/><br/>And the algorithm to merge linearized lists is:</p>
<ol><li>Take the head of the first list, i.e L[B1][0];</li>
<li>If this head is not in the tail of any of the other lists, then add it to the linearization of C and remove it from the lists in the merge,</li>
<li>Otherwise look at the head of the next list and take it,</li>
<li>If it is a good head. Then repeat the operation until all the class are removed or it is impossible to find good heads.</li>
<li>In this case, it is impossible to construct the merge, Python 2.3 will refuse to create the class C and will raise an exception.</li>
</ol><p>L[A(X,Y)] = A + merge(L[X], L[Y], X, Y) = A, X, Y<br/>L[B(Y,X)] = B + merge(L[Y], L[X], Y, X) = B, Y, X<br/><br/>So, L[F(A,B)] = F + merge( (A,X,Y) + (B, Y, X), A, B)<br/>So, applying the algorithm, A is a good head, so we keep it :<br/>L[F(A,B)] = F, A + merge( (X, Y) + (B, Y, X), B)<br/>So applaying the algorithm, X is not a good head as it appears in the tail of (B,Y, X), so we skip it and continue with next list to merge : (B, Y, X).<br/>B is a good head, so we keep it :<br/>L[F(A,B)] = F, A, B + merge( (X, Y) + (Y, X))<br/>So, applying the algorithm X is not a good head as it appears in the tail of (Y, X) so we skip it and jump to (Y, X). Y is not a good head too as it appears in the head of (X, Y). So we continue to the next list. But there is no other. <strong>Thus, Python 3 cannot linearize the class F to build the MRO and raise the exception !</strong><br/><br/>That's it. You now know how the whole mecanism works.<br/>This is not so complicated, but not so easy to guess by yourself, even by testing the language behaviour as this last script exception cannot be guessed by yourself if you do not have the Pythonic explanation on how this is implemented.<br/><br/>Hope this will help you understanding the magic of Python.</p>
<p>Ce tutorial vous a plu ? <a class="external-link" href="http://makina-corpus.com/formation/formation-python-initiation" target="_self" title="Formation Initiation Python">Consultez notre formation d'initiation à Python</a>.</p>
        </div>
    

                             </div></body></html>