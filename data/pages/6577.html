<html><body><div><div class="content html_format"><p>
      Хочу показать и рассказать о небольшой программке, которая принесла пользу.</p>
<p>
Однажды на работе мне написал друг. Диалог у нас состоялся примерно следующий:</p><p>
 — Привет, я тут обучаюсь технике слепой печати. Дело в том, что на линуксе нет программки, которая могла бы мне помочь. В общем, может ты сможешь быстренько написать такую?
</p><p>
Так как помочь другу — святое дело, да и задача выглядела интересной, помочь я согласился.
</p><p>
В итоге получилось вот что:

</p><img src="https://habrastorage.org/files/900/306/b38/900306b38ad24f1fb501c5971fe1c04c.gif"/>
<p>
Кому интересно, подробности ниже
</p><a name="habracut"/>
<div class="spoiler"><b class="spoiler_title">Предупреждение</b><p class="spoiler_text">Я не претендую на звание гуру питона, поэтому в коде (и я почти уверен в этом) присутствуют забивания гвоздей микроскопом и прочие нелепости.<br/>
</p></div><p>
Вместе с другом сделали постановку задачи:
</p><p>
Принцип её работы программы следующий — после запуска на рабочем столе появляется окно со схематическим изображением клавиатуры. При нажатии кнопок на реальной клавиатуре, на схематическом изображении нажатые кнопки вдавливаются. 
</p><p>
Это помогает выработать рефлекс смотреть на монитор во время печати на клавиатуре.
</p><p>
Главные требованиями к программе:
</p><ol>
<li>Реализовать её очень быстро;</li>
<li>Показывать нажатые клавиши в режиме реального времени;</li>
<li>«Переключать раскладки» в окне при переключении языка клавиатуры;</li>
<li>Производить настройку программы через текстовый конфигурационный файл.</li>
</ol><p>
В процессе написания также добавились:
</p><ol>
<li>Режим «залипания» последней нажатой клавиши (помогает сообразить куда нажимать пальцами дальше);</li>
<li>Работа с клавишей shift;</li>
<li>Возможность пометки цветом позиций для пальцев на клавиатуре;</li>
<li>Возможность настройки шрифта;</li>
<li>Возможность настройки ширины кнопок;</li>
<li>Автоматическое сокрытие содержимого окна при наведении мышки.</li>
</ol><p>
На момент появления программы уже имелся опыт работы с Tkinter, работы с несколькими потоками. Плюс, по роду деятельности приходится бывать и сисадмином, поэтому работа с командной строкой была не чужда.
 </p><p>
Общее описание внутренностей программы:
</p><p>
Для чтения клавиш используется найденная в google строчка на bash, позволяющая читать клавиши, нажимаемые на клавиатуре через утилиту xinput. Данный способ выбран в угоду пункту 1 требований. Процесс чтения символов запускается в отдельном потоке. Так же реализовано и чтение языка раскладки (опять таки пункт 1). Выдача информации о нажатых кнопках производится в очередь. Работа с очередью в главном окне программы производится путем периодического вызова функции periodicCall. Таким образом два потока пишут в очередь, один поток читает. </p><p>
Завершение работы программы производится своеобразно — через статусные переменные в потоках.

</p><h2>Работа с настройками программы</h2><p>
Настройки программы загружаются и хранятся в экземпляре класса ConfigManager. Чтение из главноего текстового файла настроек производится с помощью </p><a href="https://docs.python.org/2/library/configparser.html">ConfigParser</a><p>. Данный модуль позволяет использовать похожий на INI формат конфигурационных файлов. В конструкторе класса производится проверка существования конфигурационного файла, расположенного по пути "~/.key_trainer/program.conf". Если его нет, программа читает файл program.conf, расположенный в текущей папке с программой.

</p><div class="spoiler"><b class="spoiler_title">Немного кода</b><div class="spoiler_text"><pre><code class="python">import os
...
filename='program.conf'
home = os.path.expanduser("~")
if os.path.isfile(home+'/.key_trainer/'+filename):
    filename=home+'/.key_trainer/'+filename
...
</code></pre>
</div></div>
<a href="https://docs.python.org/2/library/configparser.html">ConfigParser</a><p> — замечательный модуль. Можно считать названия всех секций, а также считать ключи с их значениями внутри секций как кортежи (tuple). Так, например, реализовано считывание названий секций, и ключей в секции «KEYBOARD SETTINGS». 

</p><div class="spoiler"><b class="spoiler_title">Еще немного кода</b><div class="spoiler_text"><pre><code class="python">
from ConfigParser import RawParser
...
myParser=RawConfigParser(allow_no_value=True)
myParser.read(path_to_file)

# Получаем секции
self.sections = myParser.sections()

# Используем генератор чтобы вытащить ключи, заданные в секции KEYBOARD SETTINGS
keyboard_settings_keys=[x[0] for x in myParser.items("KEYBOARD SETTINGS")]
</code></pre>
</div></div><p>
Помимо главного конфигурационного файла есть второй не менее важный — «keyboard.conf». Он используется для настройки отображаемых кнопок, а именно кода кнопки, текста на кнопке (с шифтом и в раскладках), положения кнопки. Убирая/добавляя записи в этот файл можно менять количество и качество кнопок (и строк с кнопками) в главном окне программы.
</p><div class="spoiler"><b class="spoiler_title">Формат записей в keyboard.conf</b><p class="spoiler_text">В файле содержатся записи в виде:<br/>
<br/>
[код кнопки]:"[строчной символ в английской раскладке],[заглавный символ в английской раскладке],[строчной символ в русской раскладке],[заглавный символ в русской раскладке]":[номер строки кнопки],[номер столбца кнопки]<br/>
<br/>
Вот несколько записей для примера:<br/>
<br/>
24:«q,Q, й, Й»:3,2<br/>
25:«w,W, ц, Ц»:3,3<br/>
26:«e,E, у, У»:3,4<br/>
27:«r,R, к, К»:3,5<br/>
</p></div>
<h2>Чтение символов с клавиатуры</h2><p>
Для чтения символов написан класс KeyboardStatus, который принимает входным параметром класс конфигурации (см. выше). Внутрь этого класса инкапсулирована потокобезопасная очередь </p><a href="https://docs.python.org/2/library/queue.html">Queue</a><p>.
</p><p>
Чтение символов с клавиатуры производится в два потока. Почему два — потому что на практике так оказалось проще. Один поток читает раскладку клавиатуры, второй нажатые кнопки. Оба потока порождаются через </p><a href="https://docs.python.org/2/library/threading.html">Thread</a><p>, в каждом потоке затем через </p><a href="https://docs.python.org/2/library/subprocess.html">subprocess Popen</a><p> будет запущен соответствующий процесс чтения клавиш или раскладки. Для чтения выходного потока процесса используется </p><a href="https://docs.python.org/2/library/subprocess.html#subprocess.PIPE">subprocess.PIPE</a><p>. Как только текст пришел в поток выхода процесса, он читается, обрабатывается, и, если нужно, ставится в очередь </p><a href="https://docs.python.org/2/library/queue.html">Queue</a><p>:

</p><div class="spoiler"><b class="spoiler_title">Код</b><div class="spoiler_text"><pre><code class="python">from subprocess import Popen
from subprocess import PIPE
import threading
...
def doReadingKeys(self):
    self.myProcess=Popen('xinput list '+'|'+'   grep -Po \'id=\K\d+(?=.*slave\s*keyboard)\' '+'|'+'   xargs -P0 -n1 xinput test',shell=True,stdout=PIPE)

    while self.proc_started:
        symbol=self.myProcess.stdout.read(1)
        if symbol in press_release_dict:
            symbol_pressed=press_release_dict[symbol]
            while symbol!='\n':
                symbol=self.myProcess.stdout.read(1)
                if symbol.isdigit():
                    symbol_index=symbol_index*10+int(symbol)

                self.myQueue.put((symbol_index,symbol_pressed))
                symbol_index=0
...
keysThread=threading.Thread(target=self.doReadingKeys)
keysThread.start()
...
</code></pre>
</div></div><p>
Чтобы завершить поток используется переменная класса proc_started. При закрытии главного окна программы она устанавливается в значение False, производится выход из цикла чтения, выполняется завершения процесса чтения клавиш через terminate, а затем wait — для того чтобы дождаться пока процесс завершился. 

</p><div class="spoiler"><b class="spoiler_title">Замечание</b><p class="spoiler_text">У данного подхода есть один недостаток — разблокировка(а значит и дальнейшее завершение потока и процесса) метода read, который внутри цикла не произойдет до тех пор, пока что-нибудь не считается с выходного потока процесса myProcess. Но на практике проблем из-за этого не возникало, так как нажимаем мы на кнопки часто.<br/>
</p></div>
<h2>Графический интерфейс</h2><p>
Для того чтобы быстро сделать графический интерфейс использовался </p><a href="https://docs.python.org/2/library/tkinter.html">Tkinter</a><p>. Данный модуль позволяет легко работать с простыми графическими интерфейсами (окна, кнопки, галочки и т.п.). Класс окна GuiManager на вход, помимо других параметров, принимает класс конфигурации. Из неё берутся настройки кнопок, затем эти кнопки создаются и добавляются на главное окно программы.

</p><div class="spoiler"><b class="spoiler_title">Код добавления кнопок</b><div class="spoiler_text"><pre><code class="python">from Tkinter import *
import tkFont
...
        self.buttonFont=tkFont.Font(family=config.font_name,size=config.font_size)
        self.boldUnderscoredButtonFont=tkFont.Font(family=config.font_name,size=config.font_size,weight='bold',underline=1)

        for row_index in xrange(1,config.getNumOfRows()+1):
            self.gui_rows[int(row_index)]=Frame(master)
            self.gui_row_buttons[int(row_index)]=[]
            for button_num in xrange(1,config.getNumOfKeysInRow(row_index)+1):
                newButton=Button(self.gui_rows[int(row_index)])
                if self.config.padx!=-1:
                    newButton.config(padx=self.config.padx)
                if self.config.pady!=-1:
                    newButton.config(pady=self.config.pady)
                if (row_index,int(button_num)) in config.key_pos_to_index:
                    self.gui_all_buttons[config.key_pos_to_index[(row_index,int(button_num))]] = newButton
                self.gui_row_buttons[int(row_index)].append(newButton)
                newButton.pack(side=LEFT)

            self.gui_rows[int(row_index)].pack()
        self.reconfigure_text_on_buttons(config,shift_pressed=0,lang=0)
...
</code></pre>
</div></div><p>
При добавлении кнопок на форму попутно создаются словари с ключами номера строки и значениями — объектом </p><a href="http://effbot.org/tkinterbook/frame.htm">Frame</a><p> в каждый из которых помещаются кнопки. Как видно из кода, кнопки формируются построчно, по завершении формирования строки виджет кладется в окно методом pack().
</p><p>
Помимо прочего, в класс добавлена функция processQueue, которая со стороны потока графического интерфейса достает из очереди кортежи (tuple) с событиями нажатых кнопок и изменяет внешний вид кнопок — «нажимает» их, «переключает раскладки» и «нажимает» кнопку shift:

</p><div class="spoiler"><b class="spoiler_title">Обработка очереди со стороны графического интерфейса</b><div class="spoiler_text"><pre><code class="python">    def processQueue(self):
        while not self.queue.empty():
            msg = self.queue.get(0)
            if msg[0] == -1:                 # -1 message is for changing language
                    self.currentLang=int(msg[1])
                    if self.config.debug:
                        print "Changed lang!"
                    self.reconfigure_text_on_buttons(self.config,0,msg[1])

            if msg[0] in self.gui_all_buttons:
                if msg[0] in self.shift_key_codes:
                    self.reconfigure_text_on_buttons(self.config,msg[1],self.currentLang)
                if msg[1]==1:
                    self.gui_all_buttons[msg[0]].config(relief=SUNKEN)
                    if self.sticky_key_behaviour:
                        if self.last_sticky_button!=msg[0]:
                            self.gui_all_buttons[self.last_sticky_button].config(relief=RAISED)
                        self.last_sticky_button=msg[0]
                else:
                    if not self.sticky_key_behaviour:
                        self.gui_all_buttons[msg[0]].config(relief=RAISED)
            if self.config.debug:
                print msg
</code></pre>
</div></div><p>
Класс GuiManager инкапсулирован внутрь класса ThreadedClient, который принимает на вход главный поток Tkinter и выставляет вызов функции разбора очереди каждые 20 миллисекунд:

</p><div class="spoiler"><b class="spoiler_title">Класс, инкапсулирующий GuiManager</b><div class="spoiler_text"><pre><code class="python">class ThreadedClient:
    def __init__(self, master):
        self.master = master

        self.config=ConfigManager()
        self.keyTrainer=keyboardStatus(self.config)
        keyTrainer=self.keyTrainer

        master.protocol('WM_DELETE_WINDOW', self.kill_and_destroy)

        self.guiManager=GuiManager(master,self.config,keyTrainer.myQueue,keyTrainer)

        keyTrainer.begin_scan()

        self.running = 1
        self.periodicCall()
    def kill_and_destroy(self):
        self.running = 0
        self.keyTrainer.stop_scan()
        if self.config.debug:
            print "Stopping scan..."
        self.master.destroy()


    def periodicCall(self):
        self.guiManager.processQueue()
        if not self.running:
            # import sys
            # sys.exit(1)
            self.kill_and_destroy()
        self.master.after(20, self.periodicCall)
</code></pre>
</div></div>
<h2>Несколько картинок</h2><p>
Общий вид окна программы:

</p><img src="https://habrastorage.org/files/1e4/618/c82/1e4618c827fa469fadf2512e68d9c8a7.png"/>
<p>
Нажата левая клавиша Alt:

</p><img src="https://habrastorage.org/files/850/25b/2bb/85025b2bb5e140dea1bf8c09a539669a.png"/>
<p>
Окно программы после перенастройки:

</p><img src="https://habrastorage.org/files/0bf/f38/2af/0bff382af5784ac895305503b4434769.png"/>
<p>
При наведении курсора мыши окно программы «уезжает» под заголовок (цвета, которые остаются на белом фоне — артефакты сжатия ролика):

</p><img src="https://habrastorage.org/files/070/73e/bdb/07073ebdbbd94be8a297d08f4cc0e8aa.gif"/>
<p>
Нажатие клавиши shift и переключение языка:

</p><img src="https://habrastorage.org/files/d0d/bb9/69e/d0dbb969e0084b648f9632f9a105e0ad.gif"/>

<h2>Заключение</h2><p>
Что же получилось в итоге? А получилась неплохая программа для того, чтобы помогать людям учиться печатать вслепую на клавиатуре. Да, у нее есть недостатки и неэффективности, а именно:
</p><ul>
<li>Запускаемые со стороны процессы с командами bash для чтения символов;</li>
<li>Жестко заданные языки (только русский и английский);</li>
<li>Квадратный интерфейс;</li>
<li>Работает на Ubuntu и Linux Mint (MATE), на других дистрибутивах не опробована;</li>
</ul><p>
Код можно скачать/посмотреть здесь: </p><a href="https://bitbucket.org/alien713cea/key_trainer/downloads">Ссылка на bitbucket</a><p>
Для работы программы необходим python 2.7 и Tkinter. Чтобы установить последний, необходимо выполнить команду:

</p><pre><code class="bash">sudo apt-get install python-tk
</code></pre><p>
Запуск программы выполняется скриптом Start.sh из директории с программой.
</p><p>
Спасибо за внимание!
</p><p>
P.S. Поступил вопрос: сколько времени заняло написание программы? Времени было потрачено в общей сумме часов 6-8, после первых трех было активное тестирование и допиливались всякие детали.
</p><p>
UPD: убрал try/except из обработки очереди со стороны GUI
      </p><p class="clear"/>
    </div>

    
  </div></body></html>