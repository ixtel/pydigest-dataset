<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/files/ea5/9ea/c5f/ea59eac5fd5545569d50995571442cdf.jpg" align="left"/><p>
Контур делает несколько десятков продуктов, каждый из которых состоит из нескольких десятков микросервисов, каждый из которых запущен на десятках серверов.
</p><p>
Эта инфраструктура порождает метрики на всех технологических уровнях — нагрузка на железо, состояние ОС, метрики приложений. Исходные данные собираются в один большой кластер </p><a href="https://github.com/graphite-project/">Graphite</a><p>. Сейчас у нас есть миллион уникальных метрик, по которым суммарно генерируется 20 тысяч значений в секунду.
</p><p>
Ясно, что за миллионом метрик не уследить глазами на телевизорах и дашбордах — нужна система отправки уведомлений о нештатных ситуациях. Перед тем как написать свою систему Moira, мы использовали для этой задачи </p><a href="https://github.com/scobal/seyren">Seyren</a><p>.
</p><a name="habracut"/>

<h2>Плюсы и минусы Seyren</h2><p>
Seyren позволяет через веб-интерфейс указать произвольное выражение на языке функций Graphite и подписаться на уведомления. Уведомления приходят в том случае, если результат вычисления выражения превысил фиксированный порог.
</p><p>
Кажется, это то, что нужно. Но за год эксплуатации Seyren мы наступили на несколько граблей:

</p><ol>
<li>Внутри Контура есть несколько команд, которые делают разные продукты. В Seyren нет понятия «пользователь» или «группа» — каждый видит настройки и события всех остальных в одном огромном списке.<br/>
</li>
<li>Seyren при вычислении значения метрики полагается на API Graphite и сама никак не валидирует введенные выражения. Ошибки при этом падают где-то внутри в логи, а в веб-интерфейсе все выглядит работающим. Если вы нарисуете график в веб-интерфейсе Graphite, нет никакой гарантии, что такое же выражение будет работать в Seyren. А если и будет, его вычисление может дать неожиданный результат.</li>
<li>Не все запросы в Graphite работают эффективно. При большом количестве метрик выражение может вычисляться несколько секунд. Не беда, если это происходит однократно по запросу пользователя. Но Seyren запрашивает каждое сохраненное выражение через API Graphite раз в минуту. Если таких выражений в Seyren несколько, они гарантированно убивают кластер любого размера. Не хочется учить всех пользователей мониторинга искусству составления оптимальных запросов в Graphite.</li>
<li>Seyren пропускает события. Мы своими глазами видели точки на графике, которые выходили за пороговое значение, но Seyren при этом необъяснимо молчала. Стабильно воспроизвести и, тем более, починить этот баг нам не удалось.</li>
</ol>

<h2>Альтернативы Seyren</h2><p>
А почему мы вообще выбрали Seyren? Должны быть другие варианты.
</p><p>
Seyren — это лучшее, что было в разделе Monitoring на странице </p><a href="http://graphite.readthedocs.org/en/latest/tools.html#monitoring">Tools That Work With Graphite</a><p> из официальной документации Graphite. Мы пробовали все и выбрали Seyren. Возможно, вам подойдет что-то другое с этой страницы (теперь Moira там тоже есть).
</p><p>
Еще есть </p><a href="http://riemann.io">riemann</a><p>. Скорее всего, это самая гибкая и производительная система мониторинга в мире. Она поддерживает входящие данные в формате Graphite. Настройки riemann — это код, который хранится в репозитории. Одним словом, это настоящий DevOps.
</p><p>
К сожалению, у riemann слишком высокий порог входа. Для Seyren этот порог нулевой — если вы пользуетесь Graphite, скопировать выражение в Seyren не требует никаких дополнительных знаний. Конфигурация riemann — это код на Clojure. Страница </p><a href="http://riemann.io/clojure.html">Just enough Clojure to work with Riemann</a><p> — это пара часов вдумчивого чтения, даже если вам знакома концепция функционального программирования. Мы хотим, чтобы любой разработчик мог настроить уведомления о неполадках в своей зоне ответственности, не изучая новый язык программирования.
</p><p>
А раз уж мы начали обсуждать, чего мы хотим или не хотим, давайте поймем, какие у нас вообще есть требования к системе уведомлений.

</p><h2>Требования к системе отправки уведомлений</h2>
<ol>
<li>Не должна нагружать кластер Graphite частыми автоматизированными запросами. Хорошо, если она вообще не будет зависеть от основного кластера Graphite.</li>
<li>Должна поддерживать все функции Graphite и вычислять их так же, как они вычисляются при построении графиков.</li>
<li>Должна уметь различать пользователей и дать им возможность настраивать, что они будут видеть в веб-интерфейсе.</li>
<li>Должна уметь отправлять уведомления через популярные каналы — электронную почту, Slack, Pushover, Telegram. При этом добавление новых плагинов должно быть не слишком сложным.</li>
</ol>

<h2>Moira: как мы построили такую систему</h2><p>
Moira состоит из модулей, как и сам Graphite. Сейчас это принято называть микросервисной архитектурой. Это позволяет в любой момент заменить часть системы на более производительную или более функциональную, не выбрасывая систему целиком. Все части Moira независимы друг от друга и общаются только через единое хранилище данных Redis.

</p><h3>moira-cache</h3><p>
Мы хотим оставить в покое Graphite — следовательно, мы хотим получать копию потока входящих метрик. Но входящих метрик очень много.
</p><p>
Чтобы решить эту проблему, нужно учесть два обстоятельства:
</p><ol>
<li>Для оповещений нужна только свежая информация — историю при необходимости можно посмотреть в Graphite.</li>
<li>Среди всего потока входящих метрик нужны только те, на которые настроено хотя бы одно правило оповещения.</li>
</ol><p>
Moira-cache — это быстрый сервис на Go, который принимает входящий поток метрик, фильтрует из них нужные и сохраняет в Redis кэш значений этих метрик за последний час.

</p><h3>moira-worker</h3><p>
Мы хотим поддерживать все функции Graphite, и чтобы они вычислялись в точности так же, как в самом Graphite. Раз уж Graphite выложен в opensource, самый надежный способ добиться результата — взять исходники Graphite и включить их прямо в наше приложение.
</p><p>
Moira-worker — это сервис на Python, который проверяет значения в кэше с помощью оригинального кода функций Graphite и генерирует события для оповещения.
</p><p>
Кроме того, мы добавили в moira-worker возможность использовать для уведомлений не только функции Graphite, но и более универсальные Python-выражения.

</p>
<i>страница редактирования уведомлений</i>

<h3>moira-web</h3><p>
Мы хотим уметь различать пользователей и показывать каждому только то, что он хочет видеть. Это две задачи.
</p><p>
Как различать пользователей? Система мониторинга — это инструмент для интранета, и здесь невозможно придумать одно решение для аутентификации, которое устроило бы всех. Кому-то нужен LDAP, кому-то логин через GitHub или Google. Мы не стали ничего придумывать: Moira просто доверяет заголовку X-Webauth-User, полученному от вышестоящего веб-сервера (например, nginx или oauth_proxy). Чтобы Moira научилась различать ваших пользователей, вам нужно передать в значении этого заголовка идентификатор пользователя (например, логин).
</p><p>
Как показывать пользователю только те настройки, которые он хочет видеть? Для этого мы используем теги, которые работают как в веб-интерфейсе, так и в настройке уведомлений.

</p>
<i>список настроенных уведомлений на главном экране</i>


<i>страница редактирования подписок</i>

<h3>moira-notifier</h3><p>
Мы хотим уметь отправлять уведомления через популярные каналы — Slack, Telegram, почту, Pushover. Кроме того, moira-notifier: 

</p><ol>
<li>Умеет соблюдать заданное расписание (например, не беспокоит ночью по пустякам).</li>
<li>Защищает пользователя от заваливания письмами, если какой-то из триггеров «взбесился» и начал присылать уведомления слишком часто.</li>
<li>Повторяет отправку уведомления, если произошла ошибка доставки.</li>
</ol>

<h2>Как попробовать Moira? Как задать вопрос разработчикам?</h2><p>
Мы используем Moira в продакшен-окружении уже полгода. На одной восьмиядерной виртуальной машине мы обрабатываем входящий поток в 20 тысяч точек в секунду при тысячах отслеживаемых метрик и сотнях пользователей.
</p><p>
В конце 2015 года мы решили, что Moira уже достаточно стабильна для того, чтобы предложить opensource-сообществу попробовать ей воспользоваться.
</p><p>
Инструкция по установке и использованию есть в </p><a href="http://moira.readthedocs.org">нашей документации</a><p>. Кроме того, вы можете </p><a href="https://github.com/moira-alert">посмотреть код на GitHub</a><p>, прислать багрепорт или пуллреквест.
</p><p>
Если ваша нагрузка выше, или у вас сильнее ограничены ресурсы — приходите пообщаться в наш </p><a href="https://gitter.im/moira-alert/moira">чат Gitter</a><p>. Мы расскажем, как масштабировать Moira для вашего случая, или вместе попробуем оптимизировать ее код.
</p><p>
И, конечно, мы с удовольствием ответим на ваши вопросы в комментариях.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>