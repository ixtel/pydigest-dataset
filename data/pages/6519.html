<html><body><div><div class="entry-content">
            <p>Часто спрашивают, как отслеживать изменение структуры сайта на Django-CMS в системах контроля версий.</p>
<h3>В чём, собственно, проблема?</h3>
<p>Бывает, заказчик ставит задачу разработчикам так:</p>
<ol>
<li>Добавить страницу «О компании» по адресу  <code>/about/</code>;</li>
<li>Разместить на странице текст «мы самые крутые».</li>
</ol>
<h4>Как такое рекомендуется делать в Django-CMS:</h4>
<ul>
<li>Через админку создать страницу;</li>
<li>в интерфейсе редактирования структуры разместить плагин <code>TextPlugin</code> в соответствующий placeholder;</li>
<li>в интерфейсе редактирования контента добавить текст в этот плагин.</li>
</ul>
<p>Все эти действия приводят к изменениям в БД, но ни один файл при этом не затронут. Соответственно, страница добавлена, а в коммит добавлять нечего. Каждый разработчик должен у себя самостоятельно создать новую страницу, а на тестовом сервере и в продакшне ещё отдельно сделать то же самое? Но это же не наш метод!</p>
<h3>И что же делать?</h3>
<p>На помощь нам приходят <a href="http://djbook.ru/rel1.8/topics/migrations.html#data-migrations">миграции данных</a> и <a href="http://docs.django-cms.org/en/develop/reference/api_references.html">cms.api</a>. Миграции данных позволяют управлять контентом в БД. Cms.api позволяет выполнять действия по управлению контентом.</p>
<p>Итак, создаём пустую миграцию:</p>
<pre><code>python manage.py makemigrations app_name --empty
</code></pre>
<p>В свежесозданном файле миграции определяем функцию, которая сделает всю работу по созданию новых сущностей:</p>
<pre><code>from cms.api import create_page, add_plugin, publish_page
from django.contrib.auth.models import User

def add_pages(apps, schema_editor):
    page = create_page(
        'about',
        'default.html',
        'ru'
    )
    placeholder = page.placeholders.get(slot='content')
    add_plugin(placeholder, 'TextPlugin', 'ru', body='Мы самые крутые')
    try:
        user = User.objects.filter(is_superuser=True).first()
        publish_page(page, user, 'ru')
    except User.DoesNotExists:
        print("стоит создать суперюзера, иначе опубликовать страницу можно будет только из админки, для чего всё равно нужен суперюзер")
</code></pre>
<ul>
<li>функция create_page создаёт страницу с заданными параметрами.
   <a href="http://docs.django-cms.org/en/develop/reference/api_references.html#cms.api.create_page">Подробнее в документации</a>;</li>
<li>предположим, в шаблоне <code>default.html</code> размещён тэг <code>{% placeholder "content" %}</code>. Тогда можно методом <code>page.placeholders.get(slot='content')</code> выбрать именно это место размещения для плагина;</li>
<li>функция <code>publish_page</code> опубликовывает отредактированную страницу. Один из обязательных параметров — пользователь, от имени которого изменённая страница публикуется. Обойти это можно, но придётся функцию переписывать. Мы же делаем как проще.</li>
</ul>
<p>Теперь в классе миграции можно определять действия:
    class Migration(migrations.Migration):</p>
<pre><code>    operations = [
        migrations.RunPython(add_pages) # это имя вышеопределённой функции
    ]
</code></pre>
<p>Применяем эту миграцию, и видим новую уже опубликованную страницу, на которой размещён текстовый плагин, и в нём набран нужный текст.</p>
<p>А вот миграцию уже можно определить в коммит. Что и требовалось.</p>
        </div>
        

        

        </div></body></html>