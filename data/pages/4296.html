<html><body><div><div class="entry">
					<p>This afternoon, <a href="https://twitter.com/matlock">Matt Locke</a> tweeted the following problem from his nine-year-old daughter’s maths homework:</p>
<p><a href="https://twitter.com/matlock/status/592308642948489216/photo/1"><img class="alignnone size-full wp-image-1410" src="https://bosker.files.wordpress.com/2015/04/3975.jpg?w=480" alt="3975"/></a></p>
<p><span id="more-1409"/></p>
<p>Coins in general circulation in the UK come in the denominations 1p, 2p, 5p, 10p, 20p, 50p, £1 and £2, and I think we are supposed to assume that the coins in the problem are drawn from this set.</p>
<p>It’s a curious sort of homework problem, because there is no obvious systematic way to approach it. Presumably the intention is that the child will fiddle about with numbers until they either hit on a solution or give up.</p>
<p>But that is not a very mathematically satisfying approach. It piqued my interest partly because it’s essentially a system of two linear diophantine equations in eight variables. If we let <img src="https://s0.wp.com/latex.php?latex=c_%7B1%7D&amp;bg=ffffff&amp;fg=222222&amp;s=0" alt="c_{1}" title="c_{1}" class="latex"/> be the number of 1p coins, <img src="https://s0.wp.com/latex.php?latex=c_2&amp;bg=ffffff&amp;fg=222222&amp;s=0" alt="c_2" title="c_2" class="latex"/> the number of 2p coins, etc., then we have:</p>
<p><img src="https://s0.wp.com/latex.php?latex=%5Cbegin%7Baligned%7Dc_1+%2B+2c_2+%2B+5c_5+%2B+10c_%7B10%7D+%2B+20c_%7B20%7D+%2B+50c_%7B50%7D+%2B+100c_%7B100%7D+%2B+200c_%7B200%7D+%26%3D+3975+%5C%5C+c_1+%2B+c_2+%2B+c_5+%2B+c_%7B10%7D+%2B+c_%7B20%7D+%2B+c_%7B50%7D+%2B+c_%7B100%7D+%2B+c_%7B200%7D+%26%3D+100+%5Cend%7Baligned%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="\begin{aligned}c_1 + 2c_2 + 5c_5 + 10c_{10} + 20c_{20} + 50c_{50} + 100c_{100} + 200c_{200} &amp;= 3975 \\ c_1 + c_2 + c_5 + c_{10} + c_{20} + c_{50} + c_{100} + c_{200} &amp;= 100 \end{aligned}" title="\begin{aligned}c_1 + 2c_2 + 5c_5 + 10c_{10} + 20c_{20} + 50c_{50} + 100c_{100} + 200c_{200} &amp;= 3975 \\ c_1 + c_2 + c_5 + c_{10} + c_{20} + c_{50} + c_{100} + c_{200} &amp;= 100 \end{aligned}" class="latex"/></p>
<p>with the additional constraint that precisely five of the eight variables should have non-zero values.</p>
<p>(I have been thinking about systems of linear diophantine equations quite a lot recently, because they play a central role in Lambert’s version of Mayr’s algorithm for Petri net reachability, but that’s another story.)</p>
<p>Now, there <em>are</em> systematic algorithms for finding all the solutions to such a system of equations. If the variables are allowed to take negative values, it is not too hard: the algorithm was first <a href="http://www.jstor.org/stable/108738">described by Henry J. Stephen Smith in 1861</a>, and the structure he used is nowadays known as the <a href="https://en.wikipedia.org/wiki/Smith_normal_form">Smith normal form</a>. But if we want only non-negative solutions, as we do here, then it is harder. One algorithm is due to Evelyne Contejean and Hervé Devie in 1994: <a href="http://www.sciencedirect.com/science/article/pii/S0890540184710674">An Efficient Incremental Algorithm for Solving Systems of Linear Diophantine Equations</a>.</p>
<p>I think Contejean-Devie is roughly as good as any algorithm for this problem, but I’m not an expert. <a href="http://www.risc.jku.at/education/courses/ss2012/algorithms/kutsia.pdf">Here are some slides that explain the algorithm pretty clearly</a>. Since all the coefficients are positive, our example has only finitely many solutions and the Contejean-Devie algorithm reduces to a brute-force search.</p>
<p>Another algorithm that would do the job is due to <a href="http://msp.org/pjm/1966/16-2/pjm-v16-n2-p09-p.pdf">Seymour Ginsburg and Edwin Spanier (1966)</a>. Since the set of solutions can be described in Presburger arithmetic, Ginsburg and Spanier’s procedure can extract an explicit finite presentation of this set. But this algorithm is likely to be even slower; it is actually <a href="http://www.lcs.mit.edu/publications/pubs/ps/MIT-LCS-TM-043.ps">provable</a> – <em>without making any unproven assumptions about complexity classes such as P≠NP</em> – that it must take at least doubly-exponential time in the worst case.</p>
<p>So there isn’t obviously any better way to approach the problem than brute force, and I was intrigued enough with the problem by this point to try a simple-minded attack in Python:</p>
<pre class="brush: python; title: ; notranslate" title="">
from itertools import combinations

COINS = (1, 2, 5, 10, 20, 50, 100, 200)
TARGET = 3975

def partitions(n, k):
    """All the partitions of n into k positive integers.
    """
    if k == 1:
        yield (n,)
        return
    for i in range(1, n):
        for p in partitions(n-i, k-1):
            yield (i,) + p

def dot(xs, ys):
    return sum([ x*y for x,y in zip(xs, ys) ])

for coin_values in combinations(COINS, 5):
    for counts in partitions(100, 5):
        if dot(coin_values, counts) == TARGET:
            print tuple(zip(counts, coin_values))
</pre>
<p>This is literally just systematically checking each of the combinations of 100 coins of five different denominations, and printing out the ones that add up to the right amount.</p>
<p>It turns out that there are <a href="http://bl.ocks.org/robinhouston/raw/775d6217209978da5f92/table.html">33,798 solutions</a>.</p>
<p>At that point I couldn’t stop, and I implemented first <a href="https://github.com/robinhouston/coins/blob/master/quickcoins.py">a slightly better algorithm in Python</a> and then a <a href="https://github.com/robinhouston/coins/blob/master/coins.c">C version of the better algorithm</a>.</p>
<p>(This last can print all 33,798 solutions in about one second, which is about 90 times faster than the Python equivalent. It’s worth reminding ourselves from time to time just how much processing power we are wasting when we code in inefficient high-level languages like Python, and marvelling at the raw speed and power of modern computers.)</p>
<p>Weird question to ask a nine-year-old, anyway.</p>
<div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><div class="sharedaddy sd-block sd-like jetpack-likes-widget-wrapper jetpack-likes-widget-unloaded" id="like-post-wrapper-235722-1409-56d5c89a9d751" data-src="//widgets.wp.com/likes/#blog_id=235722&amp;post_id=1409&amp;origin=bosker.wordpress.com&amp;obj_id=235722-1409-56d5c89a9d751" data-name="like-post-frame-235722-1409-56d5c89a9d751"><h3 class="sd-title">Like this:</h3><p class="likes-widget-placeholder post-likes-widget-placeholder"><span class="button"><span>Like</span></span> <span class="loading">Loading...</span></p><span class="sd-text-color"/><a class="sd-link-color"/></div>
<p id="jp-relatedposts" class="jp-relatedposts">
	<h3 class="jp-relatedposts-headline"><em>Related</em></h3>
</p></div>					
					<p class="tags"/>
					




	

	

	

	
					
		<p/>
				</div>
			</div></body></html>