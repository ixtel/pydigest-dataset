<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/files/7d8/0ed/ee6/7d80edee6cf044c983f366cbb12ccd53.png" alt="image" align="left"/><p>
Первые недели нового года самое подходящее время для того, чтобы уютно устроившись у окошка, вспомнить что же нам принес год ушедший. </p><p>
А принес он нам два новых стандарта шифрования. Российский стандарт ГОСТ Р 34.12-2015 (блочный шифр Кузнечик). И украинский ДСТУ 7624:2014 (блочный шифр Калина). Холодными, зимними вечерами нельзя упускать такой удачный повод покодить. Под катом краткое описание алгоритмов и их реализация на Python. А чтобы новым шифрам было веселее, разбавим их общество белорусским СТБ 34.101.31-2007.
</p><a name="habracut"/>
<h4>ГОСТ Р 34.12-2015</h4><p>
Начать предлагаю с российского стандарта — блочного шифра Кузнечик. Длина входного блока шифра — 128 бит, длина ключа — 256 бит.</p><p>
В шифре используются следующие преобразования:
</p><ul>
<li><b>X</b> — побитовое сложение по модулю 2 с ключом:<br/>
<img src="https://habrastorage.org/files/dc7/6b4/0a3/dc76b40a3f404b17ab19109ddcba14f9.PNG"/> </li>
<li>Нелинейное преобразование <b>S</b> осуществляется заменой каждого байта подстановкой из таблицы π:<br/>
<img src="https://habrastorage.org/files/8f9/f6e/26b/8f9f6e26b102409ca7f875456737ed6c.PNG"/> </li>
<li>Линейное преобразование <b>L</b> реализуется с помощью умножения над полем Галуа по модулю многочлена <img src="https://habrastorage.org/files/b1e/043/e29/b1e043e292f64d7c81454ff8b86f42b4.PNG"/>:<br/>
 Δ — отображение, сопоставляющее двоичной строке элемент конечного поля. <br/>
<img src="https://habrastorage.org/files/ea5/948/420/ea59484202f34d37b6b7b4d617fb2671.PNG"/> — отображение, сопоставляющее элементу конечного поля двоичную строку.<br/>
<img src="https://habrastorage.org/files/573/dc2/d97/573dc2d976a54463ab813982e11cb6f1.PNG"/><br/>
При вычислении <img src="https://habrastorage.org/files/62e/206/839/62e20683911b457db90140ff96f7fc47.PNG"/> операции сложения и умножения производятся в конечном поле.<br/>
<img src="https://habrastorage.org/files/8e8/575/3fa/8e85753fa3124722893185001ae686ad.PNG"/><br/>
<img src="https://habrastorage.org/files/a2c/3aa/f14/a2c3aaf14503495aa9271ff231552a74.PNG"/></li>
</ul><p>
Процедуру зашифрования 128-битного блока </p><b>a</b><p> формально описывается выражением:
</p><img src="https://habrastorage.org/files/063/f9b/276/063f9b2768dc4c4395c4e4e712e0fee8.PNG"/><p>. </p><p>
Что в более наглядной форме выглядит так: 
</p><img src="https://habrastorage.org/files/819/fad/591/819fad5913e84248a47716cfe313f100.png"/>
<p>
Раундовые 128-битные ключи K</p><sub>1</sub><p>, K</p><sub>2</sub><p> получаются разбиением основного 256-битного ключа пополам.</p><p>
С их помощью вычисляются следующие раундовые ключи:
</p><img src="https://habrastorage.org/files/d56/134/551/d56134551d9c4deca19b49d15c81b199.PNG"/>
<img src="https://habrastorage.org/files/f25/d63/1c6/f25d631c62324992ae0b9c1ac3dff16a.PNG"/>
<img src="https://habrastorage.org/files/10a/0d3/8c8/10a0d38c8a2a4b0ab85f5ee979d526b1.PNG"/>
<p>
При расшифровании используются обратные преобразования:
</p><img src="https://habrastorage.org/files/a48/c49/fd0/a48c49fd0e6544aba37327fd3067dd09.PNG"/>
<p>
Пример использования на Python:
</p><pre><code class="python">if __name__ == '__main__':
    mtest = list(binascii.unhexlify('1122334455667700ffeeddccbbaa9988'))
    ktest = list(binascii.unhexlify('8899aabbccddeeff0011223344556677fedcba98765432100123456789abcdef'))
    gost =gost2015(ktest)
    print('GOST 34.12-2015')
    print(datetime.datetime.now())
    c = gost.encryption(mtest)
    d = gost.decryption(c)
    print(datetime.datetime.now())
</code></pre>

<h4>ДСТУ 7624:2014</h4><p>
Введенный в июле 2015 года в качестве украинского стандарта шифр Калина поддерживает несколько вариантов длины блока и ключа. Здесь я опишу версию шифра с длиной блока и длиной ключа равной 128 бит.
</p><p>
Внутреннее состояние шифра является матрицей с 8 рядами и 2 столбцами. Перед началом шифрования матрица заполняется байтами открытого текста. Затем над элементами матрицы производится 10 раундов следующих преобразований.
</p><ul>
<li><img src="https://habrastorage.org/files/87e/db6/35f/87edb635fbe14c469adfae7302cf2e6a.PNG"/> — сложение колонок матрицы состояния с колонками раундового ключом, представленного в виде матрицы, по модулю 2<sup>64</sup>.</li>
<li><img src="https://habrastorage.org/files/ad3/cd5/fbd/ad3cd5fbd8fc415db2415922f0cc82b9.PNG"/> (SubBytes) — замена каждого байта матрицы состояния подстановкой из одной из четырех таблиц π<sub>0</sub>, π<sub>1</sub>, π<sub>2</sub>, π<sub>3</sub>.</li>
<li><img src="https://habrastorage.org/files/1bc/d9c/5e9/1bcd9c5e98354f75b99e9b8fab2fb34a.PNG"/> (SiftRows) — циклический сдвиг вправо на одну позицию строк с 4-й по 8-ю. </li>
<li><img src="https://habrastorage.org/files/b55/f9c/bc1/b55f9cbc120043968272cb813026d0f5.PNG"/> (MixColumns) — преобразование колонок матрицы состояний. Каждый элемент новой матрицы вычисляется по формуле: <img src="https://habrastorage.org/files/fff/b3d/f6f/fffb3df6f75b427a95055d6a0009e72d.PNG"/>, где ⊗ — скалярное произведение векторов, v — вектор, <img src="https://habrastorage.org/files/f52/a66/d6d/f52a66d6d1074bc09718c698076f3c1d.PNG"/>, G<sub>j</sub> — колонка матрицы. Операции умножения и сложения производится в конечном поле по модулю многочлена <img src="https://habrastorage.org/files/fd7/f34/b05/fd7f34b0555646849c4270d82ff62430.PNG"/></li>
<li><img src="https://habrastorage.org/files/ed4/fe6/4e3/ed4fe64e3b8947bf972de0c8e5a31bce.PNG"/> — побитовое сложение по модулю 2 матрицы внутреннего состояния шифра и раундового ключа K<sub>v</sub> </li>
</ul><p>
Процесс шифрования описывается следующим выражением:
</p><img src="https://habrastorage.org/files/c71/2d4/545/c712d454557849dab445606eabee9bd7.PNG"/><p>
Или в более наглядном виде:
</p><img src="https://habrastorage.org/files/09c/bd4/f62/09cbd4f621384a22927455ec0f1903cf.png"/><p>
Для формирования раундовых ключей сначала, используя мастер-ключ К, вычисляется промежуточный ключ </p><img src="https://habrastorage.org/files/f49/59b/b16/f4959bb1650e42999177c2207ac37d9a.PNG"/><p>:
</p><img src="https://habrastorage.org/files/de5/595/bb6/de5595bb6a8f4bfd880ab721e522cee5.PNG"/><p>, где </p><img src="https://habrastorage.org/files/2eb/8e2/3b8/2eb8e23b84c1472eb5bbed8497c9923b.PNG"/><p> для случаев, когда длина блока равна длине ключа.</p><p>
Ключи для четных раундов генерируются на основе промежуточного ключа:
</p><img src="https://habrastorage.org/files/d64/ce4/82a/d64ce482a1bb43daa503b582b3048c70.PNG"/><p>, где i — номер раунда, а </p><img src="https://habrastorage.org/files/3ba/e96/6cd/3bae966cd165474db6b8b85a80146aab.PNG"/><p> и </p><img src="https://habrastorage.org/files/45b/715/25e/45b71525e00e4314a4589b58c7f8c38e.PNG"/><p>0x01000100010001000100010001000100</p><p>
Ключи для нечетных раундов вычисляются так:
</p><img src="https://habrastorage.org/files/ad9/51c/826/ad951c8267454ce986dbe75fba294490.PNG"/><p>, где l — длина блока.
</p><p>
При расшифровании используются обратные преобразования:
</p><img src="https://habrastorage.org/files/204/600/47e/20460047e0614163a1b68a4dac6ff009.PNG"/>
<p>
Пример использования на Python:
</p><pre><code class="python">if __name__ == '__main__':
    key = list(binascii.unhexlify('000102030405060708090a0b0c0d0e0f'))
    pt = list(binascii.unhexlify('101112131415161718191a1b1c1d1e1f'))
    dstu =dstu2014(key)

    key2 = list(binascii.unhexlify('0f0e0d0c0b0a09080706050403020100'))
    ct = list(binascii.unhexlify('1f1e1d1c1b1a19181716151413121110'))
    dstu2 = dstu2014(key2)

    print(datetime.datetime.now())
    c = dstu.encryption(pt)
    d = dstu2.decryption(ct)
    print(datetime.datetime.now())
</code></pre>

<h4>СТБ 34.101.31-2007</h4><p>
Шифр BelT, имеющий длину блока 128 бит и длину ключа 256 бит, был принят в качестве стандарта симметричного шифрования республики Беларусь в 2011 году. Шифрование осуществляется 8 раундами преобразований, применяемых ко входному блоку.</p><p>
Процедура зашифрования состоит из следующих шагов:
</p><ul>
<li>Входной блок записывается в виде <img src="https://habrastorage.org/getpro/habr/post_images/196/dc0/53a/196dc053a66db18b239e1a945a8cac98.png" alt="image"/> </li>
<li>Ключ записывается в виде <img src="https://habrastorage.org/getpro/habr/post_images/59b/55f/413/59b55f413783843523cce94c6afa9a7e.png" alt="image"/> и определяются раундовые ключи <img src="https://habrastorage.org/files/eb4/996/9ea/eb49969eaa2f42acab31965d956d03d8.PNG"/></li>
<li>Дополнительным переменным a, b, c, d присваиваются значения <img src="https://habrastorage.org/getpro/habr/post_images/66d/775/697/66d77569742027ba23c30027c704c92c.png" alt="image"/> </li>
<li><img src="https://habrastorage.org/files/dc7/140/78e/dc714078e00347cd83f09aff77359bb0.PNG"/><br/>
Где G<sub>r</sub> — операция преобразования 32-битной входной строки и <img src="https://habrastorage.org/files/44a/b67/47b/44ab6747b5d94083b34b39776dae2726.PNG"/>; RotHi<sup>r</sup> — циклический сдвиг влево на r бит; <i>H(u)</i> — операция замены 8-битной входной строки подстановкой из таблицы; <img src="https://habrastorage.org/files/0dd/d99/573/0ddd995736374bb2982d8632380b0046.PNG"/> и <img src="https://habrastorage.org/files/c45/686/e32/c45686e32a6447fa9162369814ad887f.PNG"/> — операции сложения и вычитания по модулю 2<sup>32</sup>.</li>
<li><img src="https://habrastorage.org/getpro/habr/post_images/6ad/19f/15d/6ad19f15d078eafa09de26fd166b70e1.png" alt="image"/> возвращается в качестве шифртекста. </li>
</ul><p>
При расшифровании те же операции применяются в обратном порядке.
</p><p>
Пример использования на Python:
</p><pre><code class="python">if __name__ == '__main__':
    key = list(binascii.unhexlify('E9DEE72C8F0C0FA62DDB49F46F73964706075316ED247A3739CBA38303A98BF6'))
    belt1 = belt(key)
    m = list(binascii.unhexlify('B194BAC80A08F53B366D008E584A5DE4'))

    key2 = list(binascii.unhexlify('92BD9B1CE5D141015445FBC95E4D0EF2682080AA227D642F2687F93490405511'))
    belt2 = belt(key2)
    c = list(binascii.unhexlify('E12BDC1AE28257EC703FCCF095EE8DF1'))
    print(datetime.datetime.now())
    c1 = belt1.encryption(m)
    d1 = belt2.decryption(c)
    print(datetime.datetime.now())
</code></pre>

<h4>PS</h4><p>
Реализацию всех описанных алгоритмов на Python можно найти на </p><a href="https://github.com/NeverWalkAloner/Cryptography-standards">GitHub</a><p>.

</p><h4>Ссылки</h4>
<ol>
<li>Более подробное описание шифра Кузнечик приводится и в <a href="http://habrahabr.ru/post/266359/">этой</a> статье пользователя  <a href="http://habrahabr.ru/users/ru_crypt/" class="user_link">ru_crypt</a>, из которой я позаимствовал несколько иллюстраций. </li>
<li>Текст стандарта ГОСТ Р 34.12-2015 можно найти <a href="http://tc26.ru/standard/gost/GOST_R_3412-2015.pdf">тут</a>.</li>
<li>Описание шифра Калина доступно <a href="https://eprint.iacr.org/2015/650.pdf">здесь</a>. </li>
<li>Стандарт СТБ 34.101.31-2007 лежит <a href="http://apmi.bsu.by/assets/files/std/belt-spec27.pdf">тут</a>.</li>
</ol>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>