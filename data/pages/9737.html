<html><body><div><div class="post-text" itemprop="text">
<p>I would do this in a similar way you're thinking of, using the 'you shall not pass' <em><a href="https://www.youtube.com/watch?v=V4UfAL9f74I" rel="nofollow">Gandalf</a></em> exception handler <em><a href="https://docs.python.org/2.7/library/exceptions.html#exceptions.Exception" rel="nofollow"><code>except Exception</code> to catch all non-system-exiting exceptions</a></em> while creating a black-listed <code>set</code> of exceptions that should pass and end be re-raised.</p>

<p>Using the <em>Gandalf handler</em> will make sure <a href="https://docs.python.org/2.7/library/exceptions.html#exceptions.GeneratorExit" rel="nofollow"><code>GeneratorExit</code></a>, <a href="https://docs.python.org/2.7/library/exceptions.html#exceptions.SystemExit" rel="nofollow"><code>SystemExit</code></a> and <a href="https://docs.python.org/2.7/library/exceptions.html#exceptions.KeyboardInterrupt" rel="nofollow"><code>KeyboardInterrupt</code></a> (all system-exiting exceptions) pass and terminate the program if no other handlers are present higher in the call stack. Here is where you can check with <a href="https://docs.python.org/2.7/library/functions.html#type" rel="nofollow"><strong><code>type(e)</code></strong></a> that a <code>__class__</code> of a caught exception <code>e</code> actually belongs in the set of black-listed exceptions and re-<a href="https://docs.python.org/2.7/library/exceptions.html#exceptions.KeyboardInterrupt" rel="nofollow"><code>raise</code></a> it.</p>

<p>As a small demonstration:</p>

<pre><code>import exceptions  # Py2.x only

# dictionary holding {exception_name: exception_class}
excptDict = vars(exceptions)

exceptionNames = ['MemoryError', 'OSError', 'SystemError'] # and others

# set containing black-listed exceptions
blackSet = {excptDict[exception] for exception in exceptionNames}
</code></pre>

<p>Now <code>blackSet = {OSError, SystemError, MemoryError}</code> holding the classes of the non-system-exiting exceptions we want to <strong>not</strong> handle.</p>

<p>A <code>try-except</code> block can now look like this:</p>

<pre><code>try:
    # calls that raise exceptions:
except Exception as e:
    if type(e) in blackSet: raise e # re-raise
    # else just handle it
</code></pre>

<p>An <strong>example</strong> which catches all exceptions using <a href="https://docs.python.org/2.7/library/exceptions.html#exceptions.BaseException" rel="nofollow"><code>BaseException</code></a> can help illustrate what I mean. (this is done <em>for demonstration purposes only</em>, in order to see how this raising will eventually terminate your program). <strong>Do note</strong>: <em>I'm <strong>not</strong> suggesting you use <code>BaseException</code>; I'm using it in order to <strong>demonstrate</strong> what exception will actually 'pass through' and cause termination</em> (i.e everything that <code>BaseException</code> catches):</p>

<pre><code>for i, j in excptDict.iteritems():
    if i.startswith('__'): continue  # __doc__ and other dunders
    try:
        try:
            raise j
        except Exception as ex:
            # print "Handler 'Exception' caught " + str(i)
            if type(ex) in blackSet:
                raise ex           
    except BaseException:
        print "Handler 'BaseException' caught " + str(i)

# prints exceptions that would cause the system to exit     
Handler 'BaseException' caught GeneratorExit
Handler 'BaseException' caught OSError
Handler 'BaseException' caught SystemExit
Handler 'BaseException' caught SystemError
Handler 'BaseException' caught KeyboardInterrupt
Handler 'BaseException' caught MemoryError
Handler 'BaseException' caught BaseException
</code></pre>

<p>Finally, in order to make this Python 2/3 agnostic, you can <code>try</code> and <code>import exceptions</code> and if that fails (which it does in Python 3), fall-back to importing <a href="https://docs.python.org/3.5/library/builtins.html" rel="nofollow"><code>builtins</code></a> which contains all <code>Exceptions</code>; we search the dictionary by name so it makes no difference:</p>

<pre><code>try:
    import exceptions
    excDict = vars(exceptions)
except ImportError:
    import builtins 
    excDict = vars(builtins)
</code></pre>

<p>I don't know if there's a smarter way to actually do this, another solution might be instead of having a <code>try-except</code> with a signle <code>except</code>, having 2 handlers, one for the black-listed exceptions and the other for the general case:</p>

<pre><code>try:
    # calls that raise exceptions:
except tuple(blackSet) as be:  # Must go first, of course.
    raise be
except Exception as e:
    # handle the rest
</code></pre>
    </div>
    </div></body></html>