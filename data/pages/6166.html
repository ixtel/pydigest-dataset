<html><body><div><div id="what-is-an-m-tuple">
<h4>What is an m-tuple?</h4>
<p>The simplest <em>m-tuple</em> is the 1-tuple (<em>m</em> = 1). <tt>methtuple</tt> tabulates
the number of reads that are methylated (<em>M</em>) and unmethylated (<em>U</em>) for
each methylation 1-tuple in the genome. 1-tuples are the type of
methylation calling performed by most methylation calling software such
as Bismark’s <tt>bismark_methylation_extractor</tt>.</p>
<p>A 2-tuple (<em>m</em> = 2) is a pair of methylation loci. <tt>methtuple</tt>
tabulates the number of reads that methylated at each locus in the pair
(<em>MM</em>), both unmethylated (<em>UU</em>) or methylated at one locus but not the
other (<em>MU</em> or <em>UM</em>). This idea readily extends to 3-tuples, 4-tuples,
etc.</p>
<p>In its default settings, and with <em>m</em> &gt; 1, <tt>methtuple</tt> tries to create
only m-tuples made of “neighbouring” loci. However, please see the
example below for why I say this only “tries” to create m-tuples of
neighbouring loci. For a DNA fragment containing <em>k</em> methylation loci
there are <em>m - k + 1</em> m-tuples made of neighbouring loci.</p>
<p>Alternatively, we can create all combinations of m-tuples by using the
<tt><span class="pre">--all-combinations</span></tt> flag. For a DNA fragment containing <em>k</em>
methylation loci there are “<em>k</em> choose <em>m</em>” m-tuples when using
<tt><span class="pre">--all-combinations</span></tt>, a number that grows rapidly in <em>k</em>, particularly
when <em>m</em> is close to <em>k/2</em>.</p>
<p>Regardless of how m-tuples are constructed, <tt>methtuple</tt> always takes
care to only count each methylation locus once when it has been
twice-sequenced by overlapping paired-end reads.</p>
</div>
<div id="draw-me-a-picture">
<h4>Draw me a picture</h4>
<p>Well, I hope ASCII art will do.</p>
<p>Suppose we sequence a region of the genome containing five methylation
loci with three paired-end reads (<tt>A</tt>, <tt>B</tt> and <tt>C</tt>):</p>
<pre>ref: 1    2   3 4 5
A_1: |-----&gt;
A_2:         &lt;------|
B_1: |-----&gt;
B_2:           &lt;----|
C_1:    |-----&gt;
C_2:      &lt;------|
</pre>
<p>If we are interested in 1-tuples, then we would obtain the following
from each read by running <tt>methtuple</tt>:</p>
<pre>A: {1}, {2}, {3}, {4}, {5}
B: {1}, {2}, {4}, {5}
C: {2}, {3}, {4}
</pre>
<p>This result is true regardless of whether the <tt><span class="pre">--all-combinations</span></tt>
flag is set.</p>
<p>If we are interested in 3-tuples, then we would obtain the following
from each read by running <tt>methtuple</tt> in its default mode:</p>
<pre>A: {1, 2, 3}, {2, 3, 4}, {3, 4, 5}
B: {1, 2, 4}, {2, 4, 5}
C: {2, 3, 4}
</pre>
<p>Things to note:</p>
<ul>
<li>Read-pair <tt>A</tt> sequences all three (= 5 - 3 + 1) “neighbouring”
3-tuples</li>
<li>Read-pair <tt>B</tt> sequences none of the “neighbouring” 3-tuples but
does “erroneously” construct two non-neighbouring 3-tuples. This
happens because m-tuples are created independently from each
read-pair; effectively, read-pair <tt>B</tt> is “unaware” of methylation
locus <tt>3</tt>. Depending on the downstream analysis, you may want to
<em>post-hoc</em> filter out these “non-neighbouring” m-tuples.</li>
<li>The twice-sequenced methylation loci, <tt>2</tt> and <tt>3</tt>, in read-pair
<tt>C</tt> are not double counted.</li>
</ul>
<p>However, if we were to run <tt>methtuple</tt> with <tt><span class="pre">--all-combinations</span></tt>
then we would obtain:</p>
<pre>A: {1, 2, 3}, {2, 3, 4}, {3, 4, 5}, {1, 2, 4}, {1, 2, 5}, {1, 3, 4}, {1, 3, 5}, {1, 4, 5}, {2, 3, 5}, {2, 4, 5}
B: {1, 2, 4}, {2, 4, 5}, {1, 2, 5}, {1, 4, 5}
C: {2, 3, 4}
</pre>
</div>
</div></body></html>