<html><body><div><p class="page-subtitle page-intro" itemprop="about">Introduction to behaviour-driven development (BDD) in Python, of a RESTful application using Flask web framework. Covers the syntax, structure and goals of BDD.</p>

          <section id="tutorial-content" class="block-center-img" itemprop="text" ng-non-bindable="">
              <h3>Introduction</h3>

<p><a href="https://semaphoreci.com/community/tutorials/behavior-driven-development">Behaviour-driven development</a> allows you to describe how your application should
behave, and drive the development of features by adding new tests and making
them pass. By clearly describing how your application behaves in different
scenarios, you can be confident that the product delivered at the end meets the
requirements you set out to deliver. Following BDD lets you build up your
application piece by piece, and also provides you with living documentation of
your entire system, that is naturally maintained as you keep the tests passing.</p>

<p>By the end of this tutorial you should be able to:</p>

<ul>
<li>Create a simple REST application using the Flask framework</li>
<li>Write behaviour tests (also known as acceptance tests) using the Lettuce
library</li>
<li>Explain the structure of the tests, in terms of the Given, When, Then, And
syntax</li>
<li>Execute and debug the tests</li>
</ul>

<h2>Prerequisites</h2>

<p>Before you begin this tutorial, ensure the following are installed to your
system:</p>



<h2>Set Up Your Project Structure</h2>

<p>In this tutorial, we will build up a simple RESTful application handling the
storing and retrieval of user data. To start, create the following directory
structure for the project on your filesystem, along with the corresponding empty
files to be added to later:</p>

<pre><code> .
├── test
│     ├── features
│            ├── __init__.py
│            ├── steps.py
│            └── user.feature  
└── app
     ├── __init__.py
     ├── application.py
     └── views.py
</code></pre>

<p>The files can be described as follows:</p>

<ul>
<li>
<code>__init__.py</code>: mark directory as a Python package.</li>
<li>
<code>steps.py</code>: The Python code which is executed by the <code>.feature</code> files.</li>
<li>
<code>user.feature</code>: The behaviour test which describes the functionality of the
user endpoint in our application.</li>
<li>
<code>application.py</code>: The entry point where our Flask application is created and
the server started.</li>
<li>
<code>views.py</code>: Code to handle the registration of views and defines the responses
to various HTTP requests made on the view.</li>
</ul>

<h2>Create the Skeleton Flask Application</h2>

<p>For the purposes of this tutorial, you will need to define a simple web
application using the Flask framework, to which you will add features following
the BDD approach outlined later in the tutorial.  For now, let's get an empty
skeleton application running for you to add to.  Open up the file
<code>application.py</code> and add the following code:</p>

<div class="highlight highlight-python"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>

<p>This code simply creates our Flask instance, and allows you to start the
packaged development server Flask provides when you execute this Python file.
Should you have everything installed correctly, open up a command prompt on
your operating system and execute the following command from the root of the
project:</p>

<div class="highlight highlight-bash"><pre>python app/application.py
</pre></div>

<p>If you see the following output, then your Flask application is running
correctly, and you can proceed with the tutorial:</p>

<div class="highlight highlight-bash"><pre><span class="nv">$ </span>python app/application.py
 * Running on http://127.0.0.1:5000/ <span class="o">(</span>Press CTRL+C to quit<span class="o">)</span>
</pre></div>

<h2>Write Your First BDD Test</h2>

<p>As we want to follow BDD, we will start by writing the test first which
describes the initial functionality we want to develop in our application. Once
the test is in place and failing, we will proceed to writing the code to make
the test pass.</p>

<h3>Write the Feature file</h3>

<p>Edit <code>user.feature</code> and add the following code to the first line:</p>

<div class="highlight highlight-gherkin"><pre><span class="k">Feature:</span><span class="nf"> Handle storing, retrieving and deleting customer details</span>
</pre></div>

<p>This first line is simply documentation for what functionality the set of
scenarios in this file cover.  Following this, let's add your first scenario:</p>

<div class="highlight highlight-gherkin"><pre><span class="nf">  </span><span class="k">Scenario:</span><span class="nf"> Retrieve a customers details</span>
</pre></div>

<p>Again, this line is simply documentation on what functionality this specific
scenario is testing. Now, let's add the actual body of the scenario test:</p>

<div class="highlight highlight-gherkin"><pre><span class="nf">  </span><span class="k">Scenario:</span><span class="nf"> Retrieve a customers details</span>
<span class="k">      Given </span><span class="nf">some users are in the system</span>
<span class="nf">      </span><span class="k">When </span><span class="nf">I retrieve the customer 'david</span><span class="s">01</span><span class="nf">'</span>
<span class="nf">      </span><span class="k">Then </span><span class="nf">I should get a '</span><span class="s">200</span><span class="nf">' response</span>
<span class="nf">      </span><span class="k">And </span><span class="nf">the following user details are returned:</span>
<span class="k">        |</span><span class="s"> name</span><span class="k">       |</span><span class="nf"/>
<span class="k">        |</span><span class="s"> David Sale</span><span class="k"> |</span>
</pre></div>

<p>You will notice the test makes use of the standard set of keywords known as
<a href="https://cucumber.io/docs/reference">gherkin</a> (e.g. <code>Given</code>, <code>When</code>, <code>Then</code>,
<code>And</code>). The syntax provides structure to your test, and generally follows the
following pattern:</p>

<ul>
<li>Given: the setup or initialisation of conditions for your test scenario. Here,
you might prime some mocks to return a successful or error response for example.
In the test above, you ensure some users are registered in the system so we can
query it.</li>
<li>When: the action under test, for example making a GET request to an endpoint
on your application.</li>
<li>Then: the assertions/expectations you wish to make in your test. For example,
in the above scenario, you are expecting a 200 status code in the response from
the web application.</li>
<li>And: allows you to continue from the keyword above. If your previous
statement began with <code>When</code>, and your next line begins with <code>And</code>, the <code>And</code>
line will be treated as a <code>When</code> also.</li>
</ul>

<p>One other important thing to note is the style of the test and how it reads. You
want to make your scenarios as easy to read and reusable as possible, allowing
anyone to understand what the test is doing, the functionality under test and
how you expect it to behave. You should make a great effort to reuse your steps
as much as possible, which keeps the amount of new code you need to write to a
minimum, and keeps consistency high across your test suite. We will cover some
techniques on reusable steps later in the tutorial, such as taking values as
parameters in your steps.</p>

<p>With Lettuce installed to your system, you can now execute the <code>user.feature</code>
file from the root directory of your project by executing the following command
in your operating system's command prompt:</p>



<p>You should see output that is similar to the following:</p>

<div class="highlight highlight-bash"><pre><span class="nv">$ </span>lettuce <span class="nb">test</span>/features/

Feature: Handle storing, retrieving and deleting customer details <span class="c"># test/features/user.feature:1</span>

  Scenario: Retrieve a customers details                          <span class="c"># test/features/user.feature:3</span>
    Given some users are in the system                            <span class="c"># test/features/user.feature:4</span>
    When I retrieve the customer <span class="s1">'david01'</span>                        <span class="c"># test/features/user.feature:5</span>
    Then I should get a <span class="s1">'200'</span> response                            <span class="c"># test/features/user.feature:6</span>
    And the following user details are returned:                  <span class="c"># test/features/user.feature:7</span>
      <span class="p">|</span> name       <span class="p">|</span>
      <span class="p">|</span> David Sale <span class="p">|</span>

<span class="m">1</span> feature <span class="o">(</span><span class="m">0</span> passed<span class="o">)</span>
<span class="m">1</span> scenario <span class="o">(</span><span class="m">0</span> passed<span class="o">)</span>
<span class="m">4</span> steps <span class="o">(</span><span class="m">4</span> undefined, <span class="m">0</span> passed<span class="o">)</span>

You can implement step definitions <span class="k">for</span> undefined steps with these snippets:

<span class="o">[</span> example snippets removed <span class="k">for</span> readability <span class="o">]</span>
</pre></div>

<p>You will notice here that our tests have obviously not passed as we have not
yet written any code to be executed by our feature file. The code to be executed
is defined in what is known as steps. Indeed, the output from Lettuce is trying
to be helpful and provide you with the outline for the steps above for you to
fill in with the Python code to be executed. You should think of each line in
the scenario as an instruction for Lettuce to execute, and the steps are what
Lettuce will match with to execute the correct code.</p>

<h3>Define Your Steps</h3>

<p>Underneath the feature file are the steps, which are essentially just Python
code and regular expressions to allow Lettuce to match each line in the feature
file to its step which is to be executed. To begin with, open up the <code>steps.py</code>
file and add the following imports from the Lettuce library:</p>

<div class="highlight highlight-python"><pre><span class="kn">from</span> <span class="nn">lettuce</span> <span class="kn">import</span> <span class="n">step</span><span class="p">,</span> <span class="n">world</span><span class="p">,</span> <span class="n">before</span>
<span class="kn">from</span> <span class="nn">nose.tools</span> <span class="kn">import</span> <span class="n">assert_equals</span>
</pre></div>

<p>The key things to note here are the imports from Lettuce, which allow you to
define the steps and store values to be used across each step in the <a href="http://lettuce.it/reference/terrain.html#lettuce-world"><code>world</code></a>
object (more to follow).  Also, the imports from the nose tests library, which
allow nicer assertions to be made in your tests.</p>

<p>Now you will add a <code>@before.all</code> step (known in Lettuce as a <a href="http://lettuce.it/reference/terrain.html#lettuce-hooks">hook</a>,
which, as the name suggests, will execute some code before each scenario. You
will use this code block to create an instance of Flask's inbuilt test client,
which will allow you to make requests to your application as if you were a real
client. Add the following code to the <code>steps.py</code> file now (don't forget to add
the import statement towards the top of your file):</p>

<div class="highlight highlight-python"><pre><span class="kn">from</span> <span class="nn">app.application</span> <span class="kn">import</span> <span class="n">app</span>


<span class="nd">@before.all</span>
<span class="k">def</span> <span class="nf">before_all</span><span class="p">():</span>
    <span class="n">world</span><span class="o">.</span><span class="n">app</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span>
</pre></div>

<p>With the test client in place, let's now define the first step from our
scenario, which is the line <code>Given some users are in the system</code>:</p>

<div class="highlight highlight-python"><pre><span class="kn">from</span> <span class="nn">app.views</span> <span class="kn">import</span> <span class="n">USERS</span>


<span class="nd">@step</span><span class="p">(</span><span class="s">u'Given some users are in the system'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">given_some_users_are_in_the_system</span><span class="p">(</span><span class="n">step</span><span class="p">):</span>
    <span class="n">USERS</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">'david01'</span><span class="p">:</span> <span class="p">{</span><span class="s">'name'</span><span class="p">:</span> <span class="s">'David Sale'</span><span class="p">}})</span>
</pre></div>

<p>The step adds some test data to the in memory <a href="https://docs.python.org/2/tutorial/datastructures.html#dictionaries">dictionary</a>,
which, for the purposes of this tutorial application, acts like our database in
a real system. You will notice the step is importing some code from our
application, which you will need to add now. <code>USERS</code> is an in-memory data store,
which, for the purposes of this tutorial, takes the place of the database which
would likely be used in a real application. Let's add the <code>USERS</code> code to the
<code>views.py</code> file now:</p>



<p>With this in place, you can now define the next step, which will make the call
to our application to retrieve a user's details and store the response in the
<code>world</code> object provided by Lettuce. This object allows us to save variables,
which we can then access across different steps, which otherwise would not
really be possible, or would lead to messy code. Add the following code to
<code>steps.py</code>:</p>

<div class="highlight highlight-python"><pre><span class="nd">@step</span><span class="p">(</span><span class="s">u'When I retrieve the customer </span><span class="se">\'</span><span class="s">(.*)</span><span class="se">\'</span><span class="s">'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">when_i_retrieve_the_customer_group1</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
    <span class="n">world</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'/user/{}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">username</span><span class="p">))</span>
</pre></div>

<p>In this step definition, notice how a capture group is used in the regular
expression allowing us to pass in variables to the step.  This allows for the
reuse of steps talked about earlier in the tutorial and gives you a great deal
of power and flexibility in your behaviour tests. When you provide a capture
group in the regular expression, Lettuce will automatically pass it through to
the method as an argument, which you can see in this step is named <code>username</code>.
You can of course have many variables in your step definition as required.</p>

<p>Next, you will add your first assertion step, which will check the status code
of the response from your application. Add this code to your <code>steps.py</code> file:</p>

<div class="highlight highlight-python"><pre><span class="nd">@step</span><span class="p">(</span><span class="s">u'Then I should get a </span><span class="se">\'</span><span class="s">(.*)</span><span class="se">\'</span><span class="s"> response'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">then_i_should_get_a_group1_response_group2</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">expected_status_code</span><span class="p">):</span>
    <span class="n">assert_equals</span><span class="p">(</span><span class="n">world</span><span class="o">.</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">expected_status_code</span><span class="p">))</span>
</pre></div>

<p>Here you make use of the assertion imported from the nosetests library
<code>assert_equals</code>, which takes two arguments and checks if they are equal to each
other. In this step, you again make use of a capture group to put the expected
status code in a variable. In this case, the variable should be an integer, so
we convert the type before making the comparison to the status code returned by
your application.</p>

<p>Finally, you need a step to check the data returned from your application was as
expected. This step definition is also a good example of how Lettuce supports
the passing in of a table of data to a step definition, which in this case is
ideal, as the data may grow quite large and the table helps the readability of
what is expected. Add the final step to the <code>steps.py</code> file:</p>

<div class="highlight highlight-python"><pre><span class="nd">@step</span><span class="p">(</span><span class="s">u'And the following user details are returned:'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">and_the_following_user_details</span><span class="p">(</span><span class="n">step</span><span class="p">):</span>
    <span class="n">assert_equals</span><span class="p">(</span><span class="n">step</span><span class="o">.</span><span class="n">hashes</span><span class="p">,</span> <span class="p">[</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">world</span><span class="o">.</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)])</span>
</pre></div>

<p>In this step you can see that when you pass in a data table, it can be accessed
from the <code>step</code> object under the name <code>hashes</code>. This is essentially a list of
dictionaries for each row of the table you passed in. In our application, it
will return a <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> string which is just
the dictionary of the key <code>name</code> to the user's name. Therefore, the assertion
just loads the string returned form our application into a Python dictionary,
and then we wrap it in a list so that it is equal to our expectation.</p>

<h3>Executing the Scenario</h3>

<p>With all your steps in place now, describing the expected functionality of your
application, you can now execute the test and see that it fails. As before,
execute the following command in a command prompt of your choice:</p>



<p>As expected the tests should fail with the following output:</p>

<div class="highlight highlight-bash"><pre><span class="nv">$ </span>lettuce <span class="nb">test</span>/features/

Feature: Handle storing, retrieving and deleting customer details <span class="c"># test/features/user.feature:1</span>

  Scenario: Retrieve a customers details                          <span class="c"># test/features/user.feature:3</span>
    Given some users are in the system                            <span class="c"># test/features/steps.py:17</span>
    When I retrieve the customer <span class="s1">'david01'</span>                        <span class="c"># test/features/steps.py:22</span>
    Then I should get a <span class="s1">'200'</span> response                            <span class="c"># test/features/steps.py:27</span>
    Traceback <span class="o">(</span>most recent call last<span class="o">)</span>:
        <span class="o">[</span> SNIPPET REMOVED FOR READABILITY <span class="o">]</span>
        raise self.failureException<span class="o">(</span>msg<span class="o">)</span>
    AssertionError: <span class="m">404</span> !<span class="o">=</span> 200
    And the following user details are returned:                  <span class="c"># test/features/steps.py:32</span>
      <span class="p">|</span> name       <span class="p">|</span>
      <span class="p">|</span> David Sale <span class="p">|</span>

<span class="m">1</span> feature <span class="o">(</span><span class="m">0</span> passed<span class="o">)</span>
<span class="m">1</span> scenario <span class="o">(</span><span class="m">0</span> passed<span class="o">)</span>
<span class="m">4</span> steps <span class="o">(</span><span class="m">1</span> failed, <span class="m">1</span> skipped, <span class="m">2</span> passed<span class="o">)</span>

List of failed scenarios:
  Scenario: Retrieve a customers details                          <span class="c"># test/features/user.feature:3</span>
</pre></div>

<p>As you can see, our application is currently returning a <code>404 Not Found</code>
response, as you have not yet defined the URL <code>/user/&lt;username&gt;</code> that the test
is trying to access. You can go ahead and add the code now to get the test
passing, and deliver the requirement you have outlined in your behaviour test.
Add the following code to <code>views.py</code>:</p>

<div class="highlight highlight-python"><pre><span class="n">GET</span> <span class="o">=</span> <span class="s">'GET'</span>


<span class="nd">@app.route</span><span class="p">(</span><span class="s">"/user/&lt;username&gt;"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="n">GET</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">access_users</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="n">GET</span><span class="p">:</span>
        <span class="n">user_details</span> <span class="o">=</span> <span class="n">USERS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">username</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">user_details</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">user_details</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="mi">404</span><span class="p">)</span>
</pre></div>

<p>The code first registers the new URL within your Flask application of
<code>/user/&lt;username&gt;</code> (the angled brackets indicate to Flask to capture anything
after the slash into a variable named <code>username</code>). You then define the method
that handles requests to that URL and state that only <code>GET</code> requests can be made
to this URL. You then check that the request received is indeed a <code>GET</code> and, if
it is, try to look up the details of the <code>username</code> provided from the <code>USERS</code>
data store. If the user's details are found, you return a 200 response, and the
user's details as a JSON response, otherwise a 404 Not Found response is
returned.</p>

<p>If you execute your tests from the command line once again, you will see they
are now all passing:</p>

<div class="highlight highlight-bash"><pre><span class="nv">$ </span>lettuce <span class="nb">test</span>/features/

Feature: Handle storing, retrieving and deleting customer details <span class="c"># test/features/user.feature:1</span>

  Scenario: Retrieve a customers details                          <span class="c"># test/features/user.feature:3</span>
    Given some users are in the system                            <span class="c"># test/features/steps.py:17</span>
    When I retrieve the customer <span class="s1">'david01'</span>                        <span class="c"># test/features/steps.py:22</span>
    Then I should get a <span class="s1">'200'</span> response                            <span class="c"># test/features/steps.py:27</span>
    And the following user details are returned:                  <span class="c"># test/features/steps.py:32</span>
      <span class="p">|</span> name       <span class="p">|</span>
      <span class="p">|</span> David Sale <span class="p">|</span>

<span class="m">1</span> feature <span class="o">(</span><span class="m">1</span> passed<span class="o">)</span>
<span class="m">1</span> scenario <span class="o">(</span><span class="m">1</span> passed<span class="o">)</span>
<span class="m">4</span> steps <span class="o">(</span><span class="m">4</span> passed<span class="o">)</span>
</pre></div>

<p>You have now delivered the functionality described in your behaviour test, and
can move onto writing the next scenario and making that pass. Clearly, this
process is an iterative cycle, which you can follow daily under your application
is delivered in its entirety.</p>

<h3>Additional Tasks</h3>

<p>If you enjoyed following this tutorial, why not extend the code you have now by
behaviour-driven development testing the following additional requirements:</p>

<ul>
<li>Support POST operations to add a new user's details to the USERS data store.</li>
<li>Support PUT operations to update a user's details from the USERS data store.</li>
<li>Support DELETE operations to remove a user's details from the USERS data store.</li>
</ul>

<p>You should be able to reuse or tweak the currently defined steps to test the
above functionality with minimal changes.</p>

<h2>Conclusion</h2>

<p>Behaviour-Driven Development is an excellent process to follow, whether you are
a solo developer working on a small project, or a developer working on a large
enterprise application. The process ensures your code meets the requirements you
set out up front, providing a formal pause for thought before you begin
developing the features you set out to deliver. BDD has the added benefit of
providing "living" documentation for your code that is, by its very nature, kept
up to date as you maintain the tests and deliver new functionality.</p>

<p>By following this tutorial, you have hopefully picked up the core skills
required to write behaviour tests of this style, execute the tests and deliver
the code required to make them pass.</p>
            </section>

        </div></body></html>