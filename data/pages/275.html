<html><body><div><div class="ibm-col-1-1">

<h2 id="N1004B">Введение</h2><p>Среда Python является самодостаточной языковой системой и технологией для разработки программных 
проектов. Механизм для расширения функциональных возможностей языка реализуется через технику модулей 
и пакетов, являющуюся фундаментальным компонентом архитектуры Python.</p><p>Тем не менее, стоит отметить, что многие из модулей, известные в Python как стандартные, на самом деле 
реализованы на языке C. Поэтому возникает интересная возможность реализовывать собственные целевые 
модули Python на C или C++. Хотя мотивы для подобного решения могут быть самыми разными, но стоит 
перечислить несколько ключевых:</p><ul class="ibm-bullet-list"><li>
эффективность реализации ресурсоёмких алгоритмов и вычислительных процедур на C, так как за счёт 
компилирующей природы этого языка скорость выполнения таких реализаций может быть в 40 (а в отдельных 
случаях и в 100) раз быстрее, чем на Python;
</li><li>
предоставить Python-приложениям доступ к различным аппаратно или системно-зависимым сущностям (аудио, 
аппаратно-зависимые счётчики и т.д.);
</li><li>
простой способ реализовать интерфейс к множеству целевых библиотек открытых проектов на C для 
использования их из Python-приложений;
</li></ul><p>Далеко не последнюю роль в привлекательности таких смешанных языковых реализаций играет и 
<strong>простота</strong> построения интерфейса из C в Python, как будет показано в данной статье.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N1005F">Альтернативы</h2><p>Существуют (разрабатываются или находятся в разной степени готовности к эксплуатации) несколько 
<strong>альтернативных</strong> способов реализации интерфейса из C в Python. Каждый из них имеет свои 
особенности, преимущества и недостатки, связанные с конкретными требованиями к ситуации. Ниже мы 
перечислим только <strong>некоторые</strong> из них, которые будут подробно рассмотрены в этой и 
последующей статьях:</p><ul class="ibm-bullet-list"><li>
модуль <strong><code>ctypes</code></strong> из стандартной библиотеки модулей Python 
(например,   <strong><code>/usr/lib/python2.7/ctypes/*</code></strong> - версия 2.7 здесь и далее 
показана совершенно условно, у вас она может отличаться);
</li><li>
ручное написание интерфейса модуля;
</li><li>
пакет <strong><code>distutils</code></strong> из стандартной библиотеки Python;
</li><li>
библиотека <strong><code>Boost.Python</code></strong>;
</li><li>
проект Cython;
</li><li>
проект SWIG;
</li></ul><p>В случае применения любого инструмента, конечный результат будет выглядеть как динамически 
связываемая <strong>библиотека</strong> (DLL — <strong><code>.so</code></strong> в Linux, 
<strong><code>.dll</code></strong> в Windows), функции которой можно будет вызывать из кода 
Python.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N10095">Модуль ctypes</h2><p>Модуль <strong><code>ctypes</code></strong> присутствует в стандартной поставке Python. Это 
самый простой способ с точки зрения написания кода и сборки, не требующий никаких дополнительных 
инструментов. Но это и самый опасный способ, так как на стыке Python/C отсутствует не только какой-либо 
контроль правильности соответствия типов ожидаемых параметров, но даже просто элементарный контроль их 
количества!</p><p>Для примера создадим несколько произвольных С-функций с самыми разнообразными наборами 
предполагаемых параметров и возвращаемых значений (см. файл <strong>call.c</strong> в архиве 
<strong>python_c_interaction.tgz</strong> в разделе "Материалы для скачивания"):</p><h5 id="listing1">Листинг 1. Тестовые функции C</h5><div class="codesection"><pre class="displaycode">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;
#include &lt;wchar.h&gt;

// <strong>c_double fun1( c_short )</strong>
double fun1( short i ) {
   printf( "получен параметр = %d\n", i );
   return (double)i;
}

// <strong>c_void_p fun2( c_char_p )</strong>
const char* fun2( const char* s ) {
   printf( "локализация операционной системы: %s\n",
           setlocale( LC_ALL, "" ) );      // <strong>по умолчанию, из установок системы</strong>
   int nsym = 0;
   const char *p = s;
   while( 1 ) {
      int n = mblen( p, MB_CUR_MAX );
      if( 0 == n ) break;
      nsym++;
      p += n;
   };
   printf( "получен параметр [ mbchar* ] :
           \"%s\"; длина: в байтах = %d, в символах = %d\n", s, strlen( s ), nsym );
   static const char* ret = "возвращаемая строка";
   return ret;
}

// <strong>c_void_p fun3( c_float, c_long, c_char_p )</strong>
void* fun3( float f, long l, char* s ) {   
   printf( "вызов функции 3-х переменных: \"float\"=%f, \"long\"=%ld,
            \"char*\"=\"%s\"\n", f, l, s );
   return (void*)s;
}</pre></div><p>Выполним сборку динамической библиотеки следующей командой:</p><div class="codesection"><pre class="displaycode"><strong>$ gcc -shared -o call.so -fPIC call.c</strong></pre></div><p>Для демонстрации вызовов подготовленных функций из кода Python подготовим тестовую программу, 
представленную в листинге 2 (см. файл <strong>test.py</strong> из архива <strong>python_c_interaction.tgz</strong>):</p><h5 id="N100CB">Листинг 2. Тестирование вызовов C-функций</h5><div class="codesection"><pre class="displaycode">#!/usr/bin/python
# -*- coding: utf-8 -*-
import ctypes

lib = ctypes.CDLL( './call.so' )

print '-----------------------------------------------------'
# === double fun1( short ) ===
# pfun = ctypes.CDLL( './call.so' ).fun1
pfun = lib.fun1
pfun.restype = ctypes.c_double
pfun.argtypes = ( ctypes.c_short, )
x = pfun( 3 )
print 'возвращено значение %f' % x
print '-----------------------------------------------------'

# === const char* fun2( const char* ) ===
#pfun = ctypes.CDLL( './call.so' ).fun2
pfun = lib.fun2
pfun.restype = ctypes.c_char_p
pfun.argtypes = ( ctypes.c_char_p, )
x = pfun( "строка вызова" )
print 'возвращено значение : "%s"' % x
print '-----------------------------------------------------'

# === void* fun3( float, long, char* ) ===
pfun = lib.fun3
pfun.restype = ctypes.c_void_p
pfun.argtypes = ( ctypes.c_float, ctypes.c_long, ctypes.c_char_p )
s = "строка"
x = pfun( 3.1415, -12345, s )
print 'возвращено значение\t= %x' % x
print 'id( строка-параметр )\t= %x' % id( s )
print '-----------------------------------------------------'</pre></div><p><strong>Примечание</strong>. В примере из листинга 2 используется синтаксис Python 2, так как в Python 3, 
где строки представляются исключительно в UTF-8, следует использовать типы 
<strong><code>wchar_t</code></strong> в C коде, и, соответственно, 
<strong><code>c_wchar_p</code></strong> в Python коде. Декодирование строк для версий 2 и 3 
выполняется различными способами. Кроме того, в Python 3 присутствует более строгий контроль соответствия 
типов параметров, передаваемых функциям.</p><p>Проверим работоспособность созданного межязыкового интерфейса:</p><div class="codesection"><pre class="displaycode">$ python test.py
-----------------------------------------------------
получен параметр = 3
возвращено значение 3.000000
-----------------------------------------------------
локализация операционной системы: ru_RU.UTF-8
получен параметр [ mbchar* ] : "строка вызова"; длина: в байтах = 25, в символах = 13
возвращено значение : "возвращаемая строка"
-----------------------------------------------------
вызов функции 3-х переменных: "float"=3,141500, "long"=-12345, "char*"="строка"
возвращено значение     = b76b15ac
id( строка-параметр )   = b76b1598
-----------------------------------------------------</pre></div><p>В листинге 1 был показан условный пример, демонстрирующий работу с самыми разными вариантами 
параметров и возвращаемых значений. Теперь мы попробуем решить более  реалистичную задачу по 
считыванию 64-х разрядного счётчика периодов частоты процессора, реализованного, начиная с процессора 
Pentium-II, и возвращаемого ассемблерной командой <strong><code>RDTSC</code></strong>. 
Такая функция позволит замерять временные интервалы в ходе выполнения программ с <strong>наносекундным</strong> 
разрешением. В листинге 3 приведён пример такой функции на языке С (см. файл 
<strong>rdtsc.c</strong> в архиве <strong>python_c_interaction.tgz</strong>):</p><h5 id="N100F3">Листинг 3. Функция rdtsc()</h5><div class="codesection"><pre class="displaycode">unsigned long long rdtsc( void ) {          // ctypes.c_ulonglong rdtsc( void )
   unsigned long long int x;
   asm volatile ( "rdtsc" : "=A" (x) );
// вариант для старых версий GCC – просто указываем численный код команды:
// asm volatile ( ".byte 0x0f, 0x31" : "=A" (x) );
   return x;
}</pre></div><p>Реализация функции <strong><code>rdtsc()</code></strong> использует такое расширение 
компилятора GCC как инлайновые ассемблерные вставки. Соберём библиотеку <strong>rdtsc.so</strong> 
с помощью следующей команды:</p><div class="codesection"><pre class="displaycode"><strong>$ gcc -shared -o call.so -fPIC call.c</strong></pre></div><p>В листинге 4 представлено тестовое приложение, использующее из кода Python функцию, реализованную 
на C (см. файл <strong>rdtest.py</strong> в архиве <strong>python_c_interaction.tgz</strong>):</p><h5 id="N10110">Листинг 4. Тестовое приложение для rdtsc()</h5><div class="codesection"><pre class="displaycode">#!/usr/bin/python
# -*- coding: utf-8 -*-

import ctypes
lib = ctypes.CDLL( './rdtsc.so' )
pfun = lib.rdtsc
pfun.argtypes = () # ctypes.c_short, )
pfun.restype = ctypes.c_ulonglong

for i in 1, 2, 3 :
    print( 'RDTSC = {}'.format( pfun() ) )</pre></div><p>Выполнив это приложение, мы получим число периодов частоты процессора с момента последней 
перезагрузки:</p><div class="codesection"><pre class="displaycode"><strong>$ python rdtest.py</strong>
RDTSC = 81688400845550
RDTSC = 81688400995990
RDTSC = 81688401103470</pre></div><p>Этот же код можно исполнить и в Python 3:</p><div class="codesection"><pre class="displaycode"><strong>$ python3 rdtest.py</strong>
RDTSC = 81694859707300
RDTSC = 81694859845670
RDTSC = 81694859918650</pre></div><p>Отдельно остановимся на важнейшей особенности этого способа, так как мы не создаём на языке C модуля 
для последующего экспорта (как это будет делаться во всех других способах), а, напротив, используем 
искусственный интерфейс к функциям C из языка Python.</p><p>Даже из простых представленных примеров видно, что, при использовании 
<strong><code>ctypes</code></strong>, код для вызова С-функций из Python 
становится громоздким и малопонятным. Тем не менее, это <strong>простейший</strong> способ для 
взаимодействия с C-библиотеками из Python-приложений. Отличительной особенностью 
<strong><code>ctypes</code></strong> является простота реализации вызовов из уже  
<strong>существующих</strong> разделяемых системных библиотек, особенно когда требуется обеспечить 
вызов одной или нескольких функций из такой библиотеки. Например, вот как могут выглядеть обращения к 
основным стандартным библиотекам в разных операционных системах. Мы не будем обсуждать особенности 
правил выполнения вызовов, которые подробно описаны в документации, перечисленной в разделе "Ресурсы":</p><ul class="ibm-bullet-list"><li>
для ОС Windows (расширение <code>.dll</code> будет добавлено автоматически):

<div class="codesection"><pre class="displaycode">from ctypes import *
libs = windll.kernel32 // <strong>функции системной библиотеки kernel32.dll</strong>
                       // <strong>используют соглашение о связях stdcall</strong>
print( libs.GetModuleHandleA(None) )
...
libc = cdll.msvcrt     // <strong>функции стандартной библиотеки msvcrt.dll</strong>
                       // <strong>используют соглашение о связях cdecl.dll</strong>
print( libc.time( None ) )</pre></div></li><li>
для ОС Linux:

<div class="codesection"><pre class="displaycode">from ctypes import *
libc = ctypes.CDLL( 'libc.so.6' )
print( libc.time( None ) )</pre></div></li></ul><p>Здесь же проявляется ещё одна неприятная особенность использования 
<strong><code>ctypes</code></strong>, то что синтаксис записи связующего кода различается 
для разных операционных систем (что в общем  не свойственно Python), а это сильно затрудняет создание 
мульти-платформенного кода.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N10159">Создание интерфейса модуля</h2><p>Это второй из названных ранее альтернативных способов использования C-кода из Python. Если в 
предыдущем случае мы не создавали отдельный модуль (а непосредственно использовали библиотеку), то 
теперь мы сможем его создать, полностью прописав на языке C создание интерфейса к такому модулю. Наш 
модуль будет также реализовывать всё ту же функцию <strong><code>rdtsc()</code></strong>, 
опрашивающую счётчик тактов процессора. Используем тот же файл <strong>rdtsc.c</strong> с реализацией 
функции, но дополним его соответствующим файлом с общими определениями - <strong>rdtsc.h</strong>, 
который необходим только для организации взаимодействия.</p><div class="codesection"><pre class="displaycode">extern unsigned long long rdtsc( void );</pre></div><p>Теперь можно вручную (листинг 5) прописать интерфейс для нашего будущего модуля 
<strong>rdtsc</strong> в виде файла <strong>rdtsc_wrap.c</strong> (код можно найти в архиве 
<strong>python_c_interaction.tgz</strong>):</p><h5 id="N1017A">Листинг 5. Интерфейс модуля</h5><div class="codesection"><pre class="displaycode">#include &lt;Python.h&gt;
#include "rdtsc.h"

PyObject* rdtsc_wrap( PyObject* self, PyObject* args ) {
   if( self != NULL ) return NULL;
   return Py_BuildValue( "L", rdtsc() );
}

static PyMethodDef rdtscmethods[] = {      // <strong>таблица описания методов модуля</strong>
   { "rdtsc", rdtsc_wrap, METH_NOARGS },
   { NULL, NULL }
};

void initrdtsc() {                         // <strong>функция инициализации модуля</strong>
   Py_InitModule( "rdtsc", rdtscmethods );
}</pre></div><p>В коде интерфейса должны присутствовать два обязательных компонента:</p><ul class="ibm-bullet-list"><li>
таблица описания всех методов модуля;
</li><li>
функция инициализации модуля (которая практически всегда одинакова, за исключением своего имени);
</li></ul><p>Правило для Makefile, ответственное за сборку DLL библиотеки, представляющей созданный Python-модуль 
будет выглядеть так как показано ниже:</p><div class="codesection"><pre class="displaycode">        gcc -c -fpic rdtsc_wrap.c rdtsc.c -I/usr/include/python2.7
        ld -shared rdtsc_wrap.o rdtsc.o -lc -o rdtscmodule.so</pre></div><p>Теперь можно будет осуществить вызов функции <strong><code>rdtsc()</code></strong> 
из кода приложения на Python, представленного в листинге 6 (файл <strong>ptest.py</strong> из архива 
<strong>python_c_interaction.tgz</strong>):</p><h5 id="N101A0">Листинг 6. Вызов C-функции c помощью интерфейсного модуля</h5><div class="codesection"><pre class="displaycode">#!/usr/bin/python -O
# -*- coding: utf-8 -*-
from rdtsc import rdtsc
from calibr import calibr

counter = []
for i in range( 5 ):
    counter.append( rdtsc() )
print "счётчик процессорных циклов:\n", counter

arg = [ 0, 10, 100, 1000, 10000, 100000 ]
msg = "калибровка последовательных вызовов:"
for i in arg:
    s = " %s(%i)" % ( str( calibr( i ) ), i )
    msg = msg + s
print msg</pre></div><p>Попутно в модуле <strong><code>calibr</code></strong> была реализована функция 
<strong><code>calibr()</code></strong>, нужная при измерения очень малых интервалов. Пример 
этой функции показан в листинге 7 и файле <strong>calibr.py</strong> в архиве 
<strong>python_c_interaction.tgz</strong>.</p><h5 id="N101B7">Листинг 7. Функция калибровки</h5><div class="codesection"><pre class="displaycode">#!/usr/bin/python
# -*- coding: utf-8 -*-
from rdtsc import rdtsc

def calibr( args = 10 ):
    sum = 0L
    if int( args ) &lt;= 0: n = 10
    else: n = int( args )
    m = n
    while n &gt; 0 :
        cf = -( rdtsc() - rdtsc() )
        sum = sum + cf
        n = n - 1
    return sum / m
...
if __name__ == "__main__":
    arg = [ 2, 5, 10, 20, 50, 100 ]
    msg = "калибровка последовательных вызовов:"
    for i in arg:
        s = " %s(%i)" % ( str( calibr( i ) ), i )
        msg = msg + s
    print msg</pre></div><p>Эта функция определяет разность значений, полученных из двух последовательных вызовов 
    <strong><code>rdtsc()</code></strong>, непосредственно следующих друг за другом, и показывает 
    временные затраты (в тактах частоты процессора) на выполнение одиночного вызова самой функции 
    <strong><code>rdtsc()</code></strong>.</p><p>Чтобы исключить дисперсию из-за загруженности процессора в многозадачной системе это значение 
    усредняется по большому числу повторных измерений (при усреднении по 10 и более замеров результат 
    можно считать стабильным).</p><p>Теперь можно проверить сценарий из листинга 6:</p><div class="codesection"><pre class="displaycode"><strong>$ python -O ptest.py</strong>
счётчик процессорных циклов:
[32794250939400L, 32794250943940L, 32794250945180L, 32794250946280L, 32794250947320L]
калибровка последовательных вызовов: 520(0) 478(10) 445(100) 441(1000) ... 422(100000)</pre></div><p>Для сравнения воспользуемся аналогичной тестовой программой, написанной на языке C (файл 
<strong>ctest.c</strong> из архива <strong>python_c_interaction.tgz</strong>):</p><h5 id="N101DA">Листинг 8. Эталонная программа с аналогичной функциональностью, написанная на C</h5><div class="codesection"><pre class="displaycode">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include "rdtsc.h"

#define NUMB 10
static unsigned calibr( int rep ) {
   uint32_t n, m, sum = 0;
   n = m = ( rep &lt;= 0 ? NUMB : rep );
   while( n-- ) {
      uint64_t cf, cs;
      cf = rdtsc();
      cs = rdtsc();
      sum += (uint32_t)( cs - cf );
   }
   return sum / m;
}

int main( int argc, char **argv, char **envp ) {
   printf( "число процессорных тактов = %llu\n", rdtsc() );
   printf( "калибровка последовательных вызовов:" );
   printf( " %lu(0)", calibr( 0 ) );
   int n;
   for( n = 10; n &lt;= 100000; n*=10 )
      printf( " %lu(%d)", calibr( n ), n );
   printf( "\n");
   exit( EXIT_SUCCESS );
};</pre></div><p>Проверим работу этой реализации (тесты выполнялись последовательно друг за другом, поэтому значения 
счётчика процессорных тактов имеют сходный порядок):</p><div class="codesection"><pre class="displaycode"><strong>$ ./ctest</strong>
число процессорных тактов = 32794140948560
калибровка последовательных вызовов: 193(0) 191(10) 191(100) 191(1000) ... 142(100000)</pre></div><p>Имея два различных варианта реализации (Python и C), мы можем сравнить время выполнения функции 
<strong><code>rdtsc()</code></strong> в Python – порядка 440 тактов с реализацией на C – около 
190 тактов. Разница всего в 2.3 раза — это очень неплохой результат для интерпретирующего языка.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N101ED">Заключение</h2><p>В этой статье были описаны 2 возможных альтернативных способа использования C-кода из программы Python.</p><p>В качестве второго способа описана общая схема самостоятельного написания интерфейса модуля, для его 
последующего использования в Python. Эта техника является основой для всех остальных способов, 
описываемых в последующих статьях. И, даже несмотря на некоторую громоздкость, описываемый подход к 
ручному написанию интерфейсов модулей Python вполне применим и эффективен, особенно для не слишком 
объёмных модулей.</p><p>В следующих статьях мы познакомимся ещё с некоторыми альтернативными способами интеграции С и 
Python-приложений, которые в некоторых смыслах могут считаться более продвинутыми.</p>
<p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="download">Загрузка</h2>

</div>
</div></body></html>