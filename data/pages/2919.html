<html><body><div><article id="HuNzYTqDxQxYE43A1VB" class="post  historical">
	<time datetime="2015-01-24" class="article_time">January 24, 2015</time>
  
	<p>Function decorators enable the addition of new functionality to a function without altering the function’s original functionality. Prior to reading this post, it is important that you have read and understood the <a href="http://intermediatepythonista.com/the-function" rel="nofollow">first installment</a> on python functions. The major take away from that tutorial is that python functions are first class objects; a result of this is that:</p>

<ol>
<li>Python functions can be passed as arguments to other functions.</li>
<li>Python functions can be returned from other function calls.</li>
<li>Python functions can be defined inside other functions resulting in closures.</li>
</ol>

<p>The above listed properties of python functions provide the foundation needed to explain <strong><em>function decorators</em></strong>. Put simply, function decorators are <strong><em>“wrappers” that let you execute code before and after the function they decorate without modifying the function itself</em></strong>. The structure of this tutorial follows an excellent <a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/1594484#1594484" rel="nofollow">stack overflow</a> answer to a question on explaining python decorators.</p>
<h2 id="function-decorators_2">
<a class="head_anchor" href="#function-decorators_2" rel="nofollow"> </a>Function Decorators</h2>
<p>Function decorators are not unique to python so to explain them, we ignore python function decorator syntax for the moment and instead focus on the essence of function decorators. To understand what decorators do, we implement a very trivial function that is decorated with another trivial function that logs calls to the decorated function. The function decoration is achieved using function composition as shown below (follow the comments):</p>

<pre><code class="prettyprint lang-python">
import datetime

# decorator expects another function as argument
def logger(func_to_decorate):

    # A wrapper function is defined on the fly
    def func_wrapper():

        # add any pre original function execution functionality 
        print("Calling function: {} at {}".format(func_to_decorate.__name__, datetime.datetime.now()))

        # execute original function
        func_to_decorate()

        # add any post original function execution functionality
        print("Finished calling : {}".format(func_to_decorate.__name__))

    # return the wrapper function defined on the fly. Body of the 
    # wrapper function has not been executed yet but a closure 
    # over the func_to_decorate has been created.
    return func_wrapper

def print_full_name():
    print("My name is John Doe")

&gt;&gt;&gt;decorated_func = logger(print_full_name)
&gt;&gt;&gt;decorated_func
# the returned value, decorated_func, is a reference to a func_wrapper
&lt;function func_wrapper at 0x101ed2578&gt;
&gt;&gt;&gt;decorated_func()
# decorated_func call output
Calling function: print_full_name at 2015-01-24 13:48:05.261413
# the original functionality is preserved
My name is John Doe
Finished calling : print_full_name
</code></pre>

<p>In the trivial example defined above, the decorator adds a new feature, printing some information before and after the original function call, to the original function without altering it. The decorator, <code class="prettyprint">logger</code> takes a function to be decorated, <code class="prettyprint">print_full_name</code> and returns a function, <code class="prettyprint">func_wrapper</code> that calls the decorated function, <code class="prettyprint">print_full_name</code>, when it is executed. The function returned, <code class="prettyprint">func_wrapper</code> is closed over the reference to the decorated function, <code class="prettyprint">print_full_name</code> and thus can invoke the decorated function when it is executing. In the above, calling <code class="prettyprint">decorated_func</code> results in  <code class="prettyprint">print_full_name</code> being executed in addition to some other code snippet that implement new functionality. This ability to add new functionality to a function without modifying the original function is the essence of function decorators. Once this concept is understood, the concept of decorators is understood.</p>
<h2 id="python-decorators_2">
<a class="head_anchor" href="#python-decorators_2" rel="nofollow"> </a>Python Decorators</h2>
<p>Now that we hopefully understand the essence of function decorators, we move on to deconstructing python constructs that enable us to define decorators more easily. The previous section describes the essence of decorators but having to use decorators via function compositions as described is cumbersome. Python introduces the <code class="prettyprint">@</code> symbol for decorating functions. Decorating a function using python decorator syntax is achieved as shown below:</p>

<pre><code class="prettyprint lang-python">@decorator
def a_stand_alone_function():
    pass
</code></pre>

<p>Calling <code class="prettyprint">stand_alone_function</code> now is equivalent to calling <code class="prettyprint">decorated_func</code> function from the previous section but we no longer have to define the intermediate <code class="prettyprint">decorated_func</code>.</p>

<p>Note that decorators can be applied not just to python functions but also to python classes and class methods but we discuss class and method decorators in a later tutorial.</p>

<p>It is important to understand what the <code class="prettyprint">@</code>  symbol does with respect to decorators in python. The <code class="prettyprint">@decorator</code> line does not define a python decorator rather one can think of it as syntactic sugar for <strong>decorating a function</strong>. <br/>
I like to define <strong>decorating a function</strong> as the process of applying an existing decorator to a function.  The <strong><em>decorator</em></strong> is the actual function, <code class="prettyprint">decorator</code> that adds the new functionality to the original function. According to <a href="https://www.python.org/dev/peps/pep-0318/#why" rel="nofollow">PEP 318</a>, the following decorator snippet </p>

<pre><code class="prettyprint lang-python">@dec2
@dec1
def func(arg1, arg2, ...):
    pass
</code></pre>

<p>is equivalent to </p>

<pre><code class="prettyprint lang-python">def func(arg1, arg2, ...):
    pass

func = dec2(dec1(func))
</code></pre>

<p>without the intermediate <code class="prettyprint">func</code> argument. In the above, <code class="prettyprint">@dec1</code> and <code class="prettyprint">@dec2</code> are the decorator invocations. Stop, think carefully and ensure you understand this. <code class="prettyprint">dec1</code> and <code class="prettyprint">dec2</code> are function object references and these are the actual decorators. These values can even be replaced by any <strong><em>function call or a value that when evaluated returns a function that takes another function</em></strong>.  What is of paramount importance is that the <em>name reference</em> following the <code class="prettyprint">@</code> symbol is a reference to a function object (for this tutorial we assume this should be a function object but in reality it should be a <strong><em>callable</em></strong> object) that takes a function as argument. Understanding this profound fact will help in understanding python decorators and more involved decorator topics such as decorators that take arguments.</p>
<h2 id="function-arguments-for-decorated-functions_2">
<a class="head_anchor" href="#function-arguments-for-decorated-functions_2" rel="nofollow"> </a>Function Arguments For Decorated Functions</h2>
<p>Arguments can be passed to  functions that are being decorated by simply passing this function into the function that wraps, <strong>i.e the inner function returned when the decorator is invoked</strong>, the decorated function. We illustrate this with an example below:</p>

<pre><code class="prettyprint lang-python">
import datetime

# decorator expects another function as argument
def logger(func_to_decorate):

    # A wrapper function is defined on the fly
    def func_wrapper(*args, **kwargs):

        # add any pre original function execution functionality 
        print("Calling function: {} at {}".format(func_to_decorate.__name__, datetime.datetime.now()))

        # execute original function
        func_to_decorate(*args, **kwargs)

        # add any post original function execution functionality
        print("Finished calling : {}".format(func_to_decorate.__name__))

    # return the wrapper function defined on the fly. Body of the 
    # wrapper function has not been executed yet but a closure over
    # the func_to_decorate has been created.
    return func_wrapper

@logger
def print_full_name(first_name, last_name):
    print("My name is {} {}".format(first_name, last_name))

print_full_name("John", "Doe")

Calling function: print_full_name at 2015-01-24 14:36:36.691557
My name is John Doe
Finished calling : print_full_name
</code></pre>

<p>Note how we use <code class="prettyprint">*args</code> and <code class="prettyprint">**kwargs</code> in defining the inner wrapper function; this is for the simple reason that we cannot know before hand what arguments are being passed to a function being decorated.</p>
<h2 id="decorator-function-with-function-arguments_2">
<a class="head_anchor" href="#decorator-function-with-function-arguments_2" rel="nofollow"> </a>Decorator Function with Function Arguments</h2>
<p>We can also pass arguments to the actual decorator function but this is more involved than the case of passing functions to decorated functions. We illustrate this with quite an example below:</p>

<pre><code class="prettyprint lang-python"># this function takes arguments and returns a function.
# the returned functions is our actual decorator
def decorator_maker_with_arguments(decorator_arg1):

    # this is our actual decorator that accepts a function

    def decorator(func_to_decorate):

        # wrapper function takes arguments for the decorated 
        # function
        def wrapped(function_arg1, function_arg2) :
            # add any pre original function execution 
            # functionality 
            print("Calling function: {} at {} with decorator arguments: {} and function arguments:{} {}".\
                format(func_to_decorate.__name__, datetime.datetime.now(), decorator_arg1, function_arg1, function_arg2))

            func_to_decorate(function_arg1, function_arg2)

            # add any post original function execution
            # functionality
            print("Finished calling : {}".format(func_to_decorate.__name__))

        return wrapped

    return decorator

@decorator_maker_with_arguments("Apollo 11 Landing")
def print_name(function_arg1, function_arg2):
   print ("My full name is -- {} {} --".format(function_arg1, function_arg2))

&gt;&gt;&gt; print_name("Tranquility base ", "To Houston")

Calling function: print_name at 2015-01-24 15:03:23.696982 with decorator arguments: Apollo 11 Landing and function arguments:Tranquility base  To Houston
My full name is -- Tranquility base  To Houston --
Finished calling : print_name
</code></pre>

<p>As mentioned previously, the key to understanding what is going on with this is to note that we can replace the reference value following the <code class="prettyprint">@</code> in a function decoration with any value that <strong><em>evaluates to a function object that takes another function as argument</em></strong>. In the above, the value returned by the function call, <code class="prettyprint">decorator_maker_with_arguments("Apollo 11 Landing")</code> , is the decorator. The call evaluates to a function, <code class="prettyprint">decorator</code> that accepts a function as argument.  Thus the decoration ’@decorator_maker_with_arguments(“Apollo 11 Landing”)’ is equivalent to <code class="prettyprint">@decorator</code> but with the decorator, <code class="prettyprint">decorator</code> , closed over the argument, <code class="prettyprint">Apollo 11 Landing</code> by the <code class="prettyprint">decorator_maker_with_arguments</code> function call.  Note that the arguments supplied to a decorator can not be dynamically changed at run time as they are executed on script import.</p>

<p>Using decorators involves swapping out one function for another. A result of this is that meta information such as docstrings in the swapped out function are lost when using a decorator with such function. This is illustrated below:</p>

<pre><code class="prettyprint lang-python">
import datetime

# decorator expects another function as argument
def logger(func_to_decorate):

    # A wrapper function is defined on the fly
    def func_wrapper():

        # add any pre original function execution functionality 
        print("Calling function: {} at {}".format(func_to_decorate.__name__, datetime.datetime.now()))

        # execute original function
        func_to_decorate()

        # add any post original function execution functionality
        print("Finished calling : {}".format(func_to_decorate.__name__))

    # return the wrapper function defined on the fly. Body of the 
    # wrapper function has not been executed yet but a closure 
    # over the func_to_decorate has been created.
    return func_wrapper

@logger
def print_full_name():
    """return john doe's full name"""
    print("My name is John Doe")

&gt;&gt;&gt; print(print_full_name.__doc__)
None
&gt;&gt;&gt; print(print_full_name.__name__)
func_wrapper
</code></pre>

<p>In the above example an attempt to print the documentation string returns <code class="prettyprint">None</code> because the decorator has swapped out the <code class="prettyprint">print_full_name</code> function with the <code class="prettyprint">func_wrapper</code> function that has no documentation string.<br/>
Even the function name now references the name of the wrapper function rathe than the actual function. This, most times, is not what we want when using decorators. To work around this python <code class="prettyprint">functools</code> module provides the <code class="prettyprint">wraps</code> function that also happens to be a decorator. This decorator is applied to the wrapper function and takes the function to be decorated as argument. The usage is illustrated below:</p>

<pre><code class="prettyprint lang-python">import datetime
from functools import wraps 

# decorator expects another function as argument
def logger(func_to_decorate):

    @wraps(func_to_decorate)
    # A wrapper function is defined on the fly
    def func_wrapper(*args, **kwargs):

        # add any pre original function execution functionality 
        print("Calling function: {} at {}".format(func_to_decorate.__name__, datetime.datetime.now()))

        # execute original function
        func_to_decorate(*args, **kwargs)

        # add any post original function execution functionality
        print("Finished calling : {}".format(func_to_decorate.__name__))

    # return the wrapper function defined on the fly. Body of the 
    # wrapper function has not been executed yet but a closure over
    # the func_to_decorate has been created.
    return func_wrapper

@logger
def print_full_name(first_name, last_name):
    """return john doe's full name"""
    print("My name is {} {}".format(first_name, last_name))

&gt;&gt;&gt; print(print_full_name.__doc__)
return john doe's full name
&gt;&gt;&gt;print(print_full_name.__name__)
print_full_name
</code></pre>
<h2 id="applications-of-decorators_2">
<a class="head_anchor" href="#applications-of-decorators_2" rel="nofollow"> </a>Applications of Decorators</h2>
<p>Decorators have a wide variety of applications in python and these can not all be covered in this article. Some examples of applications of decorators include:</p>

<ol>
<li>Memoization which is the caching of values to prevent recomputing such values if the computation is expensive; A memoization decorator can be used to decorate a function that performs the actual calculation and the added feature is that for a given argument if the result has been computed previously then the stored value is returned but if it has not then it is computed  and stored before returned to the caller. </li>
<li>In web applications, decorators can be used to protect end points that require authentication; an endpoint is protected with a decorator that checks that a user is authenticated when a request is made to the endpoint. Django a popular web application framework makes use of decorators for managing caching and views permissions. </li>
<li>Decorators can also provide a clean way for carrying out household tasks such as logging function calls, timing functions etc.</li>
</ol>

<p>The use of decorators is a very large playing field that is unique to different situations. The <a href="https://wiki.python.org/moin/PythonDecoratorLibrary" rel="nofollow">python decorator library</a> provides a wealth of use cases of python decorators. Browsing through this collection will provide insight into practical uses of python decorators.</p>
<h2 id="further-reading_2">
<a class="head_anchor" href="#further-reading_2" rel="nofollow"> </a>Further Reading</h2>
<p><a href="https://www.python.org/dev/peps/pep-0318/" rel="nofollow">PEP 318 - Decorators for Functions and Methods</a></p>

<p><a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/1594484#1594484" rel="nofollow">Stack Overflow</a></p>

  <figure class="postend kudo able clearfix" id="kudo_HuNzYTqDxQxYE43A1VB">
    <a href="#kudo">
      <p class="filling"> </p>
    </a>
    <p class="num">184</p>
    <p class="txt">Kudos</p>
  </figure>
  <figure class="side kudo able clearfix" id="kudo_side_HuNzYTqDxQxYE43A1VB">
    <a href="#kudo">
      <p class="filling"> </p>
    </a>
    <p class="num">184</p>
    <p class="txt">Kudos</p>
  </figure>
</article>

</div></body></html>