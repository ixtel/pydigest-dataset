<html><body><div><article class="post-content">
    <p>Many dynamic languages have a value denoting “absence”: <code>None</code> in Python, <code>undefined</code> in JavaScript, and <code>nil</code> in Lisp, Clojure, Ruby, and Lua. We can compare this to the <code>null</code> value of reference types in languages like C, Java, or Go. Or, we can compare it to the <code>None</code> value of option types in languages like ML, Haskell, Rust, or Swift. But these two comparisons have very different properties! Nullable references make it easy to write code with non-obvious bugs. Options fix this, by requiring you to check for <code>None</code> before using the value inside.</p>

<p>Which is <code>nil</code> in a dynamic language more akin to? Is <code>nil</code> more like nullable references, or like options? The answer depends on how APIs in your language <em>use</em> <code>nil</code>. In particular, it depends on whether these APIs <em>reliably distinguish success from failure</em>, which is in a sense what option types are all about.</p>

<p>Let me show you an example.</p>

<h3 id="a-simple-function">A simple function</h3>

<p>Consider the following specification:</p>

<div class="highlight"><pre><code>values_in(keys, dict) --&gt; values

Returns a list containing, for each key in `keys`, its
associated value in `dict`, dropping keys not in `dict`.
</code></pre></div>
<p>Let’s implement this in our favorite dynamic languages:</p>

<p><strong>Ruby</strong></p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">values_in</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">dict</span><span class="p">)</span>
  <span class="c1"># find associated values with .map and throw out nils</span>
  <span class="c1"># with .compact (nils indicate absent keys)</span>
  <span class="n">keys</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="o">|</span> <span class="n">dict</span><span class="p">[</span><span class="n">k</span><span class="p">]}.</span><span class="nf">compact</span>
<span class="k">end</span>
</code></pre></div>
<p><strong>JavaScript</strong> (objects as dicts, strings as keys)</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">values_in</span><span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">dict</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">keys</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">dict</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">})</span>
               <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="p">})</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Clojure</strong></p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">values-in</span><span class="w"> </span><span class="p">[</span><span class="nb">keys</span><span class="w"> </span><span class="n">dict</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="nb">complement</span><span class="w"> </span><span class="nb">nil?</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">dict</span><span class="w"> </span><span class="nb">keys</span><span class="p">)))</span><span class="w">
</span></code></pre></div>
<p><strong>Python</strong></p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">values_in</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">keys</span> <span class="k">if</span> <span class="nb">dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">]</span>
</code></pre></div>
<p><strong>You may notice that this code smells. Can you spot the bug?</strong></p>

<p>If <code>dict</code> maps a key in <code>keys</code> to <code>nil</code>/<code>undefined</code>/<code>None</code>, this value will be absent from the list returned by <code>values_in</code>! It will get discarded by <code>compact</code> in Ruby (or by the <code>filter</code> in JavaScript and Clojure, or by the <code>if</code> clause in our Python list comprehension).</p>

<p>Of course, we can fix this:</p>

<p><strong>Ruby</strong></p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">values_in</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">dict</span><span class="p">)</span>
  <span class="c1"># We filter out keys not in the dictionary first</span>
  <span class="n">keys</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">dict</span><span class="p">.</span><span class="nf">has_key?</span> <span class="n">x</span><span class="p">}.</span><span class="nf">map</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">dict</span><span class="p">[</span><span class="n">x</span><span class="p">]}</span>
<span class="k">end</span>
</code></pre></div>
<p><strong>JavaScript</strong></p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">values_in</span><span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">dict</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">keys</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="k">in</span> <span class="nx">dict</span> <span class="p">})</span>
               <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">dict</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Clojure</strong></p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">values-in</span><span class="w"> </span><span class="p">[</span><span class="nb">keys</span><span class="w"> </span><span class="n">dict</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">dict</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">dict</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="nb">keys</span><span class="p">)))</span><span class="w">
</span></code></pre></div>
<p><strong>Python</strong></p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">values_in</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">keys</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">]</span>
</code></pre></div>
<p>The correct way is to filter out absent keys <em>before</em> we look them up in the dictionary. The tempting-but-wrong way is to look up <em>all</em> the keys and filter out failures (indicated by <code>nil</code>) afterward. But this conflates the absence of a key with the presence of a key which is mapped to <code>nil</code>. We have failed to distinguish success from failure!</p>

<h2 id="null--and-option-like-interfaces">Null- and option-like interfaces</h2>

<p>But wait! In Python, dictionary lookup <code>dict[key]</code> doesn’t return <code>None</code> (Python’s <code>nil</code>) on failure: it raises a <code>KeyError</code>! Comparing the two Python solutions, the correct one is actually <em>simpler</em>; the wrong one has to carefully avoid an exception using <code>dict.get(key)</code>, which returns <code>None</code> on failure.</p>

<p>Dictionary lookup is <em>null-like</em> in Ruby, JavaScript, and Clojure, but is <em>option-like</em> in Python<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>. Dictionary lookup in Ruby, JavaScript, and Clojure does not reliably distinguish between success and failure (unless you know that <code>nil</code> can’t be a value in your dictionary). Python’s <code>dict[key]</code> returns on success, and throws an exception on failure.</p>

<p>(Interestingly, Lua takes a “none of the above” approach. In Lua, it’s impossible to have a dictionary that maps a key to <code>nil</code>: setting a key to <code>nil</code> removes it from the dictionary!)</p>

<h2 id="options-and-exceptions">Options and exceptions</h2>

<p>I call Python’s dictionary lookup option-like, but it doesn’t involve anything that looks like an option type in Haskell, ML, Rust, or Swift. Why do I say they’re analogous?</p>

<p>Informally, by “option-like” I just mean “always distinguishes success from failure”. Options do this by having two <em>forms</em>: <code>None</code>, representing failure, and <code>Just x</code>, representing a successful result <code>x</code>. If I look up an absent key, I get <code>None</code>. If I look up a key mapped to <code>v</code>, I get <code>Just v</code>. Even if the key is mapped to <code>None</code> (the equivalent of a key mapped to <code>nil</code> in a dynamic language), I get <code>Just None</code> — which, critically, is not the same as <code>None</code>!</p>

<p>Exceptions accomplish the same goal differently, by altering control flow. Success returns to the function who called us; failure jumps to an enclosing <code>catch</code>. Instead of two <em>forms</em>, we have two <em>continuations</em>.</p>

<p>But there is a formal connection here, too. In a language with exceptions, we can view functions as giving either a successful result (if the function returns), or a value representing failure (if it threw an exception). This is akin to returning an option (more generally, a sum type). The <code>Either</code> monad and the <code>MonadError</code> typeclass in Haskell are manifestations of this connection.</p>

<h2 id="why-care">Why care?</h2>

<p>One might object: why would you ever store <code>nil</code> in a dictionary anyway? I have two retorts to this, one philosophical and one concrete.</p>

<p>Philosophically, I hate fragile abstractions. Barring typos and other trivialities, in my experience most bugs originate from using a leaky abstraction and not being aware of it. Sometimes it’s hard or impossible to build an abstraction that doesn’t leak (consider any language that lets you allocate memory without checking for out of memory conditions); but dictionary lookup is
not one of those cases.</p>

<p>Concretely, one case where it’s natural to map a value to <code>nil</code> is <em>reflection</em>. For example, if I’m representing a context mapping symbols to their values, <code>nil</code> is a perfectly reasonable thing to put in a dictionary. You may object that in that context, I should take care to write code that avoids conflating <code>nil</code> with absence. But if I wish to use a library function (some less trivial analog of <code>values_in</code>), I can only hope that its author was as careful as you advise me to be.</p>

<p>Languages and libraries are defined not by what they make possible (the Church-Turing thesis tells us that), but by what they make <em>easy</em>. If a language makes it easy to conflate <code>nil</code> and absence, to write code that does not reliably distinguish between success and failure, then bugs are sure to follow.</p>

<h3 id="appendix-a-does-language-affect-how-people-write-code">Appendix A: Does language affect how people write code?</h3>

<p>I did a <em>horrendously</em> unscientific study by asking current and former <a href="hackerschool.com">Hacker Schoolers</a> to implement <code>values_in</code> in whichever of {Ruby, JavaScript, Clojure, Python} they knew. I hypothesized that most Python solutions would handle <code>None</code> correctly, and most {Ruby, Clojure, JavaScript} solutions would not. (Some of you may notice a similarity to the infamous <a href="http://en.wikipedia.org/wiki/Sapir-Whorf_Hypothesis">Sapir-Whorf hypothesis</a>.) Most Python solutions were indeed correct. The {Ruby, Clojure, JavaScript} solutions were split about evenly between correct and <code>nil</code>-dropping.</p>

<p>However, the sample size was <em>tiny</em>. So scientifically the answer is a resounding “maybe”. (If you really want to know, give me a research grant.)</p>

<h3 id="appendix-b-adding-options-to-python">Appendix B: Adding options to Python</h3>

<p>Suppose we wanted option-like behavior in a dynamic language <em>without</em> throwing exceptions. Is that possible? Yes, it is:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Just</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

<span class="c"># Our option-like lookup function</span>
<span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="n">Just</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>

<span class="c"># How to use it</span>
<span class="k">def</span> <span class="nf">values_in</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">lookup</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span><span class="n">k</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="n">x</span><span class="p">]</span>
</code></pre></div>
<p>This is more complex than the previously-given correct Python code. However, it does only one lookup per key, rather than two. And there are no standard library functions for working with our new <code>Just</code> type. By contrast, in Haskell we could say:</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Data.Maybe</span> <span class="p">(</span><span class="nf">mapMaybe</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">Map</span>
<span class="n">valuesIn</span> <span class="n">keys</span> <span class="n">dict</span> <span class="o">=</span> <span class="n">mapMaybe</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">x</span> <span class="n">dict</span><span class="p">)</span> <span class="n">keys</span>
</code></pre></div>
<h3 id="appendix-c-language-comparison">Appendix C: Language comparison</h3>

<p><strong>Python:</strong></p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>              <span class="c"># raises KeyError</span>
<span class="nb">dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>          <span class="c"># None</span>
<span class="nb">dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span> <span class="c"># default</span>
</code></pre></div>
<p><strong>Ruby:</strong></p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>                   <span class="c1"># nil</span>
<span class="n">dict</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>             <span class="c1"># raises KeyError</span>
<span class="n">dict</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>    <span class="c1"># default</span>
<span class="n">dict</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">block</span><span class="p">}</span> <span class="c1"># block(key)</span>
</code></pre></div>
<p><strong>Clojure:</strong></p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">dict</span><span class="w"> </span><span class="nb">key</span><span class="p">)</span><span class="w">         </span><span class="c1">; nil
</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">dict</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="n">default</span><span class="p">)</span><span class="w"> </span><span class="c1">; default
</span></code></pre></div>
<p><strong>JavaScript:</strong></p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">dict</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="c1">// (for string keys) undefined</span>
</code></pre></div>
<p><strong>Lua:</strong></p>


<p><strong>Racket:</strong></p>

<div class="highlight"><pre><code class="language-racket" data-lang="racket"><span class="p">(</span><span class="nf">dict-ref</span> <span class="nv">dict</span> <span class="nv">key</span><span class="p">)</span>         <span class="c1">; Throws exception</span>
<span class="p">(</span><span class="nf">dict-ref</span> <span class="nv">dict</span> <span class="nv">key</span> <span class="nv">default</span><span class="p">)</span> <span class="c1">; default, unless it is a function</span>
<span class="p">(</span><span class="nf">dict-ref</span> <span class="nv">dict</span> <span class="nv">key</span> <span class="nv">default</span><span class="p">)</span> <span class="c1">; (default) if default is a function</span>
</code></pre></div>
<p><strong>Common Lisp:</strong></p>

<div class="highlight"><pre><code class="language-lisp" data-lang="lisp">(gethash keydict)         ; nil; nil (multiple return values)
(gethash keydict default) ; default; nil (multiple return values)
</code></pre></div>

  </article>

  

  </div></body></html>