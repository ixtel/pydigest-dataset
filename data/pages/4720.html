<html><body><div><div class="post-text" itemprop="text">

<p>Following-up from <a href="http://stackoverflow.com/q/5859144/478288">this question</a> years ago, is there a canonical "shift" function in numpy? I don't see anything from <a href="http://docs.scipy.org/doc/numpy/reference/routines.array-manipulation.html">the documentation</a>.</p>

<p>Here's a simple version of what I'm looking for:</p>

<pre><code>def shift(xs, n):
    if n &gt;= 0:
        return np.r_[np.full(n, np.nan), xs[:-n]]
    else:
        return np.r_[xs[-n:], np.full(-n, np.nan)]
</code></pre>

<p>Using this is like:</p>

<pre><code>In [76]: xs
Out[76]: array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.])

In [77]: shift(xs, 3)
Out[77]: array([ nan,  nan,  nan,   0.,   1.,   2.,   3.,   4.,   5.,   6.])

In [78]: shift(xs, -3)
Out[78]: array([  3.,   4.,   5.,   6.,   7.,   8.,   9.,  nan,  nan,  nan])
</code></pre>

<p><sub>This question came from my attempt to <a href="http://stackoverflow.com/a/30386409/478288">write a fast rolling_product</a> yesterday. I needed a way to "shift" a cumulative product and all I could think of was to replicate the logic in <code>np.roll()</code>.</sub></p>

<hr/>

<p>So <code>np.concatnate()</code> is much faster than <code>np.r_[]</code>. This version of the function performs a lot better:</p>

<pre><code>def shift(xs, n):
    if n &gt;= 0:
        return np.concatenate((np.full(n, np.nan), xs[:-n]))
    else:
        return np.concatenate((xs[-n:], np.full(-n, np.nan)))
</code></pre>

<hr/>

<p>An even faster version simply pre-allocates the array:</p>

<pre><code>def shift(xs, n):
    e = np.empty_like(xs)
    if n &gt;= 0:
        e[:n] = np.nan
        e[n:] = xs[:-n]
    else:
        e[n:] = np.nan
        e[:n] = xs[-n:]
    return e
</code></pre>
    </div>
    </div></body></html>