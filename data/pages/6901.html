<html><body><div><div class="post-text" itemprop="text">
<p>There are some important issues that I think all of the existing answers have missed.</p>

<hr/>

<p>Weak typing means allowing access to the underlying representation. In C, I can create a pointer to characters, then tell the compiler I want to use it as a pointer to integers:</p>

<pre><code>char sz[] = "abcdefg";
int *i = (int *)sz;
</code></pre>

<p>On a little-endian platform with 32-bit integers, this makes <code>i</code> into an array of the numbers <code>0x64636261</code> and <code>0x00676665</code>. In fact, you can even cast pointers themselves to integers (of the appropriate size):</p>

<pre><code>intptr_t i = (intptr_t)&amp;sz;
</code></pre>

<p>And of course this means I can overwrite memory anywhere in the system.*</p>

<pre><code>char *spam = (char *)0x12345678
spam[0] = 0;
</code></pre>

<p><sub>* Of course modern OS's use virtual memory and page protection so I can only overwrite my own process's memory, but there's nothing about C itself that offers such protection, as anyone who ever coded on, say, Classic Mac OS or Win16 can tell you.</sub></p>

<p>Traditional Lisp allowed similar kinds of hackery; on some platforms, double-word floats and cons cells were the same type, and you could just pass one to a function expecting the other and it would "work".</p>

<p>Most languages today aren't quite as weak as C and Lisp were, but many of them are still somewhat leaky. For example, any OO language that has an unchecked "downcast",* that's a type leak: you're essentially telling the compiler "I know I didn't give you enough information to know this is safe, but I'm pretty sure it is," when the whole point of a type system is that the compiler always has enough information to know what's safe.</p>

<p><sub>* A checked downcast doesn't make the language's type system any weaker just because it moves the check to runtime. If it did, then subtype polymorphism (aka virtual or fully-dynamic function calls) would be the same violation of the type system, and I don't think anyone wants to say that.</sub></p>

<p>Very few "scripting" languages are weak in this sense. Even in Perl or Tcl, you can't take a string and just interpret its bytes as an integer.* But it's worth noting that in CPython (and similarly for many other interpreters for many languages), if you're really persistent, you can use <code>ctypes</code> to load up <code>libpython</code>, cast an object's <code>id</code> to a <code>POINTER(Py_Object)</code>, and force the type system to leak. Whether this makes the type system weak or not depends on your use cases—if you're trying to implement an in-language restricted execution sandbox to ensure security, you do have to deal with these kinds of escapes…</p>

<p><sub>* You can use a function like <code>struct.unpack</code> to read the bytes and build a new int out of "how C would represent these bytes", but that's obviously not leaky; even Haskell allows that.</sub></p>

<hr/>

<p>Meanwhile, implicit conversion is really a different thing from a weak or leaky type system.</p>

<p>Every language, even Haskell, has functions to, say, convert an integer to a string or a float. But some languages will do some of those conversions for you automatically—e.g., in C, if you call a function that wants a <code>float</code>, and you pass it in <code>int</code>, it gets converted for you. This can definitely lead to bugs with, e.g., unexpected overflows, but they're not the same kinds of bugs you get from a weak type system. And C isn't really being any weaker here; you can add an int and a float in Haskell, or even concatenate a float to a string, you just have to do it more explicitly.</p>

<p>And with dynamic languages, this is pretty murky. There's no such thing as "a function that wants a float" in Python or Perl. But there are overloaded functions that do different things with different types, and there's a strong intuitive sense that, e.g., adding a string to something else is "a function that wants a string". In that sense, Perl, Tcl, and JavaScript appear to do a lot of implicit conversions (<code>"a" + 1</code> gives you <code>"a1"</code>), while Python does a lot fewer (<code>"a" + 1</code> raises an exception, but <code>1.0 + 1</code> does give you <code>2.0</code>*). It's just hard to put that sense into formal terms—why shouldn't there be a <code>+</code> that takes a string and an int, when there are obviously other functions, like indexing, that do?</p>

<p><sub>* Actually, in modern Python, that can be explained in terms of OO subtyping, since <code>isinstance(2, numbers.Real)</code> is true. I don't think there's any sense in which <code>2</code> is an instance of the string type in Perl or JavaScript… although in Tcl, it actually is, since <em>everything</em> is an instance of string.</sub></p>

<hr/>

<p>Finally, there's another, completely orthogonal, definition of "strong" vs. "weak" typing, where "strong" means powerful/flexible/expressive.</p>

<p>For example, Haskell lets you define a type that's a number, a string, a list of this type, or a map from strings to this type, which is a perfectly way to represent anything that can be decoded from JSON. There's no way to define such a type in Java. But at least Java has parametric (generic) types, so you can write a function that takes a List of T and know that the elements are of type T; other languages, like early Java, forced you to use a List of Object and downcast. But at least Java lets you create new types with their own methods; C only lets you create structures. And BCPL didn't even have that. And so on down to assembly, where the only types are different bit lengths.</p>

<p>So, in that sense, Haskell's type system is stronger than modern Java's, which is stronger than earlier Java's, which is stronger than C's, which is stronger than BCPL's.</p>

<p>So, where does Python fit into that spectrum? That's a bit tricky. In many cases, duck typing allows you to simulate everything you can do in Haskell, and even some things you can't; sure, errors are caught at runtime instead of compile time, but they're still caught. However, there are cases where duck typing isn't sufficient. For example, in Haskell, you can tell that an empty list of ints is a list of ints, so you can decide that reducing <code>+</code> over that list should return 0*; in Python, an empty list is an empty list; there's no type information to help you decide what reducing <code>+</code> over it should do.</p>

<p><sub>* In fact, Haskell doesn't let you do this; if you call the reduce function that doesn't take a start value on an empty list, you get an error. But its type system is powerful enough that you <em>could</em> make this work, and Python's isn't.</sub></p>
    </div>
    </div></body></html>