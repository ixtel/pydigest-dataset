<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/getpro/habr/post_images/a68/ddf/3e6/a68ddf3e6b52165cae0448a58f3a6b37.png" alt="image"/>
<p>
На сегодняшний день две мои самые любимые темы — SQLite и key-value базы данных. И в этот раз я пишу сразу про обе: этот пост посвящён Python-обёртке для используемого в SQLite 4 key-value хранилища на основе </p><a href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">LSM</a><p>.
</p><p>
Я не слишком внимательно отслеживаю релизы SQLite, но версия 3.8.11 привлекла моё внимание, поскольку в её описании заявлено серьёзное увеличение производительности по сравнению с 3.8.0. В сопроводительной информации я наткнулся на упоминание о новом экспериментальном расширении для полнотекстового поиска (</p><a href="http://charlesleifer.com/blog/building-the-sqlite-fts5-search-extension/">о котором писал когда-то</a><p>), и потому мне стало интересно, какая складывается ситуация с </p><a href="http://sqlite.org/src4/doc/trunk/www/design.wiki">SQLite 4</a><p>.
</p><p>
Изучив доступную информацию, я обратил внимание, что одной из задач разработчиков было обеспечить в новых версиях </p><a href="http://sqlite.org/src4/doc/trunk/www/storage.wiki">интерфейс для подключаемых движков баз данных</a><p>. На момент написания этого поста в SQLite 4 уже было два встроенных бэкенда, один из которых — key-value хранилище на основе LSM. В последние пару месяцев мне доводилось поиграться с </p><a href="http://cython.org/">Cython</a><p>, пока я писал Python-обёртку для встроенных k-v хранилищ </p><a href="http://unqlite-python.readthedocs.org/">UnQLite</a><p> и </p><a href="http://vedis-python.readthedocs.org/">Vedis</a><p>. И я подумал, что было бы неплохо применить Cython для создания интерфейса движка БД на основе LSM, используемого в SQLite 4.
</p><p>
Разобравшись с </p><a href="http://sqlite.org/src4/tree?ci=trunk">исходным кодом SQLite 4</a><p> и </p><a href="https://github.com/coleifer/python-lsm-db/blob/master/src/lsm.h">крохотным заголовочным файлом LSM</a><p>, я написал </p><a href="https://github.com/coleifer/python-lsm-db">python-lsm-db</a><p> (</p><a href="http://lsm-db.readthedocs.org/">документация</a><p>).
</p><a name="habracut"/>
<h1>Что такое LSM-дерево?</h1><p>
Насколько я понимаю теорию, LSM-деревья состоят из:

</p><ul>
<li>расположенного в памяти дерева, работающего в качестве буфера,</li>
<li>и одного или нескольких хранимых (persistent) деревьев, размещённых на диске.</li>
</ul><p>
Буква М в аббревиатуре LSM означает merge: операцию по объединению буферизированных записей с деревом (деревьями) на диске. Эта процедура позволяет сильно уменьшить стоимость seek по диску, что означает одно — быструю запись. С другой стороны, произвольное чтение может оказаться более медленным, поскольку система будет искать по нескольким деревьям. А LSM-дерево может быть </p><b>длиннее</b><p>, чем сравнимое с ним B-дерево. Полагаю, что ещё одним преимуществом LSM-деревьев является меньшая фрагментированность хранимых данных, что ускоряет чтение диапазонов ключей.
</p><p>
Ещё раз подчеркну: таково моё понимание теории. Я мог в чём-то ошибиться или упустить важные моменты.

</p><h1>Свойства</h1><p>
Реализация LSM в SQLite 4 обладает рядом очень интересных свойств:

</p><ul>
<li>Embedded БД, используемая вашим приложением.</li>
<li>Задание порядка просмотра ключей с помощью курсоров.</li>
<li>Транзакционность (включая вложенные транзакции).</li>
<li>Транзакционная модель распараллеливания на базе MVCC с поддержкой режима «один пишет / несколько читают».</li>
<li>Хранимая на диске база в виде одного файла.</li>
<li>Устойчивость данных при сбоях приложения или питания.</li>
<li>Возможность гибкой настройки под свои нужды.</li>
</ul>
<h1>Создание Python-библиотеки </h1><p>
Итак, приступим. Для начала создадим virtualenv и воспользуемся pip для установки Cython и lsm-db:

</p><pre><code class="bash">$ virtualenv test_lsm
$ cd test_lsm
$ source bin/activate
(test_lsm) $ pip install Cython lsm-db
</code></pre><p>
Для проверки установки можно выполнить строку:

</p><pre><code class="bash">(test_lsm) $ python -c "import lsm, tempfile; lsm.LSM(tempfile.mktemp())"
</code></pre><p>
Если всё установлено и работает корректно, то выполнение этой команды ничего за собой не повлечёт. Но имейте в виду, я тестировал её только на Python 2.7 под Linux. Так что если вы пользуетесь Python 3.4 под Windows, то вам может потребоваться отладить этот код.

</p><h1>Небольшое отступление</h1><p>
Далее будет пример интерактивного консольного сеанса, который отражает основные особенности и возможности библиотеки lsm-db. В </p><a href="http://lsm-db.readthedocs.org/en/latest/api.html">документации API</a><p> содержится полный список классов, методов и описаний параметров и возвращаемых значений.
</p><p>
Для начала запустите в виртуальном окружении интерпретатор Python и создайте экземпляр объекта LSM, указав путь к файлу базы данных:

</p><pre><code class="python">&gt;&gt;&gt; from lsm import LSM
&gt;&gt;&gt; db = LSM('test.ldb')
</code></pre><p>
В классе LSM есть ещё </p><a href="http://lsm-db.readthedocs.org/en/latest/api.html#lsm.LSM.__init__">ряд параметров</a><p>, помимо filename, которые вы можете настроить: размер блока, размер страницы и т. д.

</p><h1>Особенности key-value</h1><p>
LSM-движок SQLite 4 является key/value-хранилищем, что делает его отчасти похожим на объект dict в Python. Воспользуемся dict-like API.

</p><pre><code class="python">&gt;&gt;&gt; db['foo'] = 'bar'
&gt;&gt;&gt; print db['foo']
bar

&gt;&gt;&gt; for i in range(4):
...     db['k%s' % i] = str(i)
...

&gt;&gt;&gt; 'k3' in db
True
&gt;&gt;&gt; 'k4' in db
False

&gt;&gt;&gt; del db['k3']
&gt;&gt;&gt; db['k3']
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "lsm.pyx", line 973, in lsm.LSM.__getitem__ (lsm.c:7142)
  File "lsm.pyx", line 777, in lsm.LSM.fetch (lsm.c:5756)
  File "lsm.pyx", line 778, in lsm.LSM.fetch (lsm.c:5679)
  File "lsm.pyx", line 1289, in lsm.Cursor.seek (lsm.c:12122)
  File "lsm.pyx", line 1311, in lsm.Cursor.seek (lsm.c:12008)
KeyError: 'k3'
</code></pre><p>
Обратите внимание: когда мы попытались получить доступ к только что удалённому ключу, сразу выскочила KeyError. По умолчанию, когда мы ищем ключ, библиотека сначала ищет полное совпадение. В SQLite 4 LSM может также искать наиболее близкий ключ лексикографически, если искомое нами значение не существует. В дополнение к поиску по совпадению есть ещё два метода поиска, возвращающих следующий ближайший ключ: SEEK_LE и SEEK_GE. Если полное совпадение не обнаружено, то SEEK_LE возвращает самый верхний из ключей (highest key), значение которого меньше искомого, а SEEK_GE — самый нижний из ключей (lowest key), чьё значение больше искомого. Допустим, k1.5 не существует:

</p><pre><code class="python">&gt;&gt;&gt; from lsm import SEEK_LE, SEEK_GE

&gt;&gt;&gt; # Здесь будет выбран "k1", самый верхний из всех, что меньше k1.5
&gt;&gt;&gt; db['k1.5', SEEK_LE]
'1'

&gt;&gt;&gt; # Здесь будет выбран "k2", самый нижний из всех, что больше k1.5
&gt;&gt;&gt; db['k1.5', SEEK_GE]
'2'
</code></pre><p>
Помимо этих, LSM поддерживает и ряд других методов: keys(), values() и update().

</p><h1>Слайсы и итерации</h1><p>
В SQLite 4 LSM можно итерироваться напрямую по данным либо делать выборку по подмножеству ключей. Интересный момент заключается в том, что при запросе диапазона ключей его начало и конец могут не существовать. Если какой-то ключ отсутствует, то база воспользуется одним из seek-методов чтобы найти следующий близкий ключ (next-closest key):

</p><pre><code class="python">&gt;&gt;&gt; [item for item in db]
[('foo', 'bar'), ('k0', '0'), ('k1', '1'), ('k2', '2')]

&gt;&gt;&gt; db['k0':'k99']
&lt;generator object at 0x7f2ae93072f8&gt;

&gt;&gt;&gt; list(db['k0':'k99'])
[('k0', '0'), ('k1', '1'), ('k2', '2')]
</code></pre><p>
Для возврата всех ключей в заданном направлении можно воспользоваться открытыми (open-ended) слайсами:

</p><pre><code class="python">&gt;&gt;&gt; list(db['k0':])
[('k0', '0'), ('k1', '1'), ('k2', '2')]

&gt;&gt;&gt; list(db[:'k1'])
[('foo', 'bar'), ('k0', '0'), ('k1', '1')]
</code></pre><p>
Если верхняя(upper bound) или нижняя(lower bound) граница за пределами диапазона ключей, то возвращается пустой список.

</p><pre><code class="python">&gt;&gt;&gt; list(db[:'aaa'])
[]
&gt;&gt;&gt; list(db['z':])
[]
</code></pre><p>
Для извлечения ключей в обратном порядке достаточно просто указать в качестве первого параметра слайса верхний ключ. Если вы извлекаете открытый слайс, то в качестве его step-параметра можно указать True.

</p><pre><code class="python">&gt;&gt;&gt; list(db['k1':'aaa'])  # Поскольку 'k1' &gt; 'aaa', то ключи извлекаются в обратном порядке:
[('k1', '1'), ('k0', '0'), ('foo', 'bar')]

&gt;&gt;&gt; list(db['k1'::True])  # В открытых слайсах True указывается в качестве step:
[('k1', '1'), ('k0', '0'), ('foo', 'bar')]

При необходимости вы можете &lt;b&gt;удалять&lt;/b&gt; слайсы, но сами ключи при этом не будут затронуты:
&gt;&gt;&gt; del db['k0':'k99']

&gt;&gt;&gt; list(db)  # 'k0' всё ещё существует.
[('foo', 'bar'), ('k0', '0')]
</code></pre><p>
Если вас интересует более подробная информация о работе seek-методов, обратитесь к документации </p><a href="http://lsm-db.readthedocs.org/en/latest/api.html#lsm.LSM.fetch_range">LSM.fetch_range()</a><p>.

</p><h1>Курсоры</h1><p>
Хотя в большинстве случаев слайсов вполне достаточно, иногда нужен более тонкий контроль процесса поиска и просмотра записей.

</p><pre><code class="python">&gt;&gt;&gt; with db.cursor() as cursor:
...     for key, value in cursor:
...         print key, '=&gt;', value
...
foo =&gt; bar
k0 =&gt; 0

&gt;&gt;&gt; db.update({'k1': '1', 'k2': '2', 'k3': '3'})

&gt;&gt;&gt; with db.cursor() as cursor:
...     cursor.first()
...     print cursor.key()
...     cursor.last()
...     print cursor.key()
...     cursor.previous()
...     print cursor.key()
...
foo
k3
k2

&gt;&gt;&gt; with db.cursor() as cursor:
...     cursor.seek('k0', SEEK_GE)
...     print list(cursor.fetch_until('k99'))
...
[('k0', '0'), ('k1', '1'), ('k2', '2'), ('k3', '3')]
</code></pre><p>
Применяя курсоры, ни в коем случае не оставляйте их открытыми. На первых порах можете воспользоваться менеджером контекста LSM.cursor(), который поможет закрывать курсоры.

</p><h1>Транзакции</h1><p>
LSM-база SQLite 4 поддерживает вложенные транзакции. Проще всего их использовать вместе с методом LSM.transaction(), выступающим также в роли менеджера контекста или декоратора.

</p><pre><code class="python">&gt;&gt;&gt; with db.transaction() as txn:
...     db['k1'] = '1-mod'
...     with db.transaction() as txn2:
...         db['k2'] = '2-mod'
...         txn2.rollback()
...
True
&gt;&gt;&gt; print db['k1'], db['k2']
1-mod 2
</code></pre><p>
Вы можете частично закоммитить или откатить транзакции с помощью изолированной блокировки (wrapped block), и новая транзакция начнётся со старого места:

</p><pre><code class="python">&gt;&gt;&gt; with db.transaction() as txn:
...    db['k1'] = 'outer txn'
...    txn.commit()  # Запись закоммичена.
...
...    db['k1'] = 'outer txn-2'
...    with db.transaction() as txn2:
...        db['k1'] = 'inner-txn'  # Закоммичено после снятия блокировки.
...    print db['k1']  # Печатает "inner-txn".
...    txn.rollback()  # Откатывает из txn2 оба изменения и предыдущую запись.
...    print db['k1']
...
1              &lt;- Return value from call to commit().
inner-txn      &lt;- Printed after end of txn2.
True           &lt;- Return value of call to rollback().
outer txn      &lt;- Printed after rollback.
</code></pre><p>
Если хотите, можете явным образом вызвать LSM.begin(), LSM.commit()и LSM.rollback().

</p><pre><code class="python">&gt;&gt;&gt; db.begin()
&gt;&gt;&gt; db['foo'] = 'baze'
&gt;&gt;&gt; print db['foo']
baze
&gt;&gt;&gt; db.rollback()
True
&gt;&gt;&gt; print db['foo']
bar
</code></pre>
<h1>Производительность</h1><p>
Хоть я и не могу терпеть все эти бенчмарки, мне было очень интересно, какова производительность у LSM-базы. Поэтому я с помощью </p><a href="https://gist.github.com/coleifer/747c4406b3c2363e0716">небольшого бенчмарка</a><p> сравнил SQLite 4 LSM с LevelDB, Berkeley DB и Kyoto Cabinet. По-хорошему, их нельзя было сравнивать, поскольку Kyoto Cabinet и Berkeley DB являются встроенными В-деревьями, а Kyoto Cabinet и LevelDB не поддерживают множественный доступ процессов к базе. Также я не уверен, есть ли поддержка транзакций в LevelDB. Помимо прочего, бенчмарк использует библиотеки баз не напрямую, а через доступный драйвер Python. Так что на результат могли повлиять какие-то ограничения и особенности питоновских библиотек. 
</p><p>
Результаты бенчмарка (чем меньше, тем лучше):

</p><pre><code class="bash">Testing with N = 100000
------------------------------------

BDBBTree
~~~~~~~~
Writes:        0.469
Reads:         0.479
Range (10%):   0.212
Range (20%):   0.192
Range (40%):   0.185
Range (80%):   0.186

KyotoBTree
~~~~~~~~~~
Writes:        0.208
Reads:         0.203
Range (10%):   0.219
Range (20%):   0.188
Range (40%):   0.188
Range (80%):   0.187

LevelDB
~~~~~~~
Writes:        0.227
Reads:         0.225
Range (10%):   0.031
Range (20%):   0.027
Range (40%):   0.028
Range (80%):   0.027

LSM
~~~
Writes:        0.282
Reads:         0.239
Range (10%):   0.059
Range (20%):   0.052
Range (40%):   0.052
Range (80%):   0.052
</code></pre><p>
Я интерпретирую эти данные так: производительность Berkeley DB и Kyoto Cabinet при получении диапазонов ключей оказалась вполне ожидаемой, то есть примерно такой, как и при произвольном чтении. А LevelDB и LSM, напротив, оказались гораздо быстрее при чтении диапазонов, да и запись у них производится довольно быстро.
</p><p>
LevelDB превзошёл SQLite 4 LSM, но последний считывает диапазоны куда шустрее, чем В-деревья. Надо будет продебажить бенчмарк LSM’а, потому что чтение у него оказалось в четыре раза медленнее, чем запись! Сначала я подумал, что просто есть какие-то проблемы с чтением, но потом сообразил, что всё дело в Python-обёртке курсора для каждого fetch(). После замены кода Python на пару прямых вызовов API языка С скорость чтения сильно выросла. Если захотите попробовать биндинги LSM Python, то удостоверьтесь, что вы пользуетесь версией 0.1.4 или выше, поскольку в предыдущих версиях очень медленная реализация fetch(). 

</p><h1>Заметки об SQLite 4</h1><p>
Если хотите сами собрать SQLite 4, то можете клонировать устаревший репозиторий и скомпилировать его. 

</p><pre><code class="bash">$ fossil clone http://www.sqlite.org/src4/ sqlite4.fossil
$ mkdir sqlite4-build
$ cd sqlite4-build
$ fossil open ../sqlite4.fossil
$ ln -s Makefile.linux-gcc Makefile
$ export CFLAGS="$CFLAGS -DSQLITE_ENABLE_FTS3=1 -DSQLITE_ENABLE_COLUMN_METADATA=1 -DSQLITE_ENABLE_UNLOCK_NOTIFY -DSQLITE_SECURE_DELETE
$ make
</code></pre><p>
По завершении у вас будет бинарный файл sqlite4, libsqlite4.a и sqlite4.h.
</p><p>
Также для упрощения процесса встраивания можно создать собственные копии исходного объединённого файла:

</p><pre><code class="bash">make sqlite4.c
</code></pre><p>
Должен также отметить, что текущий статус SQLite 4… неизвестен. Доктор Хипп обмолвился, что он планирует продолжать поддержку SQLite 3. Трудно его за это винить. Но на месте конечных пользователей я бы поэкспериментировал с четвёртой версией. Возможно, за ней будущее, но не факт. А даже если и да, то, возможно, не в текущем виде.

</p><h1>Дополнительные материалы</h1><p>
Если вам нужны грязные подробности, то вот список полезных ссылок:

</p><p>
Другие мои посты, которые могут вам понравиться:

</p><p>
Если вас интересуют другие встраиваемые NoSQL-базы, то обратите внимание на </p><a href="http://unqlite-python.readthedocs.org/">unqlite-python</a><p> и </p><a href="http://vedis-python.readthedocs.org/">vedis-python</a><p>. Они очень похожи на MongoDB и Redis соответственно, используют обёртки, легковесные расширения на С и могут встраиваться в проекты на Python.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>