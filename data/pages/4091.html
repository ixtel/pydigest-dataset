<html><body><div><article>
<header>
<h1>Introduction to Fuzzing in Python with AFL</h1>

</header>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Fuzz_testing">Fuzzing</a> is a technique in computer testing and security where you generate
a bunch of random inputs, and see how some program handles it. For example, if
you had a JPEG parser, you might create a bunch of valid images and broken
images, and make sure it either parses them or errors out cleanly. In C (and
other memory unsafe languages) fuzzing can often be used to discover
segfaults, invalid reads, and other potential security issues. Fuzzing is also
useful in Python, where it can discover uncaught exceptions, and other API
contract violations.</p>
<p>This blog post is going to walk you through getting started with <a class="reference external" href="http://lcamtuf.coredump.cx/afl/">afl</a>
(American Fuzzy Lop), a new, but extremely powerful fuzzer which can be used
on Python code. afl is very good at finding bugs. In addition to clever
techniques for generating random inputs, it also instruments your program, and
uses coverage data about what paths are being taken to find interesting new
bugs.</p>
<p>To get started, you'll first need to install afl. If you're on OS X and using
Homebrew:</p>

<p>Next you'll probably want to create a virtualenv. Inside of it you'll want to
grab a copy of the Python afl tooling and install it into the virtualenv:</p>
<div class="highlight"><pre><span class="gp">$</span> hg clone https://bitbucket.org/jwilk/python-afl
<span class="gp">$</span> pip install cython
<span class="gp">$</span> pip install -e ./python-afl
</pre></div>
<p>Now you'll want to write a small script which takes some input from
<tt class="docutils literal">sys.stdin</tt>, and tries to parse it (or do whatever your program does):</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">afl</span>

<span class="kn">from</span> <span class="nn">cryptography.hazmat.primitives.asymmetric.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">decode_rfc6979_signature</span>
<span class="p">)</span>

<span class="n">afl</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">decode_rfc6979_signature</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
<p>Pretty simple. The <tt class="docutils literal">afl.init()</tt> line is a thing for performance, you should
put that line after all your imports and setup, before before you do anything
with <tt class="docutils literal">sys.stdin</tt>. You need to make sure that you catch any exception which
your code could throw, in <tt class="docutils literal">decode_rfc6979_signature</tt> the only exception that
it's documented as raising is <tt class="docutils literal">ValueError</tt>, so anything else that's raised
is an error. Please note that this will only be effective if your code is
pure-python, if the majority of your code is a C extension (e.g. <tt class="docutils literal">cPickle</tt>)
you need to take a slightly different approach, which isn't described here.</p>
<p>Next you'll need to create a corpus of "example" inputs. It doesn't have to be
big, just a few small examples of what a valid input to your function looks
like. I've used as little as one input with success. Once you've got them, put
them all in a directory, one per file (the files' names don't matter).</p>
<p>Now you can invoke afl:</p>
<div class="highlight"><pre><span class="gp">$</span> ./python-afl/py-afl-fuzz -o results-path/ -i /path/to/examples -- /path/to/python /path/to/your/test/script.py
</pre></div>
<p>It'll pop up a curses display to let you know the progress, and you're off to
the traces. Some of the display is self-explanatory, for the rest you can
<a class="reference external" href="http://lcamtuf.coredump.cx/afl/status_screen.txt">consult the documentation</a>. When afl discovers crashers, you'll be able to
find them in <tt class="docutils literal"><span class="pre">results-path/crashes/</span></tt>.</p>
<p>Fuzzing can be very CPU intensive, so doing it on your laptop isn't the most
efficient way to do it, a large cloud server can be a good choice for serious
fuzzing.</p>
<p>And that's all there is to it! Happy Fuzzing!</p>
<section class="comments">
<p>Sorry, no comments here. I'd much rather you wrote your own blog post or sent me an email instead.</p>
</section>
</article>
</div></body></html>