<html><body><div><div class="section" id="python-semantics">
    
    <p>
     Python is hard to optimize because almost everything is mutable: builtin
functions, function code, global variables, local variables, ... can be
modified at runtime. Implement optimizations respecting the Python
semantics requires to detect when "something changes", we will call these
checks "guards".
    </p>
    <p>
     This PEP proposes to add a public API to the Python C API to add
specialized codes with guards to a function. When the function is
called, a specialized code is used if nothing changed, otherwise use the
original bytecode.
    </p>
    <p>
     Even if guards help to respect most parts of the Python semantics, it's
hard to optimize Python without making subtle changes on the exact
behaviour. CPython has a long history and many applications rely on
implementation details. A compromise must be found between "everything
is mutable" and performance.
    </p>
    <p>
     Writing an optimizer is out of the scope of this PEP.
    </p>
   </div>
   <div class="section" id="why-not-a-jit-compiler">
    
    <p>
     There are multiple JIT compilers for Python actively developed:
    </p>
    
    <p>
     Numba is specific to numerical computation.  Pyston and Pyjion are still
young.  PyPy is the most complete Python interpreter, it is generally
faster than CPython in micro- and many macro-benchmarks and has a very
good compatibility with CPython (it respects the Python semantics).
There are still issues with Python JIT compilers which avoid them to be
widely used instead of CPython.
    </p>
    <p>
     Many popular libraries like numpy, PyGTK, PyQt, PySide and wxPython are
implemented in C or C++ and use the Python C API. To have a small memory
footprint and better performances, Python JIT compilers do not use
reference counting to use a faster garbage collector, do not use C
structures of CPython objects and manage memory allocations differently.
PyPy has a
     <tt class="docutils literal">
      cpyext
     </tt>
     module which emulates the Python C API but it has
worse performances than CPython and does not support the full Python C
API.
    </p>
    <p>
     New features are first developped in CPython. In january 2016, the
latest CPython stable version is 3.5, whereas PyPy only supports Python
2.7 and 3.2, and Pyston only supports Python 2.7.
    </p>
    <p>
     Even if PyPy has a very good compatibility with Python, some modules are
still not compatible with PyPy: see
     <a class="reference external" href="https://bitbucket.org/pypy/compatibility/wiki/Home">
      PyPy Compatibility Wiki
     </a>
     . The incomplete
support of the the Python C API is part of this problem. There are also
subtle differences between PyPy and CPython like reference counting:
object destructors are always called in PyPy, but can be called "later"
than in CPython. Using context managers helps to control when resources
are released.
    </p>
    <p>
     Even if PyPy is much faster than CPython in a wide range of benchmarks,
some users still report worse performances than CPython on some specific
use cases or unstable performances.
    </p>
    <p>
     When Python is used as a scripting program for programs running less
than 1 minute, JIT compilers can be slower because their startup time is
higher and the JIT compiler takes time to optimize the code. For
example, most Mercurial commands take a few seconds.
    </p>
    <p>
     Numba now supports ahead of time compilation, but it requires decorator
to specify arguments types and it only supports numerical types.
    </p>
    <p>
     CPython 3.5 has almost no optimization: the peephole optimizer only
implements basic optimizations. A static compiler is a compromise
between CPython 3.5 and PyPy.
    </p>
    <div class="note">
     <p class="first admonition-title">
      Note
     </p>
     <p class="last">
      There was also the Unladen Swallow project, but it was abandoned in
2011.
     </p>
    </div>
   </div>
  </div></body></html>