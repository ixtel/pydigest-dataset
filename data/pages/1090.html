<html><body><div><div class="subsection homepage-subsection">
                  <div class="row">
                    <div class="ui two column middle aligned stackable grid">
                    
                  <div class="twelve wide column">
                    <h1 class="dark">Faking the Funk: Mocking External Services in Python Tests</h1>
                    <p class="date-index">by <a href="https://www.appneta.com/blog/author/driti/" title="Posts by Dan Riti" rel="author">Dan Riti</a> July 25, 2014</p>
                  </div>
                  </div>
                  </div>
                  <p class="space-top">
            
                  </p><p class="ttr_start"/><p>In this day and age, it’s difficult to build an application that does <strong>not</strong> rely on some type of external service. Whether the service is handling <a href="https://dev.twitter.com/docs/auth">user identity</a>, analyzing <a href="https://developer.github.com/v3/issues/">interesting data</a>, or hurling RESTful <a href="http://foaas.herokuapp.com/">insults</a>, you have to accept the fact that you now have a dependency on something you do <strong>not</strong> control.</p>
<p>One place where this dependency can become painfully obvious is running your test suite. Making requests to an external service can cause your tests to become <em>extremely</em> slow. According to <a href="http://robots.thoughtbot.com/how-to-stub-external-services-in-tests">Harlow Ward</a>, these extra requests during tests can cause a wide range of problems:</p>
<ul class="list-styled">
<li>Tests failing intermittently due to connectivity issues.</li>
<li>Dramatically slower test suites.</li>
<li>Hitting API rate limits on 3rd party sites (e.g. Twitter).</li>
<li>Service may not exist yet (only documentation for it).</li>
<li>Service doesn’t have a sandbox or staging server.</li>
</ul>
<p>We want to ensure our test suite is fast and consistent. Thus, let’s take a look at how we can leverage <a href="http://en.wikipedia.org/wiki/Mock_object">mocks</a> to create an isolated test environment in Python.</p>
<h2>We Want the Funk</h2>
<p>To begin, let’s take a look at some of the tools we’re going to use in this exercise:</p>
<ol class="list-styled">
<li><a href="https://developer.github.com/v3/">GitHub API</a>, external service we are going to mock</li>
<li><a href="http://docs.python-requests.org/">requests</a>, a fantastic HTTP library</li>
<li><a href="https://github.com/patrys/httmock">httmock</a>, a mocking library for requests</li>
<li><a href="https://github.com/danriti/python-mocked-service">python-mocked-service</a>, an example GitHub repository for tracking our code changes throughout this article</li>
</ol>
<p>Let’s start by assuming our application relies on the GitHub <a href="https://developer.github.com/v3/repos/#get">repository</a> endpoint. Thus, we can begin with the following changes:</p>
<ul class="list-styled">
<li>(<a href="https://github.com/danriti/python-mocked-service/commit/c97eb466131c66cd3daf0b4c5e0014a5a4756bb0">Commit</a>) Add <code>get_repository</code> function, for getting GitHub repository information.</li>
<li>(<a href="https://github.com/danriti/python-mocked-service/commit/5003a893b1c52b662d4618a754e921e857e65f9f">Commit</a>) Add <code>test_get_repository</code> test case, for testing our newly created <code>get_repository</code> function.</li>
</ul>
<p>Now let’s go ahead and run the test:</p>
<pre class="wp-code-highlight prettyprint">
 (env)[driti@ubuntu]$ python test_github.py
.
----------------------------------------------------------------------
Ran 1 test in 0.245s

OK
</pre>
<p>We can see the test passes, however it took a total of <strong>0.245 seconds</strong>. I don’t know about you, but that’s <em>way</em> too slow for me. So let’s speed things up a bit by mocking out the repository endpoint! To do this, we can make the following changes:</p>
<ul class="list-styled">
<li>(<a href="https://github.com/danriti/python-mocked-service/commit/5c69623d77bbe5780d5d68dbc5e85bba08ae3770">Commit</a>) Create a <code>repository</code> mock, for faking the response from the repository endpoint.</li>
<li>(<a href="https://github.com/danriti/python-mocked-service/commit/332f03211dbe307b8dcce9b11f7e939f54262276">Commit</a>) Update our unit test to use the <code>repository</code> mock.</li>
</ul>
<p>Now we re-run the test and …</p>
<pre class="wp-code-highlight prettyprint">
(env)[driti@ubuntu]$ python test_github.py
.
----------------------------------------------------------------------
Ran 1 test in 0.009s

OK
</pre>
<p>Wow, talk about a speed up! In fact, it was a <strong>27x</strong> speed up off of a <em>single</em> test:</p>
<pre class="wp-code-highlight prettyprint">
(env)[driti@ubuntu]$ python -c &amp;quot;print(0.245 / 0.009)&amp;quot;
27.2222222222
</pre>
<p>It’s important to note that we do <strong>not</strong> want to create our mocks within our test files, as this does not promote the idea of reusability. Thus, I highly recommend creating all your mocks within a <a href="https://github.com/danriti/python-mocked-service/tree/master/mocks"><code>mocks</code> module</a> to encourage reuse among existing and future tests.</p>
<p>The mock we created was quite basic. So let’s take a look at how we can further improve.</p>
<h2>Tear the Roof Off</h2>
<p>Thinking ahead, I’d like to add many more methods to my GitHub library to support the numerous functionalities of the GitHub API. However, I’m reluctant because this means I have to create many more mocks.</p>
<p>Immediately, I realize that my initial approach at designing a mock was rushed and has room for improvement. For starters, let’s approach the problem from a <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a> point of view. We have two concerns when it comes to mocking a service, the mock and the <a href="http://en.wikipedia.org/wiki/Web_resource">resource</a> response. Lumping both these concerns into the same places makes my mock quite inflexible. So why don’t we try moving our resource response into a <a href="http://en.wikipedia.org/wiki/Test_fixture#Software">test fixture</a>!</p>
<p>Lucky for us, GitHub followed the RESTful best practice of <strong>Addressability</strong> when designing their API. Addressability is defined by <a href="https://twitter.com/leonardr">Leonard Richardson</a> and <a href="https://twitter.com/samruby">Sam Ruby</a> in <a href="http://shop.oreilly.com/product/9780596529260.do">RESTful Web Services</a> as,</p>
<blockquote><p>A web service is addressable if it exposes the interesting aspects of its data set through resources. <strong>Every resource has it’s own unique URI</strong>: in fact, URI just stands for “Universal Resource Identifier.”</p></blockquote>
<p>Since every GitHub resource is uniquely addressed, this makes it easy for us to map a resource URI to a file on our file system. For example, the resource URI <code>api.github.com/repos/appneta/burndown</code> can just be a file containg JSON that is nested in several directories:</p>
<pre class="wp-code-highlight prettyprint">
(env)[driti@ubuntu]$ mkdir -p api.github.com/repos/appneta
(env)[driti@ubuntu]$ echo '{&amp;quot;name&amp;quot;:&amp;quot;burndown&amp;quot;}' &amp;gt; api.github.com/repos/appneta/burndown
(env)[driti@ubuntu]$ cat api.github.com/repos/appneta/burndown | python -m json.tool
{
    &amp;quot;name&amp;quot;: &amp;quot;burndown&amp;quot;
}
</pre>
<p>Now let’s go ahead and update our mock and test:</p>
<ul class="list-styled">
<li>(<a href="https://github.com/danriti/python-mocked-service/commit/b8304d3a6e7225b2e2d2d9bdf3a7c623f095fba0">Commit</a>) Refactor <code>repository</code> mock to use test fixtures.</li>
</ul>
<pre class="wp-code-highlight prettyprint">
(env)[driti@ubuntu]$ python test_github.py
.
----------------------------------------------------------------------
Ran 1 test in 0.009s

OK
</pre>
<p>Awesome!</p>
<p>Looking back at our <code>repository</code> mock, it actually contains <em>nothing</em> specific about the repository endpoint anymore (other then the <code>path</code> parameter). In fact, it seems like the mock can be reused for generic GET requests for <em>any</em> resource that has a test fixture on our file system.</p>
<p>The proof is in the pudding, so let’s update our mock:</p>
<ul class="list-styled">
<li>(<a href="https://github.com/danriti/python-mocked-service/commit/f4e91a12fc401dd7f39f96a315e4eab19e8b115f">Commit</a>) Rename <code>repository</code> mock to <code>resource_get</code>.</li>
</ul>
<p>So let’s go ahead and put our updated <code>resource_get</code> mock to the test and see if it can properly handle requests for GitHub <a href="https://developer.github.com/v3/users/#get-a-single-user">user</a> information:</p>
<ul class="list-styled">
<li>(<a href="https://github.com/danriti/python-mocked-service/commit/9c7cad198d0e2eed8053198c08fe12f093ad17f5">Commit</a>) Add <code>get_user</code> function, for getting GitHub <a href="https://developer.github.com/v3/users/#get-a-single-user">user</a> information.</li>
<li>(<a href="https://github.com/danriti/python-mocked-service/commit/95e2c572fba2b7eec5bf6492876906b22c98e441">Commit</a>) Add <code>test_get_user</code> test case, for testing our <code>get_user</code> function.</li>
<li>(<a href="https://github.com/danriti/python-mocked-service/commit/c4f45acd4e29beff06b410892324c041f494641d">Commit</a>) Create a test fixture for user <code>danriti</code>.</li>
</ul>
<p>Running our updated test suite yields sweet victory:</p>
<pre class="wp-code-highlight prettyprint">
(env)[driti@ubuntu]$ python test_github.py
..
----------------------------------------------------------------------
Ran 2 tests in 0.013s

OK
</pre>
<p>With our new and improved <code>resource_get</code> mock, we now only have to create test fixtures anytime we want to add new functionality and test it!</p>
<h2>Whole Lot of Rhythm Going Round</h2>
<p>Developers love refactoring, right? Well I can think of a few more changes that are appropriate.</p>
<p>First, our mock <a href="https://github.com/danriti/python-mocked-service/blob/f4e91a12fc401dd7f39f96a315e4eab19e8b115f/mocks/github.py#L20-L21">knows too much</a>! Thus, I propose we do some good old <a href="http://en.wikipedia.org/wiki/Information_hiding">information hiding</a> and move the file handling functionality out of our mock and into a new class called <code>Resource</code>:</p>
<ul class="list-styled">
<li>(<a href="https://github.com/danriti/python-mocked-service/commit/7fc95b4a8a53b5555ccef529271aaca76fd3cf8e">Commit</a>) Create Resource class for encapsulating file handling.</li>
</ul>
<p>At first glance, you might think this is <a href="http://en.wikipedia.org/wiki/Overengineering">overengineering</a>. While this may be true for simple file reading (i.e. mocking GET requests), you will have to deal with more complex file handling functionality when you start mocking POST, PUT, and DELETE requests. Thus, starting with this level of abstraction will help you in the long run.</p>
<p>Secondly, let’s introduce some error handling so our mock will respond properly with a <code>404</code> if a resource is not available:</p>
<ul class="list-styled">
<li>(<a href="https://github.com/danriti/python-mocked-service/commit/40a4ef112e11cba668b4d62f528e98b50d0041cd">Commit</a>) Add error handling if resource is not available.</li>
</ul>
<pre class="wp-code-highlight prettyprint">
(env)[driti@ubuntu]$ python test_github.py
..
----------------------------------------------------------------------
Ran 2 tests in 0.011s

OK
</pre>
<p>Now I can rest easy, knowing that I have created a realistic, reusable and easy to maintain code base for mocking my dependency on GitHub!</p>
<h2>Conclusion</h2>
<p>Mocking external services can get complicated, fast. In this article, we’ve only covered the handling of GET requests (i.e. reading test fixtures), so it’s important to note that complexity may increase as you introduce mocking of POST, PUT, and DELETE requests.</p>
<p>However complex, I hope I have demonstrated the value to your test suite of using a structured and well organized approach when creating mocks for external services. Not only will your test suite improve in speed, but you’ll create a set of reusable mocks that can be leveraged by existing and future tests.</p>
<p>As a follow up, I highly encourage you to watch the PyCon 2014 talk by <a href="https://twitter.com/durin42">Augie Fackler</a> and <a href="https://plus.google.com/+NathanielManista">Nathaniel Manista</a> titled <a href="http://www.youtube.com/watch?v=Xu5EhKVZdV8">Stop Mocking, Start Testing</a>.</p>
<div id="snippet-box"><p class="snippet-title">Summary</p><div itemscope="" itemtype="http://schema.org/Article"><div class="aio-info"><p class="snippet-label-img">Article Name</p><p class="snippet-data-img"><span itemprop="headline">Faking the Funk: Mocking External Services in Python Tests</span></p><p class="snippet-clear"/><p class="snippet-label-img">Description</p><p class="snippet-data-img"><span itemprop="description">We want to ensure our integration test suite is fast and consistent. Thus, let’s take a look at how we can leverage mocks to create a unit test environment in Python.</span></p><p class="snippet-clear"/><p class="snippet-label-img">Author</p><p class="snippet-data-img" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
							<span itemprop="name">Dan Riti</span>
							</p>
							<p class="snippet-clear"/><meta itemscope="" itemprop="mainEntityOfPage" itemtype="https://schema.org/WebPage" itemid="https://www.appneta.com/blog/python-unit-test-mock/"/><meta itemprop="datePublished" content="2014-07-25T08:00:40+00:00"/><meta itemprop="dateModified" content="2016-02-12T14:53:37+00:00"/></div>
					</div></div><p class="snippet-clear"/><p class="ttr_end"/>

                  

                  
                                    

                                    
                  

                  




                    </div>
              </div></body></html>