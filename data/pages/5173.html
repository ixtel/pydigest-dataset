<html><body><div><div class="post-text" itemprop="text">
<p>The reason behind this is that <code>+=</code> and <code>+</code> calls two different methods of the class, <a href="http://docs.python.org/2/reference/datamodel.html#object.__iadd__" rel="nofollow"><code>__iadd__</code> method</a> and <a href="http://docs.python.org/2/reference/datamodel.html#object.__add__" rel="nofollow"><code>__add__</code> method</a>.</p>

<p>From an API perspective, <strong>iadd</strong> is supposed to be used for modifying mutable objects in place (returning the object which was mutated) whereas <strong>add</strong> should return a new instance of something. For immutable objects, both methods return a new instance, but <strong>iadd</strong> will put the new instance in the current namespace with the same name that the old instance had. This is why</p>

<pre><code>i = 1
i += 1
</code></pre>

<p>seems to increment i. In reality, you get a new integer and assign it "on top of" i -- losing one reference to the old integer. In this case, i += 1 is exactly the same as i = i + 1. But, with most mutable objects, it's a different story:</p>

<p>As a concrete example:</p>

<pre><code>a = [1, 2, 3]
b = a
b += [1, 2, 3]
print a  #[1, 2, 3, 1, 2, 3]
print b  #[1, 2, 3, 1, 2, 3]
</code></pre>

<p>compared to:</p>

<pre><code>a = [1, 2, 3]
b = a
b = b + [1, 2, 3]
print a #[1, 2, 3]
print b #[1, 2, 3, 1, 2, 3]
</code></pre>

<p>notice how in the first example, since b and a reference the same object, when I use += on b, it actually changes b (and a sees that change too -- After all, it's referencing the same list). In the second case however, when I do b = b + [1, 2, 3], this takes the list that b is referencing and concatenates it with a new list [1, 2, 3]. It then stores the concatenated list in the current namespace as b -- With no regard for what b was the line before.</p>
    </div>
    </div></body></html>