<html><body><div><div class="post-body" id="post_body_869546">
<h1>Introduction:</h1><p>FuzzyFinder is a popular feature available in decent editors to open files. The idea is to start typing partial strings from the full path and the list of suggestions will be narrowed down to match the desired file. </p><p>Examples: </p><p>Vim (Ctrl-P)</p><p>        </p>
<p>Sublime Text (Cmd-P)</p><p>        </p>
<p>This is an extremely useful feature and it's quite easy to implement.</p><h1>Problem Statement:</h1><p>We have a collection of strings (filenames). We're trying to filter down that collection based on user input. The user input can be partial strings from the filename. Let's walk this through with an example. Here is a collection of filenames:</p><p/><p>When the user types 'djm' we are supposed to match '<b>dj</b>ango_<b>m</b>igrations.py' and '<b>dj</b>ango_ad<b>m</b>in_log.py'. The simplest route to achieve this is to use regular expressions. </p><h1>Solutions:</h1><h3>Naive Regex Matching:</h3><p>Convert 'djm' into 'd.*j.*m' and try to match this regex against every item in the list. Items that match are the possible candidates.</p><p/><p>This got us the desired results for input 'djm'. But the suggestions are not ranked in any particular order.</p><p>In fact, for the second example with user input 'mig' the best possible suggestion 'migrations.py' was listed as the last item in the result.</p><h3>Ranking based on match position:</h3><p>We can rank the results based on the position of the first occurrence of the matching character. For user input 'mig' the position of the matching characters are as follows:</p><p/><p>Here's the code:</p><p/><p>We made the list of suggestions to be tuples where the first item is the position of the match and second item is the matching filename. When this list is sorted, python will sort them based on the first item in tuple and use the second item as a tie breaker. On line 14 we use a list comprehension to iterate over the sorted list of tuples and extract just the second item which is the file name we're interested in.</p><p>This got us close to the end result, but as shown in the example, it's not perfect. We see 'main_generator.py' as the first suggestion, but the user wanted 'migration.py'.</p><h3><b>Ranking based on compact match:</b></h3><p>When a user starts typing a partial string they will continue to type consecutive letters in a effort to find the exact match. When someone types 'mig' they are looking for '<b>mig</b>rations.py' or 'django_<b>mig</b>rations.py' not 'main_generator.py'. The key here is to find the most compact match for the user input.</p><p>Once again this is trivial to do in python. When we match a string against a regular expression, the matched string is stored in the match.group(). </p><p>For example, if the input is 'mig', the matching group from the '<a href="https://gist.github.com/amjith/f0d4fa57e6e47d0e1e9c#file-file_list" target="_blank">collection</a>' defined earlier is as follows:</p><p/><p>We can use the length of the captured group as our primary rank and use the starting position as our secondary rank. To do that we add the len(match.group()) as the first item in the tuple, match.start() as the second item in the tuple and the filename itself as the third item in the tuple. Python will sort this list based on first item in the tuple (primary rank), second item as tie-breaker (secondary rank) and the third item as the fall back tie-breaker. </p><p/><p>This produces the desired behavior for our input. We're not quite done yet.</p><h3>Non-Greedy Matching</h3><p>There is one more subtle corner case that was caught by <a href="https://github.com/drocco007" target="_blank">Daniel Rocco</a>. Consider these two items in the collection ['api_user', 'user_group']. When you enter the word 'user' the ideal suggestion should be ['user_group', 'api_user']. But the actual result is:</p><p/><p>Looking at this output, you'll notice that <code>api_user</code> appears before <code>user_group</code>. Digging in a little, it turns out the search <code>user</code> expands to <code>u.*s.*e.*r</code>; notice that <code>user_group</code> has <em>two</em> <code>r</code>s, so the pattern matches <code>user_gr</code> instead of the expected <code>user</code>. The longer match length forces the ranking of this match down, which again seems counterintuitive. This is easy to change by using the non-greedy version of the regex (<code>.*?</code> instead of <code>.*</code>) on line 4. <br/></p><p/><p>Now that works for all the cases we've outlines. We've just implemented a fuzzy finder in 10 lines of code.</p><h1>Conclusion:</h1><p>That was the design process for implementing fuzzy matching for my side project <a href="https://github.com/dbcli/pgcli/blob/amjith/fuzzy_completion/pgcli/pgcompleter.py#L198..L204" target="_blank">pgcli</a>, which is a repl for Postgresql that can do auto-completion. </p><p>        </p>
<p>I've extracted <a href="https://github.com/amjith/fuzzyfinder" target="_blank">fuzzyfinder</a> into a stand-alone python package. You can install it via 'pip install fuzzyfinder' and use it in your projects.</p><p>Thanks to <a href="https://github.com/zoltu" target="_blank">Micah Zoltu</a> and <a href="https://github.com/drocco007" target="_blank">Daniel Rocco</a> for reviewing the algorithm and fixing the corner cases.</p><p>If you found this interesting, you should follow me on <a href="https://twitter.com/amjithr" target="_blank">twitter</a>. </p><h3>Epilogue:</h3><p>When I first started looking into fuzzy matching in python, I encountered this excellent library called <a href="https://github.com/seatgeek/fuzzywuzzy" target="_blank">fuzzywuzzy</a>. But the fuzzy matching done by that library is a different kind. It uses <a href="https://en.wikipedia.org/wiki/Levenshtein_distance" target="_blank">levenshtein distance</a> to find the closest matching string from a collection. Which is a great technique for auto-correction against spelling errors but it doesn't produce the desired results for matching long names from partial sub-strings.</p>
</div>

</div></body></html>