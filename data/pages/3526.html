<html><body><div><div class="content">
      
        <h1 class="content-title">Querying the top N objects per group with Peewee ORM</h1>
      
      
      
  <div class="post-info"><p>
    
    
      March 03, 2015 00:39
      </p><span class="separator">/</span>
      <a href="#comments">1 comments</a>
      <span class="separator">/</span>
      
        <a href="/blog/tags/peewee/">peewee</a>
      
        <a href="/blog/tags/python/">python</a>
      
        <a href="/blog/tags/sql/">sql</a>
      
    
  </div>
  
  
    <p><a href="http://media.charlesleifer.com/blog/photos/p1425417194.66.png" title="photos/p1425417194.66.png"><img alt="photos/p1425417194.66.png" class="img-responsive" src="http://m.charlesleifer.com/t/800x-/blog/photos/p1425417194.66.png?key=arpKpoMzygu5eyHnw8nSeA"/></a></p>
<p>This post is a follow-up to my post about <a href="/blog/techniques-for-querying-lists-of-objects-and-determining-the-top-related-item/">querying the top related item by group</a>. In this post we'll go over ways to retrieve the top <em>N</em> related objects by group using the <a href="http://docs.peewee-orm.com">Peewee ORM</a>. I've also presented the SQL and the underlying ideas behind the queries, so you can translate them to whatever ORM / query layer you are using.</p>
<p>Retrieving the top N per group is a pretty common task, for example:</p>
<ul>
<li>Display my followers and their 10 most recent tweets.</li>
<li>In each of my inboxes, list the 5 most recent unread messages.</li>
<li>List the sections of the news site and the three latest stories in each.</li>
<li>List the five best sales in each department.</li>
</ul>
<p>In this post we'll discuss the following types of solutions:</p>
<ul>
<li>Solutions involving <code>COUNT()</code></li>
<li>Solutions involving <code>LIMIT</code></li>
<li>Window functions</li>
<li>Postgresql lateral joins</li>
</ul>
<p>For the purposes of this post, and for continuity with last week's post, the examples will focus on displaying a list of users and their three most-recent posts. Here are the database models we'll be using:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">from</span> <span class="nn">peewee</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">SqliteDatabase</span><span class="p">(</span><span class="s1">':memory:'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">BaseModel</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">database</span> <span class="o">=</span> <span class="n">db</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">CharField</span><span class="p">(</span><span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Post</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">ForeignKeyField</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">related_name</span><span class="o">=</span><span class="s1">'posts'</span><span class="p">)</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">TextField</span><span class="p">()</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">DateTimeField</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
<h3>The naive implementation</h3>
<p>The simplest way to implement this is by executing an additional query for each <code>User</code>. To do this in <em>O(n)</em> queries, we might write:</p>
<div class="highlight"><pre><span class="k">for</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">User</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">username</span><span class="p">):</span>
    <span class="n">recent_posts</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">posts</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Post</span><span class="o">.</span><span class="n">timestamp</span><span class="o">.</span><span class="n">desc</span><span class="p">())</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">print</span> <span class="s1">'Recent posts by'</span><span class="p">,</span> <span class="n">user</span><span class="o">.</span><span class="n">username</span>
    <span class="k">for</span> <span class="n">post</span> <span class="ow">in</span> <span class="n">recent_posts</span><span class="p">:</span>
        <span class="k">print</span> <span class="s1">'*'</span><span class="p">,</span> <span class="n">post</span><span class="o">.</span><span class="n">content</span>
</pre></div>
<p>This approach has the benefit of simplicity, and works fine for smaller applications or situations where the list of users is not very large. Since we have an index on the <code>Post.timestamp</code> and <code>Post.user</code> fields, retrieving the latest posts for a user is quite fast.</p>
<p>As we'll see when we start comparing the execution times of various queries, it may surprise you that with SQLite the naive <em>O(n)</em> approach may actually be a very good choice! However, with a more sophisticated database like Postgresql, or a database that is accessed over a network, the <em>O(n)</em> approach is not likely to be the best choice.</p>
<h2>Single query solutions</h2>
<p>In the previous post we were focused only on retrieving the single most-recent <code>Post</code> by a given <code>User</code>. Because we only needed one <code>Post</code>, we could use the <code>Max()</code> aggregate and other tricks like <code>NOT EXISTS</code>. The more general <em>most recent N</em> query requires a different approach.</p>
<h3>Counting solutions</h3>
<p>The first approach I'd like to discuss uses counting to retrieve the most recent posts. Our query will express the following statement:</p>
<blockquote>
<p>Get all the posts where there are less than <em>N</em> posts with a higher timestamp.</p>
</blockquote>
<p>This is a sort of roundabout way of getting to a solution, but the query is not too complex so I thought it would be a good one to start with. What we will do is use a subquery to determine the number of posts with a higher (more recent) timestamp than the post we are currently examining, and throw out any where that count exceeds <em>N</em>. Here is how we might write it with Peewee:</p>
<div class="highlight"><pre><span class="n">PostAlias</span> <span class="o">=</span> <span class="n">Post</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>

<span class="c1"># Create a correlated subquery that calculates the number of</span>
<span class="c1"># posts with a higher (newer) timestamp than the post we're</span>
<span class="c1"># looking at in the outer query.</span>
<span class="n">subquery</span> <span class="o">=</span> <span class="p">(</span><span class="n">PostAlias</span>
            <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">COUNT</span><span class="p">(</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
            <span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="p">(</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&gt;=</span> <span class="n">Post</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span> <span class="o">&amp;</span>
                <span class="p">(</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">user</span> <span class="o">==</span> <span class="n">Post</span><span class="o">.</span><span class="n">user</span><span class="p">)))</span>

<span class="c1"># Wrap the subquery and filter on the count.</span>
<span class="n">query</span> <span class="o">=</span> <span class="p">(</span><span class="n">Post</span>
         <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">Post</span><span class="p">,</span> <span class="n">User</span><span class="p">)</span>
         <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
         <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subquery</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
<p>The resulting SQL query is:</p>
<div class="highlight"><pre><span class="k">SELECT</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="n">content</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="k">timestamp</span><span class="p">,</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">t2</span><span class="p">.</span><span class="n">username</span>
<span class="k">FROM</span> <span class="n">post</span> <span class="k">AS</span> <span class="n">t1</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="k">user</span> <span class="k">AS</span> <span class="n">t2</span> <span class="k">ON</span> <span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
<span class="k">WHERE</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">t3</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
    <span class="k">FROM</span> <span class="n">post</span> <span class="k">AS</span> <span class="n">t3</span>
    <span class="k">WHERE</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">t3</span><span class="p">.</span><span class="k">timestamp</span> <span class="o">&gt;=</span> <span class="n">t1</span><span class="p">.</span><span class="k">timestamp</span><span class="p">)</span> <span class="k">AND</span>
        <span class="p">(</span><span class="n">t3</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">t1</span><span class="p">.</span><span class="n">user_id</span><span class="p">))</span>
<span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span>
</pre></div>
<p>As you might imagine, this query is probably not very efficient since the subquery is correlated and must be calculated separately for each post in the outer query.</p>
<p>Another way we can express similar logic is by doing a self-join on <code>Post</code> and using a combination of join predicates and the SQL <code>HAVING</code> clause to restrict the result set. This query is also fairly simple and will work on both Postgresql and SQLite.</p>
<div class="highlight"><pre><span class="n">PostAlias</span> <span class="o">=</span> <span class="n">Post</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>

<span class="c1"># Use a self-join and join predicates to count the number of</span>
<span class="c1"># newer posts.</span>
<span class="n">query</span> <span class="o">=</span> <span class="p">(</span><span class="n">Post</span>
         <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">Post</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">Post</span><span class="o">.</span><span class="n">content</span><span class="p">,</span> <span class="n">Post</span><span class="o">.</span><span class="n">user</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">username</span><span class="p">)</span>
         <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
         <span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">Post</span><span class="p">)</span>
         <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">PostAlias</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">(</span>
             <span class="p">(</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">user</span> <span class="o">==</span> <span class="n">Post</span><span class="o">.</span><span class="n">user</span><span class="p">)</span> <span class="o">&amp;</span>
             <span class="p">(</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&gt;=</span> <span class="n">Post</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)))</span>
         <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">Post</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">Post</span><span class="o">.</span><span class="n">content</span><span class="p">,</span> <span class="n">Post</span><span class="o">.</span><span class="n">user</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">username</span><span class="p">)</span>
         <span class="o">.</span><span class="n">having</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">COUNT</span><span class="p">(</span><span class="n">Post</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
<p>Here is the corresponding SQL query:</p>
<div class="highlight"><pre><span class="k">SELECT</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">t2</span><span class="p">.</span><span class="n">username</span>
<span class="k">FROM</span> <span class="n">post</span> <span class="k">AS</span> <span class="n">t1</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="k">user</span> <span class="k">AS</span> <span class="n">t2</span> <span class="k">ON</span> <span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">post</span> <span class="k">AS</span> <span class="n">t3</span> <span class="k">ON</span> <span class="p">(</span>
    <span class="p">(</span><span class="n">t3</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">t1</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span> <span class="k">AND</span>
    <span class="p">(</span><span class="n">t3</span><span class="p">.</span><span class="k">timestamp</span> <span class="o">&gt;=</span> <span class="n">t1</span><span class="p">.</span><span class="k">timestamp</span><span class="p">))</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="n">content</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">t2</span><span class="p">.</span><span class="n">username</span>
<span class="k">HAVING</span> <span class="p">(</span><span class="k">COUNT</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
<p>Despite the simplicity of the query, the self-join ends up being pretty expensive and gives the query a pretty bad run-time on both SQLite and Postgresql.</p>
<p>I made one final attempt at the <em>COUNT</em> approach based on some SQL I saw on StackOverflow. This query is similar to the previous query, in that we are using a self-join and <code>HAVING</code> clause to find the most recent posts per user. The difference is that we'll evaluate the <code>Post</code> portion in a subquery, and our outer query will select from the <code>User</code> table. Like the previous two queries, this query also ended up having a bad run-time:</p>
<div class="highlight"><pre><span class="n">PostAlias</span> <span class="o">=</span> <span class="n">Post</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>

<span class="c1"># Similar to previous, we are using join predicates and counting to</span>
<span class="c1"># determine the number of newer posts for a given post.</span>
<span class="n">subquery</span> <span class="o">=</span> <span class="p">(</span><span class="n">Post</span>
            <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">Post</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">Post</span><span class="o">.</span><span class="n">content</span><span class="p">,</span> <span class="n">Post</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
            <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">PostAlias</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">(</span>
                <span class="p">(</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">user</span> <span class="o">==</span> <span class="n">Post</span><span class="o">.</span><span class="n">user</span><span class="p">)</span> <span class="o">&amp;</span>
                <span class="p">(</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&gt;=</span> <span class="n">Post</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)))</span>
            <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">Post</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">Post</span><span class="o">.</span><span class="n">content</span><span class="p">,</span> <span class="n">Post</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
            <span class="o">.</span><span class="n">having</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">COUNT</span><span class="p">(</span><span class="n">Post</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span>
            <span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">'sq'</span><span class="p">))</span>

<span class="n">query</span> <span class="o">=</span> <span class="p">(</span><span class="n">User</span>
         <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">subquery</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
         <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subquery</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">subquery</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">))</span>
         <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">username</span><span class="p">,</span> <span class="n">subquery</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">content</span><span class="p">))</span>
</pre></div>
<p>I'll omit the corresponding SQL for brevity and because the query did not really show much improvement over the previous examples.</p>
<h3>Trying LIMIT instead of COUNT</h3>
<p>After giving up on trying to use <code>COUNT()</code>, I decided to try a different approach using subqueries and <code>LIMIT</code>. With this query, we'll create a subquery for each user which retrieves that user's posts ordered newest-to-oldest. A <code>LIMIT 3</code> is applied to the subquery to ensure that a maximum of three posts are returned for each user. Then, in our outer query, we'll restrict the result set to those posts that correspond to a row in the correlated subquery.</p>
<div class="highlight"><pre><span class="n">PostAlias</span> <span class="o">=</span> <span class="n">Post</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>

<span class="c1"># The subquery here will calculate, for the user who created the</span>
<span class="c1"># post in the outer loop, the three newest posts. The expression</span>
<span class="c1"># will evaluate to `True` if the outer-loop post is in the set of</span>
<span class="c1"># posts represented by the inner query.</span>
<span class="n">query</span> <span class="o">=</span> <span class="p">(</span><span class="n">Post</span>
         <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">Post</span><span class="p">,</span> <span class="n">User</span><span class="p">)</span>
         <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
         <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Post</span><span class="o">.</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="p">(</span>
             <span class="n">PostAlias</span>
             <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
             <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">user</span> <span class="o">==</span> <span class="n">Post</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
             <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">timestamp</span><span class="o">.</span><span class="n">desc</span><span class="p">())</span>
             <span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="mi">3</span><span class="p">))))</span>
</pre></div>
<p>I think the corresponding SQL is a bit easier to read:</p>
<div class="highlight"><pre><span class="k">SELECT</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="n">content</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="k">timestamp</span><span class="p">,</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">t2</span><span class="p">.</span><span class="n">username</span>
<span class="k">FROM</span> <span class="n">post</span> <span class="k">AS</span> <span class="n">t1</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="k">user</span> <span class="k">AS</span> <span class="n">t2</span> <span class="k">ON</span> <span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
<span class="k">WHERE</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">t3</span><span class="p">.</span><span class="n">id</span>
    <span class="k">FROM</span> <span class="n">post</span> <span class="k">AS</span> <span class="n">t3</span>
    <span class="k">WHERE</span> <span class="p">(</span><span class="n">t3</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">t1</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span>
    <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">t3</span><span class="p">.</span><span class="k">timestamp</span> <span class="k">DESC</span>
    <span class="k">LIMIT</span> <span class="mi">3</span>
<span class="p">)</span>
</pre></div>
<p>As with our previous attempts using <code>COUNT()</code>, these queries performed badly on both SQLite and Postgresql.</p>
<h3>Window functions to the rescue</h3>
<p>The final queries we will look at use <a href="http://www.postgresql.org/docs/9.1/static/tutorial-window.html">window functions</a> to calculate aggregates over <em>windows</em> of rows. For our use-case, these windows will be the set of posts created by a given user. We will be calculating the ordered <em>rank</em> of these posts and filtering so that we only retrieve the three newest posts by user.</p>
<p>The good news is that these queries were by far the most performant! The downside is that at the time of writing, SQLite does not support window functions, so they only work if you're using Postgresql.</p>
<p>Window functions are great, but there are some restrictions on how and where you can use them to filter result-sets, due to the order in which they're evaluated. To get them working I had to use some small workarounds.</p>
<p>The first example works by calculating the ranking of posts per user as a separate table, then uses join predicates to join the ranked posts to the canonical list of posts and users. Here is how it is expressed with Peewee:</p>
<div class="highlight"><pre><span class="n">PostAlias</span> <span class="o">=</span> <span class="n">Post</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>

<span class="c1"># Calculate the ranked posts per user as a separate "table".</span>
<span class="n">subquery</span> <span class="o">=</span> <span class="p">(</span><span class="n">PostAlias</span>
            <span class="o">.</span><span class="n">select</span><span class="p">(</span>
                <span class="n">PostAlias</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                <span class="n">fn</span><span class="o">.</span><span class="n">RANK</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span>
                    <span class="n">partition_by</span><span class="o">=</span><span class="p">[</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">user</span><span class="p">],</span>
                    <span class="n">order_by</span><span class="o">=</span><span class="p">[</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">timestamp</span><span class="o">.</span><span class="n">desc</span><span class="p">()])</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">'rnk'</span><span class="p">))</span>
            <span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">'subq'</span><span class="p">))</span>

<span class="c1"># Join the ranked posts on the set of all posts, ensuring that we</span>
<span class="c1"># only get posts that are ranked less-than or equal-to *N*.</span>
<span class="n">query</span> <span class="o">=</span> <span class="p">(</span><span class="n">Post</span>
         <span class="o">.</span><span class="n">select</span><span class="p">(</span>
             <span class="n">Post</span><span class="p">,</span>
             <span class="n">User</span><span class="p">)</span>
         <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
         <span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">Post</span><span class="p">)</span>
         <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subquery</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">(</span>
             <span class="p">(</span><span class="n">subquery</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">Post</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="o">&amp;</span>
             <span class="p">(</span><span class="n">subquery</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">rnk</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">))))</span>
</pre></div>
<p>This query corresponds to the following SQL query:</p>
<div class="highlight"><pre><span class="k">SELECT</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="n">content</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="k">timestamp</span><span class="p">,</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">t2</span><span class="p">.</span><span class="n">username</span>
<span class="k">FROM</span> <span class="n">post</span> <span class="k">AS</span> <span class="n">t1</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="k">user</span> <span class="k">AS</span> <span class="n">t2</span> <span class="k">ON</span> <span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">t4</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
        <span class="n">RANK</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span>
            <span class="n">PARTITION</span> <span class="k">BY</span> <span class="n">t4</span><span class="p">.</span><span class="n">user_id</span>
            <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">t4</span><span class="p">.</span><span class="k">timestamp</span> <span class="k">DESC</span>
        <span class="p">)</span> <span class="k">AS</span> <span class="n">rnk</span>
    <span class="k">FROM</span> <span class="n">post</span> <span class="k">AS</span> <span class="n">t4</span>
<span class="p">)</span> <span class="k">AS</span> <span class="n">subq</span> <span class="k">ON</span> <span class="p">(</span>
    <span class="p">(</span><span class="n">subq</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">AND</span>
    <span class="p">(</span><span class="n">subq</span><span class="p">.</span><span class="n">rnk</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
<p>Another way we can express the same query is by wrapping the ranked set of posts in an outer query and performing the filtering in the outer query. Here is how to do this with peewee:</p>
<div class="highlight"><pre><span class="n">PostAlias</span> <span class="o">=</span> <span class="n">Post</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>

<span class="c1"># The subquery will select the relevant data from the Post and</span>
<span class="c1"># User table, as well as ranking the posts by user from newest</span>
<span class="c1"># to oldest.</span>
<span class="n">subquery</span> <span class="o">=</span> <span class="p">(</span><span class="n">PostAlias</span>
            <span class="o">.</span><span class="n">select</span><span class="p">(</span>
                <span class="n">PostAlias</span><span class="o">.</span><span class="n">content</span><span class="p">,</span>
                <span class="n">User</span><span class="o">.</span><span class="n">username</span><span class="p">,</span>
                <span class="n">fn</span><span class="o">.</span><span class="n">RANK</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span>
                    <span class="n">partition_by</span><span class="o">=</span><span class="p">[</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">user</span><span class="p">],</span>
                    <span class="n">order_by</span><span class="o">=</span><span class="p">[</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">timestamp</span><span class="o">.</span><span class="n">desc</span><span class="p">()])</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">'rnk'</span><span class="p">))</span>
            <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">(</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">user</span> <span class="o">==</span> <span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
            <span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">'subq'</span><span class="p">))</span>

<span class="c1"># Since we can't filter on the rank, we are wrapping it in a query</span>
<span class="c1"># and performing the filtering in the outer query.</span>
<span class="n">query</span> <span class="o">=</span> <span class="p">(</span><span class="n">Post</span>
         <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">subquery</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">content</span><span class="p">,</span> <span class="n">subquery</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">username</span><span class="p">)</span>
         <span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="n">subquery</span><span class="p">)</span>
         <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subquery</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">rnk</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
<p>Almost all the logic for selecting and joining occurs in the subquery. The outer query is only responsible for filtering the ranked results.</p>
<p>Here is the resulting SQL:</p>
<div class="highlight"><pre><span class="k">SELECT</span> <span class="n">subq</span><span class="p">.</span><span class="n">content</span><span class="p">,</span> <span class="n">subq</span><span class="p">.</span><span class="n">username</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">t2</span><span class="p">.</span><span class="n">content</span><span class="p">,</span>
        <span class="n">t3</span><span class="p">.</span><span class="n">username</span><span class="p">,</span>
        <span class="n">RANK</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span>
            <span class="n">PARTITION</span> <span class="k">BY</span> <span class="n">t2</span><span class="p">.</span><span class="n">user_id</span>
            <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">t2</span><span class="p">.</span><span class="k">timestamp</span> <span class="k">DESC</span>
        <span class="p">)</span> <span class="k">AS</span> <span class="n">rnk</span>
    <span class="k">FROM</span> <span class="n">post</span> <span class="k">AS</span> <span class="n">t2</span>
    <span class="k">INNER</span> <span class="k">JOIN</span> <span class="k">user</span> <span class="k">AS</span> <span class="n">t3</span> <span class="k">ON</span> <span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">t3</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span> <span class="k">AS</span> <span class="n">subq</span>
<span class="k">WHERE</span> <span class="p">(</span><span class="n">subq</span><span class="p">.</span><span class="n">rnk</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
<p>Both of these window queries had similar run-times, but the second query (the wrapped subquery) was faster overall.</p>
<h3>Lateral Joins</h3>
<p>If you're using Postgresql 9.3 or newer, there's a cool feature called <a href="http://blog.heapanalytics.com/postgresqls-powerful-new-join-type-lateral/">lateral joins</a> that seems to have been designed exactly for this type of query. Lateral joins act like <em>for each</em> loops, where each joined query can be correlated with data from previously-joined queries. I stumbled on these late into writing the post so they aren't included in the performance section below, but I believe they are a great option if you're using Postgresql.</p>
<p>Here is how you would express the top posts query using lateral joins:</p>
<div class="highlight"><pre><span class="c1"># We'll reference `Post` twice, so keep an alias handy.</span>
<span class="n">PostAlias</span> <span class="o">=</span> <span class="n">Post</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>

<span class="c1"># Just like our O(n) example, the outer loop will be iterating</span>
<span class="c1"># over the users whose posts we are trying to find.</span>
<span class="n">user_query</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">username</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">'uq'</span><span class="p">)</span>

<span class="c1"># The inner loop will select posts and is correlated to the</span>
<span class="c1"># outer loop via the WHERE clause. Note that we are using a</span>
<span class="c1"># LIMIT clause!</span>
<span class="n">post_query</span> <span class="o">=</span> <span class="p">(</span><span class="n">PostAlias</span>
              <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">content</span><span class="p">,</span> <span class="n">PostAlias</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
              <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">user</span> <span class="o">==</span> <span class="n">user_query</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
              <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">PostAlias</span><span class="o">.</span><span class="n">timestamp</span><span class="o">.</span><span class="n">desc</span><span class="p">())</span>
              <span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
              <span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">'pq'</span><span class="p">))</span>

<span class="c1"># Now we join the outer and inner queries using the LEFT LATERAL</span>
<span class="c1"># JOIN. The join predicate is *ON TRUE*, since we're effectively</span>
<span class="c1"># joining in the post subquery's WHERE clause.</span>
<span class="n">join_clause</span> <span class="o">=</span> <span class="n">Clause</span><span class="p">(</span>
    <span class="n">user_query</span><span class="p">,</span>
    <span class="n">SQL</span><span class="p">(</span><span class="s1">'LEFT JOIN LATERAL'</span><span class="p">),</span>
    <span class="n">post_query</span><span class="p">,</span>
    <span class="n">SQL</span><span class="p">(</span><span class="s1">'ON </span><span class="si">%s</span><span class="s1">'</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span>

<span class="c1"># Finally, we'll wrap these up and SELECT from the result.</span>
<span class="n">query</span> <span class="o">=</span> <span class="p">(</span><span class="n">Post</span>
         <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">SQL</span><span class="p">(</span><span class="s1">'*'</span><span class="p">))</span>
         <span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="n">join_clause</span><span class="p">))</span>
</pre></div>
<p>The corresponding SQL looks like this:</p>
<div class="highlight"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">t2</span><span class="p">.</span><span class="n">username</span> <span class="k">FROM</span> <span class="k">user</span> <span class="k">AS</span> <span class="n">t2</span><span class="p">)</span> <span class="k">AS</span> <span class="n">uq</span> 
  <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="k">LATERAL</span> 
  <span class="p">(</span><span class="k">SELECT</span> <span class="n">t2</span><span class="p">.</span><span class="n">content</span><span class="p">,</span> <span class="n">t2</span><span class="p">.</span><span class="k">timestamp</span> 
   <span class="k">FROM</span> <span class="n">post</span> <span class="k">AS</span> <span class="n">t2</span> 
   <span class="k">WHERE</span> <span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">uq</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> 
   <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">t2</span><span class="p">.</span><span class="k">timestamp</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">3</span><span class="p">)</span> 
  <span class="k">AS</span> <span class="n">pq</span> <span class="k">ON</span> <span class="k">true</span>
</pre></div>
<p>It's definitely a bit unusual, but in my brief testing it seemed quite performant and looks like a viable solution to this type of problem. For more information, <a href="https://wiki.postgresql.org/wiki/What's_new_in_PostgreSQL_9.3#LATERAL_JOIN">here are the Postgresql 9.3 release notes</a>.</p>
<h2>Measuring performance</h2>
<p>As always, these results are not indicative of some absolute truth and you should always profile your code before and after attempting any optimizations. Your results may differ quite a bit from the results presented below, as they will be very dependent on the size and shape of your data, and the configuration and choice of database engine.</p>
<p>That being said, the results from my testing were pretty clear. If you're using Postgresql, window functions are going to be a lot faster and more scalable than the alternatives presented in this post. If you're using SQLite, then the results are a bit disconcerting as the most reliable performance can be achieved using the naive <em>O(n)</em> queries approach. The caveat with SQLite is that I was using an in-memory SQLite database for the benchmarks, and an on-disk database may have very different performance.</p>
<p>Below are some graphs showing the run-times of these queries with different ratios of users to posts.</p>
<h4>SQLite</h4>
<p><a href="http://media.charlesleifer.com/blog/photos/p1425355725.87.png" title="photos/p1425355725.87.png"><img alt="photos/p1425355725.87.png" class="img-responsive" src="http://m.charlesleifer.com/t/800x-/blog/photos/p1425355725.87.png?key=SXVdMFpJECVUmgGj8G27DQ"/></a></p>
<p><a href="http://media.charlesleifer.com/blog/photos/p1425355734.24.png" title="photos/p1425355734.24.png"><img alt="photos/p1425355734.24.png" class="img-responsive" src="http://m.charlesleifer.com/t/800x-/blog/photos/p1425355734.24.png?key=8okhpgHZfPAdxKylseZWAA"/></a></p>
<h4>Postgresql</h4>
<p><a href="http://media.charlesleifer.com/blog/photos/p1425355742.63.png" title="photos/p1425355742.63.png"><img alt="photos/p1425355742.63.png" class="img-responsive" src="http://m.charlesleifer.com/t/800x-/blog/photos/p1425355742.63.png?key=1ukNnj7USrRfB_4hlLsJ1g"/></a></p>
<p><a href="http://media.charlesleifer.com/blog/photos/p1425355750.22.png" title="photos/p1425355750.22.png"><img alt="photos/p1425355750.22.png" class="img-responsive" src="http://m.charlesleifer.com/t/800x-/blog/photos/p1425355750.22.png?key=VYz5vFWxRaP-2m6yVJ4dRw"/></a></p>
<h2>Thanks for reading</h2>
<p>Thanks for taking the time to read this post, I hope you found it helpful. Please feel free to <a href="#comments">make a comment</a> if you have any questions, comments, or suggestions. I'd really like to hear about other approaches for solving this type of problem with SQL, so please don't be shy!</p>
<h3>Links</h3>

  
  

  
  
  


<hr/>

  <p>Commenting has been closed, but please feel free to <a href="/contact/">contact me</a></p>


    </div>

    </div></body></html>