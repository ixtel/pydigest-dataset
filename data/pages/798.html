<html><body><div><div id="articleText">
                    <p id="articleLongDescription">Stephen B. Morris digs deeper into the terrain between C++ and Python, both of which provide powerful exception-management facilities. Later maintainers of your code will thank you for implementing decent exception logic! In addition to the maintenance advantages, careful use of exception handlers can facilitate effective integration between Python and C++.</p>
                    <p id="articleDescription"/>

                    <a class="relatedBookLink" href="#">Like this article? We recommend <span class="ss-icon"></span></a>
                    
                    

                <h2>The Importance of Handling Exceptions</h2>
<p>Exception handling is an area that programmers seem to either love or hate. I've even been surprised a few times by seeing code that swallows all exceptions, without exception! This is a lazy and hazardous way of implementing exception handlers, as illustrated in Listing 1.</p>
<h4><em>Listing 1Swallowing all exceptions. Please don't do this at
home—or at work.</em></h4>
<pre>try:
    aFile = open('anyOldFile.txt')
    myString = aFile.readline()
    print('File contents are: ')
    print(myString)
except IOError as e:
    print "I/O error({0}): {1}".format(e.errno, e.strerror)
except:
    print "Unexpected error:", sys.exc_info()[0]
    raise</pre>

<p>Why might the code in Listing 1 be considered bad practice? Well, suppose some truly catastrophic exception occurs; for example, the runtime system runs out of memory. Listing 1 offers no way for the exception handler to cope in a graceful fashion. In other words, the last <tt>except</tt> clause in Listing 1 may be the wrong place to try to handle a more general exception.</p>
<p>Let's improve Listing 1 by simply removing the last <tt>except</tt> clause, as shown in Listing 2.</p>
<h4><em>Listing 2No longer swallowing all exceptions (less is
more).</em></h4>
<pre>try:
    aFile = open('anyOldFile.txt')
    myString = aFile.readline()
    print('File contents are: ')
    print(myString)
except IOError as e:
    print "I/O error({0}): {1}".format(e.errno, e.strerror)</pre>
<p>Listing 2 improves on Listing 1 by doing just one thing and doing it well; it handles the exception type <tt>IOError</tt>. If the code throws an <tt>IOError</tt> exception, the appropriate error details will be printed. An example is what occurs if the file in question doesn't exist:</p>
<pre>I/O error(2): No such file or directory</pre>
<p>What other exceptions might occur in Listing 2, apart from <tt>IOError</tt>? Well, any such exceptions must then be handled at a higher level; for example, in the code that calls Listing 2. On a deeper level, this can be considered an example of the <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">Separation of Concerns design pattern</a>. In this case, Listing 2 does some file I/O and handles any associated exceptions. Any other exceptions are the responsibility of the code that calls Listing 2. The exception-specific concerns have thereby been separated, as indicated in Listing 3.</p>
<h4><em>Listing 3Our exception-handling hierarchy.</em></h4>
<pre>Listing 2 code -----------&gt; Handles IOError only
Listing 2 caller ----------&gt; Handles all other exceptions</pre>
<p>Viewed as a separation of concerns, the exception management strategy is distributed across the calling chain. The key requirement is to allocate only certain exception-handling responsibilities to certain code. This more sophisticated approach illustrates why the code in Listing 1 isn't very good, but is all too common.</p>
<p>Why isn't exception management more popular among programmers? Perhaps because it's not glamorous. Why think about possible errors in a completed piece of code, when you can just move onto the next coding task? Here's why: If you think a piece of code can't possibly fall foul of an exception state, you're probably wrong!</p>
<p>Writing robust exception-handlers is an opportunity to make your code stronger and more resilient. To illustrate this point, let's look again at Listing 2. Notice anything else missing from this listing? What about closing the file that we've just opened? The <tt>finally</tt> clause provides a nice mechanism for fulfilling this requirement. Let's do this with a little refactoring, as shown in Listing 4.</p>
<h4><em>Listing 4Better handling of allocated resources.</em></h4>
<pre>aFile = None

try:
    aFile = open('anyOldFile.txt')
    myString = aFile.readline()
    print('File contents are: ')
    print(myString)
except IOError as e:
    print('I/O error({0}): {1}'.format(e.errno, e.strerror))
else:
    print 'No exception'
finally:
    if (aFile != None):
        print('File is being closed')
        aFile.close()
    else:
        print('File already closed')</pre>
<p>The extra lines of code at the end of Listing 4 provide a degree of enhanced robustness because we're giving back our allocated file resource. With the file closed in the <tt>finally</tt> clause, we guarantee this beneficial outcome, and we avoid the problem of our code leaving files open unnecessarily. We make our code far more robust by using a language feature, and we avoid the need for complicated and error-prone mechanisms such as state variables.</p>

<h3><strong>Running Python Example Code</strong></h3>
<p>One of Python's many merits is its lightweight nature. It's pretty straightforward to get started coding in Python—no need to install (at least initially) and learn to use complex IDEs such as Eclipse. Instead, you can simply run up a Python console. In Linux, this is as simple as running the <tt>python</tt> command, which results in something similar to Listing 5.</p>
<h4><em>Listing 5The Python console.</em></h4>
<pre>Python 2.7.3 (default, Sep 26 2013, 20:08:41) 

[GCC 4.6.3] on linux2

Type "help", "copyright", "credits" or "license" for more information.

&gt;&gt;&gt; 

Here's how to get the Python host version:
&gt;&gt;&gt; import sys

&gt;&gt;&gt; sys.version

'2.7.3 (default, Sep 26 2013, 20:08:41) \n[GCC 4.6.3]'

&gt;&gt;&gt; </pre>
<p>Obviously, as code examples become more complex, copying-and-pasting the code into a console gets a bit clunky. But the console approach is useful for getting started or for testing code snippets.</p>
<p>So what about C++ exception management?</p>
<h3><strong>Handling Exceptions with C++</strong></h3>
<p>C++ also has a powerful exception-management facility. Listing 6 shows a simple example of C++ exception management. Here I attempt to force a memory-allocation exception called <tt>bad_alloc</tt> by allocating a pathologically large array of integers.</p>
<h4><em>Listing 6C++ exception management.</em></h4>
<pre>#include &lt;iostream&gt;
#include &lt;exception&gt;

using namespace std;

int main () {
      int* myarray = NULL;

      if (myarray) {
            cout &lt;&lt; "Not NULL" &lt;&lt; endl;
      } else {
            cout &lt;&lt; "Is NULL" &lt;&lt; endl;
      }

      try
      {
            int* myarray = new int[1000000000];
      }
      catch (exception&amp; e)
      {
            cout &lt;&lt; "Standard exception: " &lt;&lt; e.what() &lt;&lt; endl;
            if (myarray) {
                  cout &lt;&lt; "Not NULL" &lt;&lt; endl;
            } else {
                  cout &lt;&lt; "Is NULL" &lt;&lt; endl;
            }
      }

      if(myarray) {
            cout &lt;&lt; "Deleting myarray" &lt;&lt; endl;
            delete [] myarray;
      }

      cout &lt;&lt; "Returning" &lt;&lt; endl;

      return 0;
}</pre>
<p>In Listing 6, I've also inserted some code to determine if and when the allocation occurs, via the call to <tt>new()</tt>. Listing 7 shows a run of the code where the exception occurs.</p>
<h4><em>Listing 7A C++ exception handler in action.</em></h4>
<pre>Is NULL
Standard exception: std::bad_alloc
Is NULL
Returning</pre>
<p>Notice in Listing 7 that the exception handler has been invoked, and the type of exception is indeed <tt>bad_alloc</tt>. Naturally, this means that the runtime system was unable to provide the massive array I requested.</p>
<p>Of course, not everyone likes exception handlers. A veteran C++ programmer probably wouldn't use a try-catch block here. Instead, a pro would most likely just check that the call to <tt>new()</tt> returns a non-NULL pointer:</p>
<pre>if(myarray) { // The myarray is not NULL if call to new() succeeded</pre>
<p>Programming professionals also might dislike exception handlers because C++ exception checking potentially consumes valuable resources. For mere mortals, however, the use of the exception mechanism still has its merits. Aside from <tt>bad_alloc</tt>, the other exception types are as follows:</p>
<ul>
	<li><tt>bad_exception</tt> is thrown by certain dynamic exception-specifiers.</li>
	<li><tt>bad_typeid</tt> is thrown by typeid.</li>
	<li><tt>bad_function_call</tt> is thrown by an empty function object.</li>
	<li><tt>bad_weak_ptr</tt> is thrown by <tt>shared_ptr</tt> when passed a bad <tt>weak_ptr</tt>.</li>
</ul>
<p>Generic exceptions such as <tt>logic_error</tt> and <tt>runtime_error</tt> are another option, which programmers can use for application-specific purposes. Using <tt>runtime_error</tt> is potentially a good step in the direction of exception-centric development, where any exceptions get reported to a central repository.</p>
<h4>Catching Exceptions by Reference in C++</h4>
<p>The exception that can be caught by the handler in Listing 6 is a <tt>bad_alloc</tt>. The <tt>bad_alloc</tt> exception is itself derived from the standard base-class exception, so <tt>bad_alloc</tt> can be caught this way because it's part of the object graph. This works because capturing by reference in turn captures all related classes—which is good news because we can also capture other exceptions. If we capture an exception and don't know what to do with it, we can just rethrow it for handling at a higher level.</p>
<h4>C++ and RAII (Resource Acquisition Is Initialization)</h4>
<p>You might have noticed that the C++ example doesn't include the <tt>finally</tt> clause in its exception structure. The normal "finally" semantics are intended to be provided by a design feature of C++ called <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">Resource Acquisition Is Initialization</a> (RAII). Coupled with a feature called <a href="http://stackoverflow.com/questions/2331316/what-is-stack-unwinding">stack unwinding</a>, RAII provides a model for exception-safe C++ code. RAII is a nice approach because it facilitates the exception-safe release of resources such as files, memory, allocated objects, and so on. RAII allows for appropriate destructor code to be invoked automatically as part of the exception management infrastructure.</p>
<p>RAII mechanisms are facilitated by some of the elements of C++ 11, specifically the smart pointer classes and mutex locks. Of course, the latter are geared toward multithreaded C++ programming; I described them to some extent in my article "<a href="http://www.informit.com/articles/article.aspx?p=1823696">C++ 11 Memory Management</a>."</p>




            </div>
            </div></body></html>