<html><body><div><div class="entry-content">
		<p>During the last year or so, I have made some attempts to become familiar with CPython (henceforth, I would refer to the CPython implementation of the awesome Python 3 simply as CPython). I have tried different tactics:</p>

<p>Along the way, I have noticed some smart looking people say that the best way to understand CPython is to make some changes to it, and then see what happens. Of course I felt I was capable enough to figure it all out by simply reading stuff. Thus it turned out that a full year after starting my quest of understanding CPython, I have decided to make some patches to it.</p>
<p>I found the process of searching and messing with CPython sources while having a well defined purpose to be a great experience, which was fun and also quite educating. I have decided to write this walkthrough in hopes of inspiring you to try making your own patches (which would probably be much better than mine).</p>
<p>It would probably be easier to follow the walkthrough while looking at <a href="https://github.com/orenmn/orenmnCpython/tree/033b14db1c641d80d856c6766c81b5210c9ae14a">my patched CPython version</a>, but I would try to make things clear even without it.</p>
<p>Let us start with that walkthrough right away.</p>
<p>Our first goal is to change the base of the representation of an ‘int’ object from decimal to hexadecimal, i.e.:</p>
<pre class="brush: python; title: ; notranslate" title="">
&gt;&gt;&gt; 31
1f
&gt;&gt;&gt; 32
20
</pre>
<p>We know the ‘int’ type is implemented in C, so we have to find its C equivalents of ‘__repr__’ and ‘__str__’ in the type declaration. There must be a file in the ‘Objects’ directory for the ‘int’ type. Ah? No such file? We can easily spot floatobject.c, dictobject.c, listobject.c, but where is intobject.c?? Let’s try another approach. Search every *.c or *.h file in the code base for ‘”int”‘. Two results look quite interesting:</p>
<p>In Python\bltinmodule.c:</p>
<pre class="brush: cpp; title: ; notranslate" title="">
SETBUILTIN("int",           &amp;PyLong_Type);
</pre>
<p>and in Objects\longobject.c:</p>
<pre class="brush: cpp; title: ; notranslate" title="">
PyTypeObject PyLong_Type = {
    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)
    "int",            /* tp_name */
</pre>
<p>Seems like the ‘int’ type is referred to as PyLong_Type in CPython. To make sure, we google ‘int long in python 3’. One of the first results is <a href="https://docs.python.org/3/c-api/long.html">Integer Objects – Python 3.5.1 documentation</a>, which says very clearly:</p>
<blockquote>
<h4/>
<p><a class="reference internal" title="PyTypeObject" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject">PyTypeObject</a> <code class="descname">PyLong_Type</code></p>
<p>This instance of <a class="reference internal" title="PyTypeObject" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject"><code class="xref c c-type docutils literal"><span class="pre">PyTypeObject</span></code></a> represents the Python integer type. This is the same object as <a class="reference internal" title="int" href="https://docs.python.org/3/library/functions.html#int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> in the Python layer.</p></blockquote>
<p>This site looks really useful. We should better remember it.</p>
<p>Anyway, seems like we found the initialization of the ‘int’ PyTypeObject in Objects\longobject.c:</p>
<pre class="brush: cpp; title: ; notranslate" title="">
PyTypeObject PyLong_Type = {
    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)
    "int",                                      /* tp_name */
    ...
    long_to_decimal_string,                     /* tp_repr */
    ...
    long_to_decimal_string,                     /* tp_str */
    ...
};
</pre>
<p>Great! Seems like replacing <i>tp_repr</i> and <i>tp_str</i> with our function would do the job. We search for ‘long_to_decimal_string’ to realize how our function should look. We find it in Objects\longobject.c:</p>
<pre class="brush: cpp; title: ; notranslate" title="">
static PyObject *
long_to_decimal_string(PyObject *aa)
{
    PyObject *v;
    if (long_to_decimal_string_internal(aa, &amp;v, NULL) == -1)
        return NULL;
    return v;
}
</pre>
<p><i>long_to_decimal_string</i> receives an ‘int’ and returns a ‘str’, as expected. So we have to find a function similar to the builtin ‘hex’ function, but one that won’t add the ‘0x’ prefix. We search for ‘”hex”‘, and find in Python\clinic\bltinmodule.c.h:</p>
<pre class="brush: cpp; title: ; notranslate" title="">
#define BUILTIN_HEX_METHODDEF \
    {"hex", (PyCFunction)builtin_hex, METH_O, builtin_hex__doc__},
</pre>
<p>All right. We search for ‘builtin_hex’, and find in Python\bltinmodule.c:</p>
<pre class="brush: cpp; title: ; notranslate" title="">
static PyObject *
builtin_hex(PyModuleDef *module, PyObject *number)
/*[clinic end generated code: output=618489ce3cbc5858 input=e645aff5fc7d540e]*/
{
    return PyNumber_ToBase(number, 16);
}
</pre>
<p>Ah? What’s that ‘clinic’ thing? We google ‘python clinic’ and find <a href="https://www.python.org/dev/peps/pep-0436/">PEP-0436</a> right away. This is some code generator to make the CPython developer’s life easier. Nothing we should worry about. Anyway, <i>builtin_hex</i> is just a wrapper of <i>PyNumber_ToBase</i>, which we search for and find in Objects\abstract.c:</p>
<pre class="brush: cpp; title: ; notranslate" title="">
PyObject *
PyNumber_ToBase(PyObject *n, int base)
{
    PyObject *res = NULL;
    PyObject *index = PyNumber_Index(n);

    if (!index)
        return NULL;
    if (PyLong_Check(index))
        res = _PyLong_Format(index, base);
    else
        /* It should not be possible to get here, as
        PyNumber_Index already has a check for the same
        condition */
        PyErr_SetString(PyExc_ValueError, "PyNumber_ToBase: index not int");
    Py_DECREF(index);
    return res;
}
</pre>
<p>Some more work is done here, but still it seems like most of the work is not done here, but in <i>_PyLong_Format</i>, which we find in Objects\longobject.c:</p>
<pre class="brush: cpp; title: ; notranslate" title="">
PyObject *
_PyLong_Format(PyObject *obj, int base)
{
    PyObject *str;
    int err;
    if (base == 10)
        err = long_to_decimal_string_internal(obj, &amp;str, NULL);
    else
        err = long_format_binary(obj, base, 1, &amp;str, NULL);
    if (err == -1)
        return NULL;
    return str;
}
</pre>
<p>In our case, base is 16, so <i>long_format_binary</i> is the relevant function, and we find it also in Objects\longobject.c:</p>
<pre class="brush: cpp; title: ; notranslate" title="">

/* Convert an int object to a string, using a given conversion base,
   which should be one of 2, 8 or 16.  Return a string object.
   If base is 2, 8 or 16, add the proper prefix '0b', '0o' or '0x'
   if alternate is nonzero. */

static int
long_format_binary(PyObject *aa, int base, int alternate,
                   PyObject **p_output, _PyUnicodeWriter *writer)
{
...
</pre>
<p>‘add the proper prefix … if alternate is nonzero’?!?</p>
<p>Perfect!</p>
<p>Looks like we know enough to write our own <i>tp_repr</i> and <i>tp_str</i> for ‘int’:</p>
<pre class="brush: cpp; title: ; notranslate" title="">
static PyObject *
orenmn_long_to_hex_string(PyObject *longObjPtr)
{
    PyObject *hexStrReprPtr;

    if (-1 == long_format_binary(
        longObjPtr, 0x10,
        0,  // alternate = 0 to exclude the '0x' prefix
        &amp;hexStrReprPtr, NULL))
    {
        return NULL;
    }
    return hexStrReprPtr;
}
</pre>
<p>We put it in Objects\longobject.c, just as <i>long_to_decimal_string</i>. Now we just replace the <i>tp_repr</i> and <i>tp_str</i>:</p>
<pre class="brush: cpp; title: ; notranslate" title="">
PyTypeObject PyLong_Type = {
    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)
    "int",                                      /* tp_name */
...
    // origLine: long_to_decimal_string,        /* tp_repr */
    orenmn_long_to_hex_string,                  /* tp_repr */
...
    // origLine: long_to_decimal_string,        /* tp_str */
    orenmn_long_to_hex_string,                  /* tp_str */
</pre>
<p>And that’s it! We build our patched CPython, and now the representation of ‘int’ is really in hex <span class="wp-smiley wp-emoji wp-emoji-smile" title=":)">:)</span></p>
<p><a href="https://orenmn.wordpress.com/2016/01/02/understanding-cpython-by-patching-part-2/">part 2</a></p>
<div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><div class="sharedaddy sd-block sd-like jetpack-likes-widget-wrapper jetpack-likes-widget-unloaded" id="like-post-wrapper-104378497-31-56d5a78dcfa34" data-src="//widgets.wp.com/likes/#blog_id=104378497&amp;post_id=31&amp;origin=orenmn.wordpress.com&amp;obj_id=104378497-31-56d5a78dcfa34" data-name="like-post-frame-104378497-31-56d5a78dcfa34"><h3 class="sd-title">Like this:</h3><p class="likes-widget-placeholder post-likes-widget-placeholder"><span class="button"><span>Like</span></span> <span class="loading">Loading...</span></p><span class="sd-text-color"/><a class="sd-link-color"/></div></div>			</div>

	</div></body></html>