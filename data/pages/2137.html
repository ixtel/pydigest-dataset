<html><body><div><div class="forum-post blog-post">
            <p>
    A few weeks ago, we published missions devoted to World Urbanism Day. The first mission, <i><a href="http://www.checkio.org/mission/building-base/share/3de02090eb5fac4f0da0ced85f9f3f61/">Building
    Base</a></i>, was a pilot for our OOP based missions. The second, <i><a href="http://www.checkio.org/mission/inside-block/share/be1a9f11c3133f4527a19c4e45b7affc/">Inside Block</a></i>,
    was a reincarnation of the older mission <i>Target Hit</i> which some long time CheckiO players should remember.
    Today, we'll be taking a close look at some of the more interesting and top scoring solutions.</p>

<p>
    For this mission you are tasked with creating a class to build the ideal base. We described some of the required
    methods, but placed no restrictions on how to store and process the data.</p>
<h4>Clear</h4>
<p>
    The top voted solution in the <b>Clear</b> category for Building Base as of 11/21/2014 is <i><a href="http://www.checkio.org/mission/building-base/publications/gyahun_dash/python-3/first/share/318bd98592f451ab82c9cd507b4747a6/">"First"</a></i>
    by <a href="http://www.checkio.org/user/gyahun_dash/">@gyahun_dash</a>.</p>
<pre>
def __init__(self, south, west, width, depth, height=10):
    self.south, self.west = south, west
    self.width, self.depth, self.height = width, depth, height
    self.north, self.east = south + depth, west + width
</pre>
<p> </p>
<p>
    As we can see, the author decided to store state data rather than calculate it inside methods, which comes in useful
    if need to expand the class. </p>
<p>
    The next interesting feature is the authors realization of the <i>corners</i> method:</p>
<pre>
def corners(self):
    pairs = product(('south', 'north'), ('west', 'east'))
    return {'-'.join(p): [getattr(self, d) for d in p] for p in pairs}
</pre>
<p> </p>
<p>
    As you can see, they used the itertools.product function for pairs names. This is a good example of the <i>batteries
    included</i> philosophy. They even added a little metaprogramming for flavor with the <a href="https://docs.python.org/3/library/functions.html#getattr">gettattr</a> function. But, as <a href="http://www.checkio.org/user/veky/">@veky</a> said: "If you want to be a wizard, corners can be much more
    elegant using operator.attrgetter. ;-)"</p>
<p>Before we finish, I'd like to note the elegant usage of the variable names in the "__repr__" method. This
    realization requires no comment! :-)</p>
<pre>
txt = 'Building({0.south}, {0.west}, {0.width}, {0.depth}, {0.height})'
    return txt.format(self)
</pre>
<p> </p>
<h4>Creative</h4>
<p>
    In the <b>Creative category</b> we have a pair of brain breaking solutions.</p>
<p>
    <i><a href="http://www.checkio.org/mission/building-base/publications/samulih/python-3/zzdgnczfgdmksjdgfjs/share/4b70ca1fdee5fd14a8877fab4f0561a9/">"zzdgnczfgdmksjdgfjs"</a></i>
    by <a href="http://www.checkio.org/user/samulih/">@samulih</a> is something packed into one initial method class.
    Try to puzzle out this dense function with reusable variable names -- ('sou', 'nor'), ('we', 'ea'). This solution
    isn't just noteworthy because it's funny, we can learn something from the authors interesting usage of the <i>self.__dict__.update</i>
    trick. You can read more about the use of this interesting trick at <a href="http://pydanny.blogspot.ru/2011/11/loving-bunch-class.html">this resource</a>. When all is said and done,
    we only have one question for the author: what on Earth does <i>zzdgnczfgdmksjdgfjs</i> mean?!</p>
<p>
    <a href="http://www.checkio.org/user/veky/">@veky</a> intrigued us with his rather interesting <i><a href="http://www.checkio.org/mission/building-base/publications/veky/python-3/real-base/share/1b56dcf2beafea40e454e25e3409fe6b/">real
    base</a></i> solution. In it, we see a bunch of neat tricks, metaprogramming and advanced techniques. And lambdas of
    course, you won't see the classical "def" here. We recommend you to examine this solution thoroughly, especially
    this part:</p>
<pre>
from collections import namedtuple
class Building(namedtuple("Base", "south west width_we width_ns height")):
    ....
    __repr__ = lambda I: I.__class__.__name__ + repr(tuple(I))
</pre>
<p> </p>
<p>
    Here we see a very pretty usage of namedtuple as a class base (Yeah inheritance!!!). As we've said before: Python is
    <i>batteries included</i> language.</p>
<h4>Discussions</h4>
<p>
    Sometimes discussions in the comments of a solutions can be very interesting and often times players stray away from
    the original topic. For this mission solutions we found couple interesting and useful discussion for your weekend
    reading.</p>
<p>
    A review of <a href="http://www.checkio.org/user/AQiccl135/">@AQiccl135's</a> solution becomes a <a href="http://www.checkio.org/mission/building-base/publications/AQiccl135/python-3/first-building-base/share/98e3e00cf3a2c30d31f532d5daeb74f3/#comment-20322">discussion
    about CiO teaching power</a>.</p>
<p>
    Is speed required for a basic class? How about caching? 
    <a href="http://www.checkio.org/mission/building-base/publications/andrea.manno1/python-3/first/share/8575c4f2b13810e7176e0cdb93aa7a57/#comment-20316">
        Read it here
    </a>
</p>

<p>
    For this mission you are tasked with defining if a point lays inside a selection of polygons which are represent as
    topographical structures. This concept is often used in image recognition software.</p>
<p>
    This mission is not an easy and here we don't typically see many solutions for it, but we found a pretty solid one
    by a well known CheckiO player.</p>
<p>
    The solution is <i><a href="http://www.checkio.org/mission/inside-block/publications/bunnychai/python-3/insideblock/share/ac44333efece6349f8e0b90f672dce4c/">
    "Inside Block(winding number)"</a></i> by <a href="http://www.checkio.org/user/bunnychai/">@bunnychai</a>. As we can see from
    the title, this solution uses the <a href="http://en.wikipedia.org/wiki/Winding_number">Winding Number</a> concept.
    The author counts a winding number with the given point and polygon, (the polygon is little corner curve) and based
    on this number we can decide if the point is inside a block. The main point to comprehend here is if you properly
    "orient" method work, you'll get the whole solution. An interesting point we want to draw your attention to is line
    8:</p>
<pre>
for (x0, y0), (x1, y1) in zip(polygon, polygon[1:] + (polygon[0],)):
</pre>
<p> </p>
<p>
    With this trick, the author can compare elements from an array to the next element. Of course this can be done with
    additional "memory" variables, but it's not so pretty. :-)</p>
<p>
    That's all folks!!! If you want to see more articles and reviews like this, then please upvote, like, retweet and
    share with it with your programmer friends!</p>
        </div>
        </div></body></html>