<html><body><div><div class="post-body entry-content" id="post-body-4101175550702168502" itemprop="description articleBody">
<i>Disclaimer: If you have some bias and/or dislike AsyncIO, <a href="http://blog.gmludo.eu/2015/02/open-letter-for-sync-world.html">please read my previous blog post</a> before starting a war.</i>

<b>Warning: Since I've published this article, my first benchmark published in public, I've received a lot of remarks. Even I've tried to have no errors to be the closest to the "truth", for this benchmark, I've made a mistake: No keepalive for Flask and Django. It's why I've made <a href="http://blog.gmludo.eu/2015/03/benchmark-python-web-production-stack.html" target="_blank">a second benchmark</a>, and now <a href="http://blog.gmludo.eu/2015/04/techempower-frameworkbenchmarks-round-10.html" target="_blank">API-Hour is participating to FrameworkBenchmarks contest</a>, to have the most realistics numbers about theses problematics.</b>
<b>Thanks everybody that helped me to give me all pieces of information to improve my knowledge.</b>
<b>Please to forgive me, first times are always catastrophics, especially in public ;-)</b>
<h3>
Context of this macro-benchmark</h3><p>
Today, I propose you to benchmark a HTTP daemon based on </p><a href="https://docs.python.org/3/library/asyncio.html">AsyncIO</a><p>, and compare results with a Flask and Django version.
</p><p>
For those who didn't follow </p><a href="https://docs.python.org/3/library/asyncio.html">AsyncIO</a><p> news, </p><a href="http://aiohttp.readthedocs.org/en/latest/web.html">aiohttp.web</a><p> is a light Web framework based on </p><a href="http://aiohttp.readthedocs.org/en/">aiohttp</a><p>. It's like Flask but with less internal layers.
</p><a href="http://aiohttp.readthedocs.org/en/">aiohttp</a><p> is the implementation of HTTP with AsyncIO.
</p><p>
Moreover, </p><a href="http://www.api-hour.io/#api-hour">API-Hour</a><p> helps you to have multiprocess daemons with </p><a href="https://docs.python.org/3/library/asyncio.html">AsyncIO</a><p>.</p><p>
With this tool, we can compare Flask, Django and </p><a href="http://aiohttp.readthedocs.org/en/latest/web.html">aiohttp.web</a><p> in the same conditions.</p><p>
This benchmark is based on a concrete need of one of our customers: they wanted to have a REST/JSON API to interact with their telephony server, based on Asterisk.</p><p>
One of the WebServices gives the list of agents with their status. This WebService is heavily used because they use it on their public Website (itself having a serious traffic) to show who is available.
</p><p>
First, I've made a HTTP daemon based on Flask and Gunicorn, which gave honorable results. Later on, I replaced the HTTP part and pushed in production a daemon based on </p><a href="http://aiohttp.readthedocs.org/en/latest/web.html">aiohttp.web</a><p> and </p><a href="http://www.api-hour.io/#api-hour">API-Hour</a><p>.</p><p>
A subset of theses daemons are used for this benchmark.</p><p>
I've added a Django version because with Django and Flask, I certainly cover 90% of tools used by Python Web developers.
</p><p>
I've tried to have the same parameters for each daemon: for example, I obviously use the same number of workers, 16 in this benchmark.
</p><p>
I don't benchmark Django manage.py or dev HTTP server of Flask, I use Gunicorn, as most people use on production, to try to compare apples with apples.

</p><h3>
Hardware</h3>
<ul>
<li>Server: A Dell Precision M6800 with i7 2.90GHz and 16 GB of RAM</li>
<li>Client: A Dell XPS L502X with i5 2.40GHz and 6GB of RAM</li>
<li>Network: RJ45 cable between server and client</li>
</ul>
<h4>
</h4>
<h4>
Network  benchmark</h4><p>
I've almost 1Gb/s with this network:
</p><p>
On Server:
</p><pre>$ iperf -c 192.168.2.101 -d
------------------------------------------------------------
Server listening on TCP port 5001
TCP window size: 28.6 MByte (default)
------------------------------------------------------------
------------------------------------------------------------
Client connecting to 192.168.2.101, TCP port 5001
TCP window size: 28.6 MByte (default)
------------------------------------------------------------
[  5] local 192.168.2.100 port 24831 connected with 192.168.2.101 port 5001
[  4] local 192.168.2.100 port 5001 connected with 192.168.2.101 port 16316
[ ID] Interval       Transfer     Bandwidth
[  4]  0.0-10.1 sec  1.06 GBytes   903 Mbits/sec
[  5]  0.0-10.1 sec  1.11 GBytes   943 Mbits/sec</pre>
<p>
On Client:
</p><pre>$ iperf -s
------------------------------------------------------------
Server listening on TCP port 5001
TCP window size: 28.6 MByte (default)
------------------------------------------------------------
[  4] local 192.168.2.101 port 5001 connected with 192.168.2.100 port 24831
------------------------------------------------------------
Client connecting to 192.168.2.100, TCP port 5001
TCP window size: 28.6 MByte (default)
------------------------------------------------------------
[  6] local 192.168.2.101 port 16316 connected with 192.168.2.100 port 5001
[ ID] Interval       Transfer     Bandwidth
[  6]  0.0-10.0 sec  1.06 GBytes   908 Mbits/sec
[  4]  0.0-10.2 sec  1.11 GBytes   927 Mbits/sec
</pre>

<b><br/></b>
<b>System configuration</b><p>
It's important to configure your PostgreSQL as a production server.</p><p>
You need also to configure your Linux kernel to handle a lot of open sockets and some TCP tricks.</p><p>
Everything is in the </p><a href="https://github.com/Eyepea/API-Hour/tree/master/benchmarks">benchmark repository</a><p>.
</p><h3>
</h3>
<h3>
Client benchmark tool</h3><p>
From my experience with AsyncIO, Apache Benchmark (ab), Siege, Funkload and some old fashion HTTP benchmarks tools don't hit enough for an API-Hour daemon.</p><p>
For now, I use </p><a href="https://github.com/wg/wrk">wrk</a><p> and </p><a href="https://github.com/giltene/wrk2">wrk2</a><p> to benchmark.</p><p>
wrk hits as fast as possible, where wrk2 hits with the same rate.

</p><h3>
Metrics observed</h3><p>
I record three metrics:
</p><ol>
<li><b>Requests/sec</b>: Least interesting of metrics. (see below)</li>
<li><b>Error rate</b>: Sum of all errors (socket timeout, socket read/write, 5XX errors...)</li>
<li><b>Reactivity</b>: Certainly the most interesting of the three, it measures the time that our client will actually wait.</li>
</ol>

<h3>
</h3>
<h3>
WebServices daemons</h3><p>
You can find all source code in API-Hour repository: </p><a href="https://github.com/Eyepea/API-Hour/tree/master/benchmarks">https://github.com/Eyepea/API-Hour/tree/master/benchmarks</a><p>
Each daemon has at least two WebServices:
</p><ul>
<li><b>/index</b>: It's a simple JSON document</li>
<li><b>/agents</b>: The list of agents that uses, in backend, a SQL query to retrieve agents and status</li>
</ul><p>
On Flask daemon, I added </p><b>/agents_with_pool</b><p> endpoint, to use a database connection pool with Flask, but it isn't really good, you'll see later.</p><p>
On Django daemon, I added </p><b>/agents_with_orm</b><p> endpoint, to measure the overhead to use Django-ORM instead of to use SQL directly. Warning: I didn't find a solution to have the exact same query.

</p><h3>
Methodology</h3><p>
Each daemon will run alone to preserve resources.</p><p>
Between each run, the daemon is restarted to be sure that previous test doesn't pollute the next one.

</p><h3>
First turn</h3><p>
At the beginning, to have an idea how much maximum HTTP queries each daemon can support, I quickly attack (30 seconds) on localhost.

</p><i><b>Warning ! This benchmark doesn't represent the reality you can have in production, because you don't have a network limitation nor latency, it's only for calibration.</b></i>

<h4>
Simple JSON document</h4><p>
In each daemon folder in </p><a href="https://github.com/Eyepea/API-Hour/tree/master/benchmarks">benchmarks repository</a><p>, you can read the output result of each wrk.</p><p>
To simplify the reading, I summarize the captured values with an array and graphs:

</p><table border="0" cellspacing="0">
 <colgroup/>
 <colgroup/>
 <colgroup/>
 <colgroup/>
 <tbody>
<tr>
  <td align="left"><b><br/></b></td>
  <td align="left"><b>Requests/s</b></td>
  <td align="left"><b>Errors</b></td>
  <td align="left"><b>Avg Latency (s)</b></td>
 </tr>
<tr>
  <td align="left"><b>Django+Gunicorn</b></td>
  <td align="right" sdnum="2057;" sdval="70598">70598</td>
  <td align="right" sdnum="2057;" sdval="4489">4489</td>
  <td align="right" sdnum="2057;" sdval="7.7">7.7</td>
 </tr>
<tr>
  <td align="left"><b>Flask+Gunicorn</b></td>
  <td align="right" sdnum="2057;" sdval="79598">79598</td>
  <td align="right" sdnum="2057;" sdval="4433">4433</td>
  <td align="right" sdnum="2057;" sdval="13.16">13.16</td>
 </tr>
<tr>
  <td align="left"><b>aiohttp.web+API-Hour</b></td>
  <td align="right" sdnum="2057;" sdval="395847">395847</td>
  <td align="right" sdnum="2057;" sdval="0">0</td>
  <td align="right" sdnum="2057;" sdval="0.03">0.03</td>
 </tr>
</tbody></table>

<p class="separator">
</p>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://4.bp.blogspot.com/-gMV_inkNn3M/VOzqcQVrkpI/AAAAAAAAPX4/ULj5lVaCRKY/s1600/requests.png" imageanchor="1"><img border="0" src="http://4.bp.blogspot.com/-gMV_inkNn3M/VOzqcQVrkpI/AAAAAAAAPX4/ULj5lVaCRKY/s1600/requests.png"/></a></td></tr>
<tr><td class="tr-caption"><b><span>Requests by seconds<br/>(Higher is better)</span></b></td></tr>
</tbody></table>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://2.bp.blogspot.com/-kv726tCVZU8/VOzr7auIWPI/AAAAAAAAPYE/mOkpMyxdm_Y/s1600/errors.png" imageanchor="1"><img border="0" src="http://2.bp.blogspot.com/-kv726tCVZU8/VOzr7auIWPI/AAAAAAAAPYE/mOkpMyxdm_Y/s1600/errors.png"/></a></td></tr>
<tr><td class="tr-caption"><span><b>Errors<br/>(Lower is better)</b></span></td></tr>
</tbody></table>

<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://2.bp.blogspot.com/-ecAzQ58UsN8/VOzr9TsJCTI/AAAAAAAAPYM/0N4ePrzcdho/s1600/latency.png" imageanchor="1"><img border="0" src="http://2.bp.blogspot.com/-ecAzQ58UsN8/VOzr9TsJCTI/AAAAAAAAPYM/0N4ePrzcdho/s1600/latency.png"/></a></td></tr>
<tr><td class="tr-caption"><span><b>Latency (s)<br/>(Lower is better)</b></span></td></tr>
</tbody></table>
<h4>
</h4>
<h4>
Agents list from database</h4>
<table border="0" cellspacing="0">
 <colgroup/>
 <colgroup/>
 <colgroup/>
 <colgroup/>
 <tbody>
<tr>
  <td align="left"><b><br/></b></td>
  <td align="left"><b>Requests/s</b></td>
  <td align="left"><b>Errors</b></td>
  <td align="left"><b>Avg Latency (s)</b></td>
 </tr>
<tr>
  <td align="left"><b>Django+Gunicorn</b></td>
  <td align="right" sdnum="2057;" sdval="583">583</td>
  <td align="right" sdnum="2057;" sdval="2518">2518</td>
  <td align="right" sdnum="2057;" sdval="0.324">0.324</td>
 </tr>
<tr>
  <td align="left"><b>Django ORM+Gunicorn</b></td>
  <td align="right" sdnum="2057;" sdval="572">572</td>
  <td align="right" sdnum="2057;" sdval="2798">2798</td>
  <td align="right" sdnum="2057;" sdval="0.572">0.572</td>
 </tr>
<tr>
  <td align="left"><b>Flask+Gunicorn</b></td>
  <td align="right" sdnum="2057;" sdval="634">634</td>
  <td align="right" sdnum="2057;" sdval="2985">2985</td>
  <td align="right" sdnum="2057;" sdval="13.16">13.16</td>
 </tr>
<tr>
  <td align="left"><b>Flask (connection pool)</b></td>
  <td align="right" sdnum="2057;" sdval="2535">2535</td>
  <td align="right" sdnum="2057;" sdval="79704">79704</td>
  <td align="right" sdnum="2057;" sdval="12.09">12.09</td>
 </tr>
<tr>
  <td align="left"><b>aiohttp.web+API-Hour</b></td>
  <td align="right" sdnum="2057;" sdval="4179">4179</td>
  <td align="right" sdnum="2057;" sdval="0">0</td>
  <td align="right" sdnum="2057;" sdval="0.098">0.098</td>
 </tr>
</tbody></table>
<p class="separator">
<br/></p>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://4.bp.blogspot.com/-blwaVFb_dx8/VOzy5_MQN5I/AAAAAAAAPYs/-1Z8TWChMMU/s1600/requests.png" imageanchor="1"><img border="0" src="http://4.bp.blogspot.com/-blwaVFb_dx8/VOzy5_MQN5I/AAAAAAAAPYs/-1Z8TWChMMU/s1600/requests.png"/></a></td></tr>
<tr><td class="tr-caption"><b><span>Requests by seconds<br/>(Higher is better)</span></b></td></tr>
</tbody></table>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://2.bp.blogspot.com/-pyMY69oKtDQ/VOzy55UPycI/AAAAAAAAPYg/wOEjDlNOxJQ/s1600/errors.png" imageanchor="1"><img border="0" src="http://2.bp.blogspot.com/-pyMY69oKtDQ/VOzy55UPycI/AAAAAAAAPYg/wOEjDlNOxJQ/s1600/errors.png"/></a></td></tr>
<tr><td class="tr-caption"><b>Errors<br/>(Lower is better)</b></td></tr>
</tbody></table>

<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://2.bp.blogspot.com/-L6WFd5nvpOI/VOzy5_NDEOI/AAAAAAAAPYc/-14ciuU3DjE/s1600/latency.png" imageanchor="1"><img border="0" src="http://2.bp.blogspot.com/-L6WFd5nvpOI/VOzy5_NDEOI/AAAAAAAAPYc/-14ciuU3DjE/s1600/latency.png"/></a></td></tr>
<tr><td class="tr-caption"><b>Latency (s)<br/>(Lower is better)</b></td></tr>
</tbody></table>
<h3>
<br/> Conclusions for the next round</h3><p>
On high charge, Django doesn't have the same behaviour as Flask: Both handle more or less the same requests rate, but Django penalizes less global latency of HTTP queries. The drawback is that the slow HTTP queries are very slow (26,43s for Django compared to 13,31s for Flask).</p><p>
I removed Django ORM test for the next round because it isn't exactly the same SQL query generated and the performance difference with a SQL query is negligible.</p><p>
I removed also Flask DB connection pool because the error rate is too important compared to other tests.

</p><h3>
Second round</h3><p>
Here, I use wrk2, and changed the run time to 5 minutes.</p><p>
A longer run time is very important because of how resources availability can change with time.</p><p>
There are at least two reasons for this:
</p><p>
1. Your test environment runs  on top of some OS which continues its activity during the test.</p><p>
Therefore, you need a long time to be more insensitive to transient use of your test machine resources by other things</p><p>
like another OS daemon or cron job triggering meanwhile.
</p><p>
2. The ramp-up of your test will gradually consume more resources at different levels: at the level of your Python scripts &amp; libs,</p><p>
 as well as at the level of you OS / (Virtual) Machine.</p><p>
This decrease of available resources will not necessarily be instantaneous, nor linear.</p><p>
This is a typical source of after-deployment bad surprises in prod.</p><p>
Here too, to be as close as possible to production scenario, you need to give time to your test to arrive to a "hover", eventually saturating some resources.</p><p>
Ideally you'd saturate the network first (which in this case is like winning the jackpot).
</p><p>
Here, I'm testing at a constant 4000 queries per second, this time through the network.

</p><h4>
Simple JSON document</h4>
<div>
<table border="0" cellspacing="0">
 <colgroup/>
 <colgroup/>
 <colgroup/>
 <colgroup/>
 <tbody>
<tr>
  <td align="left"><b><br/></b></td>
  <td align="left"><b>Requests/s</b></td>
  <td align="left"><b>Errors</b></td>
  <td align="left"><b>Avg Latency (s)</b></td>
 </tr>
<tr>
  <td align="left"><b>Django+Gunicorn</b></td>
  <td align="right" sdnum="2057;" sdval="1799">1799</td>
  <td align="right" sdnum="2057;" sdval="26883">26883</td>
  <td align="right" sdnum="2057;" sdval="97">97</td>
 </tr>
<tr>
  <td align="left"><b>Flask+Gunicorn</b></td>
  <td align="right" sdnum="2057;" sdval="2714">2714</td>
  <td align="right" sdnum="2057;" sdval="26742">26742</td>
  <td align="right" sdnum="2057;" sdval="52">52</td>
 </tr>
<tr>
  <td align="left"><b>aiohttp.web+API-Hour</b></td>
  <td align="right" sdnum="2057;" sdval="3995">3995</td>
  <td align="right" sdnum="2057;" sdval="0">0</td>
  <td align="right" sdnum="2057;" sdval="0.002">0.002</td>
 </tr>
</tbody></table>
</div>
<p class="separator">
<br/></p>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://4.bp.blogspot.com/-cYyoWENAU1c/VOz4Xqw_vyI/AAAAAAAAPZA/4OwzNnD9n_o/s1600/requests.png" imageanchor="1"><img border="0" src="http://4.bp.blogspot.com/-cYyoWENAU1c/VOz4Xqw_vyI/AAAAAAAAPZA/4OwzNnD9n_o/s1600/requests.png"/></a></td></tr>
<tr><td class="tr-caption"><b><span>Requests by seconds<br/>(Higher is better)</span></b></td></tr>
</tbody></table>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://4.bp.blogspot.com/-8lY1jJhV5DA/VOz4XlsdArI/AAAAAAAAPY8/n8UVVpEZXyw/s1600/errors.png" imageanchor="1"><img border="0" src="http://4.bp.blogspot.com/-8lY1jJhV5DA/VOz4XlsdArI/AAAAAAAAPY8/n8UVVpEZXyw/s1600/errors.png"/></a></td></tr>
<tr><td class="tr-caption"><b>Errors<br/>(Lower is better)</b></td></tr>
</tbody></table>

<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://1.bp.blogspot.com/-1lXdtugplgs/VOz4Xu_LCLI/AAAAAAAAPZE/hZezaba1DOw/s1600/latency.png" imageanchor="1"><img border="0" src="http://1.bp.blogspot.com/-1lXdtugplgs/VOz4Xu_LCLI/AAAAAAAAPZE/hZezaba1DOw/s1600/latency.png"/></a></td></tr>
<tr><td class="tr-caption"><b>Latency (s)<br/>(Lower is better)</b></td></tr>
</tbody></table>
<h4>
Agents list from database</h4>
<div>
<table border="0" cellspacing="0">
 <colgroup/>
 <colgroup/>
 <colgroup/>
 <colgroup/>
 <tbody>
<tr>
  <td align="left"><b><br/></b></td>
  <td align="left"><b>Requests/s</b></td>
  <td align="left"><b>Errors</b></td>
  <td align="left"><b>Avg Latency (s)</b></td>
 </tr>
<tr>
  <td align="left"><b>Django+Gunicorn</b></td>
  <td align="right" sdnum="2057;" sdval="278">278</td>
  <td align="right" sdnum="2057;" sdval="37480">37480</td>
  <td align="right" sdnum="2057;" sdval="141.6">141.6</td>
 </tr>
<tr>
  <td align="left"><b>Flask+Gunicorn</b></td>
  <td align="right" sdnum="2057;" sdval="304">304</td>
  <td align="right" sdnum="2057;" sdval="40951">40951</td>
  <td align="right" sdnum="2057;" sdval="136.8">136.8</td>
 </tr>
<tr>
  <td align="left"><b>aiohttp.web+API-Hour</b></td>
  <td align="right" sdnum="2057;" sdval="3698">3698</td>
  <td align="right" sdnum="2057;" sdval="0">0</td>
  <td align="right" sdnum="2057;" sdval="7.84">7.84</td>
 </tr>
</tbody></table>
</div>

<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://1.bp.blogspot.com/-l5FZmu5LCOQ/VOz7bnfbmRI/AAAAAAAAPZk/nvqK_hqfP0U/s1600/requests.png" imageanchor="1"><img border="0" src="http://1.bp.blogspot.com/-l5FZmu5LCOQ/VOz7bnfbmRI/AAAAAAAAPZk/nvqK_hqfP0U/s1600/requests.png"/></a></td></tr>
<tr><td class="tr-caption"><b><span>Requests by seconds<br/>(Higher is better)</span></b></td></tr>
</tbody></table>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://2.bp.blogspot.com/-GKV0o-wmrm4/VOz7bu3SatI/AAAAAAAAPZc/O9IxGuVfV7I/s1600/errors.png" imageanchor="1"><img border="0" src="http://2.bp.blogspot.com/-GKV0o-wmrm4/VOz7bu3SatI/AAAAAAAAPZc/O9IxGuVfV7I/s1600/errors.png"/></a></td></tr>
<tr><td class="tr-caption"><b>Errors<br/>(Lower is better)</b></td></tr>
</tbody></table>

<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://4.bp.blogspot.com/-9FWMx1Po4hA/VOz7bmLT8VI/AAAAAAAAPZY/txO51gfu8Os/s1600/latency.png" imageanchor="1"><img border="0" src="http://4.bp.blogspot.com/-9FWMx1Po4hA/VOz7bmLT8VI/AAAAAAAAPZY/txO51gfu8Os/s1600/latency.png"/></a></td></tr>
<tr><td class="tr-caption"><b>Latency (s)<br/>(Lower is better)</b></td></tr>
</tbody></table>
<h3>
</h3>
<h3>
(Extra) Third round</h3><p>
For the fun, I used the same setup as second round, but with only with 10 requests/seconds during 30 seconds to see if under a low load, sync daemons could be quicker, because you have the AsyncIO overhead.

</p><h4>
Agents list from database</h4>
<table border="0" cellspacing="0">
 <colgroup/>
 <colgroup/>
 <colgroup/>
 <colgroup/>
 <tbody>
<tr>
  <td align="left"><b><br/></b></td>
  <td align="left"><b>Requests/s</b></td>
  <td align="left"><b>Errors</b></td>
  <td align="left"><b>Avg Latency (s)</b></td>
 </tr>
<tr>
  <td align="left"><b>Django+Gunicorn</b></td>
  <td align="right" sdnum="2057;" sdval="10">10</td>
  <td align="right" sdnum="2057;" sdval="0">0</td>
  <td align="right" sdnum="2057;" sdval="0.01936">0.01936</td>
 </tr>
<tr>
  <td align="left"><b>Flask+Gunicorn</b></td>
  <td align="right" sdnum="2057;" sdval="10">10</td>
  <td align="right" sdnum="2057;" sdval="0">0</td>
  <td align="right" sdnum="2057;" sdval="0.01874">0.01874</td>
 </tr>
<tr>
  <td align="left"><b>aiohttp.web+API-Hour</b></td>
  <td align="right" sdnum="2057;" sdval="10">10</td>
  <td align="right" sdnum="2057;" sdval="0">0</td>
  <td align="right" sdnum="2057;" sdval="0.00642">0.00642</td>
 </tr>
</tbody></table>

<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://2.bp.blogspot.com/-RtjoR9r3Elc/VOz9tD23HBI/AAAAAAAAPZ0/GYo9Pxk8hmU/s1600/latency.png" imageanchor="1"><img border="0" src="http://2.bp.blogspot.com/-RtjoR9r3Elc/VOz9tD23HBI/AAAAAAAAPZ0/GYo9Pxk8hmU/s1600/latency.png"/></a></td></tr>
<tr><td class="tr-caption"><b>Latency (s)<br/>(Lower is better)</b></td></tr>
</tbody></table>
<div>
<h3>
</h3>
<h3>
Conclusion</h3>
<div>
<a href="https://docs.python.org/3/library/asyncio.html">AsyncIO</a><p> with </p><a href="http://aiohttp.readthedocs.org/en/latest/web.html">aiohttp.web</a><p> and </p><a href="http://www.api-hour.io/#api-hour">API-Hour</a><p> increases the number of requests per second, but more importantly, you have no sockets nor 5XX errors and the waiting time for each user is very really better, even with low load. This benchmark uses an ideal network setup, and therefore it doesn't cover a much worse scenario where your client arrives over a slow network (think smartphone users) on your Website.</p></div>
<p>
<br/></p>
<p>
It has been said often: If your webapp is your business, reduce waiting time is a key winner for you:</p>

<p>
<br/></p>
<h3>
Some clues to improve AsyncIO performances</h3>
<p>
Even if this looks like good performance, we shouldn't rest on our laurels, we can certainly find more optimizations:</p>
<p>
<br/></p>
<div>
<ol>
<li><b>Use an alternative event loop</b>: I've tested to replace AsyncIO event loop and network layer by <a href="https://github.com/saghul/aiouv">aiouv</a> and <a href="https://github.com/harvimt/quamash">quamash</a>. For now, it doesn't really have a huge impact, maybe in the future.</li>
<li><b>Have multiplex protocols from frontend to backend</b>: HTTP 2 is now a multiplex protocol, it means you can stack several HTTP queries without waiting for the first response. This pattern should increase AsyncIO performances, but it must be validated by a benchmark.</li>
<li>If you have another idea, don't hesitate to post it in comments.</li>
</ol>
<p>
<br/></p>
<h3>
Don't take architectural decisions based on micro-benchmarks</h3>
</div>
<p>
It's important to be very cautious with benchmarks, especially with micro-benchmarks. Check several different benchmarks, using different scenari, before to conclude on architecture for your application.</p>
<p>
<br/></p>
<h3>
Don't forget this is all about IO-bound</h3>
<p>
If I was working for an organisation with a lot of CPU-bound projects, (such as a scientific organisation for example), my speech would be totally different.</p>
<p>
But, my day-to-day challenges are more about I/O than about CPU, probably like for most Web developers.</p>
<p>
<br/></p>
<p>
Don't simply take me as a mentor. The needs and problematics of one person or organisation are not necessarily the same as your, even if that person is considered as a "guru" in one opensource community or another. </p>
<p>
<br/></p>
<p>
We should all try to keep a rational, scientific approach instead of religious approach when selecting your tools.</p>
<p>
I hope this post will give you some ideas to experiment with. Feel free to share your tips to increase performances, I'd be glad to include them in my benchmarks!</p>
<p>
<br/></p>
<p>
I hope that these benchmarks will be an eye-opener for you.</p>
</div>
<p/>
</div>
</div></body></html>