<html><body><div><article class="markdown-body entry-content" itemprop="text"><table frame="void" rules="none">


<tbody valign="top">
<tr><th>PEP:</th><td/>
</tr>
<tr><th>Title:</th><td>Support for indexing with keyword arguments.</td>
</tr>
<tr><th>Version:</th>
<td>41421</td></tr>
<tr><th>Last-Modified:</th><td>2005-11-10</td>
</tr>
<tr><th>Author:</th>
<td>Stefano Borini, Joseph Martinot-Lagarde</td></tr>
<tr><th>Discussion-To:</th><td><a href="mailto:python-ideas@python.org">python-ideas@python.org</a></td>
</tr>
<tr><th>Status:</th>
<td>Draft</td></tr>
<tr><th>Type:</th><td>Standards Track</td>
</tr>
<tr><th>Content-Type:</th><td>text/x-rst</td>
</tr>
<tr><th>Created:</th><td>24-Jun-2014</td>
</tr>
<tr><th>Python-Version:</th><td>3.6</td>
</tr>
<tr><th>Post-History:</th><td>02-Jul-2014</td>
</tr>
</tbody>
</table>
<a name="user-content-abstract"/>
<h2><a id="user-content-abstract" class="anchor" href="#abstract" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Abstract</h2>
<p>This PEP proposes an extension of the indexing operation to support keyword
arguments. Notations in the form <code>a[K=3,R=2]</code> would become legal syntax.
For future-proofing considerations, <code>a[1:2, K=3, R=4]</code> are considered and
may be allowed as well, depending on the choice for implementation. In addition
to a change in the parser, the index protocol (<code>__getitem__</code>, <code>__setitem__</code>
and <code>__delitem__</code>) will also potentially require adaptation.</p>
<a name="user-content-motivation"/>
<h2><a id="user-content-motivation" class="anchor" href="#motivation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Motivation</h2>
<p>The indexing syntax carries a strong semantic content, differentiating it from
a method call: it implies referring to a subset of data. We believe this
semantic association to be important, and wish to expand the strategies allowed
to refer to this data.</p>
<p>As a general observation, the number of indices needed by an indexing operation
depends on the dimensionality of the data: one-dimensional data (e.g. a list)
requires one index (e.g. <code>a[3]</code>), two-dimensional data (e.g. a matrix) requires
two indices (e.g. <code>a[2,3]</code>) and so on. Each index is a selector along one of the
axes of the dimensionality, and the position in the index tuple is the
metainformation needed to associate each index to the corresponding axis.</p>
<p>The current python syntax focuses exclusively on position to express the
association to the axes, and also contains syntactic sugar to refer to
non-punctiform selection (slices)</p>
<pre>&gt;&gt;&gt; a[3]       # returns the fourth element of a
&gt;&gt;&gt; a[1:10:2]  # slice notation (extract a non-trivial data subset)
&gt;&gt;&gt; a[3,2]     # multiple indexes (for multidimensional arrays)
</pre>
<p>The additional notation proposed in this PEP would allow notations involving
keyword arguments in the indexing operation, e.g.</p>
<pre>&gt;&gt;&gt; a[K=3, R=2]
</pre>
<p>which would allow to refer to axes by conventional names.</p>
<p>One must additionally consider the extended form that allows both positional
and keyword specification</p>
<pre>&gt;&gt;&gt; a[3,R=3,K=4]
</pre>
<p>This PEP will explore different strategies to enable the use of these notations.</p>
<a name="user-content-use-cases"/>
<h2><a id="user-content-use-cases" class="anchor" href="#use-cases" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Use cases</h2>
<p>The following practical use cases present two broad categories of usage of a
keyworded specification: Indexing and contextual option. For indexing:</p>
<ol>
<li><p>To provide a more communicative meaning to the index, preventing e.g. accidental
inversion of indexes</p>
<pre>&gt;&gt;&gt; gridValues[x=3, y=5, z=8]
&gt;&gt;&gt; rain[time=0:12, location=location]
</pre>
</li>
<li><p>In some domain, such as computational physics and chemistry, the use of a
notation such as <code>Basis[Z=5]</code> is a Domain Specific Language notation to represent
a level of accuracy</p>
<pre>&gt;&gt;&gt; low_accuracy_energy = computeEnergy(molecule, BasisSet[Z=3])
</pre>
<p>In this case, the index operation would return a basis set at the chosen level
of accuracy (represented by the parameter Z). The reason behind an indexing is that
the BasisSet object could be internally represented as a numeric table, where
rows (the "coefficient" axis, hidden to the user in this example) are associated
to individual elements (e.g. row 0:5 contains coefficients for element 1,
row 5:8 coefficients for element 2) and each column is associated to a given
degree of accuracy ("accuracy" or "Z" axis) so that first column is low
accuracy, second column is medium accuracy and so on. With that indexing,
the user would obtain another object representing the contents of the column
of the internal table for accuracy level 3.</p>
</li>
</ol>
<p>Additionally, the keyword specification can be used as an option contextual to
the indexing. Specifically:</p>
<ol>
<li><p>A "default" option allows to specify a default return value when the index
is not present</p>
<pre>&gt;&gt;&gt; lst = [1, 2, 3]
&gt;&gt;&gt; value = lst[5, default=0]  # value is 0
</pre>
</li>
<li><p>For a sparse dataset, to specify an interpolation strategy
to infer a missing point from e.g. its surrounding data.</p>
<pre>&gt;&gt;&gt; value = array[1, 3, interpolate=spline_interpolator]
</pre>
</li>
<li><p>A unit could be specified with the same mechanism</p>
<pre>&gt;&gt;&gt; value = array[1, 3, unit="degrees"]
</pre>
</li>
</ol>
<p>How the notation is interpreted is up to the implementing class.</p>
<a name="user-content-current-implementation"/>
<h2><a id="user-content-current-implementation" class="anchor" href="#current-implementation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Current implementation</h2>
<p>Currently, the indexing operation is handled by methods <code>__getitem__</code>,
<code>__setitem__</code> and <code>__delitem__</code>. These methods' signature accept one argument
for the index (with <code>__setitem__</code> accepting an additional argument for the set
value). In the following, we will analyze <code>__getitem__(self, idx)</code> exclusively,
with the same considerations implied for the remaining two methods.</p>
<p>When an indexing operation is performed, <code>__getitem__(self, idx)</code> is called.
Traditionally, the full content between square brackets is turned into a single
object passed to argument <code>idx</code>:</p>
<blockquote>
<ul>
<li>When a single element is passed, e.g. <code>a[2]</code>, <code>idx</code> will be <code>2</code>.</li>
<li>When multiple elements are passed, they must be separated by commas: <code>a[2, 3]</code>.
In this case, <code>idx</code> will be a tuple <code>(2, 3)</code>. With <code>a[2, 3, "hello", {}]</code>
<code>idx</code> will be <code>(2, 3, "hello", {})</code>.</li>
<li>A slicing notation e.g. <code>a[2:10]</code> will produce a slice object, or a tuple
containing slice objects if multiple values were passed.</li>
</ul>
</blockquote>
<p>Except for its unique ability to handle slice notation, the indexing operation
has similarities to a plain method call: it acts like one when invoked with
only one element; If the number of elements is greater than one, the <code>idx</code>
argument behaves like a <code>*args</code>. However, as stated in the Motivation section,
an indexing operation has the strong semantic implication of extraction of a
subset out of a larger set, which is not automatically associated to a regular
method call unless appropriate naming is chosen. Moreover, its different visual
style is important for readability.</p>
<a name="user-content-specifications"/>
<h2><a id="user-content-specifications" class="anchor" href="#specifications" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Specifications</h2>
<p>The implementation should try to preserve the current signature for
<code>__getitem__</code>, or modify it in a backward-compatible way. We will present
different alternatives, taking into account the possible cases that need
to be addressed</p>
<pre>C0. a[1]; a[1,2]         # Traditional indexing
C1. a[Z=3]
C2. a[Z=3, R=4]
C3. a[1, Z=3]
C4. a[1, Z=3, R=4]
C5. a[1, 2, Z=3]
C6. a[1, 2, Z=3, R=4]
C7. a[1, Z=3, 2, R=4]    # Interposed ordering
</pre>
<a name="user-content-strategy-strict-dictionary"/>
<h3><a id="user-content-strategy-strict-dictionary" class="anchor" href="#strategy-strict-dictionary" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Strategy "Strict dictionary"</h3>
<p>This strategy acknowledges that <code>__getitem__</code> is special in accepting only
one object, and the nature of that object must be non-ambiguous in its
specification of the axes: it can be either by order, or by name. As a result
of this assumption, in presence of keyword arguments, the passed entity is a
dictionary and all labels must be specified.</p>
<pre>C0. a[1]; a[1,2]      -&gt; idx = 1; idx = (1, 2)
C1. a[Z=3]            -&gt; idx = {"Z": 3}
C2. a[Z=3, R=4]       -&gt; idx = {"Z": 3, "R": 4}
C3. a[1, Z=3]         -&gt; raise SyntaxError
C4. a[1, Z=3, R=4]    -&gt; raise SyntaxError
C5. a[1, 2, Z=3]      -&gt; raise SyntaxError
C6. a[1, 2, Z=3, R=4] -&gt; raise SyntaxError
C7. a[1, Z=3, 2, R=4] -&gt; raise SyntaxError
</pre>
<a name="user-content-pros"/>
<h4><a id="user-content-pros" class="anchor" href="#pros" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Pros</h4>
<ul>
<li>Strong conceptual similarity between the tuple case and the dictionary case.
In the first case, we are specifying a tuple, so we are naturally defining
a plain set of values separated by commas. In the second, we are specifying a
dictionary, so we are specifying a homogeneous set of key/value pairs, as
in <code>dict(Z=3, R=4)</code>;</li>
<li>Simple and easy to parse on the <code>__getitem__</code> side: if it gets a tuple,
determine the axes using positioning. If it gets a dictionary, use
the keywords.</li>
<li>C interface does not need changes.</li>
</ul>
<a name="user-content-neutral"/>
<h4><a id="user-content-neutral" class="anchor" href="#neutral" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Neutral</h4>
<ul>
<li>Degeneracy of <code>a[{"Z": 3, "R": 4}]</code> with <code>a[Z=3, R=4]</code> means the notation
is syntactic sugar.</li>
</ul>
<a name="user-content-cons"/>
<h4><a id="user-content-cons" class="anchor" href="#cons" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Cons</h4>
<ul>
<li>Very strict.</li>
<li>Destroys ordering of the passed arguments. Preserving the
order would be possible with an OrderedDict as drafted by PEP-468 <a href="#pep-468" id="user-content-id1">[5]</a>.</li>
<li>Does not allow use cases with mixed positional/keyword arguments such as
<code>a[1, 2, default=5]</code>.</li>
</ul>
<a name="user-content-strategy-mixed-dictionary"/>
<h3><a id="user-content-strategy-mixed-dictionary" class="anchor" href="#strategy-mixed-dictionary" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Strategy "mixed dictionary"</h3>
<p>This strategy relaxes the above constraint to return a dictionary containing
both numbers and strings as keys.</p>
<pre>C0. a[1]; a[1,2]      -&gt; idx = 1; idx = (1, 2)
C1. a[Z=3]            -&gt; idx = {"Z": 3}
C2. a[Z=3, R=4]       -&gt; idx = {"Z": 3, "R": 4}
C3. a[1, Z=3]         -&gt; idx = { 0: 1, "Z": 3}
C4. a[1, Z=3, R=4]    -&gt; idx = { 0: 1, "Z": 3, "R": 4}
C5. a[1, 2, Z=3]      -&gt; idx = { 0: 1, 1: 2, "Z": 3}
C6. a[1, 2, Z=3, R=4] -&gt; idx = { 0: 1, 1: 2, "Z": 3, "R": 4}
C7. a[1, Z=3, 2, R=4] -&gt; idx = { 0: 1, "Z": 3, 2: 2, "R": 4}
</pre>
<a name="user-content-id2"/>
<h4><a id="user-content-pros-1" class="anchor" href="#pros-1" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Pros</h4>

<a name="user-content-id3"/>
<h4><a id="user-content-cons-1" class="anchor" href="#cons-1" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Cons</h4>
<ul>
<li>Destroys ordering information for string keys. We have no way of saying if
<code>"Z"</code> in C7 was in position 1 or 3.</li>
<li>Implies switching from a tuple to a dict as soon as one specified index
has a keyword argument. May be confusing to parse.</li>
</ul>
<a name="user-content-strategy-named-tuple"/>
<h3><a id="user-content-strategy-named-tuple" class="anchor" href="#strategy-named-tuple" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Strategy "named tuple"</h3>
<p>Return a named tuple for <code>idx</code> instead of a tuple.  Keyword arguments would
obviously have their stated name as key, and positional argument would have an
underscore followed by their order:</p>
<pre>C0. a[1]; a[1,2]      -&gt; idx = 1; idx = (_0=1, _1=2)
C1. a[Z=3]            -&gt; idx = (Z=3)
C2. a[Z=3, R=2]       -&gt; idx = (Z=3, R=2)
C3. a[1, Z=3]         -&gt; idx = (_0=1, Z=3)
C4. a[1, Z=3, R=2]    -&gt; idx = (_0=1, Z=3, R=2)
C5. a[1, 2, Z=3]      -&gt; idx = (_0=1, _2=2, Z=3)
C6. a[1, 2, Z=3, R=4] -&gt; (_0=1, _1=2, Z=3, R=4)
C7. a[1, Z=3, 2, R=4] -&gt; (_0=1, Z=3, _1=2, R=4)
                      or (_0=1, Z=3, _2=2, R=4)
                      or raise SyntaxError
</pre>
<p>The required typename of the namedtuple could be <code>Index</code> or the name of the
argument in the function definition, it keeps the ordering and is easy to
analyse by using the <code>_fields</code> attribute. It is backward compatible, provided
that C0 with more than one entry now passes a namedtuple instead of a plain
tuple.</p>
<a name="user-content-id4"/>
<h4><a id="user-content-pros-2" class="anchor" href="#pros-2" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Pros</h4>
<ul>
<li>Looks nice. namedtuple transparently replaces tuple and gracefully
degrades to the old behavior.</li>
<li>Does not require a change in the C interface</li>
</ul>
<a name="user-content-id5"/>
<h4><a id="user-content-cons-2" class="anchor" href="#cons-2" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Cons</h4>
<ul>
<li>According to some sources <a href="#namedtuple" id="user-content-id6">[4]</a> namedtuple is not well developed.
To include it as such important object would probably require rework
and improvement;</li>
<li>The namedtuple fields, and thus the type, will have to change according
to the passed arguments. This can be a performance bottleneck, and makes
it impossible to guarantee that two subsequent index accesses get the same
Index class;</li>
<li>the <code>_n</code> "magic" fields are a bit unusual, but ipython already uses them
for result history.</li>
<li>Python currently has no builtin namedtuple. The current one is available
in the "collections" module in the standard library.</li>
<li>Differently from a function, the two notations <code>gridValues[x=3, y=5, z=8]</code>
and <code>gridValues[3,5,8]</code> would not gracefully match if the order is modified
at call time (e.g. we ask for <code>gridValues[y=5, z=8, x=3])</code>. In a function,
we can pre-define argument names so that keyword arguments are properly
matched. Not so in <code>__getitem__</code>, leaving the task for interpreting and
matching to <code>__getitem__</code> itself.</li>
</ul>
<a name="user-content-strategy-new-argument-contents"/>
<h3><a id="user-content-strategy-new-argument-contents" class="anchor" href="#strategy-new-argument-contents" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Strategy "New argument contents"</h3>
<p>In the current implementation, when many arguments are passed to <code>__getitem__</code>,
they are grouped in a tuple and this tuple is passed to <code>__getitem__</code> as the
single argument <code>idx</code>. This strategy keeps the current signature, but expands the
range of variability in type and contents of <code>idx</code> to more complex representations.</p>
<p>We identify four possible ways to implement this strategy:</p>
<ul>
<li><strong>P1</strong>: uses a single dictionary for the keyword arguments.</li>
<li><strong>P2</strong>: uses individual single-item dictionaries.</li>
<li><strong>P3</strong>: similar to <strong>P2</strong>, but replaces single-item dictionaries with a <code>(key, value)</code> tuple.</li>
<li><strong>P4</strong>: similar to <strong>P2</strong>, but uses a special and additional new object: <code>keyword()</code></li>
</ul>
<p>Some of these possibilities lead to degenerate notations, i.e. indistinguishable
from an already possible representation. Once again, the proposed notation
becomes syntactic sugar for these representations.</p>
<p>Under this strategy, the old behavior for C0 is unchanged.</p>
<pre>C0: a[1]        -&gt; idx = 1                    # integer
    a[1,2]      -&gt; idx = (1,2)                # tuple
</pre>
<p>In C1, we can use either a dictionary or a tuple to represent key and value pair
for the specific indexing entry. We need to have a tuple with a tuple in C1
because otherwise we cannot differentiate <code>a["Z", 3]</code> from <code>a[Z=3]</code>.</p>
<pre>C1: a[Z=3]      -&gt; idx = {"Z": 3}             # P1/P2 dictionary with single key
                or idx = (("Z", 3),)          # P3 tuple of tuples
                or idx = keyword("Z", 3)      # P4 keyword object
</pre>
<p>As you can see, notation P1/P2 implies that <code>a[Z=3]</code> and <code>a[{"Z": 3}]</code> will
call <code>__getitem__</code> passing the exact same value, and is therefore syntactic
sugar for the latter. Same situation occurs, although with different index, for
P3. Using a keyword object as in P4 would remove this degeneracy.</p>
<p>For the C2 case:</p>
<pre>C2. a[Z=3, R=4] -&gt; idx = {"Z": 3, "R": 4}     # P1 dictionary/ordereddict
                or idx = ({"Z": 3}, {"R": 4}) # P2 tuple of two single-key dict
                or idx = (("Z", 3), ("R", 4)) # P3 tuple of tuples
                or idx = (keyword("Z", 3),
                          keyword("R", 4) )   # P4 keyword objects
</pre>
<p>P1 naturally maps to the traditional <code>**kwargs</code> behavior, however it breaks
the convention that two or more entries for the index produce a tuple.  P2
preserves this behavior, and additionally preserves the order.  Preserving the
order would also be possible with an OrderedDict as drafted by PEP-468 <a href="#pep-468" id="user-content-id7">[5]</a>.</p>
<p>The remaining cases are here shown:</p>
<pre>C3. a[1, Z=3]   -&gt; idx = (1, {"Z": 3})                     # P1/P2
                or idx = (1, ("Z", 3))                     # P3
                or idx = (1, keyword("Z", 3))              # P4

C4. a[1, Z=3, R=4] -&gt; idx = (1, {"Z": 3, "R": 4})          # P1
                   or idx = (1, {"Z": 3}, {"R": 4})        # P2
                   or idx = (1, ("Z", 3), ("R", 4))        # P3
                   or idx = (1, keyword("Z", 3),
                                keyword("R", 4))           # P4

C5. a[1, 2, Z=3]   -&gt; idx = (1, 2, {"Z": 3})               # P1/P2
                   or idx = (1, 2, ("Z", 3))               # P3
                   or idx = (1, 2, keyword("Z", 3))        # P4

C6. a[1, 2, Z=3, R=4] -&gt; idx = (1, 2, {"Z":3, "R": 4})     # P1
                      or idx = (1, 2, {"Z": 3}, {"R": 4})  # P2
                      or idx = (1, 2, ("Z", 3), ("R", 4))  # P3
                      or idx = (1, 2, keyword("Z", 3),
                                      keyword("R", 4))     # P4

C7. a[1, Z=3, 2, R=4] -&gt; idx = (1, 2, {"Z": 3, "R": 4})    # P1. Pack the keyword arguments. Ugly.
                      or raise SyntaxError                 # P1. Same behavior as in function calls.
                      or idx = (1, {"Z": 3}, 2, {"R": 4})  # P2
                      or idx =  (1, ("Z", 3), 2, ("R", 4)) # P3
                      or idx =  (1, keyword("Z", 3),
                                 2, keyword("R", 4))       # P4
</pre>
<a name="user-content-id8"/>
<h4><a id="user-content-pros-3" class="anchor" href="#pros-3" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Pros</h4>
<ul>
<li>Signature is unchanged;</li>
<li>P2/P3 can preserve ordering of keyword arguments as specified at indexing,</li>
<li>P1 needs an OrderedDict, but would destroy interposed ordering if allowed:
all keyword indexes would be dumped into the dictionary;</li>
<li>Stays within traditional types: tuples and dicts. Evt. OrderedDict;</li>
<li>Some proposed strategies are similar in behavior to a traditional function call;</li>
<li>The C interface for <code>PyObject_GetItem</code> and family would remain unchanged.</li>
</ul>
<a name="user-content-id9"/>
<h4><a id="user-content-cons-3" class="anchor" href="#cons-3" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Cons</h4>
<ul>
<li>Apparenty complex and wasteful;</li>
<li>Degeneracy in notation (e.g. <code>a[Z=3]</code> and <code>a[{"Z":3}]</code> are equivalent and
indistinguishable notations at the <code>__[get|set|del]item__</code> level).
This behavior may or may not be acceptable.</li>
<li>for P4, an additional object similar in nature to slice() is needed,
but only to disambiguate the above degeneracy.</li>
<li><code>idx</code> type and layout seems to change depending on the whims of the caller;</li>
<li>May be complex to parse what is passed, especially in the case of tuple of tuples;</li>
<li>P2 Creates a lot of single keys dictionary as members of a tuple. Looks ugly.
P3 would be lighter and easier to use than the tuple of dicts, and still
preserves order (unlike the regular dict), but would result in clumsy
extraction of keywords.</li>
</ul>
<a name="user-content-strategy-kwargs-argument"/>
<h3><a id="user-content-strategy-kwargs-argument" class="anchor" href="#strategy-kwargs-argument" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Strategy "kwargs argument"</h3>
<p><code>__getitem__</code> accepts an optional <code>**kwargs</code> argument which should be keyword only.
<code>idx</code> also becomes optional to support a case where no non-keyword arguments are allowed.
The signature would then be either</p>
<pre>__getitem__(self, idx)
__getitem__(self, idx, **kwargs)
__getitem__(self, **kwargs)
</pre>
<p>Applied to our cases would produce:</p>
<pre>C0. a[1,2]            -&gt; idx=(1,2);  kwargs={}
C1. a[Z=3]            -&gt; idx=None ;  kwargs={"Z":3}
C2. a[Z=3, R=4]       -&gt; idx=None ;  kwargs={"Z":3, "R":4}
C3. a[1, Z=3]         -&gt; idx=1    ;  kwargs={"Z":3}
C4. a[1, Z=3, R=4]    -&gt; idx=1    ;  kwargs={"Z":3, "R":4}
C5. a[1, 2, Z=3]      -&gt; idx=(1,2);  kwargs={"Z":3}
C6. a[1, 2, Z=3, R=4] -&gt; idx=(1,2);  kwargs={"Z":3, "R":4}
C7. a[1, Z=3, 2, R=4] -&gt; raise SyntaxError # in agreement to function behavior
</pre>
<p>Empty indexing <code>a[]</code> of course remains invalid syntax.</p>
<a name="user-content-id10"/>
<h4><a id="user-content-pros-4" class="anchor" href="#pros-4" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Pros</h4>
<ul>
<li>Similar to function call, evolves naturally from it;</li>
<li>Use of keyword indexing with an object whose <code>__getitem__</code>
doesn't have a kwargs will fail in an obvious way.
That's not the case for the other strategies.</li>
</ul>
<a name="user-content-id11"/>
<h4><a id="user-content-cons-4" class="anchor" href="#cons-4" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Cons</h4>
<ul>
<li>It doesn't preserve order, unless an OrderedDict is used;</li>
<li>Forbids C7, but is it really needed?</li>
<li>Requires a change in the C interface to pass an additional
PyObject for the keyword arguments.</li>
</ul>
<a name="user-content-c-interface"/>
<h2><a id="user-content-c-interface" class="anchor" href="#c-interface" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>C interface</h2>
<p>As briefly introduced in the previous analysis, the C interface would
potentially have to change to allow the new feature. Specifically,
<code>PyObject_GetItem</code> and related routines would have to accept an additional
<code>PyObject *kw</code> argument for Strategy "kwargs argument". The remaining
strategies would not require a change in the C function signatures, but the
different nature of the passed object would potentially require adaptation.</p>
<p>Strategy "named tuple" would behave correctly without any change: the class
returned by the factory method in collections returns a subclass of tuple,
meaning that <code>PyTuple_*</code> functions can handle the resulting object.</p>
<a name="user-content-alternative-solutions"/>
<h2><a id="user-content-alternative-solutions" class="anchor" href="#alternative-solutions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Alternative Solutions</h2>
<p>In this section, we present alternative solutions that would workaround the
missing feature and make the proposed enhancement not worth of implementation.</p>
<a name="user-content-use-a-method"/>
<h3><a id="user-content-use-a-method" class="anchor" href="#use-a-method" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Use a method</h3>
<p>One could keep the indexing as is, and use a traditional <code>get()</code> method for those
cases where basic indexing is not enough. This is a good point, but as already
reported in the introduction, methods have a different semantic weight from
indexing, and you can't use slices directly in methods. Compare e.g.
<code>a[1:3, Z=2]</code> with <code>a.get(slice(1,3), Z=2)</code>.</p>
<p>The authors however recognize this argument as compelling, and the advantage
in semantic expressivity of a keyword-based indexing may be offset by a rarely
used feature that does not bring enough benefit and may have limited adoption.</p>
<a name="user-content-emulate-requested-behavior-by-abusing-the-slice-object"/>
<h3><a id="user-content-emulate-requested-behavior-by-abusing-the-slice-object" class="anchor" href="#emulate-requested-behavior-by-abusing-the-slice-object" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Emulate requested behavior by abusing the slice object</h3>
<p>This extremely creative method exploits the slice objects' behavior, provided
that one accepts to use strings (or instantiate properly named placeholder
objects for the keys), and accept to use ":" instead of "=".</p>
<pre>&gt;&gt;&gt; a["K":3]
slice('K', 3, None)
&gt;&gt;&gt; a["K":3, "R":4]
(slice('K', 3, None), slice('R', 4, None))
&gt;&gt;&gt;
</pre>
<p>While clearly smart, this approach does not allow easy inquire of the key/value
pair, it's too clever and esotheric, and does not allow to pass a slice as in
<code>a[K=1:10:2]</code>.</p>
<p>However, Tim Delaney comments</p>
<blockquote>
"I really do think that <code>a[b=c, d=e]</code> should just be syntax sugar for
<code>a['b':c, 'd':e]</code>. It's simple to explain, and gives the greatest backwards
compatibility. In particular, libraries that already abused slices in this
way will just continue to work with the new syntax."</blockquote>
<p>We think this behavior would produce inconvenient results. The library Pandas uses
strings as labels, allowing notation such as</p>
<pre>&gt;&gt;&gt; a[:, "A":"F"]
</pre>
<p>to extract data from column "A" to column "F". Under the above comment, this notation
would be equally obtained with</p>
<pre>&gt;&gt;&gt; a[:, A="F"]
</pre>
<p>which is weird and collides with the intended meaning of keyword in indexing, that
is, specifying the axis through conventional names rather than positioning.</p>
<a name="user-content-pass-a-dictionary-as-an-additional-index"/>
<h3><a id="user-content-pass-a-dictionary-as-an-additional-index" class="anchor" href="#pass-a-dictionary-as-an-additional-index" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Pass a dictionary as an additional index</h3>
<pre>&gt;&gt;&gt; a[1, 2, {"K": 3}]
</pre>
<p>this notation, although less elegant, can already be used and achieves similar
results. It's evident that the proposed Strategy "New argument contents" can be
interpreted as syntactic sugar for this notation.</p>
<a name="user-content-additional-comments"/>
<h2><a id="user-content-additional-comments" class="anchor" href="#additional-comments" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Additional Comments</h2>
<p>Commenters also expressed the following relevant points:</p>
<a name="user-content-relevance-of-ordering-of-keyword-arguments"/>
<h3><a id="user-content-relevance-of-ordering-of-keyword-arguments" class="anchor" href="#relevance-of-ordering-of-keyword-arguments" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Relevance of ordering of keyword arguments</h3>
<p>As part of the discussion of this PEP, it's important to decide if the ordering
information of the keyword arguments is important, and if indexes and keys can
be ordered in an arbitrary way (e.g. <code>a[1,Z=3,2,R=4]</code>). PEP-468 <a href="#pep-468" id="user-content-id12">[5]</a>
tries to address the first point by proposing the use of an ordereddict,
however one would be inclined to accept that keyword arguments in indexing are
equivalent to kwargs in function calls, and therefore as of today equally
unordered, and with the same restrictions.</p>
<a name="user-content-need-for-homogeneity-of-behavior"/>
<h3><a id="user-content-need-for-homogeneity-of-behavior" class="anchor" href="#need-for-homogeneity-of-behavior" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Need for homogeneity of behavior</h3>
<p>Relative to Strategy "New argument contents", a comment from Ian Cordasco
points out that</p>
<blockquote>
"it would be unreasonable for just one method to behave totally
differently from the standard behaviour in Python.  It would be confusing for
only <code>__getitem__</code> (and ostensibly, <code>__setitem__</code>) to take keyword
arguments but instead of turning them into a dictionary, turn them into
individual single-item dictionaries." We agree with his point, however it must
be pointed out that <code>__getitem__</code> is already special in some regards when it
comes to passed arguments.</blockquote>
<p>Chris Angelico also states:</p>
<blockquote>
"it seems very odd to start out by saying "here, let's give indexing the
option to carry keyword args, just like with function calls", and then come
back and say "oh, but unlike function calls, they're inherently ordered and
carried very differently"." Again, we agree on this point.  The most
straightforward strategy to keep homogeneity would be Strategy "kwargs
argument", opening to a <code>**kwargs</code> argument on <code>__getitem__</code>.</blockquote>
<p>One of the authors (Stefano Borini) thinks that only the "strict dictionary"
strategy is worth of implementation. It is non-ambiguous, simple, does not
force complex parsing, and addresses the problem of referring to axes either
by position or by name. The "options" use case is probably best handled with
a different approach, and may be irrelevant for this PEP. The alternative
"named tuple" is another valid choice.</p>
<a name="user-content-having-get-become-obsolete-for-indexing-with-default-fallback"/>
<h3><a id="user-content-having-get-become-obsolete-for-indexing-with-default-fallback" class="anchor" href="#having-get-become-obsolete-for-indexing-with-default-fallback" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Having .get() become obsolete for indexing with default fallback</h3>
<p>Introducing a "default" keyword could make <code>dict.get()</code> obsolete, which would be
replaced by <code>d["key", default=3]</code>. Chris Angelico however states:</p>
<blockquote>
"Currently, you need to write <code>__getitem__</code> (which raises an exception on
finding a problem) plus something else, e.g. <code>get()</code>, which returns a default
instead. By your proposal, both branches would go inside <code>__getitem__</code>, which
means they could share code; but there still need to be two branches."</blockquote>
<p>Additionally, Chris continues:</p>
<blockquote>
"There'll be an ad-hoc and fairly arbitrary puddle of names (some will go
<code>default=</code>, others will say that's way too long and go <code>def=</code>, except that
that's a keyword so they'll use <code>dflt=</code> or something...), unless there's a
strong force pushing people to one consistent name.".</blockquote>
<p>This argument is valid but it's equally valid for any function call, and is
generally fixed by established convention and documentation.</p>
<a name="user-content-on-degeneracy-of-notation"/>
<h3><a id="user-content-on-degeneracy-of-notation" class="anchor" href="#on-degeneracy-of-notation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>On degeneracy of notation</h3>
<p>User Drekin commented: "The case of <code>a[Z=3]</code> and <code>a[{"Z": 3}]</code> is similar to
current <code>a[1, 2]</code> and <code>a[(1, 2)]</code>.  Even though one may argue that the parentheses
are actually not part of tuple notation but are just needed because of syntax,
it may look as degeneracy of notation when compared to function call: <code>f(1, 2)</code>
is not the same thing as <code>f((1, 2))</code>.".</p>
<a name="user-content-references"/>
<h2><a id="user-content-references" class="anchor" href="#references" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>References</h2>




<table frame="void" id="user-content-pep-468" rules="none">

<tbody valign="top">
<tr><td>[5]</td><td><em>(<a href="#id1">1</a>, <a href="#id7">2</a>, <a href="#id12">3</a>)</em> "Preserving the order of **kwargs in a function."
<a href="http://legacy.python.org/dev/peps/pep-0468/">http://legacy.python.org/dev/peps/pep-0468/</a></td></tr>
</tbody>
</table>
<a name="user-content-copyright"/>
<h2><a id="user-content-copyright" class="anchor" href="#copyright" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Copyright</h2>
<p>This document has been placed in the public domain.</p>

</article>
  </div></body></html>