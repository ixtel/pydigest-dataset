<html><body><div><div class="post_content" itemprop="articleBody">

<p>Regular expressions as a concept is not exclusive to Python at all.</p>
<p>Python, however, does have some nuances when it come to working with regular expressions.</p>
<p>This article is part of a series of articles on Python Regular Expressions.<br/>
<span id="more-16047"/><br/>
In the first article of this series, we will focus on discussing how we work with regular expressions in python, highlighting python specifics.</p>
<p>We are going to introduce the methods we can use to perform queries over strings in Python. We’ll then talk about how we can use grouping to work with sub-parts of the matches we found using our queries.</p>
<p>The package we are interested in using to work with regular expressions in python is appropriately named ‘re’.</p>
<pre>  &gt;&gt;&gt; import re</pre>
<h3>1. Raw Strings in Python</h3>
<p>The python parser interprets ‘\’ (backslashes) as escape characters in string literals.</p>
<p>If the backslash is followed by a special sequence recognized by the parser, the whole escape sequence is replaced by a corresponding special character (for example, ‘\n’ is replaced by a newline character when processed by the parser).</p>
    <center>
      <p>

        
		


<ins class="adsbygoogle" data-ad-client="ca-pub-8090601437064582" data-ad-slot="8643685131"/>


        

	  </p>
    </center>


<p>This behavior causes a problem when working with regular expressions in python because the ‘re’ package also uses backslash characters to escape special regex characters (like * or +).</p>
<p>The combination of these two behaviors would mean that sometimes you would have to escape escape characters themselves (when the special character was recognized by both the python parser and the regex parser), yet other times you would not (if the special character was not recognized by the python parser).</p>
<p>Rather than bend our brains trying to figure out how many backslashes we need, we can instead use raw strings.</p>
<p>A raw string is created by simply adding an ‘r’ character before the opening quote of a normal string. When a string is raw, the python parser will not even attempt to make any substitutions within it. Essentially, you are telling the parser to completely leave your string alone.</p>
<pre>  &gt;&gt;&gt; string = 'This is a\nnormal string'
  &gt;&gt;&gt; rawString = r'and this is a\nraw string'
  &gt;&gt;&gt; print string
  This is a
  normal string
  &gt;&gt;&gt; print rawString
  and this is a\nraw string</pre>
<h3>Performing Queries with Regex in Python</h3>
<p>The ‘re’ package provides several methods to actually perform queries on an input string. The methods that we will be discussing are:</p>
<ul>
<li>re.match()</li>
<li>re.search()</li>
<li>re.findall()</li>
</ul>
<p>Each of the methods accepts a regular expression, and string to scan for matches. Lets take a look at each of these methods in a little more detail to see how they work and how they differ.</p>
<h3>2. Find Using re.match – Matches Beginning</h3>
<p>Lets first take a look at the match() method. The way the match() method works is that it will only find matches if they occur at the start of the string being searched.</p>
<p>So for example, calling match() on the string ‘dog cat dog’, looking for the pattern ‘dog’ will match:</p>
<pre>  &gt;&gt;&gt; re.match(r'dog', 'dog cat dog')
  &lt;_sre.SRE_Match object at 0xb743e720&lt;
  &gt;&gt;&gt; match = re.match(r'dog', 'dog cat dog')
  &gt;&gt;&gt; match.group(0)
  'dog'</pre>
<p>We’ll be talking more about the group() method in a little bit. For now, just know that when called with 0 as it’s argument, the group() method returns the pattern matched by the query.</p>
<p>I’m also glossing over the returned SRE_Match object for now, we’ll talk about that in a minute too.</p>
<p>But, if we call match() on the same string, looking for the pattern ‘cat’, we won’t:</p>
<pre>  &gt;&gt;&gt; re.match(r'cat', 'dog cat dog')
  &gt;&gt;&gt;</pre>
<h3>3. Find Using re.search – Matches Anywhere</h3>
<p>The search() method is similar to match(), but search() doesn’t restrict us to only finding matches at the beginning of the string, so searching for ‘cat’ in our example string finds a match:</p>
<pre>  search(r'cat', 'dog cat dog')
  &gt;&gt;&gt; match.group(0)
  'cat'</pre>
<p>The search() method, however, stops looking after it finds a match, so search()-ing for ‘dog’ in our example string only finds the first occurrence:</p>
<pre>  &gt;&gt;&gt; match = re.search(r'dog', 'dog cat dog')
  &gt;&gt;&gt; match.group(0)
  'dog'</pre>
<h3>4. Get Using re.findall – All Matching Objects</h3>
<p>The querying method that I use by far the most in python though is the findall() method. Rather than being returned match objects (we’ll talk more about match objects in a little bit), when we call findall(), we simply get a list of all matching patterns. For me, this is just simpler. Calling findall() on our example string we get:</p>
<pre>  &gt;&gt;&gt; re.findall(r'dog', 'dog cat dog')
  ['dog', 'dog']
  &gt;&gt;&gt; re.findall(r'cat', 'dog cat dog')
  ['cat']</pre>
<h3>5. Use match.start and match.end Methods</h3>
<p>So, what exactly are these ‘match objects’ that search() and match() gave us earlier?</p>
<p>Rather than simply return the matching portion of the string, search() and match() return ‘matches’, which are essentially a wrapper around the matching substring.</p>
<p>You saw earlier that I could get to the matching substring by calling the matches group() method, (match objects are actually pretty useful when it comes to working with grouping, as we will see in the next section), but the match object also contains much more information about the matching substring.</p>
<p>For example, the match object can tell us the start and end indexes of the matching content from the original string:</p>
<pre>  &gt;&gt;&gt; match = re.search(r'dog', 'dog cat dog')
  &gt;&gt;&gt; match.start()
  0
  &gt;&gt;&gt; match.end()
  3</pre>
<p>Knowing information like this can sometimes be very useful.</p>
<h3>6. Group by Number Using match.group</h3>
<p>As I mentioned earlier, match objects come in very handy when working with grouping.</p>
<p>Grouping is the ability to address certain sub-parts of the entire regex match. We can define a group as a piece of the regular expression search string, and then individually address the corresponding content that was matched by this piece.</p>
<p>Let’s look at an example to see how this works:</p>
<pre>  &gt;&gt;&gt; contactInfo = 'Doe, John: 555-1212'</pre>
<p>The string I just created resembles a snippet taken out of someones address book. We can match the line with a regular expression like this one:</p>
<pre>  &gt;&gt;&gt; re.search(r'\w+, \w+: \S+', contactInfo)
  &lt;_sre.SRE_Match object at 0xb74e1ad8&lt;</pre>
<p>By surrounding certain parts of the regular expression in parentheses (the ‘(‘ and ‘)’ characters), we can group the content and then work with these individual groups.</p>
<pre>  &gt;&gt;&gt; match = re.search(r'(\w+), (\w+): (\S+)', contactInfo)</pre>
<p>These groups can be fetched using the match object’s group() method. The groups are addressable numerically in the order that they appear, from left to right, in the regular expression (starting with group 1):</p>
<pre>  &gt;&gt;&gt; match.group(1)
  'Doe'
  &gt;&gt;&gt; match.group(2)
  'John'
  &gt;&gt;&gt; match.group(3)
  '555-1212'</pre>
<p>The reason that the group numbering starts with group 1 is because group 0 is reserved to hold the entire match (we saw this earlier when we were learning about the match() and search() methods)</p>
<pre>  &gt;&gt;&gt; match.group(0)
  'Doe, John: 555-1212'</pre>
<h3>7. Grouping by Name Using match.group</h3>
<p>Sometimes, especially when a regular expression has a lot of groups, it is impractical to address each group by its number. Python also allows you to assign a name to a group using the following syntax:</p>
<pre>  &gt;&gt;&gt; match = re.search(r'(?P&lt;last&gt;\w+), (?P&lt;first&gt;\w+): (?P&lt;phone&gt;\S+)', contactInfo)</pre>
<p>When can still fetch the grouped content using the group() method, but this time specifying the names we assigned the groups instead of the numbering we used before:</p>
<pre>  &gt;&gt;&gt; match.group('last')
  'Doe'
  &gt;&gt;&gt; match.group('first')
  'John'
  &gt;&gt;&gt; match.group('phone')
  '555-1212'</pre>
<p>This makes for much more explicit and readable code. You can imagine that as the regular expression became more and more complicated, understanding what was being captured by a grouping would get harder and harder. Assigning names to your groups explicitly informs you and your readers of your intentions.</p>
<p>Grouping can be used with the findall() method too, even though it doesn’t return match objects. Instead, findall() will return a list of tuples, where the Nth element of each tuple corresponds to the Nth group of the regex pattern:</p>
<pre>  &gt;&gt;&gt; re.findall(r'(\w+), (\w+): (\S+)', contactInfo)
  [('Doe', 'John', '555-1212')]</pre>
<p>However, named grouping doesn’t work when using the findall() method.</p>
<p>In this article we’ve introduced the basics of working with regular expressions in Python. We’ve learned about raw strings (and the headaches that they can save you when working with regular expressions). We’ve also learned how to perform basic queries using the match(), search(), and findall() methods, and even how to work with sub-components of a match using grouping.</p>
<p>As always, to find out more about this topic, the Python Official documentation on <a href="https://docs.python.org/2/library/re.html">re package</a> is a great resource.</p>
<p>In future articles, we’ll dive deeper into regular expressions in Python. We’ll talk about how we can capture an even broader range of matches, how we can use them to make substitutions within a string, and how we can even use them to parse python data structures out of text files.</p>

<h3>If you enjoyed this article, you might also like..</h3>


<center>

</center>

				</div>
				</div></body></html>