<html><body><div><div class="section">
              <h1>whisker 0.1.2</h1>

              


<p>Whisker Python client library</p><p>








.. For RST help, see http://www.sphinx-doc.org/en/stable/rest.html</p><p>.. include:: doc/symbols/isonum.txt</p><p>===============================================================================</p><p>whisker</p><p>===============================================================================</p><p>Python package for Whisker clients.</p><p>- Whisker is a TCP/IP-based research control software suite.</p><p>  See http://www.whiskercontrol.com/</p><p>TL;DR</p><p>===============================================================================</p><p>-   :code:`pip install whisker`</p><p>-   Copy/paste the demo config file and demo task under "A complete simple</p><p>    task" at the end.</p><p>-   If you have a Whisker server running, this should now work.</p><p>Author/licensing</p><p>===============================================================================</p><p>By Rudolf Cardinal (rudolf@pobox.com).</p><p>Copyright |copy| Rudolf Cardinal.</p><p>Licensed under a permissive open-source license; see LICENSE.</p><p>Usage</p><p>===============================================================================</p><p>There are three styles of Whisker client available. Full worked exampes are</p><p>shown below, along with a rationale for their use. The outlines, however,</p><p>look like these:</p><p>Twisted client (preferred for simple interfaces)</p><p>------------------------------------------------</p><p>.. code:: python</p><p>    from twisted.internet import reactor</p><p>    from whisker.twistedclient import WhiskerTask</p><p>    class MyWhiskerTask(WhiskerTask):</p><p>        # ...</p><p>    w = MyWhiskerTask()</p><p>    w.connect(...)</p><p>    reactor.run()</p><p>Qt client (preferred for GUI use)</p><p>---------------------------------</p><p>More complex; see the Starfeeder project example.</p><p>Raw socket client (deprecated)</p><p>------------------------------</p><p>.. code:: python</p><p>    from whisker.rawsocketclient import Whisker</p><p>    w = Whisker()</p><p>    w.connect_both_ports(...)</p><p>    # ...</p><p>    for line in w.getlines_mainsocket():</p><p>        # ...</p><p>Rationale</p><p>===============================================================================</p><p>Approaches to sockets and message passing</p><p>-------------------------------------------------------------------------------</p><p>Whisker allows a multitude of clients in a great many languages -- anything</p><p>that can "speak" down a TCP/IP port, such as C++, Visual Basic, Perl, and</p><p>Python.</p><p>Whisker uses two sockets, a "main" socket, through which the Whisker server</p><p>can send events unprompted, and an "immediate" socket, used for sending</p><p>commands/queries and receiving immediate replies with a one-to-one</p><p>relationship between commands (client |rarr| server) and responses (server |rarr|</p><p>client). Consequently, the client must deal with unpredictable events</p><p>coming from the server. It might also have to deal with some sort of user</p><p>interface (UI) code (and other faster things, like data storage).</p><p>C++</p><p>~~~</p><p>In C++/MFC, sockets get their own thread anyway, and the framework tries to</p><p>hide this from you. So the GUI and sockets coexists fairly happily. Many</p><p>Whisker tasks use C++, but it's not the easiest thing in the world.</p><p>Perl</p><p>~~~~</p><p>In Perl, I've used only a very basic approach with a manual message loop,</p><p>like this:</p><p>.. include:: doc/whisker_client_snippet.pl</p><p>    :code: perl</p><p>Python</p><p>~~~~~~</p><p>In Python, I've used the following approaches:</p><p>Manual event loop</p><p>:::::::::::::::::</p><p>You can use base socket code, and poll the main</p><p>socket for input regularly. Simple. But you can forget about</p><p>simultaneous UI. Like this:</p><p>.. include:: whisker/test_rawsockets.py</p><p>    :code: python</p><p>Non-threaded, event-driven</p><p>::::::::::::::::::::::::::</p><p>The Twisted library is great for this (https://twistedmatrix.com/) However:</p><p>-   Bits of it, like Tkinter integration, still don't support Python 3 fully</p><p>    (as of 2015-12-23), though this is not a major problem (it's easy to</p><p>    hack in relevant bits of Python 3 support).</p><p>-   Though it will integrate its event loop (reactor) with several GUI</p><p>    toolkits, e.g.</p><p>    http://twistedmatrix.com/documents/current/core/howto/choosing-reactor.html</p><p>    this can still fail; e.g. with Tkinter, if you open a system dialogue</p><p>    (such as the standard "Open File..." or "Save As..." dialogues), the</p><p>    Twisted reactor will stop and wait, which is no good.</p><p>    This is a much bigger problem.</p><p>    (More detail on this problem in my dev_notes.txt for the starfeeder</p><p>    project.)</p><p>-   So one could use Twisted with no user interaction during the task.</p><p>It looks, from the task writer's perspective, like this:</p><p>.. include:: whisker/test_twisted.py</p><p>    :code: python</p><p>Multithreading</p><p>::::::::::::::</p><p>For multithreading we can use Qt (with the PySide bindings). In this approach,</p><p>the Whisker task runs in separate threads from the UI. This works well,</p><p>though is not without some complexity. The Qt interface is nice, and</p><p>can be fairly fancy. You have to be careful with database access if</p><p>using SQLite (which is not always happy in a multithreaded context).</p><p>Verdict for simple uses</p><p>:::::::::::::::::::::::</p><p>Use Twisted and avoid any UI code while the task is running.</p><p>Database access</p><p>-------------------------------------------------------------------------------</p><p>Database backend</p><p>~~~~~~~~~~~~~~~~</p><p>There are distinct advantages to making SQLite the default, namely:</p><p>-   It comes with everything (i.e. no installation required);</p><p>-   Database can be copied around as single files.</p><p>On the downside, it doesn't cope with multithreading/multiuser access quite</p><p>as well as "bigger" databases like MySQL.</p><p>Users will want simple textfile storage as well.</p><p>Front end</p><p>~~~~~~~~~</p><p>The options for SQLite access include direct access:</p><p>    https://docs.python.org/3.4/library/sqlite3.html</p><p>and SQLAlchemy:</p><p>    http://www.sqlalchemy.org/</p><p>Getting fancier, it's possible to manage database structure migrations with</p><p>tools like Alembic (for SQLAlchemy), but this may be getting too complicated</p><p>for the target end user.</p><p>However, the other very pleasantly simple front-end is dataset:</p><p>    https://dataset.readthedocs.org/en/latest/</p><p>User interface</p><p>-------------------------------------------------------------------------------</p><p>A GUI can consume a lot of programmer effort. Let's keep this minimal or</p><p>absent as the general rule; for more advanced coding, the coder can do</p><p>his/her own thing (a suggestion: Qt).</p><p>Task configuration</p><p>-------------------------------------------------------------------------------</p><p>Much of the GUI is usually about configuration. So let's get rid of all</p><p>that, because we're aiming at very simple programming here. Let's just</p><p>put config in a simple structure like JSON or YAML, and have the user edit it</p><p>separately.</p><p>JSON</p><p>~~~~</p><p>An example program:</p><p>.. include:: doc/json_config_example.py</p><p>    :code: python</p><p>The JSON looks like:</p><p>.. include:: doc/json_config_demo.json</p><p>    :code: json</p><p>YAML with attrdict</p><p>~~~~~~~~~~~~~~~~~~</p><p>This can be a bit fancier in terms of the object structure it can represent,</p><p>a bit cleaner in terms of the simplicity of the config file, and safer in terms</p><p>of security from dodgy config files.</p><p>Using an AttrDict allows a cleaner syntax for reading/writing the Python</p><p>object.</p><p>.. include:: doc/yaml_config_example.py</p><p>    :code: python</p><p>The YAML looks like this:</p><p>.. include:: doc/yaml_config_demo.yaml</p><p>    :code: yaml</p><p>A quick YAML tutorial</p><p>:::::::::::::::::::::</p><p>A key:value pair looks like:</p><p>.. code:: yaml</p><p>    key: value</p><p>A list looks like:</p><p>.. code:: yaml</p><p>    list:</p><p>        - value1</p><p>        - value2</p><p>        # ...</p><p>A dictionary looks like:</p><p>.. code:: yaml</p><p>    dict:</p><p>        key1: value1</p><p>        key2: value2</p><p>        # ...</p><p>Verdict for simple uses</p><p>~~~~~~~~~~~~~~~~~~~~~~~</p><p>Use YAML with AttrDict.</p><p>Package distribution</p><p>-------------------------------------------------------------------------------</p><p>This should be via PyPI, so users can just do:</p><p>.. code:: python</p><p>    pip3 install whisker</p><p>    # ...</p><p>    from whisker import ...</p><p>A complete simple task</p><p>===============================================================================</p><p>Having done :code:`pip install whisker`, you should be able to do this:</p><p>.. include:: doc/demo_config.yaml</p><p>    :code: yaml</p><p>.. include:: doc/demo_simple_whisker_client.py</p><p>    :code: python

</p><a name="downloads">Â </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>80</span> downloads in the last week
  </li>
  <li>
    <span>619</span> downloads in the last month
  </li>
</ul>









            </div>


          </div></body></html>