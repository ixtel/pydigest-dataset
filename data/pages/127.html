<html><body><div><div class="post">
<p>In this entry we will dive into the world of dynamic programming, by looking at
one of the most simplest yet illustrative algorithmic problems, namely
the problem of Interval Scheduling. We will start with special case of unweighted interval scheduling,
and then elaborate from there into a more general case of weighted intervals.</p>

<h2 id="sample-problem">Sample Problem</h2>

<p>Some time ago when working on student and course management system for my client I needed to find out
how many teaching periods are there withing a given date range.</p>

<p>Colleges and universities have different teaching periods types e.g.
semesters, trimesters, quarters, summer terms of various length. So, with a date range given, what is the maximum
study duration of non-overlapping terms within that range? That’s if our aim was to spend as much time at school as possible
(consider we suddenly went crazy) what teaching periods should we consider enrolling in.</p>

<p>Here is sample set of available teaching periods:</p>

<p><span class="image-container">
<img src="/assets/posts/weighted-interval-scheduling/teaching-periods.png" alt="Teaching Periods"/>
</span></p>

<p>Sounds like a simple quest! Take your time to figure it out what algorithm or probably heuristics would you employ?</p>

<div class="bs-callout bs-callout-info">
    <h4>Summer school in January??</h4>
    <p>I am sure that those who spotted that Summer School starts in January, already figured out what's going on. If not,
    then the explantion is trivial: I work for an Australian education provider, and there Summer is from December to
    February.</p>
</div>

<p>If you are new to the problem, chances that you would try some sort of heuristic in search for the <a href="http://en.wikipedia.org/wiki/Greedy_algorithm">greedy algorithm</a>.
For example you might opt for selecting whatever interval starts the earliest (Summer School in our case).</p>

<p>And if it wasn’t for weights (i.e. teaching periods have different durations and thus are <em>weighted</em>) then I bet you
would definitely find such an algorithm. But it takes a bit of more involved process in case of weighted intervals.</p>

<p>The good news: this problem has an elegant and very efficient solution which is not hard to comprehend and implement.</p>

<h2 id="proper-problem-statement">Proper Problem Statement</h2>

<p>While we definitely know what we are looking for, let’s start by redefining our problem more precisely.
Informally, in Weighted Interval Scheduling each interval has a certain value (weight), and we want to select set of intervals of a
maximum total weight.</p>

<p>So, suppose we have set of intervals , let’s denote this set as .</p>

<p>Arbitrary interval  has a start and finish time as  and  respectively. Additionally each  has a weight, denoted as
.</p>

<p>What we want to find is a subset  () of non-overlapping (aka mutually compatible) intervals, with the maximum possible
sum of intervals’ weights:</p>



<p>Don’t panic, that formula is pretty much self explanatory:</p>

<ul>
  <li>Locate subset </li>
  <li>Any two intervals in , say  and , must be non-overlapping. That’s why we require that either
 or  is true.</li>
  <li>Finally we are searching for the maximum sum of intervals weights , hence the <a href="http://en.wikipedia.org/wiki/Arg_max">argmax</a>.</li>
</ul>

<p>Since we have a properly defined problem as well as precisely described expected outcome, it is a good time to start
designing our algorithm.</p>

<h2 id="greedy-algorithm">Greedy algorithm</h2>

<p>First let’s think of Weighted Interval Scheduling problem where each interval has an equal weight i.e. .</p>

<p>Effectively what we will be looking for is to get subset  having as much intervals in it as possible.
Indeed, if intervals have equal length, then the more intervals we are able to select the higher is our total weight.</p>

<p>It is pretty clear that (unweighted) Interval Scheduling is nothing more but a special case of a more general Weighted Interval Scheduling.</p>

<p>If you look into our list of teaching periods you will probably notice that you can select four intervals, maximum:</p>

<ol>
  <li>Summer School</li>
  <li>Trimester 1</li>
  <li>Trimester 2</li>
  <li>Either Trimester 3 or Semester 2</li>
</ol>

<p>The greedy strategy that happens to produce optimal solution  for unweighted intervals is pretty simple:
<strong>accept the interval  which has the minimum finishing time .</strong></p>

<p>That’s it! You just grab interval  which has the earliest , discard any intervals that overlap with ,
and continue until there’s no more intervals to pick from. Try it with our primitive example, you will immediately grasp
what is going on.</p>

<p>Let me further illustrate this with code:</p>

<div class="highlight"><pre><code class="python"><span class="k">class</span> <span class="nc">Interval</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">'''Date interval'''</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">mktime</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="s">"</span><span class="si">%d</span><span class="s"> %b, %y"</span><span class="p">)</span><span class="o">.</span><span class="n">timetuple</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finish</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">mktime</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">finish</span><span class="p">,</span> <span class="s">"</span><span class="si">%d</span><span class="s"> %b, %y"</span><span class="p">)</span><span class="o">.</span><span class="n">timetuple</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">finish</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">schedule_unweighted_intervals</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
    <span class="sd">'''Use greedy algorithm to schedule unweighted intervals</span>
<span class="sd">       sorting is O(n log n), selecting is O(n)</span>
<span class="sd">       whole operation is dominated by O(n log n)</span>
<span class="sd">    '''</span>

    <span class="n">I</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">finish</span> <span class="o">-</span> <span class="n">y</span><span class="o">.</span><span class="n">finish</span><span class="p">)</span>  <span class="c"># f_1 &lt;= f_2 &lt;= .. &lt;= f_n</span>

    <span class="n">O</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">finish</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">finish</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
            <span class="n">finish</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">finish</span>
            <span class="n">O</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">O</span>
</code></pre></div>

<p>If you need more code to look at, here is complete <a href="https://github.com/farazdagi/algorithms/blob/master/interval-scheduling.py">implementation of Interval Scheduling in Python</a>.</p>

<p>Now that we have wrapped up constant weight interval scheduling, what happens to our amazing greedy strategy if intervals have different
weights? <strong>It will fail miserably</strong>.</p>

<p>Just consider situation when we need to decide which one to pick as the last interval: Trimester 3 or Semester 2? If we follow
the greedy method for selection by the smaller finishing time , then we will have to pick Trimester 3 (instead
of more longer Semester 2).</p>

<p>So, while unweighted intervals are easy to schedule, we need to spend more time on weighted ones!</p>

<h2 id="recursive-solution">Recursive solution</h2>

<p>Before we proceed I have to make one assumption: all intervals are sorted by finish times i.e. .
That’s not too much to ask, as you can always sort your data in say  time, therefore it will not add much
to our final asymptotic complexity.</p>

<p>Now, consider two intervals  and . Let’s assume that  is to mean  i.e. interval 
comes before the interval . To make things more straightforward we will define a function :
<strong>rightmost interval , where  and intervals  and  are mutually compatible</strong>.</p>

<p>Basically,  will help us talk about the first interval to the left of  which is not-overlapping with it.
I know that <em>rightmost</em> non-overlapping interval to the <em>left</em> of the , might sound complex at first, but I am sure it will settle
once you meditate on it a bit.</p>

<p>When locating that rightmost interval we can use binary search which has an  running time. Since we
need to find , overall complexity is bound by .</p>

<p>When it comes to Python then <a href="http://docs.python.org/2/library/bisect.html">bisect</a> (yes internally it is implemented as a binary search) module provides a very succinct solution:</p>

<div class="highlight"><pre><code class="python"><span class="k">def</span> <span class="nf">calculate_previous_intervals</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
    <span class="sd">'''For every interval j, calculate the rightmost mutually compatible interval i, where i &lt; j</span>
<span class="sd">       I is a sorted list of Interval objects (sorted by finish time)</span>
<span class="sd">    '''</span>
    <span class="c"># extract start and finish times</span>
    <span class="n">start</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">start</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="p">]</span>
    <span class="n">finish</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">finish</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="p">]</span>

    <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">)):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_right</span><span class="p">(</span><span class="n">finish</span><span class="p">,</span> <span class="n">start</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c"># rightmost interval f_i &lt;= s_j</span>
        <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">p</span>
</code></pre></div>

<p>I also posted on GitHub the complete <a href="https://github.com/farazdagi/algorithms/blob/master/weighted-interval-scheduling.py">implementation of Weighted Interval Selection in Python</a>.</p>

<p>Attention! We come to the crucial point of our discussion, where we will finally get an insight into solving the
Weighted Interval Scheduling problem.</p>

<p>Let’s think about optimal solution . This solution is what we are after, but we do not know what it looks like.
However, even without knowing much about the actual solution we can infer that last interval  is either part of
optimal solution or not:</p>



<p>Indeed, it is perfectly safe to assume such a dichotomy. And since it is a dichotomy, we can look into both
possibilities and see if we can make any further inferences.</p>

<h3 id="case-1-n-in-o">Case 1: </h3>

<p>If  is a part of optimal solution , then we can be sure that no interval between  can be part of
the  (because all intervals within that range will be overlapping with  by the definition of ). So, if
, we can discard intervals .</p>

<p>Another important conclusion is that if , then optimal solution  must also include an optimal solution to the
problem set . Indeed, if  is an optimal solution and , then  can be divided into
 and optimal solution to a set of intervals between  (we denote such a smaller solution as ).</p>

<h3 id="case-2-n-notin-o">Case 2: </h3>

<p>When  then our optimal solution is equal to the optimal solution to a smaller problem consisting of
intervals . Indeed, if  is not a part of optimal solution, then we look for such a solution
within a smaller set consisting of intervals .</p>

<h3 id="finding-optimal-solution-in-set-1dots-j-oj">Finding optimal solution in set , </h3>

<p>After we reviewed both cases it is obvious that in order to find optimal solution  (for  elements) we have to
look into smaller and smaller problems in the form of .</p>

<p>Let’s denote such optimal solution over intervals  as , and actual value (maximum sum of weights) as .
So, for any given  we have the very same dichotomy: either  or , therefore we can
have the crucial piece of our design:</p>



<p>That is value of optimal solution  is either  or , whichever is bigger.</p>

<p>And from this follows another related inference: some arbitrary interval  is a part of optimal solution   iff:</p>



<p>At this point we have everything necessary to solve the original problem. Indeed we have all we need to compute optimal solutions for any
interval  and by definition of our problem statement we are after the  solution:</p>

<div class="highlight"><pre><code class="python"><span class="k">def</span> <span class="nf">compute_opt</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">compute_opt</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">compute_opt</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></div>

<p>Since we recursively computing optimal solutions to smaller and smaller subsets, we recalculate the very same values
over and over again, which results in exponential execution time i.e. unacceptable. The obvious solution is <a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>
to avoid recalculations, which will result in amazing  runtime.</p>

<p>Now say we have calculated all our optimal solutions values: .
What if we need (and we generally do) to have actual intervals gathered? Easy:</p>

<div class="highlight"><pre><code class="python"><span class="c"># given OPT and p, find actual solution intervals in O(n)</span>
<span class="n">O</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">def</span> <span class="nf">compute_solution</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># will halt on OPT[-1]</span>
        <span class="k">if</span> <span class="n">I</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span> <span class="o">+</span> <span class="n">OPT</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">OPT</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">O</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">compute_solution</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compute_solution</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">compute_solution</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>

<p>As you see, we have used the idea that interval  is in optimal solution  iff:</p>



<p>At this point we solved our original problem by designing adequate algorithm
(more details on how good is our algorithm are in Algorithm Analysis section).</p>

<h2 id="dynamic-programming">Dynamic programming</h2>

<p>The pith of our algorithm is obtaining the  list. Once we got it, everything else was trivial to
unfold.</p>

<p>So let’s scrutinize that  list, and see if we need a recursive solution to calculate it.</p>

<p>Given the formula</p>



<p>we know that any given value of  depends on previous values: either  or .</p>

<p>So what if we start from the first interval and traverse to the th, can we compute  values iteratively? We can!
For any given  to have access to previous  values, all we need to do is to persist already calculated
items as we traverse the set :</p>

<div class="highlight"><pre><code class="python"><span class="c"># compute OPTs iteratively in O(n), here we use DP</span>
<span class="n">OPT</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="n">OPT</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">OPT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">)):</span>
    <span class="n">OPT</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span> <span class="o">+</span> <span class="n">OPT</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">OPT</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
</code></pre></div>

<p>And since we are iteratively building up subproblems to finally arrive to the one we are originally expected to solve , we
are having fun with <a href="http://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a> (or DP for short).</p>

<p>In its essence DP involves dynamically building up sub-solutions, one after another, to finally
solve the case in question.</p>

<p>I will write more about DP, not only because the technique is essential
knowledge for any decent programmer, but also because solutions involving dynamic algorithms represent real elegance and
beauty of the Computer Science.</p>

<h2 id="algorithm-analysis">Algorithm Analysis</h2>

<p>It is time to briefly analyse our algorithms and their worst case complexities. Should you have any issues on Big-Oh
analysis the best resource on the topic is <a href="http://www.amazon.com/gp/product/1848000693/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1848000693&amp;linkCode=as2&amp;tag=phma01-20">Skiena’s “Algorithm Design Manual”</a>.</p>

<p>Here is a list of steps we have to take and their respective time complexities:</p>

<h4 id="sort-intervals-set-i-so-that-f1-le-f2-le-dots-le-fn">1. Sort intervals set , so that </h4>

<p>If we use something like <a href="http://en.wikipedia.org/wiki/Quicksort">Quicksort</a> or <a href="http://en.wikipedia.org/wiki/Merge_sort">Mergesort</a> and get away with  (on average
in case of Quicksort and as a worst case for the Mergesort).</p>

<h4 id="calculate-p1-p2-dots-pn">2. Calculate </h4>
<p>We iterate over  different items, and for each item we need to find the first non-overlapping interval to
the left of it.
Suppose we use binary search to locate that non-overlapping neighbor interval (which has  complexity).</p>

<p>Then, since we have two growing functions  and , the total time complexity will be their product:</p>



<h4 id="calculate-opt1-opt2-dots-optn">3. Calculate </h4>

<p>Both memoized and iterative versions of function yield .</p>

<h4 id="calculate-solution-given-opt-list">4. Calculate solution (given  list)</h4>

<p>Since we already have  values calculated, recursively traversing them is an  operation.</p>

<h4 id="overall-performance">5. Overall performance</h4>

<p>When adding Big-Oh complexities the dominant function defines the whole relationship.
In our case it is</p>



<p>Not bad, I believe!</p>

<h2 id="summary">Summary</h2>

<p>That’s it for today, so let me conclude this article by quick summary:</p>

<ul>
  <li>we briefly visited special case of unweighted intervals</li>
  <li>algorithm based on greedy selection proved not good enough to solve more general case of Weighted Interval Scheduling</li>
  <li>we then developed a recursive function to calculate </li>
  <li>and finally experienced example of DP in iterative version of  calculation</li>
  <li>when we have an array of  values, it is trivial to produce a list of actual intervals that are elements of
.</li>
</ul>

<p>Have a nice day!</p>

<p>NB: I created a <a href="https://github.com/farazdagi/algorithms">repository</a> with complete implementations of both weighted and unweighted
problem variants. Feel free to fork and send me PR should you locate some issues with the code!</p>

<h2 id="references">References</h2>




</div>
</div></body></html>