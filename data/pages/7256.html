<html><body><div><div class="post-text" itemprop="text">
<p>With <code>itertools.groupby</code>, the problem of partionning a list of integers <code>L</code> in sublists of adjacent and increasing consecutive items from <code>L</code> can be done with a one-liner. Nevertheless I don't know how pythonic it can be considered ;)</p>

<p>Here is the code with some simple tests:</p>

<p>[EDIT : now subsequences are increasing <strong>by 1</strong>, I missed this point the first time.]</p>

<pre><code>from itertools import groupby

def f(i):
    return  L[i-1]+1==L[i]


def igroups(L):
    return [[L[I[0]-1]]+[L[i] for i in I] for I in [I for (v,I) in [(k,[i for i in list(g)]) for (k, g) in groupby(range(1, len(L)), f)] if v]]
</code></pre>

<p>outputting:</p>

<pre><code>tests=[
    [0, 0, 0, 0],
    [7, 8, 9, 10, 6, 0, 1, 2, 3, 4, 5],
    [8, 9, 10, 11, 7, 1, 2, 3, 4, 5, 6],
    [9, 1, 2, 3, 1, 1, 2, 3, 5],
    [4,3,2,1,1,2,3,3,4,3],
    [1, 4, 3],
    [1],
    [1,2, 2],
    [2,1],
    [0, 0, 0, 0, 2, 5, 5, 8],
    ]
for L in tests:
    print(L)
    print(igroups(L))
    print('-'*10)


[0, 0, 0, 0]
[]
----------
[7, 8, 9, 10, 6, 0, 1, 2, 3, 4, 5]
[[7, 8, 9, 10], [0, 1, 2, 3, 4, 5]]
----------
[8, 9, 10, 11, 7, 1, 2, 3, 4, 5, 6]
[[8, 9, 10, 11], [1, 2, 3, 4, 5, 6]]
----------
[9, 1, 2, 3, 1, 1, 2, 3, 5]
[[1, 2, 3], [1, 2, 3]]
----------
[4, 3, 2, 1, 1, 2, 3, 3, 4, 3]
[[1, 2, 3], [3, 4]]
----------
[1, 4, 3]
[]
----------
[1]
[]
----------
[1, 2, 2]
[[1, 2]]
----------
[2, 1]
[]
----------
[0, 0, 0, 0, 2, 5, 5, 8]
[]
----------
</code></pre>

<p>Some explanation. If you "unroll" the code, the logic is more apparant :</p>

<pre><code>from itertools import groupby

def f(i):
    return L[i]==L[i-1]+1

def igroups(L):
    monotonic_states = [(k,list(g)) for (k, g) in groupby(range(1, len(L)), f)]
    increasing_items_indices = [I for (v,I) in monotonic_states if v]
    print("\nincreasing_items_indices -&gt;", increasing_items_indices, '\n')
    full_increasing_items= [[L[I[0]-1]]+[L[i] for i in I] for I in increasing_items_indices]
    return full_increasing_items

L= [2, 8, 4, 5, 6, 7, 8, 5, 9, 10, 11, 12, 25, 26, 27, 42, 41]
print(L)
print(igroups(L))
</code></pre>

<p>outputting :</p>

<pre><code>[2, 8, 4, 5, 6, 7, 8, 5, 9, 10, 11, 12, 25, 26, 27, 42, 41]

increasing_items_indices -&gt; [[3, 4, 5, 6], [9, 10, 11], [13, 14]]

[[4, 5, 6, 7, 8], [9, 10, 11, 12], [25, 26, 27]]
</code></pre>

<p>We need a key function <code>f</code> that compares an item with the preceding one in the given list. Now, the important point is that the <code>groupby</code> function with the key function <code>f</code> provides a tuple <code>(k, S)</code> where S represents <em>adjacent</em> indices from the initial list and where the state of <code>f</code> is constant, the state being given by the value of <code>k</code>: if  <code>k</code> is <code>True</code>, then <code>S</code> represents increasing (by 1) items indices else non-increasing items indices. (in fact, as the example above shows, the list S is incomplete and lacks the first item).</p>

<p>I also made some random tests with one million items lists : <code>igroups</code> function returns always the correct response but is 4 times slower than a naive implementation! Simpler is easier and faster ;)</p>

<p>Thanks alvas for your question, it gives me a lot of fun!</p>
    </div>
    </div></body></html>