<html><body><div><div class="deployment-academy post">
<h1>Docker in Action - Development to Delivery, Part 2</h1>
<p class="meta">
<span class="date">Monday December 8, 2014</span>
</p>
<p><strong><em>This is a guest post by Michael Herman from <a href="https://realpython.com/?utm_source=rainforestqa&amp;utm_medium=link&amp;utm_campaign=deployment-academy">Real Python</a> - learn Python programming and web development through hands-on, interesting examples that are useful and fun!</em></strong></p>
<p>This three part series will teach you everything you need to know about developing with Docker - from setting up your environments and utilizing Flask on Docker to detailing a powerful development workflow that covers setting up a fully functional development environment, on your Mac, and managing continuous integration and delivery.</p>
<ol>
<li>Part 1: Local Docker Setup</li>
<li><strong>Part 2: Continuous Integration (current)</strong></li>
<li>Part 3: Continuous Delivery</li>
</ol>
<p><strong>END GOAL</strong>:</p>
<p><img alt="steps" src="/images/steps.jpg?1456621770"/></p>
<p>Last <a href="/2014-11-19-docker-in-action-from-deployment-to-delivery-part-1-local-docker-setup/">time</a> we set up our local environment, detailing the basic process of building an <em>image</em> from a <em>Dockerfile</em> and then creating an instance of the <em>image</em> called a <em>container</em>, which runs our Flask app. This time, let’s look at a nice continuous integration workflow powered by <a href="https://circleci.com/">CircleCI</a>.</p>
<blockquote>
<p>Services used: Docker Hub, Github, CircleCI</p>
</blockquote>
<h2>Docker Hub</h2>
<p>Thus far we’ve worked with Dockerfiles, images, and containers. If you’re familiar with the Git workflow, then images are like Git repositories while containers are similar to a cloned repository. Sticking with that metaphor, <a href="https://hub.docker.com/">Docker Hub</a>, which is repository of Docker images, is akin to Github.</p>
<ol>
<li>Signup <a href="https://hub.docker.com/account/signup/">here</a>, using your Github credentials.</li>
<li>Then add a new automated build. Find your Github repo that you pushed to in the first tutorial. Once added, this will trigger an initial build. Make sure the build is successful.</li>
</ol>
<h3>Docker Hub as a CI server</h3>
<p>Docker Hub, in itself, acts as a continuous integration server since you can configure it to create a build every time you push a new commit to Github. In other words, it ensures you do not cause a regression that completely breaks the build process when the code base is updated.</p>
<blockquote>
<p>Keep in mind by using an <a href="https://docs.docker.com/userguide/dockerrepos/#automated-builds">automated build</a>, you cannot use the <code>docker push</code> command. Builds must be triggered by committing code to your GitHub or BitBucket repository.</p>
</blockquote>
<p>Let’s test this out. Update the <code>test_data()</code> function in <em>test.py</em>:</p>
<pre class="highlight python"><span class="k">def</span> <span class="nf">test_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">tester</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">tester</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'/data'</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content_type</span><span class="p">,</span> <span class="s">'application/json'</span><span class="p">)</span>
</pre>
<blockquote>
<p>Need the code? Grab it from the <a href="https://github.com/realpython/flask-docker-workflow">repo</a>.</p>
</blockquote>
<p>Commit and push to Github to generate a new build.</p>
<p>Bottom-line: It’s good to know that if a commit does cause a regression that Docker Hub will catch it, but since this is the last line of defense before deploying you ideally want to catch any breaks before generating a new build on Docker Hub. Plus, you also want to run your unit and integration tests from a <em>true</em> continuous integration server.</p>
<p>Enter CircleCi.</p>
<h2>CircleCI</h2>
<p><a href="https://circleci.com/">CircleCI</a> is a continuous integration and delivery platform, which supports Docker. Given a Dockerfile, CircleCI builds an image, starts a new container, and then runs tests against that container.</p>
<p>The process to follow is simple:</p>
<ol>
<li>Code locally on a <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow">feature branch</a></li>
<li>Open a pull request on Github against the master branch</li>
<li>Run automated tests against the Docker container</li>
<li>If tests pass, manually merge the pull request into master</li>
<li>Once merged, the automated tests run again</li>
<li>If tests pass, a build is created on Docker Hub</li>
<li>Once the build is created, it is then automagically deployed to production</li>
</ol>
<p>Let’s take a look…</p>
<h3>Setup</h3>
<p>Sign up with your Github account, then add a new project, and select your repo. At this point, CircleCI automatically-</p>
<ul>
<li>Adds a webhook in the repo so that anytime you push to Github, the tests are triggered to run. (You should receive an email about this.)</li>
<li>Starts running a new build.</li>
</ul>
<p>This build should pass, but we need to configure CircleCI specifically for Docker. So, let’s add a configuration file.</p>
<h3><em>circle.yml</em></h3>
<p>Add the following build commands:</p>
<pre class="highlight text">machine:
  services:
    - docker

dependencies:
  override:
    - docker info
    - docker build -t mjhea0/flask-docker-workflow .

test:
  override:
    - docker run -d -p 80:80 mjhea0/flask-docker-workflow; sleep 10
    - curl --retry 10 --retry-delay 5 -v http://localhost:80
    - pip install -r requirements.txt
    - python app/tests.py
</pre>
<blockquote>
<p>Make sure you replace <code>mjhea0</code> with your Docker Hub username.</p>
</blockquote>
<p>Essentially, we create a new image, run the container, then test - first that the app is live (e.g., the web process is running) and then that our unit tests pass. With the <em>circle.yml</em> file created, push the changes to Github to trigger a new test. <em>Remember: this will also trigger a new build on Docker Hub.</em></p>
<blockquote>
<p>CircleCI does not support the caching feature discussed in <a href="/2014-11-19-docker-in-action-from-deployment-to-delivery-part-1-local-docker-setup/">Part 1</a>, so by default the entire image is rebuilt from scratch each time. Check out the official CircleCI <a href="https://circleci.com/docs/docker#caching-docker-layers">documentation</a> for an alternative way to speed up builds.</p>
</blockquote>
<p>If all went well, that should have passed. Before we call it quits, we need to change our workflow since we won’t be pushing directly to the master branch anymore.</p>
<h3>Feature Branch Workflow</h3>
<p>For these unfamiliar with the Feature Branch workflow, check out <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow">this</a> excellent introduction.</p>
<p>Here’s the basic workflow that we’ll utilize:</p>
<ol>
<li>Create a feature branch from master.</li>
<li>Write your code and tests on the feature branch.</li>
<li>Issue a pull request to merge your feature branch back to the master branch.</li>
<li>Run the tests from CircleCI against the feature branch.</li>
<li>If the tests pass, <em>manually</em> merge the commit into Master.</li>
<li>Run the tests from CircleCI against the Master branch.</li>
</ol>
<p>Let’s run through a quick example…</p>
<h3>Create the feature branch</h3>
<pre class="highlight shell"><span class="gp">$ </span>git checkout -b circleci-test master
Switched to a new branch <span class="s1">'circleci-test'</span>
</pre>
<h3>Update the app</h3>
<p>Add a new assert to <code>test_data()</code> in <em>tests.py</em>:</p>
<pre class="highlight python"><span class="bp">self</span><span class="o">.</span><span class="n">assertIn</span><span class="p">(</span><span class="s">'Seattle'</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre>
<h3>Issue a Pull Request</h3>
<pre class="highlight shell"><span class="gp">$ </span>git add app/tests.py
<span class="gp">$ </span>git commit -am <span class="s2">"circleci-test"</span>
<span class="gp">$ </span>git push origin circleci-test
</pre>
<p>Even before you create the actual pull request, CircleCI runs the automated tests. While the tests are running, go ahead and create the pull request, then once the tests pass, press the Merge button (with confidence!). Once merged, the build is triggered on Docker Hub.</p>
<h3>Refactoring the workflow</h3>
<p>If you jump back to the overall workflow at the top of this post, you’ll see that we don’t actually want to trigger a new build on Docker Hub until the tests pass against the master branch. So, let’s make some quick changes…</p>
<ol>
<li>Open your repository on Docker Hub, and then under <em>Settings</em> click <em>Automated Build</em>.</li>
<li>Uncheck the Active box: “When active we will build when new pushes occur”.</li>
<li>Save.</li>
<li>Click <em>Build Triggers</em> under <em>Settings</em></li>
<li>Change the status to on.</li>
<li>Copy the example curl command - i.e., <code>$ curl --data "build=true" -X POST https://registry.hub.docker.com/u/mjhea0/flask-docker/trigger/488f6652-6e9d-11e4-9a92-b6e30c63109a/</code></li>
</ol>
<p>Now add the following code to the bottom of your <em>circle.yml</em> file:</p>
<pre class="highlight text">deployment:
  hub:
    branch: master
    commands:
      - $DEPLOY
</pre>
<p>Here we fire the <code>$DEPLOY</code> variable <em>after</em> we merge to master <em>and</em> the tests pass. We’ll add the actual value of this variable as an environment variable on CircleCI:</p>
<ol>
<li>Open up the <em>Settings</em>, and click <em>Environment variables</em>.</li>
<li>Add a new variable with the name “DEPLOY” and paste the example curl command (that you copied) from Docker Hub as the value.</li>
</ol>
<p>Now let’s test.</p>
<pre class="highlight shell"><span class="gp">$ </span>git add -A
<span class="gp">$ </span>git commit -am <span class="s2">"circleci-test"</span>
<span class="gp">$ </span>git push origin circleci-test
</pre>
<p>Open a new pull request, and then once the tests pass, merge to master. Now once the tests pass, the new build will trigger on Docker Hub via the curl command. Nice.</p>
<h2>Conclusion and Next Steps</h2>
<p>Next time we’ll look at delivery. See you then!</p>

<div class="deployment-academy-cta">
<p>
<strong>Read more articles like this.</strong>
Get a quick post in your inbox each week:
</p>

</div>
<h3 class="further-reading">Further reading:</h3>

</div>
</div></body></html>