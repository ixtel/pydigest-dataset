<html><body><div><div class="post entry-content ">
					<p>Profile seems to point to 'blit'.</p>
<pre class="prettyprint">
 ncalls  tottime  percall  cumtime  percall filename:lineno(function)
      1    0.000    0.000  122.073  122.073 main.py:2(&lt;module&gt;)
  95466   87.969    0.001   87.969    0.001 {method 'blit' of 'pygame.Surface' objects}
    259    3.744    0.014    3.744    0.014 {method 'fill' of 'pygame.Surface' objects}</pre>
<p>First a little about what things mean here</p>
<p> </p>
<p>The long list are all the functions in your code, as well as in the pygame code.</p>
<p> </p>
<p>The "ncalls" column lists how often the function is used, obviously "main.py" is used exactly once. The "percall" (5th column) is how much time is spend in each call. "cumtime" is the cumulative time for all calls together. Eg the "fill" call takes (on average) 0.014, but it's called 259 times, and needs 3.744.</p>
<p>"time spend" here is the time between entering the function and leaving it. For main it is 122.073, which is about 2 minutes.</p>
<p> </p>
<p>While main is running all the time (as in, you call it at startup, and it finishes at the end of the game), the function itself doesn't do much, it just calls "launch", and waits until it returns.</p>
<p>The 122.073 thus does not say what it was actually doing those two minutes.</p>
<p>That information is in the 2nd and 3rd column. It works just like above, but it only measures time you spend calculating in the function itself, leaving out the time needed by functions that it calls (that time is listed at another line). So you can see, main used 0.000 time itself, which is what you expect.</p>
<p> </p>
<p>Now if you scan the list, you see "blit" jumping out. It is fast (0.001), but as you call it almost 100,000 times, you spend almost 88 seconds there.</p>
<p>'fill' also takes some time.</p>
<p>A second one (but you don't gain much), is 'fill'.</p>
<p> </p>
<p>The way to go thus seems to reduce the number of 'blit' calls. And this is the complicated part of speed-up, you have to figure out how to avoid calling this function.</p>
<p> </p>
<p>I scanned your code, and you seem to build the entire display from scratch, for each frame.</p>
<p>If that is true, why do you 'fill'? The next thing you do is blit the background all over it.</p>
<p> </p>
<p>A simple way to reduce the number of calls to 'blit' is to blit larger areas. You could for example make a larger background to blit, Doing a blit will take longer, but you need less calls to fill the entire background. I expect it to be faster, but you have to try. Make the change, run the profiler again, and check how much it improved.</p>
<p> </p>
<p> </p>
<p>If I remember correctly, pygame remembers the previous image if you don't blit everywhere. (try this!)</p>
<p>If that is true, there is another way, namely by dirtying areas. The basic idea is that most of the display is not changing, just the areas where the bad guys, balloons, and arrows are changes (since they move each time). You only need to draw those areas again, and can skip all areas that have not changed at all. Pygame (I hope) displays the blit you did the previous time at the skipped areas.</p>
<p>That should drastically reduce the number 'blit' calls. It's a challenge to implement though.</p>
<p> </p>
<p> </p>
<p>As for your code, some recommendations</p>
<p> </p>
<p>- You comment a lot, which is good. A lot of comment (especially at the start) however seems to say what the code line below it does. If someone is reading code, it is safe to assume they can read the code, they know Python, and they know pygame. As such, what the program does can be read in the code lines already, no need to repeat that in the comment. Instead, use the comment to explain <em>why</em> this action must be done at this point, or explain <em>what is happening</em> at a more global level, eg line 64 "# Load images" says what the next 20 lines do. The other "# load FOO image" can be left out, as the code already says what happens. In the main loop, your comments seem fine.</p>
<p> </p>
<p>- You have a very long main loop, try to break it into separate functions. A function attaches a name to some code which is useful for reading. Also, you can re-use the same code by calling the function from several places in the code.</p>
<p> </p>
<p>- In settings.py, you remove the settings file (remove("settings.txt")), and use an operating system call to create a new empty file (execute("type NUL &gt; settings.txt")). The open function can do both things for you: open("settings.txt", "w")  deletes the old content, and creates a blank new file, where you can write to (but not read).</p>
<p> </p>
<p> </p>
<p>Finally some code fragments that you can simplify/improve</p>
<pre class="prettyprint">
        # Change the image of the badgers
        if badguyimg == badguyimg1:
            badguyimg = badguyimg2
        elif badguyimg == badguyimg2:
            badguyimg = badguyimg3
        elif badguyimg == badguyimg3:
            badguyimg = badguyimg4
        elif badguyimg == badguyimg4:
            badguyimg = badguyimg1</pre>
<p>can be rewritten to</p>
<pre class="prettyprint">
bad_guys = [badguyimg1, badguyimg2, badguyimg3, badguyimg4]
current_badguy = 0  # displayed bad guy is bad_guys[current_badguy]

current_badguy = currentbadguy + 1
if current_badguy &gt;= len(bad_guys):
    current_badguy = 0</pre>
<p>Make a lis the bad guy images, and an integer that points to the currently displayed bad guy. Instead of checking which bad guy image you display, just increment the integer, so it points to the 'next' bad guy image. At the end of the list, jump back to the beginning.</p>
<p> </p>
<p> </p>
<p>The key handling can also be improved a bit</p>
<pre class="prettyprint">
                # Move up
                if event.key==K_w:
                    keys[0]=True
                elif event.key==K_UP:
                    keys[0]=True</pre>
<p>The index 0 seems to be associated with "up", you can express that more clearly. Also, Python has a little trick for the comparison you do here.</p>
<pre class="prettyprint">
# At start of the file:
KEY_UP = 0

# In the loop:

# Move up
if event.key in (K_w, K_UP):     # Test whether event.key is one of the values.
    keys[KEY_UP] = True          # Use the KEY_UP number instead of 0.</pre>

					
					
					
				</div>
				
				
			
				</div></body></html>