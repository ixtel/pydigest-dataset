<html><body><div><div class="entry-content"><p><img class="center" src="/images/pythonic_cpp.png"/></p>

<p>C++ has changed a lot in recent years. The last two revisions, C++11 and C++14, introduce so many new features that, in the words of Bjarne Stroustrup, <a href="http://www.stroustrup.com/C++11FAQ.html#think">“It feels like a new language.”</a></p>

<p>It’s true. Modern C++ lends itself to a whole new style of programming – and I couldn’t help noticing it has more of a <a href="https://www.python.org/">Python</a> flavor. Ranged-based for loops, type deduction, vector and map initializers, lambda expressions. The more you explore modern C++, the more you find Python’s fingerprints all over it.</p>


<p>Was Python a direct influence on modern C++? Or did Python simply adopt a few useful constructs before C++ got around to it? You be the judge.</p>

<h2 id="literals">Literals</h2>

<p>Python introduced <a href="https://docs.python.org/dev/whatsnew/2.6.html#pep-3127-integer-literal-support-and-syntax">binary literals</a> in 2008. Now <a href="http://en.cppreference.com/w/cpp/language/integer_literal">C++14 has them</a>. <em>[Update: Thiago Macieira points out in the comments that GCC actually supported them back in 2007.]</em></p>

<div overlay="/images/cppicon.png"><div class="CodeRay">
  <div class="code"><pre>static const int primes = 0b10100000100010100010100010101100;
</pre></div>
</div>
</div>

<p>Python also introduced <a href="https://www.python.org/download/releases/1.5/whatsnew/">raw string literals</a> back in 1998. They’re convenient when hardcoding a regular expression or a Windows path. <a href="http://en.cppreference.com/w/cpp/language/string_literal">C++11</a> added the same idea with a slightly different syntax:</p>

<div overlay="/images/cppicon.png"><div class="CodeRay">
  <div class="code"><pre>const char* path = R"(c:\this\string\has\backslashes)";
</pre></div>
</div>
</div>

<h2 id="range-based-for-loops">Range-Based For Loops</h2>

<p>In Python, a <code>for</code> loop always iterates over a Python object:</p>

<div overlay="/images/pyicon.png"><div class="CodeRay">
  <div class="code"><pre><span class="keyword">for</span> x <span class="keyword">in</span> myList:
    print(x)
</pre></div>
</div>
</div>

<p>Meanwhile, for nearly three decades, C++ supported only C-style <code>for</code> loops. Finally, in C++11, <a href="http://en.cppreference.com/w/cpp/language/range-for">range-based for loops</a> were added:</p>

<div overlay="/images/cppicon.png"><div class="CodeRay">
  <div class="code"><pre><span class="keyword">for</span> (<span class="predefined-type">int</span> x : myList)
    std::cout &lt;&lt; x;
</pre></div>
</div>
</div>

<p>You can iterate over a <code>std::vector</code> or any class which implements the <code>begin</code> and <code>end</code> member functions – not unlike Python’s <a href="https://docs.python.org/release/2.2/lib/typeiter.html">iterator protocol</a>. With range-based for loops, I often find myself wishing C++ had Python’s <code>xrange</code> function built-in.</p>

<h2 id="auto">Auto</h2>

<p>Python has always been a dynamically typed language. You don’t need to declare variable types anywhere, since types are a property of the objects themselves.</p>

<div overlay="/images/pyicon.png"><div class="CodeRay">
  <div class="code"><pre>x = <span class="string"><span class="delimiter">"</span><span class="content">Hello world!</span><span class="delimiter">"</span></span>
print(x)
</pre></div>
</div>
</div>

<p>C++, on the other hand, is not dynamically typed. It’s statically typed. But since C++11 <a href="http://en.cppreference.com/w/cpp/language/auto">repurposed</a> the <code>auto</code> keyword for type deduction, you can write code that <em>looks</em> a lot like dynamic typing:</p>

<div overlay="/images/cppicon.png"><div class="CodeRay">
  <div class="code"><pre><span class="directive">auto</span> x = <span class="string"><span class="delimiter">"</span><span class="content">Hello world!</span><span class="delimiter">"</span></span>;
std::cout &lt;&lt; x;
</pre></div>
</div>
</div>

<p>When you call functions that are overloaded for several types, such as <code>std::ostream::operator&lt;&lt;</code> or a template function, C++ resembles a dynamically typed language even more. C++14 further fleshes out support for the <code>auto</code> keyword, adding support for <code>auto</code> <a href="http://en.wikipedia.org/wiki/C%2B%2B14#Function_return_type_deduction">return values</a> and <code>auto</code> <a href="http://en.wikipedia.org/wiki/C%2B%2B14#Generic_lambdas">arguments</a> to lambda functions.</p>

<h2 id="tuples">Tuples</h2>

<p>Python has had <a href="https://docs.python.org/release/1.4/ref/ref3.html">tuples</a> pretty much since the beginning. They’re nice when you need to package several values together, but don’t feel like naming a class.</p>

<div overlay="/images/pyicon.png"><div class="CodeRay">
  <div class="code"><pre>triple = (<span class="integer">5</span>, <span class="integer">6</span>, <span class="integer">7</span>)
print(triple[<span class="integer">0</span>])
</pre></div>
</div>
</div>

<p>C++ added tuples to the standard library in C++11. The proposal <a href="http://open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1403.pdf">even mentions Python</a> as an inspiration:</p>

<div overlay="/images/cppicon.png"><div class="CodeRay">
  <div class="code"><pre><span class="directive">auto</span> triple = std::make_tuple(<span class="integer">5</span>, <span class="integer">6</span>, <span class="integer">7</span>);
std::cout &lt;&lt; std::get&lt;<span class="integer">0</span>&gt;(triple);
</pre></div>
</div>
</div>

<p>Python lets you unpack a tuple into separate variables:</p>



<p>You can do the same thing in C++ using <code>std::tie</code>:</p>

<div overlay="/images/cppicon.png"><div class="CodeRay">
  <div class="code"><pre>std::tie(x, y, z) = triple;
</pre></div>
</div>
</div>

<h2 id="uniform-initialization">Uniform Initialization</h2>

<p>In Python, lists are a <a href="https://docs.python.org/2/tutorial/introduction.html#lists">built-in type</a>. As such, you can create a Python list using a single expression:</p>

<div overlay="/images/pyicon.png"><div class="CodeRay">
  <div class="code"><pre>myList = [<span class="integer">6</span>, <span class="integer">3</span>, <span class="integer">7</span>, <span class="integer">8</span>]
myList.append(<span class="integer">5</span>);
</pre></div>
</div>
</div>

<p>C++’s <code>std::vector</code> is the closest analog to a Python list. <a href="http://www.stroustrup.com/C++11FAQ.html#init-list">Uniform initialization</a>, new in C++11, now lets us create them using a single expression as well:</p>

<div overlay="/images/cppicon.png"><div class="CodeRay">
  <div class="code"><pre><span class="directive">auto</span> myList = std::vector&lt;<span class="predefined-type">int</span>&gt;{ <span class="integer">6</span>, <span class="integer">3</span>, <span class="integer">7</span>, <span class="integer">8</span> };
myList.push_back(<span class="integer">5</span>);
</pre></div>
</div>
</div>

<p>In Python, you can also create a <a href="https://docs.python.org/2/tutorial/datastructures.html#dictionaries">dictionary</a> with a single expression:</p>

<div overlay="/images/pyicon.png"><div class="CodeRay">
  <div class="code"><pre>myDict = {<span class="integer">5</span>: <span class="string"><span class="delimiter">"</span><span class="content">foo</span><span class="delimiter">"</span></span>, <span class="integer">6</span>: <span class="string"><span class="delimiter">"</span><span class="content">bar</span><span class="delimiter">"</span></span>}
print(myDict[<span class="integer">5</span>])
</pre></div>
</div>
</div>

<p>Similarly, uniform initialization also works on C++’s <code>std::map</code> and <code>unordered_map</code>:</p>

<div overlay="/images/cppicon.png"><div class="CodeRay">
  <div class="code"><pre><span class="directive">auto</span> myDict = std::unordered_map&lt;<span class="predefined-type">int</span>, <span class="directive">const</span> <span class="predefined-type">char</span>*&gt;{ { <span class="integer">5</span>, <span class="string"><span class="delimiter">"</span><span class="content">foo</span><span class="delimiter">"</span></span> }, { <span class="integer">6</span>, <span class="string"><span class="delimiter">"</span><span class="content">bar</span><span class="delimiter">"</span></span> } };
std::cout &lt;&lt; myDict[<span class="integer">5</span>];
</pre></div>
</div>
</div>

<h2 id="lambda-expressions">Lambda Expressions</h2>

<p>Python has supported <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196">lambda functions</a> since 1994:</p>

<div overlay="/images/pyicon.png"><div class="CodeRay">
  <div class="code"><pre>myList.sort(key = <span class="keyword">lambda</span> x: <span class="predefined">abs</span>(x))
</pre></div>
</div>
</div>

<p><a href="http://www.stroustrup.com/C++11FAQ.html#lambda">Lambda expressions</a> were added in C++11:</p>

<div overlay="/images/cppicon.png"><div class="CodeRay">
  <div class="code"><pre>std::sort(myList.begin(), myList.end(), [](<span class="predefined-type">int</span> x, <span class="predefined-type">int</span> y){ <span class="keyword">return</span> std::abs(x) &lt; std::abs(y); });
</pre></div>
</div>
</div>

<p>In 2001, Python added <a href="https://docs.python.org/2/whatsnew/2.2.html#pep-227-nested-scopes">statically nested scopes</a>, which allow lambda functions to capture variables defined in enclosing functions:</p>

<div overlay="/images/pyicon.png"><div class="CodeRay">
  <div class="code"><pre><span class="keyword">def</span> <span class="function">adder</span>(amount):
    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x + amount
...
print(adder(<span class="integer">5</span>)(<span class="integer">5</span>))
</pre></div>
</div>
</div>

<p>Likewise, C++ lambda expressions support a flexible set of <a href="http://en.cppreference.com/w/cpp/language/lambda#Lambda_capture">capture rules</a>, allowing you to do similar things:</p>

<div overlay="/images/cppicon.png"><div class="CodeRay">
  <div class="code"><pre><span class="directive">auto</span> adder(<span class="predefined-type">int</span> amount) {
    <span class="keyword">return</span> [=](<span class="predefined-type">int</span> x){ <span class="keyword">return</span> x + amount; };
}
...
std::cout &lt;&lt; adder(<span class="integer">5</span>)(<span class="integer">5</span>);
</pre></div>
</div>
</div>

<h2 id="standard-algorithms">Standard Algorithms</h2>

<p>Python’s built-in <code>filter</code> function lets you selectively copy elements from a list (though <a href="https://docs.python.org/3/whatsnew/2.0.html#list-comprehensions">list comprehensions</a> are preferred):</p>

<div overlay="/images/pyicon.png"><div class="CodeRay">
  <div class="code"><pre>result = <span class="predefined">filter</span>(<span class="keyword">lambda</span> x: x &gt;= <span class="integer">0</span>, myList)
</pre></div>
</div>
</div>

<p>C++11 <a href="http://en.cppreference.com/w/cpp/algorithm/copy">introduces</a> <code>std::copy_if</code>, which lets us use a similar, almost-functional style:</p>

<div overlay="/images/cppicon.png"><div class="CodeRay">
  <div class="code"><pre><span class="directive">auto</span> result = std::vector&lt;<span class="predefined-type">int</span>&gt;{};
std::copy_if(myList.begin(), myList.end(), std::back_inserter(result), [](<span class="predefined-type">int</span> x){ <span class="keyword">return</span> x &gt;= <span class="integer">0</span>; });
</pre></div>
</div>
</div>

<p>Other C++ <a href="http://en.cppreference.com/w/cpp/algorithm">algorithms</a> that mimic Python built-ins include <code>transform</code>, <code>any_of</code>, <code>all_of</code>, <code>min</code> and <code>max</code>. The upcoming <a href="https://github.com/ericniebler/range-v3/blob/master/doc/D4128.md">ranges proposal</a> has the potential to simplify such expressions further.</p>

<h2 id="parameter-packs">Parameter Packs</h2>

<p>Python began supporting arbitrary argument lists in <a href="https://docs.python.org/release/1.5/tut/node29.html">1998</a>. You can define a function taking a variable number of arguments, exposed as a tuple, and expand a tuple when passing arguments to another function:</p>

<div overlay="/images/pyicon.png"><div class="CodeRay">
  <div class="code"><pre><span class="keyword">def</span> <span class="function">foo</span>(*args):
    <span class="keyword">return</span> <span class="predefined">tuple</span>(*args)
...
triple = foo(<span class="integer">5</span>, <span class="integer">6</span>, <span class="integer">7</span>)
</pre></div>
</div>
</div>

<p>C++11 adds support for <a href="http://www.stroustrup.com/C++11FAQ.html#variadic-templates">parameter packs</a>. Unlike C-style variable arguments, but like Python’s arbitrary argument lists, the parameter pack has a name which represents the entire sequence of arguments. One important difference: C++ parameter packs are <em>not</em> exposed as a single object at runtime. You can only manipulate them through template metaprogramming at compile time.</p>

<div overlay="/images/cppicon.png"><div class="CodeRay">
  <div class="code"><pre><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt; <span class="directive">auto</span> foo(T&amp;&amp;... args) {
    <span class="keyword">return</span> std::make_tuple(args...);
}
...
<span class="directive">auto</span> triple = foo(<span class="integer">5</span>, <span class="integer">6</span>, <span class="integer">7</span>);
</pre></div>
</div>
</div>

<p>Not all of the new C++11 and C++14 features mimic Python functionality, but it seems a lot of them do. Python is recognized as a friendly, approachable programming language. Perhaps some of its charisma has rubbed off?</p>

<p>What do you think? Do the new features succeed in making C++ simpler, more approachable or more expressive?</p>
</div>



  

  </div></body></html>