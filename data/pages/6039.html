<html><body><div><div id="using-typedjsonrpc">
<h2>Using typedjsonrpc</h2>
<div id="installation">
<h3>Installation</h3>
<p>Use pip to install typedjsonrpc:</p>
<pre>$ pip install typedjsonrpc
</pre>
</div>
<div id="project-setup">
<h3>Project setup</h3>
<p>To include typedjsonrpc in your project, use:</p>
<pre><span class="kn">from</span> <span class="nn">typedjsonrpc.registry</span> <span class="kn">import</span> <span class="n">Registry</span>
<span class="kn">from</span> <span class="nn">typedjsonrpc.server</span> <span class="kn">import</span> <span class="n">Server</span>

<span class="n">registry</span> <span class="o">=</span> <span class="n">Registry</span><span class="p">()</span>
<span class="n">server</span> <span class="o">=</span> <span class="n">Server</span><span class="p">(</span><span class="n">registry</span><span class="p">)</span>
</pre>
<p>The registry will keep track of methods that are available for JSON-RPC. Whenever you annotate
a method, it will be added to the registry. You can always use the method <tt>rpc.describe()</tt> to get
a description of all available methods. <tt>Server</tt> is a
<a href="http://wsgi.readthedocs.org/en/latest/" rel="nofollow">WSGI</a> compatible app that handles requests. <tt>Server</tt>
also has a development mode that can be run using <tt>server.run(host, port)</tt>.</p>
</div>
<div id="example-usage">
<h3>Example usage</h3>
<p>Annotate your methods to make them accessible and provide type information:</p>
<pre><span class="nd">@registry.method</span><span class="p">(</span><span class="n">returns</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="nd">@registry.method</span><span class="p">(</span><span class="n">returns</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre>
<p>The return type <em>has</em> to be declared using the <tt>returns</tt> keyword. For methods that don’t return
anything, you can use either <tt>type(None)</tt> or just <tt>None</tt>:</p>
<pre><span class="nd">@registry.method</span><span class="p">(</span><span class="n">returns</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="n">a</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="nd">@registry.method</span><span class="p">(</span><span class="n">returns</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
</pre>
<p>You can use any of the basic JSON types:</p>
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr><th>JSON type</th>
<th>Python type</th>
</tr>
</thead>
<tbody>
<tr><td>string</td>
<td>basestring (Python 2), str (Python 3)</td>
</tr>
<tr><td>number</td>
<td>int, float</td>
</tr>
<tr><td>null</td>
<td>None</td>
</tr>
<tr><td>boolean</td>
<td>bool</td>
</tr>
<tr><td>array</td>
<td>list</td>
</tr>
<tr><td>object</td>
<td>dict</td>
</tr>
</tbody>
</table>
<p>Your functions may also accept <tt>*args</tt> and <tt>**kwargs</tt>, but you cannot declare their types. So
the correct way to use these would be:</p>
<pre><span class="nd">@registry.method</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
</pre>
<p>To check that everything is running properly, try (assuming <tt>add</tt> is declared in your main
module):</p>
<pre>$ curl -XPOST http://&lt;host&gt;:&lt;port&gt;/api -d @- <span class="s">&lt;&lt;EOF
{
    "jsonrpc": "2.0",
    "method": "__main__.add",
    "params": {
        "a": 5,
        "b": 7
    },
    "id": "foo"
}
EOF</span>

<span class="o">{</span>
    <span class="s2">"jsonrpc"</span>: <span class="s2">"2.0"</span>,
    <span class="s2">"id"</span>: <span class="s2">"foo"</span>,
    <span class="s2">"result"</span>: 12
<span class="o">}</span>
</pre>
<p>Passing any non-integer arguments into <tt>add</tt> will raise a <tt>InvalidParamsError</tt>.</p>
</div>
<div id="batching">
<h3>Batching</h3>
<p>You can send a list of JSON-RPC request objects as one request and will receive a list of JSON-RPC
response objects in return. These response objects can be mapped back to the request objects using
the <tt>id</tt>. Here’s an example of calling the <tt>add</tt> method with two sets of parameters:</p>
<pre>$ curl -XPOST http://&lt;host&gt;:&lt;port&gt;/api -d @- <span class="s">&lt;&lt;EOF
[
    {
        "jsonrpc": "2.0",
        "method": "__main__.add",
        "params": {
            "a": 5,
            "b": 7
        },
        "id": "foo"
    }, {
        "jsonrpc": "2.0",
        "method": "__main__.add",
        "params": {
            "a": 42,
            "b": 1337
        },
        "id": "bar"
    }
]
EOF</span>

<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">"jsonrpc"</span>: <span class="s2">"2.0"</span>,
        <span class="s2">"id"</span>: <span class="s2">"foo"</span>,
        <span class="s2">"result"</span>: 12
    <span class="o">}</span>, <span class="o">{</span>
        <span class="s2">"jsonrpc"</span>: <span class="s2">"2.0"</span>,
        <span class="s2">"id"</span>: <span class="s2">"bar"</span>,
        <span class="s2">"result"</span>: 1379
    <span class="o">}</span>
<span class="o">]</span>
</pre>
</div>
<div id="debugging">
<h3>Debugging</h3>
<p>If you create the registry with the parameter <tt>debug=True</tt>, you’ll be able to use
<a href="http://werkzeug.pocoo.org/docs/0.10/debug/" rel="nofollow">werkzeug’s debugger</a>. In that case, if there is an
error during execution - e.g. you tried to use a string as one of the parameters for <tt>add</tt> - the
response will contain an error object with a <tt>debug_url</tt>:</p>
<pre>$ curl -XPOST http://&lt;host&gt;:&lt;port&gt;/api -d @- <span class="s">&lt;&lt;EOF
{
    "jsonrpc": "2.0",
    "method": "__main__.add",
    "params": {
        "a": 42,
        "b": "hello"
    },
    "id": "bar"
}
EOF</span>

<span class="o">{</span>
    <span class="s2">"jsonrpc"</span>: <span class="s2">"2.0"</span>,
    <span class="s2">"id"</span>: <span class="s2">"bar"</span>,
    <span class="s2">"error"</span>: <span class="o">{</span>
        <span class="s2">"message"</span>: <span class="s2">"Invalid params"</span>,
        <span class="s2">"code"</span>: -32602,
        <span class="s2">"data"</span>: <span class="o">{</span>
            <span class="s2">"message"</span>: <span class="s2">"Value 'hello' for parameter 'b' is not of expected type &lt;type 'int'&gt;."</span>,
            <span class="s2">"debug_url"</span>: <span class="s2">"/debug/1234567890"</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre>
<p>This tells you to find the traceback interpreter at <tt><span class="pre">&lt;host&gt;:&lt;port&gt;/debug/1234567890</span></tt>.</p>
</div>
<div id="logging">
<h3>Logging</h3>
<p>The registry has a default logger in the module <tt>typedjsonrpc.registry</tt> and it logs all errors
that are not defined by <tt>typedjsonrpc</tt>. You can configure the logger as follows:</p>
<pre><span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">"typedjsonrpc.registry"</span><span class="p">)</span>
<span class="c1"># Do configuration to this logger</span>
</pre>
</div>
<div id="http-status-codes">
<h3>HTTP status codes</h3>
<p>Since typedjsonrpc 0.4.0, HTTP status codes were added to the responses from the
<tt>typedjsonrpc.server.Server</tt> class. This is to improve the usage of typedjsonrpc over HTTP. The
following chart are the satus codes which are returned:</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr><th>Condition</th>
<th>Batched</th>
<th>Status code</th>
</tr>
</thead>
<tbody>
<tr><td>Success</td>
<td>Y</td>
<td>200</td>
</tr>
<tr><td>N</td>
<td>200</td>
</tr>
<tr><td>All notifications</td>
<td>Y</td>
<td>204</td>
</tr>
<tr><td>N</td>
<td>204</td>
</tr>
<tr><td>ParseError or InvalidRequestError</td>
<td>Y</td>
<td>200</td>
</tr>
<tr><td>N</td>
<td>400</td>
</tr>
<tr><td>MethodNotFoundError</td>
<td>Y</td>
<td>200</td>
</tr>
<tr><td>N</td>
<td>404</td>
</tr>
<tr><td>All other errors</td>
<td>Y</td>
<td>200</td>
</tr>
<tr><td>N</td>
<td>500</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="additional-features">
<h2>Additional features</h2>
<div id="customizing-type-serialization">
<h3>Customizing type serialization</h3>
<p>If you would like to serialize custom types, you can set the <tt>json_encoder</tt> and <tt>json_decoder</tt>
attributes on <tt>Server</tt> to your own custom <tt>json.JSONEncoder</tt> and <tt>json.JSONDecoder</tt>
instance. By default, we use the default encoder and decoder.</p>
</div>
<div id="adding-hooks-before-the-first-request">
<h3>Adding hooks before the first request</h3>
<p>You can add functions to run before the first request is called. This can be useful for some
special setup you need for your WSGI app. For example, you can register a function to print
debugging information before your first request:</p>
<pre><span class="kn">import</span> <span class="nn">datetime</span>

<span class="kn">from</span> <span class="nn">typedjsonrpc.registry</span> <span class="kn">import</span> <span class="n">Registry</span>
<span class="kn">from</span> <span class="nn">typedjsonrpc.server</span> <span class="kn">import</span> <span class="n">Server</span>

<span class="n">registry</span> <span class="o">=</span> <span class="n">Registry</span><span class="p">()</span>
<span class="n">server</span> <span class="o">=</span> <span class="n">Server</span><span class="p">(</span><span class="n">registry</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">print_time</span><span class="p">():</span>
    <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">"Handling first request at: {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">now</span><span class="p">))</span>

<span class="n">server</span><span class="o">.</span><span class="n">register_before_first_request</span><span class="p">(</span><span class="n">print_time</span><span class="p">)</span>
</pre>
</div>
<div id="accessing-the-http-request-from-json-rpc-methods">
<h3>Accessing the HTTP request from JSON-RPC methods</h3>
<p>In some situations, you may want to access the HTTP request from your JSON-RPC method. For example,
you could need to perform logic based on headers in the request. In the <cite>typedjsonrpc.server</cite>
module, there is a special <cite>typedjsonrpc.server.current_request</cite> attribute which allows you to
access the HTTP request which was used to call the current method.</p>
<div>
<p>Warning</p>
<p><tt>current_request</tt> is implemented as a thread-local. If you attempt to call
<tt>Server.wsgi_app</tt> from <tt>Registry.method</tt>, then <tt>current_request</tt> <em>will be overriden in</em>
<em>that thread</em>.</p>
</div>
<p>Example:</p>
<pre><span class="kn">from</span> <span class="nn">typedjsonrpc.server</span> <span class="kn">import</span> <span class="n">current_request</span>

<span class="nd">@registry.method</span><span class="p">(</span><span class="n">returns</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_headers</span><span class="p">():</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">current_request</span><span class="o">.</span><span class="n">headers</span><span class="p">)</span>
</pre>
</div>
<div id="disabling-strictness-of-floats">
<h3>Disabling strictness of floats</h3>
<p><tt>typedjsonrpc</tt> by default will only accept floats into a <cite>float</cite> typed parameter. For example, if
your function were this:</p>
<pre><span class="kn">import</span> <span class="nn">math</span>

<span class="nd">@registry.method</span><span class="p">(</span><span class="n">returns</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">floor</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre>
<p>and your input were this:</p>
<pre>{
    "jsonrpc": "2.0",
    "method": "floor",
    "params": {
        "x": 1
    },
    "id": "foo"
}
</pre>
<p>You would get an invalid param error like this:</p>
<pre>{
    "error": {
        "code": -32602,
        "data": {
            "debug_url": "/debug/4456954960",
            "message": "Value '1' for parameter 'x' is not of expected type &lt;type 'float'&gt;."
        },
        "message": "Invalid params"
    },
    "id": "foo",
    "jsonrpc": "2.0"
}
</pre>
<p>This can actually frequently come up when you use a JSON encoder. A JSON encoder may choose to write
the float <tt>1.0</tt> as an integer <tt>1</tt>. In order to get around this, you can manually edit the JSON
or set <tt>strict_floats</tt> to <tt>False</tt> in your <cite>typedjsonrpc.registry.Registry</cite>.</p>
</div>
</div>


</div></body></html>