<html><body><div><div class="section-inner layoutSingleColumn"><h3 name="9744" id="9744" class="graf--h3 graf--first">Explicit vs. Implicit concurrency</h3><p name="42c0" id="42c0" class="graf--p graf-after--h3">I think I’m now getting to what I consider to be the main difference between these two approaches — the choice between explicit and implicit concurrency.</p><p name="b4ed" id="b4ed" class="graf--p graf-after--p">If you wanted to move from an implicit to an explicit world, your first approach might (very basically) be to just convert anything that does IO into a coroutine and pepper your code base with a bunch of <em class="markup--em markup--p-em">yield from</em> statements.</p><figure name="c720" id="c720" class="graf--figure graf--iframe graf-after--p"><p class="iframeContainer"/><figcaption class="imageCaption"><a href="https://gist.github.com/shauns/7d2bdc624f165d23b98d" data-href="https://gist.github.com/shauns/7d2bdc624f165d23b98d" class="markup--anchor markup--figure-anchor" rel="nofollow">https://gist.github.com/shauns/7d2bdc624f165d23b98d</a></figcaption></figure><figure name="5d12" id="5d12" class="graf--figure graf--iframe graf-after--figure"><p class="iframeContainer"/><figcaption class="imageCaption"><a href="https://gist.github.com/shauns/0387cb7f9f9225dab1fc" data-href="https://gist.github.com/shauns/0387cb7f9f9225dab1fc" class="markup--anchor markup--figure-anchor" rel="nofollow">https://gist.github.com/shauns/0387cb7f9f9225dab1fc</a></figcaption></figure><p name="00d8" id="00d8" class="graf--p graf-after--figure">For a lot of use-cases, this is going to be fine.</p><h3 name="3690" id="3690" class="graf--h3 graf-after--p">Where explicit concurrency falls down</h3><p name="8230" id="8230" class="graf--p graf-after--h3">The problem with explicit concurrency is that you have to be explicit about it. Obvious, I know, but this offers up some interesting drawbacks.</p><p name="9ccc" id="9ccc" class="graf--p graf-after--p">Take an ORM, like <a href="http://www.sqlalchemy.org/" data-href="http://www.sqlalchemy.org/" class="markup--anchor markup--p-anchor" rel="nofollow">SQLAlchemy</a> (if you hate ORMs, you can make up your own example). What would this library look like in an explicit world?</p><p name="1144" id="1144" class="graf--p graf-after--p">Let’s say we want to query for a particular model instance — and therefore hit the database — how could the library be adapted to support that?</p><figure name="ea95" id="ea95" class="graf--figure graf--iframe graf-after--p"><p class="iframeContainer"/><figcaption class="imageCaption"><a href="https://gist.github.com/shauns/ae7d6c298a1cc48e390a" data-href="https://gist.github.com/shauns/ae7d6c298a1cc48e390a" class="markup--anchor markup--figure-anchor" rel="nofollow">https://gist.github.com/shauns/ae7d6c298a1cc48e390a</a></figcaption></figure><figure name="d5ee" id="d5ee" class="graf--figure graf--iframe graf-after--figure"><p class="iframeContainer"/><figcaption class="imageCaption"><a href="https://gist.github.com/shauns/090bbfa4447adff8a760" data-href="https://gist.github.com/shauns/090bbfa4447adff8a760" class="markup--anchor markup--figure-anchor" rel="nofollow">https://gist.github.com/shauns/090bbfa4447adff8a760</a></figcaption></figure><p name="ee35" id="ee35" class="graf--p graf-after--figure">Not too bad so far. Our problems start though when we consider more advanced features, such as laziness.</p><p name="8152" id="8152" class="graf--p graf-after--p">Taking our example above, we’re going to say that <em class="markup--em markup--p-em">Book</em> has a one-to-many relationship with <em class="markup--em markup--p-em">Chapter</em> — a book can have multiple chapters associated with it. This will be exposed through a <em class="markup--em markup--p-em">chapters</em> attribute on the book instance. One more thing — in our world it’s expensive to fetch the chapters for a book, and we don’t always need them, so we want this attribute to be filled <a href="http://docs.sqlalchemy.org/en/latest/orm/loading.html" data-href="http://docs.sqlalchemy.org/en/latest/orm/loading.html" class="markup--anchor markup--p-anchor" rel="nofollow">lazily</a>.</p><p name="007e" id="007e" class="graf--p graf-after--p">Take a look at this snippet:</p><figure name="fe6c" id="fe6c" class="graf--figure graf--iframe graf-after--p"><p class="iframeContainer"/><figcaption class="imageCaption"><a href="https://gist.github.com/shauns/989f11e93d4f1d366f1e" data-href="https://gist.github.com/shauns/989f11e93d4f1d366f1e" class="markup--anchor markup--figure-anchor" rel="nofollow">https://gist.github.com/shauns/989f11e93d4f1d366f1e</a></figcaption></figure><p name="5b0e" id="5b0e" class="graf--p graf-after--figure">What happens on the first line — Do we hit the database? Can we switch?</p><p name="a93e" id="a93e" class="graf--p graf-after--p">In an implicit world, the answer to both questions is yes. We access the lazy attribute <em class="markup--em markup--p-em">chapters</em>, our ORM knows that this hasn’t been ‘filled’ yet and that a database query is needed. The ORM puts together the query, executes it — we implicitly yield here — and once the result is back, fills up <em class="markup--em markup--p-em">chapters</em> accordingly and exposes the result.</p><p name="6be1" id="6be1" class="graf--p graf-after--p">In an explicit world, its not clear how we’d model something like this. The flexibility of something like an ORM means there are so many potential interactions that could end up triggering some IO.</p><p name="7671" id="7671" class="graf--p graf-after--p">Some might take this as an argument against ORMs — “if it’s so complicated to use, and the behaviour of seemingly simple calls can vary so wildly, don’t use one”. It’s a valid viewpoint, though not something everyone will agree with.</p><p name="55e5" id="55e5" class="graf--p graf-after--p">Alternatively, perhaps an API could be provided that makes the laziness a little less magical. Check out this (ugly) code.</p><figure name="2fcb" id="2fcb" class="graf--figure graf--iframe graf-after--p"><p class="iframeContainer"/><figcaption class="imageCaption"><a href="https://gist.github.com/shauns/b62c1f53b497620b0cce" data-href="https://gist.github.com/shauns/b62c1f53b497620b0cce" class="markup--anchor markup--figure-anchor" rel="nofollow">https://gist.github.com/shauns/b62c1f53b497620b0cce</a></figcaption></figure><p name="80de" id="80de" class="graf--p graf-after--figure">Lastly, maybe the contract you come to with your ORM could be such that it promises to give you a good explicit API, but you lose niceties such as dynamic lazy attributes.</p><h3 name="7371" id="7371" class="graf--h3 graf-after--p">The answer is in the middle?</h3><p name="38bf" id="38bf" class="graf--p graf-after--h3">Asyncio is still relatively new, and there’s a whole world of issues, problems and space for growth ahead of it, but at some point, the issues touched on in this post will need to be addressed — even if the conclusion is that it’s not going to try solving these problems.</p><p name="998f" id="998f" class="graf--p graf-after--p">Personally I’d like to see a more hybrid world. I’ve never been particularly bothered with implicit yielding switching out my coroutine at ‘unexpected’ times, but I do see the benefits of making things a little more explicit — and of course having asyncio as a blessed part of the standard library makes it really attractive to use.</p><p name="e801" id="e801" class="graf--p graf-after--p graf--last">It’s a tough problem to solve and I look forward to seeing what happens next.</p></div></div></body></html>