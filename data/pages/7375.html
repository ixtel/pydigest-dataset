<html><body><div><div class="post-text" itemprop="text">

<p><strong>Is it conclusive that now the <code>scipy.misc.comb</code> is indeed faster than the ad-hoc implementation?</strong></p>

<p>According to an old answer, <a href="http://stackoverflow.com/questions/3025162/statistics-combinations-in-python/3025547#3025547">Statistics: combinations in Python</a>, this homebrew function is faster than <code>scipy.misc.comb</code> when calculating combinations <code>nCr</code>:</p>

<pre><code>def choose(n, k):
    """
    A fast way to calculate binomial coefficients by Andrew Dalke (contrib).
    """
    if 0 &lt;= k &lt;= n:
        ntok = 1
        ktok = 1
        for t in xrange(1, min(k, n - k) + 1):
            ntok *= n
            ktok *= t
            n -= 1
        return ntok // ktok
    else:
        return 0
</code></pre>

<p>But after running some tests on my own machine, this doesn't seem like the case, using this script:</p>

<pre><code>from scipy.misc import comb
import random, time

def choose(n, k):
    """
    A fast way to calculate binomial coefficients by Andrew Dalke (contrib).
    """
    if 0 &lt;= k &lt;= n:
        ntok = 1
        ktok = 1
        for t in xrange(1, min(k, n - k) + 1):
            ntok *= n
            ktok *= t
            n -= 1
        return ntok // ktok
    else:
        return 0

def timing(f):
    def wrap(*args):
        time1 = time.time()
        ret = f(*args)
        time2 = time.time()
        print '%s function took %0.3f ms' % (f.__name__, (time2-time1)*1000.0)
        return ret
    return wrap

@timing
def test_func(combination_func, nk):
    for n,k in nk:
        combination_func(n, k)

nk = []
for _ in range(1000):
    n = int(random.random() * 10000)
    k = random.randint(0,n)
    nk.append((n,k))

test_func(comb, nk)
test_func(choose, nk)
</code></pre>

<p>I get the following output:</p>

<pre><code>$ python test.py
/usr/lib/python2.7/dist-packages/scipy/misc/common.py:295: RuntimeWarning: overflow encountered in exp
  vals = exp(lgam(N+1) - lgam(N-k+1) - lgam(k+1))
999
test_func function took 32.869 ms
999
test_func function took 1859.125 ms

$ python test.py
/usr/lib/python2.7/dist-packages/scipy/misc/common.py:295: RuntimeWarning: overflow encountered in exp
  vals = exp(lgam(N+1) - lgam(N-k+1) - lgam(k+1))
999
test_func function took 32.265 ms
999
test_func function took 1878.550 ms
</code></pre>

<p><strong>Did the time profiling test show that the new <code>scipy.misc.comb</code> is faster than the ad-hoc <code>choose()</code> function?</strong> Is there any error on my test script that makes the timing inaccurate?</p>

<p><strong>Why is it that the <code>scipy.misc.comb</code> is faster now? It is because of some <code>cython</code> / <code>c</code> wrapping tricks?</strong></p>

<hr/>

<h1>EDITED</h1>

<p>After @WarrenWeckesser comment:</p>

<p>Using the default floating point approximation when using <code>scipy.misc.comb()</code>, the computation breaks because of floating point overflow. </p>

<p>(see <a href="http://docs.scipy.org/doc/scipy-0.16.0/reference/generated/scipy.misc.comb.html">http://docs.scipy.org/doc/scipy-0.16.0/reference/generated/scipy.misc.comb.html</a> for documentation)</p>

<p>When tested with <code>exact=True</code> which computes with long integers instead of floating point using the function below, it's a lot slower when computing 1000 combinations:</p>

<pre><code>@timing
def test_func(combination_func, nk):
    for i, (n,k) in enumerate(nk):
        combination_func(n, k, exact=True)
</code></pre>

<p>[out]:</p>

<pre><code>$ python test.py
test_func function took 3312.211 ms
test_func function took 1764.523 ms

$ python test.py
test_func function took 3320.198 ms
test_func function took 1782.280 ms
</code></pre>
    </div>
    </div></body></html>