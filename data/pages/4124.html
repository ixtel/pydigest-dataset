<html><body><div><div class="post-text" itemprop="text">

<p>I'm using python <code>pcapy</code> in a <code>docker</code> container using this piece of code:</p>

<pre><code>from pcapy import open_live, findalldevs
import sys
import traceback

p = open_live("eth0", 1024, False, 100)
dumper = p.dump_open("test.pcap")

devices = findalldevs()
print dumper, devices
while True:
    try:
        print p.next()
    except Exception as e:
        print dir(e), e.message, e.args[0]
        traceback.print_exc(file=sys.stdout)
        break
</code></pre>

<p>When I run it I get the following exception:</p>

<blockquote>
  <p>Traceback (most recent call last):</p>
  
  <p>File "test_pcap.py", line 12, in </p>

<pre><code>print p.next()
</code></pre>
  
  <p>PcapError</p>
</blockquote>

<p>I've tried to play with the arguments by changing to different maximum packet sizes and setting promiscuous to <code>True</code>.</p>

<p>I've tried to get any message from the exception, but it seems the message is empty. I also skimmed through pcapy <a href="https://github.com/CoreSecurity/pcapy/blob/2984bf5e974ab3a2af58c0501f2d4072db5ac4e4/pcapobj.cc#L197" rel="nofollow">source code</a>: since the exception in the PcapyError object is empty and the other PcapErrors in the <code>next</code> function are explicit strings, it implies we are falling into the condition in which <code>buf</code> is empty. It seems <code>pcap_geterr</code> returns an empty string because <code>pp-&gt;pcap</code> has been closed and the pointer to the pcap exception no longer exists (take a look into the <a href="http://www.manpagez.com/man/3/pcap_geterr/" rel="nofollow">doc</a>).</p>

<p>When I run using the <code>loop()</code> method, everything works fine:</p>

<pre><code># Modified from: http://snipplr.com/view/3579/
import pcapy
from impacket.ImpactDecoder import *

# list all the network devices
pcapy.findalldevs()

max_bytes = 1024
promiscuous = False
read_timeout = 100 # in milliseconds
pc = pcapy.open_live("eth0", max_bytes,
    promiscuous, read_timeout)

# callback for received packets
def recv_pkts(hdr, data):
    packet = EthDecoder().decode(data)
    print packet

packet_limit = -1 # infinite
pc.loop(packet_limit, recv_pkts) # capture packets
</code></pre>

<p>I really don't know the source of the problem or what else to do for debugging it.</p>

<p><strong>EDIT</strong></p>

<p>I cannot find any error using <code>strace</code>. This is the grep for error in <code>strace</code> output:</p>

<pre><code>strace python test_pcap.py 2&gt;&amp;1 1&gt;/dev/null | grep -i error
</code></pre>

<blockquote>
  <p>read(6, "\0\0\0t\3\0\0\0intt\n\0\0\0ValueErrort\23\0\0\0_"..., 4096) = 995</p>
  
  <p>getsockopt(3, SOL_SOCKET, SO_ERROR, [0], [4]) = 0</p>
  
  <p>getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0</p>
  
  <p>getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0</p>
</blockquote>

<p><strong>EDIT2</strong></p>

<p>I also tested <code>pcap.h</code> by calling to <code>pcap_next</code> myself:</p>

<pre><code> // Modified from: http://www.tcpdump.org/pcap.html
 #include &lt;pcap.h&gt;
 #include &lt;stdio.h&gt;

 int main(int argc, char *argv[])
 {
        pcap_t *handle;                 /* Session handle */
        char *dev;                      /* The device to sniff on */
        char errbuf[PCAP_ERRBUF_SIZE];  /* Error string */
        bpf_u_int32 mask;               /* Our netmask */
        bpf_u_int32 net;                /* Our IP */
        struct pcap_pkthdr header;      /* The header that pcap gives us */
        const u_char *packet;           /* The actual packet */

        /* Define the device */
        dev = pcap_lookupdev(errbuf);
        if (dev == NULL) {
                fprintf(stderr, "Couldn't find default device: %s\n", errbuf);
                return(2);
        }
        /* Find the properties for the device */
        if (pcap_lookupnet(dev, &amp;net, &amp;mask, errbuf) == -1) {
                fprintf(stderr, "Couldn't get netmask for device %s: %s\n", dev, errbuf);
                net = 0;
                mask = 0;
        }
        /* Open the session in promiscuous mode */
        handle = pcap_open_live(dev, BUFSIZ, 1, 1000, errbuf);
        if (handle == NULL) {
                fprintf(stderr, "Couldn't open device %s: %s\n", "eth0", errbuf);
                return(2);
        }
        while (1) {
                /* Grab a packet */
                packet = pcap_next(handle, &amp;header);
                /* Print its length */
                printf("Jacked a packet with length of [%d]\n", header.len);
                /* Print contents */
                printf("\tPacket: %s\n", packet);
                /* And close the session */
        }
        pcap_close(handle);
        return(0);
 }
</code></pre>

<p>To compile, write it to <code>test_sniff.c</code> and run:</p>

<pre><code>gcc test_sniff.c -o test_sniff -lpcap
</code></pre>

<p>And I was able to capture packets successfully. So I don't really know where the problem is... </p>

<p><strong>Other info to reproduce behaviour</strong></p>

<ul>
<li>Docker version: <code>Docker version 1.5.0, build a8a31ef</code></li>
<li>Docker image is the Docker default <code>Ubuntu</code></li>
<li>Python2.7</li>
</ul>
    </div>
    </div></body></html>