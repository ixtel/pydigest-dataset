<html><body><div><section>


				<section>
					<h2>Ask StackOverflow</h2>
                    <em>when you're looking for <strong>test cases</strong></em><br/>
                    <a href="http://stackoverflow.com/questions/26823312/numba-or-cython-acceleration-in-reaction-diffusion-algorithm">http://stackoverflow.com/[...]numba-or-cython-acceleration-in-reaction-diffusion-algorithm</a>
                <pre><code class="python">import numpy as np
def GrayScott(counts, Du, Dv, F, k):
    n = 300
    U = np.zeros((n+2,n+2), dtype=np.float32)
    V = np.zeros((n+2,n+2), dtype=np.float32)
    u, v = U[1:-1,1:-1], V[1:-1,1:-1]

    r = 20
    u[:] = 1.0
    U[n/2-r:n/2+r,n/2-r:n/2+r] = 0.50
    V[n/2-r:n/2+r,n/2-r:n/2+r] = 0.25
    u += 0.15*np.random.random((n,n))
    v += 0.15*np.random.random((n,n))

    for i in range(counts):
        Lu = (                 U[0:-2,1:-1] +
              U[1:-1,0:-2] - 4*U[1:-1,1:-1] + U[1:-1,2:] +
                               U[2:  ,1:-1] )
        Lv = (                 V[0:-2,1:-1] +
              V[1:-1,0:-2] - 4*V[1:-1,1:-1] + V[1:-1,2:] +
                               V[2:  ,1:-1] )
        uvv = u*v*v
        u += Du*Lu - uvv + F*(1 - u)
        v += Dv*Lv + uvv - (F + k)*v

    return V</code></pre>
				</section>

                <section>
                    <h2>Thread Summary</h2>

                    <dl>
                        <dt>OP</dt>
                        <dd>My code is slow with Cython and Numba</dd>
                        <dt>Best Answer</dt>
                        <dd>You need to make all loops explicit</dd>
                    </dl>

                </section>

                <section>
                    <h2>Cython Version</h2>
                <pre><code class="python">cimport cython
import numpy as np
cimport numpy as np

cpdef cythonGrayScott(int counts, double Du, double Dv, double F, double k):
    cdef int n = 300
    cdef np.ndarray U = np.zeros((n+2,n+2), dtype=np.float_)
    cdef np.ndarray V = np.zeros((n+2,n+2), dtype=np.float_)
    cdef np.ndarray u = U[1:-1,1:-1]
    cdef np.ndarray v = V[1:-1,1:-1]

    cdef int r = 20
    u[:] = 1.0
    U[n/2-r:n/2+r,n/2-r:n/2+r] = 0.50
    V[n/2-r:n/2+r,n/2-r:n/2+r] = 0.25
    u += 0.15*np.random.random((n,n))
    v += 0.15*np.random.random((n,n))

    cdef np.ndarray Lu = np.zeros_like(u)
    cdef np.ndarray Lv = np.zeros_like(v)
    cdef int i, c, r1, c1, r2, c2
    cdef double uvv

    cdef double[:, ::1] bU = U
    cdef double[:, ::1] bV = V
    cdef double[:, ::1] bLu = Lu
    cdef double[:, ::1] bLv = Lv

    for i in range(counts):
        for r in range(n):
            r1 = r + 1
            r2 = r + 2
            for c in range(n):
                c1 = c + 1
                c2 = c + 2
                bLu[r,c] = bU[r1,c2] + bU[r1,c] + bU[r2,c1] + bU[r,c1] - 4*bU[r1,c1]
                bLv[r,c] = bV[r1,c2] + bV[r1,c] + bV[r2,c1] + bV[r,c1] - 4*bV[r1,c1]

        for r in range(n):
            r1 = r + 1
            for c in range(n):
                c1 = c + 1
                uvv = bU[r1,c1]*bV[r1,c1]*bV[r1,c1]
                bU[r1,c1] += Du*bLu[r,c] - uvv + F*(1 - bU[r1,c1])
                bV[r1,c1] += Dv*bLv[r,c] + uvv - (F + k)*bV[r1,c1]

    return V</code></pre>

                </section>

                <section>
                    <h2>Pythran version</h2>
                    <p>Add this line to the original kernel:
                    </p><pre><code class="python">#pythran export GrayScott(int, float, float, float, float)</code></pre>
                    
                    <h3>Timings</h3>
                    <pre><code class="shell">$ python -m timeit -s 'from grayscott import GrayScott' 'GrayScott(40, 0.16, 0.08, 0.04, 0.06)'
10 loops, best of 3: 52.9 msec per loop
$ cython grayscott.pyx
$ gcc grayscott.c `python-config --cflags --libs` -shared -fPIC -o grayscott.so -O3 -march=native
$ python -m timeit -s 'from grayscott import GrayScott' 'GrayScott(40, 0.16, 0.08, 0.04, 0.06)'
10 loops, best of 3: 36.4 msec per loop
$ pythran grayscott.py -O3 -march=native
$ python -m timeit -s 'from grayscott import GrayScott' 'GrayScott(40, 0.16, 0.08, 0.04, 0.06)'
10 loops, best of 3: 20.3 msec per loop</code></pre>
                </section>

                <section>
                    <h2>Lessons learnt</h2>
                    <p>
                    </p><ul>
                        <li>Explicit is not always better than implicit</li>
                        <li>Many ``optimization hints'' can be deduced by the compiler</li>
                        <li>High level constructs carry valuable informations</li>
                    </ul>
                    
                    <p>
                    <em>I am <strong>not</strong> saying Cython is bad. Cython does a <strong>great</strong> job. It is just <strong>pragmatic</strong> where Pythran is <strong>idealist</strong></em>
                    </p>
                </section>

                <section>
                    <h2>Compilation Challenges</h2>
                    <pre><code class="python">u = U[1:-1,1:-1]
U[n/2-r:n/2+r,n/2-r:n/2+r] = 0.50
u += 0.15*np.random.random((n,n))</code></pre>
                    <p>
                    </p><ul>
                        <li>Array views</li>
                        <li>Value broadcasting</li>
                        <li>Temporary arrays creation</li>
                        <li>Extended slices composition</li>
                        <li>Numpy API calls</li>
                    </ul>
                    
                </section>

                <section>
                    <h2>Optimization Opportunities</h2>
                    <pre><code class="python">Lu = (U[0:-2,1:-1] + U[1:-1,0:-2]
  - 4*U[1:-1,1:-1] + U[1:-1,2:] + U[2:  ,1:-1])</code></pre>

                    <p>
                    </p><ul>
                        <li>Many useless temporaries</li>
                        <li><code class="python">Lu</code> could be forward-substituted</li>
                        <li>SIMD instruction generation opportunities</li>
                        <li>Parallel loop opportunities</li>
                    </ul>
                    
                </section>


        </section>

        <section>

                <section>
                    <h2>Benchmarks</h2>
                    <p>
                    <a href="https://github.com/serge-sans-paille/numpy-benchmarks">https://github.com/serge-sans-paille/numpy-benchmarks</a><br/>
                    A collection of high-level benchmarks
                    </p><ul>
                        <li>Code gathered from StackOverflow + other compiler code base</li>
                        <li>Mostly high-level code</li>
                        <li>Generate results for CPython, PyPy, Numba, Parakeet, Hope and Pythran</li>
                    </ul>
                    <em>Most kernels are too high level for Numba and Hopeâ€¦</em>
                    
                </section>

                <section>
                    <h2>Benchmarks</h2>
                    <p>no parallelism, no vectorisation (, no fat)</p>
                    <img src="./pythran07-benchmarks.png"/>

                </section>

                <section>
                    <h2>(Num)Focus: growcut</h2>
                    <p>From the Numba codebase!</p>
                    <pre><code class="python">#pythran export growcut(float[][][], float[][][], float[][][], int)
import math
import numpy as np
def window_floor(idx, radius):
    if radius &gt; idx:
        return 0
    else:
        return idx - radius


def window_ceil(idx, ceil, radius):
    if idx + radius &gt; ceil:
        return ceil
    else:
        return idx + radius

def growcut(image, state, state_next, window_radius):
    changes = 0
    sqrt_3 = math.sqrt(3.0)

    height = image.shape[0]
    width = image.shape[1]

    for j in xrange(width):
        for i in xrange(height):

            winning_colony = state[i, j, 0]
            defense_strength = state[i, j, 1]

            for jj in xrange(window_floor(j, window_radius),
                             window_ceil(j+1, width, window_radius)):
                for ii in xrange(window_floor(i, window_radius),
                                 window_ceil(i+1, height, window_radius)):
                    if (ii != i and jj != j):
                        d = image[i, j, 0] - image[ii, jj, 0]
                        s = d * d
                        for k in range(1, 3):
                            d = image[i, j, k] - image[ii, jj, k]
                            s += d * d
                        gval = 1.0 - math.sqrt(s)/sqrt_3

                        attack_strength = gval * state[ii, jj, 1]

                        if attack_strength &gt; defense_strength:
                            defense_strength = attack_strength
                            winning_colony = state[ii, jj, 0]
                            changes += 1

            state_next[i, j, 0] = winning_colony
            state_next[i, j, 1] = defense_strength

    return changes</code></pre>


                </section>
                <section>
                    <h2>(Num)Focus: growcut</h2>
                    <img src="growcut.png"/>
                </section>


                <section>
                <h2>Academic Results</h2>
                <ul>
                    <li><strong>Pythran: Enabling Static Optimization of Scientific Python Programs</strong>,
                    S. Guelton, P. Brunet et al. in <em>CSD</em>, 2015</li>
                    <li><strong>Exploring the Vectorization of Python Constructs Using Pythran and Boost SIMD</strong>,
                    S. Guelton, J. Falcou and P. Brunet, in <em>WPMVP</em>, 2014</li>
                    <li><strong>Compiling Python modules to native parallel modules using Pythran and OpenMP Annotations</strong>,
                    S. Guelton, P. Brunet and M. Amini, in <em>PyHPC</em>, 2013</li>
                    <li><strong>Pythran: Enabling Static Optimization of Scientific Python Programs</strong>,
                    S. Guelton, P. Brunet et al. in <em>SciPy</em>, 2013</li>
                </ul>
                
                </section>


                <section>
                <h3>Powered by Strong Engineering</h3>
                <h4>Preprequisite for reproductible science</h4>
                <p>
                </p>

                
                </section>

                <section>
                    <h2>We need more peons</h2>
                    <p>
                    </p><ul>
                        <li>Pythonic needs a serious cleanup</li>
                        <li>Typing module needs better error reporting</li>
                        <li>OSX support is partial and Windows support is on-going</li>
                        <li><code>numpy.random</code> and <code>numpy.linalg</code></li>
                    </ul>
                    
                </section>

        </section>




				</div></body></html>