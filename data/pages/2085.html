<html><body><div><div id="article_text">
    <p>I enjoy coding in Python because I find it very readable and easy to understand quickly. But certain idioms I brought over from other programming languages have cost me a lot in terms of code performance. I used for loops and recursive calls in other languages I coded in. Nether of these are Python idioms and rarely are they the faster in terms of execution time.</p>
<p>I've written up six tips for writing faster Python code. None of these tips were of my own discovery; a whole host of Python Wiki documentation, job interview questions and Stackoverflow answers led me to these speed improvements.</p>
<p>The benchmarks were run in CPython's reference interpreter for Python 2.7, other implementations and versions may vary in their performance.</p>
<div class="section" id="the-right-data-structure-for-the-job">
<h2>The right data structure for the job</h2>
<p>In Python, <cite>dict</cite>, <cite>list</cite> and <cite>set</cite> are three popular data structures. They vary in their operations but there are cases where two or more of the structures can be used to solve the same problem. But the same functionality can have very different time complexities in different structures.</p>
<p>Imagine having ten suitcases and you're trying to find a shirt in one of them. If you have an inventory list stating which suitcase the shirt is in then you'd only need to look in that one suitcase to find it. If you don't have an inventory list then you'd need to search through possibly every suitcase till you've found the shirt you're after. This is a 'membership test': "Does a shirt exist within any of the suitcases?".</p>
<p>Sets are implemented using a hash table (think of this as the inventory list) so membership tests are O(1). Searching a set is as simple as seeing if the object appears at the position described by the hash table. The size of the set doesn't affect the lookup speed.</p>
<p>Lists implement the same functionality using <a class="reference external" href="https://docs.python.org/2/faq/design.html#how-are-lists-implemented">variable-length arrays</a> so operations are O(n). With lists, the whole list potentially needs to be searched. As the list size grows the amount of time needed to search it could grow as well.</p>
<p>In the following example membership testing is 5.8x faster using a set than a list.</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">timeit</span>


<span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="s">'"9" in string'</span><span class="p">,</span>
           <span class="n">setup</span><span class="o">=</span><span class="s">'string = list("abcefg0123456789")'</span><span class="p">,</span>
           <span class="n">number</span><span class="o">=</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">8</span><span class="p">)</span>
<span class="mf">13.123163938522339</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="s">'"9" in string'</span><span class="p">,</span>
           <span class="n">setup</span><span class="o">=</span><span class="s">'string = set("abcefg0123456789")'</span><span class="p">,</span>
           <span class="n">number</span><span class="o">=</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">8</span><span class="p">)</span>
<span class="mf">2.534371852874756</span>
</pre></div>
<p>Even if I made the list a string it's still 1.28x slower than a set.</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">timeit</span>


<span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="s">'"9" in string'</span><span class="p">,</span>
           <span class="n">setup</span><span class="o">=</span><span class="s">'string = "abcefg0123456789"'</span><span class="p">,</span>
           <span class="n">number</span><span class="o">=</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">8</span><span class="p">)</span>
<span class="mf">3.213447093963623</span>
</pre></div>
<p>Not all list operations are slow. The operations to append, get an item, set an item and get the length of a list are all O(1). But deleting an item from a list is O(n) whereas deleting a key from a dictionary is O(1).</p>
<p>The Python wiki has a good write up on <a class="reference external" href="https://wiki.python.org/moin/TimeComplexity">time complexity</a> of Python's data structures.</p>
</div>
<div class="section" id="keep-variables-local">
<h2>Keep variables local</h2>
<p>CPython can store local variables faster than global variables. Look ups are also quicker as it'll look for variables in the local namespace before searching the global and build-in namespaces.</p>
<p>In the following example the loop running in a method is 10.55x faster than the loop running in the global namespace.</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">timeit</span>


<span class="o">&gt;&gt;&gt;</span> <span class="n">setup</span> <span class="o">=</span> <span class="s">"""</span>
<span class="s">    def main():</span>
<span class="s">        for _ in xrange(1000):</span>
<span class="s">            pass</span>
<span class="s">    """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="s">'main()'</span><span class="p">,</span>
           <span class="n">setup</span><span class="o">=</span><span class="n">setup</span><span class="p">,</span>
           <span class="n">number</span><span class="o">=</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">5</span><span class="p">)</span>
<span class="mf">0.9138619899749756</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="s">'for _ in xrange(1000): pass'</span><span class="p">,</span>
           <span class="n">number</span><span class="o">=</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">5</span><span class="p">)</span>
<span class="mf">9.643129110336304</span>
</pre></div>
</div>
<div class="section" id="c-code-usually-outruns-interpreted-code">
<h2>C code usually outruns interpreted code</h2>
<p>Calling out to methods written in C is usually quicker than running interpreted code.</p>
<p>In this example the while loop will run completely interpreted while the <cite>xrange</cite> implementation below it will call out to C. The <cite>xrange</cite> implementation 2.9x faster as a result.</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">timeit</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="s">'while i &lt; 10 ** 8: i += 1'</span><span class="p">,</span>
           <span class="n">setup</span><span class="o">=</span><span class="s">'i = 0'</span><span class="p">,</span>
           <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="mf">2.727679967880249</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="s">'for _ in xrange(0, 10 ** 8): pass'</span><span class="p">,</span>
           <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="mf">0.9349009990692139</span>
</pre></div>
</div>
<div class="section" id="avoid-recursive-calls">
<h2>Avoid recursive calls</h2>
<p>Recursive method calls in Python cause a new stack frame allocation for every call. If you can iterate over a list instead then you avoid this allocation and will see a tremendous speed increase.</p>
<p>The code below runs around 4x faster as a loop than as a recursive method.</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">timeit</span>


<span class="c"># Derived from rosettacode.org/wiki/Fibonacci_sequence</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">setup</span> <span class="o">=</span> <span class="s">"""</span>
<span class="s">    def fib(n):</span>
<span class="s">        def _fib(prvprv, prv, c):</span>
<span class="s">            if c &lt; 1:</span>
<span class="s">                return prvprv</span>
<span class="s">            return _fib(prv, prvprv + prv, c - 1)</span>
<span class="s">        return _fib(0, 1, n)</span>
<span class="s">    """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="s">'fib(35)'</span><span class="p">,</span>
           <span class="n">setup</span><span class="o">=</span><span class="n">setup</span><span class="p">,</span>
           <span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="mf">0.021694183349609375</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">setup</span> <span class="o">=</span> <span class="s">"""</span>
<span class="s">    def fib(n):</span>
<span class="s">        a, b = 1, 1</span>
<span class="s">        for _ in xrange(n - 1):</span>
<span class="s">            a, b = b, a + b</span>
<span class="s">        return a</span>
<span class="s">    """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="s">'fib(35)'</span><span class="p">,</span>
           <span class="n">setup</span><span class="o">=</span><span class="n">setup</span><span class="p">,</span>
           <span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="mf">0.005464076995849609</span>
</pre></div>
<p>There is also a default recursion depth of 1,000 calls in CPython. If you do run recursive method calls make sure they won't call themselves over 999 times.</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">recursive</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>

    <span class="k">return</span> <span class="n">recursive</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">recursive</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="mi">50</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">recursive</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="mi">500</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">recursive</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">5</span><span class="p">,</span> <span class="ow">in</span> <span class="n">recursive</span>
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">5</span><span class="p">,</span> <span class="ow">in</span> <span class="n">recursive</span>
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">5</span><span class="p">,</span> <span class="ow">in</span> <span class="n">recursive</span>
  <span class="o">...</span>
<span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">maximum</span> <span class="n">recursion</span> <span class="n">depth</span> <span class="n">exceeded</span>
</pre></div>
</div>
<div class="section" id="join-rather-than-concatenate">
<h2>Join rather than concatenate</h2>
<p>Strings are immutable objects in Python. In order to change a string a new representation needs to be created. If you concatenate a string in a loop you'll create a new representation of that string during every iteration.</p>
<p>Lists only have a single representation so their creation event happens only once.</p>
<p>In the example below joining is 4x faster than concatenating.</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">timeit</span>


<span class="o">&gt;&gt;&gt;</span> <span class="n">setup</span> <span class="o">=</span> <span class="s">"""</span>
<span class="s">    def concat_str(limit):</span>
<span class="s">        resp = ''</span>
<span class="s">        for num in xrange(limit):</span>
<span class="s">            resp += `num`</span>
<span class="s">        return resp</span>
<span class="s">    """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="s">'concat_str(2 ** 20)'</span><span class="p">,</span>
           <span class="n">setup</span><span class="o">=</span><span class="n">setup</span><span class="p">,</span>
           <span class="n">number</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="mf">3.9850499629974365</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">setup</span> <span class="o">=</span> <span class="s">"""</span>
<span class="s">    def join_list(limit):</span>
<span class="s">        return ''.join([`num` for num in xrange(limit)])</span>
<span class="s">    """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="s">'join_list(2 ** 20)'</span><span class="p">,</span>
           <span class="n">setup</span><span class="o">=</span><span class="n">setup</span><span class="p">,</span>
           <span class="n">number</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="mf">0.9801981449127197</span>
</pre></div>
</div>
<div class="section" id="list-comprehensions-over-loops">
<h2>List comprehensions over loops</h2>
<p>When a for loop executes it looks for an append attribute in it's subject list and calls it during each iteration. List comprehensions don't do this lookup and instead have a dedicated <cite>LIST_APPEND</cite> opcode they call instead.</p>
<p>In the example below the for loop implementation is 25x slower than the list comprehension implementation.</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">timeit</span>


<span class="o">&gt;&gt;&gt;</span> <span class="n">setup</span> <span class="o">=</span> <span class="s">"""</span>
<span class="s">    def join_list(limit):</span>
<span class="s">        resp = []</span>
<span class="s">        for num in xrange(limit):</span>
<span class="s">            resp.append(`num`)</span>
<span class="s">        return ''.join(resp)</span>
<span class="s">    """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="s">'join_list(2 ** 20)'</span><span class="p">,</span>
           <span class="n">setup</span><span class="o">=</span><span class="n">setup</span><span class="p">,</span>
           <span class="n">number</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="mf">24.570796012878418</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">setup</span> <span class="o">=</span> <span class="s">"""</span>
<span class="s">    def join_list(limit):</span>
<span class="s">        return ''.join([`num` for num in xrange(limit)])</span>
<span class="s">    """</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">timeit</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="s">'join_list(2 ** 20)'</span><span class="p">,</span>
           <span class="n">setup</span><span class="o">=</span><span class="n">setup</span><span class="p">,</span>
           <span class="n">number</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="mf">0.9801981449127197</span>
</pre></div>
</div>

  </div>

   <div id="support_text"><p>
    Thank you for taking the time to read this post. If you're considering using </p><a href="https://www.digitalocean.com/?refcode=074ce6598105">Digital Ocean</a><p>, the hosting provider this blog is hosted on, please consider using </p><a href="https://www.digitalocean.com/?refcode=074ce6598105">this link to sign up</a><p>.
  </p></div>


  
</div></body></html>