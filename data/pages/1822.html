<html><body><div><div>
      <section><h1>Painless testing for Django</h1>
        <p>Max Kharandziuk @ DjangoStars</p>
      </section><section><h2>assert is a way to guard you code</h2>
        <ul><li>check program invariants</li>
          <li>checking contracts (e.g. pre-conditions and post-conditions)</li>
          <li>checked documentation</li>
          <li>runtime checks on program logic</li>
        </ul></section><section><h2>Invariant check example:</h2>
        <pre>
          def some_function(arg):
              assert not DB.closed()
              ... # code goes here
              assert not DB.closed()
              return result
        </pre>
      </section><section><h2>Contract check example:</h2>
        <pre>
          def first_upper(astring):
              assert isinstance(astring, str) and len(astring) &gt; 0
              result = astring[0].upper()
              assert isinstance(result, str) and len(result) == 1
              assert result == result.upper()
              return result
        </pre>
      </section><section><h2>Runtime check example:</h2>
        <pre>
        assert target in (x, y, z)
        if target == x:
            run_x_code()
        elif target == y:
            run_y_code()
        else:
            assert target == z
            run_z_code()
        </pre>
      </section><section><h2>Don't do that</h2>
          <pre>
          try:
              assert False
          except AssertionException:
              ...
          </pre>
      </section><section><h2>A little bit of practice:</h2>
            <p>assert sqrt(4) == 2</p>
            <p># should we provide a test for sqrt(9)?</p>
            <p># ...sqrt(4.5)?</p>
            <p># ...sqrt(-1)?</p>
        </section><section><h2>Concepts:</h2>
            <ul><li>black box</li>
                <li>possitive/negative logic</li>
                <li>classes of input</li>
            </ul></section><section><h1>Djangooo!</h1>
        </section><section><h2>No shared state: don't use fixtures</h2>
          <h3>cons:</h3>
          <ul><li>hard to maintain</li>
              <li>it`s not descriptive</li>
              <li>it`s JSON</li>
          </ul></section><section><h2>Better: factory_boy -- factories for data</h2>
          <h3>pros:</h3>
          <ul><li>it's just Python code</li>
              <li>explicit input data for tests</li>
              <li>easy to create complicated data(1-n or n-m relations)</li>
              <li>easy to extend for something other then RDBMS</li>
          </ul></section><section><pre>
class AuthorFactory(factory.DjangoModelFactory):
  FACTORY_FOR = models.Author
  name = factory.Sequence(lambda i: "name{}".format(i))

class PostFactory(factory.DjangoModelFactory):
  FACTORY_FOR = models.Post
  title = factory.Sequence(lambda i: "title{}".format(i))
  author = factory.SubFactory(AuthorFactory)


post = PostFactory(title='specific') 
assert(post.author != None)
          </pre>
      </section><section><h2>Proper level of abstraction: think request-response</h2>
      </section><section><h3>WebTest</h3>
          <p>A test framework for functional testing</p>
      </section><section><h3>Django-WebTest</h3>
          <p>Set of helpers intended to simpify integration with Django</p>
      </section><section><h4>Overview:</h4>
          <ul><li>faster then Selenium</li>
              <li>convenient form handling</li>
              <li>convenient authentication</li>
          </ul><h4>but:</h4>
          </section><section><pre>
from django_webtest import WebTest

class AuthTest(WebTest):
  fixtures = ['users.json']

  def test_login(self):
      form = self.app.get(reverse('auth_login')).form
      form['username'] = 'foo'
      form['password'] = 'bar'
      response = form.submit().follow()
      self.assertEqual(
        response.context['user'].username,
        'foo'
      )
          </pre>
      </section><section><pre>
  def test_login(self):
      user = UserFactory(username='foo', password=PASSWORD)
      form = self.app.get(reverse('auth_login')).form
      form['username'] = user.username
      form['password'] = PASSWORD
      response = form.submit().follow()
      self.assertEqual(
        response.context['user'].username,
        user.username
      )
          </pre>
      </section><section><pre>
def test_can_perform_search__with_tag(self):
    me = UserFactory()
    response = self.app.get(
      reverse('search:query',),
      params={
        'q': 'some query',
        'tag': 'super'
      },
      user=me.username,
    )
    self.assertTemplateUsed(response, 'search/search.html')
        </pre>
      </section><section><h1>it plays really nice with DRF</h1>
      </section><section><pre>
def test_can_perform_search_by_post_title(self):
    me = UserFactory()
    searched_posts = []
    searched_post = [
        PostFactory(title='searched1'),
        PostFactory(title='searched2')
    ]
    response = self.app.get(
        reverse('search:query',),
        params={
            'q': 'search',
        }, xhr=True, user=me.username,
    )
    self.assertEqual(response.status_int, 200)
    result = response.json
    self.assertEqual(len(result['result']), 2)
        </pre>
      </section><section><pre>
def test_can_sign_up(self):
    _user = factories.UserFactory.build()
    assert _user.pk == None
    response = self.app.post(
        reverse('api-v1:users'),
        params={
            'username': _user.username,
            'password': factories.USER_PASSWORD,
        },
        xhr=True,
    )
    self.assertEqual(201, response.status_code)
    user = models.User.objects.get(username=_user.username)
    self.assertIsNotNone(user)
  </pre>
</section><section><pre>
    def test_user_can_get_and_use_token(self):
        user = factories.UserFactory()
        response = self.app.post(
            reverse('api-v1:login'),
            params={
                'username': user.username,
                'password': factories.USER_PASSWORD,
            },
            xhr=True,
        )
        token = response.json['token']
        response = self.app.get(
            reverse('api-v1:users'),
            headers={
              u'Authorization': 'JWT {}'.format(token)
            },
        )
        self.assertEqual(response.status_code, 200)
  </pre>
</section><section><pre>
def test_user_creates_post(self):
    user = factories.UserFactory()
    assert user.posts.count() == 0
    response = self.app.post(
        reverse('api-v1:login'),
        params={
            'username': user.username,
            'password': factories.USER_PASSWORD,
        },
        xhr=True,
    )
    token = response.json['token']
    response = self.app.post(
        reverse('api-v1:posts'),
        params={
            'title': 'some text',
            'body': 'title',
        },
        user=user.username,
        headers={u'Authorization': 'JWT {}'.format(token)},
    )
    self.assertEqual(user.posts.count(), 1)
    </pre>
    </section><section><h2>no mocks(except third-patry API, e.g.: Twitter) </h2>
          <pre>
@patch('project.hub.LoginHandler.onBitesRegistrationComplete', on_bites_registration_complete)
@patch('project.project_aws_sns.AWSPushNotification.exec_in_pool')
@patch('project.hub.LoginHandler.get_gigya_user_info')
@patch('project.hub.LoginHandler.registration', registration)
@patch('project.session.RedisSessionStore.get_session')
@patch('project.hub.LoginHandler.session', new_callable=PropertyMock)
@patch('project.hub.LoginHandler.check_user_password')
def test_login_api(...
           </pre>
      </section><section><pre>
class UsersEndpointTestCase(WebTest):
  setup_auth = False

  @patch('users.backends.requests')
  def test_can_sign_up_and_get_token(self, mock_requests):
    data_for_mock = {
      "id": "737522959636397", "first_name": "Max",
      "last_name": "Kharandziuk", "locale": "en_GB",
    }
    mock_requests.get.return_value.status_code = 200
    mock_requests.get.return_value.json =
      lambda: data_for_mock
    response = self.app.post(
      reverse('api-v1:login'),
      params={
          'username': '#token',
          'password': factories.USER_PASSWORD,
      },
      xhr=True,
    )
    assert response.json['token']
    user = models.User.objects.get(fb_id='737522959636397')
    self.assertIsNotNone(user)
</pre>
</section><section><h2>no logic in tests(don't use loops or conditions!)</h2>
      </section><section><h2>one class of data input -- one test method</h2>
      </section></div>
  </div></body></html>