<html><body><div><div class="ArticleText">
<p class="FeatureByline">
           By <b>Jake Edge</b><br/>December 24, 2014
           </p>
<p>
Python is a poster child for <a href="http://en.wikipedia.org/wiki/Type_system#Dynamic_type-checking_and_runtime_type_information">dynamically typed</a> languages, but
if Guido van Rossum gets his way—as benevolent dictator for life (BDFL), he
usually does—the language will soon get optional support for <a href="http://en.wikipedia.org/wiki/Type_system#Static_type-checking">static
type-checking</a>.  The discussion and debate has played out since August
(at least), but Van Rossum has just <a href="/Articles/627558/">posted a proposal</a> that targets
Python 3.5, which is due in September 2015, for including this "type
hinting" feature.  Unlike many languages (e.g. C, C++, Java), Python's
static type-checking would be optional—programs can still be run even if
the static checker has complaints.
</p>

<p>
Static vs. dynamic type checking is one of the big religious wars in
computer language design.  Statically typed languages rigidly enforce the rules
on the types that can be assigned to variables or passed to functions,
typically refusing to compile or run programs 
that violate those rules.  Dynamically typed (some of which, like Python, are known as "<a href="http://en.wikipedia.org/wiki/Duck_typing">duck typed</a>") languages,
on the other hand, allow an object of any type to be assigned to any variable or
passed to any function, which adds a great deal of flexibility, but can
also lead to runtime errors that could never
occur in a statically typed program.
</p>

<p>
Both type systems have merits—and proponents—but they are usually mutually
exclusive in a particular language. Either dynamic or static
typing is inherent in the language's design, so it is rare to have both.
What Van Rossum is proposing is to adopt the notation used by the 
<a href="http://mypy-lang.org/">mypy static type-checker for Python</a> to,
optionally, specify the types of function parameters and their return
types, along with the types of variables.  
That would allow a static type-checker (either mypy or something else) to
reason (and complain) about the wrong types being used.

</p><p>
For function argument and return types, the
syntax to <a href="https://www.python.org/dev/peps/pep-3107/">annotate
functions</a> is already present in Python 3, and has been since its
first release.  It is a little-used feature that was put into the language to see where it
led.  One of those outcomes was mypy.  Function annotation is fairly
straightforward:
</p><pre>
    def foo(a, b: int, c: str) -&gt; str:
        pass
</pre><p>
That defines a do-nothing function that takes two integers and a string as
arguments and returns a string.  
For those unfamiliar with Python, the "normal" definition of that function
would look like:
</p><pre>
    def foo(a, b, c):
        pass
</pre><p>
As might be guessed, user-defined class names
can be used, as can various built-in aggregation types
(e.g. </p><tt>List[int]</tt><p> or </p><tt>Dict[str, int]</tt><p>).  Python function
annotations are completely open-ended (just associating some value with
each function argument and its return value), so the conventions used to specify
type information are largely derived from mypy (which has good </p><a href="http://mypy.readthedocs.org/en/latest/introduction.html">documentation</a><p>
that includes the type conventions).


</p><p>
There is not yet a Python Enhancement Proposal (PEP) for type hinting,
though there is <a href="https://github.com/ambv/typehinting/blob/master/pep-NNNN.txt">work in
progress</a> on one.  In addition, Van Rossum has put together a <a href="https://quip.com/r69HA9GhGa7J">theory document</a> that he referenced
in his proposal.  It describes a new relationship ("is-consistent-with")
between types; if type <tt>t1</tt> is a subclass of <tt>t2</tt>, <tt>t1</tt> is
consistent with <tt>t2</tt> (but not vice versa).  The <tt>Any</tt> type is kind of
a wildcard, it is consistent with every type (but <tt>Any</tt> is not a
subclass of any
other type) and every type is a subclass of <tt>Any</tt> (thus consistent
with it).  
</p>

<p>
Those simple rules allow various kinds of reasoning about the types that
get assigned to variables and passed to functions.  Van Rossum's ideas come
from a number of sources, but "gradual
typing" is clearly central to his thinking.  His theory document refers
those looking for "<span>a longer explanation and motivation</span>" to
a <a href="http://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/">gradual
typing blog post</a> from Jeremy Siek.  It is, essentially, a blueprint
for providing both static and dynamic typing for a language.
</p>

<p>
There is more to type hinting than just function annotations, however.  The
proposal does not add any syntax to the language for declaring variables to
be a certain type, so comments with a specific format are used:
</p><pre>
    x = {}    # type: Dict[str, str]
</pre><p>
That would declare </p><tt>x</tt><p> to be a dictionary with strings as both keys
and values.  

</p><p>For situations where there are several options for types, the
<tt>Union</tt> type can be used:
</p><pre>
    def feed(a: Union[Animal, Sequence[Animal]]) -&gt; bool:
        pass
</pre><p>
That allows the argument </p><tt>a</tt><p> to either be an instance of the
</p><tt>Animal</tt><p> class or a sequence of </p><tt>Animal</tt><p>s (or, of course, any
type that is-consistent-with those). </p><tt>feed()</tt><p>
returns </p><tt>True</tt><p> or </p><tt>False</tt><p>.  To simplify types in
declarations, aliases can be used:
</p><pre>
    point = Tuple[float, float]

    def distance(a, b: point) -&gt; float:
        pass
</pre><p>
Forward references are handled by strings with the type name that are to be evaluated later:
</p><pre>
    class C:
        def foo(self, other: 'C') -&gt; int:
            pass
</pre><p>
The class </p><tt>C</tt><p> is being referred to before it is defined, so using
        the name as a string (i.e. </p><tt>'C'</tt><p>) avoids the forward reference.


</p><p>
There is more, of course, but that should give a reasonable flavor of the
proposal.  Van Rossum has chosen a fairly aggressive schedule for adding
the feature, which he
acknowledged in his message:
</p><p class="BigQuote">
I am still hoping to get a PEP out for discussion in early January, and I
am aiming for provisional acceptance by PyCon Montréal, which should allow
a first version of typing.py to be included with Python 3.5 alpha 4. If you
are wondering how I can possibly meet that schedule: (a) the entire runtime
component proposal can be implemented as a single pure-Python module: hence
the use of square brackets for generic types; (b) a static type checker is
not part of the proposal: you can use mypy, or write your own.
</p>


<p>
The reaction has been largely positive.  Part of the reason is that the feature only
affects those few who are already using function annotations in some other way
(which won't break, <a href="/Articles/627601/">at least yet</a>) or who
want some amount of static checking added to the language.  While there are
other ways to do so, Van Rossum's approach is minimally intrusive—it
doesn't change the language at <i>all</i>—so those
who want to can simply ignore it entirely.
</p>

<p>
It will be interesting to watch this feature play out over the coming
months.  Even more interesting, though, will be seeing what uses  Python
developers find for a
standardized static type system.  Certain kinds of large
projects and organizations are likely to benefit from static typing, so
some pieces that might have been written in other languages may stick with
Python instead.  In any case, it is yet more evidence that Python has come
a long way since its genesis in the late 1980s.
</p><hr align="left"/><p>
           (</p><a href="https://lwn.net/login?target=/Articles/627418/">Log in</a><p> to post comments)
           </p><p>
           
</p></div> 
</div></body></html>