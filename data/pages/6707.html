<html><body><div><div class="ArticleText">
<p class="FeatureByline">
           By <b>Jonathan Corbet</b><br/>September 10, 2015
           </p><p>
Some languages pride themselves on providing many ways to accomplish any
given task.  Python, instead, tends to focus on providing a single solution
to most problems.  There are exceptions, though; the creation of formatted
strings would appear to be one of them.  Despite the fact that there are
(at least) three mechanisms available now, Python's developers have just
adopted a plan to add a fourth.  
With luck, this new formatting mechanism (slated for Python 3.6) will
improve the traditionally cumbersome string-formatting facilities available
in Python.
</p><p>
Like many interpreted languages, Python is used heavily for string
processing tasks.  At the output end, that means creating formatted text.
Currently, there are three supported ways to get the same result:
</p><p>
</p><pre>
    'The answer is %d' % (42,)

    'The answer = {answer}'.format(answer = 42)

    s = string.Template('The answer is $answer')
    s.substitute(answer=42)
</pre>
<p>

The traditional "<tt>%</tt>" operator suffers from some interesting lexical
traps and only supports a small number of types.  The <tt>format()</tt>
string method is more flexible, but is somewhat verbose, and the
<tt>Template</tt> class seems to combine the shortcomings of the previous
two methods and throws in yet another syntax to boot.  All three methods
require a separation between the format string and the values that are to
be formatted into it, increasing
verbosity and, arguably, decreasing readability, while other languages have
facilities that do not require that separation.

</p><p>
</p><h4>f-strings</h4>
<p>
Other languages, such as Perl and Ruby, have more concise string-formatting
operations.  With the debut of the string interpolation mechanism described
in <a href="https://www.python.org/dev/peps/pep-0498/">PEP 498</a>,
Python will have a similar facility.  This PEP introduces a new type of
string, called an "f-string" ("formatted string") denoted by an
"<tt>f</tt>" character before the opening quote:
</p><p>
</p><pre>
    f'This is an f-string'
</pre>
<p>
F-strings thus join the short list of special string types in Python;
others include <tt>r'raw'</tt> and <tt>b'byte'</tt> strings.  The thing that
makes an f-string special is that it is evaluated as a particular type of
expression when it is executed.  Thus, to replicate the above examples:
</p><p>
</p><pre>
    answer = 42
    f'The answer is {answer}'
</pre>
<p>
As can be seen, f-strings obtain the value to be formatted directly from
the local (and global) namespace; there is no need to pass it in as a
parameter to a formatting function or operator.  Beyond that, though, what
appears between the brackets can be an arbitrary expression:
</p><p>
</p><pre>
    answer = 42
    f'The answer is not {answer+1}'
    f'The root of the answer is {math.sqrt(answer)}'
</pre>
<p>
So formatted output can be created with expressions of just about any
complexity.  These expressions might even have side effects, though one
suspects that would rarely be a good idea.
</p><p>
Under the hood, the execution of f-strings works by evaluating each
expression found in curly brackets, then invoking the 
<tt>__format__()</tt> method on each result.  So the following two lines
would have an equivalent effect:
</p><p>
</p><pre>
    f'The answer is {answer}'
    'The answer is ' + answer.__format__()
</pre>
<p>
A format string to be passed to <tt>__format__()</tt> can be appended to
the expression with a colon, thus, for example:
</p><p>
</p><pre>
    f'The answer is {answer:%04d}'
</pre>
<p>
One can also append "<tt>!s</tt>" to pass the value to <tt>str()</tt>
first, "<tt>!r</tt>" to use <tt>repr()</tt>, or "<tt>!a</tt>" to use
<tt>ascii()</tt>.  So, once again, the following two lines would do the
same thing:
</p><p>
</p><pre>
    f'The answer is {answer:%04d!r}'
    'The answer is ' + repr(answer).__format__('%04d')
</pre>
<p>
That is the core of the change.  There are other details, of course; see
the PEP for the full story.  The PEP was <a href="/Articles/657004/">accepted</a> by Python benevolent dictator for
life Guido 
van Rossum on September 8, so, unless something goes surprisingly
wrong somewhere, f-strings will be a part of the Python 3.6 release.
</p><p>
</p><h4>Where next?</h4>
<p>
PEP 498 was somewhat controversial over the course of its development.
There were a number of concerns about how f-strings fit into the Python
worldview in general, but there was also a specific concern: security.  In
particular, Nick Coghlan <a href="/Articles/657008/">expressed</a> concerns
that f-strings would make it easy to write insecure code.  Examples would
be usage like:
</p><p>
</p><pre>
    os.system(f'cat {file}')
    SQL.run(f'select {column} from {table}')
</pre>
<p>
In either case, if any of the values substituted into the strings are
supplied by the user, the result could be the compromise of the whole
system.  The problem is not that f-strings make it possible to incorporate
untrusted data into trusted strings — that can just as easily be done with
existing string-formatting mechanisms.  And the problem is certainly not
that f-strings make string formatting easier in general; Nick's specific
concern is that 
f-strings will be the <i>easiest</i> way to put strings together, while
more secure methods remain harder.  Using an
f-string to format an SQL query will be easier to code (and to read later)
than properly escaping the parameters, so developers will be drawn toward
the insecure alternative.
</p><p>
His suggestion, as described in <a href="https://www.python.org/dev/peps/pep-0501/">PEP 501</a>, is to make
the secure way as easy to use as the insecure way.  The result is
"i-strings"; they look a lot like f-strings in that the syntax is nearly
identical:
</p><p>
</p><pre>
    i'The answer is {answer}'
</pre>
<p>
There is a key difference, though: while f-strings produce a formatted
string immediately on execution, i-strings delay that formatting.  An
explicit call to a format function is required to do the job.  To see the
difference, consider the two lines below, which have equivalent effect:
</p><p>
</p><pre>
    print(f'The answer is {answer}')
    print(format(i'The answer is {answer}'))
</pre>
<p>
The key to Nick's proposal is that <tt>format()</tt> can be replaced with
another formatting function that knows how to escape dangerous characters
in the intended usage scenario.  Thus:
</p><p>
</p><pre>
    os.system(sh(i'cat {file}'))
    SQL.run(sql(i'select {column} from {table}'))
</pre>
<p>
The <tt>sh()</tt> formatter would ensure that no shell metacharacters get
through, while <tt>sql()</tt> would prevent SQL-injection attacks.  These
formatters would be easy enough to use that developers would not be tempted
to bypass them.  Just as importantly, static analysis software could easily
distinguish between safe and unsafe string usage for a given API, making it
possible to automatically detect when the wrong type of string is being
used. 
</p><p>
PEP 501 has been through a long series of revisions, involving significant
changes, since first being posted.  At times the syntax was rather more
complicated, prompting Guido to <a href="/Articles/657009/">ask</a>:
"<span>Have I died and gone to Perl?</span>".  Nick's proposal had
originally been intended as an alternative to PEP 498, but, over time,
Nick <a href="/Articles/657010/">warmed</a> to the f-string approach and
came out in favor of its adoption.  PEP 501 remains outstanding,
though, and will likely be pursued as an extension to f-strings.
</p><p>
That work, too, could conceivably happen in time for the 3.6 release, which
is planned to happen in late 2016.  Given its volatile history thus far,
chances are that the end result will look somewhat different from what has
been proposed to date.  However it turns out, though, Python should no
longer have to defer to other languages when it comes to the ease of
creating formatted output.</p><hr align="left"/><p>
           (</p><a href="https://lwn.net/login?target=/Articles/656898/">Log in</a><p> to post comments)
           </p><p>
           
</p></div> 
</div></body></html>