<html><body><div><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-simon--speck-block-ciphers-in-python-3x2x" class="anchor" href="#simon--speck-block-ciphers-in-python-3x2x" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Simon &amp; Speck Block Ciphers in Python 3.x/2.x</h1>

<p>Pure python implementations of the <a href="http://eprint.iacr.org/2013/404.pdf">Simon and Speck</a> block ciphers. These are small ciphers designed by the <a href="https://www.nsa.gov/">National Security Agency</a> for use in constrained hardware and software environments such as micro controllers or small ASICs/FPGAs.</p>

<p><strong>WARNING</strong> The following implementations are for reference/research/entertainment only and should not be considered 100% free of bugs or side channel attacks. Use in a production environment is discouraged.</p>

<h2><a id="user-content-basic-usage" class="anchor" href="#basic-usage" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Basic Usage</h2>

<p>Simon and Speck work identically. Once the code has been copied into your project, the ciphers can be imported:</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-k">&gt;&gt;&gt;</span> from speck import SpeckCipher
<span class="pl-k">&gt;&gt;&gt;</span> from simon import SimonCipher</pre></div>

<p>Once imported, a ciphers object that store the state of the cipher can be created. The only parameter required to initialize a cipher object is an encryption key.</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-k">&gt;&gt;&gt;</span> my_speck = SpeckCipher(0x123456789ABCDEF00FEDCBA987654321)
<span class="pl-k">&gt;&gt;&gt;</span> my_simon = SimonCipher(0xABBAABBAABBAABBAABBAABBAABBAABBA)</pre></div>

<p>Once initialized, the cipher can encrypt or decrypt provided plaintext or ciphertext values using the <code>encrypt()</code> and <code>decrypt()</code> methods. The object will continue to process encryption/decryption requests as long as the object exists.</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-k">&gt;&gt;&gt;</span> my_plaintext = 0xCCCCAAAA55553333
<span class="pl-k">&gt;&gt;&gt;</span> speck_ciphertext = my_speck.encrypt(my_plaintext)
<span class="pl-k">&gt;&gt;&gt;</span> speck_plaintext = my_speck.decrypt(speck_ciphertext)
<span class="pl-k">&gt;&gt;&gt;</span> simon_ciphertext = my_simon.encrypt(0xFFFF0000EEEE1111)
<span class="pl-k">&gt;&gt;&gt;</span> simon_plaintext = my_simon.decrypt(simon_ciphertext)</pre></div>

<p>The encryption key may be read or updated by way of the <code>key</code> attribute</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-k">&gt;&gt;&gt;</span> hex(my_speck.key)
<span class="pl-s"><span class="pl-pds">'</span>0x123456789abcdef00fedcba987654321<span class="pl-pds">'</span></span></pre></div>

<h3><a id="user-content-block-and-key-size" class="anchor" href="#block-and-key-size" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Block and Key Size</h3>

<p>All valid key and block sizes as described in the specification are supported as optional parameters. Valid block and key sizes in bits are:</p>

<table><thead>
<tr>
<th align="center"><strong>block size</strong></th>
<th align="center"><strong>key sizes</strong></th>
</tr>
</thead><tbody>
<tr>
<td align="center">32</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">48</td>
<td align="center">72,96</td>
</tr>
<tr>
<td align="center">64</td>
<td align="center">96,128</td>
</tr>
<tr>
<td align="center">96</td>
<td align="center">96,144</td>
</tr>
<tr>
<td align="center">128</td>
<td align="center">128,192,256</td>
</tr>
</tbody></table>

<p>If not supplied at initialization, both ciphers will default to 128-bit encryption keys and block sizes. If the defaults are not used, it is reccomended to specify both the key size and block explictly. </p>

<div class="highlight highlight-source-shell"><pre><span class="pl-k">&gt;&gt;&gt;</span> tiny_cipher = SpeckCipher(0x123456789ABCDEF0, key_size=64, block_size=32)
<span class="pl-k">&gt;&gt;&gt;</span> big_cipher = SimonCipher(0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFF0000, key_size=256, block_size=128)
<span class="pl-k">&gt;&gt;&gt;</span> trunc_cipher = SimonCipher(0x111122223333444455556666777788889999, key_size=96, block_size=48)
<span class="pl-k">&gt;&gt;&gt;</span> hex(trunc_cipher.key)
<span class="pl-s"><span class="pl-pds">'</span>0x444455556666777788889999<span class="pl-pds">'</span></span></pre></div>

<p>All inputted values (keys, plaintexts, IVs, etc) will be truncated or padded with zeros to the bit size specified by the block and key sizes. The current key and block sizes can be accessed via the <code>key_size</code> and <code>block_size</code> attributes</p>

<h3><a id="user-content-block-modes" class="anchor" href="#block-modes" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Block Modes</h3>

<p>For convenience, both ciphers support the <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">most common modes</a> of block cipher operation. </p>

<ul>
<li>Electronic Code Book <code>ECB</code> (Default mode for Speck/Simon)</li>
<li>Counter <code>CTR</code></li>
<li>Cipher Block Chaining <code>CBC</code></li>
<li>Propagating Cipher Block Chaining <code>PCBC</code></li>
<li>Cipher Feedback <code>CFB</code></li>
<li>Output Feedback <code>OFB</code></li>
</ul>

<p>These can be enabled at initialization using the <code>mode</code> optional argument or via the <code>mode</code> attribute after creation.
Other than ECB, these modes require an additional Initialization Vector (IV) and possibly a Counter. These values can be set at cipher creation using the <code>init</code> and <code>counter</code> optional arguments. 
The ciphers automatically update or increment the IV and counter values internal between encrypt and decrypt operations. There is no need to manual update them between operations.</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-k">&gt;&gt;&gt;</span> ofb_cipher = SpeckCipher(1234, mode=<span class="pl-s"><span class="pl-pds">'</span>OFB<span class="pl-pds">'</span></span>, init=0x999999)
<span class="pl-k">&gt;&gt;&gt;</span> ctr_cipher = SimonCipher(0x525354, mode=<span class="pl-s"><span class="pl-pds">'</span>CTR<span class="pl-pds">'</span></span>, init=0xCABCABCAB, counter=1)
<span class="pl-k">&gt;&gt;&gt;</span> ctr_cipher.counter
1
<span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-en">ofb_cipher.update_iv</span>()
10066329</pre></div>

<p>The IV may be may also be altered or read anytime during the cipher objects life using the <code>update_iv()</code> method. If a new IV is provided, this method returns the current IV, otherwise, it returns the IV that was just updated. The ciphers internal counter value may be read and altered through the <code>counter</code> attribute.</p>

<h3><a id="user-content-data-types" class="anchor" href="#data-types" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Data Types</h3>

<p>Currently, both the Speck and Simon ciphers expect <strong>int</strong> inputs for keys, IVs, counters, plaintexts, and ciphertexts. Any value provided that does not match the bit size for keys, plaintexts, etc, will be truncated down or MSB padded with 0's up to the correct size. If your application requires strings or bytearrays, input and output values can be easily translated to and from ints.</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-k">&gt;&gt;&gt;</span> key_bytes = bytes([0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00])
<span class="pl-c"># For Python 3.x Only</span>
<span class="pl-k">&gt;&gt;&gt;</span> key_int = int.from_bytes(key_bytes, byteorder=<span class="pl-s"><span class="pl-pds">'</span>big<span class="pl-pds">'</span></span>, signed=<span class="pl-s"><span class="pl-pds">'</span>False<span class="pl-pds">'</span></span>)
<span class="pl-c"># Python 2.x/3.x</span>
<span class="pl-k">&gt;&gt;&gt;</span> import binascii
<span class="pl-k">&gt;&gt;&gt;</span> key_int = int(binascii.hexlify(key_bytes),16)
<span class="pl-k">&gt;&gt;&gt;</span> hex(key_int)
<span class="pl-s"><span class="pl-pds">'</span>0x112233445566778899aabbccddeeff00<span class="pl-pds">'</span></span>
<span class="pl-k">&gt;&gt;&gt;</span> msg = <span class="pl-s"><span class="pl-pds">'</span>ATTACK AT DAWN!!<span class="pl-pds">'</span></span>
<span class="pl-k">&gt;&gt;&gt;</span> msg_int = sum([ord(c) <span class="pl-k">&lt;&lt;</span> (8 <span class="pl-k">*</span> x) <span class="pl-k">for</span> <span class="pl-smi">x, c</span> <span class="pl-k">in</span> enumerate(reversed(msg))])
<span class="pl-k">&gt;&gt;&gt;</span> hex(msg_int)
<span class="pl-s"><span class="pl-pds">'</span>0x41545441434b204154204441574e2121<span class="pl-pds">'</span></span>
<span class="pl-k">&gt;&gt;&gt;</span> new_cipher = SimonCipher(key_int, key_size=128, block_size=128)
<span class="pl-k">&gt;&gt;&gt;</span> my_secret = new_cipher(msg_int)
<span class="pl-k">&gt;&gt;&gt;</span> my_secret_bytes = bytearray.fromhex(<span class="pl-s"><span class="pl-pds">'</span>{:032x}<span class="pl-pds">'</span></span>.format(my_secret))
<span class="pl-k">&gt;&gt;&gt;</span> my_secret_bytes
bytearray(b<span class="pl-s"><span class="pl-pds">'</span>HD\xbb\xe4\xa1\xed\x95\xd8&gt;\x1bx&lt;HOL[<span class="pl-pds">'</span></span>)</pre></div>

<h2><a id="user-content-tests--examples" class="anchor" href="#tests--examples" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Tests &amp; Examples</h2>

<p>A robust pytest suite is provided in <code>tests.py</code>. Here all the official test vectors are exercised as well as random values. Exceptions are tested as well as block cipher modes. Refer to these tests for clean examples of how to use each mode.</p>
</article>
  </div></body></html>