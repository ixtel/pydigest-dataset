<html><body><div><div><p>With more than half a million PyPI downloads every month, the <a class="reference external" href="http://lxml.de/">lxml</a> toolkit
is the most widely used external XML library for Python.
It's even one of the most often downloaded packages overall, with apparently millions of users world wide.
If you add to that the fact that it's mostly compatible with the standard library ElementTree package,
it shows that its API is highly predominant in the Python world for anything that's XML processing.</p>
<p>However, I keep seeing people ask about the best way to find stuff in their XML documents.
I guess that's because there are a couple of ways to do that: by (recursively) traversing the tree,
by <a class="reference external" href="http://lxml.de/tutorial.html#tree-iteration">iterating</a> over the tree,
or by using the <a class="reference external" href="http://lxml.de/tutorial.html#elementpath">find()</a> methods,
<a class="reference external" href="http://lxml.de/xpathxslt.html#xpath">XPath</a> and even
<a class="reference external" href="http://lxml.de/cssselect.html">CSS selectors</a>
(which now rely on the external <a class="reference external" href="https://pypi.python.org/pypi/cssselect">cssselect</a> package).
There are many ways to do this, simply because there are so many use cases.
XPath is obviously the does-it-all tool here, and many people would quickly recommend an XPath expression
when you give them a search problem, but it's also a lot like regular expressions for XML: now you have two problems.</p>
<p>Often, tree iteration is actually a much better way to do this than XPath.
It's simpler and also faster in most cases.
When looking for a specific tag, you can simply say:</p>
<pre class="code python literal-block">
<span class="k">for</span> <span class="n">paragraph</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s">'p'</span><span class="p">):</span>
    <span class="o">...</span>  <span class="c"># do something with the &lt;p&gt; element</span>
</pre>
<p>Note that this iterates over the tree and processes elements as they are found, whereas the XPath engine always evaluates the expression exhaustively
and only then returns with the complete list of results that it found.
Expressing in XPath that only one element is wanted, i.e. making it short-circuit, can be quite a challenge.</p>
<p>Even when looking for a set of different tags, tree iteration will work just beautifully:</p>
<pre class="code python literal-block">
<span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s">'p'</span><span class="p">,</span> <span class="s">'div'</span><span class="p">,</span> <span class="s">'pre'</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s">'p'</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">elif</span> <span class="n">block</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s">'pre'</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">else</span><span class="p">:</span> <span class="o">...</span>
</pre>
<p>For the more involved tasks, however, such as finding an element in a specific subtree below sme parent,
or selecting elements by attributes or text, you will quickly end up wanting to use a path language anyway.
Lxml comes with two implementations here: ElementPath (implemented in Python) and XPath (implemented in C by libxml2).
At this point, you might think that XPath, being implemented in C, should generally be a better choice, but that's actually not true.
In fact, the ElementPath implementation in lxml makes heavy use of lxml's optimised tree iterators and tends to be faster than the generic XPath engine.
Especially when only looking for one specific element, something like this is usually much faster than using the same expression in XPath:</p>
<pre class="code python literal-block">
<span class="n">target</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">'.//parent/child//target'</span><span class="p">)</span>
</pre>
<p>One really nice feature of ElementPath is that it uses fully qualified tag names rather than resorting to externally defined prefixes.
This means that a single expression in a self-contained string is enough to find what you are looking for:</p>
<pre class="code python literal-block">
<span class="n">target</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">'.//{http://some/namespace}parent/*/{http://other/namespace}target'</span><span class="p">)</span>
</pre>
<p>On the downside, the predicate support in ElementPath is substantially more limited than in real XPath.
Functions do not exist at all, for example.
However, for simple things like testing attribute values, you don't have to sacrifice the performance of ElementPath.</p>
<pre class="code python literal-block">
<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iterfind</span><span class="p">(</span><span class="s">'.//a[@href]'</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">link</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'href'</span><span class="p">)</span>
</pre>
<p>This example only tests for the existence of the attribute, which may still have an empty value.
But you can also look for a specific value:</p>
<pre class="code python literal-block">
<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iterfind</span><span class="p">(</span><span class="s">'.//a[@href = "http://lxml.de/"]'</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"link to lxml's homepage found"</span><span class="p">)</span>
</pre>
<p>So, while XPath may appear like the one thing that helps with all your search needs, it's often better to use a simpler tool for the job.</p></div>
    </div></body></html>