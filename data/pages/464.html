<html><body><div><div class="entry-content" itemprop="articleBody">
    
        <p><em>Update: you can check this out on GitHub <a href="http://www.github.com/jeffknupp/brokest">here</a>.</em></p>
<p><a href="http://docs.celeryproject.org/en/latest/">Celery</a> is probably the best known
task queuing Python package around. It makes asynchronous execution of Python
code both possible and reasonably straightforward. It does, however, come with a
good deal of complexity, and it's not as simple to use as I would like (i.e. for
many use cases it's overkill). So I wrote a distributed Python task queue. In 55
lines of code (caveat: using two awesome libraries).</p>


<h2>Background</h2>
<p>What does a distributed task queue do? It takes code like the following (taken
from the documentation for <a href="http://python-rq.org/">RQ</a>, another Celery alternative):</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">requests</span>

<span class="k">def</span> <span class="nf">count_words_in_page</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
</pre></div>


<p>and allows it to be sent to a worker process (possibly on another machine) for
execution. The worker process then sends back the results after the calculation
is complete. In the meantime, the sender doesn't have to block waiting for the
(possibly expensive) calculation to complete. They can just periodically check
if the results are ready.</p>
<p>So what's the absolute simplest way we could do this?
I submit to you, <code>brokest.py</code>:</p>
<div class="codehilite"><pre><span class="sd">"""Broker-less distributed task queue."""</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="kn">import</span> <span class="nn">zmq</span>
<span class="kn">import</span> <span class="nn">cloud</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s">'127.0.0.1'</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">9090</span>
<span class="n">TASK_SOCKET</span> <span class="o">=</span> <span class="n">zmq</span><span class="o">.</span><span class="n">Context</span><span class="p">()</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">zmq</span><span class="o">.</span><span class="n">REQ</span><span class="p">)</span>
<span class="n">TASK_SOCKET</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s">'tcp://{}:{}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Worker</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""A remote task executor."""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="n">HOST</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="n">PORT</span><span class="p">):</span>
        <span class="sd">"""Initialize worker."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">host</span> <span class="o">=</span> <span class="n">host</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_context</span> <span class="o">=</span> <span class="n">zmq</span><span class="o">.</span><span class="n">Context</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_socket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">zmq</span><span class="o">.</span><span class="n">REP</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Start listening for tasks."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="s">'tcp://{}:{}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">host</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">))</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">runnable_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_socket</span><span class="o">.</span><span class="n">recv_pyobj</span><span class="p">()</span>
            <span class="n">runnable</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">runnable_string</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_socket</span><span class="o">.</span><span class="n">send_pyobj</span><span class="p">(</span><span class="s">''</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_socket</span><span class="o">.</span><span class="n">recv_pyobj</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_socket</span><span class="o">.</span><span class="n">send_pyobj</span><span class="p">(</span><span class="s">''</span><span class="p">)</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_socket</span><span class="o">.</span><span class="n">recv_pyobj</span><span class="p">()</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_work</span><span class="p">(</span><span class="n">runnable</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_socket</span><span class="o">.</span><span class="n">send_pyobj</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_do_work</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Return the result of executing the given task."""</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'Running [{}] with args [{}] and kwargs [{}]'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">task</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">task</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">queue</span><span class="p">(</span><span class="n">runnable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">"""Return the result of running the task *runnable* with the given </span>
<span class="sd">    arguments."""</span>
    <span class="n">runnable_string</span> <span class="o">=</span> <span class="n">cloud</span><span class="o">.</span><span class="n">serialization</span><span class="o">.</span><span class="n">cloudpickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">runnable</span><span class="p">)</span>
    <span class="n">TASK_SOCKET</span><span class="o">.</span><span class="n">send_pyobj</span><span class="p">(</span><span class="n">runnable_string</span><span class="p">)</span>
    <span class="n">TASK_SOCKET</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
    <span class="n">TASK_SOCKET</span><span class="o">.</span><span class="n">send_pyobj</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">TASK_SOCKET</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
    <span class="n">TASK_SOCKET</span><span class="o">.</span><span class="n">send_pyobj</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">TASK_SOCKET</span><span class="o">.</span><span class="n">recv_pyobj</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">results</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">Worker</span><span class="p">()</span>
    <span class="n">w</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>


<p>And to use it? Here's the complete contents of <code>app.py</code>:</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">brokest</span> <span class="kn">import</span> <span class="n">queue</span>

<span class="k">def</span> <span class="nf">count_words_in_page</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">queue</span><span class="p">(</span><span class="n">count_words_in_page</span><span class="p">,</span> <span class="s">'http://www.jeffknupp.com'</span><span class="p">)</span>
<span class="k">print</span> <span class="n">result</span>
</pre></div>


<p>Rather than calling the function directly, you simply call <code>brokest.queue</code> with
the function and it arguments as arguments. While the current implementation is
blocking, it would be trivially easy to make it non-blocking. Adding multiple
workers is just a matter of adding code to make use of a config file with their
locations.</p>
<p>Clearly, the stars here are <code>zmq</code> and <code>cloud</code>. <a href="http://zeromq.org/">ZeroMQ</a>
makes creating distributed systems a lot easier, and the documentation is chock
full of ZeroMQ design patterns (ours is probably the simplest one, Request-Reply).</p>
<p><code>cloud</code> is the LGPL'd <a href="http://www.picloud.com">PiCloud</a> library. PiCloud is a
company whose value proposition is that they let you seamlessly run
computationally intensive Python code using Amazon EC2 for computing resources.
Part of making that a reality, though, required a way to pickle functions <em>and their dependencies</em>
(functions are not normally directly pickle-able). In our example, the <code>Worker</code>
is able to make use of code using <code>requests</code> library despite not having imported it.
It's the secret sauce that makes this all possible.</p>
<h2>Is This For Real?</h2>
<p>The code works, but my intention was not to create a production quality
distributed task queue. Rather, it was to show how new libraries are making it
easier than ever to create distributed systems. Having a way to pickle code
objects and their dependencies is a <em>huge</em> win, and I'm angry I hadn't heard of
PiCloud earlier.</p>
<p>One of the best things about being a programmer is the ability to tinker not
just with things, but with <em>ideas</em>. I can take existing ideas and tweak them, or
combine existing ideas in new ways. I think <code>brokest</code> is an interesting example
of how easy it has become to create distributed systems.</p>
        <small>Posted on <time datetime="2014-02-11 10:00:00" pubdate="" data-updated="true" itemprop="datePublished">Feb 11, 2014</time> by <span itemprop="author"> Jeff Knupp</span></small>
    <p class="meta">
    <a href="/blog/2014/02/11/big-news-about-writing-idiomatic-python" title="Previous Post: Big News About Writing Idiomatic Python">« Previous Post: Big News About Writing Idiomatic Python</a>
    </p>
      

</div>
</div></body></html>