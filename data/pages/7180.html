<html><body><div><div class="entry-content">

                

                <p>Слышали фразу: "Если что-то выглядит как утка, плавает как утка и крякает как утка, то, вероятно, это утка"?
Эта поговорка характеризует утиную типизацию == утипизацию</p>
<p>Смысл утиной типизации заключается в ослаблении типов. Вместо того чтобы заботиться о точном классе объекта мы заботимся о том какие методы для него можно вызвать и какие операции над ним можно выполнять. Таким образом, обычным делом становится просто передать объект методу, зная, что при неправильном использовании будет выброшено исключение (<code>exception</code>).</p>
<p>Например: если есть код</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
   <span class="n">obj</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>


<p>При утиной типизации мы не заботимся о типе объекта <code>obj</code>, нам лишь важно, что у него есть метод <code>start</code>. Если же такого метода нет, то исключение нас разочарует.    </p>
<p>Утиная типизация решает некоторые проблемы иерархической типизации:</p>
<ul>
<li>невозможность явно указать (путем наследования) на совместимость интерфейса со всеми настоящими и будущими интерфейсами, с которыми он идейно совместим;</li>
<li>экспоненциальное увеличение числа связей в иерархии типов.</li>
</ul>
<p><img alt="Image" src="https://pbs.twimg.com/media/BPgjzbBCUAAXgMa.jpg"/></p>
            </div>
            
</div></body></html>