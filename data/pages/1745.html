<html><body><div><div class="content html_format">
      
<em>Представляю вам перевод статей о Django с сайта <a href="http://effectivedjango.com/">effectivedjango.com</a>. Наткнулся я на этот сайт во время изучения данного фреймворка. Информация размещенная на этом ресурсе показалась мне полезной, но так как нигде не нашел перевода на русский, решил сделать сие доброе дело сам. Этот цикл статей, как мне думается, будет полезен веб-разработчикам, которые делают только первые шаги в изучении Django.</em>
<a name="habracut"/>
<hr/>
<a name="contents"/><h1>Оглавление</h1><ul>
<li><a href="#introduction">Введение</a></li>
<li>Эффективный Django. Руководство<br/>
 </li>
<li>Тестирование в Django</li>
<li>Понимание Middleware'ов</li>
<li>Базы данных и модели</li>
<li>Представления-классы (CBV)</li>
<li>Формы</li>
</ul>
<a name="introduction"/><h1>Введение <a href="#contents" title="к оглавлению">⇧</a></h1><p>
Django — это популярный, мощный фреймворк на языке Python. Он имеет множество "</p><abbr title="battaries">батареек</abbr><p>", и позволяет </p><abbr title="get up and going">сразу начать разработку</abbr><p>. Однако вся эта мощь означает, что вы можете написать низкопробный код, который будет казаться рабочим. Так что же подразумевается под Эффективным Django? Под Эффективным Django будем понимать использование Django таким образом, чтобы написанный код был </p><em>связным</em><p>, </p><em>тестируемым</em><p> и </p><em>масштабируемым</em><p>. Что же каждое из этих слов значит?
</p><p>
"</p><em>Связный" код</em><p> — это код, который сосредоточен на выполнении одной вещи, только одной единственной вещи. Это значит, что когда вы пишете функцию или метод — написанный вами код должен делать что-то одно и делать это хорошо.
</p><p>
Это непосредственно относится к написанию </p><em>тестируемого кода</em><p>: код, который делает много вещей, достаточно часто является чересчур сложным для тестирования. Когда я ловлю себя на мысли: «Хорошо, этот кусок кода слишком сложен, чтобы писать для него тесты — это просто не стоит потраченных усилий» — вот сигнал к тому, чтобы вернутся назад и сосредоточиться на упрощении. </p><em>Тестируемый код</em><p> — такой код, который позволяет просто писать для него тесты; код, в котором легко найти проблемы.
</p><p>
И наконец, мы хотим писать </p><em>масштабируемый код</em><p>. Это означает не просто масштабировать его в терминах исполнения, но так же увеличивать в терминах команды и командного понимания. Хорошо протестированные приложения проще для понимания другими (и проще для изменения ими), что подразумевает большую возможность улучшить ваше приложение, путем добавления новых инженеров.
</p><p>
Моя цель — убедить вас в важности этих принципов, и предоставить примеры того, как следуя им, построить более стойкое Django-приложение. Я собираюсь последовательно пройти через процесс построения приложения для управления контактами, рассказывая про решения и стратегию тестирования, которые я использую.
</p><p>
Эти документы являются сочетанием заметок и примеров подготовленных для PyCon 2012, PyOhio 2012, и PyCon 2013, а также для web-разработки </p><a href="https://www.eventbrite.com/">Eventbrite</a><p>. Я все еще работаю над объединением их в один документ, но надеюсь вы найдете их полезными.
</p><p>
Примеры кода для этого руководства доступны на </p><a href="https://github.com/nyergler/effective-django">github'е</a><p>. Отзывы, предложения и вопросы можете присылать на </p><a href="mailto:nathan@yergler.net">nathan@yergler.net</a><p>.</p><p>
Этот документ доступен на </p><a href="http://effectivedjango.com/">сайте</a><p>, а также в форматах </p><a href="http://effectivedjango.com/latex/EffectiveDjango.pdf">PDF</a><p> и </p><a href="http://effectivedjango.com/epub/EffectiveDjango.epub">EPub</a><p>.
</p><p>
Видео этого руководства с PyCon можно посмотреть на </p><a href="https://www.youtube.com/watch?v=NfsJDPm0X54">YouTube</a><p>.

</p><a name="chapter_01"/><h1>Глава 1. Приступая к работе <a href="#contents" title="к оглавлению">⇧</a></h1>
<h2>1.1. Ваша среда разработки</h2><p>
Когда ведется разговор о вашей среде разработки, существует три важных факта, которые необходимо иметь в виду: </p><strong><abbr title="isolation">изоляция</abbr></strong><p>, </p><strong><abbr title="determinism">предопределенность</abbr></strong><p> и </p><strong><abbr title="similarity">сходство</abbr></strong><p>. Каждый из них важен и все они взаимодействуют друг с другом согласованно.

</p><u><em>Изоляция</em></u><p> означает, что вы не сможете случайно воспользоватся инструментами или пакетами установленными вне вашего окружения. Это особенно важно, когда подобное происходит с чем-то, похожим на пакеты Python с расширениями написанными на C: если вы используете что-то установленное на системном уровне и не знаете об этом, то при развертывании или распространении своего кода вы можете обнаружить, что он работает не так как предполагалось. Инструменты наподобие </p><a href="http://www.virtualenv.org/">virtualenv</a><p> могут помочь создать нечто похожее на изолированную среду.
</p><p>
Ваша среда </p><u><em>предопределена</em></u><p>, если вы уверены в том, на какую версию ваших зависимостей вы полагаетесь и сможете ли вы наверняка воспроизвести системное окружение.
</p><p>
И на конец, </p><u><em>сходство</em></u><p> с производственной средой или средой сервера разработки означает, что везде установлена одна и та же операционная система (возможно даже одинаковый </p><abbr title="release">выпуск</abbr><p>) и вы используете одинаковые инструменты как для конфигурирования вашей среды разработки, так и для конфигурирования вашей производственной среды. Это отнюдь не необходимость, но если вы строите большое и сложное программное обеспечение — сходство будет полезно для уверенности в том, что все проблемы, которые вы можете увидеть на «боевом» сервере, воспроизводимы в той среде, где вы ведете разработку. К тому же </p><u><em>сходство</em></u><p> ограничивает область </p><abbr title="investigation">исследования</abbr><p> вашего кода.

</p><h3>1.1.1. Изоляция</h3>
<ul>
<li>Мы хотим избежать использования неизвестных зависимостей или неизвестных версий.</li>
<li><a href="http://www.virtualenv.org/">virtualenv</a> предоставляет простой путь для работы над проектом, без использования системных site-packages.</li>
</ul>
<h3>1.1.2. Предопределенность</h3>
<ul>
<li>Предопределенность означает управление зависимостями.</li>
<li>Выберете один из инструментов и используйте как при разработке, так на «боевом» сервере:<br/>
 </li>
<li>Определите точные версии зависимостей.</li>
</ul><p>
Вы можете точно определить версии используя либо версию пакета на PyPI, либо же определенную ревизию (SHA в git, номер ревизии в Subversion и т. д.). Это гарантирует вам возможность получить в точности те же версии пакетов, которые вы используете при тестировании.

</p><h3>1.1.3. Сходство</h3>
<ul>
<li>Работа в среде, похожей на ту, где вы будете разворачивать ваше приложение и пытаться обнаружить проблемы.</li>
<li>Если вы разрабатываете что-то, требующее дополнительных сервисов — сходство становится еще более важным.</li>
<li><a href="http://vagrantup.com/">Vagrant</a> — это инструмент для управления виртуальными машинами, позволяющий вам легко создавать окружение отделенное от вашего повседневного окружения.</li>
</ul>

<h2>1.2. Настройка вашего окружения</h2>
<h3>1.2.1. Создание чистого рабочего пространства</h3>
<blockquote><em><u>Примечание переводчика:</u></em><br/>
<em>Для начала создадим каталог (<code>tutorial</code>), в котором будем работать:</em><br/>
<br/>
<pre><code>~$ mkdir tutorial
~$ cd tutorial
~/tutorial$ mkdir venv project</code></pre><br/>
<em>В каталоге <code>venv</code> будет находится наше виртуальное окружение, а в каталоге <code>project</code> — Django-проект</em></blockquote>
<pre><code>~/tutorial$ virtualenv --prompt="(venv:tutorial)" ./venv/

New python executable in ./venv/bin/python
Installing setuptools............done.
Installing pip...............done.

~/tutorial$ source ./venv/bin/activate
(venv:tutorial)~/tutorial$</code></pre>

<h3>1.2.2. Создание файла зависимостей</h3><p>
Создайте файл </p><code>requirements.txt</code><p> в директории </p><code>tutorial</code><p> с единственной строкой (зависимостью) в нем:

</p><pre><code>Django==1.6.7</code></pre>
<blockquote><em><u>Примечание переводчика:</u></em><br/>
<em>В случае, если вы хотите использовать последнюю версию Django (1.7 — на момент написания перевода) — вместо строки <code>Django==1.6.7</code> оставьте просто <code>Django</code> — pip установит последнюю доступную версию.</em></blockquote>
<h3>1.2.3. Установка зависимостей</h3><p>
А теперь мы можем использовать </p><a href="http://www.pip-installer.org/">pip</a><p> для установки зависимостей:

</p><pre><code>(venv:tutorial)~/tutorial$ pip install -U -r requirements.txt

Downloadping/unpacking Django==1.6.7 (from -r requirements.txt (line 1))
  Downloading Django-1.6.7.tar.gz (6.6MB): 6.6MB downloaded
  Running setup.py egg_info for package Django

    warning: no previously-included files matching ’__pycache__’ found under directory ’*’
    warning: no previously-included files matching ’*.py[co]’ found under directory ’*’
Installing collected packages: Django
  Running setup.py install for Django
    changing mode of build/scripts-2.7/django-admin.py from 644 to 755

    warning: no previously-included files matching ’__pycache__’ found under directory ’*’
    warning: no previously-included files matching ’*.py[co]’ found under directory ’*’
    changing mode of /home/nathan/p/edt/bin/django-admin.py to 755
Successfully installed Django
Cleaning up...</code></pre>

<h2>1.3. Начало проекта Django</h2><p>
Когда здание находится в процессе постройки, строительные леса часто используются для поддержания структуры до того как строительство будет завершено. Строительные леса могут быть временными или они могут служить частью фундамента здания, но несмотря на это, они представляют некоторую поддержку когда вы только начинаете работу.
</p><p>
Django, как и многие web-фреймворки, представляет </p><abbr title="scaffolding"><a href="https://en.wikipedia.org/wiki/Scaffold_(programming)">скаффолдинг</a></abbr><p> для вашей разработки. Это происходит при помощи принятия решений и предоставления отправной точки для вашего кода, что позволяет вам сосредоточится на проблеме, которую вы пытаетесь решить, а не на том, как разобрать HTTP-запрос. Django предоставляет скаффолдинг как для работы с HTTP, так и для работы с файловой системой.
</p><p>
HTTP-скаффолдинг управляет, например, преобразованием HTTP-запроса в объект языка Python, а также предоставляет инструменты для более простого создания серверных ответов. Скаффолдинг файловой системы иной: это набор соглашений по организации вашего кода. Эти соглашения облегчают добавление новых инженеров в проект, так как инженеры (гипотетически) уже понимают как организован код. В терминах Django, </p><em><abbr title="project">проект</abbr></em><p> — это конечный продукт, и он объединяет внутри себя одно или несколько </p><em><abbr title="apps">приложений</abbr></em><p>. В Django 1.4 было изменено то, как проекты и приложения размещаются на диске, что облегчило разъединение и повторное использование приложений в разных проектах.

</p><h3>1.3.1. Создание проекта</h3><p>
Django устанавливает в систему скрипт </p><code>django-admin.py</code><p> для обработки задач скаффолдинга. Для создания файлов проекта используется задача </p><code>startproject</code><p>. Мы определим имя проекта и имя директории, в которой хотим разместить проект. Так как, мы уже находимся в изолированной среде, можно просто написать:

</p><blockquote><em><u>Примечание переводчика:</u></em><br/>
<em>Перейдем директорию <code>~/tutorial/project/</code> и в дальнейшем будем работать только из этой директории (под <code>$</code> далее будем подразумевать <code>~/tutorial/project/$</code>):</em><br/>
<br/>
<pre><code>(venv:tutorial)~/tutorial/$ cd project</code></pre></blockquote>
<pre><code>(venv:tutorial)$ django-admin.py startproject addressbook .</code></pre><p>
Созданный проект имеет следующую структуру

</p><pre><code>manage.py
./addressbook
    __init__.py
    settings.py
    urls.py
    wsgi.py</code></pre>

<h3>1.3.2. Скаффолдинг проекта</h3>
<ul>
<li><code>manage.py</code> — является ссылкой на скрипт <code>django-admin</code>, но с уже предустановленными переменными окружения, указывающими на ваш проект, как для чтения настроек оттуда, так и для управления им при необходимости;</li>
<li><code>settings.py</code> — здесь находятся настройки вашего проекта. Файл уже содержит несколько разумных настроек, но база данных не указана;</li>
<li><code>urls.py</code> — содержит URL'ы для <abbr title="mapping"><a href="https://en.wikipedia.org/wiki/Data_mapping">маппирования (отображения)</a></abbr> представлений: мы вскоре (<em>в дальнейших главах</em>) поговорим об этом подробнее;</li>
<li><code>wsgi.py</code> — это <a href="https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface">WSGI</a> <abbr title="wrapper">обёртка</abbr> для вашего приложения. Этот файл используется сервером разработки Django и возможно другими контейнерами, такими как <code>mod_wsgi</code>, <code>uwsgi</code> и др. на «боевом» сервере.</li>
</ul>

<h3>1.3.3. Создание приложения</h3>
<pre><code>(venv:tutorial)$ python ./manage.py startapp contacts</code></pre><p>
Созданное приложение имеет следующую структуру:

</p><pre><code>./contacts
    __init__.py
    models.py
    tests.py
    views.py</code></pre>
<ul>
<li>Начиная с Django 1.4, приложения размещаются внутри пакета с проектом. Это замечательное улучшение, особенно когда приходит время разворачивать проект на «боевом» сервере;</li>
<li><code>models.py</code> будет содержать Django ORM-модели для вашего приложения;</li>
<li><code>views.py</code> будет содержать код представлений;</li>
<li><code>tests.py</code> будет содержать написанные вами модульные и интеграционные тесты.</li>
<li><em>Django 1.7: <code>admin.py</code> будет содержать модель для административного интерфейса.</em></li>
<li><em>Django 1.7: <code>migrations/</code> содержит файлы миграций</em></li>
</ul>
<blockquote><em><u>Примечание переводчика:</u></em><br/>
<em>На текущий момент наша директория <code>~/tutorial/</code> содержит файл зависимостей (<code>requirements.txt</code>), директорию с виртуальным окружением (<code>venv/</code>), один проект (<code>project/addressbook</code>), одно приложение (<code>project/contacts</code>) и имеет следующее содержание:</em><br/>
<br/>
<pre><code>~/tutorial/
	requirements.txt
	venv/
		...
	project/
		manage.py
		addressbook/
			__init__.py
			settings.py
			urls.py
			wsgi.py
		contacts/
			__init__.py
			models.py
			tests.py
			views.py</code></pre></blockquote>

<a name="chapter_02"/><h1>Глава 2. Используем модель <a href="#contents" title="к оглавлению">⇧</a></h1>
<h2>2.1. Конфигурирование базы данных</h2><p>
Django поддерживает «из коробки» MySQL, PostgreSQL, SQLite3 и Oracle. </p><a href="http://docs.python.org/2/library/sqlite3.html">SQLite3</a><p> входит в состав Python начиная с версии 2.5, так что мы будем использовать его в нашем проекте (для простоты). Если вы хотите, к примеру, использовать MySQL, то нужно добавить </p><a href="https://pypi.python.org/pypi/MySQL-python">mysql-python</a><p> в ваш </p><code>requirements.txt</code><p>.
</p><p>
Для того чтобы в качестве базы данных использовать SQLite, отредактируйте определение </p><code>DATABASES</code><p> в файле </p><code>addressbook/settings.py</code><p>. Файл settings.py содержит настройки Django для нашего проекта. В нем есть несколько настроек, которые вы обязаны указать — например </p><code>DATABASES</code><p> — а так же другие, необязательные, настройки. Django устанавливает некоторые настройки сам, когда генерирует проект. Документация содержит </p><a href="https://docs.djangoproject.com/en/1.5/ref/settings/">полный список настроек</a><p>. К тому же вы можете добавить свои собственные настройки, если это необходимо.
</p><p>
Для использования SQLite нам нужно указать движок (</p><code>ENGINE</code><p>) и имя базы (</p><code>NAME</code><p>). SQLite интерпертирует имя базы как имя файла для базы данных:

</p><pre><code class="python">DATABASES = {
    'defaults': {
	    'ENGINE': 'django.db.backends.sqlite3,' # ’postgresql_psycopg2’, ’mysql’, ’sqlite3’ or ’oracle'.
		'NAME': os.path.join(BASE_DIR, 'address.db'),
		'USER': '',     # Not used with sqlite3.
		'PASSWORD': '', # Not used with sqlite3.
		'HOST': '',     # Set to empty string for localhost. Not used with sqlite3.
		'PORT': '',     # Set to empty string for default. Not used with sqlite3.
	}
}</code></pre><p>
Заметьте, что движок базы данных указан строкой, а не прямой ссылкой на объект Python. Это сделано по той причине, что файл настроек должен быть легко импортирован </p><abbr title="without triggering any side effects">не вызывая сторонних эффектов</abbr><p>. Вы должны избегать добавления вызовов import в этот файл.
</p><p>
Вам редко придется непосредственно импортировать файл настроек: Django импортирует его за вас, и делает настройки доступными как </p><code>django.conf.settings</code><p>. Вы, как правило, импортируете настройки из </p><code>django.conf</code><p>:

</p><pre><code class="python">from django.conf import settings</code></pre>

<h2>2.2. Создание модели</h2><p>
Модели Django отображают (грубо говоря) таблицы базы данных, и предоставляют место для инкапсулирования бизнес-логики. Все модели являются наследниками базового класса </p><a href="https://docs.djangoproject.com/en/1.5/ref/models/instances/#django.db.models.Model">Model</a><p> и содержат поля определений. Давайте создадим простую модель </p><code>Contacts</code><p> для нашего приложения в файле </p><code>contacts/models.py</code><p>:

</p><pre><code class="python">from django.db import models

class Contact(models.Model):

    first_name = models.CharField(
        max_length=255,
    )
    last_name = models.CharField(
        max_length=255,
    )
	
    email = models.EmailField()

	def __str__(self):

	    return ' '.join([
            self.first_name,
            self.last_name,
        ])</code></pre><p>
Django предоставляет </p><a href="https://docs.djangoproject.com/en/1.5/ref/models/fields/">набор полей</a><p> для отображения типов данных и различных правил валидации. К примеру, </p><code>EmailField</code><p>, который мы использовали, является отображением на колонку с типом </p><code>CharField</code><p>, но добавляет валидацию данных.
</p><p>
После того, как вы создали модель, необходимо дополнить вашу базу данных новыми таблицами. Команда Django </p><code>syncdb</code><p> смотрит установленные модели и создает (если нужно) таблицы для них:

</p><blockquote><em><u>Примечание переводчика:</u><br/>
Django предложит создать суперпользователя для андминки, которая включена в этой версии по умолчанию. Воспользуйтесь его предложением.</em></blockquote><blockquote><em><u>Примечание переводчика:</u><br/>
С версии Django 1.7 во фреймворк добавлена нативная поддержка <a href="http://djbook.ru/rel1.7/topics/migrations.html">миграций</a> и команда <code>syncdb</code> объявлена устаревшей. Так что будьте так любезны, воспользуйтесь командой <code>migrate</code> вместо <code>syncdb</code>.</em></blockquote>
<pre><code>(venv:tutorial)$ python ./manage.py syncdb

Creating tables ...
Creating table django_admin_log
Creating table auth_permission
Creating table auth_group_permissions
Creating table auth_group
Creating table auth_user_groups
Creating table auth_user_user_permissions
Creating table auth_user
Creating table django_content_type
Creating table django_session

You just installed Django's auth system, which means you don't have any superusers defined.
Would you like to create one now? (yes/no): yes
Username (leave blank to use 'bjakushka'):
Email address: 
Password:
Password (again):
Superuser created successfully.
Installing custom SQL ...
installing indexes ...
Installed 0 object(s) from 0 fixture(s)

(venv:tutorial)$</code></pre><blockquote><em><u>Примечание переводчика:</u><br/>
Если вы используете Django версии 1.7 и выше — вывод будет следующий:</em><br/>
<br/>
<pre><code>(venv:tutorial)$ python ./manage.py migrate

Opperation to perform:
    Apply all migrations: admin, contenttypes, auth, sessions
Running migrations:
    Applying contenttypes.0001_initial... OK
    Applying auth.0001_initial... OK
    Applying admin.0001_initial... OK
    Applying sessions.0001_initial... OK

(venv:tutorial)$ </code></pre></blockquote><p>
Однако нашей таблицы с контактами нигде не видно. Причина этого состоит в том, что нам нужно еще указать проекту использовать приложение.
</p><p>
Настройка </p><code>INSTALLED_APPS</code><p> содержит список приложений, используемых в проекте. Этот список содержит в себе строки, которые отображают пакеты Python. Django будет импортировать каждый из указанных пакетов, а потом смотреть модуль </p><code>models</code><p>. Давайте добавим наше приложение </p><code>contacts</code><p> в настройки проекта (</p><code>addressbook/settings.py</code><p>):

</p><pre><code class="python">INSTALLED_APPS = (
  'django.contrib.admin',
  'django.contrib.auth',
  'django.contrib.contenttypes',
  'django.contrib.sessions',
  'django.contrib.messages',
  'django.contrib.staticfiles',
  
  'contacts',
)</code></pre><p>
После этого запустите </p><code>syncdb</code><p> снова:</p><blockquote><em><u>Примечание переводчика:</u><br/>
Для Django версии 1.7 и выше вам нужно будет запустить сначала команду <code>makemigrations</code> — для создания миграций на основе изменений в моделях, а после этого выполнить команду <code>migrate</code> — для того чтобы применить созданные миграции.</em></blockquote>
<pre><code>(venv:tutorial)$ python ./manage.py syncdb

Creating tables ...
Creating table contacts_contact
Installing custom SQL ...
Installing indexes ...
Installed 0 object(s) from 0 fixture(s)

(venv:tutorial)$</code></pre><blockquote><em><u>Примечание переводчика:</u><br/>
Вывод для Django 1.7 и выше:</em><br/>
<br/>
<pre><code>(venv:tutorial)$ python ./manage.py makemigrations

Migrations for 'contacts':
    0001_initial.py:
        - Create model Contact

(venv:tutorial)$ python ./manage.py migrate

Opperation to perform:
    Apply all migrations: admin, contenttypes, sessions, auth, contacts
Running migrations:
    Applying contacts.0001_initial... OK

(venv:tutorial)$ </code></pre></blockquote><p>
Заметьте, что Django создает таблицу с именем </p><code>contacts_contact</code><p>: по умолчанию Dj ango дает таблицам имена используя комбинацию имени приложения и имени модели. Вы можете изменить это с помощью опций модели </p><a href="https://docs.djangoproject.com/en/1.5/ref/models/options/">Meta</a><p>.

</p><h2>2.3. Взаимодействие с моделью</h2><p>
Теперь, когда модель синхронизирована с базой данных мы можем взаимодействовать с нею используя интерактивную оболочку:

</p><pre><code>(venv:tutorial)$ python ./manage.py shell
Python 2.7.3 (default, Mar 14 2014, 11:57:14)
[GCC 4.7.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
&gt;&gt;&gt; from contacts.models import Contact
&gt;&gt;&gt; Contact.objects.all()
[]
&gt;&gt;&gt; Contact.objects.create(first_name='Nathan', last_name='Yergler')
&lt;Contact: Nathan Yergler&gt;
&gt;&gt;&gt; Contact.objects.all()
[&lt;Contact: Nathan Yergler&gt;]
&gt;&gt;&gt; nathan = Contact.objects.get(first_name='Nathan')
&gt;&gt;&gt; nathan
&lt;Contact: Nathan Yergler&gt;
&gt;&gt;&gt; print nathan
Nathan Yergler
&gt;&gt;&gt; nathan.id
1</code></pre><p>
Здесь использовалось несколько новых штук. Во-первых, команда </p><code>manage.py shell</code><p> запускает для нас интерактивную оболочку Python'а с правильно установленными путями для Django. Если вы попробуете запустить интерпретатор Python и просто импортировать ваше приложения, будет выброшено исключение, потому что Django не знает, какие настройки использовать, и не может отобразить экземпляры модели на базу данных. 
</p><p>
Во-вторых, здесь использовалось свойство </p><code>objects</code><p> нашей модели. Это </p><a href="https://docs.djangoproject.com/en/1.5/topics/db/managers/">менеджер модели</a><p>. Так, если один экземпляр модели является аналогией для строки в базе, то менеджер модели — аналогией для таблицы. По умолчанию менеджер модели предоставляет функциональность запросов и может быть настроен. Когда мы вызываем </p><code>all()</code><p>, </p><code>filter()</code><p> или сам менеджер, возвращается объект </p><code>QuerySet</code><p>. </p><code>QuerySet</code><p> является итерируемым объектом и загружает данные из базы по необходимости.
</p><p>
И последнее — выше использовалось поле с именем </p><code>id</code><p>, которое мы не определяли в нашей модели. Django добавляет это поле как первичный ключ для модели, но только в том случае если вы сами не определили какое поле будет </p><a href="https://docs.djangoproject.com/en/1.5/topics/db/models/#automatic-primary-key-fields">первичным ключом</a><p>.

</p><h2>2.4. Написание тестов</h2><p>
В нашей модели определен один метод, </p><code>__str__</code><p>, так что настало время писать тесты. Метод </p><code>__str__</code><p> будет использоваться всего лишь в нескольких местах, и, </p><abbr title="it’s entirely conceivable it’d be exposed to end users">вполне возможно, полностью будет показан конечному пользователю</abbr><p>. </p><abbr title="It’s worth writing a test so we understand how we expect it to operate">Для этого метода стоит написать тест, пока мы понимаем как он работает</abbr><p>. Django создал файл </p><code>tests.py</code><p> когда создавал приложение, так что мы добавим первый тест в этот файл, приложения </p><code>contacts</code><p>.

</p><pre><code class="python">from django.test import TestCase

from contacts.models import Contact

class ContactTests(TestCase):
    """Contact model tests."""
	
    def test_str(self):
	
        contact = Contact(first_name='John', last_name='Smith')
        self.assertEquals(
            str(contact),
            'John Smith',
        )</code></pre><p>
Вы можете запустить тесты для вашего приложения используя команду </p><code>manage.py test</code><p>:

</p><pre><code>(venv:tutorial)$ python ./manage.py test</code></pre><p>
Если вы запустите это, то увидите что выполнилось около 420 тестов. Это удивляет, так как мы написали только один. Произошло это потому, что по умолчанию Django запускает тесты для всех установленных приложений. Когда вы добавляли приложение </p><code>contacts</code><p> в наш проект, то могли увидеть, что там по умолчанию были добавлены несколько встроенных приложений Django. Дополнительные 419 тестов были взяты оттуда.
</p><blockquote><em><u>Примечание переводчика:</u></em><br/>
<em>В нашем случае (при использовании версии Django 1.6.7) предыдущий абзац несколько устарел: запустится только один тест — тот который мы создали. Вывод команды будет такой как указано ниже.</em></blockquote><p>
Если же вы захотите запустить тесты для определенного приложения — укажите имя приложения в команде:

</p><pre><code>(venv:tutorial)$ python manage.py test contacts

Creating test database for alias ’default’...
.
----------------------------------------------------------------------
Ran 1 tests in 0.001s

OK
Destroying test database for alias ’default’...

(venv:tutorial)$</code></pre><p>
Еще одна интересная вещь на заметку, прежде чем двигаться дальше — первая и последняя строка вывода: </p><code>Creating test database</code><p> и </p><code>Destroying test database</code><p>. Некоторым тестам необходим доступ к базе данных, и поскольку мы не хотим мешать тестовые данные с «реальными» (по разным причинам, не последней из которых является предопределенность), Django услужливо создает тестовую базу для нас, прежде чем запускать тесты. По существу, создается новая база данных, и потом запускается </p><code>syncdb</code><p> для нее. Если тестовый класс является потомком класса </p><code>TestCase</code><p> (как у нас), Django так же сбросит данные в значения по умолчанию после запуска каждого теста, так что изменения в одном из тестов не затронут другие.

</p><h2>2.5. Резюме</h2>
<ul>
<li>Модель определяет поля в таблице, и содержит бизнес-логику.</li>
<li>Команда <code>syncdb</code> создает таблицы в вашей базе данных из моделей. <em>В Django версии 1.7 и выше вместо команды <code>syncdb</code> необходимо использовать сначала команду <code>makemigrations</code> — для создания миграций, а после этого команду <code>migrate</code> — для внесение изменений в базу.</em></li>
<li>Менеджер модели позволяет вам оперировать коллекциями экземпляров: запросы, создание и т. д..</li>
<li>Пишите модульные тесты для методов, которые вы добавили в модель.</li>
<li>Команда управления <code>test</code> запускает модульные тесты на выполнение.</li>
</ul>
<blockquote><em><u>Примечание переводчика:</u></em><br/>
<em>Для того чтобы протестировать наше, пока еще пустое, приложение нужно выполнить следующую команду:</em><br/>
<br/>
<pre><code>(venv:tutorial)$ python ./manage.py runserver 0.0.0.0:8080</code></pre><br/>
<em>Это запустит встроенный сервер, функционал которого любезно предоставляет нам Django. В параметрах после <code>runserver</code> указывается ip-адрес и порт, который будет слушаться работающим сервер. В нашем случае сервер будет принимать запросы от всех ip-адресов при обращении на 8080 порт.<br/>
<br/>
Я использую для разработки домашний сервер с внутренним IP 192.168.1.51. Так что для того что-бы увидеть результат работы сервера разработки в браузере я захожу по адресу <a href="http://192.168.1.51:8080/">http://192.168.1.51:8080/</a>. Вы же должны подставить адрес своего сервера.<br/>
<br/>
<a href="//habrastorage.org/files/bb9/f41/93a/bb9f4193a8934150ab84199c02d16812.png"/></em></blockquote>
<hr/>
<em> Как думаете, нужно ли продолжать перевод остальных глав? Оказался ли перевод для Вас полезен?<br/>
 Буду рад конструктивной критике в комментариях.<br/>
 Об ошибках и неточностях перевода прошу сообщать в личном сообщении.<br/>
</em>
<em>Использованное в начале поста изображение создано как вариация <a href="http://aruseni.deviantart.com/art/Django-white-and-green-318200642">изображения</a> пользователя  <a href="https://habrahabr.ru/users/magic2lantern/" class="user_link">MaGIc2laNTern</a></em>
      <p class="clear"/>
    </div>

    
  </div></body></html>