<html><body><div><p>Add the django-multisite/multisite folder to your PYTHONPATH.</p>
<div id="quickstart">
<h2>Quickstart</h2>
<p>Replace your SITE_ID in settings.py to:</p>
<pre>from multisite import SiteID
SITE_ID = SiteID()
</pre>
<p>Add to settings.py TEMPLATE_LOADERS:</p>
<pre>TEMPLATE_LOADERS = (
    'multisite.template_loader.Loader',
    'django.template.loaders.app_directories.Loader',
)
</pre>
<p>Edit to settings.py MIDDLEWARE_CLASSES:</p>
<pre>MIDDLEWARE_CLASSES = (
    ...
    'multisite.middleware.DynamicSiteMiddleware',
    ...
)
</pre>
<p>Append to settings.py, in order to use a custom cache that can be
safely cleared:</p>
<pre># The cache connection to use for django-multisite.
# Default: 'default'
CACHE_MULTISITE_ALIAS = 'multisite'

# The cache key prefix that django-multisite should use.
# Default: '' (Empty string)
CACHE_MULTISITE_KEY_PREFIX = ''
</pre>
<p>If you have set CACHE_MULTISITE_ALIAS to a custom value, <em>e.g.</em>
<tt>'multisite'</tt>, add a separate backend to settings.py CACHES:</p>
<pre>CACHES = {
    'default': {
        ...
    },
    'multisite': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'TIMEOUT': 60 * 60 * 24,  # 24 hours
        ...
    },
}
</pre>
</div>
<div id="domain-fallbacks">
<h2>Domain fallbacks</h2>
<p>By default, if the domain name is unknown, multisite will respond with
an HTTP 404 Not Found error. To change this behaviour, add to
settings.py:</p>
<pre># The view function or class-based view that django-multisite will
# use when it cannot match the hostname with a Site. This can be
# the name of the function or the function itself.
# Default: None
MULTISITE_FALLBACK = 'django.views.generic.base.RedirectView

# Keyword arguments for the MULTISITE_FALLBACK view.
# Default: {}
MULTISITE_FALLBACK_KWARGS = {'url': 'http://example.com/',
                             'permanent': False}
</pre>
<p>Create a directory settings.TEMPLATE_DIRS directory with the names of
domains, such as:</p>
<pre>mkdir templates/example.com
</pre>
</div>
<div id="cross-domain-cookies">
<h2>Cross-domain cookies</h2>
<p><em>New in version 0.3.0.</em></p>
<p>In order to support <a href="http://en.wikipedia.org/wiki/HTTP_cookie#Domain_and_Path" rel="nofollow">cross-domain cookies</a>,
for purposes like single-sign-on,
prepend the following to the top of
settings.py MIDDLEWARE_CLASSES:</p>
<pre>MIDDLEWARE_CLASSES = (
    'multisite.middleware.CookieDomainMiddleware',
    ...
)
</pre>
<p>CookieDomainMiddleware will consult the <a href="http://publicsuffix.org/" rel="nofollow">Public Suffix List</a>
for effective top-level domains.
It caches this file
in the systemâ€™s default temporary directory
as <tt>effective_tld_names.dat</tt>.
To change this in settings.py:</p>
<pre>MULTISITE_PUBLIC_SUFFIX_LIST_CACHE = '/path/to/multisite_tld.dat'
</pre>
<p>By default,
any cookies without a domain set
will be reset to allow *.domain.tld.
To change this in settings.py:</p>
<pre>MULTISITE_COOKIE_DOMAIN_DEPTH = 1  # Allow only *.subdomain.domain.tld
</pre>
<p>In order to fetch a new version of the list,
run:</p>
<pre>manage.py update_public_suffix_list
</pre>
</div>


</div></body></html>