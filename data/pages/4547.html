<html><body><div><div class="content html_format"><p>
      Рассуждая о функциональном программировании, люди часто начинают выдавать кучу «функциональных» характеристик. Неизменяемые данные, функции первого класса и оптимизация хвостовой рекурсии. Это свойства языка, помогающие писать функциональные программы. Они упоминают мапирование, каррирование и использование функций высшего порядка. Это приёмы программирования, использующиеся для написания функционального кода. Они упоминают распараллеливание, ленивые вычисления и детерменизм. Это преимущества функциональных программ.</p>
<p>
Забейте. Функциональный код отличается одним свойством: отсутствием побочных эффектов. Он не полагается на данные вне текущей функции, и не меняет данные, находящиеся вне функции. Все остальные «свойства» можно вывести из этого. 
</p><p>
Нефункциональная функция:

</p><pre><code class="python">a = 0
def increment1():
    global a
    a += 1
</code></pre>
<p>
Функциональная функция:

</p><pre><code class="python">def increment2(a):
    return a + 1
</code></pre>
<p>
Вместо проходов по списку используйте map и reduce
</p><a name="habracut"/>
<h4>Map</h4><p>
Принимает функцию и набор данных. Создаёт новую коллекцию, выполняет функцию на каждой позиции данных и добавляет возвращаемое значение в новую коллекцию. Возвращает новую коллекцию.
</p><p>
Простой map, принимающий список имён и возвращающий список длин:

</p><pre><code class="python">name_lengths = map(len, ['Маша', 'Петя', 'Вася'])

print name_lengths
# =&gt; [4, 4, 3]
</code></pre>
<p>
Этот map возводит в квадрат каждый элемент:
 
</p><pre><code class="python">squares = map(lambda x: x * x, [0, 1, 2, 3, 4])

print squares
# =&gt; [0, 1, 4, 9, 16]
</code></pre>
<p>
Он не принимает именованную функцию, а берёт анонимную, определённую через lambda. Параметры lambda определены слева от двоеточия. Тело функции – справа. Результат возвращается неявным образом.
</p><p>
Нефункциональный код в следующем примере принимает список имён и заменяет их случайными прозвищами.

</p><pre><code class="python">import random

names = ['Маша', 'Петя', 'Вася']
code_names = ['Шпунтик', 'Винтик', 'Фунтик']

for i in range(len(names)):
    names[i] = random.choice(code_names)

print names
# =&gt; ['Шпунтик', 'Винтик', 'Шпунтик']
</code></pre>
<p>
Алгоритм может присвоить одинаковые прозвища разным секретным агентам. Будем надеяться, что это не послужит источником проблем во время секретной миссии.
</p><p>
Перепишем это через map:

</p><pre><code class="python">import random

names = ['Маша', 'Петя', 'Вася']

secret_names = map(lambda x: random.choice(['Шпунтик', 'Винтик', 'Фунтик']), names)
</code></pre>

<b>Упражнение 1</b><p>. Попробуйте переписать следующий код через map. Он принимает список реальных имён и заменяет их прозвищами, используя более надёжный метод.

</p><pre><code class="python">names = ['Маша', 'Петя', 'Вася']

for i in range(len(names)):
    names[i] = hash(names[i])

print names
# =&gt; [6306819796133686941, 8135353348168144921, -1228887169324443034]
</code></pre>

<div class="spoiler"><b class="spoiler_title">Моё решение:</b><div class="spoiler_text"><pre><code class="python">names = ['Маша', 'Петя', 'Вася']

secret_names = map(hash, names)
</code></pre>
</div></div>

<h4>Reduce</h4><p>
Reduce принимает функцию и набор пунктов. Возвращает значение, получаемое комбинированием всех пунктов.
</p><p>
Пример простого reduce. Возвращает сумму всех пунктов в наборе:
 
</p><pre><code class="python">sum = reduce(lambda a, x: a + x, [0, 1, 2, 3, 4])

print sum
# =&gt; 10
</code></pre>
<p>
x – текущий пункт, а – аккумулятор. Это значение, которое возвращает выполнение lambda на предыдущем пункте. reduce() перебирает все значения, и запускает для каждого lambda на текущих значениях а и х, и возвращает результат в а для следующей итерации.
</p><p>
А чему равно а в первой итерации? Оно равно первому элементу коллекции, и reduce() начинает работать со второго элемента. То есть, первый х будет равен второму предмету набора.
</p><p>
Следующий пример считает, как часто слово «капитан» встречается в списке строк:

</p><pre><code class="python">sentences = ['капитан джек воробей',
             'капитан дальнего плавания',
             'ваша лодка готова, капитан']

cap_count = 0
for sentence in sentences:
    cap_count += sentence.count('капитан')

print cap_count
# =&gt; 3
</code></pre>
<p>
Тот же код с использованием reduce:

</p><pre><code class="python">sentences = ['капитан джек воробей',
             'капитан дальнего плавания',
             'ваша лодка готова, капитан']

cap_count = reduce(lambda a, x: a + x.count('капитан'),
                   sentences,
                   0)
</code></pre>
<p>
А откуда здесь берётся начальное значение а? Оно не может быть вычислено из количества повторений в первой строке. Поэтому оно задаётся как третий аргумент функции reduce().

</p><h4>Почему map и reduce лучше?</h4><p>
Во-первых, они обычно укладываются в одну строку.
</p><p>
Во-вторых, важные части итерации,– коллекция, операция и возвращаемое значение,– всегда находятся в одном месте map и reduce.
</p><p>
В-третьих, код в цикле может изменить значение ранее определённых переменных, или влиять на код, находящийся после него. По соглашению, map и reduce – функциональны.
</p><p>
В-четвёртых, map и reduce – элементарные операции. Вместо построчного чтения циклов читателю проще воспринимать map и reduce, встроенные в сложные алгоритмы.
</p><p>
В-пятых, у них есть много друзей, позволяющих полезное, слегка изменённое поведение этих функций. Например, filter, all, any и find.

</p><b>Упражнение 2</b><p>: перепишите следующий код, используя map, reduce и filter. Filter принимает функцию и коллекцию. Возвращает коллекцию тех вещей, для которых функция возвращает True.

</p><pre><code class="python">people = [{'имя': 'Маша', 'рост': 160},
    {' рост ': 'Саша', ' рост ': 80},
    {'name': 'Паша'}]

height_total = 0
height_count = 0
for person in people:
    if 'рост' in person:
        height_total += person[' рост ']
        height_count += 1

if height_count &gt; 0:
    average_height = height_total / height_count

    print average_height
    # =&gt; 120
</code></pre>

<div class="spoiler"><b class="spoiler_title">Моё решение:</b><div class="spoiler_text"><pre><code class="python">people = [{'имя': 'Маша', 'рост': 160},
    {' рост ': 'Саша', ' рост ': 80},
    {'name': 'Паша'}]

heights = map(lambda x: x['рост'],
              filter(lambda x: 'рост' in x, people))

if len(heights) &gt; 0:
    from operator import add
    average_height = reduce(add, heights) / len(heights)
</code></pre>
</div></div>

<h4>Пишите декларативно, а не императивно</h4><p>
Следующая программа эмулирует гонку трёх автомобилей. В каждый момент времени машина либо двигается вперёд, либо нет. Каждый раз программа выводит пройденный автомобилями путь. Через пять промежутков времени гонка заканчивается.
</p><p>
Примеры вывода:

</p><pre><code class="bash"> -
 - -
 - -

 - -
 - -
 - - -

 - - -
 - -
 - - -

 - - - -
 - - -
 - - - -

 - - - -
 - - - -
 - - - - -
</code></pre>
<p>
Текст программы:

</p><pre><code class="python">from random import random

time = 5
car_positions = [1, 1, 1]

while time:
    # decrease time
    time -= 1

    print ''
    for i in range(len(car_positions)):
        # move car
        if random() &gt; 0.3:
            car_positions[i] += 1

        # draw car
        print '-' * car_positions[i]
</code></pre>
<p>
Код императивен. Функциональная версия была бы декларативной – она бы описывала, что нужно сделать, а не то, как это надо сделать.

</p><h4>Используем функции</h4><p>
Декларативности можно достичь, вставляя код в функции:

</p><pre><code class="python">from random import random

def move_cars():
    for i, _ in enumerate(car_positions):
        if random() &gt; 0.3:
            car_positions[i] += 1

def draw_car(car_position):
    print '-' * car_position

def run_step_of_race():
    global time
    time -= 1
    move_cars()

def draw():
    print ''
    for car_position in car_positions:
        draw_car(car_position)

time = 5
car_positions = [1, 1, 1]

while time:
    run_step_of_race()
    draw()
</code></pre>
<p>
Для понимания программы читатель просматривает основной цикл. «Если осталось время, пройдём один шаг гонки и выведем результат. Снова проверим время». Если читателю надо будет разобраться, как работает шаг гонки, он сможет прочесть его код отдельно.
</p><p>
Комментарии не нужны, код объясняет сам себя.
</p><p>
Разбиение кода на функции делает код более читаемым. Этот приём использует функции, но лишь как подпрограммы. Они упаковывают код, но не делают его функциональным. Функции влияют на окружающий их код и меняют глобальные переменные, а не возвращают значения. Если читатель встречает переменную, ему потребуется найти, откуда она взялась.
</p><p>
Вот функциональная версия этой программы:

</p><pre><code class="python">from random import random

def move_cars(car_positions):
    return map(lambda x: x + 1 if random() &gt; 0.3 else x,
               car_positions)

def output_car(car_position):
    return '-' * car_position

def run_step_of_race(state):
    return {'time': state['time'] - 1,
            'car_positions': move_cars(state['car_positions'])}

def draw(state):
    print ''
    print '\n'.join(map(output_car, state['car_positions']))

def race(state):
    draw(state)
    if state['time']:
        race(run_step_of_race(state))

race({'time': 5,
      'car_positions': [1, 1, 1]})
</code></pre>
<p>
Теперь код разбит на функциональные функции. Тому есть три признака. Первый – нет расшаренных переменных. time и car_positions передаются прямиком в race(). Второе – функции принимают параметры. Третье – переменные не меняются внутри функций, все значения возвращаются. Каждый раз, когда run_step_of_race() проделывает следующий шаг, он передаётся опять в следующий.
</p><p>
Вот вам две функции zero() и one():

</p><pre><code class="python">def zero(s):
    if s[0] == "0":
        return s[1:]

def one(s):
    if s[0] == "1":
        return s[1:]
</code></pre>
<p>
zero() принимает строку s. Если первый символ – 0, то возвращает остаток строки. Если нет – тогда None. one() делает то же самое, если первый символ – 1.
</p><p>
Представим функцию rule_sequence(). Она принимает строку и список из функций-правил, состоящий из функций zero и one. Она вызывает первое правило, передавая ему строку. Если не возвращено None, то берёт возвращённое значение и вызывает следующее правило. И так далее. Если возвращается None, rule_sequence() останавливается и возвращает None. Иначе – значение последнего правила.
</p><p>
Примеры входных и выходных данных:

</p><pre><code class="python">print rule_sequence('0101', [zero, one, zero])
# =&gt; 1

print rule_sequence('0101', [zero, zero])
# =&gt; None
</code></pre>
<p>
Императивная версия rule_sequence():

</p><pre><code class="python">def rule_sequence(s, rules):
    for rule in rules:
        s = rule(s)
        if s == None:
            break

    return s
</code></pre>

<b>Упражнение 3</b><p>. Этот код использует цикл. Перепишите его в декларативном виде с использованием рекурсии.

</p><div class="spoiler"><b class="spoiler_title">Моё решение:</b><div class="spoiler_text"><pre><code class="python">def rule_sequence(s, rules):
    if s == None or not rules:
        return s
    else:
        return rule_sequence(rules[0](s), rules[1:])
</code></pre>
</div></div>

<h4>Используйте конвейеры (pipelines)</h4><p>
Теперь перепишем другой вид циклов при помощи приёма под названием конвейер.
</p><p>
Следующий цикл изменяет словари, содержащие имя, неправильную страну происхождения и статус некоторых групп.

</p><pre><code class="python">bands = [{'name': 'sunset rubdown', 'country': 'UK', 'active': False},
         {'name': 'women', 'country': 'Germany', 'active': False},
         {'name': 'a silver mt. zion', 'country': 'Spain', 'active': True}]

def format_bands(bands):
    for band in bands:
        band['country'] = 'Canada'
        band['name'] = band['name'].replace('.', '')
        band['name'] = band['name'].title()

format_bands(bands)

print bands
# =&gt; [{'name': 'Sunset Rubdown', 'active': False, 'country': 'Canada'},
#     {'name': 'Women', 'active': False, 'country': 'Canada' },
#     {'name': 'A Silver Mt Zion', 'active': True, 'country': 'Canada'}]
</code></pre>
<p>
Название функции «format» слишком общее. И вообще, код вызывает некоторое беспокойство. В одном цикле происходят три разные вещи. Значение ключа 'country' меняется на 'Canada'. Убираются точки и первая буква имени меняется на заглавную. Сложно понять, что код должен делать, и сложно сказать, делает ли он это. Его тяжело использовать, тестировать и распараллеливать.
</p><p>
Сравните:

</p><pre><code class="python">print pipeline_each(bands, [set_canada_as_country,
                            strip_punctuation_from_name,
                            capitalize_names])
</code></pre>
<p>
Всё просто. Вспомогательные функции выглядят функциональными, потому что они связаны в цепочку. Выход предыдущей – вход следующей. Их просто проверить, использовать повторно, проверять и распараллеливать.
</p><p>
pipeline_each() перебирает группы по одной, и передаёт их функциям преобразования, вроде set_canada_as_country(). После применения функции ко всем группам, pipeline_each() делает из них список и передаёт следующей.
</p><p>
Посмотрим на функции преобразования.

</p><pre><code class="python">def assoc(_d, key, value):
    from copy import deepcopy
    d = deepcopy(_d)
    d[key] = value
    return d

def set_canada_as_country(band):
    return assoc(band, 'country', "Canada")

def strip_punctuation_from_name(band):
    return assoc(band, 'name', band['name'].replace('.', ''))

def capitalize_names(band):
    return assoc(band, 'name', band['name'].title())
</code></pre>
<p>
Каждая связывает ключ группы с новым значением. Без изменения оригинальных данных это тяжело сделать, поэтому мы решаем это с помощью assoc(). Она использует deepcopy() для создания копии переданного словаря. Каждая функция преобразовывает копию и возвращает эту копию.
</p><p>
Всё вроде как нормально. Оригиналы данных защищены от изменений. Но в коде есть два потенциальных места для изменений данных. В strip_punctuation_from_name() создаётся имя без точек через вызов calling replace() с оригинальным именем. В capitalize_names() создаётся имя с первой прописной буквой на основе title() и оригинального имени. Если replace и time не функциональны, то и strip_punctuation_from_name() с capitalize_names() не функциональны.
</p><p>
К счастью, они функциональны. В Python строки неизменяемы. Эти функции работают с копиями строк. Уфф, слава богу.
</p><p>
Такой контраст между строками и словарями (их изменяемостью) в Python демонстрирует преимущества языков типа Clojure. Там программисту не надо думать, не изменит ли он данные. Не изменит.

</p><b>Упражнение 4</b><p>. Попробуйте сделать функцию pipeline_each. Задумайтесь над последовательностью операций. Группы – в массиве, передаются по одной для первой функции преобразования. Затем полученный массив передаётся по одной штучке для второй функции, и так далее.

</p><div class="spoiler"><b class="spoiler_title">Моё решение:</b><div class="spoiler_text"><pre><code class="python">def pipeline_each(data, fns):
    return reduce(lambda a, x: map(x, a),
                  fns,
                  data)
</code></pre>
</div></div>
<p>
Все три функции преобразования в результате меняют конкретное поле у группы. call() можно использовать, чтобы создать абстракцию для этого. Она принимает функцию и ключ, к которому она будет применена.

</p><pre><code class="python">set_canada_as_country = call(lambda x: 'Canada', 'country')
strip_punctuation_from_name = call(lambda x: x.replace('.', ''), 'name')
capitalize_names = call(str.title, 'name')

print pipeline_each(bands, [set_canada_as_country,
                            strip_punctuation_from_name,
                            capitalize_names])
</code></pre>
<p>
Или, жертвуя читаемостью:
 
</p><pre><code class="python">print pipeline_each(bands, [call(lambda x: 'Canada', 'country'),
                            call(lambda x: x.replace('.', ''), 'name'),
                            call(str.title, 'name')])
</code></pre>
<p>
Код для call():

</p><pre><code class="python">def assoc(_d, key, value):
    from copy import deepcopy
    d = deepcopy(_d)
    d[key] = value
    return d

def call(fn, key):
    def apply_fn(record):
        return assoc(record, key, fn(record.get(key)))
    return apply_fn
</code></pre>
<p>
Что тут у нас происходит.
</p><p>
Один. call – функция высшего порядка, т.к. принимает другую функцию как аргумент и возвращает функцию.
</p><p>
Два. apply_fn() похожа на функции преобразования. Получает запись (группу). Ищет значение record[key]. Вызывает fn. Присваивает результат в копию записи и возвращает её.
</p><p>
Три. call сам ничего не делает. Всю работу делает apply_fn(). В примере использования pipeline_each(), один экземпляр apply_fn() задаёт 'country' значение 'Canada'. Другой – делает первую букву прописной.
</p><p>
Четыре. При выполнении экземпляра apply_fn() функции fn и key не будут доступны в области видимости. Это не аргументы apply_fn() и не локальные переменные. Но доступ к ним будет. При определении функции она сохраняет ссылки на переменные, которые она замыкает – те, что были определены снаружи функции, и используются внутри. При запуске функции переменные ищутся среди локальных, затем среди аргументов, а затем среди ссылок на замкнутые. Там и найдутся fn и key.
</p><p>
Пять. В call нет упоминания групп. Это оттого, что call можно использовать для создания любых конвейеров, независимо от их содержимого. Функциональное программирование, в частности, строит библиотеку общих функций, пригодных для композиций и для повторного использования.
</p><p>
Молодцом. Замыкания, функции высшего порядка и область видимости – всё в нескольких параграфах. Можно и чайку с печеньками выпить.
</p><p>
Остаётся ещё одна обработка данных групп. Убрать всё, кроме имени и страны. Функция extract_name_and_country():

</p><pre><code class="python">def extract_name_and_country(band):
    plucked_band = {}
    plucked_band['name'] = band['name']
    plucked_band['country'] = band['country']
    return plucked_band

print pipeline_each(bands, [call(lambda x: 'Canada', 'country'),
                            call(lambda x: x.replace('.', ''), 'name'),
                            call(str.title, 'name'),
                            extract_name_and_country])

# =&gt; [{'name': 'Sunset Rubdown', 'country': 'Canada'},
#     {'name': 'Women', 'country': 'Canada'},
#     {'name': 'A Silver Mt Zion', 'country': 'Canada'}]
</code></pre>
<p>
extract_name_and_country() можно было бы написать в обобщённом виде под названием pluck(). Использовалась бы она так:

</p><pre><code class="python">print pipeline_each(bands, [call(lambda x: 'Canada', 'country'),
                            call(lambda x: x.replace('.', ''), 'name'),
                            call(str.title, 'name'),
                            pluck(['name', 'country'])])
</code></pre>

<b>Упражнение 5</b><p>. pluck принимает список ключей, которые надо извлечь из записей. Попробуйте её написать. Это буде функция высшего порядка.

</p><div class="spoiler"><b class="spoiler_title">Моё решение:</b><div class="spoiler_text"><pre><code class="python">def pluck(keys):
    def pluck_fn(record):
        return reduce(lambda a, x: assoc(a, x, record[x]),
                      keys,
                      {})
    return pluck_fn
</code></pre>
</div></div>
<p>
И что теперь?
</p><p>
Функциональный код хорошо сочетается с традиционным. Преобразования из этой статьи можно использовать в любом языке. Попробуйте и вы для своего кода. 
</p><p>
Вспомните про Машу, Петю и Васю. Превратите итерации по спискам в map и reduces.
</p><p>
Вспомните гонки. Разбейте код на функции, и сделайте их функциональными. Превратите цикл в рекурсию.
</p><p>
Вспомните про группы. Превратите последовательность операций в конвейер.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>