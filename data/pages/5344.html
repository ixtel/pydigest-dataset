<html><body><div><div class="content html_format">
      <a href="http://habrahabr.ru/company/itinvest/blog/263097/"><img src="https://habrastorage.org/files/293/6ac/abf/2936acabf56146e485b01c8b3327a688.jpg"/></a>
<p>
Ранее в нашем блоге на Хабре мы рассматривали различные</p><a href="http://habrahabr.ru/company/itinvest/blog/224353/"> этапы разработки</a><p> торговых систем (есть и </p><a href="http://www.itinvest.ru/education/schedule/">онлайн-курсы</a><p> по теме), среди которых одним из наиболее важных является </p><a href="http://habrahabr.ru/company/itinvest/blog/238839/">тестирование на исторических данных</a><p> (бэктестинг). Сегодня речь пойдет о практической релизации событийно-ориентированного бэктест-модуля с помощью Python.</p><a name="habracut"/>

<h4>Событийно-ориентированный софт</h4><p>
Прежде, чем погрузиться в разработку бэктестера, следует разобраться с понятием событийно-ориентированных систем. Одним из наиболее очевидных примеров подобных программ являются компьютерные игры. В видеоигре есть множество компонентов, которые взаимодействуют друг с другом в режиме реального времени с высоким фреймрейтом. Справляться с нагрузкой помогает осуществление всех вычислений внутри «бесконечной» петли, которую еще называют </p><a href="https://en.wikipedia.org/wiki/Event_loop">петлей событий</a><p> или </p><a href="https://en.wikipedia.org/wiki/Game_programming#Game_structure">игровой петлей</a><p>.
</p><p>
На каждом тике петли вызывается функция для получения последнего события, которое было сгенерировано каким-либо действием в игре. В зависимости от природы этого события (нажатие клавиши, клик мыши) предпринимается последующее действие, которое либо прерывает петлю, либо создает дополнительные события, и процесс продолжается. Проиллюстрировать все это можно таким псевдокодом:

</p><pre><code class="python">while True:  # Петля продолжается бесконечно
    new_event = get_new_event()   # Получаем последнее событие

    # В зависимости от типа события выполняем действие
    if new_event.type == "LEFT_MOUSE_CLICK":
        open_menu()
    elif new_event.type == "ESCAPE_KEY_PRESS":
        quit_game()
    elif new_event.type == "UP_KEY_PRESS":
        move_player_north()
    # ... and many more events

    redraw_screen()   # Обновляем экран для отображения соответствующей анимации
    tick(50)   # Ждем 50 миллисекунд
</code></pre><p>
Код будет снова и снова проверять наличие новых событий и выполнять действия на их основе. В частности, благодаря этому создается иллюзия ответа в реальном времени. Как станет понятно далее, это — как раз то, что нам нужно для запуска симуляции высокочастотного трейдинга.

</p><h4>Почему именно событийно-ориентированный бэктестер</h4><p>
Событийно-ориентированные системы обладают рядом преимуществ перед векторизированным подходом:

</p><ul>
<li><b>Повторное использование кода</b>. Благодаря своей природе событийно-ориентированный модуль тестирования может быть использован как для работы с историческими данными, так и при реальной торговле на бирже при необходимости лишь минимальной «доводки» компонентов. В случае векторизированных бэктестеров нам необходимо иметь весь набор данных сразу для проведения статистического анализа.</li>
<li><b>Предугадывание искажений</b>. Событийно-ориентированные бэктестеры воспринимают рыночные данные, в качестве «событий», на которые нужно как-то реагировать. Таким образом, можно «скормить» модулю информацию, реакция на которую будет максимально соответствовать тому, что будет наблюдаться впоследствии в реальной торговле.</li>
<li><b>Реализм</b>. Событийно-ориентированные бэктестеры позволяют значительно кастомизировать процесс выполнения ордеров и оптимизировать транзакционные издержки. Важно уметь работать с базовыми типами ордеров (market, limit) и более сложными (market-on-open, MOO и market-on-close, MOC) — таким образом можно создаться «кастомный» обработчик исключений.</li>
</ul><p>
Однако не все так безоблачно, и у событийно-ориентированных систем есь свои недостатки. Во-первых, их значительно сложнее создавать и тестировать — больше «подвижных частей», а значит и больше багов. Поэтому для их создания рекомендуется применять </p><a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">разработку через тестирование</a><p>. Во-вторых, они работают медленнее векторизированных систем.

</p><h4>Обзор бэктестера</h4><p>
Чтобы применить событийно-ориентированный подход, прежде всего необходимо разобраться с частями нашей системы, которые будут отвечать за определенные участки работы:

</p><ul>
<li><b>Событие (<code>event</code></b>) — это фундаментальная единица класса событийно-ориентированной системы. Содержит тип (например, «MARKET», «SIGNAL», «ORDER» или «FILL»), который влияет на то, как событие будет обрабатываться в петле.</li>
<li><b>Очередь событий (<code>event queue</code>)</b> — in-memory-объект Python, который хранит все объекты подклассов <code>Event</code>, сгенерированные остальными частями системы.</li>
<li><b><code>DataHandler</code></b> — это абстрактный базовый класс (АБК), который представляет собой интерфейс для обработки исторических и текущих рыночных данных. Это повышает гибкость системы, поскольку модули стратегии и управления портфолио могут быть использованы как для тестирования на исторических данных так и для работы на «живом» рынке. DataHandler генерирует событие <code>MarketEvent</code> при каждом «ударе сердца» (heartbeat) системы.</li>
<li><b>Модуль стратегии (<code>Strategy</code>)</b> — еще один АБК, который представляет собой интерфейс для забора рыночных данных и генерации на их основе сигнальных событий (<code>SignalEvent</code>), которые используются объектом <code>Portfolio</code>. <code>SignalEvent</code> содержит символ биржевого тикера, направление ордера (Long, Short) и временную метку.</li>
<li><b><code>Portfolio</code></b> — также АБК, отвечающий за обработку приказов, связанных с текущей и последующими позициями, подразумевающимися стратегией (<code>Strategy</code>). Сюда же входит риск-менеджмент портфолио, включая контроль размеров позиций и анализ секторов рынка. В более сложных реализациях эта часть работы может быть передана классу <code>RiskManagement</code>. <code>Portfolio</code> берет <code>SignalEvent</code> из очереди и генерирует события ордеров (<code>OrderEvent</code>), которые также попадают в очередь.</li>
<li><b><code>ExecutionHandler</code></b> — в нашем случае симулирует соединение с брокерской системой. Задача обработчика заключается в том, чтобы брать события OrderEvent из очереди, выполнять их (в режиме симуляции или через реальное подключение к брокеру). Когда ордер выполнен, обработчик создает событие <code>FillEvent</code>, которое описывает транзакцию, включая комиссии брокера и биржи, а также проскальзывание (если оно учитывается в модели).</li>
<li><b>Петля (<code>Loop</code>)</b> — все описанные компоненты включены в петлю событий, которая обрабатывает все типы событий, направляя их к соответствующему модулю системы.</li>
</ul><p>
Выше мы описали базовую модель торгового дивжка, которую можно усложнять и расширять по многим направлениям, например, в области работы модуля </p><code>Portfolio</code><p>. Кроме того, можно вынести разные модели транзакционных издержек в отдельную иерархию классов. В нашем случае, однако, это только создаст лишние сложности, поэтому мы будем лишь постепенно привносить в систему больше реализма.
</p><p>
Ниже представлен кусок кода на Python, который демонстрирует практическую работу бэктестера. В коде возникают две петли. Внешняя петля используется для придания бэктестеру сердцебиения (heartbeat). В онлайн-трейдинге это означает частоту, с которой происходит запрос рыночных данных. Для стратегий тестирования на исторических данных — это не обязательный компонент, поскольку рыночные данные вливаются в систему по частям — см. строку </p><code>bars.update_bars()</code><p>.
</p><p>
Внутренняя петля нужна для обработки событий из объекта Queue. Конкретные события делегируются соответствующим компонентам в очередь последовательно добавляются новые события. Когда очередь пустеем петля сердцебиения делает новый виток:

</p><pre><code class="python"># Объявление компонентнов с соответствующими параметрами
bars = DataHandler(..)
strategy = Strategy(..)
port = Portfolio(..)
broker = ExecutionHandler(..)

while True:
    # Обновляем бары (код для бэктестинга, а не живой торговли)
    if bars.continue_backtest == True:
        bars.update_bars()
    else:
        break
    
    # Обрабатываем события
    while True:
        try:
            event = events.get(False)
        except Queue.Empty:
            break
        else:
            if event is not None:
                if event.type == 'MARKET':
                    strategy.calculate_signals(event)
                    port.update_timeindex(event)

                elif event.type == 'SIGNAL':
                    port.update_signal(event)

                elif event.type == 'ORDER':
                    broker.execute_order(event)

                elif event.type == 'FILL':
                    port.update_fill(event)

    # следующий удар сердца через 10 минут
    time.sleep(10*60)

</code></pre>
<h4>Классы событий</h4><p>
В описанной схеме есть четыре типа событий:

</p><ul>
<li><b><code>MarketEvent</code></b> — инициируется, когда внешняя петля начинает новый «удар сердца». Оно возникает, когда объект DataHandler получает новое обновление рыночных данных для любых отслеживаемых финансовых инструментов. Оно используется для того, чтобы запустить генерацию торговых сигналов объектом <code>Strategy</code>. Объект события содержит идентификатор того, что это рыночное событие, и никакой другой структуры.</li>
<li><b><code>SignalEvent</code></b> — объект <code>Strategy</code> использует рыночную информацию для создания нового сигнального события <code>SignalEvent</code>. Это событие содержит символ тикера, временную метку генерации и направление ордера (long или short). Такие сигнальные события используются объектом <code>Portfolio</code> в качестве своеобразных подсказок на тему того, как торговать.</li>
<li><b><code>OrderEvent</code></b> — когда объект <code>Portfolio</code> получает <code>SignalEvent</code>, он использует такие события для более широкого контекста портфолио (расчет рисков и размера позиции). Все это приводит к созданию <code>OrderEvent</code>, который затем посылается в <code>ExecutionHandler</code>.</li>
<li><b><code>FillEvent</code></b> — когда ExecutionHandler получает <code>OrderEvent</code>, он обязан его выполнить. После того, как произошла транзакция, создается событие <code>FillEvent</code>, которое описывает стоимость покупки или продажи и траназкционные издержки (проскальзывания, комиссии и т.п.)</li>
</ul><p>
Родительский класс называется </p><code>Event</code><p> — это базовый класс, который не предоставляет никакой функциональности или специального интерфейса. В дальнейших реализациях класс </p><code>Event</code><p> с большой долей вероятности станет сложнее, поэтому стоит предусмотреть такую возможность заранее, создав иерархию классов:

</p><pre><code class="python"># event.py

class Event(object):
    """
    Event — это базовый класс, обеспечивающий интерфейс для последующих (наследованных) событий, которые активируют последующие    события в торговой инфраструктуре. 
    """
    pass
</code></pre>
<code>MarketEvent</code><p> наследует от </p><code>Event</code><p> и несет в себе чуточку больше, чем простая самоидентификация типа ‘MARKET’:

</p><pre><code class="python"># event.py

class MarketEvent(Event):
    """
    Обрабатывает событие получние нового обновления рыночной информации с соответствущими барами.
    """

    def __init__(self):
        """
        Инициализирует MarketEvent.
        """
        self.type = 'MARKET'
</code></pre>
<code>SignalEvent</code><p> требует наличия символа тикера, временной метки и направления ордера, которые объект портфолио может использовать в качестве «совета» при торговле:

</p><pre><code class="python"># event.py

class SignalEvent(Event):
    """
    Обрабатывает событие отправки Signal из объекта Strategy. Его получает объект Portfolio, который предпринимает нужное действие.
    """
    
    def __init__(self, symbol, datetime, signal_type):
        """
        Инициализирует SignalEvent.

        Параметры:
        symbol - Символ тикера, например для Google — 'GOOG'.
        datetime - временная метка момента генерации сигнала.
        signal_type - 'LONG' или 'SHORT'.
        """
        
        self.type = 'SIGNAL'
        self.symbol = symbol
        self.datetime = datetime
        self.signal_type = signal_type
</code></pre>
<code>OrderEvent</code><p> сложнее, чем </p><code>SignalEvent</code><p>, и содержит дополнительное поле для указания количества единиц финансового инструмента в ордере. Количество определяется ограничениями объекта </p><code>Portfolio</code><p>. Вдобавок </p><code>OrderEvent</code><p> содержит метод </p><code>print_order()</code><p>, который используется для вывода информация в консоль при необходимости:

</p><pre><code class="python"># event.py

class OrderEvent(Event):
    """
    Обрабатывает событие отправки приказа Order в торговый движок. Приказ содержит тикер (например, GOOG), тип (market или limit), количество и направление.
    """

    def __init__(self, symbol, order_type, quantity, direction):
        """
        Инициализирует тип приказа (маркет MKT или лимит LMT), также устанавливается число единиц финансового инструмента и направление ордера (BUY или SELL).

        Параметры:
        symbol - Инструмент, сделку с которым нужно осуществить.
        order_type - 'MKT' или 'LMT' для приказов Market или Limit.
        quantity - Не-негативное целое (integer) для определения количества единиц инструмента. 
        direction - 'BUY' или 'SELL' для длинной или короткой позиции.
        """
        
        self.type = 'ORDER'
        self.symbol = symbol
        self.order_type = order_type
        self.quantity = quantity
        self.direction = direction

    def print_order(self):
        """
        Выводит значения, содержащиеся в приказе Order.
        """
        print "Order: Symbol=%s, Type=%s, Quantity=%s, Direction=%s" % \
            (self.symbol, self.order_type, self.quantity, self.direction)
</code></pre>
<code>FillEvent</code><p> — это </p><code>Event</code><p> повышенной сложности. Оно содержит временную метку исполнения приказа, тикер и информациб о бирже, на которой он был исполнен, количество единиц финансового инструмента (акций, фьючерсов и т.п.), фактическую цену сделки и сопутствующие комиссии.
</p><p>
Сопутствующие издержки вычисляются с помощью API брокерской системы (у </p><a href="http://www.itinvest.ru/promo/adv/">ITinvest</a><p> есть свой </p><a href="http://www.itinvest.ru/services/robots/">API-интерфейс</a><p>). В нашем примере используется система американского брокера, комиссия которого составляет минимум $1.30 с ордера с единой ставкой от $0,013 или $0,08 за акцию в зависимости от того, превышает ли количество акций 500 единиц или нет.

</p><pre><code class="python"># event.py

class FillEvent(Event):
    """
    Инкапсулирует понятие исполненного ордера (Filled Order), возвращаемое брокером. 
    Хранит количество единиц инструмента, которые были куплены/проданы по конкретной цене. 
    Также хранит комиссии сделки.
    """

    def __init__(self, timeindex, symbol, exchange, quantity, 
                 direction, fill_cost, commission=None):
        """
        Инициализирует объек FillEvent. 
        Устанавливает тикер, биржевую площадку, количество, направление, цены и (опционально) комиссии.

        Если информация о комиссиях отсутствиет, то объект Fill вычислит их на основе объема сделки
        и информации о тарифах брокерах (полученной через API)

        Параметры:
        timeindex - Разрешение баров в момент выполнения ордера.
        symbol - Инструмент, по которому прошла сделка.
        exchange - Биржа, на которой была осуществлена сделка.
        quantity - Количество единиц инструмента в сделке.
        direction - Направление исполнения ('BUY' или 'SELL')
        fill_cost - Размер обеспечения.
        commission - Опциональная комиссия, информация отправляемая бркоером.
        """
        
        self.type = 'FILL'
        self.timeindex = timeindex
        self.symbol = symbol
        self.exchange = exchange
        self.quantity = quantity
        self.direction = direction
        self.fill_cost = fill_cost

        # Calculate commission
        if commission is None:
            self.commission = self.calculate_ib_commission()
        else:
            self.commission = commission

    def calculate_ib_commission(self):
        """
        Вычисляет издержки торговли на основе данных API брокера (в нашем случае, американского, т.е. цены в долларах). 

       Не включает комиссии биржи.
        """
        full_cost = 1.3
        if self.quantity &lt;= 500:
            full_cost = max(1.3, 0.013 * self.quantity)
        else: # Greater than 500
            full_cost = max(1.3, 0.008 * self.quantity)
        full_cost = min(full_cost, 0.5 / 100.0 * self.quantity * self.fill_cost)
        return full_cost
</code></pre><p>
На сегодня все, спасибо за внимание. В следующей части мы поговорим об использовании рыночной информации (класс </p><code>DataHandler</code><p>) для тестирования на исторических данных и при реальной торговле.

</p><h5>Все материалы цикла:</h5>

      <p class="clear"/>
    </div>

    
  </div></body></html>