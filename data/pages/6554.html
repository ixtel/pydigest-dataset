<html><body><div><body class="deck-container" id="readabilityBody">


<section class="slide" id="title-slide">
	<h1>Creating beautiful REST APIs with Flask</h1>
</section>

<section class="slide" id="intro-slide">
    <h2>Introduction</h2>
    <h3>Presentation located at: pycoder.net</h3>
    <h3>email: brendan.kohler@pycoder.net</h3>
    <h3>twitter: @xnomagichash</h3>
</section>



<section class="slide" id="technical-debt">
    <h2>Technical Debt: Enemy of Weekends</h2>
    <h3>A summary of Seldera's codebase before we achieved product/market fit:</h3>
    <ul>
        <li>Lots of Django</li>
        <li>Many incompatible branches</li>
        <li>Several years of technical debt</li>
    </ul>
    <h3>What can we do about it?</h3>
    <ol>
        <li class="slide" id="technical-debt-nuke-it"><h4>Nuke it from orbit!</h4></li>
        <li class="slide" id="technical-debt-maintain-it"><h4>Maintain the code base</h4></li>
        <li class="slide" id="technical-debt-deprecate-it"><h4>Gradually phase old systems out</h4></li>
    </ol>
</section>


<section class="slide" id="phasing-old-systems-out">
    <h2>Phasing old systems out</h2>
    <h3>As your systems scale, your architecture gets more exotic. Planning for change is not premature optimization.</h3>
    <ol>
        <li class="slide" id="phasing-api"><h4>Move to service oriented architecture with REST APIs</h4></li>
        <li class="slide" id="phasing-flask"><h4>Migrate from Django to Flask for new all new services</h4></li>
        <li class="slide" id="phasing-api"><h4>Move to a schemaless (NoSQL) database</h4></li>
        <li class="slide" id="phasing-api"><h4>Plan for many types of clients</h4></li>
    </ol>
    <h3 class="slide" id="nice-apis">...but building nice APIs is hard and we made a lot of mistakes at first.</h3>
</section>


<section class="slide" id="realmon-create-user-conceptual">
    <h2>Example Endpoint: Creating a User</h2>
    <h3>Simple, right? <span class="slide" id="cu0">Let's enumerate the steps...</span></h3>
    <ol>
        <li class="slide" id="cu1">Decode a JSON object containing an email address and password.</li>
        <li class="slide" id="cu2">Validate the email address and password.</li>
        <li class="slide" id="cu3">Hash the password with bcrypt.</li>
        <li class="slide" id="cu4">Insert the new user into the data store.</li>
        <li class="slide" id="cu5">Send a welcome email to the new user.</li>
        <li class="slide" id="cu6">Send an "New User" notification to the system administator.</li>
        <li class="slide" id="cu7">Create a new session for the user.</li>
        <li class="slide" id="cu8">Return a JSON response to the client indicating success or failure.</li>
        <li class="slide" id="cu9">Enforce a rate limit to prevent abuse and/or attacks.</li>
   </ol>
    <h3 class="slide" id="work-to-do">This could wind up being complicated after all.</h3>

</section>

<section class="slide" id="create-user-naive">
<h2><em>The</em> Flask Anti-Pattern:<br/>putting everything in the endpoint</h2>
<pre><code>@api.route('/user', methods=['POST'])
def create_user():
    data = request.get_json(force=True)
    email    = json.get('email','')
    password = json.get('password','')
    attrs = {}

    if not re.match("^[^@ ]+@[^@ ]+\.[^@ ]+$", email):
        raise ValidationError()
    attrs['email'] = email

    if len(password) &lt; 7:
        raise ValidationError()
    attrs['password'] = bcrypt.hashpw(password, bcrypt.gensalt())
    attrs['id'] = str(db.users.insert(attrs))
    del attrs['password']
    session['id'] = new_user['id']
    notify('admins', 'New User', repr(new_user))
    envelope = Envelope(
        to_addr   = new_user['email'],
        subject   = api.config['WELCOME_EMAIL_SUBJECT'],
        text_body = render_template('emails/new_user.txt'),
        html_body = render_template('emails/new_user.html'))
    def sender():
        envelopes.connstack.push_connection(conn)
        smtp = envelopes.connstack.get_current_connection()
        smtp.send(envelope)
        envelopes.connstack.pop_connection()
    gevent.spawn(sender)
    
    return jsonify({'status': 'OK'})</code></pre>
</section>

<section class="slide" id="api-donts">
    <h2>Flask API "DON'Ts"</h2>
    <ol>
        <li class="slide" id="api-donts-versioning"><h4>DON'T use your version control system to version your APIs</h4>
        <p>You'll just wind up with a bunch of incompatible code branches that you might not be able to merge.</p></li>
        <li class="slide" id="api-donts-testing"><h4>DON'T write endpoints you can't test</h4>
        <p>Flask makes it easy to test your endpoints using <em>signals</em>, so you have no excuse.</p></li>
        <li class="slide" id="api-donts-exts"><h4>DON'T use lots of extensions</h4>
        <p>For any application of sufficient complexity, you will outgrow your extensions.
           The one exception: when you write your own.</p></li>
    </ol>
</section>

<section class="slide" id="api-dos">
    <h2>Flask API "DOs"</h2>
    <ol>
        <li class="slide" id="api-dos-versioning"><h4>Implement API versions as blueprints</h4>
        <p>This way your compatibility-breaking changes are modularized and separated by url.</p></li>
        <li class="slide" id="api-dos-signals-mocks"><h4>Use signals and mocks for testing</h4>
        <p>Signals and mocks make unit testing easy if you modularize your API carefully</p></li>
        <li class="slide" id="api-dos-decorators"><h4>Use decorators as a code-reuse pattern</h4>
        <p>Flask is flexible, so use decorators to abstract out reusable patterns.</p></li>
        <li class="slide" id="api-dos-handlers"><h4>Use Flask's custom error handler capability</h4>
        <p>The one feature that nobody uses, but everyone should. You should almost never use abort
           in your API endpoints.</p></li>
    </ol>
</section>


<section class="slide" id="api-structure">
    <h2>A sample application structure</h2>
    <h3>Real Time Monitoring API:</h3>
<pre><code>realmon/
    server.py
    api/
        __init__.py
        v1/                  &lt;--- API major version
            __init__.py      &lt;--- Blueprint location
            decorators.py    &lt;--- Decorators
            errors.py        &lt;--- Custom Error Handlers
            endpoints.py     &lt;--- API endpoints
            models/
                __init__.py
                building.py
                user.py      &lt;--- All validators and code
                meter.py          related to the model layer
                env.py
            templates/
                ...
            tests/
                ...
</code></pre>
</section>

<section class="slide" id="create-user-correct">
<h2>What that endpoint <em>should</em> look like</h2>
<pre><code><span class="slide hi" id="cuc-1">@api.route('/users', methods=['POST'])</span>
<span class="slide hi" id="cuc-2">@limit(requests=10, window=60, by="ip")</span>
<span class="slide hi" id="cuc-3">@email</span>
def create_user():
    <span class="slide hi" id="cuc-4">data = request.get_json(force=True)</span>
    <span class="slide hi" id="cuc-5">new_user = user.create(json=data)</span>
    <span class="slide hi" id="cuc-6">session['uid'] = new_user['id']</span>
    <span class="slide hi" id="cuc-7">notify('admins', 'New User', repr(new_user))</span>
    return Envelope(
        to_addr   = <span class="slide hi" id="cuc-8">new_user['email']</span>,
        subject   = api.config['WELCOME_EMAIL_SUBJECT'],
        text_body = render_template('emails/new_user.txt'),
        html_body = render_template('emails/new_user.html'))
</code></pre>
<h6>*Envelope comes from the excellent email library <em>envelopes</em>.</h6>
</section>








<section class="slide" id="decorators">
<h2>API Decorators</h2>
<h3>The Goal: Find common API patterns and abstract them out into decorators</h3>
<ol>
    <li class="slide" id="decorator-1">
        <h3>Sending Emails</h3>
        <p>Often an endpoint's primary output is an email, rather than JSON, but it can be messy to send emails synchronously.</p>
    </li>
    <li class="slide" id="decorator-2">
        <h3>Rate Limiting Requests</h3>
        <p>It's always a good idea to carefully rate limit your API. It prevents accidental server overloading and malicious behavior.</p>
    </li>
    <li class="slide" id="decorator-3">
        <h3>Background Tasks</h3>
        <p>There are often tasks API needs to perform that take too long to do synchronously. In those cases it's often
        better to run the task asychronously and let initiator of the request retrieve the results when the task has finished.</p>
    </li>
</ol>
</section>

<section class="slide" id="decorator-refresher">
<h2>A short refresher on decorators</h2>
<div class="slide" id="refresher-simple">
<h3>A decorator without arguments</h3>
<pre><code>def decorator(f):
    @functools.wraps(f)
    def wrapped(*args, **kwargs):
        results = f(*args, **kwargs)
        # do something
        return results
    return wrapped
</code></pre>
</div>

<div class="slide" id="refresher-complex">
<h3>A Decorator with arguments</h3>
<pre><code>def decorator_args(a, b, c):
    def decorator(f):
        @functools.wraps(f)
        def wrapped(*args, **kwargs):
            results = f(*args, **kwargs)
            # do something
            return results
        return wrapped
    return decorator
</code></pre>
</div>

</section>




<section class="slide" id="email-decorator">
<h2>The email decorator</h2>
<pre><code>
def email(f):
    @functools.wraps(f)
    def wrapped(*args, **kwargs):
        <span class="slide hi" id="emld-1">envelope = f(*args, **kwargs)</span>
        <span class="slide hi" id="emld-2">envelope.from_addr = api.config['SYSTEM_EMAIL']</span>
<span class="slide hi" id="emld-3"><span class="no-hi">        </span>def task():
<span class="no-hi">            </span>smtp().send(envelope)
<span class="no-hi">        </span>gevent.spawn(task)</span>
        <span class="slide hi" id="emld-4">return jsonify({"status": "OK"})</span>
    return wrapped
</code></pre>
</section>

<section class="slide" id="email-decorator-in-use">
<h2>Using the <em>email</em> decorator</h2>
<pre><code>
@api.route('/users', methods=['POST'])
@limit(requests=100, interval=3600, by="ip")
<span class="hi">@email</span>
def create_user():
    data = request.get_json(force=True)
    new_user = user.create(json=data, retrieve=True)
    session['id'] = new_user['id']
    notify('admins', 'New User', repr(new_user))
    return <span class="hi">Envelope(
<span class="no-hi">           </span>to_addr   = new_user['email'],
<span class="no-hi">           </span>subject   = api.config['WELCOME_EMAIL_SUBJECT'],
<span class="no-hi">           </span>text_body = render_template('emails/new_user.txt'),
<span class="no-hi">           </span>html_body = render_template('emails/new_user.html'))</span>
</code></pre>
</section>
<section class="slide" id="rate-limit-decorator-primer">
<h2>The <em>limit</em> decorator</h2>
<h3>First let's start with some definitions:</h3>
<ul>
    <li class="slide" id="rldp-1">
        <h4>requests</h4>
        <p>The number of requests that are allowed within a certain time window</p>
    </li>
    <li class="slide" id="rldp-2">
        <h4>window</h4>
        <p>The length of the time window in seconds.</p>
    </li>
    <li class="slide" id="rldp-3">
        <h4>by</h4>
        <p>a function that extracts the key ID that the limit is enforced on.</p>
    </li>
    <li class="slide" id="rldp-4">
        <h4>group (optional)</h4>
        <p>Specifies a group of endpoints that share the same requests pool for rate limiting.</p>
    </li>
</ul></section>

<section class="slide" id="rate-limit-decorator">
<h2>Building the <em>limit</em> decorator</h2>
<pre><code>def limit(requests=100, window=60, by="ip", group=None):
    <span class="slide hi" id="rldi-1">if not callable(by):
<span class="no-hi">        </span>by = { 'ip': lambda: request.headers.remote_addr }[by]</span>

    def decorator(f):
        @functools.wraps(f)
        def wrapped(*args, **kwargs):
            <span class="slide hi" id="rldi-2">group = group or request.endpoint</span>
            <span class="slide hi" id="rldi-3">key = ":".join(["rl", group, by()])</span>

            try:
                <span class="slide hi" id="rldi-4">remaining = requests - int(redis.get(key))</span>
            except (ValueError, TypeError):
                <span class="slide hi" id="rldi-5">remaining = requests
<span class="no-hi">                </span>redis.set(key, 0)</span>

            <span class="slide hi">ttl = redis.ttl(key)</span>
            if not ttl:
                <span class="slide hi" id="rldi-6">redis.expire(key, window)
<span class="no-hi">                </span>ttl = window</span>

            <span class="slide hi" id="rldi-7">g.view_limits = (requests,remaining-1,time()+ttl)</span>

            if remaining &gt; 0:
                <span class="slide hi" id="rldi-8">redis.incr(key, 1)
<span class="no-hi">                </span>return f(*args, **kwargs)</span>
            else:
                <span class="slide hi" id="rldi-9">return Response("Too Many Requests", 429)</span>
        return wrapped
    return decorator</code></pre>
</section>



<section class="slide" id="background-decorator-intro">
<h2>The <em>background</em> decorator</h2>
<h3>An example:</h3>
<pre><code>@api.route('/reports/power/monthly/<year>/<month>')
@limit(requests=1, by='ip')
@background
def report_monthly_power(year, month):
    rdata = generate_power_report(year, month)
    return rdata</month></year></code></pre>
<span class="slide"><h3>The pattern:</h3>
<ol>
    <li>Run function that takes a long time</li>
    <li>Return important information to client asynchronously</li>
</ol></span>
</section>

<section class="slide" id="background-decorator">
<h2>The <em>background</em> decorator</h2>
<pre><code>def background(f):
    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        <span class="slide hi">jobid = uuid4().hex</span>
        <span class="slide hi">key = 'job-{0}'.format(jobid)</span>
        <span class="slide hi">skey = 'job-{0}-status'.format(jobid)</span>
        <span class="slide hi">expire_time = 3600</span>
        <span class="slide hi">redis.set(skey, 202)</span>
        redis.expire(skey, expire_time)

        <span class="slide hi">@copy_current_request_context</span>
        def task():
            try:
                <span class="slide hi">data = f(*args, **kwargs)</span>
            except:
                <span class="slide hi">redis.set(skey, 500)</span>
            else:
                <span class="slide hi">redis.set(skey, 200)</span>
                <span class="slide hi">redis.set(key, data)</span>
                <span class="slide hi">redis.expire(key, expire_time)</span>
            <span class="slide hi">redis.expire(skey, expire_time)</span>

        <span class="slide hi">gevent.spawn(task)</span>
        <span class="slide hi">return jsonify({"job": jobid})</span>
    return wrapper
</code></pre>
</section>


<section class="slide" id="decorator-summary">
    <h2>Decorators: A Summary</h2>
    <h3 class="slide">Find common API patterns and turn them into decorators</h3>
    <h3 class="slide">Keep the "plumbing" out of your endpoints.</h3>
    <h3 class="slide">Use libraries like Gevent to run tasks asynchronously</h3>
    <h3 class="slide">Use rate limiting everywhere</h3>
    <h3 class="slide">Let errors bubble up from your decorators (and endpoints)</h3>
    <h3 class="slide">request, session and g make powerful decorators possible</h3>
    <h3 class="slide">Don't ignore Flask's built-in decorators</h3>
</section>



<section class="slide" id="bonus-material">
    <h2>Bonus Material: Error Handlers</h2>
<h3>Here is an exception from <em>models/user.py</em>:</h3>
<pre><code>class ValidationError(Exception):
    def __init__(self, field, message):
        self.field = field
        self.message = message</code></pre>

<h3>Here is an error handler from <em>errors.py</em>:</h3>
<pre><code>@api.errorhandler(user.ValidationError)
def handle_user_validation_error(error):
    response = jsonify({
        'msg': error.message,
        'type': 'validation',
        'field': error.field })
    response.status_code = 400
    return response</code></pre>
<h3>Save yourself from doing error handling in your endpoints. Write JSON-friendly error handlers like this.</h3>
</section>













<a href="#" class="deck-prev-link" title="Previous">←</a>
<a href="#" class="deck-next-link" title="Next">→</a>


<p class="deck-status">
	<span class="deck-status-current"/>
	/
	<span class="deck-status-total"/>
</p>





<a href="." title="Permalink to this slide" class="deck-permalink">#</a>


















</body>
</div></body></html>