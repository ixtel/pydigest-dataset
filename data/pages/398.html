<html><body><div><div class="content_body" data-subscribe="true" data-view="content#body"><p>When people think computational geometry, in my experience, they typically think one of two things:</p>

<ol>
  <li>Wow, that sounds complicated.</li>
  <li>Oh yeah, <a href="http://en.wikipedia.org/wiki/Convex_hull">convex hull</a>.</li>
</ol>

<p>In this post, I’d like to shed some light on computational geometry, starting with a brief overview of the subject before moving into some practical advice based on my own experiences (<a href="#practical-advice-and-concerns">skip ahead</a> if you have a good handle on the subject).</p>

<h2 id="whats-all-the-fuss-about">What’s all the fuss about?</h2>

<p>While convex hull computational geometry algorithms are typically included in an <a href="http://www.cs.princeton.edu/courses/archive/fall13/cos226/demo/99DemoGrahamScan.pdf">introductory algorithms course</a>, computational geometry is a far richer subject that rarely gets sufficient attention from the average developer/computer scientist (unless you’re making games or something).</p>

<h3 id="theoretically-intriguing">Theoretically intriguing…</h3>

<p>From a theoretical standpoint, the questions in computational geometry are often exceedingly interesting; the answers, compelling; and the paths by which they’re reached, varied. These qualities alone make it a field worth studying, in my opinion.</p>

<p>For example, consider the <a href="http://en.wikipedia.org/wiki/Art_gallery_problem">Art Gallery Problem</a>: We own an art gallery and want to install security cameras to guard our artwork. But we’re under a tight budget, so we want to use as few cameras as possible. How many cameras do we need?</p>

<p>When we translate this to computational geometric notation, the ‘floor plan’ of the gallery is just a simple polygon. And with some elbow grease, we can prove that <em>n/3</em> cameras is always sufficient for a polygon on <em>n</em> vertices, no matter how messy it is. The <a href="http://en.wikipedia.org/wiki/Art_gallery_problem#Fisk.27s_short_proof">proof itself</a> uses dual graphs, some graph theory, triangulations, and more.</p>

<p>Here, we see a clever proof technique and a result that is curious enough to be appreciated on its own. But if theoretical relevance isn’t enough for you…</p>

<h3 id="and-important-in-practice">And important in-practice</h3>

<p>As I mentioned earlier, game development relies heavily on the application of computational geometry (for example, <a href="http://www.cs.sfu.ca/~haoz/pubs/liu_zhang_gi08.pdf">collision detection</a> often relies on computing the convex hull of a set of objects); as do <a href="http://en.wikipedia.org/wiki/Geographic_information_system">geographic information systems (GIS)</a>, which are used for storing and performing computations on geographical data; and robotics, too (e.g., for visibility and planning problems).</p>

<h2 id="whys-it-so-tough">Why’s it so tough?</h2>

<p>Let’s take a fairly straightforward computational geometry problem: given a point and a polygon, does the point lie inside of the polygon? (This is called the <a href="http://en.wikipedia.org/wiki/Point_in_polygon">point-in-polygon, or PIP problem</a>.)</p>

<p>PIP does a great job of demonstrating why computational geometry can be (deceptively) tough. To the human eye, this isn’t a hard question. We see the following diagram and it’s <em>immediately</em> obvious to us that the point is in the polygon:</p>

<p><img src="//assets.toptal.io/uploads/blog/image/255/toptal-blog-image-1389197373756.png" alt="This point-in-polygon problem is a good example of computational geometry in one of its many applications."/></p>

<p>Even for relatively complicated polygons, the answer doesn’t elude us for more than a second or two. But when we feed this problem to a computer, it might see the following:</p>

<pre lang="python"><code>poly = Polygon([Point(0, 5), Point(1, 1), Point(3, 0),
               Point(7, 2), Point(7, 6), Point(2, 7)])
point = Point(5.5, 2.5)
poly.contains(point)
</code></pre>

<p>What is intuitive to the human brain does not translate so easily to computer language.</p>

<p>More abstractly (and ignoring the need to represent these things in code), the problems we see in this discipline are very hard to rigorize (‘make rigorous’) in a computational geometry algorithm. How would we describe the point-in-polygon scenario without using such tautological language as ‘A point is inside a polygon if it is inside the polygon’? Many of these properties are so fundamental and so basic that it is difficult to define them concretely.</p>

<p class="pop_out_box is-full_width is-big">
How would we describe the point-in-polygon scenario without using such tautological language as 'it's inside the polygon if it's inside the polygon'?
</p>

<p>Difficult, but not impossible. For example, you could rigorize point-in-polygon with the following definitions:</p>

<ul>
  <li>A point is inside a polygon if <em>any infinite ray beginning at the point intersects with an odd number of polygon edges</em> (known as the <a href="http://en.wikipedia.org/wiki/Even-odd_rule">even-odd rule</a>).</li>
  <li>A point is inside a polygon if <em>it has a non-zero <a href="http://en.wikipedia.org/wiki/Winding_number">winding number</a></em> (defined as the number of times that the curve defining the polygon travels around the point).</li>
</ul>

<p>Unless you’ve had some experience with computational geometry, these definitions probably won’t be a part of your existing vocabulary. And perhaps that’s emblematic of how computational geometry can push you to <em>think differently</em>.</p>

<h2 id="introducing-ccw">Introducing CCW</h2>

<p>Now that we have a sense for the importance and difficulty of computational geometry problems, it’s time to get our hands wet.</p>

<p>At the backbone of the subject is a deceptively powerful primitive operation: counterclockwise, or ‘CCW’ for short. (I’ll warn you now: CCW will pop up again and again.)</p>

<p>CCW takes three points A, B, and C as arguments and asks: do these three points compose a counterclockwise turn (vs. a clockwise turn)? In other words, is A -&gt; B -&gt; C a counterclockwise angle?</p>

<p>For example, the <strong>green</strong> points are CCW, while the <strong>red</strong> points are not:</p>

<p><img src="//assets.toptal.io/uploads/blog/image/256/toptal-blog-image-1389197545990.png" alt="This computational geometry problem requires points both clockwise and counterclockwise."/></p>

<h3 id="why-ccw-matters">Why CCW Matters</h3>

<p>CCW gives us a <em>primitive</em> operation on which we can build. It gives us a place to start rigorizing and solving computational geometry problems.</p>

<p>To give you a sense for its power, let’s consider two examples.</p>

<h4 id="determining-convexity">Determining Convexity</h4>

<p>The first: <em>given a polygon, can you determine if it’s convex?</em> <a href="http://en.wikipedia.org/wiki/Convex_polygon">Convexity</a> is an invaluable property: knowing that your polygons are convex often lets you improve performance by orders of magnitude. As a concrete example: there’s a <a href="http://www.cs.tufts.edu/comp/163/notes05/point_inclusion_handout.pdf">fairly straightforward PIP algorithm</a> that runs in Log(n) time for convex polygons, but fails for many concave polygons.</p>

<p>Intuitively, this gap makes sense: convex shapes are ‘nice’, while concave shapes can have sharp edges jutting in and out—they just don’t follow the same rules.</p>

<p>A simple (but non-obvious) computational geometry algorithm for determining convexity is to <a href="http://debian.fmi.uni-sofia.bg/~sergei/cgsr/docs/clockwise.htm">check that every triplet of consecutive vertices is CCW</a>. This takes just a few lines of Python geometry code (assuming that the <code>points</code> are provided in counterclockwise order—if <code>points</code> is in clockwise order, you’ll want all triplets to be clockwise):</p>

<pre><code>class Polygon(object):
    ...
    def isConvex(self):
        for i in range(self.n):
            # Check every triplet of points
            A = self.points[i % self.n]
            B = self.points[(i + 1) % self.n]
            C = self.points[(i + 2) % self.n]
            if not ccw(A, B, C):
                return False
        return True
</code></pre>

<p>Try this on paper with a few examples. You can even use this result to <em>define</em> convexity. (To make things more intuitive, note that a CCW curve from A -&gt; B -&gt; C corresponds to an angle of less than 180º, which is a widely taught <a href="http://www.mathopenref.com/polygonconvex.html">way to define convexity</a>.)</p>

<h4 id="line-intersection">Line Intersection</h4>

<p>As a second example, consider line segment intersection, which can also be <a href="http://bryceboe.com/2006/10/23/line-segment-intersection-algorithm/">solved using CCW alone</a>:</p>

<pre><code>def intersect(a1, b1, a2, b2):
    """Returns True if line segments a1b1 and a2b2 intersect."""
    return ccw(a1, b1, a2) != ccw(a1, b1, b2) and ccw(a2, b2, a1) != ccw(a2, b2, b1)
</code></pre>

<p>Why is this the case? Line segment intersection can also be phrased as: given a segment with endpoints A and B, do the endpoints C and D of another segment lie on the same side of AB? In other words, if the turns from A -&gt; B -&gt; C and A -&gt; B -&gt; D are in the same direction, the segments can’t intersect. When we use this type of language, it becomes clear that such a problem is CCW’s bread and butter.</p>

<h3 id="a-rigorous-definition">A Rigorous Definition</h3>

<p>Now that we have a taste for the importance of CCW, let’s see how it’s computed. Given points A, B, and C:</p>

<pre><code>def ccw(A, B, C):
    """Tests whether the turn formed by A, B, and C is ccw"""
    return (B.x - A.x) * (C.y - A.y) &gt; (B.y - A.y) * (C.x - A.x)
</code></pre>

<p>To understand where this definition comes from, consider the vectors AB and BC. If we take their cross product, AB x BC, this will be a vector along the z-axis. But in which direction (i.e, +z or -z)? As it turns out, if the cross product is positive, the turn is counterclockwise; otherwise, it’s clockwise.</p>

<p>This definition will seem unintuitive unless you have a really good understanding of linear algebra, the right-hand rule, etc. But that’s why we have abstraction—when you think CCW, just think of its intuitive definition rather than its computation. The value will be immediately clear.</p>

<h2 id="my-dive-into-computational-geometry-and-programming-using-python">My Dive Into Computational Geometry and Programming Using Python</h2>

<p>Over the past month, I’ve been working on implementing several computational geometry algorithms in Python. As I’ll be drawing on them throughout the next few sections, I’ll take a second to describe my computational geometry applications, which can be found on <a href="https://github.com/crm416/point-location">GitHub</a>.</p>

<p><em>Note: My experience is admittedly limited. As I’ve been working on this stuff for months rather than years, take my advice with a grain of salt. That said, I learned much in those few months, so I hope these tips prove useful.</em></p>

<h3 id="kirkpatricks-algorithm">Kirkpatrick’s Algorithm</h3>

<p>At the core of my work was an implementation of <a href="http://www.cs.princeton.edu/courses/archive/fall05/cos528/handouts/Optimal%20Search%20In%20Planar.pdf">Kirkpatrick’s Algorithm</a> for <a href="http://en.wikipedia.org/wiki/Point_location">point location</a>. The problem statement would be something like: <em>given a planar subdivision (a bunch of non-overlapping polygons in the plane) and a point P, which polygon contains P?</em> Think point-in-polygon on steroids—instead of a single polygon, you’ve got a plane-ful of them.</p>

<p>As a use-case, consider a web page. When a user clicks on the mouse, the web page needs to figure out <em>what</em> the user clicked on as quickly as possible. Was it Button A? Was it Link B? The web page is composed of non-overlapping polygons, so Kirkpatrick’s Algorithm would be well-positioned to help out.</p>

<p>While I won’t discuss the algorithm in-depth, you can learn more <a href="http://www.cs.ucsb.edu/~suri/cs235/Location.pdf">here</a>.</p>

<h3 id="minimum-bounding-triangle">Minimum Bounding Triangle</h3>

<p>As a subtask, I also implemented <a href="http://prografix.narod.ru/source/orourke1986.pdf">O’Rourke’s algorithm</a> for computing a minimum enclosing/bounding triangle (that is, finding the smallest triangle that encloses convex a set of points) in linear-time.</p>

<p><em>Note: Computing the minimum bounding triangle does not help or hurt the asymptotic performance of Kirkpatrick’s Algorithm as the computation itself is linear-time—but it’s useful for aesthetic purposes.</em></p>

<h2 id="practical-advice-applications-and-concerns">Practical Advice, Applications, and Concerns</h2>

<p>The previous sections focused on why computational geometry can be difficult to reason about rigorously.</p>

<p>In practice, we have to deal with a whole new host of concerns.</p>

<p>Remember CCW? As a nice segue, let’s see yet another one of its great qualities: it protects us against the dangers of floating-point errors.</p>

<h3 id="floating-point-errors-why-ccw-is-king">Floating-Point Errors: Why CCW is King</h3>

<p>In my computational geometry course, <a href="http://www.cs.princeton.edu/~chazelle/">Bernard Chazelle</a>, an esteemed professor who’s <a href="http://www.cs.princeton.edu/~chazelle/pubs.html">published more papers</a> than I can count, made it a rule that we couldn’t mention angles when attempting to describe an algorithm or a solution.</p>

<p class="pop_out_box is-full_width is-big">
It became a rule that we couldn't even <i>mention</i> angles. Why? Angles are messy—angles are "dirty".
</p>

<p>Why? Angles are messy. Angles are “dirty”. When you have to compute an angle, you need to divide, or use some approximation (anything involving Pi, for example) or some trigonometric function.</p>

<p>When you have to compute an angle <em>in code</em>, you’ll almost <em>always</em> be approximating. You’ll be off by some tiny floating point degree of precision—which matters when you’re testing for equality. You may solve for some point in the plane through two different methods and, of course, expect that <code>p1.x == p2.x and p1.y == p2.y</code>. But, in reality, this check will fail <em>often</em>. Further (and quite obviously), these points will then have different hashes.</p>

<p>To make matters worse, your degree of error will increase as your tiny differences propagate through your computations. (For some more scientific examples, <a href="http://www.mpi-inf.mpg.de/~mehlhorn/ftp/classroomExamplesNonrobustness.pdf">this paper</a> goes through what can go wrong when computing the convex hull or Delaunay triangulation.)</p>

<p>So, what can we do about this?</p>

<h4 id="almostequal">almostEqual</h4>

<p>Part of the Python computational geometry problem is that we’re requiring <em>exactness</em> in a world where things are <em>rarely</em> exact. This will become a problem more often than when handling angles. Consider the following:</p>

<pre><code># Define two random points
p1 = RandomPoint()
p2 = RandomPoint()

# Take the line through them
l1 = Line(p1, p2)

# Shift both points up by sqrt(2)
p1.y += sqrt(2)
p2.y += sqrt(2)

l2 = Line(p1, p2)

# Slope 'should' be the same?
if abs(l1.slope - l2.slope) &gt; 0:
    print "Error!"
# Error!
</code></pre>

<p>In fact, this code will print “Error!” roughly 70% of the time (empirically). We can address this concern by being slightly more lenient with our definition of equality; that is, by sacrificing a degree of accuracy.</p>

<p>One approach I’ve used (and seen in, e.g., some <a href="http://opencv.org">OpenCV</a> modules) is to define two numbers as equal if they differ only by some small value epsilon. In Python, you might have:</p>

<pre><code>def almostEqual(x, y, EPSILON=1e-5):
    return abs(x - y) &lt; EPSILON

class Point(object):
    ...
    def __eq__(self, that):
        return (almostEqual(self.x, that.x) and
                almostEqual(self.y, that.y))
</code></pre>

<p>In practice, this is very helpful. Rarely, if ever, would you compute two points that differ by less than 1e-5 that are actually meant to be different points. I highly recommend implementing this type of override. Similar methods can be used for lines, for example:</p>

<pre><code>class Line(object):
    ...
    def __eq__(self, that):
        return (almostEqual(self.slope, that.slope) and
                almostEqual(self.intercept, that.intercept))
</code></pre>

<p>More advanced solutions have been proposed, of course. For example, the ‘exact geometric computation’ school of thought (described in <a href="http://www.informatik.uni-trier.de/Reports/TR-08-2004/rnc6_03_schirra.pdf">this paper</a>) aims to have all decision paths in a program depend solely on the <em>sign</em> of some computation, rather than its exact numerical value, taking away many of the concerns related to floating-point computations. Our <em>near equality</em> approach just scratches the surface, but will often be sufficient in practice.</p>

<h4 id="ccw-is-king">CCW is King</h4>

<p>At a higher level, it’s (arguably) problematic that we even <em>define</em> our solutions in terms of such exact computational quantities as angles or point coordinates. Rather than addressing the symptoms alone (i.e., washing over floating-point errors with <code>almostEqual</code>), why not address the cause? The solution: instead of thinking in terms of angles, <strong>think in terms of CCW</strong>, which will help to abstract away the concerns associated with floating-point computation.</p>

<p>Here’s a concrete example: lets say you have some convex polygon <em>P</em>, a vertex <em>v</em>, and some point <em>u</em> outside of the polygon. How can you figure out if the line <em>uv</em> intersects <em>P</em> above or below <em>v</em>, or not at all, in constant time?</p>

<p>The brute force solution (besides being linear-time, rather than constant) would be problematic as you’d have to compute some exact line intersection points.</p>

<p>One constant-time approach I’ve seen involves:</p>

<ul>
  <li>Calculating some angles using <code>arctan2</code>.</li>
  <li>Converting these angles to degrees by multiplying by 180/Pi.</li>
  <li>Examining the relationships between these various angles.</li>
</ul>

<p>Luckily, the author used the <code>almostEqual</code> technique above to smooth over the floating-point errors.</p>

<p>In my opinion, it’d be better to avoid the issue of floating-point errors entirely. If you take a few minutes to look at the problem on paper, you can get a solution based entirely on CCW. The intuition: if the vertices adjacent to <em>v</em> are on the same side of <em>uv</em>, then the line does not intersect; else, see if <em>u</em> and <em>v</em> are on the same side of the line between the adjacent vertices and, depending on the result, compare their heights.</p>

<p>Here’s the Python code for testing intersection above <em>v</em> (intersection below just reverses the direction of the comparisons):</p>

<pre><code>def intersectsAbove(verts, v, u):
    """
        Returns True if uv intersects the polygon defined by 'verts' above v.
        Assumes v is the index of a vertex in 'verts', and u is outside of the
        polygon.
    """
    n = len(verts)
    
    # Test if two adjacent vertices are on same side of line (implies
    # tangency)
    if ccw(u, verts[v], verts[(v - 1) % n]) == ccw(u, verts[v], verts[(v + 1) % n]):
        return False

    # Test if u and v are on same side of line from adjacent
    # vertices
    if ccw(verts[(v - 1) % n], verts[(v + 1) % n], u) == ccw(verts[(v - 1) % n], verts[(v + 1) % n], verts[v]):
        return u.y &gt; verts[v].y
    else:
        return u.y &lt; verts[v].y
</code></pre>

<p>The solution isn’t immediately obvious to the naked eye, but it’s in the <em>language</em> of a computational geometry algorithm: ‘same side of the line’ is a classic element of that trusty algorithm.</p>

<h3 id="done-is-better-than-perfect">Done is Better than Perfect</h3>

<p>In the computational geometric literature, there’s often a fair amount of wizardry involved in seemingly simple operations. This gives you a choice: you can do things the hard way, following some paper that defines an incredibly advanced solution to a not-so-advanced problem—or you can do things the easy way with a bit of brute force.</p>

<p>Again, I’ll use an example: sampling a random interior point from an arbitrary polygon. In other words, I give you some simple polygon, and you give me a random point inside it (uniformly distributed across the polygon).</p>

<p>Often, interior points are required for testing. In that case, you don’t have any specific runtime requirements on the computational geometry algorithm that produces them (within reason). The quick and dirty solution, which takes ~2 minutes to implement, would be to pick a random point within a box containing the polygon and see if the point itself is within the polygon.</p>

<p>For example, we may miss twice and find a valid sample only on the third point:</p>

<p><img src="//assets.toptal.io/uploads/blog/image/257/toptal-blog-image-1389197582165.gif" alt="This animation demonstrates the result of computational geometry in Python."/></p>

<p>Here’s the code:</p>

<pre><code>class Polygon(object):
    ...
    def interiorPoint(self):
        """Returns a random point interior point"""
        min_x = min([p.x for p in self.points])
        max_x = max([p.x for p in self.points])
        min_y = min([p.y for p in self.points])
        max_y = max([p.y for p in self.points])

        def x():
            return min_x + random() * (max_x - min_x)

        def y():
            return min_y + random() * (max_y - min_y)

        p = Point(x(), y())
        while not self.contains(p):
            p = Point(x(), y())

        return p

    def contains(self, p):
        for i in range(self.n):
            p1 = self.points[i]
            p2 = self.points[(i + 1) % self.n]
            p3 = self.points[(i + 2) % self.n]
            if not ccw(p1, p2, p3):
                return False
        return True
</code></pre>

<p>This is known as <a href="http://en.wikipedia.org/wiki/Rejection_sampling"><em>rejection sampling</em></a>: take random points until one satisfies your criteria. While it may require several samples to find a point that meets your criteria, in practice, <strong>the difference will be negligible</strong> for your test suite. So why work any harder? In summary: don’t be afraid to take the dirty route when the occasion calls for it.</p>

<p>By the way: if you want an <em>exact</em> algorithm for random sampling, there’s a clever one <a href="http://www.cs.princeton.edu/~funk/tog02.pdf">here</a> that I’ve implemented below. The gist of it:</p>

<ol>
  <li><a href="http://en.wikipedia.org/wiki/Triangulation">Triangulate</a> your polygon (i.e., break it into triangles).</li>
  <li>Choose a triangle with probability proportional to its area.</li>
  <li>Take a random point from within the chosen triangle (a constant-time operation).</li>
</ol>

<p>Note that this algorithm requires you to triangulate your polygon, which immediately imposes a different runtime bound on the algorithm, as well as the necessity that you <em>have</em> a library for triangulating arbitrary polygons (I used <a href="http://code.google.com/p/poly2tri/">poly2tri</a> with Python bindings).</p>

<pre><code>from p2t import CDT

class Triangle(object):
    ...
    def area(self):
        return abs((B.x * A.y - A.x * B.y) + (C.x * B.y - B.x * C.y) + (A.x * C.y - C.x * A.y)) / 2

    def interiorPoint(self):
        r1 = random()
        r2 = random()
        # From http://www.cs.princeton.edu/~funk/tog02.pdf
        return (1 - sqrt(r1)) * A + sqrt(r1) * (1 - r2) * B + r2 * sqrt(r1) * C


class Polygon(object):
    ...
    def triangulate(self):
        # Triangulate poly with hole
        cdt = CDT(poly.points)
        triangles = cdt.triangulate()

        def convert(t):
            A = Point(t.a.x, t.a.y)
            B = Point(t.b.x, t.b.y)
            C = Point(t.c.x, t.c.y)
            return Triangle(A, B, C)
        return map(convert, triangles)

    def interiorPoint(self):
        # Triangulate polygon
        triangles = self.triangulate()
        areas = [t.area() for t in triangles]
        total = sum(areas)
        # Calculate normalized areas
        probabilities = [area / total for area in areas]
        weighted_triangles = zip(triangles, probabilities)

        # Sample triangles according to area
        r = random()
        count = 0
        for (triangle, prob) in weighted_triangles:
            count += prob
            # Take random point from chosen triangle
            if count &gt; r:
                return triangle.interiorPoint()
</code></pre>

<p>Hopefully, the extra effort is evident from the code. Remember: as they say at Facebook, <a href="http://lifehacker.com/5870379/done-is-better-than-perfect">“done is better than perfect”</a>. The same goes for computational geometry problems.</p>

<h3 id="visual-and-automated-testing">Visual and Automated Testing</h3>

<p>As many of the problems you work on in computational geometry are defined in terms of easily visualizable qualities or quantities, visual testing is <em>particularly</em> important—although insufficient on its own. The ideal test suite will have a combination of visual and randomized automated testing.</p>

<p class="pop_out_box is-full_width is-big">
The ideal test suite will have a combination of visual and randomized automated testing.
</p>

<p>Again, we proceed by example. Consider testing our implementation of Kirkpatrick’s Algorithm. At one step, the algorithm needs to bound the given polygon by a triangle and triangulate the region between the polygon and the outer triangle. Here’s a visual example, where the solid green line defines the initial polygon, and the dashed lines define the triangulated region:</p>

<p><img src="//assets.toptal.io/uploads/blog/image/258/toptal-blog-image-1389197608789.gif" alt="This visual of a computational geometry problem in Python sheds light on the principles covered in this tutorial."/></p>

<p>Confirming that this triangulation has been executed correctly is very difficult to verify through code, but is immediately evident to the human eye. <em>Note: I highly suggest using <a href="http://matplotlib.org">Matplotlib</a> to aid in your visual testing—there’s a nice guide <a href="http://www.loria.fr/~rougier/teaching/matplotlib/">here</a>.</em></p>

<p>Later, we will want to verify that the algorithm correctly locates points. A randomized, automated approach would be to generate a bunch of interior points for every polygon and  make sure that we return the desired polygon. In code:</p>

<pre><code>class TestLocator(unittest.TestCase):
    ...
    def runLocator(self, polygons):
        # Pre-process regions
        l = Locator(polygons)

        # Ensure correctness
        for polygon in polygons:
            # Test 100 random interior points per region
            for k in range(100):
                target = polygon.interiorPoint()
                target_polygon = l.locate(target)
                self.assertEqual(polygon, target_polygon)
                self.assertTrue(target_polygon.contains(target))
</code></pre>

<p>We could then use the <code>runLocator</code> method on different sets of polygons, giving us a well-diversified test suite.</p>

<h3 id="open-source-solutions">Open-Source Solutions</h3>

<p>Computational geometry has a nice suite of open-source libraries and solutions available regardless of your programming language of choice (although C++ libraries seem to crop up a disproportionate amount).</p>

<p>The benefits of using existing open-source solutions (<a href="https://www.toptal.com/scientific-computing/scientific-computing-with-open-source-tools">as with scientific computing in Python</a>) are well-known and have been discussed extensively, so I won’t go on about it here. But I thought I’d mention a few Python-centric resources that I found useful:</p>

<ul>
  <li><a href="http://code.google.com/p/poly2tri/">poly2tri</a>: a great library for fast triangulations of polygons. Also supports (and this is often crucial) polygons with <em>holes</em> in them. Written in C++, poly2tri also has Python bindings and was quite easy to get up and running. See my <code>triangulate</code> method above for a taste for the function calls.</li>
  <li><a href="http://docs.scipy.org/doc/scipy/reference/spatial.html">scipy.spatial</a>: includes functions for computing convex hulls, Delaunay Triangulations, and more. Fast (as always), reliable, etc. <em>Note: I found it useful to use my own <code>Point</code> datatype with a <code>toNumpy</code> method: <code>def np(self): return [self.x, self.y]</code>. Then, I could easily call scipy.spatial methods, e.g.: <code>scipy.spatial.ConvexHull(np.array(map(lambda p: p.np()), points))</code></em>.</li>
  <li><a href="http://opencv.org">OpenCV</a>: the open-source computer vision library has some nice standalone computational geometry modules. In particular, I used its <a href="http://docs.opencv.org/master/d3/dc0/group__imgproc__shape.html#ga1513e72f6bbdfc370563664f71e0542f">minimum enclosing triangle function</a> for a while before implementing it myself.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>I hope this post has given you a taste for the beauty of computational geometry as a <a href="https://www.toptal.com/python">Python developer</a>, a subject rich with fascinating problems and equally fascinating applications.</p>

<p>In practice, computational geometric implementations present unique challenges that will push you to exercise new and exciting problem-solving skills.</p>

<p>If you’re interested in learning more or have any questions for me, I can be reached at <a href="mailto:charlie@toptal.com">charlie@toptal.com</a>.</p>
<p class="template" data-role="subscribe_template" data-template="{&quot;html&quot;:&quot;\u003cdiv class=\&quot;embeddable_form-wrapper\&quot; data-view=\&quot;blog_subscribe#form\&quot;\u003e\u003cform action=\&quot;/blog/subscription\&quot; class=\&quot;embeddable_form for-post\&quot; data-entity=\&quot;blog_subscription\&quot; data-remote=\&quot;\&quot; data-view=\&quot;form#form\&quot; method=\&quot;post\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-step is-email_form is-current\&quot; data-role=\&quot;step\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-row is-label\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-label_title\&quot;\u003eLike what you\u0026#39;re reading?\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-label\&quot;\u003eGet the latest updates first.\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row form-field is-email_field\&quot;\u003e\u003cinput autocomplete=\&quot;off\&quot; class=\&quot;input is-medium\&quot; data-role=\&quot;email\&quot; name=\&quot;blog_subscription[email]\&quot; placeholder=\&quot;Enter your email address...\&quot; type=\&quot;text\&quot; /\u003e\u003cinput name=\&quot;blog_subscription[vertical]\&quot; type=\&quot;hidden\&quot; value=\&quot;developers\&quot; /\u003e\u003cinput name=\&quot;from_widget\&quot; type=\&quot;hidden\&quot; value=\&quot;true\&quot; /\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-submit\&quot;\u003e\u003cinput class=\&quot;button is-green_candy is-default is-full_width\&quot; data-loader-text=\&quot;Subscribing...\&quot; data-role=\&quot;submit\&quot; type=\&quot;submit\&quot; value=\&quot;Get Exclusive Updates\&quot; /\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-privacy\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-privacy\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-privacy_icon\&quot;\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-privacy_text\&quot;\u003eNo spam. Just great engineering and design posts.\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-step is-confirmation\&quot; data-role=\&quot;step\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-row is-label is-success\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-label_title\&quot;\u003eLike what you\u0026#39;re reading?\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-label\&quot;\u003eGet the latest updates first.\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-success\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-label is-header\&quot;\u003eThank you for subscribing!\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-label\&quot;\u003eYou can edit your subscription preferences \u003ca href='#' data-role='preferences_link'\u003ehere\u003c/a\u003e.\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-success\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-done\&quot;\u003e\u003cul class=\&quot;blog_follow_us\&quot;\u003e\u003cul class=\&quot;social_share\&quot;\u003e\u003cli class=\&quot;social_share-item is-facebook\&quot;\u003e\u003cdiv class=\&quot;fb-like\&quot; data-href=\&quot;https://www.toptal.com/blog\&quot; data-layout=\&quot;button_count\&quot; data-send=\&quot;false\&quot; data-show-faces=\&quot;false\&quot; data-width=\&quot;450\&quot;\u003e\u003c/div\u003e\u003c/li\u003e\u003cli class=\&quot;social_share-item is-twitter_follow\&quot;\u003e\u003ca class=\&quot;twitter-follow-button\&quot; data-show-count=\&quot;true\&quot; href=\&quot;https://twitter.com/toptalllc\&quot;\u003eFollow @toptalllc\u003c/a\u003e\u003c/li\u003e\u003cli class=\&quot;social_share-item is-google_plus_follow\&quot;\u003e\u003cdiv class=\&quot;g-follow\&quot; data-annotation=\&quot;bubble\&quot; data-height=\&quot;20\&quot; data-href=\&quot;https://plus.google.com/109028009576318848424\&quot; data-rel=\&quot;publisher\&quot;\u003e\u003c/div\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/form\u003e\u003c/div\u003e&quot;}"/></div></div></body></html>