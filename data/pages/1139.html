<html><body><div><div role="main">
        
<h2>Security releases issued</h2>

<span class="meta">Posted by <strong>James Bennett</strong> on April 21, 2014 </span>

<p>Today the Django team is issuing multiple releases -- Django 1.4.11,
Django 1.5.6, Django 1.6.3 and Django 1.7 beta 2 -- as part of <a class="reference external" href="https://www.djangoproject.com/security/">our
security process</a>. These
releases are now available on <a class="reference external" href="https://pypi.python.org/pypi/Django">PyPI</a> and our <a class="reference external" href="/download/">download page</a>.</p>
<p>These releases address an unexpected code-execution issue, a caching
issue which can expose CSRF tokens and a MySQL typecasting
issue. While these issues present limited risk and may not affect all
Django users, we encourage all users to evaluate their own risk and
upgrade as soon as possible.</p>
<p>For more details, read on.</p>
<div class="section" id="s-issue-unexpected-code-execution-using-reverse">
<h4>Issue: Unexpected code execution using <tt class="docutils literal">reverse()</tt></h4>
<p>Django's URL handling is based on a mapping of regex patterns
(representing the URLs) to callable views, and Django's own processing
consists of matching a requested URL against those patterns to
determine the appropriate view to invoke.</p>
<p>Django also provides a convenience function --
<tt class="docutils literal">django.core.urlresolvers.reverse()</tt> -- which performs this process
in the opposite direction. The <tt class="docutils literal">reverse()</tt> function takes
information about a view and returns a URL which would invoke that
view. Use of <tt class="docutils literal">reverse()</tt> is encouraged for application developers,
as the output of <tt class="docutils literal">reverse()</tt> is always based on the current URL
patterns, meaning developers do not need to change other code when
making changes to URLs.</p>
<p>One argument signature for <tt class="docutils literal">reverse()</tt> is to pass a dotted Python
path to the desired view. In this situation, Django will import the
module indicated by that dotted path as part of generating the
resulting URL. If such a module has import-time side effects, those
side effects will occur.</p>
<p>Thus it is possible for an attacker to cause unexpected code
execution, given the following conditions:</p>
<ol class="arabic simple">
<li>One or more views are present which construct a URL based on user
input (commonly, a "next" parameter in a querystring indicating
where to redirect upon successful completion of an action).</li>
<li>One or more modules are known to an attacker to exist on the
server's Python import path, which perform code execution with side
effects on importing.</li>
</ol>
<p>To remedy this, <tt class="docutils literal">reverse()</tt> will now only accept and import dotted
paths based on the view-containing modules listed in the project's URL
pattern configuration, so as to ensure that only modules the developer
intended to be imported in this fashion can or will be imported.</p>
<p>This issue has been assigned the CVE identifier CVE-2014-0472.</p>
<p>Thanks to Benjamin Bach for reporting this issue.</p>
</div>
<div class="section" id="s-issue-caching-of-anonymous-pages-could-reveal-csrf-token">
<h4>Issue: Caching of anonymous pages could reveal CSRF token</h4>
<p>Django includes both a caching framework and a system for preventing
cross-site request forgery (CSRF) attacks. The CSRF-protection system
is based on a random nonce sent to the client in a cookie which must
be sent by the client on future requests and, in forms, a hidden value
which must be submitted back with the form.</p>
<p>The caching framework includes an option to cache responses to
anonymous (i.e., unauthenticated) clients.</p>
<p>When the first anonymous request to a given page is by a client which
did not have a CSRF cookie, the cache framework will also cache the
CSRF cookie and serve the same nonce to other anonymous clients who
do not have a CSRF cookie. This can allow an attacker to obtain a
valid CSRF cookie value and perform attacks which bypass the check for
the cookie.</p>
<p>To remedy this, the caching framework will no longer cache such
responses. The heuristic for this will be:</p>
<ol class="arabic simple">
<li>If the incoming request did not submit any cookies, and</li>
<li>If the response did send one or more cookies, and</li>
<li>If the <tt class="docutils literal">Vary: Cookie</tt> header is set on the response, then the
response will not be cached.</li>
</ol>
<p>This issue has been assigned the CVE identifier CVE-2014-0473.</p>
<p>Thanks to committer Paul McMillan for reporting this issue.</p>
</div>
<div class="section" id="s-issue-mysql-typecasting">
<h4>Issue: MySQL typecasting</h4>
<p>The MySQL database is known to "typecast" on certain queries; for
example, when querying a table which contains string values, but using
a query which filters based on an integer value, MySQL will first
silently coerce the strings to integers, and return a result based on
that.</p>
<p>If a query is performed without first converting values to the
appropriate type, this can produce unexpected results, similar to what
would occur if the query itself had been manipulated.</p>
<p>Django's model field classes are aware of their own types and most
such classes perform explicit conversion of query arguments to the
correct database-level type before querying. However, three model
field classes did not correctly convert their arguments:</p>
<ul class="simple">
<li><tt class="docutils literal">FilePathField</tt></li>
<li><tt class="docutils literal">GenericIPAddressField</tt></li>
<li><tt class="docutils literal">IPAddressField</tt></li>
</ul>
<p>These three fields have been updated to convert their arguments to the
correct types before querying.</p>
<p>Additionally, developers of custom model fields are now warned via
documentation to ensure their custom field classes will perform
appropriate type conversions, and users of the <tt class="docutils literal">raw()</tt> and
<tt class="docutils literal">extra()</tt> query methods -- which allow the developer to supply raw
SQL or SQL fragments -- will be advised to ensure they perform
appropriate manual type conversions prior to executing queries.</p>
<p>This issue has been assigned the CVE identifier CVE-2014-0474.</p>
<p>Thanks to the Ruby on Rails team, and specifically Michael Koziarski,
for providing information regarding this issue.</p>
</div>
<div class="section" id="s-affected-versions">
<h4>Affected versions</h4>
<ul class="simple">
<li>Django master development branch</li>
<li>Django 1.7 (currently at beta status)</li>
<li>Django 1.6</li>
<li>Django 1.5</li>
<li>Django 1.4</li>
</ul>
</div>
<div class="section" id="s-resolution">
<h4>Resolution</h4>
<p>Patches have been applied to Django's master development branch, and
to the 1.4, 1.5, 1.6 and 1.7 release branches, which resolve the
issues described above. The patches may be obtained directly from the
following changesets:</p>
<p>On the development master branch:</p>

<p>On the Django 1.7 release branch:</p>

<p>On the Django 1.6 release branch:</p>

<p>On the Django 1.5 release branch:</p>

<p>On the Django 1.4 release branch:</p>

<p>The following new releases have been issued:</p>

</div>
<div class="section" id="s-general-notes-regarding-security-reporting">
<h4>General notes regarding security reporting</h4>
<p>As always, we ask that potential security issues be reported via
private email to <em>security@djangoproject.com</em>, and not via Django's
Trac instance or the django-developers list. Please see <a class="reference external" href="https://djangoproject.com/security">our security
policies</a> for further
information.</p>
<p><strong>UPDATE</strong>: 1850 CST 21 Apr 2014 - The version numbers at the end of this post mistakenly referenced version 1.5.7, instead of 1.5.6.</p>
</div>


        <a href="#top" class="backtotop"><i class="icon icon-chevron-up"/> Back to Top</a>
      </div>

      
  </div></body></html>