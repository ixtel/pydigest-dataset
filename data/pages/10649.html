<html><body><div><div id="about">
<h2>About</h2>
<p>Genty, pronounced “gen-tee”, stands for “generate tests”. It promotes generative
testing, where a single test can execute over a variety of input. Genty makes
this a breeze.</p>
<p>For example, consider a file sample.py containing both the code under test and
the tests:</p>
<pre><span class="kn">from</span> <span class="nn">genty</span> <span class="kn">import</span> <span class="n">genty</span><span class="p">,</span> <span class="n">genty_repeat</span><span class="p">,</span> <span class="n">genty_dataset</span>
<span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">TestCase</span>

<span class="c1"># Here's the class under test</span>
<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="c1"># Here's the test code</span>
<span class="nd">@genty</span>
<span class="k">class</span> <span class="nc">MyClassTests</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@genty_dataset</span><span class="p">(</span>
        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">100000</span><span class="p">,</span> <span class="mi">100001</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_add_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">expected_result</span><span class="p">):</span>
        <span class="n">actual_result</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span><span class="o">.</span><span class="n">add_one</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">expected_result</span><span class="p">,</span> <span class="n">actual_result</span><span class="p">)</span>
</pre>
<p>Running the <tt>MyClassTests</tt> using the default unittest runner</p>
<pre><span class="gp">$</span> python -m unittest -v sample
<span class="go">test_add_one(0, 1) (sample.MyClassTests) ... ok
test_add_one(100000, 100001) (sample.MyClassTests) ... ok

----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK</span>
</pre>
<p>Instead of having to write multiple independent tests for various test cases,
code can be refactored and parametrized using genty!</p>
<p>It produces readable tests.
It produces maintainable tests.
It produces expressive tests.</p>
<p>Another option is running the same test multiple times. This is useful in stress
tests or when exercising code looking for race conditions. This particular test</p>
<pre><span class="nd">@genty_repeat</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_adding_one_to_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">MyClass</span><span class="p">()</span><span class="o">.</span><span class="n">add_one</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</pre>
<p>would be run 3 times, producing output like</p>
<pre><span class="gp">$</span> python -m unittest -v sample
<span class="go">test_adding_one() iteration_1 (sample.MyClassTests) ... ok
test_adding_one() iteration_2 (sample.MyClassTests) ... ok
test_adding_one() iteration_3 (sample.MyClassTests) ... ok

----------------------------------------------------------------------
Ran 3 tests in 0.001s

OK</span>
</pre>
<p>The 2 techniques can be combined:</p>
<pre><span class="nd">@genty_repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nd">@genty_dataset</span><span class="p">(</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">100000</span><span class="p">,</span> <span class="mi">100001</span><span class="p">),</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">test_add_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">expected_result</span><span class="p">):</span>
    <span class="n">actual_result</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span><span class="o">.</span><span class="n">add_one</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">expected_result</span><span class="p">,</span> <span class="n">actual_result</span><span class="p">)</span>
</pre>
<p>There are more options to explore including naming your datasets and <tt>genty_args</tt>.</p>
<pre><span class="nd">@genty_dataset</span><span class="p">(</span>
    <span class="n">default_case</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">limit_case</span><span class="o">=</span><span class="p">(</span><span class="mi">999</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span>
    <span class="n">error_case</span><span class="o">=</span><span class="n">genty_args</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">is_something</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">test_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">,</span> <span class="n">optional_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">is_something</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="o">...</span>
</pre>
<p>would run 3 tests, producing output like</p>
<pre><span class="gp">$</span> python -m unittest -v sample
<span class="go">test_complex(default_case) (sample.MyClassTests) ... ok
test_complex(limit_case) (sample.MyClassTests) ... ok
test_complex(error_case) (sample.MyClassTests) ... ok

----------------------------------------------------------------------
Ran 3 tests in 0.003s

OK</span>
</pre>
<p>The <tt>@genty_datasets</tt> can be chained together. This is useful, for example, if there are semantically different datasets
so keeping them separate would help expressiveness.</p>
<pre><span class="nd">@genty_dataset</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="nd">@genty_dataset</span><span class="p">(</span><span class="s1">'first'</span><span class="p">,</span> <span class="s1">'second'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_composing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_value</span><span class="p">):</span>
        <span class="o">...</span>
</pre>
<p>would run 4 tests, producing output like</p>
<pre><span class="gp">$</span> python -m unittest -v sample
<span class="go">test_composing(10) (sample.MyClassTests) ... ok
test_composing(100) (sample.MyClassTests) ... ok
test_composing(u'first') (sample.MyClassTests) ... ok
test_composing(u'second') (sample.MyClassTests) ... ok

----------------------------------------------------------------------
Ran 4 tests in 0.000s

OK</span>
</pre>
<p>Sometimes the parameters to a test can’t be determined at module load time. For example,
some test might be based on results from some http request. And first the test needs to
authenticate, etc. This is supported using the <tt>@genty_dataprovider</tt> decorator like so:</p>
<pre><span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">MyClassTests</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">setUp</span><span class="p">()</span>

    <span class="c1"># http authentication happens</span>
    <span class="c1"># And imagine that _some_function is actually some http request</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_some_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">))</span>

<span class="nd">@genty_dataset</span><span class="p">((</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">calculate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">):</span>
    <span class="c1"># when this is called... we've been authenticated</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_some_function</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">)</span>

<span class="nd">@genty_dataprovider</span><span class="p">(</span><span class="n">calculate</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_heavy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">data3</span><span class="p">):</span>
    <span class="o">...</span>
</pre>
<p>would run 4 tests, producing output like</p>
<pre><span class="gp">$</span> python -m unittest -v sample
<span class="go">test_heavy_calculate(100, 1) (sample.MyClassTests) ... ok
test_heavy_calculate(1000, 100) (sample.MyClassTests) ... ok

----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK</span>
</pre>
<p>Notice here how the name of the helper (<tt>calculate</tt>) is added to the names of the 2
executed test cases.</p>
<p>Like <tt>@genty_dataset</tt>, <tt>@genty_dataprovider</tt> can be chained together.</p>
<p>Enjoy!</p>
</div>
</div></body></html>