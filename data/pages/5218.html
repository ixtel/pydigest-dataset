<html><body><div><div id="entry" class="usertext">
<p>Object builder is what makes a parser actually useful: it takes a sequence of raw parser events and creates strings, numbers, arrays, maps, etc. With this, <a href="http://softwaremaniacs.org/blog/category/ijson-in-rust/en/">ijson</a> is <a href="https://github.com/isagalaev/ijson-rust/tree/builder">functionally complete</a>.</p>
<p><a name="more"/></p>
<h2>Filtering</h2>
<p>Ijson can filter parser events based on a path down JSON hierarchy. For example, in a file like this:</p>
<pre><code>[
  {
    "name": "John",
    "friends": [ ... ]
  },
  {
    "name": "Mary",
    "friends": [ ... ]
  }
  ... gazillion more records ...
]
</code></pre>
<p>… you would get events with their corresponding paths:</p>
<pre><code>""                   StartArray
"item"               StartMap
"item"               Key("name")
"item.name"          String("John")
"item"               Key("friends")
"item.friends"       StartArray
"item.friends.item"  ...
"item.friends"       EndArray
"item"               EndMap
...                  ...
""                   EndArray
</code></pre>
<p>In Python I implemented this by simply pairing each event with its path string in a tuple <code>(path, event)</code>. In Rust though it <em>feels wrong</em>. The language makes you very conscious of every memory allocation you make, so before even having run a single benchmarks I already worry about creating a new throwaway String instance for every event.</p>
<p>Instead, my filtering parser now accepts a target path, <a href="https://github.com/isagalaev/ijson-rust/blob/builder/src/builder.rs#L95">splits it and keeps it as a vector of strings</a> which it then <a href="https://github.com/isagalaev/ijson-rust/blob/builder/src/builder.rs#L28">compares with a running path stack</a> which it maintains through the whole iterating process. Maintaining a path stack — also a vector of string — still feels slow but at least I don't join those strings constantly for the sole purpose of comparing.</p>
<p>By the way, I was pleasantly surprised to find two handy functions in Rust's stdlib:</p>
<ul>
<li>
<p><code>String::split_terminator</code> which works better than the regular <code>String::split</code> for empty strings, as I want an empty vector in this case:</p>
<pre><code>"".split(".")            // [""]
"".split_terminator(".") // []
</code></pre>
</li>
<li>
<p><code>Vec::starts_with</code> which has the same semantics as <code>String::starts_with</code> but compares values in a vector. Python doesn't have it, so I somewhat hastily implemented it only to find it in the docs after it was done. Oh well :-)</p>
</li>
</ul>
<h2>Building objects</h2>
<p>By now I've flexed my instincts enough so I could write the builder function recursively. It might not seem like a big achievement but I still remember the times just a few weeks ago when I just couldn't persuade the borrow checker to let me do something very similar while I was writing the parser! Now I can't even remember what the problem was. Something silly, for sure…</p>
<p>The <a href="https://github.com/isagalaev/ijson-rust/blob/builder/src/builder.rs#L58">function itself</a> is short but convoluted with <em>slightly</em> ugly differences between handling array and maps (the latter even has the <a href="https://github.com/isagalaev/ijson-rust/blob/builder/src/builder.rs#L69"><code>unreachable!</code> kludge</a> to satisfy the compiler).</p>
<h2>Magical unwrapping</h2>
<p>There's a general problem with deserializing any stream of bytes in a statically typed language: what type should a hypothetical <code>parse_json(blob)</code> return? The answer is, it depends on whatever is in the "blob" and you don't know that in advance.</p>
<p>As far as I know there are two ways of dealing with it:</p>
<ul>
<li>
<p>Wrap all possible value types in a tagged union and confine yourself to tedious unwrapping values on every access: <code>value.as_array().get(0).as_map().get("key").as_int()</code>.</p>
</li>
<li>
<p>Provide a schema for every format you expect from the wire and let some tool generate typed code deserializing bytes into native values of known types.</p>
</li>
</ul>
<p>Since I'm writing a generic JSON parser I went ahead with <a href="https://github.com/isagalaev/ijson-rust/blob/44384c31b4f289d92b425ad62c6b9c63511c00b2/src/builder.rs#L8">wrapped values</a>, leaving unwrapping to a consumer of the library. But then I've found a magical (if badly named) library — <a href="https://doc.rust-lang.org/rustc-serialize/rustc_serialize/index.html">rustc-serialize</a> that can <em>automatically</em> unwrap JSON values into an arbitrarily complex native type:</p>
<pre><code>#[derive(RustcDecodable)]
struct Person {
    name: String,
    friends: Vec&lt;String&gt;,
}

let f = File::open("people.json").unwrap();
let json = Parser::new(f).items("item").next().unwrap();

let result: Person = decode(json).unwrap(); // ← magic happens here
</code></pre>
<p>Let me make it clear: it doesn't just unwrap the top-level <em>struct</em> it does it all the way down, so in <code>friends</code> you get a real vector of strings, not json-vector of json-strings. Isn't that cool?!</p>
<p>Magic consists of two parts:</p>
<ul>
<li><code>derive(RustcDecodable)</code> is some macro-thingie that generates code specific to this particular struct that unwraps a JSON value of the same structure. </li>
<li><code>decode(json)</code> is a generic function that works for all decodable types defined in the code, and Rust automatically picks up the right implementation knowing that the result is assigned to a <code>Person</code> variable.</li>
</ul>
<p>Come to think of it, this is in fact the very same "schema + codegen" option with the schema being described directly in Rust and code being generated by the macro system instead of relying on some pesky cross-language IDL and stub-generating build scripts. (Yeah, I still remember Microsoft COM and CORBA :-) )</p>
<h2>Splendours and miseries of traits</h2>
<p>To expose the builder interface I decided to exercise the power of Rust's traits. Instead of hard-glueing the <code>items(prefix)</code> method to <code>Parser</code> I wanted it to work for any type that is an iterator of parser events:</p>
<pre><code>parser.items("");                    // Parser itself
parser.prefix("root").items("");     // my own preifxed wrapper around parser
parser.filter(predicate).items("");  // Rust's stdlib Filter type
</code></pre>
<p>In a language that couples interfaces with type definitions (e.g. Java) the last line wouldn't be possible as <code>filter(..)</code> is something declared in the stdlib and it has no idea about my local interfaces.</p>
<p>In a duck-typed language (quack! quack!) it would work by asking an object at run time to turn itself into an iterator and treating whatever it would yield as events. No guarantees of any kind, but very flexible and with no declarations necessary.</p>
<p>Here's where Rust's splendour comes in: you can describe your trait (a.k.a. interface) generically so it will be applicable to any type meeting your conditions, no matter where it is defined:</p>
<pre><code>pub trait Builder where Self: Sized + Iterator&lt;Item=Event&gt; {

    fn items(self, prefix: &amp;str) -&gt; Items&lt;Prefix&lt;Self&gt;&gt; { ... }

}
</code></pre>
<p><code>Self</code> here denotes the type of an object that this trait can be glued onto. We don't specify any base type for that, instead we describe a condition: <code>Sized</code> and <code>Iterator&lt;Item=Event&gt;</code> are the traits that this type must have in order to accept a Builder trait. So this literally says that the Builder trait is applicable to any type that is an iterator of parser events (forget about <code>Sized</code> for now.)</p>
<p>This isn't enough, however. A trait itself is only a description of an interface, and usually it needs a separate implementation for every type you want it to work with. However my trait is different: it doesn't really need to know anything about the concrete type of <code>Self</code>, it has all its methods already implemented using features provided by the Iterator trait. Still, even in the case where there's nothing to implement I had to explicitly tell Rust to consider the Builder trait implemented for any type it's implementable for:</p>
<pre><code>impl&lt;T&gt; Builder for T where T: Sized + Iterator&lt;Item=Event&gt; {}
</code></pre>
<p>All those repeating impls, angle brackets and types feel like boilerplate. And even though it seems like a small price for great flexibility, the hard part is actually finding how these things are supposed to be done. It usually means looking at other code that does something similar. Or bothering other people :-)</p>
<p>Another problem is that the origin of trait methods is completely undiscoverable using the code alone, because you have to import the trait, not individual methods:</p>
<pre><code>use ijson::parser::Builder;

parser.items(""); // Where did items come from? No idea...
</code></pre>
<p>Without help from some clever IDE you're left with guessing and reading docs for all the traits you've got imported in the file.</p>
<p>To be honest, I'd prefer pure functional interface to all this machinery. So that <code>items()</code>, <code>filter()</code>, <code>prefix()</code> would be stand-alone functions without the need of describing traits grouping them together. But method chaining seems to be idiomatic to Rust so I decided to stick with it.</p>
<h2>One last wart</h2>
<p>Turns out there are no macros for initializing maps of any kind! While you can easily initialize a vector:</p>
<pre><code>let v = vec![1, 2, 3];
</code></pre>
<p>… a map is going bore you to death before you even get to the third element:</p>
<pre><code>let m = HashMap::new();
m.insert("key", "value");
m.insert("key2", "value2");
// ...
</code></pre>
<p>On the other hand, you're much more likely to define custom structs instead of relying on ad-hoc maps.</p>
<h2>What's next</h2>
<p>First, I want to replace all the <code>unwrap</code>s and <code>panic!</code>s with the proper Rustian error handling. Expect some rants!</p>
<p>And then I want to spend some time optimizing performance. Running some quick tests showed that my horribly unoptimized code is only 4 times slower than <a href="https://gist.github.com/isagalaev/523a93f837976c9b3682">C using yajl</a>. I've been expecting much worse, to be honest!

</p></div>
</div></body></html>