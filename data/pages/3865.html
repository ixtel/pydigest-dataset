<html><body><div><div class="content html_format"><p>
      Хочу поделиться опытом участия в конкурсе Kaggle и алгоритмами машинного обучения, с помощью которых добрался </p><a href="https://www.kaggle.com/c/avazu-ctr-prediction/leaderboard/private">до 18-го места из 1604 в конкурсе Avazu</a><p> по прогнозированию CTR (click-through rate) мобильной рекламы. В процессе работы попытался воссоздать оригинальный алгоритм Мактрикснета, тестировал несколько вариантов логистической регрессии и работал с характеристиками. Обо всём этом ниже, плюс прикладываю полный код, чтобы можно было посмотреть, как всё работает.
</p><p>
Рассказ делю на следующие разделы:</p><p>
1. Условия конкурса;</p><p>
2. Создание новых характеристик;</p><p>
3. Логистическая регрессия – прелести адаптивного градиента;</p><p>
4. Матрикснет – воссоздание полного алгоритма;</p><p>
5. Ускорение машинного обучения в Python.
</p><a name="habracut"/>
<h4>1. Условия конкурса</h4><p>
Предоставленные данные:
</p><ul>
<li>40.4 млн записей для обучения (10 дней показов рекламы Avazu);</li>
<li>4.5 млн записей для тестирования (1 день).</li>
</ul><p>
Сами данные можно скачать </p><a href="https://www.kaggle.com/c/avazu-ctr-prediction/data">здесь</a><p>.
</p><p>
В качестве критерия оценки была заявлена отрицательная вероятность ошибки (Negative Likelihood Loss – NLL):

</p><img src="https://habrastorage.org/files/f19/591/daf/f19591dafc7541bd9af2b2eaaf9039fe.jpg"/>
<p>
Где </p><b>N</b><p> – это кол-во записей, </p><b>y</b><p> – это значение переменной click, </p><b>p</b><p> – вероятность того, что событием был клик («1»).
</p><p>
Важным свойством этой функции ошибки является то, что если </p><b>p</b><p> основана на сигмоид функции, то частной производной (далее, градиентом) будет </p><b>(p-y)</b><p>.

</p><img src="https://habrastorage.org/files/029/dd1/7df/029dd17df9764fd68cd75a534f509226.jpg"/>

<h4>2. Создание новых характеристик</h4><p>
Для начала посмотрим на исходные данные, с чем мы можем работать:
</p><ul>
<li>сlick – «0» – не было клика, «1» – был клик, это цель для предсказания; </li>
<li>hour – время и дата показа рекламы;</li>
<li>banner_pos – расположение баннера (предположительно, первый экран, второй и т.д.);</li>
<li>site*, app* характеристики – информация о месте показа рекламы;</li>
<li>device* характеристики – информация о девайсе, на котором показывается реклама;</li>
<li>C1, C14-C21 — зашифрованные характеристики (предположительно, включающие в себя данные о геолокации показа, часовом поясе и, возможно, другую информацию).</li>
</ul>
<p>
Это не очень большое поле для работы, так как у нас нет исторических данных по пользователям, а самое главное — мы ничего не знаем о том, что за реклама показывается каждый раз. А это важная составляющая (вы ведь кликаете не на всю подряд рекламу?).
</p><p>
Что создаём нового:
</p><ol>
<li>Полиноминальные характеристики 2-го уровня (3-й слишком замедляет процесс обучения); </li>
<li>User_id. Тестировал несколько вариантов, лучше всего работает – device_id + device_ip + device_model + C14 (предположительно география на уровне города / региона). И да, device_id не равняется user_id;</li>
<li>Частота контакта с рекламой. Обычно пользователи, которые видят рекламу в 100-й раз за день, реагируют на неё не так же, как те, кто видит в 1-й. Поэтому считаем частоту каждого показа для каждого user_id.</li>
</ol>
<div class="spoiler"><b class="spoiler_title">Пример формирования user id</b></div><p>
Идеи пробовал разные, указанные выше дали наилучший результат. При их формировании в основном основывался на своём опыте работы в рекламе и том, что можно было вытащить из данных Avazu.
</p><p>
Также делаем небольшие преобразования/трансформации данных, направленные, прежде всего, на избавление от повторяющейся информации:
</p><ul>
<li>hour – выделяем час, выбрасываем день; </li>
<li>C1 – предполагаю, что за этим скрывался часовой пояс, поэтому после 2 числа сливаю с колонкой час;</li>
<li>С15 и C16 – объединяем, так как за ними легко угадывается ширина и высота баннера, нет смысла оставлять лишние характеристики;</li>
<li>Site* и app* — трансформируем в placement*, так как понятно, что баннер показывается либо на сайте, либо в приложении, а остальные значения – это просто зашифрованный NULL, который доп. информации не несёт;</li>
<li>Убираем все значения, которые не встречались в тестовых данных. Это помогает уменьшить переобучение.</li>
</ul><p>
Все изменения тестировал с помощью логистической регрессии: они либо давали улучшения, либо ускоряли алгоритм и не ухудшали результаты.

</p><h4>3. Логистическая регрессия (Logistic Regression) – прелести адаптивного градиента</h4><p>
Логистическая регрессия – популярный алгоритм для классификации. Есть 2 основные причины такой популярности:</p><p>
1. Простота для понимания и создания алгоритма;

</p><img src="https://habrastorage.org/files/9a8/029/2bf/9a80292bfbea4bdb867b1c051ce0aa9d.jpg"/>
<p>
2. Скорость и адаптивность предсказания на больших данных за счёт стохастического градиентного спуска (stochastoc gradient descent, SGD).

</p><img src="https://habrastorage.org/files/265/de6/d95/265de6d95a234c6fbfa19aa1340e3283.jpg"/>
<p>
На примере данных Avazu посмотрим, как из-за стохастического градиента мы не всегда «идём» точно к минимуму:

</p><img src="https://habrastorage.org/files/58a/f19/433/58af194333c34c3f8252d16b989a73e0.jpg"/>

<h5>3.1. Адаптивный градиент</h5><p>
Однако если со временем сокращать скорость обучения алгоритма (learning rate), то мы будем приходить всё к более точному решению, так как градиент будет не так сильно реагировать на нетипичные данные. Авторы адаптивного градиента (Adaptive Gradient, AdaGrad) предлагают использовать сумму всех предыдущих градиентов, чтобы уменьшать последовательно скорости обучения:

</p><img src="https://habrastorage.org/files/701/5e7/a3c/7015e7a3c1cd4b548cfc50ccfbe0cc69.jpg"/>
<p>
Таким образом, мы получаем полезные свойства алгоритма:
</p><ul>
<li>Более гладкий спуск к минимуму (скорость обучения уменьшается со временем); </li>
<li>Альфа для каждой характеристики рассчитывается индивидуально (что очень важно для sparse данных, где большинство характеристик встречаются очень редко);</li>
<li>В расчете альфы учитывается, насколько сильно менялся параметр (w) характеристики: чем сильнее менялся раньше, тем меньше будет меняться в будущем.</li>
</ul><p>
Адаптивный градиент начинает обучаться так же, как обычная логистическая регрессия, но потом приходит к более низкому минимуму:

</p><img src="https://habrastorage.org/files/05a/76f/6de/05a76f6dea6a421498037c92fc9ad697.jpg"/>
<p>
По факту если обычный стохастический градиентный спуск повторять много раз на одних и тех же данных, то он может приблизиться к AdaGrad. Однако это займёт больше итераций. В своей модели я использовал комбинацию этих техник: 5 итераций с обычным алгоритмом, а потом один с AdaGrad. Вот результаты:

</p><img src="https://habrastorage.org/files/f4e/148/819/f4e148819a4e4b90a932e5290ef0479c.jpg"/>

<h5>3.2. Трансформация данных для логистической регрессии</h5><p>
Чтобы алгоритм логистической регрессии мог работать с данными (а они представлены в формате текстовых значений), их необходимо преобразовать в скалярные значения. Я использовал one-hot encoding: преобразование текстовых характеристик в матрицу NxM cо значениями «0» и «1», где N – это кол-во записей, а M – кол-во уникальных значений у этой характеристики. Основные причины – сохраняется максимум информации, а feature hashing позволяет быстро работать с пространствами с миллионами характеристик в рамках логистической регрессии.

</p>

<h4>4. Матрикснет – сборка в домашних условиях</h4><p>
После того, как я получил неплохие результаты с логистической регрессией, необходимо было дальше улучшаться. Мне было интересно разобраться в том, как работает Матрикснет Яндекса, более того, я ожидал от него хороших результатов (всё-таки это его одна из задач – предсказывать CTR внутри Яндекса для рекламной выдачи в поиске). Если собрать всю публично доступную информацию о Матрикснете (см. полный список ссылок в конце статьи), то можно воссоздать его алгоритм. Я не претендую на то, что именно в таком виде алгоритм работает внутри Яндекса, я этого не знаю, но в своём коде и в этой статье использовал все найденные «фишки» и намёки на них.
</p><p>
Пойдём по порядку, из чего состоит Мактрикснет:
</p><ol>
<li>Базовый элемент – Classification and Regression Tree (CART);</li>
<li>Основной алгоритм – Gradient Boosting Machine (GBM)</li>
<li>Апдейт основного алгоритма – Stochastic Gradient Boosting Machine (SGBM).</li>
</ol>
<h5>4.1. Classification and Regression Tree (CART)</h5><p>
Это один из </p><a href="http://en.wikipedia.org/wiki/Decision_tree_learning#Types">классических алгоритмов дерева решений</a><p>, о котором уже писали на Хабре (например, </p><a href="http://habrahabr.ru/post/215453/">тут</a><p> и </p><a href="http://habrahabr.ru/post/116385/">тут</a><p>). Поэтому не буду уходить в детали, лишь напомню принцип работы и основные термины.

</p><img src="https://habrastorage.org/files/050/58b/d13/05058bd13ba64e2c96dd5152d63d104c.jpg"/>
<p>
Таким образом, у дерева решений есть следующие параметры, определяющие алгоритм:
</p><ul>
<li>Условия сплита на листы (<b>x_1≥0.5</b>) </li>
<li>«Высота» дерева (кол-во уровней с условиями, в примере выше их 2) </li>
<li>Правило прогнозирования <b>p</b> (в примере выше используется математическое ожидание) </li>
</ul>
<h6>4.1.1. Как определить характеристику для условия сплита</h6><p>
На каждом уровне нам необходимо определить характеристику для условия сплита, который разделит плоскость таким образом, что мы будем делать более точные прогнозы.

</p><img src="https://habrastorage.org/files/815/f11/3a9/815f113a99f34643a59e562a32e29acc.jpg"/>
<p>
Таким образом проходим по всем характеристикам и возможным сплитам и выбираем те точки, где у нас будет ниже значение NLL после сплита (в примере выше это, конечно, </p><b>x2</b><p>). Для определения сплита обычно используются другие функции – </p><a href="http://en.wikipedia.org/wiki/Decision_tree_learning#Metrics">information gain и Gini impurity</a><p>, однако в нашем случае мы выбираем NLL, так как именно это просили нас минимизировать в задании (см. описание задания в разделе №1).

</p><h6>4.1.2. Регуляризация в CART</h6><p>
В случае с CART обычно необходима регуляризация, чтобы не делать слишком уверенные предсказания там, где мы на самом деле не уверены. Яндекс предлагает скорректировать формулу предсказания следующим образом:

</p><img src="https://habrastorage.org/files/2b7/f36/c5b/2b7f36c5bbde43adb4ef9a3a4a9ea095.jpg"/>
<p>
Где </p><b>N</b><p> – кол-во значений в листе, а лямбда – регуляризационный параметр (специалисты Мактрикснета рекомендуют 100, но нужно тестировать под каждую задачу отдельно). Таким образом, чем меньше у нас значений в листе, тем меньше наш алгоритм будет уверен в предсказываемом значении.

</p><h6>4.1.3. Забывчивые деревья (Oblivious Trees)</h6><p>
В Матрикснете вместо классического подхода, когда после сплита по </p><b>x1</b><p> следующий уровень дерева не может делить данные по этой характеристике, используются т.н. забывчивые деревья, которые могут в рамках нескольких уровней сплитить значения по одной и той же характеристике (как будто «забывая», что по ней сплит уже был сделан).

</p><img src="https://habrastorage.org/files/78a/683/34d/78a68334de9542978ac4b627a3c40dc6.jpg"/>
<p>
Использование этого типа деревьев, на мой взгляд, обосновано прежде всего в тех случаях, когда в данных есть 1-2 характеристики, более узкие сплиты по которым дают лучше результаты, чем сплиты по ещё не использованным характеристикам.

</p><h5>4.2. Gradient Boosting Machine</h5><p>
Gradient Boosting Machine (GBM) – это использование леса коротких деревьев, где каждое последующее не пытается угадать целевое значение, а пытается улучшить прогноз предыдущих деревьев. Рассмотрим простой пример с регрессией и деревьями с высотой 1 (можем делать только 1 сплит в рамках каждого дерева).

</p><img src="https://habrastorage.org/files/ff3/593/145/ff35931454574cd88a4bb3073da5c980.jpg"/>
<p>
По сути каждое дерево помогает оптимизировать функцию квадратичной ошибки:

</p><img src="https://habrastorage.org/files/d8c/552/fd8/d8c552fd8c404732aa9ecf1a4ea2ca39.jpg"/>
<p>
Основное преимущество GBM по сравнению с CART – это меньшая вероятность переобучения, так как мы даём прогнозы на основании листов с бОльшим кол-вом значений. В Матрикснете в GBM «высота» дерева зависит от текущей итерации: начинается с 1, каждые 10 итераций увеличивается ещё на 1, но никогда не превышает 6. Этот подход позволяет существенно разогнать алгоритм, не сильно ухудшая результат на первых итерациях. Я тестировал этот вариант, но остановился на варианте, когда переход на следующий уровень осуществляется после исчерпания возможностей на предыдущем.

</p><h6>4.2.1. GBM для классификации</h6><p>
При работе с классификацией каждое последующее дерево должно улучшать предсказание предыдущего, однако делать это нужно таким образом, чтобы деревья работали на одну задачу – классификацию с помощью сигмоид функции. В этом случае удобно представить задачу оптимизации такой же, как в логистической регрессии, а именно:

</p><img src="https://habrastorage.org/files/c6c/c6c/171/c6cc6c171f1f40218b7622678b1ba72c.jpg"/>
<p>
Интересным решением Яндекса является то, что в качестве первоначального прогноза </p><b>p0</b><p> используются предсказания логистической регрессии, а произведения весов и характеристик (wTx) — в качестве одной из характеристик.

</p><h5>4.3. Stochastic GBM</h5><p>
Stochastic GBM отличается от обычного GBM тем, что каждое дерево считается на выборке из данных (10-50%). Это помогает одновременно убить 2-х зайцев – ускорить работу алгоритма (иначе нам бы пришлось просчитывать результат для всех 40,4 млн. тренировочных записей), а также в значительной степени избавиться от проблемы перетренированности.</p><p>
Финальный результат:

</p><img src="https://habrastorage.org/files/c9a/8cc/aa4/c9a8ccaa4ada429a8261ad00555b0409.jpg"/>
<p>
Как видно, всё-таки самую большую оптимизацию даёт работа с данными, а не сами по себе алгоритмы. Хотя с обычной логистической регрессией было бы сложно подняться выше 30-го места, где счёт идёт на каждую десятитысячную.

</p><h4>5. Попытки ускорить машинное обучение в Python</h4><p>
Это был мой первый проект реализации алгоритмов машинного обучения собственными силами, то есть в коде, которым делал предсказания, не используются готовые сторонние решения, все алгоритмы и манипуляции с данными происходят в открытую, что позволило мне лучше понять суть задачи и принципы работы этих инструментов. Однако я пользовался наработками: логистическая регрессия в значимой степени – </p><a href="https://kaggle2.blob.core.windows.net/forum-message-attachments/56731/1699/fast_solution.py?sv=2012-02-12&amp;se=2015-03-26T22%3A00%3A28Z&amp;sr=b&amp;sp=r&amp;sig=sEs40bqPiqGawCpXp92qTucsT9n9ru1E3JUqIWCSiXU%3D">код</a><p> Абнишека на Kaggle, Матрикснет заимствует небольшую часть CART из </p><a href="https://seat.massey.ac.nz/personal/s.r.marsland/Code/Ch12/dtree.py">кода</a><p> Стивена Маршала к книге Machine Learning: Algorithmic Perspective.
</p><p>
С точки зрения реализации, я начинал экспериментировать с задачей в R, но потом быстро отказался от него, так как практически невозможно работать с большими данными. Python был выбрал из-за простоты синтаксиса и наличия большого кол-ва библиотек для машинного обучения.
</p><p>
Основная проблема CPython – он ОЧЕНЬ медленный (хотя и гораздо быстрее R). Однако есть много опций для его ускорения, в результате использовал следующие:
</p><ul>
<li>PyPy – JIT-компилятор, который позволяет ускорить стандартный CPython x20 раз, основная проблема – нет практически никаких библиотек для работы с вычислениями (NumPyPy всё ещё в разработке), всё нужно писать без них. Прекрасно подходило для реализации логистической регрессии со стохастическим градиентным спуском, как в нашем случае; </li>
<li>Numba – декораторы  <a href="http://habrahabr.ru/users/jit/" class="user_link">jit</a> позволяют пре-компилировать некоторые функции (принцип, как в PyPy), однако остальной код может использовать все преимущества библиотек CPython. Большой плюс – для прекомпилированных функций можно снимать GIL (Global Interpreter Lock) и использовать несколько cpu. Что я и использовал для ускорения Матрикснета. Проблема у Numba такая же, как и у PyPy, — нет поддержки никаких библиотек, главное отличие – у Numba есть реализация некоторых функций NumPy. </li>
</ul><p>
До Cython не дошёл, так как старался ускориться минимальной кровью, но, думаю, в следующий раз проще переходить сразу на GPGPU с помощью Theano / Numba.

</p><a href="https://github.com/Ivanopolo/Avazu_Code">Полный код всех преобразований с данными и самими алгоритмами обучения лежит здесь.</a><p> Disclaimer: код не оптимизирован, предназначен только для изучения самих алгоритмов.
</p><p>
Если вы нашли любые неточности или ошибки в статье или коде, пишите в личку.
</p><p>
Ссылки на источники, использовавшиеся для статьи и при работе над алгоритмами:
</p>
      <p class="clear"/>
    </div>

    
  </div></body></html>