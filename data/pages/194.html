<html><body><div><div class="entry-content"><p>I’ve now migrated the asynchronous download logic in 0install from Python to OCaml + Lwt.
This post records my experiences using Lwt, plus some comparisons with Python’s coroutines.
As usual, the examples will be based on the real-world case of 0install, rather than on idealised text-book examples.</p>



<p><strong>Table of Contents</strong></p>



<h2 id="the-problem">The problem</h2>

<p>What happens when you download a program using <a href="http://0install.net/">0install</a>? To make this concrete, let’s look at the downloads that happen when you enter the command:</p>

<pre><code>$ 0launch http://simamo.de/0install/armagetronad.xml
</code></pre>

<p>to make this happen:</p>

<p><a href="http://armagetronad.org/"><img class="border center" src="/blog/images/armagetron.png"/></a></p>

<p>If the software is cached, we run immediately. If not, we need to download some things first. The steps are (you don’t need to remember this!):</p>

<ol>
  <li>Download <a href="http://simamo.de/0install/armagetronad.xml">http://simamo.de/0install/armagetronad.xml</a>. This feed just points us at various sub-feeds that say where to get implementations for each platform.</li>
  <li>I’m on Linux (64 bit), so on my computer we next download (concurrently) the four suggested sub-feeds:
    
  </li>
  <li>Once we have these, we find a dependency on the library <a href="http://simamo.de/0install/armagetronad-libs-Linux-x86_64.xml">http://simamo.de/0install/armagetronad-libs-Linux-x86_64.xml</a>, so we download that XML file too.</li>
  <li>Once all the XML downloads have finished, we select a version of Armagetron (0.2.8.3.2 in my case) and its (single) declared library (version 0.3-pre0.1570 here).</li>
  <li>We download these two tar.bz2 files (concurrently) and unpack them to the cache.</li>
  <li>Finally, we run (as described in previous posts).</li>
</ol>

<p>That’s the overall process. It’s not totally trivial, but in fact some of the steps are complex in themselves. For example, to download a single feed (XML) file:</p>

<ol>
  <li>We download the feed from the given URL.</li>
  <li>We check the GPG signature on the feed. If we don’t have the GPG key, we must download that next.</li>
  <li>Once we’ve checked that the signature is valid, we need to decide whether to trust it. We download information from the key information server.</li>
  <li>Depending on the user’s configuration and the key information server’s response, we may show a confirmation dialog to the user.</li>
</ol>

<p>In addition:</p>

<ol>
  <li>If the primary site (simamo.de) fails, we try the mirror site <a href="http://roscidus.com/0mirror/">http://roscidus.com/0mirror/</a> instead.</li>
  <li>If the primary site is slow, we ask the mirror too. If the primary then succeeds, we cancel the mirror download. If the mirror succeeds first, we use the information we got from it to find more required downloads, but also continue waiting for the primary (which may have more up-to-date information).</li>
  <li>If the key information server is slow, we display the dialog to the user anyway, but update the display if the information arrives while the user is pondering.</li>
  <li>We never use more than 2 HTTP connections per site at the same time. Further requests are queued.</li>
</ol>

<p>In other words, there’s quite a bit of logic here (and there’s still the archive downloads too…). How can we make sure all these operations happen at the right time and that errors are handled correctly?</p>

<h2 id="solutions">Solutions</h2>

<p>Note that the challenge here is not to use multiple CPUs in parallel to perform some calculation faster, but to schedule and manage multiple concurrent operations. The effects of concurrency will be visible (i.e. the behaviour of the code, such as whether we decide to contact the mirror server or not, depends on how quickly things happen). Therefore, some non-determinism is unavoidable. However, we want to minimise it.</p>

<p>Most languages provide some kind of low-level <em>preemptive multi-threading</em> support, e.g. Python’s <code>threading.create</code>, Haskell’s <code>forkIO</code>, OCaml’s <code>Thread.create</code>, Java’s <code>java.lang.Thread</code> and Go’s <code>go</code>. In these cases, all threads always run in parallel by default. If two threads access a shared or global variable without appropriate locking, the program will occasionally fail in ways that are hard to reproduce or diagnose.</p>

<p>Of course, these languages provide mutexes, channels, etc to make correct code possible, but this style is unsafe by default. For example, if a multi-threaded program uses some library from multiple threads, and the author of the library was only thinking about single-threaded use, then you likely have a subtle, hard-to-trigger bug.</p>

<p>Let’s consider a simplified example: we want to fetch information from the key information server, parse it, and confirm the key with the user (this server says things like “This key belongs to a registered Debian developer”).
Within each thread, we might do something like this:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">confirm_key</span><span class="p">(</span><span class="n">feed</span><span class="p">):</span>
</span><span class="line">	<span class="n">data</span> <span class="o">=</span> <span class="n">download_key_info</span><span class="p">(</span><span class="n">feed</span><span class="o">.</span><span class="n">sig</span><span class="p">)</span>
</span><span class="line">	<span class="n">info</span> <span class="o">=</span> <span class="n">parse_key_info</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span><span class="line">	<span class="n">ok</span> <span class="o">=</span> <span class="n">confirm_with_gui</span><span class="p">(</span><span class="n">feed</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
</span><span class="line">	<span class="k">if</span> <span class="n">ok</span><span class="p">:</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Probably this code will crash if two keys are downloaded close together, because the graphical toolkit library used to show the GUI isn’t thread-safe. But there could be similar issues with any code we call (is <code>parse_key_info</code> thread-safe, for example? What about the XML parser it uses? etc).</p>

<p>So how can we avoid these problems? Rust uses its linear types to prevent concurrent access to mutable state, which looks very useful. For other languages, we can use <em>cooperative multi-threading</em>.</p>

<p>The idea here is that instead of running threads in parallel by default and remembering to add locks wherever necessary, we run only one thread at a time, switching between threads only at explicitly marked points.</p>

<p>The two schemes have different failure modes. If you forget the locking in preemptive code, you get subtle bugs. If you forget to allow task switching in a cooperative system, the program may run slower (waiting when it could be getting on with something). For an application like 0install, cooperative makes far more sense. Just making downloads and GUI interaction alone concurrent is really all we need.</p>

<h3 id="callbacks">Callbacks</h3>

<p>The simplest scheme to implement uses <em>callbacks</em>. You tell the system to start an operation, and give it a function to call on success:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">confirm_key</span><span class="p">(</span><span class="n">feed</span><span class="p">):</span>
</span><span class="line">	<span class="n">download_key_info</span><span class="p">(</span><span class="n">feed</span><span class="o">.</span><span class="n">sig</span><span class="p">,</span> <span class="n">key_info_downloaded</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">key_info_downloaded</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
</span><span class="line">	<span class="n">info</span> <span class="o">=</span> <span class="n">parse_key_info</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span><span class="line">	<span class="n">confirm_with_gui</span><span class="p">(</span><span class="n">feed</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">trust_confirmed</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">trust_confirmed</span><span class="p">(</span><span class="n">ok</span><span class="p">):</span>
</span><span class="line">	<span class="k">if</span> <span class="n">ok</span><span class="p">:</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Here, we don’t know what other functions may be called in the time between us calling <code>download_key_info</code> and the <code>key_info_downloaded</code> callback, but while our code is executing we know that we have complete control. For example, it’s not a problem if <code>parse_key_info</code> here only supports single threading.</p>

<p>Callbacks have two major problems:</p>

<ul>
  <li>They make the code messy and hard to read.</li>
  <li>They handle exceptions poorly.</li>
</ul>

<p>Imagine that <code>download_key_info</code> has succeeded. It calls the <code>key_info_downloaded</code> callback. That calls <code>parse_key_info</code>, which throws an exception. The exception gets returned to <code>download_key_info</code> which can’t do anything useful with it. Probably, it gets logged and the program hangs, waiting for a call to <code>trust_confirmed</code> that will never happen.</p>

<h3 id="promises">Promises</h3>

<p><em>Promises</em> are a nice alternative to callbacks. When you start an operation, you get a <em>promise</em> for the result. A promise is a place-holder for a result that will arrive in the future. Without any special syntax, using promises might look something like this:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">confirm_key</span><span class="p">(</span><span class="n">feed</span><span class="p">):</span>
</span><span class="line">	<span class="n">data_promise</span> <span class="o">=</span> <span class="n">download_key_info</span><span class="p">(</span><span class="n">feed</span><span class="o">.</span><span class="n">sig</span><span class="p">)</span>
</span><span class="line">	<span class="k">return</span> <span class="n">data_promise</span><span class="o">.</span><span class="n">when_fulfilled</span><span class="p">(</span><span class="n">key_info_downloaded</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">key_info_downloaded</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
</span><span class="line">	<span class="n">info</span> <span class="o">=</span> <span class="n">parse_key_info</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span><span class="line">	<span class="n">confirmation_promise</span> <span class="o">=</span> <span class="n">confirm_with_gui</span><span class="p">(</span><span class="n">feed</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
</span><span class="line">	<span class="k">return</span> <span class="n">confirmation_promise</span><span class="o">.</span><span class="n">when_fulfilled</span><span class="p">(</span><span class="n">trust_confirmed</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="nf">trust_confirmed</span><span class="p">(</span><span class="n">ok</span><span class="p">):</span>
</span><span class="line">	<span class="k">if</span> <span class="n">ok</span><span class="p">:</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The function <code>promise.when_fulfilled(callback)</code> immediately returns a new promise for the (future) result of the callback.</p>

<p>Internally, a promise initially contains a queue for callbacks. When the promise is (eventually) resolved to a value, the callbacks are all run and the queue is replaced by the value. Attempting to attach any further callbacks just runs them immediately on the value.</p>

<p>Promises have a number of advantages over callbacks. For example, you can store promises of results in lists, pass them to other functions, etc. One particular advantage is exception handling. Consider our previous example:</p>

<ol>
  <li><code>confirm_key</code> returns a promise for the result of <code>key_info_downloaded</code>.</li>
  <li><code>download_key_info</code> downloads the data successfully, fulfilling <code>data_promise</code>.</li>
  <li><code>key_info_downloaded</code> is called (it was attached to <code>data_promise</code> as a callback).</li>
  <li><code>parse_key_info</code> throws an exception, which is caught by the promise system.</li>
  <li>This “breaks” the promise returned by <code>confirm_key</code>.</li>
  <li>Whoever was waiting for <code>confirm_key</code> gets notified of the exception.</li>
</ol>

<p>Notice that instead of propagating uncaught exceptions <em>backwards</em> (to <code>download_key_info</code>), we propagate them <em>forwards</em> (to whoever is waiting for the result). The result is that, as in synchronous programming, an exception is not lost just because someone in the chain doesn’t handle it.</p>

<p>A natural next step is to introduce some simpler syntax for this…</p>

<h3 id="ocaml-lwt">OCaml Lwt</h3>

<p>OCaml provides a couple of libraries for handling promises - <a href="http://ocsigen.org/lwt/">Lwt</a> and <a href="https://realworldocaml.org/v1/en/html/concurrent-programming-with-async.html">Jane Street’s Async</a>. I’ve only looked at Lwt, although they seem <a href="http://lists.ocaml.org/pipermail/wg-parallel/2013-April/000000.html">fairly similar</a>.</p>

<p>The terminology I introduced above I learnt from E (which also has <a href="http://www.erights.org/elib/concurrency/refmech.html">sophisticated distributed promises</a>). I find the E terms more natural, but here’s a conversion table:</p>

<table class="table">
  <thead>
    <tr>
      <th>E term</th>
      <th>Lwt term</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Promise</td>
      <td>Thread</td>
    </tr>
    <tr>
      <td>Fulfilled promise</td>
      <td>Returned thread</td>
    </tr>
    <tr>
      <td>Broken promise</td>
      <td>Failed thread</td>
    </tr>
    <tr>
      <td>Unresolved promise</td>
      <td>Sleeping thread</td>
    </tr>
    <tr>
      <td>Resolver</td>
      <td>Waker</td>
    </tr>
  </tbody>
</table>

<p>In particular, while a Lwt thread is still working to produce a result, the thread is said to be “sleeping”, which I find rather awkward. A resolver/waker is the object used by the maker of the promise to resolve it.</p>

<p>Anyway, switching to OCaml and using Lwt without the syntax extensions, we get this:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="ocaml"><span class="line"><span class="k">let</span> <span class="n">confirm_key</span> <span class="n">feed</span> <span class="o">=</span>
</span><span class="line">  <span class="k">let</span> <span class="n">data_promise</span> <span class="o">=</span> <span class="n">download_key_info</span> <span class="n">feed</span><span class="o">.</span><span class="n">signature</span> <span class="k">in</span>
</span><span class="line">  <span class="nn">Lwt</span><span class="p">.</span><span class="n">bind</span> <span class="n">data_promise</span> <span class="o">(</span><span class="k">fun</span> <span class="n">data</span> <span class="o">-&gt;</span>
</span><span class="line">    <span class="k">let</span> <span class="n">info</span> <span class="o">=</span> <span class="n">parse_key_info</span> <span class="n">data</span> <span class="k">in</span>
</span><span class="line">    <span class="k">let</span> <span class="n">confirmation_promise</span> <span class="o">=</span> <span class="n">confirm_with_gui</span> <span class="n">feed</span> <span class="n">info</span> <span class="k">in</span>
</span><span class="line">    <span class="nn">Lwt</span><span class="p">.</span><span class="n">bind</span> <span class="n">confirmation_promise</span> <span class="o">(</span><span class="k">fun</span> <span class="n">ok</span> <span class="o">-&gt;</span>
</span><span class="line">      <span class="k">if</span> <span class="n">ok</span> <span class="k">then</span> <span class="o">...</span>
</span><span class="line">    <span class="o">)</span>
</span><span class="line">  <span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Here, <code>Lwt.bind promise callback</code> is like our previous <code>promise.when_fulfilled(callback)</code>. Again, <code>confirm_key</code> returns a promise (thread) for the final result.</p>

<p>To make things more convenient, you can enable the Lwt syntax extension. This provides thread-aware alternatives to several built-in OCaml keywords:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="ocaml"><span class="line"><span class="k">let</span> <span class="n">confirm_key</span> <span class="n">feed</span> <span class="o">=</span>
</span><span class="line">  <span class="k">lwt</span> <span class="n">data</span> <span class="o">=</span> <span class="n">download_key_info</span> <span class="n">feed</span><span class="o">.</span><span class="n">signature</span> <span class="k">in</span>
</span><span class="line">  <span class="k">let</span> <span class="n">info</span> <span class="o">=</span> <span class="n">parse_key_info</span> <span class="n">data</span> <span class="k">in</span>
</span><span class="line">  <span class="k">lwt</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">confirm_with_gui</span> <span class="n">feed</span> <span class="n">info</span> <span class="k">in</span>
</span><span class="line">  <span class="k">if</span> <span class="n">ok</span> <span class="k">then</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>As if by magic, our asynchronous code now reads like the original synchronous code! <code>lwt</code> is the new way to do <code>Lwt.bind</code>, by analogy with the ordinary <code>let</code> construct. We just have to remember that we give up control between evaluating the right-hand side of the assignment (getting a thread/promise for the data) and assigning the actual data on the left-hand side. For example, another function might change a global variable while we’re waiting for the promise to resolve.</p>

<p><a href="http://ocsigen.org/lwt/api/Pa_lwt">The other short-cuts</a> are <code>try_lwt</code>, <code>for_lwt</code>, <code>while_lwt</code> and <code>match_lwt</code>, which do what you’d expect. As a bonus, <code>try_lwt</code> also adds a <code>finally</code> construct and <code>for_lwt</code> adds iteration over sequences - both are missing for the core OCaml language.</p>

<p>There are plenty of functions for combining or creating threads in various ways, including:</p>

<ul>
  <li><code>let thread, waker = Lwt.wait ()</code> explicitly creates a promise and a resolver for it.</li>
  <li><code>Lwt.return value</code> evaluates to a returned thread, which is useful if something needs a thread type but you already have the value.</li>
  <li><code>Lwt.choose threads</code> waits until one of the given threads is ready.</li>
  <li><code>Lwt.join threads</code> returns a single thread that returns when all of the given threads have returned.</li>
  <li><code>Lwt_list.map_s fn items</code> applies <code>fn</code> to each item, waiting for the resulting thread to resolve before doing the next item.</li>
  <li><code>Lwt_list.map_p fn items</code> as above, but runs all the threads in parallel.</li>
</ul>

<h3 id="python-generators">Python generators</h3>

<p>Python has an unusual solution to the problem, using its <em>generator functions</em>.</p>

<p>A generator is any function which contains a <code>yield</code>. Running such a function gets you an iterator. Each time you ask for a value from the iterator, the generator runs until the next <code>yield</code> to produce the result. It is suspended until the next call. Generators were originally just an easy way to produce sequences, for example:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">count</span><span class="p">():</span>
</span><span class="line">  <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class="line">  <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class="line">    <span class="k">yield</span> <span class="n">x</span>
</span><span class="line">    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class="line">
</span><span class="line"><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">count</span><span class="p">():</span>
</span><span class="line">  <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>However, this ability to suspend and resume functions is obviously useful for cooperative multi-threading too and, like many other people, I used them to create a such a system (back in 2004). The version used in the Python version of 0install was designed for Python 2.3, but since then Python has added many useful new features so I’ll describe the recent <a href="http://www.python.org/dev/peps/pep-3156/">Tulip/asyncio</a> system rather than my own, even though I haven’t actually used it much.</p>

<p>The idea is that every time you need to wait, you yield the promise (“future” in Python terminology) you’re waiting for. When it’s ready, the scheduler will resume your generator function with the result:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">confirm_key</span><span class="p">(</span><span class="n">feed</span><span class="p">):</span>
</span><span class="line">	<span class="n">data</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">download_key_info</span><span class="p">(</span><span class="n">feed</span><span class="o">.</span><span class="n">sig</span><span class="p">)</span>
</span><span class="line">	<span class="n">info</span> <span class="o">=</span> <span class="n">parse_key_info</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span><span class="line">	<span class="n">ok</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">confirm_with_gui</span><span class="p">(</span><span class="n">feed</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
</span><span class="line">	<span class="k">if</span> <span class="n">ok</span><span class="p">:</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="examples">Examples</h2>

<p>Both systems (OCaml Lwt and Python generators) work very well in general. Here are some (slightly simplified) examples from 0install.</p>

<h3 id="following-a-recipe">Following a recipe</h3>

<p>Some downloads require collecting files from several places (e.g. an upstream tarball and some files to patch it with). We want to download the files in parallel, but execute the steps (e.g. unpacking downloads into the target directory) in series. My solution is that each download is a thread that performs the download and then returns a lazy thunk that applies it:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="ocaml"><span class="line">  <span class="c">(* Start all the downloads in parallel. *)</span>
</span><span class="line">  <span class="k">let</span> <span class="n">downloads</span> <span class="o">=</span> <span class="n">steps</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">do_step</span> <span class="k">in</span>
</span><span class="line">
</span><span class="line">  <span class="c">(* Now iterate over the steps in series. *)</span>
</span><span class="line">  <span class="n">downloads</span> <span class="o">|&gt;</span> <span class="nn">Lwt_list</span><span class="p">.</span><span class="n">iter_s</span> <span class="o">(</span><span class="k">fun</span> <span class="n">unpack</span> <span class="o">-&gt;</span>
</span><span class="line">    <span class="c">(* Wait for download *)</span>
</span><span class="line">    <span class="k">lwt</span> <span class="n">unpack</span> <span class="o">=</span> <span class="n">unpack</span> <span class="k">in</span>
</span><span class="line">    <span class="c">(* Apply download to directory *)</span>
</span><span class="line">    <span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">unpack</span>
</span><span class="line">  <span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Note that we start unpacking as soon as possible; we only wait when the next thing to unpack isn’t downloaded yet.</p>

<p>This was my first attempt at a Python version with asyncio:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># Start all downloads in parallel</span>
</span><span class="line"><span class="n">downloads</span> <span class="o">=</span> <span class="p">[</span><span class="n">do_step</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">]</span>
</span><span class="line">
</span><span class="line"><span class="c"># Wait for all downloads to complete</span>
</span><span class="line"><span class="n">tasks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">downloads</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="c"># Unpack each download in sequence</span>
</span><span class="line"><span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
</span><span class="line">	<span class="n">unpack</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
</span><span class="line">	<span class="k">yield from</span> <span class="n">unpack</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>An interesting difference is that OCaml threads, once started, continue to run by themselves even if no-one is waiting for the result. When the OCaml code is waiting for the first download to complete, the other downloads are still going on. But if we <code>yield from</code> just the first download in Python, only that download makes progress. In the code above, therefore, the Python waits for all downloads to complete before it starts unpacking.</p>

<p>You can fix this by wrapping the future with <code>async</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># Start all downloads in parallel</span>
</span><span class="line"><span class="n">downloads</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">async</span><span class="p">(</span><span class="n">do_step</span><span class="p">(</span><span class="n">step</span><span class="p">))</span> <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">]</span>
</span><span class="line">
</span><span class="line"><span class="c"># Now iterate over the steps in series.</span>
</span><span class="line"><span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downloads</span><span class="p">:</span>
</span><span class="line">	<span class="c"># Wait for download</span>
</span><span class="line">	<span class="n">unpack</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">d</span>
</span><span class="line">	<span class="c"># Apply download to directory</span>
</span><span class="line">	<span class="k">yield from</span> <span class="n">unpack</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="downloading-with-libcurl">Downloading with libcurl</h3>

<p>libcurl doesn’t provide Lwt support. However, it is thread-safe. We can therefore use the <code>Lwt_preemptive</code> module to run each download in a real operating system thread and get a promise for its completion. In addition, we use a <code>Lwt_pool</code> to keep up to two Curl connections per site (queuing further requests).</p>

<p>When it’s our turn to run, we also start a five second timer if the caller wanted to be notified if the download is slow. This is used when downloading the small XML metadata files so the mirror can be tried in parallel (for archives, we only try the mirror if the download actually fails).</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="ocaml"><span class="line"><span class="k">let</span> <span class="n">make_site</span> <span class="n">max_per_site</span> <span class="o">=</span>
</span><span class="line">  <span class="k">let</span> <span class="n">create_connection</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">return</span> <span class="o">(</span><span class="nn">Curl</span><span class="p">.</span><span class="n">init</span> <span class="bp">()</span><span class="o">)</span> <span class="k">in</span>
</span><span class="line">  <span class="k">let</span> <span class="n">pool</span> <span class="o">=</span> <span class="nn">Lwt_pool</span><span class="p">.</span><span class="n">create</span> <span class="n">max_per_site</span> <span class="n">create_connection</span> <span class="k">in</span>
</span><span class="line">
</span><span class="line">  <span class="k">object</span>
</span><span class="line">    <span class="k">method</span> <span class="n">schedule_download</span> <span class="o">?</span><span class="n">if_slow</span> <span class="n">channel</span> <span class="n">url</span> <span class="o">=</span>
</span><span class="line">      <span class="nn">Lwt_pool</span><span class="p">.</span><span class="n">use</span> <span class="n">pool</span> <span class="o">(</span><span class="k">fun</span> <span class="n">connection</span> <span class="o">-&gt;</span>
</span><span class="line">	<span class="k">let</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">if_slow</span> <span class="o">|&gt;</span> <span class="n">pipe_some</span> <span class="o">(</span><span class="k">fun</span> <span class="n">if_slow</span> <span class="o">-&gt;</span>
</span><span class="line">	  <span class="k">let</span> <span class="n">timeout</span> <span class="o">=</span> <span class="nn">Lwt_timeout</span><span class="p">.</span><span class="n">create</span> <span class="mi">5</span> <span class="n">if_slow</span> <span class="k">in</span>
</span><span class="line">	  <span class="nn">Lwt_timeout</span><span class="p">.</span><span class="n">start</span> <span class="n">timeout</span><span class="o">;</span>
</span><span class="line">	  <span class="nc">Some</span> <span class="n">timeout</span><span class="o">;</span>
</span><span class="line">	<span class="o">)</span> <span class="k">in</span>
</span><span class="line">
</span><span class="line">	<span class="k">let</span> <span class="n">download</span> <span class="bp">()</span> <span class="o">=</span>
</span><span class="line">	  <span class="n">download_in_thread</span> <span class="n">connection</span> <span class="n">channel</span> <span class="n">url</span> <span class="k">in</span>
</span><span class="line">
</span><span class="line">	<span class="k">try_lwt</span>
</span><span class="line">	  <span class="nn">Lwt_preemptive</span><span class="p">.</span><span class="n">detach</span> <span class="n">download</span> <span class="bp">()</span>
</span><span class="line">	<span class="k">finally</span>
</span><span class="line">	  <span class="n">timeout</span> <span class="o">|&gt;</span> <span class="n">if_some</span> <span class="nn">Lwt_timeout</span><span class="p">.</span><span class="n">stop</span><span class="o">;</span>
</span><span class="line">	  <span class="nn">Lwt</span><span class="p">.</span><span class="n">return</span> <span class="bp">()</span>
</span><span class="line">    <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The <code>download_in_thread</code> function also needs to send progress notifications to back to Lwt, which it does using <code>Lwt_preemptive.run_in_main</code>.</p>

<p>Update: note that recent versions of ocurl support Lwt directly.</p>

<p>Python provides the <code>ThreadPoolExecutor</code>, which combines pooling and preemptive threading. This makes it a bit harder to start the timer (which should happen cooperatively), so we need to use <code>call_soon_threadsafe</code>, which is like Lwt’s <code>run_in_main</code>. Python doesn’t seem to provide a way to manage the HTTP connections with the pool - I guess you have to do that manually.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">class</span> <span class="nc">Site</span><span class="p">:</span>
</span><span class="line">    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_per_site</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
</span><span class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_per_site</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="k">def</span> <span class="nf">schedule_download</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">if_slow</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
</span><span class="line">        <span class="n">thread_ready</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">()</span>
</span><span class="line">        <span class="k">def</span> <span class="nf">timer</span><span class="p">():</span>
</span><span class="line">            <span class="c"># Wait for an executor to be ready...</span>
</span><span class="line">            <span class="k">yield from</span> <span class="n">thread_ready</span>
</span><span class="line">            <span class="c"># Wait until 5 seconds into the download</span>
</span><span class="line">            <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class="line">            <span class="c"># Notify that the download is slow</span>
</span><span class="line">            <span class="n">if_slow</span><span class="p">()</span>
</span><span class="line">
</span><span class="line">        <span class="k">def</span> <span class="nf">run_in_thread</span><span class="p">():</span>
</span><span class="line">            <span class="n">connection</span> <span class="o">=</span> <span class="o">...</span>
</span><span class="line">            <span class="k">if</span> <span class="n">if_slow</span><span class="p">:</span>
</span><span class="line">                <span class="n">loop</span><span class="o">.</span><span class="n">call_soon_threadsafe</span><span class="p">(</span><span class="n">thread_ready</span><span class="o">.</span><span class="n">set_result</span><span class="p">,</span>
</span><span class="line">					  <span class="bp">True</span><span class="p">)</span>
</span><span class="line">            <span class="n">download_in_thread</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">        <span class="n">download</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="p">,</span> <span class="n">run_in_thread</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">        <span class="n">t</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">async</span><span class="p">(</span><span class="n">timer</span><span class="p">())</span>
</span><span class="line">	<span class="k">try</span><span class="p">:</span>
</span><span class="line">	    <span class="k">yield from</span> <span class="n">download</span>
</span><span class="line">	<span class="k">finally</span><span class="p">:</span>
</span><span class="line">	    <span class="n">t</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="error-handling-in-key-look-ups">Error handling in key look-ups</h3>

<p>Lwt does have a gotcha for error handling. Consider this code:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="ocaml"><span class="line"><span class="k">let</span> <span class="n">confirm_key</span> <span class="n">feed</span> <span class="o">=</span>
</span><span class="line">  <span class="k">lwt</span> <span class="n">data</span> <span class="o">=</span>
</span><span class="line">    <span class="k">try</span>
</span><span class="line">      <span class="n">download_key_info</span> <span class="n">feed</span><span class="o">.</span><span class="n">signature</span>
</span><span class="line">    <span class="k">with</span> <span class="nc">Failure</span> <span class="n">msg</span> <span class="o">-&gt;</span>
</span><span class="line">      <span class="n">log_warning</span> <span class="s2">"Failed to download key info: %s"</span> <span class="n">msg</span><span class="o">;</span>
</span><span class="line">      <span class="nn">Lwt</span><span class="p">.</span><span class="n">return</span> <span class="bp">[]</span>
</span><span class="line">  <span class="k">in</span>
</span><span class="line">  <span class="k">let</span> <span class="n">info</span> <span class="o">=</span> <span class="n">parse_key_info</span> <span class="n">data</span> <span class="k">in</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>If querying the key info server fails, we want to log the error but continue with the confirmation, just with an empty list of hints.</p>

<p>Something I really dislike is code that looks right, compiles without warnings, works when you test it, and then fails in the field. Unfortunately, this code does just that. Even if you unit-test the error case!</p>

<p>The bug occurs because we accidentally used <code>try</code> rather than <code>try_lwt</code>. <code>download_key_info</code> successfully returns a promise for the information, so the <code>with</code> clause isn’t triggered and we exit the try block. Then Lwt waits for the promise to resolve so it can set <code>data</code>.
When unit-testing, you’ll probably raise the test exception immediately and so the <code>with</code> block does get called.</p>

<p>By contrast, Python’s generators have no such problems:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">confirm_key</span><span class="p">(</span><span class="n">feed</span><span class="p">):</span>
</span><span class="line">	<span class="k">try</span><span class="p">:</span>
</span><span class="line">		<span class="n">data</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">download_key_info</span><span class="p">(</span><span class="n">feed</span><span class="o">.</span><span class="n">sig</span><span class="p">)</span>
</span><span class="line">	<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
</span><span class="line">		<span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">"Failed to download key info: </span><span class="si">%s</span><span class="s">"</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
</span><span class="line">		<span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line">	<span class="n">info</span> <span class="o">=</span> <span class="n">parse_key_info</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span><span class="line">	<span class="n">ok</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">confirm_with_gui</span><span class="p">(</span><span class="n">feed</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
</span><span class="line">	<span class="k">if</span> <span class="n">ok</span><span class="p">:</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The other Lwt constructs don’t have this problem because the type-system will detect the error (e.g. if you use <code>match</code> instead of <code>match_lwt</code>), but with <code>try</code> and <code>try_lwt</code> the type signatures are the same.</p>

<h3 id="failing-over-to-a-mirror">Failing over to a mirror</h3>

<p>We start downloading each XML feed from its primary site, but trigger a timeout task if it takes too long.
The timeout starts a download from the mirror, which happens in parallel with the original download attempt.
We don’t want to start the timer immediately because the download might get queued due to the rate limiting code, so we just pass the <code>if_slow</code> trigger to the download system (see above).</p>

<p>Because we need to report intermediate results (e.g. we have downloaded a possibly-slightly-old version from the mirror), we return a pair of the new result and a promise for the next update (or <code>None</code> if this is the last). In a similar way, we return errors as a pair of the current error (e.g. “mirror failed”) and a promise for the other result.</p>

<p><code>Lwt.choose</code> selects the result of the first task from a list to resolve. When choosing between the primary and the mirror however we ignore the result and test explicitly, because we need to know which one it was.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
</pre></td><td class="code"><pre><code class="ocaml"><span class="line"><span class="k">let</span> <span class="n">timeout_task</span><span class="o">,</span> <span class="n">timeout_waker</span> <span class="o">=</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">wait</span> <span class="bp">()</span> <span class="k">in</span>
</span><span class="line"><span class="k">let</span> <span class="n">if_slow</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">wakeup</span> <span class="n">timeout_waker</span> <span class="o">`</span><span class="n">timeout</span> <span class="k">in</span>
</span><span class="line">
</span><span class="line"><span class="k">let</span> <span class="n">primary</span> <span class="o">=</span> <span class="n">do_primary_download</span> <span class="o">~</span><span class="n">if_slow</span> <span class="n">feed</span> <span class="k">in</span>
</span><span class="line">
</span><span class="line"><span class="c">(* Download just the upstream feed, unless it takes too long... *)</span>
</span><span class="line"><span class="n">match_lwt</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">choose</span> <span class="o">[</span><span class="n">primary</span><span class="o">;</span> <span class="n">timeout_task</span><span class="o">]</span> <span class="k">with</span>
</span><span class="line"><span class="o">|</span> <span class="o">`</span><span class="n">ok</span> <span class="n">result</span> <span class="o">-&gt;</span>
</span><span class="line">    <span class="o">`</span><span class="n">update</span> <span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span> <span class="o">|&gt;</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">return</span>
</span><span class="line"><span class="o">|</span> <span class="o">`</span><span class="n">problem</span> <span class="n">msg</span> <span class="o">-&gt;</span>
</span><span class="line">    <span class="k">let</span> <span class="n">mirror</span> <span class="o">=</span> <span class="n">do_mirror_download</span> <span class="bp">()</span> <span class="k">in</span>
</span><span class="line">    <span class="o">`</span><span class="n">problem</span> <span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">wait_for_mirror</span> <span class="n">mirror</span><span class="o">))</span> <span class="o">|&gt;</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">return</span>
</span><span class="line"><span class="o">|</span> <span class="o">`</span><span class="n">timeout</span> <span class="o">-&gt;</span>
</span><span class="line">    <span class="c">(* OK, maybe it's just being slow... *)</span>
</span><span class="line">    <span class="n">log_info</span> <span class="s2">"Feed download from %s is taking a long time."</span> <span class="n">feed_url</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">    <span class="c">(* Start downloading from mirror... *)</span>
</span><span class="line">    <span class="k">let</span> <span class="n">mirror</span> <span class="o">=</span> <span class="n">do_mirror_download</span> <span class="bp">()</span> <span class="k">in</span>
</span><span class="line">
</span><span class="line">    <span class="c">(* Wait for a result from either *)</span>
</span><span class="line">    <span class="n">lwt</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">choose</span> <span class="o">[</span><span class="n">primary</span><span class="o">;</span> <span class="n">mirror</span><span class="o">]</span> <span class="k">in</span>
</span><span class="line">
</span><span class="line">    <span class="k">match</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">state</span> <span class="n">primary</span> <span class="k">with</span>
</span><span class="line">    <span class="o">|</span> <span class="nn">Lwt</span><span class="p">.</span><span class="nc">Fail</span> <span class="n">msg</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">msg</span>
</span><span class="line">    <span class="o">|</span> <span class="nn">Lwt</span><span class="p">.</span><span class="nc">Sleep</span> <span class="o">-&gt;</span>
</span><span class="line">	<span class="c">(* The mirror finished first *)</span>
</span><span class="line">	<span class="k">begin</span> <span class="n">match_lwt</span> <span class="n">mirror</span> <span class="k">with</span>
</span><span class="line">	<span class="o">|</span> <span class="o">`</span><span class="n">ok</span> <span class="n">result</span> <span class="o">-&gt;</span>
</span><span class="line">	    <span class="n">log_info</span> <span class="s2">"Mirror succeeded, but will continue to wait for primary"</span><span class="o">;</span>
</span><span class="line">	    <span class="o">`</span><span class="n">update</span> <span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">wait_for_primary</span> <span class="n">primary</span><span class="o">))</span> <span class="o">|&gt;</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">return</span>
</span><span class="line">	<span class="o">|</span> <span class="o">`</span><span class="n">problem</span> <span class="n">msg</span> <span class="o">-&gt;</span>
</span><span class="line">	    <span class="n">log_info</span> <span class="s2">"Mirror download failed: %s"</span> <span class="n">msg</span><span class="o">;</span>
</span><span class="line">	    <span class="n">wait_for_primary</span> <span class="n">primary</span> <span class="k">end</span>
</span><span class="line">    <span class="o">|</span> <span class="nn">Lwt</span><span class="p">.</span><span class="nc">Return</span> <span class="n">v</span> <span class="o">-&gt;</span>
</span><span class="line">	<span class="c">(* The primary returned first *)</span>
</span><span class="line">	<span class="k">match</span> <span class="n">v</span> <span class="k">with</span>
</span><span class="line">	<span class="o">|</span> <span class="o">`</span><span class="n">ok</span> <span class="n">result</span> <span class="o">-&gt;</span>
</span><span class="line">	    <span class="nn">Lwt</span><span class="p">.</span><span class="n">cancel</span> <span class="n">mirror</span><span class="o">;</span>
</span><span class="line">	    <span class="o">`</span><span class="n">update</span> <span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span> <span class="o">&gt;</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">return</span>
</span><span class="line">	<span class="o">|</span> <span class="o">`</span><span class="n">problem</span> <span class="n">msg</span> <span class="o">-&gt;</span>
</span><span class="line">	    <span class="o">`</span><span class="n">problem</span> <span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">wait_for_mirror</span> <span class="n">mirror</span><span class="o">))</span> <span class="o">|&gt;</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">return</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>I’m too lazy to translate this into modern Python, but I think it’s clear that a direct translation would be easy enough.</p>

<p>The main problem would be losing OCaml’s type checking, which ensures that we handle all the possible error conditions. I simplified the outcomes into just <code>ok</code> and <code>problem</code> above, but in the real code we also distinguish <code>replay_attack</code>, <code>aborted_by_user</code> and <code>no_trusted_keys</code>, and handle them differently. For example, a “replay attack” from the mirror (where the mirror gives us a version older than one we’ve already seen) is ignored, whereas it’s reported if it comes from the primary.</p>

<h2 id="switches">Switches</h2>

<p>The <code>Lwt_switch</code> module provides a way to group a set of activities together so you can stop them all at once.
You create a switch and pass it to all the various setup functions you call.
When you’re done, call <code>Lwt_switch.turn_off</code> to kill everything.
For example, each download goes to a temporary file. To ensure they’re all deleted afterwards:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="ocaml"><span class="line"><span class="k">let</span> <span class="n">switch</span> <span class="o">=</span> <span class="nn">Lwt_switch</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span> <span class="k">in</span>
</span><span class="line"><span class="k">try_lwt</span>
</span><span class="line">  <span class="k">let</span> <span class="n">tmpfile</span> <span class="o">=</span> <span class="n">download</span> <span class="o">~</span><span class="n">switch</span> <span class="n">url</span> <span class="k">in</span>
</span><span class="line">  <span class="o">...</span>
</span><span class="line"><span class="k">finally</span>
</span><span class="line">  <span class="nn">Lwt_switch</span><span class="p">.</span><span class="n">turn_off</span> <span class="n">switch</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>It’s easy to attach whatever finalisation code you want to a switch, e.g.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="ocaml"><span class="line"><span class="k">let</span> <span class="n">download</span> <span class="o">~</span><span class="n">switch</span> <span class="n">url</span> <span class="o">=</span>
</span><span class="line">  <span class="k">let</span> <span class="n">tmpfile</span> <span class="o">=</span> <span class="n">make_temp_file</span> <span class="bp">()</span> <span class="k">in</span>
</span><span class="line">  <span class="nn">Lwt_switch</span><span class="p">.</span><span class="n">add_hook</span>
</span><span class="line">    <span class="o">(</span><span class="nc">Some</span> <span class="n">switch</span><span class="o">)</span>
</span><span class="line">    <span class="o">(</span><span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="nn">Unix</span><span class="p">.</span><span class="n">unlink</span> <span class="n">tmpfile</span><span class="o">;</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">return</span> <span class="bp">()</span><span class="o">);</span>
</span><span class="line">  <span class="o">...</span>
</span><span class="line">  <span class="nn">Lwt</span><span class="p">.</span><span class="n">return</span> <span class="n">tmpfile</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Then it doesn’t matter whether we download successfully, raise an exception inside of <code>download</code>, raise an exception after calling <code>download</code>, etc; the file always gets deleted.</p>

<p>Perhaps this is bad API design and I shouldn’t rely on <code>download</code>’s caller to clean up the file if <code>download</code> fails, but it does seem convenient. To avoid mistakes, I used <code>~switch</code> to force the caller to pass a switch instead of the more normal <code>?switch</code> (where use of a switch is optional).</p>

<h2 id="parallel-tasks">Parallel tasks</h2>

<p>Regular OCaml lets you assign multiple variables at once using <code>and</code>, so that all the expressions are evaluated in a context where none of them is bound. For example, to switch the names of two variables:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ocaml"><span class="line"><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
</span><span class="line"><span class="ow">and</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="k">in</span>
</span><span class="line"><span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Lwt uses this syntax with <code>lwt</code> to create multiple tasks in parallel and then wait for all of them. For example, when we run a command we may want to collect the standard output and standard error separately but in parallel (if we did them in series, the process might get stuck trying to write its stderr while we were trying to read its stdout, if the Unix pipe gets full). With this syntax, we can get the two strings with just:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ocaml"><span class="line"><span class="k">lwt</span> <span class="n">stdout</span> <span class="o">=</span> <span class="nn">Lwt_io</span><span class="p">.</span><span class="n">read</span> <span class="n">child</span><span class="o">#</span><span class="n">stdout</span>
</span><span class="line"><span class="ow">and</span> <span class="n">stderr</span> <span class="o">=</span> <span class="nn">Lwt_io</span><span class="p">.</span><span class="n">read</span> <span class="n">child</span><span class="o">#</span><span class="n">stderr</span> <span class="k">in</span>
</span><span class="line"><span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="conclusions">Conclusions</h2>

<p>0install needs to manage several fairly complex concurrent download activities, including error handling, timeouts and mirrors. Cooperative multi-threading allows us to support this easily with a low risk of race conditions.</p>

<p>Python and OCaml both provide powerful and easy-to-use cooperative threading support. I think Python’s generators are slightly easier to understand for beginners, but I find both quite easy to use. I find Lwt’s terminology a little confusing, but thinking of threads as promises seems to help. Both systems handle exceptions sensibly.</p>

<p>Comparing Python and OCaml code, they’re pretty similar. Both make it easy to start and manage cooperative threads, to interact with pools of preemptively threaded code (e.g. libcurl) and to handle errors.
Using OCaml variants for network errors rather than exceptions is useful; this ensures that all such errors are handled. If you rely on exceptions instead then things mostly work, but watch out for using <code>try</code> rather than <code>try_lwt</code>.</p>

<p>The old 0install Python code used a custom system built on top of Python’s generators, but Python’s new asyncio module provides a standardised replacement (asyncio will be added to the standard library in Python 3.4). Lwt has been around for a while and is already available from Linux distribution repositories.</p>

<p>Lwt also integrates with several other libraries, including GTK, OBus (D-BUS bindings) and React. Lwt seems very reliable. The only bug I found in Lwt so far was <a href="https://github.com/ocsigen/lwt/issues/20">a pipe read failure on Windows</a>, which they quickly fixed.</p>
</div>


  </div></body></html>