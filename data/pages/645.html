<html><body><div><div class="post-content">
    <p>While it’s not always the case that every Python program you write will require a rigorous performance analysis, it is reassuring to know that there are a wide variety of tools in Python’s ecosystem that one can turn to when the time arises.</p>

<p>Analyzing a program’s performance boils down to answering 4 basic questions:</p>

<ol>
  <li>How fast is it running?</li>
  <li>Where are the speed bottlenecks?</li>
  <li>How much memory is it using?</li>
  <li>Where is memory leaking?</li>
</ol>

<p>Below, we’ll dive into the details of answering these questions using some awesome tools.</p>

<h3 id="coarse-grain-timing-with-time">Coarse grain timing with time</h3>

<p>Let’s begin by using a quick and dirty method of timing our code: the good old unix utility <code>time</code>.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">$ time python yourprogram.py

real    0m1.028s
user    0m0.001s
sys     0m0.003s</code></pre></figure>

<p>The meaning between the three output measurements are detailed in this <a href="http://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">stackoverflow article</a>, but in short</p>

<ul>
  <li>real - refers to the actual elasped time</li>
  <li>user - refers to the amount of cpu time spent outside of kernel</li>
  <li>sys - refers to the amount of cpu time spent inside kernel specific functions</li>
</ul>

<p>You can get a sense of how many cpu cycles your program used up regardless of other programs running on the system by adding together the <em>sys</em> and <em>user</em> times.</p>

<p>If the sum of <em>sys</em> and <em>user</em> times is much less than <em>real</em> time, then you can guess that most your program’s performance issues are most likely related to IO waits.</p>

<h3 id="fine-grain-timing-with-a-timing-context-manager">Fine grain timing with a timing context manager</h3>

<p>Our next technique involves direct instrumentation of the code to get access to finer grain timing information. Here’s a small snippet I’ve found invaluable for making ad-hoc timing measurements:</p>

<p><code>timer.py</code></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">import time

class Timer(object):
    def __init__(self, verbose=False):
        self.verbose = verbose

    def __enter__(self):
        self.start = time.time()
        return self

    def __exit__(self, *args):
        self.end = time.time()
        self.secs = self.end - self.start
        self.msecs = self.secs * 1000  # millisecs
        if self.verbose:
            print 'elapsed time: %f ms' % self.msecs</code></pre></figure>

<p>In order to use it, wrap blocks of code that you want to time with Python’s <code>with</code> keyword and this <code>Timer</code> context manager. It will take care of starting the timer when your code block begins execution and stopping the timer when your code block ends.</p>

<p>Here’s an example use of the snippet:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">from timer import Timer
from redis import Redis
rdb = Redis()

with Timer() as t:
    rdb.lpush("foo", "bar")
print "=&gt; elasped lpush: %s s" % t.secs

with Timer() as t:
    rdb.lpop("foo")
print "=&gt; elasped lpop: %s s" % t.secs</code></pre></figure>

<p>I’ll often log the outputs of these timers to a file in order to see how my program’s performance evolves over time.</p>

<h3 id="line-by-line-timing-and-execution-frequency-with-a-profiler">Line-by-line timing and execution frequency with a profiler</h3>

<p>Robert Kern has a nice project called <a href="http://packages.python.org/line_profiler/">line_profiler</a> which I often use to see how fast and how often each line of code is running in my scripts.</p>

<p>To use it, you’ll need to install the python package via pip:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">$ pip install line_profiler</code></pre></figure>

<p>Once installed you’ll have access to a new module called “line_profiler” as well as an executable script “kernprof.py”.</p>

<p>To use this tool, first modify your source code by decorating the function you want to measure with the <code>@profile</code> decorator. Don’t worry, you don’t have to import anyting in order to use this decorator. The <code>kernprof.py</code> script  automatically injects it into your script’s runtime during execution.</p>

<p><code>primes.py</code></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">@profile
def primes(n): 
    if n==2:
        return [2]
    elif n&lt;2:
        return []
    s=range(3,n+1,2)
    mroot = n ** 0.5
    half=(n+1)/2-1
    i=0
    m=3
    while m &lt;= mroot:
        if s[i]:
            j=(m*m-3)/2
            s[j]=0
            while j&lt;half:
                s[j]=0
                j+=m
        i=i+1
        m=2*i+3
    return [2]+[x for x in s if x]
primes(100)</code></pre></figure>

<p>Once you’ve gotten your code setup with the <code>@profile</code> decorator, use <code>kernprof.py</code> to run your script.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">$ kernprof.py -l -v fib.py</code></pre></figure>

<p>The <code>-l</code> option tells kernprof to inject the <code>@profile</code> decorator into your script’s builtins, and <code>-v</code> tells kernprof to display timing information once you’re script finishes. Here’s one the output should look like for the above script:</p>

<pre><code>Wrote profile results to primes.py.lprof
Timer unit: 1e-06 s

File: primes.py
Function: primes at line 2
Total time: 0.00019 s

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     2                                           @profile
     3                                           def primes(n): 
     4         1            2      2.0      1.1      if n==2:
     5                                                   return [2]
     6         1            1      1.0      0.5      elif n&lt;2:
     7                                                   return []
     8         1            4      4.0      2.1      s=range(3,n+1,2)
     9         1           10     10.0      5.3      mroot = n ** 0.5
    10         1            2      2.0      1.1      half=(n+1)/2-1
    11         1            1      1.0      0.5      i=0
    12         1            1      1.0      0.5      m=3
    13         5            7      1.4      3.7      while m &lt;= mroot:
    14         4            4      1.0      2.1          if s[i]:
    15         3            4      1.3      2.1              j=(m*m-3)/2
    16         3            4      1.3      2.1              s[j]=0
    17        31           31      1.0     16.3              while j&lt;half:
    18        28           28      1.0     14.7                  s[j]=0
    19        28           29      1.0     15.3                  j+=m
    20         4            4      1.0      2.1          i=i+1
    21         4            4      1.0      2.1          m=2*i+3
    22        50           54      1.1     28.4      return [2]+[x for x in s if x]
</code></pre>

<p>Look for lines with a high amount of hits or a high time interval. These are the areas where optimizations can yield the greatest improvements.</p>

<h3 id="how-much-memory-does-it-use">How much memory does it use?</h3>

<p>Now that we have a good grasp on timing our code, let’s move on to figuring out how much memory our programs are using. Fortunately for us, Fabian Pedregosa has implemented a nice <a href="https://github.com/fabianp/memory_profiler">memory profiler</a> modeled after Robert Kern’s line_profiler.</p>

<p>First install it via pip:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">$ pip install -U memory_profiler
$ pip install psutil</code></pre></figure>

<p>(Installing the <code>psutil</code> package here is recommended because it greatly improves the performance of the memory_profiler).</p>

<p>Like line_profiler, memory_profiler requires that you decorate your function of interest with an <code>@profile</code> decorator like so:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">@profile
def primes(n): 
    ...
    ...</code></pre></figure>

<p>To see how much memory your function uses run the following:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">$ python -m memory_profiler primes.py</code></pre></figure>

<p>You should see output that looks like this once your program exits:</p>

<pre><code>Filename: primes.py

Line #    Mem usage  Increment   Line Contents
==============================================
     2                           @profile
     3    7.9219 MB  0.0000 MB   def primes(n): 
     4    7.9219 MB  0.0000 MB       if n==2:
     5                                   return [2]
     6    7.9219 MB  0.0000 MB       elif n&lt;2:
     7                                   return []
     8    7.9219 MB  0.0000 MB       s=range(3,n+1,2)
     9    7.9258 MB  0.0039 MB       mroot = n ** 0.5
    10    7.9258 MB  0.0000 MB       half=(n+1)/2-1
    11    7.9258 MB  0.0000 MB       i=0
    12    7.9258 MB  0.0000 MB       m=3
    13    7.9297 MB  0.0039 MB       while m &lt;= mroot:
    14    7.9297 MB  0.0000 MB           if s[i]:
    15    7.9297 MB  0.0000 MB               j=(m*m-3)/2
    16    7.9258 MB -0.0039 MB               s[j]=0
    17    7.9297 MB  0.0039 MB               while j&lt;half:
    18    7.9297 MB  0.0000 MB                   s[j]=0
    19    7.9297 MB  0.0000 MB                   j+=m
    20    7.9297 MB  0.0000 MB           i=i+1
    21    7.9297 MB  0.0000 MB           m=2*i+3
    22    7.9297 MB  0.0000 MB       return [2]+[x for x in s if x]
</code></pre>

<h3 id="ipython-shortcuts-for-lineprofiler-and-memoryprofiler">IPython shortcuts for line_profiler and memory_profiler</h3>

<p>A little known feature of <code>line_profiler</code> and <code>memory_profiler</code> is that both programs have shortcut commands accessible from within IPython. All you have to do is type the following within an IPython session:</p>

<pre><code>%load_ext memory_profiler
%load_ext line_profiler
</code></pre>

<p>Upon doing so you’ll have access to the magic commands <code>%lprun</code> and <code>%mprun</code> which behave similarly to their command-line counterparts. The major difference here is that you won’t need to decorate your to-be-profiled functions with the <code>@profile</code> decorator. Just go ahead and run the profiling directly within your IPython session like so:</p>

<pre><code>In [1]: from primes import primes
In [2]: %mprun -f primes primes(1000)
In [3]: %lprun -f primes primes(1000)
</code></pre>

<p>This can save you a lot of time and effort since none of your source code needs to be modified in order to use these profiling commands.</p>

<h3 id="wheres-the-memory-leak">Where’s the memory leak?</h3>

<p>The cPython interpreter uses reference counting as it’s main method of keeping track of memory. This means that every object contains a counter, which is incremented when a reference to the object is stored somewhere, and decremented when a reference to it is deleted. When the counter reaches zero, the cPython interpreter knows that the object is no longer in use so it deletes the object and deallocates the occupied memory.</p>

<p>A memory leak can often occur in your program if references to objects are held even though the object is no longer in use.</p>

<p>The quickest way to find these “memory leaks” is to use an awesome tool called <a href="http://mg.pov.lt/objgraph/">objgraph</a> written by Marius Gedminas. This tool allows you to see the number of objects in memory and also locate all the different places in your code that hold references to these objects.</p>

<p>To get started, first install <code>objgraph</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">pip install objgraph</code></pre></figure>

<p>Once you have this tool installed, insert into your code a statement to invoke the debugger:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">import pdb; pdb.set_trace()</code></pre></figure>

<h5 id="which-objects-are-the-most-common">Which objects are the most common?</h5>

<p>At run time, you can inspect the top 20 most prevalent objects in your program by running:</p>

<pre><code>(pdb) import objgraph
(pdb) objgraph.show_most_common_types()

MyBigFatObject             20000
tuple                      16938
function                   4310
dict                       2790
wrapper_descriptor         1181
builtin_function_or_method 934
weakref                    764
list                       634
method_descriptor          507
getset_descriptor          451
type                       439
</code></pre>

<h5 id="which-objects-have-been-added-or-deleted">Which objects have been added or deleted?</h5>

<p>We can also see which objects have been added or deleted between two points in time:</p>

<pre><code>(pdb) import objgraph
(pdb) objgraph.show_growth()
.
.
.
(pdb) objgraph.show_growth()   # this only shows objects that has been added or deleted since last show_growth() call

traceback                4        +2
KeyboardInterrupt        1        +1
frame                   24        +1
list                   667        +1
tuple                16969        +1
</code></pre>

<h5 id="what-is-referencing-this-leaky-object">What is referencing this leaky object?</h5>

<p>Continuing down this route, we can also see where references to any given object is being held. Let’s take as an example the simple program below:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">x = [1]
y = [x, [x], {"a":x}]
import pdb; pdb.set_trace()</code></pre></figure>

<p>To see what is holding a reference to the variable <code>x</code>, run the <code>objgraph.show_backref()</code> function:</p>

<pre><code>(pdb) import objgraph
(pdb) objgraph.show_backref([x], filename="/tmp/backrefs.png")
</code></pre>

<p>The output of that command should be a PNG image stored at <code>/tmp/backrefs.png</code> and it should look something like this:</p>

<p><img src="/media/3011/backrefs.png" alt="back refrences"/></p>

<p>The box at the bottom with red lettering is our object of interest. We can see that it’s referenced by the symbol <code>x</code> once and by the list <code>y</code> three times. If <code>x</code> is the object causing a memory leak, we can use this method to see why it’s not automatically being deallocated by tracking down all of its references.</p>

<p>So to review, <a href="http://mg.pov.lt/objgraph/">objgraph</a> allows us to:</p>

<ul>
  <li>show the top N objects occupying our python program’s memory</li>
  <li>show what objects have been deleted or added over a period of time</li>
  <li>show all references to a given object in our script</li>
</ul>

<h3 id="effort-vs-precision">Effort vs precision</h3>

<p>In this post, I’ve shown you how to use several tools to analyze a python program’s performance. Armed with these tools and techniques you should have all the information required to track down most memory leaks as well as identify speed bottlenecks in a Python program.</p>

<p>As with many other topics, running a performance analysis means balancing the tradeoffs between effort and precision. When in doubt, implement the simplest solution that will suit your current needs.</p>

<h5 id="refrences">Refrences</h5>




    </div>

    
     
    
    </div></body></html>