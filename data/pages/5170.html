<html><body><div><div class="section-inner layoutSingleColumn"><h3 name="f3d9" id="f3d9" class="graf--h3 graf--first">Utilizing classes to create readable and maintainable project code with Python and Flask.</h3><p name="8f6f" id="8f6f" class="graf--p graf-after--h3">Given the freedom that Flask gives a developer, it’s very easy to create an application structure that leads to unmaintainable and unreadable code. I have found a structure that works for me when it comes to Flask projects, which keeps your project readable, testable, and maintainable — with very well defined entry points. When starting a project, define a folder structure as such:</p><pre name="fe19" id="fe19" class="graf--pre graf-after--p">/project<br/>    /app<br/>        /lib<br/>            /database<br/>                mysql.py<br/>                mongo.py<br/>            /queue<br/>                rabbit.py<br/>            /models<br/>                model.py<br/>        /config<br/>            config.py<br/>            development.json<br/>            production.json<br/>            test.json<br/>        /controllers<br/>            controller_a.py<br/>            controller_b.py<br/>/static<br/>/templates<br/>main.py</pre><p name="72a1" id="72a1" class="graf--p graf-after--pre">Our <em class="markup--em markup--p-em">main.py</em> is actually our route file, but also acts as an initializer for objects that we want to pass around. The <em class="markup--em markup--p-em">main.py</em> file would look as follows:</p><pre name="8d16" id="8d16" class="graf--pre graf-after--p">from flask import Flask</pre><pre name="c2fd" id="c2fd" class="graf--pre graf-after--pre">from app.controllers.controller_a import ControllerA<br/>from app.controllers.controller_b import ControllerB<br/>from app.lib.config import Config<br/>from app.lib.database import MySQL<br/>from app.lib.queue import Rabbit</pre><pre name="1d86" id="1d86" class="graf--pre graf-after--pre">if __name__ == ‘__main__’:<br/>    app = Flask(__name__)</pre><pre name="8939" id="8939" class="graf--pre graf-after--pre">    # load libs<br/>    Config = Config(os.environ['APP_ENVIRONMENT'])<br/>    MySQL = MySQL(Config.mysql)<br/>    Rabbit = Rabbit(Config.rabbit)</pre><pre name="949d" id="949d" class="graf--pre graf-after--pre">    # controllers<br/>    ControllerA = ControllerA(Config, MySQL, Rabbit)<br/>    ControllerB = ControllerB(Config, MySQL, Rabbit)</pre><pre name="ef35" id="ef35" class="graf--pre graf-after--pre">    # Define our routes below</pre><pre name="b616" id="b616" class="graf--pre graf-after--pre">    # handle interaction with the homepage and login/signup pages<br/>    app.add_url_rule(‘/’, ‘home’, <br/>                     ControllerA.index, methods=[‘GET’])<br/>    app.add_url_rule(‘/signup’, ‘signup’, <br/>                     ControllerA.signup, methods=[‘GET’, ‘POST’])<br/>    app.add_url_rule(‘/login’, ‘login’, <br/>                     ControllerA.signin, methods=[‘GET’, ‘POST’])</pre><pre name="8343" id="8343" class="graf--pre graf-after--pre">    # handle post interaction<br/>    app.add_url_rule(‘/posts’, ‘posts’, ControllerB.posts, <br/>                     methods=[‘GET’, ‘POST’, ‘PUT’, ‘DELETE’])<br/>    app.add_url_rule(‘/posts/&lt;int:post_id&gt;’, ‘posts’,<br/>                     ControllerB.posts, methods=[‘GET’])</pre><pre name="eae2" id="eae2" class="graf--pre graf-after--pre">    app.run(host=Config.host, port=Config.port, debug=Config.debug)</pre><p name="dd38" id="dd38" class="graf--p graf-after--pre">This way, there’s no need to apply decorators to the methods defined in the controller, as it’s simply a class that’s being called:</p><pre name="9ead" id="9ead" class="graf--pre graf-after--p">class ControllerA<br/>    def __init__(self):<br/>        pass</pre><pre name="ff9f" id="ff9f" class="graf--pre graf-after--pre">    def index(self):<br/>        pass</pre><pre name="c267" id="c267" class="graf--pre graf-after--pre">    def signup(self):<br/>        pass</pre><pre name="f895" id="f895" class="graf--pre graf-after--pre">    def signin(self):<br/>        pass</pre><pre name="c380" id="c380" class="graf--pre graf-after--pre">    def posts(self):<br/>        pass</pre><p name="8bd1" id="8bd1" class="graf--p graf-after--pre">While I have not explored the performance implications of this setup vs a more traditional setup, I can only imagine that not spinning up multiple objects per request, but having one set of objects warmed and ready to run would be far more advantageous performance-wise. Not only that, but your methods are now testable as well.</p><p name="727a" id="727a" class="graf--p graf-after--p graf--last">Would be interested in hearing what project structure you use, or your thoughts on this particular structure!</p></div></div></body></html>