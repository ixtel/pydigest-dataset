<html><body><div><div class="post-content">
    <p>As I was working on a signal processing project for <a href="http://www.equisense.com">Equisense</a>, I’ve come to need an equivalent
of the MatLab <a href="http://fr.mathworks.com/help/signal/ref/findpeaks.html"><code>findpeaks</code> function</a> in the Python world.</p>

<p>For those not familiar to digital signal processing, peak detection is as easy to understand as it sounds: this is the process of finding peaks - we also names them local maxima or local minima - in a signal. The MatLab DSP Toolbox makes this super easy with its <code>findpeaks</code> function. Saying your want to search local maxima in an audio signal, for example 2000 samples of the Laurent Garnier famous track Cripsy Bacon, all you have to do is:</p>

<p><code>cb = audioread('Crispy_Bacon.wav');
findpeaks(cb(50061:52060), 'MinPeakDistance', 100, 'MinPeakHeight', 0.04)
</code></p>

<figure>
  
  <img src="/assets/2015-11-01-findpeaks-in-python/matlab_findpeaks.png" alt="Plot of results from MatLab findpeaks"/>
  
  
    <figcaption>MatLab findpeaks in action on an audio sample. We've specified a minimum distance (100 samples) and a minimum height (0.04 amplitude) filters.</figcaption>
  
</figure>

<p>We can specify filtering options to the function so the peaks that do not interest us are discarded. All this is great, but we need something working in Python. In a perfect world it will give exactly the same output, so we have consistent results between our Python code and the MatLab code.</p>

<p>Contrary to other MatLab functions that have direct equivalents in the Numpy and Scipy scientific and processing packages, it is no easy task to get the same results from the Scipy <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.find_peaks_cwt.html"><code>find_peaks_cwt</code> function</a> that from the MatLab <code>findpeaks</code>. Even worse, the wavelet convolution approach of <code>find_peaks_cwt</code> is not straightforward to work with: it adds complexity that is of no use for well-filtered and noiseless signals.</p>

<p><code>import numpy as np
from scipy.signal import find_peaks_cwt
cb = np.array([-0.010223, ... ])
indexes = find_peaks_cwt(cb, np.arange(1, 550))
</code></p>

<figure>
  
  <img src="/assets/2015-11-01-findpeaks-in-python/find_peaks_cwt.png" alt="Plot of results from Scipy find_peaks_cwt"/>
  
  
    <figcaption>Scipy find_peaks_cwt on the same sample. I'm not sure how it works and I was not able to easily specify a minimum peak height filter.</figcaption>
  
</figure>

<p>Wondering how to make our algorithms works as simply with Python that they were in MatLab, I’ve search around the web for other peak detection algorithms available in Python. <a href="https://stackoverflow.com/questions/1713335/peak-finding-algorithm-for-python-scipy/">Stackoverflow</a> get me to <a href="https://gist.github.com/sixtenbe/1178136"><code>peakdetect</code></a>, a translation of a MatLab script. As it is clearly more trivial to use that <code>find_peaks_cwt</code>, it still won’t give you the same results that the MatLab <code>findpeaks</code> function. The algorithm don’t find all peaks on low sampled signals or on short samples, and don’t have either a support for minimum peak height filter.</p>

<p><code>import numpy as np
from peakdetect import peakdetect
cb = np.array([-0.010223, ... ])
peaks = peakdetect(cb, lookahead=100)
</code></p>

<figure>
  
  <img src="/assets/2015-11-01-findpeaks-in-python/peakdetect.png" alt="Plot of results from peakdetect"/>
  
  
    <figcaption>Sixtenbe peakdetect at work. Easy to use and great results, but miss filtering. Note it detects both local maxima and local minima.</figcaption>
  
</figure>

<p>Going ahead I’ve checkout the GNU Octave project, a processing-intended language quite similar to MatLab. The Octave-Forge repository hosts a digital signal processing package with a <a href="http://octave.sourceforge.net/signal/function/findpeaks.html"><code>findpeaks</code> function</a>. Bingo? Well, yes and no. The function have an appealing interface, with a great filtering support. But this is not a Python project: as you’ll find ways to call your Octave distribution from your Python code (see <a href="https://github.com/blink1073/oct2py">oct2py</a>), it surely won’t be effective at large scale and makes the requirements for your code more complex.</p>

<p><code>import numpy as np
from oct2py import octave
cb = np.array([-0.010223, ... ])
octave.eval("pkg load signal")
(peaks, indexes) = octave.findpeaks(cb, 'DoubleSided', 'MinPeakHeight', 0.04, 'MinPeakDistance', 100, 'MinPeakWidth', 0)
</code></p>

<figure>
  
  <img src="/assets/2015-11-01-findpeaks-in-python/octave_findpeaks.png" alt="Plot of results from Octave-Forge findpeaks"/>
  
  
    <figcaption>Octave-Forge findpeaks is doing great, with double sided results and extended filtering. But this is not a Python project.</figcaption>
  
</figure>

<p>As I was going to code a Python adaptation of the Octave-Force <code>findpeaks</code>, I finally found what I was searching: a Python native equivalent of the MatLab <code>findpeaks</code>, with minimum distance and height filtering support. I even found two!</p>

<p>The first is <a href="https://bitbucket.org/lucashnegri/peakutils">the PeakUtils package</a> by Lucas Hermann Negri which provides 1D peak detection utilities. Its <a href="http://pythonhosted.org/PeakUtils/reference.html#peakutils.peak.indexes"><code>indexes</code></a> function allows you to detect peaks with minimum height and distance filtering.</p>

<p><code>import numpy as np
import peakutils
cb = np.array([-0.010223, ... ])
indexes = peakutils.indexes(cb, thres=0.02/max(cb), min_dist=100)
</code></p>

<figure>
  
  <img src="/assets/2015-11-01-findpeaks-in-python/peakutils_indexes.png" alt="Plot of results from PeakUtils indexes"/>
  
  
    <figcaption>The PeakUtils indexes function is easy to use and allows to filter on an height threshold and on a minimum distance between peaks.</figcaption>
  
</figure>

<p>The second is published on a <a href="http://nbviewer.ipython.org/github/demotu/BMC/blob/master/notebooks/DetectPeaks.ipynb">jupyter notebook</a> and is written by Marcos Duarte. Not easy to find, but the greatest so far for what I need: the parameters for filtering are modeled after the MatLab <code>findpeaks</code> ones. It comes as a single source file and only depends on Numpy, so it is no big deal to integrate. And more importantly, it will consistently get you the same results than MalLab <code>findpeaks</code>!</p>

<p><code>import numpy as np
from detect_peaks import detect_peaks
cb = np.array([-0.010223, ... ])
indexes = detect_peaks(cb, mph=0.04, mpd=100)
</code></p>

<figure>
  
  <img src="/assets/2015-11-01-findpeaks-in-python/peakutils_indexes.png" alt="Plot of results from Marcos Duarte detect_peaks"/>
  
  
    <figcaption>As direct to use as the MatLab findpeaks, the detect_peaks function is a great choice as a Python substitute.</figcaption>
  
</figure>

<p>To avoid others the same roaming I’ve put on GitHub <a href="https://github.com/MonsieurV/py-findpeaks">an overview</a> of these findings. Let me know if you got another open-source alternatives so we update the list.</p>

<hr/>

<h4 id="edit-17th-november">Edit 17th November</h4>

<p>As Marcos Duarte pointed out on <a href="https://news.ycombinator.com/item?id=10524933">HN</a>, the PeakUtils <code>indexes</code> function was actually inspired by his implementation of <code>detect_peaks</code>, explaining the similar results. Moreover he notes that the PeakUtils comes with other convenient utilities, such as <code>baseline</code> or <code>interpolate</code>.</p>

<p>The <a href="http://pythonhosted.org/PeakUtils/reference.html#peakutils.peak.interpolate"><code>interpolate</code> function</a> enhances the peak resolution by fitting Gaussians or computing centroids. Taking the previous example, here how you get it work:</p>

<p><code>import numpy as np
import peakutils
cb = np.array([-0.010223, ... ])
indexes = peakutils.indexes(cb, thres=0.02/max(cb), min_dist=100)
# [ 333  693 1234 1600]
interpolatedIndexes = peakutils.interpolate(range(0, len(cb)), cb, ind=indexes)
# [  332.61234263   694.94831376  1231.92840845  1600.52446335]
</code></p>

<figure>
  
  <a href="/assets/2015-11-01-findpeaks-in-python/peakutils_interpolate.png">
  
  <img src="/assets/2015-11-01-findpeaks-in-python/peakutils_interpolate.png" alt="Plot of results from PeakUtils interpolate"/>
  
  </a>
  
  
    <figcaption>Near to be insensible in our case, the PeakUtils interpolate function allows a higher peak resolution.</figcaption>
  
</figure>

<p>This time before the peak resolution, the <a href="http://pythonhosted.org/PeakUtils/reference.html#peakutils.baseline.baseline"><code>baseline</code> function</a> will be very handy in presence of drifting signals or to deal with unwanted low-frequency phenomenon: it kind of <a href="http://www.nws.noaa.gov/os/csd/pds/PCU2/statistics/Stats/part2/Filter_HP.htm">high-pass filter</a> the signal. The PeakUtils documentation have a <a href="http://pythonhosted.org/PeakUtils/tutorial_a.html#estimating-and-removing-the-baseline">good example</a> of its use.</p>


  </div>
  
  
  
    </div></body></html>