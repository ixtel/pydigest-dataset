<html><body><div><div class="entry-content">
					<hr/>
<h2><span>Introduction</span></h2>
<h6>(This post continues on my older <a href="https://helentronica.wordpress.com/2014/09/04/quantum-mechanics-with-the-python/">post </a>on using Python in solving simple quantum mechanics problems)</h6>
<figure data-shortcode="caption" id="attachment_341" class="wp-caption alignright"><a href="https://helentronica.files.wordpress.com/2014/12/bull-dog-in-a-swing1.jpg"><img class=" wp-image-341" src="https://helentronica.files.wordpress.com/2014/12/bull-dog-in-a-swing1.jpg?w=208&amp;h=216" alt="A completely simple everyday example of harmonic motion on a pendulum"/></a><figcaption class="wp-caption-text">A completely simple everyday example of a harmonic motion on a pendulum</figcaption></figure>
<p>You have heard of harmonic oscillator in physics classroom. It is a simple mathematical tool to describe some kind of  repetitive motion, either it is pendulum, a kid on a sway, a kid on a spring or something else. As long as it goes back and forth in periodical way, it’s a harmonic oscillator. Usual way of solving HO  motion is classic Newton’s mechanics. We’d start with the basic equations of motion, something like <img src="https://s0.wp.com/latex.php?latex=%5Cddot%7Bx%7D%2B%5Comega%5E2+x+%3D+0&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\ddot{x}+\omega^2 x = 0" title="\ddot{x}+\omega^2 x = 0" class="latex"/>, where <em>x</em> is the spatial variable (it can be displacement in spring system, but also an angle for the pendulum case), and <img src="https://s0.wp.com/latex.php?latex=%5Comega&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\omega" title="\omega" class="latex"/> is a frequency of the oscillation. Solution is always some combination of sine and cosine function. The very same problem can be solved using quantum mechanics, i.e. Schrödinger equation. Solution in that case is weird, something completely contrary to our everyday experiences, but perfectly suitable for microcosmos of atoms and elementary particles. This kind of craziness I’ll try to present with help of programming language Python.</p>
<h2><span>Potential function</span></h2>
<p>We start again with her majesty, Schrödinger equation:</p>
<p><a href="https://helentronica.files.wordpress.com/2014/09/schrodinger1.png"><img class="  wp-image-229 aligncenter" src="https://helentronica.files.wordpress.com/2014/09/schrodinger1.png?w=215&amp;h=43" alt="schrodinger[1]"/></a></p>
<p>So, to make long story short: <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/> is a wave function associated with our particle – it has no meaning per se, but <img src="https://s0.wp.com/latex.php?latex=%5Cleft%7C%5Cpsi%28x%29%5Cright%7C%5E2&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\left|\psi(x)\right|^2" title="\left|\psi(x)\right|^2" class="latex"/> is a<em> probability</em> of finding the particle at the place <em>x</em>. Solving the equation will tell us this probability. Regarding other symbols, <em>m</em> is a mass of the particle, <em>E</em> is its energy, <img src="https://s0.wp.com/latex.php?latex=%5Chbar&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\hbar" title="\hbar" class="latex"/> is reduced Planck’s constant and 2 is just a number 2. <em>V(x)</em> is something interesting – it is the <em>potential function</em>. What does it mean? Potential is something that controls the particle. We are everyday controlled by the gravitational potential of our Earth – we all have a tendency to go down, we fall when standing free in the air. The higher we are, our potential energy is bigger, because the potential <em>V(x)</em>  is higher. Everything has a tendency to move to the lower potential, whether it is body in gravitational field, charged particle in electrical field or something third. No wonder, because the gradient of the potential, <img src="https://s0.wp.com/latex.php?latex=%5Cnabla+%5Ccdot+V%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\nabla \cdot V(x)" title="\nabla \cdot V(x)" class="latex"/>, is nothing more than a force, pulling the body towards the lower potential energy state.</p>
<figure data-shortcode="caption" id="attachment_409" class="wp-caption aligncenter"><a href="https://helentronica.files.wordpress.com/2014/12/vxho.png"><img class="size-medium wp-image-409" src="https://helentronica.files.wordpress.com/2014/12/vxho.png?w=300&amp;h=172" alt="Approximation of any ugly potential function as a pretty parabolic HO potential with a puppy."/></a><figcaption class="wp-caption-text">Approximation of any ugly potential function with a pretty parabolic HO potential with a puppy (from the Griffith’s <em>Introduction to QM</em>).</figcaption></figure>
<p>Potential function is a space dependent function. It varies with <em>x</em>, and it can vary in many different ways, like on the image above. It may be very hard to describe it mathematically in a nice way. But we don’t care for all x-s  in the world – we are interested in what happens in some constrained area, say, surrounding of this gap at <img src="https://s0.wp.com/latex.php?latex=x_0&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="x_0" title="x_0" class="latex"/>, which we will call <em>local minimum</em>. This is obviously the place where the force will pull the body to. If we want to approximate <em>V(x)</em> at this point we’ll do it by expanding Taylor’s series:</p>
<p><img src="https://s0.wp.com/latex.php?latex=V%28x%29+%3D+V%28x_0%29+%2B+%5Cfrac%7BdV%7D%7Bdx%7D%28x-x_0%29+%2B+%5Cfrac%7B1%7D%7B2%21%7D%5Cfrac%7Bd%5E2V%7D%7Bdx%5E2%7D%28x-x_0%29%5E2+%2B%5Cfrac%7B1%7D%7B3%21%7D%5Cfrac%7Bd%5E3V%7D%7Bdx%5E3%7D%28x-x_0%29%5E3+%2B+%5Cldots&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="V(x) = V(x_0) + \frac{dV}{dx}(x-x_0) + \frac{1}{2!}\frac{d^2V}{dx^2}(x-x_0)^2 +\frac{1}{3!}\frac{d^3V}{dx^3}(x-x_0)^3 + \ldots" title="V(x) = V(x_0) + \frac{dV}{dx}(x-x_0) + \frac{1}{2!}\frac{d^2V}{dx^2}(x-x_0)^2 +\frac{1}{3!}\frac{d^3V}{dx^3}(x-x_0)^3 + \ldots" class="latex"/></p>
<p>Now, since <img src="https://s0.wp.com/latex.php?latex=x_0&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="x_0" title="x_0" class="latex"/> is local minimum, we know that first derivative of <em>V(x)</em> will be zero.  Second derivative will remain, but any derivative of higher order will vanish. The first term, <img src="https://s0.wp.com/latex.php?latex=V%28x_0%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="V(x_0)" title="V(x_0)" class="latex"/> is constant and independent of <em>x</em> and can be ignored. Finally, we can shift our x-axis to the point where <img src="https://s0.wp.com/latex.php?latex=x_0&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="x_0" title="x_0" class="latex"/> is 0. Our potential function now looks like this: <img src="https://s0.wp.com/latex.php?latex=V%28x%29+%3D+%5Cfrac%7B1%7D%7B2%7D+k+x%5E2&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="V(x) = \frac{1}{2} k x^2" title="V(x) = \frac{1}{2} k x^2" class="latex"/>, where <em>k</em> is some constant of proportionality. Interestingly, potential energy of the body on the spring is exactly <img src="https://s0.wp.com/latex.php?latex=%5Cfrac%7B1%7D%7B2%7D+k+x%5E2&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\frac{1}{2} k x^2" title="\frac{1}{2} k x^2" class="latex"/> if <em>k</em> is the spring constant.</p>
<h2><span>Going the Python way</span></h2>
<p>In my <a href="https://helentronica.wordpress.com/2014/09/04/quantum-mechanics-with-the-python/">older post</a>, I used Python to solve some simple problems of quantum mechanics. The very same applies here. Firstly, I’ll define potential function, <em>V(x)</em>.  For every point x, the function checks whether x is within the region of HO. If it is, output value is  <img src="https://s0.wp.com/latex.php?latex=%5Cfrac%7B1%7D%7B2%7D+k+x%5E2&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\frac{1}{2} k x^2" title="\frac{1}{2} k x^2" class="latex"/>. Otherwise, output is some constant value.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate" title="">
def V(x):
    """
    Potential function in the Harmonic oscillator. Returns V = 0.5 k x^2 if |x|&amp;lt;L and 0.5*k*L^2 otherwise
    """    
    if abs(x)&lt;L:
        return 0.5*k*x**2
    else:
        return 0.5*k*L**2
</pre>
<h3><em>Equation solver</em></h3>
<p>Schrödinger’s equation is 2nd order differential equation and nobody with the clear mind wants to solve it by hand. Instead, normal people use Python embedded numerical solver <em>odeint() </em>from<em> </em><em>scipy.integrate</em> package. We’ll first rewrite this perverse equation as a system of two 1st order diff. equations by introducing a new variable <img src="https://s0.wp.com/latex.php?latex=bunny+%3A%3D+%5Cdot%7B%5Cpsi%7D&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="bunny := \dot{\psi}" title="bunny := \dot{\psi}" class="latex"/>, so that the system becomes:</p>
<p><img src="https://s0.wp.com/latex.php?latex=%5Cdot%7B%5Cpsi%7D+%3D+bunny&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\dot{\psi} = bunny" title="\dot{\psi} = bunny" class="latex"/></p>
<p><img src="https://s0.wp.com/latex.php?latex=%5Cdot%7Bbunny%7D+%3D+%5Cfrac%7B2m%7D%7B%5Chbar%5E2%7D+%28+V%28x%29+-+E+%29+%5Cpsi&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\dot{bunny} = \frac{2m}{\hbar^2} ( V(x) - E ) \psi" title="\dot{bunny} = \frac{2m}{\hbar^2} ( V(x) - E ) \psi" class="latex"/></p>
<p>Left sides of the equations, we will call them <em>states</em>, as they are representing the <em>state space</em> of the system. The <em>odeint() </em>will solve two of them at the same time and put the solutions in a 2×<em>length(x)</em> – sized array called <em>psi </em>(global variable here).  All this is done in the function <em>Wave_function()</em>. The other function, <em>SE(),</em> prepares the derivatives from the given wave function <em>psi</em>. As always when solving diff. equations, we need to specify initial conditions which will be in a 2-element array <em>psi_init. </em>These will be very low, cause we expect the wave function to vanish at the position outside of the HO.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate" title="">
def SE(psi, x):
    """
    Returns derivatives for the 1D schrodinger eq.
    Requires global value E to be set somewhere. State0 is
    first derivative of the wave function psi, and state1 is
    its second derivative.
    """
    state0 = psi[1]
    state1 = 2.0*(V(x) - E)*psi[0]
    return array([state0, state1])

def Wave_function(energy):
    """
    Calculates wave function psi for the given value
    of energy E and returns value at point b
    """
    global psi
    global E
    E = energy
    psi = odeint(SE, psi_init, x)
    return psi[-1,0]
</pre>
<h3><em>Finding alowed states</em></h3>
<p>The problem is – upper program will work almost all the time <span class="wp-smiley wp-emoji wp-emoji-smile" title=":)">:)</span>. We can get infinitely many solutions. And that’s bad. cause not all of them are meaningful. We need to find only those solutions where wave function <img class="latex" title="\psi(x)" src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=111111&amp;s=0" alt="\psi(x)"/> converges at the edges of <em>x</em>. If it doesn’t, it means that particle is not localized – it appears to be everywhere with the total probability more than 1! This is physically false. So here’s what we do: we run value of particle’s energy <em>E</em> from 0 to some value, say Emax, and calculate <img class="latex" title="\psi(x)" src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=111111&amp;s=0" alt="\psi(x)"/> for each <em>E</em>. Value of <img class="latex" title="\psi(x)" src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=111111&amp;s=0" alt="\psi(x)"/> outside of the HO is put into the separate <em>psi_end</em> list whose roots (places where it crosses zero) are to be found. Only those energies <em>E</em> for which wave function  is zero are taken into consideration and they represent the valid state of the particle. Here we see one of many weird things happening in the quantum world – particle can not have any value for its energy, only some of discrete numbers.</p>
<p>Once we have the values of <em>psi_end</em> for a range of energies we need to distinguish those states where wave function diverges. This is done using the Brent method to find a zero of the function <em class="xref py py-obj">f</em> on the sign changing interval [x , x+dx]. The method is available as a Python’s routine <em>scipy.optimize.brentq(). </em>For an array of energies <em>E </em>we will check the sign of the <em>psi_end</em>. When the sign changes, it means that <em>psi_end</em> crosses zero and now we can call <em>brentq() </em>to find the exact zero-point. The function is embedded as follows:</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate" title="">
def find_all_zeroes(x,y):
    """
    Gives all zeroes in y = f(x)
    """
    all_zeroes = []
    s = sign(y)
    for i in range(len(y)-1):
        if s[i]+s[i+1] == 0:
            zero = brentq(Wave_function, x[i], x[i+1])
            all_zeroes.append(zero)
    return all_zeroes
</pre>
<h3><em>Results and “is this correct?”</em></h3>
<p>To make life easier, I put values for <img src="https://s0.wp.com/latex.php?latex=k%2C+%5Chbar+%5Ctext%7B+and+%7D+m&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="k, \hbar \text{ and } m" title="k, \hbar \text{ and } m" class="latex"/> to be 100, 1 and 1, respectively. First figure shows how <em>psi_end</em> varies for different energies. The program found those energies <em>E</em> for which psi converges outside of the HO. These correspond to so-called <em>eigenstates</em> of the harmonic oscillator. How many of these are there anyway? Actually, <a href="http://en.wikipedia.org/wiki/Quantum_harmonic_oscillator">theory</a> of  the quantum HO is simple: for n-th eigenstate of HO, energy will be <img src="https://s0.wp.com/latex.php?latex=E+%3D+%5Chbar+%5Comega%28n%2B0.5%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="E = \hbar \omega(n+0.5)" title="E = \hbar \omega(n+0.5)" class="latex"/>. Knowing that <img src="https://s0.wp.com/latex.php?latex=%5Comega+%3D+%5Csqrt%7Bk%2Fm%7D&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\omega = \sqrt{k/m}" title="\omega = \sqrt{k/m}" class="latex"/>, we can expect energies of 5, 15, 25, 35 and 45. Triumphantly, they are exactly what the program has found!</p>
<figure data-shortcode="caption" id="attachment_404" class="wp-caption aligncenter"><a href="https://helentronica.files.wordpress.com/2014/12/allowede_ho.png"><img class=" wp-image-404" src="https://helentronica.files.wordpress.com/2014/12/allowede_ho.png?w=338&amp;h=161" alt="Allowed energies for the quantum harmonic oscillator (only lowest 4)"/></a><figcaption class="wp-caption-text">Allowed energies for the quantum harmonic oscillator (only lowest 4)</figcaption></figure>
<p>Now that we have required energies,  we can’t wait to see how the particle will behave. Next plot shows the probability density function for the first 4 eigenstates.  It looks pretty weird, huh? Let’s check what classical physics tells us. All the time energy of the body is constant and it is a sum of its kinetic and potential energy. At the balance point, the potential energy is zero meaning that kinetic energy is maximum. So the highest speed particle can have is when it is passing through the balance point. Logically, there is the least probability of finding a particle there. Vis-a-vis to that, at the edges of the oscillator particle has no kinetic energy at all, therefore speed is zero, therefore there is the most chance of finding the particle there. But check the plot again. It doesn’t work that way for quantum physics. Here, for the lowest energy, probability of finding a particle is the greatest in the middle, at the balance point. Why is that so? How is that possible?!</p>
<figure data-shortcode="caption" id="attachment_405" class="wp-caption aligncenter"><a href="https://helentronica.files.wordpress.com/2014/12/first_4_states_ho.png"><img class="wp-image-405" src="https://helentronica.files.wordpress.com/2014/12/first_4_states_ho.png?w=495&amp;h=236" alt="Wave functions for 4 lowest states of quantum harmonic oscillator. Here you see where is the most probable to find a particle with a specific energy."/></a><figcaption class="wp-caption-text">Wave functions for 4 lowest states of quantum harmonic oscillator. Here you see where is the most probable to find a particle with a specific energy.</figcaption></figure>
<p>The truth is – no one knows. There are <a href="http://en.wikipedia.org/wiki/Interpretations_of_quantum_mechanics">many different interpretations</a> of quantum physics and no way to prove any of them. It just works that way. If you put an electron at the minimum energy in the oscillating state, you’ll most likely find it in the middle. But the same will not be true if you put a pup on a swing in the oscillating state. How is that so? Shouldn’t the Schrödinger equation work the same for both electron and the puppy?</p>
<p>It should and it does. Only difference is that the puppy has a much much greater energy than the electron. Check the expression for the energy above. Since the Planck constant is ridiculously small number, quantum number <em>n</em> has to be insanely big to be adequate for the dog on the swing. Let’s see what happens if we increase n to, say, 50 (actually, I put the mass m = 100. Now I can keep energy vector lower than the maximum potential energy of HO but with better resolution).</p>
<figure data-shortcode="caption" id="attachment_408" class="wp-caption aligncenter"><a href="https://helentronica.files.wordpress.com/2014/12/ho1.png"><img class=" wp-image-408" src="https://helentronica.files.wordpress.com/2014/12/ho1.png?w=405&amp;h=193" alt="Probability density of particle with high quantum number, in e. puppy in the swing"/></a><figcaption class="wp-caption-text">Probability density of particle with high quantum number, in e. puppy in the swing</figcaption></figure>
<p>Ha, beautiful! It looks more like what we would expect from the classical mechanics – the probability is lowest in the middle. I find it amazing how such simple program can find such complex functions. But still, there are some peaks and dips along the x-axis. Still not exactly what we would like it to be. But don’t worry, in a world where we and the puppy live, the quantum number is so large and width of the dips is so small that there are no means to measure them. For us, probability density function is a smooth line along the x, just the way we’d expect from the classical physics. And there is a name for this –  a <em>correspondence principle</em>. It <a href="http://en.wikipedia.org/wiki/Correspondence_principle">says</a> that when the quantum number <em>n</em> goes insanely large, quantum mechanics starts to reproduce classical physics. In other words, for the large energies quantum calculations must agree with classical calculations. Correspondence principle is next big thing coming up from quantum mechanics after the energy discreteness and quantum tunneling which I covered in previous <a href="https://helentronica.wordpress.com/2014/09/04/quantum-mechanics-with-the-python/">post</a>.</p>
<p>Complete Python code for one-dimensional quantum harmonic oscillator can be found here:</p>
<pre class="brush: python; collapse: true; light: false; title: ; toolbar: true; wrap-lines: false; notranslate" title="">
# -*- coding: utf-8 -*-
"""
Created on Sun Dec 28 12:02:59 2014

@author: Pero

1D Schrödinger Equation in a harmonic oscillator.

Program calculates bound states and energies for a quantum harmonic oscillator. It will find eigenvalues 
in a given range of energies and plot wave function for each state.

For a given energy vector e, program will calculate 1D wave function using the Schrödinger equation
in the potential V(x). If the wave function diverges on x-axis, the
energy e represents an unstable state and will be discarded. If the wave function converges on x-axis, 
energy e is taken as an eigenvalue of the Hamiltonian (i.e. it is alowed energy and wave function
represents allowed state). 

Program uses differential equation solver &amp;quot;odeint&amp;quot; to calculate Sch. equation and optimization
tool &amp;quot;brentq&amp;quot; to find the root of the function. Both tools are included in the Scipy module.
The following functions are provided:

    - V(x) is a potential function of the HO. For a given x it returns the value of the potential
    - SE(psi, x) creates the state vector for a Schrödinger differential equation. Arguments are:
        psi - previous state of the wave function
        x - the x-axis
    - Wave_function(energy) calculates wave function using SE and &amp;quot;odeint&amp;quot;. It returns the wave-function
        at the value b far outside of the square well, so we can estimate convergence of the wave function.
    - find_all_zeroes(x,y) finds the x values where y(x) = 0 using &amp;quot;brentq&amp;quot; tool.    

Vales of m and L are taken so that h-bar^2/m*L^2 is 1.

v2 adds feature of computational solution of analytical model from the usual textbooks. As a result, 
energies computed by the program are printed and compared with those gained by the previous program.
"""
from pylab import *
from scipy.integrate import odeint
from scipy.optimize import brentq
#import matplotlib as plt

def V(x):
    """
    Potential function in the Harmonic oscillator. Returns V = 0.5 k x^2 if |x|&amp;lt;L and 0.5*k*L^2 otherwise
    """    
    if abs(x)&lt; L:
        return 0.5*k*x**2
    else:
        return 0.5*k*L**2
        
def SE(psi, x):
    """
    Returns derivatives for the 1D schrodinger eq. 
    Requires global value E to be set somewhere. State0 is first derivative of the 
    wave function psi, and state1 is its second derivative.
    """
    state0 = psi[1]
    state1 = (2.0*m/h**2)*(V(x) - E)*psi[0]
    return array([state0, state1])
    
def Wave_function(energy):
    """
    Calculates wave function psi for the given value 
    of energy E and returns value at point b
    """
    global psi
    global E
    E = energy
    psi = odeint(SE, psi_init, x)
    return psi[-1,0]

def find_all_zeroes(x,y):
    """
    Gives all zeroes in y = f(x)
    """
    all_zeroes = []   
    s = sign(y)
    for i in range(len(y)-1):
        if s[i]+s[i+1] == 0:
            zero = brentq(Wave_function, x[i], x[i+1])
            all_zeroes.append(zero)
    return all_zeroes
    

    
def find_analytic_energies(en):
    """ 
    Calculates Energy values for the harmonic oscillator using analytical
    model (Griffiths, Introduction to Quantum Mechanics, page 35.)
    """
    E_max = max(en)
    print 'Allowed energies of HO:'
    i = 0
    while((i+0.5)*h*w &lt; E_max):
        print '%.2f'%((i+0.5)*h*w)
        i+=1
    
    
    
N = 1000                  # number of points to take on x-axis    
psi = np.zeros([N,2])     # Wave function values and its derivative (psi and psi')
psi_init = array([.001,0])# Wave function initial states
E = 0.0                   # global variable Energy  needed for Sch.Eq, changed in function "Wave function"
b = 2                     # point outside of HO where we need to check if the function diverges
x = linspace(-b, b, N)    # x-axis
k = 100                   # spring constant 
m = 1                     # mass of the body
w = sqrt(k/m)             # classical HO frequency 
h = 1                     # normalized Planck constant
L = 1                     # size of the HO
               
def main():    
    # main program        
    
    en = linspace(0, 0.5*k*L**2, 50)   # vector of energies where we look for the stable states
    
    psi_end = []      # vector of wave function at x = b for all of the energies in en
    for e1 in en:
        psi_end.append(Wave_function(e1))     # for each energy e1 find the the psi(x) outside of HO        
        
    E_zeroes = find_all_zeroes(en, psi_end)   # now find the energies where psi(b) = 0 
    
    #Plot wave function values at b vs energy vector
    figure()
    plot(en,psi_end)
    title('Values of the $\Psi(b)$ vs. Energy')
    xlabel('Energy, $E$')
    ylabel('$\Psi(x = b)$', rotation='horizontal')
    for E in E_zeroes:
        plot(E, [0], 'go')
        annotate("E = %.2f" %E, xy = (E, 0), xytext=(E, 5))
    grid()
       
    # Print energies for the found states
    print &amp;quot;Energies for the bound states are: &amp;quot;
    for En in E_zeroes:
        print "%.2f " %En
        
    # Print energies of each bound state from the analytical model
    find_analytic_energies(en)   

    # Plot the wave function for 1st 4 eigenstates
    figure(2)
    for i in range(4):                                                 # For each of 1st 4 allowed energies
        Wave_function(E_zeroes[i])                                     # find the wave function psi(x) 
        plot(x, 100**i*psi[:,0]**2, label="E = %.2f" %E_zeroes[i])      # and plot it scaled for comparison    
    legend(loc="upper right")
    title('Wave function')
    xlabel('x, $x/L$')
    ylabel('$|\Psi(x)|^2$', rotation='horizontal', fontsize = 20)    
    grid()       
    
    # Plot the wave function for the last eigenstate
    figure(3)
    Wave_function(E_zeroes[-1])                                        # Find Wave function for the last allowed energy
    plot(x, psi[:,0]**2, label="E = %.2f" %E_zeroes[-1])    
    legend(loc="upper right")
    title('Wave function')
    xlabel('x, $x/L$')
    ylabel('$|\Psi(x)|^2$', rotation='horizontal', fontsize = 20)    
    grid()    
    
if __name__ == "__main__":
    main()
</pre>
		<div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><div class="sharedaddy sd-block sd-like jetpack-likes-widget-wrapper jetpack-likes-widget-unloaded" id="like-post-wrapper-65788698-326-56d5b967eddbd" data-src="//widgets.wp.com/likes/#blog_id=65788698&amp;post_id=326&amp;origin=helentronica.wordpress.com&amp;obj_id=65788698-326-56d5b967eddbd" data-name="like-post-frame-65788698-326-56d5b967eddbd"><h3 class="sd-title">Like this:</h3><p class="likes-widget-placeholder post-likes-widget-placeholder"><span class="button"><span>Like</span></span> <span class="loading">Loading...</span></p><span class="sd-text-color"/><a class="sd-link-color"/></div></div>					</div>

	</div></body></html>