<html><body><div><td class="mainsection">

   <br/>

<span class="dateheader">Tue, 04 Aug 2015</span>
<p>
<a class="storytitle" name="monad-search-2" href="http://blog.plover.com/prog/monad-search-2.html">The list monad in Perl and Python</a>
<br/>
</p><p>A few months ago I wrote <a href="http://blog.plover.com/prog/haskell/monad-search.html">an article about using Haskell's list monad
to do exhaustive
search</a>, with
the running example of solving this cryptarithm puzzle:</p>

<pre><code>    S E N D
+   M O R E
-----------
  M O N E Y
</code></pre>

<p>(This means that we want to map the letters <code>S</code>, <code>E</code>, <code>N</code>, <code>D</code>, <code>M</code>,
<code>O</code>, <code>R</code>, <code>Y</code> to distinct digits 0 through 9 to produce a five-digit
and two four-digit numerals which, when added in the indicated way,
produce the indicated sum.)</p>

<p>At the end, I said: </p>

<blockquote>
  <p>It would be an interesting and pleasant exercise to try to implement
  the same underlying machinery in another language. I tried this in
  Perl once, and I found that although it worked perfectly well, between
  the lack of the do-notation's syntactic sugar and Perl's clumsy
  notation for lambda functions (<code>sub { my ($s) = @_; âŚ }</code> instead of
  <code>\s -&gt; âŚ)</code> the result was completely unreadable and therefore
  unusable. However, I suspect it would be even worse in Python because
  of semantic limitations of that language. I would be interested to
  hear about this if anyone tries it.</p>
</blockquote>

<p>I was specifically worried about Python's peculiar local variable
binding.  But I did receive the following quite clear solution from
Peter De Wachter, who has kindly allowed me to reprint it:</p>

<pre><code>digits = set(range(10))

def to_number(*digits):
    n = 0
    for d in digits:
        n = n * 10 + d
    return n

def let(x, f):
    return f(x)

def unit(x):
     return [x]

def bind(xs, f):
     ys = []
     for x in xs:
         ys += f(x)
     return ys

def guard(b, f):
     return f() if b else []
</code></pre>

<p>after which the complete solution looks like:</p>

<pre><code>def solutions():
    return bind(digits - {0}, lambda s:
           bind(digits - {s}, lambda e:
           bind(digits - {s,e}, lambda n:
           bind(digits - {s,e,n}, lambda d:
           let(to_number(s,e,n,d), lambda send:
           bind(digits - {0,s,e,n,d}, lambda m:
           bind(digits - {s,e,n,d,m}, lambda o:
           bind(digits - {s,e,n,d,m,o}, lambda r:
           let(to_number(m,o,r,e), lambda more:
           bind(digits - {s,e,n,d,m,o,r}, lambda y:
           let(to_number(m,o,n,e,y), lambda money:
           guard(send + more == money, lambda:
           unit((send, more, money))))))))))))))

print(solutions())
</code></pre>

<p>I think this shows that my fears were unfounded.  This code produces
the correct answer in about 1.8 seconds on my laptop.</p>

<p>Thus inspired, I tried doing it again in Perl, and it was not as bad
as I remembered:</p>

<pre><code>sub bd { my ($ls, $f) = @_;
  [ map @{$f-&gt;($_)}, @$ls ]      # Yow
}
sub guard { $_[0] ? [undef] : [] }
</code></pre>

<p>I opted to omit <code>unit</code>/<code>return</code> since an idiomatic solution doesn't
really need it.  We can't name the <code>bind</code> function <code>bind</code> because that
is reserved for a built-in function; I named it <code>bd</code> instead.  We
could use Perl's operator overloading to represent binding with the
<code>&gt;&gt;</code> operator, but that would require turning all the lists into
objects, and it didn't seem worth doing.</p>

<p>We don't need <code>to_number</code>, because Perl does it implicitly, but we do
need a set subtraction function, because Perl has no built-in set
operators:</p>

<pre><code>sub remove {
  my ($b, $a) = @_;
  my %h = map { $_ =&gt; 1 } @$a;
  delete $h{$_} for @$b;
  return [ keys %h ];
}
</code></pre>

<p>After which the solution, although cluttered by Perl's verbose
notation for lambda functions, is not too bad:</p>

<pre><code>my $digits = [0..9];
my $solutions =
  bd remove([0],        $digits) =&gt; sub { my ($s) = @_;
  bd remove([$s],       $digits) =&gt; sub { my ($e) = @_;
  bd remove([$s,$e],    $digits) =&gt; sub { my ($n) = @_;
  bd remove([$s,$e,$n], $digits) =&gt; sub { my ($d) = @_;
    my $send = "$s$e$n$d";

  bd remove([0,$s,$e,$n,$d],     $digits) =&gt; sub { my ($m) = @_;
  bd remove([$s,$e,$n,$d,$m],    $digits) =&gt; sub { my ($o) = @_;
  bd remove([$s,$e,$n,$d,$m,$o], $digits) =&gt; sub { my ($r) = @_;
    my $more = "$m$o$r$e";

  bd remove([$s,$e,$n,$d,$m,$o,$r], $digits) =&gt; sub { my ($y) = @_;
    my $money = "$m$o$n$e$y";
  bd guard($send + $more == $money) =&gt; sub { [[$send, $more, $money]] }}}}}}}}};

  for my $s (@$solutions) {
    print "@$s\n";
  }
</code></pre>

<p>This runs in about 5.5 seconds on my laptop. I guess, but am not sure,
that <code>remove</code> is mainly at fault for this poor performance.</p>

<p>An earlier version of this article claimed, incorrectly, that the
Python version had lazy semantics.  It does not; it is strict.</p>

<p>[ Addendum: Aaron Crane has done some benchmarking of the Perl
version.  A better implementation of <code>remove</code> (using an array instead
of a hash) does speed up the calculation somewhat, but contrary to my
guess, the largest part of the run time is <code>bd</code> itself, apparently
becuse Perl function calls are relatively slow.</p>

<p>HN user <code>masklinn</code> tried a translation of the Python code into <a href="https://news.ycombinator.com/item?id=10002761">a
version that returns a lazy
iterator</a>; I gather the
changes were minor. ]</p>



<br clear="all"/>
<p align="right">
<i>[<a href="http://blog.plover.com/prog">Other articles in category /prog</a>] 
<a href="http://blog.plover.com/prog/monad-search-2.html">permanent link</a></i>
</p>

<br/>

  </td>

 </div></body></html>