<html><body><div><div class="content html_format"><p>
      Техники перехвата функций в Linux хорошо известны и описаны в интернете. Наиболее простой метод заключается в написании динамической библиотеки с «функциями-клонами» и использовании механизма LD_PRELOAD для переопределения таблицы импорта на этапе загрузки процесса.</p>
<p>
Недостаток LD_PRELOAD в том что необходимо контролировать запуск процесса. Для перехвата функций в уже работающем процессе или функций отсутствующих в таблице импорта можно использовать «сплайсинг» — запись команды перехода на перехватчик в начало перехватываемой функции.
</p><p>
Также известно, что в Python имеется модуль </p><code>ctypes</code><p> позволяющий взаимодействовать с данными и функциями языка Си (т.е. большим числом динамических библиотек имеющих Си интерфейс). Таким образом ничто не мешает перехватить функцию процесса и направить её в Python метод обёрнутый в С-callback с помощью </p><code>ctypes</code><p>.
</p><a name="habracut"/><p>
Для перехвата управления и загрузки кода в целевой процесс удобно использовать отладчик GDB, который поддерживает написание модулей расширения на языке Python (</p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Python-API.html">https://sourceware.org/gdb/current/onlinedocs/gdb/Python-API.html</a><p>).
</p><div class="spoiler"><b class="spoiler_title">Нюансы</b><div class="spoiler_text"><p>Код примера приведен полностью в конце статьи и состоит из двух файлов:</p>

<ul>
<li>pyinject.py — расширение GDB </li>
<li>hook.py — модуль с функциями перехватчиками </li>
</ul> <p>
Со стороны GDB код удобно оформить в виде пользовательской команды. Новую команду можно создать, наследуя от класса </p><code>gdb.Command</code><p>. При использовании команды в GDB будет вызываться метод </p><code>invoke(argument, from_tty)</code><p>.
</p><p>
Также можно создавать пользовательские параметры наследуя от </p><code>gdb.Parameter</code><p>. В примере статьи он используется для задания имени файла с функциями перехвата.
</p><p>
Подключение к работающему процессу </p><code>PID</code><p> и загрузку модуля удобно делать сразу при запуске GDB
</p><pre><code class="bash">gdb -ex 'attach PID' -ex 'source pyinject.py' -ex 'set hookfile hook.py'</code></pre><p>Поле этого отлаживаемый процесс остановлен и запущена интерактивная командная строка GDB, в которой будет доступна новая команда «pyinject».
</p></div></div><p>
Перехват можно условно разделить на три этапа:</p><ol>
<li>Инжектирование интерпретатора Python в адресное пространство целевого процесса</li>
<li>Сбор информации о перехватываемой функции</li>
<li>Собственно перехват</li>
</ol><p>Пункты 1 и 2 проще делать на стороне отладчика, пункт 3 уже внутри целевого процесса.

</p><h2>Инжектирование интерпретатора Python</h2><p>
Большая часть Python интерфейса GDB предназначена для расширения отладочных возможностей. Для всего остального есть </p><code>gdb.execute(command, from_tty, to_string)</code><p>, которая позволяет выполнить произвольную команду GDB и получить её вывод в виде строки.</p><p>
Например:
</p><pre><code class="python">out = gdb.execute("info registers", False, True)
</code></pre><p>Также полезна </p><code>gdb.parse_end_eval(expression)</code><p>, вычисляющая выражение и возвращающая результат в виде </p><code>gdb.Value</code><p>.
</p><p>
Первым делом необходимо загрузить библиотеку Python в адресное пространство целевого процесса. Для этого необходимо вызвать </p><code>dlopen</code><p> в контексте целевого процесса.</p><p>
Можно использовать команду </p><code>call</code><p> в </p><code>gdb.execute</code><p>, либо </p><code>gdb.parse_and_eval</code><p>:
</p><pre><code class="python"># pyinject.py
gdb.execute('call dlopen("libpython2.7.so", %d)' % RTLD_LAZY)
assert long(gdb.history(0))
handle = gdb.parse_and_eval('dlopen("libpython2.7.so", %d)' % RTLD_LAZY)
assert long(handle)
</code></pre><p>
После этого можно инициализировать интерпретатор
</p><pre><code class="python"># pyinject.py
gdb.execute('call PyEval_InitThreads()')
gdb.execute('call Py_Initialize()')
</code></pre><p>Первый вызов создает GIL (global interpreter lock), второй подготавливает Python C-API к использованию.
</p><p>
И загрузить модуль с функциями перехвата
</p><pre><code class="python"># pyinject.py
fp = gdb.parse_and_eval('fopen("hook.py", "r")')
assert long(fp) != 0
pyret = gdb.parse_and_eval('PyRun_AnyFileEx(%u, "hook.py", 1)' % fp)
</code></pre><code>PyRun_AnyFileEx</code><p> выполняет код из файла в контексте модуля </p><code>__main__</code><p>.</p><div class="spoiler"><b class="spoiler_title">Нюансы</b><p class="spoiler_text">Вышеописанное будет работать только если целевой процесс не использует Python (как основной или скриптовый язык). Если это не так, то всё серьёзно усложняется. Основная проблема в том что в процессе остановленном для отладки в случайном месте нельзя использовать никакие функции Python C-API (кроме может быть <code>Py_AddPendingCall</code>).</p></div>
<h2>Модуль hook.py</h2><p>
Модуль hook.py содержит функции перехватчики и класс </p><code>Hook</code><p> выполняющий собственно перехват.</p><p>
Функции перехватчики обозначаются при помощи декоратора. Например для функции </p><code>open</code><p> стандартной библиотеки напечатаем её аргументы и вернем результат вызова оригинальной функции, хранящейся в поле </p><code>orig</code>
<pre><code class="python"># hook.py
@hook(symbol='open', ctype=CFUNCTYPE(c_int, c_char_p, c_int))
def python_open(fname, oflag):
    print "open: ", fname, oflag
    return python_open.orig(fname, oflag)
</code></pre><p>
Декоратор </p><code>@hook</code><p> принимает два параметра:</p><ul>
<li>symbol — имя перехватываемого символа (предполагается что символ доступен в GDB из таблиц импорта или отладочной информации, но ничто не мешает перехватывать функции по адресам вместо символов)</li>
<li>ctype — класс <code>ctypes</code> задающий тип функции</li>
</ul><p>Декоратор регистрирует функцию в классе Hook и возвращает не изменяя.
</p><pre><code class="python"># hook.py
def hook(symbol, ctype):
    def deco(func):
        Hook.register(symbol, ctype, func)
        return func
    return deco
</code></pre><p>
Метод </p><code>register</code><p> создает экземпляр класса и сохраняет его в словаре </p><code>all_hooks</code><p>. Таким образом после выполнения файла, благодаря декораторам в </p><code>Hook.all_hooks</code><p> будет вся информация о доступных функциях перехватчиках.
</p><pre><code class="python"># hook.py
class Hook(object):
    all_hooks = {}
    @staticmethod
    def register(symbol, *args):
        Hook.all_hooks[symbol] = Hook(symbol, *args)
</code></pre><p>
Чтобы осуществить перехват со стороны GDB вызовом одной функции, удобно определить статический метод в классе </p><code>Hook</code><p>, ответственный за перехват
</p><pre><code class="python"># hook.py
class Hook(object):
    @staticmethod
    def hook(symbol, *args):
        h = Hook.all_hooks[symbol]
        if h.active:
            return
        h.install(*args)
</code></pre><p>В </p><code>*args</code><p> здесь передается дополнительная информация о перехватываемой функции. Какая именно зависит от метода перехвата.

</p><h2>Методы перехвата «сплайсингом»</h2><p>
Сплайсинг глобально делится на два подвида по способу вызова оригинальной функции.
</p><p>
В </p><b>simple hook</b><p> вызов оригинальной функции состоит из нескольких шагов:</p><ol>
<li>начало оригинальной функции восстанавливается из сохраненной копии</li>
<li>производится вызов</li>
<li>начало снова затирается инструкцией перехода на перехватчик</li>
</ol><div class="spoiler"><b class="spoiler_title">Нюансы</b><p class="spoiler_text">Недостаток очевиден, в многопоточной программе нельзя гарантировать, что другой поток не вызовет функцию во время перезаписи её начала. Частично это лечится остановкой других потоков на время вызова оригинальной функции. Но во-первых нет стандартного способа этого достичь, во-вторых можно словить deadlock если неудачно вызвать функцию типа malloc</p></div><p>
В </p><b>trampoline hook</b><p> начало оригинальной функции копируется в новое место и после него записывается переход в тело оригинальной функции. В этом варианте оригинальная функция всегда доступна по новому адресу.
</p><p>
Trampoline hook работает в многопоточных программах, но гораздо сложнее в установке. Необходимо перезаписывать целое число инструкций, для чего обычно используется дизассемблер. Приход архитектуры x86_64 добавил еще больше проблем из-за повсеместного распространения адресации памяти относительно регистра </p><code>%rip</code><p> (адрес текущей команды).
</p><div class="spoiler"><b class="spoiler_title">Нюансы</b><div class="spoiler_text"><p>Посмотрим на начало функции </p><code>open</code><p> в GDB:
</p><pre><code class="perl">0x7f6cc8aa83e0 &lt;open64+0&gt;:          83 3d ed 33 2d 00 00  cmpl    $0x0,0x2d33ed(%rip)
0x7f6cc8aa83e7 &lt;open64+7&gt;:          75 10                 jne     0x7f6cc8aa83f9 &lt;open64+25&gt;
0x7f6cc8aa83e9 &lt;__open_nocancel+0&gt;: b8 02 00 00 00        mov     $0x2,%eax
0x7f6cc8aa83ee &lt;__open_nocancel+5&gt;: 0f 05                 syscall
</code></pre><p>
Если мы перепишем первую команду "</p><code>cmpl $0x0,0x2d33ed(%rip)</code><p>" по другому адресу, то относительный адрес </p><code>0x2d33ed(%rip)</code><p>, который сейчас указывает на </p><code>0x7f6cc8d7b7d4</code><p>, будет указывать в другое место (привет SIGSEGV).
</p><p>
Чтобы сделать trampoline hook этой функции нужно:</p><ol>
<li>определить размер команд в начале функции</li>
<li>выделить память не дальше чем в 2ГБ от целевого адреса команды cmpl (смещение <code>0x2d33ed(%rip)</code> знаковое 32-битное)</li>
<li>скопировать начало в новое место и пропатчить доступ к памяти относительно <code>%rip</code> в <code>cmpl</code></li>
</ol><p>В довершение картины, команда перехода должна быть короче 9 байт, т.к. это функция с двумя точками входа и по адресу </p><code>0x7f6cc8aa83e9</code><p> уже находится </p><code>__open_nocancel</code><p>. Это значит, что наш трамплин должен быть не дальше чем в 2ГБ от начала </p><code>open</code><p> для возможности 32-битного перехода (все 64-битные переходы длиннее 9 байт).</p></div></div><p>
В принципе, имея всю мощь GDB за спиной (</p><code>gdb.execute()</code><p>), ничто не мешает корректно реализовать trampoline hook, но для простоты примера в этой статье будет использоваться simple hook.
</p><p>
В </p><b>simple hook</b><p> единственное ограничение это длина инструкции перехода.</p><p>
Вариантов два (основных):
</p><p>
В статье используется второй метод
</p><pre><code class="python"># hook.py
class Hook(object):
    @staticmethod
    def get_indlongjmp(srcaddr, proxyaddr):
        s = struct.pack('=BBl', 0xff, 0x25, proxyaddr - srcaddr - 6)
        return map(ord, s)
</code></pre><code>get_indlongjmp</code><p> возвращает код для прыжка с адреса </p><code>srcaddr</code><p> на адрес сохраненный в QWORD по адресу </p><code>proxyaddr</code>
<p>
Теперь можно наконец написать недостающие методы класса </p><code>Hook</code><p>. Метод </p><code>install</code><p> получает адрес оригинальной функции </p><code>address</code><p> и адрес вспомогательной зоны </p><code>proxyaddr</code><p>. После чего переписывает начало функции (предварительно сохранив его в </p><code>self.code</code><p>) переходом на перехватчик
</p><pre><code class="python"># hook.py
    def install(self, address, proxyaddr):
        self.address = address
        self.proxyaddr = proxyaddr
        proxymemory = (c_void_p * 1).from_address(self.proxyaddr)
        proxymemory[0] = Hook.cast_to_void_p(self.cfunc)
        self.jmp = self.get_indlongjmp(self.address, self.proxyaddr)
        self.memory = (c_ubyte * len(self.jmp)).from_address(self.address)
        self.code = list(self.memory)
        self.patchmem(self.jmp)
        self.pyfunc.orig = self.origfunc()
        self.active = True
</code></pre>
<code>patchmem</code><p> перезаписывает начало оригинальной функции данными из </p><code>src</code>
<pre><code class="python"># hook.py
    def patchmem(self, src):
        for i in range(len(src)):
            self.memory[i] = src[i]
</code></pre>
<code>origfunc</code><p> оборачивает вызов функции в код снимающий и устанавливающий переход на перехватчик.
</p><pre><code class="python"># hook.py
    def origfunc(self):
        ofunc = self.ctype(self.address)
        def wrap(*args):
            self.patchmem(self.code)
            val = ofunc(*args)
            self.patchmem(self.jmp)
            return val
        return wrap
</code></pre>
<h2>Последние штрихи</h2><p>
Python загружен в адресное пространство, файл hook.py загружен в Python. Осталось вызвать </p><code>Hook.hook(symbol, address, proxyaddr)</code><p> cо стороны Python модуля GDB.
</p><p>
Находим адрес функции "</p><code>open</code><p>"
</p><pre><code class="python">line = gdb.execute('info address %s' % "open" False, True)
m = re.match(r'.*?(0x[0-9a-f]+)', line)
addr = int(m.group(1), 16)
</code></pre><div class="spoiler"><b class="spoiler_title">Нюансы</b><p class="spoiler_text">В общем случае, перед тем как бежать переписывать код остановленного процесса надо убедиться что он не остановлен посередине этого кода (или собирается вернуться в него). Сделать это проще всего, отпарсив вывод <code>gdb.execute("thread apply all backtrace")</code></p></div><p>
Выделяем память поблизости от </p><code>addr</code>
<pre><code class="python">prot = PROT_READ | PROT_WRITE | PROT_EXEC
flags = MAP_PRIVATE | MAP_ANONYMOUS
maddr = gdb.parse_and_eval('(void*)mmap(0x%x, %d, %d, %d, -1, 0)\n'
                           % (addr | 0x7FFFFFFF, 4096, prot, flags))
maddr = (long(maddr) &amp; 0x00000000FFFFFFFF) | (addr &amp; 0xFFFFFFFF00000000)
</code></pre><div class="spoiler"><b class="spoiler_title">Нюансы</b><p class="spoiler_text">Последняя строка это обход бага в GDB, который съедает старшие биты результата. Аргумент <code>(addr | 0x7FFFFFFF)</code> использует недокументированное свойство <code>mmap</code> выдавать память с адресом меньше занятого желаемого.<br/>
<br/>
Без трюков по-правильному чуть длиннее: надо отпарсить вывод <code>gdb.execute('info proc mappings', False, True)</code>, найти ближайшую к addr дырку в адресном пространстве и вывать mmap с <code>MAP_FIXED</code>. Ну и естественно не обязательно выделять по целой странице памяти для каждой перехваченой функции.</p></div><p>
Разрешаем перезапись оригинальной функции (иначе SIGSEGV)
</p><pre><code class="python">gdb.parse_and_eval('mprotect(0x%x, %u, %d)' % (addr &amp; -0x1000, 4096*2, prot))
</code></pre><p>
Вызываем </p><code>Hook.hook</code><p> через </p><code>PyRun_SimpleString</code>
<pre><code class="python">pyret = gdb.parse_and_eval('PyRun_SimpleString("Hook.hook(\\"open\\", 0x%x, 0x%x)")'
                            % (addr, maddr))
</code></pre><p>
Готово! Теперь вызов "</p><code>open</code><p>" в целевом процессе будет перехвачен и направлен в </p><code>python_open</code><p> из hook.py.

</p><h2>Файлы примеров</h2><p>
Полные файлы примеров (с чуть большим количеством проверок, но без учета многих нюансов)
</p><div class="spoiler"><b class="spoiler_title">pyinject.py</b><div class="spoiler_text"><pre><code class="python"># pyinject.py
import re
import os

RTLD_LAZY = 1
PROT_READ = 0x1
PROT_WRITE = 0x2
PROT_EXEC = 0x4
MAP_PRIVATE = 0x2
MAP_FIXED = 0x10
MAP_ANONYMOUS = 0x20
LIBPYTHON = 'libpython2.7.so'

class ParamHookfile(gdb.Parameter):
    instance = None
    def __init__(self, default=''):
        super(ParamHookfile, self).__init__("hookfile",
                                            gdb.COMMAND_NONE, gdb.PARAM_FILENAME)
        self.value = default
        ParamHookfile.instance = self

    def get_set_string(self):
        return self.value

    def get_show_string(self, svalue):
        return svalue

class CmdHook(gdb.Command):
    instance = None
    def __init__(self):
        super(CmdHook, self).__init__("pyinject", gdb.COMMAND_NONE)
        self.initialized = False
        CmdHook.instance = self

    def complete(self, text, word):
        matching = [s[4:] for s in dir(self)
                     if s.startswith('cmd_')
                     and s[4:].startswith(text)]
        return matching

    def invoke(self, subcmd, from_tty):
        self.dont_repeat()
        if subcmd.startswith("hook"):
            self.cmd_hook(*gdb.string_to_argv(subcmd))
        elif subcmd.startswith("unhook"):
            self.cmd_unhook(*gdb.string_to_argv(subcmd))
        else:
            gdb.write('unknown sub-command "%s"' % subcmd)

    def cmd_hook(self, *args):
        self.initialize()
        if not self.initialized:
            return

        pyret = gdb.parse_and_eval('PyRun_SimpleString("print Hook")')
        if long(pyret) != 0:
            hookfile = ParamHookfile.instance.value
            if not os.path.exists(hookfile):
                gdb.write('Use "set hookfile &lt;path&gt;"\n')
                return
            fp = gdb.parse_and_eval('fopen("%s", "r")' % hookfile)
            assert long(fp) != 0
            pyret = gdb.parse_and_eval('PyRun_AnyFileEx(%u, "%s", 1)' % (fp, hookfile))
            if long(pyret) != 0:
                gdb.write('Error loading "%s"\n' % hookfile)
                return

        for symbol in args:
            try:
                line = gdb.execute('info address %s' % symbol, False, True)
                m = re.match(r'.*?(0x[0-9a-f]+)', line)
                if m:
                    addr = int(m.group(1), 16)
            except gdb.error:
                continue
            prot = PROT_READ | PROT_WRITE | PROT_EXEC
            flags = MAP_PRIVATE | MAP_ANONYMOUS # | MAP_FIXED
            maddr = gdb.parse_and_eval('(void*)mmap(0x%x, %d, %d, %d, -1, 0)\n'
                                       % (addr | 0x7FFFFFFF , 4096, prot, flags))
            maddr = (long(maddr) &amp; 0x00000000FFFFFFFF) | (addr &amp; 0xFFFFFFFF00000000)
            gdb.write("mmap = 0x%x\n" % maddr)
            if maddr == 0:
                continue
            gdb.parse_and_eval('mprotect(0x%x, %u, %d)' % (addr &amp; -0x1000, 4096*2, prot))
            pyret = gdb.parse_and_eval('PyRun_SimpleString("Hook.hook(\\"%s\\", 0x%x, 0x%x)")'
                                       % (symbol, addr, maddr))
            if long(pyret) == 0:
                gdb.write('hook "%s" OK\n' % symbol)

    def cmd_unhook(self, *args):
        for symbol in args:
            pyret = gdb.parse_and_eval('PyRun_SimpleString("Hook.unhook(\\"%s\\")")'
                                       % (symbol))
            if long(pyret) == 0:
                gdb.write('unhook "%s" OK\n' % symbol)

    def initialize(self):
        if self.initialized:
            return
        handle = gdb.parse_and_eval('dlopen("%s", %d)' % (LIBPYTHON, RTLD_LAZY))
        if not long(handle):
            gdb.write('Cannot load library %s\n' % LIBPYTHON)
            return
        if not long(gdb.parse_and_eval('Py_IsInitialized()')):
            gdb.execute('call PyEval_InitThreads()')
            gdb.execute('call Py_Initialize()')
        self.initialized = True

if __name__ == '__main__':
    ParamHookfile()
    CmdHook()
</code></pre>
</div></div><div class="spoiler"><b class="spoiler_title">hook.py</b><div class="spoiler_text"><pre><code class="python"># hook.py
import struct
from ctypes import (CFUNCTYPE, POINTER, c_ubyte, c_int, c_char_p, c_void_p)

class Hook(object):
    all_hooks = {}

    @staticmethod
    def cast_to_void_p(pointer):
        return CFUNCTYPE(c_void_p, c_void_p)(lambda x: x)(pointer)

    @staticmethod
    def register(symbol, *args):
        Hook.all_hooks[symbol] = Hook(symbol, *args)

    def __init__(self, symbol, ctype, pyfunc):
        self.symbol = symbol
        self.ctype = ctype
        self.pyfunc = pyfunc
        self.cfunc = self.ctype(self.pyfunc)
        self.address = 0
        self.proxyaddr = 0
        self.jmp = None
        self.memory = None
        self.code = None
        self.active = False

    def install(self, address, proxyaddr):
        print "install:", hex(address)
        self.address = address
        self.proxyaddr = proxyaddr
        proxymemory = (c_void_p * 1).from_address(self.proxyaddr)
        proxymemory[0] = Hook.cast_to_void_p(self.cfunc)
        self.jmp = self.get_indlongjmp(self.address, self.proxyaddr)
        self.memory = (c_ubyte * len(self.jmp)).from_address(self.address)
        self.code = list(self.memory)
        self.patchmem(self.jmp)
        self.pyfunc.orig = self.origfunc()
        self.active = True

    def uninstall(self):
        self.patchmem(self.code)
        self.active = False

    def origfunc(self):
        ofunc = self.ctype(self.address)
        def wrap(*args):
            self.patchmem(self.code)
            val = ofunc(*args)
            self.patchmem(self.jmp)
            return val
        return wrap

    def patchmem(self, src):
        for i in range(len(src)):
            self.memory[i] = src[i]

    @staticmethod
    def get_indlongjmp(srcaddr, proxyaddr):
        # 64-bit indirect absolute jump (6 + 8 bytes)
        # ff 25 off32     jmpq  *off32(%rip)
        try:
            s = struct.pack('=BBl', 0xff, 0x25, proxyaddr - srcaddr - 6)
            return map(ord, s)
        except:
            print hex(proxyaddr), hex(srcaddr), hex(proxyaddr - srcaddr - 6)
            raise

    @staticmethod
    def hook(symbol, address, proxyaddr):
        h = Hook.all_hooks[symbol]
        if h.active:
            return
        h.install(address, proxyaddr)

    @staticmethod
    def unhook(symbol):
        h = Hook.all_hooks[symbol]
        if not h.active:
            return
        h.uninstall()

def hook(symbol, ctype):
    def deco(func):
        Hook.register(symbol, ctype, func)
        return func
    return deco

#int open (const char *__file, int __oflag, ...)
@hook(symbol='open', ctype=CFUNCTYPE(c_int, c_char_p, c_int))
def python_open(fname, oflag):
    print "open: ", fname, oflag
    return python_open.orig(fname, oflag)
</code></pre>
</div></div><p> Запуск примера (лучше с абсолютными путями)
</p><pre><code class="bash">gdb -ex 'attach PID' -ex 'source /path/pyinject.py' -ex 'set hookfile /path/hook.py'
(gdb) pyinject hook open
(gdb) continue</code></pre>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>