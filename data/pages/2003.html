<html><body><div><div class="content html_format"><p>
      Эта статья рассказывает о проблемах, которые поджидают программиста, работающего с часовыми поясами. В теории, вроде, всё хорошо, просто и понятно, но жизнь — штука сложная, и на практике, порой, возникают совершенно неожиданные ситуации.</p>

<strong>TL;DR: Работа с таймзонами — это боль и унижение. Никогда не работайте с таймзонами!</strong>
<p>
Итак, </p><a href="http://lucumr.pocoo.org/2011/7/15/eppur-si-muove/">все</a> <a href="http://habrahabr.ru/company/mailru/blog/242615/">кругом</a> <a href="http://asvetlov.blogspot.ru/2011/02/date-and-time.html">твердят</a><p> вам, что при получении времени от пользователя нужно сразу же переводить его в UTC, работать со временем нужно только в UTC и хранить время тоже нужно строго в UTC. Совет, на первый взгляд, выглядит разумным, и следование ему делает вашу жизнь проще… Если только ваша программа не предполагает сложной работы с датами. Записать в базу данных дату и время регистрации пользователя на сайте? Сохранить время отправки сообщения или дату создания заказа в интернет-магазине? Вывести сообщение в лог с указанием даты-времени? Используйте UTC и всё будет в порядке, можете даже не читать эту статью дальше. Любое текущее время можно совершенно спокойно конвертировать в UTC и забыть о проблемах. Но что, если мы хотим работать с временем в будущем? Или в прошлом? Например, если мы пишем сервис календаря, или сервис для отложенной отправки сообщений?

</p><a name="habracut"/><h1>UTC не панацея</h1><p>Поясню на примере. Допустим, мы создали тот же сервис отложенных сообщений. Зайдя на наш сайт пользователь может создать себе напоминание на любое время (разумеется, в будущем) по почте или СМС. Сайт наш предельно прост: задаём дату, время, вводим текст напоминания и канал связи (адрес email или номер телефона), полученные от пользователя данные складываем в базу и потом периодически делаем по ней выборки и отправляем сообщения. Всё, профит и уважение благодарных людей!
</p><p>
Нет, не всё. Следуя совету всегда везде хранить всё в UTC, мы преобразовали полученную от пользователя дату и время в UTC и положили их в базу данных. Пусть пользователь из Москвы зашёл на наш сайт 2 марта 2014 года и создал напоминание на 09:00 утра 3 ноября 2014 года. Соответственно, в базу мы положили значение «2014-11-03 05:00:00», ведь в тот день, 2 марта 2014 года, смещение для таймзоны «Europe/Moscow» для 3 ноября 2014 года составляло «UTC+4».
</p><p>
Понимаете, к чему я клоню?
</p><p>
Да, 21 июля 2014 года Государственная дума Российской Федерации приняла законопроект об отмене летнего времени. Согласно этому закону, с 26 октября 2014 года, смещение для таймзоны Europe/Moscow стало «UTC+3» вместо «UTC+4» (а ещё переход на летнее время отменили, но речь сейчас не об этом). Соответственно, если мы отправим уведомление пользователю 3 ноября в 5:00 утра по UTC, он получит его в 8:00 утра по Москве, и я уверен, что пользователь будет недоумевать, ведь он просил, чтобы уведомление пришло ему ровно в девять утра.
</p><p>
Вывод прост: вы можете хранить время в UTC, но только для событий в настоящем и недавнем прошлом, то есть для тех дат, таймзона которых заведомо не изменится. Хранить время в UTC для дат в будущем опасно, ведь никто не знает, какие ещё законы примут правительства каких стран, и что станет с таймзонами через десять лет, пять лет, или даже через год.
</p><p>
С другой стороны, если вы будете хранить в базе данных локальное время пользователя и его таймзону, работать с такими данными будет практически невозможно. Вернёмся к нашему примеру сервиса уведомлений: два пользователя создали по уведомлению. Первый пользователь из Москвы, попросил прислать ему СМС 15 декабря 2014 года в 15:00 (пишем в базу его локальное время «2014-12-15 15:00:00» и его часовой пояс «Europe/Moscow»). Второй пользователь из Нью-Йорка, попросил прислать ему письмо на электронную почту 15 декабря 2015 года в 7:00PM (пишем в базу его локальное время «2014-12-15 19:00:00» и его часовой пояс «America/New_York»). Пока всё хорошо: у нас записано локальное время, в которое пользователь хотел бы получить своё уведомление, и он его получит строго в это время, даже если правительство одной из этих стран изменит один из этих часовых поясов (смещение, правила перехода на летнее время, всё, что угодно).
</p><p>
Проблемы начинаются, когда вы будете писать скрипт, выбирающий из базы уведомления для отправки. Если бы все даты были записаны в UTC, всё было бы просто, — каждую минуту выбираем сообщения для отправки:
</p><pre><code class="sql">SELECT * FROM reminders WHERE remind_time &lt; NOW();
</code></pre><p>
При условии, что «SELECT NOW();» возвращает время в UTC. Но мы записали в базу локальное время пользователя и его часовой пояс, что же делать? Страдать :-) Ведь «NOW()» по UTC — это "+3" часа в Москве (и сообщение уже опоздало) и "-5" часов в Нью-Йорке (сообщение ещё рано отправлять).
</p><p>
Нет, конечно можно придумать много способов выборки из базы тех уведомлений, которые пора отправлять, но все они на более-менее нагруженном сервисе приведут к проблемам с производительностью, да и вообще мы же хотим сделать всё правильно, без «костылей», да?
</p><p>
Какие есть варианты? Их много, однако я вижу только один более-менее приемлимый вариант: хранить в базе три значения: время в UTC (для выборки по этому полю), локальное время пользователя и его часовой пояс (таймзону). Да, у нас будут храниться избыточные данные, однако я не знаю ни одного нагруженного сервиса, который не прибегал бы к денормализации данных. В реальном мире это нормально. Какие плюсы мы получаем? В случае изменений часовых поясов, мы можем пройтись по записям для изменившихся таймзон специальным скриптом, и обновить время в UTC, если оно поменялось в результате обновления часового пояса. По моему скромному мнению, это хороший компромисс.

</p><h1>Всё ещё хуже, чем кажется</h1><p>Вроде всё, да? Нет, мы только начали :-) Правительство может не только менять конфигурацию часовых поясов, но и добавлять новые и выкидывать старые таймзоны. Так, например, для жителей Российского города Чита (и не только для него, но сейчас не об этом) с 26 октября 2014 года был введён новый часовой пояс «Asia/Chita» (раньше такого часового пояса не существовало) вместо употреблявшегося до этого «Asia/Yakutsk». Разница с UTC у прежнего часового пояса («Asia/Yakutsk») составляет "+09:00", а у нового часового пояса («Asia/Chita») эта разница составляет "+08:00". Проблема заключается в том, что мы храним в базе только время и часовой пояс пользователя, но не его географическое положение. И для записей с часовым поясом «Asia/Yakutsk» мы никак не можем знать, из Читы ли наш пользователь, или из Якутстка, и мы никак не можем достоверно определить время отправки сообщения пользователю. Шах и мат! Не забываем страдать, друзья.
</p><p>
Если у вас есть возможность узнать географическое положение пользователя и при следующем его заходе на сайт определить, что он находится в регионе со сменившейся таймзоной (Чита для случая выше), можно спросить у него правильный часовой пояс. И предложить обновить таймзону для всех его событий (с пересчётом времени в UTC для каждого события), но здесь тоже могут возникнуть подводные камни и нюансы, выходящие за рамки данной статьи. Кстати, отчасти по этой причине мы в настройках </p><a href="https://calendar.mail.ru/">Календаря mail.ru</a><p> просим пользователя выбрать его географическое местоположение (город), а не часовой пояс, как это делают остальные сервисы :-) И даже несмотря на это, скажу честно, периодически бывают проблемы.
</p><p>
С хранением времени в прошлом тоже не всё так просто. Если это прошлое — относительно недавнее (скажем, речь идёт о двадцать первом веке), то проблем с хранением времени в UTC быть не должно (хотя гарантий вам, конечно, никто не даст). Если же речь идёт о двадцатом веке или (о, ужас) более давних временах, проблемы гарантированы. Начнём с того, что для многих периодов истории прошлого века, информация о переводе часов постоянно меняется по сей день. Так, например, в обновлении базы данных часовых поясов tzdata версии 2014g от 30 августа 2014 года для ряда часовых поясов СССР были внесены изменения на несколько секунд или минут для дат до 1926 года. Просто кто-то заметил несоответствие и уведомил об этом составителей tzdata. Или вот ещё пример из более близких нам времён: в обновлении tzdata версии 2014a от 9 марта 2014 года изменилась информация о дате перехода Украины с Московского времени на Восточноевропейское: этот переход произошёл не первого января 1992 года (как было записано в этой базе), а первого июля 1990 года.
</p><p>
База данных часовых поясов обновляется несколько раз в год, во всём мире появляются новые таймзоны, меняются правила существующих, актуализируется информация о прошлом времени, постоянно происходят какие-то изменения, и их постоянно необходимо учитывать.

</p><h1>Как же всё-таки правильно хранить время?</h1><p>Итак, как же всё-таки правильно хранить время в базе данных? Лучше, конечно, этого не делать, однако если очень нужно, то вот мои личные рекомендации (буду рад услышать критику или предложения):
</p><ol>
<li>Если вам нужно хранить время только что произошедшего события, текущее время, по факту определённого действия, храните его в UTC. Это могут быть записи в логах, время регистрации пользователя, совершения заказа или отправки письма.</li>
<li>Если время не привязано к пользователю или его часовому поясу, храните его в UTC. Это может быть, например, время следующего солнечного затмения.</li>
<li>Если вам нужно хранить время в прошлом или в будущем, сохраняйте локальное время пользователя, а рядом сохраняйте его таймзону. А ещё лучше, так, чтобы наверняка, сохраняйте географическое положение пользователя. Если нужно делать выборки по этому времени, сохраняйте рядом время в UTC, и обновляйте это время при изменении информации о часовом поясе.</li>
<li>Если вам нужно совершенно точно знать время для любой даты для заданного географического положения (например, для астрономических расчётов) — храните точные координаты пользователя, но не его часовой пояс. Впрочем, если перед вами стоит такая задача, то вы и так знаете, как делать правильно.</li>
</ol><p>
Первый вариант покрывает возможные сценарии использования для 99% программ и, вполне возможно, вам этого будет достаточно. Однако необходимо чётко понимать и осознавать выбор того или иного варианта дейстий.

</p><h1>Работаем со временем</h1><p>С хранением времени, вроде, разобрались. Однако часто можно услышать так же совет «всегда работайте с временем в UTC». Подразумевается, что как только вы получили время от пользователя, его нужно сразу же перевести в UTC и работать только с временем в UTC. Звучит логично, не правда ли?
</p><p>
Неправда. По крайней мере, не во всех случаях, и вот вам конкретный пример.
</p><p>
Вернёмся к нашему примеру с сервисом отложенных сообщений. Всё хорошо, сервис развивается, пользователи довольны, но просят добавить функционал повторяющихся уведомлений. А повторы бывают не только простые («каждый день», «через день», «каждый месяц»), но и достаточно сложные («каждую неделю по вторникам», «каждый месяц в последнюю пятницу месяца» и т.д.). Чтобы не писать свой велосипед для этих повторов, изучим уже готовые решения. Существует такое понятие, как «повторяющиеся события». Существует специальный формат описания правил повторения, который, конечно, учитывает не все возможные варианты (например, нельзя задать «два дня через два»), однако большую часть случаев он покрывает. Примеры применения этого формата можно увидеть в описании поля RRULE </p><a href="https://tools.ietf.org/html/rfc5545#section-3.3.10">спецификации iCalendar</a><p> и в </p><a href="https://labix.org/python-dateutil#head-470fa22b2db72000d7abe698a5783a46b0731b57">документации объекта rrule</a><p> модуля python-dateutil для Python.
</p><p>
Возьмём модуль python-dateutil и используем его в нашем коде. Вроде всё должно быть хорошо, однако пользователи жалуются, и исследование этих жалоб приводит нас с достаточно неожиданным результатам.
</p><p>
Один из вариантов повторяющихся событий — повтор по дням недели. Мы можем описать событие, которое повторяется, например, в 12:00 каждую неделю по вторникам и пятницам. Вот как это может выглядеть на практике, в реальном коде:
</p><pre><code class="python">&gt;&gt;&gt; import datetime
&gt;&gt;&gt; from dateutil import rrule
&gt;&gt;&gt; list(rrule.rrule(rrule.WEEKLY, count=4, byweekday=(rrule.TU, rrule.FR),
                     dtstart=datetime.datetime(2014, 11, 3, 12, 0)))
[datetime.datetime(2014, 11, 4, 12, 0),
 datetime.datetime(2014, 11, 7, 12, 0),
 datetime.datetime(2014, 11, 11, 12, 0),
 datetime.datetime(2014, 11, 14, 12, 0)]
</code></pre><p>
Казалось бы, всё хорошо. Теперь давайте представим себе, что пользователь из Москвы создал повторяющееся событие, которое происходит в час ночи. Как только мы получили от него время «2014-11-03 01:00:00» мы, согласно рекомендациям умных людей, сразу же переводим его в UTC (процесс перевода нас сейчас не интересует, нам следует знать, что фактически мы отнимаем три часа от полученного времени), и получаем следующее время в UTC: datetime.datetime(2014, 11, 2, 23, 0). Пока всё хорошо. Давайте получим повторы для полученного времени:
</p><pre><code class="python">&gt;&gt;&gt; list(rrule.rrule(rrule.WEEKLY, count=4, byweekday=(rrule.TU, rrule.FR),
                     dtstart=datetime.datetime(2014, 11, 2, 23, 0)))
[datetime.datetime(2014, 11, 4, 23, 0),
 datetime.datetime(2014, 11, 7, 23, 0),
 datetime.datetime(2014, 11, 11, 23, 0),
 datetime.datetime(2014, 11, 14, 23, 0)]
</code></pre><p>
Кажется, что-то пошло не так. Если мы переведём полученные значения в локальное время пользователя (прибавим к каждому три часа), мы увидим, что повторы сдвинулись и событие повторяется всё так же в час ночи, но уже по средам и субботам. И это не ошибка модуля python-dateutil, код отработал корректно. Это наша ошибка, в этом конкретном случае нам нужно было работать с локальным временем пользователя.
</p><p>
Кстати, многие сервисы календарей имеют этот баг, например, программа iCal в OS X, в определённых случаях, считает повторы совершенно неправильно.

</p><h1>Не забывайте страдать</h1><p>Вывод можно сделать простой и совершенно банальный: </p><strong>никогда</strong><p> не слушайте категоричных утверждений, рекомендующих вам </p><strong>никогда</strong><p> не делать тех или иных вещей. Всегда продумывайте и прорабатывайте все возможные варианты, особо внимательно прорабатывайте архитектуру проекта, пишите качественные тесты и поддерживайте их в актуальном состоянии.
</p><p>
А работа с таймзонами — это боль и страдание, да. Если есть хоть малейшая возможность не работать с ними — воспользуйтесь ей, не пожалеете. Напоследок приведу пару примеров некорректной работы реальных программ:

</p><strong>Python 2.7.6</strong>
<pre><code class="bash">➜ date
воскресенье,  9 ноября 2014 г. 22:44:32 (MSK)
➜ python -c "import datetime; print datetime.datetime.now()"
2014-11-09 22:44:33.310904
➜ python -c "import datetime; print datetime.datetime.utcnow()"
2014-11-09 19:44:34.405287
</code></pre><p>
Вроде всё хорошо. Смотрим дальше:
</p><pre><code class="bash">➜ date +%z
+0300
➜ python -c "import time; print time.timezone/3600"
-4
</code></pre><p>
WAT? Нет, вроде это </p><a href="http://bugs.python.org/issue22752">не баг, а фича</a><p>, однако никому от этого не легче. Какой вообще смысл в коде, который в любой момент может сломаться (и ломается!)?

</p><strong>Firefox 33.0.3</strong>
<pre><code class="javascript">new Date(2015, 0, 6) 
"Tue Jan 06 2015 00:00:00 GMT+0300 (Russia TZ 2 Standard Time)" 

new Date(2015, 0, 7) 
"Tue Jan 06 2015 23:00:00 GMT+0300 (Russia TZ 2 Standard Time)" 

new Date(2015, 0, 8) 
"Thu Jan 08 2015 00:00:00 GMT+0400 (Russia TZ 2 Daylight Time)"
</code></pre><p>
WAT? Нет, я понимаю, что этот вопрос уже много раз </p><a href="http://habrahabr.ru/post/239423/">поднимался</a><p>, но жить от этого не легче.
</p><p>
В общем, что могу сказать, </p><em>не забывайте страдать</em><p> :-)
</p><p>
А как вы работаете с датами, временем и таймзонами?

</p><i>Владимир Рудных,<br/>
Технический руководитель Календаря Mail.Ru.</i>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>