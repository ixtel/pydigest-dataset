<html><body><div><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-tasktiger" class="anchor" href="#tasktiger" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>TaskTiger</h1>
<a href="https://circleci.com/gh/closeio/tasktiger/tree/master"><img alt="https://circleci.com/gh/closeio/tasktiger/tree/master.svg?style=svg&amp;circle-token=a86617952aa9b4cfee784b6ac43358cd042a6672" src="https://camo.githubusercontent.com/b4aef2abaf087363c1ceba440b41b8c90209bbe8/68747470733a2f2f636972636c6563692e636f6d2f67682f636c6f7365696f2f7461736b74696765722f747265652f6d61737465722e7376673f7374796c653d73766726636972636c652d746f6b656e3d61383636313739353261613962346366656537383462366163343333353863643034326136363732" data-canonical-src="https://circleci.com/gh/closeio/tasktiger/tree/master.svg?style=svg&amp;circle-token=a86617952aa9b4cfee784b6ac43358cd042a6672"/></a>
<p><em>TaskTiger</em> is a Python task queue using Redis.</p>
<p>(Interested in working on projects like this? <a href="http://close.io">Close.io</a> is looking for <a href="http://jobs.close.io">great engineers</a> to join our team)</p>

<a name="user-content-features"/>

<ul>
<li><p>Per-task fork</p>
<p>TaskTiger forks a subprocess for each task, This comes with several benefits:
Memory leaks caused by tasks are avoided since the subprocess is terminated
when the task is finished. A hard time limit can be set for each task, after
which the task is killed if it hasn't completed. To ensure performance, any
necessary Python modules can be preloaded in the parent process.</p>
</li>
<li><p>Unique queues</p>
<p>TaskTiger has the option to avoid duplicate tasks in the task queue. In some
cases it is desirable to combine multiple similar tasks. For example, imagine
a task that indexes objects (e.g. to make them searchable). If an object is
already present in the task queue and hasn't been processed yet, a unique
queue will ensure that the indexing task doesn't have to do duplicate work.
However, if the task is already running while it's queued, the task will be
executed another time to ensure that the indexing task always picks up the
latest state.</p>
</li>
<li><p>Task locks</p>
<p>TaskTiger can ensure to never execute more than one instance of tasks with
similar arguments by acquiring a lock. If a task hits a lock, it is requeued
and scheduled for later executions after a configurable interval.</p>
</li>
<li><p>Task retrying</p>
<p>TaskTiger lets you retry exceptions (all exceptions or a list of specific
ones) and comes with configurable retry intervals (fixed, linear,
exponential, custom).</p>
</li>
<li><p>Flexible queues</p>
<p>Tasks can be easily queued in separate queues. Workers pick tasks from a
randomly chosen queue and can be configured to only process specific queues,
ensuring that all queues are processed equally. TaskTiger also supports
subqueues which are separated by a period. For example, you can have
per-customer queues in the form <code>process_emails.CUSTOMER_ID</code> and start a
worker to process <code>process_emails</code> and any of its subqueues. Since tasks
are picked from a random queue, all customers get equal treatment: If one
customer is queueing many tasks it can't block other customers' tasks from
being processed.</p>
</li>
<li><p>Batch queues</p>
<p>Batch queues can be used to combine multiple queued tasks into one. That way,
your task function can process multiple sets of arguments at the same time,
which can improve performance. The batch size is configurable.</p>
</li>
<li><p>Scheduled tasks</p>
<p>Tasks can be scheduled for execution at a specific time.</p>
</li>
<li><p>Structured logging</p>
<p>TaskTiger supports JSON-style logging via structlog, allowing more
flexibility for tools to analyze the log. For example, you can use TaskTiger
together with Logstash, Elasticsearch, and Kibana.</p>
</li>
<li><p>Reliability</p>
<p>TaskTiger atomically moves tasks between queue states, and will re-execute
tasks after a timeout if a worker crashes.</p>
</li>
<li><p>Error handling</p>
<p>If an exception occurs during task execution and the task is not set up to be
retried, TaskTiger stores the execution tracebacks in an error queue. The
task can then be retried or deleted manually. TaskTiger can be easily
integrated with error reporting services like Rollbar.</p>
</li>
<li><p>Admin interface</p>
<p>A simple admin interface using flask-admin exists as a separate project
(<a href="https://github.com/closeio/tasktiger-admin">tasktiger-admin</a>).</p>
</li>
</ul>
<a name="user-content-quick-start"/>

<p>It is easy to get started with TaskTiger.</p>
<p>Create a file that contains the task(s).</p>
<div class="highlight highlight-source-python"><pre><span class="pl-c"># tasks.py</span>
<span class="pl-k">def</span> <span class="pl-en">my_task</span>():
    <span class="pl-c1">print</span> <span class="pl-s"><span class="pl-pds">'</span>Hello<span class="pl-pds">'</span></span></pre></div>
<p>Queue the task using the <code>delay</code> method.</p>
<div class="highlight highlight-source-python"><pre>In [<span class="pl-c1">1</span>]: <span class="pl-k">import</span> tasktiger, tasks
In [<span class="pl-c1">2</span>]: tiger <span class="pl-k">=</span> tasktiger.TaskTiger()
In [<span class="pl-c1">3</span>]: tiger.delay(tasks.my_task)</pre></div>
<p>Run a worker.</p>
<div class="highlight highlight-source-shell"><pre>% tasktiger
{<span class="pl-s"><span class="pl-pds">"</span>timestamp<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>2015-08-27T21:00:09.135344Z<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>queues<span class="pl-pds">"</span></span>: null, <span class="pl-s"><span class="pl-pds">"</span>pid<span class="pl-pds">"</span></span>: 69840, <span class="pl-s"><span class="pl-pds">"</span>event<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>ready<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>level<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>info<span class="pl-pds">"</span></span>}
{<span class="pl-s"><span class="pl-pds">"</span>task_id<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>6fa07a91642363593cddef7a9e0c70ae3480921231710aa7648b467e637baa79<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>level<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>debug<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>timestamp<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>2015-08-27T21:03:56.727051Z<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>pid<span class="pl-pds">"</span></span>: 69840, <span class="pl-s"><span class="pl-pds">"</span>queue<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>default<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>child_pid<span class="pl-pds">"</span></span>: 70171, <span class="pl-s"><span class="pl-pds">"</span>event<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>processing<span class="pl-pds">"</span></span>}
Hello
{<span class="pl-s"><span class="pl-pds">"</span>task_id<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>6fa07a91642363593cddef7a9e0c70ae3480921231710aa7648b467e637baa79<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>level<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>debug<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>timestamp<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>2015-08-27T21:03:56.732457Z<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>pid<span class="pl-pds">"</span></span>: 69840, <span class="pl-s"><span class="pl-pds">"</span>queue<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>default<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>event<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>done<span class="pl-pds">"</span></span>}</pre></div>
<a name="user-content-configuration"/>

<p>A <code>TaskTiger</code> object keeps track of TaskTiger's settings and is used to
decorate and queue tasks. The constructor takes the following arguments:</p>
<ul>
<li><p><code>connection</code></p>
<p>Redis connection object</p>
</li>
<li><p><code>config</code></p>
<p>Dict with config options. Most configuration options don't need to be
changed, and a full list can be seen within <code>TaskTiger</code>'s <code>__init__</code>
method.</p>
</li>
<li><p><code>setup_structlog</code></p>
<p>If set to True, sets up structured logging using <code>structlog</code> when
initializing TaskTiger. This makes writing custom worker scripts easier
since it doesn't require the user to set up <code>structlog</code> in advance.</p>
</li>
</ul>
<p>Example:</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> tasktiger
<span class="pl-k">from</span> redis <span class="pl-k">import</span> Redis
conn <span class="pl-k">=</span> redis.Redis(<span class="pl-v">db</span><span class="pl-k">=</span><span class="pl-c1">1</span>)
tiger <span class="pl-k">=</span> tasktiger.TaskTiger(<span class="pl-v">connection</span><span class="pl-k">=</span>conn, <span class="pl-v">config</span><span class="pl-k">=</span>{
    <span class="pl-s"><span class="pl-pds">'</span>BATCH_QUEUES<span class="pl-pds">'</span></span>: { <span class="pl-s"><span class="pl-pds">'</span>batch<span class="pl-pds">'</span></span>: <span class="pl-c1">10</span> },
})</pre></div>
<a name="user-content-task-decorator"/>

<p>TaskTiger provides a task decorator to specify task options. Note that simple
tasks don't need to be decorated. However, decorating the task allows you to
use an alternative syntax to queue the task, which is compatible with Celery:</p>
<div class="highlight highlight-source-python"><pre><span class="pl-c"># tasks.py</span>

<span class="pl-k">import</span> tasktiger
tiger <span class="pl-k">=</span> tasktiger.TaskTiger()

<span class="pl-en">@tiger.task</span>()
<span class="pl-k">def</span> <span class="pl-en">my_task</span>(<span class="pl-smi">name</span>, <span class="pl-smi">n</span><span class="pl-k">=</span><span class="pl-c1">None</span>):
    <span class="pl-c1">print</span> <span class="pl-s"><span class="pl-pds">'</span>Hello<span class="pl-pds">'</span></span>, name</pre></div>
<div class="highlight highlight-source-python"><pre>In [<span class="pl-c1">1</span>]: <span class="pl-k">import</span> tasks
<span class="pl-c"># The following are equivalent. However, the second syntax can only be used</span>
<span class="pl-c"># if the task is decorated.</span>
In [<span class="pl-c1">2</span>]: tasks.tiger.delay(my_task, <span class="pl-v">args</span><span class="pl-k">=</span>(<span class="pl-s"><span class="pl-pds">'</span>John<span class="pl-pds">'</span></span>,), <span class="pl-v">kwargs</span><span class="pl-k">=</span>{<span class="pl-s"><span class="pl-pds">'</span>n<span class="pl-pds">'</span></span>: <span class="pl-c1">1</span>})
In [<span class="pl-c1">3</span>]: tasks.my_task.delay(<span class="pl-s"><span class="pl-pds">'</span>John<span class="pl-pds">'</span></span>, <span class="pl-v">n</span><span class="pl-k">=</span><span class="pl-c1">1</span>)</pre></div>
<a name="user-content-task-options"/>

<p>Tasks support a variety of options that can be specified either in the task
decorator, or when queueing a task. For the latter, the <code>delay</code> method must
be called on the <code>TaskTiger</code> object, and any options in the task decorator
are overridden.</p>
<div class="highlight highlight-source-python"><pre><span class="pl-en">@tiger.task</span>(<span class="pl-v">queue</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>myqueue<span class="pl-pds">'</span></span>, <span class="pl-v">unique</span><span class="pl-k">=</span><span class="pl-c1">True</span>)
<span class="pl-k">def</span> <span class="pl-en">my_task</span>():
    <span class="pl-c1">print</span> <span class="pl-s"><span class="pl-pds">'</span>Hello<span class="pl-pds">'</span></span></pre></div>
<div class="highlight highlight-source-python"><pre><span class="pl-c"># The task will be queued in "otherqueue", even though the task decorator</span>
<span class="pl-c"># says "myqueue".</span>
tiger.delay(my_task, <span class="pl-v">queue</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>otherqueue<span class="pl-pds">'</span></span>)</pre></div>
<p>When queueing a task, the task needs to be defined in a module other than the
Python file which is being executed. In other words, the task can't be in the
<code>__main__</code> module. TaskTiger will give you back an error otherwise.</p>
<p>The following options are supported for <code>delay</code>:</p>
<ul>
<li><p><code>queue</code></p>
<p>Name of the queue where the task will be queued.</p>
</li>
<li><p><code>hard_timeout</code></p>
<p>If the task runs longer than the given number of seconds, it will be
killed and marked as failed.</p>
</li>
<li><p><code>unique</code></p>
<p>The task will only be queued if there is no similar task with the
same function, arguments, and keyword arguments in the queue. Note
that multiple similar tasks may still be executed at the same time
since the task will still be inserted into the queue if another one
is being processed.</p>
</li>
<li><p><code>lock</code></p>
<p>Hold a lock while the task is being executed (with the given args and
kwargs). If a task with similar args/kwargs is queued and tries to
acquire the lock, it will be retried later.</p>
</li>
<li><p><code>lock_key</code></p>
<p>If set, this implies lock=True and specifies the list of kwargs to
use to construct the lock key. By default, all args and kwargs are
serialized and hashed.</p>
</li>
<li><p><code>when</code></p>
<p>Takes either a datetime (for an absolute date) or a timedelta
(relative to now). If given, the task will be scheduled for the given
time.</p>
</li>
<li><p><code>retry</code></p>
<p>Whether to retry a task when it fails (either because of an exception
or because of a timeout). To restrict the list of failures, use
retry_on. Unless retry_method is given, the configured
<code>DEFAULT_RETRY_METHOD</code> is used.</p>
</li>
<li><p><code>retry_on</code></p>
<p>If a list is given, it implies <code>retry=True</code>. Task will be only retried
on the given exceptions (or its subclasses). To retry the task when a
hard timeout occurs, use <code>JobTimeoutException</code>.</p>
</li>
<li><p><code>retry_method</code></p>
<p>If given, implies <code>retry=True</code>. Pass either:</p>
<ul>
<li>a function that takes the retry number as an argument, or,</li>
<li>a tuple <code>(f, args)</code>, where <code>f</code> takes the retry number as the first
argument, followed by the additional args.</li>
</ul>
<p>The function needs to return the desired retry interval in seconds,
or raise StopRetry to stop retrying. The following built-in functions
can be passed for common scenarios and return the appropriate tuple:</p>
<ul>
<li><p><code>fixed(delay, max_retries)</code></p>
<p>Returns a method that returns the given delay or raises StopRetry
if the number of retries exceeds max_retries.</p>
</li>
<li><p><code>linear(delay, increment, max_retries)</code></p>
<p>Like fixed, but starts off with the given delay and increments it
by the given increment after every retry.</p>
</li>
<li><p><code>exponential(delay, factor, max_retries)</code></p>
<p>Like fixed, but starts off with the given delay and multiplies it
by the given factor after every retry.</p>
</li>
</ul>
</li>
</ul>
<p>The following options can be only specified in the task decorator:</p>
<ul>
<li><p><code>batch</code></p>
<p>If set to <code>True</code>, the task will receive a list of dicts with args and
kwargs and can process multiple tasks of the same type at once.
Example: <code>[{"args": [1], "kwargs": {}}, {"args": [2], "kwargs": {}}]</code>
Note that the list will only contain multiple items if the worker
has set up <code>BATCH_QUEUES</code> for the specific queue.</p>
</li>
</ul>
<a name="user-content-custom-retrying"/>

<p>In some cases the task retry options may not be flexible enough. For example,
you might want to use a different retry method depending on the exception type,
or you might want to like to suppress logging an error if a task fails after
retries. In these cases, <code>RetryException</code> can be raised within the task
function. The following options are supported:</p>
<ul>
<li><p><code>method</code></p>
<p>Specify a custom retry method for this retry. If not given, the task's
default retry method is used, or, if unspecified, the configured
<code>DEFAULT_RETRY_METHOD</code>. Note that the number of retries passed to the
retry method is always the total number of times this method has been
executed, regardless of which retry method was used.</p>
</li>
<li><p><code>original_traceback</code></p>
<p>If <code>RetryException</code> is raised from within an except block and
<code>original_traceback</code> is True, the original traceback will be logged (i.e.
the stacktrace at the place where the caught exception was raised). False by
default.</p>
</li>
<li><p><code>log_error</code></p>
<p>If set to False and the task fails permanently, a warning will be logged
instead of an error, and the task will be removed from Redis when it
completes. True by default.</p>
</li>
</ul>
<p>Example usage:</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> tasktiger.exceptions <span class="pl-k">import</span> RetryException

<span class="pl-k">def</span> <span class="pl-en">my_task</span>():
    <span class="pl-k">if</span> <span class="pl-k">not</span> ready():
        <span class="pl-c"># Retry every minute up to 3 times if we're not ready. An error will</span>
        <span class="pl-c"># be logged if we're out of retries.</span>
        <span class="pl-k">raise</span> RetryException(<span class="pl-v">method</span><span class="pl-k">=</span>fixed(<span class="pl-c1">60</span>, <span class="pl-c1">3</span>))

    <span class="pl-k">try</span>:
        some_code()
    <span class="pl-k">except</span> NetworkException:
        <span class="pl-c"># Back off exponentially up to 5 times in case of a network failure.</span>
        <span class="pl-c"># Log the original traceback (as a warning) and don't log an error if</span>
        <span class="pl-c"># we still fail after 5 times.</span>
        <span class="pl-k">raise</span> RetryException(<span class="pl-v">method</span><span class="pl-k">=</span>exponential(<span class="pl-c1">60</span>, <span class="pl-c1">2</span>, <span class="pl-c1">5</span>),
                             <span class="pl-v">original_traceback</span><span class="pl-k">=</span><span class="pl-c1">True</span>,
                             <span class="pl-v">log_error</span><span class="pl-k">=</span><span class="pl-c1">False</span>)</pre></div>
<a name="user-content-workers"/>

<p>The <code>tasktiger</code> command is used on the command line to invoke a worker. To
invoke multiple workers, multiple instances need to be started. This can be
easily done e.g. via Supervisor. The following Supervisor configuration file
can be placed in <code>/etc/supervisor/tasktiger.ini</code> and runs 4 TaskTiger workers
as the <code>ubuntu</code> user. For more information, read Supervisor's documentation.</p>
<div class="highlight highlight-source-shell"><pre>[program:tasktiger]
<span class="pl-c1">command</span>=/usr/local/bin/tasktiger
process_name=%(program_name)s_%(process_num)02d
numprocs=4
numprocs_start=0
priority=999
autostart=<span class="pl-c1">true</span>
autorestart=<span class="pl-c1">true</span>
startsecs=10
startretries=3
exitcodes=0,2
stopsignal=TERM
stopwaitsecs=600
killasgroup=<span class="pl-c1">false</span>
user=ubuntu
redirect_stderr=<span class="pl-c1">false</span>
stdout_logfile=/var/log/tasktiger.out.log
stdout_logfile_maxbytes=250MB
stdout_logfile_backups=10
stderr_logfile=/var/log/tasktiger.err.log
stderr_logfile_maxbytes=250MB
stderr_logfile_backups=10</pre></div>
<p>Workers support the following options:</p>
<ul>
<li><p><code>-q</code>, <code>--queues</code></p>
<p>If specified, only the given queue(s) are processed. Multiple queues can be
separated by comma. Any subqueues of the given queues will be also processed.
For example, <code>-q first,second</code> will process items from <code>first</code>,
<code>second</code>, and subqueues such as <code>first.CUSTOMER1</code>, <code>first.CUSTOMER2</code>.</p>
</li>
<li><p><code>-m</code>, <code>--module</code></p>
<p>Module(s) to import when launching the worker. This improves task performance
since the module doesn't have to be reimported every time a task is forked.
Multiple modules can be separated by comma.</p>
<p>Another way to preload modules is to set up a custom TaskTiger launch script,
which is described below.</p>
</li>
<li><p><code>-h</code>, <code>--host</code></p>
<p>Redis server hostname (if different from <code>localhost</code>).</p>
</li>
<li><p><code>-p</code>, <code>--port</code></p>
<p>Redis server port (if different from <code>6379</code>).</p>
</li>
<li><p><code>-a</code>, <code>--password</code></p>
<p>Redis server password (if required).</p>
</li>
<li><p><code>-n</code>, <code>--db</code></p>
<p>Redis server database number (if different from <code>0</code>).</p>
</li>
</ul>
<p>In some cases it is convenient to have a custom TaskTiger launch script. For
example, your application may have a <code>manage.py</code> command that sets up the
environment and you may want to launch TaskTiger workers using that script. To
do that, you can use the <code>run_worker_with_args</code> method, which launches a
TaskTiger worker and parses any command line arguments. Here is an example:</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> sys
<span class="pl-k">from</span> tasktiger <span class="pl-k">import</span> TaskTiger

<span class="pl-k">try</span>:
    command <span class="pl-k">=</span> sys.argv[<span class="pl-c1">1</span>]
<span class="pl-k">except</span> <span class="pl-c1">IndexError</span>:
    command <span class="pl-k">=</span> <span class="pl-c1">None</span>

<span class="pl-k">if</span> command <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>tasktiger<span class="pl-pds">'</span></span>:
    tiger <span class="pl-k">=</span> TaskTiger(<span class="pl-v">setup_structlog</span><span class="pl-k">=</span><span class="pl-c1">True</span>)
    <span class="pl-c"># Strip the "tasktiger" arg when running via manage, so we can run e.g.</span>
    <span class="pl-c"># ./manage.py tasktiger --help</span>
    tiger.run_worker_with_args(sys.argv[<span class="pl-c1">2</span>:])
    sys.exit(<span class="pl-c1">0</span>)</pre></div>
<p>Note that if you're using <code>flask-script</code>, you will still need to manually
evaluate <code>sys.argv</code> to ensure proper argument parsing, instead of using a
<code>flask-script</code> command.</p>
<a name="user-content-inspect-requeue-and-delete-tasks"/>

<p>TaskTiger does not currently come with an admin interface, but provides access
to the <code>Task</code> class which lets you inspect queues and requeue and delete
tasks.</p>
<p>Each queue can have tasks in the following states:</p>
<ul>
<li><code>queued</code>: Tasks that are queued and waiting to be picked up by the workers.</li>
<li><code>active</code>: Tasks that are currently being processed by the workers.</li>
<li><code>scheduled</code>: Tasks that are scheduled for later execution.</li>
<li><code>error</code>: Tasks that failed with an error.</li>
</ul>
<p>To get a list of all tasks for a given queue and state, use
<code>Task.tasks_from_queue</code>. The method gives you back a tuple containing the
total number of tasks in the queue (useful if the tasks are truncated) and a
list of tasks in the queue, latest first. Using the <code>skip</code> and <code>limit</code>
keyword arguments, you can fetch arbitrary slices of the queue. If you know the
task ID, you can fetch a given task using <code>Task.from_id</code>. Both methods let
you load tracebacks from failed task executions using the <code>load_executions</code>
keyword argument, which accepts an integer indicating how many executions
should be loaded.</p>
<p>The <code>Task</code> object has the following properties:</p>
<ul>
<li><code>id</code>: The task ID.</li>
<li><code>data</code>: The raw data as a dict from Redis.</li>
<li><code>executions</code>: A list of failed task executions (as dicts). An execution
dict contains the processing time in <code>time_started</code> and <code>time_failed</code>,
the worker host in <code>host</code>, the exception name in <code>exception_name</code> and
the full traceback in <code>traceback</code>.</li>
<li><code>func</code>, <code>args</code>, <code>kwargs</code>: The serialized function name with all of its
arguments.</li>
</ul>
<p>The <code>Task</code> object has the following methods. Note that these methods only
work for tasks that are in the error queue.</p>
<ul>
<li><code>retry</code>: Requeue the task for execution.</li>
<li><code>delete</code>: Remove the task from the error queue.</li>
</ul>
<p>Example:</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">from</span> tasktiger <span class="pl-k">import</span> TaskTiger
<span class="pl-k">from</span> tasktiger.task <span class="pl-k">import</span> Task

<span class="pl-c1">QUEUE_NAME</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>default<span class="pl-pds">'</span></span>
<span class="pl-c1">TASK_STATE</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>error<span class="pl-pds">'</span></span>
<span class="pl-c1">TASK_ID</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>6fa07a91642363593cddef7a9e0c70ae3480921231710aa7648b467e637baa79<span class="pl-pds">'</span></span>

tiger <span class="pl-k">=</span> TaskTiger()

n_total, tasks <span class="pl-k">=</span> Task.tasks_from_queue(tiger, <span class="pl-c1">QUEUE_NAME</span>, <span class="pl-c1">TASK_STATE</span>)

<span class="pl-k">for</span> task <span class="pl-k">in</span> tasks:
    <span class="pl-c1">print</span> task.id, task.func

task <span class="pl-k">=</span> Task.from_id(tiger, <span class="pl-c1">QUEUE_NAME</span>, <span class="pl-c1">TASK_STATE</span>, <span class="pl-c1">TASK_ID</span>)
task.retry()</pre></div>
<a name="user-content-rollbar-error-handling"/>

<p>TaskTiger comes with Rollbar integration for error handling. When a task errors
out, it can be logged to Rollbar, grouped by queue, task function name and
exception type. To enable logging, initialize rollbar with the
<code>StructlogRollbarHandler</code> provided in the <code>tasktiger.rollbar</code> module. The
handler takes a string as an argument which is used to prefix all the messages
reported to Rollbar. Here is a custom worker launch script:</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> logging
<span class="pl-k">import</span> rollbar
<span class="pl-k">import</span> sys
<span class="pl-k">from</span> tasktiger <span class="pl-k">import</span> TaskTiger
<span class="pl-k">from</span> tasktiger.rollbar <span class="pl-k">import</span> StructlogRollbarHandler

tiger <span class="pl-k">=</span> TaskTiger(<span class="pl-v">setup_structlog</span><span class="pl-k">=</span><span class="pl-c1">True</span>)

rollbar.init(<span class="pl-c1">ROLLBAR_API_KEY</span>, <span class="pl-c1">APPLICATION_ENVIRONMENT</span>,
             <span class="pl-v">allow_logging_basic_config</span><span class="pl-k">=</span><span class="pl-c1">False</span>)
rollbar_handler <span class="pl-k">=</span> StructlogRollbarHandler(<span class="pl-s"><span class="pl-pds">'</span>TaskTiger<span class="pl-pds">'</span></span>)
rollbar_handler.setLevel(logging.<span class="pl-c1">ERROR</span>)
tiger.log.addHandler(rollbar_handler)

tiger.run_worker_with_args(sys.argv[<span class="pl-c1">1</span>:])</pre></div>

</article>
  </div></body></html>