<html><body><div><div class="content html_format">
      <div class="spoiler"><b class="spoiler_title">От переводчика</b><div class="spoiler_text"><p>Как всегда вольный перевод интересной статьи о конкретном подходе к организации кода в django-приложениях. Будет полезна:</p>
<ul>
<li>Тем, кто еще не задумывался о таких вопросах</li>
<li>Тем, кто уже имеет собственные взгляды на организацию логики, но не против оценить альтернативные варианты</li>
<li>Тем, кто уже использует обсуждаемый подход, для подтверждения своих мыслей</li>
<li>Тем, кто уже не использует обсуждаемый подход и имеет аргументы против</li>
</ul><p>
Большого количества кода не будет, статья по большей части дискуссионная. Энжой)
</p></div></div>

<img src="https://habrastorage.org/getpro/habr/post_images/fcb/f5b/d4e/fcbf5bd4e871347d3b0d77bb28a1e405.png" alt="image"/>
<i>Толстые модели.</i>
<a name="habracut"/>
<h2>Интро</h2><p>
Большинство django-туториалов и примеров по этому фреймворку подают плохой пример новичкам в плане организации кода в их проектах. В случае крупного/долгоиграющего приложения, структура кода, подчерпнутая из подобных примеров, может стать причиной нетривиальных проблем и сложных ситуаций в процессе разработки. В данной статье я опишу альтернативный, достаточно редко встречающийся подход к организации кода, который, надеюсь, покажется вам интересным.

</p><h2>MVC в django = MTV + встроенное C</h2><p>
Пытались когда-нибудь объяснить как устроено MTV в django, скажем, RoR-девелоперу? Кто-то может подумать, что шаблоны – это представления, а представления – это контроллеры. Не совсем так. Контроллер – это встроенный в django URL-маршрутизатор, который обеспечивает логику запрос-ответ. Представления нужны для представления нужных данных в нужных шаблонах. Шаблоны и представления совокупно составляют «презентационный» слой фреймворка.
</p><p>
В подобном MTV много плюсов – с его помощью можно легко и быстро создавать типовые и не только приложения. Тем не менее, остаётся неясным где должна храниться логика по обработке и правке данных, куда абстрагировать код в каких случаях. Давайте оценим несколько разных подходов и посмотрим на результаты их применения.

</p><h2>Логика в представлениях</h2><p>
Засунуть всю или большую часть логики во вьюхи. Подход, наиболее часто встречающийся в различных туториалах и у новичков. Выглядит как-то так:

</p><pre><code class="python">def accept_quote(request, quote_id, template_name="accept-quote.html"):

    quote = Quote.objects.get(id=quote_id)
    form = AcceptQuoteForm()

    if request.METHOD == 'POST':
        form = AcceptQuoteForm(request.POST)
        if form.is_valid():

            quote.accepted = True
            quote.commission_paid = False

            # назначаем комиссию
            provider_credit_card = CreditCard.objects.get(user=quote.provider)
            braintree_result = braintree.Transaction.sale({
                'customer_id': provider_credit_card.token,
                'amount': quote.commission_amount,
            })
            if braintree_result.is_success:
                quote.commission_paid = True
                transaction = Transaction(card=provider_credit_card,
                                          trans_id = result.transaction.id)
                transaction.save()
                quote.transaction = transaction
            elif result.transaction:
                # обрабатываем ошибку, позже таск будет передан в celery
                logger.error(result.message)
            else:
                # обрабатываем ошибку, позже таск будет передан в celery
                logger.error('; '.join(result.errors.deep_errors))

            quote.save()
            return redirect('accept-quote-success-page')

    data = {
        'quote': quote,
        'form': form,
    }
    return render(request, template_name, data)
</code></pre>
<p>
Предельно просто, поэтому на первый взгляд привлекательно – весь код в одном месте, не нужно напрягать мозг и что-то там абстрагировать. Но это только на первый взгляд. Подобный подход плохо масштабируется и быстро приводит к потере читаемости. Я имел счастье лицезреть представления на полтысячи строк кода, от которых даже у матерых девелоперов сводило скулы и сжимались кулачки. Толстые вьюхи ведут к дублированию и усложнению кода, их тяжело тестировать и дебажить и, как следствие, – легко сломать.

</p><h2>Логика в формах</h2><p>
Формы в django объектно-ориентированы, в них происходит валидация и очистка данных, в силу чего их также можно рассматривать, как место размещения логики.

</p><pre><code class="python">def accept_quote(request, quote_id, template_name="accept-quote.html"):

    quote = Quote.objects.get(id=quote_id)
    form = AcceptQuoteForm()

    if request.METHOD == 'POST':
        form = AcceptQuoteForm(request.POST)
        if form.is_valid():

            # инкапсулируем логику в форме
            form.accept_quote()
            success = form.charge_commission()
            return redirect('accept-quote-success-page')

    data = {
        'quote': quote,
        'form': form,
    }
    return render(request, template_name, data)
</code></pre>
<p>
Уже лучше. Проблема в том, что теперь форма для приёма оплаты также занимается обработкой комиссий по кредитным картам. Некомильфо. Что если мы захотим использовать данную функцию в каком-то другом месте? Мы, разумеется, умны и могли бы закодить необходимые примеси, но опять-таки, что если данная логика понадобится нам в консоли, в celery или другом внешнем приложении? Решение инстанцировать форму для работы с моделью не выглядит правильным.

</p><h2>Код в представлениях на основе классов</h2><p>
Подход очень похож на предыдущий – те же преимущества, те же недостатки. У нас нет доступа к логике из консоли и из внешних приложений. Более того, усложняется схема наследования вьюх в проекте.

</p><h2>utils.py</h2><p>
Еще один простой и заманчивый подход – абстрагировать из представлений весь побочный код и вынести его в виде utility-функций в отдельный файл. Казалось бы, быстрое решение всех проблем (которое многие в итоге и выбирают), но давайте немного поразмыслим.

</p><pre><code class="python">def accept_quote(request, quote_id, template_name="accept-quote.html"):

    quote = Quote.objects.get(id=quote_id)
    form = AcceptQuoteForm()

    if request.METHOD == 'POST':
        form = AcceptQuoteForm(request.POST)
        if form.is_valid():

            # инкапсулируем логику в utility-функции
            accept_quote_and_charge(quote)
            return redirect('accept-quote-success-page')

    data = {
        'quote': quote,
        'form': form,
    }
    return render(request, template_name, data)
</code></pre>
<p>
Первая проблема в том, что расположение таких функций может быть неочевидно, код относящийся к определённым моделям может быть размазан по нескольким пакетам. Вторая проблема в том, что когда ваш проект вырастет и над ним начнут работать новые / другие люди, будет неясно какие функции вообще существуют. Что, в свою очередь, увеличивает время разработки, раздражает девелоперов и может стать причиной дублирования кода. Определённые вещи можно отловить на код-ревью, но это уже решение постфактум.

</p><h2>Решение: толстые модели и жирные менеджеры</h2><p>
Модели и их менеджеры являются идеальным местом для инкапсуляции кода, предназначенного для обработки и обновления данных, особенно, когда такой код логически или функционально завязан на возможности ORM. По сути, мы расширяем API модели собственными методами.

</p><pre><code class="python">def accept_quote(request, quote_id, template_name="accept-quote.html"):

    quote = Quote.objects.get(id=quote_id)
    form = AcceptQuoteForm()

    if request.METHOD == 'POST':
        form = AcceptQuoteForm(request.POST)
        if form.is_valid():

            # инкапсулируем логику в методе модели
            quote.accept()
            return redirect('accept-quote-success-page')

    data = {
        'quote': quote,
        'form': form,
    }
    return render(request, template_name, data)
</code></pre>
<p>
На мой вкус, подобное решение является самым правильным. Код по обработке кредитных карт изящно инкапсулирован, логика находится в релевантном для неё месте, нужную функциональность легко найти и (пере)использовать.

</p><h2>Резюме: общий алгоритм</h2><p>
Куда писать код </p><s>бле@ть</s><p>? Если ваша логика завязана на объект request, то ей, вероятно, самое место в представлении. В противном случае, рассмотрите следующий порядок вариантов:
</p><ul>
<li>Код в методе модели</li>
<li>Код в методе менеджера</li>
<li>Код в методе формы</li>
<li>Код в методе CBV</li>
</ul><p>
Если ни один из вариантов не подошел, возможно стоит рассмотреть абстрагирование в отдельную utility-функцию.

</p><h2>TL;DR</h2><p>
Логика в моделях улучшает django-приложения </p><s>не говоря уже о ваших волосах</s><p>.

</p><h2>Бонус</h2><p>
В комментариях к оригинальному топику проскользнули ссылки на два интересных приложения, близких теме статьи.

</p><a href="https://github.com/kmmbvnr/django-fsm">github.com/kmmbvnr/django-fsm</a><p> – </p><i>поддержка конечного автомата для django-моделей</i><p> (из описания). Устанавливаете на модель поле FSMField и отслеживаете изменение заранее предопределенных состояний с помощью декоратора в духе  </p><a href="http://habrahabr.ru/users/receiver/" class="user_link">receiver</a><p>.

</p><a href="https://github.com/adamhaney/django-ondelta">github.com/adamhaney/django-ondelta</a><p> – </p><i>примесь для django-моделей, позволяющая обрабатывать изменения в полях модели. Предоставляет API в стиле собственных clean_*-методов модели</i><p>. Делает именно то, что указано в описании.
</p><p>
Там же был предложен еще один подход – абстрагировать весь код, относящийся к бизнес-логике в отдельный модуль. Например, в приложении prices выделяем весь код, ответственный за обработку цен, в модуль processing. Сходно с подходом utils.py, отличается тем, что абстрагируем бизнес-логику, а не всё подряд.
</p><p>
В собственных проектах я в целом использую подход автора статьи, придерживаясь такой логики:
</p><ul>
<li>Код в методе модели – <i>если код относится к конкретному инстансу модели</i></li>
<li>Код в методе менеджера – <i>если код затрагивает всю соответствующую таблицу</i></li>
<li>Код в методе формы – <i>если код валидирует и/или предобрабатывает данные из запроса</i></li>
<li>Код в методе CBV – <i>то, что относится к request и по остаточному принципу</i></li>
<li>В utils.py – <i>код, не относящийся напрямую к проекту</i></li>
</ul><p>
Обсудим?
      </p><p class="clear"/>
    </div>

    
  </div></body></html>