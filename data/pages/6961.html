<html><body><div><div class="entry-content">
                
                <p>When working with multi-dimensional arrays, one important decision programmers
have to make fairly early on in the project is what memory layout to use for
storing the data, and how to access such data in the most efficient manner.
Since computer memory is inherently linear - a one-dimensional structure,
mapping multi-dimensional data on it can be done in several ways. In this
article I want to examine this topic in detail, talking about the various memory
layouts available and their effect on the performance of the code.</p>
<div class="section" id="row-major-vs-column-major">
<h2>Row-major vs. column-major</h2>
<p>By far the two most common memory layouts for multi-dimensional array data are
<em>row-major</em> and <em>column-major</em>.</p>
<p>When working with 2D arrays (matrices), row-major vs. column-major are easy to
describe. The row-major layout of a matrix puts the first row in contiguous
memory, then the second row right after it, then the third, and so on.
Column-major layout puts the first column in contiguous memory, then the second,
etc.</p>
<p>Higher dimensions are a bit more difficult to visualize, so let's start with
some diagrams showing how 2D layouts work.</p>
</div>
<div class="section" id="d-row-major">
<h2>2D row-major</h2>
<p>First, some notes on the nomenclature of this article. Computer memory will be
represented as a linear array with low addresses on the left and high addresses
on the right. Also, we're going to use programmer notation for matrices: rows
and columns start with zero, at the top-left corner of the matrix. Row indices
go over rows from top to bottom; column indices go over columns from left to
right.</p>
<p>As mentioned above, in row-major layout, the first row of the matrix is placed
in contiguous memory, then the second, and so on:</p>
<img alt="Row major 2D" class="align-center" src="http://eli.thegreenplace.net/images/2015/row-major-2D.png"/>
<p>Another way to describe row-major layout is that <em>column indices change the
fastest</em>. This should be obvious by looking at the linear layout at the bottom
of the diagram. If you read the element index pairs from left to right, you'll
notice that the column index changes all the time, and the row index only
changes once per row.</p>
<p>For programmers, another important observation is that given a row index
<img alt="&lt;math&gt;" class="valign-m3" src="http://eli.thegreenplace.net/images/math/256e11c46808f68dec43d4a7b0e271f05d697785.png"/> and a column index <img alt="&lt;math&gt;" class="valign-m3" src="http://eli.thegreenplace.net/images/math/e0ebbfb8bc0af1c2247c6c3f9119be855fed933d.png"/>, the offset of the element
they denote in the linear representation is:</p>
<img alt="&lt;math&gt;" class="align-center" src="http://eli.thegreenplace.net/images/math/9161443cbcdff4891bbda9b82127634630ad8952.png"/>
<p>Where NCOLS is the number of columns per row in the matrix. It's easy to see
this equation fits the linear layout in the diagram shown above.</p>
</div>
<div class="section" id="d-column-major">
<h2>2D column-major</h2>
<p>Describing column-major 2D layout is just taking the description of row-major
and replacing every appearance of "row" by "column" and vice versa. The first
column of the matrix is placed in contiguous memory, then the second, and so on:</p>
<img alt="Column major 2D" class="align-center" src="http://eli.thegreenplace.net/images/2015/column-major-2D.png"/>
<p>In column-major layout, <em>row indices change the fastest</em>. The offset of an
element in column-major layout can be found using this equation:</p>
<img alt="&lt;math&gt;" class="align-center" src="http://eli.thegreenplace.net/images/math/ab533f15375dcdb69e7affdd1a4c835e146b7751.png"/>
<p>Where NROWS is the number of rows per column in the matrix.</p>
</div>
<div class="section" id="beyond-2d-indexing-and-layout-of-n-dimensional-arrays">
<h2>Beyond 2D - indexing and layout of N-dimensional arrays</h2>
<p>Even though matrices are the most common multi-dimensional arrays
programmers deal with, they are by no means the only ones. The notation of
multi-dimensional arrays is fully generalizable to more than 2 dimensions. These
entities are commonly called "N-D arrays" or "tensors".</p>
<p>When we move to 3D and beyond, it's best to leave the row/column notation of
matrices behind. This is because this notation doesn't easily translate to 3
dimensions due to a <a class="reference external" href="http://eli.thegreenplace.net/2014/meshgrids-and-disambiguating-rows-and-columns-from-cartesian-coordinates/">common confusion</a>
between rows, columns and the Cartesian coordinate system. In 4 dimensions and
above, we lose any purely-visual intuition to describe multi-dimensional
entities anyway, so it's best to stick to a consistent mathematical notation
instead.</p>
<p>So let's talk about some arbitrary number of dimensions <em>d</em>, numbered from 1 to
<em>d</em>. For each dimension <img alt="&lt;math&gt;" class="valign-m3" src="http://eli.thegreenplace.net/images/math/05446b54bd23d571898ab5f1ad448f7ca767f19a.png"/>, <img alt="&lt;math&gt;" class="valign-m3" src="http://eli.thegreenplace.net/images/math/855336587fa59262965cdb9a2a6114933586800b.png"/> is the size of the
dimension. Also, the index of an element in dimension <img alt="&lt;math&gt;" class="valign-0" src="http://eli.thegreenplace.net/images/math/042dc4512fa3d391c5170cf3aa61e6a638f84342.png"/> is <img alt="&lt;math&gt;" class="valign-m3" src="http://eli.thegreenplace.net/images/math/5b05dd3722f57cd7ac250228f9a1aaf3af86311d.png"/>.
For example, in the latest matrix diagram above (where column-layout is shown),
we have <img alt="&lt;math&gt;" class="valign-0" src="http://eli.thegreenplace.net/images/math/8587fbaabf40db5bd2eb87f7ec6112beb7200253.png"/>. If we choose dimension 1 to be the row and dimension 2 to
be the column, then <img alt="&lt;math&gt;" class="valign-m4" src="http://eli.thegreenplace.net/images/math/2f780e2fb7cabe0948456a71d435b0a136de60f9.png"/>, and the element in the bottom-left corner
of the matrix has <img alt="&lt;math&gt;" class="valign-m4" src="http://eli.thegreenplace.net/images/math/0fb7ec5c44ec7de842ea61803aa4c9aec6412770.png"/> and <img alt="&lt;math&gt;" class="valign-m3" src="http://eli.thegreenplace.net/images/math/7d5ac2db0b27193cce99b1fe091ef5ce84eee9a9.png"/>.</p>
<p>In row-major layout of multi-dimensional arrays, the <em>last</em> index is the fastest
changing. In case of matrices the last index is columns, so this is equivalent
to the previous definition.</p>
<p>Given a <img alt="&lt;math&gt;" class="valign-0" src="http://eli.thegreenplace.net/images/math/3c363836cf4e16666669a25da280a1865c2d2874.png"/>-dimensional array, with the notation shown above, we
compute the memory location of an element from its indices as:</p>
<img alt="&lt;math&gt;" class="align-center" src="http://eli.thegreenplace.net/images/math/032b2eb5714fa4457fd349eec8f775c3e75584cd.png"/>
<p>For a matrix, <img alt="&lt;math&gt;" class="valign-0" src="http://eli.thegreenplace.net/images/math/8587fbaabf40db5bd2eb87f7ec6112beb7200253.png"/>, this reduces to:</p>
<img alt="&lt;math&gt;" class="align-center" src="http://eli.thegreenplace.net/images/math/c80b9d7877819556e5059016a2426e9727e0f949.png"/>
<p>Which is exactly the formula we've seen above for row-major layout, just using a
slightly more formal notation.</p>
<p>Similarly, in column-major layout of multi-dimensional arrays, the <em>first</em> index
is the fastest changing. Given a <img alt="&lt;math&gt;" class="valign-0" src="http://eli.thegreenplace.net/images/math/3c363836cf4e16666669a25da280a1865c2d2874.png"/>-dimensional array, we compute the
memory location of an element from its indices as:</p>
<img alt="&lt;math&gt;" class="align-center" src="http://eli.thegreenplace.net/images/math/35ece5a7b18c317a71e6914ff62c7dd7840952cf.png"/>
<p>And again, for a matrix with <img alt="&lt;math&gt;" class="valign-0" src="http://eli.thegreenplace.net/images/math/8587fbaabf40db5bd2eb87f7ec6112beb7200253.png"/> this reduces to the familiar:</p>
<img alt="&lt;math&gt;" class="align-center" src="http://eli.thegreenplace.net/images/math/c084b1f35e57a402567ddc8058ea346d574cd207.png"/>
</div>
<div class="section" id="example-in-3d">
<h2>Example in 3D</h2>
<p>Let's see how this works out in 3D, which we can still visualize. Assuming 3
dimensions: rows, columns and depth. The following diagram shows the memory
layout of a 3D array with <img alt="&lt;math&gt;" class="valign-m4" src="http://eli.thegreenplace.net/images/math/6275e16f8c4fe91d4591dedfec44bb859159bd4c.png"/>, in <em>row-major</em>:</p>
<img alt="Row major 3D" class="align-center" src="http://eli.thegreenplace.net/images/2015/row-major-3D.png"/>
<p>Note how the last dimension (depth, in this case) changes the fastest and the
first (row) changes the slowest. The offset for a given element is:</p>
<img alt="&lt;math&gt;" class="align-center" src="http://eli.thegreenplace.net/images/math/3952a22345f3e71ecbf5b74899d875ca2b9035f2.png"/>
<p>For example, the offset of the element with indices 2,1,1 is 22.</p>
<p>As an exercise, try to figure out how this array would be laid out in
<em>column-major</em> order. But beware - there's a caveat! The term <em>column-major</em> may
lead you to believe that columns are the slowest-changing index, but this is
wrong. The <em>last</em> index is the slowest changing in column-major, and the last
index here is depth, not columns. In fact, columns would be right in the middle
in terms of change speed. This is exactly why in the discussion above I
suggested dropping the row/column notation when going above 2D. In higher
dimensions it becomes confusing, so it's best to refer to the relative change
rate of the indices, since these are unambiguous.</p>
<p>In fact, one could conceive a sort of hybrid (or "mixed") layout where the
second dimension changes faster than the first or the third. This would be
neither row-major nor column-major, but in itself it's a consistent and
perfectly valid layout that may benefit some applications. More details on why
we would choose one layout over another are later in the article.</p>
</div>
<div class="section" id="history-fortran-vs-c">
<h2>History: Fortran vs. C</h2>
<p>While knowing which layout a particular data set is using is critical for good
performance, there's no single answer to the question which layout "is better"
in general. It's not much different from the big-endian vs. little-endian
debate; what's important is to pick up a consistent standard and stick to it.
Unfortunately, as almost always happens in the world of computing, different
programming languages and environments picked different standards.</p>
<p>Among the programming languages still popular today, Fortran was definitely
one of the pioneers. And Fortran (which is still very important for scientific
computing) uses column-major layout. I read somewhere that the reason for this
is that column vectors are more commonly used and considered "canonical" in
linear algebra computations. Personally I don't buy this, but you can make your
own judgement.</p>
<p>A slew of modern languages follow Fortran's lead - Matlab, R, Julia, to name a
few. One of the strongest reasons for this is that they want to use LAPACK - a
fast Fortran library for linear algebra, so using Fortran's layout makes sense.</p>
<p>On the other hand, C and C++ use row-major layout. Following their example
are a few other popular languages such as Python, Pascal and Mathematica. Since
multi-dimensional arrays are a first-class type in the C language, the standard
defines the layout very explicitly in section 6.5.2.1 <a class="footnote-reference" href="#id4" id="id1">[1]</a>.</p>
<p>In fact, having the first index change the slowest and the last index change the
fastest makes sense if you think about how multi-dimensional arrays in C are
indexed.</p>
<p>Given the declaration:</p>

<p>Then <tt class="docutils literal">x</tt> is an array of 3 elements, each of which is an array of 5 integers.
<tt class="docutils literal">x[1]</tt> is the address of the second array of 5 integers contained in <tt class="docutils literal">x</tt>,
and <tt class="docutils literal"><span class="pre">x[1][4]</span></tt> is the fifth integer of the second 5-integer array in <tt class="docutils literal">x</tt>.
These indexing rules imply row-major layout.</p>
<p>None of this is to say that C could not have chosen column-major layout. It
could, but then its multi-dimensional array indexing rules would have to be
different as well. The result could be just as consistent as what we have now.</p>
<p>Moreover, since C lets you manipulate pointers, you can decide on the layout
of data in your program by computing offsets into multi-dimensional arrays on
your own. In fact, this is how most C programs are written.</p>
</div>
<div class="section" id="memory-layout-example-numpy">
<h2>Memory layout example - numpy</h2>
<p>So far we've discussed memory layout purely conceptually - using diagrams and
mathematical formulae for index computations. It's worthwhile to see a "real"
example of how multi-dimensional arrays are stored in memory. For this purpose,
the Numpy library of Python is a great tool since it supports both layout kinds
and is easy to play with from an interactive shell.</p>
<p>The <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html">numpy.array constructor</a> can be
used to create multi-dimensional arrays. One of the parameters it accepts is
<tt class="docutils literal">order</tt>, which is either "C" for C-style layout (row-major) or "F" for
Fortran-style layout (column-major). "C" is the default. Let's see how this
looks:</p>
<div class="highlight"><pre><span class="n">In</span> <span class="p">[</span><span class="mi">42</span><span class="p">]:</span> <span class="n">ar2d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">'uint8'</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">'C'</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">43</span><span class="p">]:</span> <span class="s">'  '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ar2d</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">43</span><span class="p">]:</span> <span class="s">'1  2  3  11  12  13  10  20  40'</span>
</pre></div>
<p>In "C" order, elements of rows are contiguous, as expected. Let's try Fortran
layout now:</p>
<div class="highlight"><pre><span class="n">In</span> <span class="p">[</span><span class="mi">44</span><span class="p">]:</span> <span class="n">ar2df</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">'uint8'</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">'F'</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">45</span><span class="p">]:</span> <span class="s">'  '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ar2df</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">45</span><span class="p">]:</span> <span class="s">'1  11  10  2  12  20  3  13  40'</span>
</pre></div>
<p>For a more complex example, let's encode the following 3D array as a
<tt class="docutils literal">numpy.array</tt> and see how it's laid out:</p>
<img alt="Numeric 3D array" class="align-center" src="http://eli.thegreenplace.net/images/2015/numeric-3D-mat.png"/>
<p>This array has two rows (first dimension), 4 columns (second dimension) and
depth 2 (third dimension). As a nested Python list, this is its representation:</p>
<div class="highlight"><pre><span class="n">In</span> <span class="p">[</span><span class="mi">47</span><span class="p">]:</span> <span class="n">lst3d</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">14</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">17</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">18</span><span class="p">]]]</span>
</pre></div>
<p>And the memory layout, in both C and Fortran orders:</p>
<div class="highlight"><pre><span class="n">In</span> <span class="p">[</span><span class="mi">50</span><span class="p">]:</span> <span class="n">ar3d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lst3d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">'uint8'</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">'C'</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">51</span><span class="p">]:</span> <span class="s">'  '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ar3d</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">51</span><span class="p">]:</span> <span class="s">'1  11  2  12  3  13  4  14  5  15  6  16  7  17  8  18'</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">52</span><span class="p">]:</span> <span class="n">ar3df</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lst3d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">'uint8'</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">'F'</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">53</span><span class="p">]:</span> <span class="s">'  '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ar3df</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">53</span><span class="p">]:</span> <span class="s">'1  5  2  6  3  7  4  8  11  15  12  16  13  17  14  18'</span>
</pre></div>
<p>Note that in C layout (row-major), the first dimension (rows) changes the
slowest while the third dimension (depth) changes the fastest. In Fortran layout
(column-major) the first dimension changes the fastest while the third dimension
changes the slowest.</p>
</div>
<div class="section" id="performance-why-it-s-worth-caring-which-layout-your-data-is-in">
<h2>Performance: why it's worth caring which layout your data is in</h2>
<p>After reading the article thus far, one may wonder why any of this matters.
Isn't it just another way of divergence of standards, a-la endianness? As long
as we all agree on the layout, isn't this just a boring implementation detail?
Why would we care about this?</p>
<p>The answer is: performance. We're talking about numerical computing here (number
crunching on large data sets) where performance is almost always critical. It
turns out that matching the way your algorithm works with the data layout can
make or break the performance of an application.</p>
<p>The short takeaway is: <strong>always traverse the data in the order it was laid
out</strong>. If your data sits in memory in row-major layout, iterate over each row
before going to the next one, etc. The rest of the section will explain why this
is so and will also present a benchmask with some measurements to get a feel of
the consequences of this decision.</p>
<p>There are two aspects of modern computer architecture that have a large impact
on code performance and are relevant to our discussion: caching and vector
units. When we iterate over each row of a row-major array, we access the array
sequentially. This pattern has <a class="reference external" href="https://en.wikipedia.org/wiki/Locality_of_reference">spatial locality</a>, which makes the code
perfect for cache optimization. Moreover, depending on the operations we do with
the data, the CPU's vector unit can kick in since it also requires consecutive
access.</p>
<p>Graphically, it looks something like the following diagram. Let's say we have
the array: <tt class="docutils literal">int <span class="pre">array[128][128]</span></tt>, and we iterate over each row, jumping to the
next one when all the columns in the current one were visited. The number within
each gray cell is the memory address - it grows by 4 since this is an array if
integers. The blue numbered arrow enumerates accesses in the order they are
made:</p>
<img alt="Row access pattern" class="align-center" src="http://eli.thegreenplace.net/images/2015/row-access-pattern.png"/>
<p>Here, the optimal usage of caching and vector instructions should be obvious.
Since we always access elements sequentially, this is the perfect scenario for
the CPU's caches to kick in - we will <em>always hit the cache</em>. In fact, we always
hit the fastest cache - L1, because the CPU correctly pre-fetches all data
ahead.</p>
<p>Moreover, since we always read one 32-bit word <a class="footnote-reference" href="#id5" id="id2">[2]</a> after another, we can leverage the CPU's
vector units to load the data (and perhaps process is later). The purple arrows
show how this can be done with SSE vector loads that grab 128-bit chunks (four
32-bit words) at a time. In actual code, this can either be done with intrinsics or
by relying on the compiler's auto-vectorizer (as we will soon see in an actual
code sample).</p>
<p>Contrast this with accessing this row-major data one <em>column</em> at a time,
iterating over each column before moving to the next one:</p>
<img alt="Column access pattern" class="align-center" src="http://eli.thegreenplace.net/images/2015/column-access-pattern.png"/>
<p>We lose spatial locality here, unless the array is very narrow. If there are few
columns, consecutive rows <em>may</em> be found in the cache. However, in more typical
applications the arrays are large and when access #2 happens it's likely that
the memory it accesses is nowhere to be found in the cache. Unsurprisingly, we
also lose the vector units since the accesses are not made to consecutive
memory.</p>
<p>But what should you do if your algorithm <em>needs</em> to access data column-by-column
rather than row-by-row? Very simple! This is precisely what column-major layout
is for. With column-major data, this access pattern will hit all the same
architectural sweetspots we've seen with consecutive access on row-major data.</p>
<p>The diagrams above should be convincing enough, but let's do some actual
measurements to see just how dramatic these effects are.</p>
<p>The full code for the benchmark is <a class="reference external" href="https://github.com/eliben/code-for-blog/tree/master/2015/benchmark-row-col-major">available here</a>,
so I'll just show a few selected snippets. We'll start with a basic matrix type
laid out in linear memory:</p>
<div class="highlight"><pre><span class="c1">// A simple Matrix of unsigned integers laid out row-major in a 1D array. M is</span>
<span class="c1">// number of rows, N is number of columns.</span>
<span class="k">struct</span> <span class="n">Matrix</span> <span class="p">{</span>
  <span class="kt">unsigned</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>The matrix is using row-major layout: its elements are accessed using this C
expression:</p>

<p>Here's a function that adds two such matrices together, using a "bad" access
pattern - iterating over the the rows in each column before going to the next
column. The access patter is very easy to spot looking at C code - the inner
loop is the faster-changing index, and in this case it's rows:</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">AddMatrixByCol</span><span class="p">(</span><span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">M</span> <span class="o">==</span> <span class="n">x</span><span class="p">.</span><span class="n">M</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">N</span> <span class="o">==</span> <span class="n">x</span><span class="p">.</span><span class="n">N</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">.</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">col</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">.</span><span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">row</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">y</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">y</span><span class="p">.</span><span class="n">N</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">x</span><span class="p">.</span><span class="n">N</span> <span class="o">+</span> <span class="n">col</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>And here's a version that uses a better pattern, iterating over the columns in
each row before going to the next row:</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">AddMatrixByRow</span><span class="p">(</span><span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">M</span> <span class="o">==</span> <span class="n">x</span><span class="p">.</span><span class="n">M</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">N</span> <span class="o">==</span> <span class="n">x</span><span class="p">.</span><span class="n">N</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">.</span><span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">row</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">.</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">col</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">y</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">y</span><span class="p">.</span><span class="n">N</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">x</span><span class="p">.</span><span class="n">N</span> <span class="o">+</span> <span class="n">col</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>How do the two access patterns compare? Based on the discussion in this article,
we'd expect the by-row access pattern to be faster. But how much faster? And
what role does vectorization play vs. efficient usage of cache?</p>
<p>To try this, I ran the access patterns on matrices of various sizes, and added a
variation of the by-row pattern where vectorization is disabled <a class="footnote-reference" href="#id6" id="id3">[3]</a>. Here are
the results; the vertical bars represent the bandwidth - how many billions of
items (32-bit words) were processed (added) by the given function.</p>
<img alt="Benchmark results" class="align-center" src="http://eli.thegreenplace.net/images/2015/rowcol-benchmark1.png"/>
<p>Some observations:</p>
<ul class="simple">
<li>For matrix sizes above 64x64, by-row access is significantly faster than
by-column (6-8x, depending on size). In the case of 64x64, what I believe
happens is that both matrices fit into the 32-KB L1 cache of my machine, so
the by-column pattern actually manages to find the next row in cache. For
larger sizes the matrices no longer fit in L1, so the by-column version has to
go to L2 frequently.</li>
<li>The vectorized version beats the non-vectorized one by 2-3x in all cases. On
large matrices the speedup is a bit smaller; I think this is because at
256x256 and beyond the matrices no longer fit in L2 (my machine has 256KB of
it) and needs slower memory access. So the CPU spends a bit more time waiting
for memory on average.</li>
<li>The overall speedup of the vectorized by-row access over the by-column access
is enormous - up to 25x for large matrices.</li>
</ul>
<p>I'll have to admit that, while I expected the by-row access to be faster, I
didn't expect it to be <em>this much</em> faster. Clearly, choosing the proper access
pattern for the memory layout of the data is absolutely crucial for the
performance of an application.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>This article examined the issue of multi-dimensional array layout from multiple
angles. The main takeaway is: know how your data is laid out and access it
accordingly. In C-based programming languages, even though the default layout
for 2D-arrays is row-major, when we use pointers to dynamically allocated data,
we are free to choose whatever layout we like. After all, multi-dimensional
arrays are just a logical abstraction above a linear storage system.</p>
<p>Due to the wonders of modern CPU architectures, choosing the "right" way to
access multi-dimensional data may result in colossal speedups; therefore, this
is something that should always be on the programmer's mind when working on
large multi-dimensional data sets.</p>
<hr class="docutils"/>



</div>

            </div>
            

    </div></body></html>