<html><body><div><div class="content html_format"><p>
      В </p><a href="http://habrahabr.ru/company/mailru/blog/202832/">предыдущей статье</a><p> мы закончили разговор о профилировании обзором событийных профайлеров.
</p><p>
Сегодня я предлагаю рассмотреть методы отладки программ.

</p><a name="habracut"/>

<p>
Прежде, чем начинать разговор об отладке, нам нужно определиться, что же это такое. По традиции, обратимся к </p><a href="http://ru.wikipedia.org/wiki/Отладка_программы">Википедии</a><p>: «Отладка — обнаружение, локализация и устранение ошибок». Вообще, для успешной отладки программы, нам необходимо (но не всегда достаточно) две вещи: значение переменных в том месте программы, в котором произошла ошибка, а так же стектрейс: порядок вызова функций, вплоть до ошибочной. Полезно так же знать об окружении, в котором выполняется программа: наличие (или отсутствие) свободной памяти, системные ограничения (например, на количество файловых дескрипторов) и так далее, но это слегка выходит за пределы нашей статьи.

</p><h2>Классика жанра</h2><p>
Что делает начинающий программист, когда хочет «проникнуть» внутрь программы и изучить содержимое переменных (в нужных местах) и логику работы программы (вызовы функций, выполнение условий)? Он прибегает к самому распространённому, самому простому и самому «действенному» способу отладки: расставляет по всему коду «принты» (оператор print в Python 2.x и функция print() в Python 3.x). Но не только начинающие грешат этим: продвинутые разработчики частенько ленятся использовать специальные инструменты для отладки, надеясь быстренько, за пару минут, найти причину ошибки и всё исправить, и не замечая, что поиски ошибок растягиваются на часы и даже дни. Кстати, такой подход называют «журналированием».
</p><p>
Сюда же относится запись всей нужной для отладки программы информации в лог-файл. Иногда других вариантов нет, например, когда скрипт работает в продакшене и ошибки возникают эпизодически, или когда ошибка проявляется только после долгой работы программы (скажем, через две-три недели после запуска).
</p><p>
Но мы же пишем на Python, так почему бы не воспользоваться встроенными средствами отладки или инструментами, предлагаемыми сообществом? Например, вместо обычного логгирования в файл имеет смысл использовать </p><a href="https://github.com/getsentry/sentry/">Sentry</a><p>, чтобы кроме сообщения об ошибке можно было отправить дополнительную информацию: стектрейс со всеми локальными переменными, любые другие переменные и вообще всё, что посчитаете нужным.

</p><h2>The Python Debugger</h2><p>
Python имеет встроенный отладчик: модуль </p><a href="http://docs.python.org/2/library/pdb.html">pdb</a><p>. В принципе, на этом можно было бы закончить статью, т.к. pdb — чрезвычайно мощный отладчик и всё остальное, по сути, всего лишь «украшательства» к нему. Но мы продолжим =)
</p><p>
Как можно заметить из названия, pdb многое взял от gdb (GNU Project debugger) — отладчика Си (и не только) программ. К слову, программы на Python можно отлаживать и с помощью gdb, просто это немножко сложнее и дольше, хотя тем, кто хочет углубиться в устройство языка, а так же тем, кто пишет сишные модули для питона без gdb никак не обойтись. Кроме того, gdb позволяет подключиться к уже работающей программе (через её pid) и заниматься её отладкой «прямо на месте».
</p><p>
Я сейчас не буду подробно описывать pdb, вот замечательная статья Дага Хеллманна (Doug Hellmann): </p><a href="http://pymotw.com/2/pdb/">pdb – Interactive Debugger</a><p> на очень полезном ресурсе </p><a href="http://pymotw.com/2/">Python Module of the Week</a><p>, а вот её хороший перевод на хабре: </p><a href="http://habrahabr.ru/post/104086/">pdb – Интерактивный отладчик</a><p>, выполненный пользователем  </p><a href="https://habrahabr.ru/users/xa4a/" class="user_link">xa4a</a><p>.

</p><h2>IPython pdb</h2><p>
Предлагаю сразу поставить </p><a href="http://ipython.org/">IPython</a><p> и модуль </p><a href="https://github.com/gotcha/ipdb/">ipdb</a><p> для него:
</p><pre><code>➜ pip install ipython ipdb</code></pre><p>
IPython (и ipdb, как его часть) предлагает «более лучшую» консоль и, как следствие, более удобную отладку программ: подсветка кода, автодополнение, историю команд, динамическую интроспекцию любых объектов, магические функции, алиасы и многое другое. Полный список улучшений можно посмотреть в документации или прямо из консоли IPython, введя "?" в качестве команды. Всё это помогает при отладке и делает её простой и увлекательной.
</p><p>
Запустить отладку скрипта в ipdb можно несколькими способами:
</p><pre><code>➜ python -m ipdb script.py</code></pre>
<pre><code>➜ ipdb script.py</code></pre><p>
Эти команды откроют программу в отладчике, дальше можно делать всё, что угодно: ставить брейкпоинты, изучать её работу по шагам или просто запустить программу — отладчик автоматически остановится при возникновении неотловленного исключения.
</p><p>
Но обычно такой вариант чересчур изнурителен: пока доберёшься до нужного места всеми этими «next», «step», да и ставить точку останова («break») руками каждый раз утомительно. Гораздо удобнее в нужном месте программы вставить следующую строку:
</p><pre><code class="python">import ipdb; ipdb.set_trace()</code></pre><p>
И тогда при исполнении этой строки выполнение программы приостановится и будет запущен отладчик, — дальше можно начинать углубляться в изучение программы. По сути, функция «set_trace» — это установка точки останова (breakpoint).
</p><div class="spoiler"><b class="spoiler_title">Примечание для эстетов</b><p class="spoiler_text">Любой, кому знакома аббревиатура PEP8, в этом месте может обвинить меня в использовании двух команд в одной строке через точку с запятой, однако такой подход вполне имеет право на жизнь. Во-первых, это временный код, который никогда не будет закоммичен в репозиторий (об этом позаботится специальный хук, который проверяет код на соответствие PEP8 перед коммитом и пушем, а так же автопроверка кода в текстовом редакторе). Во-вторых, так проще вставлять и удалять эту строку в код. Ну и в-третьих, как написано в PEP8: «A Foolish Consistency is the Hobgoblin of Little Minds».</p></div><p>
Python Debugger имеет ещё один режим работы, который в некоторых случаях оказывается удобнее фукнции set_trace. Он называется «post mortem»: запуск отладчика с заданным трейсбеком:
</p><pre><code class="python">try:
    some_code()
except:
    import sys
    import ipdb
    tb = sys.exc_info()[2]
    ipdb.post_mortem(tb)</code></pre><p>
или так:
</p><pre><code class="python">import sys
import ipdb


def run_debugger(type, value, tb):
    ipdb.pm()


sys.excepthook = run_debugger
some_code()</code></pre><p>
В случае возникновения любых неотлавливаемых исключений в функции «some_code» будет вызван отладчик в том месте программы, где произошло исключение.

</p><h2>debug</h2><p>
Интересной заменой функции «set_trace» является модуль </p><a href="https://github.com/narfdotpl/debug/">debug</a><p>, который просто импортирует библиотеки </p><a href="https://github.com/gotcha/ipdb/">ipdb</a><p> и </p><a href="https://github.com/inky/see/">see</a><p> (удобная альтернатива функции dir) и запускает отладку. Единственным плюсом модуля является удобство использования, достаточно в любом месте программы вставить строку:
</p><pre><code class="python">import debug</code></pre><p>
И при выполнении этой строки будет вызван отладчик «ipdb» и импортирован модуль «see».

</p><h2>ipdbplugin</h2><p>
Ещё одна интересная и, на этот раз, полезная библиотека: </p><a href="https://github.com/flavioamieiro/nose-ipdb">nose-ipdb</a><p>. С её помощью можно автоматически запускать отладчик при ошибках (исключениях) или же просто при неверно отработанных тестах (я надеюсь, вы используете nose? =). Для запуска отладчика ipdb при ошибках, достаточно при запуске тестов добавить ключ "--ipdb":
</p><pre><code>➜ nosetests --ipdb</code></pre><p>
А для запуска отладчика при некорректно завершившихся тестов нужно добавить ключ "--ipdb-failures":
</p><pre><code>➜ nosetests --ipdb-failures</code></pre><p>
Конечно, можно ловить всё и сразу:
</p><pre><code>➜ nosetests --ipdb --ipdb-failures</code></pre><p>
Я каждый день использую этот модуль и просто не представляю себе жизни без него.

</p><h2>werkzeug</h2><p>
Потрясающий проект Армина Ронахера (</p><a href="http://lucumr.pocoo.org/about/">Armin Ronacher</a><p>), автора фреймворка </p><a href="https://github.com/mitsuhiko/flask/">Flask</a><p> и вообще одного из </p><a href="http://lucumr.pocoo.org/projects/">крутейших</a><p> программистов Python называется </p><a href="https://github.com/mitsuhiko/werkzeug/">werkzeug</a><p> и представляет собой сборник различных утилит для WSGI приложений. Одна из них — </p><a href="http://werkzeug.pocoo.org/docs/debug/">клёвый отладчик</a><p>, который позволяет выводить удобный трейсбек ошибки, а так же запускать консоль Python в соответствующем месте трейсбека прямо на странице браузера:
</p><img src="https://habrastorage.org/getpro/habr/post_images/542/171/007/5421710071f3deebcef08f7f8c4499ea.png"/><p>
Использовать его очень просто, достаточно обернуть приложение с помощью соответствующего middleware:
</p><pre><code class="python">from werkzeug.debug import DebuggedApplication
from myapp import app
app = DebuggedApplication(app, evalex=True)</code></pre><p>
Говорят, что werkzeug умеет отлаживать даже Ajax-запросы, но, к сожалению, я сам лично никогда этого не делал. Буду рад любым комментариям на эту тему.

</p><h2>django-pdb</h2><p>
Ещё один хороший модуль, на этот раз для Django: </p><a href="https://github.com/tomchristie/django-pdb/">django-pdb</a><p>. Он позволяет запускать отладчик при наличии соответствующего GET-параметра в запросе (например: </p><a href="http://127.0.0.1:8000/app/view?ipdb">http://127.0.0.1:8000/app/view?ipdb</a><p>) либо для всех запросов:
</p><pre><code>➜ python manage.py runserver --ipdb</code></pre><p>
Либо вызывать отладчик при возникновении исключений (режим «post-mortem»):
</p><pre><code>➜ python manage.py runserver --pm</code></pre><p>
или
</p><pre><code class="python">POST_MORTEM = True</code></pre><p>
в settings.py.

</p><h2>django-extensions</h2><p>
Но гораздо лучше в Django использовать модуль </p><a href="https://github.com/django-extensions/django-extensions/">django-extensions</a><p>, который добавляет очень полезную команду </p><a href="http://django-extensions.readthedocs.org/en/latest/runserver_plus.html">runserver_plus</a><p>. С помощью этой батарейки можно подружить Django и Werkzeug (см. выше) и начать получать удовольствие от страниц с пятисотой ошибкой =)
</p><p>
Для использования всего этого чуда достаточно запустить девелоперский сервер с помощью команды runserver_plus:
</p><pre><code>➜ python manage.py runserver_plus</code></pre>

<h2>sentry</h2><p>
Отладка программы в девелоперском окружении это, конечно, удобно и хорошо, но самое сложное — локализовать проблему по багрепорту от живого пользователя. Иногда это бывает сложно. Несмотря на все </p><a href="http://xkcd.com/353/">преимущества Python</a><p>, модуля «телепатии» не существует, и разработчик остаётся один на один со словами пользователя «ничего не работает!!!11».
</p><p>
Проект </p><a href="https://github.com/getsentry/sentry/">Sentry</a><p> позволяет сохранять </p><strong>каждую</strong><p> ошибку пользователя с текстом исключения, полным стектрейсом исключения и значениями всех локальных переменных в каждой из функций стектрейса, а так же много другой информации: окружение пользователя (браузер, ОС), все заголовки запроса и вообще всё, что пожелает разработчик.
</p><img src="https://habrastorage.org/getpro/habr/post_images/aaf/daf/a85/aafdafa85d3a69b29250a2c68854ced9.png"/><p>
Одинаковые ошибки группируются, таким образом можно наблюдать за «пульсом» проекта и чинить в первую очередь самые критичные места. Ещё один пример использования sentry — логгирование. Можно просто добавить в спорное место запись в лог сообщения с любыми интересующими разработчика переменными, и всё это окажется в sentry.
</p><p>
Но самый большой плюс в том, что всё это можно (и нужно!) использовать в продакшене.

</p><h2>PuDB</h2><p>
Ещё один интересный отладчик: </p><a href="https://pypi.python.org/pypi/pudb">PuDB</a><p> представляет собой консольный дебагер с графическим интерфейсом:
</p><img src="https://habrastorage.org/getpro/habr/post_images/593/b39/259/593b392590397fd303e78bd7288f0518.png"/><p>
Не буду много о нём писать (честно говоря, я сам активно им не пользовался), предлагаю прочитать короткую заметка на хабре: </p><a href="http://habrahabr.ru/post/158139/">Удобный отладчик для Python/Django проектов</a><p> от пользователя  </p><a href="https://habrahabr.ru/users/int22h/" class="user_link">int22h</a><p> или более полный обзор: </p><a href="http://adw0rd.com/2012/3/24/python-django-pudb/">Отладка Python/Django при помощи PuDB</a><p>.

</p><h2>Winpdb</h2><p>
Standalone отладчик Python, на этот раз с полноценным графическим интерфейсом: </p><a href="http://winpdb.org/about/">Winpdb</a><p>:
</p><img src="https://habrastorage.org/getpro/habr/post_images/b5b/5be/d1f/b5b5bed1f19b644e4c7b789053355276.png"/><p>
Его разработчики утверждают, что winpdb в 20 раз быстрее pdb, а так же поддерживает работу с тредами. Очень большой и подробный туториал можно найти на этой странице: </p><a href="https://code.google.com/p/winpdb/wiki/DebuggingTutorial">code.google.com/p/winpdb/wiki/DebuggingTutorial</a><p>.

</p><h2>IDE</h2><p>
Отдельного слова заслуживают универсальные «комбайны» программирования: IDE, которые позволяют не выходя из редактора запустить код, отпрофилировать его или запустить встроенный отладчик. Я, пожалуй, выделю несколько продуктов, предназначенных для разработки на Python: </p><a href="http://www.jetbrains.com/pycharm/">PyCharm</a><p>, </p><a href="http://pydev.org/">PyDev</a><p>, </p><a href="http://www.wingware.com/">Wing IDE</a><p> и </p><a href="http://pytools.codeplex.com/">PTVS</a><p>.
</p><img src="https://habrastorage.org/getpro/habr/post_images/696/e93/572/696e93572868d1cae83986376fcfe812.png"/>
<div class="spoiler"><b class="spoiler_title">Лирическое отступление</b><p class="spoiler_text">К сожалению, лично я сколько не пытался, так и не смог пересилить себя и променять скорость, удивительную гибкость и удобство работы с консолью и любимым текстовым редактором (будь то vim, emacs или sublime text) на любую из вышеперечисленных IDE, однако мои коллеги успешно ими пользуются и поэтому я советую хотя бы дать этим замечательным продуктам шанс и попробовать их.</p></div><p>
Если честно, я не вижу особого смысла рассматривать каждую из этих IDE, достаточно знать что они есть, что они успешно справляются со своими задачами и вы можете использовать встроенный отладчик прямо из редактора, — это действительно удобно, круто и здорово.
</p><p>
Спасибо всем, кто дочитал и прокомментировал.

</p><i>Владимир Рудных,<br/>
Технический руководитель Календаря Mail.Ru.</i>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>