<html><body><div><div class="entry-content"><p>
</p><div class="text_cell_render border-box-sizing rendered_html">


<div>
<center>
<a href="http://www.astroml.org/_images/fig_LS_example_1.png"><img src="http://www.astroml.org/_images/fig_LS_example_1.png"/></a> <small>Image source: astroML. Source code <a href="http://www.astroml.org/book_figures/chapter10/fig_LS_example.html#book-fig-chapter10-fig-ls-example">here</a></small>
</center>
</div>

<p>The Lomb-Scargle periodogram (named for <a href="http://adsabs.harvard.edu/abs/1976Ap%26SS..39..447L">Lomb (1976)</a> and <a href="http://adsabs.harvard.edu/abs/1982ApJ...263..835S">Scargle (1982)</a>) is a classic method for finding periodicity in irregularly-sampled data. It is in many ways analogous to the more familiar Fourier Power Spectral Density (PSD) often used for detecting periodicity in regularly-sampled data.</p>
<p>Despite the importance of this method, until recently there have not been any (in my opinion) solid implementations of the algorithm available for easy use in Python. That has changed with the introduction of the <a href="http://astroml.org/gatspy/">gatspy</a> package, which I recently released. In this post, I will compare several available Python implementations of the Lomb-Scargle periodogram, and discuss some of the considerations required when using it to analyze data.</p>
<p>To cut to the chase, I'd recommend using the <a href="http://astroml.org/gatspy/">gatspy</a> package for Lomb-Scargle periodograms in Python, and particularly its <code>gatspy.periodic.LombScargleFast</code> algorithm which implements an efficient pure-Python version of Press &amp; Rybicki's <span class="math">\(O[N\log N]\)</span> periodogram. Below, I'll dive into the reasons for this recommendation.</p>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="example-lomb-scargle-on-variable-stars">Example: Lomb-Scargle on Variable Stars</h2>
<p>As an motivation, let's briefly consider some data from my own field: observations of an <a href="https://en.wikipedia.org/wiki/RR_Lyrae_variable"><em>RR Lyrae-type</em></a> variable star. RR Lyrae are small stars – about 50% the mass of our sun – which pulsate with a regular period on order half a day. Their relatively consistent peak intrinsic brightness allows for an accurate estimation of their distance from the sun, and thus they are important for studies such as <a href="http://www.mpia.de/~bsesar/media.html">understanding the substructure</a> of the Milky Way galaxy. Because of this and other similar applications, detecting the telltale periodic variation of RR Lyrae stars within noisy data is an important statistical task for astronomers.</p>
<p>Here we will quickly demonstrate what this looks like in practice, using tools from the <a href="http://astroML.org">astroML</a> package to download some data, and tools from the <a href="http://astroml.org/gatspy/">gatspy</a> package to detect the periodicity.</p>
<p>We'll start with some typical Python import statements:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [1]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="c"># Do preliminary imports and notebook setup</span>
<span class="o">%</span><span class="k">matplotlib</span> <span class="n">inline</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="c"># use seaborn for plot styles</span>
<span class="kn">import</span> <span class="nn">seaborn</span><span class="p">;</span> <span class="n">seaborn</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</pre></div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we'll download some data from the <a href="https://en.wikipedia.org/wiki/Lincoln_Near-Earth_Asteroid_Research">LINEAR</a> dataset, using tools in astroML. We'll plot the data to see what we're working with:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [2]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="kn">from</span> <span class="nn">astroML.datasets</span> <span class="kn">import</span> <span class="n">fetch_LINEAR_sample</span>
<span class="n">LINEAR_data</span> <span class="o">=</span> <span class="n">fetch_LINEAR_sample</span><span class="p">()</span>
<span class="n">star_id</span> <span class="o">=</span> <span class="mi">10040133</span>
<span class="n">t</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">dmag</span> <span class="o">=</span> <span class="n">LINEAR_data</span><span class="o">.</span><span class="n">get_light_curve</span><span class="p">(</span><span class="n">star_id</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">dmag</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s">'.k'</span><span class="p">,</span> <span class="n">ecolor</span><span class="o">=</span><span class="s">'gray'</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s">'Time (days)'</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s">'magitude'</span><span class="p">,</span>
       <span class="n">title</span><span class="o">=</span><span class="s">'LINEAR object {0}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">star_id</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">();</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>This data has around 250 observations spread across about 2000 days, and we're hoping to detect a period of order 0.5 days. If the series were regularly-sampled, we'd be far above the Nyquist limit and all hope would be lost. Fortunately for astronomers, the assumptions behind the Nyquist sampling limit do not hold for irregular sampling rates, and we can proceed with no problem.</p>
<p>Let's start by computing and plotting the Lomb-Scargle Periodogram for this data, using tools from gatspy:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [3]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="kn">from</span> <span class="nn">gatspy.periodic</span> <span class="kn">import</span> <span class="n">LombScargleFast</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">LombScargleFast</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">dmag</span><span class="p">)</span>
<span class="n">periods</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">periodogram_auto</span><span class="p">(</span><span class="n">nyquist_factor</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">),</span> <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span>
       <span class="n">xlabel</span><span class="o">=</span><span class="s">'period (days)'</span><span class="p">,</span>
       <span class="n">ylabel</span><span class="o">=</span><span class="s">'Lomb-Scargle Power'</span><span class="p">);</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>The periodogram gives a measure of periodic content as a function of period; we see here a strong peak at around 0.61 days. Other lower peaks are due to some combination of higher-order harmonics in the data and effects of the irregular survey window. While we could find this maximum manually from the above grid, <code>gatspy</code> provides a better way: a built-in two-stage grid-search that accurately determines the best period in a specified range:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [4]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="c"># set range and find period</span>
<span class="n">model</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">period_range</span><span class="o">=</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">)</span>
<span class="n">period</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">best_period</span>
<span class="k">print</span><span class="p">(</span><span class="s">"period = {0}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">period</span><span class="p">))</span>
</pre></div>

</div>
</div>

<div class="vbox output_wrapper">
<div class="output vbox">


<div class="hbox output_area"><p class="prompt"/>
<div class="box-flex1 output_subarea output_stream output_stdout">
<pre>
Finding optimal frequency:
 - Estimated peak width = 0.0032
 - Using 5 steps per peak; omega_step = 0.00064
 - User-specified period range:  0.2 to 1.4
 - Computing periods at 42104 steps
Zooming-in on 5 candidate peaks:
 - Computing periods at 1000 steps
period = 0.6105387801103276

</pre>
</div>
</div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>We see that the optimizer determined that it needed a grid of over 40,000 points to adequately cover the frequency grid (more on this below), and in the end arrived at a best period of 0.6105 days. Given this detected period, we can fold the input data and over-plot a best-fit empirical RR Lyrae template to see the fit:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [5]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="c"># Compute phases of the obsevations</span>
<span class="n">phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">period</span><span class="p">)</span> <span class="o">%</span> <span class="mi">1</span>

<span class="c"># Compute best-fit RR Lyrae template</span>
<span class="kn">from</span> <span class="nn">gatspy.periodic</span> <span class="kn">import</span> <span class="n">RRLyraeTemplateModeler</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">RRLyraeTemplateModeler</span><span class="p">(</span><span class="s">'r'</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">dmag</span><span class="p">)</span>
<span class="n">phase_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">mag_fit</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">period</span> <span class="o">*</span> <span class="n">phase_fit</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>

<span class="c"># Plot the phased data &amp; model</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">dmag</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s">'.k'</span><span class="p">,</span> <span class="n">ecolor</span><span class="o">=</span><span class="s">'gray'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">phase_fit</span><span class="p">,</span> <span class="n">mag_fit</span><span class="p">,</span> <span class="s">'-k'</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s">'Phase'</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s">'magitude'</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">();</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>This very close template fit gives a strong indication that the star in question is an RR Lyrae.</p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="computational-considerations-for-lomb-scargle">Computational Considerations for Lomb-Scargle</h2>
<p>The Lomb-Scargle periodogram involves the computation of a power <span class="math">\(P(\omega)\)</span> at a set of frequencies <span class="math">\(\omega_i\)</span>. For data <span class="math">\(\{y_k\}\)</span> pre-centered such that <span class="math">\(\sum_k y_k = 0\)</span>, the expression for the power is:</p>
<p><span class="math">\[
P(\omega) \propto
  \frac{\left[\sum_k y_k \cos\omega(t_k - \tau)\right]^2}
    {\sum_k \cos^2\omega(t_k - \tau)} +
  \frac{\left[\sum_k y_k \sin\omega(t_k - \tau)\right]^2}
    {\sum_k \sin^2\omega(t_k - \tau)}
\]</span></p>
<p>where <span class="math">\(\tau\)</span> is an easily computed time-offset which orthogonalizes the model and makes <span class="math">\(P(\omega)\)</span> independent of a translation in <span class="math">\(t\)</span>.</p>
<p>Rather than get lost in the math, I want to emphasize the key feature of this expression: <strong>for any frequency <span class="math">\(\omega\)</span>, the power is an <span class="math">\(O[N]\)</span> computation involving simple trigonometric sums over the data,</strong> where <span class="math">\(N\)</span> is the number of observed data points. The main computational question then becomes: how many frequencies must you compute? In my experience, the most common mistake people make when doing this sort of periodic analysis is not thinking hard enough about the frequency grid. It turns out that the grid-spacing question is <em>very</em> important. If you choose too fine a grid, you do much more computation than is required. Worse, if you choose too coarse a grid, the periodogram peak may fall between grid points and you'll miss it entirely!</p>
<p>Let's think about the required frequency range and frequency spacing for Lomb-Scargle.</p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="frequency-spacing">Frequency spacing</h3>
<p>First we'll choose the spacing of the frequency grid. If you're asking about a candidate frequency <span class="math">\(f\)</span>, then data with range <span class="math">\(T = t_{max} - t_{min}\)</span> contains <span class="math">\(T \cdot f\)</span> complete cycles. If our error in frequency is <span class="math">\(\delta f\)</span>, then <span class="math">\(T\cdot\delta f\)</span> is the error in number of cycles between the endpoints of the data. It's clear that this error must not be a significant fraction of a cycle, or the fit could be drastically affected. This leads to an approximate grid-spacing criterion:</p>
<p><span class="math">\[
T\cdot\delta f \ll 1
\]</span></p>
<p>Commonly, we'll choose some oversampling factor (say, 5) and use <span class="math">\(\delta f = (5T)^{-1}\)</span> as our frequency grid spacing.</p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="frequency-limits">Frequency limits</h3>
<p>Next, we need to choose the upper and lower limits of the frequency grid. On the low end, <span class="math">\(f=0\)</span> is suitable, but causes some numerical problems – we'll go one step away and use <span class="math">\(\delta f\)</span> as our minimum frequency. But on the high end, we need to make a choice: what's the highest frequency we'd trust our data to be sensitive to? At this point, many people are tempted to mis-apply the Nyquist-Shannon sampling theorem, and choose some version of the Nyquist limit for the data (based on, say, the minimum or mean spacing between observations). But this is entirely wrong! The Nyquist frequency is derived from special properties of regularly-sampled data, and does not apply – even approximately – to irregularly-sampled time-series. In fact, as we saw above, irregularly-sampled data can be sensitive to much, much higher frequencies than even the minimum spacing between observations. With this in mind, the upper limit for frequencies should be determined based on <strong>what kind of signal you are looking for.</strong></p>
<p>Still, a common (if dubious) rule-of-thumb is that the high frequency is some multiple of what Press &amp; Rybicki call the "average" Nyquist frequency,</p>
<p><span class="math">\[
\hat{f}_{Ny} = \frac{N}{2T}
\]</span></p>
<p>This means that the "typical" number of frequencies you'll need is</p>
<p><span class="math">\[
N_{freq} \sim O\left[\frac{\hat{f}_{Ny}}{\delta f}\right] \sim O\left[\frac{N/(2T)}{1/T}\right] \sim O[N]
\]</span></p>
<p>That is, the number of frequencies to search will scale with the number of data points!</p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="computational-complexity">Computational Complexity</h3>
<p>From the above considerations, we see that the determination of the optimal Lomb-Scargle period within <span class="math">\(N\)</span> points requires computing an <span class="math">\(O[N]\)</span> expression for power across <span class="math">\(O[N]\)</span> grid points; that is, Lomb-Scargle is naively an <span class="math">\(O[N^2]\)</span> algorithm.</p>
<p>This computational complexity can be improved in one of several ways. Most notably, in a <a href="http://adsabs.harvard.edu/full/1989ApJ...338..277P">1989 paper</a>, Press and Rybicki proposed a clever method whereby a Fast Fourier Transform is used on a grid <em>extirpolated</em> from the original data, such that this naively <span class="math">\(O[N^2]\)</span> problem can be solved in <span class="math">\(O[N\log N]\)</span> time. The broad idea is that when you compute sums of sines and cosines for one frequency, this gives you some amount of information about those sums computed at another frequency, and by carefully using all information across a frequency grid, you can significantly reduce the number of required operations.</p>
<p>Thus the fundamental divide between Lomb-Scargle implementations is whether they use the naive <span class="math">\(O[N^2]\)</span> algorithm or the <span class="math">\(O[N\log N]\)</span> algorithm of Press &amp; Rybicki and other similar approaches.</p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="lomb-scargle-algorithms-in-python">Lomb-Scargle Algorithms in Python</h2>
<p>Now we get to the meat of this post: Lomb-Scargle implementations written in Python. If you search this on Google, you'll currently find links to several available implementations. Here I'm going to delve into and compare the following four implementations:</p>
<ul>
<li><code>scipy.signal.lombscargle</code>, an <span class="math">\(O[N^2]\)</span> implementation from <a href="http://docs.scipy.org/doc/scipy/reference/">SciPy</a>.</li>
<li><code>astroML.time_series.lomb_scargle</code>, an <span class="math">\(O[N^2]\)</span> implementation from <a href="http://astroML.org/">astroML</a>.</li>
<li><code>gatspy.periodic.LombScargle</code>, an <span class="math">\(O[N^2]\)</span> implementation from <a href="http://astroml.org/gatspy/">gatspy</a>.</li>
<li><code>gatspy.periodic.LombScargleFast</code>, an <span class="math">\(O[N\log N]\)</span> implementation, also from <a href="http://astroml.org/gatspy/">gatspy</a>.</li>
</ul>
<p>Let's see some examples of the above tools:</p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="scipy.signal.lombscargle"><code>scipy.signal.lombscargle</code></h4>
<p>The SciPy Lomb-Scargle periodogram is a C implementation of the naive <span class="math">\(O[N^2]\)</span> algorithm. The algorithm cannot account for noise in the data, and has some other quirks as well:</p>
<ul>
<li>it requires you to center your data (by subtracting the mean) before computing the periodogram. If you do not, the results will be garbage.</li>
<li>it computes the unnormalized periodogram, which can be normalized manually as we'll see below.</li>
<li>it takes <em>angular frequencies</em> as the argument.</li>
</ul>
<p>Let's use scipy's algorithm to plot the periodogram of the data shown above. Note that the results will not be identical, because this algorithm ignores the noise in the data and doesn't fit for the data mean.</p>
<p>Against the above recommendations, we'll choose a simple regular grid in period for the plot:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [6]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">lombscargle</span>

<span class="c"># Choose a period grid</span>
<span class="n">periods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">,</span> <span class="mi">4000</span><span class="p">)</span>
<span class="n">ang_freqs</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">periods</span>

<span class="c"># compute the (unnormalized) periodogram</span>
<span class="c"># note pre-centering of y values!</span>
<span class="n">power</span> <span class="o">=</span> <span class="n">lombscargle</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mag</span> <span class="o">-</span> <span class="n">mag</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">ang_freqs</span><span class="p">)</span>

<span class="c"># normalize the power</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">power</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">mag</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

<span class="c"># plot the results</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span> <span class="n">xlabel</span><span class="o">=</span><span class="s">'period (days)'</span><span class="p">,</span>
       <span class="n">ylabel</span><span class="o">=</span><span class="s">'Lomb-Scargle Power'</span><span class="p">);</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>Comparing to the first periodogram plot, we see that becuase our period grid here is too coarse at low frequencies, some of the peak structure is missed by this visualization. Consider this a warning against arbitrarily choosing a period gridding!</p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="astroml.time_series.lomb_scargle"><code>astroML.time_series.lomb_scargle</code></h4>
<p>AstroML has two <span class="math">\(O[N^2]\)</span> implementations of Lomb-Scargle: one in <code>astroML</code> and one in <code>astroML_addons</code>, which is a collection of C extensions which replace slower functionality in the pure-python astroML package. In order to use the faster version, make sure you install both packages; e.g.</p>
<pre><code>$pip install astroML$ pip install astroML_addons</code></pre>
<p>Some important features of astroML's Lomb Scargle periodogram:</p>
<ul>
<li>unlike scipy, it uses an extended periodogram model which can correctly account for uncorrelated Gaussian measurement error.</li>
<li>like scipy, it takes <em>angular frequencies</em> as its argument.</li>
<li>unlike scipy, it implements a <em>floating mean periodogram</em>, meaning that the data centering required for scipy is not required here, but it goes beyond simple centering: the mean of the data is fit <em>as part of the model</em>, which has advantages in many real-world scenarios. To directly compare to scipy's standard Lomb Scargle pass <code>generalized=False</code>.</li>
</ul>
<p>Let's repeat the above plot with this periodogram:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [7]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="kn">from</span> <span class="nn">astroML.time_series</span> <span class="kn">import</span> <span class="n">lomb_scargle</span>
<span class="n">power</span> <span class="o">=</span> <span class="n">lomb_scargle</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">dmag</span><span class="p">,</span> <span class="n">ang_freqs</span><span class="p">)</span>

<span class="c"># plot the results</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span> <span class="n">xlabel</span><span class="o">=</span><span class="s">'period (days)'</span><span class="p">,</span>
       <span class="n">ylabel</span><span class="o">=</span><span class="s">'Lomb-Scargle Power'</span><span class="p">);</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="gatspy.periodic.lombscargle"><code>gatspy.periodic.LombScargle</code></h4>
<p>Gatspy's basic Lomb-Scargle algorithm is an <span class="math">\(O[N^2]\)</span> implementation, but is implemented differently than either of the above versions. It uses a direct linear algebra approach which carries some additional computational and memory overhead. The reason for this approach is that it naturally accommodates several extensions to the periodogram, including floating mean, multiple terms, regularization, and multi-band models (more details in <a href="http://adsabs.harvard.edu/abs/2015arXiv150201344V">VanderPlas &amp; Ivezic (2015)</a>, the paper that inspired <code>gatspy</code>).</p>
<p>Gatspy is a pure python package, and thus installation is easy and requires no compilation of C or Fortran code:</p>
<pre><code>$ pip install gatspy</code></pre>
<p>Some important features of this implementation:</p>
<ul>
<li>like astroML, it uses an extended periodogram model which correctly accounts for uncorrelated Gaussian measurement error.</li>
<li>unlike astroML, it takes <em>periods</em> as its argument.</li>
<li>like astroML, it uses a floating mean model by default. To compare directly to scipy's non-floating-mean model, set <code>fit_offset=False</code>.</li>
<li>it has an API inspired by scikit-learn, where the model itself is a class instance, the model is applied to data with a <code>fit()</code> method, and the periodogram is computed via a <code>score()</code> method.</li>
</ul>
<p>Let's repeat the above periodogram using this tool:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [8]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="kn">from</span> <span class="nn">gatspy.periodic</span> <span class="kn">import</span> <span class="n">LombScargle</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">LombScargle</span><span class="p">(</span><span class="n">fit_offset</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">dmag</span><span class="p">)</span>
<span class="n">power</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">periods</span><span class="p">)</span>

<span class="c"># plot the results</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span> <span class="n">xlabel</span><span class="o">=</span><span class="s">'period (days)'</span><span class="p">,</span>
       <span class="n">ylabel</span><span class="o">=</span><span class="s">'Lomb-Scargle Power'</span><span class="p">);</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="gatspy.periodic.lombscarglefast"><code>gatspy.periodic.LombScargleFast</code></h4>
<p>Gatspy's fast Lomb-Scargle is an <span class="math">\(O[N\log N]\)</span> algorithm built on a pure Python/numpy implementation of the Press &amp; Rybicki FFT/extirpolation method. Note that a requirement of this fast algorithm is that it be computed on a regular grid of <em>frequencies</em> (not periods), and so to attain this performance it provides the <code>score_frequency_grid()</code> method which takes 3 arguments: the minimum frequency <code>f0</code>, the frequency spacing <code>df</code>, and the number of grid points <code>N</code>.</p>
<p>Some features of the model</p>
<ul>
<li>like astroML, it uses an extended periodogram model which correctly accounts for uncorrelated Gaussian measurement error.</li>
<li>it takes <em>a regular frequency grid</em> as its argument for the fast computation; note that the <code>score()</code> function itself falls back on the slower <code>LombScargle</code> approach above.</li>
<li>like astroML, it uses a floating mean model by default. To compare directly to scipy, set <code>fit_offset=False</code>.</li>
<li>it has an identical API to the <code>LombScargle</code> object above.</li>
</ul>
<p>Let's take a look at computing the periodogram:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [9]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="kn">from</span> <span class="nn">gatspy.periodic</span> <span class="kn">import</span> <span class="n">LombScargleFast</span>

<span class="n">fmin</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">periods</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">fmax</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">periods</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="n">df</span> <span class="o">=</span> <span class="p">(</span><span class="n">fmax</span> <span class="o">-</span> <span class="n">fmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">LombScargleFast</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">dmag</span><span class="p">)</span>
<span class="n">power</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">score_frequency_grid</span><span class="p">(</span><span class="n">fmin</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">freqs</span> <span class="o">=</span> <span class="n">fmin</span> <span class="o">+</span> <span class="n">df</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="c"># plot the results</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span> <span class="n">xlabel</span><span class="o">=</span><span class="s">'period (days)'</span><span class="p">,</span>
       <span class="n">ylabel</span><span class="o">=</span><span class="s">'Lomb-Scargle Power'</span><span class="p">);</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>You'll notice here that this approach shows a lot more high-frequency peaks than any of the above versions. This is not because it is computing a different model; it is because we are using a finer frequency grid which does not miss these peaks. The above versions, with a regular grid of 4000 periods <em>miss these important features</em>, and give the user absolutely no warning that these features are missed! Keep this in mind as you choose grid parameters while following the above discussion.</p>
<p>If you want to make sure you're using a sufficient grid, you can use the <code>periodogram_auto()</code> method of <code>LombScargleFast</code>, which computes a sufficient frequency grid for you using the rules-of-thumb discussed in the previous section:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [10]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">model</span> <span class="o">=</span> <span class="n">LombScargleFast</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">dmag</span><span class="p">)</span>

<span class="n">period</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">periodogram_auto</span><span class="p">(</span><span class="n">nyquist_factor</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"period range: ({0}, {1})"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">period</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">period</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"number of periods: {0}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">period</span><span class="p">)))</span>
</pre></div>

</div>
</div>

<div class="vbox output_wrapper">
<div class="output vbox">


<div class="hbox output_area"><p class="prompt"/>
<div class="box-flex1 output_subarea output_stream output_stdout">
<pre>
period range: (0.0764511670428014, 9823.97496499998)
number of periods: 128500

</pre>
</div>
</div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>The model decided that we needed over 100,000 periods, between about 0.1 days (which was tuned by the <code>nyquist_factor</code> argument) and about 10,000 days (which is derived from the time-span of the data). Plotting the results as above, we see a similar periodogram:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [11]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="c"># plot the results</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">period</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">),</span> <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
       <span class="n">xlabel</span><span class="o">=</span><span class="s">'period (days)'</span><span class="p">,</span>
       <span class="n">ylabel</span><span class="o">=</span><span class="s">'Lomb-Scargle Power'</span><span class="p">);</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>The <code>LombScargleFast</code> algorithm computes these <span class="math">\(10^5\)</span> periodogram steps very quickly; I wouldn't suggest any of the other methods with a grid of this size!</p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="benchmarking-lomb-scargle-implementations">Benchmarking Lomb-Scargle Implementations</h2>
<p>As a final piece of the picture, let's compare the execution speed of the four approaches. We can do this with IPython's <code>%timeit</code> magic function using the following script. Note that this script will take several minutes to run, as it automatically does multiple passes of each benchmark to minimize system timing variation. For efficiency, we cut-off the slower algorithms at high <span class="math">\(N\)</span>:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [12]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">lombscargle</span> <span class="k">as</span> <span class="n">ls_scipy</span>
<span class="kn">from</span> <span class="nn">astroML.time_series</span> <span class="kn">import</span> <span class="n">lomb_scargle</span> <span class="k">as</span> <span class="n">ls_astroML</span>

<span class="k">def</span> <span class="nf">create_data</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">rseed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="mf">0.61</span><span class="p">):</span>
    <span class="sd">"""Create noisy data"""</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">rseed</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">52000</span> <span class="o">+</span> <span class="mi">2000</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">dmag</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
    <span class="n">mag</span> <span class="o">=</span> <span class="mi">15</span> <span class="o">+</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">t</span> <span class="o">/</span> <span class="n">period</span><span class="p">)</span> <span class="o">+</span> <span class="n">dmag</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">dmag</span>

<span class="k">def</span> <span class="nf">compute_frequency_grid</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">oversampling</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">"""Compute the optimal frequency grid (**not** angular frequencies)"""</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">oversampling</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">fmax</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">fmax</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>

<span class="n">Nrange</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
<span class="n">t_scipy</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">t_astroML</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">t_gatspy1</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">t_gatspy2</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">Nrange</span><span class="p">:</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">dmag</span> <span class="o">=</span> <span class="n">create_data</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">compute_frequency_grid</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">periods</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">freqs</span>
    <span class="n">ang_freqs</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freqs</span>
    <span class="n">f0</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">Nf</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
    
    <span class="c"># Don't compute the slow algorithms at very high N</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">15</span><span class="p">:</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="o">%</span><span class="k">timeit</span> <span class="o">-</span><span class="n">oq</span> <span class="n">ls_scipy</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mag</span> <span class="o">-</span> <span class="n">mag</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">ang_freqs</span><span class="p">)</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="o">%</span><span class="k">timeit</span> <span class="o">-</span><span class="n">oq</span> <span class="n">ls_astroML</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">dmag</span><span class="p">,</span> <span class="n">ang_freqs</span><span class="p">)</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="o">%</span><span class="k">timeit</span> <span class="o">-</span><span class="n">oq</span> <span class="n">LombScargle</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">dmag</span><span class="p">)</span><span class="o">.</span><span class="n">score_frequency_grid</span><span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">Nf</span><span class="p">)</span>
        <span class="n">t_scipy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">best</span><span class="p">)</span>
        <span class="n">t_astroML</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">best</span><span class="p">)</span>
        <span class="n">t_gatspy1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t3</span><span class="o">.</span><span class="n">best</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t_scipy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">t_astroML</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">t_gatspy1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        
    <span class="n">t4</span> <span class="o">=</span> <span class="o">%</span><span class="k">timeit</span> <span class="o">-</span><span class="n">oq</span> <span class="n">LombScargleFast</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">dmag</span><span class="p">)</span><span class="o">.</span><span class="n">score_frequency_grid</span><span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">Nf</span><span class="p">)</span>
    <span class="n">t_gatspy2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t4</span><span class="o">.</span><span class="n">best</span><span class="p">)</span>
</pre></div>

</div>
</div>

</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>When these timings are finished, we can plot the results to get an idea of how the algorithms compare:</p>
</div>
<div class="cell border-box-sizing code_cell vbox">
<div class="input hbox">
<p class="prompt input_prompt">
In [13]:
</p>
<div class="input_area box-flex1">
<div class="highlight-ipynb"><pre class="ipynb"><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">xscale</span><span class="o">=</span><span class="s">'log'</span><span class="p">,</span> <span class="n">yscale</span><span class="o">=</span><span class="s">'log'</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Nrange</span><span class="p">,</span> <span class="n">t_scipy</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'scipy: lombscargle'</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Nrange</span><span class="p">,</span> <span class="n">t_astroML</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'astroML: lomb_scargle'</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Nrange</span><span class="p">,</span> <span class="n">t_gatspy1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'gatspy: LombScargle'</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Nrange</span><span class="p">,</span> <span class="n">t_gatspy2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'gatspy: LombScargleFast'</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s">'N'</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s">'time (seconds)'</span><span class="p">,</span>
       <span class="n">title</span><span class="o">=</span><span class="s">'Comparison of Lomb-Scargle Implementations'</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">);</span>
</pre></div>

</div>
</div>



</div>
<div class="text_cell_render border-box-sizing rendered_html">
<p>Each model has a characteristic performance curve:</p>
<ul>
<li>The <strong>scipy</strong> and <strong>astroML</strong> algorithms show similar behavior: fast <span class="math">\(O[1]\)</span> scaling at the small-<span class="math">\(N\)</span> limit, and clear <span class="math">\(O[N^2]\)</span> scaling at the large-<span class="math">\(N\)</span> limit. SciPy is slightly faster, primarily due to the fact that it computes the simpler noiseless non-floating-mean model.</li>
<li>Gatspy's <code>LombScargle</code> also becomes <span class="math">\(O[N^2]\)</span> at large <span class="math">\(N\)</span>, but is dominated at small <span class="math">\(N\)</span> by an <span class="math">\(O[N]\)</span> contribution which comes from allocating &amp; building the matrices associated with its linear algebraic approach. As <span class="math">\(N\)</span> grows larger than <span class="math">\(\sim 10^4\)</span>, however, gatspy's model begins to beat the performance of the other two <span class="math">\(O[N^2]\)</span> algorithms.</li>
<li>Gatspy's <code>LombScargleFast</code> has an upfront <span class="math">\(O[1]\)</span> cost that makes it slower than other approaches at small <span class="math">\(N\)</span>, but as <span class="math">\(N\)</span> grows its <span class="math">\(O[N\log N]\)</span> scaling means it dominates the performance of the other approaches by orders of magnitude.</li>
</ul>
<p>If you'd like to push the speed of the computation even further, there may be some options available. For example, the <a href="https://pypi.python.org/pypi/pynfftls/">pynfftls</a> package implements an <span class="math">\(O[N\log N]\)</span> Lomb-Scargle based on the NFFT algorithm, which is similar to the NUFFT that I discussed in a <a href="https://jakevdp.github.io/blog/2015/02/24/optimizing-python-with-numpy-and-numba/">previous post</a>. The <code>pynfftls</code> installation depends on prior installations of the <a href="http://www-user.tu-chemnitz.de/~potts/nfft/download.php">NFFT</a> and <a href="http://www.fftw.org/">FFTW</a> libraries. These libraries are best-in-class implementations of their respective algorithms, and from my past experience with them, I'd expect <code>pynfftls</code> to be around a factor of 10 faster than <code>LombScargleFast</code> with the same <span class="math">\(O[N\log N]\)</span> scaling.</p>
<p>I should mention that I briefly tried installing <code>pynfftls</code> for this post, but ran into difficulties with linking the source to the appropriate C headers and library/shared object files. No doubt with a couple hours of tinkering it could be done, but in a <a href="http://www.continuum.io/blog/conda">conda</a> world I've found my threshold of tolerance for such installation headaches has gone <em>way</em> down. Package developers take note: in most situations, ease of installation is easily worth a factor of a few in runtime performance. If any readers want to tackle the comparison between <code>LombScargleFast</code> and <code>pynfftls</code>, I'd be intrested to learn whether my factor-of-ten intuition is correct!</p>
</div>
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="conclusion">Conclusion</h2>
<p>If there's anything I want you to take from the above discussion, it's these three points:</p>
<ul>
<li>Naive application of Nyquist-style limits to irregularly-sampled data is 100% wrong. Don't be the next person to make this mistake in the published literature! I've been meaning to write a full rant/post on this subject for a while. Perhaps I will someday.</li>
<li>Selection of period/frequency grids for Lomb-Scargle analysis should not be taken lightly. It's very easy to inadvertently use too coarse of a grid, and entirely miss important periodogram peaks!</li>
<li>Use <code>gatspy.periodic.LombScargleFast</code> if you want any easy-to-install means of computing a fast, <span class="math">\(O[N\log N]\)</span> Lomb-Scargle periodogram in Python.</li>
</ul>
<p><small> This post was written entirely in the IPython notebook. You can <a href="http://jakevdp.github.io/downloads/notebooks/LombScarglePython.ipynb">download</a> this notebook, or see a static view <a href="http://nbviewer.ipython.org/url/jakevdp.github.io/downloads/notebooks/LombScarglePython.ipynb">here</a>. </small></p>
</div></div>
    </div></body></html>