<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/getpro/habr/post_images/d8f/708/fed/d8f708fedf75540efa66b12784f92fbb.png"/><p>
Привет, друзья! Сегодня мы наконец-то доделаем нашего </p><b>мариобоя</b><p>. Начало </p><a href="http://habrahabr.ru/post/193888/">тут</a><p> и </p><a href="http://habrahabr.ru/post/196432/">тут</a><p>. Вот только мы не будем изобретать свой велосипед в виде редактора уровней, а воспользуемся готовым мощным </p><a href="http://www.mapeditor.org">инструментом</a><p>. За знакомство с которым я благодарен господам(товарищам) </p><a href="https://habrahabr.ru/users/sourcerer/" class="user_link">sourcerer</a><p> и </p><a href="https://habrahabr.ru/users/tarvitz/" class="user_link">Tarvitz</a>

<h4>Почему так?</h4><p>
На это есть несколько причин
</p><ul>
<li>Удобный редактор уровней не пишется за 5 минут, лучше потратим это время на допиливание самой игры</li>
<li>Более легкий способ добавления в игру разных на вид типов блоков</li>
<li><b>Tiled map editor</b> является универсальным инструментом для 2d игр, разобравшись с ним единожды, мы приобретаем навык генерации уровней для разных игр, написанных на разных языках и технологиях</li>
</ul>
<a name="habracut"/>
<h4>Создаём неприятности и преграды нашему герою</h4><p>
Про работу с Tiled map editor можно почитать, например, </p><a href="http://habrahabr.ru/post/199064/">тут</a><p>.</p><p>
Я же опишу основные моменты создания уровня именно для нашей игры.</p><p>
Наша карта состоит из минимум 5-ти слоёв:
</p><ol>
<li><b>BackGround</b> — фон </li>
<li><b>Platforms</b> — блоки, по которым можно бегать </li>
<li><b>DieBlocks</b> -блоки, соприкосновение с которыми вызывает у героя моментальную смерть</li>
<li><b>Monsters</b> — слой объектов, тут наши монстрики, а так же, принцесса и сам герой</li>
<li><b>Teleports</b> -слой объектов, для чего — понятно по названию </li>
</ol>
<img src="https://habrastorage.org/getpro/habr/post_images/f3b/268/58b/f3b26858b4d0e188ef68a744237c9655.png"/>

<h5>Фон</h5><p>
Тут можете рисовать что угодно и как угодно, </p><a href="http://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F_%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0">тайлы</a><p> с этого слоя ни как не влияют на героя или игровой процесс, разве что на эстетический вид игры :)
</p><img src="https://habrastorage.org/getpro/habr/post_images/5b4/18f/cfa/5b418fcfaf01fe8f4d17de6e41dcdcf3.png"/>

<h5>Блоки, по которым можно бегать</h5><p>
На этом слое располагаются тайлы, которые в игре создают объекты класса </p><b>Platform</b>
<img src="https://habrastorage.org/getpro/habr/post_images/009/db6/30f/009db630f14e66295f51866460f36588.png"/>

<h5>Смертельно опасные блоки</h5><p>
Все тайлы, независимо от внешнего вида, будь то шипы или кирпичная стена, создают в игре объекты класса </p><b>BlockDie</b>
<img src="https://habrastorage.org/getpro/habr/post_images/aa7/553/4bd/aa75534bd5bcf11fa8bc770881791d10.png"/>

<h5>Монстры</h5><p>
Это слой объектов, а значит, он не отображает в игре тайлы и каждый объект, добавленный на него, должен обладать какими — нибудь свойствами.</p><p>
Объекты класса </p><b>Monster</b><p>, чей конструктор имеет следующий вид
</p><pre><code class="python">class Monster(sprite.Sprite):
    def __init__(self, x, y, left, up, maxLengthLeft,maxLengthUp):
</code></pre><p>
Обязательно должны иметь такие свойства, как: </p><b>left</b><p>, </p><b>maxLeft</b><p>, </p><b>up</b><p>, </p><b>maxUp</b><p> — заполняемые вручную и </p><b>x</b><p>, </p><b>y</b><p> — передающиеся по расположению объекта.
</p><img src="https://habrastorage.org/getpro/habr/post_images/714/e90/df4/714e90df4e1289515f27d6dd7eeac9d0.png"/>
<p>
Объект персонажа должен иметь имя </p><b>Player</b>
<img src="https://habrastorage.org/getpro/habr/post_images/746/73d/a52/74673da52f854bf7c8f4e4c0880f2b58.png"/>
<p>
Объект принцессы должен иметь имя Princess
</p><img src="https://habrastorage.org/getpro/habr/post_images/8e2/a98/d48/8e2a98d485bdc41c1d6129c874800542.png"/>
<p>
Вид слоя:
</p><img src="https://habrastorage.org/getpro/habr/post_images/c74/e8e/cdb/c74e8ecdb6ea6c1b6589105c83aa004d.png"/>

<h5>Телепорты</h5><p>
Объекты этого слоя должны иметь свойства конечного назначения перемещения героя: </p><b>goX</b><p> и </p><b>goY</b>
<img src="https://habrastorage.org/getpro/habr/post_images/79e/931/607/79e9316077562c5cf9e5e3ab23a2405e.png"/><p>
Слой:
</p><img src="https://habrastorage.org/getpro/habr/post_images/170/c1f/541/170c1f541d6de27faf21eefec94f1020.png"/>
<h6>Как узнать конечные координаты?</h6><p>
Легко! Навести курсор мыши на то место, куда хотите, чтобы герой телепортировался и посмотреть слева снизу координаты места
</p><img src="https://habrastorage.org/getpro/habr/post_images/7f0/4c1/cfd/7f04c1cfdb60bbee6084545408688fe0.png"/>

<h4>Карту в игру</h4>
<s>Немного</s><p>Изменим основной файл игры для того, чтобы открыть в ней выше созданную карту.</p><p>
Для начала скачиваем необходимые библиотеки от </p><a href="https://code.google.com/p/pytmxloader/downloads/list">сюда</a><p> и кидаем их в папку с исходными кодами игры. </p><p>
И импортируем их
</p><pre><code class="python">import tmxreader # Может загружать tmx файлы
import helperspygame # Преобразует tmx карты в формат  спрайтов pygame
</code></pre><p>
Далее, очищаем процедуру </p><b>loadLevel()</b><p>, мы её перепишем.
</p><div class="spoiler"><b class="spoiler_title">loadlevel</b><div class="spoiler_text"><pre><code class="python">def loadLevel(name):
    global playerX, playerY # объявляем глобальные переменные, это координаты героя
    global total_level_height, total_level_width
    global sprite_layers # все слои карты

    world_map = tmxreader.TileMapParser().parse_decode('%s/%s.tmx' % (FILE_DIR, name)) # загружаем карту
    resources = helperspygame.ResourceLoaderPygame() # инициируем преобразователь карты 
    resources.load(world_map) # и преобразуем карту в понятный pygame формат
    
    sprite_layers = helperspygame.get_layers_from_map(resources) # получаем все слои карты
    
    # берем слои по порядку 0 - слой фона, 1- слой блоков, 2 - слой смертельных блоков
    # 3 - слой объектов монстров, 4 - слой объектов телепортов
    platforms_layer = sprite_layers[1] 
    dieBlocks_layer = sprite_layers[2]

    for row in range(0, platforms_layer.num_tiles_x): # перебираем все координаты тайлов
        for col in range(0, platforms_layer.num_tiles_y):
            if platforms_layer.content2D[col][row] is not None:
                pf = Platform(row * PLATFORM_WIDTH, col * PLATFORM_WIDTH)# как и прежде создаем объкты класса Platform
                platforms.append(pf)
            if dieBlocks_layer.content2D[col][row] is not None:
                bd = BlockDie(row * PLATFORM_WIDTH, col * PLATFORM_WIDTH)
                platforms.append(bd)

    teleports_layer = sprite_layers[4]
    for teleport in teleports_layer.objects:
        try: # если произойдет ошибка на слое телепортов
            goX = int(teleport.properties["goX"]) * PLATFORM_WIDTH
            goY = int (teleport.properties["goY"]) * PLATFORM_HEIGHT
            x = teleport.x
            y = teleport.y - PLATFORM_HEIGHT
            tp = BlockTeleport(x, y, goX, goY)
            entities.add(tp)
            platforms.append(tp)
            animatedEntities.add(tp)
        except: # то игра не вылетает, а просто выводит сообщение о неудаче
            print(u"Ошибка на слое телепортов")

    monsters_layer = sprite_layers[3]
    for monster in monsters_layer.objects:
        try:
            x = monster.x
            y = monster.y
            if monster.name == "Player":
                playerX = x
                playerY = y - PLATFORM_HEIGHT
            elif monster.name == "Princess":
                pr = Princess(x, y - PLATFORM_HEIGHT)
                platforms.append(pr)
                entities.add(pr)
                animatedEntities.add(pr)
            else:
                up = int(monster.properties["up"])
                maxUp = int(monster.properties["maxUp"])
                left = int(monster.properties["left"])
                maxLeft = int(monster.properties["maxLeft"])
                mn = Monster(x, y - PLATFORM_HEIGHT, left, up, maxLeft, maxUp)
                entities.add(mn)
                platforms.append(mn)
                monsters.add(mn)
        except:
            print(u"Ошибка на слое монстров")

    total_level_width = platforms_layer.num_tiles_x * PLATFORM_WIDTH # Высчитываем фактическую ширину уровня
    total_level_height = platforms_layer.num_tiles_y * PLATFORM_HEIGHT   # высоту
 </code></pre>
</div></div>
<h6>Что мы тут видим?</h6><p>
Начнем с того, что теперь процедура принимает входной параметр </p><b>name</b><p>, который используется для загрузки карты уровня. Это сделали для того, чтобы сделать переход между уровнями.</p><p>
Далее идёт загрузка и преобразование карты, и по тому же принципу, что мы парсили массив с картой, парсим слои с тайлами. Обратите внимание, что теперь созданные объекты классов </p><b>Platform</b><p> и </p><b>BlockDie</b><p> не помещаются в группу </p><b>entities</b><p>, а значит, мы их не будет отображать т.е. они будут существовать, но не отображаться. Вместо них мы будет отображать тайлы со слоёв карты.

</p><h6>Продолжим</h6><p>
Теперь займемся процедурой </p><b>main</b><p>
Добавим визуализатор</p><a href="http://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BD%D0%B4%D0%B5%D1%80%D0%B8%D0%BD%D0%B3">(рендерер)</a><p> слоёв карты
</p><pre><code class="python">renderer = helperspygame.RendererPygame() # визуализатор
</code></pre><p>
Для чего он — увидим чуть ниже
</p><p>
Изменим вызов процедуры </p><b>loadLevel</b>
<pre><code class="python">for lvl in range(1,4):
        loadLevel("map_%s" % lvl)
</code></pre><p>
И далее, весь код будет в этом цикле
</p><p>
В блоке вывода изображений на экран добавим работу визуализатора
</p><pre><code class="python">for sprite_layer in sprite_layers: # перебираем все слои
      if not sprite_layer.is_object_group: # и если это не слой объектов
           renderer.render_layer(screen, sprite_layer) # отображаем его
***
 center_offset = camera.reverse(CENTER_OF_SCREEN) # получаем координаты внутри длинного уровня
 renderer.set_camera_position_and_size(center_offset[0], center_offset[1], \
                                                  WIN_WIDTH, WIN_HEIGHT, "center")
</code></pre><p>
Обратите внимание, что </p><b>renderer</b><p> выводит свои изображения по центру экрана, внутри передвигающегося фокуса камеры, для этого нам нужно было добавить процедуру в класс </p><b>Camera</b>
<div class="spoiler"><b class="spoiler_title">Camera</b><div class="spoiler_text"><pre><code class="python">class Camera(object):
    def __init__(self, camera_func, width, height):
        self.camera_func = camera_func
        self.state = Rect(0, 0, width, height)

    def apply(self, target):
        return target.rect.move(self.state.topleft)

    def update(self, target):
        self.state = self.camera_func(self.state, target.rect)

    def reverse(self, pos):# получение внутренних координат из глобальных
        return pos[0] - self.state.left, pos[1] - self.state.top
</code></pre>
</div></div>
<p>
Уберем то, что перенесли в процедуру </p><b>loadlevel</b><p>, добавим немного нового и получим следующий вид:
</p><div class="spoiler"><b class="spoiler_title">main</b><div class="spoiler_text"><pre><code class="python">def main():
    pygame.init() # Инициация PyGame, обязательная строчка
    screen = pygame.display.set_mode(DISPLAY) # Создаем окошко
    pygame.display.set_caption("Super Mario Boy") # Пишем в шапку
    bg = Surface((WIN_WIDTH, WIN_HEIGHT)) # Создание видимой поверхности
    # будем использовать как фон

    renderer = helperspygame.RendererPygame() # визуализатор
    for lvl in range(1,4):
        loadLevel("levels/map_%s" % lvl)
        bg.fill(Color(BACKGROUND_COLOR))     # Заливаем поверхность сплошным цветом

        left = right = False # по умолчанию - стоим
        up = False
        running = False
        try:
            hero = Player(playerX, playerY) # создаем героя по (x,y) координатам
            entities.add(hero)
        except:
            print (u"Не удалось на карте найти героя, взяты координаты по-умолчанию")
            hero = Player(65, 65)
        entities.add(hero)

        timer = pygame.time.Clock()

        camera = Camera(camera_configure, total_level_width, total_level_height)

        while not hero.winner: # Основной цикл программы
            timer.tick(60)
            for e in pygame.event.get(): # Обрабатываем события
                if e.type == QUIT:
                    raise SystemExit, "QUIT"
                if e.type == KEYDOWN and e.key == K_UP:
                    up = True
                if e.type == KEYDOWN and e.key == K_LEFT:
                    left = True
                if e.type == KEYDOWN and e.key == K_RIGHT:
                    right = True
                if e.type == KEYDOWN and e.key == K_LSHIFT:
                    running = True

                if e.type == KEYUP and e.key == K_UP:
                    up = False
                if e.type == KEYUP and e.key == K_RIGHT:
                    right = False
                if e.type == KEYUP and e.key == K_LEFT:
                    left = False
                if e.type == KEYUP and e.key == K_LSHIFT:
                    running = False
            for sprite_layer in sprite_layers: # перебираем все слои
                if not sprite_layer.is_object_group: # и если это не слой объектов
                   renderer.render_layer(screen, sprite_layer) # отображаем его

            for e in entities:
                screen.blit(e.image, camera.apply(e))
            animatedEntities.update() # показываеaм анимацию
            monsters.update(platforms) # передвигаем всех монстров
            camera.update(hero) # центризируем камеру относительно персонаж
            center_offset = camera.reverse(CENTER_OF_SCREEN)
            renderer.set_camera_position_and_size(center_offset[0], center_offset[1], \
                                                  WIN_WIDTH, WIN_HEIGHT, "center")
            hero.update(left, right, up, running, platforms) # передвижение
            pygame.display.update()     # обновление и вывод всех изменений на экран
            screen.blit(bg, (0, 0))      # Каждую итерацию необходимо всё перерисовывать
        for sprite_layer in sprite_layers:
            if not sprite_layer.is_object_group:
                renderer.render_layer(screen, sprite_layer)
        # когда заканчиваем уровень
        for e in entities:
            screen.blit(e.image, camera.apply(e)) # еще раз все перерисовываем
        font=pygame.font.Font(None,38) 
        text=font.render(("Thank you MarioBoy! but our princess is in another level!"), 1,(255,255,255))# выводим надпись
        screen.blit(text, (10,100))
        pygame.display.update()
        time.wait(10000) # ждем 10 секунд и после - переходим на следующий уровень
</code></pre>
</div></div>
<h6>Что тут интересного?</h6><p>
кроме того, что мы разобрали в этой и предыдущей частях статьи, тут имеется событие, присходящее, когда наш герой касается принцессы. В этот момент мы выводим сообщение о его неудаче и, даём время прочитать его и идет на следующую итерацию, загружая следующий уровень.
</p><p>
Вот и всё. Вот так, легко и быстро мы переделали игру для загрузки уровней из </p><b> tmx </b><p> файлов.
</p><iframe src="https://www.youtube.com/embed/oOvgT108dx4?feature=oembed" frameborder="0" allowfullscreen="">VIDEO</iframe><p>
Исходники на </p><a href="https://github.com/Velesey/SuperMarioBoy/releases/tag/0.2.2">github</a>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>