<html><body><div><div class="post">
  <h1 class="post-title">Saving 9 GB of RAM with Python’s __slots__</h1>
  <span class="post-date">17 Nov 2013 by Ben</span>
  <p>We’ve <a href="http://tech.oyster.com/pythons-garbage-collector/">mentioned before</a> how Oyster.com’s Python-based web servers cache huge amounts of static content in huge Python dicts (hash tables). Well, we recently saved over 2 GB in each of four 6 GB server processes with a single line of code — using <a href="http://docs.python.org/2/reference/datamodel.html#slots"><code class="highlighter-rouge">__slots__</code></a> on our <code class="highlighter-rouge">Image</code> class.</p>

<p>Here’s a screenshot of RAM usage before and after deploying this change on one of our servers:</p>

<p><img class=" wp-image-801 " alt="RAM usage before and after deploying this change" src="http://tech.oyster.com/wp-content/uploads/2013/11/physical-memory-usage-history.png"/></p>

<p>We allocate about a million instances of a class like the following:</p>

<pre>class Image(object):
    def __init__(self, id, caption, url):
        self.id = id
        self.caption = caption
        self.url = url
        self._setup()

    # ... other methods ...</pre>

<p>By default Python uses a dict to store an object’s instance attributes. Which is usually fine, and it allows fully dynamic things like setting arbitrary new attributes at runtime.</p>

<p>However, for small classes that have a few fixed attributes known at “compile time”, the dict is a waste of RAM, and this makes a real difference when you’re creating a million of them. You can tell Python not to use a dict, and only allocate space for a fixed set of attributes, by settings <code class="highlighter-rouge">__slots__</code> on the class to a fixed list of attribute names:</p>

<pre>class Image(object):
    __slots__ = ['id', 'caption', 'url']

    def __init__(self, id, caption, url):
        self.id = id
        self.caption = caption
        self.url = url
        self._setup()

    # ... other methods ...</pre>

<p>Note that you can also use <a href="http://docs.python.org/2/library/collections.html#collections.namedtuple">collections.namedtuple</a>, which allows attribute access, but only takes the space of a tuple, so it’s similar to using <code class="highlighter-rouge">__slots__</code> on a class. However, to me it always <a href="http://stackoverflow.com/questions/4071765/in-python-how-do-i-call-the-super-class-when-its-a-one-off-namedtuple">feels weird</a> to inherit from a namedtuple class. Also, if you want a custom initializer you have to override <code class="highlighter-rouge">__new__</code> rather than <code class="highlighter-rouge">__init__</code>.</p>

<p><strong>Warning:</strong> Don’t prematurely optimize and use this everywhere! It’s not great for code maintenance, and it really only saves you when you have thousands of instances.</p>


</div>

</div></body></html>