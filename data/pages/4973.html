<html><body><div><div class="post hentry" itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting">
<meta content="1659670526506182475" itemprop="blogId"/>
<meta content="3632565007916559950" itemprop="postId"/>
<a name="3632565007916559950"/>
<h1 class="post-title entry-title">
Django Rest Framework - обновление поля типа ImageField
</h1>
<div class="post-header">
<p class="post-header-line-1"/>
<span class="post-author vcard">
<i class="fa fa-user"/>
<span class="fn">
Максим Дунаевский
</span>
</span>
<span class="post-timestamp">
<i class="fa fa-clock-o"/>
<abbr class="published" title="2015-06-16T05:42:00-07:00">
5:42
</abbr>
</span>
<span class="post-labels">
<i class="fa fa-tags"/>
<a href="http://dunmaksim.blogspot.ru/search/label/%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0" rel="tag">
загрузка
</a>

                                ,
                              
<a href="http://dunmaksim.blogspot.ru/search/label/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5" rel="tag">
изображение
</a>

                                ,
                              
<a href="http://dunmaksim.blogspot.ru/search/label/%D0%BE%D0%B1%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5" rel="tag">
обновление
</a>

                                ,
                              
<a href="http://dunmaksim.blogspot.ru/search/label/%D1%84%D0%B0%D0%B9%D0%BB" rel="tag">
файл
</a>

                                ,
                              
<a href="http://dunmaksim.blogspot.ru/search/label/django" rel="tag">
django
</a>

                                ,
                              
<a href="http://dunmaksim.blogspot.ru/search/label/Field" rel="tag">
Field
</a>

                                ,
                              
<a href="http://dunmaksim.blogspot.ru/search/label/Framework" rel="tag">
Framework
</a>

                                ,
                              
<a href="http://dunmaksim.blogspot.ru/search/label/image" rel="tag">
image
</a>

                                ,
                              
<a href="http://dunmaksim.blogspot.ru/search/label/patch" rel="tag">
patch
</a>

                                ,
                              
<a href="http://dunmaksim.blogspot.ru/search/label/REST" rel="tag">
REST
</a>

                                ,
                              
<a href="http://dunmaksim.blogspot.ru/search/label/update" rel="tag">
update
</a>
</span>
<span class="post-comment-link">
<a class="comment-link" href="http://dunmaksim.blogspot.ru/2015/06/django-rest-framework-imagefield.html#comment-form">
Комментариев нет
</a>
</span>
</div>
<p>Убил сегодня полдня на решение этой проблемы. Чтобы не забыть, сразу же публикую всё здесь.</p>

<h2>Исходные данные</h2>

<p>Дано:</p>
<ul>
    <li>Модель, имеющая поле типа <code>ImageField</code></li>
    <li>Django REST Framework</li>
    <li><a href="https://github.com/danialfarid/ng-file-upload">ngFileUpload</a> на фронте</li>
</ul>

<p>Задача: сделать возможным загрузку изображений в указанное поле на основе <b>Class-Based View</b> в DRF.</p>

<h2>Решение</h2>

<h3>Фронт-энд:</h3>

<div class="panel panel-default">
    <p class="panel-heading">
        <h4 class="panel-title">Вёрстка</h4>
    </p>
 <div class="panel-body">
  <pre><code class="html">&lt;img ng-src="{$ item.logo200x200 $}" ng-model="logo" ngf-select ngf-change="uploadLogo(files)" accept="image/*" /&gt;</code></pre>
 </div>
</div>

<p>Да, всего одна строка. Вы можете поместить указанное изображение в любой подходящий контейнер, например, панель из <a href="http://getbootstrap.com/components/#panels">Twitter Bootstrap</a>.</p>

<p><b>Что делает этот код:</b></p>

<table class="table table-bordered table-responsive table-striped">
 <thead>
  <tr>
   <th>Параметр</th>
   <th>Описание</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code class="html">ng-src="{$ item.logo200x200 $}"</code></td>
   <td>Связываем свойство модели и источник для нашего изображения. Делается через директиву Angular <a href="https://docs.angularjs.org/api/ng/directive/ngSrc">ng-src</a>, как того советует официальная документация. На скобки в виде '{$' и '$}' не обращайте внимания. Т.к. на сервере используется стандартный шаблонизатор Django, приходится для Angular использовать другие скобки.</td>
  </tr>
  <tr>
   <td><code class="html">ng-model="logo"</code></td>
   <td>Для выбора файлов будет использоваться отдельная модель - <b>logo</b></td>
  </tr>
  <tr>
   <td><code class="html">ngf-select</code></td>
   <td>Указываем, что данное изображение (можно использовать вообще-то что угодно) является полем ввода для плагина <b>ngFileUpload</b></td>
  </tr>
  <tr>
   <td><code class="html">ngf-change="uploadLogo(files)"</code></td>
   <td>При изменении значения поля выполняем указанную функцию. Загрузка без нажатия кнопки "Загрузить", в общем, достаточно лишь выбрать файл.</td>
  </tr>
  <tr>
   <td><code class="html">accept="image/*"</code></td>
   <td>Разрешаем выбирать любые изображения. Фильтр для окна выбора файла.</td>
  </tr>
 </tbody>
</table>

<p>После того, как будет произведён клик по указанному изображению, откроется обычное окно открытия файла. Когда же файл будет выбран, запустится функция загрузки изображения:</p>

<div class="panel panel-default">
    <p class="panel-heading">
        <h4 class="panel-title">LogoController.js</h4>
    </p>
    <div class="panel-body">
  <pre><code class="javascript">$scope.uploadLogo = function() {
    if ($scope.logo.length </code></pre>  
 </div>
</div>

<p>Я описал лишь одну функцию контроллера. Надеюсь, догадаться, что нужно инжектировать <code>$scope</code> и <code>Upload</code>, не сложно.</p>

<p class="alert alert-warning">Обратите внимание, для загрузки логотипа используется метод <b>PATCH</b>, а файл логотипа помещяется в объект <code>file</code> - потом именно его будем обрабатывать на сервере.</p>

<h3>Бэк-энд</h3>

<p>Нам понадобятся модель, отдельный сериализатор для логотипов и отдельное представление. Так же размеры всех логотипов следует нормализовать - не более 200px по большей стороне. Для этого можно написать отдельную функцию - <code>resize_logo()</code>, принимающую как аргумент экземпляр нашей модели.</p>

<div class="panel panel-default">
    <p class="panel-heading">
        <h4 class="panel-title">core.helpers.py</h4>
    </p>
 <div class="panel-body">
  <pre><code class="python">from PIL import Image

MAX_THUMBNAIL_SIZE = 200

def resize_logo(instance):
    """
    Resize model logo to needed sizes.
    """
    width = instance.logo.width
    height = instance.logo.height

    filename = instance.logo.path

    max_size = max(width, height)

    if max_size &gt; MAX_THUMBNAIL_SIZE:  # Да, надо изменять размер
        image = Image.open(filename)
        image = image.resize(
            (round(width / max_size * MAX_THUMBNAIL_SIZE),
             round(height / max_size * MAX_THUMBNAIL_SIZE)),
            Image.ANTIALIAS
        )
        image.save(filename)</code></pre>
 </div>
</div>

<p>Пришло время описать саму модель, переопределив её метод <code>save()</code> таким образом, чтобы при сохранении размеры изображения для логотипа нормализовались, как нам нужно:</p>

<div class="panel panel-default">
    <p class="panel-heading">
        <h4 class="panel-title">core.items.models.py</h4>
    </p>
 <div class="panel-body">
  <pre><code class="python">from os import path

from django.db import models

from core.helpers import resize_logo

class ItemModel(models.Model):

    name = models.CharField(
        "Название",
        max_length=255,
        help_text='Максимум 255 знаков',
        null=False,
        blank=False
    )
    logo = models.ImageField(
        "Логотип",
        upload_to=path.join('item', 'logo'), # Отдельный каталог для аватаров
        null=True,
        blank=True,
    )

    def save(self, *args, **kwargs):
        # Сначала модель нужно сохранить, иначе изменять/обновлять будет нечего
        super(ItemModel, self).save(*args, **kwargs)

        # Приводит размеры лого к одному виду - 200px по наибольшей стороне
        if self.logo:
            resize_logo(self)

    class Meta:
        app_label = 'core'
        db_table = 'item'
        verbose_name = 'элемент'
        verbose_name_plural = 'элементы'</code></pre>
 </div>
</div>

<p>Теперь можно описать части, относящиеся к API - сериализатор, представление и часть конфигурации URL.</p>

<div class="panel panel-default">
    <p class="panel-heading">
        <h4 class="panel-title">api.items.serializers.py</h4>
    </p>
 <div class="panel-body">
  <pre><code class="python">from rest_framework import serializers

from core.items.models import ItemModel

# Тут должны быть описаны остальные сериализаторы, сейчас же опускаю для краткости


class ItemLogoSerializer(serializers.ModelSerializer):

    class Meta:
        model = ItemModel</code></pre>
 </div>
</div>

<p>Как видно, сериализатор крайне прост. Опишем наше представление.</p>

<div class="panel panel-default">
    <p class="panel-heading">
        <h4 class="panel-title">api.items.api.py</h4>
    </p>
 <div class="panel-body">
  <pre><code class="python">from rest_framework import permissions
from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView

from core.items.models import ItemModel

from .serializers import ItemLogoSerializer


class ItemLogoAPIView(APIView):

    permission_classes = [
        permissions.IsAdminUser,
    ]

    serializer_class = ItemLogoSerializer

    # Обновление модели - методом PATCH, как я уже писал выше
    def patch(self, *args, **kwargs):

        # Находим нужную модель (по-хорошему надо обернуть в try ... except, но
        # сейчас я этого делать не буду, чтобы не загромождать код)
        instance = ItemModel.objects.get(pk=kwargs.get('pk'))

        # Получаем из запроса наш файл (как указали выше, в JS)
        instance.logo = self.request.FILES['file']

        # Сохраняем запись (тут должна быть проверка значений встроенными в DRF
        # методами, но сейчас я этого делать не буду)
        instance.save()

        # Возвращаем ответ - нашу сериализованную модель и статус 200
        return Response(
            ItemLogoSerializer(instance).data,
            status=status.HTTP_200_OK
        )</code></pre>
 </div>
</div>

<p class="alert alert-danger">Обязательно проверяйте, что именно приходит от клиента, иначе будут проблемы. Так же добавьте нужные права в <code>permission_classes</code>.</p>

<p>Теперь - самое простое - конфигурация URL:</p>

<div class="panel panel-default">
    <p class="panel-heading">
        <h4 class="panel-title">api.items.urls.py</h4>
    </p>
    <div class="panel-body">
        <pre><code class="python">from django.conf.urls import url

# Тут должен быть импорт остальных сериализаторов
from .api import ItemLogoAPIView

urlpatterns = [
    # А здесь должны быть остальные URL (создание/получение/обнавление)
    url(r'^(?P<pk>\d+)/logo/$', ServiceLogoAPIView.as_view()),
]</pk></code></pre>
    </div>
</div>

<p>Ну что ж, всё выглядит не таким уж сложным. Пришло время закрыть вопросы на Toster'е и StackOverflow.</p>



<p class="clear"/>

</div>
</div></body></html>