<html><body><div><article class="markdown-body entry-content" itemprop="text"><h2><a id="user-content-shablona" class="anchor" href="#shablona" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>shablona</h2>

<p><a href="https://travis-ci.org/uwescience/shablona"><img src="https://camo.githubusercontent.com/8911aa5f74430c25587ff4ee1252a5c727dc6aa4/68747470733a2f2f7472617669732d63692e6f72672f757765736369656e63652f736861626c6f6e612e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/uwescience/shablona.svg?branch=master"/></a></p>

<p>Shablona is a template project for small scientific python projects. The
recommendations we make here follow the standards and conventions of much of
the scientific Python eco-system. Following these standards and recommendations
will make it easier for others to use your code, and can make it easier for you
to port your code into other projects and collaborate with other users of this
eco-system.</p>

<p>To use it as a template for your own project, you will need to clone this
repository into your computer and follow the instructions at the <a href="#using-shablona-as-a-template">bottom of this page</a>.</p>

<p>First, let me explain all the different moving parts that make up a small
scientific python project, and all the elements which allow us to effectively
share it with others, test it, document it, and track its evolution.</p>

<h3><a id="user-content-organization-of-the--project" class="anchor" href="#organization-of-the--project" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Organization of the  project</h3>

<p>The project has the following structure:</p>

<pre><code>shablona -
          |- `README.md`
          |- shablona
                |- `__init__.py`
                |- `shablona.py`
                |- data
                    |- ...
                |- tests
                    |- ...
          |- doc
                |- `Makefile`
                |- `conf.py`
                |- sphinxext
                    |- ...
                |- _static
                    |- ...
          |- `setup.py`
          |- `.travis.yml`
          |- `appveyor.yml`
          |- `LICENSE`
          |- ipynb
                |- ...
</code></pre>

<p>In the following sections we will examine these elements one by one. First,
let's consider the core of the project. This is the code inside of
<code>shablona/shablona.py</code>. This code provided in this file is intentionally rather
simple. It implements some simple curve-fitting to data from a psychophysical
experiment. It's not too important to know what it does, but if you are really
interested, you can read all about it
<a href="/uwescience/shablona/blob/master/http/arokem.github.io/2014-08-12-learn-optimization.html">here</a>.</p>

<h3><a id="user-content-module-code" class="anchor" href="#module-code" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Module code</h3>

<p>We place the module code in a file called <code>shablona.py</code> in directory called
<code>shablona</code>. This structure is a bit confusing at first, but it is a simple way
to create a structure where when we type <code>import shablona as sb</code> in an
interactive Python session, the classes and functions defined inside of the
<code>shablona.py</code> file are available in the <code>sb</code> namespace. For this to work, we
need to also create a file in <code>__init__.py</code> which contains code that imports
everything in that file into the namespace of the project:</p>

<pre><code>from .shablona import *
</code></pre>

<p>In the module code, we follow the convention that a function is defined in
lines that precede the lines that use that function. This helps readability of
the code, because you know that if you see some name, the definition of that
name will appear earlier in the file, either as a function/variable definition,
or as an import from some other module or package.</p>

<p>In the case of the shablona module, the main classes defined at the bottom of
the file make use of some of the functions defined in preceding lines.</p>

<p>Remember that code will be probably be read more times than it will be written.
Make it easy to read (for others, but also for yourself when you come back to
it), by following a consistent formatting style. We strongly recommend
following the <a href="https://www.python.org/dev/peps/pep-0008/">PEP8 code formatting standard</a>.</p>

<h3><a id="user-content-project-data" class="anchor" href="#project-data" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Project Data</h3>

<p>In this case, the project data is rather small, and recorded in csv files. Thus, it can be stored alongside the module code. Even if the data that you are analyzing is too large, and cannot be effectively tracked with github, you might still want to store some data for testing purposes.</p>

<p>Either way, you can create a <code>shablona/data</code> folder in which you can organize the data. As you can see in the test scripts, and in the analysis scripts, this provides a standard file-system location for the data at:</p>

<pre><code>import os.path as op
  import shablona as sb
  data_path = op.join(sb.__path__[0], 'data')
</code></pre>

<h3><a id="user-content-testing" class="anchor" href="#testing" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Testing</h3>

<p>Most scientists who write software constantly test their code. That is, if you
are a scientist writing software, I am sure that you have tried to see how well
your code works by running every new function you write, examining the inputs
and the outputs of the function, to see if the code runs properly (without
error), and to see whether the results make sense.</p>

<p>Automated code testing takes this informal practice, makes it formal, and
automates it, so that you can make sure that your code does what it is supposed
to do, even as you go about making changes around it.</p>

<p>Most scientists writing code are not really in a position to write a complete
<a href="http://www.wired.com/2013/01/code-bugs-programming-why-we-need-specs/">specification</a>
of their software, because when they start writing their code they don't quite
know what they will discover in their data, and these chance discoveries might
affect how the software evolves. Nor do most scientists have the inclination to
write complete specs - scientific code often needs to be good enough to cover
our use-case, and not any possible use-case. Testing the code serves as a way to
provide a reader of the code with very rough specification, in the sense that it
at least specifies certain input/output relationships that will certainly hold
in your code.</p>

<p>We recommend using the <a href="http://nose.readthedocs.org/">'Nose'</a> library for
testing. The <code>nosetests</code> application traverses the directory tree in which it is
issued, looking for files with the names that match the pattern <code>test_*.py</code>
(typically, something like our <code>shablona/tests/test_shablona.py</code>). Within each
of these files, it looks for functions with names that match the pattern
<code>test_*</code>. Typically each function in the module would have a corresponding test
(e.g. <code>test_transform_data</code>). This is sometimes called 'unit testing', becasue
it independently tests each atomic unit in the software. Other tests might run a
more elaborate sequence of functions ('end-to-end testing' if you run through
the entire analysis), and check that particular values in the code evaluate to
the same values over time. This is sometimes called 'regression testing'. We
have one such test in <code>shablona/tests/test_shablona.py</code> called
<code>test_params_regression</code>. Regressions in the code are often canaries in the coal
mine, telling you that you need to examine changes in your software
dependencies, the platform on which you are running your software, etc.</p>

<p>Test functions should contain assertion statements that check certain relations
in the code. Most typically, they will test for equality between an explicit
calculation of some kind and a return of some function. For example, in the
<code>test_cumgauss</code> function, we test that our implmentation of the cumulative
Gaussian function evaluates at the mean minus 1 standard deviation to
approximately (1-0.68)/2, which is the theoretical value this calculation should
have. We recommend using functions from the <code>numpy.testing</code> module (which we
import as <code>npt</code>) to assert certain relations on arrays and floating point
numbers. This is because <code>npt</code> contains functions that are specialized for
handling <code>numpy</code> arrays, and they allow to specify the tolerance of the
comparison through the <code>decimal</code> key-word argument.</p>

<p>To run the tests on the command line, change your present working directory to
the top-level directory of the repository (e.g. <code>/Users/arokem/code/shablona</code>),
and type:</p>

<pre><code>nosetests
</code></pre>

<p>This will exercise all of the tests in your code directory. If a test fails, you
will see a message such as:</p>

<pre><code>.F...
======================================================================
FAIL: shablona.tests.test_shablona.test_cum_gauss
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/arokem/anaconda/lib/python3.4/site-packages/nose/case.py", line 198, in runTest
    self.test(*self.arg)
  File "/Users/arokem/source/shablona/shablona/tests/test_shablona.py", line 49, in test_cum_gauss
    npt.assert_almost_equal(y[0], (1 - 0.68) / 2, decimal = 3)
  File "/Users/arokem/anaconda/lib/python3.4/site-packages/numpy/testing/utils.py", line 490, in assert_almost_equal
    raise AssertionError(_build_err_msg())
AssertionError:
Arrays are not almost equal to 3 decimals
 ACTUAL: 0.15865525393145707
 DESIRED: 0.15999999999999998

----------------------------------------------------------------------
Ran 5 tests in 0.395s
</code></pre>

<p>This indicates to you that a test has failed. In this case, the calculationg is
accurate up to 2 decimal places, but not beyond, so the <code>decimal</code> key-word
argument needs to be adjusted (or the calculation needs to be made more
accurate).</p>

<p>As your code grows and becomes more complicated, you might develop new features
that interact with your old features in all kinds of unexpected and surprising
ways. As you develop new features of your code, keep running the tests, to make
sure that you haven't broken the old features.  Keep writing new tests for your
new code, and recording these tests in your testing scripts. That way, you can
be confident that even as the software grows, it still keeps doing correctly at
least the few things that are codified in the tests.</p>

<h3><a id="user-content-styling" class="anchor" href="#styling" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Styling</h3>

<p>It is a good idea to follow the PEP8 standard for code formatting. Common code
formatting makes code more readable, and using tools such as <code>flake8</code> (which
combines the tools <code>pep8</code> and <code>pyflakes</code>) can help make your code more readable,
avoid extraneous imports and lines of code, and overall keep a clean project
code-base.</p>

<p>Some projects include <code>flake8</code> inside their automated tests, so that every pull
request is examined for code cleanliness.</p>

<p>In this project, we have run <code>flake8</code> most (but not all) files, on most (but not all) checks:</p>

<pre><code>flake8 --ignore N802,N806 `find . -name *.py | grep -v setup.py | grep -v /doc/`
</code></pre>

<p>This means, check all .py files, but exclude setup.py and everything in
directories named "doc". Do all checks except N802 and N806, which enforce
lowercase-only names for variables and functions.</p>

<h3><a id="user-content-documentation" class="anchor" href="#documentation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Documentation</h3>

<p>Documenting your software is a good idea. Not only as a way to communicate to
others about how to use the software, but also as a way of reminding yourself
what the issues are that you faced, and how you dealt with them, in a few
months/years, when you return to look at the code.</p>

<p>The first step in this direction is to document every function in your module
code. We recommend following the <a href="https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt">numpy docstring
standard</a>,
which specifies in detail the inputs/outputs of every function, and specifies
how to document additional details, such as references to scientific articles,
notes about the mathematics behind the implementation, etc.</p>

<p>This standard also plays well with a system that allows you to create more
comprehensive documentation of your project. Writing such documentation allows
you to provide more elaborate explanations of the decisions you made when you
were developing the software, as well as provide some examples of usage,
explanations of the relevant scientific concepts, and references to the relevant
literature.</p>

<p>To document <code>shablona</code> we use the <a href="http://sphinx-doc.org/">sphinx documentation
system</a>. You can follow the instructions on the sphinx
website, and the example <a href="http://matplotlib.org/sampledoc/">here</a> to set up the
system, but we have also already initialized and commited a skeleton
documentation system in the <code>docs</code> directory, that you can build upon.</p>

<p>Sphinx uses a <code>Makefile</code> to build different outputs of your documentation. For
example, if you want to generate the HTML rendering of the documentation (web
pages that you can upload to a website to explain the software), you will type:</p>

<pre><code>make html
</code></pre>

<p>This will generate a set of static webpages in the <code>doc/_build/html</code>, which you can then upload to a website of your choice.</p>

<p>Alternatively, <a href="https://readthedocs.org">readthedocs.org</a> (careful, <em>not</em> readthedocs.<strong>com</strong>) is a service that will run sphinx for you, and upload the documentation to their website. To use this service, you will need to register with RTD. After you have done that, you will need to "import your project" from your github account, through the RTD web interface. To make things run smoothly, you also will need to go to the "admin" panel of the project on RTD, and navigate into the "advanced settings" so that you can tell it that your Python configuration file is in <code>doc/conf.py</code>:</p>

<p><a href="https://github.com/uwescience/shablona/blob/master/doc/_static/RTD-advanced-conf.png" target="_blank"><img src="https://github.com/uwescience/shablona/raw/master/doc/_static/RTD-advanced-conf.png" alt="RTD conf"/></a></p>

<p><a href="http://shablona.readthedocs.org/en/latest/">http://shablona.readthedocs.org/en/latest/</a></p>

<h3><a id="user-content-installation" class="anchor" href="#installation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Installation</h3>

<p>For installation and distribution we will use the python standard library <code>distutils</code> module. This module uses a <code>setup.py</code> file to figure out how to install your software on a particular system. For a small project such as this one, managing installation of the software modules and the data is rather simple.</p>

<p>A <code>shablona/version.py</code> contains all of the information needed for the installation and for setting up the <a href="https://pypi.python.org/pypi/shablona">PyPI page</a> for the software. This also makes it possible to install your software with using <code>pip</code> and <code>easy_install</code>, which are package managers for Python software. The <code>setup.py</code> file reads this information from there and passes it to the <code>setup</code> function which takes care of the rest.</p>

<p>Much more information on packaging Python software can be found in the <a href="https://the-hitchhikers-guide-to-packaging.readthedocs.org">Hitchhiker's guide to packaging</a>.</p>

<h3><a id="user-content-continuous-integration" class="anchor" href="#continuous-integration" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Continuous integration</h3>

<p>Travis-CI is a system that can be used to automatically test every revision of
your code directly from github, including testing of github pull requests,
before they are merged into the <code>master</code> branch. This provides you with
information needed in order to evaluate contrubutions made by others. It also
serves as a source of information for others interested in using or contributing
to your project about the degree of test coverage of your project.</p>

<p>You will need a .travis.yml file in your repo. This file contains the
configuration of your testing environment. This includes the different
environments in which you will test the source code (for example, we test
<code>shablona</code> against Python 2.7, Python 3.3 and Python 3.4). It includes steps
that need to be taken before installation of the software. For example,
installation of the software dependencies. For <code>shablona</code>, we use the
<a href="http://conda.pydata.org/miniconda.html"><code>Miniconda</code></a> software distribution (not
to be confused with <a href="https://store.continuum.io/cshop/anaconda/"><code>Anaconda</code></a>,
though they are similar and both produced by Continuum).</p>

<p>For details on setting up Travis-CI with github, see Travis-CI's <a href="https://docs.travis-ci.com/user/getting-started/#To-get-started-with-Travis-CI%3A">getting started page</a>. To summarize:</p>

<p>First, go to the Travis-CI <a href="https://travis-ci.org/">website</a> and get a Travis user account, linked to your github user account.</p>

<p>You will need to set up your github repo to talk to Travis (More explanation +
pictures will come here).</p>

<p>You will need to go back to travis-ci, and flip on the switch on that side as
well.</p>

<p>The travis output will also report to you about test coverage, if you set it up
that way.</p>

<p>You will start getting emails telling you the state of the testing suite on
every pull request for the software, and also when you break the test suite on
the <code>master</code> branch. That way, you can be pretty sure that the <code>master</code> is
working (or at least know when it isn't...).</p>

<p>You can also continuously test your code on a Windows system. This is done on
another CI system called <a href="http://www.appveyor.com/">Appveyor</a>. In prinicple, it
does something that is very similar to what Travis does: downloads your code,
installs it on a Windows machine, with various versions of python, and runs the
tests. Appveyor is controlled through another configuration file: the
<code>appveyor.yml</code>. In addition to committing this file into the repository, you
will need to activate Appveyor for your project. This is done by signing into
the Appveyor interface with your Github account, clicking on the "projects" tab
at the top of the page, then clicking on the "+" sign for "New project" and
selecting the project you would like to add from the menu that appears (you
might need to give Appveyor the permission to see projects in your Github
account).</p>

<h3><a id="user-content-distribution" class="anchor" href="#distribution" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Distribution</h3>

<p>The main venue for distribution of Python software is the <a href="https://pypi.python.org/">Python Package Index</a>, or PyPI, also lovingly known as "the cheese-shop".</p>

<p>To distribute your software on PyPI, you will need to create a user account on PyPI. You can upload your software using <code>python setup.py upload</code>.</p>

<p>Using Travis, you can automatically upload your software to PyPI, every time you push a tag of your software to github. The instructions on setting this up can be found <a href="http://docs.travis-ci.com/user/deployment/pypi/">here</a>. You will need to install the travis command-line interface</p>

<h3><a id="user-content-licensing" class="anchor" href="#licensing" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Licensing</h3>

<p>License your code! A repository like this without a license maintains copyright to the author, but does not provide others with any conditions under which they can use the software. In this case, we use the MIT license. You can read the conditions of the license in the <code>LICENSE</code> file. As you can see, this is not an Apple software license agreement (has anyone ever actually tried to read one of those?). It's actually all quite simple, and boils down to "You can do whatever you want with my software, but I take no responsibility for what you do with my software"</p>

<p>For more details on what you need to think about when considering choosing a license, see this <a href="http://www.astrobetter.com/blog/2014/03/10/the-whys-and-hows-of-licensing-scientific-code/">article</a>!</p>

<h3><a id="user-content-scripts" class="anchor" href="#scripts" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Scripts</h3>

<p>A scripts directory can be used as a place to experiment with your module code, and as a place to produce scripts that contain a narrative structure, demonstrating the use of the code, or producing scientific results from your code and your data and telling a story with these elements.</p>

<p>For example, this repository contains an [IPython notebook] that reads in some data, and creates a figure. Maybe this is <em>Figure 1</em> from some future article? You can see this notebook fully rendered <a href="https://github.com/uwescience/shablona/blob/master/scripts/Figure1.ipynb">here</a>.</p>

<h3><a id="user-content-using-shablona-as-a-template" class="anchor" href="#using-shablona-as-a-template" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Using <code>shablona</code> as a template</h3>

<p>Let's assume that you want to create a small scientific Python project called <code>smallish</code>. Maybe you already have some code that you are interested in plugging into the module file, and some ideas about what the tests might look like.</p>

<p>To use this repository as a template, start by cloning it to your own computer under the name you will want your project to have:</p>

<pre><code>git clone https://github.com/uwescience/shablona smallish
cd smallish
</code></pre>

<p>To point to your own repository on github you will have to issue something like the following:</p>

<pre><code>git remote rm origin
git remote add origin https://github.com/arokem/smallish
</code></pre>

<p>(replace <code>arokem</code> with your own Github user name).</p>

<p>Next, you will want to move <code>shablona/shablona.py</code> to be called <code>smallish/smallish.py</code></p>

<pre><code>git mv shablona smallish
git mv smallish/shablona.py smallish/smallish.py
git mv smallish/tests/test_shablona.py smallish/tests/test_smallish.py
</code></pre>

<p>Make a commit recording these changes. Something like:</p>

<pre><code>git commit -a -m"Moved names from `shablona` to `smallish`"
</code></pre>

<p>You will probably want to remove all the example data:</p>

<pre><code>git rm smallish/data/*
git commit -a -m"Removed example `shablona` data"
</code></pre>

<p>Possibly, you will want to add some of your own data in there.</p>

<p>You will want to edit a few more places that still have <code>shablona</code> in them. Type
the following to see where all these files are:</p>

<pre><code>git grep shablona
</code></pre>

<p>This very file (README.md) should be edited to reflect what your project is
about.</p>

<p>Other places that contain this name include the <code>doc/conf.py</code> file, which
configures the sphinx documentation, as well as the <code>doc/Makefile</code> file (edit
carefully!), and the <code>doc/index.rst</code> file.</p>

<p>The <code>.coveragerc</code> file contains a few mentions of that name, as well as the
<code>.travis.yml</code> file. This one will also have to be edited to reflect your PyPI
credentials (see <a href="###%20Distribution">above</a>).</p>

<p>Edit all the mentions of <code>shablona</code> in the <code>shablona/__init__.py</code> file, and in
the <code>shablona/version.py</code> file as well.</p>

<p>Finally, you will probably want to change the copyright holder in the <code>LICENSE</code>
file to be you. You can also replace the text of that file, if it doesn't match
your needs.</p>

<p>At this point, make another commit, and continue to develop your own code based
on this template.</p>
</article>
  </div></body></html>