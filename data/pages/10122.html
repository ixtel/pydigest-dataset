<html><body><div><div id="goal">
<h3>Goal</h3>
<p>This package implements a framework for <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" rel="nofollow">functional reactive
programming</a>
which wants to be simple to use and extend without imposing complex
concepts of streams, channels and so on that are typical of <em>dataflow
programming</em>.</p>
<p>To explain reactive programming just think about a spreadsheet where
you have a value cell and a formula cell. The latter updates
automatically just when it’s  appropriate.</p>
<p>This package implement just that. No, wait, not a spreadsheet, but a
way to express that a block of code (a function) that creates a result
(a calculated value) or a <em>side effect</em> depends on some other value
so that when the value changes, the block of code is automatically
re-run.</p>
<p>It has been inspired by Javascript <a href="https://github.com/meteor/meteor/tree/devel/packages/tracker" rel="nofollow">meteor’s “tracker” package</a> but
it diverges from in order to be more pythonic.</p>
</div>
<div id="usage">
<h3>Usage</h3>
<p>Let’s see a small example:</p>
<pre><span class="n">cur_temp_fahrenheit</span> <span class="o">=</span> <span class="mi">40</span>

<span class="k">def</span> <span class="nf">cur_temp_celsius</span><span class="p">(</span><span class="n">t_fahrenheit</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">t_fahrenheit</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.8</span>

<span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">log_temp_celsius</span><span class="p">():</span>
    <span class="n">log</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_temp_celsius</span><span class="p">(</span><span class="n">cur_temp_fahrenheit</span><span class="p">))</span>

<span class="n">log_temp_celsius</span><span class="p">()</span>

<span class="k">assert</span> <span class="n">log</span> <span class="o">==</span> <span class="p">[</span><span class="mf">4.444444444444445</span><span class="p">]</span>
</pre>
<p>This is a small piece of code with a function that converts Fahrenheit
degrees to Celsius and then logs them to a list, but you can think of
it as any kind of side effect.</p>
<p>Now, we suppose that <tt>cur_temp_fahrenheit</tt> changes and we want to
log it whenever it does so.</p>
<p>To do that we need to trasform <tt>cur_temp_fahrenheit</tt> into a
<em>reactive</em> value and have the <em>tracker</em> track the dependencies between
that value and the <em>computation</em> that uses it. This way, when the
value is changed, our <tt>log_temp_celsius()</tt> can be re-run and it will
do its work. So we change the code a bit mostly by using a getter and
a setter to change the temp variable and add some code  when
this happens and then instruct the <em>tracker</em> to run the log
function so that it knows what to re-run. Let’s see:</p>
<pre><span class="kn">from</span> <span class="nn">metapensiero</span> <span class="kn">import</span> <span class="n">reactive</span>

<span class="n">tracker</span> <span class="o">=</span> <span class="n">reactive</span><span class="o">.</span><span class="n">get_tracker</span><span class="p">()</span>
<span class="n">dep</span> <span class="o">=</span> <span class="n">tracker</span><span class="o">.</span><span class="n">dependency</span><span class="p">()</span>

<span class="c1"># this is just to handle setting a global var</span>
<span class="n">cur_temp_fahrenheit</span> <span class="o">=</span> <span class="p">[</span><span class="mi">40</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">get_temp_f</span><span class="p">():</span>
    <span class="n">dep</span><span class="o">.</span><span class="n">depend</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">cur_temp_fahrenheit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">set_temp_f</span><span class="p">(</span><span class="n">new</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">new</span> <span class="o">!=</span> <span class="n">cur_temp_fahrenheit</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">dep</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span>
    <span class="n">cur_temp_fahrenheit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span>

<span class="k">def</span> <span class="nf">cur_temp_celsius</span><span class="p">(</span><span class="n">t_fahrenheit</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">t_fahrenheit</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.8</span>

<span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">log_temp_celsius</span><span class="p">(</span><span class="n">handle</span><span class="p">):</span>
    <span class="n">log</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_temp_celsius</span><span class="p">(</span><span class="n">get_temp_f</span><span class="p">()))</span>

<span class="n">handle</span> <span class="o">=</span> <span class="n">tracker</span><span class="o">.</span><span class="n">reactive</span><span class="p">(</span><span class="n">log_temp_celsius</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">log</span> <span class="o">==</span> <span class="p">[</span><span class="mf">4.444444444444445</span><span class="p">]</span>

<span class="n">set_temp_f</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">log</span> <span class="o">==</span> <span class="p">[</span><span class="mf">4.444444444444445</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">cur_temp_fahrenheit</span> <span class="o">==</span> <span class="mi">50</span>

<span class="n">handle</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">set_temp_f</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">log</span> <span class="o">==</span> <span class="p">[</span><span class="mf">4.444444444444445</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">cur_temp_fahrenheit</span> <span class="o">==</span> <span class="mi">60</span>
</pre>
<p>As you can see, when we set the current temperature to a new
value, <tt>log_temp_celsius</tt> is re-run and a new entry is added to the
<tt>log</tt> list. we can still use the function(s) without using the
tracker, in which case we will have the default, normal, non-reactive
behavior. When we use <tt>tracker.reactive()</tt> all the defined
dependencies on reactive-aware data sources are tracked by running
the given function immediately. Next, when the reactive source
changes, the tracker re-executes the function, thus re-tracking the
dependencies that may be different. <tt>tracker.reactive()</tt> returns an
handle, a <tt>Computation</tt> object that can be used to stop the
reactive behavior when it’s no more necessary. The same object is
given as parameter to the tracked function.</p>
<p>The example proposed is indeed silly, but shows you the power of the
framework:</p>
<ul>
<li>code changes are minimal;</li>
<li>the new concepts to learn are very few and simple;</li>
<li>the reactive functions can be run alone without tracker involvement
and they will run as normal code, without the need to refactor them.</li>
</ul>
<p>Tracked functions can use <tt>tracker.reactive()</tt> themselves, in which
case the inner trackings will be stopped when the outer is re-run.</p>
<p>The code above is a bit ugly due to the usage of the getter and
setter, how can we avoid that? Here is the same example using the
<tt>Value</tt> class:</p>
<pre><span class="kn">from</span> <span class="nn">metapensiero</span> <span class="kn">import</span> <span class="n">reactive</span>

<span class="n">tracker</span> <span class="o">=</span> <span class="n">reactive</span><span class="o">.</span><span class="n">get_tracker</span><span class="p">()</span>
<span class="n">cur_temp_fahrenheit</span> <span class="o">=</span> <span class="n">reactive</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cur_temp_celsius</span><span class="p">(</span><span class="n">t_fahrenheit</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">t_fahrenheit</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.8</span>

<span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">log_temp_celsius</span><span class="p">(</span><span class="n">handle</span><span class="p">):</span>
    <span class="n">log</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_temp_celsius</span><span class="p">(</span><span class="n">cur_temp_fahrenheit</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>

<span class="n">handle</span> <span class="o">=</span> <span class="n">tracker</span><span class="o">.</span><span class="n">reactive</span><span class="p">(</span><span class="n">log_temp_celsius</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">log</span> <span class="o">==</span> <span class="p">[</span><span class="mf">4.444444444444445</span><span class="p">]</span>

<span class="n">cur_temp_fahrenheit</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">50</span>

<span class="k">assert</span> <span class="n">log</span> <span class="o">==</span> <span class="p">[</span><span class="mf">4.444444444444445</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]</span>

<span class="n">handle</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">cur_temp_fahrenheit</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">60</span>
<span class="k">assert</span> <span class="n">log</span> <span class="o">==</span> <span class="p">[</span><span class="mf">4.444444444444445</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]</span>
</pre>
<p><tt>Value</tt> class can be used also be used as a method decorator in a
way similar to the builtin <tt>property</tt> decorator but with only a
<em>getter</em> function.</p>
<p>Another way to use the Value class is just as a value container, by
using its <tt>value</tt> to get or set the value, or just as any other data
member in a class body.</p>
<pre><span class="n">a</span> <span class="o">=</span> <span class="n">Value</span><span class="p">()</span>

<span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">True</span>
<span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">True</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">bar</span> <span class="o">=</span> <span class="n">Value</span><span class="p">()</span>

    <span class="nd">@Value</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">zoo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># ... calc something useful</span>



<span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="bp">True</span>

<span class="k">assert</span> <span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="o">==</span> <span class="bp">True</span>

<span class="n">animal</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">zoo</span>
</pre>
<p>When used in class’ body a <tt>Value</tt> saves a triplet of <tt>(Dependency,
Computation, value)</tt> per instance so you have to take that into
account. <tt>Value</tt> uses weak references in order to avoid keeping
instances alive.</p>
<p>There is also a constructor to build reactive
<a href="https://pypi.python.org/pypi/namedlist" rel="nofollow">namedlist</a> classes.</p>
<p>The framework is also compatible with <tt>gevent</tt> and <tt>asyncio</tt> in
order to batch computation’s recalculation in another <tt>Greenlet</tt> or
<tt>Task</tt>, respectively. As all the <em>invalidated</em> calculations are
recomputed sequentially, it’s important to avoid having <em>suspension
points</em> in the reactive code, like calls to <tt>sleep()</tt> functions or
the execution of <tt>yield from</tt> and <tt>await</tt> statements. If this is
unavoidable, a <em>manual</em> suspension context manager is avaliable in
computations, named <tt>suspend()</tt>. Using that, the block of code
inside a <em>with</em> statement runs isolated, and tracking is reinstated
afterwards.</p>
<p>For all those features, please have a look at code and tests for now.</p>
</div>
</div></body></html>