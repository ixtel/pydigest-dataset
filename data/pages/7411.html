<html><body><div><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-sops-secrets-operations" class="anchor" href="#sops-secrets-operations" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>SOPS: Secrets OPerationS</h1>
<p><strong>sop</strong> is an editor of encrypted files that supports YAML, JSON and BINARY formats and encrypts with AWS KMS and PGP (via GnuPG). Watch <a href="https://www.youtube.com/watch?v=YTEVyLXFiq0">the demo</a>.</p>
<a href="https://camo.githubusercontent.com/24f35da2fda8707eaa84e187377a4ac114ae24c3/687474703a2f2f692e696d6775722e636f6d2f494c36646c686d2e676966" target="_blank"><img alt="http://i.imgur.com/IL6dlhm.gif" src="https://camo.githubusercontent.com/24f35da2fda8707eaa84e187377a4ac114ae24c3/687474703a2f2f692e696d6775722e636f6d2f494c36646c686d2e676966" data-canonical-src="http://i.imgur.com/IL6dlhm.gif"/></a>
<a href="https://travis-ci.org/mozilla/sops"><img alt="https://travis-ci.org/mozilla/sops.svg?branch=master" src="https://camo.githubusercontent.com/2751e44b44e639edad1c1f818bdbc04d022c9ed5/68747470733a2f2f7472617669732d63692e6f72672f6d6f7a696c6c612f736f70732e7376673f6272616e63683d6d6173746572" data-canonical-src="https://travis-ci.org/mozilla/sops.svg?branch=master"/></a>

<a name="user-content-up-and-running-in-60-seconds"/>

<p>First install some libraries from your package manager:</p>
<ul>
<li><p>RHEL family:</p>
<pre>sudo yum install gcc git libffi-devel libyaml-devel make openssl openssl-devel python-devel python-pip
</pre>
</li>
<li><p>Debian family:</p>
<pre>sudo apt-get install gcc git libffi-dev libssl-dev libyaml-dev make openssl python-dev python-pip
</pre>
</li>
<li><p>MacOS:</p>
<pre>brew install libffi libyaml
sudo easy_install pip

# note: on OSX El Capitan, Apple stopped shipping the OpenSSL headers
# the command below is a workaround to install the Cryptography package
env LDFLAGS="-L$(brew --prefix openssl)/lib" CFLAGS="-I$(brew --prefix openssl)/include" pip install cryptography
</pre>
</li>
</ul>
<p>Then install sops from pip:</p>
<pre>sudo pip install --upgrade sops
</pre>
<p>Clone the repository, load the test PGP key and open the test files:</p>
<pre>$ git clone https://github.com/mozilla/sops.git
$ cd sops
$ gpg --import tests/sops_functional_tests_key.asc
$ sops example.yaml
</pre>
<p>This last step will decrypt example.yaml using the test private key. To create
your own secrets files using keys under your control, keep reading.</p>
<a name="user-content-install-in-a-virtualenv"/>

<p>Assuming you already have libffi and libyaml installed, the following commands will install sops in a virtualenv:</p>
<div class="highlight highlight-source-shell"><pre>$ sudo pip install virtualenv --upgrade
$ virtualenv <span class="pl-k">~</span>/sopsvenv
$ <span class="pl-c1">source</span> <span class="pl-k">~</span>/sopsvenv/bin/activate
$ pip install -U sops
$ sops -h <span class="pl-k">|</span> grep ^Version
Version 1.0</pre></div>
<a name="user-content-usage"/>

<p>If you're using AWS KMS, create one or multiple master keys in the IAM console
and export them, comma separated, in the <strong>SOPS_KMS_ARN</strong> env variable. It is
recommended to use at least two master keys in different regions.</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-k">export</span> SOPS_KMS_ARN=<span class="pl-s"><span class="pl-pds">"</span>arn:aws:kms:us-east-1:656532927350:key/920aff2e-c5f1-4040-943a-047fa387b27e,arn:aws:kms:ap-southeast-1:656532927350:key/9006a8aa-0fa6-4c14-930e-a2dfb916de1d<span class="pl-pds">"</span></span></pre></div>
<p>Your AWS credentials must be present in ~/.aws/credentials. sops uses boto3.</p>
<pre>$ cat ~/.aws/credentials
[default]
aws_access_key_id = AKI.....
aws_secret_access_key = mw......
</pre>
<p>If you want to use PGP, export the fingerprints of the public keys, comma
separated, in the <strong>SOPS_PGP_FP</strong> env variable.</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-k">export</span> SOPS_PGP_FP=<span class="pl-s"><span class="pl-pds">"</span>85D77543B3D624B63CEA9E6DBC17301B491B3F21,E60892BB9BD89A69F759A1A0A3D652173B763E8F<span class="pl-pds">"</span></span></pre></div>
<p>Note: you can use both PGP and KMS simultaneously.</p>
<p>Then simply call sops with a file path as argument. It will handle the
encryption/decryption transparently and open the cleartext file in an editor.</p>
<div class="highlight highlight-source-shell"><pre>$ sops mynewtestfile.yaml
mynewtestfile.yaml doesn<span class="pl-s"><span class="pl-pds">'</span>t exist, creating it.</span>
<span class="pl-s">please wait while an encryption key is being generated and stored in a secure fashion</span>
<span class="pl-s">[... editing happens in vim, or whatever $EDITOR is set to ...]</span>
<span class="pl-s">file written to mynewtestfile.yaml</span></pre></div>
<p>The resulting encrypted file looks like this:</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">myapp1:</span> <span class="pl-s">ENC[AES256_GCM,data:Tr7o=,iv:1=,aad:No=,tag:k=]</span></span>
<span class="pl-s"><span class="pl-ent">app2:</span></span>
    <span class="pl-s"><span class="pl-ent">db:</span></span>
        <span class="pl-s"><span class="pl-ent">user:</span> <span class="pl-s">ENC[AES256_GCM,data:CwE4O1s=,iv:2k=,aad:o=,tag:w==]</span></span>
        <span class="pl-s"><span class="pl-ent">password:</span> <span class="pl-s">ENC[AES256_GCM,data:p673w==,iv:YY=,aad:UQ=,tag:A=]</span></span>
    <span class="pl-c"># private key for secret operations in app2</span>
<span class="pl-s">    <span class="pl-ent">key:</span> |-</span>
<span class="pl-s">        ENC[AES256_GCM,data:Ea3kL5O5U8=,iv:DM=,aad:FKA=,tag:EA==]</span>
<span class="pl-s"/><span class="pl-s"><span class="pl-ent">an_array:</span></span>
<span class="pl-s">- <span class="pl-s">ENC[AES256_GCM,data:v8jQ=,iv:HBE=,aad:21c=,tag:gA==]</span></span>
<span class="pl-s">- <span class="pl-s">ENC[AES256_GCM,data:X10=,iv:o8=,aad:CQ=,tag:Hw==]</span></span>
<span class="pl-s">- <span class="pl-s">ENC[AES256_GCM,data:KN=,iv:160=,aad:fI4=,tag:tNw==]</span></span>
<span class="pl-s"><span class="pl-ent">sops:</span></span>
    <span class="pl-s"><span class="pl-ent">kms:</span></span>
    <span class="pl-c1">-   <span class="pl-ent">created_at:</span> 1441570389.775376</span>
        <span class="pl-s"><span class="pl-ent">enc:</span> <span class="pl-s">CiC....Pm1Hm</span></span>
        <span class="pl-s"><span class="pl-ent">arn:</span> <span class="pl-s">arn:aws:kms:us-east-1:656532927350:key/920aff2e-c5f1-4040-943a-047fa387b27e</span></span>
    <span class="pl-c1">-   <span class="pl-ent">created_at:</span> 1441570391.925734</span>
        <span class="pl-s"><span class="pl-ent">enc:</span> <span class="pl-s">Ci...awNx</span></span>
        <span class="pl-s"><span class="pl-ent">arn:</span> <span class="pl-s">arn:aws:kms:ap-southeast-1:656532927350:key/9006a8aa-0fa6-4c14-930e-a2dfb916de1d</span></span>
    <span class="pl-s"><span class="pl-ent">pgp:</span></span>
    <span class="pl-s">-   <span class="pl-ent">fp:</span> <span class="pl-s">85D77543B3D624B63CEA9E6DBC17301B491B3F21</span></span>
        <span class="pl-c1"><span class="pl-ent">created_at:</span> 1441570391.930042</span>
<span class="pl-s">        <span class="pl-ent">enc:</span> |</span>
<span class="pl-s">            -----BEGIN PGP MESSAGE-----</span>
<span class="pl-s">            hQIMA0t4uZHfl9qgAQ//UvGAwGePyHuf2/zayWcloGaDs0MzI+zw6CmXvMRNPUsA</span>
<span class="pl-s">                            ...=oJgS</span>
<span class="pl-s">            -----END PGP MESSAGE-----</span></pre></div>
<p>A copy of the encryption/decryption key is stored securely in each KMS and PGP
block. As long as one of the KMS or PGP method is still usable, you will be able
to access your data.</p>
<p>To decrypt a file in a cat fashion, use the -d flag:</p>
<div class="highlight highlight-source-shell"><pre>$ sops -d mynewtestfile.yaml</pre></div>
<p>sops encrypted files contain the necessary information to decrypt their content.
All a user of sops needs is valid AWS credentials and the necessary
permissions on KMS keys.</p>
<p>Given that, the only command a sops user needs is:</p>

<p>&lt;file&gt; will be opened, decrypted, passed to a text editor (vim by default),
encrypted if modified, and saved back to its original location. All of these
steps, apart from the actual editing, are transparent to the user.</p>
<a name="user-content-adding-and-removing-keys"/>

<p>When creating new files, sops uses the PGP and KMS defined in the command
line arguments --kms and --pgp, or from the environment variables
SOPS_KMS_ARN and SOPS_PGP_FP. That information is stored in the file under
the sops section, such that decrypting files does not require providing those
parameters again.</p>
<p>Master PGP and KMS keys can be added and removed from a sops file in one of
two ways: by using command line flag, or by editing the file directly.</p>
<p>Command line flag --add-kms, --add-pgp, --rm-kms and --rm-pgp can be
used to add and remove keys from a file. These flags use the comma separated
syntax as the --kms and --pgp arguments when creating new files.</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"># add a new pgp key to the file and rotate the data key</span>
$ sops -r --add-pgp 85D77543B3D624B63CEA9E6DBC17301B491B3F21 example.yaml

<span class="pl-c"># remove a pgp key from the file and rotate the data key</span>
$ sops -r --rm-pgp 85D77543B3D624B63CEA9E6DBC17301B491B3F21 example.yaml</pre></div>
<p>Alternatively, invoking sops with the flag <strong>-s</strong> will display the master keys
while editing. This method can be used to add or remove kms or pgp keys under the
sops section.</p>
<p>For example, to add a KMS master key to a file, add the following entry while
editing:</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">sops:</span></span>
    <span class="pl-s"><span class="pl-ent">kms:</span></span>
    <span class="pl-s">- <span class="pl-ent">arn:</span> <span class="pl-s">arn:aws:kms:us-east-1:656532927350:key/920aff2e-c5f1-4040-943a-047fa387b27e</span></span></pre></div>
<p>And, similarly, to add a PGP master key, we add its fingerprint:</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">sops:</span></span>
    <span class="pl-s"><span class="pl-ent">pgp:</span></span>
    <span class="pl-s">- <span class="pl-ent">fp:</span> <span class="pl-s">85D77543B3D624B63CEA9E6DBC17301B491B3F21</span></span></pre></div>
<p>When the file is saved, sops will update its metadata and encrypt the data key
with the freshly added master keys. The removed entries are simply deleted from
the file.</p>
<p>When removing keys, it is recommended to rotate the data key using -r,
otherwise owners of the removed key may have add access to the data key in the
past.</p>
<a name="user-content-assuming-roles-and-using-kms-in-various-aws-accounts"/>

<p>SOPS has the ability to use KMS in multiple AWS accounts by assuming roles in
each account. Being able to assume roles is a nice feature of AWS that allows
administrators to establish trust relationships between accounts, typically from
the most secure account to the least secure one. In our use-case, we use roles
to indicate that a user of the Master AWS account is allowed to make use of KMS
master keys in development and staging AWS accounts. Using roles, a single file
can be encrypted with KMS keys in multiple accounts, thus increasing reliability
and ease of use.</p>
<p>You can use keys in various accounts by tying each KMS master key to a role that
the user is allowed to assume in each account. The <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html">IAM roles</a>
documentation has full details on how this needs to be configured on AWS's side.</p>
<p>From the point of view of sops, you only need to specify the role a KMS key
must assume alongside its ARN, as follows:</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">sops:</span></span>
    <span class="pl-s"><span class="pl-ent">kms:</span></span>
    <span class="pl-s">-   <span class="pl-ent">arn:</span> <span class="pl-s">arn:aws:kms:us-east-1:656532927350:key/920aff2e-c5f1-4040-943a-047fa387b27e</span></span>
        <span class="pl-s"><span class="pl-ent">role:</span> <span class="pl-s">arn:aws:iam::927034868273:role/sops-dev-xyz</span></span></pre></div>
<p>The role must have permission to call Encrypt and Decrypt using KMS. An example
policy is shown below.</p>
<div class="highlight highlight-source-json"><pre>{
  <span class="pl-s"><span class="pl-pds">"</span>Sid<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Allow use of the key<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>Effect<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Allow<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>Action<span class="pl-pds">"</span></span>: [
        <span class="pl-s"><span class="pl-pds">"</span>kms:Encrypt<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>kms:Decrypt<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>kms:ReEncrypt*<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>kms:GenerateDataKey*<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>kms:DescribeKey<span class="pl-pds">"</span></span>
  ],
  <span class="pl-s"><span class="pl-pds">"</span>Resource<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>Principal<span class="pl-pds">"</span></span>: {
        <span class="pl-s"><span class="pl-pds">"</span>AWS<span class="pl-pds">"</span></span>: [
          <span class="pl-s"><span class="pl-pds">"</span>arn:aws:iam::927034868273:role/sops-dev-xyz<span class="pl-pds">"</span></span>
        ]
  }
}</pre></div>
<p>You can specify a role in the --kms flag and SOPS_KMS_ARN variable by
appending it to the ARN of the master key, separated by a <strong>+</strong> sign:</p>
<pre>&lt;KMS ARN&gt;+&lt;ROLE ARN&gt;
arn:aws:kms:us-west-2:927034868273:key/fe86dd69-4132-404c-ab86-4269956b4500+arn:aws:iam::927034868273:role/sops-dev-xyz
</pre>
<a name="user-content-key-rotation"/>

<p>It is recommended to renew the data key on a regular basis. sops supports key
rotation via the -r flag. Invoking it on an existing file causes sops to
reencrypt the file with a new data key, which is then encrypted with the various
KMS and PGP master keys defined in the file.</p>

<a name="user-content-important-information-on-types"/>

<a name="user-content-yaml-and-json-type-extensions"/>

<p>sops uses the file extension to decide which encryption method to use on the file
content. YAML and JSON files are treated as trees of data, and key/values are
extracted from the files to only encrypt the leaf values. The tree structure is also
used to check the integrity of the file.</p>
<p>Therefore, if a file is encrypted using a specific format, it need to be decrypted
in the same format. The easiest way to achieve this is to conserve the original file
extension after encrypting a file. For example:</p>
<pre>$ sops -e -i myfile.json

$ sops -d myfile.json
</pre>
<p>If you want to change the extension of the file once encrypted, you need to provide
sops with the --input-type flag upon decryption. For example:</p>
<pre>$ sops -e myfile.json &gt; myfile.json.enc

$ sops -d --input-type json myfile.json.enc
</pre>
<a name="user-content-yaml-anchors"/>

<p>sops only supports a subset of YAML's many types. Encrypting YAML files that
contain strings, numbers and booleans will work fine, but files that contain anchors
will not work, because the anchors redefine the structure of the file at load time.</p>
<p>This file will not work in sops:</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">bill-to:</span>  <span class="pl-s">&amp;id001</span></span>
<span class="pl-s">    <span class="pl-ent">street:</span> |</span>
<span class="pl-s">        123 Tornado Alley</span>
<span class="pl-s">        Suite 16</span>
<span class="pl-s"/>    <span class="pl-s"><span class="pl-ent">city:</span>   <span class="pl-s">East Centerville</span></span>
    <span class="pl-s"><span class="pl-ent">state:</span>  <span class="pl-s">KS</span></span>

<span class="pl-s"><span class="pl-ent">ship-to:</span>  <span class="pl-s">*id001</span></span></pre></div>
<p>sops uses the path to a value as additional data in the AEAD encryption, and thus
dynamic paths generated by anchors break the authentication step.</p>
<p>JSON and TEXT file types do not support anchors and thus have no such limitation.</p>
<a name="user-content-top-level-arrays"/>

<p>YAML and JSON top-level arrays are not supported, because sops needs a top-level
sops key to store its metadata.
This file will not work in sops:</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-s">-<span class="pl-s">--</span></span>
  <span class="pl-s">- <span class="pl-s">some</span></span>
  <span class="pl-s">- <span class="pl-s">array</span></span>
  <span class="pl-s">- <span class="pl-s">elements</span></span></pre></div>
<p>But this one will because because the sops key can be added at the same level as the
data key.</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">data:</span></span>
  <span class="pl-s">- <span class="pl-s">some</span></span>
  <span class="pl-s">- <span class="pl-s">array</span></span>
  <span class="pl-s">- <span class="pl-s">elements</span></span></pre></div>
<p>Similarly, with JSON arrays, this document will not work:</p>
<div class="highlight highlight-source-json"><pre>[
  <span class="pl-s"><span class="pl-pds">"</span>some<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>array<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>elements<span class="pl-pds">"</span></span>
]</pre></div>
<p>But this one will work just fine:</p>
<div class="highlight highlight-source-json"><pre>{
  <span class="pl-s"><span class="pl-pds">"</span>data<span class="pl-pds">"</span></span>: [
    <span class="pl-s"><span class="pl-pds">"</span>some<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>array<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>elements<span class="pl-pds">"</span></span>
  ]
}</pre></div>
<a name="user-content-examples"/>

<a name="user-content-creating-a-new-file"/>

<p>The command below creates a new file with a data key encrypted by KMS and PGP.</p>
<div class="highlight highlight-source-shell"><pre>$ sops --kms <span class="pl-s"><span class="pl-pds">"</span>arn:aws:kms:us-west-2:927034868273:key/fe86dd69-4132-404c-ab86-4269956b4500<span class="pl-pds">"</span></span> --pgp C9CAB0AF1165060DB58D6D6B2653B624D620786D /path/to/new/file.yaml</pre></div>
<a name="user-content-encrypting-an-existing-file"/>

<p>Similar to the previous command, we tell sops to use one KMS and one PGP key.
The path points to an existing cleartext file, so we give sops flag -e to
encrypt the file, and redirect the output to a destination file.</p>
<div class="highlight highlight-source-shell"><pre>$ <span class="pl-k">export</span> SOPS_KMS_ARN=<span class="pl-s"><span class="pl-pds">"</span>arn:aws:kms:us-west-2:927034868273:key/fe86dd69-4132-404c-ab86-4269956b4500<span class="pl-pds">"</span></span>
$ <span class="pl-k">export</span> SOPS_PGP_FP=<span class="pl-s"><span class="pl-pds">"</span>C9CAB0AF1165060DB58D6D6B2653B624D620786D<span class="pl-pds">"</span></span>
$ sops -e /path/to/existing/file.yaml <span class="pl-k">&gt;</span> /path/to/new/encrypted/file.yaml</pre></div>
<p>Decrypt the file with -d.</p>
<div class="highlight highlight-source-shell"><pre>$ sops -d /path/to/new/encrypted/file.yaml</pre></div>
<a name="user-content-encrypt-or-decrypt-a-file-in-place"/>

<p>Rather than redirecting the output of -e or -d, sops can replace the
original file after encrypting or decrypting it.</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"># file.yaml is in cleartext</span>
$ sops -e -i /path/to/existing/file.yaml
<span class="pl-c"># file.yaml is now encrypted</span>
$ sops -d -i /path/to/existing/file.yaml
<span class="pl-c"># file.yaml is back in cleartext</span></pre></div>
<a name="user-content-encrypting-binary-files"/>

<p>sops primary use case is encrypting YAML and JSON configuration files, but it
also has the ability to manage binary files. When encrypting a binary, sops will
read the data as bytes, encrypt it, store the encrypted base64 under
tree['data'] and write the result as JSON.</p>
<p>Note that the base64 encoding of encrypted data can actually make the encrypted
file larger than the cleartext one.</p>
<p>In-place encryption/decryption also works on binary files.</p>
<pre>$ dd if=/dev/urandom of=/tmp/somerandom bs=1024
count=512
512+0 records in
512+0 records out
524288 bytes (524 kB) copied, 0.0466158 s, 11.2 MB/s

$ sha512sum /tmp/somerandom
9589bb20280e9d381f7a192000498c994e921b3cdb11d2ef5a986578dc2239a340b25ef30691bac72bdb14028270828dad7e8bd31e274af9828c40d216e60cbe /tmp/somerandom

$ sops -e -i /tmp/somerandom
please wait while a data encryption key is being generated and stored securely

$ sops -d -i /tmp/somerandom

$ sha512sum /tmp/somerandom
9589bb20280e9d381f7a192000498c994e921b3cdb11d2ef5a986578dc2239a340b25ef30691bac72bdb14028270828dad7e8bd31e274af9828c40d216e60cbe /tmp/somerandom
</pre>
<a name="user-content-extract-a-sub-part-of-a-document-tree"/>

<p>sops can extract a specific part of a YAML or JSON document, by provided the
path in the --extract command line flag. This is useful to extract specific
values, like keys, without needing an extra parser.</p>
<div class="highlight highlight-source-shell"><pre>$ sops -d <span class="pl-k">~</span>/git/svc/sops/example.yaml -t <span class="pl-s"><span class="pl-pds">'</span>["app2"]["key"]<span class="pl-pds">'</span></span>
-----BEGIN RSA PRIVATE KEY-----
MIIBPAIBAAJBAPTMNIyHuZtpLYc7VsHQtwOkWYobkUblmHWRmbXzlAX6K8tMf3Wf
ImcbNkqAKnELzFAPSBeEMhrBN0PyOC9lYlMCAwEAAQJBALXD4sjuBn1E7Y9aGiMz
bJEBuZJ4wbhYxomVoQKfaCu+kH80uLFZKoSz85/ySauWE8LgZcMLIBoiXNhDKfQL
vHECIQD6tCG9NMFWor69kgbX8vK5Y+QL+kRq+9HK6yZ9a+hsLQIhAPn4Ie6HGTjw
fHSTXWZpGSan7NwTkIu4U5q2SlLjcZh/AiEA78NYRRBwGwAYNUqzutGBqyXKUl4u
Erb0xAEyVV7e8J0CIQC8VBY8f8yg+Y7Kxbw4zDYGyb3KkXL10YorpeuZR4LuQQIg
bKGPkMM4w5blyE1tqGN0T7sJwEx+EUOgacRNqM2ljVA=
-----END RSA PRIVATE KEY-----</pre></div>
<p>The tree path syntax uses regular python dictionary syntax, without the
variable name. Extract keys by naming them, and array elements by numbering
them.</p>
<div class="highlight highlight-source-shell"><pre>$ sops -d <span class="pl-k">~</span>/git/svc/sops/example.yaml -t <span class="pl-s"><span class="pl-pds">'</span>["an_array"][1]<span class="pl-pds">'</span></span>
secretuser2</pre></div>
<a name="user-content-using-sops-as-a-library-in-a-python-script"/>

<p>You can import sops as a module and use it in your python program.</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> sops

pathtype <span class="pl-k">=</span> sops.detect_filetype(path)
tree <span class="pl-k">=</span> sops.load_file_into_tree(path, pathtype)
sops_key, tree <span class="pl-k">=</span> sops.get_key(tree)
tree <span class="pl-k">=</span> sops.walk_and_decrypt(tree, sops_key)
sops.write_file(tree, <span class="pl-v">path</span><span class="pl-k">=</span>path, <span class="pl-v">filetype</span><span class="pl-k">=</span>pathtype)</pre></div>
<a name="user-content-showing-diffs-in-cleartext-in-git"/>

<p>You most likely want to store encrypted files in a version controlled repository.
Sops can be used with git to decrypt files when showing diffs between versions.
This is very handy for reviewing changes or visualizing history.</p>
<p>To configure sops to decrypt files during diff, create a .gitattributes file
at the root of your repository that contains a filter and a command.</p>
<p>... code:</p>
<pre>*.yaml diff=sopsdiffer
</pre>
<p>Here we only care about YAML files. sopsdiffer is an arbitrary name that we map
to a sops command in the git configuration file of the repository.</p>
<div class="highlight highlight-source-shell"><pre>$ git config diff.sopsdiffer.textconv <span class="pl-s"><span class="pl-pds">"</span>sops -d<span class="pl-pds">"</span></span>

$ grep -A 1 sopsdiffer .git/config
[diff <span class="pl-s"><span class="pl-pds">"</span>sopsdiffer<span class="pl-pds">"</span></span>]
        textconv = <span class="pl-s"><span class="pl-pds">"</span>sops -d<span class="pl-pds">"</span></span></pre></div>
<p>With this in place, calls to git diff will decrypt both previous and current
versions of the target file prior to displaying the diff. And it even works with
git client interfaces, because they call git diff under the hood!</p>
<a name="user-content-encrypting-only-parts-of-a-file"/>

<p>Note: this only works on YAML and JSON files, not on BINARY files.</p>
<p>By default, sops encrypts all the values of a YAML or JSON file and leaves the
keys in cleartext. In some instances, you may want to exclude some values from
being encrypted. This can be accomplished by adding the suffix <strong>_unencrypted</strong>
to any key of a file. When set, all values underneath the key that set the
<strong>_unencrypted</strong> prefix will be left in cleartext.</p>
<p>Note that, while in cleartext, unencrypted content is still added to the
checksum of the file, and thus cannot be modified outside of sops without
breaking the file integrity check.</p>
<p>The unencrypted suffix can be set to a different value using the
--unencrypted-suffix option.</p>
<a name="user-content-encryption-protocol"/>

<p>When sops creates a file, it generates a random 256 bit data key and asks each
KMS and PGP master key to encrypt the data key. The encrypted version of the data
key is stored in the sops metadata under sops.kms and sops.pgp.</p>
<p>For KMS:</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">sops:</span></span>
    <span class="pl-s"><span class="pl-ent">kms:</span></span>
    <span class="pl-s">-   <span class="pl-ent">enc:</span> <span class="pl-s">CiC6yCOtzsnFhkfdIslYZ0bAf//gYLYCmIu87B3sy/5yYxKnAQEBAQB4usgjrc7JxYZH3SLJWGdGwH//4GC2ApiLvOwd7Mv+cmMAAAB+MHwGCSqGSIb3DQEHBqBvMG0CAQAwaAYJKoZIhvcNAQcBMB4GCWCGSAFlAwQBLjARBAyGdRODuYMHbA8Ozj8CARCAO7opMolPJUmBXd39Zlp0L2H9fzMKidHm1vvaF6nNFq0ClRY7FlIZmTm4JfnOebPseffiXFn9tG8cq7oi</span></span>
        <span class="pl-c1"><span class="pl-ent">enc_ts:</span> 1439568549.245995</span>
        <span class="pl-s"><span class="pl-ent">arn:</span> <span class="pl-s">arn:aws:kms:us-east-1:656532927350:key/920aff2e-c5f1-4040-943a-047fa387b27e</span></span></pre></div>
<p>For PGP:</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">sops:</span></span>
    <span class="pl-s"><span class="pl-ent">pgp:</span></span>
    <span class="pl-s">-   <span class="pl-ent">fp:</span> <span class="pl-s">85D77543B3D624B63CEA9E6DBC17301B491B3F21</span></span>
        <span class="pl-c1"><span class="pl-ent">created_at:</span> 1441570391.930042</span>
<span class="pl-s">        <span class="pl-ent">enc:</span> |</span>
<span class="pl-s">            -----BEGIN PGP MESSAGE-----</span>
<span class="pl-s">            Version: GnuPG v1</span>
<span class="pl-s"/>
<span class="pl-s">            hQIMA0t4uZHfl9qgAQ//UvGAwGePyHuf2/zayWcloGaDs0MzI+zw6CmXvMRNPUsA</span>
<span class="pl-s">            pAgRKczJmDu4+XzN+cxX5Iq9xEWIbny9B5rOjwTXT3qcUYZ4Gkzbq4MWkjuPp/Iv</span>
<span class="pl-s">            qO4MJaYzoH5YxC4YORQ2LvzhA2YGsCzYnljmatGEUNg01yJ6r5mwFwDxl4Nc80Cn</span>
<span class="pl-s">            RwnHuGExK8j1jYJZu/juK1qRbuBOAuruIPPWVdFB845PA7waacG1IdUW3ZtBkOy3</span>
<span class="pl-s">            O0BIfG2ekRg0Nik6sTOhDUA+l2bewCcECI8FYCEjwHm9Sg5cxmP2V5m1mby+uKAm</span>
<span class="pl-s">            kewaoOyjbmV1Mh3iI1b/AQMr+/6ZE9MT2KnsoWosYamFyjxV5r1ZZM7cWKnOT+tu</span>
<span class="pl-s">            KOvGhTV1TeOfVpajNTNwtV/Oyh3mMLQ0F0HgCTqomQVqw5+sj7OWAASuD3CU/dyo</span>
<span class="pl-s">            pcmY5Qe0TNL1JsMNEH8LJDqSh+E0hsUxdY1ouVsg3ysf6mdM8ciWb3WRGxih1Vmf</span>
<span class="pl-s">            unfLy8Ly3V7ZIC8EHV8aLJqh32jIZV4i2zXIoO4ZBKrudKcECY1C2+zb/TziVAL8</span>
<span class="pl-s">            qyPe47q8gi1rIyEv5uirLZjgpP+JkDUgoMnzlX334FZ9pWtQMYW4Y67urAI4xUq6</span>
<span class="pl-s">            /q1zBAeHoeeeQK+YKDB7Ak/Y22YsiqQbNp2n4CKSKAE4erZLWVtDvSp+49SWmS/S</span>
<span class="pl-s">            XgGi+13MaXIp0ecPKyNTBjF+NOw/I3muyKr8EbDHrd2XgIT06QXqjYLsCb1TZ0zm</span>
<span class="pl-s">            xgXsOTY3b+ONQ2zjhcovanDp7/k77B+gFitLYKg4BLZsl7gJB12T8MQnpfSmRT4=</span>
<span class="pl-s">            =oJgS</span>
<span class="pl-s">            -----END PGP MESSAGE-----</span></pre></div>
<p>sops then opens a text editor on the newly created file. The user adds data to the
file and saves it when done.</p>
<p>Upon save, sops browses the entire file as a key/value tree. Every time sops
encounters a leaf value (a value that does not have children), it encrypts the
value with AES256_GCM using the data key and a 256 bit random initialization
vector.</p>
<p>Each file uses a single data key to encrypt all values of a document, but each
value receives a unique initialization vector and has unique authentication data.</p>
<p>Additional data is used to guarantee the integrity of the encrypted data
and of the tree structure: when encrypting the tree, key names are concatenated
into a byte string that is used as AEAD additional data (aad) when encrypting
values. We expect that keys do not carry sensitive information, and
keeping them in cleartext allows for better diff and overall readability.</p>
<p>Any valid KMS or PGP master key can later decrypt the data key and access the
data.</p>
<p>Multiple master keys allow for sharing encrypted files without sharing master
keys, and provide a disaster recovery solution. The recommended way to use sops
is to have two KMS master keys in different regions and one PGP public key with
the private key stored offline. If, by any chance, both KMS master keys are
lost, you can always recover the encrypted data using the PGP private key.</p>
<a name="user-content-message-authentication-code"/>

<p>In addition to authenticating branches of the tree using keys as additional
data, sops computes a MAC on all the values to ensure that no value has been
added or removed fraudulently. The MAC is stored encrypted with AES_GCM and
the data key under tree-&gt;`sops`-&gt;`mac`.</p>
<a name="user-content-motivation"/>

<p>Automating the distribution of secrets and credentials to components of an
infrastructure is a hard problem. We know how to encrypt secrets and share them
between humans, but extending that trust to systems is difficult. Particularly
when these systems follow devops principles and are created and destroyed
without human intervention. The issue boils down to establishing the initial
trust of a system that just joined the infrastructure, and providing it access
to the secrets it needs to configure itself.</p>
<a name="user-content-the-initial-trust"/>

<p>In many infrastructures, even highly dynamic ones, the initial trust is
established by a human. An example is seen in Puppet by the way certificates are
issued: when a new system attempts to join a Puppetmaster, an administrator
must, by default, manually approve the issuance of the certificate the system
needs. This is cumbersome, and many puppetmasters are configured to auto-sign
new certificates to work around that issue. This is obviously not recommended
and far from ideal.</p>
<p>AWS provides a more flexible approach to trusting new systems. It uses a
powerful mechanism of roles and identities. In AWS, it is possible to verify
that a new system has been granted a specific role at creation, and it is
possible to map that role to specific resources. Instead of trusting new systems
directly, the administrator trusts the AWS permission model and its automation
infrastructure. As long as AWS keys are safe, and the AWS API is secure, we can
assume that trust is maintained and systems are who they say they are.</p>
<a name="user-content-kms-trust-and-secrets-distribution"/>

<p>Using the AWS trust model, we can create fine grained access controls to
Amazon's Key Management Service (KMS). KMS is a service that encrypts and
decrypts data with AES_GCM, using keys that are never visible to users of the
service. Each KMS master key has a set of role-based access controls, and
individual roles are permitted to encrypt or decrypt using the master key. KMS
helps solve the problem of distributing keys, by shifting it into an access
control problem that can be solved using AWS's trust model.</p>
<a name="user-content-operational-requirements"/>

<p>When Mozilla's Services Operations team started revisiting the issue of
distributing secrets to EC2 instances, we set a goal to store these secrets
encrypted until the very last moment, when they need to be decrypted on target
systems. Not unlike many other organizations that operate sufficiently complex
automation, we found this to be a hard problem with a number of prerequisites:</p>
<ol>
<li>Secrets must be stored in YAML files for easy integration into hiera</li>
<li>Secrets must be stored in GIT, and when a new CloudFormation stack is
built, the current HEAD is pinned to the stack. (This allows secrets to
be changed in GIT without impacting the current stack that may
autoscale).</li>
<li>Entries must be encrypted separately. Encrypting entire files as blobs makes
git conflict resolution almost impossible. Encrypting each entry
separately is much easier to manage.</li>
<li>Secrets must always be encrypted on disk (admin laptop, upstream
git repo, jenkins and S3) and only be decrypted on the target
systems</li>
</ol>
<p>SOPS can be used to encrypt YAML, JSON and BINARY files. In BINARY mode, the
content of the file is treated as a blob, the same way PGP would encrypt an
entire file. In YAML and JSON modes, however, the content of the file is
manipulated as a tree where keys are stored in cleartext, and values are
encrypted. hiera-eyaml does something similar, and over the years we learned
to appreciate its benefits, namely:</p>
<ul>
<li>diffs are meaningful. If a single value of a file is modified, only that
value will show up in the diff. The diff is still limited to only showing
encrypted data, but that information is already more granular that
indicating that an entire file has changed.</li>
<li>conflicts are easier to resolve. If multiple users are working on the
same encrypted files, as long as they don't modify the same values,
changes are easy to merge. This is an improvement over the PGP
encryption approach where unsolvable conflicts often happen when
multiple users work on the same file.</li>
</ul>
<a name="user-content-openpgp-integration"/>

<p>OpenPGP gets a lot of bad press for being an outdated crypto protocol, and while
true, what really made us look for alternatives is the difficulty of managing and
distributing keys to systems. With KMS, we manage permissions to an API, not keys,
and that's a lot easier to do.</p>
<p>But PGP is not dead yet, and we still rely on it heavily as a backup solution:
all our files are encrypted with KMS and with one PGP public key, with its
private key stored securely for emergency decryption in the event that we lose
all our KMS master keys.</p>
<p>SOPS can be used without KMS entirely, the same way you would use an encrypted
PGP file: by referencing the pubkeys of each individual who has access to the file.
It can easily be done by providing sops with a comma-separated list of public keys
when creating a new file:</p>
<div class="highlight highlight-source-shell"><pre>$ sops --pgp <span class="pl-s"><span class="pl-pds">"</span>E60892BB9BD89A69F759A1A0A3D652173B763E8F,84050F1D61AF7C230A12217687DF65059EF093D3,85D77543B3D624B63CEA9E6DBC17301B491B3F21<span class="pl-pds">"</span></span> mynewfile.yaml</pre></div>
<a name="user-content-threat-model"/>

<p>The security of the data stored using sops is as strong as the weakest
cryptographic mechanism. Values are encrypted using AES256_GCM which is the
strongest symetric encryption algorithm known today. Data keys are encrypted
in either KMS, which also uses AES256_GCM, or PGP which uses either RSA or
ECDSA keys.</p>
<p>Going from the most likely to the least likely, the threats are as follows:</p>
<a name="user-content-compromised-aws-credentials-grant-access-to-kms-master-key"/>

<p>An attacker with access to an AWS console can grant itself access to one of
the KMS master keys used to encrypt a sops data key. This threat should be
mitigated by protecting AWS accesses with strong controls, such as multi-factor
authentication, and also by performing regular audits of permissions granted
to AWS users.</p>
<a name="user-content-compromised-pgp-key"/>

<p>PGP keys are routinely mishandled, either because owners copy them from
machine to machine, or because the key is left forgotten on an unused machine
an attacker gains access to. When using PGP encryption, sops users should take
special care of PGP private keys, and store them on smart cards or offline
as often as possible.</p>
<a name="user-content-factorized-rsa-key"/>

<p>sops doesn't apply any restriction on the size or type of PGP keys. A weak PGP
keys, for example 512 bits RSA, could be factorized by an attacker to gain
access to the private key and decrypt the data key. Users of sops should rely
on strong keys, such as 2048+ bits RSA keys, or 256+ bits ECDSA keys.</p>
<a name="user-content-weak-aes-cryptography"/>

<p>A vulnerability in AES256_GCM could potentially leak the data key or the KMS
master key used by a sops encrypted file. While no such vulnerability exists
today, we recommend that users keep their encrypted files reasonably private.</p>
<a name="user-content-backward-compatibility"/>

<p>sops will remain backward compatible on the major version, meaning that all
improvements brought to the 1.X branch (current) will maintain the file format
introduced in <strong>1.0</strong>.</p>
<a name="user-content-license"/>

<p>Mozilla Public License Version 2.0</p>
<a name="user-content-authors"/>


<a name="user-content-credits"/>

<p>sops is inspired by <a href="https://github.com/TomPoulton/hiera-eyaml">hiera-eyaml</a>,
<a href="https://github.com/LuminalOSS/credstash">credstash</a> ,
<a href="https://github.com/codahale/sneaker">sneaker</a>,
<a href="http://www.passwordstore.org/">password store</a> and too many years managing
PGP encrypted files by hand...</p>

</article>
  </div></body></html>