<html><body><div><div class="content html_format">
      <i>От переводчика: мы в компании <a href="http://www.enterra.ru/">Энтерра</a> очень любим алгоритмы компьютерного зрения. Работаем чаще всего с OpenCv. Время от времени нам пишут разные разработчики с вопросами: «А как лучше начать работать с OpenCv?» или «Какую интересную задачу можно просто решить с помощью OpenCv?» В связи с чем мы решили перевести очень хорошую статью, которая будет полезна всем, кто интересуется компьютерным зрением.</i>

<img src="https://habrastorage.org/files/c3e/8ef/0e4/c3e8ef0e415d46cd81d8e4f6c29b33c1.jpg"/>
<p>
Черная Пятница близко.
</p><p>
Толпы злых покупателей. Рой одинаковых теток среднего возраста, готовых сожрать практически всё, что угодно, в ближайшем супермаркете — главное, что со скидкой 75%. Они выстроятся в очереди перед дверьми магазинов в полночь Дня благодарения. Они будут ломиться внутрь, стучать в запертые двери кулаками и головами, пока не сплющат друг друга и не разобьют руки в кровь, став похожими на зомби из «28 дней спустя». Но вместо человеческой плоти, они жаждут удовлетворить инстинкт покупателя. Их боевые кличи о скидках и распродажах достигают небес. А их громовая поступь способна привести к землетрясению на Великой Равнине.
</p><p>
Естественно, от СМИ помощи не жди — они будут смаковать каждую подробность. От обмороженных семейств, ночевавших в палатке на морозе, до старой леди, растоптанной охотниками за скидкой в момент, когда открылись двери. Что-то похожее случилось с галлимимусом в «Парке Юрского периода». А она просто хотела купить Halo для девятилетнего внука Тимми, чьи родители забыли это сделать в прошлом году. В Wal-Mart. Во время Черной Пятницы.
</p><p>
И я обязан спросить: весь этот хаос и бедлам стоят того?

</p><b>Чёрт возьми, нет!</b>
<p>
Любая покупка, которую я совершу в эту Черную Пятницу, будет сделана совершенно безопасно с помощью ноутбука. Но если вы решите выйти в реальный мир и вступить в схватку с охотниками за наживой, </p><b>вам в первую очередь понадобится загрузить код из <a href="http://www.pyimagesearch.com/2014/11/24/detecting-barcodes-images-python-opencv/">оригинального поста</a></b><p>.
</p><p>
Просто представьте, как глупо вы будете выглядеть, стоя в очереди в ожидании свободной кассы – только для того, чтобы после сканирования штрихкода последнего сезона «Игры Престолов» выяснить, что в Target его можно купить на 5 долларов дешевле?
</p><p>
Собственно, далее я покажу, как можно обнаружить штрихкод на изображении, используя только Python и OpenCV.</p><a name="habracut"/>

<h3>Распознаём штриходы на изображениях на Pyhton и OpenCv</h3><p>
Задача этого поста — показать простое применение компьютерного зрения и технологий обработки изображений для распознавания штрихкодов. Мой алгоритм — это вариация на тему из вот этого </p><a href="http://stackoverflow.com/questions/9013703/how-to-find-the-location-of-red-region-in-an-image-using-matlab/9014569">вопроса со StackOverflow</a><p>. Я просмотрел оригинальный код и добавил к нему ряд обновлений и улучшений. Стоит отметить, что этот код не будет работать для всех штрихкодов, но в любом случае вы получите представление о том, какие методы нужно будет использовать.
</p><p>
Важно отметить, что алгоритм не будет работать для </p><i>всех штрихкодов</i><p>, но зато даст базовое интуитивное понимание того, какие техники должны быть для этого использованы.
</p><p>
Для примера, мы определим штрихкод со следующего изображения:

</p><img src="https://habrastorage.org/files/5aa/4dc/e1a/5aa4dce1a6fd417e8b9df368d6c93842.jpg"/>
<p>
Перейдём к коду. Открываем новый файл, называем его </p><code>detect_barcode.py</code><p> — и поехали:

</p><pre><code class="python"># import the necessary packages
import numpy as np
import argparse
import cv2
 
# construct the argument parse and parse the arguments
ap = argparse.ArgumentParser()
ap.add_argument("-i", "--image", required = True, help = "path to the image file")
args = vars(ap.parse_args())
</code></pre><p>
Прежде всего нужно сделать импорт необходимых пакетов. Нам потребуются NumPy для работы с числами, </p><code>agparse</code><p> для парсинга аргументов командной строки и </p><code>cv2</code><p> для связи с OpenCV.
</p><p>
Далее обрабатываем аргументы командной строки. Мы будем использовать единственный аргумент </p><code>--image</code><p> для задания пути к изображению с штрихкодом.
</p><p>
Теперь приступим к непосредственной обработке изображения:

</p><pre><code class="python"># load the image and convert it to grayscale
image = cv2.imread(args["image"])
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
 
# compute the Scharr gradient magnitude representation of the images
# in both the x and y direction
gradX = cv2.Sobel(gray, ddepth = cv2.cv.CV_32F, dx = 1, dy = 0, ksize = -1)
gradY = cv2.Sobel(gray, ddepth = cv2.cv.CV_32F, dx = 0, dy = 1, ksize = -1)
 
# subtract the y-gradient from the x-gradient
gradient = cv2.subtract(gradX, gradY)
gradient = cv2.convertScaleAbs(gradient)
</code></pre><p>Мы загружаем изображение </p><code>image</code><p> и преобразуем его цветовой режим в оттенки серого.
</p><p>
Затем, мы используем оператор Собеля (с выставленным </p><code>ksize = -1</code><p>), чтобы вычислить величину градиента серой картинки в вертикальном и горизонтальном направлениях.
</p><p>
После этого мы вычитаем y-градиент оператора Собеля из x-градиента. После вычитания мы получаем изображение с высоким значением горизонтального градиента и низким значением вертикального.
</p><p>
И сейчас наше изображение выглядит так:

</p><img src="https://habrastorage.org/files/785/ffa/307/785ffa307e5146d5a877d90da6c28474.jpg"/>

<b>Обратите внимание, что зона штрихкода была определена с помощью операций с градиентом.</b><p> Следующий шаг — устранить шум на изображении и сфокусироваться сугубо на области со штрихкодом.

</p><pre><code class="python"># blur and threshold the image
blurred = cv2.blur(gradient, (9, 9))
(_, thresh) = cv2.threshold(blurred, 225, 255, cv2.THRESH_BINARY)
</code></pre><p>И первое, что мы сделаем — это используем average blur с ядром размера 9x9. Это поможет сгладить высокочастотный шум на нашей картинке с градинентами.
</p><p>
Затем мы проведём бинаризацию размытого изображения. Каждый пиксель изображения со значением не выше 225 мы превратим в 0 (чёрный), а остальные — в 255 (белый). В итоге получим:

</p><img src="https://habrastorage.org/files/7ef/d42/f37/7efd42f3779b49d7a42b335c7bff2f82.jpg"/><p>
Однако, как вы можете заметить на исходном изображении, между вертикальными полосками штрихкода есть пространство. Чтобы его закрыть и облегчить нашему алгоритму определение области штрихкода, нам нужно произвести ряд простых морфологических операций:

</p><pre><code class="python"># construct a closing kernel and apply it to the thresholded image
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (21, 7))
closed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)
</code></pre><p>Мы начнем с создания прямоугольника с помощью </p><code>cv2.getStructuringElement</code><p>. Ширина ядра больше его высоты, что позволяет нам перекрыть пространство между вертикальными полосками штрихкода.
</p><p>
Далее, произведем нашу морфологическую операцию, применив ядро к бинаризированному изображению, замазывая пространство между полосками. И вы можете сами увидеть, что «пробелы» почти полностью закрыты, по сравнению с изображениями выше:

</p><img src="https://habrastorage.org/files/bb7/80e/48b/bb780e48b2d84779a279ca9dedacfb3b.jpg"/>
<p>
Конечно, на картинке остались и некоторые светлые пятна, которые не имеют отношения к штрихкоду и способны помешать точно определить его контур.
</p><p>
Давайте постараемся избавиться от этих пятен:

</p><pre><code class="python"># perform a series of erosions and dilations
closed = cv2.erode(closed, None, iterations = 4)
closed = cv2.dilate(closed, None, iterations = 4)
</code></pre><p>
Тут мы делаем четыре итерации эрозии, за которым следуют четыре итерации дилатация. Эрозия уберёт белые пиксели с изображения, удаляя мелкие блобы, а дилатация не позволит крупным белым областям уменьшиться. Удаленные во время размытия мелкие пятна во время растяжения не появятся вновь.
</p><p>
После серии эрозий и дилатаций можно увидеть, что мелкие пятна успешно были удалены, осталась только область штрихкода:

</p><img src="https://habrastorage.org/files/ace/9c5/a78/ace9c5a789ab4710994308ebeb911b76.jpg"/>
<p>
Наконец, давайте найдем контуры области штрихкода на изображении:

</p><pre><code class="python"># find the contours in the thresholded image, then sort the contours
# by their area, keeping only the largest one
(cnts, _) = cv2.findContours(closed.copy(), cv2.RETR_EXTERNAL,
cv2.CHAIN_APPROX_SIMPLE)
c = sorted(cnts, key = cv2.contourArea, reverse = True)[0]
 
# compute the rotated bounding box of the largest contour
rect = cv2.minAreaRect(c)
box = np.int0(cv2.cv.BoxPoints(rect))
 
# draw a bounding box arounded the detected barcode and display the
# image
cv2.drawContours(image, [box], -1, (0, 255, 0), 3)
cv2.imshow("Image", image)
cv2.waitKey(0)
</code></pre><p>
К счастью, это довольно просто. Мы находим самый большой контур на изображении с помощью </p><code>cv2.findContours</code><p>, который (если обработка была произведена корректно) точно соотносится с областью штрихкода.
</p><p>
Затем мы определяем минимальный ограничивающий прямоугольник, в который заключим этот самый большой контур, после чего наконец отображаем найденный штрихкод. 
</p><p>
Как вы можете видеть, мы успешно нашли штрихкод:

</p><img src="https://habrastorage.org/files/8a9/68d/90e/8a968d90ea904b25b5782c92bb4f0234.jpg"/><p>
Попробуем сделать это еще с несколькими изображениями?

</p><h3>Успешное определение штрихкодов</h3><p>
Чтобы получить аналогичные результаты, используйте мой код (можно загрузить целиком на странице поста-оригинала) и приведенные здесь изображения. Как только у вас будет код и изображения, откройте терминал и выполните следующую команду:

</p><pre><code>1 $ python detect_barcode.py --image images/barcode_02.jpg
</code></pre>
<img src="https://habrastorage.org/files/ca1/49c/e84/ca149ce84a3746ea83cfde3a2557c50c.jpg"/><p>Без проблем найден штрихкод кокосового масла. Пробуем еще:

</p><pre><code>1 $ python detect_barcode.py --image images/barcode_03.jpg
</code></pre><img src="https://habrastorage.org/files/362/ccc/fb2/362cccfb28194416879d4d8a2c1fe7e0.jpg"/><p>И на этом изображении мы успешно обнаружили штрихкод! Но что это мы все про еду, давайте перейдем к книгам.

</p><pre><code>1 $ python detect_barcode.py --image images/barcode_04.jpg
</code></pre><img src="https://habrastorage.org/files/2a9/3cd/7fc/2a93cd7fc6fe40cd8ebede0638e9c5f6.jpg"/><p>И снова – никаких проблем! Сможем ли мы определить номер для отслеживания посылки? 

</p><pre><code>1 $ python detect_barcode.py --image images/barcode_05.jpg
</code></pre><img src="https://habrastorage.org/files/ffc/add/618/ffcadd61855d444fb555435ab3d055ae.jpg"/>
<p>
И вновь наш алгоритм успешно обнаружил штрихкод.

</p><h3>Заключение</h3><p>
В этом посте мы рассмотрели необходимые шаги для обнаружения штрихкодов на изображениях с помощью технологий компьютерного зрения. Мы применили алгоритм, использующий язык программирования Python и библиотеку OpenCV.
</p><p>
В основе нашего алгоритма лежат следующие действия:</p><ol>
<li>Вычислите размер градиента по осям x и y.</li>
<li>Отделите вертикальный градиент от горизонтального, чтобы выявить область штрихкода.</li>
<li>Примените размытие и бинаризацию.</li>
<li>Примените ядро к бинаризированной картинке для удаления «пробелов» между полосками.</li>
<li>Произведите серию эрозий и дилатаций.</li>
<li>Найдите на изображении самый большой контур, который и будет являться областью штрихкода.</li>
</ol><p>Стоит отметить, что, так как метод основан на представлении изображения в форме градиента, он будет корректно работать только для горизонтальных штрихкодов.
</p><p>
Если вы хотите использовать более надёжный алгоритм обнаружения штрихкодов, стоит принять во внимание ориентацию изображения, а еще лучше — использовать самообучаемые системы, например, каскады Хаара или HOG+ Linear SVM, чтобы «сканировать» изображение на предмет областей со штрихкодом.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>