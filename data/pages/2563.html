<html><body><div><div class="entry-content clearfix"><p><strong>In this part, we’ll update the staging environment, with our latest code changes, by first setting up Redis on Heroku and then looking at how to run both our web and worker processes on a single dyno.</strong></p>

<p><strong>Updated 02/22/2015:</strong> Added Python 3 support.</p>









<p>Remember, here’s what we’re building: A Flask app that calculates word-frequency pairs based on the text from a given URL. This is a full-stack tutorial.</p>

<ol>
<li><a href="http://www.realpython.com/blog/python/flask-by-example-part-1-project-setup">Part One</a>: Setup a local development environment and then deploy both a staging environment and a production environment on Heroku.</li>
<li><a href="http://www.realpython.com/blog/flask-by-example-part-2-postgres-sqlalchemy-and-alembic">Part Two</a>: Setup a PostgreSQL database along with SQLAlchemy and Alembic to handle migrations.</li>
<li><a href="https://realpython.com/blog/python/flask-by-example-part-3-text-processing-with-requests-beautifulsoup-nltk/">Part Three</a>: Add in the back-end logic to scrape and then process the counting of words from a webpage using the requests, BeautifulSoup, and Natural Language Toolkit (NLTK) libraries.</li>
<li><a href="https://realpython.com/blog/python/flask-by-example-implementing-a-redis-task-queue/">Part Four</a>: Implement a Redis task queue to handle the text processing.</li>
<li><a href="https://realpython.com/blog/python/flask-by-example-integrating-flask-and-angularjs/">Part Five</a>: Setup Angular on the front-end to continuously poll the back-end to see if the request is done.</li>
<li><strong>Part Six: Push to the staging server on Heroku – setting up Redis, detailing how to run two processes (web and worker) on a single Dyno. (current)</strong></li>
<li><a href="https://realpython.com/blog/python/flask-by-example-updating-the-ui/">Part Seven</a>: Update the front-end to make it more user-friendly.</li>
<li>Part Eight: Add the D3 library into the mix to graph a frequency distribution and histogram.</li>
</ol>


<blockquote><p>Need the code? Grab it from the <a href="https://github.com/realpython/flask-by-example/releases">repo</a>.</p></blockquote>

<a name="Test.Push"/>
<h2>Test Push</h2>

<p>Let’s start with pushing up the code in its current state and see what needs to be fixed.</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>workon wordcounts
</span><span class="line"><span class="nv">$ </span>git add -A
</span><span class="line"><span class="nv">$ </span>git commit -am <span class="s2">"added angular and the backend worker process"</span>
</span><span class="line"><span class="nv">$ </span>git push stage master
</span><span class="line"><span class="nv">$ </span>heroku open --app wordcounts-stage
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>Make sure to replace <code>wordcounts-stage</code> with the name of your app.</p></blockquote>

<p>First off, if you open your app using the HTTP secure (‘<a href="https://">https://</a>’) protocol, notice how none of the external JavaScript or CSS files are loading. To fix that, remove the ‘<a href="http:">http:</a>’ from the links in the <em>index.html</em> file.</p>

<p>For example:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">"//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css"</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">media=</span><span class="s">"screen"</span><span class="nt">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Update all of the files, then commit and push your changes back up to Heroku. Now regardless of whether you view the site from ‘https’ or ‘http’, the external files will load correctly.</p>

<p>Next, try to run a quick test to see if the wordcount feature works. Nothing should happen. Why? Well, If you open the “Network” tab in “Chrome Developer Tools”, you’ll see that the post request to the <code>/start</code> endpoint returned a 500 (Internal Server Error) status code.</p>









<p>Think about how we run this locally: We have a worker process and the Redis server running along with the Flask development server. The same needs to happen on Heroku.</p>

<a name="Redis"/>
<h2>Redis</h2>

<p>Start by adding Redis to the staging app:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>heroku addons:add redistogo --app wordcounts-stage
</span></code></pre></td></tr></table></div></figure>


<p>You can test to make sure the <code>REDISTOGO_URL</code> has been set as an environment variable with the following command:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">$ </span>heroku config --app wordcounts-stage <span class="p">|</span> grep REDISTOGO_URL
</span></code></pre></td></tr></table></div></figure>


<p>We need to make sure we’re linking to the Redis URI in our code, which actually is already set up. Open up <em>worker.py</em> and find this code:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">redis_url</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">'REDISTOGO_URL'</span><span class="p">,</span> <span class="s">'redis://localhost:6379'</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here we first try to use the URI associated with the environment variable. And if that variable does not exist (like in our local environment), then we use the <code>redis://localhost:6379</code> URI. Perfect.</p>

<blockquote><p>Be sure to check out the <a href="https://devcenter.heroku.com/articles/redistogo">official Heroku documentation</a> for more on working with Redis.</p></blockquote>

<p>With Redis setup, we now just need to get our worker process running.</p>

<a name="Worker"/>
<h2>Worker</h2>

<p>Heroku allows you to run one free dyno. And you <em>should</em> run one process per dyno – meaning our web process should be in one dyno and the worker process should be in another. However, since we’re working on a small project, there is a workaround that we can employ to run both processes on one dyno. Keep in mind that this method is <strong>not</strong> recommended for larger projects, as the process will not properly scale as traffic increases.</p>

<p>First, add a bash script called <em>heroku.sh</em> to the Project root directory:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="c">#!/bin/bash</span>
</span><span class="line">gunicorn app:app --daemon
</span><span class="line">python worker.py
</span></code></pre></td></tr></table></div></figure>


<p>Then, update the <em>Procfile</em>:</p>

<figure class="code"><figcaption><span/></figcaption></figure>


<p>Now both the web (demonized, in the background) and worker (in the foreground) processes are ran under the web process in the <em>Procfile</em>.</p>

<blockquote><p>Please note that there are other ways of running a web and worker for free on Heroku. We’ll look at an alternative method in a future post (if there’s interest).</p></blockquote>

<p>Let’s test this out locally before pushing to the staging server. In a new terminal window, run the Redis server – <code>redis-server</code>. Then run <code>foreman start</code>. Navigate to <a href="http://localhost:5000/">http://localhost:5000/</a> and test the application out. It should work.</p>

<p>Commit your changes, and then push to Heroku. Test it out.</p>

<a name="Conclusion"/>
<h2>Conclusion</h2>

<p>Homework! Although we have much more to do, the application does work – so let’s get an iteration out there for the world to see. Go ahead and update the production environment, using the same workflow.</p>

<p><strong>Links:</strong></p>

<ol>
<li><a href="https://github.com/realpython/flask-by-example/releases">Repo</a></li>
<li><a href="http://wordcounts-stage.herokuapp.com/">My Staging app</a></li>
<li><a href="http://wordcounts-pro.herokuapp.com/">My Production app</a></li>
</ol>


<p>Leave questions and comments below.</p>
</div>


      </div></body></html>