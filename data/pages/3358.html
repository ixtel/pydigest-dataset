<html><body><div><article class="post-content" itemprop="ArticleBody">
    <p>In this post I’d like to create demo realtime Stack Overflow mirror with 
<a href="http://www.celeryproject.org/">Celery</a>, <a href="http://www.cherrypy.org/">CherryPy</a>
and MongoDB. By realtime I mean that app will fetch results
from remote resource in short intervals, and it will display results 
in simple one page js-html app without user clicking browser refresh button.</p>

<p>** All of the code for this tutorial is placed <a href="https://github.com/pawelmhm/pawelmhm.github.io/tree/master/_code">in my blog’s github account.</a></p>

<p>Design for the whole project is quite simple. First we’ll create 
basic HTTP client that will connect to <a href="http://stackoverflow.com/feeds">Stack Overflow xml feed</a> and parse results.
The client itself will be synchronous, created with python-requests,
but it will be executed as periodic task running with Celery beat scheduler. 
It will run at regular intervals, check if there are new questions in SO, if there
are, it will insert them into database.</p>

<p>To this I’ll add simple REST-ful backend that will return results in JSON.
We’ll have one endpoint /update. It will accept one parameter ‘timestamp’,
and will return all results fetched from Stack Overflow after time designated by 
timestamp. I’m going to use CherryPy because it’s simple and easy.
CherryPy has really gentle learning curve, if you know some Python you can get
up and running in matter of minutes, design of framework seems intuitive, 
it does not enforce any design paradigm and gives you freedom to do what you’d like to do.</p>

<p>Finally I’ll add some frontend to whole mixture - trivial JS script polling our
/update endpoint and appending (or actually prepending) results to DOM. I’m 
going to use poling instead of websockets, because it’s a bit easier to start
with polling, you remain on the level of simple HTTP GET without having 
to setup websockets server.</p>

<h2 id="simple-stack-overflow-scraper">Simple Stack Overflow Scraper</h2>

<p>Fist let’s write a client that will parse Stack Overflow feed and get all 
new questions for us. Recent questions feed is located at: http://stackoverflow.com/feeds,
it’s plain rss xml, that we can easily parse by using xpaths. If you prefer
BeautifulSoup or some other library, nothing should stop you from using it!
I prefer xpaths only because I use them quite often so I’m familiar with them.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># stack_scrap.py</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
<span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">sha224</span>

<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">lxml</span> <span class="kn">import</span> <span class="n">etree</span>
<span class="kn">from</span> <span class="nn">pymongo</span> <span class="kn">import</span>  <span class="n">MongoClient</span>
<span class="kn">from</span> <span class="nn">pymongo.errors</span> <span class="kn">import</span> <span class="n">DuplicateKeyError</span>

<span class="k">def</span> <span class="nf">questions</span><span class="p">():</span>
    <span class="n">feed_url</span> <span class="o">=</span> <span class="s">"http://stackoverflow.com/feeds"</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">feed_url</span><span class="p">)</span>
    <span class="c"># remove namespace because they are incovenient</span>
    <span class="n">xmlstring</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">'xmlns="[^"]+"'</span><span class="p">,</span> <span class="s">u''</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="n">xmlstring</span> <span class="o">=</span> <span class="n">xmlstring</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'utf8'</span><span class="p">)</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">xmlstring</span><span class="p">)</span>

    <span class="n">client</span> <span class="o">=</span> <span class="n">MongoClient</span><span class="p">(</span><span class="s">"localhost"</span><span class="p">,</span> <span class="mi">27017</span><span class="p">)</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">client</span><span class="p">[</span><span class="s">"stack_questions"</span><span class="p">]</span>
    <span class="n">coll</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="s">"questions"</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s">".//entry"</span><span class="p">):</span>
        <span class="n">author</span> <span class="o">=</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s">".//author/name/text()"</span><span class="p">))</span>
        <span class="n">link</span> <span class="o">=</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s">"././/link/@href"</span><span class="p">))</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s">"./title/text()"</span><span class="p">))</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c"># links should be unique</span>
            <span class="c"># using them as _id will ensure we will</span>
            <span class="c"># not insert duplicate entries</span>
            <span class="s">"_id"</span><span class="p">:</span> <span class="n">sha224</span><span class="p">(</span><span class="n">link</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(),</span>
            <span class="s">"author"</span><span class="p">:</span> <span class="n">author</span><span class="p">,</span>
            <span class="s">"link"</span><span class="p">:</span> <span class="n">link</span><span class="p">,</span>
            <span class="s">"title"</span><span class="p">:</span> <span class="n">title</span><span class="p">,</span>
            <span class="s">"fetched"</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="p">())</span>
        <span class="p">}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">coll</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">DuplicateKeyError</span><span class="p">:</span>
            <span class="c"># we alredy have this entry in db</span>
            <span class="c"># so stop, no need to parse rest of xml doc</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">questions_data</span></code></pre></div>

<p>The script simply visits feed and extracts title, link and author
of the post, it then stores this data into MongoDB. We use hash of
link <a href="http://docs.mongodb.org/manual/reference/glossary/#term-objectid">as object id</a> to ensure that duplicate records are not inserted
into collection. When you try to insert duplicate id mongodb will raise
exception. If this happens we know that we encountered post that we already 
have in database, and we can safely stop parsing remaining questions.</p>

<p>You can call ‘questions’ function, run it normally and perhaps
print some results to see if it works ok.</p>

<h2 id="scheduling-our-client-at-regular-intervals">Scheduling our client at regular intervals</h2>

<p>Now we would like to be able to run our script
at regular intervals. As usual there are many ways to do this.
You could set it up as cron job, you could use Python’s time.sleep(). 
I’m going to use Celery. Celery is  an asynchronous task runner, 
it allows you to turn your function into a task that will be executed in the 
background. It will nicely handle all problems with your script, 
it can retry task, report problems log what happens etc. 
Running your process in the background and having something that
manages is properly is huge benefit, your server app can just forget about
this task, it can do its thing as it normally does without minding task 
running in the background.</p>

<p>Turning our Stack scraper into Celery task is easy, we just need to create 
Celery app instance and decorate our task with Celery ‘task’ decorator.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># stack_scrap.py</span>

<span class="kn">from</span> <span class="nn">celery</span> <span class="kn">import</span> <span class="n">Celery</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Celery</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config_from_object</span><span class="p">(</span><span class="s">"celeryconfig"</span><span class="p">)</span>

<span class="nd">@app.task</span>
<span class="k">def</span> <span class="nf">questions</span><span class="p">():</span>
    <span class="n">feed_url</span> <span class="o">=</span> <span class="s">"http://stackoverflow.com/feeds"</span>
    <span class="c"># rest of our code stays the same</span></code></pre></div>

<p>Now we need to add Celerybeat schedule that will ensure
that our task is scheduled every 30 seconds. We’ll use following Celery config:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># celeryconfig.py</span>

<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">timedelta</span>

<span class="n">CELERYBEAT_SCHEDULE</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">"poll_SO"</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">"task"</span><span class="p">:</span> <span class="s">"stack_scrap.questions"</span><span class="p">,</span>
        <span class="s">"schedule"</span><span class="p">:</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">30</span><span class="p">),</span>
        <span class="s">"args"</span><span class="p">:</span> <span class="p">[]</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>You need to call it with</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">&gt; celery -A stack_scrap worker -B --loglevel<span class="o">=</span>INFO</code></pre></div>

<p>You should see in logs that Celery is up and running, scheduling task
at regular invervals:</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">[</span>2015-02-15 19:20:37,511: INFO/Beat<span class="o">]</span> Scheduler: Sending due task poll_SO <span class="o">(</span>stack_scrap.questions<span class="o">)</span>
<span class="o">[</span>2015-02-15 19:20:37,528: INFO/MainProcess<span class="o">]</span> Received task: stack_scrap.questions<span class="o">[</span>bba18f4d-ada6-4efa-a490-7fa1e355223d<span class="o">]</span></code></pre></div>

<p>If you open mongo shell and check yout ‘questions’ collection in ‘stack_questions’
database you’ll see new posts inserted.</p>

<h2 id="create-web-app">Create web app</h2>
<p>We now have a script that pings Stack Overflow and checks if there are 
new questions in xml feed. It’s time to actually display results
in a browser.</p>

<p>First we need a server that will server some static assets 
(our index.html and js) and will return posts from database.
This can be written with CherryPy in a matter of minutes,
what is cool about CherryPy is that it looks like plain old
python, it doesn’t read like a framework at all.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">json</span>

<span class="kn">from</span> <span class="nn">pymongo</span> <span class="kn">import</span> <span class="n">MongoClient</span>
<span class="kn">import</span> <span class="nn">cherrypy</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">path</span><span class="p">,</span> <span class="n">curdir</span>

<span class="k">class</span> <span class="nc">StackMirror</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">MongoClient</span><span class="p">(</span><span class="s">"localhost"</span><span class="p">,</span> <span class="mi">27017</span><span class="p">)[</span><span class="s">"stack_questions"</span><span class="p">]</span>

    <span class="nd">@cherrypy.expose</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">file</span><span class="p">(</span><span class="s">"index.html"</span><span class="p">)</span>

    <span class="nd">@cherrypy.expose</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">coll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="s">"questions"</span><span class="p">]</span>
        <span class="n">records</span> <span class="o">=</span> <span class="n">coll</span><span class="o">.</span><span class="n">find</span><span class="p">({</span><span class="s">"fetched"</span><span class="p">:</span> <span class="p">{</span><span class="s">"$gt"</span><span class="p">:</span><span class="n">timestamp</span><span class="p">}})</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
                    <span class="s">"fetched"</span><span class="p">,</span> <span class="n">direction</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">records</span><span class="p">])</span>

<span class="n">cherrypy</span><span class="o">.</span><span class="n">quickstart</span><span class="p">(</span><span class="n">StackMirror</span><span class="p">(),</span> <span class="s">"/"</span><span class="p">,</span> <span class="p">{</span> <span class="s">"/static"</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s">"tools.staticfile.on"</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
                        <span class="s">"tools.staticfile.filename"</span> <span class="p">:</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">curdir</span><span class="p">),</span> <span class="s">"realtime.js"</span><span class="p">)}})</span></code></pre></div>

<p>You can start our app just like you’d run any other python script, 
this is all you need to start it</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">&gt; ~/github_blog/pawelmhm.github.io/_code<span class="nv">$ </span>python site.py 
<span class="o">[</span>15/Feb/2015:19:51:31<span class="o">]</span> ENGINE Listening <span class="k">for</span> SIGHUP.
<span class="o">[</span>15/Feb/2015:19:51:31<span class="o">]</span> ENGINE Listening <span class="k">for</span> SIGTERM.
<span class="o">[</span>15/Feb/2015:19:51:31<span class="o">]</span> ENGINE Listening <span class="k">for</span> SIGUSR1.
<span class="o">[</span>15/Feb/2015:19:51:31<span class="o">]</span> ENGINE Bus STARTING
<span class="o">[</span>15/Feb/2015:19:51:31<span class="o">]</span> ENGINE Started monitor thread <span class="s1">'Autoreloader'</span>.
<span class="o">[</span>15/Feb/2015:19:51:31<span class="o">]</span> ENGINE Started monitor thread <span class="s1">'_TimeoutMonitor'</span>.
<span class="o">[</span>15/Feb/2015:19:51:31<span class="o">]</span> ENGINE Serving on http://127.0.0.1:8080
<span class="o">[</span>15/Feb/2015:19:51:31<span class="o">]</span> ENGINE Bus STARTED</code></pre></div>

<h2 id="finally-lets-add-some-javascript">Finally let’s add some JavaScript</h2>

<p>Now that our server is listening for connections we can add some client
site code. We need a way to update index.html page with results of our crawl.
How a browser is going to get results that are up to date? We don’t
want to just click refresh, our app has to be realtime. Users don’t like
to click refresh, they can forget about clicking refresh and loose some 
crucial content. One solution would be websockets, other easier solution
would involve using JavaScript setTimeout and just repeatingly calling 
our server /update endpoint.</p>

<p>Our client-side code will send ajax GET request to /update endpoint with
timestamp as sole parameter. When the page first loads timestamp will be
set to zero and script will fetch all results from database. After
fetching results it will append them to DOM and add ‘modified’ attribute
to div. In subsequent calls it will take value of ‘modified’ attribute and use 
it to query server. So our JS should essentialy say something like:
“hey, server, give me all results fetched after I last updated DOM”.
If server doesn’t have anything it will respond with blank answer and
script will do nothing, if there are some new questions fetched by our
celery stack scraper it will append them to DOM, and refresh ‘modified’
atribute.</p>

<p>Polling part will look like this:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">doPoll</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">({</span>
        <span class="nx">url</span><span class="o">:</span> <span class="s2">"update"</span><span class="p">,</span>
        <span class="nx">data</span><span class="o">:</span> <span class="p">{</span>
            <span class="s2">"timestamp"</span><span class="o">:</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">'#realtime'</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="s2">"modified"</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span>
        <span class="p">}</span>
    <span class="p">}).</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">append_to_dom</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">}).</span><span class="nx">always</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">doPoll</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>
    <span class="p">})</span>
<span class="p">}</span></code></pre></div>

<p>We’ll use jQuery <a href="http://api.jquery.com/deferred.always/">always</a> so that the 
code will set timeouts even in case of failures.</p>

<p>Part appending to DOM is rather typical, you could use some js templates, 
like Mustache to make code cleaner and more readable, generating DOM
from string is probably bad practice but we’ll do this here for the
sake of simplicity.</p>

<p>Full JavaScript code:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// realtime.js</span>
<span class="s2">"use strict"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">append_to_dom</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">blocks</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">question</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">block</span> <span class="o">=</span> <span class="s2">"&lt;div class='row'&gt;&lt;div&gt;&lt;span&gt;&lt;a href='"</span> <span class="o">+</span> <span class="nx">question</span><span class="p">.</span><span class="nx">link</span><span class="p">;</span>
        <span class="nx">block</span> <span class="o">+=</span> <span class="s2">"'&gt;"</span> <span class="o">+</span> <span class="nx">question</span><span class="p">.</span><span class="nx">title</span> <span class="o">+</span> <span class="s2">"&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;"</span><span class="p">;</span>
        <span class="nx">block</span> <span class="o">+=</span> <span class="s2">"&lt;div&gt;&lt;small&gt;"</span> <span class="o">+</span> <span class="nx">question</span><span class="p">.</span><span class="nx">author</span> <span class="o">+</span> <span class="s2">" "</span>
        <span class="nx">block</span> <span class="o">+=</span> <span class="nx">question</span><span class="p">.</span><span class="nx">fetched</span> <span class="o">+</span> <span class="s2">"&lt;/small&gt;&lt;/div&gt;&lt;/div&gt;"</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">block</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="nx">$</span><span class="p">(</span><span class="s2">"#realtime"</span><span class="p">).</span><span class="nx">prepend</span><span class="p">(</span><span class="nx">blocks</span><span class="p">).</span><span class="nx">hide</span><span class="p">().</span><span class="nx">fadeIn</span><span class="p">();</span>
    <span class="nx">$</span><span class="p">(</span><span class="s2">"#realtime"</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="s2">"modified"</span><span class="p">,</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">());</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">doPoll</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">({</span>
        <span class="nx">url</span><span class="o">:</span> <span class="s2">"update"</span><span class="p">,</span>
        <span class="nx">data</span><span class="o">:</span> <span class="p">{</span>
            <span class="s2">"timestamp"</span><span class="o">:</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">'#realtime'</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="s2">"modified"</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span>
        <span class="p">}</span>
    <span class="p">}).</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">append_to_dom</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">}).</span><span class="nx">always</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">doPoll</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>
    <span class="p">})</span>
<span class="p">}</span>


<span class="nx">$</span><span class="p">(</span><span class="nb">document</span><span class="p">).</span><span class="nx">ready</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">doPoll</span><span class="p">();</span>
<span class="p">})</span></code></pre></div>

<p>At this point it’s ready, you should start your celery scraper,
launch python site, and you’ll see SO questions displayed.</p>

  </article>

</div></body></html>