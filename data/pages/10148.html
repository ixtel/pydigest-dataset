<html><body><div><div class="post-text" itemprop="text">
<p>You don't need to do anything complicated with exceptions. To think that you do is what creates the problem. What you actually need (my guess, because as other said it's not so clear) is to <em>process</em> the returned values of <code>numGen</code>, and do something (maybe, raising an exception) based on them.</p>

<p>Once you phrase your goal this way, it's clear that you need something much simpler. Just a decorator which stores all the "wrong" values returned by <code>numGen</code> (according to your definition of what's wrong) and allows you to process them later. So here is my solution:</p>

<pre><code># Using a class as a decorator, so you can easily access its .wrong_values attribute
class ErrorHandler:
     def __init__(self, func):
         self.func = func
         self.wrong_values = []

     def __call__(self, arg):
         # Remove the first line if you want to keep wrong values from previous calls
         self.wrong_values.clear()
         result = self.func(arg)
         self.register_errors(result)
         return result

     def register_errors(self, result):
         wrong_values = [(k, v) for k, v in result.iteritems() if v % 2]
         self.wrong_values += wrong_values

@ErrorHandler
def numGen(input):
    from random import randint
    # You say you want 10 numbers, so the argument to range should be 10
    # And you can use dict-comp, which requires only one line and is faster
    return {i: randint(0, 4) + input for i in range(10)}

if __name__ == '__main__':
    print 'result', numGen(4)
    print 'wrong values', numGen.wrong_values
</code></pre>

<p>When I run this, I get</p>

<pre><code>result {0: 4, 1: 8, 2: 6, 3: 8, 4: 7, 5: 5, 6: 6, 7: 5, 8: 6, 9: 5}
wrong values [(4, 7), (5, 5), (7, 5), (9, 5)]
</code></pre>

<p>Now you have easy access to <code>numGen.wrong_values</code>; do whatever you want with them.</p>

<p>Looking back at your problem statement:</p>

<blockquote>
  <p>Problem statement:</p>
  
  <p>I am not able to iterate over the dictionary in a try block, So I am
  not able catch specific error.</p>
</blockquote>

<p>Not a problem because you don't need a <code>try</code> block.</p>

<blockquote>
  <p>How to aggregate exceptions by creating an aggregated exception, like
  MyExceptionsCollection, that would hold the array and raise it instead
  of printing.</p>
</blockquote>

<p>I have no idea what it is to aggregate exceptions. I think it's more sensible to collect values and raise an exception (or whatever) from the collected values. This is achieved.</p>

<blockquote>
  <p>How to reraise exact exception or all exceptions that were occurred</p>
</blockquote>

<p>Again, this is an artificial problem created by thinking that you have to raise exceptions first in order to "aggregate" them. You don't. Instead you aggregate values and process them.</p>

<blockquote>
  <p>Note: Implementation has to use 2 decorators one for generating errors
  and catching errors. Because I will have 200- 250 functions, I need to
  check error for all this functions</p>
</blockquote>

<p>I don't see the need for two decorators. If you have different error-catching logic for different functions, just subclass <code>ErrorHandler</code> and override the <code>register_errors</code> method. (One more advantage of using a class, rather than a function, as a decorator.)</p>
    </div>
    </div></body></html>