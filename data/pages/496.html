<html><body><div><div class="post-body entry-content" id="post-body-2693920742259622657" itemprop="description articleBody">
<div dir="ltr" trbidi="on">
<p>
Когда я закончил работу над </p><a href="http://alemeshev.blogspot.com/2014/02/raspoznaiemtekstnapython.html" target="_blank">скриптом для распознавания текста</a><p> то столкнулся с неожиданной проблемой. Дело в том что компьютер на котором его планировалось запускать работает под управлением ОС Windows и у оператора нет возможности установить python и необходимые библиотеки. Я столкнулся с таким препятствием впервые так как раньше мои скрипты применялись только на компьютерах с *nix системами, а там поставить все необходимое из репозитория не проблема. Решить вопрос я смог при помощи cx_Freeze. Свой опыт по его использованию я решил изложить в этом небольшом мануале.
</p><a name="more"/>
<b>Анамнез</b>
<b><br/></b><p>
cx_Freeze это набор скриптов и модулей для сборки поставки приложения из python скриптов. Является прямым конкурентом py2exe и py2app в отличии от них является кросс-платформенным и потенциально способен работать на любой платформе на которой работает сам python.
</p><p>
Фреймворк опубликован под лицензией </p><a href="http://docs.python.org/2/license.html" target="_blank">PSF</a><p>.

</p><b>Рецепт</b>
<p>
Первое что вам потребуется сделать -  установить пакет cx_Freez. Проще всего это можно сделать при помощи pip.</p><p>
После этого, в папке скрипта который должен быть собран, необходимо создать скрипт сценария сборки. По конвенции он может иметь любое имя, я же назвал свой "setup.py". Ниже приведен пример скрипта сборки для проекта </p><a href="https://github.com/andrey-stekov/sketches/tree/master/python/dummy_ocr" target="_blank">Dummy OCR</a><p>:
</p><p>


Параметры компиляции могут быть установлены как атрибуты конструктора объекта Executable. Также некоторые из них можно передать через словарь из параметров (в примере build_exe_options). Ниже рассмотрены основные опции компиляции приложения и описание:

</p><table border="1" cellspacing="0">
<tbody>
<tr>
  <td>Название опции</td>
  <td>Описание</td>
</tr>
<tr>
  <td>script</td>
  <td>Имя файла скрипта. <span>Нельзя передать через словарь параметров.</span></td>
</tr>
<tr>
  <td>initScript</td>
  <td>Инициализирующий скрипт. Будет выполнятся перед выполнением основного скрипта. Как правило применяется для конфигурации окружения. <span>Нельзя передать через словарь параметров.</span></td>
</tr>
<tr>
  <td>base</td>
  <td>Тип приложения. По факту имя исполняемого файла-болванки для целевой платформы который будет использован. Можно задать свой но записав абсолютный путь, иначе путь следует указывать начиная от поддиректории cx_Freeze.<br/>
Для Windows из коробки поддерживаются следующие варианты: 
  <br/>
<ul>
<li>Console</li>
<li>Win32GUI</li>
<li>Win32Service</li>
</ul>
<span>Нельзя передать через словарь параметров.
</span></td>
</tr>
<tr>
  <td>path</td>
  <td>Список путей где будет проводится поиск. <span>Нельзя передать через словарь параметров.</span></td>
</tr>
<tr>
  <td>targetDir</td>
  <td>Имя директории с билдом. <span>Нельзя передать через словарь параметров.</span></td>
</tr>
<tr>
  <td>targetName</td>
  <td>Имя исполняемого файла. <span>Нельзя передать через словарь параметров.</span></td>
</tr>
<tr>
  <td>includes</td>
  <td>Список модулей включенных в компиляцию.</td>
</tr>
<tr>
  <td>excludes</td>
  <td>Список модулей исключенных из компиляции.</td>
</tr>
<tr>
  <td>packages</td>
  <td>Список пакетов включенных в компиляцию.</td>
</tr>
<tr>
  <td>replacePaths</td>
  <td>Модифицирует имена файлов привязанных к объектам в коде при выводе в tracebacks. Принимает список кортежей состоящих из двух элементов "путь который следует найти" и "путь который следует заменить". При поиске по ‘*’ обработает директорию содержащую весь пакет за исключением относительного пути к модулю.</td>
</tr>
<tr>
  <td>compress</td>
  <td>Флаг - сжимать байт-код модулей.</td>
</tr>
<tr>
  <td>copyDependentFiles</td>
  <td>Флаг - копировать зависимые файлы в сборку.</td>
</tr>
<tr>
  <td>appendScriptToExe</td>
  <td>Флаг - указывает на необходимость включить скрипт непосредственно в тело исполняемого файла.</td>
</tr>
<tr>
  <td>appendScriptToLibrary</td>
  <td>Флаг - указывает на необходимость включить скрипт в архив библиотек сборки.</td>
</tr>
<tr>
  <td>icon</td>
  <td>Имя файла-иконки который должен быть включен в исполняемый файл для Windows приложения, или помещен в директорию сборки для других платформ.</td>
</tr>
<tr>
  <td>namespacePackages</td>
  <td>Список неймспейс-пакетов (их пути изменены при помощи <a href="http://docs.python.org/2/library/pkgutil.html" target="_blank">pkgutil</a>)</td>
</tr>
<tr>
  <td>shortcutName</td>
  <td>Имя ярлыка исполняемого файла в случае включения в MSI-пакет.</td>
</tr>
<tr>
  <td>shortcutDir</td>
  <td>Имя директории в которой будет расположен ярлык после установки MSI-пакета.</td>
</tr>
</tbody>
</table>
<p>
После создания сборочного скрипта вам достаточно запустить его передав необходимую команду. К примеру:

</p><pre>python setup.py build</pre><p>
На данный момент поддерживаются следующие команды:

</p><table border="1" cellspacing="0">
<tbody>
<tr>
  <td>Команда</td>
  <td>Описание</td>
</tr>
<tr>
  <td>build, build_exe</td>
  <td>Собрать проект.</td>
</tr>
<tr>
  <td>install, install_exe</td>
  <td>Собрать набор exe-файлов. Применяется для установки Windows и RPM пакетов.</td>
</tr>
<tr>
  <td>bdist_msi</td>
  <td>Создать MSI-пакет.</td>
</tr>
<tr>
  <td>bdist_rpm</td>
  <td>Собрать RPM-пакет.</td>
</tr>
<tr>
  <td>bdist_mac</td>
  <td>Собрать приложение для Mac OS (.app - директорию).</td>
</tr>
<tr>
  <td>bdist_dmg</td>
  <td>Собрать DMG-образ диска для инсталляции на Mac OS.</td>
</tr>
</tbody>
</table>
<p>
Каждая из этих команд может быть сконфигурированна своим набором параметров. Ознакомится с ними можно на официальном </p><a href="http://cx-freeze.readthedocs.org/en/latest/distutils.html#distutils-commands" target="_blank">сайте</a><p>.

</p><b>Почему не py2exe</b>
<p>
Py2exe был отличной утилитой но к сожалению не обновлялся с 2008-го года. Посему я решил попробовать нечто более актуальное. Хотя </p><a href="http://www.py2exe.org/index.cgi/Tutorial#Step52" target="_blank">официальный туториал утверждает</a><p> о наличии поддержки версий языка вплоть до 3.1.

</p><b>Ссылки</b>

<a href="http://cx-freeze.readthedocs.org/en/latest/index.html" target="_blank">Официальный сайт.</a>
<a href="https://bitbucket.org/anthony_tuininga/cx_freeze/src/52b63b329684?at=default" target="_blank">Репозиторий на BitBucket.</a></div>
<p/>
</div>
</div></body></html>