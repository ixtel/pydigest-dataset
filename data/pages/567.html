<html><body><div><div class="entry-content" itemprop="text"><p>I’ve written previously about the mechanics of <a href="http://www.garysieling.com/blog/building-decision-tree-python-postgres-data">building decision trees</a>: extract data from some system, build a model on it, then save the model in a file for later:</p>
<p><a href="http://www.garysieling.com/blog/wp-content/uploads/2014/03/tree-output.png"><img src="//www.garysieling.com/blog/wp-content/uploads/2014/03/tree-output-578x324.png" alt="tree-output" class="aligncenter size-large wp-image-2130" srcset="//www.garysieling.com/blog/wp-content/uploads/2014/03/tree-output-300x168.png 300w, //www.garysieling.com/blog/wp-content/uploads/2014/03/tree-output-578x324.png 578w, //www.garysieling.com/blog/wp-content/uploads/2014/03/tree-output.png 1046w" sizes="(max-width: 578px) 100vw, 578px"/></a></p>
<p>Once you get that far, you’ll likely find that you want to try different models or change the parameters on the ones you’re using.</p>
<p>Ideally, you want to write code like this, which runs several different experiments in sequence, saving the results to a file:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python">args <span>=</span> <span>{</span><span>'criterion'</span>: <span>'entropy'</span><span>,</span> <span>'max_depth'</span>: <span>5</span><span>,</span> <span>'min_samples_split'</span>: <span>10</span><span>}</span>
createModels<span>(</span>treeParams<span>=</span>args<span>,</span> folds <span>=</span> <span>3</span><span>)</span>
 
args <span>=</span> <span>{</span><span>'criterion'</span>: <span>'entropy'</span><span>,</span> <span>'max_depth'</span>: <span>10</span><span>,</span> <span>'min_samples_split'</span>: <span>10</span><span>}</span>
createModels<span>(</span>treeParams<span>=</span>args<span>,</span> folds <span>=</span> <span>3</span><span>)</span>
 
args <span>=</span> <span>{</span><span>'criterion'</span>: <span>'entropy'</span><span>,</span> <span>'max_depth'</span>: <span>15</span><span>,</span> <span>'min_samples_split'</span>: <span>10</span><span>}</span>
createModels<span>(</span>treeParams<span>=</span>args<span>,</span> folds <span>=</span> <span>3</span><span>)</span></pre></td></tr></table></div>
<p>Once you start running experiments, you’ll get loads of files, so it’s important to name them based on what you’re running. Having saved off the results, you’ll be able to save models in source control and keep a permanent record of what experiments you ran.</p>
<p>Like unit tests, you can write out the results of accuracy tests as well, which lets you see how well you’re doing.</p>
<p><a href="http://www.garysieling.com/blog/wp-content/uploads/2014/03/trees.png"><img src="//www.garysieling.com/blog/wp-content/uploads/2014/03/trees-578x235.png" alt="trees" class="aligncenter size-large wp-image-2127" srcset="//www.garysieling.com/blog/wp-content/uploads/2014/03/trees-300x122.png 300w, //www.garysieling.com/blog/wp-content/uploads/2014/03/trees-578x235.png 578w, //www.garysieling.com/blog/wp-content/uploads/2014/03/trees.png 779w" sizes="(max-width: 578px) 100vw, 578px"/></a></p>
<p>To make the filing system clear, the key is to take a python dictionary and turn it into a file name. With that in hand, we <a href="http://www.garysieling.com/blog/convert-scikit-learn-decision-trees-json">convert the model to JSON</a>, and write it and the test results to a file.</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>def</span> save<span>(</span>trees<span>,</span> features<span>,</span> args<span>)</span>:
  <span>print</span> <span>"Saving..."</span>
  idx <span>=</span> <span>0</span>
  params <span>=</span> <span>""</span>
  <span>for</span> k <span>in</span> <span>sorted</span><span>(</span>args.<span>keys</span><span>(</span><span>)</span><span>)</span>:
    params <span>=</span> params + k + <span>"-"</span> + <span>str</span><span>(</span>args<span>[</span>k<span>]</span><span>)</span> + <span>" "</span>
 
  <span>for</span> t<span>,</span> report <span>in</span> trees:
    f <span>=</span> <span>open</span><span>(</span><span>'D:<span>\\</span>projects<span>\\</span>tree<span>\\</span>tree '</span> + params + \
             <span>" fold "</span> + <span>str</span><span>(</span>idx<span>)</span> + <span>".json"</span><span>,</span> <span>'w'</span><span>)</span>
    f.<span>write</span><span>(</span>report<span>)</span>
    f.<span>write</span><span>(</span>treeToJson<span>(</span>t<span>,</span> features<span>)</span><span>)</span>
    f.<span>close</span><span>(</span><span>)</span>
    idx <span>=</span> idx + <span>1</span></pre></td></tr></table></div>
<p>When we define the createModels function, it forces us to define and extract what this model-building process requires – for instance, what database tables to pull data from, a function to extract the value we want to predict, and how many folds we want to run.</p>
<p>The database operation in particular can be pretty heavy (pulling hundreds of thousands of records into memory), so memoization is key here.</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>def</span> createModels<span>(</span>treeParams <span>=</span> <span>None</span><span>,</span> folds <span>=</span> <span>None</span><span>,</span> _cache <span>=</span> <span>{</span><span>}</span><span>)</span>:
  <span>print</span> <span>"Creating models..."</span>
 
  <span>def</span> f<span>(</span>a<span>)</span>:
    <span>if</span> <span>'&gt;'</span> <span>in</span> a:
      <span>return</span> <span>1</span>
    <span>else</span>:
      <span>return</span> <span>0</span>
 
  <span>if</span> <span>len</span><span>(</span>_cache<span>)</span> <span>==</span> <span>0</span>:
    _cache<span>[</span><span>'data'</span><span>]</span><span>,</span> _cache<span>[</span><span>'outputs'</span><span>]</span> <span>=</span> \
      extract<span>(</span><span>'income_trn'</span><span>,</span> f<span>,</span> <span>'category'</span><span>)</span>
    _cache<span>[</span><span>'intData'</span><span>]</span><span>,</span> _cache<span>[</span><span>'features'</span><span>]</span> <span>=</span> \
      transform<span>(</span>_cache<span>[</span><span>'data'</span><span>]</span><span>,</span>  _cache<span>[</span><span>'outputs'</span><span>]</span><span>)</span>
 
  trees <span>=</span> runTests<span>(</span>_cache<span>[</span><span>'intData'</span><span>]</span><span>,</span> _cache<span>[</span><span>'outputs'</span><span>]</span><span>,</span> \
                   treeParams<span>,</span> folds<span>)</span>
  save<span>(</span>trees<span>,</span> _cache<span>[</span><span>'features'</span><span>]</span><span>,</span> treeParams<span>)</span></pre></td></tr></table></div>
<p>In any project where you reshape real data, you typically spend an inordinate amount of time on data transformations, and much less on fun steps like model training or performance tuning. This I’ve found true whether you do machine learning, data warehousing, or data migration projects.</p>
<p>Fortunately most commercial products and libraries that work in those areas provide utilities for common operations, and this is an area where scikit-learn really shines.</p>
<p>For instance, when we run tests we might train the model on 75% of the data, then validate it on 25% of the data. There are different strategies like this, but in this case I’d like to do that four times (each time removing a different 25% of the data). If I had to write the code to do that, it would be a pain – one more source of defects.</p>
<p>Scikit-learn, provide around a half dozen different implementations for splitting data, so if you run into a problem, chances are all you need to do is change which class you instantiate in the cross_validation package:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>def</span> runTests<span>(</span>intData<span>,</span> classify<span>,</span> treeParams<span>,</span> folds<span>)</span>:
  <span>print</span> <span>"Testing data..."</span>
 
  rs <span>=</span> cross_validation.<span>ShuffleSplit</span><span>(</span><span>len</span><span>(</span>intData<span>)</span><span>,</span> n_iter<span>=</span>folds<span>,</span>
    test_size<span>=</span><span>.25</span><span>,</span> random_state<span>=</span><span>0</span><span>)</span>
 
  foldNumber <span>=</span> <span>1</span>
  trees <span>=</span> <span>[</span><span>]</span>
  <span>for</span> train_index<span>,</span> test_index <span>in</span> rs:
    <span>print</span> <span>"Fold %s..."</span> % <span>(</span>foldNumber<span>)</span>
    train_data <span>=</span> <span>[</span>intData<span>[</span>idx<span>]</span> <span>for</span> idx <span>in</span> train_index<span>]</span>
    test_data <span>=</span> <span>[</span>intData<span>[</span>idx<span>]</span> <span>for</span> idx <span>in</span> test_index<span>]</span>
 
    train_v <span>=</span> <span>[</span>classify<span>[</span>idx<span>]</span> <span>for</span> idx <span>in</span> train_index<span>]</span>
    test_v <span>=</span> <span>[</span>classify<span>[</span>idx<span>]</span> <span>for</span> idx <span>in</span> test_index<span>]</span>
 
    clf <span>=</span> tree.<span>DecisionTreeClassifier</span><span>(</span>**treeParams<span>)</span>
    clf <span>=</span> clf.<span>fit</span><span>(</span>train_data<span>,</span> train_v<span>)</span>
 
    predictions <span>=</span> <span>[</span>clf.<span>predict</span><span>(</span>r<span>)</span><span>[</span><span>0</span><span>]</span> <span>for</span> r <span>in</span> test_data<span>]</span>
    report <span>=</span> classification_report<span>(</span>test_v<span>,</span> predictions<span>)</span>
 
    trees.<span>append</span><span>(</span> <span>(</span>clf<span>,</span> report<span>)</span> <span>)</span>
    foldNumber <span>=</span> foldNumber + <span>1</span>
 
  <span>return</span> trees</pre></td></tr></table></div>
<p>Similarly, one of the painful parts of the tree implementation is figuring out how to use data that has both text and numeric attributes. This is a specific case of the general problem of transforming data, and scikit-learn has dozens of classes to help in this area.</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>def</span> transform<span>(</span>measurements<span>,</span> classify<span>)</span>:
  <span>print</span> <span>"Transforming data..."</span>
 
  vec <span>=</span> DictVectorizer<span>(</span><span>)</span>
  intData <span>=</span> vec.<span>fit_transform</span><span>(</span>measurements<span>)</span>.<span>toarray</span><span>(</span><span>)</span>
  featureNames <span>=</span> vec.<span>get_feature_names</span><span>(</span><span>)</span>
 
  <span>return</span> intData<span>,</span> featureNames</pre></td></tr></table></div>
<p>As a digression, there is an interesting technical problem that lies hidden under the surface of the API. Trees specifically require that you make all your rows of data arrays of numbers – while this is very frustrating when you come in with strings, this is by design and not by accident and the code below using DictVectorizer will transform the data as you need.</p>
<p>When I first began researching python for data analysis, I was doing a broad search for tools, products, and libraries that might replace parts of the SQL + Relational database ecosystem. This includes tools that fall under the NoSQL umbrella, like Cassandra, Hadoop, and Solr, but also some ETL and data wrangling tools, like R, SAS, Informatica, and python.</p>
<p>If someone specifically wanted to avoid SQL as a language, for instance, there are quite a few options: swap in a different database underneath, use an ORM library to not have to see SQL, or use some sort of in-memory structure.</p>
<p>The python ORM (sqlalchemy) is quite nice for the purposes used in this article, as we can trivially read an entire table into RAM, converting each row into a dictionary:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>def</span> extract<span>(</span>tableName<span>,</span> resultXForm<span>,</span> resultColumn<span>)</span>:
  <span>print</span> <span>"Loading from database..."</span>
 
  <span>from</span> sqlalchemy <span>import</span> create_engine<span>,</span> MetaData<span>,</span> Table
  <span>from</span> sqlalchemy.<span>sql</span> <span>import</span> <span>select</span>
  engine <span>=</span> create_engine<span>(</span>
                <span>"postgresql+pg8000://postgres:postgres@localhost/pacer"</span><span>,</span>
                isolation_level<span>=</span><span>"READ UNCOMMITTED"</span>
            <span>)</span>
  conn <span>=</span> engine.<span>connect</span><span>(</span><span>)</span>
  meta <span>=</span> MetaData<span>(</span><span>)</span>
 
  table <span>=</span> Table<span>(</span>tableName<span>,</span> meta<span>,</span> autoload<span>=</span><span>True</span><span>,</span> autoload_with<span>=</span>engine<span>)</span>
 
  <span>def</span> toDict<span>(</span>row<span>,</span> columns<span>)</span>:
    <span>return</span> <span>{</span>columns<span>[</span>i<span>]</span>: x <span>for</span> i<span>,</span> x <span>in</span> <span>enumerate</span><span>(</span>row<span>)</span> \
      <span>if</span> columns<span>[</span>i<span>]</span> <span>!=</span> resultColumn<span>}</span>
 
  s <span>=</span> <span>select</span><span>(</span><span>[</span>table<span>]</span><span>)</span>
  result <span>=</span> conn.<span>execute</span><span>(</span>s<span>)</span>
 
  columns <span>=</span> <span>[</span>c.<span>name</span> <span>for</span> c <span>in</span> table.<span>columns</span><span>]</span>
  resultIdx <span>=</span> columns.<span>index</span><span>(</span>resultColumn<span>)</span>
 
  data <span>=</span> <span>[</span><span>[</span>c <span>for</span> c <span>in</span> row<span>]</span> <span>for</span> row <span>in</span> result<span>]</span>
  split <span>=</span> <span>[</span>toDict<span>(</span>row<span>,</span> columns<span>)</span> <span>for</span> row <span>in</span> data<span>]</span>
  classes <span>=</span> <span>[</span>resultXForm<span>(</span>row<span>[</span>resultIdx<span>]</span><span>)</span> <span>for</span> row <span>in</span> data<span>]</span>
  <span>return</span> <span>(</span>split<span>,</span> classes<span>)</span></pre></td></tr></table></div>
<p>There’s lots of code out there that looks like this, and it’s kind of kludgy, because eventually you’ll have so much data you wish you could switch algorithms as it grows, while serializing infrequently used structures to disk…which is exactly what relational databases give you.</p>
<p>One of the key value points of the scientific python stack is <a href="http://www.numpy.org/">NumPy</a>, which bridges a part of that gap (if you read “<a href="http://docs.scipy.org/doc/numpy/reference/internals.html#internal-organization-of-numpy-arrays">NumPy Internals</a>“, it sounds an awful lot like something out of a database textbook).</p>
<p>This internal storage, then, is the reason for the above mentioned issue with Trees: internally, they use a massive array of floats, using NumPy underneath, so that it can be really fast on large datasets. </p>
<p>And with that, with a little bit of effore, we have a script that is almost exactly two hundred lines of code, allowing us to harness hundreds of thousands of engineering and grad student hours to find patterns out in the world. </p>
<p><a href="http://www.garysieling.com/blog/wp-content/uploads/2014/03/conclusion-image.png"><img src="//www.garysieling.com/blog/wp-content/uploads/2014/03/conclusion-image.png" alt="conclusion-image" class="aligncenter size-full wp-image-2138" srcset="//www.garysieling.com/blog/wp-content/uploads/2014/03/conclusion-image-300x285.png 300w, //www.garysieling.com/blog/wp-content/uploads/2014/03/conclusion-image.png 532w" sizes="(max-width: 532px) 100vw, 532px"/></a></p>
</div></div></body></html>