<html><body><div><div class="post-text" itemprop="text">
<p><em>"I would appreciate an answer that explains to me what the problem actually is and if there are ways to fix it."</em></p>

<p>First, let me say that doqtor already answered how to fix the issue -- by ensuring a well-defined destruction time of all used OpenCL resources. IMO, this is not a "hack", but the right thing to do. Trying to rely on static init/cleanup magic to do the right thing -- and watching it fail to do so -- is the real hack!</p>

<p>Second, some thoughts about the issue: the actual problem is even more complex than the common static initialization order fiasco stories. It involves DLL loading/unloading order, both in connection with python loading your custom dll at runtime and (more importantly) with OpenCL's installable client driver (ICD) model. </p>

<p>What DLLs are involved when running an application/dll that uses OpenCL? To the application, the only relevant DLL is the <code>opencl.dll</code> you link against. It is loaded into process memory during application startup time (or when your custom DLL which needs opencl is dynamically loaded in python).
Then, at the time when you first call clGetPlatformInfo() or similar in your code, the ICD logic kicks in: <code>opencl.dll</code> will look for installed drivers (in windows, those are mentioned somewhere in the registry) and dynamically load their respective dlls (using sth like the <code>LoadLibrary()</code> system call). That may be e.g. <code>nvopencl.dll</code> for nvidia, or some other dll for the intel driver you have installed. Now, in contrast to the relatively simple opencl.dll, this ICD dll can and will have a multitude of dependencies on its own -- probably using Intel IPP, or TBB, or whatever. So by now, things have become real messy already.</p>

<p>Now, during shutdown, the windows loader must decide which dlls to unload in which order. When you compile your example in a single executable, the number and order of dlls being loaded/unloaded will certainly be different than in the "python loads your custom dll at runtime" scenario. And that could well be the reason why you experience the problem only in the latter case, and only if you still have an opencl-context+commandqueue alive during shutdown of your custom dll. The destruction of your queue (triggered via clRelease... during static destruction of your testclass instance) is delegated to the intel-icd-dll, so this dll must still be fully functional at that time. If, for some reason, that is not the case (perhaps because the loader chose to unload it or one of the dlls it needs), you crash.</p>

<p>That line of thought reminded me of this article:</p>

<p><a href="https://blogs.msdn.microsoft.com/larryosterman/2004/06/10/dll_process_detach-is-the-last-thing-my-dlls-going-to-see-right/" rel="nofollow">https://blogs.msdn.microsoft.com/larryosterman/2004/06/10/dll_process_detach-is-the-last-thing-my-dlls-going-to-see-right/</a></p>

<p>There's a paragraph, talking about "COM objects", which might be equally applicable to "OpenCL resources":</p>

<p><em>"So consider the case where you have a DLL that instantiates a COM object at some point during its lifetime.  If that DLL keeps a reference to the COM object in a global variable, and doesn’t release the COM object until the DLL_PROCESS_DETACH, then the DLL that implements the COM object will be kept in memory during the lifetime of the COM object.  Effectively the DLL implementing the COM object has become dependant on the DLL that holds the reference to the COM object.  But the loader has no way of knowing about this dependency.  All it knows is that the DLL’s are loaded into memory."</em></p>

<hr/>

<p>Now,  I wrote a lot of words without coming to a definitive proof of what's actually going wrong. The main lesson I learned from bugs like these is: don't enter that snake pit, and do your resource-cleanup in a well-defined place like doqtor suggested. Good night.</p>
    </div>
    </div></body></html>