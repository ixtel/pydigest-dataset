<html><body><div><div class="entry-content"><p>Некоторые не совсем очевидные вещи, с которыми сталкиваются начинающие программисты Python.</p><div class="section" id="unboundlocalerror"><h2>Почему я получаю исключение UnboundLocalError, хотя переменная имеет значение?</h2><p>Может показаться неожиданным получить <tt>UnboundLocalError</tt> в ранее работающем коде, в который добавили операцию присваивания где-то внутри функции.</p><p>Этот код:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="p">()</span>
<span class="go">10</span></pre><p>работает, но следующий код:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span></pre><p>приводит к <tt>UnboundLocalError</tt>:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):
</span>  <span class="c">...</span>
<span class="gr">UnboundLocalError</span>: <span class="n">local variable 'x' referenced before assignment</span></pre><p>Это происходит потому, что, когда вы делаете присваивание переменной в области видимости, она становится локальной в этой области и скрывает другие переменные с таким же именем во внешних областях.</p><p>Когда последняя инструкция в <tt>foo</tt> присваивает новое значение переменной <tt>x</tt>, компилятор решает, что это локальная переменная. Следовательно, когда более ранний <tt>print</tt> пытается напечатать неинициализированную переменную, возникает ошибка.</p><p>В примере выше можно получить доступ к переменной, объявив её глобальной:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foobar</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">global</span> <span class="n">x</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foobar</span><span class="p">()</span>
<span class="go">10</span></pre><p>Это явное объявление требуется для того, чтобы напомнить вам, что (в отличие от внешне аналогичной ситуации с переменными класса и экземпляра), вы на самом деле, изменяете значение переменной во внешней области видимости:</p><pre class="code pycon literal-block">
<span class="k"/><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">11</span></pre><p>Вы можете сделать подобную вещь во вложенной области видимости использованием ключевого слова <tt>nonlocal</tt>:</p><pre class="code pycon literal-block">
<span class="k"/><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">... </span>   <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="gp">... </span>       <span class="n">nonlocal</span> <span class="n">x</span>
<span class="gp">... </span>       <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>       <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>   <span class="n">bar</span><span class="p">()</span>
<span class="gp">... </span>   <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span>
<span class="go">10
11</span></pre></div><div class="section" id="python"><h2>Каковы правила для глобальных и локальных переменных в Python?</h2><p>В Python, переменные, на которые только ссылаются внутри функции, считаются глобальными. Если переменной присваивается новое значение где-либо в теле функции, считается, что она локальная, и, если вам нужно, то нужно явно указывать её глобальной.</p><p>Хотя это немного удивительно на первый взгляд, это легко объяснимо. С одной стороны, требование <tt>global</tt> для присваиваемых переменных предотвращает непреднамеренные побочные эффекты в <tt>bar</tt>. С другой стороны, если <tt>global</tt> был обязательным для всех глобальных ссылок, вы бы использовали global все время. Вы должны были бы объявить как глобальную каждую ссылку на встроенную функцию или компонент импортируемого модуля.</p></div><div class="section" id="lambda"><h2>Почему анонимные функции (lambda), определенные в цикле с разными значениями, возвращают один и тот же результат?</h2><p>Например, вы написали следующий код:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>   <span class="n">squares</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></pre><p>Это даёт вам список из 5 функций, считающих <tt><span class="pre">x**2</span></tt>. Можно ожидать, что, будучи вызванными, они вернут, соответственно, 0, 1, 4, 9, и 16. Однако, вы увидите, что все они возвращают 16:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
<span class="go">16
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">4</span><span class="p">]()</span>
<span class="go">16</span></pre><p>Это случается, поскольку <tt>x</tt> не является локальной для <tt>lambda</tt>, а определена во внешней области видимости, и получается тогда, когда она вызывается - а не когда определяется.</p><p>В конце цикла, <tt>x=4</tt>, поэтому все функции возвращают <tt><span class="pre">4**2</span></tt>, то есть <tt>16</tt>. Это можно также проверить, изменив значение <tt>x</tt> и посмотрев на результат:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
<span class="go">64</span></pre><p>Чтобы избежать подобного, необходимо сохранять значения переменных локально:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>   <span class="n">squares</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="o">=</span><span class="n">x</span><span class="p">:</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></pre><p>Здесь, <tt>n=x</tt> создаёт локальную для функции переменную <tt>n</tt> и вычисляется в момент определения функции:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
<span class="go">4
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">4</span><span class="p">]()</span>
<span class="go">16</span></pre><p class="note container"> Это применимо не только к анонимным, а также и к обычным функциям.</p></div><div class="section" id="id2"><h2>Как организовать совместный доступ к глобальным переменным для нескольких модулей?</h2><p>Канонический способ организовать подобный доступ - это создать отдельный модуль (часто называемый config или cfg). Просто добавьте <tt>import config</tt> в каждый модуль приложения. При этом модуль становится доступен через глобальное имя. Поскольку существует только один экземпляр модуля, любые изменения, произведённые в модуле отражаются везде. Например:</p><p>config.py:</p><pre class="code python3"><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span></pre><p>mod.py:</p><pre class="code python3"><span class="kn">import</span> <span class="nn">config</span>
<span class="n">config</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span></pre><p>main.py:</p><pre class="code python3"><span class="kn">import</span> <span class="nn">config</span>
<span class="kn">import</span> <span class="nn">mod</span>
<span class="nb">print</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">x</span><span class="p">)</span></pre><p>По тем же соображениям, модули можно использовать как основу для имплементации синглтона.</p></div><div class="section" id="id3"><h2>Как правильнее использовать импортирование?</h2><p>В общих случаях не используйте <tt>from modulename import *</tt>. Это засоряет пространство имён того, кто импортирует. Некоторые люди избегают этой идиомы даже для тех немногих модулей, которые были спроектированны, чтобы так импортироваться. Это такие модули как Tkinter и threading.</p><p>Импортируйте модули в начале файла. Это отвечает на вопрос, какие модули требует Ваш код и находится ли имя модуля в области видимости. Запись по одному импорту на строку упрощает добавление и удаление операторов импорта, но множественный импорт будет занимать меньше места на экране.</p><p>Хорошая практика, если Вы импортируете модули в следующем порядке:</p><ul><li>стандартные библиотечные модули (например, sys, os, getopt, re)</li><li>модули сторонних разработчиков (всё, что установлено в директории site-packages) -- например, PIL, NumPy и т.д.</li><li>локально созданные модули</li></ul><p>Иногда бывает необходимо поместить импорт в функцию или класс, чтобы избежать проблем с циклическим импортом. Gordon McMillan советует:</p><p class="note container"> Циклический импорт отлично работает, если оба модуля используют форму <tt>import &lt;module&gt;</tt>. Но они терпят неудачу, когда второй модуль хочет извлечь имя из первого (<tt>from module import name</tt>) и импорт находится на внешнем уровне. Это происходит из-за того, что имена первого модуля ещё недоступны, так как первый модуль занят импортом второго.</p><p>В этом случае, если второй модуль используется только в одной функции, то импорт можно легко поместить в эту функцию. К тому времени, как он будет вызван, первый модуль уже закончит инициализацию и второй модуль осуществит свой импорт.</p><p>Может оказаться необходимым переместить импорт из начала файла, если один из модулей платформно-зависимый. В этом случае импорт всех модулей в начале файла окажется невозможным. В этой ситуации хорошим решением будет импорт нужных модулей в соответствующем платформно-зависимом коде.</p><p>Переносите импорт во вложенные области видимости, такие как определения функций, только если Вы столкнулись с проблемой, например циклического импорта, или если Вы пытаетесь сократить время инициализации модуля.</p><p>Эта техника полезна, если многие из импортов не являются необходимыми, и зависят от того, как программа будет исполняться. Вы также можете поместить импорт в функцию, если конкретные модули используются только в этой функции. Обратите внимание, что загрузить модуль в первый раз может оказаться дорого из-за задержки на инициализацию модуля, однако повторные загрузки "бесплатны", они стоят только пары поисков в словарях. Даже если имя модуля исчезло из области видимости, модуль скорее всего до сих пор находится в <tt>sys.modules</tt>.</p></div><div class="section" id="id4"><h2>Почему значения по умолчанию разделяются между объектами?</h2><p>Этот тип ошибки часто встречается среди начинающих. Предположим, функция:</p><pre class="code python3"><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="p">{}):</span>  <span class="c1"># Опасность: разделяемая ссылка между вызовами</span>
    <span class="o">...</span> <span class="n">compute</span> <span class="n">something</span> <span class="o">...</span>
    <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">mydict</span></pre><p>В первый раз, когда вы вызываете функцию, <tt>mydict</tt> содержит одно значение. Второй раз, <tt>mydict</tt> содержит 2 элемента, поскольку, когда <tt>foo()</tt> начинает выполняться, <tt>mydict</tt> уже содержит элемент.</p><p>Часто ожидается, что вызов функции создаёт новые объекты для значений по умолчанию. Но это не так. Значения по умолчанию создаются лишь однажды, когда функция определяется. Если этот объект изменяется, как словарь в нашем примере, последующие вызовы функции будут использовать изменённый объект.</p><p>По определению, неизменяемые объекты (числа, строки, кортежи и None), безопасны при изменении. Изменение изменяемых объектов, таких как словари, списки, и экземпляры пользовательских классов может привести к неожиданным последствиям.</p><p>Поэтому, хорошей практикой является не использовать изменяемые объекты в качестве значений по умолчанию. Вместо этого, используйте <tt>None</tt> и внутри функции, проверяйте аргумент на <tt>None</tt> и создавайте новый список/словарь. Например, не пишите:</p><pre class="code python3"><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="p">{}):</span>
    <span class="o">...</span></pre><p>Но пишите так:</p><pre class="code python3"><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mydict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mydict</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># create a new dict for local namespace</span></pre><p>Однако, эта особенность может быть полезна. Когда у вас есть функция, которая долго выполняется, часто применяемая техника - кэширование параметров и результата каждого вызова функции:</p><pre class="code python3"><span class="k">def</span> <span class="nf">expensive</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">_cache</span><span class="o">=</span><span class="p">{}):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_cache</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cache</span><span class="p">[(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)]</span>

    <span class="c1"># Расчёт значения</span>
    <span class="n">result</span> <span class="o">=</span> <span class="o">...</span> <span class="n">expensive</span> <span class="n">computation</span> <span class="o">...</span>
    <span class="n">_cache</span><span class="p">[(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span>     <span class="c1"># Кладём результат в кэш</span>
    <span class="k">return</span> <span class="n">result</span></pre></div><div class="section" id="id5"><h2>Как передать опциональные или именованные параметры из одной функции в другую?</h2><p>Получить такие параметры можно с помощью спецификаторов * и ** в списке аргументов функции; они возвращают кортеж позиционных аргументов и словарь именованых параметров. После этого Вы можете передать их в другую функцию, используя в её вызове * и **:</p><pre class="code python3"><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">'width'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'14.3c'</span>
    <span class="o">...</span>
    <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></pre></div><div class="section" id="y-x"><h2>Почему изменение списка 'y' изменяет также список 'x'?</h2><p>Если вы написали код:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">[10]
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">[10]</span></pre><p>вы, возможно, будете удивлены тому, что добавление в <tt>y</tt> изменяет также и <tt>x</tt>.</p><p>Два факта приводят к такому результату:</p><ul><li>Переменные - это просто ссылки на объекты. <tt>y = x</tt> не создаёт копию списка - это просто создаёт переменную <tt>y</tt>, которая ссылается на <b>тот же</b> объект, что и <tt>x</tt>.</li><li>Списки изменяемы.</li></ul><p>После вызова <tt>append</tt>, содержимое объекта было изменено с <tt>[]</tt> на <tt>[10]</tt>. Поскольку <tt>x</tt> и <tt>y</tt> ссылаются на один и тот же объект, использование любого из них даёт нам <tt>[10]</tt>.</p><p>Если мы используем неизменяемые объекты:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># числа неизменяемы</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># 5 нельзя изменить. Мы создаём НОВЫЙ объект</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">6
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">5</span></pre><p>мы можем видеть, что <tt>x</tt> и <tt>y</tt> больше не равны, поскольку числа неизменяемы, и <tt>x = x + 1</tt> не изменяет число 5 путем увеличения. Вместо этого, создаётся новый объект 6 и присваивается переменной <tt>x</tt> (то есть, изменяется то, на какой объект ссылается <tt>x</tt>). После этого у нас 2 объекта (6 и 5) и 2 переменные, которые на них ссылаются.</p><p>Некоторые операции (например <tt>y.append(10)</tt> и <tt>y.sort()</tt>) изменяют объект, в то время, как внешне похожие операции (например <tt>y = y + [10]</tt> и <tt>sorted(y)</tt>) создают новый объект. Вообще в Python (и во всех случаях в стандартной библиотеке), метод, который изменяет объект, возвращает <tt>None</tt>, чтобы помочь избежать ошибок. Поэтому, если вы написали</p><pre class="code python3"><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span></pre><p>думая, что это даст вам отсортированную копию y, вы вместо этого получите <tt>None</tt>, что скорее всего приведёт к легко диагностируемой ошибке.</p><p>Однако, существует один класс операций, где одна и та же операция ведёт себя по-разному с различными типами: расширенные операторы присваивания. Например, <tt>+=</tt> изменяет списки, но не кортежи или числа (<tt>a_list += [1, 2, 3]</tt> эквивалентно <tt><span class="pre">a_list.extend([1,</span> 2, 3])</tt>) и изменяет список, в то время, как <tt>some_tuple += (1, 2, 3)</tt> и <tt>some_int += 1</tt> создают новый объект.</p><p>Если вы хотите знать, ссылаются ли 2 переменные на один объект или нет, вы можете использовать оператор <tt>is</tt>, или встроенную функцию <tt>id</tt>.</p></div><div class="section" id="id6"><h2>Как создавать функции более высокого порядка?</h2><p>Есть два пути: использовать вложенные функции или вызываемые объекты. Например, с использованием вложенных функций:</p><pre class="code python3"><span class="k">def</span> <span class="nf">linear</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">result</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">result</span></pre><p>Использование вызываемого объекта:</p><pre class="code python3"><span class="k">class</span> <span class="nc">linear</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span></pre><p>В обоих случаях,</p><pre class="code python3"><span class="n">taxes</span> <span class="o">=</span> <span class="n">linear</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></pre><p>даёт функцию, что (к примеру) <tt>taxes(10e6) == 0.3 * 10e6 + 2</tt>.</p><p>Использование вызываемого объекта - немного медленнее, и в результате получается больше кода. Однако, заметьте, что несколько функций могут разделять свою сигнатуру с помощью <a href="http://pythonworld.ru/osnovy/inkapsulyaciya-nasledovanie-polimorfizm.html" target="_blank">наследования</a>:</p><pre class="code python3"><span class="k">class</span> <span class="nc">exponential</span><span class="p">(</span><span class="n">linear</span><span class="p">):</span>
    <span class="c1"># __init__ наследуется</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span></pre><p>Объект может сохранять свое состояние для нескольких вызовов:</p><pre class="code python3"><span class="k">class</span> <span class="nc">counter</span><span class="p">:</span>

    <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">down</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">count</span> <span class="o">=</span> <span class="n">counter</span><span class="p">()</span>
<span class="n">inc</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">reset</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="n">up</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">down</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">set</span></pre><p>Здесь <tt>inc</tt>, <tt>dec</tt>, <tt>reset</tt> выступают в роли функций, которые разделяют одну и ту же переменную.</p></div><div class="section" id="id7"><h2>Как скопировать объект в Python?</h2><p>В общем случае, с помощью <a href="http://pythonworld.ru/moduli/modul-copy.html" target="_blank">модуля copy</a>.</p><p>Некоторые объекты можно скопировать более просто. Словари имеют метод copy:</p><pre class="code python3"><span class="n">newdict</span> <span class="o">=</span> <span class="n">olddict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></pre><p>Последовательности могут быть скопированы путём <a href="http://pythonworld.ru/osnovy/indeksy-i-srezy.html" target="_blank">срезов</a>:</p><pre class="code python3"><span class="n">new_l</span> <span class="o">=</span> <span class="n">l</span><span class="p">[:]</span></pre></div><div class="section" id="id8"><h2>Как узнать доступные методы и атрибуты объекта?</h2><p><tt>dir(x)</tt> возвращает список методов и атрибутов.</p></div><div class="section" id="id9"><h2>Как можно узнать имя объекта?</h2><p>Вообще говоря, никак, поскольку объекты в действительности не имеют имён. Важно: присваивание всегда связывает имя с объектом. Это верно и для инструкций <tt>def</tt> и <tt>class</tt>.</p><pre class="code pycon literal-block">
<span class="k"/><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
<span class="gp">... </span>   <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span>
<span class="go">&gt;&gt;&gt;
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&lt;__main__.A object at 0x7fbcc3ee5160&gt;
</span><span class="k"/><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;__main__.A object at 0x7fbcc3ee5160&gt;</span></pre><p>Возможно, класс имеет имя: однако, хотя он связан с двумя именами и запрашивается через имя <tt>B</tt>, созданный экземпляр всё ещё считается экземпляром класса <tt>A</tt>. Однако, невозможно сказать, имя экземпляра <tt>a</tt> или <tt>b</tt>, поскольку оба они связаны с одним и тем же значением.</p></div><div class="section" id="id10"><h2>Какой приоритет у оператора "запятая"?</h2><p>Запятая не является оператором в Python.</p><pre class="code pycon literal-block">
<span class="s2"/><span class="gp">&gt;&gt;&gt; </span><span class="s2">"a"</span> <span class="ow">in</span> <span class="s2">"b"</span><span class="p">,</span> <span class="s2">"a"</span>
<span class="go">(False, 'a')</span></pre><p>Поскольку запятая - не оператор, но разделитель между выражениями, пример выше исполняется как если бы было введено:</p><pre class="code python3"><span class="p">(</span><span class="s2">"a"</span> <span class="ow">in</span> <span class="s2">"b"</span><span class="p">),</span> <span class="s2">"a"</span></pre><p>А не</p><pre class="code python3"><span class="s2">"a"</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">"b"</span><span class="p">,</span> <span class="s2">"a"</span><span class="p">)</span></pre><p>То же самое верно и для операторов присваивания (<tt>=</tt>, <tt>+=</tt> и другие). Они не являются операторами как таковыми, а лишь синтаксическими разделителями в операциях присваивания.</p></div><div class="section" id="python-c"><h2>Есть ли в Python эквивалент тернарного оператора "?:" в C?</h2><p>Да. Синтаксис:</p><pre class="code python3"><span class="p">[</span><span class="n">on_true</span><span class="p">]</span> <span class="k">if</span> <span class="p">[</span><span class="n">expression</span><span class="p">]</span> <span class="k">else</span> <span class="p">[</span><span class="n">on_false</span><span class="p">]</span></pre><pre class="code python3"><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">25</span>
<span class="n">small</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">else</span> <span class="n">y</span></pre></div><div class="section" id="id11"><h2>Можно ли писать обфусцированные однострочники?</h2><p>Можно.</p><pre class="code python3"><span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>

<span class="c1"># Простые числа &lt; 1000</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">*</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span>
<span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">%</span><span class="n">x</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))),</span><span class="mi">1</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1000</span><span class="p">)))))</span>

<span class="c1"># Первые 10 чисел Фибоначчи</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">:(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">f</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span><span class="p">:</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))))</span>

<span class="c1"># Множество Мандельброта</span>
<span class="nb">print</span><span class="p">((</span><span class="k">lambda</span> <span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="p">,</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="p">,</span><span class="n">IM</span><span class="p">,</span><span class="n">Sx</span><span class="p">,</span><span class="n">Sy</span><span class="p">:</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">,</span>
<span class="n">Iu</span><span class="o">=</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="o">=</span><span class="n">Io</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span><span class="n">Sy</span><span class="o">=</span><span class="n">Sy</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="k">lambda</span> <span class="n">yc</span><span class="p">,</span><span class="n">Iu</span><span class="o">=</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="o">=</span><span class="n">Io</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">IM</span><span class="p">,</span>
<span class="n">Sx</span><span class="o">=</span><span class="n">Sx</span><span class="p">,</span><span class="n">Sy</span><span class="o">=</span><span class="n">Sy</span><span class="p">:</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">xc</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">yc</span><span class="o">=</span><span class="n">yc</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span>
<span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">Sx</span><span class="o">=</span><span class="n">Sx</span><span class="p">,</span><span class="n">F</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="p">:(</span><span class="n">k</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span><span class="ow">or</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span>
<span class="o">&gt;=</span><span class="mf">4.0</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">xc</span><span class="p">,</span><span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">yc</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">f</span><span class="p">):</span><span class="n">f</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="p">):</span><span class="nb">chr</span><span class="p">(</span>
<span class="mi">64</span><span class="o">+</span><span class="n">F</span><span class="p">(</span><span class="n">Ru</span><span class="o">+</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">Ro</span><span class="o">-</span><span class="n">Ru</span><span class="p">)</span><span class="o">/</span><span class="n">Sx</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">)),</span><span class="nb">range</span><span class="p">(</span><span class="n">Sx</span><span class="p">))):</span><span class="n">L</span><span class="p">(</span><span class="n">Iu</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">Io</span><span class="o">-</span><span class="n">Iu</span><span class="p">)</span><span class="o">/</span><span class="n">Sy</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Sy</span>
<span class="p">))))(</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">24</span><span class="p">))</span>
<span class="c1">#    \___ ___/  \___ ___/  |   |   |__ lines on screen</span>
<span class="c1">#        V          V      |   |______ columns on screen</span>
<span class="c1">#        |          |      |__________ maximum of "iterations"</span>
<span class="c1">#        |          |_________________ range on y axis</span>
<span class="c1">#        |____________________________ range on x axis</span></pre><p>Не пытайтесь это делать дома!</p></div><div class="section" id="id12"><h2>Почему -22 // 10 равно -3?</h2><p>Поскольку <tt>i % j</tt> имеет тот же знак, что <tt>j</tt>. А ещё</p><pre class="code python3"><span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">i</span> <span class="o">//</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">j</span><span class="p">)</span></pre></div><div class="section" id="id13"><h2>Как можно изменить строку?</h2><p>Никак, поскольку строки неизменяемы. В большинстве ситуаций, нужно просто сделать новую строку из различных частей. Однако, если так нужно, можно использовать <tt>io.StringIO</tt>, либо модуль <a href="http://pythonworld.ru/moduli/modul-array-massivy-v-python.html" target="_blank">array</a>:</p><pre class="code pycon literal-block">
<span class="kn"/><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">"Hello, world"</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">'Hello, world'
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">7
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"there!"</span><span class="p">)</span>
<span class="go">6
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">'Hello, there!'

</span><span class="kn"/><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'u'</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array('u', 'Hello, world')
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'y'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array('u', 'yello, world')
</span><span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">tounicode</span><span class="p">()</span>
<span class="go">'yello, world'</span></pre></div><div class="section" id="id14"><h2>Как использовать строки для вызова функций/методов?</h2><p>Существует несколько приёмов.</p><ul><li>Лучший - использование словаря, ставящего соответствие строке функцию. Его главное достоинство - строки не обязаны совпадать с названиями функций.</li></ul><pre class="code python3"><span class="k">def</span> <span class="nf">a</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">b</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="n">dispatch</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'go'</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="s1">'stop'</span><span class="p">:</span> <span class="n">b</span><span class="p">}</span>  <span class="c1"># Note lack of parens for funcs</span>

<span class="n">dispatch</span><span class="p">[</span><span class="n">get_input</span><span class="p">()]()</span></pre><ul><li>Использование встроенной функции getattr:</li></ul><pre class="code python3"><span class="kn">import</span> <span class="nn">foo</span>
<span class="nb">getattr</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="s1">'bar'</span><span class="p">)()</span></pre><ul><li>Использование locals или eval (не рекомендуется)</li></ul><pre class="code python3"><span class="k">def</span> <span class="nf">myFunc</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"hello"</span><span class="p">)</span>

<span class="n">fname</span> <span class="o">=</span> <span class="s2">"myFunc"</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">fname</span><span class="p">]</span>
<span class="n">f</span><span class="p">()</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
<span class="n">f</span><span class="p">()</span></pre></div><div class="section" id="id15"><h2>Как удалить все символы новой строки в конце строки?</h2><p>Можно использовать <tt><span class="pre">S.rstrip("\r\n")</span></tt> для удаления символов новой строки, без удаления конечных пробелов:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"line 1 </span><span class="se">\r\n</span><span class="s2">"</span>
<span class="gp">... </span>         <span class="s2">"</span><span class="se">\r\n</span><span class="s2">"</span>
<span class="gp">... </span>         <span class="s2">"</span><span class="se">\r\n</span><span class="s2">"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">"</span><span class="se">\r\n</span><span class="s2">"</span><span class="p">)</span>
<span class="go">'line 1 '</span></pre></div><div class="section" id="id17"><h2>Как создать многомерный список?</h2><p>Возможно, вы попробуете этот неудачный вариант:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span></pre><p>Это выглядит правильно, если напечатать:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">[[None, None], [None, None], [None, None]]</span></pre><p>Но если вы присвоите значение, то оно появится в нескольких местах:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">[[5, None], [5, None], [5, None]]</span></pre><p>Причина в том, что оператор <tt>*</tt> не создаёт копию, а только ссылку на существующий объект. <tt>*3</tt> создаёт список из 3 ссылок на один и тот же список. Изменение в одной строке изменяют другие, что, вероятно, не то, что вы хотите.</p><p>Возможные пути решения:</p><pre class="code python3"><span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span></pre><pre class="code python3"><span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">)]</span></pre><p>Или, можно использовать специальные модули, предоставляющие матрицы. Наиболее известным является <a href="http://pythonworld.ru/numpy" target="_blank">NumPy</a>.</p></div><div class="section" id="a-tuple-i-item"><h2>Почему a_tuple[i] += ['item'] не работает, а добавление работает?</h2><p>Это из-за того, что расширенный оператор присваивания - оператор <i>присваивания</i>, а также из-за разницы между изменяемыми и неизменяемыми объектами в Python.</p><p>Это обсуждение относится в общем, когда расширенные операторы присваивания применяются к элементам кортежа, которые указывают на изменяемые объекты, но мы будем использовать список и <tt>+=</tt>, как образец.</p><p>Если вы напишете:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gt">Traceback (most recent call last):
</span>  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">'tuple' object does not support item assignment</span></pre><p>Причина исключения должна быть понятна: <tt>1</tt> добавляется к объекту <tt>a_tuple[0]</tt>, но когда мы пытаемся присвоить результат, <tt>2</tt>, к первому элементу в кортеже, мы получаем ошибку, поскольку мы не можем изменить элемент кортежа.</p><p>То есть, это выражение делает следующее:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
<span class="gt">Traceback (most recent call last):
</span> <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">'tuple' object does not support item assignment</span></pre><p>Когда мы пишем что-то вроде:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span> <span class="o">=</span> <span class="p">([</span><span class="s1">'foo'</span><span class="p">],</span> <span class="s1">'bar'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">'item'</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):
</span> <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">'tuple' object does not support item assignment</span></pre><p>Исключение немного более неожиданное, но более удивителен тот факт, что, несмотря на ошибку, элемент добавился!</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">['foo', 'item']</span></pre><p>Чтобы понять, что случилось, нужно знать, что:</p><ul><li>Если объект определяет метод <tt>__iadd__</tt>, он вызывается, когда выполняется <tt>+=</tt>, и возвращенное значение используется для присваивания</li><li>Для списков, <tt>__iadd__</tt> эквивалентен вызову <tt>extend</tt> для списка</li></ul><p>Таким образом,</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span>
<span class="go">[1]</span></pre><p>Эквивалентен:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">a_list</span><span class="o">.</span><span class="n">__iadd__</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">=</span> <span class="n">result</span></pre><p>Таким образом, наш пример с кортежом эквивалентен:</p><pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__iadd__</span><span class="p">([</span><span class="s1">'item'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
<span class="gt">Traceback (most recent call last):
</span>  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">'tuple' object does not support item assignment</span></pre><p><tt>__iadd__</tt> завершился успешно, и список увеличился, но присваивание законилось ошибкой.</p></div></div></div></body></html>