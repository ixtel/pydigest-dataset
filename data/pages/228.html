<html><body><div><div class="step-body">
      <em>Another disclaimer: I'm also not a computer scientist or programmer, much less a Python expert. If the code below looks awful, inefficient, or just makes you cringe, please feel free to post a link to better code, for the sake of people reading this in the future.</em>  <strong>Update 12/13/2013: See mmoon's comment below for a link to some neater code.</strong> <p> Now that you have the circuit built, it's time to start using the Raspberry Pi! This is another part that was confusing for a first-time Raspberry Pi user - it wasn't immediately obvious how to actually control the GPIO pins, because apparently there's more than one way to do it. A Google search for "raspberry pi gpio python" reveals multiple different tutorials and Python packages you can download. You can also </p><a href="http://wiringpi.com/" rel="nofollow">control the pins directly from a terminal without using Python at all</a><p>. So, it took me a while to figure out that the </p><a href="http://elinux.org/RPi_Low-level_peripherals#Python" rel="nofollow">default Raspbian distribution already comes with a Python module for controlling GPIO pins</a><p>. Phew! </p><p> Remember that I'm assuming you already have a Raspberry Pi up and running this point, using Raspbian, which comes with </p><em>both</em><p> Python 2.x and 3.x (as of December 2013). I wrote the code in Python 3.2.3 using IDLE 3 (Integrated Development Library) - there's a shortcut for it on the default Raspbian desktop. </p><p> To run the code: </p><p> 1. Open a terminal ("LXTerminal" icon on the desktop), type </p><strong>sudo idle3</strong><p>, and hit enter. This runs IDLE "as root", which is required for GPIO access with Python.</p><p> 2. Download christmas_timer.py (below) and then open it in IDLE 3, </p><em>or</em><p> create a new Python file and copy and paste the code below.</p><p> 3. Take a minute to look at the code and the comments. The only part you should need to edit is the section towards the beginning with all the "on" and "off" times (MonOn, MonOff, TueOn, etc).</p><p> 4. You're almost ready to run the code! But first...(go to the next step)  </p><blockquote>  <p>   # Raspberry Pi custom Christmas light timer<br/>   <br/>   # import GPIO module<br/>   import RPi.GPIO as GPIO<br/>   <br/>   # set up GPIO pins as outputs<br/>   # This convention is for the "P1" header pin convention<br/>   # where the pins start with P1 in the upper left<br/>   # and go to P26 in the lower right, with odds in the<br/>   # left column and evens in the right column.<br/>   # So, pins P1-11 and P1-12 correspond to GPIO17 and<br/>   # GPIO18 respectively.<br/>   GPIO.setmode(GPIO.BOARD)<br/>   GPIO.setup(11, GPIO.OUT)<br/>   GPIO.setup(12, GPIO.OUT)<br/>   <br/>   # import date and time modules<br/>   import datetime<br/>   import time<br/>   <br/>   # Enter the times you want the lights to turn on and off for<br/>   # each day of the week. Default is for lights to turn on at<br/>   # 5:30pm and off at 10:30pm on weekdays, on at 5:00pm and off<br/>   # at 11:30pm on weekends. Note that this is using a 24-hour clock.<br/>   <br/>   MonOn  = datetime.time(hour=17,minute=30,second=0)<br/>   MonOff = datetime.time(hour=22,minute=30,second=0)<br/>   TueOn  = datetime.time(hour=17,minute=30,second=0)<br/>   TueOff = datetime.time(hour=22,minute=30,second=0)<br/>   WedOn  = datetime.time(hour=17,minute=30,second=0)<br/>   WedOff = datetime.time(hour=22,minute=30,second=0)<br/>   ThuOn  = datetime.time(hour=17,minute=30,second=0)<br/>   ThuOff = datetime.time(hour=22,minute=30,second=0)<br/>   FriOn  = datetime.time(hour=17,minute=30,second=0)<br/>   FriOff = datetime.time(hour=22,minute=30,second=0)<br/>   SatOn  = datetime.time(hour=17,minute=0,second=0)<br/>   SatOff = datetime.time(hour=23,minute=30,second=0)<br/>   SunOn  = datetime.time(hour=17,minute=0,second=0)<br/>   SunOff = datetime.time(hour=23,minute=30,second=0)<br/>   <br/>   # Store these times in an array for easy access later.<br/>   OnTime = [MonOn, TueOn, WedOn, ThuOn, FriOn, SatOn, SunOn]<br/>   OffTime = [MonOff, TueOff, WedOff, ThuOff, FriOff, SatOff, SunOff]<br/>   <br/>   # Set a "wait time" in seconds. This ensures that the program pauses<br/>   # briefly after it turns the lights on or off. Otherwise, since the<br/>   # loop will execute more than once a second, it will try to keep<br/>   # turning the lights on when they are already on (or off when they are<br/>   # already off.<br/>   <br/>   waitTime = 3<br/>   <br/>   # Start the loop that will run until you stop the program or turn<br/>   # off your Raspberry Pi.<br/>   <br/>   while True:<br/>   <br/>       # get the current time in hours, minutes and seconds<br/>       currTime = datetime.datetime.now()<br/>       # get the current day of the week (0=Monday, 1=Tuesday, 2=Wednesday...)<br/>       currDay = datetime.datetime.now().weekday()<br/>   <br/>       #Check to see if it's time to turn the lights on<br/>       if (currTime.hour - OnTime[currDay].hour == 0 and<br/>           currTime.minute - OnTime[currDay].minute == 0 and<br/>           currTime.second - OnTime[currDay].second == 0):<br/>   <br/>           # set the GPIO pin to HIGH, equivalent of<br/>           # pressing the ON button on the remote<br/>           GPIO.output(11, GPIO.HIGH)<br/>   <br/>           # wait for a very short period of time then set<br/>           # the value to LOW, the equivalent of releasing the<br/>           # ON button<br/>           time.sleep(.5)<br/>           GPIO.output(11, GPIO.LOW)<br/>   <br/>           # wait for a few seconds so the loop doesn't come<br/>           # back through and press the "on" button again<br/>           # while the lights ae already on<br/>           time.sleep(waitTime)<br/>   <br/>       #check to see if it's time to turn the lights off<br/>       elif (currTime.hour - OffTime[currDay].hour == 0 and<br/>           currTime.minute - OffTime[currDay].minute == 0 and<br/>           currTime.second - OffTime[currDay].second == 0):<br/>   <br/>           # set the GPIO pin to HIGH, equivalent of<br/>           # pressing the OFF button on the remote<br/>           GPIO.output(12, GPIO.HIGH)<br/>   <br/>           # wait for a very short period of time then set<br/>           # the value to LOW, the equivalent of releasing the<br/>           # OFF button<br/>           time.sleep(.5)<br/>           GPIO.output(12, GPIO.LOW)<br/>   <br/>           # wait for a few seconds so the loop doesn't come<br/>           # back through and press the "off" button again<br/>           # while the lights ae already off<br/>           time.sleep(waitTime)</p> </blockquote> <p>   </p> 
    </div>    

    
        


</div></body></html>