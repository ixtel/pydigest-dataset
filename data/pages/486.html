<html><body><div><div class="col-xs-9">
                                <div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/pycharm2.PNG" alt="Successful PyUnit testing of login feature from within PyCharm IDE"/>
<p>
Successful PyUnit testing of login feature from within PyCharm IDE
</p>
</div>
<p align="justify">
Let me be honest about one thing : I don't have any draft outline for contents written in this blog. All of these articles were written in the spirit of improvisation and freedom to think/write/speech. For example, although I have been one of Qt fans since it was still owned by Trolltech, I have not the slightest idea that there will be a Qt series here. Even though I knew that Qt is supported in Python through PyQt, I am not <em>that </em>curious to start writing articles about it here. Only after I wrote <a href="http://pythonthusiast.pythonblogs.com/230_pythonthusiast/archive/1340_exploring_python_prospective_technology_to_encourage_children_in_loving_computer_programming.html">this article</a>, which lead me to <a href="http://pythonthusiast.pythonblogs.com/230_pythonthusiast/archive/1346_starting_to_use_kivy__developing_letter_of_heroes_an_android_alphabet_teaching_aid_application_for_kids-part_1_of_2.html">Kivy</a> that I began to experience something thrilling : doing Android development using pure Python! While I work on Kivy though, I also explore were there any alternatives to Android development using Python? Or in general, <em>"Can we develop Android application without the use of Java?".</em> The answer to this question bring me to (amongst other things) : <a href="http://necessitas.kde.org/">Qt in Android</a>. In which in Qt Project website itself, Python is listed as the most prominence <a href="http://qt-project.org/wiki/Category:LanguageBindings">third party programming language binding</a> having Qt support! That was such a great news... Hence, our Qt series articles was born..
</p>
<p align="justify">
Another example is an answer around this question<em>, "In this Qt series, what is the application that we are going to build?"</em>. Plain answer? No idea. Well, not <em>that </em>completely blind for sure. I just know that it must be a <a href="http://pythonthusiast.pythonblogs.com/230_pythonthusiast/archive/1351_developing_cross_platform_application_using_qt_pyqt_and_pyside__first_iteration_of_the_overall_application_design_and_hello_world-part_2_of_7.html">data aware application</a>. And in the process of its development, it must be prefaced with a practical introduction to <a href="http://pythonthusiast.pythonblogs.com/230_pythonthusiast/archive/1354_developing_cross_platform_application_using_qt_pyqt_and_pyside__test_driven_development_and_unit_testing-part_3_of_7.html">Test Driven Development(TDD)</a>. Combining both requirements, bring us to this current article : database support in either C++ Qt or PySide/PyQt. To keep things interesting, in this article we will officially use two IDEs : <a href="http://qt-project.org/wiki/Category:Tools::QtCreator">QtCreator</a> for cross platform C++ Qt development and <a href="http://www.jetbrains.com/pycharm/">PyCharm</a> for its Python counterpart. 
</p>
<p align="justify">
Now that I have your attention ladies and gentlemen, lets drill on this cool talk about database support in Qt using either C++ or Python! Enjoy your time and .. happy reading! <img src="http://pythonthusiast.pythonblogs.com/js/tinymce/plugins/emotions/images/smiley-laughing.gif" border="0" alt="Laughing" title="Laughing"/>
</p>
<p align="justify"/>
<h1>Database Support in Qt<br/>
</h1>
<p align="justify">
Database maybe the most prevalence reason why computer have massive cultural impact in our human civilization development : all aspects of our culture will eventually have some sort of data need to be written and or transported somewhere. Following its development, database  application develop itself from 1-tier architecture, 2-tier, 3-tier and from there on, simply known as <a href="http://en.wikipedia.org/wiki/Multitier_architecture">multi-tier</a>. The main theme being brought was simple : any application from different programming languages should  be able to talk to any database, provide that database driver for that particular database is available. Note that, in our discussion, when we refer to database actually we refer to specific type of database, which is <a href="http://en.wikipedia.org/wiki/Relational_model">relational database</a> with its language, <a href="http://en.wikipedia.org/wiki/SQL">SQL</a>. Another <a href="http://en.wikipedia.org/wiki/Types_of_DBMS">database type</a> exists for sure, such as <a href="http://en.wikipedia.org/wiki/NoSQL">NoSQL</a>, <a href="http://en.wikipedia.org/wiki/Hierarchical_database_model">hierarchical</a> or even <a href="http://en.wikipedia.org/wiki/Flat_file_database">flat file database</a>.
</p>
<p align="justify">
Qt --as with any modern application framework-- was also designed with this modularity in mind. Amongst <a href="http://qt-project.org/doc/qt-5.0/qtdoc/modules.html">Qt modules</a>, <a href="http://qt-project.org/doc/qt-5.0/qtsql/qtsql-index.html">Qt Sql </a>is the module that particularly responsible with database support for Qt applications. Due to its layered architecture, you can switch to any supported database anytime and yet your applications deserve only one single line of change: loading of database driver. In this article we are going to have a hands-on on Qt database support using either C++ or PyQt/PySide. Lets start with the C++ version first, this time using QtCreator.
</p>
<h1>Creating Application Database </h1>
<p align="justify">
Below is our Users table that we will use in the next subsequent section. How do you prepare such table? Or, a much better question is how do you prepare the database in a particular RDBMS (Relational Database Management System) product?
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/Users.PNG" alt="Just a plain Users table"/>
<p>
Just a plain Users table
</p>
</div>
<p align="justify">
As Qt will be able to work with any database --provide that its database driver existed--, technically speaking, the question of what RDBMS product to be use is somewhat a minor question. In this article I provide the code work using either PostgreSQL or Sqlite. I suggest that you test your application against SQLite first. Once done, you can easily switch to full fledged client-server RDBMS product such as PostgreSQL or MySQL. 
</p>
<h2>Using SQLite<br/>
</h2>
<p align="justify">
<a href="http://sqlite.org">SQLite</a> probably the easiest database to use. Qt binary was prebuilt with SQLite support, so there is nothing extra work must be done in your part as developer or in your user workstation. Every SQLite database is stored in a single file, so it is perfectly well suited for a standalone application that need database access in some sort. Looking at its <a href="http://sqlite.org/famous.html">serious user</a>, we can say that SQLite is not a toy. It really is a production quality database. 
</p>
<p align="justify">
We will create SQLite database directly from within Qt code, so there really is nothing managerial task must be done. 
</p>
<h2>Using PostgreSQL<br/>
</h2>
<p align="justify">
But the case is rather different with PostgreSQL. It's a client server RDBMS product, which require a magnitude of managerial task before the database can be use by your application. You can <a href="http://pythonthusiast.pythonblogs.com/230_pythonthusiast/archive/1314_building_python_flask_application_in_openshiftheroku_replacement_part_v__implementing_application_model_using_sqlalchemy__postgresql_92.html">follow my other article</a> that briefly explained how to install PostgreSQL in either Linux or Windows. To create our database, lets just call it <code>pythonthusiast</code>, you can use PgAdmin III that shipped with PostgreSQL distribution or, you can create a simple Django project and lets South manage your database schema creation from Django models. These are the series of commands that eventually create the appropriate database.  
</p>
<p align="justify">
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td><pre>$ createdb pythonthusiast <span>#create postgresql database</span>
$ mkdir database <span>#create directory to hold django project</span>
$ <span>cd</span> database <span>#go to directory</span>
$ python /usr/lib/python2.7/dist-packages/django/bin/django-admin.<span>py</span> startproject pythonthusiast <span>#create django project</span>
$ <span>cd</span> pythonthusiast <span>#go to newly created django project</span>
$ python /usr/lib/python2.7/dist-packages/django/bin/django-admin.<span>py</span> startapp qtapp <span>#create django application</span>
$ <span>cd</span> qtapp <span>#go to directory</span>
$ emacs models.<span>py</span> <span>#also edit pythonthusiast/settings.py to use south and match Postgresql database configuration</span>
$ <span>cd</span> ../
$ python manage.<span>py</span> syncdb <span>#initialize database</span>
$ python manage.<span>py</span> convert_to_south qtapp <span>#convert to south application</span>
$ python manage.<span>py</span> migrate qtapp <span>#migrate to south</span></pre></td></tr></tbody></table>
<p> 
</p>
<p>
Below is the content of <code>models.py</code> which resemblance Users table previously:
</p>
<p>
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
</pre></td><td><pre><span>from</span> django.<span>db</span> <span>import</span> models
 
<span>class</span> Users<span>(</span>models.<span>Model</span><span>)</span>:
    username <span>=</span> models.<span>CharField</span><span>(</span>max_length <span>=</span> <span>30</span><span>)</span>
    password <span>=</span> models.<span>CharField</span><span>(</span>max_length <span>=</span> <span>255</span><span>)</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
By using Django application (installed with South) to manage your database, you will gain the benefit of a simpler process of managing database schema changes. Read more about how to use South in Django application in my other article <a href="http://pythonthusiast.pythonblogs.com/230_pythonthusiast/archive/1339_django_kfimember_tutorial_part_iv-using_south_to_manage_schema_migration.html">here</a>. 
</p>
<p align="justify">
Finally to use PostgreSQL with Qt, you will have to install PostgreSQL driver. In Linux Ubuntu 12.0.4 LTS, this can be done easily by issuing the following command : <code>sudo apt-get install libqt4-sql-psql</code>. But in Windows you will have to <a href="http://briolidz.wordpress.com/2011/11/20/postgresql-driver-for-windows-and-linux/">build it yourselves</a>. Once done, your Qt application will have the ability connecting to PostgreSQL database. 
</p>
<h1>Accessing Database From C++ Qt Application<br/>
</h1>
<h2>Opening *.pro project file in QtCreator<br/>
</h2>
<p align="justify">
Now that we already have a proper database of our choice, let start to code from our <a href="http://pythonthusiast.pythonblogs.com/230_pythonthusiast/archive/1354_developing_cross_platform_application_using_qt_pyqt_and_pyside__test_driven_development_and_unit_testing-part_3_of_7.html">previous</a> <code>unittest.pro</code> project file, but this time we're going to open it from QtCreator. Simply launch QtCreator and open the existing project file through the menu command File-&gt;Open file or project. As this is the first time we open this *.pro file using QtCreator, it will open Target Setup dialog box as below:
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/sql3.PNG" alt="First time open a *.pro file"/>
<p>
First time opening a *.pro file using QtCreator 
</p>
</div>
<p align="justify">
If you run this project (using CTRL+R), somehow the terminal stay blank. To fix this, switch to projects mode (CTRL + 5), and unchecked the Run in Terminal checkbox. Run the project again, and you will see our familiar QtTest unit testing output in 
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/sql5.PNG" alt="QtTest output"/> 
<p>
QtTest output
</p>
</div>
<p align="justify">
Mind you, that the code above haven't got any database support implemented. It was merely running our previous project within QtCreator. Anyway, I always think that QtCreator should've been created with a much tighter support by treating unit testing  output in the  Red Green bar visualization like its JUnit counterpart. But, the good news is, iff there are failed assertion in the unit test method, you can still double click on them to go directly to the source code. Compare this with bare bone console output, this is an improvement. 
</p>
<h2>Connecting to Database<br/>
</h2>
<p align="justify">
Simply open <code>unittest.pro</code> project file and change <code>QT += testlib</code>  property to read <code>QT += sql testlib</code>. This will link your Qt application to QtSql module and will let you access all QtSql classes. That's all!
</p>
<p align="justify">
To test whether we really able to connect to the underlying database, let's review our <code>TestFeature01.cpp</code> and modify <code>initTestCase()</code> method as follows:
</p>
<p align="justify">
</p>
<table class="cpp code"><tbody><tr class="li1"><td><pre>1
2
3
4
</pre></td><td><pre><span>void</span> TestCase01<span>::</span><span>initTestCase</span><span>(</span><span>)</span>
<span>{</span>
    QCOMPARE<span>(</span>Helper<span>::</span><span>dbConnect</span><span>(</span><span>)</span>, <span>true</span><span>)</span><span>;</span>
<span>}</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
We expect the result of <code>Helper::dbConnect()</code> to be <code>true</code> for a successful connection. Bellow is the <code>Helper::dbConnect()</code> method:
</p>
<p align="justify">
</p>
<table class="cpp code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td><pre><span>bool</span> Helper<span>::</span><span>dbConnect</span><span>(</span><span>)</span>
<span>{</span>
    <span>//If using Sqlite</span>
    QSqlDatabase db <span>=</span> QSqlDatabase<span>::</span><span>addDatabase</span><span>(</span><span>"QSQLITE"</span><span>)</span><span>;</span>
    QString filename <span>=</span> <span>"pythonthusiast.db"</span><span>;</span>
    QFile database<span>(</span>filename<span>)</span><span>;</span>
    <span>if</span><span>(</span><span>!</span>database.<span>exists</span><span>(</span><span>)</span><span>)</span>
    <span>{</span>   
        qDebug<span>(</span><span>)</span> <span>&lt;&lt;</span> <span>"Database not found. Creating and opening"</span><span>;</span>
        db.<span>setDatabaseName</span><span>(</span>filename<span>)</span><span>;</span>
        db.<span>open</span><span>(</span><span>)</span><span>;</span>
        QSqlQuery query<span>;</span>
        query.<span>exec</span><span>(</span><span>"create table qtapp_users "</span>
                    <span>"(id integer primary key autoincrement, "</span>
                    <span>"username varchar(30), "</span>
                    <span>"password varchar(255))"</span><span>)</span><span>;</span>
        query.<span>prepare</span><span>(</span><span>"insert into qtapp_users(username, password) values(:username, :password)"</span><span>)</span><span>;</span>
        query.<span>bindValue</span><span>(</span><span>":username"</span>, <span>"eko"</span><span>)</span><span>;</span>
        query.<span>bindValue</span><span>(</span><span>":password"</span>, Helper<span>::</span><span>computeHash</span><span>(</span><span>"password"</span><span>)</span><span>)</span><span>;</span>
        query.<span>exec</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>else</span>
    <span>{</span>
        qDebug<span>(</span><span>)</span> <span>&lt;&lt;</span> <span>"Database found. Opening"</span><span>;</span>
        db.<span>setDatabaseName</span><span>(</span>filename<span>)</span><span>;</span>
        db.<span>open</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
 
    <span>//If using PostgreSQL</span>
    <span>/*</span>
<span>    QSqlDatabase db = QSqlDatabase::addDatabase("QPSQL");</span>
<span>    db.setHostName("localhost");</span>
<span>    db.setDatabaseName("pythonthusiast");</span>
<span>    db.setUserName("postgres");</span>
<span>    db.setPassword("your-password-please");</span>
<span>    db.open();</span>
<span>    */</span>
 
    <span>return</span> db.<span>isOpen</span><span>(</span><span>)</span><span>;</span>
<span>}</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
I commented the code that will be use if we are about to switch into PostgreSQL. Currently, the code that will use SQLite is having another layer of complexity by creating all the required tables. This is the very fun part of using SQLite : you can easily create the database by your own code. If the database is not existed, the code <code>db.open()</code> will create it. User won't have to use another application to create the database. And it really is a wonderful user experience!
</p>
<p align="justify">
Try to run this unit testing code, and experiment with the database driver selection. You can inspect all the database driver installed with your Qt distribution.
</p>
<h2>Implementing doLogin() Method </h2>
<p align="justify">
This maybe the core part of this article discussion : continuing our development of <code>Auth::doLogin()</code> method from previous article, where we simply <code>return true</code>. Here, we are going to use <code>QSqlQuery</code> object to execute query against active database. Below is the complete code for <code>Auth::doLogin()</code>:
</p>
<p align="justify">
</p>
<table class="cpp code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td><pre><span>bool</span> Auth<span>::</span><span>doLogin</span><span>(</span>QString name, QString pass<span>)</span>
<span>{</span>
    QSqlQuery query<span>;</span>
    query.<span>prepare</span><span>(</span><span>"select id from qtapp_users where username = :username and password = :password"</span><span>)</span><span>;</span>
    query.<span>bindValue</span><span>(</span><span>":username"</span>, name<span>)</span><span>;</span>
    query.<span>bindValue</span><span>(</span><span>":password"</span>, Helper<span>::</span><span>computeHash</span><span>(</span>pass<span>)</span><span>)</span><span>;</span>
    query.<span>exec</span><span>(</span><span>)</span><span>;</span>
    <span>if</span><span>(</span>query.<span>next</span><span>(</span><span>)</span><span>)</span><span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
We use <code>QSqlQuery::prepare()</code> to easier construct a valid SQL command having several arguments, and use <code>QSqlQuery::bindValue()</code> to supply value to those arguments. We also saved our password as MD5 hash for a much safer way than storing a plain text password, by utilizing <a href="http://www.qtcentre.org/wiki/index.php?title=Cryptography#MD5_hash">Qt Cryptography</a> module. Below is how to compute MD5 Hash using Qt Cryptography module:
</p>
<p align="justify">
</p>
<table class="cpp code"><tbody><tr class="li1"><td><pre>1
2
3
4
</pre></td><td><pre>QString Helper<span>::</span><span>computeHash</span><span>(</span>QString original<span>)</span>
<span>{</span>
    <span>return</span> QString<span>(</span>QCryptographicHash<span>::</span><span>hash</span><span>(</span>original.<span>toUtf8</span><span>(</span><span>)</span>,QCryptographicHash<span>::</span><span>Md5</span><span>)</span>.<span>toHex</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
Qt will create a binary format for the MD5 result, while why need the result to be stored as Hexadecimal number. Hence, we convert it using <code>QCryptographicHash::hash()::toHex()</code> method.
</p>
<h2>Testing of Auth::doLogin() Method<br/>
</h2>
<p align="justify">
To aid us in testing our login feature, we will need to know beforehand an MD5 value for a certain string, e.g. "password". Lucky for us, we can use <a href="http://www.pythonblogs.com/md5.gromweb.com/?string=password">this web page</a> to calculate hash value for any string. Therefore, we can construct a more reliable unit testing code and become confidence of our overall application maturity. Depicted below is the final unit testing code and its output, taken directly from QtCreator application output:
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/test2.PNG" alt="A complete unit testing code of login feature"/>
<p>
A complete unit testing code of login feature
</p>
</div>
<p align="justify">
 
</p>
<h1>Accessing Database From PyQt/PySide Application<br/>
</h1>
<h2>Using PyCharm in Test-First Programming </h2>
<h1>
</h1>
<p align="justify">
Although in my <a href="http://pythonthusiast.pythonblogs.com/230_pythonthusiast/archive/1354_developing_cross_platform_application_using_qt_pyqt_and_pyside__test_driven_development_and_unit_testing-part_3_of_7.html">previous article</a> we have already talked about unit testing of a Python project, in there we still run our unit testing code using console. For this session, lets use one in the many array of Python IDE that support Test-First Programming/Test Driven Development, by giving a better visualization and control of unit testing result, much as JUnit plugin in Eclipse does. I am using JetBrains PyCharm Community Editions which can be downloaded and use freely from the following <a href="http://www.jetbrains.com/pycharm/download/">download page</a>. 
</p>
<p align="justify">
As PyCharm is a Java SE application, you will need to install Java SE from <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html?ssSourceSiteId=otnjp">Oracle download page</a>. The lighter version is to download the JRE, which gives you Java Runtime Environment only. While the complete version is to download JDK, which not only gives JRE but also a complete development tools to build Java application. I recommend that you install JDK in your system, as we are going to discuss <a href="http://www.jython.org">Jython</a> in the near feature. And installing JDK right now, will help you in the integration of Java and Python, which is what Jython is all about.
</p>
<p align="justify">
Once installed, run PyCharm and you'll be presented with this welcome page :
</p>
<div align="center">
<img src="http://pythonthusiast.pythonblogs.com/gallery/230/idea.png" alt="Jetbrains PyCharm welcome page"/>
<p>
PyCharm welcome page 
</p>
</div>
<p align="justify">
As we will open our previous Python unit testing application reside in an --of course-- existing folder, choose Open Directory and navigate to that particular directory. Actually, for this new article, I create a new directory named <code>PyQt</code> and copy all Python code from previous article to this new directory. I also have to rename <code>TestFeature01.py</code> into <code>test_feature01.py</code> in order for PyCharm to be able to find all my unit test classes. This is a slight requirement that's not much of a headache to comply with. This same requirement apply if you're about to use <a href="http://www.activestate.com/komodo-ide/downloads">ActiveState KomodoIDE</a> instead of PyCharm.  
</p>
<p align="justify">
Now that your project already opened in PyCharm, simply right click on its top Project Node, choose "Run 'Unittests in ..." and PyCharm will automatically (by means of file name pattern previously mentioned) runs all unit tests code within your project. Like its JUnit counterpart, PyCharm display unit test result in a much more pleasant way.
</p>
<h2>Connecting to Database </h2>
<h1>
</h1>
<p align="justify">
If you have installed PyQt4 / PyQt5 in Windows, have a look at the following directory : <code>C:\Python2.7\Lib\site-packages\PyQt4\plugins\sqldrivers</code>. It contains SQL database drivers shipped with every PyQt4/5 installation, which are : SQLite, PostgreSQL, MySQL and ODBC. Therefore, we can readily access supported database from within our PyQt application. If you have gone through our previous C++ code, you will also find that our PyQt4 code was very much a direct translation from its C++ counterpart. Below is the complete listing of <code>helper.py</code> module
</p>
<p align="justify">
<code>helper.py</code>
</p>
<p align="justify">
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td><pre><span>from</span> PyQt4.<span>QtCore</span> <span>import</span> *
<span>from</span> PyQt4.<span>QtSql</span> <span>import</span> *
 
<span>def</span> dbConnect<span>(</span><span>)</span>:
    db <span>=</span> QSqlDatabase.<span>addDatabase</span><span>(</span><span>"QSQLITE"</span><span>)</span>
    filename <span>=</span> <span>"pythonthusiast.db"</span>
    database <span>=</span>  QFile<span>(</span>filename<span>)</span>
    <span>if</span> <span>not</span> database.<span>exists</span><span>(</span><span>)</span>:
        qDebug<span>(</span><span>"Database not found. Creating and opening"</span><span>)</span>
        db.<span>setDatabaseName</span><span>(</span>filename<span>)</span>
        db.<span>open</span><span>(</span><span>)</span>
        query <span>=</span> QSqlQuery<span>(</span><span>)</span>
        query.<span>exec_</span><span>(</span><span>"create table qtapp_users "</span>
                    <span>"(id integer primary key autoincrement, "</span>
                    <span>"username varchar(30), "</span>
                    <span>"password varchar(255))"</span><span>)</span>
        query.<span>prepare</span><span>(</span><span>"insert into qtapp_users(username, password) values(:username, :password)"</span><span>)</span>
        query.<span>bindValue</span><span>(</span><span>":username"</span><span>,</span> <span>"eko"</span><span>)</span>
        query.<span>bindValue</span><span>(</span><span>":password"</span><span>,</span> computeHash<span>(</span><span>"password"</span><span>)</span><span>)</span>
        query.<span>exec_</span><span>(</span><span>)</span>
    <span>else</span>:
        qDebug<span>(</span><span>"Database found. Opening"</span><span>)</span>
        db.<span>setDatabaseName</span><span>(</span>filename<span>)</span>
        db.<span>open</span><span>(</span><span>)</span>
    <span>return</span> db.<span>isOpen</span><span>(</span><span>)</span>
 
<span>def</span> computeHash<span>(</span>original<span>)</span>:
    <span>return</span> QCryptographicHash.<span>hash</span><span>(</span>QString<span>(</span>original<span>)</span>.<span>toUtf8</span><span>(</span><span>)</span><span>,</span> QCryptographicHash.<span>Md5</span><span>)</span>.<span>toHex</span><span>(</span><span>)</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
Try to compare it with its C++ counterpart, and you will have a deja vu experience! 
</p>
<p align="justify">
But there is one important requirement for this code to work : a <code>QApplication</code> instance must be created before hand, in order SQL drivers to be loaded. Failed to do so will result in a run-time error with this message <code>QSqlDatabase: an instance of QCoreApplication is required for loading driver plugins</code>.
</p>
<h2>Implementing doLogin() Method </h2>
<p align="justify">
Not surprisingly, the PyQt version of <code>Auth</code> class is practically a translation of its C++ Qt version. I really just copy it from the C++ version, paste it into PyCharm, and then adjust the syntax to be a valid Python syntax. Here is the full code of <code>auth.py</code> :
</p>
<p>
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td><pre><span>from</span> PyQt4.<span>QtSql</span> <span>import</span> *
<span>import</span> helper
 
<span>class</span> Auth:
    <span>def</span> doLogin<span>(</span><span>self</span><span>,</span> username<span>,</span> password<span>)</span>:
        query <span>=</span> QSqlQuery<span>(</span><span>)</span>
        query.<span>prepare</span><span>(</span><span>"select id from qtapp_users where username = :username and password = :password"</span><span>)</span>
        query.<span>bindValue</span><span>(</span><span>":username"</span><span>,</span> username<span>)</span>
        query.<span>bindValue</span><span>(</span><span>":password"</span><span>,</span> helper.<span>computeHash</span><span>(</span>password<span>)</span><span>)</span>
        query.<span>exec_</span><span>(</span><span>)</span>
        <span>if</span> query.<span>next</span><span>(</span><span>)</span>:
            <span>return</span> <span>True</span>
        <span>return</span> <span>False</span></pre></td></tr></tbody></table>
<p> 
</p>
<p align="justify">
 
</p>
<h2>Testing of Auth.doLogin() Method<br/>
</h2>
<p align="justify">
To test the our Python code, we must preface it with a call to instantiate <code>QCoreApplication</code>. Please be advised that all test methods must be viewed to run independently. Therefore, for each test method that execute SQL query to the database, we must preface it with the call to instantiate <code>QCoreApplication</code> This will assure that all test methods will be able to run independently. 
</p>
<p>
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td><pre><span>import</span> <span>unittest</span>
<span>from</span> PyQt4.<span>QtCore</span> <span>import</span> QCoreApplication
<span>from</span> auth <span>import</span> Auth
<span>import</span> helper
<span>import</span> <span>sys</span>
 
<span>class</span> TestCase01<span>(</span><span>unittest</span>.<span>TestCase</span><span>)</span>:
    <span>def</span> testConnect<span>(</span><span>self</span><span>)</span>:
        qApp <span>=</span> QCoreApplication<span>(</span><span>sys</span>.<span>argv</span><span>)</span>
        <span>self</span>.<span>assertTrue</span><span>(</span>helper.<span>dbConnect</span><span>(</span><span>)</span><span>)</span>
 
    <span>def</span> testMd5<span>(</span><span>self</span><span>)</span>:
        <span>self</span>.<span>assertEqual</span><span>(</span>helper.<span>computeHash</span><span>(</span><span>"password"</span><span>)</span><span>,</span><span>"5f4dcc3b5aa765d61d8327deb882cf99"</span><span>)</span>
 
    <span>def</span> testAuth<span>(</span><span>self</span><span>)</span>:
        qApp <span>=</span> QCoreApplication<span>(</span><span>sys</span>.<span>argv</span><span>)</span>
        helper.<span>dbConnect</span><span>(</span><span>)</span>
        auth <span>=</span> Auth<span>(</span><span>)</span>
        <span>self</span>.<span>assertEqual</span><span>(</span>auth.<span>doLogin</span><span>(</span><span>"eko"</span><span>,</span> <span>"password"</span><span>)</span><span>,</span> <span>True</span><span>)</span>
 
<span>if</span> __name__ <span>==</span> <span>"__main__"</span>:
    <span>unittest</span>.<span>main</span><span>(</span><span>)</span></pre></td></tr></tbody></table>
<p> 
</p>
<p>
For a successful unit test execution for this unit testing method, you may refer to the first image in this article.
</p>
<p>
 
</p>
<h2>Using PySide instead of PyQt
</h2>
<p>
Converting the application to use PySide, merely means replacing below PyQt4 import :
</p>
<p>
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
</pre></td><td><pre><span>import</span> PyQt4.<span>QtCore</span> <span>import</span> *
<span>from</span> PyQt4.<span>QtSql</span> <span>import</span> *</pre></td></tr></tbody></table>
<p> 
</p>
<p>
Into PySide import:
</p>
<p>
</p>
<table class="python code"><tbody><tr class="li1"><td><pre>1
2
</pre></td><td><pre><span>from</span> PySide.<span>QtCore</span> <span>import</span> *
<span>from</span> PySide.<span>QtSql</span> <span>import</span> *</pre></td></tr></tbody></table>
<p> 
</p>
<p>
Beside that there is no <code>QString</code> in PySide, the code runs just as well, although with several different behaviours, such as:
</p>
<ol>
	<li>In PySide you may not have more than one <code>QCoreApplication</code>  instance. Having multiple instance of <code>QCoreApplication</code> will result in run-time error. This case is not happening in PyQt application.<code/>   </li>
	<li>It seems that PySide won't be able to load 32 bit SQL drivers in a 64 bit OS. You will also need to use a 64 bit version of Python. Also, in 64 version of Python, you don't have to instantiate <code>QCoreApplication</code>   to have the SQL drivers loaded.</li>
	<li>There is no PySide binary distribution for Python 2.7, so you will have to use either the Python 2.6 version or the Python 3.3 version. </li>
	<li>As there is no <code>QString</code> in PySide, you will simply have to let Python handle string for you. </li>
</ol>
<h1>What's Next?<br/>
</h1>
<p align="justify">
In this article I have gone into practical hands-on on database access using either C++ Qt or PyQt/PySide. We use SQLite and PostgreSQL as the backend database, which simply means loading different SQL drivers. You can also see that the PySide/PyQt application version is a direct translation of its C++ Qt counterpart. 
</p>
<p align="justify">
Our next article will ultimately use Qt Designer to design our application user interface and then we will have a look on how to use the designed user interface into our C++/Python application.
</p>
<p align="justify">
You can download the current state of the application here : <a href="https://www.dropbox.com/sh/t4r9zq0a56xxutk/_hSvz8PPNy/Cross%20Platform%20Qt%20using%20C%2B%2B%2C%20PyQt%20or%20PySide/crossplatformqt-3.zip">crossplatformqt-3.zip</a>. 
</p>
<p align="justify">
Or follow its Github repository here : <a href="https://github.com/pythonthusiast/CrossPlatformQt">pythonthusiast/CrossPlatformQt</a>. 
</p>
<p align="justify">
Stay tuned! 
</p>
<p>
 
</p>


                

            </div>

            </div></body></html>