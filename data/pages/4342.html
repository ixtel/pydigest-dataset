<html><body><div><div class="entry-content">
		<p>I wrote a small command-line text processing program in four different ML-derived languages, to try to get a feel for how they compare in terms of syntax, library, and build-run cycles.</p>
<p><a href="http://en.wikipedia.org/wiki/ML_%28programming_language%29">ML</a> is a family of functional programming languages that have grown up during the past 40 years and more, with strong static typing, type inference, and eager evaluation. I tried out <a href="http://sml-family.org/">Standard ML</a>, <a href="https://ocaml.org/">OCaml</a>, <a href="http://mth.github.io/yeti/">Yeti</a>, and <a href="http://fsharp.org/">F#</a>, all compiling and running from a shell prompt on Linux.</p>
<p>The job was to write a utility that:</p>
<ul>
<li>accepts the name of a CSV (comma-separated values) file as a command-line argument</li>
<li>reads all the lines from that file, each consisting of the same number of numeric columns</li>
<li>sums each column and prints out a single CSV line with the results</li>
<li>handles large inputs</li>
<li>fails if it finds a non-numeric column value or an inconsistent number of columns across lines (an uncaught exception is acceptable)</li>
</ul>
<p>A toy exercise, but one that touches on file I/O, library support, string processing and numeric type conversion, error handling, and the build-invocation cycle.</p>
<p>I tested on a random Big Data CSV file that I had to hand; running the <code>wc</code> (word count) utility on it gives the size and a plausible lower bound for our program’s runtime:</p>
<pre>$ time wc big-data.csv 
 337024 337024 315322496 big-data.csv

real 0m3.086s
user 0m3.050s
sys 0m0.037s
$</pre>
<p>I’ve included timings throughout because I thought a couple of them were interesting, but they don’t tell us much except that none of the languages performed badly (with the slowest taking about 16 seconds on this file).</p>
<p>Finally I wrote the same thing in Python as well for comparison.</p>
<p><small><i><b>Practical disclaimer:</b> If you actually have a CSV file you want to do things like this with, don’t use any of these languages. Do it with <a href="http://www.r-project.org/">R</a> instead, where this exercise takes three lines including file I/O. Or at least use an existing CSV-mangling library.<br/>
</i></small></p>
<p>Here are the programs I ended up with, and my impressions.</p>
<h3>Standard ML</h3>
<p><a href="http://en.wikipedia.org/wiki/Standard_ML">Standard ML</a>, or SML, is the oldest and “smallest” of the four and the only one to have a formal standard, fixed since 1997. Its standard library (the <a href="http://sml-family.org/Basis/">Basis library</a>) is a more recent addition.<br/>
</p>
<div>
<pre><span>fun</span> <span>fold_stream</span> f acc stream =
    <span>case</span> <span>TextIO</span>.inputLine stream <span>of</span>
	SOME line =&gt; fold_stream f (f (line, acc)) stream
      | NONE =&gt; acc
    
<span>fun</span> <span>to_number</span> str =
    <span>case</span> <span>Real</span>.fromString str <span>of</span>
	SOME r =&gt; r
      | NONE =&gt; <span>raise</span> Fail (<span>"Invalid real: "</span> ^ str)
		      
<span>fun</span> <span>values_of_line</span> line =
    <span>let</span> <span>val</span> <span>fields</span> = <span>String</span>.fields (<span>fn</span> c =&gt; c = <span>#","</span>) line <span>in</span>
	map to_number fields
    <span>end</span>

<span>fun</span> <span>add_to</span> [] values = values
  | <span>add_to</span> totals values =
    <span>if</span> length totals = length values <span>then</span>
	<span>ListPair</span>.map (<span>Real</span>.+) (totals, values)
    <span>else</span> <span>raise</span> Fail <span>"Inconsistent-length rows"</span>

<span>fun</span> <span>sum_stream</span> stream =
    fold_stream (<span>fn</span> (line, tot) =&gt; add_to tot (values_of_line line)) [] stream
		    
<span>fun</span> <span>sum_and_print_file</span> filename =
    <span>let</span> <span>val</span> <span>stream</span> = <span>TextIO</span>.openIn filename <span>in</span>
	<span>let</span> <span>val</span> <span>result</span> = sum_stream stream <span>in</span>
	    print ((<span>String</span>.concatWith <span>","</span> (map <span>Real</span>.toString result)) ^ <span>"\n"</span>)
	<span>end</span>;
	<span>TextIO</span>.closeIn stream
    <span>end</span>
							     
<span>fun</span> <span>main</span> () =
    <span>case</span> <span>CommandLine</span>.arguments () <span>of</span> [filename] =&gt; sum_and_print_file filename
      | _ =&gt; <span>raise</span> Fail <span>"Exactly 1 filename must be given"</span>

<span>val</span> () <span>=</span> main ()
</pre>
</div>
<p>(Note that although I haven’t included any type annotations, like all ML variants this is statically typed and the compiler enforces type consistency. There are no runtime type errors.)</p>
<p>This is the first SML program I’ve written since 23 years ago. I enjoyed writing it, even though it’s longer than I’d hoped. The Basis library doesn’t offer a whole lot, but it’s nicely structured and easy to understand. To my eye the syntax is fairly clear. I had some minor problems getting the syntax right first time—I kept itching to add <code>end</code> or semicolons in unnecessary places—but once written, it worked, and my first attempt was fine with very large input files.</p>
<p>I had fun messing around with a few different function compositions before settling on the one above, which takes the view that, since summing up a list is habitually expressed in functional languages as an application of <code>fold</code>, we could start with a function to apply a fold over the sequence of lines in a file.</p>
<p>More abstractly, there’s something delightful about writing a language with a small syntax that was fixed and standardised 18 years ago and that has more than one conforming implementation to choose from. C++ programmers (like me) have spent much of those 18 years worrying about which bits of which sprawling standards are available in which compiler. And let’s not talk about the lifespans of web development frameworks.</p>
<p>To build and run it I used the <a href="http://mlton.org/">MLton</a> native-code compiler:</p>
<pre>$ time mlton -output sum-sml sum.sml

real 0m2.295s
user 0m2.160s
sys 0m0.103s
$ time ./sum-sml big-data.csv 
150.595368855,68.9467923856,[...]

real 0m16.383s
user 0m16.370s
sys 0m0.027s
$</pre>
<p>The executable was a 336K native binary with dependencies on libm, libgmp, and libc. Although the compiler has a good reputation, this was (spoiler alert!) the slowest of these language examples both to build and to run. I also tried the <a href="http://www.polyml.org/">PolyML</a> compiler, with which it took less than a tenth of a second to compile but 26 seconds to run, and <a href="http://mosml.org/">Moscow ML</a>, which was also fast to compile but much slower to run.</p>
<h3>OCaml</h3>
<p><a href="http://en.wikipedia.org/wiki/OCaml">OCaml</a> is a more recent language, from the same root but with a more freewheeling style. It seems to have more library support than SML and, almost certainly, more users. I started taking an interest in it recently because of its use in the <a href="http://openmirage.org/">Mirage OS</a> unikernel project—but of these examples it’s the one in which I’m least confident in my ability to write idiomatic code.<br/>
</p>
<p><em>(Edit: at least two commenters below have posted improved versions of this—thanks!)</em></p>
<div>
<pre><span>open</span> <span>Str</span>

<span>let</span> read_line chan =
  <span>try</span> <span>Some</span> (input_line chan)
  <span>with</span> <span>End_of_file</span> -&gt; <span>None</span>

<span>let</span> <span>rec</span> fold_channel f acc chan =
  <span>match</span> read_line chan <span>with</span>
  | <span>Some</span> line -&gt; fold_channel f (f line acc) chan
  | <span>None</span> -&gt; acc

<span>let</span> values_of_line line =
  <span>let</span> fields = <span>Str</span>.split (<span>Str</span>.regexp <span>","</span>) line <span>in</span>
  <span>List</span>.map float_of_string fields
  
<span>let</span> add_to totals values =
  <span>match</span> totals <span>with</span>
  | <span>[]</span> -&gt; values
  | _  -&gt;
     <span>if</span> <span>List</span>.length totals = <span>List</span>.length values <span>then</span>
       <span>List</span>.map2 (+.) totals values
     <span>else</span> failwith <span>"Inconsistent-length rows"</span>

<span>let</span> sum_channel chan =
  <span>let</span> folder line tot = add_to tot (values_of_line line) <span>in</span>
  fold_channel folder <span>[]</span> chan
	      
<span>let</span> sum_and_print_file filename =
  <span>let</span> chan = open_in filename <span>in</span>
  (<span>let</span> result = sum_channel chan <span>in</span>
   print_string ((<span>String</span>.concat <span>","</span> (<span>List</span>.map string_of_float result)) ^ <span>"\n"</span>);
   close_in chan)

<span>let</span> main <span>()</span> =
  <span>match</span> <span>Sys</span>.argv <span>with</span>
  | [| _; filename |] -&gt; sum_and_print_file filename
  | _ -&gt; failwith <span>"Exactly 1 filename must be given"</span>
    
<span>let</span> <span>()</span> = main <span>()</span>
</pre>
</div>
<p>I’m in two minds about this code. I don’t much like the way it looks and reads. Syntax-wise there are an awful lot of <code>let</code>s; I prefer the way SML uses <code>fun</code> for top-level function declarations and saves <code>let</code> for scoped bindings. OCaml has a more extensive but scruffier library than SML and although there’s lots of documentation, I didn’t find it all that simple to navigate—as a result I’m not sure I’m using the most suitable tools here. There is probably a shorter simpler way. And my first attempt didn’t work for long files: caught out by the fact that <code>input_line</code> throws an exception at end of file (ugh), I broke tail-recursion optimisation by adding an exception handler.</p>
<p>On the other hand, writing this after the SML and Yeti versions, I found it very easy to write syntax that worked, even when I wasn’t quite clear in my head what the syntax was supposed to look like. (At one point I started to worry that the compiler wasn’t working, because it took no time to run and printed no errors.)</p>
<p>I didn’t spot at first that OCaml ships with separate bytecode and optimising native-code compilers, so my first tests seemed a bit slow. In fact it was very fast indeed:</p>
<pre>$ time ocamlopt -o sum-ocaml str.cmxa sum.ml

real 0m0.073s
user 0m0.063s
sys 0m0.003s
$ time ./sum-ocaml big-data.csv 
150.595368855,68.9467923856,[...]

real 0m7.761s
user 0m7.740s
sys 0m0.027s
$</pre>
<p>The OCaml native binary was 339K and depended only on libm, libdl, and libc.</p>
<h3>Yeti</h3>
<p><a href="http://mth.github.io/yeti/">Yeti</a> is an ML-derived language for the Java virtual machine. I’ve written about it a couple of <a title="Conversing with the author of the Yeti programming language" href="http://thebreakfastpost.com/2013/05/29/conversing-with-the-author-of-the-yeti-programming-language/">times</a> <a title="Functional programming and the joy of learning something again" href="http://thebreakfastpost.com/2013/01/08/functional-programming-and-the-joy-of-learning-something-again/">before</a>.<br/>
</p>
<div>
<pre>valuesOfLine line =
    map number (strSplit <span>","</span> line);
    
addTo totals row =
    <span>if</span> empty? totals <span>then</span> <span>array</span> row
    elif length totals == length row <span>then</span> <span>array</span> (map2 (+) totals row)
    <span>else</span> failWith <span>"Inconsistent-length rows"</span>
    fi;

rowsOfFile filename =
    readFile filename <span>"UTF-8"</span>
        <span>do</span> handle: map valuesOfLine (handle.lines <span>()</span>) <span>done</span>;

sumFile filename =
    fold addTo (<span>array</span> <span>[]</span>) (rowsOfFile filename);

sumAndPrintFile filename =
    println (strJoin <span>","</span> (map <span>string</span> (sumFile filename)));

case (<span>list</span> _argv) <span>of</span>
     [filename]: sumAndPrintFile filename;
     _: failWith <span>"Exactly 1 filename must be given"</span>;
esac
</pre>
</div>
<p>I love Yeti’s dismissive approach to function and binding declaration syntax—no <code>let</code> or <code>fun</code> keywords at all. Psychologically, this is great when you’re staring at an empty REPL prompt trying to decide where to start: no syntax to forget, the first thing you need to type is whatever it is that you want your function to produce.</p>
<p>The disadvantage of losing <code>let</code> and <code>fun</code> is that Yeti needs semicolons to separate bindings. It also makes for a visually rather irregular source file.</p>
<p>As OCaml is like a pragmatic SML, so Yeti seems like a pragmatic OCaml. It provides some useful tools for a task like this one. Although the language is eagerly evaluated, lazy lists have language support and are interchangeable with standard lists, so the standard library can expose the lines of a text file as a lazy list making a fold over it very straightforward. The default <code>map</code> and <code>map2</code> functions produce lazy lists.</p>
<p>Unfortunately, this nice feature then bit me on the bottom in my first draft, as the use of a lazy <code>map2</code> in line 6 blew the stack with large inputs (why? not completely sure yet). The standard library has an eager <code>map</code> as well as a lazy one but lacks an eager <code>map2</code>, so I fixed this by converting the number row to an array (arguably the more natural type for it).</p>
<p>The Yeti compiler runs very quickly and compiles to Java .class files. With a small program like this, I would usually just invoke it and have the compiler build and run it in one go:</p>
<pre>$ time yc ./sum.yeti big-data.csv 
150.59536885458684,68.9467923856445,[...]

real 0m14.440s
user 0m26.867s
sys 0m0.423s
$</pre>
<p>Those timings are interesting, because this is the only example to use more than one processor—the JVM uses a second thread for garbage collection. So it took more time than the MLton binary, but finished quicker…</p>
<h3>F♯</h3>
<p><a href="http://en.wikipedia.org/wiki/F_Sharp_%28programming_language%29">F♯</a> is an ML-style language developed at Microsoft and subsequently open-sourced, with a substantial level of integration with the .NET platform and libraries.<br/>
</p>
<p><em>(Edit: as with the OCaml example, you’ll find suggestions for alternative ways to write this in the comments below.)</em></p>
<div>
<pre><span>let</span> addTo totals row =
    <span>match</span> totals <span>with</span>
    | [||] -&gt; row
    | _ -&gt;
       <span>if</span> <span>Array</span>.length totals = <span>Array</span>.length row <span>then</span>
         <span>Array</span>.map2 (+) totals row
       <span>else</span> failwith <span>"Inconsistent-length rows"</span>

<span>let</span> sumOfFields fields =
    <span>let</span> rows = <span>Seq</span>.map (<span>Array</span>.map <span>float</span>) fields <span>in</span>
    <span>Seq</span>.fold addTo [||] rows

<span>let</span> fieldsOfFile filename = 
    seq { <span>use</span> s = <span>System</span>.<span>IO</span>.<span>File</span>.<span>OpenText</span>(filename)
          <span>while</span> <span>not</span> s.<span>EndOfStream</span> <span>do</span> <span>yield</span> s.<span>ReadLine</span><span>()</span>.<span>Split</span> <span>','</span> }

<span>let</span> sumAndPrintFile filename =
    <span>let</span> result = fieldsOfFile filename |&gt; sumOfFields <span>in</span>
    printfn <span>"%s"</span> (<span>String</span>.concat <span>","</span> (<span>Array</span>.map <span>string</span> result))

[&lt;<span>EntryPoint</span>&gt;]
<span>let</span> main argv = 
    <span>match</span> argv <span>with</span>
    | [|filename|] -&gt; (sumAndPrintFile filename; <span>0</span>)
    | _ -&gt; failwith <span>"Exactly 1 filename must be given"</span>
</pre>
</div>
<p>F♯ also has language support for lazy lists, but with different syntax (they’re called sequences) and providing a Python-style <code>yield</code> keyword to generate them via continuations. The sequence generator here came from one of the example tutorials.</p>
<p>A lot of real F♯ code looks like it’s mostly plugging together .NET calls, and there are a lot of capital letters going around, but the basic functional syntax is almost exactly OCaml. It’s interesting that the fundamental unit of text output seems to be the formatted print (<code>printfn</code>). I gather F♯ programmers are fond of their <code>|&gt;</code> operator, so I threw in one of those.</p>
<p>I’m running Linux so I used the open source edition of the F♯ compiler:</p>
<pre>$ time fsharpc -o sum-fs.exe sum.fs
F# Compiler for F# 3.1 (Open Source Edition)
Freely distributed under the Apache 2.0 Open Source License

real 0m2.115s
user 0m2.037s
sys 0m0.063s
$ time ./sum-fs.exe big-data.csv 
150.595368854587,68.9467923856445,[...]

real 0m13.944s
user 0m13.863s
sys 0m0.070s
$</pre>
<p>The compiler produced a mere 7680-byte .NET assembly, that of course (like Yeti) requires a substantial managed runtime. Performance seems pretty good.</p>
<h3>Python</h3>
<p>Python is not an ML-like language; I include it just for comparison.</p>
<div>
<pre><span>import</span> <span>sys</span>

<span>def</span> <span>add_to</span>(totals, values):
    n = <span>len</span>(totals)
    <span>if</span> n == <span>0</span>:
        <span>return</span> values
    <span>elif</span> n == <span>len</span>(values):
        <span>return</span> [totals[i] + values[i] <span>for</span> i <span>in</span> <span>range</span>(n)]
    <span>else</span>:
        <span>raise</span> RuntimeError(<span>"Inconsistent-length rows"</span>)
        
<span>def</span> <span>add_line_to</span>(totals, line):
    values = [<span>float</span>(s) <span>for</span> s <span>in</span> line.strip().split(<span>','</span>)]
    <span>return</span> add_to(totals, values)

<span>def</span> <span>sum_file</span>(filename):
    f = <span>open</span>(filename, <span>'r'</span>)
    totals = []
    <span>for</span> line <span>in</span> f:
        totals = add_line_to(totals, line)
    f.close()
    <span>return</span> totals

<span>if</span> __name__ == <span>'__main__'</span>:
    <span>if</span> <span>len</span>(sys.argv) != <span>2</span>:
        <span>raise</span> RuntimeError(<span>"Exactly 1 filename must be given"</span>)
    result = sum_file(sys.argv[<span>1</span>])
    <span>print</span>(<span>','</span>.join([<span>str</span>(v) <span>for</span> v <span>in</span> result]))
</pre>
</div>
<p>Feels odd having to use the <code>return</code> keyword again, after using languages in which one just leaves the result at the end of the function.</p>
<p>This is compact and readable. A big difference from the above languages is invisible—it’s dynamically typed, without any compile-time type checking.</p>
<p>To build and run this, I just invoked Python on it:</p>
<pre>$ time python ./sum.py ./big-data.csv 
150.59536885458684,68.9467923856445,[...]

real 0m10.939s
user 0m10.853s
sys 0m0.060s
$</pre>
<p>That’s Python 3. Python 2 was about a second faster. I was quite impressed by this result, having expected to suffer from my decision to always return new lists of totals rather than updating the values in them.</p>
<h3>Any conclusions?</h3>
<p>Well, it was a fun exercise. Although I’ve written more in these languages than appears here, and read quite a bit about all of them, I’m still pretty ignorant about the library possibilities for most of them, as well as about the object support in OCaml and F♯.</p>
<p>I am naively impressed by the OCaml compiler. For language “feel”, it gave me the least favourable first impression but I can imagine it being pleasant to use daily.</p>
<p>F♯ on Linux proved unexpectedly straightforward (and fast). Could be a nice choice for web and server applications.</p>
<p>I have made small web and server applications using Yeti and enjoyed the experience. Being able to integrate with existing Java code is good, though of course doubly so when the available libraries in the language itself are so limited.</p>
<p>Standard ML has a clarity and simplicity I really like, and I’d still love to try to use it for something serious. It’s just, well, nobody else seems to—I bet quite a lot of people have learned the language as undergrads (as I did) but it doesn’t seem to be the popular choice outside it. Hardly anyone uses Yeti either, but the Java interoperability means you aren’t so dependent on other developers.</p>
<p>Practically speaking, for jobs like this, and where you want to run something yourself or give someone the source, there’s not much here to recommend anything other than Python. Of course I do appreciate both compile-time typechecking and (for some problems) a more functional style, which is why I’m writing this at all.</p>
<p>But the fact that compilers for both SML and OCaml can generate compact and quick native binaries is interesting, and Yeti and F♯ are notable for their engagement with other existing frameworks.</p>
<p>If you’ve any thoughts or suggestions, do leave a comment.</p>
			</div>

	</div></body></html>