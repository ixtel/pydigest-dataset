<html><body><div><div class="post-content">
				<p>In this installment of Docker 101 you will learn how to create your own Docker image of a simple Python application, push that to a code repository (Github) and set up automatic builds to register the image with the public Docker hub. From a high level, we will use the problem of managing Docker images to motivate learning more about the images themselves.</p>
<p>Please keep in mind this tutorial is meant to be for <em>Docker</em> beginners. Use of things like GitHub and familiarity other web based technical services is assumed. We make only a best effort to explain them well enough to provide a true technical beginner the context to search for more and better explanations. Please do feel free to ask questions in the comments below or offer corrections and details. We always appreciate the feedback.</p>
<p>Series Overview:</p>

<p>If you have advanced past this point and are thinking about running Docker in production on multiple hosts, check out the Docker 201 series on <a href="http://stackengine.wpengine.com/minimum-viable-production-environments-with-docker/">Minimum Viable Production Environment</a> (MVPE):</p>

<h1>Prerequisites</h1>
<p>Open a terminal and ensure your Docker development environment is up. Below is an example from a workstation where the environment is already running:</p>
<div id="attachment_858" class="wp-caption aligncenter"><a href="http://stackengine.wpengine.com/wp-content/uploads/2015/05/Screen-Shot-2015-05-25-at-12.44.15-PM.png"><img src="http://stackengine.wpengine.com/wp-content/uploads/2015/05/Screen-Shot-2015-05-25-at-12.44.15-PM.png" alt="Ladies and Gentleman, Start your Environments" class="size-full wp-image-858" srcset="http://www.stackengine.com/wp-content/uploads/2015/05/Screen-Shot-2015-05-25-at-12.44.15-PM-300x112.png 300w, http://www.stackengine.com/wp-content/uploads/2015/05/Screen-Shot-2015-05-25-at-12.44.15-PM.png 905w" sizes="(max-width: 905px) 100vw, 905px"/></a><p class="wp-caption-text">Ladies and Gentleman, Start your Environments</p></div>
<p>Our first Docker 101 tutorial on <a href="http://stackengine.wpengine.com/docker-101-01-docker-development-environments/">Docker Development Environments</a> was a great success at Austin DevOps and the OpenStack Summit’s Container Day track. If you have not worked your way through that post yet, please be sure to do so as all further content depends on your ability to develop Docker images and run them on your local work station.</p>
<h1>Obtain Github and Public Docker Hub Accounts</h1>
<p>A goal of this series is to leave you with a minimum viable development environment and deployment pipeline. This will likely not be the environment or pipeline you will use as a professional, but it will be something you can <em>reason from</em>. So, if you end up going to work and showing off this environment, then collaborating with peers and fortify it for your professional needs, then we would count that as a huge success. Please let us know!</p>
<p>Ultimately you will have a development pipeline that enables a <code>git push</code> from your workstation to cause a new build of your image on the Docker hub and its registration automagically. You can then run that image on any machine at your disposal that is running the Docker daemon.</p>
<div id="attachment_857" class="wp-caption aligncenter"><a href="http://stackengine.wpengine.com/wp-content/uploads/2015/05/docker_101_dev_pipeline.001.png"><img src="http://stackengine.wpengine.com/wp-content/uploads/2015/05/docker_101_dev_pipeline.001.png" alt="Docker 101 SDLC Pipeline" class="size-full wp-image-857" srcset="http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_dev_pipeline.001-300x225.png 300w, http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_dev_pipeline.001.png 1024w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><p class="wp-caption-text">Docker 101 SDLC Pipeline</p></div>
<p>To this end, you will need free and public Github and Docker Hub account if you don’t have them already.</p>
<h2>Github Account</h2>
<p>If you already have a GitHub account, skip this step.</p>
<p>Open the <a href="https://github.com/">GitHub main page</a> in your browser and create an account. There is no reason to pay for an account as everything done in this series is assumed to be public. Indeed your ability to share the code with others in the comments below is a powerful way to ask questions!</p>
<p>You will need to ensure your SSH public key is uploaded so you can easily push and pull over ssh. Instructions can be <a href="https://help.github.com/articles/generating-ssh-keys/#platform-windows">found here</a> if you are unfamiliar with the process.</p>
<h2>Docker Hub Account</h2>
<p>An account on the public Docker Hub provides you with your own namespace to push and pull images from. This correlates directly to GitHub’s “social coding” paradigm except you share Docker images rather than source code.</p>
<p>Gotcha: Both services use the word “repo”. At GitHub, a repo is a fully realized coding project. This will be application code, dependency files (like gemspec or requirements.txt), Dockerfile and others.  At the Docker Hub, a repo is a fully built image. While we will be tying a GitHub repo to a Docker Hub repo, it is common for Docker Hub repos to stand alone.</p>
<p>Open the <a href="https://hub.docker.com/account/signup/">Docker Hub</a> page and sign up for an account. Again, the free tier will meet your needs for this series.</p>
<p>Keep close track of your credentials and <em>the email address you have signed up with</em>. We will now use these to login to the Docker hub via the command line interface (CLI).</p>
<div id="attachment_859" class="wp-caption aligncenter"><a href="http://stackengine.wpengine.com/wp-content/uploads/2015/05/Screen-Shot-2015-05-25-at-12.47.11-PM.png"><img src="http://stackengine.wpengine.com/wp-content/uploads/2015/05/Screen-Shot-2015-05-25-at-12.47.11-PM.png" alt="Getting Connected to the Docker Hub" class="size-full wp-image-859" srcset="http://www.stackengine.com/wp-content/uploads/2015/05/Screen-Shot-2015-05-25-at-12.47.11-PM-300x50.png 300w, http://www.stackengine.com/wp-content/uploads/2015/05/Screen-Shot-2015-05-25-at-12.47.11-PM.png 902w" sizes="(max-width: 902px) 100vw, 902px"/></a><p class="wp-caption-text">Getting Connected to the Docker Hub</p></div>
<p><strong>What Happened?</strong></p>
<p>You have now told the Docker client on the machine you are on that when you issue a command that would upload (push) and image to the Docker Hub that the namespace <code>behemphi</code> is available. Of course your namespace will be the username you created above with your Docker Hub account.</p>
<p>—</p>
<h1>Image Basics</h1>
<p>If you are a developer, the best way to think of an image is as class while a container would correspond to the the object instantiated from that class. Just like you can instantiate any number of objects from a class, you can start any number of containers from an image provide certain runtime configuration doesn’t conflict (more on that later).</p>
<p>If you are more an operations person, a container image can be though of as a virtual machine image. As any number of VM’s can be started from an image, so too can any number of containers be started from a container image. Like a VM image needs a hypervisor to keep it running, so does the Docker container need a Docker daemon running on a host to keep it running.</p>
<p>You might be aware that images are made of layers and so forth. This is critically important to effective development and operations down the line. However, Turnbull describes this so well in Chapter 5 of <a href="http://goo.gl/nWI6A9"><em>The Docker Book</em></a> that we recommend you read that immediately after completing this blog.</p>
<h2>Image Vocabulary and Names</h2>
<p>Consider the <code>myapp</code> image you currently have from the previous installment. You can now <em>register</em> this image as a <em>repository</em> in your namespace by <em>pushing</em> and <em>tagging</em> it.</p>
<p>Before we are able to register the image at the Docker Hub, we must first tag it locally:</p>
<pre><code>%&gt; docker tag myapp behemphi/myapp:1.0
</code></pre>
<div id="attachment_860" class="wp-caption aligncenter"><a href="http://stackengine.wpengine.com/wp-content/uploads/2015/05/docker_101_02_03.png"><img src="http://stackengine.wpengine.com/wp-content/uploads/2015/05/docker_101_02_03.png" alt="Tagging an Existing Docker Image" class="size-full wp-image-860" srcset="http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_03-300x38.png 300w, http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_03.png 902w" sizes="(max-width: 902px) 100vw, 902px"/></a><p class="wp-caption-text">Tagging an Existing Docker Image</p></div>
<p><strong>What Happened?</strong></p>
<p>Note the output of the <code>docker images</code> command and that the hashes for both images are identical.  All that has happened so far is the image was given a namespace (username), image name (stayed the same) and tag.</p>
<p>Succinctly, there is a many tags to one image relationship.</p>
<p>—</p>
<p>Gotcha: The word “tag” is overloaded in the Docker lexicon. The <code>docker tag</code> command not only tags and image, but also can completely rename it, assign it to a different namespace and even point it towards an completely different public or private registry.  However a “tag” is the bit of the name after the colon (:).  In the case above it is common to say the “myapp” image was tagged as “1.0”.</p>
<p>Study carefully the output of <code>docker tag -h</code> and understand the possibilities.</p>
<p>Now let’s register this image at the Docker Hub:</p>
<pre><code>%&gt; docker push behemphi/myapp:1.0
</code></pre>
<div id="attachment_861" class="wp-caption aligncenter"><a href="http://stackengine.wpengine.com/wp-content/uploads/2015/05/docker_101_02_04.png"><img src="http://stackengine.wpengine.com/wp-content/uploads/2015/05/docker_101_02_04.png" alt="Registering Your First Docker Image" class="size-full wp-image-861" srcset="http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_04-300x104.png 300w, http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_04.png 902w" sizes="(max-width: 902px) 100vw, 902px"/></a><p class="wp-caption-text">Registering Your First Docker Image</p></div>
<p><strong>What Happened?</strong></p>
<p>In summary, all layers of the image were individually uploaded to the Docker Hub under your username. But the details of how this is done are very interesting.</p>
<p>Note all the hashes and the message “Images already pushed, skipping”. Each layer of a Docker image is given a unique hash. When you push to a registry, Docker checks to see if that image already exists, and if so it does not bother to upload it.  Such images are <em>immutable</em> thus this layer is shared for the global Docker Hub name space.</p>
<p>Practically, this means that even though you have the Python:2.7 image as your base, that ~750MB did not get transferred across the wire because the Docker Hub already has it.</p>
<p>From the output above, you can see that only four of the layers actually needed to be uploaded.</p>
<p>—</p>
<p>Now check it out at the Docker Hub itself. In your browser go to <a href="https://registry.hub.docker.com/u/behemphi/myapp/">https://registry.hub.docker.com/u/behemphi/myapp/</a> but be sure to change the username or you will see <em>my</em> image, not your own.</p>
<div id="attachment_863" class="wp-caption aligncenter"><a href="http://stackengine.wpengine.com/wp-content/uploads/2015/05/docker_101_02_06.png"><img src="http://stackengine.wpengine.com/wp-content/uploads/2015/05/docker_101_02_06.png" alt="The myapp Image is now Publically Availabe on the Docker Hub" class="size-full wp-image-863" srcset="http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_06-300x189.png 300w, http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_06-320x202.png 320w, http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_06-700x441.png 700w, http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_06.png 741w" sizes="(max-width: 741px) 100vw, 741px"/></a><p class="wp-caption-text">The myapp Image is now Publically Availabe on the Docker Hub</p></div>
<p>Congrats, you are now able to manually manage your images. Take a break and come back in a bit. Next, we will talk a bit more about building an image from a Dockerfile.</p>
<h1>Why BusyBox is a Worthwhile Headache</h1>
<p>Docker is revolutionary because it simplifies many paradigms previously only available to unicorns such as Google, Netflix and Facebook. These include:</p>
<ul>
<li>A/B Deployments</li>
<li>Instantaneous cross host/data center scaling up and down</li>
<li>Portability across environments</li>
</ul>
<p>Most of these benefits are lost when you have a 1GB image to move around. This is a real problem with our myapp image. If we wanted to deploy it on 100 machines, that would mean moving 100GB of data.</p>
<p>When we want to promote an image from development to QA, moving a GB is time consuming and for us, it is only one container. Many apps are made up of dozens of containers (usually called services). Deploying new code could become a network event (all puns intended).</p>
<p>Ultimately, there is a reason that we don’t bounce ISO images around today. They a unwieldy. Careful consideration of Docker image size empowers portability in all cases (promotion, scaling and deployment). It also means that, in production, <a href="http://stackengine.wpengine.com/container-memory-usage-or-size-matters/">fewer memory and CPU resources</a> are consumed.</p>
<p>BusyBox is a linux distribution of only 5mb is size. Compare this to the the typical 200MB for Ubuntu or Centos and the size savings quickly adds up. There is, alas, no free lunch. Busybox does not have package management (i.e apt or yum) as is generally familiar to us. This means you will have to learn some new techniques for building your image if you want to take advantage of small containers.</p>
<p>In particular, consider the <code>python:2.7</code> and <code>odise/busybox-python:latest</code> images:</p>
<div id="attachment_862" class="wp-caption aligncenter"><a href="http://stackengine.wpengine.com/wp-content/uploads/2015/05/docker_101_02_05.png"><img src="http://stackengine.wpengine.com/wp-content/uploads/2015/05/docker_101_02_05.png" alt="Difference in Python Image Sizes" class="size-full wp-image-862" srcset="http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_05-300x28.png 300w, http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_05.png 905w" sizes="(max-width: 905px) 100vw, 905px"/></a><p class="wp-caption-text">Difference in Python Image Sizes</p></div>
<p>The BusyBox image is 727mb smaller, but what did we give up? The first thing a Python dev will note is that <code>pip</code> is not available by default. The more venerable <code>easy_install</code> is there. If you try to install <code>pip</code> you will quickly land in SSL hell because there are no root certificates in the BusyBox image.</p>
<p>Is it worth learning how to deal with these sorts of issues in the name of container size? We certainly think so, but ultimately the choice is yours. Going forward we will often use these images in lieu of the more canonical containers and operating systems.</p>
<h1>Building Docker Images</h1>
<p>The GitHub code repo for this post is the boilerplate for me and my kids to write a basic sign up app in Python. This will allow their friend to request whitelist status to the Minecraft server running in a container next to it. Rather than cloning the repo, please fork it.</p>
<p>Forking the repo is accomplished by clicking the “Fork” button in the upper right corner of the repo <a href="https://github.com/behemphi/hemphikid">found on the GitHub site</a>. You can learn a bit more about forking from <a href="https://help.github.com/articles/fork-a-repo/">GitHub help</a>.</p>
<p><em>What Happened?</em></p>
<p>GitHub made a complete (deep) copy of the behemphi/hemphikid code repo in your GitHub account.</p>
<p>While this is a deep copy, a relationship still exists via a “pull request”.  Pull requests allow you to change code in your copy of the repo then push them upstream (to my repo) for review, comment and acceptance. This is what GitHub’s tag line, “social coding” refers to.</p>
<p>It is also possible for you to merge any changes I make upstream in to your project at a later day.</p>
<p>The “fork and pull request” method of development is extremely powerful and found in nearly every open source software project out there. It is worth your time to get familiar with it as you are then empowered to contribute changes to something like Docker or Chef (even just the documentation)!</p>
<p>—</p>
<p>Now clone your own repo:</p>
<pre><code>%&gt; cd ~
%&gt; git clone git@github.com:YOURUSERNAME/hemphikid.git docker-austin-101-02
%&gt; cd docker-austin-101-02
</code></pre>
<p>You should now be in a local copy of the code on your workstation.</p>
<h2>Building the Docker Image Locally</h2>
<p>First let’s build and test this image locally as we would if we were a developer. Note below that we are tagging the image in our own namespace for when we want to push it.</p>
<pre><code>%&gt; cd  ~/docker-austin-tutorial-02
%&gt; docker build -t YOURUSERNAME/YOURREPONAME .
</code></pre>
<p>Gotcha: Don’t panic if you see a lot of red. It is intentional.</p>
<p><strong>What Happened?</strong></p>
<p>Unlike the last installment, this time there is a large amount of output, some of it indicating there are potential problems. Read through the output and convince yourself that:</p>
<ul>
<li>These problems should be corrected</li>
<li>There is nothing “show stopping” and we can continue</li>
</ul>
<p>Rectifying these issues is not within the scope of a 101 class. Look for a later post on this, and an exercise below. Remember this is part of the headache (worthwhile?) of using BusyBox.</p>
<p>—</p>
<p>Let’s take a look at the size of this new image by issuing the <code>docker images</code> command.  You should see a list of local images, one of which <code>behemphi/hemphikid</code> with a size of 24.7MB.  This is 30 times smaller than the <code>myapp</code> images at 754MB! Now imaging moving each around your network and you can quickly see why size matters.</p>
<p>Run this application container and see it work locally:</p>
<pre><code>%&gt; docker run -d -p 5000:5000 -v /Users/boyd/docker-austin-tutorial-02:/code -name hemphikid.com behemphi/hemphikid
</code></pre>
<p><strong>What Happened?</strong></p>
<p>A container named <code>hemphikid.com</code> was started from the image specified (in this case <code>behemphi/hemphikid</code>). We map port 5000 on the host to port 5000 on the container. The astute will notice this is different from the directions in the README and on the Docker Hub. This is so we don’t end up with port collisions on our workstation.</p>
<p>Note also that we are running in detached mode.</p>
<p>—</p>
<p>Open a browser and navigate to http://192.168.59.103:5000/.  Note that in some, rare, cases the IP might be different. You can always open a new terminal window and issue a <code>boot2docker up</code> command to see the IP address your set up is using.</p>
<div id="attachment_864" class="wp-caption aligncenter"><a href="http://stackengine.wpengine.com/wp-content/uploads/2015/05/docker_101_02_07.png"><img src="http://stackengine.wpengine.com/wp-content/uploads/2015/05/docker_101_02_07.png" alt="Our App Responds as Expected" class="size-full wp-image-864" srcset="http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_07-300x87.png 300w, http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_07.png 661w" sizes="(max-width: 661px) 100vw, 661px"/></a><p class="wp-caption-text">Our App Responds as Expected</p></div>
<p>This leaves us about where we were in the first installment, but we don’t have the complexity of hooking up Redis. In other words, this is just a static website at this point.</p>
<p>Exercise: Use your development environment to change the text to something you would like to see and refresh your browser to see the changes appear.</p>
<p>You are now ready to have your image automagically registered on the Docker Hub.</p>
<h1>Continuously Registering Docker Images</h1>
<p>While there are great services for managing the complexities of building software on teams and at scale (e.g. Shippable, Jenkins, Bamboo), we are going to keep it simple for now as we build our image management muscles. We want continuous delivery, we just don’t need sophistication yet. We are going to take a step in that direction with “continuous registration”. To that end, the Docker Hub provides a simple automatic build process that links your Github account to the Docker Hub.</p>
<p>Please take a moment to read through <a href="https://docs.docker.com/docker-hub/builds/">this article</a> from Docker detailing the steps to link accounts, security precautions and other information. The basic steps are outlined here:</p>
<ol>
<li><a href="https://docs.docker.com/docker-hub/builds/#linking-your-docker-hub-account-to-a-github-account">Connect your Docker Hub and GitHub accounts</a>. This allows Docker to watch for changes to the code repo on GitHub and cause actions to occur in the corresponding image repo on the Docker Hub.</li>
<li><a href="https://registry.hub.docker.com/builds/github/select/">Select the GitHub repo</a> you would like to connect to the Docker Hub. This will create a new image repo in your Docker Registry namespace the corresponds to the code repo in GitHub.</li>
<li>You will see a new build pending in your image repo. Wait until it is done.</li>
</ol>
<p><strong>What Happened?</strong></p>
<p>You have allowed the Docker Hub to talk to your GitHub account, and told the Docker Hub specifically to build the <code>YOURREPONAME</code> image each time it sees a push to the master branch of the <code>YOURREPONAME</code> code repo on Github.</p>
<p>Once the linking is complete, Docker Hub automatically kicked off the first build.</p>
<p>The important thing to grok here is that you are not performing the build on your infrastructure, nor wasting your time issuing commands, managing storage, etc.</p>
<ul>
<li>You can remain focused on the job of creating value through the product.</li>
<li>The building of the image is now an automated process, this lowers release stress by increasing consistency in the builds</li>
</ul>
<p>You are on the path to realizing all the great thing Humble and Farley describe in <a href="http://goo.gl/X83qoQ"><em>Continous Delivery</em></a>.</p>
<p>—</p>
<p>Note the title of this section is “continuous registering” not “continuous deployment”. Container images are not being put in production, nor are they even being run. Rather they are being registered (staged in this case) in a canonical location from which they can be deployed to another environment via some other sane process.</p>
<p>In the last couple of months, sophisticated tools such as the StackEngine Controller have show up to help manage the deployment of images to production environments. Again, for the purposes of a 101 context we will keep things simple and remain at the command line. Look for more information on managing applications with StackEngine at a later date.</p>
<h2>Running Newly Built Docker Images</h2>
<p>By now your build is likely done and you can see the new image <code>YOURUSERNAME/YOURIMAGENAME:latest</code> in the web GUI of the Docker Hub. So lets place it on a host and see it run!</p>
<p>We will refer to the machine we are deploying the image to as the “target”. For the purposes of this article we suggest you run a cloud server to mimic a production environment. We are running a CoreOS virtual machine at Digital Ocean. If you have yet to dabble in the public cloud, $5 per month for a droplet is a great way to get your feet wet (yep, puns intended).</p>
<p>Alternately you can use your boot2docker VM as your target as well. Just be aware that you will need to do some port and container name juggling. We will point this out in the next couple of steps to help you along if this is what you choose to do.</p>
<p>In all cases we will used a terminal screen with a green background to make it clear that we are looking at the target machine.</p>
<p>On the target, pull and run the image:</p>
<pre><code>%&gt; docker pull YOURUSERNAME/YOURIMAGENAME:latest
%&gt; docker run -d -p 80:5000 --name hemphikid.com YOURUSERNAME/YOURIMAGENAME:latest
</code></pre>
<p>Gotcha: It is <em>IMPORTANT</em> to realize that the image <code>behemphi/hemphikid</code> is a live and publicly available image. You must use your namespace (username), image name (if you changed it) and tag to get the expected result! Check this twice as it will save you a great deal of hair pulling later.</p>
<p>If you are using your boot2docker VM as your target, be sure that the <code>--name</code> flag is set to something different than you used for your development container. This is an artifact of using the same host for both development and “production”. Also consider using port 50001 instead of 80 so you don’t cause any headaches with your workstation’s internet connection. You will then need to go to http://192.168.59.103:5001 to see the resulting message from the deployed container.</p>
<div id="attachment_865" class="wp-caption aligncenter"><a href="http://stackengine.wpengine.com/wp-content/uploads/2015/05/docker_101_02_08.png"><img src="http://stackengine.wpengine.com/wp-content/uploads/2015/05/docker_101_02_08.png" alt="Pulling and Running our Auto Built Image" class="size-full wp-image-865" srcset="http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_08-300x122.png 300w, http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_08-1024x417.png 1024w, http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_08-669x272.png 669w, http://www.stackengine.com/wp-content/uploads/2015/05/docker_101_02_08.png 1033w" sizes="(max-width: 1033px) 100vw, 1033px"/></a><p class="wp-caption-text">Pulling and Running our Auto Built Image</p></div>
<p><strong>What Happened?</strong></p>
<p>Your automagically built image was download from your namespace on the Public Docker Hub. It is now on disk on the target machine.</p>
<p>Once that was done, the image is run so that any traffic pointing to the host on port 80 will be mapped to port 5000 in the container, thus the flask application will respond to the request.</p>
<p>Pro Tip: You could just issue the <code>docker run</code> command and the Docker client will realize the image is not locally available and pull it for you.</p>
<p>—</p>
<p>You have deployed your application to a new environment by managing the images.</p>
<h2>A Demonstration of Continuous Registration</h2>
<p>Let’s make some changes to the code repo:</p>
<ul>
<li>Navigate to the build page of your Docker Hub repo. The address for mine looks like this: https://registry.hub.docker.com/u/behemphi/hemphikid/builds_history/211579/ </li>
<li>Alternatively you can click on your username, the tile with the repo, then the build details tag.</li>
<li>In your development environment, make a change to the <code>app.py</code> file to have it return some text of your choice. </li>
<li>Make a change to the README.md like putting your name at the bottom</li>
<li>Commit your changes and push to master</li>
<li>Refresh your image repository’s build page and note that you now have a pending build listed in the web GUI</li>
</ul>
<p><strong>What Happened?</strong></p>
<p>By pushing your <em>code</em> changes to GitHub, you have <em>triggered</em> a new build of the <em>container image</em> on the Docker Hub.</p>
<p>Essentially you have a new build artifact that you could test for:</p>
<ul>
<li>function compliance</li>
<li>integration compliance</li>
<li>security</li>
<li>perfomance</li>
<li>stress characteristics</li>
</ul>
<p>This is the latest “rage” about containerization; the implications of black box thinking. At StackEngine we refer to it as compliance (enforcement through testing the box) vs. governance (enforcement through controlling the contents of the box).</p>
<p>—</p>
<p>Click on the “Information” tab of your container repo. Note that your changes to the README.md file are also reflected there. The context and instructions you provide as part of the code will carry forward to the image repository as well.</p>
<h1>Closure and Homework</h1>
<p>In this installment you have learned about images within the context of managing images in a deployment pipeline. While unsophisticated, this pipeline coupled with the Docker development environment allow you to code and share your images across environments (dev, test, prod) and platform.</p>
<p>Specifically, we have seen:</p>
<ul>
<li>How to name an image locally</li>
<li>What “tagging” means in its various contexts</li>
<li>How to register a container image in a Docker Hub repository</li>
<li>How to cause the Docker Hub to automatically build images when it is alerted of changes in the code making up that image in a GitHub repository</li>
<li>How to deploy the image from the Docker Hub to the server of your choice.</li>
<li>Used our Docker development environment to easily work with the application code.</li>
<li>Why size matters and how to shrink image sizes</li>
</ul>
<p>In our next installment we will build and run an image of a legacy Java application, dealing with things like data persistence and logging.</p>
<p>Homework:</p>
<ul>
<li>Read Chapter 5 of <a href="http://goo.gl/nWI6A9"><em>The Docker Book</em></a>. It will explain much more about the gory details of an image and the file system</li>
<li>Type <code>docker inspect YOURUSERNAME/YOURIMAGENAME</code> and see what details you glean (do this after reading the chapter)</li>
<li>Go back to the first installment and set up <code>myapp</code> code and image repos that will auto build. Deploy <code>myapp</code> to your target host looking out for port and name collisions</li>
<li>Advanced: When you build the hemphikid image for the first time in section “Building the Docker Image Locally” there were a number of warnings. Track these down and cause the build to happen with no warnings (clean). Make a pull request to the upstream project (behemphi/hemphikid).</li>
<li>Highly Advanced: Redo the Dockerfile for <code>myapp</code> to start from the base odise/busybox-python rather than python:2.7. If you get this done, let me know and we will use it as a lesson on sharing images with the group.</li>
</ul>
<p>Food for Thought:</p>
<p>At Container Days Austin, Paul Czarkowski gave us a fantastic laundry list of ways to optimize the building of images. After reading Chapter 5 of <a href="http://goo.gl/nWI6A9"><em>The Docker Book</em></a>, take a look at his <a href="http://tech.paulcz.net/2015/03/optimizing-your-dockerfiles/">supporting blog post</a>.</p>
<p>Think through our simple Dockerfiles. Could we optimize them? How would we do this? What would we be optimizing for?</p>
							</div>
						</div></body></html>