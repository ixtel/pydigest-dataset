<html><body><div><div class="post-body__content"><p>So you're learning to use the Django Web Framework and you're loving it. But you want an attractive, easy to use API for your application? Look no further than the <a href="http://www.django-rest-framework.org/">Django Rest Framework</a> (DRF). The DRF is powerful, sophisticated, and surprisingly easy to use. It offers an attractive, web browseable version of your API, and the option of returning raw JSON. The Django Rest Framework provides powerful model serialization, display data using standard function based views, or get granular with powerful class based views for more complex functionality. All in a fully REST compliant wrapper. Let's dig in.<br/></p>

<h2>Laying the Foundation</h2>

<p>When working with Python applications, it's always a good idea to sandbox your development with a virtual environment. It helps prevent version collisions between libraries you need in your application and libraries you might already have installed on your machine, it makes it easy to install dependencies within a <em>virtual env</em> using the <code>requirements.txt</code> file, and lastly it makes sharing your development environment with other developers a snap.</p>

<p>Tuts+ has two excellent videos on how to install <a href="http://code.tutsplus.com/articles/python-power-tools-virtualenv--net-31560">virtualenv</a> and <a href="http://code.tutsplus.com/articles/python-power-tools-virtualenvwrapper--net-31569">virtualenvwrapper</a>. Take a few minutes to walk through those videos to get virtualenv and virtualenvwrapper installed on your machine. If you've already got them installed, then skip the next section.</p>

<h3>Setting Up Your Virtual Environment</h3>

<p>The first thing we'll do as part of our application is to set up the virtual environment. Enter the following commands in your Terminal.</p><pre class="brush: bash noskimlinks noskimwords">$ mkvirtualenv drf
$ workon drf</pre>



<p>It doesn't matter where you are in the file system when these commands are run. All virtualenv files are stored in a centralized location and activated on demand.</p>

<h3>Installing the Django Application</h3>

<p>Since this article isn't about Django itself, I've saved some time by creating a repository containing the app we'll be working in. It's a simple bookshelf application which will allow us to store lists of authors and books. <a href="https://github.com/commadelimited/beginners-guide-to-django-rest-framework">Download the companion repository to this article</a>, into the directory of your choice, then run <code>pip install -r requirements.txt</code> to install all of the dependencies. Remember to make sure you've activated the virtual environment we set up in the last step. After the installation is complete, you should be able to type <code>fab runserver</code> to start a local web server and open a web browser pointing to <code>http://127.0.0.1:8000/</code>. If you see a list of authors on screen then you're good to go.</p>

<p>If at any point you're not getting the expected results, please try switching your local repository's branch to final to see the results: <code>git checkout final</code>.</p>

<h4>Fab? What's That?</h4>

<p>Fab == <a href="http://docs.fabfile.org/en/1.8/">Fabric</a>, a <a href="https://gist.github.com/DavidWittman/1886632">Python task runner</a>. From the docs:</p><p>"Fabric is a Python (2.5 or higher) library and command-line tool for streamlining the use of SSH for application deployment or systems administration tasks."</p>

<p>While a more complete discussion about Fabric is beyond the scope of this article, I've implemented some basic fab commands which make working with this application a little easier. You've seen the <code>fab runserver</code> command. There's also the <code>fab shell</code> command which brings up an interactive iPython shell within the context of the application and the <code>fab syncdb</code> command which runs Django's <code class="inline">syncdb</code> command to sync changes in models to the database.</p>

<h2>Working With Serialization</h2>

<p>One powerful feature of the Django Rest Framework is the built in model serialization it offers. With just a few lines of code you can compose powerful representations of your data that can be delivered in a number of formats. As previously mentioned, our application will be a simple bookshelf app, with Authors and Books. I've already created the <code class="inline">Author </code>and <code class="inline">Book </code>models for you, so open up <code>/app/bookreview/models.py</code>. There are already a few Authors stored in the local SQLite database, so let's open up an interactive shell for our app and poke around. Switch to your Terminal window, make sure you're in the <code>./app</code> directory and type in the following command.</p><pre class="brush: bash noskimlinks noskimwords">$ fab shell </pre>

<p>After the shell loads, input the next few lines to retrieve an Author record from the database, which just happens to be mine. What a coincidence. :)</p><pre class="brush: bash noskimlinks noskimwords">$ from bookreview.models import Author
$ author = Author.objects.get(pk=1)
$ author.id
&gt; 1
$ author.first_name
&gt; u'Andy'
$ author.last_name
&gt; u'Matthews'</pre>

<p>Similarly, you can retrieve all of the Author records from the database with a different command:</p><pre class="brush: bash noskimlinks noskimwords">$ from bookreview.models import Author
$ authors = Author.objects.all()
$ authors
&gt; [&lt;Author: Andy Matthews&gt;, &lt;Author: China Mieville&gt;, &lt;Author: Neil Gaiman&gt;, &lt;Author: Veronica Roth&gt;, &lt;Author: Suzanne Collins&gt;, &lt;Author: Brandon Sanderson&gt;, &lt;Author: Rick Riordan&gt;, &lt;Author: Phillip K. Dick&gt;, &lt;Author: John Scalzi&gt;, &lt;Author: Jesse Petersen&gt;]</pre><p>Unfortunately this doesn't return data that an AJAX call can understand. So let's add a serializer for Authors. Close out the shell by typing <code>quit</code> and open up <code>bookreview/serializers.py</code>. Type, or paste, the next few lines of code and save the file.</p><pre class="brush: python noskimlinks noskimwords">class AuthorSerializer(serializers.ModelSerializer):
    """
    Serializing all the Authors
    """
    class Meta:
        model = Author
        fields = ('id', 'first_name', 'last_name')</pre><p>Without making any more changes, the serializer gives us quite a bit of power. Head back into the shell and let's review.</p><pre class="brush: bash noskimlinks noskimwords">$ from bookreview.models import Author
$ from bookreview.serializers import AuthorSerializer
$ author = Author.objects.get(pk=1)
$ serialized = AuthorSerializer(author)
$ serialized.data
&gt; {'id': 1, 'first_name': u'Andy', 'last_name': u'Matthews'}</pre><blockquote>
</blockquote>

<p>Let's add a few more lines of code and see what our API will show us in the browser after our data is run through our new <code class="inline">AuthorSerializer</code>. </p>

<h3>Checking Out the Web Browseable API</h3>

<p>First, open <code>bookreview/urls.py</code> and add the following line just after the <code>index_view</code> route:</p><pre class="brush: python noskimlinks noskimwords">url(r'^authors/$', views.AuthorView.as_view(), name='author-list'),</pre><p>Next, open <code>bookreview/views.py</code> and add these lines to the end of the file:</p><pre class="brush: python noskimlinks noskimwords">class AuthorView(generics.ListAPIView):
    """
    Returns a list of all authors.
    """
    model = Author
    serializer_class = AuthorSerializer</pre><p>Then make sure to add the import for the <code class="inline">AuthorSerializer </code>at the top of the page:</p><pre class="brush: python noskimlinks noskimwords">from bookreview.serializers import AuthorSerializer</pre><p>The default view for the Django Rest Framework is the APIView. It allows you to define your own <code class="inline">get</code>, <code class="inline">put</code>, and <code class="inline">delete </code>methods. It's a good way to get base functionality but still have control over the end result. In our case though, we're letting the DRF do the heavy lifting for us by extending the ListAPIView. We just need to provide a few bits of information to allow the DRF to connect the pieces. We give it the <code class="inline">Author </code>model so that it knows how to talk to the database, and the <code class="inline">AuthorSerializer </code>so that the DRF knows how to return the information. We'll only be working with a few of the built in APIViews, but you can <a href="http://www.django-rest-framework.org/api-guide/generic-views">read about all of the options</a> on the Django Rest Framework website.<br/></p>

<p>Now that you've made those changes, make sure you've got the server running by typing <code>fab runserver</code> then enter the URL <code>http://127.0.0.1:8000/authors/</code>. You should see an attractively designed API view page containing a list of all the authors in the database.</p>

<p>Now that we've got the Authors API view in place, try hitting that URL with a <code class="inline">curl </code>command:</p><pre class="brush: bash noskimlinks noskimwords">$ curl http://127.0.0.1:8000/authors/
&gt; [{"id": 1, "first_name": "Andy", "last_name": "Matthews"},..., {"id": 10, "first_name": "Jesse", "last_name": "Petersen"}]</pre><blockquote>
</blockquote>

<p>Pretty snazzy eh?</p>

<h3>Giving the Authors Some Books!</h3>

<p>While this API view is pretty slick, it's one-for-one with the database. Let's kick up our API view by composing a more complex data set for Authors by including a list of all of their books. Open <code>bookreview/serializers.py</code> and add the following line of code before the <code class="inline">AuthorSerializer</code> class definition.</p><pre class="brush: python noskimlinks noskimwords">class BookSerializer(serializers.ModelSerializer):
    """
    Serializing all the Books
    """
    class Meta:
        model = Book
        fields = ('id', 'title', 'isbn')</pre><p>Before we can add books to the <code class="inline">AuthorSerializer</code>, we have to serialize Books. This should look completely familiar to you. Because it's almost identical to the <code class="inline">AuthorSerializer</code>, we're not going to discuss it.<br/></p>

<p>Next, add the following line immediately after the docstring of the <code class="inline">AuthorSerializer </code>class:</p><pre class="brush: python noskimlinks noskimwords">books = BookSerializer(many=True)</pre>

<p>Then add <code class="inline">books </code>to the fields property of the inner Meta class of the <code class="inline">AuthorSerializer</code>:</p><pre class="brush: python noskimlinks noskimwords">fields = ('id', 'first_name', 'last_name', 'books')</pre><p>Reload the <code>/authors/</code> endpoint and you should now see an array of books coming in for each author. Not bad for just a few more lines of code eh?.<br/></p>

<p>Good guy DRF indeed!</p>

<h4>Use SerializerMethodField to Create Custom Properties</h4>

<p>The serializer is clever...when we indicate which model it should serialize within the inner meta class, it knows everything about that model...properties, lengths, defaults, and so on. Notice that we're not defining any of the properties found on the model directly within the serializer, we're only indicating which fields should be returned to the API in the <code>fields</code> property.</p>

<p>Because the DRF already knows about the properties of the model, it doesn't require us to repeat ourselves. If we wanted, we could be explicit in the <code class="inline">BookSerializer </code>and add the following lines...and the DRF would be just as happy.</p><pre class="brush: python noskimlinks noskimwords">title = serializers.Field(source='title')
isbn = serializers.Field(source='isbn')</pre><p>The <code>serializers.field</code> method allows you to point to an existing property of the model, the <code>source</code> field, and allows you to explicitly name it something else when returning it to the end user. But what about <code>serializers.SerializerMethodField</code>? That allows you to essentially create a custom property, one that's not directly tied to the model, whose content is the result of a method call. In our case, we're going to return a URL which contains a list of places you could go to purchase the book. Let's add that custom method now.<br/></p>

<p>Immediately after the docstring of the <code class="inline">BookSerializer </code>add the following string:</p><pre class="brush: python noskimlinks noskimwords">search_url = serializers.SerializerMethodField('get_search_url')</pre><p>Then after the <code>class Meta</code> definition of the <code class="inline">BookSerializer </code>add the following lines:</p><pre class="brush: python noskimlinks noskimwords">def get_search_url(self, obj):
    return "http://www.isbnsearch.org/isbn/{}".format(obj.isbn)</pre><p>Then lastly we need to add our new property, to the list of fields. Change this:</p><pre class="brush: python noskimlinks noskimwords">fields = ('id', 'title', 'isbn')</pre><p>
to this:</p><pre class="brush: python noskimlinks noskimwords">fields = ('id', 'title', 'isbn', 'search_url')</pre><p>Reload the <code>/authors/</code> endpoint and you should now see a URL coming back along with the other information about the book.<br/></p>

<h3>Adding an Author Endpoint</h3>

<p>We already have a list of authors, but it would be nice for each author to have their own page...just like MySpace right? Lets add an API endpoint to view a single author. Open <code>urls.py</code> and add the following line after the <code>author-list</code> route:</p><pre class="brush: python noskimlinks noskimwords">url(r'^authors/(?P&lt;pk&gt;[\d]+)/$', views.AuthorInstanceView.as_view(), name='author-instance'),</pre><p>Then open <code>views.py</code> and add the following lines after the <code class="inline">AuthorView </code>class:</p><pre class="brush: python noskimlinks noskimwords">class AuthorInstanceView(generics.RetrieveAPIView):
    """
    Returns a single author.
    Also allows updating and deleting
    """
    model = Author
    serializer_class = AuthorSerializer</pre><p>Click one of the author names on the index page and you should see the author Instance page load up.<br/></p>

<h4>Refactoring for the Win!</h4>

<p>Now would be a good time to do a quick bit of refactoring. Since Django offers the option of naming your routes, we can reference the route by that name. This prevents us from having to build the URL manually. Open <code>templates/index.html</code> and swap out the following piece:</p><pre class="brush: html noskimlinks noskimwords">&lt;a href="/authors/{{author.id}}/"&gt;{{author.first_name}} {{author.last_name}}&lt;/a&gt;</pre><p>with this line</p><pre class="brush: html noskimlinks noskimwords">&lt;a href="{% url 'author-instance' author.id %}"&gt;{{author.first_name}} {{author.last_name}}&lt;/a&gt;</pre>

<h2>Saving Data: Let the DRF Work for You!</h2>

<p>Up until now our app has been read only. It's time to start saving some data. Open <code>templates/index.html</code> and add the following lines underneath the Authors header:</p><pre class="brush: html noskimlinks noskimwords">&lt;form action="{% url 'author-list' %}" method="post"&gt;
    &lt;input type="text" name="first_name" /&gt;
    &lt;input type="text" name="last_name" /&gt;
    &lt;input type="submit" value="Add Author" /&gt;
&lt;/form&gt;</pre><p>The DRF isn't quite THAT magical...or is it?</p><p>Open <code>views.py</code>, change the class that <code class="inline">AuthorView </code>extends from <code>generics.ListAPIView</code> to <code>generics.ListCreateAPIView</code>. Then try your request again. Boom! You're an author! And your fourth grade gym teacher said you'd never amount to anything. But what did he know, he has to work around sweaty socks all day. Go back to the main author's page to see your name in lights.</p>

<p>What just happened? The default API View we used only allowed <code class="inline">GET </code>requests to the authors endpoint. By changing it to ListCreateAPIView, we told DRF we wanted to also allow <code class="inline">POST </code>requests. It does everything else for us. We could just as easily define our own <code class="inline">post </code>method within the <code class="inline">AuthorView </code>and do some extra stuff there. It might look like this:</p><pre class="brush: python noskimlinks noskimwords">def post(self, *args, **kwargs):
    import pdb; pdb.set_trace()</pre><p>Keep in mind that while the DRF does enforce database integrity based on the properties of the model, we're not setting any sort of security on who can access or use this form. Diving into security, logging in, and managing permissions is outside the scope of this article, but suffice it to say that <a href="http://www.django-rest-framework.org/api-guide/permissions">DRF does have functionality</a> for allowing access to the views you've been working with and it's fairly trivial to set up.<br/></p>

<h2>Finishing Up</h2>

<p>You've learned quite a lot about the Django Rest Framework now: how to implement a web-viewable API which can return JSON for you, how to configure serializers to compose and transform your data, and how to use class based views to abstract away boilerplate code. </p><p>The DRF has more to it than the few bits we were able to cover, but I hope you'll find it useful for your next application.</p><p/></div></div></body></html>