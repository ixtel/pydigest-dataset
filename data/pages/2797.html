<html><body><div><p>By the way / user is shown Landing, which has no connection with the application. When switching to / app / file server gives app.html, which contains the entire head, all the scripts at the end of a single body and a div with a modest attribute ui-view. It is in this div is loaded all the application. Depending on user is logged in or not, it shows a different filling this div'a.</p>

<p>I will not get ahead of ourselves, and consider the case for the authenticated user. So, in this case in the URL after the / app / no hash inside </p><div><p> &lt;/ div&gt; loaded next layer: index.html. This file have the static part of the application, which surrounds the entire working area: Header, footer and sidebar. In index.html also have a div with the attribute ui-view, which is loaded into another application level - namely, the various screens (in this case: the main screen, the detailed screen of the server screen billing, backup and recovery the screen, etc.)

</p><p><em>Let's see how this all described by ui-router:</em></p>

<pre><code>    app.config(['$stateProvider', '$urlRouterProvider', function ($stateProvider,                      $urlRouterProvider) {
        $stateProvider
            .state('index', {
                url: '/',
                templateUrl: '/static/views/index.html'
            })
            .state('index.main', {
                url: '^/main',
                templateUrl: '/static/views/pages/main.html'
            })
            .state('index.client', {
                url: '^/main/c/:id',
                templateUrl: '/static/views/pages/client.html'
            })
            .state('index.billing', {
                url: '^/billing',
                templateUrl: '/static/views/pages/billing.html'
            })
            .state('index.restore', {
                url: '^/restore',
                templateUrl: '/static/views/pages/restore.html'
            });
        $urlRouterProvider.otherwise('/main');  // ???? ??? ?? ????????? ?? ?         ?????, ?? ???????? ?? ???????? /main
    }])</code></pre>

<p>In the module responsible for the authorization of a factory, which determines whether the user is logged in:</p>

<pre><code>    AuthModule.factory('Auth', ['$cookieStore', function ($cookieStore) {
        var currentUser = $cookieStore.get('login') || 0,
            publicStates = ['login', 'signup', 'recovery'];
        return {
            authorize: function(state) {
                return (this.isLoggedIn() &amp;&amp; (publicStates.indexOf(state) &lt; 0)) ||         (!this.isLoggedIn() &amp;&amp; (publicStates.indexOf(state) &gt;= 0))
            },
            isLoggedIn: function() {
                return !!currentUser;
            }
        }
    }])</code></pre>

<p>Is Logged In method returns true, if the user is logged in, or false otherwise. The method determines authorize for the current state, has a right to the user to be in it.</p>

<p>Use of these methods is done in the event handler $ stateChangeStart, which occurs at the beginning of changes in the state:</p>

<pre><code>    $rootScope.$on("$stateChangeStart", function (event, toState, toParams,         fromState, fromParams) {
        // If the user has no right to be in this state
        if (!Auth.authorize(toState.name)) {
            // It is necessary to prevent further changes in the state
            event.preventDefault();
            // For the case of the primary ways of determining (when entering the /         app / without hash)        
            if (fromState.url === '^') {
                if (Auth.isLoggedIn()) {
                    $state.go('index.main');
                } else {
                    $state.go('auth');
                }
            }
        }
    });</code></pre>

<p><strong>Authentication</strong><br/>The authentication procedure on the client side is implemented using a factory Auth:</p>

<pre><code>    login: function (user, success, error) {
        $http.post('/login/', user)
            .success(function () {
                currentUser = 1;
                success();
            })
            .error(error);
    }</code></pre>

<p>Call this function is performed on the controller. The arguments are passed username, password and callbacks:</p>

<pre><code>    Auth.login({
        username: $scope.login.username,
        password: $scope.login.password
    },
    function () {
        $state.go('index.main');
    },
    function () {
        $scope.login.error = true;
    });</code></pre>

<p>On a server with standard django-sessions is stored user information (its id). It uses standard methods django.contrib.auth.</p>

<pre><code>    from django.contrib.auth import authenticate, login
    def login_service(request):
        data = json.loads(request.body)
        user = authenticate(username=data['username'],         password=data['password'])
        if user is not None:
            login(request, user)
            return HttpResponse(status=200)
        else:
            return HttpResponse('Login error', status=401)</code></pre>

<p>During each http-request, the server checks whether the user is logged in, and sets in the header 'Set-Cookie' appropriate value. This value is checked in the client side using $ cookieStore.get ('login').</p>

<p><strong>Connection between the server and client models</strong><br/>In order to accelerate the development and increase the flexibility of the application, it was decided to use a middleware between Django and AngularJS. The choice fell on django-angular.</p>

<p><em>Its main advantages:</em></p>

<p>provides the ability to perform basic <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="nofollow">CRUD</a> operations;<br/>allows tight tie django-forms and angular-controllers;<br/>provides functionality to call methods in django straight from angular-controller.<br/>For more information about installing and configuring can be found in the <a href="http://django-angular.readthedocs.org/en/latest/" rel="nofollow">documentation</a>.</p>
</div>
      </div></body></html>