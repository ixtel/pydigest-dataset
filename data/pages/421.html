<html><body><div><div class="wpis" id="post-4228">
	
		<span class="data"><small><i>2014-01-27 23:00</i></small></span>
	
	<p>Over the course of several past months and years I was coding in Python, I’ve created quite a few Python packages: both <a href="http://github.com/Xion">open source</a> and for private projects. Even though their most important part was always the code, there are numerous additional files that are necessary for the package to correctly serve its purpose. Rather than part of the Python language, they are more closely related to the Python <em>platform</em>.</p>
<p><img src="http://xion.org.pl/wp-content/uploads/2014/01/snake-anathomy.png" alt=""/>But if you look for any definite, systemic info about them, you will at best find some scattered pieces of knowledge in various unrelated places. At worst, the only guidance would come in the form of a multitude of existing Python package sources, available on GitHub and similar sites. Parroting them is certainly an option, although I believe it’s much more advantageous to acquire firm understanding of how those different cogs fit together. Without it, following the modern Python’s best development practices – which are all hugely beneficial – is largely impossible.</p>
<p>So, I want to fill this void by outlining the structure of a Python package, as completely as possible. You can follow it as a step-by-step guide when creating your next project. Or just skim through it to see what you’re missing, and whether it’d be worthwhile to address such gaps. Any additional element or file will usually provide some tangible benefit, but of course not every project requires all bells and whistles.</p>
<p>Without further ado, let’s see what’s necessary for a complete Python software bundle.<br/>
<span id="more-4228"/></p>
<h3>0. <em>LICENSE</em> file</h3>
<p>Very early, possibly even before you write a single line of code, configuration or documentation, I’d like you first to take a moment and decide how you’re going to distribute your work. It’s fine to belay that decision if it’s not intended to be public, but for any kind of open source projects, establishing a <strong>license</strong> is of paramount importance. In fact, I <a href="http://xion.org.pl/2013/01/31/license-it-please/">wrote about this very topic</a> some time ago.</p>
<p>As for practical matters, generating the actual license text turns out to be extremely easy if you use the incredibly useful, small program called <a href="https://pypi.python.org/pypi/lice">lice</a>. I recommend installing it directly into your global Python interpreter space:</p>

<p>Now you can just navigate to your project’s directory and whip out a license file with one simple command:</p>

<p>Variable parts of license text, such as project’s and author’s name, are filled in automatically. Refer to <code>$ lice --help</code> for more details, and a list of available licenses.</p>
<h3>1. Main Python file</h3>
<p>Now, with clear conscience, you can commence coding. But wait! There is a small piece of boilerplate that you may find tremendously useful to put right on top of your main Python file. “Main” means, of course, either the sole <em>.py</em> module, or <em>__init__.py</em> of the top level package.</p>
<p>Also, it’s not really a boilerplate. It’s more like… an introduction:</p>
<div id="ig-sh-3" class="syntax_hilite">	<div class="code"><ol class="python"><li><p><span>"""</span></p></li>
<li><p><span>dogelchemist :: Turns spam emails into Dogecoins</span></p></li>
<li><p><span>"""</span></p></li>
<li><p>__version__ <span>=</span> <span>"0.0.1"</span></p></li>
<li><p>__author__ <span>=</span> <span>"John Doe"</span></p></li>
<li><p>__license__ <span>=</span> <span>"WTFPL"</span></p></li>
</ol>	</div></div>
<p>It happens that version number, author’s name and program’s license are often needed in at least few parts of the code, and beyond. Examples include:</p>
<ul>
<li><em>setup.py</em> file (see below)</li>
<li>usage/<code>--help</code> documentation, for command line programs</li>
<li>content of <em>About</em> dialog, for GUI programs</li>
<li>text in footer, for web applications</li>
<li>User Agent (e.g. for <a href="http://docs.python.org/2/library/urllib.html#urllib.urlopen"><code>urllib.urlopen</code></a>) and other kind of client identification strings</li>
</ul>
<p>Exposing <code>__version__</code> in code also means that dependent packages may possibly adjust to different releases of your bundle, at least in <em>somewhat</em> systematic way. Should you deprive them of this possibility, they’ll inevitably resort to much nastier hacks.</p>
<h3>2. <em>requirements-test.txt</em></h3>
<p>Most projects rely on existing packages to handle some of their necessary functionality; those are referred to as <strong>dependencies</strong> or <strong>requirements</strong>. By no means this is a necessity, though. Since Python’s standard library is rich and powerful, it’s sometimes possible to build valuable packages based entirely upon standard modules.</p>
<p>The <em>tests</em>, however, are pretty much given to require some assistance. There is little reason not to use a third-party <strong>test runner</strong>, for example. Indeed, something like <a href="https://nose.readthedocs.org/">nose</a> or <a href="http://pytest.org/">py.test</a> makes running tests a breeze and simplifies writing them, too.<br/>
Likewise for the <a href="http://stackoverflow.com/q/98053/434799">various mocking libraries</a>, not to mention more specialized tools for e.g. benchmarking or load testing. Testing can be complicated affair sometimes, especially in a language such as Python where it’s <em>absolutely crucial</em>.</p>
<p>Therefore the recommendation is to put all dependencies required strictly by tests – and tests only! – into a separate <em>requirements-test.txt</em> file. Here’s an example:</p>
<div id="ig-sh-4" class="syntax_hilite">	<div class="code"><ol class="code"><li><p>-e .</p></li>
<li><p> </p></li>
<li><p>py.test==2.5.0</p></li>
<li><p>mocktest==0.7</p></li>
</ol>	</div></div>
<p>Like traditional <em>requirements.txt</em> described later, this file is in the standard format, understood by Pip. With a properly configured Python package, it is also complete enough to allow a single command:</p>
<div id="ig-sh-5" class="syntax_hilite">	<div class="code"><ol class="code"><li><p>$ pip install -r requirements-test.txt</p></li>
</ol>	</div></div>
<p>to install everything what’s necessary for tests to run – and hopefully pass! Being capable of such a level of automation can unlock quite powerful rewards later on, as it’s a prerequisite for any kind of <strong>continuous integration</strong>.</p>
<h3>3. <em>setup.py</em></h3>
<p>Python has no “package description” file <em>per se</em>, akin to <em>package.json</em> from Node.js or <em>*.cabal</em> files for Haskell. Instead, it takes an approach not entirely dissimilar to Ruby’s, where the bundle’s “specification” is also executable code. But Python’s <em>setup.py</em> is not just that: it’s an actual <strong>installation script</strong>.</p>
<p>Although not strictly necessary for executable programs, having a <em>setup.py</em> is still recommended for all Python packages. For libraries, it is absolutely mandatory. In either case, <em>setup.py</em> is the file which enables a package to be installed into the interpreter, and hence imported by any other Python code it runs.</p>
<p>Most of the content of <em>setup.py</em> is typically an invocation of <code>setuptools.setup</code> function. The majority of its parameters are in fact fields in the package’s resume: name, description, author, etc. Rest is more substantial: they describe what Python files the package consists of, and what are its installation requirements.</p>
<p>Let’s have a look at a “real world” example:</p>
<div id="ig-sh-6" class="syntax_hilite">	<div class="code"><ol class="python"><li><p><span>#!/usr/bin/env python</span></p></li>
<li><p><span>"""</span></p></li>
<li><p><span>dogelchemist</span></p></li>
<li><p><span>============</span></p></li>
<li><p> </p></li>
<li><p><span>Turns spam emails into Dogecoins</span></p></li>
<li><p><span>"""</span></p></li>
<li><p> </p></li>
<li><p><span>from</span> setuptools <span>import</span> setup<span>,</span> find_packages</p></li>
<li><p> </p></li>
<li><p><span>import</span> dogelchemist</p></li>
<li><p> </p></li>
<li><p> </p></li>
<li><p>setup<span>(</span></p></li>
<li><p>    name<span>=</span><span>"dogelchemist"</span><span>,</span></p></li>
<li><p>    version<span>=</span>dogelchemist.__version__<span>,</span></p></li>
<li><p>    description<span>=</span><span>"Turns spam emails into Dogecoins"</span><span>,</span></p></li>
<li><p>    long_description<span>=</span>__doc__<span>,</span></p></li>
<li><p>    author<span>=</span>dogelchemist.__author__<span>,</span></p></li>
<li><p>    url<span>=</span><span>"http://example.com/dogelchemist"</span><span>,</span></p></li>
<li><p>    license<span>=</span>dogelchemist.__license__<span>,</span></p></li>
<li><p> </p></li>
<li><p>    classifiers<span>=</span><span>[</span></p></li>
<li><p>        <span>"Intended Audience :: End Users/Desktop"</span><span>,</span></p></li>
<li><p>        <span>"License :: Freely Distributable"</span><span>,</span></p></li>
<li><p>        <span>"Operating System :: OS Independent"</span><span>,</span></p></li>
<li><p>        <span>"Programming Language :: Python"</span><span>,</span></p></li>
<li><p>        <span>"Programming Language :: Python :: 2.6"</span><span>,</span></p></li>
<li><p>        <span>"Programming Language :: Python :: 2.7"</span><span>,</span></p></li>
<li><p>        <span>"Topic :: Office/Business :: Financial"</span><span>,</span></p></li>
<li><p>        <span>"Topic :: Security :: Cryptography"</span><span>,</span></p></li>
<li><p>    <span>]</span><span>,</span></p></li>
<li><p> </p></li>
<li><p>    platforms<span>=</span><span>'any'</span><span>,</span></p></li>
<li><p>    install_requires<span>=</span><span>[</span></p></li>
<li><p>        <span>"requests&gt;=1.0"</span><span>,</span></p></li>
<li><p>        <span>"quantum-gravity&gt;=1.0"</span><span>,</span></p></li>
<li><p>        <span>"unobtanium&gt;=0.4"</span><span>,</span></p></li>
<li><p>    <span>]</span><span>,</span></p></li>
<li><p> </p></li>
<li><p>    packages<span>=</span>find_packages<span>(</span>exclude<span>=</span><span>[</span><span>'tests'</span><span>]</span><span>)</span><span>,</span></p></li>
<li><p>    entry_points<span>=</span><span>{</span></p></li>
<li><p>        <span>'console_scripts'</span>: <span>[</span><span>'dogelchemist=dogelchemist.main:main'</span><span>]</span><span>,</span></p></li>
<li><p>    <span>}</span><span>,</span></p></li>
<li><p><span>)</span></p></li>
</ol>	</div></div>
<p>While this by far doesn’t <a href="https://pythonhosted.org/setuptools/setuptools.html">exhaust the breadth of <code>setup</code> parameters</a>, it demonstrates some of the more common arguments. This includes <code>classifiers=</code>, <a href="https://pypi.python.org/pypi?%3Aaction=list_classifiers">a complete list of which</a> can be found on PyPI website; and <code>entry_points=</code> with executable commands.</p>
<p>But more importantly, we have <code>packages=</code> argument which is almost always used in conjunction with <code>find_packages</code> function. (Should you only have loose modules, you’d use <code>py_modules=</code> instead). We typically exclude tests from packages to be installed, as they are not relevant for end users who just want to use our code.<br/>
Finally, <code>install_requires=</code> lists all the external packages we depend on. For short dependency lists, it’s fine to enumerate them like that, though the usual practice nowadays is to use a dedicated <em>requirements.txt</em> file.</p>
<h3>4. <em>MANIFEST.in</em></h3>
<p>Among the purposes of <em>setup.py</em> is to tell where are <em>.py</em> files. It’s not as good for pointing to all the other necessary files – basically those we’re talking about here.</p>
<p>To maintain tighter control over what goes into final distribution package, we should use a <strong>manifest file</strong> called <em>MANIFEST.in</em>. It acts as a fine grained filter, allowing to include or exclude directories, wildcard groups, or individual files:</p>
<div id="ig-sh-7" class="syntax_hilite">	<div class="code"><ol class="code"><li><p>include LICENSE</p></li>
<li><p>include README.rst</p></li>
<li><p>include requirements-test.txt</p></li>
<li><p>recursive-exclude * *.pyc</p></li>
</ol>	</div></div>
<p>The manifest file is critically important, if only for the first line of the above example. It ensures that even when installing from PyPI, the user still receives a copy of the license.</p>
<h3>5. <em>requirements.txt</em> (optional)</h3>
<p>As mentioned previously, it’s a common practice to extract the dependency list into separate file named <em>requirements.txt</em>. Sometimes it’s even an obligatory, pardon the pun, requirement; that’s how Heroku cloud platform recognizes Python apps, for example.</p>
<p>The file itself is rather straightforward:</p>
<div id="ig-sh-8" class="syntax_hilite">	<div class="code"><ol class="code"><li><p>-e .</p></li>
<li><p> </p></li>
<li><p>requests&gt;=1.0</p></li>
<li><p>quantum-gravity&gt;=1.0</p></li>
<li><p>unobtanium&gt;=0.4</p></li>
</ol>	</div></div>
<p>What’s less obvious is finding a way to tie it back to <em>setup.py</em>, replacing a literal content of <code>install_requires=</code> argument value. For that, I find the following function quite useful:<br/>
<br/>
as it makes everything very straightforward</p>
<div id="ig-sh-9" class="syntax_hilite">	<div class="code"><ol class="python"><li><p>setup<span>(</span></p></li>
<li><p>    ...</p></li>
<li><p>    <span>install_requires</span><span>=</span>read_requirements<span>(</span><span>)</span><span>,</span></p></li>
<li><p>    ...</p></li>
<li><p>    <span>tests_require</span><span>=</span>read_requirements<span>(</span><span>'test'</span><span>)</span><span>,</span></p></li>
<li><p><span>)</span></p></li>
</ol>	</div></div>
<p>Of course, you need to embed it verbatim in your <em>setup.py</em> first, which may diminish the appeal of it somewhat. On the plus side, your requirements’ files may now contain <code>-X</code> flags for Pip (like <code>-e</code> or <code>-r</code>) and comments, which is useful for bigger projects but impossible with simple:</p>
<div id="ig-sh-10" class="syntax_hilite">	<div class="code"><ol class="python"><li><p>install_requires<span>=</span><span>open</span><span>(</span><span>'requirements.txt'</span><span>)</span>.<span>readlines</span><span>(</span><span>)</span><span>,</span></p></li>
</ol>	</div></div>
<h3>6. <em>tox.ini</em> (optional)</h3>
<p>How many Python versions does your package support? The answer is obvious for standalone applications: the only one it’s currently running on.<br/>
But writing a library, we need to treat that issue with a little more gravity. As of now, there are still multiple versions of the language powering thousands of working, production apps. Not just 2.7, but perhaps even 2.6 is not going anywhere anytime soon. Meanwhile, 3.x is increasingly viable option. What do we target?</p>
<p>Whatever we do, it’s important to be explicit and <em>honest</em> about. Explicit means stating it upfront in the <em>README</em> or elsewhere, so that potential users are not left wondering or set up for disappointment. Honest, on the other hand, means fulfilling the promises and <em>actually testing</em> against all these different versions (and implementations) of Python.</p>
<p>This is where wonders of test automation technology come into play. The de facto standard solution for cross-interpreter testing in Python is a tool called <a href="http://tox.readthedocs.org/">tox</a>. Projects that employ it include a <em>tox.ini</em> configuration file, where they list what Python environments they are expected to work in. “Work”, of course, is defined as having the test suite run without any failure.</p>
<p>Simplest <em>tox.ini</em> might look like this:</p>
<div id="ig-sh-11" class="syntax_hilite">	<div class="code"><ol class="code"><li><p>[tox]</p></li>
<li><p>minversion=1.4</p></li>
<li><p>envlist=py26,py27,pypy,py33</p></li>
<li><p> </p></li>
<li><p>[testenv]</p></li>
<li><p>deps=-rrequirements-test.txt</p></li>
<li><p>commands=py.test</p></li>
</ol>	</div></div>
<p>and, I believe, is pretty self-explanatory. This is also where it clearly shows how extracting <em>requirements-test.txt</em> is a worthwhile endeavor. tox will use it to install test dependencies in virtualenvs for each Python version we’ve specified. Then, it will run the test command (here, <code>py.test</code>) and accumulate results for all environments.</p>
<h3>7. <em>.travis.yml</em> (optional)</h3>
<p>Running <code>tox</code> is practical equivalent of “building” a Python project from the continuous integration point of view. I’m pretty sure, though, that no one would fancy keeping up a CI server just for their little open source pet project. Fortunately, this doesn’t mean you need to forgo the benefits of CI anymore.</p>
<p>If you haven’t heard of <a href="http://travis-ci.org">Travis</a>, it’s a free, hosted continuous integration platform for open source projects. As long as your package is publicly available on one of the code hosting providers (like GitHub or Bitbucket), you can configure a hook that’ll make Travis build it after every code push, and notify immediately should a failure occur.</p>
<p>There’s some configuration involved, of course, but it’s limited to providing a fairly basic <em>.travis.yml</em> file:</p>
<div id="ig-sh-12" class="syntax_hilite">	<div class="code"><ol class="code"><li><p>language: python</p></li>
<li><p>python:</p></li>
<li><p>    - "2.6"</p></li>
<li><p>    - "2.7"</p></li>
<li><p>    - "pypy"</p></li>
<li><p>    - "3.3"</p></li>
<li><p> </p></li>
<li><p>install:</p></li>
<li><p>    - pip install -r requirements-test.txt --use-mirrors</p></li>
<li><p>script:</p></li>
<li><p>    - py.test</p></li>
</ol>	</div></div>
<p>Its content is eerily similar to that of <em>tox.ini</em>, which is no coincidence. In practice, you can treat running <code>`tox`</code> as local substitute of a Travis CI build. If the former goes all right, it’s almost certain you can safely push your code upstream, and the latter will build just fine, too.</p>
<h3>8. <em>requirements-dev.txt</em> (optional)</h3>
<p>Almost all of the other files described there, both very mandatory and those quite optional, are provided for the benefit of some (more or less) automated process. I say that, for a change, we should finish off with something that’ll be helpful for <em>humans</em> instead.</p>
<p>The file – which I propose to call <em>requirements-dev.txt</em> – is yet another listing of packages in Pip-compatible format. But they are not any sort of actual dependencies; neither should the project need them to work correctly, nor its test suite require them to pass.<br/>
What I suggest to put into <em>requirements-dev.txt</em> are packages necessary for the <strong>development process</strong> itself. The goal is to streamline the initial setup for the new contributors to our project. Ideally, all they have to do before starting to code would consist of:</p>
<ol>
<li>cloning the project’s repository</li>
<li>creating a <a href="http://xion.org.pl/2012/02/22/importance-of-using-virtual-environments/">virtualenv</a></li>
<li>running <code>$ pip install -r requirements-dev.txt</code></li>
</ol>
<p>Not every project would be complex enough to require some auxiliary tools. For those that don’t, <em>requirements-dev.txt</em> would be reduced to simple delegation:</p>
<div id="ig-sh-13" class="syntax_hilite">	<div class="code"><ol class="code"><li><p>-e .</p></li>
<li><p>-r requirements-test.txt</p></li>
</ol>	</div></div>
<p>which hardly justifies its existence. But in reality, software tends to quickly spread its tendrils far and wide, whilst developers are eager to automate any task that appears cumbersome or mundane. Soon enough, those handcrafted helpers start to surround the core project like growth rings.</p>
<p>In essence, <em>requirements-dev.txt</em> is mostly there to support them. The exact packages that are worthy of putting there will vary from project to project, but common examples would include:</p>
<ul>
<li>configuration and deployment tools, such as like <a href="http://www.fabfile.org">Fabric</a></li>
<li>database migration utilities , e.g. <a href="http://alembic.readthedocs.org/">alembic</a></li>
<li>debuggers and other development aids, like <a href="http://ipython.org/">IPython</a> and <a href="https://pypi.python.org/pypi/ipdb">ipdb</a></li>
<li>test environment managers, including <code>tox</code> that was presented before</li>
<li>tools for measuring test coverage</li>
<li>log analyzers</li>
<li>…and so on</li>
</ul>
<h3>Automation?…</h3>
<p>OK, I think I know what you’re thinking now. You didn’t sign up for this! You just wanted to write some Python code. Why do you need to bother with all these asides? And since we spoke of automation, why they cannot be taken care of… automatically?</p>
<p>Alas, there exist only some incomplete attempts to tackle this issue. <a href="https://github.com/Zulko/picnic.py">Picnic.py</a>, for example, is currently making rounds, but it focuses more on documentation and version control rather than Python-specific artifacts. When it comes to procuring the latter, we are largely on our own. I recommend therefore to closely balance the benefits they may provide with efforts required to create and maintain them.</p>

			
		
</div>
		    
		    </div></body></html>