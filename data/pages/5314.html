<html><body><div><div class="blog-post">

    
    <p>We love Python at Nylas. The syntax is simple and expressive, there are tons of open source modules and frameworks available, and the community is welcoming and diverse. Our backend is <a href="https://github.com/nylas/sync-engine">written exclusively in Python</a>, and our team frequently <a href="https://www.youtube.com/watch?v=Sadng6tR7Q4">gives</a> <a href="https://www.youtube.com/watch?v=u5QT3luWx7w">talks</a> at PyCon and <a href="https://www.dropbox.com/s/1nckhy2ctakhms6/Flask%20APIs.pdf?dl=0">meetups</a>. You could say we are super fans.</p>
<p><img src="/static/img/blog/packaging-deploying-python/python-love.png"/></p>
<p>However, one of Python’s big drawbacks is a lack of clear tools for deploying Python server apps. The state of the art seems to be <em>“run git pull and pray”</em>, which is not an option when users depend on your app. Python deployment becomes even more complicated when your app has <a href="https://github.com/nylas/sync-engine/blob/master/requirements.txt">a lot of dependencies</a> that are also moving. This <a href="https://news.ycombinator.com/item?id=9778408">HN comment</a> sums up the deplorable state of deploying Python.</p>
<h2>Why, after so many years, there is no way for me to ship software written in python, in deb format?
<br/>
<p>—<i>Frustrated HN User</i></p><p/>
</h2>

<p>At Nylas, we’ve developed a better way to deploy Python code along with its dependencies, resulting in lightweight packages that can be easily installed, upgraded, or removed. And we’ve done it without transitioning our entire stack to a system like Docker, CoreOS, or fully-baked AMIs.</p>
<h3 id="babys-first-python-deployment-git-pip_3">Baby’s first python deployment: git &amp; pip</h3>
<p><img src="/static/img/blog/packaging-deploying-python/babys-first-python.png"/></p>
<p>Python offers a rich ecosystem of modules. Whether you’re building a web server or a machine learning classifier, there’s probably a module to help you get started. Today’s standardized way of getting these modules is via pip, which downloads and installs from the Python Package Index (aka PyPI). This is just like apt, yum, rubygem, etc.</p>
<p>Most people set up their development environment by first cloning the code using git, and then installing dependencies via pip. So it makes sense why this is also how most people first try to deploy their code. A deploy script might look something like this:</p>
<p class="codehilite-header">git-pull-pip-install-deploy.sh</p>

<div class="codehilite-body">
<pre class="codehilite">

git clone https://github.com/company/somerepo.git
cd /opt/myproject
pip install -r requirements.txt
python start_server.py
</pre>
</div>

<p>But when deploying large production services, this strategy breaks down for several reasons:</p>
<p><strong>pip does not offer a “revert deploy” strategy</strong><br/>
<code>pip uninstall</code> <a href="https://stackoverflow.com/questions/14572773/pip-is-not-uninstalling-packages">doesn’t always work properly</a>, and there’s no way to “rollback” to a previous state. Virtualenv could help with this, but it’s really not built for managing a history of environments.</p>
<p><strong>Installing dependencies with pip can make deploys painfully slow</strong><br/>
Calling <code>pip install</code> for a module with C extensions will often build it from source, which can take on the order of minutes to complete for a new virtualenv. Deploys should be a fast lightweight process, taking on the order of seconds.</p>
<p><strong>Building your code separately on each host will cause consistency issues</strong><br/>
When you deploy with pip, the version of your app running is not guaranteed to be the same from server to server. Errors in the build process or existing dependencies result in inconsistencies that are difficult to debug.</p>
<p><strong>Deploys will fail if the PyPI or your git server are down</strong><br/>
<code>pip install</code> and <code>git pull</code> oftentimes depend on external servers. You can choose to use third party systems (e.g. Github, PyPI) or setup your own servers. Regardless, it is important to make sure that your deploy process meets the same expectations of uptime and scale. Often external services are the first to fail when you scale your own infrastructure, especially with large deployments.</p>
<p>If you’re running an app that people depend on, and running it across many servers, then the git+pip strategy will only cause headaches. What we need is a deploy strategy that’s fast, consistent and reliable. More specifically:</p>
<ol>
<li>Capability to build code into a single, versioned artifact</li>
<li>Unit and system tests that can test the versioned artifact</li>
<li>A simple mechanism to cleanly install/uninstall artifacts from remote hosts</li>
</ol>
<p>Having these three things would let us spend more time building features, and less time shipping our code in a consistent way.</p>
<h3 id="just-use-docker_3">“Just use Docker”</h3>
<p>At first glance, this might seem like a perfect job for <a href="https://www.docker.com/">Docker</a>, the popular container management tool. Within a Dockerfile, one simply adds a reference to the code repository and installs the necessary libraries and dependencies. Then we build a Docker image, and ship it as the versioned artifact to remote hosts.</p>
<p>However, we ran into several issues when we tried to implement this:</p>
<ul>
<li>Our kernel version (3.2) did not natively support Docker, and we felt that upgrading the kernel just to ship code faster was an overkill solution.</li>
<li>Distributing Docker images within a private network also requires a separate service which we would need to configure, test, and maintain.</li>
<li>Converting our <a href="https://nylas.com/blog/graduating-past-playbooks">ansible setup automation</a> to a Dockerfile would be painful and require a lot of ugly hacks with our logging configuration, user permissions, secrets management, etc.</li>
</ul>
<p><img src="/static/img/blog/packaging-deploying-python/whale.png"/></p>
<p>Even if we succeeded in fixing these issues, our engineering team would have to learn how to interface with Docker in order to debug production issues. We don’t think shipping code faster should involve reimplementing our entire infrastructure automation and orchestration layer. So we searched on.</p>
<h3 id="pex_3">PEX</h3>
<p><a href="https://pex.readthedocs.org/en/latest/">PEX</a> is a clever tool being developed at Twitter that allows Python code to be shipped as executable zip files. It’s a pretty cool idea, and we recommend <a href="https://www.youtube.com/watch?v=NmpnGhRwsu0">Brian Wickman’s Twitter University talk</a> on the subject.</p>
<p>Setting up PEX is simpler than Docker as it only involves running the resultant executable zip file, but building PEX files turned out to be a huge struggle. We ran into several issues building third party library requirements, especially when including static files. We were also confronted with confusing stack traces produced from within PEX’s source code, making it harder to debug builds. This was a dealbreaker, as our primary goal was to improve engineering productivity and make things easier to understand.</p>
<p>Using Docker would have added complexity to our runtime. Using PEX would have added complexity to our builds. We needed a solution that would minimize overall complexity, while giving us reliable deploys, so our search continued.</p>
<h3 id="packages-the-original-containers_3">Packages: the original “containers”</h3>
<p><img src="/static/img/blog/packaging-deploying-python/debian-blimp.png"/></p>
<p>A couple years ago, Spotify quietly released a tool called <a href="https://github.com/spotify/dh-virtualenv">dh-virtualenv</a>, which you can use to build a debian package that contains a virtualenv. We thought this was interesting, and already had lots of experience using Debian and running it in production. (One of our co-founders, Christine, is a <a href="https://openhatch.org/static/static/photos/profile-photos/493197275eae4feda4152f0b32719597">Debian developer</a>.)</p>
<p>Building with <code>dh-virtualenv</code> simply creates a debian package that includes a virtualenv, along with any dependencies listed in the requirements.txt file. When this debian package is installed on a host, it places the virtualenv at <code>/usr/share/python/<project-name/></code>. That’s it.</p>
<p>This is the core of how we deploy code at Nylas. Our continuous integration server (Jenkins) runs dh-virtualenv to build the package, and uses Python’s <a href="https://wheel.readthedocs.org/en/latest/">wheel</a> cache to avoid re-building dependencies. This creates a single bundled artifact (a debian package), which is then run through extensive unit and system tests. If the artifact passes, it is certified as safe for prod and uploaded to s3.</p>
<p>A key part of this process is that we can minimize the complexity of our deploy script by leveraging Debian’s builtin package manager, dpkg. A deploy script might look something like this:</p>
<p class="codehilite-header">simple_deploy.sh</p>

<div class="codehilite-body">
<pre class="codehilite">

temp=$(mktemp /tmp/deploy.deb.XXXXX)
curl “https://artifacts.nylas.net/sync-engine-3k48dls.deb” -o $temp
dpkg -i $temp
sv reload sync-engine

</pre>
</div>

<p>To rollback, we simply deploy the previous versioned artifact. The dpkg utility handles cleaning up the old code for free.</p>
<p>One of the most important aspects of this strategy is that it achieves consistency and reliability, but <em>still matches our development environment</em>. Our engineers already use virtualenvs, and dh-virtualenv is really just a way to ship them to remote hosts. If we had chosen Docker or PEX, we would have had to dramatically change the way we develop locally and introduce a lot of complexity. We also didn’t want to introduce that complexity burden on the developers using our open source code.</p>
<p>Today, we ship all of our Python code with Debian packages. Our entire codebase (with dozens of dependencies) takes fewer than 2 minutes to build, and seconds to deploy.</p>
<h3 id="getting-started-with-dh-virtualenv_3">Getting started with dh-virtualenv</h3>
<p>If you are experiencing painful Python deployments, then ask your doctor about dh-virtualenv. It might be right for you!</p>
<p>Configuring Debian packages can be tricky for newcomers, so we’ve built a utility to help you get started called <a href="https://github.com/nylas/make-deb">make-deb</a>. It generates a Debian configuration based on the setup.py file in your Python project.</p>
<p>First install the <code>make-deb</code> tool, then run it from the root of your project:</p>
<p class="codehilite-header">setup-make-deb.sh</p>

<div class="codehilite-body">
<pre class="codehilite">

cd /my/project
pip install make-deb
make-deb
</pre>
</div>

<p>If information is missing from your setup.py file, <code>make-deb</code> will ask you to add it. Once it has all the needed details, <code>make-deb</code> creates a debian directory at the root of your project that contains all the configuration you’ll need for dh-virtualenv.</p>
<p><em>Building a Debian package requires you to be running Debian with dh-virtualenv installed. If you’re not running Debian, we recommend Vagrant+Virtualbox to set up a Debian VM on Mac or Windows. You can see an example of this configuration by looking at the Vagrantfile in our <a href="https://github.com/nylas/sync-engine">sync engine Git repository</a>.</em></p>
<p>Finally, running <code>dpkg-buildpackage -us -uc</code> will create the Debian package. You don’t need to call dh-virtualenv directly, because it’s already specified in the configuration rules that <code>make-deb</code> created for you. Once this command is finished, you should have a shiny build artifact ready for deployment!</p>
<p>A simple deploy script might look like this:</p>
<p class="codehilite-header">deploy-the-artifact.sh</p>

<div class="codehilite-body">
<pre class="codehilite">

scp my-package.deb remote-host.example.org:
ssh remote-host.example.org

# Run the next commands on remote-host.example.org
dpkg -i my-package.deb

/usr/share/python/myproject/bin/python
&gt;&gt;&gt; import myproject # it works!
</pre>
</div>

<p>To deploy, you need to upload this artifact to your production machine. To install it, just run <code>dpkg -i my-package.deb</code>. Your virtualenv will be placed at <code>/usr/share/python/<project-name/></code> and any script files <a href="https://github.com/nylas/sync-engine/blob/master/setup.py#L64">defined in your setup.py</a> will be available in the accompanying <code>bin</code> directory. And that’s it! You’re on your way to simpler deploys.</p>
<h3 id="wrapping-up_11">Wrapping Up</h3>
<p>When building large systems, the engineering dilemma is often to find a balance between creating proper tooling, but not constantly rearchitecting a new system from scratch. We think using Debian package-based deploys is a great solution for deploying Python apps, and most importantly it lets us ship code faster with fewer issues.</p>
<p>If you have comments, suggestions, or you simply found this article interesting, please <a href="https://twitter.com/nylas">let us know</a>. Thanks for reading!</p>
    

    
    
    

    
    

    
  </div>
</div></body></html>