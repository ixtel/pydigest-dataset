<html><body><div><div class="post-body entry-content" id="post-body-3470481785398575170" itemprop="description articleBody"><p>
In this post would like to present the idea of the vectorization optimization that will be implemented in the PyPy JIT compiler and compare it to vectorization algorithm of an ahead of time compiler.</p>

<b>The big picture </b>
<b><br/></b><p>
The benefit of executing vector statements is hardware support. SSE/AVX/NEON are able to execute vector statements nearly as efficient as doing the computation on only one element in the vector. This speeds up numerical applications.</p><b> </b>

<b>However</b><p>, if you application only spends a fraction of its time executing vector statements the gain in speed will be insignificant.

</p><b>Let's start</b>
<p>
The idea is based on work done in these two sources: </p><i>Exploiting superword level parallelism with multimedia instruction sets</i><p> and </p><i>Compiler optimizations for processors with SIMD instructions </i><p>(see full references at the end)</p><i>.</i>
<p>
To understand the following paragraphs the notion of a dependency graph might help. A </p><i><a href="https://en.wikipedia.org/wiki/Dependency_graph">dependency graph</a> </i><p>has nodes for each instruction of a basic block or trace instructions. If instruction A at position X depends on instruction B at position Y (Y &lt; X), then B must be executed before A.
</p><p>
Using the graph it is possible verify if two instructions can be executed at the same time (they are not dependent).

</p><b>Don't despair! </b><p>The description below contains a lot of domain specific terminology. It is not easy to describe the optimization technique without those and if you are not into programming compilers/VMs you might have a hard time understanding it.

</p><b>Single Instruction Multiple Data (SIMD)</b>
<p>
As the name of SIMD suggests, such an instruction applies an operation to multiple data elements. SSE or AVX would be examples of instruction extensions that allow e.g. arithmetic to be executed on multiple data elements. The size in bytes of a vector register is usually 16-64 depending on the instruction set available on the x86 CPU.

</p><b>The classical approach</b>
<p>
One of the best sources for data elements are (you guessed 
it) arrays. Loops that iterate over arrays are the target of vectorizing
 algorithms in compiler backends. Let's consider an example:
</p><p>
a,b,c = ... # arrays of 32 bit floats 
</p><span><span>for</span> i in <span>range</span>(30):</span>
<span>    a[i] = b[i] + c[i]</span>
<p>
This is one of the most basic examples to show the power of vectorization. If a vector register would hold up to 30 elements of a 32 bit float the loop could be replaced with a single vector statement.
</p><span><br/></span>
<span>a(0:30) = b(0:30) + c(0:30) # Fortran notation</span>
<span><br/></span><p>
If the hardware is able to execute 30 floating point operations at the same time the loop is finished 30 times faster.</p><span/>
<span><br/></span><p>
Having that said, </p><b>this is the theoretical optimal speedup</b><p>. In reality things are not that simple, but these potentially will speedup for your numerical application.

</p><b>Preserving semantics </b>
<p>
How does an optimizer transform such a loop? This is where dependencies between statements of the loop and statements of an iteration come into play. Lets adapt the loop from the previous example:

</p><span><span>for</span> i in <span>range</span>(1,29):</span>
<span>    a[i] = b[i-1] + c[i] # S_1</span>
<span>    b[i] = a[i] * 2      # S_2</span>
<p>
Lets construct the dependencies on a statement level and across iterations.

</p>

<p>
The solid dependency edge (denoted with delta) is a true dependency. a[i] is written in S_1 and used in the rhs expression of S_2. The dashed line is a loop carried dependency. At iteration i &gt; 1, the value of b[i-1] is read of the previous iteration. Each step has a previous step that needs to be completed first, making this example impossible to vectorize (If the loop is unrolled once, it is easier to see that S_2 depends on S_1 across iterations). Let's relax the previous example:

</p><span><span>for</span> i in <span>range</span>(1,29):</span>
<span>    a[i] = b[i-1] + c[i] # S_1</span>
<span>    b[i] = <span>c[i]</span> * 2      # S_2</span>
<p>
Now S_2 does not depend on S_1, thus it is possible to swap the instructions in the loop body and pre compute all values of b[1:29] using vector instruction. Yielding the result:

</p><span>b(1:29) =<span> c(1:29)</span> * 2       # S_2</span>
<span>a(1:29) = b(0:28) + c(0:29) # S_1</span>
<p>
Vectorization on loop basis needs a </p><b>cyclic</b><p> dependency graph and a way to find cycles. Graph algorithms that operate on cyclic graphs </p><b>often have worse complexity</b><p> than acyclic graphs or trees.

</p><b>A new approach to vectorize basic blocks</b>
<p>
The algorithm chosen and already (partly) implemented in the PyPy JIT backend must be able to operate on a trace. A trace represents a sequence of instructions that where executed in the user program quite frequently. Let's have a look at a trace that could have been generated from the first loop snippet (unrolled once):
</p><span><br/></span>
<span># loop</span>
<span><span>for</span> i in <span>range</span>(30):</span>
<span>    a[i] = b[i] + c[i]</span>
<span># trace: </span>
<span>label(a,b,c,i)</span><span/>
<span>j = i + 1</span>
<span>guard_true(j &lt;= 30)</span>
<span>ai = load(a, i)      # S_3</span>
<span>bi = load(b, i)      # S_4</span>
<span>ci = ai + bi         # S_5</span>
<span>store(c, i, ci)      # S_6</span>
<span>k = j + 1</span>
<span>guard_true(k &lt;= 30)</span>
<span>aj = load(a, j)      # S_9</span>
<span>bj = load(b, j)      # S_10</span>
<span>cj = aj + bj         # S_11</span>
<span>store(c, j, cj)      # S_12</span>
<span>jump(a,b,c,k)</span>
<p>
The trick to find vectorizable statements is very simple: We know that the indices i and j are used to load and store from arrays. i = j + 1, thus statement S_3 and S_9 access two elements that are adjacent in the array a.</p><p>
We record them as a pair (S_3,S_9). The same is true for (S_4,S_10) and (S_6,S_12). Now the last missing tile in the puzzle is the addition instructions S_5 and S_11. Lets consider the dependency graph (slightly more complicated):

</p><p class="separator">
</p>


<p>
The sky blue lines from the load operations provide a lead to the two 
addition operations. The algorithm adds new pairs by following the 
definition-use and use-definition edges in the dependency graph. Thus yielding the pair (S_5, S_11). Having all pairs the algorithm tries to extend pairs that are adjacent to each other. In this example above, there is nothing that can be merged, but if the loop is unrolled once more, there will be pairs that can be merged. If a pair is merged it is called a pack. As an example if there are two pairs (a,b), (b,c) they are merged into the pack (a,b,c).
</p><p>
Operations that are independent and adjacent in memory have been merged into packs. The last step is to schedule the instructions using the acyclic dependency graph (see picture above). Scheduling tries to emit grouped operations. For the pair (S_3,S_9) it will schedule all other nodes until both have no preceding dependency and emits an instruction </p><span>v_ai = vec_load(a, i, 2)</span><p> operation instead of two separate load instructions. The resulting trace looks similar to:

</p><span>label(a,b,c,i)</span>
<span>j = i + 1</span>
<span>guard_true(j &lt;= 30)</span>
<span>k = j + 1</span>
<span>guard_true(k &lt;= 30)</span>
<span><span>v_ai = vec_load(a, i, 2)</span></span>
<span><span>v_bi = vec_load(b, i, 2)</span></span>
<span><span>v_ci = vec_add(v_ai,v_bi,2)</span></span>
<span><span>vec_store(c, i, ci)</span></span>
<span>jump(a,b,c,k)</span>
<p>
If we are able to get rid of the redundant index calculation and the weaker </p><span>guard(j &lt;= 30)</span><p>, then the algorithm managed to let the loop finish twice as fast. This will be subject on the next post.

</p><b>Implementation progress</b>
<p>
Things are partly working already and some problems have already been solved. The PyPy backend in my vecopt branch can build dependency graphs of traces, is able to unroll them and apply the algorithm on that unrolled trace. So it is able to group instructions and emits vector operations. In addition I adapted the x86 backend to emit SSE2 vector instructions</p><b> </b><p>and tested it both in the test suite and build a sample interpreter that suddenly was able to boost the loop of 32-bit integer arithmetic 4x faster (wow!).
</p><p>
Still there is a lot todo this summer! I started to test more complicated cases of NumPy traces and currently work on constant and variable expansion.

</p><b>Summary</b>
<p>
In this post I outlined how an ahead of time compiler vectorizes loops. This is not feasible because of the fact that traces do not carry explicit loop information in the loop header. In addition the dependency graph is cyclic and cycle checking is needed. It is also hard to apply loop distribution and loop fission on a trace (it is not easy to reconstruct resume state from a guard in a custom tailored trace). 
</p><p>
Basic blocks also suitable to vectorize statements. Even if the loop is not unrolled, if there is parallelism on statement level, the algorithm will find it. In fact the only few tricks are needed to reschedule traces in a vectorized form: unroll the loop, find pairs, extend them to packs and reschedule them.

</p><b>References</b>
<b> </b> 
<a href="http://groups.csail.mit.edu/commit/papers/2000/SLarsen-SM.pdf"> </a><p>
Larsen, Samuel, and Saman Amarasinghe. </p><i>Exploiting superword level parallelism with multimedia instruction sets</i><p>. Vol. 35. No. 5. ACM, 2000. 
</p><p>
Pryanishnikov, Ivan, Andreas Krall, and Nigel Horspool. "Compiler optimizations for processors with SIMD instructions." </p><i>Software: Practice and Experience</i><p> 37.1 (2007): 93-113.

</p><p/>
</div>
</div></body></html>