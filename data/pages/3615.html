<html><body><div><div class="post-text" itemprop="text">
<p>Pandas does some pretty interesting things with the <a href="https://github.com/pydata/pandas/blob/077b99e17a090901636844612cec581282607ae7/pandas/core/indexing.py">indexing classes</a>. I don't think I am capable of describing a simple way to know which to use but I can give some insight on the implementation.</p>

<p><a href="https://github.com/pydata/pandas/blob/077b99e17a090901636844612cec581282607ae7/pandas/core/indexing.py#L21"><code>DataFrame#ix</code></a> is an <a href="https://github.com/pydata/pandas/blob/077b99e17a090901636844612cec581282607ae7/pandas/core/indexing.py#L1171"><code>_IXIndexer</code></a> which does not declare its own <a href="https://docs.python.org/2/reference/datamodel.html#object.__getitem__"><code>__getitem__</code></a> or <a href="https://docs.python.org/2/reference/datamodel.html#object.__setitem__"><code>__setitem__</code></a>. These two methods are important because they control how values are accessed with Pandas. Since <code>_IXIndexer</code> does not declare these methods the <a href="https://github.com/pydata/pandas/blob/077b99e17a090901636844612cec581282607ae7/pandas/core/indexing.py#L40">super class <code>_NDFrameIndexer</code></a>'s are used instead.</p>

<p>Further digging on the <code>_NDFrameIndexer</code>'s <a href="https://github.com/pydata/pandas/blob/077b99e17a090901636844612cec581282607ae7/pandas/core/indexing.py#L62"><code>__getitem__</code></a> shows that it is relatively simple and in some cases wraps the logic found in <a href="https://github.com/pydata/pandas/blob/077b99e17a090901636844612cec581282607ae7/pandas/core/indexing.py#L65"><code>get_value</code></a>. Then <code>__getitem__</code> is close to as fast as <code>get_value</code> for some scenarios.</p>

<p><code>_NDFrameIndexer</code>'s <a href="https://github.com/pydata/pandas/blob/077b99e17a090901636844612cec581282607ae7/pandas/core/indexing.py#L116"><code>__setitem__</code></a> is a different story. At first it looks simple but the second method it calls is <a href="https://github.com/pydata/pandas/blob/077b99e17a090901636844612cec581282607ae7/pandas/core/indexing.py#L202"><code>_setitem_with_indexer</code></a> which does a considerable amount of work for most scenarios.</p>

<p>This information suggests that calls to get values using <code>ix</code> are limited by <code>get_value</code> in the best case and calls to set values using <code>ix</code> would take a core committer to explain.</p>

<p>Now for <a href="https://github.com/pydata/pandas/blob/077b99e17a090901636844612cec581282607ae7/pandas/core/indexing.py#L25"><code>DataFrame#iat</code></a> which is an <a href="https://github.com/pydata/pandas/blob/077b99e17a090901636844612cec581282607ae7/pandas/core/indexing.py#L1586"><code>_iAtIndexer</code></a> which also doesn't declare its own <code>__getitem__</code> or <code>__setitem__</code> therefor falling back to its super class <a href="https://github.com/pydata/pandas/blob/077b99e17a090901636844612cec581282607ae7/pandas/core/indexing.py#L1527"><code>_ScalarAccessIndexer</code></a>'s implementation.</p>

<p><code>_ScalarAccessIndexer</code> has a <a href="https://github.com/pydata/pandas/blob/077b99e17a090901636844612cec581282607ae7/pandas/core/indexing.py#L1534">simple <code>__getitem__</code></a> implementation but it requires a loop in order to convert the key into the proper format. The additional loop adds some extra processing time before calling <code>get_value</code>.</p>

<p><code>_ScalarAccessIndexer</code> also has a fairly <a href="https://github.com/pydata/pandas/blob/077b99e17a090901636844612cec581282607ae7/pandas/core/indexing.py#L1546">simple <code>__setitem__</code></a> implementation which converts the key the parameters <code>set_value</code> requires before setting the value.</p>

<p>This information suggests that calls to get values using <code>iat</code> are limited by <code>get_value</code> as well as a <a href="https://github.com/pydata/pandas/blob/077b99e17a090901636844612cec581282607ae7/pandas/core/indexing.py#L1602">for loop</a>. Setting values with <code>iat</code> are primarily limited by calls to <code>set_value</code>. So getting values with <code>iat</code> has a bit of an overhead, while setting them has a smaller overhead.</p>

<p><strong>TL;DR</strong></p>

<p>I believe you are using the correct accessor for an <code>Int64Index</code> index based on the documentation but I don't think that means it is the fastest. The best performance can be found using <code>get_value</code> and <code>set_value</code> directly but they require an extra depth of knowledge in how Pandas DataFrames are implemented.</p>

<p><strong>Notes</strong></p>

<p>It is worth noting that the documentation on Pandas mentions that <code>get_value</code> and <code>set_value</code> are deprecated  which I believe was meant to be <a href="http://pandas.pydata.org/pandas-docs/dev/whatsnew.html#selection-deprecations"><code>iget_value</code></a> instead.</p>

<p><strong>Examples</strong></p>

<p>In order to show the difference in performance using a few indexers (including directly calling <code>get_value</code> and <code>set_value</code>) I made this script:</p>

<p><code>example.py</code>:</p>

<pre><code>import timeit


def print_index_speed(stmnt_name, stmnt):
    """
    Repeatedly run the statement provided then repeat the process and take the
    minimum execution time.
    """
    setup = """
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.rand(1000,2),columns = ['A','B'])
idx = 0
    """

    minimum_execution_time = min(
        timeit.Timer(stmnt, setup=setup).repeat(5, 10))

    print("{stmnt_name}: {time}".format(
        stmnt_name=stmnt_name,
        time=round(minimum_execution_time, 5)))

print_index_speed("set ix", "for i in range(1000): df.ix[i, 'A'] = 1")
print_index_speed("set at", "for i in range(1000): df.at[i, 'A'] = 2")
print_index_speed("set iat", "for i in range(1000): df.iat[i, idx] = 3")
print_index_speed("set loc", "for i in range(1000): df.loc[i, 'A'] = 4")
print_index_speed("set iloc", "for i in range(1000): df.iloc[i, idx] = 5")
print_index_speed(
    "set_value scalar",
    "for i in range(1000): df.set_value(i, idx, 6, True)")
print_index_speed(
    "set_value label",
    "for i in range(1000): df.set_value(i, 'A', 7, False)")

print_index_speed("get ix", "for i in range(1000): tmp = df.ix[i, 'A']")
print_index_speed("get at", "for i in range(1000): tmp = df.at[i, 'A']")
print_index_speed("get iat", "for i in range(1000): tmp = df.iat[i, idx]")
print_index_speed("get loc", "for i in range(1000): tmp = df.loc[i, 'A']")
print_index_speed("get iloc", "for i in range(1000): tmp = df.iloc[i, idx]")
print_index_speed(
    "get_value scalar",
    "for i in range(1000): tmp = df.get_value(i, idx, True)")
print_index_speed(
    "get_value label",
    "for i in range(1000): tmp = df.get_value(i, 'A', False)")
</code></pre>

<p>Output:</p>

<pre><code>set ix: 0.9918
set at: 0.06801
set iat: 0.08606
set loc: 1.04173
set iloc: 1.0021
set_value: 0.0452
**set_value**: 0.03516
get ix: 0.04827
get at: 0.06889
get iat: 0.07813
get loc: 0.8966
get iloc: 0.87484
get_value: 0.04994
**get_value**: 0.03111
</code></pre>
    </div>
    </div></body></html>