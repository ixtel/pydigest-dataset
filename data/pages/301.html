<html><body><div><div class="content html_format">
      <i>От переводчика: Armin Ronacher довольно известный разработчик в Python-сообществе(Flask,jinja2,werkzeug). <br/>
Он довольно давно начал своеобразный крестовый поход против Python3, но обвинить его в истерике и ретроградстве не так-то просто: его возражения продиктованы серьезным опытом разработки, он довольно подробно аргументирует свою точку зрения. Немного о терминологии:<br/>
coercion я перевел как принудительное преобразование кодировок, а byte string как байтовые строки, так как термин «сырые» строки(raw string) все же означает несколько иное.<br/>
«Историческое» примечание: в 2012 г. Армин предложил PEP 414, который содержал ряд мер по устранению проблем с Unicode, PEP подтвердили довольно быстро, однако воз и ныне там, так как нижеприведенный текст написан 5 января 2014 года </i> 
<p>
Все труднее становиться вести обоснованную дискуссию о различиях между Python 2 и 3, так как один язык уже мертв,</p><p>
а второй активно развивается. Когда кто-либо начинает обсуждение поддержки Unicode в двух ветках Python — это весьма сложная тема. Вместо рассмотрения поддержки Unicode в двух версиях языка, я рассмотрю базовую модель обработки текста и байтовых строк. 

</p><a name="habracut"/>
 <p>
В данном посте я покажу на примере решений разработчиков языка и стандартной библиотеки,</p><p>
 что Python 2 лучше подходит для работы с текстом и байтовыми строками.
 
</p><p>
С тех пор как мне пришлось сопровождать большое количество кода, который напрямую работал с преобразованием между байтовыми строками и Unicode, ухудшения, произошедшие в Python3, вызвали у меня много печали. Особенно меня раздражают </p><a href="https://speakerdeck.com/pyconslides/python-3-dot-3-trust-me-its-better-than-python-2-dot-7-by-dr-brett-cannon">материалы</a><p> основной команды разработчиков python, которые призывают меня верить, что python 3 лучше 2.7. 

</p><h2>Модель представления текста</h2>
<p>
Главное различие между Python 2 и Python 3 --базовые типы, существующие для работы со строками и байтовыми строками. В Python 3 мы имеем один строковый тип: </p><b>str</b><p>, который хранит данные в Unicode, и два байтовых типа: </p><b>bytes</b><p> и </p><b>bytearray</b><p>. 
 
</p><p>
С другой стороны, в Python 2 у нас есть два строковых типа: </p><b>str</b><p>, который достаточен для любых целей и задач, ограниченных строками в кодировке ASCII + некоторыми неопределенными данными, превышающими интервал в 7 бит. Вместе с типом str у Python2 есть тип данных</p><b>unicode</b><p>, эквивалентный типу данных </p><b>str</b><p> Python 3. Для работы с байтами в Python 2 есть один тип:bytearray, взятый из Python 3. Присмотревшись к ситуации, вы можете заметить, что из Python 3 кое-что удалили: поддержку строковых данных не в юникоде.Компенсацией жертвоприношения стал хешируемый байтовый тип данных(</p><b>bytes</b><p>). Тип данных </p><b>bytarray</b><p> изменяемый, а поэтому он не может быть хеширован. Я очень редко, использую бинарные данные как ключи словаря, а потому возможность или невозможность хеширования бинарных данных не кажется мне очень серьезной. Особенно в Python 2, так как байты могут быть без каких-либо проблем помещены в переменную типа </p><b>str</b><p>. 

</p><h2>Потерянный тип</h2>
<p>
Из Python 3 исключают поддержку байтовых строк, которые в ветке 2.x были типом </p><b>str</b><p>. На бумаге в этом решении нет ничего плохого. С академической точки зрения строки, всегда представленные в юникоде, это прекрасно. И это действительно так, если целый мир — это ваш интерпретатор. К сожалению, в реальном мире, все происходит по-другому: вы вынуждены регулярно работать с разными кодировками, в этом случае подход Python 3 к работе со строками трещит по швам. 
</p><p>
Буду честен перед вами: то как Python 2 обрабатывает Unicode провоцирует ошибки, и я полностью одобряю улучшения обработки Unicode. Моя позиция в том, что, то как это делается в Python 3, является шагом назад и порождает еще больше ошибок, а потому я абсолютно ненавижу работать с Python 3.

</p><h2>Ошибки при работе с Unicode</h2>
<p>
Прежде чем я погружусь в детали, мы должны понять разницу поддержки Unicode в Python 2 и 3,</p><p>
а так же то, почему разработчики приняли решение поменять механизм поддержки Unicode. 
</p><p>
Изначально Python 2 как и многие иные языки до него создавался без поддержки обработки сток разных кодировок.</p><p>
Строка и есть строка, она содержит байты. Это требовало от разработчиков корректно работать с различными</p><p>
 кодировками вручную. Это было вполне приемлемо для многих ситуаций. Многие годы веб-фреймворк Django </p><p>
не работал с Unicode, а использовал исключительно байтовые строки. 
 </p><p>
Тем временем Python 2 годами улучшал внутреннюю поддержку Unicode. Улучшение поддержки Unicode</p><p>
позволяло использовать его для единообразного представления данных в различных кодировках. 
</p><p>
Подход к обработке строк, использующих определенную кодировку, в Python 2 довольно прост:</p><p>
вы берете строку (байтовую), которую вы могли получить откуда угодно, а затем преобразуете</p><p>
ее из той кодировки, которая характерна для источника строки(метаданные, заголовки, иные)</p><p>
в строку Unicode. Став Unicode строкой, она поддерживает все те же операции</p><p>
что и байтовая, но теперь она может хранить больший диапазон символов. </p><p>
Когда вам необходимо передать строку на обработку куда-либо еще, то вы снова </p><p>
преобразуете ее в ту кодировку, которая используется принимающей стороной, </p><p>
 и перед нами вновь байтовая строка 
</p><p>
Какие же особенности связаны с таким подходом? Для того, чтобы это работало на уровне ядра языка,</p><p>
Python 2 должен предоставлять способ перехода из мира без Unicode в прекрасный мир с Unicode. </p><p>
Это возможно благодаря принудительному преобразованию байтовых и небайтовых строк. Когда это происходит </p><p>
и как этот механизм работает?
</p><p>
Основной момент заключается в том, что когда байтовая строка участвует в одной операции с Unicode строкой, </p><p>
то байтовая строка преобразуется в Unicode строку при помощи неявного процесса декодирования строки, который использует кодировку «по умолчанию». Данной кодировкой по умолчанию считается ASCII. Python предоставлял возможность менять кодировку по умолчанию, используя один модуль, но теперь из модуля site.py удалили функции для изменения кодировки по умолчанию, она устанавливается в ASCII. Если запустить интерпретатор с флагом </p><b>-s</b><p>, то функция </p><b>sys.setdefaultencoding</b><p> будет вам доступна и вы сможете поэкспериментировать, чтобы выяснить что произойдет, если вы выставите кодировкой по умолчанию UTF-8. В некоторых ситуациях при работе с кодировкой по умолчанию могут возникнуть проблемы:
</p><p>
1. неявное задание и преобразование кодировки при конкатенации:

</p><pre><code class="python">&gt;&gt;&gt; "Hello " + u"World"
u'Hello World'

</code></pre>
<p>
Здесь левая строка преобразуется, используя кодировку «по умолчанию», в Unicode строку. Если строка содержит не ASCII символы, то при нормальной ситуации выполнения программы преобразование останавливается с выбросом исключения UnicodeDecodeError, так как кодировка по умолчанию — ASCII 
</p><p>
2. Неявное задание и преобразование кодировки при сравнении строк 
</p><pre><code class="python">
&gt;&gt;&gt; "Foo" == u"Foo"
True
</code></pre>
<p>
Это звучит опаснее чем есть на самом деле. Левая часть преобразуется в Unicode, а затем происходит сравнение. В случае, если левая сторона не может быть преобразована, интерпретатор выдает предупреждение, а строки считаются неравными(возвращается False в качестве результата сравнения). Это вполне здравое поведение, если даже при первом знакомстве с ним так не кажется.
 
</p><p>
3. Явное задание и преобразование кодировки, как часть механизма с использованием кодеков.
</p><p>
Это одна из наиболее зловещих вещей и наиболее распостраненный источник всех неудач и недопониманий Unicode в Python 2. Для предоления проблем в этой области в Python 3 предприняли безумный шаг, удалив метод .decode() у Unicode строк и метод .encode() у байтовых строк, это вызвало наибольшее непонимание и досаду у меня. С моей точки зрения это очень глупое решение, но мне много раз говорили что это я ничего не понимаю, возврата назад не будет. 
</p><p>
Явное преобразование кодировки при работе с кодеками выглядит так:
</p><pre><code class="python">
&gt;&gt;&gt; "foo".encode('utf-8')
'foo'
</code></pre>
<p>
Это строка, очевидно, является байтовой строкой. Мы требуем ее преобразовать в UTF-8. Само по себе эnо бессмысленно, так как UTF-8 кодек преобразует строку из Unicode в байтовую строку с кодировкой UTF-8. Как же это работает? UTF-8 кодек видит, что строка не является Unicode строка, а поэтому сначала выполняется принудительное преобразование к Unicode. Пока «foo» только ASCII данные и кодировка по умолчанию ASCII, принудительное преобразование происходит успешно, а уже после этого Unicode строка u«foo» преобразуется в UTF-8.

</p><h2>Механизм кодеков</h2> 
<p>
Теперь вы знаете что Python 2 имеет два подхода к представлению строк: байтами и Unicode. Преобразование между этими представлениями осуществляется при помощи механизма кодеков. Данный механизм не навязывает схему преобразования Unicode-&gt;byte или на нее похожую. Кодек может производить преобразование byte-&gt;byte или Unicode-&gt;Unicode. Фактически система кодеков может реализовывать преобразование между любыми типами Python. Вы можете иметь JSON кодек, который производит преобразование строки в сложный Python объект на ее основе, если сочтете, что такое преобразование вам необходимо. 
</p><p>
Такое положение дел может вызвать проблемы с пониманием механизма, начиная с его основ. Примером этого может быть кодек с названием 'undefined', который может быть установлен в качестве кодировки по умолчанию. В этом случае любые принудительные преобразования кодировок строк будут отключены:

</p><pre><code class="python">
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.setdefaultencoding('undefined')

&gt;&gt;&gt; "foo" + u"bar"
Traceback (most recent call last):
    raise UnicodeError("undefined encoding")
UnicodeError: undefined encoding
     
</code></pre>
<p>
И как же в Python 3 решают проблему с кодеками? Python 3 удаляет все кодеки, которые не выполняют преобразования вида: Unicode&lt;-&gt;byte, а кроме того уже ненужные сейчас метод байтовых строк .encode() и строковый метод .decode(). Это очень плохое решение, так как было очень </p><p>
много полезных кодеков. Например очень распространено использовать преобразование с помощью hex кодека в Python 2:
</p><pre><code class="python">
&gt;&gt;&gt; "\x00\x01".encode('hex')
'0001'  

</code></pre><p>
Пока вы можете сказать, что в данном конкретном случае задача может быть решена при помощи модуля подобного binascii, но проблема более глубока, модули с кодеками доступны отдельно. Например библиотеки, реализующие чтение из сокетов, используют кодеки для частичного преобразования данных из потоков данных библиотеки zlib:
</p><pre><code class="python">
&gt;&gt;&gt; import codecs
&gt;&gt;&gt; decoder = codecs.getincrementaldecoder('zlib')('strict')
&gt;&gt;&gt; decoder.decode('x\x9c\xf3H\xcd\xc9\xc9Wp')
'Hello '
&gt;&gt;&gt; decoder.decode('\xcdK\xceO\xc9\xccK/\x06\x00+\xad\x05\xaf')
'Encodings'

</code></pre><p>
В конце концов, проблема была признана и в Python 3.3 восстановили эти кодеки. Однако сейчас мы снова вводим пользователя в неразбериху, так как кодеки до вызова функций не предоставляют метаинформации о тех типа, которые они могут обработать. По этой причине Python теперь может выбрасывать следующие исключения: 
 </p><pre><code class="python"> 
&gt;&gt;&gt; "Hello World".encode('zlib_codec')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'str' does not support the buffer interface
</code></pre>
<p>
(Обратите внимание, что кодек теперь называется zlib_codec вместо zlib, так как Python 3.3 не сохранил старых обозначений для кодеков)
</p><p>
А что произойдет, если мы вернем назад метод .encode() для байтовых строк, например? Это легко проверить даже без хаков интерпретатора Python. Напишем функцию с аналогичным поведением: 

</p><pre><code class="python">import codecs

def encode(s, name, *args, **kwargs):
    codec = codecs.lookup(name)
    rv, length = codec.encode(s, *args, **kwargs)
    if not isinstance(rv, (str, bytes, bytearray)):
        raise TypeError('Not a string or byte codec')
    return rv
</code></pre>
<p>
Теперь мы можем использовать эту функцию как замену метода .encode() байтовых строк:

</p><pre><code class="python">&gt;&gt;&gt; b'Hello World'.encode('latin1')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'bytes' object has no attribute 'encode'

&gt;&gt;&gt; encode(b'Hello World', 'latin1')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 4, in encode
TypeError: Can't convert 'bytes' object to str implicitly
</code></pre>
<p>
Ага! Python 3 уже умеет работать с такой ситуацией. Мы получаем красивое оповещение об ошибке. Я считаю, что даже “Can't convert 'bytes' object to str implicitly” гораздо лучше и понятней чем “'bytes' object has no attribute 'encode'”. 
</p><p>
Почему бы не вернуть эти методы преобразования кодировки(encode и decode) назад? Я действительно не знаю и не думаю больше об этом. Мне уже многократно объясняли что я ничего не понимаю и я не понимаю новичков, или, то что «текстовая модель» изменилась и мои требования к ней бессмысленны.

</p><h2>Байтовые строки потеряны</h2>
<p>
Теперь вслед за регрессией системы кодеков изменились и строковые операции: они определены лишь для строк Unicode. На первый взгляд это выглядит вполне разумно, но на самом деле это не так. Раньше интерпретатор имел реализации для операций над байтовыми и Unicode строками. Этот подход был совершенно очевиден дял программистов, если объекту нужно было иметь представление в виде байтовой или Unicode строки, определялось два метода:__str__ and __unicode__. Да, конечно, использовалось принудительное изменение кодировки, которое смущало новичков, но зато у нас был выбор. 
</p><p>
Почему это полезно? Потому что, к примеру, если вы работаете с низкоуровневыми протоколами, вам часто необходимо иметь дело с числами в определенном фоормате внутри байтовой строки. 
</p><p>
Собственная система контроля версий, используемая разработчиками Python, не работает на Python 3, потому что годами команда разработки Python </p><a href="http://bugs.python.org/issue3982">не хочет вернуть возможность форматирования для байтовых строк</a><p>. 
</p><p>
Все вышеописанное показывает: модель обработки строковых данных Python 3 не работает в реальном мире. К примеру в Python 3 «обновили» некоторые API, сделав их работающими только с Unicode, а потому они полностью непригодны для применения в реальных рабочих ситуациях. К примеру теперь вы не можете больше анализировать байты с помощью стандартной библиотеки, но только URL. Причина этого в неявном предположении, что все URL представлены лишь в Unicode (при таком положении дел вы уже не сможете работать с почтовыми сообщениями в не Unicode кодировке, если не будете полностью игнорировать существование бинарных вложений в письмо).
</p><p>
Раньше такое было довольно легко исправить, но так как ныне байтовые строки потеряны для разработчиков, библиотека обработки URL имеет ныне две реализации. Одна для Unicode, а вторая для байтовых объектов. Две реализации для одной и той же функции ведут к тому что результат обработки данных может быть очень разным: 
</p><pre><code class="python">
&gt;&gt;&gt; from urllib.parse import urlparse
&gt;&gt;&gt; urlparse('http://www.google.com/')
ParseResult(scheme='http', netloc='www.google.com',
            path='/', params='', query='', fragment='')
&gt;&gt;&gt; urlparse(b'http://www.google.com/')
ParseResultBytes(scheme=b'http', netloc=b'www.google.com',
                 path=b'/', params=b'', query=b'', fragment=b'')

</code></pre><p>
Выглядит достаточно похоже? Вовсе нет, потому что в результате мы имеем совершенно разные типы данных у результата операции. </p><p>
Один из них это кортеж строк, второй больше похож на массив целых чисел. Я уже писал об этом </p><a href="http://lucumr.pocoo.org/2013/7/2/the-updated-guide-to-unicode/">ранее</a><p> и подобное состояние вызывает у меня страдания. Теперь написание кода на Python доставляет мне серьезный дискомфорт или становится крайне неэффективным, так как вам теперь приходится пройти через большое количество преобразований кодировок данных. Из-за этого становится очень сложно писать код, реализующий все необходимые функции. Идея что все Unicode очень хороша в теории, но полностью неприменима на практике. 
</p><p>
Python 3 пронизан кучей костылей для обработки ситуаций, где обрабатывать Unicode невозможно, а у таких как я, которые много работают с такими ситуациями, все это вызывает жуткое раздражение.

</p><h2>Наши костыли не работают</h2>
<p>
Поддержка Unicode в ветке 2.х неидеальна и далека от идеала. Это отсутсвующие API, проблемы, приходящие с разных сторон, но мы как программисты делали все это рабочим. Многие методы, которыми мы это делали ранее больше невозможно применить в Python 3, а некоторые API будут изменены, чтобы хорошо работать с Python 3. 
</p><p>
Мой любимый пример это обработка файловых потоков, которые могли быть как байтовыми, так и текстовыми, но не было надежного метода определить какой перед нами тип потока. Трюк, который я помог популяризировать это чтение нулевого количества байт из потока для определения его типа. Теперь этот трюк </p><a href="http://bugs.python.org/issue20007">не работает</a><p>. К примеру передача объекта запроса библиотеки urllib функции Flask, которая обрабатывает JSON, не работает в Python 3, но работает в Python 2: 

</p><pre><code class="python">&gt;&gt;&gt; from urllib.request import urlopen
&gt;&gt;&gt; r = urlopen('https://pypi.python.org/pypi/Flask/json')
&gt;&gt;&gt; from flask import json
&gt;&gt;&gt; json.load(r)
Traceback (most recent call last):
  File "decoder.py", line 368, in raw_decode
StopIteration
</code></pre>
<p>
В ходе обработки выбрашенного исключения выбрасывается еще одно:
 </p><pre><code class="python"> 
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: No JSON object could be decoded
</code></pre>

<h2>И что же?</h2> 
<p>
Кроме тех проблем, что я описал выше у Python 3 с поддержкой Unicode есть и куча других проблем. Я начал отписываться от твиттеров разработчиков Python потому что мне надоело читать какой Python 3 замечательный, так как это противоречит моему опыту. Да, в Python 3 много плюшек, но то как поступили с обработкой байтовых строк и Unicode к ним не относится. 
 </p><p>
(Хуже всего то, что многие действительно крутые возможности Python 3 обычно столь же хорошо работают и в Python 2. Например yield from, nonlocal, поддержка SNI SSL и т.д. )
</p><p>
В свете того, </p><a href="http://alexgaynor.net/2014/jan/03/pypi-download-statistics/">что только 3% разработчиков Python активно используют Python 3</a><p>, а разработчики Python в Twitter громогласно заъявляют что миграция на Python 3 идет как и планировалось, я испытываю разочарование, так как подробно описывал свой опыт с Python 3 и как от последнего хочется избавиться. 
</p><p>
Я не хочу это делать сейчас, но желаю, чтобы команда разработчиков Python 3 чуть больше прислушалась к мнению сообщества. Для 97% из нас, Python 2, уютненький мирок, в котором мы работали годами, а потому довольно болезненно воспринимается ситуация, когда к нам приходят и заъявляют: Python 3 — прекрасен и это не обсуждается. Это и просто не так в свете множества регрессий. Вместе с теми людьми, которые начинают обсуждать Python 2.8 и Stackless Python 2.8 я не знаю что такое провал, если это не он.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>