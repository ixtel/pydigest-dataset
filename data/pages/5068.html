<html><body><div><div class="content html_format">
      <h2>TL;DR</h2><p>
Чтобы просто установить и изолировать зависимости проекта, </p><a href="https://virtualenv.pypa.io/en/latest/">virtualenv</a><p> часто оказывается слишком тяжелым решением. Предлагаем простую альтернативу:
</p><ol>
<li>добавить <code>./.pip</code> в переменную окружения <code>PYTHONPATH</code>,</li>
<li>установить пакеты локально с помощью <code>pip install -t .pip</code>,</li>
<li>запускать <code>python</code> из папки проекта.</li>
</ol>
<a name="habracut"/>
<h2>Какую версию желаете сегодня?</h2><p>
Установка зависимостей — обязательный шаг практически для любого приложения на Питоне. Каждое приложение зависит от разных библиотек, и чтобы гарантировать его правильное поведение, лучше устанавливать в точности правильные версии библиотек.
</p><p>
Обычная практика — включать в проект файл </p><code>requirements.txt</code><p>. В этом файле перечислены все библиотеки, от которых зависит проект, с номерами версий. Если файл на месте, установить зависимости просто:
</p><pre><code class="bash">$ pip install -r requirements.txt
</code></pre><p>
Пока все хорошо. Плохо станет, если у вас </p><em>два и больше проектов с конфликтующими зависимостями</em><p>. Допустим, проект A работает с библиотекой X только версии 0.1, а проект B — 0.2. По умолчанию pip устанавливает библиотеки глобально в папку интерпретатора Питона. Это означает, что команда </p><code>$ pip install X==0.2</code><p> установит библиотеку X версии 0.2 для </p><em>всех</em><p> проектов и перезапишет версию 0.1, если та уже установлена. Переключение между A и B означает глобальную переустановку X каждый раз, что долго и неудобно.

</p><h2>Остров под солнцем</h2><p>
Популярное решение этой частой проблемы — </p><em>виртуальные окружения</em><p>. Фреймворк </p><a href="https://virtualenv.pypa.io/en/latest/">virtualenv</a><p> создает изолированные Питон-окружения. Зависимости каждого проекта отделяются друг от друга. Так или иначе, некоторым пользователям virtualenv кажется слишком сложным. Поэтому существуют пакеты типа </p><a href="https://virtualenvwrapper.readthedocs.org/en/latest/">virtualenvwrapper</a><p> и </p><a href="https://github.com/kennethreitz/autoenv">autoenv</a><p>, которые расширяют функциональность virtualenv, чтобы им было проще пользоваться. Другие решения: </p><code>Anaconda environments</code><p> и </p><code>pyvenv</code><p> из стандартной библиотеки Питона (3.3+).
</p><p>
Все это отличные инструменты, но нам всегда казалось, что они предлагают довольно тяжелые и сложные решения простой, в общем-то, задачи.
</p><p>
В мире Яваскрипта </p><a href="https://www.npmjs.com/">npm</a><p> и </p><a href="http://bower.io//">Bower</a><p> предлагают простое, надежное и мощное управление пакетами, которого как будто не хватает в Питоне. Их ключ к успеху в том, что они скачивают правильную версию правильной библиотеки и кладут ее в специальную папку внутри проекта. Скачанные библиотеки относятся только к конкретному проекту. Это автоматически избавляет от проблем, о которых говорилось выше.

</p><h2>Чистая магия</h2><p>
Оказывается, есть простой способ повторить подход npm и Bower в Питоне:
</p><ul>
<li>добавить <code>./.pip</code> в <code>PYTHONPATH</code>,</li>
<li>использовать <code>pip</code> с параметром <code>-t .pip</code> для локальной установки пакетов.</li>
</ul><p>
Затем просто запускаете код из папки проекта. Забудьте про </p><code>source env/bin/activate</code><p> и </p><code>deactivate</code><p>!
</p><p>
Фокус работает, потому что </p><code>./.pip</code><p> — относительный путь. В результате, когда запускаете </p><code>python</code><p> из </p><code>~/dev/project_a</code><p>, папка </p><code>~/dev/project_a/.pip</code><p> включается в список папок библиотек для этого экземпляра Питона. Запускаете </p><code>python</code><p> в </p><code>~/dev/project_b</code><p> — включается </p><code>~/dev/project_b/.pip</code><p>. Прием работает на всех популярных платформах: Линуксе, Маке и Виндоузе.
</p><p>
Название папки </p><code>.pip</code><p>, конечно, может быть любым. Кому-то больше понравится </p><code>pip_components</code><p> или </p><code>libs</code><p>. Тем не менее, </p><code>.pip</code><p> быстро печатать, а точка в начале делает папку скрытой в Линуксе и Маке.

</p><h2>Шаг 1: Установить PYTHONPATH</h2>


<h2>Шаг 2: Установить пакеты через <code>pip -t</code></h2><p>
Теперь, когда PYTHONPATH установлена, осталось только установить пакеты в правильное место с помощью pip. Для этого используем ключ </p><code>-t</code><p> или </p><code>--target</code><p>:
</p><pre><code class="bash">$ cd project_a
project_a$ pip install requests==2.7.0 -t .pip

project_a$ python
&gt;&gt;&gt; import requests
&gt;&gt;&gt; requests.__version__
'2.7.0'
</code></pre><p>
Теперь то же самое в другом проекте с другой версией:
</p><pre><code class="bash">$ cd project_b
project_b$ pip install requests==2.6.0 -t .pip

project_b$ python
&gt;&gt;&gt; import requests
&gt;&gt;&gt; requests.__version__
'2.6.0'
</code></pre><p>
С файлом requirements.txt все работает так же:
</p><pre><code class="bash">$ pip install -r requirements.txt -t .pip
</code></pre>

<h2>Потенциальные засады</h2>
<h3>Разные интерпретаторы Питона</h3><p>
Можно легко запустить программу другим интерпретатором Питона:
</p><pre><code class="bash">$ /path/to/python main.py
</code></pre><p>
Тем не менее, есть проблема с переключением между Питоном 2 и 3, если используются пакеты, которые компилируют исходный код во время установки через </p><code>2to3</code><p>. У таких пакетов нет единой кодовой базы, при установке код генерируется соответственно активной версии Питона.
</p><p>
В этом случае создайте папку типа </p><code>.pip3</code><p> и добавьте ее в начало PYTHONPATH, когда запускаете код Питоном 3.

</p><h3>easy_install</h3><p>
Если у вас есть пакеты, установленные глобально через </p><code>easy_install</code><p>, столкнетесь с проблемой: easy_install дописывает путь к таким пакетам в начало </p><code>sys.path</code><p>, поэтому у них приоритет над пакетами из </p><code>.pip</code><p>.
</p><p>
Решение — избавиться от пакетов, установленных глобально через easy_install.
</p><p>
Чтобы проверить, что ничто не мешает использовать .pip, запустите </p><code>import sys;sys.path</code><p> в Питоне. Если перед </p><code>./.pip</code><p> будут другие пути, возможно, придется сначала почистить систему от глобальных easy_install-пакетов.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>