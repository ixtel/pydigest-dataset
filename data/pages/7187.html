<html><body><div><section class="post-content">
            <p>Machine learning is a field that uses algorithms to learn from data and make predictions.  Practically, this means that we can feed data into an algorithm, and use it to make predictions about what might happen in the future.  This has a vast range of applications, from self-driving cars to stock price prediction.  Not only is machine learning interesting, it’s also starting to be widely used, making it an extremely practical skill to learn.</p>

<p>In this tutorial, we’ll guide you through the basic principles of machine learning, and how to get started with machine learning in Python.  Luckily for us, Python has an amazing ecosystem of libraries that make machine learning easy to get started with.  We’ll be using the excellent <a href="http://scikit-learn.org/">Scikit-learn</a>, <a href="http://pandas.pydata.org/">Pandas</a>, and <a href="http://matplotlib.org/">Matplotlib</a> libraries in this tutorial.  </p>

<p>If you want to dive more deeply into machine learning, and apply algorithms in your browser, check out our courses <a href="https://www.dataquest.io/section/machine-learning">here</a>.</p>

<h2 id="the-dataset">The dataset</h2>

<p>Before we dive into machine learning, we’re going to explore a dataset, and figure out what might be interesting to predict.  The dataset is from <a href="http://www.boardgamegeek.com/">BoardGameGeek</a>, and contains data on <code>80000</code> board games.  <a href="http://www.boardgamegeek.com/boardgame/169786/scythe">Here’s</a> a single boardgame on the site.  This information was kindly scraped into <em>csv</em> format by <a href="https://github.com/ThaWeatherman">Sean Beck</a>, and can be downloaded <a href="https://github.com/ThaWeatherman/scrapers/blob/master/boardgamegeek/games.csv">here</a>.  </p>

<p>The dataset contains several data points about each board game.  Here’s a list of the interesting ones:</p>

<ul>
  <li><code>name</code> – name of the board game.</li>
  <li><code>playingtime</code> – the playing time (given by the manufacturer).</li>
  <li><code>minplaytime</code> – the minimum playing time (given by the manufacturer).</li>
  <li><code>maxplaytime</code> – the maximum playing time (given by the manufacturer).</li>
  <li><code>minage</code> – the minimum recommended age to play.</li>
  <li><code>users_rated</code> – the number of users who rated the game.</li>
  <li><code>average_rating</code> – the average rating given to the game by users. (0-10)</li>
  <li><code>total_weights</code> – Number of weights given by users.  <code>Weight</code> is a subjective measure that is made up by BoardGameGeek.  It’s how “deep” or involved a game is.  <a href="http://boardgamegeek.com/wiki/page/Weight">Here’s</a> a full explanation.  </li>
  <li><code>average_weight</code> – the average of all the subjective weights (0-5).</li>
</ul>

<h2 id="introduction-to-pandas">Introduction to Pandas</h2>

<p>The first step in our exploration is to read in the data and print some quick summary statistics.  In order to do this, we’ll us the Pandas library.  Pandas provides data structures and data analysis tools that make manipulating data in Python much quicker and more effective.  The most common data structure is called a <em>dataframe</em>.  A dataframe is an extension of a matrix, so we’ll talk about what a matrix is before coming back to dataframes.</p>

<p>Our data file looks like this (we removed some columns to make it easier to look at):</p>

<pre><code>id,type,name,yearpublished,minplayers,maxplayers,playingtime
12333,boardgame,Twilight Struggle,2005,2,2,180
120677,boardgame,Terra Mystica,2012,2,5,150
</code></pre>

<p>This is in a format called <em>csv</em>, or comma-separated values, which you can read more about <a href="https://en.wikipedia.org/wiki/Comma-separated_values">here</a>.  Each row of the data is a different board game, and different data points about each board game are separated by commas within the row.  The first row is the header row, and describes what each data point is.  The entire set of one data point, going down, is a column.</p>

<p>We can easily conceptualize a csv file as a matrix:</p>

<pre><code>    1       2           3                   4
1   id      type        name                yearpublished
2   12333   boardgame   Twilight Struggle   2005
3   120677  boardgame   Terra Mystica       2012
</code></pre>

<p>We removed some of the columns here for display purposes, but you can still get a sense of how the data looks visually.  A matrix is a two-dimensional data structure, with rows and columns.  We can access elements in a matrix by position.  The first row starts with <code>id</code>, the second row starts with <code>12333</code>, and the third row starts with <code>120677</code>.  The first column is <code>id</code>, the second is <code>type</code>, and so on.  Matrices in Python can be used via the <a href="http://www.numpy.org/">NumPy</a> library.</p>

<p>A matrix has some downsides, though.  You can’t easily access columns and rows by name, and each column has to have the same datatype.  This means that we can’t effectively store our board game data in a matrix – the <code>name</code> column contains strings, and the <code>yearpublished</code> column contains integers, which means that we can’t store them both in the same matrix.</p>

<p>A dataframe, on the other hand, can have different datatypes in each column.  It has has a lot of built-in niceities for analyzing data as well, such as looking up columns by name.  Pandas gives us access to these features, and generally makes working with data much simpler.</p>

<h2 id="reading-in-our-data">Reading in our data</h2>

<p>We’ll now read in our data from a csv file into a Pandas dataframe, using the <code>read_csv</code> method.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Import the pandas library.</span>
<span class="kn">import</span> <span class="nn">pandas</span>

<span class="c"># Read in the data.</span>
<span class="n">games</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">"board_games.csv"</span><span class="p">)</span>
<span class="c"># Print the names of the columns in games.</span>
<span class="k">print</span><span class="p">(</span><span class="n">games</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span></code></pre></div>

<pre><code>Index(['id', 'type', 'name', 'yearpublished', 'minplayers', 'maxplayers',
       'playingtime', 'minplaytime', 'maxplaytime', 'minage', 'users_rated',
       'average_rating', 'bayes_average_rating', 'total_owners',
       'total_traders', 'total_wanters', 'total_wishers', 'total_comments',
       'total_weights', 'average_weight'],
      dtype='object')
</code></pre>

<p>The code above read the data in, and shows us all of the column names.  The columns that are in the data but aren’t listed above should be fairly self-explanatory.</p>



<pre><code>(81312, 20)
</code></pre>

<p>We can also see the shape of the data, which shows that it has <code>81312</code> rows, or games, and <code>20</code> columns, or data points describing each game.</p>

<h2 id="plotting-our-target-variables">Plotting our target variables</h2>

<p>It could be interesting to predict the average score that a human would give to a new, unreleased, board game.  This is stored in the <code>average_rating</code> column, which is the average of all the user ratings for a board game.  Predicting this column could be useful to board game manufacturers who are thinking of what kind of game to make next, for instance.</p>

<p>We can access a column is a dataframe with Pandas using <code>games["average_rating"]</code>.  This will extract a single column from the dataframe.</p>

<p>Let’s plot a <a href="https://en.wikipedia.org/wiki/Histogram">histogram</a> of this column so we can visualize the distribution of ratings.  We’ll use Matplotlib to generate the visualization.  Matplotlib is the main plotting infrastructure in Python, and most other plotting libraries, like <a href="http://stanford.edu/~mwaskom/software/seaborn/">seaborn</a> and <a href="https://github.com/yhat/ggplot">ggplot2</a> are built on top of Matplotlib.</p>

<p>We import Matplotlib’s plotting functions with <code>import matplotlib.pyplot as plt</code>.  We can then draw and show plots.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Import matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="c"># Make a histogram of all the ratings in the average_rating column.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">games</span><span class="p">[</span><span class="s">"average_rating"</span><span class="p">])</span>

<span class="c"># Show the plot.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>

<p><img src="/blog/images/intro_ml/ratings_hist.png" alt="png"/></p>

<p>What we see here is that there are quite a few games with a <code>0</code> rating.  There’s a fairly normal distribution of ratings, with some right skew, and a mean rating around <code>6</code> (if you remove the zeros).</p>

<h2 id="exploring-the-0-ratings">Exploring the 0 ratings</h2>

<p>Are there truly so many terrible games that were given a <code>0</code> rating?  Or is something else happening?  We’ll need to dive into the data bit more to check on this.</p>

<p>With Pandas, we can select subsets of data using Boolean <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.html">series</a> (vectors, or one column/row of data, are known as series in Pandas).  Here’s an example:</p>

<pre><code>games[games["average_rating"] == 0]
</code></pre>

<p>The code above will create a new dataframe, with only the rows in <code>games</code> where the value of the <code>average_rating</code> column equals <code>0</code>.</p>

<p>We can then <em>index</em> the resulting dataframe to get the values we want.  There are two ways to index in Pandas – we can index by the name of the row or column, or we can index by position.  Indexing by names looks like <code>games["average_rating"]</code> – this will return the whole <code>average_rating</code> column of <code>games</code>.  Indexing by position looks like <code>games.iloc[0]</code> – this will return the whole first row of the dataframe.  We can also pass in multiple index values at once – <code>games.iloc[0,0]</code> will return the first column in the first row of <code>games</code>.  Read more about Pandas indexing <a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html">here</a>.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Print the first row of all the games with zero scores.</span>
<span class="c"># The .iloc method on dataframes allows us to index by position.</span>
<span class="k">print</span><span class="p">(</span><span class="n">games</span><span class="p">[</span><span class="n">games</span><span class="p">[</span><span class="s">"average_rating"</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="c"># Print the first row of all the games with scores greater than 0.</span>
<span class="k">print</span><span class="p">(</span><span class="n">games</span><span class="p">[</span><span class="n">games</span><span class="p">[</span><span class="s">"average_rating"</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></code></pre></div>

<pre><code>id                             318
type                     boardgame
name                    Looney Leo
users_rated                      0
average_rating                   0
bayes_average_rating             0
Name: 13048, dtype: object
id                                  12333
type                            boardgame
name                    Twilight Struggle
users_rated                         20113
average_rating                    8.33774
bayes_average_rating              8.22186
Name: 0, dtype: object
</code></pre>

<p>This shows us that the main difference between a game with a <code>0</code> rating and a game with a rating above <code>0</code> is that the <code>0</code> rated game has no reviews.  The <code>users_rated</code> column is <code>0</code>.  By filtering out any board games with <code>0</code> reviews, we can remove much of the noise.</p>

<h2 id="removing-games-without-reviews">Removing games without reviews</h2>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Remove any rows without user reviews.</span>
<span class="n">games</span> <span class="o">=</span> <span class="n">games</span><span class="p">[</span><span class="n">games</span><span class="p">[</span><span class="s">"users_rated"</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
<span class="c"># Remove any rows with missing values.</span>
<span class="n">games</span> <span class="o">=</span> <span class="n">games</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></code></pre></div>

<p>We just filtered out all of the rows without user reviews.  While we were at it, we also took out any rows with missing values.  Many machine learning algorithms can’t work with missing values, so we need some way to deal with them.  Filtering them out is one common technique, but it means that we may potentially lose valuable data.  Other techniques for dealing with missing data are listed <a href="https://en.wikipedia.org/wiki/Missing_data">here</a>.</p>

<h2 id="clustering-games">Clustering games</h2>

<p>We’ve seen that there may be distinct sets of games.  One set (which we just removed) was the set of games without reviews.  Another set could be a set of highly rated games.  One way to figure out more about these sets of games is a technique called <a href="https://en.wikipedia.org/wiki/Cluster_analysis">clustering</a>.  Clustering enables you to find patterns within your data easily by grouping similar rows (in this case, games), together.</p>

<p>We’ll use a particular type of clustering called <a href="https://en.wikipedia.org/wiki/K-means_clustering">k-means clustering</a>.  Scikit-learn has an excellent implementation of k-means clustering that we can use.  Scikit-learn is the primary machine learning library in Python, and contains implementations of most common algorithms, including random forests, support vector machines, and logistic regression.  Scikit-learn has a consistent API for accessing these algorithms.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Import the kmeans clustering model.</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>

<span class="c"># Initialize the model with 2 parameters -- number of clusters and random state.</span>
<span class="n">kmeans_model</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c"># Get only the numeric columns from games.</span>
<span class="n">good_columns</span> <span class="o">=</span> <span class="n">games</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
<span class="c"># Fit the model using the good columns.</span>
<span class="n">kmeans_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">good_columns</span><span class="p">)</span>
<span class="c"># Get the cluster assignments.</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">kmeans_model</span><span class="o">.</span><span class="n">labels_</span></code></pre></div>

<p>In order to use the clustering algorithm in Scikit-learn, we’ll first intialize it using two parameters – <code>n_clusters</code> defines how many clusters of games that we want, and <code>random_state</code> is a random seed we set in order to reproduce our results later.  <a href="http://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html">Here’s</a> more information on the implementation.</p>

<p>We then only get the numeric columns from our dataframe.  Most machine learning algorithms can’t directly operate on text data, and can only take numbers as input.  Getting only the numeric columns removes <code>type</code> and <code>name</code>, which aren’t usable by the clustering algorithm.</p>

<p>Finally, we fit our kmeans model to our data, and get the cluster assignment labels for each row.</p>

<h2 id="plotting-clusters">Plotting clusters</h2>

<p>Now that we have cluster labels, let’s plot the clusters.  One sticking point is that our data has many columns – it’s outside of the realm of human understanding and physics to be able to visualize things in more than 3 dimensions.  So we’ll have to reduce the dimensionality of our data, without losing too much information.  One way to do this is a technique called <a href="https://en.wikipedia.org/wiki/Principal_component_analysis">principal component analysis</a>, or PCA.  PCA takes multiple columns, and turns them into fewer columns while trying to preserve the unique information in each column.  To simplify, say we have two columns, <code>total_owners</code>, and <code>total_traders</code>.  There is some correlation between these two columns, and some overlapping information.  PCA will compress this information into one column with new numbers while trying not to lose any information.</p>

<p>We’ll try to turn our board game data into two dimensions, or columns, so we can easily plot it out.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Import the PCA model.</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>

<span class="c"># Create a PCA model.</span>
<span class="n">pca_2</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c"># Fit the PCA model on the numeric columns from earlier.</span>
<span class="n">plot_columns</span> <span class="o">=</span> <span class="n">pca_2</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">good_columns</span><span class="p">)</span>
<span class="c"># Make a scatter plot of each game, shaded according to cluster assignment.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">plot_columns</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">plot_columns</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
<span class="c"># Show the plot.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>

<p><img src="/blog/images/intro_ml/game_clusters.png" alt="png"/></p>

<p>We first initialize a PCA model from Scikit-learn.  PCA isn’t a machine learning technique, but Scikit-learn also contains other models that are useful for performing machine learning.  Dimensionality reduction techniques like PCA are widely used when preprocessing data for machine learning algorithms.</p>

<p>We then turn our data into <code>2</code> columns, and plot the columns.  When we plot the columns, we shade them according to their cluster assignment.</p>

<p>The plot shows us that there are 5 distinct clusters.  We could dive more into which games are in each cluster to learn more about what factors cause games to be clustered.</p>

<h2 id="figuring-out-what-to-predict">Figuring out what to predict</h2>
<p>There are two things we need to determine before we jump into machine learning – how we’re going to measure error, and what we’re going to predict.  We thought earlier that <code>average_rating</code> might be good to predict on, and our exploration reinforces this notion.  </p>

<p>There are a variety of ways to measure error (many are listed <a href="https://www.kaggle.com/wiki/Metrics">here</a>).  Generally, when we’re doing regression, and predicting <a href="https://en.wikipedia.org/wiki/Continuous_and_discrete_variables">continuous</a> variables, we’ll need a different error metric than when we’re performing classification, and predicting <a href="https://en.wikipedia.org/wiki/Continuous_and_discrete_variables">discrete</a> values.</p>

<p>For this, we’ll use <a href="https://en.wikipedia.org/wiki/Mean_squared_error">mean squared error</a> – it’s easy to calculate, and simple to understand.  It shows us how far, on average, our predictions are from the actual values.</p>

<h2 id="finding-correlations">Finding correlations</h2>

<p>Now that we want to predict <code>average_rating</code>, let’s see what columns might be interesting for our prediction.  One way is to find the correlation between <code>average_rating</code> and each of the other columns.  This will show us which other columns might predict <code>average_rating</code> the best.   We can use the <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.corr.html">corr</a> method on Pandas dataframes to easily find correlations.  This will give us the correlation between each column and each other column.  Since the result of this is a dataframe, we can index it and only get the correlations for the <code>average_rating</code> column.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">games</span><span class="o">.</span><span class="n">corr</span><span class="p">()[</span><span class="s">"average_rating"</span><span class="p">]</span></code></pre></div>

<pre><code>id                      0.304201
yearpublished           0.108461
minplayers             -0.032701
maxplayers             -0.008335
playingtime             0.048994
minplaytime             0.043985
maxplaytime             0.048994
minage                  0.210049
users_rated             0.112564
average_rating          1.000000
bayes_average_rating    0.231563
total_owners            0.137478
total_traders           0.119452
total_wanters           0.196566
total_wishers           0.171375
total_comments          0.123714
total_weights           0.109691
average_weight          0.351081
Name: average_rating, dtype: float64
</code></pre>

<p>We see that the <code>average_weight</code> and <code>id</code> columns correlate best to rating.  <code>ids</code> are presumably assigned when the game is added to the database, so this likely indicates that games created later score higher in the ratings.  Maybe reviewers were not as nice in the early days of BoardGameGeek, or older games were of lower quality.  <code>average_weight</code> indicates the “depth” or complexity of a game, so it may be that more complex games are reviewed better.</p>

<h2 id="picking-predictor-columns">Picking predictor columns</h2>

<p>Before we get started predicting, let’s only select the columns that are relevant when training our algorithm.  We’ll want to remove certain columns that aren’t numeric.  </p>

<p>We’ll also want to remove columns that can only be computed if you already know the average rating.  Including these columns will destroy the purpose of the classifier, which is to predict the rating without any previous knowledge.  Using columns that can only be computed with knowledge of the target can lead to <a href="https://en.wikipedia.org/wiki/Overfitting">overfitting</a>, where your model is good in a training set, but doesn’t generalize well to future data.</p>

<p>The <code>bayes_average_rating</code> column appears to be derived from <code>average_rating</code> in some way, so let’s remove it.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Get all the columns from the dataframe.</span>
<span class="n">columns</span> <span class="o">=</span> <span class="n">games</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="c"># Filter the columns to remove ones we don't want.</span>
<span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">"bayes_average_rating"</span><span class="p">,</span> <span class="s">"average_rating"</span><span class="p">,</span> <span class="s">"type"</span><span class="p">,</span> <span class="s">"name"</span><span class="p">]]</span>

<span class="c"># Store the variable we'll be predicting on.</span>
<span class="n">target</span> <span class="o">=</span> <span class="s">"average_rating"</span></code></pre></div>

<h2 id="splitting-into-train-and-test-sets">Splitting into train and test sets</h2>

<p>We want to be able to figure out how accurate an algorithm is using our error metrics.  However, evaluating the algorithm on the same data it has been trained on will lead to overfitting.  We want the algorithm to learn generalized rules to make predictions, not memorize how to make specific predictions.  An example is learning math.  If you memorize that <code>1+1=2</code>, and <code>2+2=4</code>, you’ll be able to perfectly answer any questions about <code>1+1</code> and <code>2+2</code>.  You’ll have <code>0</code> error.  However, the second anyone asks you something outside of your training set where you know the answer, like <code>3+3</code>, you won’t be able to solve it.  On the other hand, if you’re able to generalize and learn addition, you’ll make occasional mistakes because you haven’t memorized the solutions – maybe you’ll get <code>3453 + 353535</code> off by one, but you’ll be able to solve any addition problem thrown at you.</p>

<p>If your error looks surprisingly low when you’re training a machine learning algorithm, you should always check to see if you’re overfitting.</p>

<p>In order to prevent overfitting, we’ll train our algorithm on a set consisting of <code>80%</code> of the data, and test it on another set consisting of <code>20%</code> of the data.  To do this, we first randomly samply <code>80%</code> of the rows to be in the training set, then put everything else in the testing set.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Import a convenience function to split the sets.</span>
<span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="c"># Generate the training set.  Set random_state to be able to replicate results.</span>
<span class="n">train</span> <span class="o">=</span> <span class="n">games</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">frac</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c"># Select anything not in the training set and put it in the testing set.</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">games</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">games</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">train</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>
<span class="c"># Print the shapes of both sets.</span>
<span class="k">print</span><span class="p">(</span><span class="n">train</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></code></pre></div>

<pre><code>(45515, 20)
(11379, 20)
</code></pre>

<p>Above, we exploit the fact that every Pandas row has a unique index to select any row not in the training set to be in the testing set.</p>

<h2 id="fitting-a-linear-regression">Fitting a linear regression</h2>

<p><a href="https://en.wikipedia.org/wiki/Linear_regression">Linear regression</a> is a powerful and commonly used machine learning algorithm.  It predicts the target variable using linear combinations of the predictor variables.  Let’s say we have a 2 values, <code>3</code>, and <code>4</code>.  A linear combination would be <code>3 * .5 + 4 * .5</code>.  A linear combination involves multiplying each number by a constant, and adding the results.  You can read more <a href="https://en.wikipedia.org/wiki/Linear_combination">here</a>.</p>

<p>Linear regression only works well when the predictor variables and the target variable are linearly correlated.  As we saw earlier, a few of the predictors are correlated with the target, so linear regression should work well for us.</p>

<p>We can use the linear regression implementation in Scikit-learn, just as we used the k-means implementation earlier.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Import the linearregression model.</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>

<span class="c"># Initialize the model class.</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
<span class="c"># Fit the model to the training data.</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train</span><span class="p">[</span><span class="n">columns</span><span class="p">],</span> <span class="n">train</span><span class="p">[</span><span class="n">target</span><span class="p">])</span></code></pre></div>

<p>When we fit the model, we pass in the predictor matrix, which consists of all the columns from the dataframe that we picked earlier.  If you pass a list to a Pandas dataframe when you index it, it will generate a new dataframe with all of the columns in the list.  We also pass in the target variable, which we want to make predictions for.</p>

<p>The model learns the equation that maps the predictors to the target with minimal error.</p>

<h2 id="predicting-error">Predicting error</h2>

<p>After we train the model, we can make predictions on new data with it.  This new data has to be in the exact same format as the training data, or the model won’t make accurate predictions.  Our testing set is identical to the training set (except the rows contain different board games).  We select the same subset of columns from the test set, and then make predictions on it.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Import the scikit-learn function to compute error.</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>

<span class="c"># Generate our predictions for the test set.</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="n">columns</span><span class="p">])</span>

<span class="c"># Compute error between our test predictions and the actual values.</span>
<span class="n">mean_squared_error</span><span class="p">(</span><span class="n">predictions</span><span class="p">,</span> <span class="n">test</span><span class="p">[</span><span class="n">target</span><span class="p">])</span></code></pre></div>

<pre><code>1.8239281903519875
</code></pre>

<p>Once we have the predictions, we’re able to compute error between the test set predictions and the actual values.  Mean squared error has the formula $\frac{1}{n}\sum_{i=1}^{n}(y_i - \hat{y}_i)^{2}$ .  Basically, we subtract each predicted value from the actual value, square the differences, and add them together.  Then we divide the result by the total number of predicted values.  This will give us the average error for each prediction.</p>

<h2 id="trying-a-different-model">Trying a different model</h2>

<p>One of the nice things about Scikit-learn is that it enables us to try more powerful algorithms very easily.  One such algorithm is called <a href="https://en.wikipedia.org/wiki/Random_forest">random forest</a>.  The random forest algorithm can find nonlinearities in data that a linear regression wouldn’t be able to pick up on.  Say, for example, that if the <code>minage</code> of a game, is less than 5, the rating is low, if it’s <code>5-10</code>, it’s high, and if it is between <code>10-15</code>, it is low.  A linear regression algorithm wouldn’t be able to pick up on this because there isn’t a linear relationship between the predictor and the target.  Predictions made with a random forest usually have less error than predictions made by a linear regression.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Import the random forest model.</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestRegressor</span>

<span class="c"># Initialize the model with some parameters.</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">min_samples_leaf</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c"># Fit the model to the data.</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train</span><span class="p">[</span><span class="n">columns</span><span class="p">],</span> <span class="n">train</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>
<span class="c"># Make predictions.</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="n">columns</span><span class="p">])</span>
<span class="c"># Compute the error.</span>
<span class="n">mean_squared_error</span><span class="p">(</span><span class="n">predictions</span><span class="p">,</span> <span class="n">test</span><span class="p">[</span><span class="n">target</span><span class="p">])</span></code></pre></div>

<pre><code>1.4144905030983794
</code></pre>

<h2 id="further-exploration">Further exploration</h2>

<p>We’ve managed to go from data in csv format to making predictions.  Here are some ideas for further exploration:</p>

<ul>
  <li>Try a <a href="https://en.wikipedia.org/wiki/Support_vector_machine">support vector machine</a>.</li>
  <li>Try <a href="https://en.wikipedia.org/wiki/Ensemble_learning">ensembling</a> multiple models to create better predictions.</li>
  <li>Try predicting a different column, such as <code>average_weight</code>.</li>
  <li>Generate features from the text, such as length of the name of the game, number of words, etc.</li>
</ul>

<h2 id="want-to-learn-more-about-machine-learning">Want to learn more about machine learning?</h2>

<p>At <a href="https://www.dataquest.io">Dataquest</a>, we offer interactive lessons on machine learning and data science.  We believe in learning by doing, and you’ll learn interactively in your browser by analyzing real data and building projects.  Check out our machine learning lessons <a href="https://www.dataquest.io/section/machine-learning">here</a>.</p>

        </section>

        </div></body></html>