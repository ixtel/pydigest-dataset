<html><body><div><div class="post-text" itemprop="text">
<p>One step toward improving the speed is to fill the counter in the optimal way.</p>

<p>For example, with your <code>txt</code> (802 char).</p>

<pre><code>mycounter=Counter(txt.split())
</code></pre>

<p>produces the same thing as your <code>word_counter</code>, but in 1/3 the time.</p>

<p>Or if you have to read the text line by line from a file, then use:</p>

<pre><code>word_freq=Counter()
for line in txt.splitlines():
    word_freq.update(line.split())
</code></pre>

<p>Similarly the ordered dictionary can be created without the loop:</p>

<pre><code>mydict = OrderedDict(sorted(mycounter.items(), key=operator.itemgetter(1), reverse=True))
</code></pre>

<p>Here I am calling <code>sorted</code> in the same way that <code>most_common</code> does (as per your link).  And I'm passing the list of sorted items directly to the <code>OrderedDict</code> creator.</p>

<p>When I look at <code>mycounter</code> in <code>ipython</code>, I get the values in sorted order:</p>

<pre><code>In [160]: mycounter
Out[160]: Counter({'the': 13, ',': 10, 'of': 9, 'a': 7, '.': 4, 'in': 4, 'to': 3, 'have': 3, 'session': 3, '&amp;apos;': 3, 'on': 3, 'you': 3, 'I': 3, 'that': 2, 'requested': 2, 'like': 2, 'European': 2, 'this': 2, 'countries': 2, 'as': 2, 'number': 2, 's': 1, 'various': 1, 'wish': 1, 'will': 1, 'Parliament': 1, 'meantime': 1, 'Resumption': 1, 'natural': 1, 'days': 1, 'debate': 1, 'You': 1, 'Members': 1, 'next': 1, '@-@': 1, 'hope': 1, 'enjoyed': 1, 'December': 1, 'victims': 1, 'particularly': 1, 'millennium': 1, .... 'behalf': 1, 'were': 1, 'failed': 1})
</code></pre>

<p>That's because its <code>__repr__</code> method calls <code>most_common</code>. Again this is from your link.  </p>

<pre><code>items = ', '.join(map('%r: %r'.__mod__, self.most_common()))
</code></pre>

<p>On further testing I see that calling <code>sorted</code> directly doesn't save time:</p>

<pre><code>In [166]: timeit mycounter.most_common()
10000 loops, best of 3: 31.1 µs per loop

In [167]: timeit sorted(mycounter.items(),key=operator.itemgetter(1),reverse=True)
10000 loops, best of 3: 30.5 µs per loop

In [168]: timeit OrderedDict(mycounter.most_common())
1000 loops, best of 3: 225 µs per loop
</code></pre>

<p>In this case, loading the dictionary directly doesn't save time either.  Your iteration does just as well:</p>

<pre><code>In [174]: %%timeit 
   .....: sorteddict=OrderedDict()
   .....: for word,freq in word_freq.most_common():
    sorteddict[word]=freq
   .....: 
1000 loops, best of 3: 224 µs per loop
</code></pre>

<p>For this sample, using <code>np.argsort</code> does not help (timewise).  Just calling <code>argsort</code> is slower than <code>most_common</code>.</p>

<pre><code>In [178]: timeit np.argsort(list(mycounter.values()))
10000 loops, best of 3: 34.2 µs per loop
</code></pre>

<p>Most of that time is in converting the list to an array, <code>x=np.array(list(mycounter.values()))</code>.  <code>np.argsort(x)</code> is much faster.  That's true of a lot of <code>numpy</code> functionality.  When operating on arrays <code>numpy</code> is fast.  But there's a lot of overhead when converting lists to arrays.</p>

<p>I can create the OrderedDict via <code>numpy</code> in one line with:</p>

<pre><code>OrderedDict(np.sort(np.array(list(mycounter.items()), dtype='a12,i'), order='f1')[::-1])
</code></pre>

<p>or in pieces:</p>

<pre><code>lla = np.array(list(mycounter.items()),dtype='a12,i')
lla.sort(order='f1')
OrderedDict(lla[::-1])
</code></pre>

<p>I'm making a structured array from the <code>items()</code>, sorting that by the 2nd field, and then making the dictionary.  No time savings though.  See <a href="http://stackoverflow.com/a/31837513/901925">http://stackoverflow.com/a/31837513/901925</a> for another recent example of using <code>order</code> to sort a structured array.</p>
    </div>
    </div></body></html>