<html><body><div><div class="post-content" itemprop="articleBody">
    <p>Here at HumanGeo we do all sorts of interesting things with sentiment analysis and entity resolution. Before you get to have fun with that, though, you need to bring data into the system. One data source we've recently started working with is reddit.</p>

<p>Compared to the walled gardens of Facebook and LinkedIn, <a href="https://github.com/reddit/reddit/wiki/API">reddit's API is as open as open can be;</a> Everything is nice and RESTful, rate limits are sane, the developers are open to enhancement requests, and one can do quite a bit without needing to authenticate.<br/>
The most common objects we collect from reddit are submissions (posts) and comments. A submission can either be a link, or a self post with a text body, and can have an arbitrary number of comments. Comments contain text, as well as references to parent nodes (if they're not root nodes in the comment tree). Pulling this data is as simple as <code><strong>GET</strong> http://www.reddit.com/r/washingtondc/new.json</code>. (Protip: pretty much any view in reddit has a corresponding API endpoint that can be generated by appending '.json' to the URL.)</p>
<p>With little effort a developer could hack together a quick 'n dirty reddit scraper. However, as additional features appear and collection-breadth grows, the quick 'n dirty scraper becomes more dirty than quick, and you discover <del>bugs</del>features that others utilizing the API have already encountered and possibly addressed. API wrappers help consolidate communal knowledge and best practices for the good of all. We considered <a href="https://github.com/reddit/reddit/wiki/API-Wrappers">several</a>, and, being a Python shop, settled on <a href="https://github.com/praw-dev/praw">PRAW (Python Reddit API Wrapper)</a>.</p>
<p>With PRAW, getting a list of posts is pretty easy:</p>
<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">praw</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">praw</span><span class="o">.</span><span class="n">Reddit</span><span class="p">(</span><span class="n">user_agent</span><span class="o">=</span><span class="s">'Hello world application.'</span><span class="p">)</span>
<span class="k">for</span> <span class="n">post</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">get_subreddit</span><span class="p">(</span><span class="s">'WashingtonDC'</span><span class="p">)</span> \
             <span class="o">.</span><span class="n">get_hot</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">post</span><span class="p">))</span></code></pre></figure>
<pre>$ python parse_bot_2000.py
209 :: /r/WashingtonDC's Official Guide to the City!
29 :: What are some good/active meetups in DC that are easy to join?
17 :: So no more tailgating at the Nationals park anymore...
3 :: Anyone know of a juggling club in DC
2 :: The American Beer Classic: Yay or Nay?</pre>
<h2>The Problem</h2>
<p>Now, let's try something a little more complicated. Our mission, if we choose to accept it, is to capture all incoming comments to a subreddit. For each comment we should collect the author's username, the URL for the submission, a permalink to the comment, as well as its body.</p>
<p>Here's what this looks like:</p>
<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">praw</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">praw</span><span class="o">.</span><span class="n">Reddit</span><span class="p">(</span><span class="n">user_agent</span><span class="o">=</span><span class="s">'Subreddit Parse Bot 2000'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">save_comment</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span>

<span class="k">for</span> <span class="n">comment</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">get_subreddit</span><span class="p">(</span><span class="s">'Python'</span><span class="p">)</span> \
                <span class="o">.</span><span class="n">get_comments</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
    <span class="n">save_comment</span><span class="p">(</span><span class="n">comment</span><span class="o">.</span><span class="n">permalink</span><span class="p">,</span>
        <span class="n">comment</span><span class="o">.</span><span class="n">author</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="n">comment</span><span class="o">.</span><span class="n">body_html</span><span class="p">,</span>
        <span class="n">comment</span><span class="o">.</span><span class="n">submission</span><span class="o">.</span><span class="n">url</span><span class="p">)</span></code></pre></figure>
<p>That was pretty easy. For the sake of this demo the <code>save_comment</code> method has been stubbed out, but anything can go there.</p>
<p>If you run the snippet, you'll observe the following pattern:</p>
<pre>... comment ...
... comment ...
[WAIT FOR A FEW SECONDS]
... comment ...
... comment ...
[WAIT FOR A FEW SECONDS]
... comment ...
... comment ...
[WAIT FOR A FEW SECONDS]
(repeating...)
</pre>
<p>This process also seems to be taking longer than a normal HTTP request. As anyone working with large amounts of data should do, let's quantify this.</p>
<p>Using the wonderful, indispensable <a title="iPython's official site" href="http://ipython.org/" target="_blank">iPython</a>:</p>
<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="o">%%</span><span class="n">timeit</span>
<span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'http://www.reddit.com/r/python/comments.json?limit=200'</span><span class="p">)</span>
   <span class="o">....</span><span class="p">:</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">136</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="o">%%</span><span class="n">timeit</span>
<span class="kn">import</span> <span class="nn">praw</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">praw</span><span class="o">.</span><span class="n">Reddit</span><span class="p">(</span><span class="n">user_agent</span><span class="o">=</span><span class="s">'Subreddit Parse Bot 2000'</span><span class="p">,</span>
                <span class="n">cache_timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">comment</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">get_subreddit</span><span class="p">(</span><span class="s">'Python'</span><span class="p">)</span> \
                <span class="o">.</span><span class="n">get_comments</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">comment</span><span class="o">.</span><span class="n">permalink</span><span class="p">,</span>
          <span class="n">comment</span><span class="o">.</span><span class="n">author</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
          <span class="n">comment</span><span class="o">.</span><span class="n">body_html</span><span class="p">,</span>
          <span class="n">comment</span><span class="o">.</span><span class="n">submission</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">6</span><span class="nb">min</span> <span class="mi">43</span><span class="n">s</span> <span class="n">per</span> <span class="n">loop</span></code></pre></figure>
<p>Ouch. While this difference in run-times is fine for a one-off, contrived example, such inefficiency is disastrous when dealing with large volumes of data. What could be causing this behavior?</p>
<h2>Digging</h2>
<p><a href="https://praw.readthedocs.org/en/v2.1.16/pages/lazy-loading.html#lazy-objects" target="_blank">According to the PRAW documentation</a>,</p>
<blockquote><p>Each API request to Reddit must be separated by a 2 second delay, as per the API rules. So to get the highest performance, the number of API calls must be kept as low as possible. PRAW uses lazy objects to only make API calls when/if the information is needed.</p></blockquote>
<p>Perhaps we're doing something that is triggering additional HTTP requests. Such behavior would explain the intermittent printing of comments to the output stream. Let's verify this hypothesis.</p>
<p>To see the underlying requests, we can override PRAW's default log level:</p>
<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">praw</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">praw</span><span class="o">.</span><span class="n">Reddit</span><span class="p">(</span><span class="n">user_agent</span><span class="o">=</span><span class="s">'Subreddit Parse Bot 2000'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">save_comment</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span>

<span class="k">for</span> <span class="n">comment</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">get_subreddit</span><span class="p">(</span><span class="s">'Python'</span><span class="p">)</span> \
                <span class="o">.</span><span class="n">get_comments</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
    <span class="n">save_comment</span><span class="p">(</span><span class="n">comment</span><span class="o">.</span><span class="n">author</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                 <span class="n">comment</span><span class="o">.</span><span class="n">submission</span><span class="o">.</span><span class="n">url</span><span class="p">,</span>
                 <span class="n">comment</span><span class="o">.</span><span class="n">permalink</span><span class="p">,</span>
                 <span class="n">comment</span><span class="o">.</span><span class="n">body_html</span><span class="p">)</span></code></pre></figure>
<p>And what does the output look like?</p>
<pre>DEBUG:requests.packages.urllib3.connectionpool:"PUT /check HTTP/1.1" 200 106
DEBUG:requests.packages.urllib3.connectionpool:"GET /comments/2ak14j.json HTTP/1.1" 200 888
.. comment ..
DEBUG:requests.packages.urllib3.connectionpool:"GET /comments/2aies0.json HTTP/1.1" 200 2889
.. comment ..
DEBUG:requests.packages.urllib3.connectionpool:"GET /comments/2aiier.json HTTP/1.1" 200 14809
.. comment ..
DEBUG:requests.packages.urllib3.connectionpool:"GET /comments/2ajam1.json HTTP/1.1" 200 1091
.. comment ..
.. comment ..
.. comment ..
</pre>
<p>Those intermittent requests for individual comments back up our claim. Now, let's see what's causing this.</p>
<p>Prettifying the response JSON yields the following schema (edited for brevity):</p>
<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
   <span class="s1">'kind'</span><span class="err">:</span><span class="s1">'Listing'</span><span class="p">,</span>
   <span class="s1">'data'</span><span class="err">:</span><span class="p">{</span>
      <span class="s1">'children'</span><span class="err">:</span><span class="p">[</span>
         <span class="p">{</span>
            <span class="s1">'kind'</span><span class="p">:</span><span class="s1">'t3'</span><span class="p">,</span>
            <span class="s1">'data'</span><span class="p">:{</span>
               <span class="s1">'id'</span><span class="p">:</span><span class="s1">'2alblh'</span><span class="p">,</span>
               <span class="s1">'media'</span><span class="p">:</span><span class="kc">null</span><span class="p">,</span>
               <span class="s1">'score'</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
               <span class="s1">'permalink'</span><span class="p">:</span><span class="s1">'/r/Python/comments/2alblh/django_middleware_that_prints_query_stats_to/'</span><span class="p">,</span>
               <span class="s1">'name'</span><span class="p">:</span><span class="s1">'t3_2ajam1'</span><span class="p">,</span>
               <span class="s1">'created'</span><span class="p">:</span><span class="mf">1405227385.0</span><span class="p">,</span>
               <span class="s1">'url'</span><span class="p">:</span><span class="s1">'http://imgur.com/QBSOAZB'</span><span class="p">,</span>
               <span class="s1">'title'</span><span class="p">:</span><span class="s1">'Should I? why?'</span><span class="p">,</span>
            <span class="p">}</span>
         <span class="p">}</span>
      <span class="p">]</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></figure>
<p>Lets compare that to what we get when listing comments from the <code>/python/comments</code> endpoint:</p>
<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
   <span class="s1">'kind'</span><span class="err">:</span><span class="s1">'Listing'</span><span class="p">,</span>
   <span class="s1">'data'</span><span class="err">:</span><span class="p">{</span>
      <span class="s1">'children'</span><span class="err">:</span><span class="p">[</span>
         <span class="p">{</span>
            <span class="s1">'kind'</span><span class="p">:</span><span class="s1">'t1'</span><span class="p">,</span>
            <span class="s1">'data'</span><span class="p">:{</span>
               <span class="s1">'link_title'</span><span class="p">:</span><span class="s1">'Django middleware that prints query stats to stderr after each request. pip install django-querycount'</span><span class="p">,</span>
               <span class="s1">'link_author'</span><span class="p">:</span><span class="s1">'mrrrgn'</span><span class="p">,</span>
               <span class="s1">'author'</span><span class="p">:</span><span class="s1">'mrrrgn'</span><span class="p">,</span>
               <span class="s1">'parent_id'</span><span class="p">:</span><span class="s1">'t3_2alblh'</span><span class="p">,</span>
               <span class="s1">'body'</span><span class="p">:</span><span class="s1">'Try django-devserver for query counts, displaying the full queries, profiling, reporting memory usage, etc. \n\nhttps://pypi.python.org/pypi/django-devserver'</span><span class="p">,</span>
               <span class="s1">'link_id'</span><span class="p">:</span><span class="s1">'t3_2alblh'</span><span class="p">,</span>
               <span class="s1">'name'</span><span class="p">:</span><span class="s1">'t1_ciwbo37'</span><span class="p">,</span>
               <span class="s1">'link_url'</span><span class="p">:</span><span class="s1">'https://github.com/bradmontgomery/django-querycount'</span><span class="p">,</span>
            <span class="p">}</span>
         <span class="p">}</span>
      <span class="p">]</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></figure>
<p>Now we're getting somewhere - there are fields in the per-comment's response that aren't in the subreddit listing's. Of the four fields we're collecting, the submission URL and permalink properties are not returned by the subreddit comments endpoint. Accessing those causes a lazy evaluation to fire off additional requests. If we can infer these values from the data we already have, we can avoid having to waste time querying for each comment.</p>
<h2>Doing Work</h2>
<h3>Submission URLs</h3>
<p>Submission URLs are a combination of the subreddit name, the post ID, and title. We can easily get the post ID fragment:</p>
<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">post_id</span> <span class="o">=</span> <span class="n">comment</span><span class="o">.</span><span class="n">link_id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'_'</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span></code></pre></figure>
<p>However, there is no title returned! Luckily, it turns out that it's not needed.</p>
<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">subreddit</span> <span class="o">=</span> <span class="s">'python'</span>
<span class="n">post_id</span> <span class="o">=</span> <span class="n">comment</span><span class="o">.</span><span class="n">link_id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'_'</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">url</span> <span class="o">=</span> <span class="s">'http://reddit.com/r/{}/{}/'</span> \
          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">subreddit</span><span class="p">,</span> <span class="n">post_id</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="c"># A valid submission permalink!</span>
<span class="c"># OUTPUT: http://reddit.com/r/python/2alblh/</span></code></pre></figure>
<p>Great! This also gets us most of the way to constructing the second URL we need - a permalink to the comment.</p>
<h3>Comment Permalinks</h3>
<p>Maybe we can append the comment's ID to the end of the submission URL?</p>
<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">sub_comments_url</span> <span class="o">=</span> <span class="s">'http://reddit.com/r/python/comments/2alblh/'</span>
<span class="n">comment_id</span> <span class="o">=</span> <span class="n">comment</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'_'</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">url</span> <span class="o">=</span> <span class="n">sub_comments_url</span> <span class="o">+</span> <span class="n">comment_id</span>
<span class="k">print</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="c"># OUTPUT: http://reddit.com/r/python/comments/2alblh/ciwbo37</span></code></pre></figure>
<p>Sadly, that URL doesn't work because reddit expects the submission's title to precede the ID. Referring to the subreddit comment's JSON object, we can see that the title is not returned. This is curious: why is the title important? They already have a globally unique ID for the post, and can display the post just fine without (as demonstrated by the code sample immediately preceding this). Perhaps reddit wanted to make it easier for users to identify a link and are just parsing a forward-slash delimited series of parameters. If we put the comment ID in the appropriate position, the URL <em>should</em> be valid. Let's give it a shot:</p>
<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">sub_comments_url</span> <span class="o">=</span> <span class="s">'http://reddit.com/r/python/comments/2alblh/'</span>
<span class="n">comment_id</span> <span class="o">=</span> <span class="n">comment</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'_'</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">url</span> <span class="o">=</span> <span class="s">'{}-/{}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sub_comments_url</span><span class="p">,</span> <span class="n">comment_id</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="c"># OUTPUT: http://reddit.com/r/python/comments/2alblh/-/ciwbo37</span></code></pre></figure>
<p>Following that URL takes us to the comment!</p>
<h2>Victory Lap</h2>
<p>Let's see how much we've improved our execution time:</p>
<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">%%</span><span class="n">timeit</span>
<span class="kn">import</span> <span class="nn">praw</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">praw</span><span class="o">.</span><span class="n">Reddit</span><span class="p">(</span><span class="n">user_agent</span><span class="o">=</span><span class="s">'Subreddit Parse Bot 2000'</span><span class="p">,</span>
                <span class="n">cache_timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">comment</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">get_subreddit</span><span class="p">(</span><span class="s">'Python'</span><span class="p">)</span> \
                <span class="o">.</span><span class="n">get_comments</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">comment</span><span class="o">.</span><span class="n">author</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
          <span class="n">comment</span><span class="o">.</span><span class="n">body_html</span><span class="p">,</span>
          <span class="n">comment</span><span class="o">.</span><span class="nb">id</span><span class="p">,</span>
          <span class="n">comment</span><span class="o">.</span><span class="n">submission</span><span class="o">.</span><span class="nb">id</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">3.57</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span></code></pre></figure>
<p>Wow! 403 seconds to 3.6 seconds - <strong>a factor of 111</strong>. Deploying this improvement to production not only increased the volume of data we were able to process, but also provided the side benefit of reducing the number of 504 errors we encountered during reddit's peak hours. Remember, always be on the lookout for ways to improve your stack. A bunch of small wins can add up to something significant.</p>
<p><em>[Does this sort of stuff interest you? Love hacking and learning new things? Good news - <a title="HumanGeo jobs link" href="http://thehumangeo.com/company.html#slide-5">we're hiring</a>!]</em></p>

  </div>

</div></body></html>