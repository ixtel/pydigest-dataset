<html><body><div><article id="VAaKJ9SsKI6h34CWYgF" class="post  historical">
	<time datetime="2014-09-28" class="article_time">September 28, 2014</time>
  
	<p>Learning about functional programming (FP) is well worth your time. The insights you acquire will put you straight on <a href="http://stackoverflow.com/questions/2573135/python-progression-path-from-apprentice-to-guru/2576240" rel="nofollow">the path to becoming a Python Guru</a>.</p>

<p>To get the most out of this article you should grasp the basics of <strong>pure functions</strong>, <strong>side effects</strong>, and <strong>higher order functions</strong>.</p>
<h1 id="1-use-immutable-data-structures_1">
<a class="head_anchor" href="#1-use-immutable-data-structures_1" rel="nofollow"> </a>1. Use immutable data structures</h1>
<p><a href="http://img.svbtle.com/ygckjhtzktb78w.jpg" rel="nofollow"><img src="https://d23f6h5jpj26xu.cloudfront.net/ygckjhtzktb78w_small.jpg" alt="mutability.jpg"/></a></p>

<p>The most straightforward way of avoiding side effects is to use immutable data structures. Use them as often as possible. There aren’t many immutable builtins but the standard library expands the roster a little. One surprisingly useful replacement for the builtin <code class="prettyprint">dict</code> is the <code class="prettyprint">namedtuple</code>.</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; from collections import namedtuple

# create an immutable dict-like class
&gt;&gt;&gt; faux_dict = namedtuple('faux_dict', ['name', 'age'])
&gt;&gt;&gt; person = faux_dict(name='Paul Thomas Anderson', age=44)

</code></pre>

<p>You access values through dot-notation which is even cleaner than dictionary keys, right?</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; person.age
44
</code></pre>

<p>And due to immutability, updating a value requires that you copy the entire object.</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; person._replace(age=45)
faux_dict(name='Paul Thomas Anderson', age=45)

# the original object stays unchanged
&gt;&gt;&gt; print(person)
faux_dict(name='Paul Thomas Anderson', age=44)
</code></pre>

<p>Optional attributes aren’t supported out-of-the-box but by <a href="http://stackoverflow.com/a/16721002" rel="nofollow">subclassing</a> you can make it work.</p>
<h1 id="2-trade-methods-for-functions_1">
<a class="head_anchor" href="#2-trade-methods-for-functions_1" rel="nofollow"> </a>2. Trade methods for functions</h1>
<p>When you have to deal with mutable objects like the <code class="prettyprint">list</code>, it’s important to treat them just like <em>immutable</em> objects.</p>

<p>For this reason, it’s not OK to sort a list in-place in FP.</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; directors = ['Paul Thomas Anderson', 'Terrance Malik', 'Quentin Tarantino']
&gt;&gt;&gt; directors.sort()
&gt;&gt;&gt; directors   # mutated(!)
['Paul Thomas Anderson', 'Quentin Tarantino', 'Terrance Malik']
</code></pre>

<p>It’s better to use the <code class="prettyprint">sorted</code> function which returns a copy of the list and avoids mutation.</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; sorted(directors, key=len)
['Terrance Malik', 'Quentin Tarantino', 'Paul Thomas Anderson']
</code></pre>

<p>Strings are already immutable in Python but functions are still more flexible to use than methods in FP. Each string method is available as a complementary function under the <code class="prettyprint">str</code>/<code class="prettyprint">unicode</code> class.</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; string = 'Magnolia, Boogie Nights, There Will Be Blood'
&gt;&gt;&gt; string.split(',')
['Magnolia', ' Boogie Nights', ' There Will Be Blood']
&gt;&gt;&gt; str.split(string, ',')
['Magnolia', ' Boogie Nights', ' There Will Be Blood']
</code></pre>
<h1 id="3-learn-about-map-filter-and-reduce_1">
<a class="head_anchor" href="#3-learn-about-map-filter-and-reduce_1" rel="nofollow"> </a>3. Learn about map, filter, and reduce</h1>
<p>These three functions are all staple FP functions found in Python. They work on any iterable and always accept a function as the first parameter.</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; titles = ['Magnolia', ' Boogie Nights', ' There Will Be Blood']
&gt;&gt;&gt; list(map(str.strip, titles))
['Magnolia', 'Boogie Nights', 'There Will Be Blood']
</code></pre>

<p><code class="prettyprint">map</code> and <code class="prettyprint">filter</code> are <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="nofollow">curious cases</a> in Python-land. It’s worth noting that the internal implementation is equal to a list comprehension. Effectively the above expression is the same as the possibly more Pythonic:</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; [str.strip(title) for title in titles]
['Magnolia', 'Boogie Nights', 'There Will Be Blood']
</code></pre>

<p>In Python 3 “map” has become lazy by default (like <code class="prettyprint">functools.imap</code>) and therefore the same as the complementary generator expression.</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; (str.strip(title) for title in titles)
&lt;generator object &lt;genexpr&gt; at 0x7f81f24e2f00&gt;
</code></pre>

<p><code class="prettyprint">filter</code> is in the same sense nothing more than a list comprehension + a conditional statement.</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; titles = ['Magnolia', ' Boogie Nights', ' There Will Be Blood']

&gt;&gt;&gt; def is_one_word(string):
...   return len(string.split()) == 1

&gt;&gt;&gt; list(filter(is_one_word, titles))
['Magnolia']

&gt;&gt;&gt; [title for title in titles if is_one_word(title)]
['Magnolia']
</code></pre>
<h1 id="4-curry-your-functions_1">
<a class="head_anchor" href="#4-curry-your-functions_1" rel="nofollow"> </a>4. Curry your functions</h1>
<p>Partial evaluation of functions is normally accomplished using <code class="prettyprint">functools.partial</code>.</p>
<blockquote class="large">
<p>… currying is just syntactic sugar for partial evaluation. A curried function partially evaluates if it does not receive enough arguments to compute a result. Ref: <a href="http://toolz.readthedocs.org/en/latest/curry.html" rel="nofollow">http://toolz.readthedocs.org/en/latest/curry.html</a></p>
</blockquote>
<p>The [toolz](toolz.readthedocs.org/en/latest/) library contains a very handy decorators to automatically curry regular functions.</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; from toolz import curry
&gt;&gt;&gt; @curry
... def multiply(first_factor, second_factor):
...   return first_factor * second_factor

&gt;&gt;&gt; double = multiply(2)
&gt;&gt;&gt; double(21)
42
</code></pre>

<p>We’ll soon see how we can use this trick to write very clean pipelines.</p>

<p>We have now seen many of the utilities we need to really start taking advantage of FP. Let’s implement a simple reader for a Tab-delimited stream (or file object). It will be lazy (memory efficient), linear (parallelizable), and easy to comprehend.</p>
<blockquote class="large">
<p>As indicated before <strong>toolz</strong>, a third-party library, provides a lot of the missing pieces that will make coding FP in Python a much more pleasurable experience.</p>
</blockquote>
<p>The input is really any iterable, whether a file object, list, or generator that spits out lines of text.</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; stream = [
  '#time\tevent\n',
  '003 min\tNarrator speaks\n',
  '023 min\t"What Do Kids Know?" airs on TV\n',
  '107 min\tJimmy confesses to cheating\n',
  '159 min\tFrogs begin to fall from the sky\n',
]
</code></pre>

<p>We need to setup a few layer of filters that each will take care of one dedicated task.</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; from toolz import curry
&gt;&gt;&gt; @curry
... def is_comment_line(line, prefix='#'):
...   """Check if a string starts with a specified prefix."""
...   return str.startswith(line, prefix)
</code></pre>

<p>Finally we have everything we need to combine the pieces to a fully working pipeline built from the components we’ve covered before.</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; from toolz import pipe, partial
&gt;&gt;&gt; from toolz.curried import complement, map, filter
&gt;&gt;&gt; sequence = pipe(
...   stream,
...   filter(complement(is_comment_line)),   # filter out comments
...   map(str.rstrip),                       # strip invisible chars
...   map(partial(split(sep='\t'))),         # split lines
... )

&gt;&gt;&gt; list(sequence)
[['003 min', 'Narrator speaks'],
 ['023 min', '"What Do Kids Know?" airs on TV'],
 ['107 min', 'Jimmy confesses to cheating'],
 ['159 min', 'Frogs begin to fall from the sky']]
</code></pre>

<p>Lazy, linear, and without side effects. Beautiful.</p>

<p>Thanks for your interest. Reach out <a href="https://twitter.com/robinandeer" rel="nofollow">@robinandeer</a>.</p>

  <figure class="postend kudo able clearfix" id="kudo_VAaKJ9SsKI6h34CWYgF">
    <a href="#kudo">
      <p class="filling"> </p>
    </a>
    <p class="num">27</p>
    <p class="txt">Kudos</p>
  </figure>
  <figure class="side kudo able clearfix" id="kudo_side_VAaKJ9SsKI6h34CWYgF">
    <a href="#kudo">
      <p class="filling"> </p>
    </a>
    <p class="num">27</p>
    <p class="txt">Kudos</p>
  </figure>
</article>

  </div></body></html>