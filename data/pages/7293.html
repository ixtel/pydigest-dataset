<html><body><div><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-curio---concurrent-io" class="anchor" href="#curio---concurrent-io" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>curio - concurrent I/O</h1>
<p>Curio is a modern library for performing reliable concurrent I/O using
Python coroutines and the explicit async/await syntax introduced in
Python 3.5.   Its programming model is based on cooperative
multitasking and common system programming abstractions such as
threads, sockets, files, subprocesses, locks, and queues.  Under
the covers, it is based on a task queuing system that is small, fast,
and powerful.</p>
<a name="user-content-an-example"/>
<h2><a id="user-content-an-example" class="anchor" href="#an-example" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>An Example</h2>
<p>Here is a simple TCP echo server implemented using sockets and curio:</p>
<div class="highlight highlight-source-python"><pre><span class="pl-c"># echoserv.py</span>

<span class="pl-k">from</span> curio <span class="pl-k">import</span> Kernel, new_task
<span class="pl-k">from</span> curio.socket <span class="pl-k">import</span> <span class="pl-k">*</span>

<span class="pl-k">async</span> <span class="pl-k">def</span> <span class="pl-en">echo_server</span>(<span class="pl-smi">address</span>):
    sock <span class="pl-k">=</span> socket(<span class="pl-c1">AF_INET</span>, <span class="pl-c1">SOCK_STREAM</span>)
    sock.setsockopt(<span class="pl-c1">SOL_SOCKET</span>, <span class="pl-c1">SO_REUSEADDR</span>, <span class="pl-c1">1</span>)
    sock.bind(address)
    sock.listen(<span class="pl-c1">5</span>)
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">'</span>Server listening at<span class="pl-pds">'</span></span>, address)
    <span class="pl-k">async</span> <span class="pl-k">with</span> sock:
        <span class="pl-k">while</span> <span class="pl-c1">True</span>:
            client, addr <span class="pl-k">=</span> <span class="pl-k">await</span> sock.accept()
            <span class="pl-k">await</span> new_task(echo_client(client, addr))

<span class="pl-k">async</span> <span class="pl-k">def</span> <span class="pl-en">echo_client</span>(<span class="pl-smi">client</span>, <span class="pl-smi">addr</span>):
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">'</span>Connection from<span class="pl-pds">'</span></span>, addr)
    <span class="pl-k">async</span> <span class="pl-k">with</span> client:
         <span class="pl-k">while</span> <span class="pl-c1">True</span>:
             data <span class="pl-k">=</span> <span class="pl-k">await</span> client.recv(<span class="pl-c1">1000</span>)
             <span class="pl-k">if</span> <span class="pl-k">not</span> data:
                 <span class="pl-k">break</span>
             <span class="pl-k">await</span> client.sendall(data)
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">'</span>Connection closed<span class="pl-pds">'</span></span>)

<span class="pl-k">if</span> <span class="pl-c1">__name__</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>__main__<span class="pl-pds">'</span></span>:
    kernel <span class="pl-k">=</span> Kernel()
    kernel.run(echo_server((<span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>,<span class="pl-c1">25000</span>)))</pre></div>
<p>If you have programmed with threads, you find that curio looks similar.
You'll also find that the above server can handle thousands of simultaneous
client connections even though no threads are being used under the covers.</p>
<p>Of course, if you prefer something a little higher level, you can have
curio take care of the fiddly bits related to setting up the server portion
of the code:</p>
<div class="highlight highlight-source-python"><pre><span class="pl-c"># echoserv.py</span>

<span class="pl-k">from</span> curio <span class="pl-k">import</span> Kernel, new_task, run_server

<span class="pl-k">async</span> <span class="pl-k">def</span> <span class="pl-en">echo_client</span>(<span class="pl-smi">client</span>, <span class="pl-smi">addr</span>):
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">'</span>Connection from<span class="pl-pds">'</span></span>, addr)
    <span class="pl-k">while</span> <span class="pl-c1">True</span>:
        data <span class="pl-k">=</span> <span class="pl-k">await</span> client.recv(<span class="pl-c1">1000</span>)
        <span class="pl-k">if</span> <span class="pl-k">not</span> data:
            <span class="pl-k">break</span>
        <span class="pl-k">await</span> client.sendall(data)
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">'</span>Connection closed<span class="pl-pds">'</span></span>)

<span class="pl-k">if</span> <span class="pl-c1">__name__</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>__main__<span class="pl-pds">'</span></span>:
    kernel <span class="pl-k">=</span> Kernel()
    kernel.run(run_server(<span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">25000</span>, echo_client))</pre></div>
<p>This is only a small sample of what's possible.  Read the <a href="https://curio.readthedocs.org">official documentation</a> for more in-depth coverage.  The <a href="https://curio.readthedocs.org/en/latest/tutorial.html">tutorial</a> is a good starting point.</p>
<a name="user-content-additional-features"/>
<h2><a id="user-content-additional-features" class="anchor" href="#additional-features" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Additional Features</h2>
<p>Curio provides additional support for SSL connections, synchronization
primitives (events, locks, semaphores, and condition variables),
queues, Unix signals, subprocesses, as well as thread and process
pools.  In addition, the task model fully supports cancellation,
timeouts, monitoring, and other features critical to writing reliable
code.</p>
<a name="user-content-the-big-question-why"/>
<h2><a id="user-content-the-big-question-why" class="anchor" href="#the-big-question-why" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>The Big Question: Why?</h2>
<p>Python already has a variety of libraries for async and event driven
I/O. So, why create yet another library?  There is no simple answer to
that question, but here are a few of the motivations for creating curio.</p>
<ul>
<li>Python 3 has evolved considerably as a programming language and has
adopted many new language features that are well-suited to cleanly
writing a new I/O library. For example, improved support for
non-blocking I/O, support for delegation to subgenerators (yield
from) and the introduction of explicit async and await syntax
in Python 3.5. Curio takes full advantage of these features and is
not encumbered by issues of backwards compatibility with legacy
Python code written 15 years ago.</li>
<li>Existing I/O libraries are mostly built on event-loops, callback
functions, and custom I/O abstractions--this includes Python's own
asyncio module.  Curio takes a completely different approach to the
problem that focuses almost entirely on task scheduling while
relying upon known I/O techniques involving sockets and files.  If
you have previously written synchronous code using processes or
threads, curio will feel familiar.</li>
<li>Curio is a powerful library in a small package.  An emphasis is
placed on implementation simplicity.  Simplicity is an important
part of writing reliable systems software.  When your code fails, it
helps to be able to debug it--possibly down to the level of
individual calls to the operating system if necessary. Simplicity
matters a lot.  Simple code also tends to run faster.</li>
<li>It's fun.</li>
</ul>
<a name="user-content-under-the-covers"/>
<h2><a id="user-content-under-the-covers" class="anchor" href="#under-the-covers" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Under the Covers</h2>
<p>Internally, curio is implemented entirely as a task queuing system--
much in the same model as how an actual operating system kernel
works. Tasks are represented by coroutine functions declared with the
async keyword.  Each yield of a coroutine results in a low-level
kernel "trap" or system call.  The kernel handles each trap by moving
the current task to an appropriate waiting queue. Events (i.e., due to
I/O) and other operations make the tasks move from waiting queues back
into service.</p>
<p>It's important to emphasize that the kernel is solely focused on task
management, scheduling, and nothing else. In fact, the kernel doesn't
even perform any I/O operations.  This means that it is very small,
fast, and straightforward to understand.</p>
<p>Higher-level I/O operations are carried out by a wrapper layer that
uses Python's normal socket and file objects. You use the
same operations that you would normally use in synchronous code except
that you add <code>await</code> keywords to methods that might block.</p>
<a name="user-content-questions-and-answers"/>
<h2><a id="user-content-questions-and-answers" class="anchor" href="#questions-and-answers" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Questions and Answers</h2>
<p><strong>Q: Is curio implemented using the asyncio module?</strong></p>
<p>A: No. Curio is a standalone library. Although the core of the library
uses the same basic machinery as <code>asyncio</code> to poll for I/O events,
the handling of those events is done in a completely different manner.</p>
<p><strong>Q: Is curio meant to be a clone of asyncio?</strong></p>
<p>A: No.  Although curio provides a significant amount of overlapping
functionality, some of the APIs are slightly different.  Compatibility
with other libraries is not a goal.</p>
<p><strong>Q: How many tasks can be created?</strong></p>
<p>A: Each task involves an instance of a <code>Task</code> class that
encapsulates a generator. No threads are used. As such, you're really
only limited by the memory of your machine--potentially you could have
hundreds of thousands of tasks.  The I/O functionality in curio is
implemented using the built-in <code>selectors</code> module.  Thus, the number
of open sockets allowed would be subject to the limits of that library
combined with any per-user limits imposed by the operating system.</p>
<p><strong>Q: Can curio interoperate with other event loops?</strong></p>
<p>A: At this time, no.  However, curio is a young project. It's
something that might be added later.</p>
<p><strong>Q: How fast is curio?</strong></p>
<p>A: In preliminary benchmarking of a simple echo server, curio runs
about 50-70% faster than <code>asyncio</code>.  It runs about 30-40% faster
than Twisted and about 10-15% slower than gevent, both running on
Python 2.7.  This is on OS-X so your mileage might vary. See the
<code>examples/benchmark</code> directory of the distribution for this testing
code.</p>
<p><strong>Q: Is curio going to evolve into a framework?</strong></p>
<p>A: No. The current goal is merely to provide a small, simple library
for performing concurrent I/O. It is not anticipated that curio would
evolve into a framework for implementing application level protocols
such as HTTP.  Instead, it might serve as a foundation for other packages
that want to provide that kind of functionality.</p>
<p><strong>Q: What are future plans?</strong></p>
<p>A: Future work on curio will primarily focus on features related to debugging,
diagnostics, and reliability.  A primary goal is to provide a solid
environment for running and controlling concurrent tasks.</p>
<p><strong>Q: How big is curio?</strong></p>
<p>A: The complete library currently consists of fewer than 1500 lines of
source statements.  This does not include blank lines and comments.</p>
<p><strong>Q: Can I contribute?</strong></p>
<p>A: Absolutely. Please use the Github page at
<a href="https://github.com/dabeaz/curio">https://github.com/dabeaz/curio</a> as the primary point of discussion
concerning pull requests, bugs, and feature requests.</p>
<a name="user-content-about"/>
<h2><a id="user-content-about" class="anchor" href="#about" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>About</h2>
<p>Curio was created by David Beazley (@dabeaz).  <a href="http://www.dabeaz.com">http://www.dabeaz.com</a></p>
<p>It is a young project.  Contributions welcome.</p>

</article>
  </div></body></html>