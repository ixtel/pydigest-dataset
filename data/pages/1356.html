<html><body><div><div class="content html_format"><p>
      Предыстория: я, как и многие на Хабрахабре, чертовски люблю слушать музыку. Чаще всего делаю это в ВКонтакте. Иногда уже сфомированный плейлист надоедает — хочется чего-нибудь нового; но так, чтобы не сильно отличалось от того, что уже есть. Для этого на всех сервисах, предоставляющих возможность прослушивания музыки, существуют рекомендации. Признаюсь честно, рекомендации в ВКонтакте меня ужасают. Может кому-то нравится, но у меня тамошний подбор вызывает желание закрыть браузер (ИМХО, конечно). В общем, решил я эту ситуацию для себя исправить и реализовать свои собственные рекомендации с использованием API ВКонтакте и Last.fm. Так как я много слышал и читал про Google App Engine, но никогда его не использовал, решено было приобщиться к этой платформе.</p>
<p>
Сразу скажу, что тонкости взаимодействия с API или алгоритм подбора рекомендаций здесь я описывать не буду. Об этом — в следующих статьях, может быть. В данной статье описан только процесс создания, настройки и деплоя приложения на платформе Google App Engine с использованием python и flask.</p><p>
Об опечатках и неточностях просьба сообщать в личку. Спасибо.
</p><a name="habracut"/><p>
Итак, начнем. Идем на </p><a href="https://appengine.google.com">appengine.google.com</a><p>. Там, если вы еще не авторизованы, у вас попросят ввести логин/пароль для своего аккаунта в Google.
</p><p>
После успешной авторизации видим кнопку “Create Application” (или список приложений, если они у вас есть). Насколько мне известно, без дополнительных капиталовложений Google дает возможность создать до 25-ти приложений (поправьте, если я не прав). Со списком других квот можно ознакомиться, перейдя по </p><a href="https://developers.google.com/appengine/docs/quotas">ссылке</a><p>.
</p><p>
После нажатия кнопки нас перекидывает на форму, где можно выбрать идентификатор приложения (еще не занятый) и название, а также опции аутентификации. Соглашаемся с </p><b>Terms of Service</b><p> и жмем кнопку для создания первого приложения. Создали, радость-то какая. Теперь ваше приложение доступно по адресу </p><b>http://[identifier].appspot.com</b><p>, где </p><b>identifier</b><p> — выбранный вами уникальный идентификактор приложения. Приложение доступно, но, естественно, не работает — нечему работать. Исправим ситуацию.
</p><p>
Качаем </p><b><a href="http://www.jetbrains.com/pycharm/download/">PyCharm</a></b><p>, если надо. Есть небольшой нюанс выбора версии редактора: PyCharm, который Professional Edition, имеет встроенную поддержку Google App Engine, что выражается в интегрированных в IDE инструментах деплоя. PyCharm CE такой поддержки не имеет, так что придется деплоить через консоль.
</p><p>
Создаем проект в PyCharm. Если вы используете Professional Edition, то при создании проекта можно выбрать тип “Google App Engine project”. В этом случае придется указать идентификатор вашего приложения (вышеупомянутый identifier), а также путь к App Engine SDK, так что позаботьтесь о его скачивании заранее. Получить SDK для любого поддерживаемого языка программирования можно </p><a href="https://developers.google.com/appengine/downloads">здесь</a><p>. PyCharm создаст проект с уже заполненным файлом конфигурации </p><b>app.yaml</b><p> и рабочим основным скриптом </p><b>main.py</b><p>.
</p><p>
Собственно, основной скрипт:
</p><div class="spoiler"><b class="spoiler_title">main.py</b><div class="spoiler_text"><pre><code class="python">import webapp2

class MainHandler(webapp2.RequestHandler):
    def get(self):
        self.response.write('Hello world!')

app = webapp2.WSGIApplication([
    ('/', MainHandler)
], debug=True)
</code></pre></div></div><p>
Этот пример приводится и в самом </p><a href="https://developers.google.com/appengine/docs/python/gettingstartedpython27/helloworld">руководстве</a><p> по Google App Engine для Python, и даже на сайте JetBrains. В скрипте ничего примечательного нет — стандартный HelloWorld. Скажу только для тех, кто не знает, что </p><a href="https://webapp-improved.appspot.com">webapp2</a><p> — это легковесный фреймворк, который совместим с Google App Engine и довольно прост в использовании (ну насколько я его пользовал).
</p><p>
Файл конфигурации:
</p><div class="spoiler"><b class="spoiler_title">app.yaml</b><div class="spoiler_text"><pre><code class="xml">application: pygask
version: 1
runtime: python27
api_version: 1
threadsafe: yes

handlers:
- url: /favicon\.ico
  static_files: favicon.ico
  upload: favicon\.ico

- url: .*
  script: main.app

libraries:
- name: webapp2
  version: "2.5.2"
</code></pre></div></div><p>
Разберем конфиг:
</p><ul>
<li><b>application</b> — наш идентификатор приложения (пусть ваш не смущает слово «pygask» — это вольное сокращение от python+gae+flask :) );</li>
<li><b>handlers</b> — перечень паттернов URL и описаний как их обрабатывать. В директиве handlers можно использовать два типа обработчиков — обработчики статики и обработчики скриптов. Статику, в данном случае, представляет загрузчик фавикона, скрипты — основной скрипт для запуска приложения <b>main.app</b> (Внимание! Расширение <code>.py</code> указывать не надо);</li>
<li><b>libraries</b> — библиотеки, необходимые приложению для работы; в данном случае, webapp2. Python 2.7, запускаемый на Google App Engine, поддерживает некоторый набор библиотек, работающий «из коробки». Полный список можно найти <a href="https://developers.google.com/appengine/docs/python/tools/libraries27">здесь</a>.</li>
</ul><p>
Подробное описание конфигурации приложения Google App Engine лежит </p><a href="https://developers.google.com/appengine/docs/python/config/appconfig">тут</a><p>.
</p><p>
В общем-то, наше первое приложение готово к тому, чтобы проверить его работу. Запускаем проект в PyCharm; на локальной машине он будет доступен по адресу: </p><a href="http://127.0.0.1">127.0.0.1</a><p>:8080 (если вы ничего не меняли в конфигурации проекта). Если при открытии, видите «Hello world!» — всё работает. 
</p><p>
Что делать, если вы не используете PyCharm, а запустить проект всё равно хочется? </p><p>
Linux way: в терминале выполняем команду в следующем формате:
</p><pre><code class="bash">&lt;path to python interpeter&gt; &lt;path to SDK&gt;/dev_appserver.py --host 127.0.0.1 &lt;path to project&gt;</code></pre><p>Для пояснения приведу команду, которую я использую, чтобы запустить pygask в консоли (при условии, что и SDK, и папка проекта находятся в </p><code>/var/www/</code><p>):
</p><pre><code class="bash">andymitrich@pc:~$ python /var/www/google_appengine/dev_appserver.py --host 127.0.0.1 /var/www/pygask/</code></pre><p>Набираем что-то подобное в терминале и открываем 127.0.0.1:8080 и, надеюсь, видим «Hello world!».
</p><p>
Касательно пользователей Windows — там всё немного по-другому. SDK скачивается и устанавливается на компьютер и для запуска проекта используется Google App Engine Launcher. По поводу Mac OS ничего сказать не могу — возможно в комментариях кто-нибудь расскажет.
</p><p>
К сожалению, фреймворк webapp2 — это не то, что нам нужно. Поэтому, айда подключать flask.
</p><p>
Так как в списке работающих по-умолчанию библиотек, flask не значится, то нам, в первую очередь, надо позаботиться о его подключении. Google App Engine поддерживает возможность отдельного конфигурирования используемых модулей. Делается это в файле с именем </p><b>appengine_config.py</b><p>. Подробней о нем </p><a href="https://developers.google.com/appengine/docs/python/tools/appengineconfig">здесь</a><p>. Будем использовать его для подключения фреймворка. Для этого с помощью pip установим flask во внутреннюю директорию, назовем её </p><b>lib</b><p>. Делаем это либо вручную
</p><pre><code class="bash">andymitrich@pc:~$ pip install -t /var/www/pygask/lib/ flask</code></pre><p>Либо с помощью файла </p><b>requirements.txt</b><pre><code class="bash">andymitrich@pc:~$ pip install -r /var/www/pygask/requirements.txt -t /var/www/pygask/lib/</code></pre><p> Обратите внимание на параметр </p><code>-t</code><p> — он содержит путь для установки пакета. 
</p><p>
Flask установлен, можно использовать — перепишем немного конфиг и основной скрипт:
</p><ol>
<li>Из конфига приложения <b>app.yaml</b> можно убрать участок с директивой libraries — она нам не нужна.</li>
<li>Основной скрипт теперь выглядит следующим образом:<br/>
<div class="spoiler"><b class="spoiler_title">main.py</b><div class="spoiler_text"><pre><code class="python">from flask import Flask

app = Flask(__name__)

@app.route('/')
def home():
     return 'Hello world!'
</code></pre></div></div></li>
</ol><p>
Чтобы приложение подхватило установленный flask, укажем в файле </p><b>appengine_config.py</b><p> место его нахождения.
</p><div class="spoiler"><b class="spoiler_title">appengine_config.py</b><div class="spoiler_text"><pre><code class="python">import site
import os.path

site.addsitedir(os.path.join(os.path.dirname(__file__), 'lib'))
</code></pre></div></div><p>
Пробуем запустить — видим всё тот же «Hello world!».
</p><p>
Доведем проект до более-менее кошерного вида: добавим пакет application, папки для статических файлов и шаблонов, вынесем обработчики и представления в отдельные файлы; поступайте так, как будто собираете обычный проект на flask. После всех проведенных манипуляций дерево проекта выглядит следующим образом:
</p><img src="https://habrastorage.org/files/66d/591/e88/66d591e888b545f18eb281776b1cbec7.png"/><p>
Дальше можно развивать его в какую угодно сторону.
</p><p>
Обращу ваше внимание на то, как изменились первоначальные файлы:
</p><ul>
<li>основной скрипт, который теперь состоит из одной строки<br/>
</li>
<li>файл конфигурации проекта<br/>
<div class="spoiler"><b class="spoiler_title">app.yaml</b><div class="spoiler_text"><pre><code class="xml">application: pygask
version: 1
runtime: python27
api_version: 1
threadsafe: yes

handlers:
- url: /favicon\.ico
  static_files: favicon.ico
  upload: favicon\.ico

- url: .*
  script: main.application.app</code></pre></div></div></li>
</ul><p>
В файле конфигурации изменился путь к основному скрипту — добавилось указание пакета application.
</p><p>
Допустим, выведенного на экран «Hello world!» нам достаточно на первый раз. Давайте деплоить на appspot.com. Собственно, здесь ничего сложного также нет. Но, перед тем, как начать, хочу сказать об одной важной весчи: в процессе разработки появляется много рабочих файлов, которые на сервере не нужны. Для того, чтобы они не попали туда при деплое, в конфиге приложения можно в директиве </p><b>skip_files</b><p> указать всё то, что не должно выкладываться. </p><a href="https://developers.google.com/appengine/docs/python/config/appconfig#Python_app_yaml_Skipping_files">Подробнее</a><p>.
</p><p>
Если вы счастливый пользователь PyCharm, то потрудитесь проделать «сложнейшую» операцию: Tools -&gt; Google App Engine -&gt; Upload App Engine app… Далее, если это первый деплой, выберите подходящий вам способ авторизации (я с парой email/password не разобрался — почему-то данные не подошли, поэтому использовал OAuth2 и не заморачивался) и, вуаля, можно идти на </p><b>http://[identifier].appspot.com</b><p> (в данном случае, </p><a href="http://pygask.appspot.com">pygask.appspot.com</a><p>) и смотреть на результат своих трудов.
</p><p>
Если вы по каким-то причинам не используете вышеупомянутую IDE, для вас рецепт в одну строку (Linux way):
</p><pre><code class="bash">&lt;path to python interpeter&gt; &lt;path to SDK&gt;/appcfg.py &lt;path to project&gt;</code></pre><p>Соответственно, я использую:
</p><pre><code class="bash">andymitrich@pc:~$ python /var/www/google_appengine/appcfg.py --oauth2 /var/www/pygask/</code></pre><p>
Обратите внимание на параметр </p><code>--oauth2</code><p>, он нужен для авторизации через OAuth2. Не укажете его — попросят ввести email/password. В случае успешного завершения исполнения команды, ваш проект будет доступен по соответствующему адресу.
</p><p>
На этом всё, надеюсь, что материал окажется кому-нибудь полезен. Если будет интересно, в дальнейшем расскажу как в рамках данной идеи я развлекался с API Вконтакте и Last.fm и к чему всё это привело. Спасибо за внимание.
</p><p>
P.S. Код лежит на гитхабе: </p><a href="http://github.com/andymitrich/pygask">pygask</a><p>.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>