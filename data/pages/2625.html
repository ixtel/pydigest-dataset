<html><body><div><div class="content html_format">
      <img align="right" src="https://habrastorage.org/files/652/911/ebb/652911ebbe334680a1baf15dd6815a29.png"/><p> Первого января 2015 года по расписанию вышла новая версия библиотеки для работы с изображениями </p><a href="https://pypi.python.org/pypi/Pillow/2.7.0">Pillow 2.7</a><p>. Так как многие изменения в ней были сделаны командой </p><a href="https://uploadcare.com/">Uploadcare</a><p>, мы рады представить вам расширенную версию заметок о релизе этой версии.
</p><p>
Для начала вспомним, с чего все началось. Pillow — дружественный форк (как называют его авторы) популярной библиотеки PIL, Python Imaging Library. Последняя версия PIL 1.1.7 вышла в 2009 году и в основном содержала исправления ошибок. Изначально Pillow задумывался как проект только по приведению в порядок сборки PIL, и разработчики рекомендовали отправлять все баги, не связанные со сборкой, в оригинальный PIL. Но время шло, PIL стремительно устаревала, багов не уменьшалось, тут еще Python 3 маячил на горизонте. Поэтому с версией Pillow 2.0 все изменилось. «Pillow 2.0.0 добавляет поддержку Python 3 и включает много багфиксов со всего интернета» гласит </p><a href="https://pypi.python.org/pypi/Pillow/2.0.0">описание проекта</a><p> на PyPI. И с тех пор понеслось. Каждые три месяца выходили версии с огромным количеством багфиксов и другими улучшениями от различных разработчиков. Самым значительным нововведением за это время было, пожалуй, поддержка форматов WebP и JPEG2000. Теперь пришло время следующего большого шага.
</p><a name="habracut"/>
<h2>Фильтры ресайза изображений</h2><p>
Функции ресайза изображений </p><code>Image.resize()</code><p> и </p><code>Image.thumbnail()</code><p> в качестве одного из аргументов принимают фильтр, использующийся для ресайза — </p><code>resample</code><p>. Его возможные значения: </p><code>NEAREST</code><p>, </p><code>BILINEAR</code><p>, </p><code>BICUBIC</code><p> и </p><code>ANTIALIAS</code><p>. Поведение практически каждого из них изменилось в новой версии.

</p><h3>Уменьшение изображения с билинейным и бикубическим фильтрами</h3><p>
Одной из проблем в PIL, а потом и в Pillow, было то, что для ресайза с помощью билинейного и бикубического фильтра использовался метод </p><a href="http://habrahabr.ru/post/243285/#affine-transformations">аффинных преобразований</a><p>, который использует одно и то же количество пикселей исходного изображения для формирования одного пикселя конечного (2x2 пикселя для билинейного, 4x4 для бикубического) и фиксированный размер фильтра. Это приводило к неудовлетворительным результатам для уменьшения изображения, практически не отличавшимся от метода </p><a href="http://habrahabr.ru/post/243285/#nearest-neighbor">ближайшего соседа</a><p>.

</p><img src="https://habrastorage.org/files/5de/5ab/390/5de5ab390d9341c68bce924c1cf86bb8.jpg" alt="nearest"/><img src="https://habrastorage.org/files/4bb/ab7/9cb/4bbab79cbb1445e4ab1e1d39e9066438.jpg" alt="affine"/>
<img src="https://habrastorage.org/files/9ef/e08/be1/9efe08be1c7947ab9d62bed21fd21c30.jpg" alt="nearest"/><img src="https://habrastorage.org/files/6da/8c9/84c/6da8c984c1d44d76bcdecd84db250491.jpg" alt="affine"/>
<p>
Слева метод ближайшего соседа, справа бикубический фильтр аффинных преобразований. Первый образец — уменьшение в 5,8 раз, различий практически нет. Второй — в 1,8 раз, отличия минимальные, на резких диагональных линиях видна лесенка.
</p><p>
В то же время для фильтра </p><code>ANTIALIAS</code><p> использовался высококачественный </p><a href="http://habrahabr.ru/post/243285/#convolution">алгоритм на основе сверток</a><p>, что давало одинаково хороший результат как для уменьшения, так и для увеличения.
</p><p>
Начиная с Pillow 2.7.0, высококачественный алгоритм на основе сверток используется для всех трех фильтров.

</p><img src="https://habrastorage.org/files/4bb/ab7/9cb/4bbab79cbb1445e4ab1e1d39e9066438.jpg" alt="affine"/><img src="https://habrastorage.org/files/377/b37/de6/377b37de67134e5ebf3753fcbe234b31.jpg" alt="convolution"/>
<img src="https://habrastorage.org/files/6da/8c9/84c/6da8c984c1d44d76bcdecd84db250491.jpg" alt="affine"/><img src="https://habrastorage.org/files/e0d/829/e99/e0d829e9993442b0add881cf624dd411.jpg" alt="convolution"/>
<p>
Слева бикубический фильтр на основе аффинных преобразований, справа — свертки. Свертки определенно выигрывают.
</p><p>
Если до того вы использовали какие-то ухищрения для улучшения качества при использовании билинейного или бикубического фильтра (например, уменьшение изображения за несколько шагов или предварительное размытие), теперь в них нет необходимости.

</p><h3>Antialias переименован в Lanczos</h3><p>
Новая константа </p><code>Image.LANCZOS</code><p> была добавлена взамен </p><code>Image.ANTIALIAS</code><p>.
</p><p>
Когда метод </p><code>ANTIALIAS</code><p> был впервые представлен, он был единственным высококачественным методом, основанным на свертках. И его имя отражало этот факт. Теперь, когда все методы основаны на свертках, они все стали «сглаживающими». А настоящее название фильтра, которое использовалось раньше для этой константы — фильтр Ланцоша.
</p><p>
Само собой, старая константа оставлена для обратной совместимости и является псевдонимом для новой. Шутка для лингвистов: Antialias is alias now.

</p><h3>Качество фильтра Ланцоша при увеличении</h3><p>
Как ни странно, с качеством сверок тоже было не все в порядке. В предыдущих версиях был баг, из-за которого качество фильтра Ланцоша при увеличении было практически таким же, как у фильтра </p><code>BILINEAR</code><p>. Этот баг был исправлен.

</p><img src="https://habrastorage.org/files/e70/673/ba9/e70673ba93ed4f6b96d24c5c3b6942a1.jpg" alt="before"/><img src="https://habrastorage.org/files/57d/e6e/964/57de6e9647414eb3a669dd4a3541bbf7.jpg" alt="after"/>
<img src="https://habrastorage.org/files/670/665/3e5/6706653e5f364fe28dd4b4932ac0eafb.jpg" alt="before"/><img src="https://habrastorage.org/files/c8c/65e/a0e/c8c65ea0e4ba4cf5b638d86289b2e5d2.jpg" alt="after"/>
<p>
Слева результат увеличения в 4,3 раза предыдущей версии, справа — Pillow 2.7.0. Картинки слева одновременно более размытые и пикселизованные.

</p><h3>Качество бикубического фильтра при увеличении</h3><p>
Бикубический фильтр, реализованный для аффинных преобразований, давал резкую, слегка пикселизованную картинку при увеличении. Бикубический фильтр, реализованный для сверток, немного мягче.

</p><img src="https://habrastorage.org/files/9a5/428/051/9a542805186248cc9e60669705735ec7.jpg" alt="before"/><img src="https://habrastorage.org/files/473/aec/5bf/473aec5bfbd74455aac5e691b84df69a.jpg" alt="after"/>
<img src="https://habrastorage.org/files/93a/33d/95a/93a33d95ac0c486abdb1b70277cf6d3a.jpg" alt="before"/><img src="https://habrastorage.org/files/4a0/33f/f3a/4a033ff3a2844338a0b7a86bf1cbb5f7.jpg" alt="after"/>
<p>
Слева результат увеличения в 4,3 раза предыдущей версии, справа — Pillow 2.7.0. Картинки слева более пикселизованные (имеют более ощутимые границы пикселей). В то же время диагональные линии на первом примере более четкие и менее подвержены эффекту лесенки. И то и другое — влияние параметра «a» в </p><a href="http://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm">бикубическом уравнении</a><p>. Избежать обоих эффектов можно только с помощью более качественного фильтра Ланцоша.

</p><h3>Производительность ресайза</h3><p>
В общем случае </p><a href="http://habrahabr.ru/post/243285/#convolution">свертки</a><p> — более затратный алгоритм для уменьшения, потому что в отличие от </p><a href="http://habrahabr.ru/post/243285/#affine-transformations">аффинных преобразований</a><p>, он учитывает все пиксели исходного изображения. Из-за этого чистая производительность билинейного и бикубического фильтров может быть ниже, чем раньше. С другой стороны, если вы до этого были удовлетворены качеством билинейного и бикубического фильтров для уменьшения, возможно вам стоит подумать над использованием </p><code>NEAREST</code><p> фильтра, который давал практически такой же результат. Это существенно увеличит производительность.
</p><p>
В то же время одно из существенных улучшений Pillow 2.7.0 в том, что производительность сверток для уменьшения была увеличена в среднем в 2 раза по сравнению с предыдущей версией и даже по сравнению с ImageMagick. Производительность увеличения свертками для фильтра </p><code>BILINEAR</code><p> оказалась быстрее в полтора раза, для </p><code>BICUBIC</code><p> — в четыре, а для </p><code>LANCZOS</code><p> осталась на том же уровне.
</p><p>
Т.к. скорее всего вы не использовали в своем приложении ничего, кроме </p><code>LANCZOS</code><p> (бывший </p><code>ANTIALIAS</code><p>), то производительность при уменьшении для вас должна увеличиться в среднем в два раза. Если использование Ланцоша для вас было вынужденной мерой из-за низкого качества остальных фильтров, то теперь вы можете перейти, например, на билинейный фильтр. Это увеличит производительность еще примерно в 2 раза для уменьшения и примерно на 30% для увеличения.

</p><h3>Фильтр по умолчанию для <code>Image.thumbnail()</code></h3><p>
В Pillow 2.5 фильтр по умолчанию для </p><code>Image.thumbnail()</code><p> был изменен с </p><code>NEAREST</code><p> на </p><code>ANTIALIAS</code><p>. Этот фильтр был выбран по причине, неоднократно озвученной выше — низкое качество остальных фильтров. В Pillow 2.7.0 фильтр по умолчанию вновь изменен, в этот раз на </p><code>BICUBIC</code><p>, потому что он немного быстрее. На самом деле Ланцош не дает каких-либо преимуществ после использования метода </p><code>Image.draft()</code><p> внутри </p><code>Image.thumbnail()</code><p>, который уменьшает изображение с помощью библиотеки </p><code>libjpeg</code><p> и использует для этого </p><a href="http://habrahabr.ru/post/243285/#supersampling">суперсемплинг</a><p>, а не свертки.

</p><h2>Транспонирование изображений</h2><p>
Новый метод </p><code>Image.TRANSPOSE</code><p> был добавлен для функции </p><code>Image.transpose()</code><p> в дополнение к уже существующим </p><code>FLIP_LEFT_RIGHT</code><p>, </p><code>FLIP_TOP_BOTTOM</code><p>, </p><code>ROTATE_90</code><p>, </p><code>ROTATE_180</code><p>, </p><code>ROTATE_270</code><p>. </p><code>TRANSPOSE</code><p> — это алгебраическое транспонирование, т.е. отражение изображения относительно его основной диагонали.
</p><p>
Производительность методов </p><code>ROTATE_90</code><p>, </p><code>ROTATE_270</code><p> и </p><code>TRANSPOSE</code><p> была существенно увеличена для больших изображений, не помещающихся в кэш процессора.
</p><p>
Эти три метода объединяет то, что в них пиксели берутся из строк, а помещаются в столбцы. Такой шаблон доступа к памяти оказывается очень не эффективным для больших изображений, потому что данные успевают вытесниться из кэша процессора за один проход и их приходится заново загружать из памяти для следующего прохода.
</p><p>
В новой версии изображение разбивается на логические квадраты размером в 128×128 пикселей, и операции над пикселями производятся последовательно внутри каждого квадрата. Это позволяет существенно сократить дистанцию, которую проходит процессор на каждой строке, в результате чего данные не успевают вытесниться из кэша (память, необходимая для одного квадрата, равна 64Кб).

</p><h2>Гауссово размытие и контурная резкость</h2><p>
Реализация </p><code>ImageFilter.GaussianBlur</code><p> была заменена на последовательное применение бокс-фильтров. Новая реализация основана на статье </p><a href="http://www.mia.uni-saarland.de/Publications/gwosdek-ssvm11.pdf">Theoretical foundations of Gaussian convolution by extended box filtering</a><p> от Mathematical Image Analysis Group. Так как реализация </p><code>ImageFilter.UnsharpMask</code><p> базируется на Гауссовом размытии, все, что описано в этой секции, также применимо и к ней.

</p><h3>Радиус размытия</h3><p>
В предыдущих версиях Pillow была ошибка, из-за которой радиус размытия (стандартное отклонение Гауссианы) на самом деле задавал его диаметр. Поэтому, например, чтобы размыть изображение на радиус 5, нужно было указывать значение 10. Ошибка была исправлена, и теперь значение радиуса интерпретируется так же, как во всем остальном программном обеспечении.
</p><p>
Если до этого вы использовали Гауссово размытие с определенным радиусом, вам нужно поделить его значение на два.

</p><h3>Производительность размытия</h3><p>
Время вычисления бокс-фильтра постоянно относительно его радиуса и зависит только от размеров входного изображения. Т.к. новая реализация Гауссового размытия основана на бокс-фильтре, её вычисление также не зависит от радиуса размытия.
</p><p>
Для радиуса в 1 пиксель новая реализация работает 5 раз быстрее, для радиуса 10 — в 18 раз, для радиуса 50 — уже в 85 раз. Ваш дизайнер, рисующий интерфейсы в стиле iOS 8, должен быть доволен.

</p><h3>Качество размытия</h3><p>
Теоретически при Гауссовом размытии в вычислении каждой точки конечного изображения должны участвовать все точки исходного с определенными коэффициентами. На практике коэффициенты точек дальше 3×стандартное отклонение настолько малы, что учитывать их нет смысла.
</p><p>
Предыдущая реализация учитывала только пиксели в радиусе 2×стандартное отклонение для каждого конечного пикселя. Этого было недостаточно, поэтому качество было хуже в сравнении с другими реализациями Гауссова размытия.
</p><p>
Несмотря на то, что новая реализация является лишь математической аппроксимацией, она не содержит такого бага.

</p><img src="https://habrastorage.org/files/073/86a/19d/07386a19dce1405da6e4c1fc3b6fca96.jpg" alt="before"/><img src="https://habrastorage.org/files/3eb/607/23f/3eb60723f2f042fa8cd5639b02ffa303.jpg" alt="after"/>
<img src="https://habrastorage.org/files/cec/85b/ebe/cec85bebe8eb4fb9b03943e27eb0a0cc.jpg" alt="before"/><img src="https://habrastorage.org/files/382/7bc/f82/3827bcf825f34d969401302c46e7a6e9.jpg" alt="after"/>
<p>
Слева результат размытия с радиусом 5 в предыдущей версии (с учетом бага с удвоением радиуса), справа — в новой. Слева видны резкие границы объектов.

</p><hr/><p>
Все эти изменения уже работают на наших серверах. Благодаря им мы повысили качество и скорость </p><a href="https://uploadcare.com/documentation/cdn/#image-operations">API для обработки картинок на лету</a><p>. Также мы реализовали операцию </p><a href="https://uploadcare.com/documentation/cdn/#operation-blur">быстрого блюра</a><p>. Но это еще не все. Мы готовим следующий большой шаг для Pillow, о котором объявим чуть позже.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>