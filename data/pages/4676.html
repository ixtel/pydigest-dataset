<html><body><div><div class="post-content">
      <h2>Alternate title: Pip 7 is Awesome, Here's Why</h2>

<p>A typical Python deployment looks like this:</p>

<ul>
<li>Pave the server, setting up a virtualenv and installing any pre-requisites necessary to build/install the Python requirements (compiler, development headers, etc.).</li>
<li>To update to a new release:

<ol>
<li>Update your source code</li>
<li>Install its dependencies into the virtualenv via something like <code data-syntax="text-only">pip install -r requirements.txt</code></li>
</ol></li>
</ul>

<p>This approach works, but is lacking in a few ways:</p>

<ul>
<li>Deployments are dependent on the network and availability of PyPI.</li>
<li>"Clean" installs are prohibitively slow to do on every deploy. Because of that:

<ul>
<li>You can't easily/quickly rollback to a previous release.</li>
<li>The virtualenv will accrue cruft over time as dependencies are added/removed.</li>
</ul></li>
</ul>

<p>Docker solves a number of these problems, but <a href="https://lincolnloop.com/blog/closer-look-docker/">for many reasons I'm not sold on using it in production (yet)</a>. The good news is that today's release of Python's package installer, pip (version 7), will help you solve all these issues without Docker. It uses Python's <a href="http://pythonwheels.com/">wheel</a> format to cache binary builds of the dependencies.</p>

<p>Wheels are extremely fast, particularly for packages that require compilation (Pillow, psycopg2, lxml, etc.) "How fast?" you may ask... Well, let's look at a few examples using <a href="https://github.com/lincolnloop/wagtaildemo/tree/clean">our fork of the Wagtail demo project</a> on a 2GB Digital Ocean VPS (all commands were run with a warm pip download cache).</p>

<h2>Clean Install with Pip 6.1.1</h2>

<p>First we'll do a clean install of the project using the previous version of pip (6.1.1). </p>

<pre class="highlight"><code data-syntax="bash"><span class="o">(</span>pip6<span class="o">)</span>pete@box:~<span class="nv">$ </span><span class="nb">time </span>pip install -r wagtaildemo/requirements/deploy.txt &gt; /dev/null
You are using pip version 6.1.1, however version 7.0.0 is available.
You should consider upgrading via the <span class="s1">'pip install --upgrade pip'</span> command.

real    3m4.797s
user    3m14.219s
sys     0m17.540s</code></pre>

<p>This takes about 3.25 minutes, approximately <strong>195 seconds</strong>. <em>Every</em> build with pip 6 will take roughly the same time.</p>

<h2>Clean Install with Pip 7</h2>

<p>Now we'll do the same build, but using pip 7 which caches the builds in wheel format.</p>

<pre class="highlight"><code data-syntax="bash"><span class="o">(</span>pip7<span class="o">)</span>pete@box:~<span class="nv">$ </span><span class="nb">time </span>pip install -r wagtaildemo/requirements/deploy.txt &gt; /dev/null

real    3m10.726s
user    3m19.412s
sys     0m19.167s</code></pre>

<p>This typically runs at about the same speed as pip 6 (+/- 5s), approximately <strong>200 seconds</strong>.</p>

<h2>Rebuild with Pip 7</h2>

<p>Now that we have cached wheels, let's see how long it takes to install the same dependencies into a clean virtualenv using pip 7.</p>

<pre class="highlight"><code data-syntax="bash"><span class="o">(</span>pip7-cache<span class="o">)</span>pete@box:~<span class="nv">$ </span><span class="nb">time </span>pip install -r wagtaildemo/requirements/deploy.txt &gt; /dev/null

real    0m10.852s
user    0m8.378s
sys     0m2.368s</code></pre>

<p>This runs in about <strong>11 seconds</strong>. An order of magnitude faster than the other tests. </p>

<p><em>Note: deploys that add new dependencies may take longer while the wheel cache is created for those packages.</em></p>

<h2>Deployment Improvements</h2>

<p>This speed improvement unlocks a number of interesting possibilities for Python deployments that were previously too slow to consider.</p>

<p>It's now feasible to build a new virtualenv on every deploy. The virtualenv can be considered <strong>immutable</strong>. That is, once it is created, it will never be modified. No more concerns about legacy cruft causing issues with the build.</p>

<p>This also opens the door to saving previous builds for <strong>quick rollbacks</strong> in the event of a bad deploy. Rolling back could be as simple as moving a symlink and reloading the Python services.</p>

<p>Another possibility is building your wheels in a central location prior to deployment. As long as your build server (or container) matches the OS and architecture of the application servers, you can <strong>build the wheels once and distribute</strong> them as a tarball (see Armin Ronacher's <a href="http://platter.pocoo.org/">platter</a> project) or using your own PyPI server. In this scenario, you are guaranteed the packages are an exact match across all your servers. You can also avoid installing build tools and development headers on all your servers because the wheels are pre-compiled.</p>

<h2>The Future</h2>

<p>We're excited about the opportunities wheels provide without adding additional layers of software on our servers. It's inspiring to see the massive improvements being made to Python's packaging system over the last few years while still maintaining backwards compatibility with legacy packages. I'm looking forward to seeing what comes next.</p>

    </div>

    
    
    </div></body></html>