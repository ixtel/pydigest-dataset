<html><body><div><div class="post-body entry-content"><p>
By </p><a href="http://www.dancingbison.com">Vasudev Ram</a><p/><a href=""/>
<a href=""/>
<p>
As part of some Python work, I was tinkering with the built-in </p><a href="https://docs.python.org/2/library/functions.html#globals"><b>globals()</b></a><p> function of Python,  when I noticed this:
</p><pre>&gt;&gt;&gt; g = globals()
&gt;&gt;&gt; <b>g</b>
{'a': 'A', 'A': 'C', 'C': 4, 'b': 'a', <b>'g': {...}</b>, '__builtins__': , 'k': '__doc__', '__package__': None, '__name__
': '__main__', '__doc__': None}
&gt;&gt;&gt; # The variable g seems to have got stored inside of itself!
&gt;&gt;&gt; id(g)
31298152L
&gt;&gt;&gt; id(globals())
31298152L
&gt;&gt;&gt; <b>g['g'] == g</b>
True
&gt;&gt;&gt; <b>g['g']['g'] == g</b>
True
&gt;&gt;&gt; g['g']['g']['g'] == g
True
&gt;&gt;&gt; <b>id(g['g']['g']['g']) == id(g)</b>
True
</pre><p>The above does make a kind of sense, when you remember that the </p><b>globals()</b><p> function returns a dict representing </p><a href="https://docs.python.org/2/library/functions.html#globals">the current global symbol table</a><p>, i.e. all the currently defined attributes (objects) in the global scope.
</p><p>
So when I said </p><b>g = globals()</b><p>, the variable </p><b>g</b><p> got created in the global scope; so when I next print g, it should contain g itself, i.e. </p><b>g (a list) contains itself as a list item (of g)</b><p>.
</p><p>
But on further thought, it seems like this should </p><b>depend on the order of the evaluation</b><p> of the statement </p><b>g = globals()</b><p>:
</p><p>
Case 1) If the variable g is created first (and hence the global symbol table now contains it), and if only after that is the globals() function called, and its return value assigned to g, then things should work as shown in the above interpreter output.
</p><p>
Case 2) But if the evaluation works in a different order, i.e. the globals() function is first called (before the variable g is created), then at this point its return value (the dict) should not contain the item with key 'g' (and value g), and it is this dict that should get assigned to the variable g. Hence when we print g, we should not see g again within it. 
</p><p>
Considering the above output, it seems like Case 1 is what actually happens. Also, I realized that if the globals() function is returning a </p><b>copy</b><p> of the dict that represents the global state, the above output should not work. But it seems to be returning the </p><b>original</b><p> dict itself, as shown by this:
</p><pre>&gt;&gt;&gt; id(g) == id(globals())
True
</pre><p>To explore this further, I thought of trying to create a similar self-referential structure, but without using globals():
</p><pre>lis = []
lis.append(1)
print 'lis:', lis
print 'id(lis):', id(lis)
lis.append(lis)
print 'lis:', lis
print 'id(lis):', id(lis)
print 'id(lis[1]):', id(lis[1])
print lis == lis[1]
print lis[1] == lis[1][1]
</pre><p>And the output again seems to indicate that the list lis now references itself, that is, contains itself as an item.
</p><p>
I then thought of testing my </p><a href="http://jugad2.blogspot.in/2014/10/flattening-arbitrarily-nested-list-in.html">Python function to flatten an arbitrarily nested list</a><p>, with the above definition of lis, as the input argument. As expected, it terminated with a run-time error about recursion limit exceeded. See the post linked in the previous sentence for the flatten function - and some variations on it, in the comments on that post.
</p><p>
I'll write more about this in a following post, after fixing the flatten function to handle this case. On first thought, the fix seems straightforward: at any level in the recursion, check if id(lis) == id(lis[i]) - for any i, and if so terminate with an error about this being a self-referential list - but I'll write and test it first, then blog the results.
</p><p>
The more interesting question is whether this is a known Python feature, or an undocumented one (seems unlikely), or a bug (unlikely), and also whether similar behavior exists in other languages. Interested to hear what others think / know about this.

</p><b>Update:</b>
<p>
I looked in the official Python Language Reference, at the </p><b>Section 3. Data model</b><p>:
</p><p>
https://docs.python.org/2/reference/datamodel.html
</p><p>
and saw this excerpt:
</p><p>
[ CPython implementation detail: CPython currently uses a reference-counting scheme with (optional) delayed detection of </p><b>cyclically linked</b><p> garbage, which collects most objects as soon as they become unreachable, but is not guaranteed to collect garbage containing </p><b>circular references</b><p>. ]
</p><p>
Not sure whether it is relevant to the topic at hand, since, on the one hand, it uses the words "cyclically linked", but on the other, it says "garbage collection".
</p><p>
The image at the top of the post is of an </p><a href="http://en.wikipedia.org/wiki/Ouroboros">ouroboros</a><p>, which is "ancient symbol depicting a serpent or dragon eating its own tail", according to Wikipedia. Sort of appropriate, I guess, </p><i>because Python</i><p> :)
</p><a href=""/>
<p/><p>- </p><a href="http://jugad2.blogspot.in/p/about-vasudev-ram.html">Vasudev Ram - Online Python and Linux training and programming</a> <p/><p>Dancing Bison Enterprises</p><p/><p/><b><a href="mailto:vasudevram@gmail.com?subject=Email%20me%20about%20your%20new%20products%20and%20services">Signup to hear about new products or services that I create.</a></b> <p/><a href="http://jugad2.blogspot.com/search/label/python">Posts about Python</a>  <a href="http://jugad2.blogspot.com/search/label/xtopdf">Posts about xtopdf</a> <p/><a href="http://www.dancingbison.com/contact.html">Contact Page</a> <p/>   
<p/>
</div>
</div></body></html>