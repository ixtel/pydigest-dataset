<html><body><div><div class="post-content clearfix">

        <p>Writing safe Twisted code has recently become a large focus of my job. Therefore, I have been doing a bit of thinking on the subject. I concluded that I would write a small post describing some of the considerations required when attempting to write reliable code with Twisted. </p>

<p>However, I wasn't sure how much Twisted knowledge to assume and it wasn't quite clear to me how to frame the post. So instead this post will try to evolve a minimal example to the point where the considerations I originally intended to demonstrate reveal themselves naturally. To get there, I will try to attempt to emulate some of the intuitional thinking a newer Twisted developer might progress through to reach the end result. At a minimum, you should at least know what a <code>Deferred</code> is. If you don't here is the <a href="https://twistedmatrix.com/documents/current/core/howto/defer.html">official material on them</a>. Before second guessing yourself though, <em>yes</em> they are just objects you attach callbacks to.</p>

<h1>The task at hand</h1>

<p>In this article we're going to iterate on a small script which will attempt to demonstrate some basic Twisted patterns by implementing a data pipeline with distinct asynchronous steps. In the real world this might be reflected by fetching some data from Service A, sending it to Service B for processing and finally sending it to Service C for persistence.</p>

<p>In our implementation, instead of using actual network services, we will emulate them by leaning on local Unix utilities available on our system. The premise is the same since talking to a network service and a local subprocess, while different, both rely on some deferred operation that we must handle asynchronously.</p>

<h3>Our pipeline</h3>

<ul>
<li><strong>Fetch data</strong>: <em>utilize /dev/urandom to get some bytes</em>
<ul><li><code>head -c 1024 /dev/urandom</code></li></ul></li>
<li><strong>Process data</strong>: <em>utilize wc to count the words</em>
</li>
<li><strong>Persist data</strong>: <em>utilize tee to write the data to file</em>
</li>
</ul>

<p>The pipeline we will implement will essentially be the equivalent to the following on the commandline:</p>

<pre><code>head -c 1024 /dev/urandom | wc -w | tee /tmp/result.txt
</code></pre>

<p>However, instead of utilizing pipes on the commandline, we will run each program individually with Twisted, taking its output and writing it to the standard input of the next program. While we work, try to keep the equivalency to network services in mind.</p>

<h1>Talking to subprocesses</h1>

<p>There are a few ways to spawn and communicate with subprocesses with Twisted including some nice helper functions located in <code>twisted.internet.utils</code> Each return a <code>Deferred</code> which fires with some aspect of the result of running the subprocess:</p>

<ul>
<li><code>getProcessValue</code> fires with the exit code</li>
<li><code>getProcessOutput</code> fires with whatever the process writes to standard output</li>
<li><code>getProcessValueAndOutput</code> fires with both</li>
</ul>

<p>The problem with using these in our example is that none of these utility functions provide a mechanism for writing to the standard input of our subprocesses. Therefore, we will have to utilize <code>spawnProcess</code> which is a method of the reactor.</p>

<p>Here is the (abridged) signature as listed in the <a href="http://twistedmatrix.com/documents/current/api/twisted.internet.interfaces.IReactorProcess.spawnProcess.html">documentation</a>:</p>

<pre><code>spawnProcess(processProtocol, executable, args=())
</code></pre>

<p>The only parameter here that likely needs explanation is the <code>processProtocol</code> which the documentation describes thusly:</p>

<p><strong>An object which will be notified of all events related to the created process. (type: <a href="http://twistedmatrix.com/documents/current/api/twisted.internet.interfaces.IProcessProtocol.html">IProcessProtocol</a> provider)</strong></p>

<p>Now you may not be familiar with writing process protocols but I assure it is quite simple. If you'd like a little background on how they are written and used you can read through the official "How To" on <a href="http://twistedmatrix.com/documents/current/core/howto/process.html">using processes</a>. That said, a <code>ProcessProtocol</code> is merely a class who's methods are called when various events take place like when we connect to the process, or say, when the process writes to its standard output.</p>

<h3>Building a pipe</h3>

<p>We want to interact with all three of our processes in essentially the same way. We want to write some data to their standard input, wait until they are done executing, and consume anything they write to their standard output. When the process is finished, we'd like to be called back with the standard output.</p>

<p>We'll start by defining and writing the initializer for a new <code>ProtocolProcess</code> subclass we'll call <code>Pipe</code>:</p>

<pre><code>class Pipe(protocol.ProcessProtocol):
    def __init__(self, d, input=None):
        self.deferred = d
        self.input = input
        self.output = ""
</code></pre>

<p><code>Pipe</code>'s initializer takes a <code>Deferred</code> instance and optionally some data for writing to a process' standard input. We save them to the instance and create a placeholder for the process' output.</p>

<p>Next we'll handle our connection to the process with the <code>connectionMade</code> method:</p>

<pre><code>def connectionMade(self):
    if self.input:
        self.transport.write(self.input)
    self.transport.closeStdin()
</code></pre>

<p>As soon as the process starts we will use the <code>transport</code> of the <code>protocol</code> to write to its standard input if the <code>Pipe</code> has any to write. Then we close the standard input stream whether we wrote any data or not.</p>

<pre><code>def outReceived(self, data):
    self.output += data
</code></pre>

<p>When the process writes to its standard output <code>outReceived</code> will be called with contents and here we're merely accumulating it.</p>

<pre><code>class Pipe(protocol.ProcessProtocol):
    def __init__(self, d, input=None):
        self.deferred = d
        self.input = input
        self.output = ""

    def connectionMade(self):
        if self.input:
            self.transport.write(self.input)
        self.transport.closeStdin()

    def outReceived(self, data):
        self.output += data

    def processEnded(self, reason):
        self.deferred.callback(self.output)
</code></pre>

<p>With <code>processEnded</code> we complete our protocol by handling the termination of the remote process by firing the original <code>Deferred</code> instance with the contents of the process output.</p>

<p>With the <code>ProcessProtocol</code> completed let's give ourselves an easy to use helper that will return a <code>Deferred</code> which will fire after a specified process spins up, receives our input, and we've captured its output.</p>

<pre><code>def make_pipe(cmd, *args, **kwargs):
    '''create a deferred that fires with the output of the process'''
    d = defer.Deferred()
    pipe = Pipe(d, kwargs.get('stdin'))
    args = [cmd] + list(args)
    reactor.spawnProcess(pipe, cmd, args)
    return d
</code></pre>

<p>Our helper takes the name of a command and any number of arguments. Optionally you can specify data with <code>stdin</code> to be written to the process' input.</p>

<p>After creating the <code>Deferred</code> instance that we eventually return, we pass it to a newly created instance of our <code>ProcessProtocol</code> class <code>Pipe</code>. We then finally call <code>reactor.spawnProcess</code> which schedules the spinning up of the process. Once the process has started our <code>Pipe</code> protocol will write to the standard input and suck up any output from the process. When the process terminates it will fire the <code>Deferred</code> we passed it. The same <code>Deferred</code> that is returned to the caller of this function.</p>

<p>With a simple way to start processes we can now return to the actual task at hand.</p>

<h1>Generating data</h1>

<p>The first step in our pipeline is to generate some data, the same way we might fetch some data from a remote webservice. In this case we'll simply read some bytes from <code>/dev/urandom</code> with the <code>head</code> utility. With our <code>make_pipe</code> helper this is a sinch.</p>

<pre><code>def get_data(n):
    '''emulate network retreival of some data'''
    return make_pipe('head', '-c', str(n), '/dev/urandom')
</code></pre>

<p><code>get_data</code> simply utilizes <code>make_pipe</code> to create a <code>Deferred</code> that will fire in precisely the way we wish it to. <code>get_data</code> does nothing more and simple returns this <code>Deferred</code>.</p>

<p>We'll then need a <em>"callback function"</em> for attaching to <code>Deferred</code> instances created by <code>get_data</code> which fire with the output of the process. We could print the output to the screen however since the data is random it will likely just output a bunch of garbage potentially putting our terminal into an invalid state. Instead we'll simply split the data on whitespace characters and print out how many 'words' there are:</p>

<pre><code>def result(output):
    '''take some data and print out how many words there are'''
    print len(output.split())
</code></pre>

<p>Now we have everything we need to schedule the work and handle its result:</p>

<pre><code>d = get_data(1024)
d.addCallback(result)
</code></pre>

<p>We simply take the <code>Deferred</code> instance and attach <code>result</code> as the callback. Since we don't want our program's reactor to keep running once our work is finished, we'll attach yet another callback which stops the reactor. This will allow our program to cleanly shutdown once the work is complete. We'll use a lambda to simply call <code>reactor.stop</code>:</p>

<pre><code>d.addCallback(lambda _: reactor.stop())
</code></pre>

<p>If you didn't already know, <code>addCallback</code> will actually return the original <code>Deferred</code> instance. This means you can actually chain these together into something that looks like this:</p>

<pre><code># get some data
(get_data(1024)
    # then process the data
    .addCallback(result)
    # then stop the reactor
    .addCallback(lambda _: reactor.stop()))
</code></pre>

<p>You can decide for yourself which style to use. And with that the work is scheduled. We just need to start the reactor and kick it all off and our script is complete:</p>

<pre><code>from twisted.internet import defer, task, reactor, protocol

class Pipe(protocol.ProcessProtocol):
    def __init__(self, d, input=None):
        self.deferred = d
        self.input = input
        self.output = ""

    def connectionMade(self):
        if self.input:
            self.transport.write(self.input)
        self.transport.closeStdin()

    def outReceived(self, data):
        self.output += data

    def processEnded(self, reason):
        self.deferred.callback(self.output)

def make_pipe(cmd, *args, **kwargs):
    '''create a deferred that fires with the output of the process'''
    d = defer.Deferred()
    pipe = Pipe(d, kwargs.get('stdin'))
    args = [cmd] + list(args)
    reactor.spawnProcess(pipe, cmd, args)
    return d

def get_data(n):
    '''emulate network retreival of some data'''
    return make_pipe('head', '-c', str(n), '/dev/urandom')

def result(output):
    '''take some data and print out how many words there are'''
    print len(output.split())

# get some data
(get_data(1024)
    # then process the data
    .addCallback(result)
    # then stop the reactdor
    .addCallback(lambda _: reactor.stop()))

reactor.run()
</code></pre>

<p>Here is what we get when when we run the script a few times:</p>



<p>In the next part we'll finish implementing the rest of our pipeline by adding support for <code>wc</code> and <code>tee</code>. In the third part we'll take a look at how to add exception handling in the case of failure.</p>
    </div>

    </div></body></html>