<html><body><div><div class="entry-content">
		<p><a href="http://tech.magnetic.com/2015/05/optimize-python-with-closures.html">This blog post by Dan Crosta is interesting.</a> It talks about how is possible to optimise Python code for operations that get called multiple times avoiding the usage of Object Orientation and using Closures instead.</p>
<p>While the “<em>closures</em>” gets the highlight, the main idea is a little more general. Avoid repeating code that is not necessary for the operation.</p>
<p>The difference between the first proposed code, in OOP way</p>
<pre class="brush: python; title: ; notranslate" title="">
class PageCategoryFilter(object):
    def __init__(self, config):
        self.mode = config["mode"]
        self.categories = config["categories"]

    def filter(self, bid_request):
        if self.mode == "whitelist":
            return bool(
                bid_request["categories"] &amp; self.categories
            )
        else:
            return bool(
                self.categories and not
                bid_request["categories"] &amp; self.categories
            )
</pre>
<p>and the last one</p>
<pre class="brush: python; title: ; notranslate" title="">
def make_page_category_filter(config):
    categories = config["categories"]
    mode = config["mode"]
    def page_category_filter(bid_request):
        if mode == "whitelist":
            return bool(bid_request["categories"] &amp; categories)
        else:
            return bool(
                categories and not
                bid_request["categories"] &amp; categories
            )
    return page_category_filter
</pre>
<p>The main differences are that both the config dictionary and the methods (which are also implemented as a dictionary) are not accessed. We create a direct reference to the value (categories and mode) instead of making the Python interpreter search on the self methods over and over.</p>
<p>This generates a significant increase in performance, as described on the post (around 20%).</p>
<p>But why stop there? There is another clear win in terms of access, assuming that the filter doesn’t change. This is the “mode”, which we are comparing for whitelist of blacklist on each iteration. We can create a different closure depending on the mode value.</p>
<pre class="brush: python; title: ; notranslate" title="">
def make_page_category_filter2(config):
    categories = config["categories"]
    if config['mode'] == "whitelist":
        def whitelist_filter(bid_request):
            return bool(bid_request["categories"] &amp; categories)
        return whitelist_filter
    else:
        def blacklist_filter(bid_request):
            return bool(
                categories and not
                bid_request["categories"] &amp; categories
            )
        return blacklist_filter
</pre>
<p>There are another couple of details. The first one is to transform the config categories into a <a href="https://docs.python.org/2/library/stdtypes.html#frozenset">frozenset</a>. Assuming that the config doesn’t change, a frozenset is more efficient than a regular mutable set. This is insinuated in the post, but maybe didn’t get the final review (or to simplify it).</p>
<p>Also, we are calculating the intersection of a set (operand &amp;) to then reduce it to a bool. There is currently a set operation that gets the result without calculating the whole intersection (<a href="https://docs.python.org/2/library/stdtypes.html#set.isdisjoint">isdisjoint</a>).</p>
<p>The same basic principle applies to calculate the bool category for the black filter. We can calculate it only once, as it’s there to short-circuit the result in case of an empty config category.</p>
<pre class="brush: python; title: ; notranslate" title="">
def make_page_category_filter2(config):
    categories = frozenset(config["categories"])
    bool_cat = bool(categories)
    if config['mode'] == "whitelist":
        def whitelist_filter(bid_request):
            return not categories.isdisjoint(bid_request["categories"])
        return whitelist_filter
    else:
        def blacklist_filter(bid_request):
            return (bool_cat and categories.isdisjoint(bid_request["categories"]))
        return blacklist_filter
</pre>
<p>Even if all of this enters the definition of micro-optimisations (which should be used with care, and only after a <a href="http://en.wikipedia.org/wiki/Hot_spot_%28computer_programming%29">hot spot</a> has been found), it actually makes a significant difference, reducing the time around 35% from the closure implementation and <strong>~50%</strong> from the initial reference implementation.</p>
<p>All these elements are totally applicable to the OOP implementation, by the way. Python is quite flexible about assigning methods. No closures!</p>
<pre class="brush: python; title: ; notranslate" title="">
class PageCategoryFilter2(object):
    ''' Keep the interface of the object '''
    def __init__(self, config):
        self.mode = config["mode"]
        self.categories = frozenset(config["categories"])
        self.bool_cat = bool(self.categories)
        if self.mode == "whitelist":
            self.filter = self.filter_whitelist
        else:
            self.filter = self.filter_blacklist

    def filter_whitelist(self, bid_request):
        return not bid_request["categories"].isdisjoint(self.categories)

    def filter_blacklist(self, bid_request):
        return (self.bool_cat and
                bid_request["categories"].isdisjoint(self.categories))
</pre>
<h2>Show me the time!</h2>
<p><a href="https://dl.dropboxusercontent.com/u/16516236/code/class_func_closure_bench_v2.py">Here is the updated code</a>, adding this implementations to the test.</p>
<p>The results in my desktop (2011 iMac 2.7GHz i5) are</p>
<pre class="brush: plain; title: ; notranslate" title="">
        total time (sec)  time per iteration
class   9.59787607193     6.39858404795e-07
func    8.38110518456     5.58740345637e-07
closure 7.96493911743     5.30995941162e-07
class2  6.00997519493     4.00665012995e-07
closur2 5.09431600571     3.39621067047e-07
</pre>
<p>The new class performs better than the initial closure! The optimised closure is anyway trumping, saving a big chunk compared with the slower implementation. The PyPy results are all very close, and it speeds up 10x the code, which is an amazing feat.</p>
<p>Of course, a word of caution. The configuration is assumed to not change for a filter, which I think is reasonable.</p>
<p><strong>Happy optimising!</strong></p>
<div id="jp-post-flair" class="sharedaddy sd-rating-enabled sd-like-enabled sd-sharing-enabled"><div class="sharedaddy sd-block sd-like jetpack-likes-widget-wrapper jetpack-likes-widget-unloaded" id="like-post-wrapper-6419543-1344-56d5b8e51b332" data-src="//widgets.wp.com/likes/#blog_id=6419543&amp;post_id=1344&amp;origin=wrongsideofmemphis.wordpress.com&amp;obj_id=6419543-1344-56d5b8e51b332" data-name="like-post-frame-6419543-1344-56d5b8e51b332"><h3 class="sd-title">Like this:</h3><p class="likes-widget-placeholder post-likes-widget-placeholder"><span class="button"><span>Like</span></span> <span class="loading">Loading...</span></p><span class="sd-text-color"/><a class="sd-link-color"/></div>
<p id="jp-relatedposts" class="jp-relatedposts">
	<h3 class="jp-relatedposts-headline"><em>Related</em></h3>
</p></div>			</div>

	</div></body></html>