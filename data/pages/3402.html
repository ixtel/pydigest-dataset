<html><body><div><div class="post-text" itemprop="text">
<p>Here's my try on it. If you're doing this for some end users, you might want to skip. What I did probably works well for setting up some fast math objects library, but only when the user knows what's going on.</p>

<p>Idea was that all variables describing a math object follow the same pattern, a=something*smntng. </p>

<p>So when calculating a variable irl, in the worst case I would be missing "something", then I'd go and calculate that value, and any values I'd be missing when calculating that one, and bring it back to finish calculating the original variable I was looking for. There's a certain recursion pattern noticeable. </p>

<p>When calculating a variable therefore, at <strong>each access</strong> of a variable I've got to check if it exists, and if it doesn't calculate it. Since it's at each access I have to use <code>__getattribute__</code>. </p>

<p>I also need a functional relationship between the variables. So I'll pin a class attribute <code>relations</code> which will serve just that purpose. It'll be a dict of variables and an appropriate function.</p>

<p>But I've also got to check in advance if I have all the necessary variables to calculate current one.  so I'll amend my table, of centralized math relations between variables, to list all dependencies  and before I go to calculate anything, I'll run over the listed dependencies and calc those if I need too.</p>

<p>So now it looks more like we'll have a ping pong match of semi-recursion where a function <code>_calc</code> will call <code>__getattribute__</code> which calls function <code>_calc</code> again. Until such a time we run out of variables or we actually calculate something.</p>

<p><strong>The Good</strong>: </p>

<ul>
<li>There are no <code>if</code>s</li>
<li>Can initialize with different init variables. As long as the sent variables enable calculations of others. </li>
<li>It's fairly generic and looks like it could work for any other mathematical object describable in a similar manner.</li>
<li>Once calculated all your variables will be remembered.</li>
</ul>

<p><strong>The Bad</strong>: </p>

<ul>
<li>It's fairly "unpythonic" for whatever that word means to you (explicit is always better).</li>
<li>Not user friendly. Any error message you recieve will be as long as the number of times <code>__getattribute__</code> and <code>_calc</code> called each other. Also no nice way of formulating a pretty error print. </li>
<li>You've a consistency issue at hand. This can probably be dealt with by overriding setters.</li>
<li>Depending on initial parameters, there is a possibility that you'll have to wait a long time to calculate a certain variable, especially if the requested variable calculation has to fall through several other calculations.</li>
<li>If you need a complex function, you have to make sure it's declared before <code>relations</code> which might make the code ugly (also see last point). I couldn't quite work out how to get them to be instance methods, and not class methods or some other more global functions because I basically overrided the <code>.</code> operator.</li>
<li>Circular functional dependencies are a concern as well. (<code>a</code> needs <code>b</code> which needs <code>e</code> which needs <code>a</code> again and into an infinite loop). </li>
<li><code>relations</code> are set in a <code>dict</code> type. That means here's only 1 functional dependency you can have per variable name, which isn't necessarily true in mathematical terms.</li>
<li>It's already ugly: <code>value = self.relations[var]["func"](   *[self.__getattribute__(x) for x in requirements["req"]] )</code></li>
</ul>

<p>Also that's the line in <code>_calc</code> that calls <code>__getattribute__</code> which either calls <code>_calc</code> again, or if the variable exists returns the value. Also at each <code>__init__</code> you have to set all your attributes to None, because otherwise a <code>_getattr</code> will be called.</p>

<pre><code>def cmplx_func_A(e, C):
    return 10*C*e

class Elipse():
    def __init__(self, a=None, b=None, **kwargs):
        self.relations = {
        "e": {"req":["a", "b"], "func": lambda a,b: a+b},
        "C": {"req":["e", "a"], "func": lambda e,a: e*1/(a*b)},
        "A": {"req":["C", "e"], "func": lambda e,C: cmplx_func_A(e, C)},
        "a": {"req":["e", "b"], "func": lambda e,b: e/b},
        "b": {"req":["e", "a"], "func": lambda e,a: e/a}
                   }
        self.a = a
        self.b = b
        self.e = None
        self.C = None
        self.A = None
        if kwargs:
            for key in kwargs:
                setattr(self, key, kwargs[key])

    def __getattribute__(self, attr):
        val = super(Elipse, self).__getattribute__(attr)
        if val: return val
        return self._calc(attr)

    def _calc(self, var):
        requirements = self.relations[var]
        value = self.relations[var]["func"](
            *[self.__getattribute__(x) for x in requirements["req"]]
            )
        setattr(self, var, value)
        return value
</code></pre>

<p>Oputput:</p>

<pre><code>&gt;&gt;&gt; a = Elipse(1,1)
&gt;&gt;&gt; a.A #cal to calculate this will fall through
        #and calculate every variable A depends on (C and e)
20
&gt;&gt;&gt; a.C #C is not calculated this time.
1 
&gt;&gt;&gt; a = Elipse(1,1, e=3)
&gt;&gt;&gt; a.e #without a __setattribute__ checking the validity, there is no 
3       #insurance that this makes sense.
&gt;&gt;&gt; a.A #calculates this and a.C, but doesn't recalc a.e
30
&gt;&gt;&gt; a.e
3
&gt;&gt;&gt; a = Elipse(b=1, e=2) #init can be anything that makes sense
&gt;&gt;&gt; a.a                  #as it's defined by relations dict.
2.0
&gt;&gt;&gt; a = Elipse(a=2, e=2) 
&gt;&gt;&gt; a.b
1.0
</code></pre>

<p>There is one more issue here, related to the next to last point in "the bad". I.e. let's imagine that we can can define an elipse with <code>C</code> and <code>A</code>. Because we can relate each variable with others over only 1 functional dependency, if you defined your variables <code>a</code> and <code>b</code> over <code>e</code> and <code>a|b</code> like I have, you won't be able to calculate them. There will always be at least some miniature subset of variables you will have to send. This can be alleviated by making sure you define as much of your variables over as little other variables you can but can't be avoided. </p>

<p>If you're lazy, this is a good way to short-circuit something you need done fast, but I wouldn't do this somewhere, where I expect someone else to use it, ever!</p>
    </div>
    </div></body></html>