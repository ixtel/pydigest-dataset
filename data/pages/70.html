<html><body><div><div class="post-body entry-content" id="post-body-6476291832497729684" itemprop="description articleBody"><p>
I've been hanging around on #sqlalchemy for years now, helping other users where I could. People come there for help with many different kinds of problems, but after a while, you start seeing common patterns. Certain difficulties seem to persist amongst SQLAlchemy newbies. This is my attempt at documenting these issues and providing answers and solutions where applicable. These 10 issues are not in any real order of appearance frequency – I just wrote them down in the order in which they popped into my mind.</p>

<b>Updated </b><p>2013-09-09: Corrected facts in section 5.
</p><ol>
</ol>
<h3>
1. Not finding the (right) tutorial</h3><p>
Occasionally, someone comes on the channel asking questions while referring to a tutorial outside of </p><a href="http://sqlalchemy.org/">sqlalchemy.org</a><p>. These tutorials are often out of date or just plain incorrect. Personally, when I look for a tutorial on something, the first place to look would be the official website of the project you're trying to learn to use. I would say that is common sense.
</p><p>
There's also another group of people, who are able to find the official documentation but miss the tutorials, despite them being the first links on both the ORM and Core sections.
</p><p>
While I don't think there's any important information really missing from the SQLAlchemy documentation, the top page could probably be laid out differently to emphasize the suggested starting points for new users.

</p><h3>
2. Boilerplate constructors</h3><p>
The declarative 
metaclass provides a default constructor for model classes, making 
explicit constructors largely unnecessary. The issue is that many people just don't seem to know about this, and happily add explicit constructors to all their classes. I
 actually blame the SQLAlchemy documentation for not clearly pointing 
this out. I've only ever found a single mention of this feature in the 
documentation. In my opinion, its existence should be prominently advertised in the 
ORM tutorial.
</p><p>
So instead of creating a constructor that
 accepts all your fields as arguments, just skip the constructor and 
instantiate classes like </p><span>Company(name='Foo', address='blah')</span><p>.
</p><ol>
</ol>
<h3>
3. Believing that defining or modifying the model classes creates or modifies the tables themselves</h3><p>
A surprising amount of new users seem to believe that SQLAlchemy is capable of automatically modifying their tables to match their classes. I am not aware of any ORM that does such a thing automatically, least of all reliably.
</p><p>
If you change your declared classes, you need to explicitly alter the schema in the actual database too, by  either:
</p><ol>
<li>using the tool of your choice (usually <span>psql</span> / <span>mysql</span> / other command line tool or a graphical tool like phpMyAdmin etc.) to manually create/alter/drop the tables</li>
<li>using a migration library like <a href="https://pypi.python.org/pypi/alembic" target="_blank">Alembic</a></li>
</ol>
<h3>
4. Forgetting to import model modules before attempting to call metadata.create_all()</h3><p>
I must admit that I was bitten by this one when I was starting with SQLAlchemy. You already know that </p><span>metadata.create_all()</span><p> creates all your tables, right? Sure, but before that can happen, all the modules that declare tables must have been imported. I mean, how else would SQLAlchemy know what the tables are?
</p><p>
Personally I hadn't even thought about how that works, but then there are some people who seem to expect SQLAlchemy to scan the project structure for model classes! Admittedly, the metaclass machinery that puts declarative classes in the metadata may in the beginning seem so magical that you expect everything to "just work" by itself.
</p><p>
So remember kids, you need to import all your model modules so that the metadata can be filled in. Only then will the call to </p><span>metadata.create_all()</span><p> do anything useful.

</p><h3>
5. Confusion between .one(), .first() and .scalar()</h3><p>
Every week I see someone pasting code that uses </p><span>Query.one() </span><p>and catching the </p><span>NoResultException</span><p>. Then others complain that </p><span>Query.first()</span><p> should return a scalar value instead of a </p><span>KeyedTuple</span><p> when a single column or expression has been selected. </p><span>Query.scalar()</span><p> is virtually unheard of.
</p><p>
So let me clear up the confusion once and for all:
</p><ul>
<li><span>Query.one()</span> executes the query and raises <span>MultipleResultsFound</span> if the number of rows was more than 1, and <span>NoResultFound</span> no rows were found. Otherwise it returns the sole result row (as tuple)</li>
<li><span>Query.first()</span> executes the query with <span>LIMIT 1</span> and returns the result row as tuple, or <span>None</span> if no rows were found</li>
<li><span>Query.scalar()</span> executes the query and raises <span>MultipleResultsFound<span> </span></span> if the number of rows was more than 1. If no rows were found, it returns <span>None<span>. Otherwise it </span></span>returns the first column of the sole result row. </li>
</ul>
<span>Query.one()</span><p> should be used if you want to select a single row and you assume there is exactly one row to be found. </p><span>Query.first()</span><p> should be used when you want just one row but you're not sure if one will be found. </p><span>Query.scalar()</span><p> should be used when you want, for example, just the maximum of a single column.

</p><h3>
6. Not understanding scoped_session and sessionmaker</h3><p>
This is quite possibly the greatest source of confusion among SQLAlchemy users. Especially so for developers who have very little experience in threaded programming. First, a quick recap:
</p><ul>
<li><span>Session</span>: a container of instances of mapped classes; among other things lets you construct queries dynamically and add/delete/update entities</li>
<li><span>sessionmaker</span>: a session factory generator (in other words, a function that returns a function that returns a new Session for each call)</li>
<li><span>scoped_session</span>: a threadlocal manager and proxy of sessions </li>
</ul><p>
If you're still confused, you're not alone! So let me try and clear this up a bit. The </p><span>sqlalchemy.orm.session.Session</span><p> class is where the real meat is. The other two are merely helpers. In trivial scripts, this one is all you need.
</p><p>
The </p><span>sessionmaker</span><p> function is a convenience function for instantiating </p><span>Session<span> objects </span></span><p>with customized parameters. Most notably session makers can't be used as proxies – you have to call one to get a session first.
</p><p>
The </p><span>scoped_session</span><p> function creates a thread local proxy/manager of </p><span>Session</span><p> instances. What this means is that you can access the scoped session object as if it was like a Session instance. The scoped session "knows" (by virtue of </p><a href="http://docs.python.org/3.3/library/threading.html#thread-local-data" target="_blank">threadlocal</a><p> objects) which thread is asking for a session and so it always returns the same session for the same thread. This is very convenient for multithreaded applications because you don't have to worry about sessions accidentally crossing threads.
</p><p>
Some want to call the scoped session to get a Session instance. While that certainly works, it's almost always unnecessary. Instead:

</p><pre><pre>DBSession <span>=</span> scoped_session<span>(</span>sessionmaker<span>(</span>engine<span>)</span><span>)</span>
companies <span>=</span> DBSession<span>.</span>query<span>(</span>Company<span>)</span><span>.</span>all<span>(</span><span>)</span>
</pre>
</pre>
<h3>
7. Query properties</h3><p>
Certain web frameworks (I'm looking at you, </p><a href="http://pythonhosted.org/Flask-SQLAlchemy/queries.html#querying-records" rel="nofollow" target="_blank">Flask-SQLAlchemy</a><p>!) promote the use of query properties that supposedly make querying easier. Trouble is, it is apparently not obvious from the example code how one would query for specific columns, aggregates or other expressions using said query property.
</p><p>
The solution is to use the session directly:

</p><pre><pre>db<span>.</span>session<span>.</span>query<span>(</span>Company<span>.</span>address<span>)</span>
</pre>
</pre>
<h3>
8. Attempting to access related classes through relationships in queries:</h3><p>
Someone asks something like this every week on #sqlalchemy:
</p><blockquote class="tr_bq">
&lt;<b>anon</b>&gt; anyone see anything wrong with this query: c = 
Category.query.join(Category.parent).filter(Category.name=='Social 
Issues', Category.parent.name=='Teens').first()</blockquote><p>
What is wrong with this query is of course that Category.parent is a relationship and thus it doesn't have a "name" attribute. I don't blame anyone who falls for this though. It would make sense, from the syntactic perspective, for this to work. It might automatically add a join to Category.parent in the query. The reason why this can't be done is beyond my knowledge of SQLAlchemy. Anyway, to fix the query, you add an alias and join that:

</p><pre><pre>parent <span>=</span> aliased<span>(</span>Category<span>)</span>
c <span>=</span> Category<span>.</span>query<span>.</span>join<span>(</span>parent<span>,</span> Category<span>.</span>parent<span>)</span><span>.</span>\
    <span>filter</span><span>(</span>Category<span>.</span>name<span>=</span><span>=</span><span>'Social Issues'</span><span>,</span>
           parent<span>.</span>name<span>=</span><span>=</span><span>'Teens'</span><span>)</span><span>.</span>first<span>(</span><span>)</span>
</pre>
</pre>
<h3>
9. Wanting to commit the session to get the ID of an object so it can be used to insert related objects</h3><p>
Most nontrivial SQLAlchemy applications need to work with relationships. Imagine a situation like this: You need to create a </p><span>Company</span><p> and add an </p><span>Employee</span><p> to it. You already have a relationship called employees in the </p><span>Company</span><p> class. So how would you accomplish this task? The typical answer goes along the lines of:
</p><ol>
<li>Create the <span>Company</span> instance</li>
<li>Add the <span>Company</span> instance to the session</li>
<li>Flush the session</li>
<li>Create the <span>Employee</span> instance with <span>company_id</span> from the previously flushed Company instance</li>
<li>Add the <span>Employee</span> instance to the session</li>
<li>Commit the session</li>
</ol><p>
This is just about how you'd do it without SQLAlchemy. But with SQLAlchemy this can be done much easier:
</p><ol>
<li>Create the <span>Company</span> instance</li>
<li>Create the <span>Employee</span> instance</li>
<li>Add the <span>Company</span> instance to the session</li>
<li>Commit the session</li>
</ol><p>
When the session is flushed, the </p><span>Company</span><p> row is first inserted to the database. Then, by virtue of relationship cascade, the </p><span>Employee</span><p> instance is discovered and also inserted into the database. The RDBMS can't tell the difference, but for the developer, the latter approach is much nicer.

</p><h3>
10. Running tests using SQLite instead of the production RDBMS</h3><p>
I've written a </p><a href="http://alextechrants.blogspot.fi/2013/08/unit-testing-sqlalchemy-apps.html" target="_blank">separate blog post</a><p> about this, but tl;dr: always test against the same RDBMS that you deploy with.
</p><p/>
</div>
</div></body></html>