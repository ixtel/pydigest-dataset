<html><body><div><div class="entry-content padding-bottom">
            <p>The <a href="http://launchpad.net/ceilometer">Ceilometer</a> project supports various
database backend that can be used as storage. Among them are
<a href="http://www.mongodb.org/">MongoDB</a>, <a href="http://sqlite.org">SQLite</a>
<a href="http://mysql.com">MySQL</a>, <a href="http://postgresql.org">PostgreSQL</a>,
<a href="http://hbase.apache.org/">HBase</a>, DB2… All Ceilometer's code is unit
tested, but when dealing with external storage services, one cannot be sure
that the code is really working. You could be inserting data with an
incorrect SQL statement, or in the wrong table. Only having the real
database storage running and being used can tell you that.</p>


<p>Over the months, we developed integration testing on top of our unit testing
to validate that our storage drivers are able to deal with real world
databases. That is not really different from generic
<a href="http://en.wikipedia.org/wiki/Integration_testing">integration testing</a>.
Integration testing is about plugging all the pieces of your software all
together and running. In what I call "database integration testing", the
pieces will be both your software and the database system that you are going
to rely on.</p>
<p>The only difference here is that one of the module is not coming from the
application itself but is an external project.
The type of database that you use (RDBMS, NoSQL…) does not matter. Taking a
step back, what I will describe here could also apply to a lot of other
different software modules, even something that would not be a database
sytem at all.</p>
<h2>Writing tests for integration</h2>
<p>Presumably, your Python application has unit tests. In order to test against
a database back-end, you need to write a few specific classes of tests that
will use the database subsystem for real. For example:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span><br/><span class="kn">import</span> <span class="nn">os</span><br/><span class="kn">import</span> <span class="nn">sqlalchemy</span><br/> <br/><span class="k">class</span> <span class="nc">TestDB</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span><br/>    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><br/>       <span class="n">url</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">"DB_TEST_URL"</span><span class="p">)</span><br/>       <span class="k">if</span> <span class="ow">not</span> <span class="n">url</span><span class="p">:</span><br/>           <span class="bp">self</span><span class="o">.</span><span class="n">skipTest</span><span class="p">(</span><span class="s">"No database URL set"</span><span class="p">)</span><br/>       <span class="bp">self</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">create_engine</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><br/></pre></div>

<p><br/>
This code will try to fetch the database URL to use from an environment
variable, and then will rely on <a href="http://sqlalchemy.org">SQLAlchemy</a> to
create a database connection.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span><br/><span class="kn">import</span> <span class="nn">os</span><br/><span class="kn">import</span> <span class="nn">sqlalchemy</span><br/> <br/><span class="kn">import</span> <span class="nn">myapp</span><br/> <br/><span class="k">class</span> <span class="nc">TestDB</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span><br/>    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><br/>       <span class="n">url</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">"DB_TEST_URL"</span><span class="p">)</span><br/>       <span class="k">if</span> <span class="ow">not</span> <span class="n">url</span><span class="p">:</span><br/>           <span class="bp">self</span><span class="o">.</span><span class="n">skipTest</span><span class="p">(</span><span class="s">"No database URL set"</span><span class="p">)</span><br/>       <span class="bp">self</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">create_engine</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><br/> <br/>    <span class="k">def</span> <span class="nf">test_foobar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><br/>        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">myapp</span><span class="o">.</span><span class="n">store_integer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="p">,</span> <span class="mi">42</span><span class="p">))</span><br/></pre></div>

<p><br/>
You can then add as many tests as you want using the connection stored in
<code>self.engine</code>. If no test database URL is, the tests will be skipped;
however that decision is up to you. You may want to have these tests always
run and fail if they can't be run.</p>
<p>In the <code>setUp()</code> method, you may also need to do more work, like create a
database and delete a database.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span><br/><span class="kn">import</span> <span class="nn">os</span><br/><span class="kn">import</span> <span class="nn">sqlalchemy</span><br/> <br/><span class="k">class</span> <span class="nc">TestDB</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span><br/>    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><br/>       <span class="n">url</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">"DB_TEST_URL"</span><span class="p">)</span><br/>       <span class="k">if</span> <span class="ow">not</span> <span class="n">url</span><span class="p">:</span><br/>           <span class="bp">self</span><span class="o">.</span><span class="n">skipTest</span><span class="p">(</span><span class="s">"No database URL set"</span><span class="p">)</span><br/>       <span class="bp">self</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">create_engine</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><br/>       <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span><br/>       <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"CREATE DATABASE testdb"</span><span class="p">)</span><br/> <br/>    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><br/>        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"DROP DATABASE testdb"</span><span class="p">)</span><br/></pre></div>

<p><br/>
This will make sure that the database you need is clean and ready to be used
to testing.</p>
<h2>Launching modules, a.k.a. databases</h2>


<p>The main problem we encountered when building integration testing with
databases, is to find a way to start them. Most users are used to start them
system-wide with some sort of init script, but when running sandboxed tests,
that is not really a good option. Browsing the documentation of each storage
allowed us to find a way to start them in foreground and control them
"interactively" via a shell script.</p>
<p>The following is a script that you can use to run Python tests using
<a href="http://nose.readthedocs.org/">nose</a> and is heavily inspired by the one we
wrote for Ceilometer.</p>
<div class="highlight"><pre><span class="c">#!/bin/bash</span><br/><span class="nb">set</span> -e<br/> <br/>clean_exit<span class="o">()</span> <span class="o">{</span><br/>    <span class="nb">local </span><span class="nv">error_code</span><span class="o">=</span><span class="s2">"</span><span class="nv">$?</span><span class="s2">"</span><br/>    <span class="nb">kill</span> -9 <span class="k">$(</span><span class="nb">jobs</span> -p<span class="k">)</span> &gt;/dev/null 2&gt;<span class="p">&amp;</span><span class="m">1</span> <span class="o">||</span> <span class="nb">true</span><br/><span class="nb">    </span>rm -rf <span class="s2">"PGSQL_DATA"</span><br/>    <span class="k">return</span> <span class="nv">$error_code</span><br/><span class="o">}</span><br/> <br/>check_for_cmd <span class="o">()</span> <span class="o">{</span><br/>    <span class="k">if</span> ! which <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> &gt;/dev/null 2&gt;<span class="p">&amp;</span>1<br/>    <span class="k">then</span><br/>        <span class="nb">echo</span> <span class="s2">"Could not find </span><span class="nv">$1</span><span class="s2"> command"</span> 1&gt;<span class="p">&amp;</span>2<br/>        <span class="nb">exit </span>1<br/>    <span class="k">fi</span><br/><span class="o">}</span><br/> <br/>wait_for_line <span class="o">()</span> <span class="o">{</span><br/>    <span class="k">while</span> <span class="nb">read </span>line<br/>    <span class="k">do</span><br/>        <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$line</span><span class="s2">"</span> <span class="p">|</span> grep -q <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="nb">break</span><br/><span class="nb">    </span><span class="k">done</span> &lt; <span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span><br/>    <span class="c"># Read the fifo for ever otherwise process would block</span><br/>    cat <span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span> &gt;/dev/null <span class="p">&amp;</span><br/><span class="o">}</span><br/> <br/>check_for_cmd postgres<br/> <br/><span class="nb">trap</span> <span class="s2">"clean_exit"</span> EXIT<br/> <br/><span class="c"># Start PostgreSQL process for tests</span><br/><span class="nv">PGSQL_DATA</span><span class="o">=</span><span class="sb">`</span>mktemp -d /tmp/PGSQL-XXXXX<span class="sb">`</span><br/><span class="nv">PGSQL_PATH</span><span class="o">=</span><span class="sb">`</span>pg_config --bindir<span class="sb">`</span><br/><span class="si">${</span><span class="nv">PGSQL_PATH</span><span class="si">}</span>/initdb <span class="si">${</span><span class="nv">PGSQL_DATA</span><span class="si">}</span><br/>mkfifo <span class="si">${</span><span class="nv">PGSQL_DATA</span><span class="si">}</span>/out<br/><span class="si">${</span><span class="nv">PGSQL_PATH</span><span class="si">}</span>/postgres -F -k <span class="si">${</span><span class="nv">PGSQL_DATA</span><span class="si">}</span> -D <span class="si">${</span><span class="nv">PGSQL_DATA</span><span class="si">}</span> <span class="p">&amp;</span>&gt; <span class="si">${</span><span class="nv">PGSQL_DATA</span><span class="si">}</span>/out <span class="p">&amp;</span><br/><span class="c"># Wait for PostgreSQL to start listening to connections</span><br/>wait_for_line <span class="s2">"database system is ready to accept connections"</span> <span class="si">${</span><span class="nv">PGSQL_DATA</span><span class="si">}</span>/out<br/><span class="nb">export </span><span class="nv">DB_TEST_URL</span><span class="o">=</span><span class="s2">"postgresql:///?host=</span><span class="si">${</span><span class="nv">PGSQL_DATA</span><span class="si">}</span><span class="s2">&amp;dbname=template1"</span><br/> <br/><span class="c"># Run the tests</span><br/>nosetests<br/></pre></div>

<p><br/>
If you use <a href="http://tox.readthedocs.org">tox</a> to automatize your test run,
you can use this scripts (I call it <code>run-test.sh</code>) in your <code>tox.ini</code> file.</p>
<div class="highlight"><pre><span class="k">[testenv]</span><br/><span class="na">commands</span> <span class="o">=</span> <span class="s">{toxinidir}/run-tests.sh {posargs}</span><br/></pre></div>

<p><br/>
</p>
<p>Most databases are able to be run in some sort of standalone mode where you
can connect to them using a either a Unix domain socket, or a fixed port.
Here are the snippet used in Ceilometer to run with MongoDB and MySQL:</p>
<div class="highlight"><pre><span class="c"># Start MongoDB process for tests</span><br/><span class="nv">MONGO_DATA</span><span class="o">=</span><span class="k">$(</span>mktemp -d /tmp/MONGODB-XXXXX<span class="k">)</span><br/><span class="nv">MONGO_PORT</span><span class="o">=</span>29000<br/>mkfifo <span class="si">${</span><span class="nv">MONGO_DATA</span><span class="si">}</span>/out<br/>mongod --maxConns <span class="m">32</span> --nojournal --noprealloc --smallfiles --quiet --noauth --port <span class="si">${</span><span class="nv">MONGO_PORT</span><span class="si">}</span> --dbpath <span class="s2">"</span><span class="si">${</span><span class="nv">MONGO_DATA</span><span class="si">}</span><span class="s2">"</span> --bind_ip localhost <span class="p">&amp;</span>&gt;<span class="si">${</span><span class="nv">MONGO_DATA</span><span class="si">}</span>/out <span class="p">&amp;</span><br/><span class="c"># Wait for Mongo to start listening to connections</span><br/>wait_for_line <span class="s2">"waiting for connections on port </span><span class="si">${</span><span class="nv">MONGO_PORT</span><span class="si">}</span><span class="s2">"</span> <span class="si">${</span><span class="nv">MONGO_DATA</span><span class="si">}</span>/out<br/><span class="nb">export </span><span class="nv">DB_TEST_URL</span><span class="o">=</span><span class="s2">"mongodb://localhost:</span><span class="si">${</span><span class="nv">MONGO_PORT</span><span class="si">}</span><span class="s2">/testdb"</span><br/></pre></div>

<p><br/>
</p>
<div class="highlight"><pre><span class="c"># Start MySQL process for tests</span><br/><span class="nv">MYSQL_DATA</span><span class="o">=</span><span class="k">$(</span>mktemp -d /tmp/MYSQL-XXXXX<span class="k">)</span><br/>mkfifo <span class="si">${</span><span class="nv">MYSQL_DATA</span><span class="si">}</span>/out<br/>mysqld --datadir<span class="o">=</span><span class="si">${</span><span class="nv">MYSQL_DATA</span><span class="si">}</span> --pid-file<span class="o">=</span><span class="si">${</span><span class="nv">MYSQL_DATA</span><span class="si">}</span>/mysql.pid --socket<span class="o">=</span><span class="si">${</span><span class="nv">MYSQL_DATA</span><span class="si">}</span>/mysql.socket --skip-networking --skip-grant-tables <span class="p">&amp;</span>&gt; <span class="si">${</span><span class="nv">MYSQL_DATA</span><span class="si">}</span>/out <span class="p">&amp;</span><br/><span class="c"># Wait for MySQL to start listening to connections</span><br/>wait_for_line <span class="s2">"mysqld: ready for connections."</span> <span class="si">${</span><span class="nv">MYSQL_DATA</span><span class="si">}</span>/out<br/><span class="nb">export </span><span class="nv">DB_TEST_URL</span><span class="o">=</span><span class="s2">"mysql://root@localhost/testdb?unix_socket=</span><span class="si">${</span><span class="nv">MYSQL_DATA</span><span class="si">}</span><span class="s2">/mysql.socket&amp;charset=utf8"</span><br/></pre></div>

<p><br/>
The mechanism is always the same. We create a <em>fifo</em> with <code>mkfifo</code>, and then
run the database daemon with the output redirected to that fifo. We then
read from it until we find a line stating the the database is ready to be
used. At that point, we can continue and start running the tests. You have
to read continuously from the fifo, otherwise the process writing to it will
block. We redirect the output to <code>/dev/null</code>, but you could also redirect it
to a different log file, or not at all.</p>
<blockquote>
Note: <a href="http://www.die-welt.net/">Evgeni Golov</a> pointed it exists
a <a href="https://alioth.debian.org/scm/loggerhead/pkg-postgresql/postgresql-common/trunk/view/head:/pg_virtualenv">pg_virtualenv</a>
for PostgreSQL and <a href="https://github.com/evgeni/my_virtualenv">my_virtualenv</a> for MySQL
that does the same kind of thing, but with more bells and whistles.
</blockquote>

<h2>One step further: using parallelism and scenarios</h2>
<p>The described approach is quite simple, as it only support one database
type. When using an abstraction layer, such as SQLAlchemy, it would be a
good idea to run all these tests against different RDBMS, such as MySQL and
PostgreSQL for example.</p>
<p>The snippet above allows to run both RDBMS in parallel, but the classic
approach of unit tests does not allow that. Using one scenario for each
database backend would be a great idea. To that end, you can use the
<a href="https://launchpad.net/testscenarios">testscenarios</a> library.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span><br/><span class="kn">import</span> <span class="nn">os</span><br/><span class="kn">import</span> <span class="nn">sqlalchemy</span><br/><span class="kn">import</span> <span class="nn">testscenarios</span><br/> <br/><span class="n">load_tests</span> <span class="o">=</span> <span class="n">testscenarios</span><span class="o">.</span><span class="n">load_tests_apply_scenarios</span><br/> <br/><span class="k">class</span> <span class="nc">TestDB</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span><br/>    <span class="n">scenarios</span> <span class="o">=</span> <span class="p">[</span><br/>        <span class="p">(</span><span class="s">'mysql'</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">database_connection</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">"MYSQL_TEST_URL"</span><span class="p">)),</span><br/>        <span class="p">(</span><span class="s">'postgresql'</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">database_connection</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">"PGSQL_TEST_URL"</span><span class="p">)),</span><br/>    <span class="p">]</span><br/> <br/>    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><br/>       <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_connection</span><span class="p">:</span><br/>           <span class="bp">self</span><span class="o">.</span><span class="n">skipTest</span><span class="p">(</span><span class="s">"No database URL set"</span><span class="p">)</span><br/>       <span class="bp">self</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">create_engine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database_connection</span><span class="p">)</span><br/>       <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span><br/>       <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"CREATE DATABASE testdb"</span><span class="p">)</span><br/> <br/>    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><br/>        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"DROP DATABASE testdb"</span><span class="p">)</span><br/></pre></div>

<p><br/></p>
<div class="highlight"><pre><span class="nv">$ </span>python -m subunit.run test_scenario <span class="p">|</span> subunit2pyunit<br/>test_scenario.TestDB.test_foobar<span class="o">(</span>mysql<span class="o">)</span><br/>test_scenario.TestDB.test_foobar<span class="o">(</span>mysql<span class="o">)</span> ... ok<br/>test_scenario.TestDB.test_foobar<span class="o">(</span>postgresql<span class="o">)</span><br/>test_scenario.TestDB.test_foobar<span class="o">(</span>postgresql<span class="o">)</span> ... ok<br/> <br/>---------------------------------------------------------<br/>Ran <span class="m">2</span> tests in 0.061s<br/> <br/>OK<br/></pre></div>

<p><br/>
To speed up tests run, you could also run the test in parallel. It can be
intesting as you'll be able to spread the workload among a lot of different
CPUs.
However, note that it can require a different database for each test or a
locking mechanism to be in place. It's likely that your tests won't be able
to work altogether at the same time on only one database.</p>
<p>(Both usage of scenarios and parallelism in testing will be covered in
<a href="https://julien.danjou.info/books/the-hacker-guide-to-python">The Hacker's Guide to Python</a>,
in case you wonder.)</p>          </div>

          </div></body></html>