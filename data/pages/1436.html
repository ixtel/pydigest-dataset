<html><body><div><div class="content html_format"><p>
      Это тринадцатая статья в серии, где я описываю свой опыт написания веб-приложения на Python с использованием микрофреймворка Flask.</p>
<p>
Цель данного руководства — разработать довольно функциональное приложение-микроблог, которое я за полным отсутствием оригинальности решил назвать microblog.

</p>
<a name="habracut"/>
<blockquote><h5><b>Примечание касательно GitHub</b></h5><br/>
Для тех кто не заметил, я не так давно перенес исходные коды microblog-а на github. Репозитарий расположен по следующему адресу:<br/>
<a href="https://github.com/miguelgrinberg/microblog">https://github.com/miguelgrinberg/microblog</a><br/>
Для каждого шага этого руководства добавлены соответствующие тэги.</blockquote>

<h4><b>Проблема с timestamp</b></h4><p>
Одна особенность нашего приложения, которую мы игнорировали длительное время, это отображение даты и времени. 
</p><p>
До настоящего момента, мы доверяли python отображать метки времени, хранящиеся в наших объектах User и Post по собственному усмотрению, что на самом деле не является хорошим решением. 
</p><p>
Рассмотрим следующий пример. Я пишу это в 15:54, 31 декабря 2012 года. Мой часовой пояс PST (или UTC -8 если Вам так больше нравится). Запустив интерпретатор python, я получаю следующие результаты: 

</p><pre><code class="bash">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; now = datetime.now()
&gt;&gt;&gt; print now
2012-12-31 15:54:42.915204
&gt;&gt;&gt; now = datetime.utcnow()
&gt;&gt;&gt; print now
2012-12-31 23:55:13.635874
</code></pre><p>
Вызов now() возвращает правильное время для моего часового пояса, в то время как utcnow() отображает время по Гринвичу.

</p><h5><b>Так какую функцию лучше использовать?</b></h5><p>
Если мы решим использовать now(), тогда все временные метки, которые мы планируем сохранять в нашу базу данных, будут зависеть от местоположения нашего сервера и это может породить некоторые проблемы.
</p><p>
Однажды может возникнуть необходимость перенести сервер в другой часовой пояс. И в этом случае все хранящиеся в базе данных временные метки нужно будет исправить в соответствии с новым локальным временем перед запуском сервера.
</p><p>
Но существует и более серьезная проблема, связанная с этим подходом. Для пользователей из разных часовых поясов будет сложно определить, когда именно был опубликован пост, если они будут видеть его в часовом поясе PST. Чтобы определиться, пользователи должны знать также что время указано относительно PST.
</p><p>
Очевидно, что это не самый оптимальный вариант, и именно поэтому когда мы создавали нашу базу данных, было принято решение хранить метки времени по Гринвичу.
</p><p>
Однако, приведя временные метки к некоторому стандарту, мы решили только первую проблему (с переносом сервера в другой часовой пояс), в то время как второй вопрос остался без решения — временные метки будут отображаться абсолютно всем пользователям по Гринвичу. 
</p><p>
Это по-прежнему может запутать пользователей. Представьте себе пользователя из часового пояса PST, который разместил запись в блоге около 15:00. Запись тут же появилась на главной странице, но в ней указано время создания 23:00.
</p><p>
Таким образом, цель сегодняшней статьи — прояснить вопросы отображения даты и времени, чтобы не запутывать наших пользователей.

</p><h4><b>Временные метки пользователя</b></h4><p>
Очевидным решением проблемы является индивидуальное преобразование времени по Гринвичу в локальное время для каждого пользователя. Это позволит нам продолжить использовать время по Гринвичу в нашей базе данных, а преобразованное на лету время для каждого пользователя, сделает время консистентным для всех. 
</p><p>
Но как мы узнаем местоположение наших пользователей?
</p><p>
На многих сайтах есть страница настроек, где пользователь может указать свой часовой пояс. Для этого потребуется добавить новую страницу с формой, содержащей выпадающий список существующих часовых поясов. Частью регистрации станет ответ на вопрос о часовом поясе пользователя.</p><p>
Несмотря на то, что данное решение является вполне работоспособным и решает поставленную задачу, оно представляется несколько избыточным — просить пользователя вводить информацию, которая уже однажды настроена и хранится у них в ОС. Кажется, было бы гораздо эффективнее, просто получить настройки часового пояса с компьютера пользователя. 
</p><p>
Однако, из соображений безопасности, браузеры не позволят нам получить доступ к системе пользователя, а следовательно, и получить необходимую информацию. Даже если бы это было технически возможно, нам бы нужно было знать где именно искать текущие установки для часовых поясов на Windows, Linux, Mac, iOS, и Android(и это не считая менее распространенные ОС).
</p><p>
Оказывается, браузер знает часовой пояс пользователя и делает его доступным через стандартный javascript интерфейс. В современном Web 2.0 мире вполне можно рассчитывать на включенный в браузере javascript (на практике, ни один современный сайт не будет работать корректно с отключенным javascript), так что это решение достойно рассмотрения.
</p><p>
У нас есть два варианта использования информации о часовом поясе, предоставляемой javascript:
</p><ol>
<li>Традиционный (oldschool) подход — попросить браузер отправить нам информацию о часовом поясе пользователя, когда пользователь впервые заходит к нам на сайт. Это может быть реализовано при помощи Ajax или, что гораздо проще, при помощи тэга meta refresh. Как только сервер узнает часовой пояс он может сохранить эту информацию в сессии пользователя и откорректировать все временные метки в шаблоне во время его отрисовки.</li>
<li>Современный (new-school) подход состоит в том, чтобы не привлекать к этому процессу сервер и позволить ему отправлять временные метки браузеру пользователя по Гринвичу. А преобразование времени в соответствии с часовым поясом пользователя будет происходить на клиенте при помощи javascript.</li>
</ol>
<p>
Оба варианта корректны, но у второго есть преимущество. У браузера есть больше возможностей в правильной отрисовке даты в соответствии с настройками системной локали пользователя. Такие подробности, как AM/PM(12-часовой) или 24-часовой формат времени используется, ДД/MM/ГГ или MM/ДД/ГГ формат даты предпочтителен и многие другие доступны браузеру и неизвестны серверу. 
</p><p>
И если этих доводов в пользу второго варианта недостаточно, то есть еще одно преимущество этого подхода. Оказывается, вся работа уже сделана за нас!

</p><h4><b>Знакомьтесь, moment.js</b></h4>
<a href="http://momentjs.com/">Moment.js</a><p> это компактная javascript библиотека с открытым исходным кодом, которая переводит отрисовку даты и времени на новый уровень. Она предоставляет всевозможные опции форматирования, и еще кое-что.
</p><p>
Для использования moment.js в нашем приложении, нам придется добавить совсем немного javascript в наши шаблоны. Начнем мы с создания объекта  moment из времени в формате ISO 8601. К примеру, используя время по Гринвичу из примера выше, мы создадим объект moment вот так:

</p><pre><code class="javascript">moment("2012-12-31T23:55:13 Z")
</code></pre><p>
Как только объект создан, он может быть преобразован в строку с огромным разнообразием форматов. Например, довольно многословное отображение в соответствии с системными настройками локали, может выглядеть так:

</p><pre><code class="javascript">moment("2012-12-31T23:55:13 Z").format('LLLL');
</code></pre><p>
А вот как система отобразит эту дату:

</p><pre><code class="bash">Tuesday, January 1 2013 1:55 AM
</code></pre><p>
Вот еще несколько примеров той же метки времени отображенной в различных форматах:
</p><table>
<tr>
<th>Формат</th>
<th>Результат</th>
</tr>
<tr>
<td>L</td>
<td>01/01/2013</td>
</tr>
<tr>
<td>LL</td>
<td>January 1 2013</td>
</tr>
<tr>
<td>LLL</td>
<td>January 1 2013 1:55 AM</td>
</tr>
<tr>
<td>LLLL</td>
<td>Tuesday, January 1 2013 1:55 AM</td>
</tr>
<tr>
<td>dddd</td>
<td>Tuesday</td>
</tr>
</table><p>
Поддержка библиотекой различных опций на этом не заканчивается. В дополнение к format() библиотека предлагает  fromNow() и calendar(), с гораздо более дружественным отображением временных меток:

</p><table>
<tr>
<th>Формат</th>
<th>Результат</th>
</tr>
<tr>
<td>fromNow()</td>
<td>2 years ago</td>
</tr>
<tr>
<td>calendar()</td>
<td>01/01/2013</td>
</tr>
</table><p>
Заметьте, что во всех представленных примерах, сервер отдает одно и то же время по Гринвичу, а необходимые преобразования производятся уже браузером пользователя.
</p><p>
И последняя часть магии javascript, которую мы пропустили, это сделать строку возвращенную методом объекта moment видимой на странице. Самый простой способ добиться этого — использовать фунцию javascript document.write , как показано ниже:

</p><pre><code class="javascript">document.write(moment("2012-12-31T23:55:13 Z").format('LLLL'));
</code></pre><p>
И хотя использование document.write очень просто и понятно, как способ генерации фрагмента HTML документа при помощи javascript, следует помнить, что эта реализация имеет некоторые ограничения. Наиболее значительное из них состоит в том, что document.write может использоваться только во время загрузки документа и не может использоваться для изменения документа, после окончания его загрузки. И, как следствие этого ограничения, данное решение не будет работать при загрузке данных через Ajax.

</p><h4><b>Интеграция moment.js</b></h4><p>
Есть несколько вещей, которые нам нужно сделать, чтобы использовать  moment.js в нашем приложении.
</p><p>
Первое, нужно поместить скачанную библиотеку moment.min.js в папку /app/static/js, так, что она будет отдаваться клиентам как статика(статичный файл).
</p><p>
Затем, следует добавить эту библиотеку в наш базовый шаблон (файлapp/templates/base.html):
</p><pre><code class="html">&lt;script src="/static/js/moment.min.js"&gt;&lt;/script&gt;
</code></pre><p>
Теперь мы можем добавить тэги &lt;script&gt; в шаблоны, которые отображают временные метки и дело будет сделано. Но вместо этого, мы создадим обертку для  moment.js , которую мы сможем использовать в шаблонах. Это сохранит нам время в будущем, если мы решим изменить код отображения временных меток, потому что достаточно будет изменить всего один файл.
</p><p>
Наша обертка будет представлять собой очень простой python класс (файл app/momentjs.py):

</p><pre><code class="python">from jinja2 import Markup

class momentjs(object):
    def __init__(self, timestamp):
        self.timestamp = timestamp

    def render(self, format):
        return Markup("&lt;script&gt;\ndocument.write(moment(\"%s\").%s);\n&lt;/script&gt;" % (self.timestamp.strftime("%Y-%m-%dT%H:%M:%S Z"), format))

    def format(self, fmt):
        return self.render("format(\"%s\")" % fmt)

    def calendar(self):
        return self.render("calendar()")

    def fromNow(self):
        return self.render("fromNow()")
</code></pre>
<p>
Обратите внимание, что метод  render не возвращает непосредственно строку, вместо этого он экземпляр класса Markup, предоставляемого Jinja2, нашим шаблонизатором. Смысл в том, что Jinja2 по умолчанию экранирует все строки, так, &lt;script&gt; может попасть к клиенту в таком виде &amp; lt;script&amp; gt;. Вернув вместо строки экземпляр объекта Markup, мы сообщили Jinja2 что эту строку экранировать не нужно.
</p><p>
Теперь, когда у нас есть обертка, мы должны добавить её в Jinja2 чтобы можно было использовать её в наших шаблонах(файл app/__init__.py):

</p><pre><code class="python">from momentjs import momentjs
app.jinja_env.globals['momentjs'] = momentjs
</code></pre><p>
Этим мы позволили Jinja2 предоставлять наш класс как глобальную переменную во всех шаблонах.
</p><p>
Теперь мы готовы внести изменения в наши шаблоны. Есть два места в нашем приложении, где мы отображаем дату и время. Первое — страница профиля пользователя, где мы показывает время последнего посещения. Для отображения на этой странице мы применим форматирование calendar()  (файл app/templates/user.html):

</p><pre><code class="html">{% if user.last_seen %}
&lt;p&gt;&lt;em&gt;Last seen: {{momentjs(user.last_seen).calendar()}}&lt;/em&gt;&lt;/p&gt;
{% endif %}
</code></pre><p>
Второе место — шаблон поста, который используется на страницах index, user и search. В шаблоне поста мы применим форматирование fromNow(), т. к. точное время создания поста не так важно, как время прошедшее после создания поста. Т.к. мы выделили отрисовку поста в отдельный шаблон, теперь мы должны внести изменения только в одном месте, чтобы изменить все страницы отображающие посты (файл app/templates/post.html):

</p><pre><code class="html">&lt;p&gt;&lt;a href="{{url_for('user', nickname = post.author.nickname)}}"&gt;{{post.author.nickname}}&lt;/a&gt; said {{momentjs(post.timestamp).fromNow()}}:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;{{post.body}}&lt;/strong&gt;&lt;/p&gt;
</code></pre><p>
И при помощи этого простого изменения, мы решили все наши проблемы с временными метками. И, при этом, не понадобилось никаких изменений серверного кода!

</p><h4><b>Заключение</b></h4><p>
Даже не заметив, сегодня мы сделали значительный шаг в сторону увеличения доступности нашего приложения для пользователей из всех уголков Сети, путем изменения отображения даты в соответствии с настройками локали пользователя.
</p><p>
В следующей статье этой серии, мы постараемся порадовать наших иностранных пользователей еще больше, т. к. мы включим поддержку нескольких языков. 
</p><p>
Скачать: </p><a href="https://github.com/miguelgrinberg/microblog/archive/v0.13.zip">microblog-0.13.zip.</a><p>
Или, если Вам так больше нравится, вы можете найти исходный код на </p><a href="https://github.com/miguelgrinberg/microblog/tree/v0.13">GitHub</a><p>.
</p><p>
Miguel
      </p><p class="clear"/>
    </div>

    
  </div></body></html>