<html><body><div><div class="contx entry-content clearfix">
			<p>In the last post, we have discussed abstraction and set the foundations for understanding the Pythonic OO model. In this post, you will learn about inheritance and polymorphism in Python.</p>
<h1>Inheritance</h1>
<p>Since python supports OOP, it has an inheritance model. Now, we have said that Python doesn’t exactly have interfaces, with the exception of abstract classes as explained in the previous post. We also explained the Python does not support interfaces, because we got duck typing in Python and thus we don’t really care about grouping unrelated types together.</p>
<p>However, not supporting interfaces comes with a cost, and that cost is the OO model. The pythonic OO model is a multiple inheritance model. Yep, just as you’ve heard. MULTIPLE INHERITANCE. If you were a good boy in the C# lessons, you have probably learned about the diamond diagram problem regarding multiple inheritance. I will admit, multiple inheritance has its downsides, however it seems like Guido, the BDFL, and his folk at the PSF (Python Software Foundation) have done a good job over the years to counter this problem, using something called MRO, you may have heard of it from your experience with other languages, or at the university – method resolution order.</p>
<p>Python’s MRO is a smart depth-first algorithm that travels the inheritance graph and collects all the base classes in the tree, depending on which class’ MRO is inspected.</p>
<p>Consider the following diagram:</p>
<p><a href="http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/inheritance3.jpg"><img class="alignleft size-full wp-image-218" alt="inheritance" src="http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/inheritance3.jpg" srcset="http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/inheritance3-212x300.jpg 212w, http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/inheritance3-724x1024.jpg 724w, http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/inheritance3-624x882.jpg 624w, http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/inheritance3.jpg 794w" sizes="(max-width: 794px) 100vw, 794px"/></a></p>
<p>Do you see the problem here? What happens if I define two methods with the same name on both the parent, and the right child (Child2)? Which method is called?</p>
<h2>Old Style Classes</h2>
<p>The answer to the question above, is actually not trivial. See, before the <a href="https://wiki.python.org/moin/NewClassVsClassicClass">new style classes</a> were introduced at Python 2.3, the classes used a very dumb and primitive MRO algorithm, it was depth first, until it hits something that matches the description. But the problem here was that it went to the left parent’s sub-graph and traversed it completely before going to the right’s parent’s sub-graph.</p>
<p>Or as you can see in the following image:</p>
<p><a href="http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/old-inheritance2.jpg"><img class="alignleft size-full wp-image-219" alt="old-inheritance" src="http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/old-inheritance2.jpg" srcset="http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/old-inheritance2-212x300.jpg 212w, http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/old-inheritance2-724x1024.jpg 724w, http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/old-inheritance2-624x882.jpg 624w, http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/old-inheritance2.jpg 794w" sizes="(max-width: 794px) 100vw, 794px"/></a></p>
<p>As you can see in the <a href="https://wiki.python.org/moin/NewClassVsClassicClass">old style classes</a>, in this scenario, the topmost Parent’s method will be called. The reason? As explained, the old, dumb algorithm goes left first, finds the first occurrence of the method and returns it.</p>
<h2>New Style Classes</h2>
<p>The new style classes on the other hand, have a better algorithm for solving this issue, it first calculates the MRO itself upon class object creation (that is, when the class’ metaclass <strong>__new__</strong> is called), and then it looks for the method in that exact order. Also, new style classes have <strong>__mro__</strong> special member that shows the class’ MRO, which is actually just a Python tuple.</p>
<p>The MRO in our case will be the following:</p>
<p>(&lt;class ‘__main__.GrandChild’&gt;, &lt;class ‘__main__.Child’&gt;, &lt;class ‘__main__.Child2’&gt;, &lt;class ‘__main__.Parent’&gt;, &lt;type ‘object’&gt;)</p>
<p>In this case, which method will be called? The Parent’s or Child2’s? The answer lies in the output of the __mro__ above, Child2’s method will be called.</p>
<p><a href="http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/new-inheritance.jpg"><img class="alignleft size-full wp-image-220" alt="new-inheritance" src="http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/new-inheritance.jpg" srcset="http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/new-inheritance-212x300.jpg 212w, http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/new-inheritance-724x1024.jpg 724w, http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/new-inheritance-624x882.jpg 624w, http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2014/07/new-inheritance.jpg 794w" sizes="(max-width: 794px) 100vw, 794px"/><br/>
</a></p>
<p>That concludes the hard part in multiple inheritance.</p>
<p>The fun part on the other hand, is that you can achieve tons of code reuse thanks to multiple inheritance. In C#, you would need an interface in order to create mixins. In Python, all you need, is just to add another superclass.</p>
<p>Multiple inheritance in Python has its pitfalls tho, we will get to a really major one when we start talking about metaprogramming, specifically when we meet metaclasses, but for now, the two most annoying pitfalls with multiple inheritance are:</p>
<ol>
<li>Trying, and failing to override another superclass’s method using another superclass, this happens if for instance, you have two superclasses that define the same method and a subclass that inherits from both, the superclass that comes first in the MRO will have its method called, the other will be ignored completely.</li>
<li>When multiple inheritance get more and more complicated, they may also become extremely nasty, to the point they will crash your program. In example, consider the following script:</li>
</ol>
<p><span> </span></p>
<pre class="brush: python; gutter: true; first-line: 1">class Parent(object):
	pass

class Child(Parent):
	pass

class Child2(Parent):
	pass

class GrandChild(Child, Child2):
	pass

class GrandChild2(Child2, Child):
	pass

class GreatGrandChild(GrandChild, GrandChild2):
	pass</pre>
<p>If you actually run the script above,  it will crash. The reason is that, for some reason (Which I admit, the Python’s C source code is kinda confusing, so I couldn’t really figure out exactly why, I will get back to you with another post once I dive deeper into the source code), the MRO algorithm for the new style classes can’t handle a situation where a great grandchild inherits from two grandchildren which have their parents in the different order. As you can see, GrandChild inherits from Child and Child2, while GrandChild2 inherits from Child2 and Child. Running this code will result in a nasty TypeError.</p>
<p><a href="http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2015/01/Selection_006.png"><img class="alignleft size-full wp-image-232" alt="Selection_006" src="http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2015/01/Selection_006.png" srcset="http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2015/01/Selection_006-300x68.png 300w, http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2015/01/Selection_006.png 444w" sizes="(max-width: 444px) 100vw, 444px"/></a></p>
<p>This may seem like nonsense, but it actually matters, make sure this doesn’t happen once you wander into the land of multiple inheritance.</p>
<p>Now that we are done with multiple inheritance, let’s talk about Polymorphism.</p>
<h2>Polymorphism</h2>
<p><img alt="Can you quack like a duck?" src="http://sd.keepcalm-o-matic.co.uk/i/keep-calm-and-quack-like-a-duck-8.png"/></p>
<p>Can you quack like a duck? Cause that’s what Python’s Polymorphism is all about. Duck typing. In traditional Polymorphism, like you’d expect to see in C#, the way you look at an object (As the object itself, or as its ancestor) defines who’s method will be called.</p>
<p>In python on the other hand, there are no two ways to look at an object, you get an object, and that’s it. It may or may not have the method you are looking for based on whether it is defined in the object’s class definition or in one of its ancestors.<br/>
Lucky for us, Python doesn’t actually care whether your object is of type “Mouse” or “Cat” or “Mammal”. Python simply looks for the method you ask for, if it can’t find any in the object or any of its ancestors, it will raise an <strong>AttributeError</strong> and complain it can’t find the method you are looking for, that’s the essence of Duck Typing and Python’s Polymorphism.</p>
<p>This post, along with the previous ones, pretty much sum up the chapter and everything you need to know in order to start developing an ordinary piece of software. The next series will deal with introducing some Python libraries and very often used objects like files, streams, making HTTP requests, logging, debugging and more.</p>
<p><strong>EDIT</strong>: It was rude to simply ignore the… following mechanism which is well.. I’d say its ugly as hell, but it nonetheless gives you full polymorphic capabilities.</p>
<p>Python actually fully supports your good ol’ classic polymorphism, there are two ways to achieve this, it seems as if they do the same, but actually they behave differently and one has a critical flaw, while the other is a bit code polluting, it is your choice which you choose to accomplish the required task.</p>
<p>First, the ugly:</p>
<pre class="brush: python; gutter: true; first-line: 1">import random

class Integer(object):
    def __init__(self, value):
        self.value = value

    def __add__(self, other):
        return Integer(self.value + int(other))

    def __iadd__(self, other):
        self.value = self.value + int(other)
        return self

    def __str__(self):
        return str(self.value)

    def __repr__(self):
        return str(self.value)

class DoubleAddingInteger(Integer):
    def __init__(self, value):
        Integer.__init__(self, value)

    def __add__(self, other):
        return DoubleAddingInteger(self.value + other * 2)

    def __iadd__(self, other):
        self.value += other * 2
        return self

class QuadrupleAddingInteger(DoubleAddingInteger):
    def __init__(self, value):
        DoubleAddingInteger.__init__(self, value)

    def __add__(self, other):
        return DoubleAddingInteger.__add__(self, other) * 2

    def __iadd__(self, other):
        DoubleAddingInteger.__iadd__(self, other) * 2
        self.value += self.value * 2
        return self

class RandomInteger(Integer):
    def __init__(self, value):
        Integer.__init__(self, value)

    def __add__(self, other):
        return RandomInteger(self.value + other * random.randint(1, 4))

    def __iadd__(self, other):
        self.value += other * random.randint(1, 4)
        return self

if __name__ == '__main__':
    print "NORMAL"
    normal_int = Integer(4)
    print normal_int
    print normal_int + 3
    print normal_int
    normal_int += 4
    print normal_int
    print
    print "DOUBLE ADDING"
    double_int = DoubleAddingInteger(3)
    print double_int
    print double_int + 6
    print double_int
    double_int += 2
    print double_int

    print "WACKY!!"
    random_int = RandomInteger(1)
    print random_int
    print random_int + 2
    print random_int
    random_int += 3
    print random_int

    print "Weird stuff starts here"
    random_2 = RandomInteger(2)
    print Integer.__add__(random_2, 3)
    quad = QuadrupleAddingInteger(3)
    print DoubleAddingInteger.__add__(quad, 5)
    Integer.__iadd__(quad, 2)
    print quad
    double_int_2 = DoubleAddingInteger(3)
    QuadrupleAddingInteger.__add__(double_int_2, 3)</pre>
<p>In the example above, we have 4 types of “Integer”, yeah, how lame eh? Well at any rate.</p>
<p>This is what we call the “BaseClass.method” way, it basically means, name the base class of a certain class, call a method that exists on it and it will perform that method of the specified base class with the supplied context that can be an instance of the base class or of any derived subclass.</p>
<p>If you run the code as it is, you will see funny stuff going on and it will eventually crash.<br/>
The first part up to the weird stuff is all fine, but take a look at that piece of code from the weird stuff and on.</p>
<p>You can explicitly call methods on parents and pass in child instances, as you can see with QuadrupleAddingInteger (and actually with RandomInteger as well), the method that will be called is of course, the method of the specified parent.</p>
<p>Just to remind you the most important rule of inheritance and polymorphism, you can treat a child as one of its ancestors, the reverse isn’t possible, the same applies in Python. The last line will explode with spectacular error!</p>
<p><a href="http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2015/01/Selection_012.png"><img alt="Selection_012" src="http://blogs.microsoft.co.il/terfin3/wp-content/uploads/sites/1683/2015/01/Selection_012.png"/></a></p>
<p><span>Now take a look at the same code, in the SUPER way, it is more elegant, but has a fatal flaw.</span></p>
<pre class="brush: python; gutter: true; first-line: 1">import random

class Integer(object):
    def __init__(self, value):
        self.value = value

    def __add__(self, other):
        return Integer(self.value + int(other))

    def __iadd__(self, other):
        self.value = self.value + int(other)
        return self

    def __str__(self):
        return str(self.value)

    def __repr__(self):
        return str(self.value)

class DoubleAddingInteger(Integer):
    def __init__(self, value):
        super(DoubleAddingInteger, self).__init__(value)

    def __add__(self, other):
        return DoubleAddingInteger(self.value + other * 2)

    def __iadd__(self, other):
        self.value += other * 2
        return self

class QuadrupleAddingInteger(DoubleAddingInteger):
    def __init__(self, value):
        super(QuadrupleAddingInteger, self).__init__(value)

    def __add__(self, other):
        return super(QuadrupleAddingInteger, self).__add__(other) * 2

    def __iadd__(self, other):
        super(QuadrupleAddingInteger, self).__iadd__(self, other) * 2
        self.value += self.value * 2
        return self

class RandomInteger(Integer):
    def __init__(self, value):
        super(RandomInteger, self).__init__(value)

    def __add__(self, other):
        return RandomInteger(self.value + other * random.randint(1, 4))

    def __iadd__(self, other):
        self.value += other * random.randint(1, 4)
        return self

if __name__ == '__main__':
    print "NORMAL"
    normal_int = Integer(4)
    print normal_int
    print normal_int + 3
    print normal_int
    normal_int += 4
    print normal_int
    print
    print "DOUBLE ADDING"
    double_int = DoubleAddingInteger(3)
    print double_int
    print double_int + 6
    print double_int
    double_int += 2
    print double_int

    print "WACKY!!"
    random_int = RandomInteger(1)
    print random_int
    print random_int + 2
    print random_int
    random_int += 3
    print random_int

    print "Weird stuff starts here"
    random_2 = RandomInteger(2)
    print super(RandomInteger, random_2).__add__(3)
    quad = QuadrupleAddingInteger(3)
    print super(QuadrupleAddingInteger, quad).__add__(5)
    super(DoubleAddingInteger, quad).__iadd__(2)
    print quad
    double_int_2 = DoubleAddingInteger(3)
    QuadrupleAddingInteger.__add__(double_int_2, 3)</pre>
<p>Well, the result is the same, but something completely different happens here, and it has a fatal flaw and other flaws, can you guess it?</p>
<p>Maybe this example will help (and it is Python3 friendly!):</p>
<pre class="brush: python; gutter: true; first-line: 1">class Parent(object):
    name = 'Bob'

    def do_something(self):
        print('My name is {}'.format(self.name))

class Child(Parent):
    name = 'Steve'

    def do_something(self):
        print("Ahoy, Matey! I am {} the code pirate!".format(self.name))

class OtherChild(Parent):
    name = 'Murphey'

    def do_something(self):
        print("My name is {} and I am here to impose terrible luck upon thou".format(self.name)) # I am reading the last book of The Malloreon at the moment. Arends are pretty entertaining

class OtherOtherChild(Parent):
    name = 'Gogo'

    def do_something(self):
        print("My name is {}, the malicious creature of the night".format(self.name))

class GrandChild(Child, OtherChild, OtherOtherChild):
    name = 'Joe'

    def do_something(self):
        print("Grab a cup of {}".format(self.name))

if __name__ == '__main__':
    c = Child()
    c.do_something()
    gc = GrandChild()
    gc.do_something()
    super(Child, gc).do_something()
    super(OtherChild, gc).do_something()</pre>
<p>Can you guess the output of the script above?</p>
<p>Here is what may has come up your mind:</p>
<pre>Ahoy, Matey! I am Steve the code pirate!
Grab a cup of Joe
My name is Joe
My name is Joe</pre>
<p><strong>This is not the actual output!</strong></p>
<p>Here is the correct output:</p>
<pre>Ahoy, Matey! I am Steve the code pirate!
Grab a cup of Joe
My name is Joe and I am here to impose terrible luck upon thou
My name is Joe, the malicious creature of the night</pre>
<p>Does this make any sense? no? Well neither to me when I found it out.<br/>
Apparently Python multiple inheritance is a bit wacko. If you recall, every class has its MRO, it defines the order of which methods are called when you traverse the inheritance tree.<br/>
the <strong>super </strong>function does something very unexpected, what one would expect is that super would give result with invoking a function on a subclass’ parent, but this is not true.<br/>
What <strong>super</strong> actually does is this, when calling super with Parent class and child instance:</p>
<p>So when using the single inheritance model, you will always get the parent of the class supplied as an argument to the <strong>super</strong> function, because it will appear on the subclass MRO after the class supplied.</p>
<p>When using the multiple inheritance model, a class may inherit from more than one parent and thus it will have more classes in its MRO before the grandparent class.</p>
<p>What actually happens in the script then, is this:</p>
<pre>    super(Child, gc).do_something()</pre>
<ol>
<li>Get GrandChild’s MRO</li>
<li>Locate Child in GrandChild’s MRO</li>
<li>Pick the next class after Child in GrandChild’s MRO</li>
<li>Call OtherChild.do_something</li>
</ol>
<pre>    super(OtherChild, gc).do_something()</pre>
<ol>
<li>Get GrandChild’s MRO</li>
<li>Locate OtherChild in GrandChild’s MRO</li>
<li>Pick the next class after Child in GrandChild’s MRO</li>
<li>Call OtherOtherChild.do_something</li>
</ol>
<p>This is BAD BAD BAD. It creates a lot of confusion and it not straightforward at all. The only good thing I can say about super is that its syntax is somewhat less hacky than baseclass.method. In Python3 it is a bit more attractive, as you can actually call super() (without arguments) inside a certain class’ scope and it will get you the next class on the MRO.</p>
<h3><strong/>Super VS baseclass.method</h3>
<p>To summarize super and baseclass –</p>
<p><strong>baseclass.method</strong></p>
<ol>
<li>More explicit</li>
<li>Syntax is kinda ugly.</li>
<li>No “surprises” in multiple inheritance.</li>
</ol>
<p><strong>super</strong></p>
<ol>
<li>More implicit</li>
<li>Better syntax, especially in Python 3.</li>
<li>Can be confusing with multiple inheritance.</li>
</ol>
<p>My rule of thumb, use <strong>super</strong> when using single inheritance, it is more elegant, use <strong>baseclass.method</strong> when using multiple inheritance.<br/>
If you think this is nonsense, consider the possibility of a junior programmer joining your team, someone who has not yet dived into Python deep enough to experience super’s problems. Using super will send that new programmer into wasting at least 3 hours on each class that has multiple inheritance, trying to figure out why super doesn’t work as he thinks it should. In that case, I would gladly litter my code with explicit <strong>baseclass.method</strong> calls.</p>
<p>I believe that this really does wrap up things regarding Python’s inheritance and polymorphism.</p>
			

							  

				
		</div>
		

        
</div></body></html>