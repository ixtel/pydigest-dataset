<html><body><div><div id="command-line">

<p><strong>Usage:</strong> <cite>executor [OPTIONS] COMMAND …</cite></p>
<p>Easy subprocess management on the command line based on the Python package with the same name. The “executor” program runs external commands with support for timeouts, dynamic startup delay (fudge factor) and exclusive locking.</p>
<p>You can think of “executor” as a combination of the “flock” and “timelimit” programs with some additional niceties (namely the dynamic startup delay and integrated system logging on UNIX platforms).</p>
<p><strong>Supported options:</strong></p>
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr><th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr><td><tt><span class="pre">-t</span></tt>, <tt><span class="pre">--timeout=LIMIT</span></tt></td>
<td>Set the time after which the given command will be aborted. By default
<tt>LIMIT</tt> is counted in seconds. You can also use one of the suffixes “s”
(seconds), “m” (minutes), “h” (hours) or “d” (days).</td>
</tr>
<tr><td><tt><span class="pre">-f</span></tt>, <tt><span class="pre">--fudge-factor=LIMIT</span></tt></td>
<td>This option controls the dynamic startup delay (fudge factor) which is
useful when you want a periodic task to run once per given interval but the
exact time is not important. Refer to the <tt><span class="pre">--timeout</span></tt> option for acceptable
values of <tt>LIMIT</tt>, this number specifies the maximum amount of time to sleep
before running the command (the minimum is zero, otherwise you could just
include the command “sleep N &amp;&amp; …” in your command line :-).</td>
</tr>
<tr><td><tt><span class="pre">-e</span></tt>, <tt><span class="pre">--exclusive</span></tt></td>
<td>Use an interprocess lock file to guarantee that executor will never run
the external command concurrently. Refer to the <tt><span class="pre">--lock-timeout</span></tt> option
to customize blocking / non-blocking behavior. To customize the name
of the lock file you can use the <tt><span class="pre">--lock-file</span></tt> option.</td>
</tr>
<tr><td><tt><span class="pre">-T</span></tt>, <tt><span class="pre">--lock-timeout=LIMIT</span></tt></td>
<td>By default executor tries to claim the lock and if it fails it will exit
with a nonzero exit code. This option can be used to enable blocking
behavior. Refer to the <tt><span class="pre">--timeout</span></tt> option for acceptable values of <tt>LIMIT</tt>.</td>
</tr>
<tr><td><tt><span class="pre">-l</span></tt>, <tt><span class="pre">--lock-file=NAME</span></tt></td>
<td>Customize the name of the lock file. By default this is the base name of
the external command, so if you’re running something generic like “bash”
or “python” you might want to change this :-).</td>
</tr>
<tr><td><tt><span class="pre">-v</span></tt>, <tt><span class="pre">--verbose</span></tt></td>
<td>Make more noise than usual (increase logging verbosity).</td>
</tr>
<tr><td><tt><span class="pre">-q</span></tt>, <tt><span class="pre">--quiet</span></tt></td>
<td>Make less noise than usual (decrease logging verbosity).</td>
</tr>
<tr><td><tt><span class="pre">-h</span></tt>, <tt><span class="pre">--help</span></tt></td>
<td>Show this message and exit.</td>
</tr>
</tbody>
</table>
</div>
<div id="python-api">

<p>Below are some examples of how versatile the <a href="http://executor.readthedocs.org/en/latest/#executor.execute" rel="nofollow">execute()</a> function is. Refer to
the API documentation on <a href="https://executor.readthedocs.org/en/latest/#api-documentation" rel="nofollow">Read the Docs</a> for (a lot of) other use cases.</p>

<div id="checking-status-codes">

<p>By default the status code of the external command is returned as a boolean:</p>
<pre>&gt;&gt;&gt; from executor import execute
&gt;&gt;&gt; execute('true')
True
</pre>
<p>If an external command exits with a nonzero status code an exception is raised,
this makes it easy to do the right thing (never forget to check the status code
of an external command without having to write a lot of repetitive code):</p>
<pre>&gt;&gt;&gt; execute('false')
Traceback (most recent call last):
  File "executor/__init__.py", line 124, in execute
    cmd.start()
  File "executor/__init__.py", line 516, in start
    self.wait()
  File "executor/__init__.py", line 541, in wait
    self.check_errors()
  File "executor/__init__.py", line 568, in check_errors
    raise ExternalCommandFailed(self)
executor.ExternalCommandFailed: External command failed with exit code 1! (command: bash -c false)
</pre>
<p>The <a href="http://executor.readthedocs.org/en/latest/#executor.ExternalCommandFailed" rel="nofollow">ExternalCommandFailed</a> exception exposes <tt>command</tt> and <tt>returncode</tt>
attributes. If you know a command is likely to exit with a nonzero status code
and you want <a href="http://executor.readthedocs.org/en/latest/#executor.execute" rel="nofollow">execute()</a> to simply return a boolean you can do this instead:</p>
<pre>&gt;&gt;&gt; execute('false', check=False)
False
</pre>
</div>
<div id="providing-input">

<p>Here’s how you can provide input to an external command:</p>
<pre>&gt;&gt;&gt; execute('tr a-z A-Z', input='Hello world from Python!\n')
HELLO WORLD FROM PYTHON!
True
</pre>
</div>
<div id="getting-output">

<p>Getting the output of external commands is really easy as well:</p>
<pre>&gt;&gt;&gt; execute('hostname', capture=True)
'peter-macbook'
</pre>
</div>
<div id="running-commands-as-root">

<p>It’s also very easy to execute commands with super user privileges:</p>
<pre>&gt;&gt;&gt; execute('echo test &gt; /etc/hostname', sudo=True)
[sudo] password for peter: **********
True
&gt;&gt;&gt; execute('hostname', capture=True)
'test'
</pre>
</div>
<div id="enabling-logging">

<p>If you’re wondering how prefixing the above command with <tt>sudo</tt> would
end up being helpful, here’s how it works:</p>
<pre>&gt;&gt;&gt; import logging
&gt;&gt;&gt; logging.basicConfig()
&gt;&gt;&gt; logging.getLogger().setLevel(logging.DEBUG)
&gt;&gt;&gt; execute('echo peter-macbook &gt; /etc/hostname', sudo=True)
DEBUG:executor:Executing external command: sudo bash -c 'echo peter-macbook &gt; /etc/hostname'
</pre>
</div>
<div id="running-remote-commands">

<p>To run a command on a remote system using <a href="https://en.wikipedia.org/wiki/Secure_Shell" rel="nofollow">SSH</a> you can use the <a href="https://executor.readthedocs.org/en/latest/#executor.ssh.client.RemoteCommand" rel="nofollow">RemoteCommand</a>
class, it works as follows:</p>
<pre>&gt;&gt;&gt; from executor.ssh.client import RemoteCommand
&gt;&gt;&gt; cmd = RemoteCommand('localhost', 'echo $SSH_CONNECTION', capture=True)
&gt;&gt;&gt; cmd.start()
&gt;&gt;&gt; cmd.output
'127.0.0.1 57255 127.0.0.1 22'
</pre>
</div>
<div id="running-remote-commands-concurrently">

<p>The <a href="https://executor.readthedocs.org/en/latest/#executor.ssh.client.foreach" rel="nofollow">foreach()</a> function wraps the <a href="https://executor.readthedocs.org/en/latest/#executor.ssh.client.RemoteCommand" rel="nofollow">RemoteCommand</a> and <a href="https://executor.readthedocs.org/en/latest/#executor.concurrent.CommandPool" rel="nofollow">CommandPool</a> classes to
make it very easy to run a remote command concurrently on a group of hosts:</p>
<pre>&gt;&gt;&gt; from executor.ssh.client import foreach
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; hosts = ['127.0.0.1', '127.0.0.2', '127.0.0.3', '127.0.0.4']
&gt;&gt;&gt; commands = foreach(hosts, 'echo $SSH_CONNECTION')
&gt;&gt;&gt; pprint([cmd.output for cmd in commands])
['127.0.0.1 57278 127.0.0.1 22',
 '127.0.0.1 52385 127.0.0.2 22',
 '127.0.0.1 49228 127.0.0.3 22',
 '127.0.0.1 40628 127.0.0.4 22']
</pre>
</div>
</div>
</div></body></html>