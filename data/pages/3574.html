<html><body><div><article class="post-content">
    <p>Race conditions are a danger whenever you have more than one process or thread accessing the same data. This post explores how to test race conditions after identifying them.</p>

<h2 id="incrmnt">Incrmnt</h2>

<p>You’re working on a hot new startup, Incrmnt, which does one thing and does it well.</p>

<p>You display a global counter and a plus sign. Users can click the plus sign and the counter increases by one. It’s so simple! It’s so addictive! It’s the next big thing for sure!</p>

<p>Investors are tripping over themselves to get on board but you have a problem.</p>

<h2 id="the-race-condition">The race condition</h2>

<p>During your private beta, Abraham and Belinda were so super excited that they each clicked the plus button 100 times each. Your server logs show 200 requests, but the counter only shows 173. Something doesn’t add up.</p>

<p>Trying to push the headline “Incrmnt turns out to be Excrmnt” to the back of your mind, you inspect the code (all code used for this post can be found on <a href="https://github.com/c-oreills/c-oreills.github.io/blob/master/code/race_conditions">Github</a>).</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># incrmnt.py</span>
<span class="kn">import</span> <span class="nn">db</span>

<span class="k">def</span> <span class="nf">increment</span><span class="p">():</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">get_count</span><span class="p">()</span>

    <span class="n">new_count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">db</span><span class="o">.</span><span class="n">set_count</span><span class="p">(</span><span class="n">new_count</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_count</span></code></pre></div>

<p>Your web server uses multiple processes to increase throughput, so this function can be running simultaneously in two different threads. If you’re unlucky with the timing, this occurs:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Thread 1 and Thread 2 are executing in different processes at the same time</span>
<span class="c"># For purposes of illustration, they're placed side by side here</span>
<span class="c"># They're vertically spaced to show what code is executing at each point in time</span>

<span class="c"># Thread 1                          # Thread 2</span>
<span class="k">def</span> <span class="nf">increment</span><span class="p">():</span>
                                    <span class="k">def</span> <span class="nf">increment</span><span class="p">():</span>
    <span class="c"># get_count returns 0</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">get_count</span><span class="p">()</span>
                                        <span class="c"># get_count returns 0 again</span>
                                        <span class="n">count</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">get_count</span><span class="p">()</span>
    <span class="n">new_count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c"># set_count called with 1</span>
    <span class="n">db</span><span class="o">.</span><span class="n">set_count</span><span class="p">(</span><span class="n">new_count</span><span class="p">)</span>
                                        <span class="n">new_count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
                                        <span class="c"># set_count called with 1 again</span>
                                        <span class="n">db</span><span class="o">.</span><span class="n">set_count</span><span class="p">(</span><span class="n">new_count</span><span class="p">)</span></code></pre></div>

<p>So although count should have been incremented twice, it’s only gone up by 1.</p>

<p>You know you can fix this code to be thread safe, but before you do, you want to write a test to prove the race exists.</p>

<h2 id="reproducing-the-race">Reproducing the race</h2>

<p>Ideally our test should reproduce the scenario above as closely as possible. The key ingredient of the race is:</p>

<ul>
  <li>Both get_count calls must be executed before both set_count calls, so that count has the same value in both threads.</li>
</ul>

<p>It doesn’t matter when the set_count calls are made, as long as they are both after the get_count calls.</p>

<p>For simplicity, let’s try and reproduce this nested situation, where the entirety of Thread 2 is executed just after the first get_count call in Thread 1:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Thread 1                          # Thread 2</span>
<span class="k">def</span> <span class="nf">increment</span><span class="p">():</span>
    <span class="c"># get_count returns 0</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">get_count</span><span class="p">()</span>
                                    <span class="k">def</span> <span class="nf">increment</span><span class="p">():</span>
                                        <span class="c"># get_count returns 0 again</span>
                                        <span class="n">count</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">get_count</span><span class="p">()</span>

                                        <span class="c"># set_count called with 1</span>
                                        <span class="n">new_count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
                                        <span class="n">db</span><span class="o">.</span><span class="n">set_count</span><span class="p">(</span><span class="n">new_count</span><span class="p">)</span>
    <span class="c"># set_count called with 1 again</span>
    <span class="n">new_count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">db</span><span class="o">.</span><span class="n">set_count</span><span class="p">(</span><span class="n">new_count</span><span class="p">)</span></code></pre></div>

<p><a href="https://pypi.python.org/pypi/before_after/">before_after</a> is a library that provides utilities to help reproduce this situation. It can insert arbitrary code before or after a function.</p>

<p>before_after relies on the <a href="https://pypi.python.org/pypi/mock">mock</a> library to patch functions. If you’re not familiar with mock then I suggest reading the <a href="http://www.voidspace.org.uk/python/mock/">excellent docs</a>. Of particular importance is <a href="http://www.voidspace.org.uk/python/mock/patch.html#where-to-patch">Where To Patch</a>.</p>

<p>We want to wait until just after Thread 1 has called get_count, then execute Thread 2 in its entirety, then resume execution of Thread 1</p>

<p>We can write the following test:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># test_incrmnt.py</span>

<span class="kn">import</span> <span class="nn">unittest</span>

<span class="kn">import</span> <span class="nn">before_after</span>

<span class="kn">import</span> <span class="nn">db</span>
<span class="kn">import</span> <span class="nn">incrmnt</span>

<span class="k">class</span> <span class="nc">TestIncrmnt</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">db</span><span class="o">.</span><span class="n">reset_db</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_increment_race</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># after a call to get_count, call increment</span>
        <span class="k">with</span> <span class="n">before_after</span><span class="o">.</span><span class="n">after</span><span class="p">(</span><span class="s">'incrmnt.db.get_count'</span><span class="p">,</span> <span class="n">incrmnt</span><span class="o">.</span><span class="n">increment</span><span class="p">):</span>
            <span class="c"># start off the race with a call to increment</span>
            <span class="n">incrmnt</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>

        <span class="n">count</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">get_count</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></code></pre></div>

<p>We’ve used before_after’s <code>after</code> context manager to insert another call to <code>increment</code> after the first <code>get_count</code> call.</p>

<p>By default, before_after only calls the after function once. This is useful in this particular situation, since otherwise we’d blow the stack (<code>increment</code> would call <code>get_count</code> which would chain a call to <code>increment</code> which would call <code>get_count</code>…).</p>

<p>This test fails, since <code>count</code> is equal to 1, not 2. Now we have a red test that reproduces our race condition, so let’s work on fixing it.</p>

<h2 id="preventing-the-race">Preventing the race</h2>

<p>We’re going to mitigate the race using a simple lock. This is obviously not the ideal solution - we’d be better offloading the problem to our data store using atomic updates - but this approach allows better demonstration of before_after and its usefulness for testing multithreaded applications.</p>

<p>We add a new function to incrmnt.py:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># incrmnt.py</span>

<span class="k">def</span> <span class="nf">locking_increment</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">db</span><span class="o">.</span><span class="n">get_lock</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">increment</span><span class="p">()</span></code></pre></div>

<p>This ensures that only one thread can read from and write to the counter at once. If one thread tries to get the lock while it’s held by another, a CouldNotLock exception will be raised.</p>

<p>We can now add this test:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># test_incrmnt.py</span>

<span class="k">def</span> <span class="nf">test_locking_increment_race</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">erroring_locking_increment</span><span class="p">():</span>
        <span class="c"># Trying to get a lock when the other thread has it will cause a</span>
        <span class="c"># CouldNotLock exception - catch it here or the test will fail</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">CouldNotLock</span><span class="p">):</span>
            <span class="n">incrmnt</span><span class="o">.</span><span class="n">locking_increment</span><span class="p">()</span>

    <span class="k">with</span> <span class="n">before_after</span><span class="o">.</span><span class="n">after</span><span class="p">(</span><span class="s">'incrmnt.db.get_count'</span><span class="p">,</span> <span class="n">erroring_locking_increment</span><span class="p">):</span>
        <span class="n">incrmnt</span><span class="o">.</span><span class="n">locking_increment</span><span class="p">()</span>

    <span class="n">count</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">get_count</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></code></pre></div>

<p>Now only one thread can increment the counter at a time.</p>

<h2 id="mitigating-the-race">Mitigating the race</h2>

<p>We still have a problem here, in that if two requests collide in this way, one will not be registered. In order to mitigate this, we can retry the increment (using something like <a href="http://funcy.readthedocs.org/en/stable/flow.html#retry">funcy retry</a> is a concise way of doing so):</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># incrmnt.py</span>

<span class="k">def</span> <span class="nf">retrying_locking_increment</span><span class="p">():</span>
    <span class="nd">@retry</span><span class="p">(</span><span class="n">tries</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">db</span><span class="o">.</span><span class="n">CouldNotLock</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_increment</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">locking_increment</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">_increment</span><span class="p">()</span></code></pre></div>

<p>When we need more scale than this method provides, we can move the increment into our database as an atomic update or transaction, taking the responsibility away from our application.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Incrmnt is now race free, and people can happily click all day long without worrying about not being counted.</p>

<p>This was a simple example, but before_after can be used in more complicated races to ensure that your functions deal with the situation properly. Being able to test and reproduce in a single threaded environment is key to being more confident that you’re handling your races properly.</p>

  </article>

  </div></body></html>