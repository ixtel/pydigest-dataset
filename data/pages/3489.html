<html><body><div><div class="entry-content">
		<p>Tim Peters developed the <a href="http://en.wikipedia.org/wiki/Timsort">Timsort hybrid sorting algorithm</a> in 2002. It is a clever combination of ideas from merge sort and insertion sort, and designed to perform well on real world data. TimSort was first developed for Python, but later ported to Java (where it appears as java.util.Collections.sort and java.util.Arrays.sort) by <a href="http://en.wikipedia.org/wiki/Joshua_Bloch">Joshua Bloch</a> (the designer of Java Collections who also pointed out that <a href="http://googleresearch.blogspot.no/2006/06/extra-extra-read-all-about-it-nearly.html">most binary search algorithms were broken</a>). TimSort  is today used as the default sorting algorithm for Android SDK, Sun’s JDK and OpenJDK. Given the popularity of these platforms this means that the number of computers, cloud services and mobile phones that use TimSort for sorting is well into the billions.</p>
<p>Fast forward to 2015. After we had successfully verified Counting and Radix sort implementations in Java (<a href="http://link.springer.com/article/10.1007%2Fs10817-013-9300-y">J. Autom. Reasoning 53(2), 129-139</a>) with a formal verification tool called <a href="http://www.key-project.org/">KeY</a>, we were looking for a new challenge.  TimSort seemed to fit the bill, as it is rather complex and widely used. Unfortunately, we weren’t able to prove its correctness. A closer analysis showed that this was, quite simply, because TimSort was broken and our theoretical considerations finally led us to a path towards finding the bug (interestingly, that bug appears already in the Python implementation). This blog post shows how we did it.<span id="more-1586"/></p>
<p>The paper with the complete analysis, and several test programs are available on our <a href="http://www.envisage-project.eu/timsort-specification-and-verification/">website</a>.</p>
<p><b>Structure of this blog post</b></p>
<ol>
<li><a href="#sec1">The TimSort bug in Android, Java and Python</a><br/>
<a href="#sec1.1">1.1 Reproduce TimSort bug in Java</a><br/>
<a href="#sec1.2">1.2 How does TimSort work (in principle)?</a><br/>
<a href="#sec1.3">1.3 Walkthrough of TimSort bug</a></li>
<li><a href="#sec2">Proving the (in)correctness of TimSort</a><br/>
<a href="#sec2.1">2.1 The verification system KeY</a><br/>
<a href="#sec2.2">2.2 The fix and its formal specification</a><br/>
<a href="#sec2.3">2.3 Analysing the output of KeY</a></li>
<li><a href="#sec3">Suggested fixes to the Python and Android/Java Timsort bugs</a><br/>
<a href="#sec3.1">3.1 Incorrect Python merge_collapse function</a><br/>
<a href="#sec3.2">3.2 Corrected Python merge_collapse function</a><br/>
<a href="#sec3.3">3.3 Incorrect Java/Android merge_collapse function</a><br/>
<a href="#sec3.4">3.4 Corrected Java/Android merge_collapse function</a></li>
<li><a href="#sec4">Conclusion – What can we learn?</a></li>
</ol>
<h1><a id="sec1"/>1. The TimSort bug in Android, Java and Python</h1>
<p>So what’s the bug? Why don’t you try to reproduce it yourself first?</p>
<h2><b><a id="sec1.1"/>1.1 Reproduce TimSort bug in Java</b></h2>
<pre>git clone <a href="https://github.com/abstools/java-timsort-bug.git">https://github.com/abstools/java-timsort-bug.git</a>
cd java-timsort-bug
javac *.java
java TestTimSort 67108864</pre>
<p><b>Expected output</b></p>
<pre>Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 40
at java.util.TimSort.pushRun(TimSort.java:413)
at java.util.TimSort.sort(TimSort.java:240)
at java.util.Arrays.sort(Arrays.java:1438)
at TestTimSort.main(TestTimSort.java:18)
</pre>
<p><strong>Video of walkthrough</strong></p>
<p><iframe src="https://www.youtube.com/embed/HSyJ8f7h0jI?feature=oembed" frameborder="0" allowfullscreen="">VIDEO</iframe></p>
<h2><b><a id="sec1.2"/>1.2 How does TimSort work (in principle)?</b></h2>
<p>TimSort is a hybrid sorting algorithm that uses insertion sort and merge sort.</p>
<p>The algorithm reorders the input array from left to right by finding consecutive (disjoint) sorted segments (called “runs” from hereon). If the run is too short, it is extended using insertion sort.  The lengths of the generated runs are added to an array named <b>runLen</b>. Whenever a new run is added to <b>runLen</b>, a method named mergeCollapse merges runs until the last 3 elements in <b>runLen</b> satisfy the following two conditions (the “<b>invariant</b>”):</p>
<ol>
<li><b>runLen </b>[n-2] &gt; <b>runLen </b>[n-1] + <b>runLen </b>[n]</li>
<li><b>runLen </b>[n-1] &gt; <b>runLen</b> [n]<strong><strong> </strong></strong></li>
</ol>
<p>Here n is the index of the last run in runLen.  The intention is that checking this invariant on the top 3 runs in <b>runLen </b>in fact guarantees that <i>all</i> runs satisfy it. At the very end, all runs are merged, yielding a sorted version of the input array.</p>
<p>For performance reasons, it is crucial to allocate as little memory as possible for <b>runLen, </b>but still enough to store all the runs.  If the invariant is satisfied by all runs, the length of each run grows exponentially (even faster than fibonacci: the length of the current run must be strictly bigger than the sum of the next two runs lengths).  Since runs do not overlap, only a small number of runs would then be needed to cover even very big input arrays completely.</p>
<h2><b><a id="sec1.3"/>1.3 Walkthrough of TimSort bug</b></h2>
<p>The code snippet below shows that the implementation of mergeCollapse checks the invariant for the last 3 runs in <b>runLen</b>.</p>
<pre><strong>private</strong> <strong>void</strong> mergeCollapse() {
  <strong>while</strong> (stackSize &gt; 1) {
    int n = stackSize - 2;
    <strong>if</strong> (n &gt; 0 &amp;&amp; runLen[n-1] &lt;= runLen[n] + runLen[n+1]) {
      <strong>if</strong> (runLen[n - 1] &lt; runLen[n + 1])
         n--;
      mergeAt(n);
    } <strong>else</strong> <strong>if</strong> (runLen[n] &lt;= runLen[n + 1]) {
      mergeAt(n);
    } <strong>else</strong> {
      break; // Invariant is established
    }
  }
}
</pre>
<p>Unfortunately, this is not sufficient to ensure that all runs satisfy the invariant. Suppose that <b>runLen </b>has the following content on entry to mergeCollapse:</p>
<pre>120, 80, 25, 20, 30
</pre>
<p>In the first loop iteration, 25 and 20 are merged (since 25 &lt; 20 + 30 and 25 &lt; 30):</p>
<pre>120, 80, 45, 30
</pre>
<p>In the second iteration (now n=3), it is determined that the invariant is satisfied by the last 3 runs, since 80 &gt; 45 + 30 and 45 &gt; 30, thus mergeCollapse terminates. <b>But mergeCollapse has </b><b>not</b><b> fully restored the invariant:</b><b> it is broken by </b><b>120</b><b>, since </b><b>120</b> <b>&lt;</b><b> 80 + 45.</b></p>
<p>The testgenerator on our <a title="website" href="http://www.envisage-project.eu/timsort-specification-and-verification/">website </a>exploits this problem. It generates an input array with many short runs – too short, in the sense that they do not satisfy the invariant – which eventually causes TimSort to crash. In particular, since by breaking the invariant, the length of the runs can grow slower than expected, more than <b>runLen.length </b>runs are needed to cover the entire input array, resulting in an ArrayOutOfBoundsException on <b>runLen</b>.</p>
<h1><a id="sec2"/>2. Proving the (in)correctness of TimSort</h1>
<p>We found out that the supposed invariant of mergeCollapse is broken during an attempt to formally verify TimSort. Luckily, we did not only find out that it is broken, but also how it can be fixed. In the end we even succeeded to verify a corrected invariant that actually holds. But let’s take it step by step. First of all: what do we mean with formal verification and how is it done?</p>
<h2><b><a id="sec2.1"/>2.1 The verification system KeY</b></h2>
<p><span><strong><a title="KeY:  Deductive Verification of Software" href="http://www.envisage-project.eu/key-deductive-verification-of-software/">Due to many requests we have published a brief blog post about KeY.</a></strong></span></p>
<p><a href="http://www.key-project.org">KeY</a> is a deductive verification platform for sequential Java and JavaCard applications. It allows to <b><i>prove</i></b> the correctness of programs with respect to a given specification. Roughly speaking, a specification consists of a <b>precondition</b>, also called <b>requires</b> clause and a <b>postcondition</b>, also called <b>ensures</b> clause. Specifications are attached to method implementations, such as mergeCollapse() above. The specification of a method is also called its <b>contract</b>.</p>
<p>In the case of a sorting program, the precondition might simply state that the input is a non-empty array and the postcondition that the returned array is a sorted permutation of the input. What KeY then typically proves is this: whenever the method under verification is called with an input that satisfies the precondition, then the method terminates normally and in the final state the postcondition is true. This is also known as <b>total correctness</b>, because termination is ensured. Obviously, OpenJDK’s java.utils.Array.sort() does not adhere to this contract, because it terminates exceptionally for certain inputs.</p>
<p>In addition, instance and class invariants are used to specify general constraints on the values of fields. Typical properties are concerned with data consistency or with boundary values:</p>
<pre>/*@ <b>private invariant</b>
  @    runBase.length == runLen.length &amp;&amp; runBase != runLen;
  @*/
</pre>
<p>This invariant says that the length of the arrays runBase and runLen must be equal and that both arrays must not point to the same array instance, i.e., they are not aliased. The semantics of invariants implies that each method must establish upon completion not only the postcondition of its contract, but also the invariant of its (“this”) object.</p>
<p>As specification language in KeY the <a href="http://www.jmlspecs.org/">Java Modeling Language</a> (JML) is used. It contains pure Java expressions as a sublanguage and is therefore easy to learn for Java programmers. Its main extension beyond Java are quantified expressions (<b>\forall</b> T x, <b>\exists</b> T x) and, of course, suitable keywords for contracts. JML specifications are attached to the Java declarations they belong to in .java files. Here is a simple example of a Java method, specified with JML:</p>
<pre>/*@ <b>private normal_behavior</b>
  @ <b>requires</b>
  @   n &gt;= MIN_MERGE;
  @ <b>ensures</b>
  @   \result &gt;= MIN_MERGE/2;
  @*/

<b>private</b> <b>static</b> int /*@ <b>pure</b> @*/ minRunLength(int n) {
<b>  assert</b> n &gt;= 0;
  int r = 0;      // Becomes 1 if any 1 bits are shifted off
  /*@ <b>loop_invariant</b> n &gt;= MIN_MERGE/2 &amp;&amp; r &gt;=0 &amp;&amp; r&lt;=1;
    @ <b>decreases</b> n;
    @ <b>assignable</b> <b>\nothing</b>;
    @*/
<b>  while</b> (n &gt;= MIN_MERGE) {
    r |= (n &amp; 1);
    n &gt;&gt;= 1;
  }
<b>  return</b> n + r;
}
</pre>
<p>The contract of minRunLength() requires the caller to ensure that the method is only invoked with a value greater-or-equal to MIN_MERGE. In this case (and only in this) the method ensures that it will terminate normally (i.e., neither diverge nor throw an exception) and that the returned value is at least as big as MIN_MERGE/2. In addition, the method is marked as <b>pure</b> which implies that the method does not modify the heap.</p>
<p>The crucial point is that KeY can <b>statically</b> prove such method contracts for <b>any</b> given input. How is this possible? KeY performs symbolic execution of the method under verification, that is, it executes it with symbolic values so that all possible execution paths are taken into account. But this is not enough, because symbolic execution of loops without a fixed bound (such as the one in mergeCollapse() where we don’t know the value of stackSize) will not terminate. To render symbolic execution of loops finite, invariant reasoning is used. For instance, method minRunLength() from above contains a loop which is specified using a loop invariant. The invariant ensures that after each loop iteration the condition n &gt;= MIN_MERGE/2 &amp;&amp; r &gt;=0 &amp;&amp; r&lt;=1 holds and hence the method’s postcondition can be proven. The <b>decreases</b> annotation is used to prove termination of the loop by providing an expression whose value is non-negative and strictly decreasing. The <b>assignable</b> clause lists the heap locations that might possibly be modified by the loop. The keyword <b>\nothing</b> means that no heap locations are modified. Indeed: only the local variable r and the value argument n are changed.</p>
<p>In summary, for the purpose of formal verification, method contracts are not enough. It is necessary to supply a suitable loop invariant. It can be a tricky business to come up with an invariant that is strong enough to ensure the desired postcondition and that still holds. Without tool support and automated theorem proving technology it is hardly possible to come up with correct loop invariants for non-trivial programs. And in fact, it is exactly here that the designers of TimSort went wrong. The loop of mergeCollapse causes under certain circumstances the following part of TimSort’s class invariant to be violated (see section 1.3 Walkthrough of TimSort bug):</p>
<pre>/*@ <b>private invariant </b>
  @   (<b>\forall</b> int i; 0&lt;=i &amp;&amp; i&lt;stackSize-4; 
  @                      runLen[i] &gt; runLen[i+1] + runLen[i+2]))
  @*/
</pre>
<p>which states that runLen[i] must be greater than the size of the two successor entries (for index i within 0 (including) and stackSize-4 (excluding).  As the invariant is also not restored later on method mergeCollapse does not preserve the class invariant either. Hence, the loop invariant was not as strong as assumed by the developers. We found this out during our formal verification attempt, with the help of KeY. It is nearly impossible to do so without tool support.</p>
<p>Despite being very close to Java, JML is a full-fledged design-by-contract language, suitable for full functional verification of Java programs.</p>
<h2><b><a id="sec2.2"/>2.2  The fix and its formal specification</b></h2>
<p>A <i>simplified</i> version of the contract that mergeCollapse is expected to satisfy is shown below.</p>
<pre>/*@ <b>requires</b>
  @   stackSize &gt; 0 &amp;&amp;
  @   runLen[stackSize-4] &gt; runLen[stackSize-3]+runLen[stackSize-2]
  @   &amp;&amp; runLen[stackSize-3] &gt; runLen[stackSize-2];
  @ <b>ensures</b>
  @   (<b>\forall</b> int i; 0&lt;=i &amp;&amp; i&lt;stackSize-2; 
  @                     runLen[i] &gt; runLen[i+1] + runLen[i+2])
  @   &amp;&amp; runLen[stackSize-2] &gt; runLen[stackSize-1]
  @*/
<b>private</b> <b>void</b> mergeCollapse()</pre>
<p>The two formulas in <b>ensures</b> imply that when mergeCollapse completes, then <b><i>all</i></b> runs satisfy the invariant given in section 1.2. We saw already that the above contract is not satisfied by the current implementation of mergeCollapse (in section 1.3), so we provide the following fixed version that respects the contract:</p>
<pre><strong>private</strong> <strong>void</strong> newMergeCollapse() {
  <strong>while </strong>(stackSize &gt; 1) {
    int n = stackSize - 2;
    <strong>if</strong> (n &gt; 0   &amp;&amp; runLen[n-1] &lt;= runLen[n] + runLen[n+1] || 
        n-1 &gt; 0 &amp;&amp; runLen[n-2] &lt;= runLen[n] + runLen[n-1]) {
      <strong>if</strong> (runLen[n - 1] &lt; runLen[n + 1])
        n--;
    } <strong>else</strong> <b>if</b> (n&lt;0 || runLen[n] &gt; runLen[n + 1]) {
      <strong>break</strong>; // Invariant is established
    }
    mergeAt(n);
  }
}
</pre>
<p>The main idea of this new version is to check that the invariant holds for <i>the last 4 runs</i> in runLen, instead of only <i>the last 3</i>.  We will see that this suffices to ensure that <b>all </b>runs satisfy the invariant upon completion of mergeCollapse.</p>
<p>The first step in proving the contract for our fixed version of mergeCollapse is to find a suitable loop invariant. The code snippet below shows a simplified version of the loop invariant.</p>
<pre>/*@ <b>loop_invariant</b>
  @  (<b>\forall</b> int i; 0&lt;=i &amp;&amp; i&lt;stackSize-4; 
  @             runLen[i] &gt; runLen[i+1] + runLen[i+2])
  @  &amp;&amp; runLen[stackSize-4] &gt; runLen[stackSize-3])
  @*/
</pre>
<p>Intuitively this loop invariant states that all runs, except possibly the last 4, satisfy the invariant.  Combining this with the observation that the new loop of mergeCollapse terminates (with the break statement) only if the last 4 runs also satisfy it, this guarantees that all runs satisfy the invariant.</p>
<h2><b><a id="sec2.3"/>2.3 Analysing the output of KeY</b></h2>
<p>When the fixed version of mergeCollapse, its contract and the loop invariant are given as input to KeY, the system symbolically executes the loop and generates verification conditions: formulas whose truth imply that the mergeCollapse contract is satisfied. The following formula (simplified) shows the main proof obligation generated by KeY:<br/>
<img src="http://envisage-project.eu/wp-content/uploads/2015/02/Screen-Shot-2015-02-23-at-13.42.07.png" alt=""/></p>
<p>This verification condition is generated to make sure that the postcondition of mergeCollapse  is satisfied when the loop terminates.  This explains the three formulas between the brackets: the break statement that terminates the loop is only executed if these are true. We proved this formula (and all other verification conditions) formally with KeY in a semi-automated manner. Here we sketch this proof:</p>
<p><i>Proof</i>. The formula<i> runLen[stackSize-2] &gt; runLen[stackSize-1]  </i>from the mergeCollapse postcondition follows directly from  <i>n &gt;= 0 ==&gt; runLen[n] &gt; runLen[n+1]</i>.</p>
<p>We prove the other formula,</p>
<p><i>\forall int i; 0&lt;=i &amp;&amp; i&lt;stackSize-2; runLen[i] &gt; runLen[i+1] + runLen[i+2]</i>,</p>
<p>by case distinction on the value of i:</p>
<ul>
<li>i &lt; stackSize-4: follows from the loop invariant</li>
<li>i = stackSize-4: follows from n&gt;1 ==&gt; runLen[n-2] &gt; runLen[n-1] + runLen[n]</li>
<li>i = stackSize-3: from n&gt;0 ==&gt; runLen[n-1] &gt; runLen[n] + runLen[n+1]</li>
<li>i = stackSize-2: from n&gt;=0 ==&gt; runLen[n] &gt; runLen[n+1]</li>
</ul>
<p>The above proof shows that the new version of <i>mergeCollapse </i>terminates only when <b>all</b> runs satisfy the invariant.</p>
<h1><a id="sec3"/>3. Suggested fixes to the Python and Android/Java Timsort bugs</h1>
<p>Our analysis of the bug (which included the fix for <i>mergeCollapse</i>) was submitted, reviewed and accepted in the Java bug tracker  <a href="https://bugs.openjdk.java.net/browse/JDK-8072909">https://bugs.openjdk.java.net/browse/JDK-8072909</a>.</p>
<p>The bug is present in at least the Android version of Java, OpenJDK and OracleJDK: all of these share the same source code for TimSort.  Furthermore it is also present in Python. The next two sections show (side-by-side) the original and fixed versions.</p>
<p>As explained in the previous section, the idea behind the fix is very simple: check that the invariant holds for the last 4 runs in runLen, instead of only the last 3.</p>
<h2><b><a id="sec3.1"/>3.1 Incorrect Python merge_collapse function</b></h2>
<p>Timsort for Python (written in C with the Python API) is available in <a href="https://hg.python.org/cpython/file/5c1bacba828d/Objects/listobject.c">the subversion repository</a> – The algorithm is also described in <a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">http://svn.python.org/projects/python/trunk/Objects/listsort.txt</a></p>
<p>The Java version of TimSort was ported from the original CPython version. That version also contains the bug and was intended to work for arrays with up to 2^64 elements. However, on current machines it is not possible to trigger an out-of-bounds error in the Python version: it allocates 85 elements for runLen, which suffices (following our analysis in the full paper) for arrays with less than 2^49 elements.  For comparison, the current most powerful supercomputer <a href="http://en.wikipedia.org/wiki/Tianhe-2">http://en.wikipedia.org/wiki/Tianhe-2</a> has about 2^50 bytes of memory in total.</p>
<pre><b>/* The maximum number of entries in a MergeState's 
 * pending-runs stack.</b><b>
</b><b> * This is enough to sort arrays of size up to about</b><b>
</b><b> *     32 * phi ** MAX_MERGE_PENDING</b><b>
</b><b> * where phi ~= 1.618.  85 is ridiculously large enough, 
 * good for an array </b><b>with 2**64 elements.</b><b>
</b><b> */</b><b>
</b><b>#define MAX_MERGE_PENDING 85</b>

<b>merge_collapse</b><b>(MergeState </b><b>*</b><b>ms)</b><b>
</b><b>{</b><b>
</b><b>    </b><b>struct</b><b> s_slice </b><b>*</b><b>p </b><b>=</b><b> ms</b><b>-&gt;</b><b>pending;</b><b>
</b><b>
</b><b>    assert(ms);</b><b>
</b><b>    </b><b>while</b><b> (ms</b><b>-&gt;</b><b>n </b><b>&gt;</b> <b>1</b><b>) {</b><b>
</b><b>        Py_ssize_t n </b><b>=</b><b> ms</b><b>-&gt;</b><b>n </b><b>-</b> <b>2</b><b>;</b><b>
</b><b>  </b><b>      </b><b>if</b><b> (n </b><b>&gt;</b> <b>0</b> <b>&amp;&amp;</b><b> p[n</b><b>-1</b><b>].len </b><b>&lt;=</b><b> p[n].len </b><b>+</b><b> p[n</b><b>+1</b><b>].len) {</b><b>
</b><b>            </b><b>if</b><b> (p[n</b><b>-1</b><b>].len </b><b>&lt;</b><b> p[n</b><b>+1</b><b>].len)</b><b>
</b><b>                </b><b>--</b><b>n;</b><b>
</b><b>            </b><b>if</b><b> (merge_at(ms, n) </b><b>&lt;</b> <b>0</b><b>)</b><b>
</b><b>                </b><b>return</b> <b>-1</b><b>;</b><b>
</b><b>        }</b><b>
</b><b>        </b><b>else</b> <b>if</b><b> (p[n].len </b><b>&lt;=</b><b> p[n</b><b>+1</b><b>].len) {</b><b>
</b><b>                 </b><b>if</b><b> (merge_at(ms, n) </b><b>&lt;</b> <b>0</b><b>)</b><b>
</b><b>                        </b><b>return</b> <b>-1</b><b>;</b><b>
</b><b>        }</b><b>
</b><b>        </b><b>else</b><b>
</b><b>            </b><b>break</b><b>;</b><b>
</b><b>    }</b><b>
</b><b>    </b><b>return</b> <b>0</b><b>;</b><b>
</b><b>}</b>
</pre>
<h2><b><a id="sec3.2"/>3.2 Corrected Python merge_collapse function</b></h2>
<pre><b>merge_collapse</b><b>(MergeState </b><b>*</b><b>ms)</b><b>
</b><b>{</b><b>
</b><b>    </b><b>struct</b><b> s_slice </b><b>*</b><b>p </b><b>=</b><b> ms</b><b>-&gt;</b><b>pending;</b><b>
</b><b>
</b><b>    assert(ms);</b><b>
</b><b>    </b><b>while</b><b> (ms</b><b>-&gt;</b><b>n </b><b>&gt;</b> <b>1</b><b>) {</b><b>
</b><b>        Py_ssize_t n </b><b>=</b><b> ms</b><b>-&gt;</b><b>n </b><b>-</b> <b>2</b><b>;</b><b>
</b><b>        </b><b>if</b><b> (     n </b><b>&gt;</b> <b>0</b><b>   </b><b>&amp;&amp;</b><b> p[n</b><b>-1</b><b>].len </b><b>&lt;=</b><b> p[n].len </b><b>+</b><b> p[n</b><b>+1</b><b>].len
</b><b>        </b><b>    || (n-1 &gt; 0 &amp;&amp;  p[n</b><b>-2</b><b>].len </b><b>&lt;=</b><b> p[n].len </b><b>+</b><b> p[n</b><b>-1</b><b>].len)) {</b><b>
</b><b>            </b><b>if</b><b> (p[n</b><b>-1</b><b>].len </b><b>&lt;</b><b> p[n</b><b>+1</b><b>].len)</b><b>
</b><b>                </b><b>--</b><b>n;</b><b>
</b><b>            </b><b>if</b><b> (merge_at(ms, n) </b><b>&lt;</b> <b>0</b><b>)</b><b>
</b><b>                </b><b>return</b> <b>-1</b><b>;</b><b>
</b><b>        }</b><b>
</b><b>        </b><b>else</b> <b>if</b><b> (p[n].len </b><b>&lt;=</b><b> p[n</b><b>+1</b><b>].len) {</b><b>
</b><b>                 </b><b>if</b><b> (merge_at(ms, n) </b><b>&lt;</b> <b>0</b><b>)</b><b>
</b><b>                        </b><b>return</b> <b>-1</b><b>;</b><b>
</b><b>        }</b><b>
</b><b>        </b><b>else</b><b>
</b><b>            </b><b>break</b><b>;</b><b>
</b><b>    }</b><b>
</b><b>    </b><b>return</b> <b>0</b><b>;</b><b>
</b><b>}</b>
</pre>
<h2><b><a id="sec3.3"/>3.3 Incorrect Java/Android merge_collapse function</b></h2>
<p>Same bug as for Python in section 3.1</p>
<pre><b>   private void mergeCollapse() {</b><b>
</b><b>        while (stackSize &gt; 1) {</b><b>
</b><b>            int n = stackSize - 2;</b><b>
</b><b>          </b><b>  if (n &gt; 0 &amp;&amp; runLen[n-1] &lt;= runLen[n] + runLen[n+1])</b><b> {</b><b>
</b><b>                if (runLen[n - 1] &lt; runLen[n + 1])</b><b>
</b><b>                    n--;</b><b>
</b><b>                mergeAt(n);</b><b>
</b><b>            } else if (runLen[n] &lt;= runLen[n + 1]) {</b><b>
</b><b>                mergeAt(n);</b><b>
</b><b>            } else {</b><b>
</b><b>                break; // Invariant is established</b><b>
</b><b>            }</b><b>
</b><b>        }</b><b>
</b><b>    }</b>
</pre>
<h2><b><a id="sec3.4"/>3.4 Corrected Java/Android merge_collapse function</b></h2>
<p>Equivalent fix as for Python in section 3.2<br/>
[UPDATE 26/2: we updated the code below as it was from an earlier version of the paper. The old code was equivalent but contained a redundant test and different coding style. Several people noticed – thanks for the feedback!]</p>
<pre><b>   private void newMergeCollapse() {</b>
<b>     while (stackSize &gt; 1) {</b>
<b>       int n = stackSize - 2;</b>
<b>       </b><b>if (   (n &gt;= 1 &amp;&amp; runLen[n-1] &lt;= runLen[n] + runLen[n+1])</b>
<b>           || (n &gt;= 2 &amp;&amp; runLen[n-2] &lt;= runLen[n] + runLen[n-1]))</b><b> {</b>
<b>                if (runLen[n - 1] &lt; runLen[n + 1])</b>
<b>                    n--;</b>
<b>            } else if (runLen[n] &gt; runLen[n + 1]) {</b>
<b>                break; // Invariant is established</b>
<b>            }</b>
<b>            mergeAt(n);</b>
<b>        }</b>
<b>    }</b>
</pre>
<h1><a id="sec4"/>4. Conclusion – What we can learn</h1>
<p>While attempting to verify TimSort, we failed to establish its instance invariant. Analysing the reason, we discovered a bug in TimSort’s implementation leading to an ArrayOutOfBoundsException for certain inputs. We suggested a proper fix for the culprit method (without losing measurable performance) and we have formally proven that the fix actually is correct and that this bug no longer persists.</p>
<p>There are a few observations that can be drawn from this exercise beyond the immediate issue of the bug.</p>
<ol>
<li>Formal methods are often classified as irrelevant and/or impracticable by practitioners. This is not true: we found and fixed a bug in a piece of software that is used by billions of users every single day. Finding and fixing this bug without a formal analysis and the help of a verification tool is next to impossible, as our analysis showed. It has been around for years in a core library routine of Java and Python. Earlier occurrences of the underlying bug were supposedly fixed, but actually only made its occurrence less likely.</li>
<li>Even though the bug itself is unlikely to occur, it is easy to see how it could be used in an attack. It is likely that more undetected bugs are in other parts of core libraries of mainstream programming languages. Shouldn’t we try to find them before they can do harm or they can be exploited?</li>
<li>The reaction of the Java developer community to our report is somewhat disappointing: instead of using our fixed (and verified!) version of mergeCollapse(), they opted to increase the allocated runLen “sufficiently”. As we showed, this is not necessary. In consequence, whoever uses java.utils.Collection.sort() is forced to over allocate space. Given the astronomical number of program runs that such a central routine is used in, this leads to a considerable waste of energy. As to the reasons, why our solution has not been adopted, we can only speculate: perhaps the JDK maintainers did not bother to read our report in detail, and therefore don’t trust and understand our fix. After all, Open Java is a community effort, largely driven by volunteers with limited time.</li>
</ol>
<p>What can we learn from this? We would be happy if our work could be the starting point of a closer collaboration between the formal methods and the developers of open language frameworks. Formal methods have already been adopted successfully by Amazon [<a href="http://research.microsoft.com/en-us/um/people/lamport/tla/formal-methods-amazon.pdf">link</a>] and Facebook [<a href="https://research.facebook.com/publications/422671501231772/moving-fast-with-software-verification/">link</a>]. Modern formal specification languages and formal verification tools are <b>not</b> cryptic and super-hard to learn. Usability and automation are improving constantly. But we need more people to try, test and use our formal tools. Yes, it costs a little effort to start formally specifying and verifying stuff, but not more than, say, learning how to use a compiler framework or a build tool. We are talking days/weeks, not months/years. Will <b>you</b> take up the challenge?</p>

<p><strong>Acknowledgements:</strong></p>
<p>Partly funded by the EU project FP7-610582 ENVISAGE: Engineering Virtualized Services (http://www.envisage-project.eu).</p>
<p><span>This blog would never have gotten written without the enthusiastic support and gentle pushing of </span><a href="http://memkite.com/team/">Amund Tveit</a><span>!</span> We would further like to thank Behrooz Nobakht for providing the video showcasing the bug.</p>
<p><img src="https://envisage.ifi.uio.no:8080/t/timsortbug.gif" alt="Envisage logo"/></p>
			</div>
	
	</div></body></html>