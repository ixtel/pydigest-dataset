<html><body><div><div class="section">
              <h1>obiwan 1.0.8</h1>

              


<p>A runtime type checker (contract system) and JSON validator</p>








<div id="what-is-obiwan">
<h2>what is obiwan?</h2>
<p>[blogpost]
<a href="http://williamedwardscoder.tumblr.com/post/33185451698/obiwan-typescript-for-python" rel="nofollow">http://williamedwardscoder.tumblr.com/post/33185451698/obiwan-typescript-for-python</a></p>
<p>Obiwan is a Python type-checker. You place descriptive type constraints
in your function declarations and obiwan can check them for you at
runtime.</p>
<p>A function can look like:</p>
<pre>def example(a: int, b: float) -&gt; number:
    return a/b
</pre>
<p>Obiwan is also exemplary for describing and checking external data e.g.
JSON and msgpack, and has a json parser that does this.</p>
<p>Obiwan machinary can also be used for checking contracts, constraints
and expectations in normal code rather as an assert.</p>
<p>My ambition is that this Obiwan syntax is widely adopted and eventually
Python static type checkers support it and IDEs can do auto-complete ala
Typescript.</p>
<p>To enable obiwan, you just call it:</p>
<pre>from obiwan import *; install_obiwan_runtime_check()
</pre>
<p>(Obiwan attaches to the Python VM using <tt>settrace()</tt>. You need to call
the installer in each thread you want checked)</p>
<p>you are now running obiwan! Runtime execution will be slower, but
annotated functions will be checked for parameter correctness!</p>
<p>All strings in your function annotations are ignored; you can place
documentation in annotations without impacting obiwan.</p>
</div>
<div id="maturity">
<h2>maturity</h2>
<p>The dictionary and list checking code is based upon a tried-and-tested
JSON validator.</p>
<p>The integration with Python 3 function annotations is new and the
<tt>function</tt> and <tt>duck</tt> type checking is new. Improvements and patches
welcome!</p>
</div>
<div id="validating-dictionaries-and-lists">
<h2>validating dictionaries and lists</h2>
<p>You can also describe dictionary parameters and what their expected
attributes are:</p>
<pre>def example(obj: {"a":int, "b": float}) -&gt; {"ret": number}:
    return {"ret": a/b}
</pre>
<p>Checking can support the checking of <em>optional</em> and <em>noneable</em>
attributes:</p>
<pre>def example(obj: {"a":int, optional("b"): float}):
    ...
</pre>
<p>Checks can contain dictionary and other attributes too:</p>
<pre>def example(person: {"name":str, "phone": {"type":str, "number":str}}):
    ...
</pre>
<p>Dictionaries can be checked for key and value <em>types</em>, as well as by key
name. E.g. to ensure that a function returns only dictionaries mapping
strings to integers:</p>
<pre>def example() -&gt; {str: int}:
    ...
</pre>
<p>You can specify alternative constraint types using sets:</p>
<pre>def example(x: {int,float}):
    ...
</pre>
<p>In fact, <em>number</em> type is just a set of int and float. And <em>noneable</em> is
just a way of saying <tt><span class="pre">{...,None}</span></tt></p>
<p>Lists mean that the attribute must be an array where each element
matches the constraint e.g.:</p>
<pre>def example(numbers: [int]):
    ...
</pre>
<p>And sets which must be all of one type can be specified with a set
containing a single element:</p>
<pre>def example(x: {str}):
    ...
</pre>
<p>Tuples must map to lists or tuples (no destructive iterators!) with the
appropriate types in each slot:</p>
<pre>def nearest_point_on_line(line:((int,int),(int,int)),pt:(int,int)) -&gt; (int,int):
</pre>
<p>Within tuples you can use <tt>any</tt> to indicate that a type needs not be
checked, and you can use ellipsis as the last element in the
type-defintion tuple to indicate that additional parameters are allowed:</p>
<pre>def decode_data(data: str) -&gt; (str,any,int,...):
</pre>
<p>It aids readability to use variables to hold definitions e.g.:</p>
<pre>Point = (int,int)
def nearest_point_on_line(line:(Point,Point),pt:Point) -&gt; Point:
</pre>
<p>and:</p>
<pre>api_add_user = {
    "name": str,
    "admin": bool,
}
def add_user(user: api_add_user) -&gt; int:
    ...
</pre>
<p>Dict templates can have a special <em>options</em> key which is a list of
options. Options include <em>strict</em> and <em>subtype</em>:</p>
<pre>api_base = {
    "user_id": int,
}
api_set_name = {
    options: [strict, subtype(api_base)],
    "name": str,
}
</pre>
<p><em>Strict</em> will complain if the dictionary being validated contains any
keys <em>not</em> in the template dictionary, and <em>subtype</em> will combine
parameters specified in other dictionary templates with this template.
In this example, dictionaries validated against <tt>api_set_name</tt> must
have both user_id and name specified, and no other keys.</p>
<p>You can specify multiple parent templates in the subtype arguments, and
have multiple subtype options, and nest template inheritence arbitrarily
deep.</p>
</div>
<div id="validating-json">
<h2>validating JSON</h2>
<p>Utility functions to load and dump JSON are provided. These support a
new <em>template</em> parameter and validate the input/output matches the
constraint e.g.:</p>
<pre>json.loads(tainted, template=[api_add_user])

json.loads(tainted, template={"type": str, "data": { ....
</pre>
</div>
<div id="if-it-quacks-like-a-duck">
<h2>if it quacks like a duck…</h2>
<p>In Python 3 everything is an object, even <tt>int</tt> and <tt>None</tt>. So you
can’t generically say that an argument or attribute must be an <em>object</em>.
You have to say what its attributes should be. This follows the same
style as validating dictionaries, but uses the <em>duck</em> type and keyword
arguments to define:</p>
<pre>def example(a: duck(name=str,get_name=function)):
    ...
</pre>
<p>This means that <tt>a</tt> must be something with a name attribute of type
string, and a function attribute called get_name.</p>
<p>You can of course use classes to:</p>
<pre>class Person:
   def get_name(self):
      ...

def example(person: Person):
    ...
</pre>
<p><em>duck</em> instances can <em>extend</em> other duck instances using positional
parameters:</p>
<pre>api_base = duck(user_id=int)
api_change_name = duck(api_base, name=str)
def change_name(user: api_change_name):
    ...
</pre>
</div>
<div id="validating-callbacks">
<h2>validating callbacks</h2>
<p>You can say that a parameter is callable using function:</p>
<pre>def example(callback: function):
    ...
</pre>
<p>If you want, you can describe the parameters that the function should
take:</p>
<pre>def example(callback: function(int,str)):
    ...
</pre>
<p>However, all the functions passed to example8 must now be properly
annotated with a matching annotation.</p>
<p>The special type any can be used if you do not want to check the type:</p>
<pre>def example(callback: function(int,any,number)):
    ...
</pre>
<p>You can also specify that a function should support further arguments
using ellipsis:</p>
<pre>def example(callback: function(int,any,...)):
    ...
</pre>
<p>This will ensure that all callbacks have at least two parameters, the
first being an int.</p>
</div>
<div id="using-lambdas-as-checkers">
<h2>using lambdas as checkers</h2>
<p>You can use lambdas as checkers; they should return a boolean condition
e.g.</p>
<pre>template = {
    'month': lambda x: x in ["jan","feb","mar",...],
    ...
}
</pre>
</div>
<div id="writing-your-own-custom-checkers">
<h2>writing your own custom checkers</h2>
<p>You can provide your own complex custom constraint checkers by
subclassing the ObiwanCheck class; look at obiwan.StringCheck for
inspiration.</p>
</div>


<a name="downloads"> </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>48</span> downloads in the last week
  </li>
  <li>
    <span>420</span> downloads in the last month
  </li>
</ul>









            </div>


          </div></body></html>