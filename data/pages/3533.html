<html><body><div><div id="article-content" class="article">
    <h1 class="title">Отладка SQL в django тестах</h1>
    <p/><p><a href="http://www.lexev.org/2015/debug-sql-django-test/"><img alt="Отладка SQL в django тестах" src="https://img-fotki.yandex.ru/get/4517/85893628.c67/0_1795f5_a958c090_orig.png" title="Отладка SQL в django тестах"/></a></p>
<p>В django тестах можно замерять количество сделанных SQL запросов:</p>
<pre><code>def test_home(self):
    with self.assertNumQueries(1):
        response = self.client.get('/')
    self.assertEqual(response.status_code, 200)
</code></pre>
<p>Если код в контексте <code>assertNumQueries</code> сделает иное количество обращений к БД, чем ожидается (здесь 1), то тест выдает ошибку. Но когда такой тест не проходит, бывает трудно определить лишний отправленный запрос. Для отладки такого случая удобно вывести в консоль отправленные SQL запросы. Далее опишу, как этого добиться.</p>
<p>Кстати, если вы используете Django 1.7+, то вместе с ошибкой будут показаны все SQL выражения, т.е. если этого достаточно - то делать вообще ничего не надо. Ура! Если же вы используете более старые версии, то данная статья будет полезна.</p>
<h3>Настройка логов для вывода SQL запросов в консоль</h3>
<p>Django будет логировать SQL запрос, если соблюдается одного из следующих условий:</p>
<p><code>settings.DEBUG = True</code></p>
<p>или</p>
<p><code>connection.use_debug_cursor = True</code></p>
<p>По умолчанию в тестах всегда <em>DEBUG = False</em> вне зависимости от того, что стоит в вашем <em>settings.DEBUG</em>. Это правильно, тестировать лучше с боевыми настройками.</p>
<p>Т.о. остается <em>connection.use_debug_cursor</em>, которое по умолчанию всегда <em>None</em> или <em>False</em> (в разных версиях по разному). Но контекстный менеджер <em>assertNumQueries</em> сам выставляет это значение в <em>True</em> на время работы соответствующего блока! Нам остается лишь правильно задать настройки логов.</p>
<p>Создадим отдельный файл настроек для тестов и назовем его settings_test.py. Тесты гонять будем с ним. Рекомендую всегда делать так - это удобно. Структура проекта примерно такая:</p>
<pre><code>project
├── project
│   ├── __init__.py
│   ├── settings.py
│   ├── settings_test.py
│   ├── urls.py
│   └── wsgi.py
│
├── spam  # some app
│   ├── __init__.py
│   ├── views.py
│   ├── tests.py
│   └── models.py
│
└── manage.py
</code></pre>
<p>Файл tests.py содержит тесты приложения spam. Так организовывать тесты не самый хороший выбор, лучше выделить отдельную папку и держать все тесты там. Но для простоты нашего примера годится.</p>
<p>Содержимое settings_test.py:</p>
<pre><code>from settings import *
try:
    from settings import LOGGING
except ImportError:
    LOGGING = dict(version=1, disable_existing_loggers=False,
        handlers={}, loggers={})

# use database in memory to not lose your data!
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': ':memory:',
        'USER': '',
        'PASSWORD': '',
        'TEST_CHARSET': 'utf8',
    }}

LOGGING['handlers']['console'] = {
    'level': 'DEBUG',
    'class': 'logging.StreamHandler',
}
LOGGING['loggers']['django.db.backends'] = {
    'handlers': ['console'],
    'level': 'DEBUG',
    'propagate': False,
}
LOGGING['loggers']['django.db.backends.schema'] = {
    'propagate': False,  # don't log schema queries, django &gt;= 1.7
}
</code></pre>
<p>Тест (tests.py) выглядит так:</p>
<pre><code>from django.test import TestCase
from spam.models import Foo

class SpamTestCase(TestCase):
    def setUp(self):
        Foo.objects.create(title="Foo")

    def test_home(self):
        with self.assertNumQueries(1):
            response = self.client.get('/')
        self.assertEqual(response.status_code, 200)
</code></pre>
<p>Давайте посмотрим, что будет при прогоне теста используя разные runner'ы.</p>
<h4>Django 1.4+</h4>
<p><code>$ python manage.py test</code> (нет SQL):</p>
<pre><code>Creating test database for alias 'default'...
.
----------------------------------------------------------------------
Ran 1 test in 0.009s

OK
Destroying test database for alias 'default'...
</code></pre>
<p><code>$ python manage.py test  --settings=project.settings_test</code> (SQL в консоле)</p>
<pre><code>Creating test database for alias 'default'...
(0.000) SELECT "spam_foo"."id", "spam_foo"."title" FROM "spam_foo" LIMIT 21; args=()
.
----------------------------------------------------------------------
Ran 1 test in 0.009s

OK
Destroying test database for alias 'default'...
</code></pre>
<h4>Django 1.4+ и django-nose</h4>
<ul>
<li>pip install django-nose</li>
<li>в settings.py выставляем <em>TEST_RUNNER = 'django_nose.NoseTestSuiteRunner'</em></li>
</ul>
<p><code>$ python manage.py test</code> (нет SQL):</p>
<pre><code>...
</code></pre>
<p><code>$ python manage.py test  --settings=project.settings_test</code> (SQL в консоле)</p>
<pre><code>(0.000) SELECT "spam_foo"."id", "spam_foo"."title" FROM "spam_foo" LIMIT 21; args=()
...
</code></pre>
<h4>Django 1.4+ и pytest-django</h4>
<ul>
<li>pip install pytest-django</li>
<li>
<p>создаем файл pytest.ini рядом с manage.py и задаем файл настроек:    </p>
<pre><code>[pytest]
DJANGO_SETTINGS_MODULE = project.settings
</code></pre>
</li>
<li>
<p>переименуем tests.py в test_spam.py (стандартные имена для py.test)</p>
</li>
</ul>
<p><code>$ py.test</code> (нет SQL):</p>
<pre><code>...
</code></pre>
<p><code>$ py.test  --ds=project.settings_test</code> (нет SQL, py.test перехватывает весь вывод)</p>
<pre><code>...
</code></pre>
<p><code>$ py.test  --ds=project.settings_test -s</code> (SQL в консоле)</p>
<pre><code>(0.000) SELECT "spam_foo"."id", "spam_foo"."title" FROM "spam_foo" LIMIT 21; args=()
...
</code></pre>
<h4>Итого</h4>
<p>Как видно из предыдущих примеров, при использовании нашего settings_test в консоль выводятся все запросы к БД, сделанные в блоке контекстного менеджера <em>assertNumQueries</em>.</p>
<p>Если мы хотим гонять тесты всегда с этими настройками, а не только когда хотим что-то отладить, то очень скоро устанем от обилия SQL. Можно сделать так: закомментировать строчку <code>'handlers': ['console'],</code>, т.о. ничего выводится не будет. А когда нужно их посмотреть - просто убираем комментарий.</p>
<h3>Вывод ошибки assertNumQueries и Django 1.7+</h3>
<p>Если <em>assertNumQueries</em> регистрирует отличное от ожидаемого количество обращений к БД, то выводится traceback и ошибка:</p>
<pre><code>Traceback (most recent call last):
  ...
AssertionError: 1 queries executed, 2 expected
</code></pre>
<p>Но в django 1.7+ так же выводятся и сделанные запросы:</p>
<pre><code>Captured queries were:
QUERY = u'SELECT "spam_foo"."id", "spam_foo"."title" FROM "spam_foo" LIMIT 21' - PARAMS = ()
</code></pre>
<p>Как вы понимаете, настройки логов на это не влияют, очень удобно!</p>
<h3>Вывод всех SQL запросов в консоль не используя assertNumQueries</h3>
<p>До сих пор речь шла об использовании <em>assertNumQueries</em>. Но что если нужно посмотреть запросы вне этого менеджера?</p>
<p>Для этого нужно самому выставить <code>connection.use_debug_cursor = True</code> перед прогоном тестов. Это можно сделать в test runner'е или используя специальный hook в py.test.</p>
<h4>SQL во всех тестах: Django 1.4+</h4>
<p>Создаем файл test_runner.py, кладем его рядом с settings.py и вставляем такой код:</p>
<pre><code>try:
    from django.test.runner import DiscoverRunner as DjangoTestSuiteRunner
except ImportError:
    # django &lt; 1.6
    from django.test.simple import DjangoTestSuiteRunner
from django.db import connections, DEFAULT_DB_ALIAS

class SqlDebugTestSuiteRunner(DjangoTestSuiteRunner):
    def setup_test_environment(self, **kwargs):
        super(SqlDebugTestSuiteRunner, self).setup_test_environment(**kwargs)
        connections[DEFAULT_DB_ALIAS].use_debug_cursor = True
</code></pre>
<p>Теперь либо в settings (или settings_test, если используем его для тестов) указываем наш runner:</p>
<pre><code>TEST_RUNNER = 'project.test_runner.SqlDebugTestSuiteRunner'
</code></pre>
<p>Запускаем <code>python manage.py test --settings=project.settings_test</code> и видим все запросы, созданные за время тестов.</p>
<p>Либо можно не задавать <em>TEST_RUNNER</em>, а использовать аргумент <em>--testrunner</em>:</p>
<p><code>python manage.py test --settings=project.settings_test --testrunner=project.test_runner.SqlDebugTestSuiteRunner</code></p>
<p>Результат будет тем же.</p>
<h4>SQL во всех тестах: Django 1.4+ и django-nose</h4>
<p>Для nose почти все так же, только runner нужно унаследовать от NoseTestSuiteRunner.</p>
<p>test_runner.py:</p>
<pre><code>from django_nose import NoseTestSuiteRunner
from django.db import connections, DEFAULT_DB_ALIAS

class SqlDebugTestSuiteRunner(NoseTestSuiteRunner):
    def setup_test_environment(self, **kwargs):
        super(SqlDebugTestSuiteRunner, self).setup_test_environment(**kwargs)
        connections[DEFAULT_DB_ALIAS].use_debug_cursor = True
</code></pre>
<p>Да, на момент написания статьи версия django-nose==1.3. В этой версии не поддерживается аргумент <em>--testrunner</em>. Но я отправил <a href="https://github.com/django-nose/django-nose/pull/187">пул реквест</a>, возможно, он уже попал в релиз.</p>
<h4>SQL во всех тестах: Django 1.4+ и pytest-django</h4>
<p>В py.test все немного по другому, ведь там не используется стандартный runner из django. Вместо этого для установления тестового окружения можно использовать py.test хуки.</p>
<p>Создаем файл plugin_debug_sql.py, кладем рядом с settings.py, вставляем код:</p>
<pre><code>def pytest_runtest_setup(item):
    from django.db import connections, DEFAULT_DB_ALIAS
    connections[DEFAULT_DB_ALIAS].use_debug_cursor = True
</code></pre>
<p>Запускать так:</p>
<p><code>PYTHONPATH=`pwd`:$PYTHONPATH py.test -s --ds=sql.settings_test -p project.plugin_debug_sql</code></p>
<p>Тут я явно добавляю текущую папку в PYTHONPATH, потому что иначе py.test не сможет найти наш плагин.</p>
</div>






</div></body></html>