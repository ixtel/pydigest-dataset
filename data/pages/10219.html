<html><body><div><div class="post-text" itemprop="text">
<p>you need proper unit testing. I recommend <a href="http://pythontesting.net" rel="nofollow">python-nose</a> - very easy to use.</p>

<p>As for the test vectors I'd recommend using every potential combination of two nodes <em>a</em> and <em>b</em>:</p>

<p>In the case of BSP trees you have 3 types of nodes:</p>

<ol>
<li>leaf node,</li>
<li>1-child node,</li>
<li>2-children node.</li>
</ol>

<p>in combination with the following additional cases:</p>

<ol>
<li><em>a</em> is <em>root</em>, or</li>
<li><em>a</em> is the parent of <em>b</em>,</li>
<li><em>a</em> is <em>not</em> the parent of <em>b</em>.</li>
</ol>

<p>and their combinations as well (also in the symmetric situation).</p>

<p>then after swapping you'll need to check all the nodes involved i.e.:
a,b, children of a and b, parents of a and b if everything went as planned.</p>

<p>I'd do that using a small tree that contains all the types of nodes.
Then go through all possible combinations of the nodes and swap the nodes and check against the expected outcome, and then swap again to bring the tree back to its original state.</p>

<p>[ EDIT ]</p>

<p>If your question was how to avoid all the tedious work. You may consider looking for some well established BSP implementation and compare results with your function. Vectors can be created automatically by using a prepared tree and generating all possible pairs of nodes of this tree.</p>

<p>[/EDIT]</p>

<p>As for the unwanted input to the function. You'll need to use your imagination although in my opinion you have most of the cases covered. Except the one that Austin Hastings mentions where at least on of the input nodes does not belong to the tree.</p>

<p>I found an old version of the same function written for one of my private projects, maybe you can find it useful:</p>

<pre><code>def swap( a, b ):
    if a == b: return
    if a is None or b is None: return
    #if a not in self or b not in self: return

    if b.parent == a:
        a, b = b, a

    #swap connections naively
    a.parent, b.parent = b.parent, a.parent
    a.left, b.left = b.left, a.left
    a.right, b.right = b.right, a.right

    if b.parent == b: #b was the p of a
        b.parent = a

    if a.parent is not None:
        if a.parent.left == b: a.parent.left = a
        else: a.parent.right = a
    else:
        self.root = a

    if b.parent is not None:
        if b.parent.left == a: b.parent.left = b
        else: b.parent.right = b
    else:
        self.root = b

    if a.right is not None: a.right.parent = a
    if a.left is not None: a.left.parent = a
    if b.right is not None: b.right.parent = b
    if b.left is not None: b.left.parent = b
</code></pre>

<p>and performance optimised version:</p>

<pre><code>def swap_opt( a, b ):
    if a == b: return
    if a is None or b is None: return
    #if a not in self or b not in self: return

    if b.p == a:
        a, b = b, a

    #swap connections naively
    a.p, b.p = b.p, a.p
    a.l, b.l = b.l, a.l
    a.r, b.r = b.r, a.r

    if b.p == b: #b was the p of a
        b.p = a
        if a.l == a:
            a.l = b
            if a.r is not None: a.r.p = a
        else:
            a.r = b
            if a.l is not None: a.l.p = a

        if b.r is not None: b.r.p = b
        if b.l is not None: b.l.p = b
        if a.p is not None:
            if a.p.l == b: a.p.l = a
            else: a.p.r = a
        else:
            #set new root to a
            pass

    else:
        if a.r is not None: a.r.p = a
        if a.l is not None: a.l.p = a
        if b.r is not None: b.r.p = b
        if b.l is not None: b.l.p = b

        if a.p is not None:
            if a.p.l == b: a.p.l = a
            else: a.p.r = a
        else:
            #set new root to a
            pass
        if b.p is not None:
            if b.p.l == a: b.p.l = b
            else: b.p.r = b
        else:
            #set new root to b
            pass
</code></pre>

<p>I haven't done proper unit tests for this code - it worked as I expected it to. I was more interested in performance differences between the implementations. 
<code>swap_opt</code> handles neighbouring nodes a bit faster giving it around 5% of speed increase over the compact implementation of <code>swap</code>. [EDIT2] But that depends on the tree used for testing and hardware [/EDIT2]</p>
    </div>
    </div></body></html>