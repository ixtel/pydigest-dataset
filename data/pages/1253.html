<html><body><div><div class="post-content">
        <p>A few weeks ago, I released a simple Django app to manage models for <a class="reference external" href="http://readthedocs.org/docs/django-propaganda/en/latest/">simple newsletters</a>. The package itself is blatantly useless if we do not use it on a project that integrates with other parts, so I created a fully-equipped system that can create propaganda, assign it to subscribers and queue it ready to be sent whenever I need to.</p>
<h2>The architecture</h2>
<p>First, I have been using <a class="reference external" href="http://aws.amazon.com/ses/">Amazon SES</a> for a while to send newsletters to customers, both in-house and for clients and third-parties. It removes the <strong>hassle of maintaining SMTPs, email server management, network configuration, and meeting rigorous Internet Service Provider (ISP) standards for email content</strong>. So we will take profit of all those advantages, and make our life more simple and enjoyable.</p>
<p>Second, we want a smooth and efficient delivery through <strong>concurrent background tasks</strong>, seamless for the user and detached from the front-end business logic. Whenever we press the "send" button we expect the system to return a confirmation response immediately — regardless of what's happening in the background — instead of getting the request frozen, waiting too much time for the email queue to be emptied and ending up with a web server timeout response. <a class="reference external" href="http://celeryproject.org/">Celery</a> is one of the most used solutions on the Python and Django world that allows <strong>asynchronous task queue/job queue based on distributed message passing</strong>.</p>
<p>Last, but not least, because <strong>we love Django and Python</strong>, we will be using different libraries and Django apps that will allow us to build our stuff nicely.</p>
<h2>Python and Django Requirements</h2>
<p>Below is a list of packages, Python libraries and Django apps we will need to install (using <tt class="docutils literal">Pip</tt> on most cases) and configure following the instructions provided on every case. I, therefore, <strong>don't provide such instructions</strong>.</p>
<h3>django-celery</h3>
<p><a class="reference external" href="https://github.com/ask/django-celery">This app</a> provides Celery integration for Django. <tt class="docutils literal">Celery</tt> is automatically installed as a dependency.</p>
<h3>django-seacucumber</h3>
<p><a class="reference external" href="https://github.com/hmarr/django-ses">django-ses</a> is key to consume the Amazon SES API exposed, in turn, by another Python package, <a class="reference external" href="https://github.com/boto/boto">Boto</a> (automatically installed as a dependency as well). On this tutorial, though, we will be using <a class="reference external" href="https://github.com/duointeractive/sea-cucumber">django-seacucumber</a>, an application that integrates <tt class="docutils literal"><span class="pre">django-ses</span></tt> with <tt class="docutils literal"><span class="pre">django-celery</span></tt>, so that email sent from our platform will be routed through Amazon SES via Celery. How cool is that?</p>
<h3>django-mailer</h3>
<p>This old and <a class="reference external" href="https://github.com/jtauber/django-mailer">well-known application</a> will be in charge of queuing our email and having it ready to be delivered once the time arrives.</p>
<h3>django-propaganda (optional)</h3>
<p>This <a class="reference external" href="https://github.com/nabucosound/django-propaganda">django simple newsletters</a> app takes care of handling our content (Propaganda model) and scheduled delivery (Pamphlets model) to our subscribers (Subscribers model). You can also choose among a wide range of <a class="reference external" href="http://djangopackages.com/grids/g/newsletter/">solutions</a> or write your own.</p>
<h2>Non Python-related Requirements</h2>
<p>Below is a list of non Python-related software we will need to install (using package managers like <em>apt-get</em> for Debian-based systems or <em>homebrew</em> on OSX-based systems, on most cases) and configure following the instructions provided on every documentation. Again, I don't provide such instructions.</p>
<h3>Message broker</h3>
<p><a class="reference external" href="http://celery.readthedocs.org/en/latest/getting-started/brokers/rabbitmq.html">RabbitMQ</a> is the default broker for Celery and the one I have used so far, and I have no complaints at the moment.</p>
<h3>Supervisor</h3>
<p><a class="reference external" href="http://supervisord.org/">Supervisor</a> (also know as <em>supervisord</em>) is my chosen method to daemonize and run Celery on production systems. Basically because I can run multiple instances of Celery — one for each Django project running on a same machine — and restart processes selectively.</p>
<h2>Project configuration</h2>
<p>I am providing here what I considered a minimum configuration to integrate all the parts into a project aiming the purpose of this post.</p>
<h3>Settings</h3>
<p>These are the Django settings you should have:</p>
<pre class="literal-block">
# Append to your existing apps
INSTALLED_APPS = (
        ...
    'propaganda',
    'mailer',
    'djcelery',
    'seacucumber',
        ...
)

# Route email through Amazon SES via Celery
EMAIL_BACKEND = 'seacucumber.backend.SESBackend'
MAILER_EMAIL_BACKEND = 'seacucumber.backend.SESBackend'

# Log in to Amazon SES and get these
AWS_ACCESS_KEY_ID = 'your_key_id'  # Amazon Simple Email Services key ID
AWS_SECRET_ACCESS_KEY = 'your_access_key'  # Amazon Simple Email Services access key

# Must be an email authorized on Amazon SES
DEFAULT_FROM_EMAIL = 'youremail@example.com'

# Celery loader
import djcelery
djcelery.setup_loader()

# Default broker settings, change it if you need to
BROKER_HOST = "localhost"
BROKER_PORT = 5672
BROKER_USER = "guest"
BROKER_PASSWORD = "guest"
# Make sure this is unique on production systems with more than one
# Celery project using the same RabbitMQ instance
BROKER_VHOST = "/"
</pre>
<h3>Celery task</h3>
<p>Assuming you have done your homework and have your project queuing emails on <tt class="docutils literal"><span class="pre">django-mailer</span></tt>, let's create a tiny task on a <tt class="docutils literal">tasks.py</tt> file that will make the final delivery asynchronous, so we can call it from any part of our code:</p>
<pre class="literal-block">
from celery.task import task

@task()
def send_queued_emails(*args, **kwargs):
    from mailer.engine import send_all
    send_all()
</pre>
<h2>Deployment</h2>
<p>This is the <tt class="docutils literal">celeryd.conf</tt> settings file I load to get Celery running via supervisord:</p>
<pre class="literal-block">
[program:mailing_prj__celery]
; Using virtualenv, as any reasonable python developer
command=/path/to/virtualenv/prj/bin/python /path/to/prj/manage.py celeryd -B -E -l info
directory=/path/to/prj/
numprocs=1
; Like to keep stdout and stderr on same log
stdout_logfile=/path/to/prj/logs/celeryd.log
stderr_logfile=/path/to/prj/logs/celeryd.log
autostart=true
autorestart=true
startsecs=10

; Need to wait for currently executing tasks to finish at shutdown.
; Increase this if you have very long running tasks.
stopwaitsecs = 600

; if rabbitmq is supervised, set its priority higher
; so it starts first
priority=998

; If supervisord is run as root, we could subprocess with another user
user=your_virtualenv_user
</pre>
<p>On our supervisord configuration file, load the configuration file above:</p>
<pre class="literal-block">
[include]
files = /path/to/celeryd.conf
</pre>
<p>Run supervisord and, <em>voilà!</em>, you can start sending emails asynchronously. Who needs MailChimp, Sendgrid or Campaign Monitor?</p>
      </div>

      </div></body></html>