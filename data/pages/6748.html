<html><body><div><div class="content">
				    <p class="big">MBSP is a text analysis system based on the <a href="http://ilk.uvt.nl/timbl/" target="_self">TiMBL</a> and <a href="http://ilk.uvt.nl/mbt/" target="_self">MBT</a> memory based learning applications developed at CLiPS and <a href="http://ilk.uvt.nl/" target="_self">ILK</a>. It provides tools for Tokenization and Sentence Splitting, Part of Speech Tagging, Chunking, Lemmatization, Relation Finding and Prepositional Phrase Attachment.</p>
<p>The general English version of MBSP has been trained on data from the Wall Street Journal corpus.</p>
<p><img src="/media/MBSP_schema.gif" alt="MBSP_schema"/></p>
<p> </p>
<hr/>
<h2>Download</h2>
<table>
<tbody>
<tr>
<td><a href="/media/MBSP_1.4.zip" target="_self"><img src="/sites/all/themes/clips/g/download.gif" alt="download" align="left"/></a></td>
<td><strong>MBSP for Python (1.4)</strong> | <a href="/media/MBSP_1.4.zip" target="_self">download</a> (.zip, 24MB)<br/>
<ul>
<li>Requires: Python 2.5+ on Unix | Mac | Cygwin.</li>
<li>Licensed under <a href="http://www.gnu.org/licenses/gpl.html" target="_self">GPL</a></li>
<li>Releases: <a href="/media/MBSP_1.4.zip">1.4</a> | <a href="/media/MBSP_1.3.zip">1.3</a> | <a href="/media/MBSP_1.2.zip">1.2</a> | <a href="/media/MBSP_1.1.zip" target="_self">1.1</a></li>
<li>Authors:<br/>Vincent Van Asch (<em>vincent.vanasch at uantwerpen.be</em>),<br/>Tom De Smedt (<em>tom at organisms.be</em>)</li>
</ul>
<p class="small"><span>Reference</span>: Daelemans, W., &amp; Van den Bosch, A. (2005). <br/><em>Memory-based language processing</em>. Cambridge University Press, Cambridge, UK.<br/>ISBN-13: 9780521808903 | ISBN-10: 0521808901</p>
<p class="small"><span class="grey">SHA256</span><span class="grey"> checksum of the .zip:</span><br/><span class="grey">62be10ece640404058b607d9f15493a2a98d55b7e3a3d9becc6ed5854fa800bc</span> </p>
</td>
<td><a class="twitter-share-button" href="http://twitter.com/share" data-url="http://bit.ly/shallowparser" data-text="Memory-based shallow parser for Python." data-count="none">Tweet</a>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2>Documentation</h2>

<p> </p>
<hr/>
<h2><a title="introduction" name="introduction"/>Introduction</h2>
<h3>Quick overview</h3>
<p>MBSP parses a string of characters into words and sentences, and determines the grammatical structure of the sentence. It is a Python module, so you'll need <a href="http://www.python.org/download/" target="_self">Python</a> to run it (already installed on Mac OS X).</p>
<p>The module uses a client-server architecture for performance. It includes binaries (<a href="http://ilk.uvt.nl/timbl/" target="_self">TiMBL</a>, <a href="http://ilk.uvt.nl/mbt/" target="_self">MBT</a> and <a href="http://ilk.uvt.nl/mbma/" target="_self">MBLEM</a>) precompiled for Mac OS X, so on Mac it works out-of-the-box. Otherwise, if you're on a Unix system, the module has a setup.py file that should compile everything for you. Go to the terminal and type:</p>
<pre class="brush:python; gutter:false; light:true;">&gt; cd MBSP
&gt; python setup.py</pre><p>If that doesn't work you'll need to follow the steps in the <a href="/pages/MBSP#installation" target="_self">installation instructions</a>.</p>
<p>Put the MBSP folder in the same folder as your Python script and import the module. By default, the servers are configured to start automatically. Once they are up and running you can use the <span class="inline_code">parse()</span> command to analyze texts:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; import MBSP
&gt;&gt;&gt; print MBSP.parse('cats with hats') 

cats/NNS/I-NP/O/O/A1/cat with/IN/I-PP/B-PNP/O/P1/with hats/NNS/I-NP/I-PNP/O/P1/hat</pre></div>
<p>Each word has been <em>tagged</em> with grammatical information. For example, MBSP determined that <em>cats</em> is a plural noun (<span class="postag">NNS</span>). It has a prepositional noun phrase (<span class="postag">PNP</span>) attached to it (<span class="postag">A1</span> is the anchor of <span class="postag">P1</span>), so the <em>hats</em> go <em>with</em> the <em>cats</em>. For a human this might seem pretty straightforward, but consider that without any analysis, for a machine the sentence is just a sequence of characters with no meaning.</p>
<p>The tag codes may seem cryptic at first, but consider that it is more concise to say <span class="postag">NNS</span> than <span class="postag">PLURAL NOUN</span> over and over. The tag codes are common in natural language processing, it's a good idea to <a href="/pages/MBSP-tags" target="_self">get acquainted with them</a>. </p>
<p>Something went wrong? Probably the servers didn't have enough time to start:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; MBSP.start(timeout=120)
&gt;&gt;&gt; print MBSP.parse('cats with hats')</pre></div>
<p>The output of the <span class="inline_code">parse()</span> command is a tagged string that can be manipulated in many ways. <br/>With the <span class="inline_code">split()</span> command it can be transformed into a tree of linked Python objects:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; s = MBSP.parse('black cats with striped hats')
&gt;&gt;&gt; s = MBSP.split(s)
&gt;&gt;&gt; for sentence in s:
&gt;&gt;&gt;     for chunk in sentence.chunks:
&gt;&gt;&gt;         print [word.lemma for word in chunk.words], chunk.attachments

[u'black', u'cat'] [Chunk('with striped hats/PNP')]
[u'with'] []
[u'striped', u'hat'] []</pre></div>
<p>With the <span class="inline_code">xml()</span> command it can be transformed into an <a href="http://en.wikipedia.org/wiki/XML" target="_self">XML</a> string for processing outside of Python:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; s = parse('black cats with striped hats')
&gt;&gt;&gt; print xml(s) 
</pre></div>
<h3>Purpose</h3>
<p>MBSP stands for "Memory-Based Shallow Parser". <a href="/pages/mbsp-shallow-parsing">Shallow parsing</a> (i.e. automatic discovery of a sentence constituents) is an important component of many text analysis systems, in applications such as information extraction and summary generation. The Memory-Based Learning (MBL) approach has the advantage of avoiding the need for manual definition of patterns (for example, using regular expression syntax) and of being reusable across different corpora and sublanguages.</p>
<p>MBSP is a so-called <em>lazy learner</em>: it keeps all the initial training data available (including exceptions which may sometimes be productive). This technique has been shown to achieve higher accuracy than <em>eager</em> (or <em>greedy</em>) methods for many language processing tasks. For the Wall Street Journal corpus (WSJ), accuracy (Fβ=1) is 96.4% for part-of-speech tagging, 93.8% for <span class="postag">NP</span> chunking, 94.7% for <span class="postag">VP</span> chunking, 77.1% for <span class="postag">SBJ</span> detection, 79.0% for <span class="postag">OBJ</span> detection, and 82.7% for <span class="postag">PP</span>-attachment. MBSP is based on the IB1-IG and IGT<span class="smallcaps">REE</span> algorithms bundled in our MBL software package, called TiMBL.</p>
<p class="small"><span>Reference</span>: Daelemans, W., Buchholz, S., &amp; Veenstra, J. (1999).  <br/><em>Memory-Based Shallow Parsing</em>. In: Proceedings of CoNLL, Bergen, Norway.</p>
<p>The parser provides functionality for tokenization and sentence splitting, part-of-speech tagging, chunking, relation finding, prepositional phrase attachment and lemmatization.</p>
<ul>
<li><strong>Tokenization</strong>: splits sentence periods and punctuation marks from words.</li>
<li><strong>Tagging</strong>: assigns part-of-speech tags to words (e.g. <em>cat</em> → noun → <span class="postag">NN</span>, <em>eat</em> → verb → <span class="postag">VB</span>).</li>
<li><strong>Chunking</strong>: assigns chunk tags to groups of words (e.g. <em>the black cat</em> → noun phrase → <span class="postag">NP</span>).</li>
<li><strong>Relation finder</strong>: finds relations between chunks, sentence subject, object and predicates.</li>
<li><strong>PNP finder</strong>: finds prepositional noun phrases (e.g. <em>under the table</em>).</li>
<li><strong>PP-attachment</strong>: finds prepositional noun phrase anchors (e.g. <em>eat pizza</em> → <em>with fork</em>).</li>
<li><strong>Lemmatization</strong>: finds word lemmata (e.g. <em>was</em> → <em>be</em>).</li>
</ul>
<h3>Grammar basics</h3>
<p>Sentences are made up of words. Words have a syntactic role (noun, verb, adjective, ...) depending on their location in the sentence. For example, <em>can</em> can be a verb or a noun, depending on the context (<em>the can</em>, <em>I can</em>).</p>
<ul>
<li><strong>Sentence</strong>: the basic unit of writing, expected to have a subject and a predicate.</li>
<li><strong>Word</strong>: a string of characters that expresses a meaningful concept.</li>
<li><strong>Token</strong>: a specific word with grammatical tags: <em>the can</em>/<span class="postag">NN</span>, <em>I can</em>/<span class="postag">VB</span>.</li>
<li><strong>Chunk</strong>: a group of words (phrase) that contains a single thought (e.g. <em>a sumptuous banquet</em>).</li>
<li><strong>Head</strong>: the word that determines the syntactic type of the chunk: <em>the black <span>cat</span> </em>→ <span class="postag">NP</span>.</li>
<li><strong>Subject</strong>: the person/thing <em>doing</em> or <em>being</em>, usually a noun phrase (<span class="postag">NP</span>): <em><span>the cat</span> is black</em>.</li>
<li><strong>Predicate</strong>: the remainder of the sentence tells us what the subject does: <em>the cat <span>sits on the mat</span></em>.</li>
<li><strong>Clause</strong>: subject + predicate.</li>
<li><strong>Argument</strong>: a chunk that is related to a verb in a clause, i.e. subject and object.</li>
<li><strong>Object</strong>: the person/thing affected by the action: <em>the cat eats <span>fish</span></em>. Poor fish.</li>
<li><strong>Preposition</strong>: temporal, spatial or logical relationship: <em>the cat sits <span>on the mat</span></em>.</li>
<li><strong>Copula</strong>: a word used to link subject and predicate, typically the verb <em>to be</em>.</li>
<li><strong>Lemma</strong>: canonical form of a word: <em>run</em>, <em>runs</em>, <em>running</em> are part of a lexeme, <em>run</em> is the lemma.</li>
<li><strong>POS</strong>: part-of-speech, the syntactic role that a word or phrase plays in a sentence, e.g. adjective = <span class="postag">JJ</span>.</li>
</ul>
<h3>Acknowledgements</h3>
<p>This version of MBSP has been developed by the computational linguistics group of CLiPS (Computational Linguistics &amp; Psycholinguistics, department of Linguistics, University of Antwerp, Belgium) on the basis of earlier versions developed at the University of Antwerp and Tilburg University.</p>
<p>Contributing authors: Walter Daelemans, Jakub Zavrel, Sabine Buchholz, Jorn Veenstra, Antal van den Bosch, Ko van der Sloot, Bertjan Busser, Erik F. Tjong Kim Sang, Jo Meyhi, Vincent Van Asch, Tom De Smedt. </p>
<p>For reference you can use:<br/><span class="small">De Smedt T., Van Asch V. &amp; Daelemans, W. (2010). <em>Memory-based Shallow Parser for Python</em>.<br/>CLiPS Technical Report Series (CTRS), vol. 2. ISSN <span>2033-3544. [<a href="/sites/default/files/ctrs-002.pdf">PDF</a>]</span></span></p>
<p> </p>
<hr/>
<h2><a title="installation" name="installation"/>Installation</h2>
<p>MBSP is a <a href="http://www.python.org/download/" target="_self">Python</a> module. On Mac OS X, the Python programming language is already installed. On other systems you need to download and install it yourself, if necessary. MBSP works with Python 2.5, but support for processes is better in version 2.6. It should also work with version 2.4.</p>
<p>MBSP is bundled with three required dependencies written in C/C++ (TiMBL 6.1.5, MBT 3.1.3 and MBLEM). Binaries have been precompiled for Mac OS X 10.5, but these may not work on your machine. In that case you need to compile binaries manually from the source code.</p>
<h3>Compiling with setup.py</h3>
<p>The module comes with a <span class="inline_code">setup.py</span> script that compiles the C/C++ binaries automatically. If this works for you, you're in luck – no manual compilation is necessary. Also, if you run <span class="inline_code">setup.py</span> with the <span class="inline_code">install</span> argument, it will first compile the binaries and then install a copy of MBSP in Python's <span class="inline_code">/site-packages</span> folder so that the module is available in any Python script.</p>
<pre class="brush:python; gutter:false; light:true;">&gt; cd MBSP
&gt; python setup.py install
</pre><h3>Compiling from source</h3>
<p> You'll need a <a href="http://gcc.gnu.org/" target="_self">gcc</a> compiler. On Windows you'll need <a href="http://www.cygwin.com/" target="_self">cygwin</a>. <br/>In the cygwin installer (<span class="inline_code">setup.exe</span>), be sure to select the "<span class="inline_code">devel</span>" packages for installation.</p>
<p class="smallcaps">Building MBLEM</p>
<ul>
<li>Go to the <span class="inline_code">MBSP/mblem</span> folder.</li>
<li>Delete all files with a "<span class="inline_code">.o</span>" extension + the current executable binary <span class="inline_code">mblem_english_bmt</span>.  </li>
<li>From the command line, do <span class="inline_code">make</span> in the <span class="inline_code">MBSP/mblem</span> folder:</li>
</ul>
<pre class="brush:python; gutter:false; light:true;">&gt; cd MBSP/mblem
&gt; make
</pre><p class="smallcaps">Building TiMBL</p>
<ul>
<li>Go to the <span class="inline_code">MBSP/timbl</span> folder.</li>
<li>Uncompress the source code from the <span class="inline_code">timbl-6.1.5.tar</span> archive.</li>
<li>From the command line, do <span class="inline_code">configure</span> and <span class="inline_code">make</span> in the <span class="inline_code">MBSP/timbl/timbl-6.1.5</span> folder:</li>
</ul>
<pre class="brush:python; gutter:false; light:true;">&gt; cd MBSP/timbl/timbl-6.1.5
&gt; ./configure --enable-shared=no --enable-static=no --prefix=[FOLDER]
&gt; make install</pre><ul>
<li><span class="inline_code">[FOLDER]</span> is an absolute path to the folder where Timbl will be built.</li>
<li>The Timbl executable will be in <span class="inline_code"><span class="smallcaps">[FOLDER]</span>/bin</span> → copy it to <span class="inline_code">MBSP/timbl</span>.</li>
<li>Now build MBT in the same <span class="smallcaps inline_code">[FOLDER]</span> location:</li>
</ul>
<p><span class="smallcaps">Building MBT</span></p>
<ul>
<li>Go to the <span class="inline_code">MBSP/mbt </span>folder.</li>
<li>Uncompress the source code from the <span class="inline_code">mbt-3.1.3.tar</span> archive.</li>
<li>From the command line, do <span class="inline_code">configure</span> and <span class="inline_code">make</span> in the <span class="inline_code">MBSP/mbt/mbt-3.1.3</span> folder: </li>
</ul>
<pre class="brush:python; gutter:false; light:true;">&gt; cd MBSP/mbt/mbt-3.1.3
&gt; ./configure --enable-shared=no --enable-static=no --prefix=[FOLDER]
&gt; make install
</pre><ul>
<li>The Mbt executable will be in <span class="inline_code"><span class="smallcaps">[FOLDER]</span>/bin</span> → copy it to <span class="inline_code">MBSP/mbt</span>.</li>
<li>Delete the build <span class="smallcaps inline_code">[FOLDER]</span>, it is no longer needed.</li>
</ul>
<h3>Module folder location</h3>
<p>To be able to <span class="inline_code">import MBSP</span> in your scripts, Python needs to know where the module is located. <br/>There are three basic ways to accomplish this:</p>
<ul>
<li>Put the MBSP folder in the same folder as your script.</li>
<li>Put the MBSP folder in the standard location for modules so it is available to <em>all</em> scripts.<br/>The standard location depends on your operating system, for example:<br/><span class="inline_code">/Library/Python/2.5/site-packages/</span> on Mac,<br/><span class="inline_code">/usr/lib/python2.5/site-packages/</span> on Unix,<br/><span class="inline_code">c:\python25\Lib\site-packages\ </span>on Windows.<span class="inline_code"><br/></span></li>
<li>Add the location of MBSP to the <span class="inline_code">sys.path</span> list in your script, before importing it:</li>
</ul>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; MODULE = '/users/tom/desktop/MBSP'
&gt;&gt;&gt; import sys; if MODULE not in sys.path: sys.path.append(MODULE)
&gt;&gt;&gt; import MBSP</pre></div>
<h3>Memory usage</h3>
<p>MBSP starts four data servers that require quite a bit of memory (<span class="inline_code">CHUNK</span>: 80MB, <span class="inline_code">LEMMA</span>: 10MB, <span class="inline_code">RELATION</span>: 160MB, <span class="inline_code">PREPOSITION</span>: 210MB). Only the <span class="inline_code">CHUNK</span> server (which gives you the part-of-speech tags) is mandatory. The optional servers can be disabled in <span class="inline_code">config.py</span> to reduce the memory usage, for example:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">servers = ['chunk', 'lemma']</pre></div>
<h3>Multithreading</h3>
<p>MBSP can be configured to work with multithreading, which can increase performance by 25% - 200%. <span class="inline_code">MBSP.config.threading</span> needs to be set to <span class="inline_code">True</span>. You also need to build the newer TiMBL 6.3+, MBT 3.2+ and TimblServer 2+ from <a href="http://ilk.uvt.nl/" target="_blank">source</a>. The installation instructions are mostly the same:</p>
<ul>
<li>TimblServer can be compiled in the same way as MBT.</li>
<li>Put the <span class="inline_code">TimblServer</span> executable in <span class="inline_code">MBSP/timbl</span> instead of the <span class="inline_code">Timbl</span> executable.</li>
</ul>
<p>Older systems may complain that <span class="inline_code">pkg-config</span> is outdated. In this case, before building Timbl, compile pkg-config 0.25+ (<a href="http://pkgconfig.freedesktop.org">http://pkgconfig.freedesktop.org</a>) from source with: <span class="inline_code">sudo ./configure; sudo make; sudo make install</span></p>
<p>We have precompiled versions of TimblServer which may also work on your system (in that case you don't need to install from source): download for <a href="/media/MBSP-TimblServer1.0.0-OSX10.5.zip">Mac OS X 10.5</a> | <a href="/media/MBSP-TimblServer2.0.0-Ubuntu10.04.zip">Ubuntu 10.04 (64-bit)</a>.</p>
<p> </p>
<hr size="parser" name="parser"/>Parser</h2>
<p>MBSP uses a client-server architecture. This way, the corpus data is loaded only once (during server startup) and stays available while the servers sleep in the background. Before tagging jobs can be sent to the parser, the servers have to be started. By default, this will happen automatically when you import MBSP in your script. Otherwise, the <span class="inline_code">start()</span> command starts the four servers (named <span class="inline_code">CHUNK</span>, <span class="inline_code">LEMMA</span>, <span class="inline_code">RELATION</span> and <span class="inline_code">PREPOSITION</span>). The <span class="inline_code">started()</span> command yields True if a given server has been started. The <span class="inline_code">stop()</span> command will stop the servers.</p>
<pre class="brush:python; gutter:false; light:true;">MBSP.start(timeout=60)</pre><pre class="brush:python; gutter:false; light:true;">MBSP.started(name=ALL) # CHUNK | LEMMA | RELATION | PREPOSITION 
</pre><pre class="brush:python; gutter:false; light:true;">MBSP.stop() 
</pre><p>The <span class="inline_code">parse()</span> command takes a string of sentences and returns a tagged Unicode string. <br/>Sentences in the output are separated by newline characters.</p>
<pre class="brush:python; gutter:false; light:true;">MBSP.parse(string, 
     tokenize = True, 
         tags = True, 
       chunks = True, 
    relations = True, 
      anchors = True, 
      lemmata = True, 
     encoding = 'utf-8')</pre><p>For example:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; print MBSP.parse('I ate pizza with a fork.')

I/PRP/I-NP/O/NP-SBJ-1/O/i 
ate/VBD/I-VP/O/VP-1/A1/eat 
pizza/NN/I-NP/O/NP-OBJ-1/O/pizza 
with/IN/I-PP/B-PNP/O/P1/with 
a/DT/I-NP/I-PNP/O/P1/a 
fork/NN/I-NP/I-PNP/O/P1/fork ././O/O/O/O/. 
</pre></div>
<p>Each token (i.e. tagged word) in a sentence has a number of annotations: <span class="inline_code">tags</span><span class="inline_code">=True</span> includes the word part-of-speech tag, <span class="inline_code">chunks</span> the chunk tag + <span class="postag">PNP</span> tag (prepositional noun phrase), <span class="inline_code">relations</span> the chunk relation tag, <span class="inline_code">anchors</span> the <span class="postag">PNP</span> anchor tag. With <span class="inline_code">tokenize</span> set to False, no tokenization is carried out (so the input string is expected to be tokenized). The <span class="inline_code">encoding</span> parameter defines the character encoding of the input string, "utf-8" is fine in most cases.</p>
<h3>Parser tags</h3>
<p>Let's examine the word <em>ate</em> and the tags assigned by the parser in the example above:</p>
<table class="border">
<tbody>
<tr>
<td class="smallcaps" align="center">word</td>
<td class="smallcaps" align="center">part-of-speech</td>
<td class="smallcaps" align="center">chunk</td>
<td class="smallcaps" align="center">pnp</td>
<td class="smallcaps" align="center">relation</td>
<td class="smallcaps" align="center">anchor</td>
<td class="smallcaps" align="center">lemma</td>
</tr>
<tr>
<td align="center">ate</td>
<td align="center"><span class="postag">VBD </span></td>
<td align="center"><span class="postag">I-VP</span></td>
<td align="center"><span class="postag">O</span></td>
<td align="center"><span class="postag">VP-1</span></td>
<td align="center"><span class="postag">A1</span></td>
<td align="center">eat</td>
</tr>
</tbody>
</table>
<p>The word's part-of-speech tag is <span class="postag">VBD</span>, which means that it is a verb in the past tense. The word occurs in a <span class="postag">VP</span> chunk, a verb phrase. It is not part of a prepositional noun phrase. It's relation tag is <span class="postag">VP-1</span>, which means it is linked to the words tagged as <span class="postag">NP-SBJ-1</span> (<em>I</em>, the sentence subject) and <span class="postag">NP-OBJ-1</span> (<em>pizza</em>, the sentence object). Its anchor tag is <span class="postag">A1</span>, meaning it is the anchor of the prepositional noun phrase <span class="postag">P1</span>, <em>with a fork</em>. How did I eat pizza? → with a fork. The base form or lemma of <em>ate</em> is <em>eat</em>.</p>
<p>Common part-of-speech tags include <span class="postag">NN</span> (noun), <span class="postag">JJ</span> (adjective) and <span class="postag">VB</span> (verb).<br/>Common chunk tags include <span class="postag">NP</span> (noun phrase) and <span class="postag">VP</span> (verb phrase).<br/>Common relations include <span class="postag">SBJ</span> (subject) and <span class="postag">OBJ</span> (object).</p>
<p>The <a href="/pages/MBSP-tags" target="_self">MBSP tags</a> page gives an overview of all the possible tags generated by the parser.</p>
<p>A description and an example can also be acquired with the <span class="inline_code">taginfo()</span> command:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; description, example = MBSP.taginfo('NN')
&gt;&gt;&gt; print description, example

('noun, singular or mass', 'tiger, chair, laughter')
</pre></div>
<h3>Parser shortcuts</h3>
<p>Below is a set of concise commands that internally call <span class="inline_code">parse()</span> with the required parameters.</p>
<ul>
<li>The <span class="inline_code">tag()</span> command returns a string annotated with part-of-speech tags.</li>
<li>The <span class="inline_code">chunk()</span> command returns a string annotated with part-of-speech, chunk and <span class="postag">PNP</span> tags. </li>
<li>The <span class="inline_code">lemma()</span> command takes a single word and returns its lemma.</li>
<li>The <span class="inline_code">nouns()</span>, <span class="inline_code">verbs()</span> or <span class="inline_code">adjectives()</span> <span class="inline_code"> </span> command returns a list of nouns, verbs or adjectives retrieved from the given string.</li>
</ul>
<pre class="brush:python; gutter:false; light:true;">MBSP.tokenize(string)</pre><pre class="brush:python; gutter:false; light:true;">MBSP.tag(string, tokenize=True, lemmata=False)</pre><pre class="brush:python; gutter:false; light:true;">MBSP.chunk(string, tokenize=True, lemmata=False)</pre><pre class="brush:python; gutter:false; light:true;">MBSP.lemma(word) 
</pre><pre class="brush:python; gutter:false; light:true;">MBSP.nouns(string, lemmatize=False)
MBSP.verbs(string, lemmatize=False) 
MBSP.adjectives(string, lemmatize=False) 
</pre><p>Like <span class="inline_code">parse()</span>, all of these commands have an optional <span class="inline_code">encoding</span> parameter that is "utf-8" by default. </p>
<h3>Parser output</h3>
<p>The output of the <span class="inline_code">parse()</span> command is a string of sentences in which each token has been annotated with the requested tags. The <span class="inline_code">pprint()</span> command (extra <em>p</em> is for <em>pretty</em>) gives a good overview of the tags:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; s = MBSP.parse('I eat pizza.')
&gt;&gt;&gt; MBSP.pprint(s) 

    WORD   TAG    CHUNK   ROLE   ID     PNP    ANCHOR   LEMMA
       I   PRP    NP      SBJ    1      -      -        i   
     eat   VBP    VP      -      1      -      -        eat         
   pizza   NN     NP      OBJ    1      -      -        pizza         
       .   .      -       -      -      -      -        .        </pre></div>
<p>The output string is in fact a <span class="inline_code">TokenString</span> object that behaves as a Python string, but with extra functionality. Most notably it has a <span class="inline_code">TokenString.split()</span> method that yields a <span class="inline_code">TokenList</span> object: a list of sentences, where each sentence is a list of tokens, in which each token is a list of tags. This is useful when you want to <a href="/pages/MBSP#customization" target="_self">extend the parser</a> and need to make some modifications to the output.</p>
<p>If you want to analyze the output (i.e. examine the relations between words and groups of words), it is more convenient to construct a <a href="/pages/MBSP#tree" target="_self">parse tree</a> from the output.</p>
<p> </p>
<hr/>
<h2><a title="tokenizer" name="tokenizer"/>Tokenizer</h2>
<p>MBSP includes a regular expressions-based tokenizer that divides sequences of characters into words and sentences. Special care is given to punctuation marks. We need to guess which punctuation marks are part of a word (e.g. periods in abbreviations) and which mark word and sentence breaks. Once tokenized, the <a href="/pages/MBSP#parser" target="_self">parser</a> can then determine categories for words (tokens) in the string.</p>
<pre class="brush:python; gutter:false; light:true;">MBSP.tokenizer.split(string, tags=False, citations=False, replace={}, ignore=[])</pre><p>The <span class="inline_code">split()</span> command returns a list of Unicode strings where punctuation marks have been split from words as individual tokens. Each string in the list is a sentence. By default, all SGML-tags (i.e. anything wrapped in &lt;...&gt;) are stripped from the input string. With <span class="inline_code">citations=True</span>, sentences in quoted citations are kept together. The <span class="inline_code">replace</span> dictionary is used to map unicode quotes and ellipsis to standard quotes and periods. The <span class="inline_code">ignore</span> list defines ranges of words that require special attention (for example, abbreviations and URL's – see below).</p>
<p>For example:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; MBSP.tokenizer.split('The U.N. is considering banning 
 "defamation of religion." The U.N. president said such a move 
 would not limit free speech.')

[u'The U.N. is considering banning " defamation of religion . "', 
 u'The U.N. president said such a move would not limit free speech .']
</pre></div>
<h3>Tokenization process</h3>
<p>In the simplest case, words are marked by spaces. A number of exceptions are then handled:</p>
<ul>
<li><strong>Handle missing space</strong>: punctuation inside a word can indicate a missing space.</li>
<li><strong>Handle punctuation</strong>: punctuation marks at the head or tail of a word can indicate a sentence break, the start of a citation, the start of an explanation in parenthesis. In this case the punctuation is split from the word. Punctuation that is part of the word (e.g. <em>5p.m.</em>) needs to be kept intact.</li>
<li><strong>Handle contractions</strong>: apostrophes in contractions (<em>he's</em>) and possessives (<em>father's</em>) mark word boundaries. The suffix is split from the word.</li>
<li><strong>Handle lists</strong>: list item markers such as <em>1. 1) * - a. a)</em> at the start of a new line indicate the start of a new sentence, even if the previous sentence did not end with a period.</li>
<li><strong>Handle hyphenation</strong>: hyphens at the end of a line mark words that have been split across lines: <em>mar-</em> + <em>ket</em> becomes <em>market</em>, <em>Great-</em> + <em>Britain</em> becomes <em>Great-Britain</em>.</li>
<li><strong>Handle sentence breaks</strong>: periods, exclamation marks, question marks and ellipsis end a sentence if they are followed by a capitalized letter. Parenthesis and quotes can be part of the sentence even if the period precedes it.</li>
</ul>
<h3>Tokenizer word ranges</h3>
<p>The tokenizer defines a <span class="inline_code">Range</span> class for matching sets of words: all abbreviations, all numeric strings, all hyperlinks, etc. The <span class="inline_code">Range</span> class is a list of known words enriched with regular expression patterns. In the example below, an abbreviation range is created that matches <em>U.K.</em>, <em>U.N.</em> and any single letter abbreviation (as in <em>T. De Smedt</em>).</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; abbreviations = MBSP.tokenizer.Range(['U.K.', 'U.N.'])
&gt;&gt;&gt; abbreviations.patterns.append(re.compile('^[A-Za-z]\.$'))
&gt;&gt;&gt; print 'U.K.' in abbreviations, 'T.' in abbreviations

True True
</pre></div>
<p>Custom ranges can be passed to the <span class="inline_code">ignore</span> parameter of the <span class="inline_code">split()</span> command. <br/>By default, <span class="inline_code">split()</span> will use a list of predefined ranges:</p>
<pre class="brush:python; gutter:false; light:true;">MBSP.tokenizer.ignore = [abbreviations, numeric, URI, entities, biomedical] </pre><p>Predefined ranges:</p>
<ul>
<li><strong>Abbreviations</strong>: the simple rule is that every point is a sentence break. This is 93.2% correct for Brown corpus [<a href="http://bulba.sdsu.edu/~malouf/ling571/13-token-bw.pdf" target="_self">1</a>]. Fixing decimal points, single letter abbreviations, alternating letters and capital letter followed by consonants (<em>Dept.</em>) improves sentence break correctness to 97.7%. Additionally, the abbreviations range defines a list of other well-known abbreviations.</li>
<li><strong>Numeric</strong>: matches anything starting with a digit followed by a chain of digits and .,:/ separators. The range will also recognize units of measurement (length, mass, volume, time, epoch, temperature, storage capacity, data transfer rate, percentage): US$100, 1.2MB, 31/12/2010, ...</li>
<li><strong>URI</strong>: matches URL's, links and e-mail addresses.</li>
<li><strong>Entities</strong>: matches HTML and Unicode entities.</li>
<li><strong>Biomedical</strong>: guesses biomedical-specific words, such as <em>1',2'-trifenol</em>.</li>
</ul>
<h3>Tokenizer modes</h3>
<p>The tokenizer can be configured in different modes. By default it uses Penn Treebank specifications for tokenization and uses special corrections for biomedical use.</p>
<pre class="brush:python; gutter:false; light:true;">MBSP.tokenizer.PENN_TREEBANK = True 
MBSP.tokenizer.BIOMEDICAL = True</pre><p>In Penn Treebank mode, only % is split from numbers and contractions are not substituted: <em>won't</em> becomes <em>wo n't</em> instead of <em>will not</em>. In biomedical mode, less magic is used when finding missing spaces so that <em>3(R),3a(S),6a(R)-bis-tetrahydrofuranylurethane</em> is not split at the comma or the parenthesis.</p>
<p> </p>
<hr/>
<h2><a title="lemmatizer" name="lemmatizer"/>Lemmatizer</h2>
<p>MBSP uses the MBLEM C module for word lemmatization. MBLEM (Memory-Based Lematization) transforms a word form into a canonical lexical form: <em>was</em> → <em>be</em>, <em>booking</em> → <em>book</em>.</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; print MBSP.lemmatize("The cats were sleeping.", tokenize=True) 

the cat be sleep .
</pre></div>
<p>The goal of lemmatization is to provide better (generalizable) lexical information that can be used by other components in the pipeline, and (possibly) also for indexing the processed text in a search engine. Lemmatization is not to be confused with <em>stemming</em>, in which frequent suffixes such as <em>-ing</em> and <em>-ed</em> are simply removed: <em>having</em> is stemmed to <em>hav</em>, while it is lemmatized to <em>have</em>.</p>
<h3>Lemmatization process</h3>
<p>Words can have more than one lemma. The lemmatizer's task is to find the most suitable: </p>
<ul>
<li><strong>Find lemmata</strong>: determines for each word in a sentence which lemmata it could be mapped to. The word <em>saw</em> is lemmatized to the noun lemma <em>saw</em> and the verb lemma <em>see</em>. In case of producing more than one lemma, the lemmatizer is unable to determine which lemma is appropriate in the current sentence, as it does not use context.</li>
</ul>
<ul>
<li><strong>Disambiguate</strong>: consults the output of the part-of-speech tagger. If the tagger has identified <em>saw</em> as a past-tense verb form (<span class="postag">VBD</span>), MBLEM concludes that the appropriate lemma is <em>see</em>, and selects this one as the correct output. MBLEM therefore always generates a single lemma per word.</li>
</ul>
<p>MBLEM is trained on the CELEX English lexical database, and will simply retrieve the lemmatizations of words that occur in the database. Words in the text that are not in CELEX (so-called "unknown" words, typically constituting 5% of the words in a text) are lemmatized by analogy to stored word lemmatizations.</p>
<p><span class="small"><span>Reference</span>: Van den Bosch, A., &amp; Daelemans, W. (1999). <br/><em>Memory-based morphological analysis</em>, In: Proceedings of the 37th annual meeting of the Association for Computational Linguistics on Computational Linguistics, pp. 285-292.</span></p>
<p> </p>
<hr/>
<h2><a name="pp-attacher"/>PP-attacher</h2>
<p>A shallow parsing approach sometimes has its shortcomings, an important one being that prepositional phrases, which contain important semantic information for interpreting events (e.g. <em>I sleep</em> vs. <em>I sleep <span>under a bridge</span></em>), are left unattached. MBSP comes with a memory-based PP-attacher (MBPA) trained on sections 2 through 21 of the Penn Treebank II Wall Street Journal corpus (WSJ). It will link <span class="postag">PNP</span> chunks to other “anchor” chunks. </p>
<p>With the PP-attacher enabled, performance is slower but you gain a lot of useful information.</p>
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; s = MBSP.parse('I sleep under a bridge', anchors=True)
&gt;&gt;&gt; s = MBSP.split(s)
&gt;&gt;&gt; print s[0].pnp
&gt;&gt;&gt; print s[0].pnp[0].anchor

[Chunk('under a bridge/PNP')]
sleep</pre><h3>PP-attachment process</h3>
<p>A <span class="postag">PNP</span>-chunk can be attached to different candidate chunks. However, there is a semantic difference between <em>I eat <span>pizza with olives</span></em> and <em>I <span>eat</span> pizza <span>with olives</span></em>. Which one is correct? And which one is correct here: <em>I <span>eat</span> pizza <span>with a fork</span></em> or <em>I eat <span>pizza with a fork</span></em>?</p>
<ul>
<li><strong>Find prepositional noun phrases</strong>: these are retrieved by a regular expression-like algorithm. All <span class="postag">PP</span> + <span class="postag">NP</span> sequences are considered to be <span class="postag">PNP</span>’s. Two exceptions: <span class="postag">PP</span> + <strong>“</strong> + <span class="postag">NP</span> (e.g. <em>in “modest amounts”</em>) and <span class="postag">PP</span> + <span class="postag">VBG</span> + <span class="postag">NP</span> (<em>in making paper</em>) are also considered <span class="postag">PNP</span>’s. <br/><br/></li>
<li><strong>Classify</strong>: the core of the PP-attacher is a memory-based classifier. Candidate anchors are the <span class="postag">NP</span>’s and <span class="postag">VP</span>’s of the sentence that are not part of the <span class="postag">PNP</span> itself. For example, <em>I eat a pizza with olives</em> induces three classification tasks (<em>I-with, eat-with</em>, <em>pizza-with</em>) in which the machine learner will have to decide if the pair suggests a true anchor or not – taking into account the distance to the candidate anchor and intermediary punctuation, the number of intermediary <span class="postag">NP</span>’s, and so on.</li>
<li><strong>Heuristic decision making</strong>: when the classifier identifies multiple anchor candidates, an extra step is taken to pick one unique anchor, using a baseline and entropy algorithm (details are summarized in the reference paper).</li>
</ul>
<p>In 50% of the cases a noun phrase (<span class="postag">NP</span>) is chosen as anchor, in about 45% a verb phrase (<span class="postag">VP</span>).</p>
<p><span class="small"><span>Reference</span>: Van Asch, V., &amp; Daelemans, W. (2009). <br/><em>Prepositional Phrase Attachment in Shallow Parsing</em>. In: Proceedings of the 7th International Conference on Recent Advances in Natural Language Processing (RANLP), pp. 12-17.</span></p>
<p> </p>
<hr/>
<h2><a title="tree" name="tree"/>Parse trees</h2>
<p>A parse tree stores a parsed string as a network of linked Python objects that can be traversed to analyze the sentences in the string. The output of the <a href="/pages/MBSP#parser" target="_self">parser</a> can be passed to the <span class="inline_code">split()</span> command, which produces a <span class="inline_code">Text</span> object. Essentially, a <span class="inline_code">Text</span> is a list of <span class="inline_code">Sentence</span> objects. Each <span class="inline_code">Sentence</span> consists of <span class="inline_code">Word</span> objects. <span class="inline_code">Word</span> objects are also grouped in <span class="inline_code">Chunk</span> objects, which are related to other <span class="inline_code">Chunk</span> objects in various ways.</p>
<pre class="brush:python; gutter:false; light:true;">MBSP.split(parsed_string, token=[WORD, POS, CHUNK, PNP, RELATION, ANCHOR, LEMMA])</pre><p>We'll run the sentence "<em>The cat sat on the mat.</em>" through the parse tree:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; s = MBSP.parse('The cat sat on the mat.')
&gt;&gt;&gt; s = MBSP.split(s)
&gt;&gt;&gt; print repr(s)

[Sentence(
 'The/DT/B-NP/O/NP-SBJ-1/O/the 
  cat/NN/I-NP/O/NP-SBJ-1/O/cat 
  sat/VBD/B-VP/O/VP-1/A1/sit 
  on/IN/B-PP/B-PNP/PP-CLR/P1/on 
  the/DT/B-NP/I-PNP/NP-CLR/P1/the 
  mat/NN/I-NP/I-PNP/NP-CLR/P1/mat 
  ././O/O/O/O/.')]</pre><pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; print s[0].chunks

[Chunk('The cat/NP-SBJ-1'), 
 Chunk('sat/VP-1'), 
 Chunk('on/PP-CLR'), 
 Chunk('the mat/NP-CLR')]</pre></div>
<h3>Text</h3>
<p>A <span class="inline_code">Text</span> is a list of <span class="inline_code">Sentence</span> objects.</p>
<pre class="brush:python; gutter:false; light:true;">text = MBSP.Text(parsed_string, token=[WORD, POS, CHUNK, PNP, REL, ANCHOR, LEMMA])</pre><pre class="brush:python; gutter:false; light:true;">text = MBSP.Text.from_xml(xml) 
</pre><pre class="brush:python; gutter:false; light:true;">text.string                # 'The cat sat on the mat .'
text.sentences             # [Sentence('The cat sat on the mat .')] 
text.append(sentence)
text.copy()</pre><pre class="brush:python; gutter:false; light:true;">text.xml
</pre><p><span class="inline_code"> </span>Since <span class="inline_code">Text</span> behaves as a Python list it is easy to traverse all the contained sentences:</p>
<pre class="brush:python; gutter:false; light:true;">for sentence in text:
    print sentence
</pre><h3>Sentence</h3>
<p>A <span class="inline_code">Sentence</span> is a list of <span class="inline_code">Word</span> objects, with attributes and methods that organize words in <span class="inline_code">Chunk</span> objects.</p>
<pre class="brush:python; gutter:false; light:true;">sentence = MBSP.Sentence(string="", token=[WORD,POS,CHUNK,PNP,REL,ANCHOR,LEMMA])</pre><pre class="brush:python; gutter:false; light:true;">sentence = MBSP.Sentence.from_xml(xml) 
</pre><pre class="brush:python; gutter:false; light:true;">sentence.parent            # Slices refer to the sentence they are part of. 
sentence.id                # Unique for each sentence.
sentence.start             # 0
sentence.stop              # 6
sentence.token             # [WORD, POS, CHUNK, PNP, REL, ANCHOR, LEMMA]</pre><pre class="brush:python; gutter:false; light:true;">sentence.string            # 'The cat sat on the mat .'
sentence.words             # [Word('The/DT'), Word('cat/NN'), ... ]
sentence.lemmata           # [u'the', u'cat', u'sit', u'on', u'the', u'mat', u'.']
sentence.tagged            # [(u'The', u'DT'), (u'cat', u'NN'), ... ]
sentence.parts_of_speech   # [u'DT', u'NN', u'VBD', u'IN', u'DT', u'NN', u'.']</pre><pre class="brush:python; gutter:false; light:true;">sentence.chunks            # [Chunk('The cat/NP-SBJ-1'), Chunk('sat/VP-1'), ... ]
sentence.subjects          # [Chunk('The cat/NP-SBJ-1')]
sentence.objects           # []
sentence.verbs             # [Chunk('sat/VP-1')]
sentence.relations         # {'SBJ': {1: Chunk('the cat/NP-SBJ-1')}, 
                           #   'VP': {1: Chunk('sat/VP-1')}, 
                           #  'OBJ': {}}
</pre><pre class="brush:python; gutter:false; light:true;">sentence.pnp               # [Chunk('on the mat/PNP')]
sentence.anchors           # [Chunk('sat/VP-1')]</pre><pre class="brush:python; gutter:false; light:true;">sentence.constituents(pnp=False)</pre><pre class="brush:python; gutter:false; light:true;">sentence.get(index, tag=LEMMA)
sentence.loop(tag1, tag2, ...)
sentence.indexof(value, tag=WORD)</pre><pre class="brush:python; gutter:false; light:true;">sentence.slice(start, stop)
sentence.copy()</pre><pre class="brush:python; gutter:false; light:true;">sentence.xml
sentence.nltk_tree()</pre><ul>
<li><span class="inline_code">Sentence.constituents()</span> returns an in-order list of <span class="inline_code">Word</span> and <span class="inline_code">Chunk</span> objects.<br/>With <span class="inline_code">pnp=True</span>, also groups into <span class="inline_code">PNPChunk</span> objects whenever possible.</li>
<li><span class="inline_code">Sentence.get()</span> returns the requested tag of the word at the given index.<br/>The tag can be <span class="inline_code">WORD</span>, <span class="inline_code">LEMMA</span>, <span class="inline_code">POS</span>, <span class="inline_code">CHUNK</span>, <span class="inline_code">PNP</span>, <span class="inline_code">RELATION</span>, <span class="inline_code">ROLE</span>, <span class="inline_code">ANCHOR</span> or a custom word tag.</li>
<li><span class="inline_code">Sentence.loop()</span> is an iterator over a list of tuples containing the requested tags for each word.</li>
<li><span class="inline_code">Sentence.indexof()</span> returns the indices of words for which the given tag equals the given value.</li>
<li>For example, <span class="inline_code">Sentence.indexof("NN*", tag=POS)</span> returns a list of indices of the words whose part-of-speech is <span class="postag">NN</span>, <span class="postag">NNS</span>, <span class="postag">NNP</span> or <span class="postag">NNPS</span>.</li>
<li><span class="inline_code">Sentence.slice() </span>returns a new, partial sentence starting with the word at index <span class="inline_code">start</span> and containing all the words up to (before) index <span class="inline_code">stop</span>.</li>
</ul>
<p><span class="smallcaps">Creating a sentence</span></p>
<p>Normally, a sentence is constructed from the output of the <span class="inline_code">parse()</span> command. Since this output is a <a href="/pages/MBSP#extending" target="_self">TokenString</a> which stores the order in which tags appear in a token, <span class="inline_code">Sentence</span> can figure out how to construct a parse tree by itself. If you want to construct sentences from a different source, you need to specify the <span class="inline_code">token</span> parameter in the constructor, or use <span class="inline_code">Sentence.append()</span> to add words manually. If you have tokens in a slash-formatted string like MBSP (e.g. "cats/<span class="postag">NNS</span>/<span class="postag">I-NP</span>/<span class="postag">O</span>/<span class="postag">O</span>/<span class="postag">O</span>/cat") you can use <span class="inline_code">Sentence.parse_token()</span>, which returns the arguments for <span class="inline_code">Sentence.append()</span>.</p>
<pre class="brush:python; gutter:false; light:true;">sentence.append(word, 
       lemma = None, 
        type = None, 
       chunk = None, 
        role = None, 
    relation = None, 
         pnp = None, 
      anchor = None, 
         iob = None, 
      custom = {})</pre><pre class="brush:python; gutter:false; light:true;">sentence.parse_token(token, tags=[WORD, POS, CHUNK, PNP, REL, ANCHOR, LEMMA])</pre><p>For example:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; s = MBSP.Sentence('cats/NNS', token=[MBSP.WORD, MBSP.POS])
&gt;&gt;&gt; print s.words

[Word('cats/NNS')]
</pre><pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; s = MBSP.Sentence()
&gt;&gt;&gt; s.append(word='cats', lemma='cat', type='NNS', chunk='NP')
&gt;&gt;&gt; print s.words

[Word('cats/NNS')]
</pre><pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; s = MBSP.Sentence()
&gt;&gt;&gt; s.append(*s.parse_token('cats/NNS/I-NP/O/O/O/cat'))
&gt;&gt;&gt; print s.words

[Word('cats/NNS')]</pre></div>
<h3>Sentence words</h3>
<p>A <span class="inline_code">Sentence</span> is made up of <span class="inline_code">Word</span> objects, which are also grouped in <span class="inline_code">Chunk</span> objects:</p>
<pre class="brush:python; gutter:false; light:true;">word = MBSP.Word(sentence, string, lemma=None, type=None, index=0)</pre><pre class="brush:python; gutter:false; light:true;">word.sentence              # Sentence object (e.g. 'The cat sat on the mat .')
word.index                 # 2
word.string                # 'sat'
word.lemma                 # 'sit'
word.type                  # 'VBD'
word.chunk                 # Chunk('sat/VP-1').
word.pnp                   # None</pre><pre class="brush:python; gutter:false; light:true;">word.custom_tags           # User-defined tags, e.g. {SENTIMENT: 'lazy'}</pre><pre class="brush:python; gutter:false; light:true;">word.tags()                # ['sat', 'VBD', 'B-VP', 'O', 'VP-1', 'O', 'sit']
</pre><ul>
<li><span class="inline_code">Word.type</span> is an alias for <span class="inline_code">Word.part_of_speech</span>.<span class="inline_code"> </span></li>
<li><span class="inline_code">Word.pnp</span> is an alias for <span class="inline_code">Word.prepositional_noun_phrase</span>.</li>
<li>The <span class="inline_code">word.custom_tags</span> is a dictionary of additional, user-defined tags that can occur when the parser has been <a href="/pages/MBSP#customization" target="_self">extended</a>. If the word has (for example) an additional <em>sentiment</em> tag, it is also available as <span class="inline_code">Word.sentiment</span>.</li>
<li>The <span class="inline_code">Word.tags()</span> method returns a list of token tags as they appear in the output of the parser. <br/>The order of tags is determined by the <span class="inline_code">Sentence.token</span> attribute.</li>
</ul>
<h3>Sentence chunks</h3>
<p>A <span class="inline_code">Chunk</span> is a list of <span class="inline_code">Word</span> objects that belong together. <br/>Chunks can be part of a <span class="inline_code">PNPChunk</span>, which starts with a <span class="postag">PP</span> chunk followed by <span class="postag">NP</span> chunks.</p>
<pre class="brush:python; gutter:false; light:true;">chunk = MBSP.Chunk(sentence, words=[], type=None, role=None, relation=None)</pre><pre class="brush:python; gutter:false; light:true;">chunk.sentence             # Sentence object (e.g. 'The cat sat on the mat .')
chunk.start                # 0
chunk.stop                 # 2</pre><pre class="brush:python; gutter:false; light:true;">chunk.string               # 'The cat'
chunk.words                # [Word('The/DT'), Word('cat/NN')]
chunk.lemmata              # ['the', 'cat'] 
chunk.tagged               # [(u'The', u'DT'), (u'cat', u'NN')]
chunk.head                 # Word('cat/NN')
</pre><pre class="brush:python; gutter:false; light:true;">chunk.type                 # 'NP'
chunk.role                 # 'SBJ'
chunk.relation             # 1
chunk.relations            # [(1, u'SBJ')]
chunk.related              # [Chunk('sat/VP-1')]
chunk.subject              # None
chunk.object               # None
chunk.verb                 # Chunk('sat/VP-1')
chunk.modifiers            # []
chunk.conjunctions         # []
</pre><pre class="brush:python; gutter:false; light:true;">chunk.pnp                  # None
chunk.anchor               # None
chunk.attachments          # [Chunk('on the mat/PNP')]
</pre><pre class="brush:python; gutter:false; light:true;">chunk.append(word)
</pre><pre class="brush:python; gutter:false; light:true;">chunk.previous(type=None)  # None
chunk.next(type=None)      # Chunk('sat/VP-1')
chunk.nearest(type="VP")   # Chunk('sat/VP-1')</pre><ul>
<li><span class="inline_code">Chunk.head</span> yields the last (i.e. principal) <span class="inline_code">Word</span> in the chunk.</li>
<li><span class="inline_code">Chunk.relations</span><span class="inline_code"> </span> contains <em>all</em> relations the chunk is involved in. <br/>Some chunks (about 15%) have multiple relations, for example functioning as both <span class="postag">SBJ</span> and <span class="postag">OBJ</span>, or being the <span class="postag">OBJ</span> of multiple <span class="postag">VP</span> chunks.</li>
<li>For <span class="postag">VP</span> chunks, <span class="inline_code">Chunk.modifiers</span> is a list of nearby adjectives and adverbs with no relations. <br/>For example: in '<em>the cat really wants out</em>', <em>really</em> and <em>out</em> are <span class="postag">ADVP</span> with no relations. <br/>The parse tree will assume that they have something to do with the <span class="postag">VP</span> <em>wants</em>. <br/>What does the cat want? → out. <br/>How badly does the cat want out? → really.</li>
<li><span class="inline_code">Chunk.conjunctions</span> is a list of chunks linked by "and" or "or" to this chunk. <br/>For example: in '<em>going up and down</em>', the up chunk has conjunctions: <span class="inline_code">[(Chunk('down'), AND)] </span></li>
<li><span class="inline_code">Chunk.pnp</span> is an alias for the parent <span class="inline_code">Chunk</span><span class="inline_code">.prepositional_noun_phrase</span>.</li>
<li><span class="inline_code">Chunk.attachments</span> contains related prepositional noun phrases</li>
<li><span class="inline_code">Chunk.anchor</span> references the chunk that is the anchor of this <span class="postag">PNP</span>.</li>
</ul>
<h3>Prepositional noun phrases</h3>
<p><span class="inline_code">PNPChunk</span> is a subclass of <span class="inline_code">Chunk</span>, it has the same attributes and methods. <br/>It groups multiple chunks in a prepositional noun phrase (<span class="postag">PNP</span>).</p>
<pre class="brush:python; gutter:false; light:true;">pnp = MBSP.PNPChunk(sentence, words=[], type=None, role=None, relation=None)</pre><pre class="brush:python; gutter:false; light:true;">pnp.string                 # 'on the mat'
pnp.chunks                 # [Chunk('on/PP-CLR'), Chunk('the mat/NP-CLR')]
pnp.preposition            # Chunk('on/PP-CLR')
pnp.anchor                 # Chunk('sat/VP-1')
</pre><pre class="brush:python; gutter:false; light:true;">pnp.guess_anchor()         # Returns the nearest VP chunk.</pre><p>Words and chunks that are part of a <span class="postag">PNP</span> will have their <span class="inline_code">Word.pnp</span> and <span class="inline_code">Chunk.pnp</span> attribute set.<br/>All the prepositional noun phrases in a sentence can be retrieved with <span class="inline_code">Sentence.pnp</span>.</p>
<p> </p>
<hr/>
<h2><a title="server" name="server"/>Clients and servers</h2>
<p>MBSP uses a client-server architecture so that the data only has to be loaded once. From then on it is available as a server that can be contacted with the TCP protocol. MBSP has a <span class="inline_code">Client</span> and a <span class="inline_code">Server</span> class that communicate using the Python <span class="inline_code">socket</span> module. <span class="inline_code">Server</span> is a wrapper around <span class="inline_code">subprocess.Popen</span> and starts TiMBL or MBT as a background process.</p>
<p>MBSP starts four servers:</p>
<table class="border">
<tbody>
<tr>
<td><span class="smallcaps">Name </span></td>
<td class="smallcaps">Address</td>
<td><span class="smallcaps">Process </span></td>
<td><span class="smallcaps">Description </span></td>
</tr>
<tr>
<td><span class="inline_code">MBSP.CHUNK</span></td>
<td>localhost:6061</td>
<td>MBT</td>
<td>Server  for finding part-of-speech and chunk tags.</td>
</tr>
<tr>
<td><span class="inline_code">MBSP.LEMMA</span></td>
<td>localhost:6062</td>
<td>TiMBL</td>
<td>Server used by <a href="http://ilk.uvt.nl/mbma/">MBLEM</a> to find word lemmata. </td>
</tr>
<tr>
<td><span class="inline_code">MBSP.RELATION </span></td>
<td>localhost:6063</td>
<td>TiMBL</td>
<td>Server for finding verb-argument chunk relations.</td>
</tr>
<tr>
<td><span class="inline_code">MBSP.PREPOSITION </span></td>
<td>localhost:6064</td>
<td>TiMBL</td>
<td>Server for finding <span class="postag">PNP</span> anchors.</td>
</tr>
</tbody>
</table>
<p><strong>TiMBL</strong>: memory-based learning is an elegantly simple and robust machine-learning method applicable to a wide range of tasks in Natural Language Processing.</p>
<p><a href="http://ilk.uvt.nl/timbl/" target="_self">http://ilk.uvt.nl/timbl/</a></p>
<p><strong>MBT</strong>: a memory-based tagger-generator and tagger in one. MBT can, for instance, be used to generate part-of-speech taggers or chunkers for natural language processing.<br/><a href="http://ilk.uvt.nl/mbt/" target="_self">http://ilk.uvt.nl/mbt/</a></p>
<h3>Client</h3>
<p>The <span class="inline_code">Client</span> base class can be used to contact a TiMBL or MBT server running at a given host address, at a given TCP communication port.  <span class="inline_code">Client</span> is then subclassed with <span class="inline_code">Timbl</span> and <span class="inline_code">Mbt</span> classes.</p>
<pre class="brush:python; gutter:false; light:true;">client = MBSP.Client(
        host = LOCALHOST, 
        port = 6060, 
        name = None, 
         log = False, 
     request = lambda v:v.strip()+'\n', 
    response = lambda v:v)</pre><pre class="brush:python; gutter:false; light:true;">client.name
client.host
client.port
client.connected # True after Client.connect() is called.</pre><pre class="brush:python; gutter:false; light:true;">client.connect()
client.send(request, timeout=None)
client.disconnect()
</pre><ul>
<li><span class="inline_code">Client.connect()</span> raises a <span class="inline_code">ServerConnectionError</span> if the server can't be contacted.</li>
<li><span class="inline_code">ServerConnectionError.code</span> can contain additional information, such as <span class="inline_code">CONNECTION_RESET_BY_PEER</span>, <span class="inline_code">CONNECTION_REFUSED</span> or <span class="inline_code">BROKEN_PIPE</span>.</li>
<li><span class="inline_code">Client.send()</span> prepares the request, sends it to the server and returns the response.<br/><span class="inline_code">Client.send()</span> raises a <span class="inline_code">ClientDisconnectedError</span> if <span class="inline_code">Client.connect()</span> is not called first.<br/>If <span class="inline_code">timeout</span> is given and no response is returned in the given time, a <span class="inline_code">ClientTimeoutError</span> is raised.</li>
<li>Make sure to clean up with <span class="inline_code">Client.disconnect()</span> when the client is no longer needed.</li>
</ul>
<p><span class="smallcaps">Request and response formatters</span></p>
<p>Note the <span class="inline_code">request</span> and <span class="inline_code">response</span> parameters in the <span class="inline_code">Client</span> constructor. These are formatter functions that will be called by <span class="inline_code">Client.send()</span> to 1) prepare the data before sending it to the server and 2) to clean up the server response before returning it.</p>
<p>For example, if we send a raw request to the chunk server:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; chunker = MBSP.Client(port=6061)
&gt;&gt;&gt; print chunker.send('cat')

cat/NN/I-NP -utt-</pre></div>
<p>The MBT server's response ends with a delimiter which we may want to clean from the output.<br/>This can be achieved by using a response formatter:</p>
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; chunker = MBSP.Client(port=6061, response=lambda v: v.rstrip(' -utt-\n'))
&gt;&gt;&gt; print chunker.send('cat')

cat/NN/I-NP</pre><p><span class="small"><span>Note</span>: in reality, MBT's delimiter is a <em>utt</em> tag (so <em>utt</em> enclosed in &lt; and &gt;) but </span><span class="small">in this example </span><span class="small">we use <em>-utt-</em> instead to avoid the browser thinking it's a HTML-tag. </span></p>
<h3>TiMBL and MBT client</h3>
<p>MBSP has a <span class="inline_code">Timbl</span> and a <span class="inline_code">Mbt</span> class: subclasses of <span class="inline_code">Client</span>, with the right request and response formatters.</p>
<pre class="brush:python; gutter:false; light:true;">timbl = MBSP.Timbl(host=LOCALHOST, port=6060, name=None, log=False, verbosity=[])</pre><pre class="brush:python; gutter:false; light:true;">mbt = MBSP.Mbt(host=LOCALHOST, port=6060, name=None, log=False)</pre><p>TiMBL's output depends on the way the server <em>verbosity</em> (<span class="inline_code">+v</span>) is configured. In MBSP it typically it yields a category string: "<span class="inline_code">CATEGORY {NP-SBJ} </span>". Depending on the verbosity it can also yield different output. For example, verbosity option  <span class="inline_code">+v di+db </span>yields a<em> </em>category-distance-distribution string:<br/> "<span class="inline_code">CATEGORY {VP} DISTRIBUTION { VP 3.11506, n-VP 2.58232 } DISTANCE {2.02066} </span>".</p>
<p>The TiMBL client has an additional <span class="inline_code">verbosity</span> parameter which can be used to format the response:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; timbl = MBSP.Timbl(port=6064, verbosity=['di','db'])
&gt;&gt;&gt; print timbl.send('0 0 2 - eat VBP pizza NN with fork NN 1 0')

['VP', 2.0206599999999999, {'VP': 3.1150600000000002, 'n-VP': 2.5823200000000002}]
</pre></div>
<p>The server at port 6064 is the preposition server, which loads with option <span class="inline_code">+v di+db</span>, so responses include distance and distribution metrics. The TiMBL client in this example sets the right verbosity options so that distance is correctly parsed as a float, and distribution as a dictionary.</p>
<p>See the <a href="http://ilk.uvt.nl/downloads/pub/papers/Timbl_6.2_Manual.pdf" target="_self">TiMBL manual</a> for all verbosity options.</p>
<h3>Client batch requests</h3>
<p>Since the servers are multithreaded, multiple request can be sent at the same time to speed up the lookup process. MBSP's client module has a <span class="inline_code">client.batch()</span> command to achieve this. It takes a list of requests (i.e. instances) and a "client definition". This definition is a tuple with the necessary parameters that allows the <span class="inline_code">batch()</span> command to generate threaded <span class="inline_code">Client</span> objects. The <span class="inline_code">client.define()</span> command can be used to generate the tuple.</p>
<pre class="brush:python; gutter:false; light:true;">MBSP.client.batch(instances, client, timeout=None, retries=1)</pre><pre class="brush:python; gutter:false; light:true;">MBSP.client.define(client, host=LOCALHOST, port=6060, name=None, log=False) </pre><p>For example:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; from MBSP.client import batch, define, Mbt
&gt;&gt;&gt; print batch(['cat', 'sat', 'mat'], client=define(Mbt, port=6061)) 

['cat/NN/I-NP', 'sat/VBN/I-VP', 'mat/NN/I-NP'] </pre></div>
<h3>Client request log</h3>
<p>If <span class="inline_code">config.log=True</span>, all client requests and server responses are logged. This is useful for evaluation. Also, when logs are enabled, a cached request can be reused without having to contact the server. The performance hit is negligible however – except for very repetitive texts.</p>
<p>The log is a dictionary indexed by server name (<span class="inline_code">CHUNK</span>, <span class="inline_code">LEMMA</span>, <span class="inline_code">RELATION</span> and <span class="inline_code">PREPOSITION</span>).<br/>Each individual server log in the dictionary is an ordered dictionary that stores the last 1000 requests.</p>
<pre class="brush:python; gutter:false; light:true;">MBSP.client.log 
</pre><p>For example:</p>
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; MBSP.config.log = True
&gt;&gt;&gt; MBSP.parse('I eat pizza with a fork.')
&gt;&gt;&gt; print MBSP.client.log[MBSP.RELATION]

{'-1 0 0 eat VBP - - - - - - - I PRP NP VBP VP ?': 'CATEGORY {NP-SBJ}\n',
  '1 0 0 eat VBP - - - eat VBP VP - pizza NN NP NN PNP ?': 'CATEGORY {NP-OBJ}\n',
  '2 0 0 eat VBP eat VBP VP pizza NN NP - fork NN PNP - - ?': 'CATEGORY {-}\n'}</pre><p>Three requests were sent to the relation server to find the sentence <span class="postag">SBJ</span> and <span class="postag">OBJ</span>. <br/>More complex sentences require more lookup requests and more complex request with more instance features require more time.</p>
<h3>Server</h3>
<p>MBSP has a <span class="inline_code">Server</span> class that is used to start TiMBL or MBT as a background process. A server can be queried by creating a client. Typically, servers run locally on your own machine (e.g. at "localhost") but they can also be configured to work with an IP-address over a network. You can also create new servers from scratch and work with their responses in Python code.</p>
<pre class="brush:python; gutter:false; light:true;">server = MBSP.Server(
        name, 
        host = LOCALHOST, 
        port = 6060, 
     process = TIMBL, 
        ping = None, 
    features = {})</pre><pre class="brush:python; gutter:false; light:true;">server.name                # LEMMA
server.host                # LOCALHOST
server.port                # 6062 
server.process             # TIMBL
server.features            # {'-f': '/models/em.data', '-m': 'M', '-w': 2, '-k-: 5}
server.ping                # ('c = = = = = = = = = = = = = = = = = = = B ?\n',
                           #  'CATEGORY {ABB-X}\n')</pre><pre class="brush:python; gutter:false; light:true;">server.program             # The shell command used to start the process.
server.pid                 # Process id, needed when stop() is called.
</pre><pre class="brush:python; gutter:false; light:true;">server.started             # True when ping request yields ping response.</pre><pre class="brush:python; gutter:false; light:true;">server.start(timeout=60)
server.stop()</pre><ul>
<li><span class="inline_code">Server.features</span> specifies the training data file and various options (see the <a href="http://ilk.uvt.nl/downloads/pub/papers/Timbl_6.2_Manual.pdf" target="_self">TiMBL manual</a>).<span class="inline_code"> </span></li>
<li><span class="inline_code">Server.start()</span> raises a <span class="inline_code">ServerTimeoutError</span> when the server doesn't start in the given time.<br/><span class="inline_code">Server.start()</span> will continually check <span class="inline_code">Server.started</span> until it returns True.</li>
<li><span class="inline_code">Server.started</span> determines if the server is up and running by sending a ping request.</li>
<li><span class="inline_code">Server.ping</span> is a tuple with a sample request and its desired (e.g. correct) response.<br/>If it is None, <span class="inline_code">Server.started</span> just sends "<span class="inline_code">x ?</span>" and accepts whatever response.<br/>Sending a sample request and validating the response is the only safe way to figure out you are addressing the right server.</li>
</ul>
<p><span class="smallcaps">Stopping a server</span></p>
<p>When a server is stopped, the background process is killed. The <span class="inline_code">Server.pid</span> process id is stored as a temporary file so that MBSP can retrieve which servers are up and running across Python sessions – you don't need to stop and restart a server each time you run a new Python script.</p>
<p>If the process id is lost (for example, the system did a cleanup of temporary files), the server background process will have to be killed manually. The server module has a <span class="inline_code">force_quit()</span> that terminates all running TiMBL and MBT processes:</p>
<pre class="brush:python; gutter:false; light:true;">MBSP.server.force_quit(processes=(TIMBL, MBT))</pre><p>This only works on Unix-systems though. Otherwise, the TiMBL and MBT processes will have to be terminated manually from the Windows Task Manager or Mac OS X's Activity Monitor.</p>
<p>MBSP can also be <a href="/pages/MBSP#configuration" target="_self">configured</a> to automatically stop its servers when Python exits.</p>
<p> </p>
<hr/>
<h2><a title="configuration" name="configuration"/>Configuration</h2>
<p>A number of settings in config.py can be adjusted. Most notably, IP addresses for the <a href="/pages/MBSP#server" target="_self">servers</a> (<span class="inline_code">CHUNK</span>, <span class="inline_code">LEMMA</span>, <span class="inline_code">RELATION</span>, <span class="inline_code">PREPOSITION</span>) can be defined in the <span class="inline_code">config.hosts</span> list, so MBSP can be configured to work over a network.</p>
<p>By default, the servers will start automatically when MBSP is imported. Servers are always started at localhost, i.e. the <span class="inline_code">config.hosts</span> list contains the addresses needed for the <em>clients</em>. So if your MBSP is set up to contact servers over a network, <span class="inline_code">config.autostart</span> should be set to False so that no servers are started on your own machine. Servers can also be configured to stop automatically when Python exits, by setting <span class="inline_code">config.</span><span class="inline_code">autostop</span> to True.</p>
<p>The <span class="inline_code">config.log</span> option controls whether client requests and the servers' responses are logged in the <span class="inline_code">MBSP.client.log</span> dictionary.</p>
<h3>config.py options</h3>
<table class="border">
<tbody>
<tr>
<td><span class="smallcaps">Option </span></td>
<td><span class="smallcaps">Default </span></td>
<td><span class="smallcaps">Description </span></td>
</tr>
<tr>
<td><span class="inline_code">MODULE</span></td>
<td><span class="inline_code">os.path.dirname(os.path.abspath(__file__))</span></td>
<td>MBSP folder path.</td>
</tr>
<tr>
<td><span class="inline_code">LOCALHOST </span></td>
<td><span class="inline_code">'localhost' </span></td>
<td>Localhost IP address.</td>
</tr>
<tr>
<td class="inline_code">hosts</td>
<td><span class="inline_code">[LOCALHOST, LOCALHOST, LOCALHOST, LOCALHOST]</span></td>
<td>Server IP addresses. </td>
</tr>
<tr>
<td><span class="inline_code">ports</span></td>
<td><span class="inline_code">[6061, 6062, 6063, 6064]  </span></td>
<td>Server ports.</td>
</tr>
<tr>
<td><span class="inline_code">autostart </span></td>
<td><span class="inline_code">True </span></td>
<td>Automatically start servers?</td>
</tr>
<tr>
<td><span class="inline_code">autostop </span></td>
<td><span class="inline_code">False </span></td>
<td>Automatically stop servers? </td>
</tr>
<tr>
<td><span class="inline_code">log </span></td>
<td><span class="inline_code">False </span></td>
<td>Log server requests?</td>
</tr>
<tr>
<td><span class="inline_code">verbose</span></td>
<td><span class="inline_code">True  </span></td>
<td>Server startup message? </td>
</tr>
<tr>
<td><span class="inline_code">paths </span></td>
<td><span class="inline_code">{'timbl': MODULE+'/timbl/Timbl'),<br/>   'mbt': MODULE+'/mbt/Mbt'), <br/> 'mblem': MODULE+'/mblem/mblem_english_bmt'),<br/>'models': MODULE+'/models')} </span></td>
<td>Binaries and training data.</td>
</tr>
<tr>
<td><span class="inline_code">threading</span></td>
<td><span class="inline_code">False</span></td>
<td>See <a href="/pages/MBSP#installation">installation instructions</a>.</td>
</tr>
<tr>
<td><span class="inline_code">encoding </span></td>
<td><span class="inline_code">'utf-8' </span></td>
<td>Default character encoding.</td>
</tr>
</tbody>
</table>
<p> </p>
<hr/>
<h2><a title="command_line" name="command_line"/>Command-line interface</h2>
<p>The parser can be run from the command-line by invoking mbsp.py inside the MBSP library folder. The parsed output is printed in the terminal window. Note that the servers will not be started automatically, so you have to start them manually:</p>
<pre class="brush:python; gutter:false; light:true;">&gt; cd MBSP
&gt; python mbsp.py start
&gt; python mbsp.py parse -f camelot.txt
&gt; python mbsp.py parse -s "It's only a model."
&gt; python mbsp.py parse xml -s 'It is a silly place.'
&gt; python mbsp.py stop 
</pre><h3>Command-line options</h3>
<p>If no options are given a full parse is executed (i.e. tokenization, tagging, chunking, relations, prepositions and lemmata). Otherwise, you need to explicitly list every required option:</p>
<table class="border">
<tbody>
<tr>
<td class="inline_code">-O</td>
<td class="inline_code">--tokenize</td>
<td>Tokenize the input.</td>
</tr>
<tr>
<td><span class="inline_code">-T </span></td>
<td><span class="inline_code">--tags </span></td>
<td>Parse part-of-speech tags.</td>
</tr>
<tr>
<td><span class="inline_code">-C</span></td>
<td><span class="inline_code">--chunks </span></td>
<td>Parse chunks and PNP tags.</td>
</tr>
<tr>
<td><span class="inline_code">-R</span></td>
<td><span class="inline_code">--relations</span></td>
<td>Find verb/predicate relations.</td>
</tr>
<tr>
<td><span class="inline_code">-A </span></td>
<td><span class="inline_code">--anchors</span></td>
<td>Find PP-attachments.</td>
</tr>
<tr>
<td><span class="inline_code">-L</span></td>
<td><span class="inline_code">--lemmata </span></td>
<td>Find word lemmata.</td>
</tr>
<tr>
<td><span class="inline_code">-f </span></td>
<td><span class="inline_code">--file</span></td>
<td>Input filename.</td>
</tr>
<tr>
<td class="inline_code">-s</td>
<td><span class="inline_code">--string </span></td>
<td>Input string.</td>
</tr>
<tr>
<td><span class="inline_code">-e</span></td>
<td><span class="inline_code">--encoding</span></td>
<td>Specify character encoding (utf-8 by default).</td>
</tr>
<tr>
<td><span class="inline_code">-v </span></td>
<td class="inline_code">--version</td>
<td>Current version of MBSP.</td>
</tr>
</tbody>
</table>
<p>Short options can be concatenated, e.g.: <span class="inline_code">python mbsp.py parse -OTL -f camelot.txt</span></p>
<p> </p>
<hr/>
<h2><a title="customization" name="customization"/>Extending MBSP</h2>
<h3>Event framework</h3>
<p>MBSP has a built-in event framework that offers a convenient way to customize the module. For example, each completed step in the <a href="/pages/MBSP#parser" target="_self">parser</a> fires an event. A user-defined event handler can be assigned to an event, instead of messing around in the source code.</p>
<p>Server event handlers take a <span class="inline_code">Server</span> object as input. Events are fired when a server is registered in a <span class="inline_code">Servers</span> group (see below), or when a server is successfully started or stopped.</p>
<pre class="brush:python; gutter:false; light:true;">def event_handler(server): 
    return None
</pre><pre class="brush:python; gutter:false; light:true;">MBSP.events.server.on_register = event_handler
MBSP.events.server.on_start = event_handler
MBSP.events.server.on_stop = event_handler</pre><p>Parser event handlers take a <span class="inline_code">TokenString</span> object (see below) as input and return the modified <span class="inline_code">TokenString</span>. Events are fired when each step in the parsing process is completed (for example, tokenization is done).</p>
<pre class="brush:python; gutter:false; light:true;">def event_handler(tokenstring): 
    return tokenstring
</pre><pre class="brush:python; gutter:false; light:true;">MBSP.events.parser.on_tokenize = event_handler
MBSP.events.parser.on_parse_tags_and_chunks = event_handler
MBSP.events.parser.on_parse_prepositions = event_handler
MBSP.events.parser.on_parse_relations = event_handler
MBSP.events.parser.on_parse_pp_attachments = event_handler
MBSP.events.parser.on_lemmatize = event_handler</pre><h3>Customizing the parser</h3>
<p>Suppose you need to correct some part-of-speech tags. Since the part-of-speech tag influences the relation and anchor tag annotation, you'd need to do this somewhere halfway down the parsing process. This is possible by injecting an event handler – without modifying the source code and thus keeping it easy to install package updates:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; def my_tagger_chunker(tokenstring): 
&gt;&gt;&gt;     T = tokenstring.split()
&gt;&gt;&gt; i = T.tags.index(MBSP.PART_OF_SPEECH)
&gt;&gt;&gt; for sentence in T:
&gt;&gt;&gt; for token in sentence:
&gt;&gt;&gt; print token[i] # modify POS-tag here
&gt;&gt;&gt; return T.join()
&gt;&gt;&gt;
&gt;&gt;&gt; MBSP.events.parser.on_parse_tags_and_chunks = my_tagger_chunker
</pre></div>
<p>Since the output of the event handler is then processed further, it needs to maintain the order of tags and it can't delete tags (they are still needed by the parser to determine other tags).</p>
<h3>Customizing the parser output</h3>
<p>The output of the <span class="inline_code">parse()</span> command is a string of sentences in which each token has been annotated with the requested tags. This string is in fact a <span class="inline_code">TokenString</span> object that behaves as a Python string, but with extra functionality. Most notably, it has a <span class="inline_code">TokenString.split()</span> method that yields a <span class="inline_code">TokenList</span> object: a list of sentences, where each sentence is a list of tokens, in which each token is a list of tags.</p>
<pre class="brush:python; gutter:false; light:true;">tokenstring = MBSP.TokenString(string, tags=[WORD])</pre><pre class="brush:python; gutter:false; light:true;">tokenstring.tags              # [WORD, POS, CHUNK, PNP, RELATION, ANCHOR, LEMMA]
tokenstring.split(sep=TOKENS) # Yields a TokenList.
tokenstring.copy()</pre><pre class="brush:python; gutter:false; light:true;">tokenlist = MBSP.TokenList(sentences, tags)</pre><pre class="brush:python; gutter:false; light:true;">tokenlist.tags
tokenlist.tags.insert(i, tag, values=None)
tokenlist.tags.append(tag, values=None)
tokenlist.tags.remove(tag)
tokenlist.tags.pop(i)
tokenlist.tags.swap(tag1, tag2)</pre><pre class="brush:python; gutter:false; light:true;">tokenlist.join()              # Yields a TokenString.
tokenlist.copy()
tokenlist.reduce(tags=[]) 
tokenlist.filter(
        word = None,
         tag = None,
       chunk = None,
    relation = None,
      anchor = None,
       lemma = None)
</pre><p>The <span class="inline_code">TokenString</span> facilitates the conversion from a tagged string to a list – where tokens can then be manipulated. The <span class="inline_code">TokenList.tags</span> list not only stores the order of tags in each token, it also keeps the tokens in synch. If you delete an item from <span class="inline_code">TokenList.tags</span>, all tokens in each sentence are automatically modified as well. In the same way, <span class="inline_code">TokenList.tags.append()</span> has an additional <span class="inline_code">values</span> parameter where you can enter the values of the new tag for each token in each sentence (<span class="postag"> </span>by default, <span class="postag">O</span>).</p>
<p>For example:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; s = MBSP.parse('I eat pizza')
&gt;&gt;&gt; s = s.split()
&gt;&gt;&gt; s.tags.append('semantic', values=[['person', 'action', 'food']])
&gt;&gt;&gt; s = s.join()
&gt;&gt;&gt; print s

I/PRP/I-NP/O/NP-SBJ-1/O/i/person eat/VBP/I-VP/O/VP-1/O/eat/action 
pizza/NN/I-NP/O/NP-OBJ-1/O/pizza/food</pre></div>
<p>When you create a <a href="/pages/MBSP#tree" target="_self">parse tree</a> from this output, the <em>semantic</em> tag will end up in <span class="inline_code">Word.custom_tags</span>.</p>
<p>If you want to insert a tag from one <span class="inline_code">TokenString</span> into another, you can use <span class="inline_code">TokenString1.tags.pop()</span>. It extracts (and removes) the tag value from each token. You can use this return value for the <span class="inline_code">values</span> parameter in the other <span class="inline_code">TokenString2.tags.append()</span>.</p>
<p><span class="inline_code">TokenList.reduce()</span> returns a copy with the given tags removed from all tokens. <span class="inline_code"><br/>TokenList.filter()</span> returns a list of all tokens that match the given criteria. Wildcards can be used at the head, tail or middle of a constraint:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; s = MBSP.parse('I eat pizzas with a fork.')
&gt;&gt;&gt; print s.split().filter(tag="NN*")

[[u'pizzas', u'NNS', u'I-NP', u'O', u'NP-OBJ-1', u'O', u'pizza'], 
 [u'fork', u'NN', u'I-NP', u'I-PNP', u'O', u'P1', u'fork']]
</pre></div>
<h3>Customizing the servers</h3>
<p>MBSP's servers are grouped in a <span class="inline_code">Servers</span> object: a Python list with some additional functionality:</p>
<ul>
<li><span class="inline_code">Servers</span> can automatically start and stop a <a href="/pages/MBSP#server" target="_self">server</a> (i.e. <span class="inline_code">Server</span> object) that is added to the group.</li>
<li><span class="inline_code">Servers</span> will check that all servers in the group use a different port and a different name.</li>
<li><span class="inline_code"> </span>When a server is added, its <span class="inline_code">Server.group</span> attribute will refer to the <span class="inline_code">Servers</span> object.</li>
<li>When a server is added, the <span class="inline_code">on_register </span>event will be fired.</li>
</ul>
<pre class="brush:python; gutter:false; light:true;">servers = MBSP.Servers(start=False, stop=False)</pre><pre class="brush:python; gutter:false; light:true;">servers.append(server)</pre><pre class="brush:python; gutter:false; light:true;">servers.[server_name]      # Retrieve a server by name. 
</pre><pre class="brush:python; gutter:false; light:true;">servers.started            # True when all servers in the group have started.
servers.start(timeout=60)
servers.stop()
</pre><p>The correct way to install a custom server is to add it to the module's <span class="inline_code">active_servers</span> group to ensure that it is started and stopped together with the other servers (e.g. when <span class="inline_code">MBSP.stop()</span> is called).</p>
<p>Assume we have a tagger trained for biomedical use that overrides the default part-of-speech tags:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; import MBSP
&gt;&gt;&gt; MBSP.active_servers.append(
&gt;&gt;&gt;    MBSP.Server(
&gt;&gt;&gt;            name = 'biomedical_pos',
&gt;&gt;&gt;            port = 6065, 
&gt;&gt;&gt;         process = MBSP.MBT,
&gt;&gt;&gt;        features = {'-s' : 'biopos/biopos.settings')}))
</pre></div>
<p>We can contact the server with an event, after MBSP is done tagging and chunking:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; def update_pos(tokenstring): 
&gt;&gt;&gt;     client = MBSP.Mbt(port=6065)
&gt;&gt;&gt;     s1 = tokenstring.split() 
&gt;&gt;&gt;     s2 = s1.reduce([MBSP.WORD]) 
&gt;&gt;&gt;     s2 = MBSP.TokenString(client.send(s2.join()), tags=[MBSP.WORD, MBSP.POS])
&gt;&gt;&gt;     s2 = s2.split() 
&gt;&gt;&gt;     s2.tags.append(MBSP.CHUNK, values=s1.tags.pop(s1.tags.index(MBSP.CHUNK)))
&gt;&gt;&gt;     client.disconnect()
&gt;&gt;&gt;     return s2.join()
&gt;&gt;&gt;
&gt;&gt;&gt; MBSP.events.parser.on_parse_tags_and_chunks = update_pos 
</pre></div>
<p>We have installed a new server and then contact it in the <span class="inline_code">update_pos()</span> event, right after MBSP has finished tagging and chunking with the default servers. The event extracts the original words in the sentence and feeds them to our biomedical MBT server. We append the original chunk tags to the updated output and pass it back to MBSP. MBSP will continue to look for relations and prepositions with the updated tags.</p>
<p><span class="smallcaps">Replacing a default server before it starts</span></p>
<p>Assume you want to <em>replace</em> a default server with one of your own. If MBSP's servers are <a href="/pages/MBSP#configuration" target="_self">configured</a> to start automatically, there is no way to stop them from loading before you can replace them. The way to do this is to disable MBSP's <span class="inline_code">autostart</span> feature, add replacement servers to <span class="inline_code">active_servers</span>, and then implement your own autostart in your own script.</p>
<p> </p>
<hr/>
<h2><a name="export"/>Exporting to XML and NLTK</h2>
<p>With the <span class="inline_code">xml()</span> command the output of the <span class="inline_code">parse()</span> command can be dumped as an XML string:</p>
<pre class="brush: python;light: true; fontsize: 100; first-line: 1; ">MBSP.xml(string, token=[WORD, POS, CHUNK, PNP, RELATION, ANCHOR, LEMMA])</pre><pre class="brush: python;light: true; fontsize: 100; first-line: 1; ">MBSP.Text.xml           # Returns the Text as an XML string.</pre><pre class="brush: python;light: true; fontsize: 100; first-line: 1; ">MBSP.Text.from_xml(xml) # Returns a new Text from the given XML string.</pre><p>The XML output is a <span class="inline_code">&lt;text&gt;</span> element consisting of one or more <span class="inline_code">&lt;sentence&gt;</span> elements. Each &lt;sentence&gt; has a unique <span class="inline_code">id</span>attribute, a <span class="inline_code">token</span> descriptor and consists of <span class="inline_code">&lt;chunk&gt;</span> and <span class="inline_code">&lt;chink&gt;</span> elements. A <span class="inline_code">&lt;chunk&gt;</span> can have a <span class="inline_code">type</span> attribute (e.g.<span class="postag">NP</span>, <span class="postag">VP</span>) and/or a <span class="inline_code">relation</span> attribute (e.g. <span class="postag">SBJ</span>). In this case it can also have an <span class="inline_code">of</span> attribute with the <span class="inline_code">id</span> of the related <span class="postag">VP</span>chunk.  A <span class="inline_code">&lt;chunk type=”PNP”&gt;</span> element can also have an <span class="inline_code">of</span> attribute, with the <span class="inline_code">anchor</span> of the chunk to which it is attached. A <span class="inline_code">&lt;chunk&gt;</span> consists of <span class="inline_code">&lt;word&gt;</span> elements, or other <span class="inline_code">&lt;chunk&gt;</span> elements in the case of a <span class="postag">PNP</span>. A <span class="inline_code">&lt;word&gt;</span> element contains the actual word and can have a <span class="inline_code">type</span> attribute (e.g. <span class="postag">NN</span>) and a <span class="inline_code">lemma</span> attribute. If MBSP was extended with custom tags these will be listed in the <span class="inline_code">&lt;sentence&gt; token</span> attribute and as <span class="inline_code">&lt;word&gt;</span> attributes.</p>
<p>For example:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; s = MBSP.parse('I eat pizza with a fork.')
&gt;&gt;&gt; print MBSP.xml(s)</pre></div>
<p><span class="inline_code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/></span><span>&lt;text&gt;<br/></span><span>&lt;sentence id="1" <br/></span><span>       token="word, part-of-speech, chunk, preposition, relation, anchor, lemma"&gt;<br/></span><span>    &lt;chunk type="NP" relation="SBJ" of="1.1"&gt;<br/></span><span>        &lt;word type="PRP" lemma="i"&gt;I&lt;/word&gt;<br/></span><span>    &lt;/chunk&gt;<br/></span><span>    &lt;chunk type="VP" id="1.1" anchor="1.A1"&gt;<br/></span><span>        &lt;word type="VBP" lemma="eat"&gt;eat&lt;/word&gt;<br/></span><span>    &lt;/chunk&gt;<br/></span><span>    &lt;chunk type="NP" relation="OBJ" of="1.1"&gt;<br/></span><span>        &lt;word type="NN" lemma="pizza"&gt;pizza&lt;/word&gt;<br/></span><span>    &lt;/chunk&gt;<br/></span><span>    &lt;chunk type="PNP" of="1.A1"&gt;<br/></span><span>        &lt;chunk type="PP"&gt;<br/></span><span>            &lt;word type="IN" lemma="with"&gt;with&lt;/word&gt;<br/></span><span>        &lt;/chunk&gt;<br/></span><span>        &lt;chunk type="NP"&gt;<br/></span><span>            &lt;word type="DT" lemma="a"&gt;a&lt;/word&gt;<br/></span><span>            &lt;word type="NN" lemma="fork"&gt;fork&lt;/word&gt;<br/></span><span>        &lt;/chunk&gt;<br/></span><span>    &lt;/chunk&gt;<br/></span><span>    &lt;chink&gt;<br/></span><span>        &lt;word type="." lemma="."&gt;.&lt;/word&gt;<br/></span><span>    &lt;/chink&gt;<br/></span><span>&lt;/sentence&gt;<br/></span><span>&lt;/text&gt;</span></p>
<h3>Exporting to NLTK</h3>
<p>The <span class="inline_code">MBSP.tree</span> module has an <span class="inline_code">nltk_tree()</span> command that returns an <span class="inline_code">nltk.tree.Tree</span> object from the given <span class="inline_code">MBSP.Sentence</span> object. This way the output from MBSP can be integrated into <a href="http://nltk.org">NLTK</a> for further processing. </p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; s = MBSP.parse('I eat pizza with a fork.')
&gt;&gt;&gt; s = MBSP.split(s)
&gt;&gt;&gt; print MBSP.tree.nltk_tree(s.sentences[0])
 
(S
  (NP (PRP I))
  (VP (VBP eat) (PNP (PP (IN with)) (NP (DT a) (NN fork))))
  (NP (NN pizza)))</pre></div>
<p>NLTK needs to be installed on your systeem for this to work.</p>
<h3>Exporting to GraphViz</h3>
<p>The <span class="inline_code">MBSP.tree</span> module has a <span class="inline_code">graphviz_dot()</span> command that returns a string in the DOT language (a simple way to describe graphs) from the given <span class="inline_code">MBSP.Sentence</span> object. DOT files can be visualized with <a href="http://graphviz.org">GraphViz</a>, a free application for drawing graphs and exporting them as images (PDF, PNG, ...)</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; s = MBSP.parse('I eat pizza with a fork.')
&gt;&gt;&gt; s = MBSP.split(s)
&gt;&gt;&gt; f = open('pizza.dot', 'w')
&gt;&gt;&gt; f.write(MBSP.tree.graphviz_dot(s.sentences[0])
&gt;&gt;&gt; f.close()</pre></div>
<p>When <span class="inline_code">pizza.dot</span> is then openend in GraphViz it displays the following syntax tree:</p>
<p><img src="/media/MBSP_graphviz.jpg" alt=""/></p>
<p> </p>
<hr/>
<h2><a title="license" name="license"/>Licensing</h2>
<p>MBSP uses a duel license model and offers licenses for two distinct purposes – commercial and open source development.</p>
<ul>
<li><strong>Open source</strong>: for open source purposes MBSP uses the GNU General Public License version 3 (<a href="http://www.gnu.org/licenses/gpl.html" target="_self">GPLv3</a>). It requires that you contribute to the open source community by placing your application that uses MBSP under an open source license (e.g. GPLv3). This option secures all users the rights to obtain the application's full source code, modify it, and redistribute it.</li>
</ul>
<ul>
<li><strong>Commercial</strong>: for commercial purposes you can directly contact prof. Walter Daelemans (<em>walter.daelemans at ua.ac.be</em>). This requires that you contribute to the continued development of the product by purchasing a commercial license. This option secures you the right to distribute your application under the license terms of your choice</li>
</ul>
  </div>

  
</div></body></html>