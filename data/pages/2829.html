<html><body><div><post no-compile=""><p>
<b>TL;DR: </b>
Python is a (powerful) general purpose language in broad use, let's dive in and
learn some control flow tips, standard library tricks, and common pitfalls.
</p>

<h2 id="1-introduction">1 Introduction</h2>
<p>Python (and its libraries) are enormous. It is used for system automation, web
applications, big data, analytics, and security software. This article aims to
show off some lesser-known tricks to put you on the path to faster development,
easier debugging, and general fun.</p>
<p>As with every language, the real resource you get once you learn it isn't a
language-related superpower. It's the ability to use the idioms, libraries, and
shared knowledge of the Python community.</p>
<h2 id="exploring-standard-data-types">Exploring Standard Data Types</h2>
<h3 id="the-humble-enumerate-">The Humble <code>enumerate</code></h3>
<p>Iterating over the contents of anything in Python is simple, just <code>for foo in
bar:</code> and you're off and running.</p>

<pre><code>dr{}{}ks = ["{}{}ff{}{}", "t{}{}", "m{}{}k", "w{}{}er{}{}
for dr{}{}k in dr{}{}ks:
    pr{}{}t({}{}hi{}{}ty fo{}{}, dr{}{}k)
</code></pre><p>But it's common to also want the index of items as well as the items
themselves. It's common to see programmers use <code>len()</code> and <code>range()</code> to iterate
over a list by index, but there's an easier way.</p>

<pre><code>drinks = ["coffee", "tea", "milk", "water"]
for index, drink in enumerate(drinks):
    print("Item {} is {}".format(index, drink))
#Item 0 is coffee
#Item 1 is tea
#Item 2 is milk
#Item 3 is water
</code></pre><p>The <code>enumerate</code> builtin yields both the index and the item itself.</p>
<h3 id="a-member-of-set-">A member of <code>set</code></h3>
<p>A surprising number of concepts can boil down to operations on a set. Need to
make sure a list doesn't has duplicates? Need to see what two lists have in
common? Python comes with a <code>set</code> type to make these operations fast and
readable.</p>

<pre><code># de{}{}pl{}{}ate a li{}{} *f{}{}t*
pr{}{}t({}{}t({}{}ha{}{}, "e{}{}s", "b{}{}on{}{} "h{}{}"]{}{}
# {'{}{}co{}{}, 'e{}{}s', 'h{}{}'}
</code></pre>
<pre><code># compare lists to find differences/similarities
# {} without "key":"value" pairs makes a set
menu = {"pancakes", "ham", "eggs", "bacon"}
new_menu = {"coffee", "ham", "eggs", "bacon", "bagels"}

new_items = new_menu.difference(menu)
print("Try our new", ", ".join(new_items))
# Try our new bagels, coffee

discontinued_items = menu.difference(new_menu)
print("Sorry, we no longer have", ", ".join(discontinued_items))
# Sorry, we no longer have pancakes
</code></pre>
<pre><code>ol{}{}it{}{}s = ne{}{}me{}{}.i{}{}er{}{}ct{}{}n({}{}nu)
pr{}{}t({}{}r get the sa{}{} ol{}{}, ", ".{}{}in{}{}ld{}{}te{}{}))
# Or get the sa{}{} old eg{}{}, ba{}{}n, ham
</code></pre><p>The <code>intersection</code> function compares all the items and returns only the items
both sets have in common. In this case, the breakfast staples of bacon, eggs,
and ham.</p>
<h3 id="collections-namedtuple">collections.namedtuple</h3>
<p>When you don't need to attach methods to a class, but still want the
convenience of <code>foo.prop</code>, look no further than namedtuple. You define the
fields ahead of time, then can instantiate a lightweight class that takes less
memory than a full object.</p>

<pre><code>LightObject = namedtuple('LightObject', ['shortname', 'otherprop'])
m = LightObject()
m.shortname = 'athing'
&gt; Traceback (most recent call last):
&gt; AttributeError: can't set attribute
</code></pre><p>You can't set attributes of a <code>namedtuple</code>, just like you can't change members
of a tuple. You need to set attributes when you instantiate your <code>namedtuple</code>.</p>

<pre><code>Li{}{}tO{}{}ect = na{}{}dt{}{}le{}{}Li{}{}tO{}{}ec{}{}, ['{}{}or{}{}am{}{}, 'o{}{}er{}{}op{}{})
n = Li{}{}tO{}{}ec{}{}sh{}{}tn{}{}e={}{}om{}{}hi{}{}', ot{}{}rp{}{}p={}{}om{}{}hi{}{} el{}{}')
n.{}{}or{}{}ame # so{}{}th{}{}g
</code></pre><h3 id="collections-defaultdict">collections.defaultdict</h3>
<p>It's not uncommon to see logic like this in a Python app, where it's expected
that a key won't exist initially.</p>

<pre><code>login_times = {}
for t in logins:
    if login_times.get(t.username, None):
        login_times[t.username].append(t.datetime)
    else:
        login_times[t.username] = [t.datetime]
</code></pre><p>With <code>defaultdict</code> you can skip this logic by making any access to an undefined
key return an empty list (or any other type).</p>

<pre><code>lo{}{}n_{}{}mes = co{}{}ec{}{}on{}{}de{}{}ul{}{}ic{}{}li{}{})
for t in lo{}{}ns:
    lo{}{}n_{}{}me{}{}t.{}{}er{}{}me{}{}ap{}{}nd{}{}.d{}{}et{}{}e)
</code></pre><p>You can even use custom classes, given a callable to build the class.</p>

<pre><code>from datetime import datetime
class Event(object):
    def __init__(self, t=None):
    if t is None:
        self.time = datetime.now()
    else:
        self.time = t

events = collections.defaultdict(Event)

for e in user_events:
    print(events[e.name].time)
</code></pre><p>To go beyond what defaultdict offers and to set nested keys as attributes,
check out <a href="https://github.com/mewwts/addict">addict</a></p>

<pre><code>no{}{}al{}{}ict = {
    'a{}{} {
        'b{}{} {
</code></pre><p>This snippet is <em>way</em> easier to write than it would be with the standard
<code>dict</code>, but what about <code>defaultdict</code>? Seems like it would be easy enough.</p>

<pre><code>from collections import defaultdict
default = defaultdict(dict)
default['a']['b']['c']['d']['e'] = 'really really nested dict' # fails
</code></pre><p>That looks ok, but it will actually throw a <code>KeyError</code> exception because
<code>default['a']</code> is a <code>dict</code>, not a <code>defaultdict</code>. Let's make a defaultdict that
defaults to defaulted dictionaries (say <em>that</em> a couple times fast).</p>
<p>If you just need a defaulted counter, you can use the
<a href="https://docs.python.org/3.4/library/collections.html#collections.Counter">collections.Counter</a> class which provides some convenience functions
like <code>most_common</code>.</p>
<h2 id="control-flow">Control Flow</h2>
<p>When learning control structures in Python, it's common to go over <code>for</code>,
<code>while</code>, <code>if-elif-else</code>, and <code>try-except</code>. Properly used, those few control
structures can handle most every case. There's a reason equivalents exist in
almost every language you run across. Python also offers some additions to the
basic structures that aren't often used, but can make your code more readable
and easier to maintain.</p>
<h3 id="great-exceptations">Great Exceptations</h3>
<p>Exceptions as flow control is a common pattern when dealing with databases,
sockets, files, or any resource that is likely to fail. With the standard <code>try</code>
and <code>except</code> something simple like working with a database might look like
this.</p>

<pre><code>tr{}{}
    # get API da{}{}
    da{}{} = db{}{}in{}{}id{}{}fo{}{}) # may ra{}{}e ex{}{}pt{}{}n
</code></pre><p>Can you spot the problem here? There are <em>two</em> possible exceptions that will
trigger the same <code>except</code> block. Meaning that failure to <em>find</em> the data (or to
connect to find the data) would cause a rollback attempt. This almost
definitely isn't what we want, because a failure at that point wouldn't have
even begun a transaction yet. A rollback also probably isn't the right response
to a connection failure, so let's break these cases apart.</p>
<p>First, we'll handle finding the data.</p>

<pre><code>try:
    # get API data
    data = db.find(id='foo') # may raise exception
except Exception:
    # log the failure and bail out
    log.warn("Could not retrieve FOO")
    return

# manipulate the data
db.add(data)
</code></pre><p>Now that the data retrieval has its own try-except we can take whatever action
makes sense if we don't have any data to work with. It's not likely our code
will do anything useful without data, so we'll just exit the function. Instead
of exiting you could also make a default object, retry the query, or kill the
entire program.</p>
<p>Now let's wrap the <code>commit</code> so it fails gracefully as well.</p>

<pre><code>tr{}{}
    db{}{}om{}{}t() # may ra{}{}e ex{}{}pt{}{}n
ex{}{}pt Ex{}{}pt{}{}n:
</code></pre><p>We've actually added two clauses here. First, let's look at the <code>else</code>, which
runs if no exception occurs. In our example, all it does is log that the
transaction succeeded, but you could put more interesting actions in as needed.
One potential use would be to fire off a background job or notification.</p>
<p>The <code>finally</code> clause is there to make it clear that the <code>db.close()</code> will
always run. Looking back, we can see that all the code related to persisting
our data ended up in a nice logical grouping at the same indentation level.
Editing this code later, it will be easy for us to see that all these lines are
tied to the <code>commit</code>.</p>
<h3 id="context-and-control">Context and Control</h3>
<p>We've seen control flow using exceptions before. In general, the steps are
something like:</p>
<ol>
<li>Attempt to acquire a resource (file, network connection, whatever)</li>
<li>If it fails, clean up anything left behind</li>
<li>Otherwise, perform actions on the resource</li>
<li>Log what happened</li>
<li>Program complete</li>
</ol>
<p>With that in mind, let's take a second look at the database example from the
last section. We used try-except-finally to make sure that any transaction we
began was either committed or rolled back.</p>

<pre><code>try:
    # attempt to acquire a resource
    db.commit()
except Exception:
    # If it fails, clean up anything left behind
    log.warn("Failure committing transaction, rolling back")
    db.rollback()
else:
    # If it works, perform actions
    # In this case, we just log success
    log.info("Saved the new FOO")
finally:
    # Clean up
    db.close()
# Program complete
</code></pre><p>Our previous example mapped to the steps above almost exactly. But how much of
this logic ever changes? Not very much.</p>
<p>Just about every time we save data, we'll do these exact same steps. We could
pull this logic into a method, or we could use a context manager.</p>

<pre><code>db = db{}{}ib{}{}ry{}{}on{}{}ct{}{}fa{}{}sq{}{}//{}{}
# as a fu{}{}ti{}{}
co{}{}it{}{}r_{}{}ll{}{}ck{}{}b)
</code></pre><p>A context manager makes it easy to protect some block by setting up resources
(context) that the block needs at runtime. In our example, we need a database
transaction that will be:</p>
<ol>
<li>Connected to a database</li>
<li>Started at the beginning of the block</li>
<li>Committed or rolled back at the end of the block</li>
<li>Cleaned up at the end of the block</li>
</ol>
<p>Let's build a context manager that will hide all this database setup for us.
The <code>contextmanager</code> interface is simple. The object is required to have a
<code>__enter__()</code> method to set up whatever context is needed and a
<code>__exit__(exc_type, exc_val, exc_tb)</code> method that will be called at the end of
the block. If there was no exception, then all three of the <code>exc_*</code> arguments
will be <code>None</code>.</p>
<p>The <code>__enter__</code> method will be pretty simple, so let's start with that.</p>

<pre><code>class DatabaseTransaction(object):
    def __init__(self, connection_info):
        self.conn = db_library.connect(connection_info)

    def __enter__(self):
        return self.conn
</code></pre><p>The <code>__enter__</code> method actually does nothing except return the database
connection, which we can use inside the block to retrieve or save data. The
<code>__init__</code> method is where the connection is actually made, and if it fails the
block won't run at all.</p>
<p>Now let's define how the transaction will be finished in the <code>__exit__</code> method.
This has a lot more to it, since it has to handle any exceptions thrown in the
block and close out the transaction.</p>

<pre><code>    def __{}{}it{}{}(s{}{}f, ex{}{}ty{}{}, ex{}{}va{}{} ex{}{}tb{}{}
        if ex{}{}ty{}{} is not No{}{}:
            se{}{}.c{}{}n.{}{}ll{}{}ck{}{}
</code></pre><p>Now we can use our <code>DatabaseTransaction</code> as the context manager for our block
of actions. Under the hood, the <code>__enter__</code> and <code>__exit__</code> methods will run and
handle setting up the database connection and tear it down when we're through.</p>

<pre><code># context manager
with DatabaseTransaction("fakesql://") as db:
    # retrieve data here
    # modify data here
</code></pre><p>To improve our (primitive) transaction manager, we could add handling for
different exception types. Even in its current state, this hides a <em>ton</em> of
complexity that you don't need to be worrying about every time you pull in
something from the database.</p>
<h3 id="generators">Generators</h3>
<p>Introduced in Python 2, generators are a simple way to implement an iterator
that doesn't hold all its values at once. Typically a function in Python starts
its execution, does some operations, and returns the result (or nothing).</p>
<p>Generators are different.</p>

<pre><code>def my{}{}en{}{}at{}{}(v{}{}
    yi{}{}d 'f{}{}st ' + v
    yi{}{}d 's{}{}ond ' + v
</code></pre><p>Instead of <code>return</code> we use the <code>yield</code> keyword, which is what makes a generator
special. When calling <code>my_generator('thing')</code> instead of getting the result of
the function we get a generator object, which can be used anywhere you could
use a list or other iterable.</p>
<p>Most often, you'll use generators as part of a loop as below. The loop will
continue until the generator stops <code>yield</code>ing values.</p>

<pre><code>for value in my_generator('thing'):
    print value

# first thing
# second thing
# third thing

gen = my_generator('thing')
next(gen)
# 'first thing'
next(gen)
# 'second thing'
next(gen)
# 'third thing'
next(gen)
# raises StopIteration exception
</code></pre><p>After being instantiated, a generator doesn't do anything until it is asked for
a value. It will execute until the first <code>yield</code> and pass that value to the
caller, then wait (saving its state) until another value is requested.</p>
<p>Now let's make a generator that's a bit more useful than just giving back 3
hard-coded items. The classic generator example is an endless fibonacci
generator, so let's give that a try. It will start at 1 and give the sum of the
prior two numbers for as long as you ask it to.</p>

<pre><code>def fi{}{}ge{}{}ra{}{}r({}{}
    a = 0
    b = 1
</code></pre><p>A <code>while True</code> loop in a function would normally be something to avoid because
the function would never return, but for a generator it's fine as long as
there's a <code>yield</code> in the loop. We do need to be careful to have an end
condition when we use this generator, because it will happily add numbers
forever.</p>
<p>Now let's use our generator to calculate the first fibonacci number that's
greater than 10,000.</p>

<pre><code>min = 10000
for number in fib_generator():
    if number &gt; min:
        print(number, "is the first fibonacci number over", min)
        break
</code></pre><p>That was pretty easy, and we can make that number as large as we want and it
will still (eventually) come up with the first number larger than X in the
fibonacci sequence.</p>
<p>Let's try out a more practical example. Paginating APIs is common practice to
limit usage and avoid sending 50 megabytes of JSON (!!!) to a mobile device.
First, we'll define the API we're using and then we'll write a generator around
it to hide the paging from our code.</p>
<p>The API we're using is called Scream, a place where users can argue about
restaurants they've eaten at or want to eat at. Their API for searching is
pretty simple, and looks like this.</p>

<pre><code>GET ht{}{}:/{}{}cr{}{}m-{}{}ou{}{}fo{}{}.c{}{}/s{}{}rc{}{}q={}{}ff{}{}
{
    "r{}{}ul{}{}": [
</code></pre><p>Neat! They embedded the link to the next page in the API response so it'll be
extremely easy to get the next page when it's time. We can also leave off the
page number to just get the first page. To get the data, we'll use the
always-handy <a href="http://docs.python-requests.org/en/latest/">requests</a> library and wrap it in a generator to display
our search results.</p>
<p>The generator will handle pagination and have limited retry logic, and will
work something like:</p>
<ol>
<li>Receive search term</li>
<li>Query the scream-about-food API</li>
<li>Try again if the API fails</li>
<li>Yield the results from the page it gets one at a time</li>
<li>Get the next page if there is one</li>
<li>Exit when there are no more results</li>
</ol>
<p>Easy enough. To start with, we'll implement the generator without retries to
keep the code simple.</p>

<pre><code>import requests

api_url = "http://scream-about-food.com/search?q={term}"

def infinite_search(term):
    url = api_url.format(term)
    while True:
        data = requests.get(url).json()

        for place in data['results']:
            yield place

        # end if we've gone through all the results
        if not data['more']: break

        url = data['_next']
</code></pre><p>When you create a generator, you only need to pass in search terms and the
generator will build the query and get results as long as they exist. There are
(of course) some rough edges here. Exceptions aren't handled at all, and if the
API fails or returns unexpected JSON the generator will raise an exception.</p>
<p>Despite these rough spots, we can still use it to find out what number our
restaurant is in the search results for the term "coffee".</p>

<pre><code># pa{}{} a nu{}{}er to st{}{}t at as the se{}{}nd ar{}{}me{}{} if you do{}{}t wa{}{}
# ze{}{}-i{}{}ex{}{}g
for nu{}{}er, re{}{}lt in en{}{}er{}{}e({}{}fi{}{}te{}{}ea{}{}h({}{}of{}{}e"{}{} 1):
</code></pre><p>The generator handles iterating over each page of search results, so all we
have to do is use the <code>enumerate</code> builtin from earlier in the article to keep
track of the number of results and print them when we find our shop.</p>
<p>As an exercise, go ahead and add a counter to the <code>infinite_search</code> generator
so we can write code like this instead.</p>

<pre><code>for result in infinite_search("coffee"):
    if result['name'] == "The Coffee Stain":
        print("Our restaurant, The Coffee Stain is number ", result['number'])
        return
print("Our restaurant, The Coffee Stain didn't show up at all! :(")
</code></pre><p>If you write Python 3, you already use generators when you use the standard
library. Calls like <code>dict.items()</code> now return generators instead of lists. To
get this behavior in Python 2 <code>dict.iteritems()</code> was added, but isn't as
frequently used.</p>
<h2 id="python-2-and-3-compatibility">Python 2 and 3 compatibility</h2>
<p>Moving from Python 2 to Python 3 can be an undertaking for any codebase (or any
developer) but it's possible to write code that runs in both. Support for
Python 2.7 will continue until 2020, but it's unlikely that many new features
will be backported. For now, it's recommended to support Python 2.7 and 3+
unless it's feasible for you to drop Python 2 support entirely.</p>
<p>For a comprehensive guide on supporting both versions, see the
<a href="https://docs.python.org/3.5/howto/pyporting.html">Porting Python 2 Code</a> guide
from python.org.</p>
<p>Let's look over the most common things you'll run into when trying to write
compatible code, and how to use <code>__future__</code> to work around them.</p>
<h3 id="print-or-print-">print or print()</h3>
<p>Just about every developer who has switched from Python 2 to 3 has typed the
wrong <code>print</code> statement. Fortunately, you can standardize on using print as a
function (Python 3 style) instead of a keyword by just importing
<code>print_function</code>.</p>

<pre><code>pr{}{}t "h{}{}lo"  # Py{}{}on 2
pr{}{}t({}{}el{}{}") # Py{}{}on 3

</code></pre><h3 id="divided-over-division">Divided Over Division</h3>
<p>The default behavior for division in Python also changed between 2 and 3. In
Python 2, dividing integers would perform integer-only division, chopping off
any trailing decimals. This wasn't what most users expected, so it was changed
in Python 3 to use floating point division even when dividing integers.</p>

<pre><code>print(1 / 3) # Python 2
# 0
print(1 / 3) # Python 3
# 0.3333333333333333
print(1 // 3) # Python 3
# 0
</code></pre><p>This sort of behavior change brings in a bunch of subtle bugs when writing code
to run in both major versions. Again, we're saved by the <code>__future__</code> module.
Importing <code>division</code> makes these behaviors identical in both versions.</p>

<pre><code>fr{}{} __{}{}tu{}{}__ im{}{}rt di{}{}si{}{}
pr{}{}t(1 / 3)# Py{}{}on 2
# 0.{}{}33{}{}33{}{}33{}{}33
</code></pre><h2 id="fin-thanks-for-reading">Fin - Thanks for Reading</h2>
<p>Thanks for reading, I hope you learned at least one thing. If you have
something to add (or correct, no writer is perfect) I'll be checking the
comments section frequently. If you enjoyed this article, you might want to
check out this one on <a href="https://www.airpair.com/python/posts/python-comprehension-syntax"><code>list</code> and <code>dict</code> comprehensions</a> or
a more in-depth treatment of <a href="https://www.airpair.com/python/posts/python-2-vs-python-3">Python 2 and 3</a></p>
<p>Thanks to commenters dalke (on HackerNews), György Kiss, mikemikemikemikemike,
Karl-Aksel Puulmann, Bartłomiej "furas" Burek, and Peter Venable for
finding errors and omissions in this article.</p>
</post>

  </div></body></html>