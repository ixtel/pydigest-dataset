<html><body><div><div class="reading-wrapper">
    <p>Storing your Django site's static and media files on Amazon S3, instead of serving them yourself, can make your site perform better.</p>
<p>This post is about how to do that. We'll describe how to set up an S3 bucket with the proper permissions and configuration, how to upload static and media files from Django to S3, and how to serve the files from S3 when people visit your site.</p>
<h2>S3 Bucket Access</h2>
<p>We'll assume that you've got access to an S3 account, and a user with the permissions you'll need.</p>
<p>The first thing to consider is that, while I might be using my <code>dpoirier</code> userid to set this up, I probably don't want our web site using my <code>dpoirier</code> userid permanently.  If someone was able to break into the site and get the credentials, I wouldn't want them to have access to everything I own. Or if I left Caktus (unthinkable though that is), someone else might need to be able to manage the resources on S3.</p>
<p>What we'll do is set up a separate AWS user, with the necessary permissions to run the site, but no more, and then have the web site use that user instead of your own.</p>
<ul>
<li><a href="http://docs.aws.amazon.com/AmazonS3/latest/UG/CreatingaBucket.html">Create the bucket</a>.</li>
<li>Create a new user:
<strong> Go to <a href="https://console.aws.amazon.com/iam/home?#users">AWS IAM</a>.
</strong> Click "Create new users" and follow the prompts.  Leave "Generate an access key for each User" selected.</li>
<li>Get the credentials</li>
<li>Go to the new user's Security Credentials tab.</li>
<li>Click "Manage access keys",</li>
<li>Download the credentials for the access key that was created, and</li>
<li><em>Save them somewhere</em> because no one will ever be able to download them again.</li>
<li>(Though it's easy enough to create a new access key if you lose the old one's secret key.)</li>
<li>Get the new user's ARN (Amazon Resource Name) by going to the user's Summary tab. It'll look like this: "arn:aws:iam::123456789012:user/someusername"</li>
<li>Go to the bucket properties in the <a href="https://console.aws.amazon.com/s3/home">S3 management console</a>.</li>
<li>
<p>Add a bucket policy that looks like this, but change "BUCKET-NAME" to the bucket name, and "USER-ARN" to your new user's ARN. The first statement makes the contents publicly readable (so you can serve the files on the web), and the second grants full access to the bucket and its contents to the specified user::</p>
<div class="codehilite"><pre>{
    "Statement": [
        {
          "Sid":"PublicReadForGetBucketObjects",
          "Effect":"Allow",
          "Principal": {
                "AWS": "*"
             },
          "Action":["s3:GetObject"],
          "Resource":["arn:aws:s3:::BUCKET-NAME/*"
          ]
        },
        {
            "Action": "s3:*",
            "Effect": "Allow",
            "Resource": [
                "arn:aws:s3:::BUCKET-NAME",
                "arn:aws:s3:::BUCKET-NAME/*"
            ],
            "Principal": {
                "AWS": [
                    "USER-ARN"
                ]
            }
        }
    ]
}
</pre></div>


</li>
<li>
<p>If you need to add limited permissions for another user to do things with this bucket, you can add more statements. For example, if you want another user to be able to copy all the content from this bucket to another bucket:</p>
<div class="codehilite"><pre>    {
        "Action": "s3:ListBucket",
        "Effect": "Allow",
        "Resource": "arn:aws:s3:::BUCKET-NAME",
        "Principal": {
            "AWS": [
                "USER-ARN"
            ]
        }
    }
</pre></div>


</li>
</ul>
<p>That will let the user list the objects in the bucket. The bucket was already publicly readable, but not listable, so adding this permission will let the user sync from this bucket to another one where the user has full permissions.</p>
<p>Expected results:</p>
<ul>
<li>The site can use the access key ID and secret key associated with the user's access key to access the bucket</li>
<li>The site will be able to do anything with that bucket</li>
<li>The site will not be able to do anything outside that bucket</li>
</ul>
<h2>S3 for Django static files</h2>
<p>The simplest case is just using S3 to serve your static files. In Django, we say "static files" to refer to the fixed files that we provide and serve as part of our site - typically images, css, and javascript, and maybe some static HTML files.  Static files do not include any files that might be uploaded by users of the site.  We call those "media files".</p>
<p>Before continuing, you should be familiar with <a href="https://docs.djangoproject.com/en/1.6/howto/static-files/">managing static files</a>, <a href="https://docs.djangoproject.com/en/1.6/ref/contrib/staticfiles/">the staticfiles app</a>, and <a href="https://docs.djangoproject.com/en/1.6/howto/static-files/deployment/">deploying static files</a> in Django.</p>
<p>Also, your templates should never hard-code the URL path of your static files. Use the <a href="https://docs.djangoproject.com/en/1.7/ref/contrib/staticfiles/#static">static tag</a> instead:</p>
<div class="codehilite"><pre>      {% load static from staticfiles %}
      &lt;img src="{% static 'images/rooster.png' %}"/&gt;
</pre></div>


<p>That will use whatever the appropriate method is to figure out the right URL for your static files.</p>
<h3>The two static tags</h3>
<p>Django provides <em>two</em> template tags named <code>static</code>.</p>
<p>The first <code>static</code> is in the <code>static</code> templatetags library, and accessed using <code>{% load static %}</code>.  It just puts the value of <code>STATIC_URL</code> in front of the path.</p>
<p>The one from <code>staticfiles</code> (<code>{% load static from staticfiles %}</code>)  is smarter - it uses whatever storage class you've configured for static files to come up with the URL.</p>
<p>By using the one from <code>staticfiles</code> from the start, you'll be prepared for any storage class you might decide to use in the future.</p>
<h3>Moving your static files to S3</h3>
<p>In order for your static files to be served from S3 instead of your own server, you need to arrange for two things to happen:</p>
<ol>
<li>When you serve pages, any links in the pages to your static files should point at their location on S3 instead of your own server.</li>
<li>Your static files are on S3 and accessible to the web site's users.</li>
</ol>
<p>Part 1 is easy if you've been careful not to hardcode static file paths in your templates. Just change STATICFILES_STORAGE in your settings.</p>
<p>But you still need to get your files onto S3, and keep them up to date. You could do that by running <code>collectstatic</code> locally, and using some standalone tool to sync the collected static files to S3, at each deploy. But we won't be able to get away with such a simple solution for media files, so we might as well go ahead and set up the custom Django storage we'll need now, and then our <code>collectstatic</code> will copy the files up to S3 for us.</p>
<p>To start, install two Python packages: <a href="http://django-storages.readthedocs.org/en/latest/">django-storages</a> (yes, that's "storages" with an "S" on the end), and <a href="https://pypi.python.org/pypi/boto/">boto</a>:</p>
<div class="codehilite"><pre>    $ pip install django-storages boto
</pre></div>


<p>Add <code>'storages'</code> to <code>INSTALLED_APPS</code>:</p>
<div class="codehilite"><pre>    INSTALLED_APPS = (
          ...,
          'storages',
     )
</pre></div>


<p>If you want (optional), add this to your common settings:</p>
<div class="codehilite"><pre>    AWS_HEADERS = {  # see http://developer.yahoo.com/performance/rules.html#expires
        'Expires': 'Thu, 31 Dec 2099 20:00:00 GMT',
        'Cache-Control': 'max-age=94608000',
    }
</pre></div>


<p>That will tell boto that when it uploads files to S3, it should set properties on them so that when S3 serves them, it'll include those HTTP headers in the response. Those HTTP headers in turn will tell browsers that they can cache these files for a very long time.</p>
<p>Now, add this to your settings, changing the first three values as appropriate:</p>
<div class="codehilite"><pre>    AWS_STORAGE_BUCKET_NAME = 'BUCKET_NAME'
    AWS_ACCESS_KEY_ID = 'xxxxxxxxxxxxxxxxxxxx'
    AWS_SECRET_ACCESS_KEY = 'yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'

    # Tell django-storages that when coming up with the URL for an item in S3 storage, keep
    # it simple - just use this domain plus the path. (If this isn't set, things get complicated).
    # This controls how the `static` template tag from `staticfiles` gets expanded, if you're using it.
    # We also use it in the next setting.
    AWS_S3_CUSTOM_DOMAIN = '%s.s3.amazonaws.com' % AWS_STORAGE_BUCKET_NAME

    # This is used by the `static` template tag from `static`, if you're using that. Or if anything else
    # refers directly to STATIC_URL. So it's safest to always set it.
    STATIC_URL = "https://%s/" % AWS_S3_CUSTOM_DOMAIN

    # Tell the staticfiles app to use S3Boto storage when writing the collected static files (when
    # you run `collectstatic`).
    STATICFILES_STORAGE = 'storages.backends.s3boto.S3BotoStorage'
</pre></div>


<p>Only the first three lines should need to be changed for now.</p>
<h3>CORS</h3>
<p>One more thing you need to set up is <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html">CORS</a>. CORS defines a way for client web applications that are loaded in one domain to interact with resources in a different domain. Since we're going to be serving our static files and media from a different domain, if you don't take CORS into account, you'll run into mysterious problems, like Firefox not using your custom fonts for no apparent reason.</p>
<p>Go to your S3 bucket properties, and under "Permissions", click on "Add CORS Configuration".  Paste this in:</p>
<div class="codehilite"><pre>    <span class="nt">&lt;CORSConfiguration&gt;</span>
        <span class="nt">&lt;CORSRule&gt;</span>
            <span class="nt">&lt;AllowedOrigin&gt;</span>*<span class="nt">&lt;/AllowedOrigin&gt;</span>
            <span class="nt">&lt;AllowedMethod&gt;</span>GET<span class="nt">&lt;/AllowedMethod&gt;</span>
            <span class="nt">&lt;MaxAgeSeconds&gt;</span>3000<span class="nt">&lt;/MaxAgeSeconds&gt;</span>
            <span class="nt">&lt;AllowedHeader&gt;</span>Authorization<span class="nt">&lt;/AllowedHeader&gt;</span>
        <span class="nt">&lt;/CORSRule&gt;</span>
    <span class="nt">&lt;/CORSConfiguration&gt;</span>
</pre></div>


<p>I won't bother to explain this, since there are plenty of explanations on the web that you can Google for. The tricky part is knowing you need to add CORS in the first place.</p>
<h3>Try it</h3>
<p>With this all set up, you should be able to upload your static files to S3 using collectstatic:</p>
<div class="codehilite"><pre>    python manage.py collectstatic
</pre></div>


<p>If you see any errors, double-check all the steps above.</p>
<p>Once that's successful, you should be able to start your test site and view some pages. Look at the page source and you should see that the images, css, and javascript are being loaded from S3 instead of your own server.  Any media files should still be served as before.</p>
<p>Don't put this into production quite yet, though. We still have some changes to make to how we're doing this.</p>
<h2>Moving Media Files to S3</h2>
<p>Reminder: Django "media" files are files that have been uploaded by web site users, that then need to be served from your site. One example is a user avatar (an image the user uploads and the site displays with the user's information).</p>
<p>Media files are typically managed using <code>FileField</code> and <code>ImageField</code> fields on models. In a template, you use the <code>url</code> attribute on the file field to get the URL of the underlying file.</p>
<p>For example, if <code>user.avatar</code> is an <code>ImageField</code> on your user model, then</p>
<div class="codehilite"><pre><span class="x">    &lt;img src="</span><span class="cp">{{</span> <span class="nv">user.avatar.url</span> <span class="cp">}}</span><span class="x">"&gt;</span>
</pre></div>


<p>would embed the user's avatar image in the web page.</p>
<p>By default, when a file is uploaded using a <code>FileField</code> or <code>ImageField</code>, it is saved to a file on a path inside the local directory named by <code>MEDIA_ROOT</code>, under a subdirectory named by the field's <code>upload_to</code> value. When the file's <code>url</code> attribute is accessed, it returns the value of <code>MEDIA_URL</code>, prepended to the file's path inside <code>MEDIA_ROOT</code>.</p>
<p>An example might help. Suppose we have these settings:</p>
<div class="codehilite"><pre>    MEDIA_ROOT = '/var/media/'
    MEDIA_URL = 'http://media.example.com/'
</pre></div>


<p>and this is part of our user model:</p>
<div class="codehilite"><pre>    avatar = models.ImageField(upload_to='avatars')
</pre></div>


<p>When a user uploads an avatar image, it might be saved as <code>/var/media/avatars/12345.png</code>. Then <code>&lt;img src="{{ user.avatar.url }}"&gt;</code> would expand to <code>&lt;img src="https://media.example.com/avatars/12345.png"&gt;</code>.</p>
<p>Our goal is instead of saving those files to a local directory, to send them to S3. Then instead of having to serve them somehow locally, we can let Amazon serve them for us.</p>
<p>Another advantage of using S3 for media files is if you scale up by adding more servers, this makes uploaded images available on all servers at once.</p>
<h3>Configuring Django media to use S3</h3>
<p>Ideally, we'd be able to start putting new media files on S3 just by adding this to our settings:</p>
<div class="codehilite"><pre>    # DO NOT DO THIS!
    MEDIA_URL = "https://%s/" % AWS_S3_CUSTOM_DOMAIN
    DEFAULT_FILE_STORAGE = 'storages.backends.s3boto.S3BotoStorage'
</pre></div>


<p>Adding those settings would indeed tell Django to save uploaded files to our S3 bucket, and use our S3 URL to link to them.</p>
<p>Unfortunately, this would store our media files on top of our static files, which we're already keeping in our S3 bucket.  If we were careful to always set <code>upload_to</code> on our FileFields to directory names that would never occur in our static files, we might get away with it (though I'm not sure Django would even let us). But we can do better.</p>
<p>What we want to do is either enforce storing our static files and media files in different subdirectories of our bucket, or use two different buckets. I'll show how to use the different paths first.</p>
<p>In order for our <code>STATICFILES_STORAGE</code> to have different settings from our <code>DEFAULT_FILE_STORAGE</code>, they need to use two different storage classes; there's no way to configure anything more fine-grained. So, we'll start by creating a custom storage class for our static file storage, by subclassing S3BotoStorage. We'll also define a new setting, so we don't have to hard-code the path in our Python code:</p>
<div class="codehilite"><pre>    <span class="c"># custom_storages.py</span>
    <span class="kn">from</span> <span class="nn">django.conf</span> <span class="kn">import</span> <span class="n">settings</span>
    <span class="kn">from</span> <span class="nn">storages.backends.s3boto</span> <span class="kn">import</span> <span class="n">S3BotoStorage</span>

    <span class="k">class</span> <span class="nc">StaticStorage</span><span class="p">(</span><span class="n">S3BotoStorage</span><span class="p">):</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">STATICFILES_LOCATION</span>
</pre></div>


<p>Then in our settings:</p>
<div class="codehilite"><pre>    STATICFILES_LOCATION = 'static'
    STATICFILES_STORAGE = 'custom_storages.StaticStorage'
    STATIC_URL = "https://%s/%s/" % (AWS_S3_CUSTOM_DOMAIN, STATICFILES_LOCATION)
</pre></div>


<p>Giving our class a <code>location</code> attribute of <code>'static'</code> will put all our files into paths on S3 starting with <code>'static/'</code>.</p>
<p>You should be able to run <code>collectstatic</code> again, restart your site, and now all your static files should have '/static/' in their URLs. Now delete from your S3 bucket any files outside of '/static' (using the S3 console, or whatever tool you like).</p>
<p>We can do something very similar now for media files, adding another storage class:</p>
<div class="codehilite"><pre>    <span class="k">class</span> <span class="n">MediaStorage</span>(<span class="n">S3BotoStorage</span>):
        <span class="n">location</span> = <span class="n">settings</span>.<span class="n">MEDIAFILES_LOCATION</span>
</pre></div>


<p>and in settings:</p>
<div class="codehilite"><pre>    MEDIAFILES_LOCATION = 'media'
    MEDIA_URL = "https://%s/%s/" % (AWS_S3_CUSTOM_DOMAIN, MEDIAFILES_LOCATION)
    DEFAULT_FILE_STORAGE = 'custom_storages.MediaStorage'
</pre></div>


<p>Now when a user uploads their avatar, it should go into '/media/' in our S3 bucket.  When we display the image on a page, the image URL will include '/media/'.</p>
<h3>Using different buckets</h3>
<p>You can use different buckets for static and media files by adding a <code>bucket_name</code> attribute to your custom storage classes.  You can see the whole list of attributes you can set by looking at the source for <code>S3BotoStorage</code>.</p>
<h3>Moving an existing site's media to S3</h3>
<p>If your site already has user-uploaded files in a local directory, you'll need to copy them up to your media directory on S3. There are lots of tools these days for doing this kind of thing. If the command line is your thing, try the AWS CLI tools from Amazon. They worked okay for me.</p>
<h3>Summary</h3>
<p>Serving your static and media files from S3 requires getting a lot of different parts working together. But it's worthwhile for a number of reasons:</p>
<ul>
<li>S3 can probably serve your files more efficiently than your own server.</li>
<li>Using S3 saves the resources of your own server for more important work.</li>
<li>Having media files on S3 allows easier scaling by replicating your servers.</li>
<li>Once your files are on S3, you're well on the way to using CloudFront to
  serve them even more efficiently using Amazon's CDN service.</li>
</ul>
  </div>
</div></body></html>