<html><body><div><div class="entry-content">
		<a id="dd_start"/><p><strong>A first hand experience and an introduction to Clojure at scale</strong></p>
<p>Still considered a bit of an esoteric language, Clojure is one of the JVM languages that get us excited. There aren’t many stories around about why companies start using Clojure or how they use it to build systems at Scale. We were lucky to hear an excellent example of using Clojure during a demo of <a href="http://www.takipi.com/?utm_source=Blog&amp;amp;utm_medium=in-post&amp;amp;utm_content=clojurescale&amp;amp;utm_campaign=clojure">Takipi’s error viewer for Clojure</a> at AppsFlyer’s office where we learned about the architecture that powers their mobile app measuring and tracking platform.</p>
<p>In this post we’re sharing with you the experience of our new friends from AppsFlyer, Adi Shacham-Shavit, who manages the R&amp;D department, and Ron Klein, a senior backend developer. First thing’s first, a huge thanks to Ron and Adi who treated us to behind the scenes of Clojure at <a href="http://www.appsflyer.com/" target="_blank">AppsFlyer</a>! If you have any questions for them and interested to learn more, please feel free to use the comments section below.</p>
<p><span id="more-682"/></p>
<p>Here’s their story:</p>
<h2>Let’s get started with some numbers</h2>
<ul>
<li>2 Billion events per day</li>
<li>The traffic was doubled in the last 3 months</li>
<li>Hundreds of instances</li>
<li>The company grew from 6 to 50 people over the past year</li>
<li>10 Clojure developers</li>
<li>Technologies – Redis, Kafka, Couchbase, CouchDB, Neo4j, ElasticSearch, RabbitMQ, Consul, Docker, Mesos, MongoDB, Riemann, Hadoop, Secor, Cascalog, AWS</li>
</ul>
<h2>The Pains of Scaling Up</h2>
<p>At AppsFlyer we actually started our code base in Python. Two years later this wasn’t enough to handle the growing number of users and requests. We started to encounter issues like one of the critical Python processes taking too long to digest the incoming messages, caused mainly by string manipulations and Python’s own memory management system. Even partitioning the messages amongst several processes and servers could not overcome this. This eventually killed the process and caused data loss – the first ‘Python victim’ was the reporting service.</p>
<p><span data-sheets-value="[null,2,&quot;[adrotate group=\&quot;11\&quot;]&quot;]" data-sheets-userformat="[null,null,513,[null,0],null,null,null,null,null,null,null,null,0]"/></p>
<h2>Taking the functional approach</h2>
<p>As these kinds of difficulties accumulated, we had to choose between 2 options:</p>
<ol>
<li>Rewrite some of our services in C (great performance, but less fun to code) and wrap it with Python interop code (easy to do)</li>
<li>Rewrite some of our services in a programming language more suitable for data processing</li>
</ol>
<p>It is important to mention at this point, that we took the asynchronous event-driven approach to handle incoming messages, which allows the system to easily scale as traffic grows.</p>
<p>We’ve been toying around with the idea of introducing Functional Programming into the company for some time before the rogue reporting service started failing. It’s a good fit with our way of thinking and architecture, so it was logical to make the change – especially since the reporting service failures encouraged us to make the call already. After deciding to go with it, came the second hurdle, which language should we choose?</p>
<h2>Scala Vs. OCaml Vs. Haskell Vs. Clojure</h2>
<p>Scala was out of the picture because it’s a hybrid of Object Oriented Programming &amp; Functional Programming and leans more towards OOP. OCaml was discarded because of the relatively small community and the Global Interpreter Lock (GIL) that allows only one thread to execute at a time – even on multicore machines (which was also a problem for us in Python). Monads in Haskell made us cringe in fear, so we were left with Clojure.</p>
<p>But that’s not the only reason we chose this path, Clojure won because of 2 major issues. First, it runs on the JVM and second, it’s a functional language with easy access to a mutable state if you need it, even in a heavily concurrent environment.</p>
<p><a href="http://clojure.org/" target="_blank">Clojure</a> is a dialect of the Lisp programming language by Rich Hickey. It’s a general-purpose programming language with an emphasis on functional programming. Like other Lisps, Clojure treats code as data and has a macro system. At its center are immutable values and explicit progression-of-time constructs that are intended to facilitate the development of more robust programs, particularly multithreaded ones.</p>
<h2>Micro-services architecture</h2>
<p>The server side of AppsFlyer’s system is designed to continuously receive messages (events), process them, store them, and sometimes invoke additional web requests to external endpoints based on them. This “stream” of events made us take some architectural decisions that helped us scale as needed. One of the main decisions was to think of the system as a collection of services, intercommunicating mainly by message queues (formerly via Redis’ pub/sub and currently via Kafka). This made our services independent and loosely coupled.</p>
<h2>The flow of events</h2>
<p>Let’s take a simplified example: the event of “Application Installed” is published to the entire system through a Kafka topic (queue) named “Installs”. Our Reports service listens to that topic so that it could store this piece of data for the relevant reports. In addition, our Postbacks service listens to that very same topic, and decides, upon its own rules, whether or not to invoke a web request and to which endpoint.</p>
<p>Since the entire system is based on micro-services that consume messages from (and publish messages to) a common pipeline, it’s easy to rewrite them in any programming language, assuming that it has a decent client library to the common pipeline. Kafka is used as the main backbone, with RabbitMQ for the real-time channel.<br/>
Concurrency in Clojure</p>
<p>Clojure provides its own approach to concurrency and it might take some time to adjust to it. However, once the mindset is there, it’s much easier to achieve tasks in Clojure than when taking the “conventional” approach. In most cases, writing code that deals with concurrency in Clojure doesn’t include lock statements at all. This is a huge advantage: coding is more focused on the logic itself, rather than the plumbing around locks.</p>
<p>Clojure also has mechanisms that guard data from being corrupted. This, of course, comes with a trade-off: there’s a very low probability that the shared resource held by thread A does not contain all changes made earlier by thread B. Generally speaking, Clojure provides a nice mechanism of immutable data structures, ensuring data integrity and somewhat sacrificing consistency. Clojure has access to almost everything the JVM can provide so you can still use traditional locks. However, if the system you build is based on statistics, and you can tolerate minor data loss, such as the analytics system we have at AppsFlyer, then Clojure is way more than enough.</p>
<h2>A real life example</h2>
<p>Say we have a service that holds its state in a key-value data structure, a <em>map</em>. The map is initially defined in the module level as empty (this example is simplified for clarity, so code is not written to be fully reusable):</p>
<pre class="brush: java; auto-links: false;">

(def my-map {})
;; Don't panic, you'll get used to the braces...

</pre>
<p>The statement above creates an empty map, accessible by the name <em>my-map</em>.</p>
<p>The first thing that strikes most newcomers to Clojure programming, after the braces syntax, is the freedom of naming variables. Clojure allows some interesting characters for variable names such as “-“, “?”, “!” etc. Think about the simplicity behind a function named contains? used to check whether a collection contains an item.</p>
<p>The basic code to add a key “k” with a value “v” to a given map is:</p>
<pre class="brush: java; auto-links: false;">

(assoc some-map "k" "v")

</pre>
<p>This code <strong>does not</strong> update the original map. Clojure keeps its data structures as immutable as possible. Instead, the statement above returns a new copy of the original map, with the new key and the new value. Behind the scenes, Clojure doesn’t fully duplicate the entire map. Instead, it keeps revisions with pointers to previous revisions, along with the differences. Smart, eh?!</p>
<p>Back to <em>my-map</em>. We’ll have to modify our statement so that it’s ready for concurrency:</p>
<pre class="brush: java; auto-links: false;">

(def my-map (atom {}))

</pre>
<p>That little <em>atom</em> is almost all we need to go the concurrent way. So now, when a running thread “updates” <em>my-map</em> (read: creates a new revision of it) so that it also contains the key “my-key” with the value 42, the code looks like this:</p>
<pre class="brush: java; auto-links: false;">

(swap! my-map assoc "my-key" 42)

</pre>
<p>This statement changes <em>my-map</em> so that it now holds a new version of itself.</p>
<p>So far, we have a thread “updating” <em>my-map</em>. Reading a map in Clojure and continuing with the previous example, looks like this:</p>
<pre class="brush: java; auto-links: false;">

(get some-map "k")

</pre>
<p>The statement above should return the value “v.” When working with Clojure’s <em>atom</em>, the following code can be executed when a thread reads a value from <em>my-map</em>:</p>
<pre class="brush: java; auto-links: false;">

(get @my-map "my-key")

</pre>
<p>The only difference is that little “@” before <em>my-map</em>. What it says is something like, “Hey Clojure, give me the latest revision you have for <em>my-map</em>.” As stated above, the latest, most updated revision might not contain all the changes that have been made to our map so far, but the returned value is always safe in terms of data integrity (e.g. not corrupted).</p>
<h2>Conclusion</h2>
<p>Clojure has its own mindset – immutable objects, Lispy syntax, etc. The major advantage is in its approach to concurrency, focusing on an application’s logic and reducing the overhead of locking mechanisms. This post covers just a tiny bit of Clojure’s way of concurrency. We experienced a significant performance boost when we moved AppsFlyer to Clojure. In addition, using functional programming allows us to have a really small code base with only a few hundred lines of code for each service. The effects of working in Clojure dramatically speed up the development time and allow us to create a new service in days.</p>
<p><strong>Know great Java hacks</strong>? Always wanted to share coding insights with fellow developers?<br/>
If you want to contribute to Takipi’s blog, and reach more than 80,000 developers a month, we’re looking for guest writers! Shoot us an email with your idea for a guest post: <a href="mailto:hello@takipi.com" target="_blank">hello@takipi.com</a>.</p>
<a id="dd_end"/>	</div>

	</div></body></html>