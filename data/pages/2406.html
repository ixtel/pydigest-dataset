<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/files/1db/618/216/1db618216e1e4813bdb50e4e10d15d07.png" align="left"/><p>Hi, All. 
</p><p>
Ранее я работал с C-подобными языками, теперь же пришлось сесть за Python. Синтаксис дался легко, и наступил черёд каверзных вопросов. Под катом — статья про то как в Python реализовано хранение данных в памяти. Не претендую на истину, но пробую разобраться.
</p><a name="habracut"/>
<h4>Смотрим на ссылки</h4><p>
Начнём с самого простого. Любые данные в Python это объект, любая переменная — ссылка на объект. Не существует никаких данных, которые не являются объектами. Для начала нам нужно научиться определять являются ли два «одинаковых» объекта одним и тем же. Для этого требуется получить адрес, что легко позволяет сделать встроенная функция id(). Пробуем:

</p><pre><code class="python">print(id(0))
</code></pre><p>
Как и ожидалось, выводится что-то невразумительное. Большое число, вероятно действительно адрес. Но если каждое число, использующееся на протяжении хранить в памяти, то никакой памяти, естественно, не хватит. Проводится короткий эксперимент:

</p><pre><code class="python">print(id(0))
print(id(0))
</code></pre><p>
Два абсолютно одинаковых числа. Следовательно, все константные числа на самом деле хранятся в памяти не дублираясь. Логично — у Python и так низкая производительность, такое ухищрение позволяет сохранить последние её остатки. Окей, попробуем заполнить всю память огромным массивом нулей.

</p><pre><code class="python">a = [0]
while True:
    a += [0]
</code></pre><p>
Бесконечный цикл, как и положено, выполняется бесконечно, но памяти практически не требует. Ещё один эксперимент:

</p><pre><code class="python">a = [0, 0]
print(id(a[0]))
print(id(a[1]))
</code></pre><p>
Ну да, одно и то же число. Скорее чтобы подтвердить провожу такую же проверку с двумя разными переменными — одно и то же число, да ещё и равное id(0). То есть, алгоритм, видимо такой: когда у нас меняется значение переменной мы проверяем нет ли в памяти такого же, и, если есть, перенаправляем ссылку на него. Это поведение требуется, очевидно, потому что объект занимает в памяти довольно много места, и, чтобы быть более компактным, Python по максимуму использует существующие объекты. Чтобы не загромождать статью кодом скажу что для строк (в том числе, полученных через срез), логических объектов и даже массивов это работает так же. Сделаем вторую попытку занять Python'ом всю память:

</p><pre><code class="python">i = 0
a = [0]
while True:
    a += [a[i]]
    i += 1
</code></pre><p>
Успех! Потребление памяти постоянно повышается. Делаем первый вывод:</p><p>
1. Любые данные в Python это объекты.</p><p>
2. Если объекты «одинаковы», то они хранятся по одному адресу в памяти. Иными словами, a == b и id(a) == id(b) это эквивалентные утверждения.</p><p>
3. Более сложной оптимизации не используется — довольно простая зависимость в массиве уже не оптимизируется никак (только правило «a[i] = i»). Впрочем, я бы удивился, если бы использовалась: тут уже требуется довольно сложный лексический анализ, который Python с его пошаговой интерпретацией позволить себе не может.
</p><h4>Считаем ссылки</h4><p>
Disclaimer: сейчас мы будем работать в интерактивном режиме Python'а. Для того, чтобы подсчитать ссылки на объект есть функция sys.getrefcount(). Импортируем sys:

</p><pre><code class="python">&gt;&gt;&gt; from os import sys
</code></pre><p>
И для начала нам нужно определить насколько реальными являются данные, которые она выдаёт:

</p><pre><code class="python">&gt;&gt;&gt; sys.getrefcount('There is no this string in Python')
3
&gt;&gt;&gt; sys.getrefcount('9695c3716e3b801367b7eca6a3281ac9') #md5-хеш 512 рандомных байт из /dev/urandom.
3
&gt;&gt;&gt; a = 'More random for the random god!'
&gt;&gt;&gt; sys.getrefcount(a)
2
&gt;&gt;&gt; a = 0
&gt;&gt;&gt; sys.getrefcount(a)
434
&gt;&gt;&gt; sys.getrefcount(0)
436
</code></pre><p>
Это говорит нам об одной забавной вещи: считая ссылки, getrefcount() сам их создаёт. Как мы видим, для констант он создаёт их две штуки (действительно две, я пробовал на больших объёмах входных данных, которые здесь не публикую за ненадобностью), так что мы можем просто вычитать 2. На самом деле, видимо для переменных он тоже создаёт две, но не учитывает при этом саму переменную. Ну ладно, отклонениями результатов от реальности мы разобрались. Теперь несколько примеров:

</p><pre><code class="python">&gt;&gt;&gt; sys.getrefcount(1)
754
&gt;&gt;&gt; sys.getrefcount(65)
13
&gt;&gt;&gt; sys.getrefcount(67)
11
&gt;&gt;&gt; sys.getrefcount('A')
4
&gt;&gt;&gt; sys.getrefcount('a')
6
&gt;&gt;&gt; sys.getrefcount(False)
100
&gt;&gt;&gt; sys.getrefcount(True)
101
# Истина победила!
</code></pre><p>
Почему тут внезапно появляются указатели на ровном месте (целыя 751 штука для единицы)? Потому что эта функция считает C-шные указатели, то есть включает те, которые используются в коде самого Python. Фактически, мы нагло вламываемся в ту часть Python, которую от нас стремятся скрыть разработчики.
</p><p>
Ну, вот такая вот закулиса у Python. Если дойдут руки и сумею — напишу о том, что произойдёт, если попробовать поменять эти объекты вручную через OllyDbg, скажем.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>