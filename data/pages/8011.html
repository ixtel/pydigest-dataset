<html><body><div><p>Free streaming for heavy-ion collision initial conditions.</p>








<div id="usage">
<h2>Usage</h2>
<p><tt>freestream</tt> has an object-oriented interface through the <tt>FreeStreamer</tt> class, which takes three parameters:</p>
<pre><span class="n">freestream</span><span class="o">.</span><span class="n">FreeStreamer</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">grid_max</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
</pre>
<p>where</p>
<ul>
<li><tt>initial</tt> is a square array containing the initial state,</li>
<li><tt>grid_max</tt> is the <em>x</em> and <em>y</em> maximum of the grid in fm, i.e. half the grid width (see following example),</li>
<li><tt>time</tt> is the time to free stream in fm/c.</li>
</ul>
<p>The <tt>initial</tt> array must contain a two-dimensional (boost-invariant) initial condition discretized onto a uniform square grid.
It is then interpreted as a density profile of non-interacting massless partons at time <em>τ</em> = 0+.</p>
<p>The <tt>grid_max</tt> parameter sets the outermost <em>edge</em> of the grid, <em>not</em> the midpoint of the outer grid cell (this is the same definition as <a href="https://github.com/Duke-QCD/trento" rel="nofollow">trento</a>).
For example:</p>
<ul>
<li>A 200 × 200 grid with a max of 10.0 fm has cell edges at -10.00, -9.90, …, +10.00 and cell midpoints at -9.95, -9.85, …, +9.95.</li>
<li>A 201 × 201 grid with a max of 10.05 fm has cell edges at -10.05, -9.95, …, +10.05 and cell midpoints at -10.00, -9.90, …, +10.00.</li>
</ul>
<p><strong>It is very important that the grid max is set correctly to avoid superluminal propagation.</strong></p>
<p>Suppose <tt>initial</tt> is an <em>n</em> × <em>n</em> initial condition array with a grid max of 10.0 fm and we want to free stream for 1.0 fm.
We first create a <tt>FreeStreamer</tt> object:</p>
<pre><span class="kn">import</span> <span class="nn">freestream</span>

<span class="n">fs</span> <span class="o">=</span> <span class="n">freestream</span><span class="o">.</span><span class="n">FreeStreamer</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre>
<p>We can now extract the various quantities needed to initialize hydro from <tt>fs</tt>.</p>
<div id="energy-momentum-tensor-t">
<h3>Energy-momentum tensor <em>T</em><sup>μν</sup></h3>
<pre><span class="n">Tuv</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">Tuv</span><span class="p">()</span>
</pre>
<p><tt>Tuv</tt> is now an <em>n</em> × <em>n</em> × 3 × 3 array containing the full tensor at each grid point.
If we only want a certain component of the tensor, we can pass indices to the function:</p>
<pre><span class="n">T00</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">Tuv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre>
<p><tt>T00</tt> is now an <em>n</em> × <em>n</em> array containing <em>T</em><sup>00</sup> at each grid point.
This is purely for syntactic convenience: <tt>fs.Tuv(0, 0)</tt> is equivalent to <tt><span class="pre">fs.Tuv()[:,</span> :, 0, 0]</tt>.</p>
</div>
<div id="energy-density-e-and-flow-velocity-u">
<h3>Energy density <em>e</em> and flow velocity <em>u</em><sup>μ</sup></h3>
<pre><span class="n">e</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">energy_density</span><span class="p">()</span>  <span class="c1"># n x n</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">flow_velocity</span><span class="p">()</span>  <span class="c1"># n x n x 3</span>
</pre>
<p>We can also extract the individual components of flow velocity:</p>
<pre><span class="n">u1</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">flow_velocity</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># n x n</span>
</pre>
<p>Again, this is equivalent to <tt><span class="pre">fs.flow_velocity()[:,</span> :, 1]</tt>.</p>
</div>
<div id="shear-tensor-and-bulk-pressure">
<h3>Shear tensor π<sup>μν</sup> and bulk pressure Π</h3>
<p>The shear pressure tensor π<sup>μν</sup> works just like <em>T</em><sup>μν</sup>:</p>
<pre><span class="n">pi</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">shear_tensor</span><span class="p">()</span>  <span class="c1"># n x n x 3 x 3</span>
<span class="n">pi01</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">shear_tensor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># n x n</span>
</pre>
<p>The bulk viscous pressure Π depends on the equation of state <em>P(e)</em>.
By default, the ideal EoS <em>P(e)</em> = <em>e</em>/3 is used:</p>
<pre><span class="n">bulk</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">bulk_pressure</span><span class="p">()</span>
</pre>
<p>The bulk pressure is in fact zero with the ideal EoS, but there will be small nonzero values due to numerical precision.</p>
<p>To use another EoS, pass a callable object to <tt>bulk_pressure()</tt>:</p>
<pre><span class="n">bulk</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">bulk_pressure</span><span class="p">(</span><span class="n">eos</span><span class="p">)</span>
</pre>
<p>For example, suppose we have a table of pressure and energy density we want to interpolate.
We can use <tt>scipy.interpolate</tt> to construct a spline and pass it to <tt>bulk_pressure()</tt>:</p>
<pre><span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="kn">as</span> <span class="nn">interp</span>

<span class="n">eos_spline</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">energy_density</span><span class="p">,</span> <span class="n">pressure</span><span class="p">)</span>
<span class="n">bulk</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">bulk_pressure</span><span class="p">(</span><span class="n">eos_spline</span><span class="p">)</span>
</pre>
</div>
<div id="other-notes">
<h3>Other notes</h3>
<p>The code should run in a few seconds, depending on the grid size.
Computation time is proportional to the number of grid cells (i.e. <em>n</em><sup>2</sup>).</p>
<p>Ensure that the grid is large enough to accommodate radial expansion.
The code does not check for overflow.</p>
<p><tt>FreeStreamer</tt> returns references to its internal arrays, so do not modify them in place—make copies!</p>
</div>
</div>
<div id="testing-and-internals">
<h2>Testing and internals</h2>
<p><tt>FreeStreamer</tt> uses a two-dimensional cubic spline (<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectBivariateSpline.html" rel="nofollow">scipy.interpolate.RectBivariateSpline</a>) to construct a continuous initial condition profile from a discrete grid.
This is very precise provided the grid spacing is small enough.
The spline sometimes goes very slightly negative around sharp boundaries; <tt>FreeStreamer</tt> coerces these negative values to zero.</p>
<p>The script <tt>test.py</tt> contains unit tests and generates visualizations for qualitative inspection.
To run the tests, install nose and run:</p>
<pre>nosetests -v test.py
</pre>
<p>There are two unit tests:</p>
<ul>
<li>Comparison against an analytic solution for a symmetric Gaussian initial state (computed in Mathematica).</li>
<li>Comparison against a randomly-generated initial condition without interpolation.</li>
</ul>
<p>These tests occasionally fail since there is a random component and the tolerance is somewhat stringent (every grid point must agree within 0.1%).
When a test fails, it will print out a list of ratios (observed/expected).
Typically the failures occur at the outermost grid cell where the system is very dilute, and even there it will only miss by ~0.2%.</p>
<p>To generate visualizations, execute <tt>test.py</tt> as a script with two arguments, the test case to visualize and a PDF output file.
There are three test cases:</p>
<ul>
<li><tt>gaussian1</tt>, a narrow symmetric Gaussian centered at the origin.</li>
<li><tt>gaussian2</tt>, a wider asymmetric Gaussian offset from the origin.</li>
<li><tt>random</tt>, a randomly-generated initial condition (this is not in any way realistic, it’s only for visualization).</li>
</ul>
<p>For example:</p>
<pre>python test.py gaussian1 freestream.pdf
</pre>
<p>will run the <tt>gaussian1</tt> test case and save results in <tt>freestream.pdf</tt>.
The PDF contains visualizations of the initial state and everything that <tt>FreeStreamer</tt> computes.
In each visualization, red colors indicate positive values, blue means negative, and the maximum absolute value of the array is annotated in the upper left.</p>
</div>


</div></body></html>