<html><body><div><section class="post-content entry-content">
	            

<p>Setting up Python to the point to be able install packages from PyPI can be annoying and time-intensive.  Even worse are OS-provided installations that start throwing cryptic error messages.  Especially desktops are prone to that but it’s possible to break the whole toolchain of a server by installing some shiny package you heard about on reddit.</p>

<p>Your desktop system is unlikely to be a throwaway virtual machine or container.  Which makes it a highly mutable system with difficult rollbacks and a lot of pain if stuff breaks.  So until we all run <a href="http://nixos.org/">NixOS</a> on our desktops:</p>

<p><strong>Don’t pip-install anything into its global <code>site-packages</code> beyond <a href="https://virtualenv.pypa.io/"><code>virtualenv</code></a>.</strong></p>

<p>Does that sound extreme to you?  Only if you haven’t found the right tools to make it effortless.</p>

<h2 id="virtualenv-in-2014:21721e66b30a2255773b4ba775c7121b">virtualenv in 2014‽</h2>

<p><code>virtualenv</code> has been around for a while and was a somewhat accepted standard for installing Python software.  Sadly, there are many missionaries running around nowadays, boldly proclaiming the end of <code>virtualenv</code>.  Mostly because of containers in general and usually because of <a href="https://docker.com/">Docker</a> in particular.</p>

<p>I find that unfortunate and shortsighted.  Frankly, they fail to see the whole picture:  <code>virtualenv</code>’s job isn’t just to separate your projects from each other.  Its job is also to separate <em>you</em> from the <em>operating system’s Python installation</em> and the installed packages you probably have no idea about.</p>

<p>Let’s use the widely celebrated <code>virtualenv</code>-killer Docker to see why that’s a good idea.  For that we look at the pre-installed packages you get after installing only <code>python-pip</code> into a trusty container<sup class="footnote-ref" id="fnref:21721e66b30a2255773b4ba775c7121b:image"><a rel="footnote" href="#fn:21721e66b30a2255773b4ba775c7121b:image">1</a></sup>:</p>

<pre><code class="language-nohighlight">argparse (1.2.1)
chardet (2.0.1)
colorama (0.2.5)
html5lib (0.999)
pip (1.5.4)
requests (2.2.1)
setuptools (3.3)
six (1.5.2)
urllib3 (1.7.1)
wsgiref (0.1.2)
</code></pre>

<p>Surprised<sup class="footnote-ref" id="fnref:21721e66b30a2255773b4ba775c7121b:pip"><a rel="footnote" href="#fn:21721e66b30a2255773b4ba775c7121b:pip">2</a></sup>?  What happens if you install a newer <code>requests</code>, <code>html5lib</code>, or <code>colorama</code> over it?  I’ll tell you what: <a href="https://github.com/pypa/pip/issues/1742#issuecomment-44197785">stuff</a> starts <a href="https://github.com/kennethreitz/requests/pull/2375">breaking</a>.</p>

<p>Such things can happen <em>any</em> time and make your system fragile.  Full-featured Ubuntu servers carry even more baggage of course.  Whenever you install a system tool written in Python you can expect some kind of breakage.  Whenever debian packagers decide that they don’t like something about how pip works and patch around it you’re involuntarily part of the “will it explode?” lottery.</p>

<p>OS X is in no way different; it comes with several dozens of Python packages.</p>

<p>And on the desktop – no matter what platform! – the situation is even worse.  I dare to say that the average <code>site-packages</code> is a mess and most users have no idea why a certain package is installed.  The step to break the whole installation is a very short one as many tutorial mentors will confirm.</p>

<hr/>

<p><strong>The operating system Python’s <code>site-packages</code><sup class="footnote-ref" id="fnref:21721e66b30a2255773b4ba775c7121b:derived"><a rel="footnote" href="#fn:21721e66b30a2255773b4ba775c7121b:derived">3</a></sup> belongs to the operating system.</strong></p>

<p>I’ve been saying for a while now that I would prefer if OS vendors would create a <code>virtualenv</code> for their stuff somewhere else and let the users have the system <code>site-packages</code>.  But that’s not happening.  And no one can guarantee that some system tool you don’t even know about won’t ever install a version of a library that’s incompatible with your project’s requirements.  Is it worth it to take that chance?</p>

<p>Only put software into <code>site-packages</code> that is explicitly written for that version of the OS.  In other words: system tools that only use Python packages provided by the OS.  Keep everything else in <code>virtualenv</code>.</p>

<p><strong>Stop discussing <code>virtualenv</code> vs. system isolation as if they were mutually exclusive.  You should use <em>both</em> at once, neither replaces the other:</strong></p>

<ol>
<li><em>Do</em> isolate your application server’s OS from its host using Docker/lxc/jails/zones/kvm/VMware/… to one container/vm per application.</li>
<li>But <em>inside</em> of them also <em>do</em> isolate your Python environment using <code>virtualenv</code> from unexpected surprises in the system <code>site-packages</code>.</li>
</ol>

<h2 id="less-typing-more-happiness:21721e66b30a2255773b4ba775c7121b">Less Typing, More Happiness</h2>

<p>On your desktop you’ll want a bit more convenience than pure <code>virtualenv</code>s.   So I urge you take five minutes to install and understand <a href="https://bitbucket.org/dhellmann/virtualenvwrapper">virtualenvwrapper</a>, <a href="https://github.com/davidmarble/virtualenvwrapper-win/">virtualenvwrapper-win</a>, or <a href="https://github.com/adambrenecki/virtualfish">virtualfish</a> – depending on the shell and operating system you use.  They take all the hassle from managing per-project <code>virtualenvs</code>.</p>

<p>Servers are a bit different because you’re unlikely to have more than one application (i.e. <code>virtualenv</code>) per user or even per server.  You can have a look at <a href="/articles/python-app-deployment-with-native-packages/">my current approach</a> to packaging and installing <code>virtualenv</code>s of server applications if you’re interested.</p>



<p>There’s one question that arises from this:  what about all the amazing Python-based tools we love?  How do we install <a href="https://testrun.org/tox/">tox</a>, <a href="http://mynt.uhnomoli.com/">mynt</a>, <a href="http://httpie.org">httpie</a>, <a href="http://pygments.org/">Pygments</a>, and so forth?  Arguably, they made the biggest mess in my system installations in the past.</p>

<p>Should you create <code>virtualenv</code>s for them all and link the executable scripts into some directory within you <code>PATH</code>?</p>

<p>‘Yes’ and ‘no’.  ‘Yes’, that’s the correct approach (and it <a href="http://schinckel.net/2013/11/19/per-command-virtualenv/">has been taken before</a>).  ‘No’, you shouldn’t do it <em>yourself</em>.   There’s a helpful (alas POSIX–only) tool for just that: <a href="https://github.com/mitsuhiko/pipsi"><code>pipsi</code></a>.</p>

<p>After installation (do <em>not</em> try to install it using <code>pip</code>, please read the installation instructions) you can install Python CLI tools by calling e.g.</p>

<pre><code class="language-console">$ pipsi install Pygments
</code></pre>

<p><code>pipsi</code> then will create a new <code>virtualenv</code> in  <code>~/.local/venvs</code> and install the package into it.  Finally it links the scripts into <code>~/.local/bin</code> which you can add to your <code>PATH</code>.</p>




	        </section>

	        
	        
	        
	        
	        
	        
	        
	        
	        
	        
	        
	        
	        
	        

	        </div></body></html>