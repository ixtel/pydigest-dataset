<html><body><div><div class="content html_format">
      
<p>
Доброго здравия! Не удивлюсь, что Вы раньше даже не слышали об этой программе. Как и я, до того дня, когда мне пригодился </p><b>Python Debugger</b><p>. Да, знаю, есть </p><b>pdb</b><p>, но его функционал и то, как он представлен, мне совершенно не приглянулось. После непродолжительных поисков я наткнулся на этот замечательный продукт. Тут есть все, что может пригодиться в отладке ваших </p><b>Python</b><p> приложений (скажу сразу: данный язык я не изучал, поэтому, если какие-то неточности всплывут, просьба не ругаться).
</p><a name="habracut"/>
<h5><b><u>Предостережение: повторяя действия из статьи, вы действуете на свой страх и риск!</u></b></h5>
<h4><b>Итак, мы начинаем...</b></h4><p>
Пациент, сразу скажу, необычный. Во-первых: он поставляется с исходниками (!!!), пускай и в байт-коде; во-вторых, как это иногда бывает… в общем, увидите.
</p><p>
Первым делом, качаем программу (</p><a href="http://wingware.com/pub/wingide/5.1.4/wingide-5.1.4-1.exe"><b>Wing IDE Professional v 5.1.4</b></a><p>). Устанавливаем, осматриваем папку. Главный исполняемый файл находится по адресу </p><b>./bin/wing.exe</b><p>. Запустим его. Ругается на отсутствие </p><b>Python</b><p>, поэтому установим и его. Нужен версии </p><b>2</b><p> (на данный момент это версия </p><b>2.7.9</b><p>). Снова запускаем программу. На этот раз предлагает установить патчи, и перезапуститься. Так и сделаем.
</p><p>
Теперь вылезает окошко с запросом лицензии (т.к. у нас про-версия). Введем какую-нибудь ерунду:

</p>
<p>
Получаем следующий ответ:

</p>
<p>
Что забавно: программа нам сама говорит длину ключа (20, не учитывая дефисов), и символы, с которых он должен начинаться. В принципе, с этого уже можно и начать исследовать защиту — найдем эту строчку в файлах программы.</p><p>
Дальше — интереснее. Результат поиска нашелся в файле </p><b>./bin/2.7/src.zip</b><p>!
</p><p>
Да-да. Все действительно так: программа идет с исходниками. В них-то нам и придется копаться.

</p><h4><b>Этап два: роемся в исходниках</b></h4><p>
Включим в </p><b>Total Commander</b><p> поиск по архивам, и найдем ту строку снова. Строка лежит в файле: </p><b>./bin/2.7/src.zip/process/wingctl.pyo</b><p>. </p><i>PYO</i><p>-файлы представляют из себя бинарники с "</p><i>оптимизированным</i><p>" байт-кодом </p><b>Python</b><p>.
</p><p>
К нашему счастью, для Питона существует парочка декомпиляторов байт-кода. Чтобы не утруждать Вас поисками, дам ссылки на те, которые мне пригодились:

</p><ol>
<li><a href="http://sourceforge.net/projects/easypythondecompiler/"><b>Easy Python Decompiler</b> (<i>EPD</i>)</a> — оболочка, в которой зашиты два декомпилятора (<b>Uncompyle2</b> и <b>Decompyle++</b>);</li>
<li><a href="https://github.com/wibiti/uncompyle2"><b>Форк Uncompyle2</b></a> — иногда распаковывает то, что не могут распаковать другие.</li>
</ol><p>
Итак, распакуем весь архив </p><b>src.zip</b><p> в папку </p><b>src</b><p> (рядом уже есть папка </p><b>src</b><p>, пускай туда распаковывается и все остальное) и натравим на нее </p><b>EPD</b><p>:

</p>
<p>
Дожидаемся окончания процесса, и идем осматривать что получилось. А получились на выходе декомпилированные файлы с окончанием </p><b>_dis</b><p>. Их мы переименуем в </p><b>.py</b><p>. Все бы хорошо, но, выясняется, что имеются также файлы с окончанием </p><b>_dis_failed</b><p>, что говорит о том, что эти файлы декомпилятор не осилил. К счастью, файл только один: </p><b>edit/editor.pyo_dis_failed</b>
<p>
Попробуем на него натравить </p><b>Decompyle++</b><p>… Та же беда. Не зря я дал ссылку на запасной декомпилятор, т.к. именно он и сделал то, что не удалось другим. Теперь удалим все </p><b>pyo</b><p>/</p><b>pyc</b><p> файлы из папки src, а </p><b>.py*_dis</b><p> переименуем в </p><b>.py</b><p>.
</p><p>
Далее повторим все вышеописанное для архива </p><b>opensource.zip</b><p>, распаковав его в соседнюю одноименную папку. Архив </p><b>external.zip</b><p> я решил не трогать, т.к., осмотрев его, можно увидеть, что там лежат библиотеки, которые можно установить отдельно для нашего Питона. Так и сделаем:

</p><ol>
<li><pre><code class="dos">pip install docutils</code></pre></li>
<li><a href="http://python.net/crew/gherman/programs/py2pdf/py2pdf-0.5.zip"><b>py2pdf</b></a> — его положим в папку <b>external</b>;</li>
<li><a href="http://effbot.org/downloads/PIL-1.1.7.win32-py2.7.exe"><b>Imaging-1.1.7</b></a> — запустить и установить. Из папки <b>external</b> можно удалить;</li>
<li><a href="http://ftp.gnome.org/pub/GNOME/binaries/win32/pygtk/2.24/pygtk-2.24.0.win32-py2.7.exe"><b>pygtk</b></a> — то же, что и с предыдущим файлов.</li>
</ol><p>
Остальные библиотеки (</p><b>pyscintilla2</b><p> и </p><b>pysqlite</b><p>) просто извлечем из архива </p><b>external.zip</b><p>, и декомпилируем, как и раньше.

</p><h4><b>Этапы три и четыре: собственно исходный код. Отладка.</b></h4><p>
Порыскав по питоновским скриптам, я наткнулся на файлик </p><b>wing.py</b><p> в корне папки с программой. И, первый же комментарий нам подсказывает:
</p><pre><code class="python"># Top level script for invoking Wing IDE.  If --use-src is specified
#  as an arg, then the files in WINGHOME/src, WINGHOME/external,
#  WINGHOME/opensource will be used; otherwise, the files in the version
#  specific bin directory will be used if it exists.
</code></pre>
<p>
В двух словах: если скрипту дать параметр </p><b>--use-src</b><p>, то при запуске будут использоваться исходники из папок </p><b>src</b><p>, </p><b>external</b><p>, </p><b>opensource</b><p> корневого каталога с </p><b>Wing IDE</b><p> (а не со скриптом).
</p><p>
Заглянув в корневую папку, я обнаружил еще одну папку </p><b>src</b><p>, и </p><b>.py</b><p>-файлы в ней. Подкинем их в нашу папку </p><b>src</b><p>, с перезаписью (здесь все таки оригиналы, а не декомпилированные файлы).
</p><p>
Теперь все три папки (указанные чуть выше), скопируем в корневой каталог программы. Попробуем подебажить…
</p><p>
Запускаем </p><b>Wing IDE</b><p>, и открываем в ней файл </p><b>wing.py</b><p> из каталога </p><b>bin</b><p>. Далее в меню </p><b>Debug -&gt; Debug Environment...</b><p> в поле параметров указываем </p><b>--use-src</b><p>. Теперь стартанем дебаггер (клавиша </p><b>F5</b><p>). Если все махинации с копированиями папок прошли успешно, мы получим вторую копию запущенной </p><b>Wing IDE</b><p>. Прекрасно!
</p><p>
Далее: откроем в родительском </p><b>Wing IDE</b><p> тот файлик, в котором мы нашли ранее строку о плохом </p><b>license id</b><p> (</p><b>wingctl.py</b><p>), и поставим бряку до этого сообщения:

</p>
<p>
В отлаживаемом </p><b>Wing IDE</b><p> зайдем в меню </p><b>Help -&gt; Enter License...</b><p>, и введем ключик согласно правилам (помните?: </p><b>20</b><p> символов, при том, первый из набора </p><b>['T', 'N', 'E', 'C', '1', '3', '6']</b><p>):

</p>
<p>
Жмем </p><b>Continue</b><p> и попадаем на </p><s>бабки</s><p> бряку. Первая же интересная функция: </p><b>abstract.ValidateAndNormalizeLicenseID(id)</b><p>. Зайдем в нее по </p><b>F7</b><p>. Там еще одна: </p><b>__ValidateAndNormalize(id)</b><p>. Зайдем и в нее.
</p><p>
Первая проверка на валидность:
</p><pre><code class="python">for c in code:
        if c in ('-', ' ', '\t'):
            pass
        elif c not in textutils.BASE30:
            code2 += c
            badchars.add(c)
        else:
            code2 += c
</code></pre><p>
Видим, что от нас требуют, чтобы символы </p><b>License ID</b><p> принадлежали набору </p><b>textutils.BASE30</b><p>:
</p><pre><code class="python">BASE30 = '123456789ABCDEFGHJKLMNPQRTVWXY'
</code></pre><p>
Вроде других проверок в </p><b>__ValidateAndNormalize(id)</b><p> нет. Исправляем введенный нами идентификатор и повторяем снова. Проверку на первый символ мы уже прошли:
</p><pre><code class="python">if len(id2) &gt; 0 and id2[0] not in kLicenseUseCodes:
        errs.append(_('Invalid first character: Should be one of %s') % str(kLicenseUseCodes))
</code></pre><p>
А вот и второй символ:
</p><pre><code class="python">if len(id2) &gt; 1 and id2[1] != kLicenseProdCode:
</code></pre>
<pre><code class="python">kLicenseProdCodes = {config.kProd101: '1',
 config.kProdPersonal: 'L',
 config.kProdProfessional: 'N',
 config.kProdEnterprise: 'E'}
kLicenseProdCode = kLicenseProdCodes[config.kProductCode]
</code></pre><p>
Т.к. у нас </p><b>Professional</b><p> версия, то второй символ должен быть </p><b>N</b><p> — исправляем, и возвращаемся. </p><b>abstract.ValidateAndNormalizeLicenseID(id)</b><p> прошелся без ошибок. Прекрасно. Упс:
</p><pre><code class="python">if len(errs) == 0 and id[0] == 'T':
        errs.append(_('You cannot enter a trial license id here'))
</code></pre><p>
Фиксим (я выбрал </p><b>E</b><p>), и продолжаем. Пробежавшись глазами ниже по коду, ничего дополнительно к предыдущим проверкам я не обнаружил, поэтому смело отпустил отладку далее по </p><b>F5</b><p>. Новое окно:

</p>
<p>
Вводим случайный текст, получаем сообщение об ошибке (опять </p><b>20</b><p> символов, и начинаться код активации должен с </p><b>AXX</b><p>), находим его в файлах, ставим бряку:

</p>
<p>
Первая функция проверки: </p><b>abstract.ValidateAndNormalizeActivation(act)</b><p>. В ней снова проверка на принадлежность </p><b>BASE30</b><p>. Проверка на префикс, которую мы уже прошли:
</p><pre><code class="python">if id2[:3] != kActivationPrefix:
        errs.append(_("Invalid prefix:  Should be '%s'") % kActivationPrefix)
</code></pre><p>
Следующее интересное место:
</p><pre><code class="python">err, info = self.fLicMgr._ValidateLicenseDict(lic2, None)
if err == abstract.kLicenseOK:
</code></pre><p>
Заходим в </p><b>self.fLicMgr._ValidateLicenseDict</b><p>. Тут формируется хэш от лицензии:
</p><pre><code class="python">lichash = CreateActivationRequest(lic)
act30 = lic['activation']
if lichash[2] not in 'X34':
        hasher = sha.new()
        hasher.update(lichash)
        hasher.update(lic['license'])
        digest = hasher.hexdigest().upper()
        lichash = lichash[:3] + textutils.SHAToBase30(digest)
        errs, lichash = ValidateAndNormalizeRequest(lichash)
</code></pre><p>
Если посмотреть на содержимое </p><b>lichash</b><p> после выполнения этого блока, можно заметить, что текст ее похож на </p><b>request code</b><p>, отображаемый в окошке ввода кода активации, хотя несколько цифр и отличается. Ладно, будем думать, что здесь имеют место быть какие-то рандомные части, не влияющие на активацию (что, кстати, далее подтвердится!).
</p><p>
Далее из кода активации отрезают три первых символа, убирают дефисы, преобразовывают в </p><b>BASE16</b><p>, и дополняют нулями, если нужно:
</p><pre><code class="python">act = act30.replace('-', '')[3:]
hexact = textutils.BaseConvert(act, textutils.BASE30, textutils.BASE16)
    while len(hexact) &lt; 20:
        hexact = '0' + hexact
</code></pre><p>
И вот оно, самое интересное:
</p><pre><code class="python">valid = control.validate(lichash, lic['os'], lic['version'][:lic['version'].find('.')], hexact)
</code></pre><p>
Какой-то </p><b>control</b><p> вызывает функцию </p><b>validate</b><p>, передавая ему </p><b>lichash</b><p> (</p><b>request code</b><p>), имя операционной системы, для которой делается ключ, версию программы, и преобразованный код активации. Почему я остановил на этом месте внимание? Дело в том, что этот </p><b>control</b><p> — это </p><b>pyd</b><p>-файл (в чем можно убедиться, добавив имя объекта в </p><b>watch</b><p>, и глянув поле </p><b>__file__</b><p>), которые представляют из себя обычные </p><b>DLL</b><p> с одной экспортируемой функцией (не </p><b>validate</b><p>), которая дает Питону информацию о том, что она умеет делать. Ну что же, давайте посмотрим на нее со стороны декомпилятора </p><b>Hex Rays</b><p>…

</p><h4><b>Этап пять: это уже не Python</b></h4><p>
Затащим в </p><b>IDA Pro</b><p> наш </p><b><i>control</i></b><p> (</p><b>ctlutil.pyd</b><p>) и посмотрим на экспортируемую функцию </p><b>initctlutil</b><p>:
</p><pre><code class="cpp">int initctlutil()
{
  return Py_InitModule4(aCtlutil, &amp;off_10003094, 0, 0, 1013);
}
</code></pre>
<b>off_10003094</b><p> представляет из себя структуру, в которой указаны имена и адрес экспортируемых методов. Вот и наш </p><b>validate</b><p>:
</p><pre><code class="cpp">.data:100030A4                 dd offset aValidate     ; "validate"
.data:100030A8                 dd offset sub_10001410
</code></pre><p>
Из всего кода, который содержит процедура </p><b>sub_10001410</b><p> самым интересным выглядит этот:
</p><pre><code class="cpp">if ( sub_10001020(v6, &amp;v9) || strcmp(&amp;v9, v7) )
{
  result = PyInt_FromLong(0);
}
</code></pre><p>
Зайдем и в </p><b>sub_10001020</b><p> тоже. Интересно было бы не на глаз давать имена переменным, а подебажить и обозвать их как следует. Так и сделаем. Настроим отладчик </p><b>IDA Pro</b><p>:

</p>
<p>
Думаю, все понятно из скриншота: мы указали приложение, которое в итоге будет подгружать наш </p><b>pyd</b><p>-файл.
</p><p>
Теперь ставим бряк на начало </p><b>sub_10001020</b><p>, и начинаем заглядывать в переменные и входные параметры. После непродолжительного процесса отладки приходим к такому вот листингу функции:
</p><div class="spoiler"><b class="spoiler_title">Код функции convert_reqest_key</b><div class="spoiler_text"><pre><code class="cpp">int __usercall convert_reqest_key@&lt;eax&gt;(char *version@&lt;eax&gt;, const char *platform@&lt;ecx&gt;, const char *activation_key, char *out_key)
{
  unsigned int len_1; // edi@1
  const char *platform_; // esi@1
  char *version_; // ebx@1
  int ver_; // eax@2
  signed int mul1; // ecx@3
  signed int mul2; // esi@3
  signed int mul3; // ebp@3
  bool v11; // zf@15
  const char *act_key_ptr; // eax@31
  char v13; // dl@32
  const char *act_key_ptr_1; // eax@35
  unsigned int len_2; // ecx@35
  char v16; // dl@36
  const char *act_key_ptr_2; // eax@39
  unsigned int len_3; // ecx@39
  char v19; // dl@40
  int P3_; // ebx@42
  const char *act_key_ptr_3; // eax@45
  unsigned int len_4; // ecx@45
  char v23; // dl@46
  unsigned int P4; // ebp@47
  signed int mul4; // [sp+10h] [bp-18h]@0
  unsigned int P3; // [sp+14h] [bp-14h]@1
  unsigned int P2; // [sp+18h] [bp-10h]@1
  unsigned int P1; // [sp+1Ch] [bp-Ch]@1

  len_1 = 0;
  platform_ = platform;
  version_ = version;
  P1 = 0;
  P2 = 0;
  P3 = 0;
  if ( !strcmp(platform, aWindows) )
  {
    ver_ = (unsigned __int8)*version_;
    if ( *version_ == '2' )
    {
      mul1 = 142;
      mul2 = 43;
      mul3 = 201;
      mul4 = 38;
      goto LABEL_31;
    }
    if ( (_BYTE)ver_ == '3' )
    {
      mul1 = 23;
      mul2 = 163;
      mul3 = 2;
      mul4 = 115;
      goto LABEL_31;
    }
    if ( (_BYTE)ver_ == '4' )
    {
      mul1 = 17;
      mul2 = 87;
      mul3 = 120;
      mul4 = 34;
      goto LABEL_31;
    }
  }
  else if ( !strcmp(platform_, aMacosx) )
  {
    ver_ = (unsigned __int8)*version_;
    if ( *version_ == '2' )
    {
      mul1 = 41;
      mul2 = 207;
      mul3 = 104;
      mul4 = 77;
      goto LABEL_31;
    }
    if ( (_BYTE)ver_ == '3' )
    {
      mul1 = 128;
      mul2 = 178;
      mul3 = 104;
      mul4 = 95;
      goto LABEL_31;
    }
    if ( (_BYTE)ver_ == '4' )
    {
      mul1 = 67;
      mul2 = 167;
      mul3 = 74;
      mul4 = 13;
      goto LABEL_31;
    }
  }
  else
  {
    v11 = strcmp(platform_, aLinux) == 0;
    LOBYTE(ver_) = *version_;
    if ( v11 )
    {
      if ( (_BYTE)ver_ == '2' )
      {
        mul1 = 48;
        mul2 = 104;
        mul3 = 234;
        mul4 = 247;
        goto LABEL_31;
      }
      if ( (_BYTE)ver_ == '3' )
      {
        mul2 = 52;
        mul1 = 254;
        mul3 = 98;
        mul4 = 235;
        goto LABEL_31;
      }
      if ( (_BYTE)ver_ == '4' )
      {
        mul1 = 207;
        mul2 = 45;
        mul3 = 198;
        mul4 = 189;
        goto LABEL_31;
      }
    }
    else
    {
      if ( (_BYTE)ver_ == '2' )
      {
        mul1 = 123;
        mul2 = 202;
        mul3 = 97;
        mul4 = 211;
        goto LABEL_31;
      }
      if ( (_BYTE)ver_ == '3' )
      {
        mul1 = 127;
        mul2 = 45;
        mul3 = 209;
        mul4 = 198;
        goto LABEL_31;
      }
      if ( (_BYTE)ver_ == '4' )
      {
        mul2 = 4;
        mul1 = 240;
        mul3 = 47;
        mul4 = 98;
        goto LABEL_31;
      }
    }
  }
  if ( (_BYTE)ver_ == '5' )
  {
    mul1 = 7;
    mul2 = 123;
    mul3 = 23;
    mul4 = 87;
  }
  else
  {
    mul1 = 0;
    mul2 = 0;
    mul3 = 0;
  }
LABEL_31:
  act_key_ptr = activation_key;
  do
    v13 = *act_key_ptr++;
  while ( v13 );
  if ( act_key_ptr != activation_key + 1 )
  {
    do
      P1 = (P1 * mul1 + activation_key[len_1++]) &amp; 0xFFFFF;
    while ( len_1 &lt; strlen(activation_key) );
  }
  act_key_ptr_1 = activation_key;
  len_2 = 0;
  do
    v16 = *act_key_ptr_1++;
  while ( v16 );
  if ( act_key_ptr_1 != activation_key + 1 )
  {
    do
      P2 = (P2 * mul2 + activation_key[len_2++]) &amp; 0xFFFFF;
    while ( len_2 &lt; strlen(activation_key) );
  }
  act_key_ptr_2 = activation_key;
  len_3 = 0;
  do
    v19 = *act_key_ptr_2++;
  while ( v19 );
  if ( act_key_ptr_2 != activation_key + 1 )
  {
    P3_ = 0;
    do
      P3_ = (P3_ * mul3 + activation_key[len_3++]) &amp; 0xFFFFF;
    while ( len_3 &lt; strlen(activation_key) );
    P3 = P3_;
  }
  act_key_ptr_3 = activation_key;
  len_4 = 0;
  do
    v23 = *act_key_ptr_3++;
  while ( v23 );
  P4 = 0;
  if ( act_key_ptr_3 != activation_key + 1 )
  {
    do
      P4 = (P4 * mul4 + activation_key[len_4++]) &amp; 0xFFFFF;
    while ( len_4 &lt; strlen(activation_key) );
  }
  sprintf(out_key, a_5x_5x_5x_5x, P1, P2, P3, P4);
  return 0;
}
</code></pre>
</div></div><p>
А место вызова этой функции приобретает следующий вид:
</p><pre><code class="cpp">if ( convert_reqest_key(version, platform, request_key, out_key) || strcmp(out_key, act_key_hash) )
{
  result = PyInt_FromLong(0);
}
</code></pre><p>
Из этого всего можно сделать вывод, что </p><b>request code</b><p> преобразовывается с помощью функции </p><b>convert_reqest_key</b><p> и сравнивается затем с тем преобразованным кодом активации. Помните то преобразование?
</p><blockquote>Далее из кода активации отрезают три первых символа, убирают дефисы, преобразовывают в <b>BASE16</b>, и дополняют нулями, если нужно</blockquote><p>
Значит, чтобы получить правильный код активации нам теперь можно поступить следующим образом:
</p><ol>
<li>Дать выполниться функции преобразования <b>convert_reqest_key</b>;</li>
<li>На месте выполнения <b>strcmp</b> высмотреть содержимое <b>out_key</b>;</li>
<li>Убрать лишние нули в начале <b>out_key</b>;</li>
<li>Преобразовать <b>out_key</b> обратно в <b>BASE30</b>;</li>
<li>Дописать в начало получившейся строки убранные три символа (<b>AXX</b>);</li>
<li>По желанию навтыкать дефисов через каждые пять символов.</li>
</ol><p>
Не буду мудрствовать лукаво, а втисну </p><b>print</b><p> прямо в </p><b>python</b><p>-код программы:
</p><pre><code class="python">print("AXX" + textutils.BaseConvert("FCBCFEFD2FF684FA6A4F", textutils.BASE16, textutils.BASE30))
</code></pre><p>
На выходе получил ключик:
</p><blockquote>wingide — 2015/05/24 04:03:47 — <b>AXX3Q6BQHKQ773D24P58</b></blockquote>
<p>
Введя его в поле ввода ключа активации, получил заветное:

</p>

<h4><b>ИТОГИ</b></h4><p>
Как видите, процесс взлома не столько сложный, сколько интересный получился! Исследовать свои же исходники в скомпилированном их варианте… это, конечно, забавно.
</p><p>
Не знаю, зачем авторы приложили к своей программе ее исходники (хоть и в большинстве своем, в виде байт-кода). Но, думаю, вы понимаете, что так делать не стоит!
</p><p>
Всем спасибо.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>