<html><body><div><article class="post-content">
    <h3 id="neural-networks-are-magical">Neural networks are magical</h3>

<p>When I go to Google Photos and search my photos for ‘skyline’, it finds me this picture of the New York skyline I took in August, without me having labelled it!</p>



<p>When I search for ‘cathedral’, Google’s neural networks find me pictures of cathedrals &amp; churches I’ve seen. It seems magical.</p>

<p>But of course, neural networks aren’t magic–nothing is! I recently
read a paper, <a href="http://arxiv.org/abs/1412.6572">“Explaining and Harnessing Adversarial
Examples”</a>, that helped demystify neural
networks a little for me.</p>

<p>The paper explains how to force a neural network to make really egregious mistakes. It does this by exploiting the fact that the network is <strong>simpler</strong> (more linear!) than you might expect. We’re going to approximate the network with a linear function!</p>

<p>It’s important to understand that this doesn’t explain all (or even most) kinds of mistakes neural networks make. There are a lot of possible mistakes! But it does give us some insight into one specific kind of mistake, which is awesome.</p>

<p>Before reading the paper, I knew three things about neural networks:</p>

<ul>
  <li>they can perform really well on image classification tasks (so I can search for “baby” and find that adorable picture of my friend’s baby)</li>
  <li>everyone talks about “deep” neural networks on the internet</li>
  <li>they’re composed of layers of simple (often sigmoid) functions, which are often illustrated like this<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>:<br/></li>
</ul>



<h3 id="mistakes">Mistakes</h3>

<p>The fourth and final thing I knew about neural networks was: sometimes they
make REALLY RIDICULOUS mistakes. Spoilers from later in this post: these are a couple of images, and how the neural network classifies them. We can convince it that a black image is a paper towel, and that a panda is a vulture!</p>



<p>Now, none is this is too surprising to me–machine learning is my job, and
machine learning habitually produces super weird stuff. But if we’re going to
<em>fix</em> the super weird errors, we need to understand why they happen! We’re going to learn a little about neural networks, and then I’ll teach you how to trick a neural network into thinking a panda is a vulture.</p>

<h3 id="making-our-first-prediction">Making our first prediction</h3>

<p>We’re going to load a neural network, make some predictions, and then <em>break</em> those predictions. It’s going to be awesome. But first I needed to actually get a neural network on my computer.</p>

<p>I installed <a href="https://github.com/BVLC/caffe">Caffe</a>, which is neural network software written by some people at the Berkeley Vision and Learning Center at Berkeley. I picked it because it was the first one I could figure out, and that I could download a pre-trained network for. You could also try <a href="http://deeplearning.net/software/theano/">Theano</a> or <a href="http://www.tensorflow.org/">Tensorflow</a>. Caffe has pretty clear installation instructions, which means it only took 6 hours of cursing before I got it to work.</p>

<p>If you want to install Caffe, I wrote up a procedure that will take you less than 6 hours. Just go to <a href="https://github.com/jvns/neural-nets-are-weird">the neural-networks-are-weird repo</a> and follow the instructions. Warning: it downloads approximately 1.5GB of data and needs to compile a bunch of stuff. These are the instructions to build it (3 lines!), which you can also find in the repository’s README:</p>

<div class="highlight"><pre><code>git clone https://github.com/jvns/neural-nets-are-weird
cd neural-nets-are-weird
docker build -t neural-nets-fun:caffe .
docker run -i -p 9990:8888 -v $PWD:/neural-nets -t neural-nets-fun:caffe /bin/bash -c 'export PYTHONPATH=/opt/caffe/python &amp;&amp; cd /neural-nets &amp;&amp; ipython notebook --no-browser --ip 0.0.0.0'
</code></pre></div>
<p>This starts up an IPython notebook server on your computer where you can start making neural network predictions in Python. It should be running <a href="http://localhost:9990/notebooks/notebooks/neural-nets-are-weird.ipynb">on port 9990 on localhost</a>. If you don’t want to play along, that’s also totally fine. I included pictures in this article, too!</p>

<p>Once we have the IPython notebook up and running, we can start running code and making predictions!
From here on I’m just going to post pretty pictures and small code snippets, but the full code and the gnarly details are in <a href="https://github.com/jvns/neural-nets-are-weird/blob/master/notebooks/neural-nets-are-weird.ipynb">this notebook</a>.</p>

<p>We’re going to use a neural network called GoogLeNet<sup id="fnref:5"><a href="#fn:5" class="footnote">2</a></sup>, which won the <a href="http://www.image-net.org/challenges/LSVRC/2014/results">ILSVRC 2014 competition in several categories</a>. The correct classification was in the network’s top 5 guesses 94% of the time. It’s the network that the paper I read uses. (If you want a cool read, you can see how <a href="http://karpathy.github.io/2014/09/02/what-i-learned-from-competing-against-a-convnet-on-imagenet/">a human can’t do much better than GoogLeNet</a>. Neural networks really are pretty magical.)</p>

<p>First off, let’s classify an adorable kitten<sup id="fnref:6"><a href="#fn:6" class="footnote">3</a></sup> using our network:</p>



<p>Here’s the code to classify the kitten.</p>

<div class="highlight"><pre><code>image = '/tmp/kitten.png'
# preprocess the kitten and resize it to 224x224 pixels
net.blobs['data'].data[...] = transformer.preprocess('data', caffe.io.load_image(image))
# make a prediction from the kitten pixels
out = net.forward()
# extract the most likely prediction
print("Predicted class is #{}.".format(out['prob'][0].argmax()))
</code></pre></div>
<p>That’s all! It’s just 3 lines of code. I also classified a cute dog!</p>



<p>It turns out that this dog is not a corgi, but the colors are very similar. This network already knows dogs better than I do.</p>

<h3 id="what-a-mistake-looks-like-featuring-the-queen">What a mistake looks like (featuring the queen)</h3>

<p>The most amusing thing that happened while doing this work is that I found out what the neural network thinks the queen of England is wearing on her head.</p>



<p>So now we’ve seen the network do a correct thing, and we’ve seen it make an adorable mistake by accident (the queen is wearing a shower cap ❤). Now… let’s force it to make mistakes on purpose, and get inside its soul.</p>

<h3 id="making-mistakes-on-purpose">Making mistakes on purpose</h3>

<p>We’re going to need to do some math before we truly understand how this works, but first let’s look at some pictures of a black screen.</p>



<p>This completely black image is classified with probability 27% as velvet, and 4% as a paper towel. There are some other probabilities I haven’t displayed, and they add up to 100%.</p>

<p>I would like to figure out how to make the neural network more confident that this is a paper towel.</p>

<p>To do that, we need to calculate the <strong>gradient</strong> of the neural network. This is the derivative of the neural network. You can think of this as a direction to take to make the image look more like a paper towel.</p>

<p>To calculate the gradient, we first need to pick an intended outcome to move towards, and set the output probability list to be 0 everywhere, and 1 for paper towel. <strong>Backpropagation</strong> is an algorithm for calculating the gradient. I originally thought it was totally mystical, but it turns out it’s just an algorithm implementing the chain rule. If you want to know more, <a href="http://colah.github.io/posts/2015-08-Backprop/">this article</a> has a fantastic explanation of backpropagation.</p>

<p>Here’s the code I wrote to do that–it’s actually really simple to do! Backpropagation is one of the most basic neural network operations so it’s easily available in the library.</p>

<div class="highlight"><pre><code>def compute_gradient(image, intended_outcome):
    # Put the image into the network and make the prediction
    predict(image)
    # Get an empty set of probabilities
    probs = np.zeros_like(net.blobs['prob'].data)
    # Set the probability for our intended outcome to 1
    probs[0][intended_outcome] = 1
    # Do backpropagation to calculate the gradient for that outcome
    # and the image we put in
    gradient = net.backward(prob=probs)
    return gradient['data'].copy()
</code></pre></div>
<p>This basically tells us what kind of shape the neural network is looking for at that point. Since everything we’re working with can be represented as an image, here it is–the output of <code>compute_gradient(black, paper_towel_label)</code>, scaled up to be visible.</p>



<p>Now, we can either add or subtract a very light version of that from our black screen, and make the neural net think our image is either more or less like a paper towel. Since the image we’re adding is so light (the pixel values are less than 1/256), the difference is totally invisible. Here’s the result:</p>



<p>Now the neural network thinks our black screen is a paper towel with 16% certainty, instead of 4%! That’s really neat. But, we can do better. Instead of taking one step in the direction of a paper towel, we can take ten tiny steps and become a little more like a paper towel every step. You can see the probabilities evolve over time here. You’ll notice the probabilities are different than before because our step sizes are different (0.1 instead of 0.9).</p>



<p>and the final result:</p>



<p>And here are the pixel values that make up that image! They all started out at exactly 0, and you can see that we’ve mutated them to trick the network into thinking the image is a paper towel.</p>



<p>We can also multiply the image by 50 to get a better sense of what it looks like.</p>



<p>It doesn’t look like a paper towel to me, but maybe it does to you! I like to imagine all the swirls in that image are tricking the neural network into thinking it’s a paper towel roll. So, that’s the basic proof of concept, and some of the math. We’re going to go more into the math in a second, but first we’re going to have fun.</p>

<h3 id="having-fun-tricking-the-neural-network">Having fun tricking the neural network</h3>

<p>Once I figured out to do this, it was SO FUN. We can change a cat into a bath towel:</p>



<p>a garbage can into a water jug / cocktail shaker:</p>



<p>and a panda into a vulture. What better way to spend a Sunday morning?</p>



<p>This image showing how the probabilities progress from panda to vulture over 100 steps is pretty rad:</p>



<p>You can see the code to make all this work <a href="https://github.com/jvns/neural-nets-are-weird/blob/master/notebooks/neural-nets-are-weird.ipynb">in the IPython notebook</a>. It’s so fun.</p>

<p>Now, it’s time for a little more math.</p>

<h3 id="how-it-works-logistic-regression">How it works: logistic regression</h3>

<p>First, let’s talk about the simplest way to classify an image–with logistic regression. What’s <a href="https://en.wikipedia.org/wiki/Logistic_regression">logistic regression</a>? I’ll try to explain.</p>

<p>Suppose you have a linear function, for classifying whether an image was a raccoon or not. How would we use that linear function? Well, suppose your image had only 5 pixels in it. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>5</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1, x_2, x_3, x_4, x_5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">4</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">5</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>, between 0 and 255. Our linear function would have <em>weights</em>, for instance <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>2</mn><mn>3</mn><mo separator="true">,</mo><mo>−</mo><mn>3</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>−</mo><mn>5</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(23,-3,9,2,-5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathrm">3</span><span class="mpunct">,</span><span class="mord">−</span><span class="mord mathrm">3</span><span class="mpunct">,</span><span class="mord mathrm">9</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord">−</span><span class="mord mathrm">5</span><span class="mclose">)</span></span></span></span>, and then to classify an image, we’d take the inner product of the pixels and the weights:</p>

<div class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi></mtext><mo>=</mo><mn>2</mn><mn>3</mn><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><mn>3</mn><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mn>9</mn><msub><mi>x</mi><mn>3</mn></msub><mo>+</mo><mn>2</mn><msub><mi>x</mi><mn>4</mn></msub><mo>−</mo><mn>5</mn><msub><mi>x</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">\text{result} = 23x_1 - 3x_2 + 9x_3 + 2x_4 - 5x_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base displaystyle textstyle uncramped"><span class="text mord displaystyle textstyle uncramped"><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mathrm">s</span><span class="mord mathrm">u</span><span class="mord mathrm">l</span><span class="mord mathrm">t</span></span><span class="mrel">=</span><span class="mord mathrm">2</span><span class="mord mathrm">3</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathrm">3</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">9</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">2</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">4</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathrm">5</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">5</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span></span></span></span></span></div>
<p>Now, suppose the result is 794. Does 794 mean it’s a raccoon or it’s not? Is 794 a probability? 794 IS NOT A PROBABILITY. A probability is a number between 0 and 1. Our result is a number between <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mord">−</span><span class="mord mathrm">∞</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>. The way people normally get from a number between <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mord">−</span><span class="mord mathrm">∞</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span> to a probability is by using a function called the <strong>logistic function</strong>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>(</mo><mi>t</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>t</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">S(t) = \frac{1}{1 + e^{-t}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mord mathit">S</span><span class="mopen">(</span><span class="mord mathit">t</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"/><span class="mfrac"><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">e</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord">−</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span></span></span></span><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle textstyle uncramped frac-line"/></span><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"/></span></span></span></span></p>

<p>which looks like this:</p>



<p>S(794) is basically 1, so if we got 794 out of our raccoon weights, we’d determine that it’s 100% a raccoon. This model–where we first transform our data with a linear function and then apply the logistic function to get a probability–is called <strong>logistic regression</strong>, and it’s a super simple and popular machine learning technique.</p>

<p>The “learning” part of machine learning is how to determine the right weights (like <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>2</mn><mn>3</mn><mo separator="true">,</mo><mo>−</mo><mn>3</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>−</mo><mn>5</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(23,-3,9,2,-5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathrm">3</span><span class="mpunct">,</span><span class="mord">−</span><span class="mord mathrm">3</span><span class="mpunct">,</span><span class="mord mathrm">9</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord">−</span><span class="mord mathrm">5</span><span class="mclose">)</span></span></span></span>) given a training dataset so that our probabilities can be as good as possible. The bigger the training set, the better!</p>

<p>Now that we understand what logistic regression <em>is</em>, let’s talk about how to break it!</p>

<h3 id="breaking-logistic-regression">Breaking logistic regression</h3>

<p>There’s a gorgeous blog post called <a href="http://karpathy.github.io/2015/03/30/breaking-convnets/">Breaking Linear Classifiers on ImageNet</a> by Andrej Karpathy, which explains how to break a simple linear model beautifully (it’s not quite a logistic regression, but it is a linear model). We’re going to use the same principles later to break neural networks.</p>

<p>Here’s an example (from Karpathy’s article) of some linear classifiers for various foods, flowers, and animals, visualized as images. (click to make it bigger)</p>



<p>You can see that the “Granny Smith” classifier is basically asking “is it green?” (not the worst way to find out!) and the “menu” one has discovered that menus are often white. Karpathy explains this super clearly:</p>

<blockquote>
  <p>For example, Granny Smith apples are green, so the linear classifier has
positive weights in the green color channel and negative weights in blue and
red channels, across all spatial positions. It is hence effectively counting
the amount of green stuff in the middle.</p>
</blockquote>

<p>So, if I wanted to trick the Granny Smith classifier into thinking I was an apple, all I’d have to do is</p>

<ul>
  <li>figure out which pixels it cares about being green the most</li>
  <li>tint those green</li>
  <li>profit!</li>
</ul>

<p>So now we know how to trick a linear classifier. But a neural network isn’t linear at all–it’s highly nonlinear! Why is this even relevant?!</p>

<h3 id="how-it-works-neural-networks">How it works: neural networks</h3>

<p>I’m going to be totally honest here: I’m not a neural networks expert, and my neural networks explanations are not going to be great. Michael Nielsen has written a book called <a href="http://neuralnetworksanddeeplearning.com/">Neural Networks and Deep Learning</a> which is very well-written. I’m also told that <a href="http://colah.github.io/">Christopher Olah’s blog</a> is quite good.</p>

<p>What I do know about neural networks is: they’re functions. You put in an image, and you get out a list of probabilities, one for each class. Those are the numbers you’ve been seeing next to the images throughout this article. (is it a dog? nope. A shower cap? nope. A solar dish? YES!!)</p>

<p>So a neural network is, like, 1000 functions (one for each probability). But 1000 functions are really complicated to reason about. So what neural networks people do is, they combine the 1000 probabilities into a single “score”. They call this the “loss function”.</p>

<p>This loss function for each image depends on the actual correct output for the image. So suppose that I have a picture of an ostrich, and the neural network has output probabilities <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">p_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">p</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span></span></span></span> for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>=</mo><mn>1</mn><mo>…</mo><mn>1</mn><mn>0</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">j = 1 \ldots 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mord mathit">j</span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="minner">…</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span>, but the probabilities I WANT for the ostrich are <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">y</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span></span></span></span>. Then the loss function is</p>

<div class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>=</mo><mo>−</mo><msub><mo>∑</mo><mi>j</mi></msub><msub><mi>y</mi><mi>j</mi></msub><mi>log</mi><msub><mi>p</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">L = - \sum_j y_j \log p_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base displaystyle textstyle uncramped"><span class="mord mathit">L</span><span class="mrel">=</span><span class="mord">−</span><span class="mop op-limits"><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">j</span></span></span><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span><span class="op-symbol large-op mop">∑</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">y</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span><span class="mop">lo<span>g</span></span><span class="mord"><span class="mord mathit">p</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span></span></span></span></span></div>
<p>And let’s say the label corresponding to ‘ostrich’ is number 700. Then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mrow><mn>7</mn><mn>0</mn><mn>0</mn></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y_{700}  = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">y</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">7</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span>, all the rest of the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">y</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span></span></span></span> are 0, and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>=</mo><mo>−</mo><mi>log</mi><msub><mi>p</mi><mrow><mn>7</mn><mn>0</mn><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">L = - \log p_{700}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mrel">=</span><span class="mord">−</span><span class="mop">lo<span>g</span></span><span class="mord"><span class="mord mathit">p</span><span class="vlist"><span><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">7</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span>​</span></span>​</span></span></span></span></span></span>.</p>

<p>The important thing here is to understand is that a neural network gives you a function from an image (the panda) to a final value of the loss function (a number, like 2). Because it’s a single-valued function, taking the derivative (or gradient) of that function gives you another image. You can then use that image to trick the neural network, using what we’ve talked about in this article!</p>

<h3 id="breaking-neural-networks">Breaking neural networks</h3>

<p>Here’s how all our words about breaking a linear function / logistic regression relate to neural networks! This is the math you’ve been waiting for! Near our image (an adorable panda), the loss function looks like</p>

<div class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>(</mo><mi>x</mi><mo>+</mo><mtext><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi></mtext><mo>)</mo><mo>≈</mo><mi>L</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><mtext><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi></mtext><mo>⋅</mo><mtext><mi mathvariant="normal">g</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">d</mi></mtext></mrow><annotation encoding="application/x-tex">L(x + \text{delta}) \approx  L(x) + \text{delta} \cdot \text{grad}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base displaystyle textstyle uncramped"><span class="mord mathit">L</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="text mord displaystyle textstyle uncramped"><span class="mord mathrm">d</span><span class="mord mathrm">e</span><span class="mord mathrm">l</span><span class="mord mathrm">t</span><span class="mord mathrm">a</span></span><span class="mclose">)</span><span class="mrel">≈</span><span class="mord mathit">L</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mbin">+</span><span class="text mord displaystyle textstyle uncramped"><span class="mord mathrm">d</span><span class="mord mathrm">e</span><span class="mord mathrm">l</span><span class="mord mathrm">t</span><span class="mord mathrm">a</span></span><span class="mbin">⋅</span><span class="text mord displaystyle textstyle uncramped"><span class="mord mathrm">g</span><span class="mord mathrm">r</span><span class="mord mathrm">a</span><span class="mord mathrm">d</span></span></span></span></span></span></div>
<p>where the gradient <code>grad</code> is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∇</mi><mi>L</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\nabla L(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mord mathrm">∇</span><span class="mord mathit">L</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span>. This is because of calculus. In order to change the loss function by a lot, we want to maximize the dot product of the direction we’re moving <code>delta</code> and the gradient <code>grad</code>. Let’s calculate <code>grad</code> via our <code>compute_gradient()</code> function, and draw it as a picture:</p>



<p>The intuition behind what we want to do is–we want to create a <code>delta</code> which emphasizes the pixels in the picture that the neural network thinks are important. Now, let’s suppose <code>grad</code> was <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>−</mo><mn>0</mn><mi mathvariant="normal">.</mi><mn>0</mn><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>0</mn><mi mathvariant="normal">.</mi><mn>0</mn><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mi mathvariant="normal">.</mi><mn>0</mn><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mi mathvariant="normal">.</mi><mn>0</mn><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mi mathvariant="normal">.</mi><mn>0</mn><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(-0.01, -0.01, 0.01, 0.02, 0.03)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord">−</span><span class="mord mathrm">0</span><span class="mord mathrm">.</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord">−</span><span class="mord mathrm">0</span><span class="mord mathrm">.</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">0</span><span class="mord mathrm">.</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">0</span><span class="mord mathrm">.</span><span class="mord mathrm">0</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">0</span><span class="mord mathrm">.</span><span class="mord mathrm">0</span><span class="mord mathrm">3</span><span class="mclose">)</span></span></span></span>.</p>

<p>We could make <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">g</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">d</mi></mtext><mo>⋅</mo><mtext><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi></mtext></mrow><annotation encoding="application/x-tex">\text{grad} \cdot \text{delta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">g</span><span class="mord mathrm">r</span><span class="mord mathrm">a</span><span class="mord mathrm">d</span></span><span class="mbin">⋅</span><span class="text mord textstyle uncramped"><span class="mord mathrm">d</span><span class="mord mathrm">e</span><span class="mord mathrm">l</span><span class="mord mathrm">t</span><span class="mord mathrm">a</span></span></span></span></span> big by taking <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi></mtext><mo>=</mo><mo>(</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\text{delta} = (-1, -1, 1, 1, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">d</span><span class="mord mathrm">e</span><span class="mord mathrm">l</span><span class="mord mathrm">t</span><span class="mord mathrm">a</span></span><span class="mrel">=</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord">−</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>, to get 0.08. Let’s try that! In code, that’ll be <code>delta = np.sign(grad)</code>. And when we move it by that amount, sure enough – now the panda’s a weasel.</p>



<p>But, why? Let’s think about the loss function. We started out by looking at the probability it was a panda, which was 99.57%. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi>log</mi><mo>(</mo><mn>0</mn><mi mathvariant="normal">.</mi><mn>9</mn><mn>9</mn><mn>5</mn><mn>7</mn><mo>)</mo><mo>=</mo><mn>0</mn><mi mathvariant="normal">.</mi><mn>0</mn><mn>0</mn><mn>1</mn><mn>8</mn></mrow><annotation encoding="application/x-tex">-\log(0.9957) = 0.0018</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut"/><span class="strut bottom"/><span class="base textstyle uncramped"><span class="mord">−</span><span class="mop">lo<span>g</span></span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mord mathrm">.</span><span class="mord mathrm">9</span><span class="mord mathrm">9</span><span class="mord mathrm">5</span><span class="mord mathrm">7</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">0</span><span class="mord mathrm">.</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">8</span></span></span></span>. Pretty small! So <strong>adding</strong> a multiple of delta should increase our loss function (and make it less like a panda), and subtracting a multiple of delta should decrease our loss function (and make it more like a panda). But actually the opposite happens! I’m still confused about this.</p>

<h3 id="the-dog-you-cant-trick">The dog you can’t trick</h3>

<p>Now that we know the math, a short story. I also tried to trick the network about this adorable dog from before:</p>



<p>But the dog was highly resistant to being classified as something other than a dog! I spent some time trying to convince it that the dog was a tennis ball but it remained, well, a dog. Other kinds of dogs! But still a dog.</p>

<p>I ran into Jeff Dean (who works on neural nets at Google) at a conference, and asked him about this. He told me that there are a ton of dogs in the training set for this network, way more than there are pandas. So he hypothesized that the network is better-trained to recognize dogs. Seems plausible!</p>

<p>I think this is pretty cool and it makes me feel more hopeful about training networks that are more accurate.</p>

<p>One other funny thing about this conversation–when I tried to trick the network into thinking a panda is a vulture, it spent a while thinking it was an ostrich in the middle. And when I asked Jeff Dean this question about the panda and the dog, he mentioned off-hand “the panda ostrich space” without me bringing up ostriches at all! I thought it was cool that he’s clearly spent enough time with the data &amp; these neural networks to just know offhand that ostriches and pandas are somehow close together.</p>

<h3 id="less-magic">Less magic</h3>

<p>When I started doing this, I didn’t know almost anything about neural networks. Now that I’ve tricked them into thinking a panda is a vulture and seen how it’s smarter at dealing with dogs than pandas, I understand them a tiny bit better. I won’t say that I don’t think what Google is doing is magic any more–I’m still pretty confused by neural nets. There’s a lot to learn! But tricking them like this removes a little of the magic, and now I feel better about them.</p>

<p>And so can you! All the code to reproduce this is in this <a href="https://github.com/jvns/neural-nets-are-weird">neural-networks-are-weird</a> repo. It uses Docker so you can get it installed easily, and you don’t need a GPU or a fancy computer. I did all this on my 3-year-old GPU-less laptop.</p>

<p>And if you want to feel <strong>even better</strong>, read the original paper! (<a href="http://arxiv.org/abs/1412.6572">“Explaining and Harnessing Adversarial
Examples”</a>). It’s short, well written, and tells you more that I didn’t go into here, including how to use this trick to build better neural networks!</p>

<p><small>
Thanks to Mathieu Guay-Paquet, Kamal Marhubi, and others for helping me with this article!
</small></p>



  </article>

  
    </div></body></html>