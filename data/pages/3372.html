<html><body><div><div class="post_body"><p/><center><iframe src="https://www.youtube.com/embed/kMTXL5FUHGM" frameborder="0" allowfullscreen="">VIDEO</iframe></center>
<p>In this article I'm going to introduce an authentication scheme known as <em>two factor authentication</em>. As the name implies, this method requires the user to provide two forms of identification: a regular password and a one-time token. This greatly increases account security, because a compromised password alone is not enough to gain access, an attacker also needs to have the token, which is different every time. You can see me do a short demonstration of this technique in the video above.</p>
<p>As usual, this article includes a complete example that implements this authentication technique in a Flask application. You may think this is going to be an advanced article that needs complex cryptographic techniques, specialized hardware and/or proprietary libraries, but in reality it requires none of the above. The solution is relatively simple to add if you already have username and password authentication in place, and can be done entirely with open standards and open-source software. There are even open-source token generation apps for your Android or iOS smartphone!</p>
<h2>The Example Application</h2>
<p>As mentioned above, in this article I present a complete example application. This application demonstrates how to do two factor authentication in a web application that uses Flask and Flask-Login. If you would like to try a live version of this application, click the link below and follow the instructions to register an account. Note that you will be asked to install a free app on your smartphone as part of the registration process (Android and iOS are both supported).</p>
<p><a href="https://two-factor-auth.herokuapp.com/">Try the example application now!</a></p>
<p>The source code for the example application is hosted in the following Github repository: <a href="https://github.com/miguelgrinberg/two-factor-auth-flask">https://github.com/miguelgrinberg/two-factor-auth-flask</a>. See the README file for installation instructions.</p>
<h2>Introduction to Two Factor Authentication</h2>
<p>Letting users authenticate to an application just with a username and password combination is inherently risky, because when the password is compromised the attacker obtains full access. To reduce that risk, security conscious applications can implement <a href="http://en.wikipedia.org/wiki/Multi-factor_authentication">multi-factor authentication</a>, which requires the user to provide additional additional proofs of identity. With two factor authentication, the user must provide the password, plus a second authentication factor.</p>
<p>Some of these accessory identity verification schemes are based on a physical characteristic of the user, such as a fingerprint, or an iris scan. Another common way to prove identity is with a physical object that the user carries at all times, such as a card with a magnetic strip, or a portable token generator.</p>
<p>If you work for a company that lets you connect to the office from home through a <a href="http://en.wikipedia.org/wiki/Virtual_private_network">VPN</a>, chances are you are already familiar with two factor authentication, and you already have a token generation device or app similar to these:</p>
<p/><center><img src="/static/images/two-factor-01.jpg"/></center>
<p>For the example application in this article I'm going to concentrate on this type of authentication factor, which is based on one-time password generation algorithms.</p>
<h2>One-Time Passwords</h2>
<p>The idea behind one-time passwords is that they are only valid for a single login session. These passwords are generated algorithmically by a hardware device or a smartphone app. To validate a one-time password, the server runs the same algorithm and compares the result with the password provided by the user. The difference with a traditional password is that the user does not need to memorize anything, the generated password is displayed by the token generation device and the user just copies it to the login form.</p>
<p>There are many one-time password algorithms, most are proprietary, but there are a few open standards, of which <a href="http://en.wikipedia.org/wiki/HOTP">HOTP</a> and <a href="http://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm">TOTP</a> are the most commonly used.</p>
<p>The HOTP algorithm, short for HMAC-based One-time Password, is described in <a href="http://tools.ietf.org/html/rfc4226">RFC 4226</a>. This algorithm generates tokens based on a secret and a counter, both known by the token generation device and the authentication server. Each time a token is used the counter is incremented on both sides, and that makes the algorithm generate a different token for the next login attempt.</p>
<p>The TOTP algorithm, short for Time-based One-time Password, is described in <a href="http://tools.ietf.org/html/rfc6238">RFC 6238</a>. This standard also uses a shared secret, but deals away with the counter, which is replaced by the current time. With this algorithm the token changes at a predefined time interval, usually every 30 seconds.</p>
<p>The benefit of TOTP over HOTP is that tokens are a function of time, and thus are constantly changing. That means that even if an attacker can take a peek at the current token displayed on your smartphone app, a few seconds later it will be superseded by a new one. The disadvantage of TOTP is that it requires the token generator and the authentication server to have their clocks set to approximately the same time. This is not a problem for the smartphone, but on the server it is recommended that you run an <a href="http://www.ntp.org/">NTP</a> client to keep the clock from drifting.</p>
<p>For the example application that I present in this article I'm going to use TOTP, but it should be fairly easy to adapt the application to use HOTP.</p>
<h2>The First Factor: Password Authentication</h2>
<p>I'm not going to spend a lot of time describing how to do password authentication because I have written extensively about it. But I feel it is always good to repeat a few best-practices to keep user passwords safe:</p>
<ul>
<li>Passwords must never be stored in the database. Store a password hash instead.</li>
<li>To verify a password, calculate its hash, then compare it against the hash stored in the database.</li>
<li>Always use secure HTTP to transmit forms that contain passwords.</li>
</ul>
<p>If you would like to see a fairly complete implementation of password authentication that includes user registration, email verification and password resets, you will find one in my <a href="http://flaskbook.com">book</a>. The source code featured in the book is in <a href="https://github.com/miguelgrinberg/flasky">this Github repository</a>.</p>
<p>For this example I used a much simpler setup, because I did not want to complicate the example with features that are largely unrelated to this article. I have basically skipped email verification and password reset options, but note that these are necessary for a production application, even when two-factor authentication is added to the mix.</p>
<p>For this application, I used Flask-SQLAlchemy, Flask-Login, Flask-WTF and Flask-Bootstrap, so for those that have read my other Flask tutorials this is going to be a fairly familiar application. The <code>User</code> model class is shown below:</p>
<pre><code>from werkzeug.security import generate_password_hash, check_password_hash
from flask.ext.login import UserMixin
from app import db, lm

class User(UserMixin, db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), index=True)
    password_hash = db.Column(db.String(128))

    @property
    def password(self):
        raise AttributeError('password is not a readable attribute')

    @password.setter
    def password(self, password):
        self.password_hash = generate_password_hash(password)

    def verify_password(self, password):
        return check_password_hash(self.password_hash, password)
</code></pre>
<p>As you can see, I'm hashing the passwords using Werkzeug's hashing functions. Note that the <code>password</code> property allows me to say <code>user.password = 'some-password'</code>, and this will automatically trigger the hash of the password to be stored in <code>user.password_hash</code>. The original password is then discarded.</p>
<p>The user registers an account by providing a username and a password. The password is asked twice to ensure it is typed correctly. Here is the Flask-WTF form that handles this:</p>
<pre><code>class RegisterForm(Form):
    username = StringField('Username', validators=[Required(), Length(1, 64)])
    password = PasswordField('Password', validators=[Required()])
    password_again = PasswordField('Password again',
                                   validators=[Required(), EqualTo('password')])
    submit = SubmitField('Register')
</code></pre>
<p>Once users are registered, they can login by entering the username and the password on the login form, which you can see below:</p>
<pre><code>class LoginForm(Form):
    username = StringField('Username', validators=[Required(), Length(1, 64)])
    password = PasswordField('Password', validators=[Required()])
    submit = SubmitField('Login')
</code></pre>
<p>The route that handles the registration form is pretty straightforward, so I'm not going to show it here. It basically takes the username and the password submitted by the user and adds then as a new user to the database. Below you can see the route that logs a user in:</p>
<pre><code>@app.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated():
        # if user is logged in we get out of here
        return redirect(url_for('index'))
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user is None or not user.verify_password(form.password.data):
            flash('Invalid username or password.')
            return redirect(url_for('login'))
        # log user in
        login_user(user)
        flash('You are now logged in!')
        return redirect(url_for('index'))
    return render_template('login.html', form=form)
</code></pre>
<p>Here you can see how the password verification is done, simply by calling <code>user.verify_password()</code> in the model.</p>
<p>If you look at the commit history in the Github repository, you can find a commit that adds all the code related to password authentication together. You can also checkout that commit and try the application at that stage if you like. Once you feel you have a good understanding of the application at this stage, you are ready to move on to the tokens.</p>
<h2>The Second Factor: TOTP Tokens</h2>
<p>A search on <a href="https://pypi.python.org/pypi?%3Aaction=search&amp;term=totp&amp;submit=search">pypi</a> revealed a few packages that implement the TOTP algorithm. I tested a few of them and decided on <a href="https://github.com/tadeck/onetimepass/">onetimepass</a>, a small library that supports HOTP and TOTP and is compatible with Python 2 and 3. If you want to learn how these tokens are calculated, I recommend that you read the source code, which is short and easy to understand.</p>
<h3>The User Model</h3>
<p>Now that the problem of calculating and verifying tokens is solved, let's look at the changes that add token support to the user model:</p>
<pre><code>import os
import base64
import onetimepass

class User(UserMixin, db.Model):
    # ...
    otp_secret = db.Column(db.String(16))

    def __init__(self, **kwargs):
        super(User, self).__init__(**kwargs)
        if self.otp_secret is None:
            # generate a random secret
            self.otp_secret = base64.b32encode(os.urandom(10)).decode('utf-8')

    # ...

    def get_totp_uri(self):
        return 'otpauth://totp/2FA-Demo:{0}?secret={1}&amp;issuer=2FA-Demo' \
            .format(self.username, self.otp_secret)

    def verify_totp(self, token):
        return onetimepass.valid_totp(token, self.otp_secret)
</code></pre>
<p>The user model gets an additional field called <code>otp_secret</code> that stores the shared secret that the TOTP algorithm uses as input. This should be a binary string of length 10 encoded as a <a href="http://en.wikipedia.org/wiki/Base32">base32</a> string, which makes it a printable string with 16 characters. The <code>__init__()</code> constructor sets it to a random string if a value for this field isn't given as an argument.</p>
<p>The <code>get_totp_uri()</code> function returns an authentication URI. This is used to transfer the shared secret and additional account information to the smartphone. This URI will be rendered as a <a href="http://en.wikipedia.org/wiki/QR_code">QR code</a> that you have to scan with your phone. Below you can see the structure of these URIs:</p>
<pre><code>otpauth://&lt;protocol&gt;/&lt;service-name&gt;:&lt;user-account&gt;?secret=&lt;shared-secret&gt;&amp;issuer=&lt;service-name&gt;
</code></pre>
<p>Here the <code>&lt;protocol&gt;</code> can be <code>totp</code> or <code>hotp</code>. The <code>&lt;service-name&gt;</code> is the name of the service or application that the user is authenticating to. The <code>&lt;user-account&gt;</code> can be the username, the user's email address or anything that identifies the user account. The <code>&lt;shared-secret&gt;</code> is the code that is used to seed the token generator algorithm. The <code>issuer</code> argument is normally set to the service name. A <code>period</code> optional argument can also be used to change the interval for token changes, which defaults to 30 seconds. For more information about these URIs, see the documentation on the <a href="https://github.com/google/google-authenticator/wiki/Key-Uri-Format">Google Authenticator wiki</a>.</p>
<p>Finally, the <code>verify_totp()</code> function takes a token as input, and validates using the support provided by the onetimepass package.</p>
<h3>User Registration</h3>
<p>There are several possible options to consider when implementing the user registration flow. For some applications it may make sense to leave user registration as is, and then give users the option to optionally enable two factor authentication if they wish so. For other applications, two factor may be mandatory, so it is  incorporated into the registration process.</p>
<p>For this application, I have opted for the latter, so immediately after submitting the user registration page the user is presented with a two factor authentication setup page that looks like this:</p>
<p/><center><img src="/static/images/two-factor-02.jpg"/></center>
<p>Here the user needs to start the token generator app on the smartphone, and use it to scan the QR code. This is all it takes to register the shared secret and account information on the phone. After this step is done, the user can go to the login page and login using password and token for the first time.</p>
<p>The changes to implement the QR code page are not as scary as they may seem. First, the original registration route is changed to redirect to a new route that I called <code>two_factor_setup</code> instead of sending the user to the login page. Before redirecting, it adds the <code>username</code> to the user session, so that the QR code page knows what user is registering. Here are the changes to the registration route:</p>
<pre><code>@app.route('/register', methods=['GET', 'POST'])
def register():
    # ...
    form = RegisterForm()
    if form.validate_on_submit():
        # ...

        # redirect to the two-factor auth page, passing username in session
        session['username'] = user.username
        return redirect(url_for('two_factor_setup'))
    return render_template('register.html', form=form)
</code></pre>
<p>And below you can see the implementation of the <code>two_factor_setup</code> route:</p>
<pre><code>@app.route('/twofactor')
def two_factor_setup():
    if 'username' not in session:
        return redirect(url_for('index'))
    user = User.query.filter_by(username=session['username']).first()
    if user is None:
        return redirect(url_for('index'))
    # since this page contains the sensitive qrcode, make sure the browser
    # does not cache it
    return render_template('two-factor-setup.html'), 200, {
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'}
</code></pre>
<p>After validating that there is a username stored in the user session, this route ensures the user exists, and if it does it just renders a new template called <code>two-factor-setup.html</code>. This page is served with extra headers that tell the browser to not do any caching. The reason is that this page will include a QR code that can give an attacker access to the time based tokens, so it's best to take precautions and make sure there are no copies of the QR code lost in a cache.</p>
<p>The <code>two-factor-setup.html</code> template is also fairly simple:</p>
<pre><code>{% extends "base.html" %}
{% import "bootstrap/wtf.html" as wtf %}

{% block page_content %}
    &lt;h1&gt;Two Factor Authentication Setup&lt;/h1&gt;
    &lt;p&gt;You are almost done! Please start FreeOTP on your smartphone and scan the following QR Code with it:&lt;/p&gt;
    &lt;p&gt;&lt;img id="qrcode" src="{{ url_for('qrcode') }}"&gt;&lt;/p&gt;
    &lt;p&gt;I'm done, take me to the &lt;a href="{{ url_for('login') }}"&gt;Login&lt;/a&gt; page!&lt;/p&gt;
{% endblock %}
</code></pre>
<p>The page includes a reference to the QR code image, but the URL for this image is not a usual image link, it is a dynamic URL generated with Flask's <code>url_for()</code> function. This is because the QR code image has to be generated specifically for each user, so a Flask route is invoked to do this work.</p>
<p>This <code>qrcode</code> route is different than the rest, because instead of returning HTML it returns image data, in this case in <a href="http://en.wikipedia.org/wiki/Scalable_Vector_Graphics">SVG</a> format. To generate the QR code I'm using package <a href="https://github.com/mnooner256/pyqrcode">pyqrcode</a>. Here is the code for this route:</p>
<pre><code>@app.route('/qrcode')
def qrcode():
    if 'username' not in session:
        abort(404)
    user = User.query.filter_by(username=session['username']).first()
    if user is None:
        abort(404)

    # for added security, remove username from session
    del session['username']

    # render qrcode for FreeTOTP
    url = pyqrcode.create(user.get_totp_uri())
    stream = StringIO()
    url.svg(stream, scale=5)
    return stream.getvalue().encode('utf-8'), 200, {
        'Content-Type': 'image/svg+xml',
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'}
</code></pre>
<p>Here once again I check that the username is in the session and that it is a known user. If any of those checks fail, I return a 404 error code, which to the browser will look like it requested an image file that does not exist. If the user is valid, I quickly remove it from the session, because once the user requests the QR code I want to make sure it this image cannot be requested again. This means that if the user does not scan the QR code in this only occasion it is presented, then the account is not going to be accessible.</p>
<p>The information stored in the QR code is the URL that includes the TOTP data. This is what most TOTP smartphone apps expect, something that the <a href="https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&amp;hl=en">Google Authenticator</a> app started and everyone else copied. Recall that I've added a method that generates this URL as <code>User.get_totp_uri()</code> above. The QR code rendering simply involves using the <code>pyqrcode</code> functions to render the TOTP URL as a SVG image, which I save to a <code>StringIO</code> stream in memory. This buffer is then returned as a response with the correct content type for SVG images. I also threw in the headers that disable caching for the image, as I did with the parent HTML page.</p>
<p>The user now can scan the QR code with a TOTP enabled smartphone app, and as soon as that is done the registration process is complete. Pretty cool, right?</p>
<h3>Login</h3>
<p>The only piece that is left to do is to extend the login form to accept a token, and also to validate it. I mentioned above that applications may opt to make two factor authentication optional or mandatory. If this is made optional, then the login form does not change, users enter their username and password, and upon verification the application can find out if two factor authentication is enabled and present an additional form where the user enters the token. In the case of this application, however, two factor setup is required for all accounts, so I decided to make a single login dialog that accepts username, password and token together.</p>
<p>Here is the improved login form, which just gets an extra field for the token.</p>
<pre><code>class LoginForm(Form):
    username = StringField('Username', validators=[Required(), Length(1, 64)])
    password = PasswordField('Password', validators=[Required()])
    token = StringField('Token', validators=[Required(), Length(6, 6)])
    submit = SubmitField('Login')
</code></pre>
<p>And then the login route is simply enhanced with an additional validation check:</p>
<pre><code>@app.route('/login', methods=['GET', 'POST'])
def login():
    # ...
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user is None or not user.verify_password(form.password.data) or \
                not user.verify_totp(form.token.data):
            flash('Invalid username, password or token.')
            return redirect(url_for('login'))

        # log user in
        # ...
    return render_template('login.html', form=form)
</code></pre>
<p>Here the only addition is the call to <code>user.verify_totp()</code>, the method that I added to the user model to check tokens using the onetimepass package. Note that when authentication fails I do not give any clues about what part has failed, the error message is pretty generic.</p>
<p>And that is all, the application with two factor authentication is now complete!</p>
<h2>Possible Improvements</h2>
<p>This application is focused on simplicity, I tried to not over complicate it so that the core concepts of working with tokens are easy to understand. However, in a real world application you may want to make things a bit more robust, so I'm going to discuss some of these additions that may be useful.</p>
<p>As I mentioned above, for many types of applications using two factor authentication should be optional, so it is only for users that want to take advantage of the stronger account security. For these applications, user registration and login pages do not need to change. Instead, a settings page allows users to enable and set up two factor authentication once they are logged in. The login process is then split in two parts, the first part is the regular username and password login, and then for those users that enabled two factor authentication a second page requests the token.</p>
<p>A common practice for applications that allow users to edit sensitive account settings is to request the user to authenticate again right before making account changes. For example, to change your password, applications typically ask you to enter your old password first. When two factor authentication is used, the application should ask the user to provide the current token as well, but it is important that this is a new token that was not used before. Imagine that somehow an attacker was able to crack your password, and also spied on your phone and knows the current code. That means that for up to 30 seconds you are vulnerable. If the attacker logs in to your account and then quickly goes to the account settings page entering the password and the same token again, your account is compromised. Now the attacker can disable two factor authentication and gain full access in the future. To avoid this, an application should save any tokens that were consumed to the user database and not allow the same token to be used a second time. The attacker will be forced to wait those 30 seconds before entering the settings page, so it gets even harder to have the account compromised.</p>
<p>An alternative to use a smartphone app to generate the tokens is to have the server send an email or SMS with the current code. The onetimepass package that I used for the example application not only provides a function to validate TOTP codes, it has a function that just returns the current code, so you can then send it to the user as you see appropriate. For this type of workflow it may be necessary to increase the period at which tokens change.</p>
<p>Account recovery is harder when two factor authentication is used. If an application allows users to regain access to their accounts without having a valid token, then an attacker can take advantage of this facility as well. Typically users that are locked out of their accounts have to contact an administrator and have their accounts reset manually. You can also opt to add another form of verification, such as security questions, but of course this in part undermines the increased account security.</p>
<p>As mentioned in the <a href="http://www.reddit.com/r/Python/comments/2wtfc6/two_factor_authentication_with_flask/">reddit discussion of this article</a>, there are a couple of implementation details that can be improved to make the application more secure. Storing the OTP secret and the hashed passwords in the same table can be seen as a security risk, because in the event of a security breach that gives the attacker access to the database, both will be accessible. To mitigate this risk, you could choose to store these two sensitive items in different database tables, or even better, different databases altogether. Encrypting the OTP secret, maybe using Flask's <code>SECRET_KEY</code> as encryption key, can also help. In all cases secure HTTP must be used for all communications that include passwords and the OTP secret (which is encoded in the QR code).</p>
<h2>Conclusion</h2>
<p>I hope this was a useful article. I would love to hear what you build with the techniques I presented in this article, so please let me know of any projects you make. As always, feel free to write your questions below.</p>
<p>Miguel</p></div>
</div></body></html>