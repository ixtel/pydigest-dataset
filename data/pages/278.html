<html><body><div><div id="articleText">
                    <p id="articleLongDescription">In Part 4 of his seven-part series on learning Python Pyramid,  Jesse Smith examines the startup and request processes.</p>
                    <p id="articleDescription"/>

                    <a class="relatedBookLink" href="#">Like this article? We recommend <span class="ss-icon"></span></a>
                    
                    

                <p>If you haven't read <a href="/articles/article.aspx?p=2161678">Part 3 of this series</a>,  I recommend you do that before continuing with this article. In Part 3, we looked  at the project structure and what it means to an application.</p>
<p>
  This article covers the startup process , configuration files, and  request processing. By taking a closer look at the application startup process,  we can learn more about the configuration files as well. The request process is  an artifact created by the startup process for handling user requests.</p>
<p>
  To get started, we'll first examine the startup process, which can  be outlined in several steps that the <tt>pserve.exe</tt> command (Python server)  takes to initialize an application.</p>

<hr size="3"/>
<h3>Catch Up on All of the Articles in this Python Series</h3>
<p>Jesse Smith has written four articles in this series. Here are the earlier installments:</p>




<p class="thirteen columns">
 <br/><br/>
</p>
<hr size="3"/>

<h2>Startup Process</h2>
<p>Figure 1 shows a simple workflow diagram of the system startup  process.</p>

<p>
  The process begins by issuing a <tt>pserve.exe</tt> command from the  command line:</p>
<p>
  pserver.exe \myproject development.ini –reload</p>
<p>
  pserve uses a library called <tt>PasteDeploy</tt> to create Web  Server Gateway Interface (WSGI) application instances.</p>
<p>
  The first thing <tt>pserve.exe</tt> does is look at the information  in the <tt>development.ini</tt> file. Next, pserve finds the main (that is, <tt>app:main</tt>)  sections in the file. The most common applications use the <tt>[app:main]</tt> section to define the application's entry point. The entry point will be defined  in this section's <tt>use=</tt> property. A sample <tt>[app:main]</tt> section is  shown below:</p>
<pre>[app:main]

use = egg:MyProject

pyramid.reload_templates = true
pyramid.debug_authorization = false
pyramid.debug_notfound = false
pyramid.debug_routematch = false
pyramid.default_locale_name = en
pyramid.includes =
    pyramid_debugtoolbar</pre>
<p>
  In this example, the value <tt>egg:MyProject</tt> tells the <tt>paste.app_factory</tt> method (used by pserve) that the starting point of the application will be in a  project named <tt>MyProject</tt>.</p>
<p>
  Next, pserve configures logging for the application defined by the <tt>[loggers]</tt>, <tt>[loggers:root]</tt>, and <tt>[logger:&lt;<em>project_name</em>&gt;]</tt> sections of the <tt>.ini</tt> file. An example of these three sections appears  below:</p>
<pre>[loggers]

keys = root, myproject

[logger_root]
level = INFO
handlers = console

[logger_myproject]
level = DEBUG
handlers =
qualname = myproject</pre>
<p>
  Next, the <tt>__init__.py</tt> file is located, and a dictionary of  key/value pairs from sections in the <tt>development.ini</tt> file are passed  into the <tt>main</tt> function. For example:</p>
<pre>def main(global_config, **settings):

    config = Configurator(settings=settings)
    config.add_static_view('static', 'static', cache_max_age=3600)
    config.add_route('home', '/')
    config.scan()
    return config.make_wsgi_app()</pre>
<p>
  <a href="/articles/article.aspx?p=2161677">Part 2 of this series</a> covered the <tt>__init_.py</tt> file. The <tt>global_config</tt> parameter is a set  of dictionary values that are obtained from the <tt>[DEFAULT]</tt> section (if it  exists) of the <tt>development.ini</tt> file. The <tt>**settings</tt> parameter is  a dictionary of the other settings needed to return a <tt>WSGI</tt> application  instance provided by the <tt>[app:main]</tt> section.</p>
<p>
  A <tt>Configurator</tt> instance is created next, which creates the  application's registry containing the configuration information.</p>
<p>
  Next, the <tt>config.make_wsgi_app()</tt> function returns a router  instance that's used to connect the application server to the web server, thus  creating the <tt>WSGI</tt> application instance.</p>
<p>
  Finally, the <tt>WSGI</tt> instance is returned to <tt>pserve</tt>,  which calls the <tt>make_server</tt> method (not shown here) in the application's <tt>__init__.py</tt> file.</p>
<p>
  The server is now ready to serve requests.</p>
<h2>Request Processing</h2>
<p>Request processing details the lifecycle of a request to the application.  From a high-level overview, this process is a basic one, as shown in the following  steps to handle a request:</p>
<ol>
<li>A request is made from the browser to the  server and port number defined in the application's <tt>__init__.py</tt> file.</li>
<li>The <tt>router</tt> instance creates a <tt>request</tt> object by mapping the <tt>request</tt> URL to URL patterns provided by the <em>route mapper</em>.</li>
<li>If a routing match is found, the request is  passed into a <tt>view_callable</tt> matching the route.The <tt>view_callable</tt> returns a <tt>response</tt> object that provides the response to the user. It could be simple text, custom  text, or a template page.</li>
</ol>
<p>The process of matching a route to a view is referred to as <em>URL dispatching</em>, which is discussed in  the next section.</p>
<h2>URL Dispatching</h2>
<p>URL dispatching is actually part of the request-processing  lifecycle, but should be explored further so you'll understand how Python  associates a request to a view.</p>
<p>
  Typically, a Pyramid application will have a <em>routing configuration</em>. This configuration provides an ordered set  of URLs that the application will use to map a request to a view. The code to  achieve this goal is similar to the block of code below:</p>
<pre>from views import myview

config.add_route('myroute', '/register/')
config.add_view(myview, route_name='myroute')</pre>
<p>
  This code uses the <tt>add_route</tt> method to give the route a  name. The <tt>add_view</tt> method associates that route to a view; However, the <tt>add_view</tt> method may be replaced with the <tt>scan</tt> method if you're using a  Declarative Configuration (discussed in <a href="/articles/article.aspx?p=2161677">Part 2 of this  series</a>). The second parameter to the <tt>add_view</tt> method is the  pattern. Of course, this can be more complicated than in the code example. For  example, you could use <em>replacement  markers</em>:</p>
<pre>config.add_route('myroute', '/books/{id}')</pre>
<p>
  The <tt>{id}</tt> segment in the pattern will accept any numbers or  letters as a substitute.</p>
<h2>Conclusion</h2>
<p>In this article, you learned about the application startup, request,  and URL dispatching processes. The startup process is mainly concerned with  initializing the application and getting it ready to handle requests. The  request process is the lifecycle of a request from a user to the application,  which ends in a response. The URL dispatching process helps to fulfill the  request process by matching the incoming URL to a view.</p>
<p>
  The <tt>development.ini</tt> file has several sections with settings  that are used by the application startup process. These settings also include  turning on debugging options; whereas, with the <tt>production.ini</tt> file,  these options are disabled.</p>
<p>
  After learning about these core processing units, the next logical  step is to move into the last part of the presentation layer of a Pyramid  application, which is working with views. <a href="/articles/article.aspx?p=2161680">Part 5 of this series</a> covers view concepts in more  detail.</p>
            </div>
            </div></body></html>