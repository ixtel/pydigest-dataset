<html><body><div><div class="content html_format"><p>
      Здравствуйте. </p>
<p>
Раньше часто слушал музыку средствами «Вконтакте» (далее ВК). После перехода на Ubuntu 14.10 возникли проблемы в виде полного зависания компьютера во время прослушивания аудиозаписей через браузер Google Chrome для linux систем. В связи с этим возникла необходимость забекапить свой плейлист для прослушивания музыки в оффлайн режиме. Для этих целей решил написать маленький скрипт на языке Python, которым можно будет не только скачивать музыку с нуля, но и обновлять существующую библиотеку.
</p><p>
Я использовал такие модули:
</p><ul>
<li>Selenium webdriver </li>
<li>requests</li>
<li>json</li>
<li>os</li>
</ul><p>
Собственно, начнем.
</p><a name="habracut"/><p>
Сначала подключаем модули:

</p><pre><code class="python">import os
import requests
from selenium import webdriver
import json
</code></pre><p>
Далее нужно получить access_token для выполнения запросов к API и получения необходимых нам прав доступа.</p><p>
Перед этим нам нужно создать и активировать свое Standalone/Desktop приложение, id которого мы будем указывать в запросе.
</p><p>
Схема довольно простая: Мы открываем окно браузера, переходим по ссылке, вводим данные от аккаунта, разрешаем доступ, на выходе копируем необходимые данные с url(это access_token и expires_in — срок истекания токена).
</p><p>
Более детально о создании приложения и авторизации можно почитать </p><a href="https://vk.com/dev/main">здесь</a><p>.
</p><p>
Я использовал selenium из-за собственной лени. У этого модуля достаточно функционала для автоматизации всех вышеуказанных действий. Вы можете использовать любой другой виртуальный браузер, который вам нравится.
</p><p>
Собственно код с комментариями:

</p><pre><code class="python"># Создаем объект драйвера

driver = webdriver.Firefox()

# Переходим по ссылке.
# client_id - идентификатор созданного нами приложения
# scope - права доступа
driver.get("http://api.vkontakte.ru/oauth/authorize?"
           "client_id=4591034&amp;scope=audio"
           "&amp;redirect_uri=http://api.vk.com/blank.html"
           "&amp;display=page&amp;response_type=token")

user = "email/phone"
password = "password"

# Находим элементы формы и вводим данные для авторизации
user_input = driver.find_element_by_name("email")
user_input.send_keys(user)
password_input = driver.find_element_by_name("pass")
password_input.send_keys(password)

# Нажимаем на кнопку
submit = driver.find_element_by_id("install_allow")
submit.click()

# Получаем необходимые данные для выполнения запросов к api
current = driver.current_url
access_list = (current.split("#"))[1].split("&amp;")
access_token = (access_list[0].split("="))[1] # acces_token
expires_in = (access_list[1].split("="))[1] # срок времени действия токена
user_id = (access_list[2].split("="))[1] # id нашей учетной записи в ВК
# Закрываем окно браузера

driver.close()
</code></pre><p>
До недавнего времени «ВК API» возвращало все данные в формате xml, что было немного неудобным. Сейчас же ответы сериализируются в json словарь с которым можно без проблем работать. Здесь нам пригодится библиотека </p><b>json</b><p>, а конкретнее метод </p><b>loads()</b><p>, который преобразовывает строку в словарь.
</p><p>
Дальше план действий довольно простой:
</p><ol>
<li>Выполняем запрос и получаем в ответе список всех аудиозаписей с плейлиста учетной записи (ограничение до 6000);</li>
<li>Преобразовываем ответ в словарь;</li>
<li>Берем необходимую информацию со словаря (исполнитель, название трека, ссылка на трек);</li>
<li>Скачиваем аудиозаписи в нужную директорию, называя нужными названиями, а не стандартным набором букв, в котором хранится название трека.</li>
</ol>
<p>
Первый шаг:

</p><pre><code class="python"># Принт для дебага
print "Connecting"
# Адрес запроса
url = "https://api.vkontakte.ru/method/" \
      "audio.get?uid=" + user_id +\
      "&amp;access_token=" + access_token
# Создаем листы для хранения данных
artists_list = []
titles_list = []
links_list = []
# счетчик для дебага и перехода по элементам листов
number = 0
# Читаем ответ сервера и сохраняем в переменную
page = requests.get(url)
html = page.text
</code></pre><p>
Второй шаг:

</p><pre><code class="python">my_dict = json.loads(html) # используем loads()
</code></pre>
<p>
Третий шаг, думаю все понятно без комментирования:

</p><pre><code class="python">for i in my_dict['response']:
    artists_list.append(i['artist'])
    titles_list.append(i['title'])
    links_list.append(i['url'])
    number += 1
</code></pre><p>
Четвертый и заключительный шаг:

</p><pre><code class="python"># Создаем директорию, если она не была создана ранее

path = "downloads"

if not os.path.exists(path):
    os.makedirs(path)
# Принт для дебага
print "Need to download: ", number

# Процесс скачивания файлов

for i in range(0, number):

# Путь по которому будет храниться/скачиваться конкретная аудиозапись
    new_filename = path+"/"+artists_list[i] + " - " + titles_list[i] + ".mp3"
    print "Downloading: ", new_filename, i
# Проверка на существующий файл
    if not os.path.exists(new_filename):
# Сама загрузка файла, отсекаем из ссылки все аргументы и указываем путь куда скачивать
        with open(new_filename, "wb") as out:
            response = requests.get(links_list[i].split("?")[0])
            out.write(response.content)

print "Download complete."
</code></pre><p>
Сейчас веду работу над самопальным плеером для прослушивания аудиозаписей с ВК (да, именно отдельный плеер, а не плагин для уже существующих популярных проигрывателей). В дальнейшем планирую написать статью, в которой будет описан процесс.
</p><p>
На этом все, спасибо за внимание.

</p><b>UPD:</b><p>
Статья немного отредактирована в соответствии с пожеланиями из комментариев.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>