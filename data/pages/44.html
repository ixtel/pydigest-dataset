<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/getpro/habr/post_images/255/08a/bc5/25508abc50b2c02243f7a68322a5490e.png" alt="Django"/>
<p>
Приветствую, хабралюди. Вчера в блоге популярного веб-фреймворка для питона, Django, появилась </p><a href="https://www.djangoproject.com/weblog/2013/nov/06/django-16-released/">новость</a><p> о релизе новой версии под номером 1.6.
</p><p>
Полный перечень всех новшеств, а также информация об изменениях (в том числе и обратно несовместимых) традиционно находится в </p><a href="https://docs.djangoproject.com/en/1.6/releases/1.6/">заметках к релизу</a><p>. По моим ощущениям, на этот раз разработчики сфокусировались в большей степени на работе с БД.
</p><p>
В данной статье-новости я хотел бы отметить основные, на мой взгляд, изменения.
</p><a name="habracut"/>
<h3>Работа с транзакциями</h3><p>
В 1.6 появилось новое API для работы с транзакциями. Начиная с этой версии привычные для работы с транзакциями функции </p><code>autocommit()</code><p>, </p><code>commit_on_success()</code><p> и </p><code>commit_manually()</code><p> из модуля </p><code>django.db.transaction</code><p> теперь считаются устаревшими и останутся для совместимости до 1.8. На их замену приходит </p><code>atomic()</code><p>.
</p><p>
Основная логика здесь примерно следующая: ранее, ключевым моментом был механизм управления поведением при работе с коммитом транзакции — автокоммитом (т.е. каждый SQL-запрос начинает транзакцию и коммитит ее автоматом) или ручным коммитом (</p><code>COMMIT;</code><p> SQL-запрос отправляется самостоятельно). Этот механизм довольно хорошо работал в случае независимых транзакций, но вот в случае вложенного использования устаревших функций — результат мог быть некорректен. Например если у нас есть два вложенных один в другой блока </p><code>commit_on_success()</code><p>, то может возникнуть такая ситуация, что результат выполнения внутреннего блока будет закоммичен, поломав, с точки зрения транзакций, атомарность внешнего блока.
</p><p>
Что будет теперь: во-первых, джанга теперь по умолчанию включает режим автокоммита, стоит заметить, нарушая при этом </p><a href="http://www.python.org/dev/peps/pep-0249">PEP 249</a><p>. А во-вторых, единственным механизмом работы с транзакциями становится </p><code>atomic()</code><p>, который не боится вложенности, т.к. в случае внешнего блока — работает с транзакцией, а в случае вложенного — с SQL'ными </p><a href="http://en.wikipedia.org/wiki/Savepoint">точками сохранения</a><p>. Также теперь вместо </p><code>TransactionMiddleware</code><p> доступна конфигурационная константа </p><code>ATOMIC_REQUESTS</code><p>, при установке значения которой в </p><code>True</code><p> (дефолтное значение — </p><code>False</code><p>), джанго будет стараться обработать один HTTP запрос в одной транзакции. Т.е. выполнился запрос без каких-либо проблем — закоммитили, нет — откатили.
</p><p>
Надо заметить, что </p><code>atomic()</code><p> может использоваться как декоратор, так и как менеджер контекста:

</p><pre><code class="python">from django.db import transaction

# декоратор
@transaction.atomic
def viewfunc1(request):
    # этот код будет выполнен внутри транзакции
    do_stuff()
and as a context manager:

# менеджер контекста
def viewfunc2(request):
    # этот код выполняется в режиме автокоммита
    do_stuff()

    with transaction.atomic():
        # а здесь уже выполняется внутри транзакции
        do_more_stuff()
</code></pre>
<p>
Более подробное описание — как всегда, доступно </p><a href="https://docs.djangoproject.com/en/1.6/topics/db/transactions/#django.db.transaction.atomic">в документации</a><p>.

</p><h3>Постоянные соединения с БД</h3><p>
Это, конечно, не пулл соединений, т.к. они изолированы потоками, в которых запущено приложение. Но, это уже гораздо лучше, с точки зрения производительности, чем постоянное подключение к базе при каждом HTTP запросе. Время жизни соединений регулируется конфигурационной константой </p><code>CONN_MAX_AGE</code><p>.

</p><h3>Тесты</h3><p>
В 1.6 появился новый запускальщик тестов </p><code>django.test.runner.DiscoverRunner</code><p>, который использует логику поиска модулей с тестами из </p><code>unittest2</code><p>. Теперь тесты могут располагаться в любых модулях, если имя файла, содержащего их соответствует маске </p><code>test*.py</code><p>.
</p><p>
Правда, при этом, тесты из </p><code>models.py</code><p> и </p><code>tests/__init__.py</code><p> найдены, и соответственно, запущены не будут (в отличие от поведения в предыдущих версиях). Самым простым решением является переименовывание их в что-либо вида </p><code>test_models.py</code><p> и </p><code>tests/test.py</code><p>. А также, доктесты больше не будут подгружаться автоматом. Но их будет не сложно включить обратно, следуя </p><a href="http://docs.python.org/2/library/doctest.html#unittest-api">указаниям</a><p> из документации по </p><code>unittest</code><p>.
</p><p>
Кстати, у management-команды </p><code>./manage.py test</code><p> теперь появилась опция </p><code>--pattern</code><p>, указав которую, как не трудно догадаться, можно менять маску для поиска файлов с тестами.

</p><h3>Management-команда check</h3><p>
Команда </p><code>django-admin.py check</code><p> теперь позволяет проверить совместимость проекта или приложения с текущей версией джанги, выдавая оповещения в случае нахождения несовместимых мест. Предполагается, что эта команда будет помогать при переходе на новые версии фреймворка.
</p><p>
Кстати, 1.6 — это последний релиз джанги, в котором еще поддерживается питон версии 2.6. Со следующего релиза будет требоваться как минимум 2.7 питон.

</p><h3>Улучшения ORM</h3><p>
Теперь </p><code>QuerySet</code><p> поддерживает синтаксический сахар, в виде методов </p><code>first()</code><p> и </p><code>last()</code><p>, а тажке </p><code>earliest()</code><p> в дополнение к </p><code>latest()</code><p>.
</p><p>
ORM теперь поддерживает </p><code>hour</code><p>, </p><code>minute</code><p> и </p><code>second</code><p> в дополнение к добавленным ранее </p><code>year</code><p>, </p><code>month</code><p> и </p><code>day</code><p> при поиске по полям с датой и/или временем.
</p><p>
Ну и традиционный опрос. Интересует процентное соотношение, поэтому если используется несколько версий — имеет смысл указать ту, на которой ведется основная разработка.

      	</p><div class="polling">
		

	

    <p class="for_users_only_msg">Только зарегистрированные пользователи могут участвовать в опросе. <a href="https://habrahabr.ru/auth/login/">Войдите</a>, пожалуйста.</p>
	</div>

      <p class="clear"/>
    </div>

    
  </div></body></html>