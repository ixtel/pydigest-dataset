<html><body><div><p>A saner way to parse JSON.</p>








<p>JSane is a JSON ‚Äúparser‚Äù that makes attribute accesses easier.</p>
<div id="motivation">
<h2>Motivation</h2>
<p>Picture the scene. You‚Äôre a jet-setting developer who is obsessed with
going to the gym. One day, a world-class jewel thief kidnaps you and
asks you to hack into the super-secure bank server in thirty seconds,
while an ultramodel is performing oral sex on you. You hurriedly trace
the protocol on the wire, only to discover, to your dismay, that it uses
JSON. Nested JSON, with levels and levels of keys.</p>
<p>It‚Äôs hopeless! You‚Äôll never type all those brackets and quotation marks
in time! Suddenly, a flash of a memory races through your mind, like
some cliche from a badly-written Github README. You launch the shell and
type two words:</p>
<pre>import jsane
</pre>
<p>The day is saved.</p>
</div>
<div id="motivation-non-hollywood-version">
<h2>Motivation (non-Hollywood version)</h2>
<p>Are you frustrated with having to traverse your nested JSON key by key?</p>
<pre>root = my_json.get("root")
if root is None:
    return None

key1 = root.get("key1")
if key1 is None:
    return None

key2 = key1.get("key2")
if key2 is None:
    return None

&lt;five more times&gt;
</pre>
<p>Is your code ruined by pesky all-catching <tt>except</tt> blocks?</p>
<pre>try:
    my_json["root"]["key1"]["key2"]["key3"]
except:
    return None
</pre>
<p>Are you tired of typing all the braces and quotes all the time?</p>
<pre>my_json["root"]["key1"[""]][]"]']'"}}""]
</pre>
<p>Now there‚Äôs JSane!</p>
</div>
<div id="usage">
<h2>Usage</h2>
<p>Using JSane is simple, at least. It‚Äôs pretty much a copy of the builtin <cite>json</cite>
module. Here‚Äôs an example:</p>
<pre>&gt;&gt;&gt; import jsane

&gt;&gt;&gt; j = jsane.loads('{"some": "json"}')
&gt;&gt;&gt; j.some
"json"
</pre>
<p>If the key does not exist, you‚Äôll get an exception. You can get rid of that by
specifying a default:</p>
<pre>&gt;&gt;&gt; import jsane

&gt;&gt;&gt; j = jsane.loads('{"some": "json"}')
&gt;&gt;&gt; j(default="üí©").haha_sucka_this_doesnt_exist
"üí©"
</pre>
<p>Due to Python being a non-insane language, there‚Äôs a limit to the amount of
crap you can pull with it, so JSane actually returns a <cite>Traversable</cite>  object if
you access a <cite>dict</cite> or <cite>list</cite>:</p>
<pre>&gt;&gt;&gt; j = jsane.loads('{"foo": {"bar": "baz"}}')
&gt;&gt;&gt; type(j.foo)
Traversable
</pre>
<p>If you want your object back, call <cite>.resolve()</cite>:</p>
<pre>&gt;&gt;&gt; j.foo.resolve()
{"bar": "baz"}
</pre>
<p>That‚Äôs about it. I‚Äôm not loving this API, so if anyone has any good
recommendations on how I may better fulfil my unholy purpose, I‚Äôm changing the
API on the spot. No guarantees of stability before version 1, as always. Semver
giveth, and semver taketh away.</p>
<p>Help needed/welcome/etc, mostly with designing the API. Also, if you find this
library useless, let me know.</p>
</div>
</div></body></html>