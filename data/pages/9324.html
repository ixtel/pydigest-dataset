<html><body><div><div class="entry-content">
                    <p><em>note: The introduction mentions Django and Plone. However, this is not an article about Django or Plone.</em></p>
<div class="section" id="introduction">
<h2>Introduction</h2>
<p>Years ago, when I was working with <a class="reference external" href="http://plone.org">Plone</a> at <a class="reference external" href="http://nasa.gov">NASA</a>, one thing I dreaded was when content editors would copy-and-paste from Microsoft Word into the title bar. All kinds of funny characters would appear in the title bar and URL. I would have to go into the database (ZODB) and fix things. Things didn't get better until <a class="reference external" href="https://github.com/reedobrien">Reed O'Brien</a> turned on a title validator (probably in <tt class="docutils literal">Plone.i18n</tt>).</p>
<p>When we started using <a class="reference external" href="https://www.djangoproject.com">Django</a>, one thing that made it nice was the presence of it's <a class="reference external" href="https://docs.djangoproject.com/en/dev/ref/utils/#module-django.utils.text">slugify()</a> function and template filter. Inspired by the newspaper industry, this function it easier on both content editors and software engineers. In any case, using <tt class="docutils literal">slugify()</tt> we completed a number of projects, with <a class="reference external" href="http://science.nasa.gov/">NASA Science</a> being the only public one I worked on.</p>
<p>As much as the <tt class="docutils literal">slugify()</tt> function was useful, there were problems. As I discovered time and time again over the years, it didn't handle <a class="reference external" href="https://en.wikipedia.org/wiki/Unicode">unicode</a>. Or rather, it handled them by simply vanishing non-ASCII unicode characters. For example:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.utils.text</span> <span class="kn">import</span> <span class="n">slugify</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">slugify</span><span class="p">(</span><span class="s">u"straße"</span><span class="p">)</span> <span class="c"># German for road</span>
<span class="s">u"strae"</span>
</pre></div>
<p>If you read German, you'll know that the default Django <tt class="docutils literal">slugify()</tt> function is converting the word 'road' to nonsense. For sites dealing with internationalization, this won't do. So over three years ago while at <a class="reference external" href="http://www.mozilla.org/">Mozilla</a>, <a class="reference external" href="http://pinterest.com">Pinterest</a> engineer <a class="reference external" href="https://twitter.com/davedash">Dave Dash</a> created <a class="reference external" href="https://pypi.python.org/pypi/unicode-slugify">unicode-slugify</a>. From then on we could do this:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">slugify</span> <span class="kn">import</span> <span class="n">slugify</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">slugify</span><span class="p">(</span><span class="s">u"straße"</span><span class="p">)</span> <span class="c"># Again with the German word for road</span>
<span class="s">u"straße"</span>
</pre></div>
<div class="section" id="what-if-i-m-not-using-django">
<h3>What If I'm Not Using Django?</h3>
<p>While a very nice tool, this package is dependent on Django's internal machinery to operate, which is a problem for non-Django users. While we could use Python's <a class="reference external" href="http://flask.pocoo.org/snippets/5/">unicodedata library to resolve unicode to slugs</a>, wouldn't it be nice if there was a nicely packaged/tested solution?</p>
<p>Fortunately, such a nicely packaged/tested solution exists, and it's awesome!</p>
<img alt="An Awesome Django slug" class="align-center" id="django-slug" src="https://s3.amazonaws.com/pydanny/awesome_slugify_django.jpg"/>
</div>
</div>
<div class="section" id="introducing-awesome-slugify">
<h2>Introducing awesome-slugify</h2>
<p>Created and maintained by <a class="reference external" href="https://github.com/dimka665">Dmitry Voronin</a>, <a class="reference external" href="https://pypi.python.org/pypi/awesome-slugify">awesome-slugify</a> is easy to use and <strong>100% independent from Django</strong>. You call it thus:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">slugify</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">slugify</span><span class="o">.</span><span class="n">slugify</span><span class="p">(</span><span class="s">u"straße"</span><span class="p">)</span> <span class="c"># Yet again the German for road</span>
<span class="s">u'strasse'</span>
</pre></div>
<p>Works! Hooray!</p>
<p>However, please note that unlike the Django-only <strong>unicode-slugify</strong> package which preserves the non-ASCII characters, <strong>awesome-slugify</strong> transformed the German 'ß' into an ASCII substitution of 'ss'. This is similar to how the popular <a class="reference external" href="https://pypi.python.org/pypi/python-slugify">python-slugify</a> package works. While this behavior of translating unicode to ASCII might work for English-only sites, it's not so useful for the rest of the world. Fortunately, <strong>awesome-slugify</strong> also provides the incredibly useful <tt class="docutils literal">slugify_unicode()</tt> function:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">slugify</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">slugify</span><span class="o">.</span><span class="n">slugify_unicode</span><span class="p">(</span><span class="s">u"straße"</span><span class="p">)</span> <span class="c"># What is it with German Roads?</span>
<span class="s">u'stra</span><span class="se">\xdf</span><span class="s">e'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">slugify</span><span class="o">.</span><span class="n">slugify_unicode</span><span class="p">(</span><span class="s">u"straße"</span><span class="p">)</span> <span class="o">==</span> <span class="s">u"straße"</span>
<span class="bp">True</span>
</pre></div>
<div class="section" id="using-awesome-slugify">
<h3>Using awesome-slugify</h3>
<p>Rather than describe <strong>awesome-slugify</strong> in paragraph format, here is working test code (<a class="reference external" href="http://pydanny.com/pytest-no-boilerplate-testing.html">using pytest which I described before</a>) that explains what we can do:</p>
<div class="highlight"><pre><span class="c"># -*- coding: utf-8 -*-</span>
<span class="c"># test_awesome_slugify.py</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span>
<span class="kn">import</span> <span class="nn">pytest</span>
<span class="kn">from</span> <span class="nn">slugify</span> <span class="kn">import</span> <span class="n">slugify</span><span class="p">,</span> <span class="n">slugify_unicode</span>

<span class="k">def</span> <span class="nf">test_simple</span><span class="p">():</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="s">"This is basic functionality!!!    "</span>
    <span class="k">assert</span> <span class="n">slugify</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span> <span class="o">==</span> <span class="s">"This-is-basic-functionality"</span>

<span class="k">def</span> <span class="nf">test_remove_special_characters</span><span class="p">():</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="s">"special characters (#?@$%^&amp;*) are also ASCII"</span>
    <span class="k">assert</span> <span class="n">slugify</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span> <span class="o">==</span> <span class="s">"special-characters-are-also-ASCII"</span>

<span class="k">def</span> <span class="nf">test_basic_accents_and_backslash_escapes</span><span class="p">():</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="s">'Where I</span><span class="se">\'</span><span class="s">ve gone before'</span>
    <span class="k">assert</span> <span class="n">slugify</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span> <span class="o">==</span> <span class="s">"Where-Ive-gone-before"</span>

<span class="nd">@pytest.fixture</span>
<span class="k">def</span> <span class="nf">accents</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">u'Àddîñg áçćèńtš tô Éñgłïśh íš śīłłÿ!'</span>

<span class="k">def</span> <span class="nf">test_accents</span><span class="p">(</span><span class="n">accents</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">slugify</span><span class="p">(</span><span class="n">accents</span><span class="p">)</span> <span class="o">==</span> <span class="s">"Adding-accents-to-English-is-silly"</span>

<span class="k">def</span> <span class="nf">test_keep_accents</span><span class="p">(</span><span class="n">accents</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">slugify_unicode</span><span class="p">(</span><span class="n">accents</span><span class="p">)</span> <span class="o">==</span> \
                        <span class="s">'Àddîñg-áçćèńtš-tô-Éñgłïśh-íš-śīłłÿ'</span>

<span class="k">def</span> <span class="nf">test_keep_accents_lower</span><span class="p">(</span><span class="n">accents</span><span class="p">):</span>
    <span class="c"># Because awesome-slugify doesn't lower() while slugify, we</span>
    <span class="c">#   have to do it ourselves. I'm torn if I like this or hate it</span>
    <span class="k">assert</span> <span class="n">slugify_unicode</span><span class="p">(</span><span class="n">accents</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> \
                        <span class="s">'àddîñg-áçćèńtš-tô-éñgłïśh-íš-śīłłÿ'</span>

<span class="k">def</span> <span class="nf">test_musical_notes</span><span class="p">():</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="s">"Is ♬ ♫ ♪ ♩ a melody or just noise?"</span>
    <span class="k">assert</span> <span class="n">slugify</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span> <span class="o">==</span> <span class="s">"Is-a-melody-or-just-noise"</span>
    <span class="k">assert</span> <span class="n">slugify_unicode</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span> <span class="o">==</span> <span class="s">"Is-a-melody-or-just-noise"</span>

<span class="k">def</span> <span class="nf">test_chinese</span><span class="p">():</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="s">"美国"</span> <span class="c"># Chinese for 'America'</span>
    <span class="k">assert</span> <span class="n">slugify</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span> <span class="o">==</span> <span class="s">"Mei-Guo"</span>
    <span class="k">assert</span> <span class="n">slugify_unicode</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span> <span class="o">==</span>  <span class="s">"美国"</span>

<span class="k">def</span> <span class="nf">test_separator</span><span class="p">():</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="s">"Separator is a word I frequently mispell."</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">slugify</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s">"_"</span><span class="p">,</span> <span class="n">capitalize</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="s">"Separator_is_a_word_I_frequently_mispell"</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">pytest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
<p>Easy to use as any good <tt class="docutils literal">slugify()</tt> function!</p>
</div>
<div class="section" id="restricting-the-length-of-a-returned-slug">
<h3>Restricting the length of a returned slug</h3>
<p>When using <strong>awesome-slugify</strong>'s <tt class="docutils literal">slugify()</tt> and <tt class="docutils literal">slugify_unicode()</tt> functions, the <tt class="docutils literal">max_length</tt> argument acts in an interesting fashion. On very short strings it removes longer words to make things fit. As the author of <strong>awesome-slugify</strong> is Russian, and the Russian language, as far as I know, doesn't have prepositions (words like 'the' and 'a') this makes sense.</p>
<p>Let's take a look, shall we?</p>
<div class="highlight"><pre><span class="c"># -*- coding: utf-8 -*-</span>
<span class="c"># test_awesome_slugify_max_length.py</span>
<span class="kn">import</span> <span class="nn">pytest</span>
<span class="kn">from</span> <span class="nn">slugify</span> <span class="kn">import</span> <span class="n">slugify</span><span class="p">,</span> <span class="n">slugify_unicode</span>

<span class="k">def</span> <span class="nf">test_max_length_tiny</span><span class="p">():</span>
    <span class="c"># Removes the longer words to fit smaller words in.</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="s">"$ is a special character, as is #."</span>
    <span class="k">assert</span> <span class="n">slugify</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="s">"is-a-as-is"</span>

<span class="k">def</span> <span class="nf">test_max_length_medium</span><span class="p">():</span>
    <span class="c"># Keeps in prepositions, but removes meaningful words.</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="s">"$ is a special character, as is #."</span>
    <span class="k">assert</span> <span class="n">slugify</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span> <span class="o">==</span> <span class="s">"is-a-special-as"</span>

<span class="k">def</span> <span class="nf">test_max_length_realistic</span><span class="p">():</span>
    <span class="c"># Long enough that long words are not removed from the string in favor</span>
    <span class="c">#   of shorter words.</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="s">"""This sentence illuminates the method that this package</span>
<span class="s">                handles truncation of longer strings.</span>
<span class="s">    """</span>
    <span class="k">assert</span> <span class="n">slugify</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span> <span class="o">==</span> \
        <span class="s">"This-sentence-illuminates-the-method-that-this-of"</span>

<span class="c"># The next few tests cover how the max_length argument handles truncation</span>
<span class="c">#   inside of a word. When working with longer word languages, like German,</span>
<span class="c">#   understanding how your chosen slugify() function works is important.</span>

<span class="k">def</span> <span class="nf">test_truncating_word</span><span class="p">():</span>
    <span class="c"># This demonstrates taking a long German word and truncating it.</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="s">u"Rindfleischetikettierungsüberwachungsaufgabenübertragungsgesetz"</span>
    <span class="k">assert</span> <span class="n">slugify</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span> <span class="o">==</span> \
                <span class="s">"Rindfleischetikettierungsuberwachungsauf"</span>
    <span class="k">assert</span> <span class="n">slugify_unicode</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span> <span class="o">==</span> \
                <span class="s">u"Rindfleischetikettierungsüberwachungsauf"</span>

<span class="k">def</span> <span class="nf">test_truncating_varying_letter_size</span><span class="p">():</span>
    <span class="c"># Truncating unicode slugs is challenging. For example, the German</span>
    <span class="c">#   letter 'ß' is 'ss' in English. Should a slugify's max_length</span>
    <span class="c">#   argument use the German or the English length? In the case of</span>
    <span class="c">#   awesome-slugify, it uses the length of English letter for both the</span>
    <span class="c">#   slugify() and slugify_unicode() functions.</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="s">u"straße"</span> <span class="c"># I really can't stop using German roads.</span>
    <span class="k">assert</span> <span class="n">slugify</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="s">"stras"</span>
    <span class="k">assert</span> <span class="n">slugify_unicode</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="s">u"straß"</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">pytest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="what-s-next">
<h2>What's Next?</h2>
<p>As demonstrated, <strong>awesome-slugify</strong> covers many common use cases. Nevertheless, in <a class="reference external" href="http://pydanny.com/awesome-slugify-human-readable-url-slugs-from-any-string-2.html">my next blog post</a> I cover how to write custom language <tt class="docutils literal">slugify()</tt> translation functions using <strong>awesome-slugify</strong>.</p>
<p><strong>Update 2013/01/23</strong> Thanks to <a class="reference external" href="http://www.reddit.com/user/flying-sheep">flying-sheep</a>, I Changed 'equivalent' to 'substitution' in describing the unicode-to-ASCII translation. This is because 'ss' is not a precise translation of 'ß'.</p>
</div>

                    
                </div>
                                </div></body></html>