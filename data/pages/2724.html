<html><body><div><div class="content">
      
        <h1 class="content-title">Walrus: Lightweight Python utilities for working with Redis</h1>
      
      
      
  
  
  
    <p><a href="http://media.charlesleifer.com/blog/photos/walrus-logo.png" title="photos/walrus-logo.png"><img alt="photos/walrus-logo.png" class="img-responsive" src="http://m.charlesleifer.com/t/800x-/blog/photos/walrus-logo.png?key=9jyh42CYPjjYY2T4XMmMUA"/></a></p>
<p>A couple weekends ago I got it into my head that I would build a thin Python wrapper for working with <a href="http://redis.io">Redis</a>. Andy McCurdy's <a href="https://redis-py.readthedocs.org/">redis-py</a> is a <strong>fantastic</strong> low-level client library with built-in support for connection-pooling and pipelining, but it does little more than provide an interface to Redis' built-in commands (and rightly so). I decided to build a project on top of redis-py that exposed pythonic containers for the Redis data-types. I went on to add a few extras, including a cache and a declarative model layer. The result is <a href="http://walrus.readthedocs.org/">walrus</a>.</p>
<h3>Installation</h3>
<p>If you'd like to try it out, you can install <code>walrus</code> using <code>pip</code>. Note that you will also need to install <code>redis-py</code> and have a Redis server running.</p>

<p>At the time of writing, the current version of walrus is 0.1.9.</p>
<h3>Containers</h3>
<p><a href="http://media.charlesleifer.com/blog/photos/p1421027460.57.jpg" title="photos/p1421027460.57.jpg"><img alt="photos/p1421027460.57.jpg" class="img-responsive" src="http://m.charlesleifer.com/t/800x-/blog/photos/p1421027460.57.jpg?key=iZHBit8vwVWsfRu5Y9ddEg"/></a></p>
<p>Redis supports five data-types, and each of these types supports a number of special-purpose commands. To make working with these types easier, I wrote container objects that look like their built-in analogues. For instance walrus hashes look like <code>dict</code> objects, have familiar methods like <code>keys()</code>, <code>items()</code>, <code>update()</code>, and support item access using square-brackets. Walrus sets behave like python sets, and so on.</p>
<p><code>walrus</code> comes with support for the five data-types, as well as an additional Array type implemented using lua scripts (as opposed to Redis' linked-list implementation):</p>

<p>Working with containers is easy, as they can be instantiated by calling the corresponding method on the walrus database instance. Let's see how it works:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">walrus</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">db</span> <span class="o">=</span> <span class="n">Database</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s1">'localhost'</span><span class="p">,</span> <span class="n">db</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">huey</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Hash</span><span class="p">(</span><span class="s1">'huey'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">huey</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">,</span> <span class="n">temperament</span><span class="o">=</span><span class="s1">'ornery'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">'kitty'</span><span class="p">)</span>
<span class="go">&lt;Hash "huey": {'color': 'white', 'type': 'kitty', 'temperament': 'ornery'}&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">huey</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">['color', 'type', 'temperament']</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'color'</span> <span class="ow">in</span> <span class="n">huey</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">huey</span><span class="p">[</span><span class="s1">'color'</span><span class="p">]</span>
<span class="go">'white'</span>
</pre></div>
<p>There are similar APIs for the other data-types, which you can read about in the <a href="http://walrus.readthedocs.org/en/latest/containers.html">documentation</a>.</p>
<p>Originally these containers were all I had planned on implementing, but I had such a good time working on this project that I just kept going.</p>
<h3>Models</h3>
<p><a href="http://media.charlesleifer.com/blog/photos/p1421034633.72.jpg" title="photos/p1421034633.72.jpg"><img alt="photos/p1421034633.72.jpg" class="img-responsive" src="http://m.charlesleifer.com/t/800x-/blog/photos/p1421034633.72.jpg?key=BcvF3QE2SPu09WSWMsnAqA"/></a></p>
<p>I thought it would be cool to add a lightweight structured data modelling API, something with a declarative API like Django or <a href="http://docs.peewee-orm.com/">peewee</a>. To that end, <code>walrus</code> supports declarative model classes and a number of field types for things like text, dates, integers, floats, and more.</p>
<p>Here is how I modeled a twitter-like app (which you can find in the <a href="https://github.com/coleifer/walrus/blob/master/examples/twitter/app.py">examples</a>):</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">TextField</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">TextField</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">TextField</span><span class="p">()</span>

    <span class="n">followers</span> <span class="o">=</span> <span class="n">ZSetField</span><span class="p">()</span>
    <span class="n">following</span> <span class="o">=</span> <span class="n">ZSetField</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Message</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">TextField</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">TextField</span><span class="p">(</span><span class="n">fts</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">DateTimeField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_user</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">User</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="p">)</span>
</pre></div>
<p>There are already a number of projects that do this, some of them quite well, such as <a href="http://lsbardel.github.io/python-stdnet/">Stdnet</a>. <a href="https://redisco.readthedocs.org/en/latest/">Redisco</a>, <a href="http://pythonhosted.org/rom/">Rom</a>, and <a href="https://redis-limpyd.readthedocs.org/en/latest/">limpyd</a> are also similar projects. Stdnet looks to be the most sophisticated, but it relies on a <em>ton</em> of lua scripts. Redisco, Rom, and limpyd (wtf is a limpyd?) all seem to offer only very basic column filters. The goal for walrus models was to support <strong>flexible, composable filtering</strong> using a combination of secondary indexes and set operations.</p>
<p>Walrus's model layer is built on top of the Redis hash, but all the interesting stuff happens in the indexes. Each field can have a number of secondary indexes which provide different ways to filter/query. For instance, the default index type is simply a big set of all values, and can be used to perform equality/inequality tests. For scalar values, the index is a sorted set, which can be sliced by value to perform greater-than and less-than queries. By combining filter options with set operations, walrus is able to support arbitrarily complex queries.</p>
<h4>Full-text search</h4>
<p>I'd like to take a quick detour to discuss the full-text search feature, since I think it's kind of neat. The full-text index is a basic inverted index where tokens correspond to sets of matching document IDs. The full-text search index implements the <a href="http://tartarus.org/martin/PorterStemmer/">porter stemming algorithm</a> and also supports the double-metaphone algorithm and automatic stop-word removal.</p>
<p>The cool part is that I built a very simple search query parser that executes boolean expressions against the full-text index. This makes it possible to write things like:</p>
<div class="highlight"><pre><span class="n">expr</span> <span class="o">=</span> <span class="n">Message</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">'python AND (walrus OR redis)'</span><span class="p">)</span>
<span class="n">messages</span> <span class="o">=</span> <span class="n">Message</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>
<p>This translates into the following sequence (roughly) of Redis commands being executed:</p>
<div class="highlight"><pre>"ZINTERSTORE" "temp.629a" "1" "message:content.fts.python"
"ZINTERSTORE" "temp.ebe2" "1" "message:content.fts.walru"
"ZINTERSTORE" "temp.bb37" "1" "message:content.fts.redi"
"ZUNIONSTORE" "temp.72a8" "2" "temp.ebe2" "temp.bb37"
"ZINTERSTORE" "temp.7fc3" "2" "temp.629a" "temp.72a8"
"ZREVRANGE" "temp.7fc3" "0" "-1"
</pre></div>
<p>This sequence of operations means:</p>
<ul>
<li>Store all the document IDs matching "python" in key <code>629a</code></li>
<li>Store all the document IDs matching "walrus" in key <code>ebe2</code></li>
<li>Store all the document IDs matching "redis" in key <code>bb37</code></li>
<li>Take the union of the walrus and redis sets and store it in key <code>72a8</code></li>
<li>Take the intersection of the python set and the redis/walrus set and return all the matching document IDs.</li>
</ul>
<p>All of this is handled transparently by the backend!</p>
<h3>Creating objects and performing queries</h3>
<p>The model layer is hopefully easy to work with and understand. Walrus makes use of operator overloads to create the query tree, which is then translated into a series of Redis statements and set operations.</p>
<div class="highlight"><pre><span class="n">Message</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">content</span><span class="o">=</span><span class="s1">'this is a message'</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="s1">'huey'</span><span class="p">)</span>
<span class="n">msg</span> <span class="o">=</span> <span class="n">Message</span><span class="p">(</span><span class="n">content</span><span class="o">=</span><span class="s1">'this is another message'</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="s1">'mickey'</span><span class="p">)</span>
<span class="n">msg</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

<span class="c1"># Get messages by "huey".</span>
<span class="n">messages</span> <span class="o">=</span> <span class="n">Message</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
    <span class="n">Message</span><span class="o">.</span><span class="n">username</span> <span class="o">==</span> <span class="s1">'huey'</span><span class="p">,</span>
    <span class="n">order_by</span><span class="o">=</span><span class="n">Message</span><span class="o">.</span><span class="n">timestamp</span><span class="o">.</span><span class="n">desc</span><span class="p">())</span>

<span class="c1"># Get messages by huey or mickey.</span>
<span class="n">messages</span> <span class="o">=</span> <span class="n">Message</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
    <span class="p">(</span><span class="n">Message</span><span class="o">.</span><span class="n">username</span> <span class="o">==</span> <span class="s1">'huey'</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">Message</span><span class="o">.</span><span class="n">username</span> <span class="o">==</span> <span class="s1">'mickey'</span><span class="p">),</span>
    <span class="n">order_by</span><span class="o">=</span><span class="n">Message</span><span class="o">.</span><span class="n">timestamp</span><span class="o">.</span><span class="n">desc</span><span class="p">())</span>

<span class="c1"># Find messages by huey matching a search query.</span>
<span class="n">search_expr</span> <span class="o">=</span> <span class="n">Message</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">'python AND (peewee OR huey OR walrus)'</span><span class="p">)</span>
<span class="n">messages</span> <span class="o">=</span> <span class="n">Message</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
    <span class="n">search_expr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Message</span><span class="o">.</span><span class="n">username</span> <span class="o">==</span> <span class="s1">'huey'</span><span class="p">),</span>
    <span class="n">order_by</span><span class="o">=</span><span class="n">Message</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
</pre></div>
<p>If you'd like to see more examples, check out the <a href="http://walrus.readthedocs.org/en/latest/models.html">model documentation</a>, the <a href="https://github.com/coleifer/walrus/blob/master/examples/twitter/app.py">example twitter app</a>, or the <a href="https://github.com/coleifer/walrus/blob/master/examples/diary.py">example diary app</a>.</p>
<h3>Caching</h3>
<p>The final component of <code>walrus</code> is a Caching API. The cache implements the standard <code>get</code> and <code>set</code> operators, and also provides a decorator which can be used to wrap expensive / cache-friendly functions or methods.</p>
<p>Here is how you might use the cache:</p>
<div class="highlight"><pre><span class="n">cache</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">default_timeout</span><span class="o">=</span><span class="mi">600</span><span class="p">)</span>

<span class="nd">@cache.cached</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">get_recommendations</span><span class="p">(</span><span class="n">person</span><span class="p">):</span>
    <span class="c1"># Perform some expensive calculation that can be cached.</span>
    <span class="k">return</span> <span class="n">RecommendationEngine</span><span class="p">(</span><span class="n">person</span><span class="p">)</span><span class="o">.</span><span class="n">get_recommendations</span><span class="p">()</span>
</pre></div>
<p>If you're curious about the Cache, <a href="http://walrus.readthedocs.org/en/latest/cache.html">check out the documentation</a>.</p>
<h3>Reading more</h3>
<p><a href="http://media.charlesleifer.com/blog/photos/walrus-lurker.jpg" title="photos/walrus-lurker.jpg"><img alt="photos/walrus-lurker.jpg" class="img-responsive" src="http://m.charlesleifer.com/t/800x-/blog/photos/walrus-lurker.jpg?key=Kp4sCuh0gfhArbKLpqWLNw"/></a></p>
<p>The <a href="http://walrus.readthedocs.org/en/latest/index.html">documentation</a> can be found online, and the <a href="https://github.com/coleifer/walrus">source code</a> is availabe on GitHub.</p>
<p>Walrus is still very new, so if you find bugs or have feature requests, feel free to <a href="https://github.com/coleifer/walrus/issues/new">create an issue on GitHub</a>.</p>
<p>Thanks for taking the time to read this post, I hope you enjoyed it!</p>

<h3>Impostor walrus</h3>
<p><a href="http://media.charlesleifer.com/blog/photos/p1421038498.96.jpg" title="photos/p1421038498.96.jpg"><img alt="photos/p1421038498.96.jpg" class="img-responsive" src="http://m.charlesleifer.com/t/800x-/blog/photos/p1421038498.96.jpg?key=74sjHH9HC_AM7qn1PfeYQw"/></a></p>
<p>Accept no substitutes!</p>
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  


<hr/>

  <p>Commenting has been closed, but please feel free to <a href="/contact/">contact me</a></p>


    </div>

    </div></body></html>