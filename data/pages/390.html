<html><body><div><div class="content html_format"><p>
      Питон изумителен.</p>
<p>
Удивительно, но это довольно неоднозначное заявление. Что я имею ввиду под “Питоном”? Может, абстрактный интерфейс Питона? Или CPython, распространенная реализация Питона (не путать с похожим по названию Cython)? Или я имею ввиду что-то совсем иное? Может, я косвенно ссылаюсь на Jython, или IronPython, или PyPy. Или может я отвлекся так сильно, что говорю о RPython или RubyPython (которые очень сильно отличаются).
</p><p>
Не смотря на схожесть в названиях указанных выше технологий, некоторые из них имеют совсем другие задачи (или, как минимум, работают совершенно иными способами)
</p><p>
При работе с Питоном я столкнулся с кучей таких технологий. Инструменты *ython. Но лишь недавно я уделил время, чтобы разобраться, что они собой представляют, как они работают и почему они (каждая по-своему) необходимы.
</p><p>
В этом посте я начну с нуля и пройдусь по разным реализациям Питона, а закончу подробным введением в PyPy, за которым, по моему мнению, будущее языка.
</p><p>
Все начинается с понимания того, чем на самом деле является “Питон”.</p><a name="habracut"/>
<p>
Если у вас хорошее понимание машинного кода, виртуальных машин и так далее, можете пропустить этот раздел.

</p><h4>Питон интерпретируемый или компилируемый?</h4>
<p>
Это распространенный источник непонимания среди новичков Питона.
</p><p>
Первое, что необходимо понять: “Питон” – это интерфейс. Существует </p><a href="http://docs.python.org/2/reference/index.html">спецификация</a><p>, описывающая, что должен делать Питон, и как он должен себя вести (что справедливо для любого интерфейса). И существует несколько имплементаций (что также справедливо для любого интерфейса).
</p><p>
Второе: “интерпретируемый” и “компилируемый” это свойства имплементации, но не интерфейса.
</p><p>
Так что сам вопрос не совсем корректен.
</p><p>
В случае с самой распространенной реализацией (CPython: написанный на C, часто называемый просто “Python”, и, конечно, именно тот, который вы используете, если понятия не имеете о чем я толкую) ответ: интерпретируемый, с некоторой компиляцией. CPython компилирует* исходный код на Питоне в байткод, а затем интерпретирует этот байткод, запуская его в процессе.

</p><i>* Замечание: это не совсем “компиляция” в традиционном смысле. Обычно, мы считаем, что “компиляция” это конвертация из высокоуровневого языка в машинный код. Тем не менее – в некотором роде это “компиляция”.</i>
<p>
Давайте изучим этот ответ получше, так как он поможет нам понять некоторые концепции, ожидающие нас в этой статье.

</p><h4>Байткод или машинный код</h4>
<p>
Очень важно понять разницу между байткодом и машинным (или нативным) кодом. Пожалуй, легче всего ее понять на примере:
</p><p>
 — Cи компилируется в машинный код, который впоследствии запускается напрямую процессором. Каждая инструкция заставляет процессор производить разные действия.</p><p>
 — Java компилируется в байткод, который впоследствии запускается на Виртуальной машине Java (Java Virtual Machine, JVM), абстрактном компьютере, который запускает программы. Каждая инструкция обрабатывается JVM, который взаимодействует с компьютером.
</p><p>
Сильно упрощая:</p><b> машинный код намного быстрее, но байткод лучше переносим и защищен.</b>
<p>
Машинный код может отличаться в зависимости от машины, тогда как байткод одинаковый на всех машинах. Можно сказать, что машинный код оптимизирован под вашу конфигурацию.
</p><p>
Возвращаясь к CPython, цепочка операций выглядит следующим образом:
</p><p>
1. CPython компилирует ваш исходный код на Питоне в байткод.</p><p>
2. Этот байткод запускается на виртуальной машине CPython.

</p><blockquote>Новички зачастую допускают, что Питон компилируемый из-за наличия .pyc-файлов. Это отчасти верно: .pyc-файлы – это скомпилированный байткод, который впоследствии интерпретируется. Так что если вы запускали ваш код на Питоне, и у вас есть .pyc-файл, то во второй раз он будет работать быстрее, потому что ему не нужно будет заново компилироваться в байткод.</blockquote>

<h4>Альтернативные виртуальные машины: Jython, IronPython и другие</h4>
<p>
Как я говорил выше, у Питона существует несколько реализаций. Опять же, как говори-лось выше, самой популярной является CPython. Эта версия Питона написана на C и считается имплементацией “по умолчанию”.
</p><p>
Но как насчет альтернатив? Одна из наиболее видных это </p><a href="http://www.jython.org/archive/21/docs/whatis.html">Jython</a><p>, реализация Питона на Java, которая использует JVM. В то время как CPython генерирует байткод для запуска на CPython VM, Jython генерирует байткод Java для запуска на JVM (это то же самое, что генерируется при компиляции программы на Java).

</p><img src="https://habrastorage.org/getpro/habr/post_images/a8d/3ff/ab7/a8d3ffab74108d33d3feed2e2c196d11.png"/>
<p>
“Зачем может понадобиться использовать альтернативную реализацию?”, спросите вы. Ну, для начала, </p><b>разные реализации хорошо ладят с разными наборами технологий</b><p>.
</p><p>
CPython упрощает написание C-расширений для кода на Питоне потому что в конце он запускается интерпретатором Cи. Jython в свою очередь упрощает работу с другими программами на Java: вы можете импортировать любые Java-классы без дополнительных усилий, призывая и используя ваши Java-классы из программ на Jython. (Замечание: если вы еще не думали об этом всерьез, это довольно безумно. Мы дожили до того времени, когда можно смешивать разные языки и компилировать их в одну сущность. Как заметил </p><a href="http://www.reddit.com/user/Rostin">Rostin</a><p>, программы, смешивающие код на Фортране с Cи появились довольно давно, так что это не совсем новинка. Но это все же круто.)
</p><p>
В качестве примера, вот корректный код на Jython:

</p><code>[Java HotSpot(TM) 64-Bit Server VM (Apple Inc.)] on java1.6.0_51<br/>
&gt;&gt;&gt; from java.util import HashSet<br/>
&gt;&gt;&gt; s = HashSet(5)<br/>
&gt;&gt;&gt; s.add("Foo")<br/>
&gt;&gt;&gt; s.add("Bar")<br/>
&gt;&gt;&gt; s<br/>
[Foo, Bar]</code>

<a href="http://ironpython.net/">IronPython</a><p> это другая популярная реализация Питона, написанная полностью на C# и предназначенная для .NET. В частности, она запускается на виртуальной машине .NET, если ее можно так назвать, на </p><a href="http://en.wikipedia.org/wiki/Common_Language_Runtime">Common Language Runtime (CLR)</a><p>, от Майкрософт, сравнимым с JVM.
</p><p>
Можно сказать, что Jython: Java :: IronPython: C#. Они работают на соответствующих виртуальных машинах, есть возможность импортировать классы C# в код IronPython и классы Java в код Jython, и так далее.
</p><p>
Вполне реально выжить, не прикасаясь к ни к чему, кроме CPython. Но, переходя на другие имплементации, вы получаете преимущество, в основном из-за используемого стека технологий. Используете много языков, основанных на JVM? Jython может вам подойти. Все на .NET? Возможно, стоит попробовать IronPython (и, возможно, вы уже сделали).

</p><img src="https://habrastorage.org/getpro/habr/post_images/29e/2ab/f88/29e2abf8809b486658fb09922c2fe9f5.png"/>
<p>
Кстати, хоть это и не станет причиной для перехода на другую имплементацию, стоит упомянуть, что имплементации эти на самом деле отличаются поведением. Это касается не только способов интерпретации кода на Питоне. Однако эти отличия, как правило, не-значительны, они исчезают и появляются со временем из-за активной разработки. К примеру, IronPython использует </p><a href="http://ironpython.codeplex.com/wikipage?title=IPy1.0.xCPyDifferences&amp;referringTitle=Home">строки Unicode по умолчанию</a><p>; однако CPython </p><a href="http://docs.python.org/2/howto/unicode.html#encodings">использует ASCII</a><p> в версиях 2.x (выдавая ошибку UnicodeEncodeError для не-ASCII символов), и при этом </p><a href="http://docs.python.org/3/howto/unicode.html#python-s-unicode-support">поддерживает символы Unicode по умолчанию в версиях 3.x</a><p>.

</p><h4>Компиляция на лету (Just-in-Time Compilation): PyPy и будущее</h4>
<p>
Итак, у нас есть имплементация Питона, написанная на Си, еще одна – на Java, и третья на C#. Следующий логичный шаг: имплементация Питона, написанная на… Питоне. (Подготовленный читатель заметит, что это утверждение немного обманчиво).
</p><p>
Вот почему это может сбивать с толку. Для начала, давайте обсудим компиляцию на лету (just-in-time или JIT).

</p><h5>JIT. Почему и как</h5>
<p>
Напомню, что нативный машинный код намного быстрее байткода. Ну, а что, если бы можно было компилировать часть байткода и запускать его как нативный код? Пришлось бы “заплатить” некоторую цену (иными словами: время) за компиляцию байткода, но если результат будет работать быстрее, то это здорово! Этим и мотивируется JIT-компиляция, гибридная техника, которая совмещает в себе преимущества интерпретато-ров и компиляторов. В двух словах – JIT старается использовать компиляцию, чтобы ускорить систему интерпретации.
</p><p>
Например, вот распространенный подход JIT:

</p><ol>
<li>Определить байткод, который запускается часто.</li>
<li>Скомпилировать его в нативный машинный код.</li>
<li>Закэшировать результат.</li>
<li>Всегда когда необходимо запустить тот же самый байткод, использовать уже скомпилированный машинный код и пожинать плоды (в частности, прирост скорости).</li>
</ol>
<p>
В этом вся суть PyPy: использовать JIT в Питоне (в дополнении можно найти предыдущие попытки). Конечно, есть и другие цели: PyPy нацелен на кроссплатформенность, работу с небольшим количеством памяти и поддержку stackless (отказа от стека вызовов языка Си в пользу собственного стека). Но JIT это главное преимущество. В среднем на основе временных тестов, фактор ускорения составляет </p><a href="http://speed.pypy.org/">6.27</a><p>. Более подробные данные можно получить из схемы от </p><a href="http://speed.pypy.org/">PyPy Speed Center</a><p>:

</p><img src="https://habrastorage.org/getpro/habr/post_images/e09/b86/80b/e09b8680b17b1fb72f6b8e75e49a154f.png"/>

<h5>В PyPy сложно разобраться</h5>
<p>
У PyPy есть огромный потенциал, и в данный момент он </p><a href="http://doc.pypy.org/en/latest/faq.html#is-pypy-a-drop-in-replacement-for-cpython">хорошо совместим</a><p> с CPython (так что на нем </p><a href="http://pypy.org/compat.html">можно запускать Flask, Django</a><p>, и т.д.).
</p><p>
Но с PyPy есть много путаницы. (оцените, к примеру, это бессмысленное предложение создать PyPyPy…). По моему мнению основная причина в том, что PyPy одновременно является:
</p><p>
1. Интерпретатором Питона, написанным на </p><a href="http://doc.pypy.org/en/latest/coding-guide.html#id1">RPython</a><p> (не Python (я обманул вас до этого)). RPython это подмножество Python со статичной типизацией. В Python, вести тщательные беседы о типах “</p><a href="http://doc.pypy.org/en/latest/faq.html#can-rpython-compile-normal-python-programs-to-c">в целом невозможно</a><p>” почему это так сложно? рассмотрите следующее:

</p><code> x = random.choice([1, "foo"])</code>
<p>
это корректный код на Python (спасибо </p><a href="http://www.reddit.com/user/Ademan">Ademan</a><p>‘у). Какой тип у x? Как мы можем обсуждать типы переменных, когда типы даже не форсируются?). В RPython мы жертвуем некоторой гибкостью, но взамен получаем возможность гораздо проще управлять памятью и много чего еще, что помогает при оптимизации.
</p><p>
2. Компилятором, который компилирует код на RPython в разные форматы и поддерживает JIT. Платформой по-умолчанию является Си, то есть компилятор RPython-в-Си, но в качестве целевой платформы также можно выбрать JVM и другие.
</p><p>
Для простоты описания, я буду называть их PyPy (1) и PyPy (2).
</p><p>
Зачем могут понадобиться эти две вещи, и почему – в одном наборе? Думайте об этом так: PyPy (1) это интерпретатор, написанный на RPython. То есть он берет пользовательский код на Питоне и компилирует его в байткод. Но чтобы сам интерпретатор (написанный на RPython) мог работать, он должен быть интерпретирован другой реализацией Пи-тона, верно?
</p><p>
Итак, можно просто использовать </p><a href="http://www.stavros.io/posts/what-is-pypy/">CPython</a><p> чтобы запускать интерпретатор. Но это будет не слишком быстро.
</p><p>
Вместо этого мы используем PyPy (2) (называемый </p><a href="http://doc.pypy.org/en/latest/translation.html">RPython Toolchain</a><p>) чтобы компилировать интерпретатор PyPy в код для другой платформы (например, C, JVM, или CLI) для запуска на конечной машине, с добавлением JIT. Это волшебно: PyPy динамически добавляет JIT к интерпретатору, генерируя собственный компилятор! (Опять же, это безумие: мы компилируем интерпретатор, добавляя другой отдельный, самостоятельный компилятор).
</p><p>
В конце концов результатом будет самостоятельный исполняемый файл, который интерпретирует исходный код на Питоне и использует оптимизацию JIT. То, что нужно! Понять сложновато, но, возможно, эта схема поможет:

</p><img src="https://habrastorage.org/getpro/habr/post_images/a60/643/547/a60643547ead4246eedc7874173b15e0.png"/>
<p>
Повторим: настоящая красота PyPy в том, что мы можем написать себе кучу разных интерпретаторов Питона на RPython не волнуясь о JIT (не считая </p><a href="http://doc.pypy.org/en/latest/jit/pyjitpl5.html#jit-hints">пары деталей</a><p>). После этого PyPy реализует для нас JIT, используя RPython Toolchain/PyPy (2).
</p><p>
На самом деле, если копнуть глубже в абстракцию, теоретически можно написать интерпретатор любого языка, направить его в PyPy и получить JIT для этого языка. Это возможно потому, что PyPy концентрируется на оптимизации самого интерпретатора, а не деталей языка, который тот интерпретирует.
</p><p>
В качестве отступления я бы хотел заметить, что сам JIT совершенно восхитителен. Он использует технику под названием “отслеживание” (tracing), которая работает </p><a href="http://morepypy.blogspot.com/2009/03/applying-tracing-jit-to-interpreter.html">следующим образом</a><p>:

</p><ol>
<li>Запустить интерпретатор и интерпретировать все (не добавляя JIT).</li>
<li>Провести легкое профилирование интерпретированного кода. </li>
<li>Определить операции, которые уже выполнялись ранее. </li>
<li>Скомпилировать эти части кода в машинный код. </li>
</ol>
<p>
Узнать больше можно из этой легкодоступной и очень интересной </p><a href="https://bitbucket.org/pypy/extradoc/src/tip/talk/icooolps2009/bolz-tracing-jit-final.pdf">публикации</a><p>.
</p><p>
Подытожим: мы используем PyPy-компилятор RPython-в-Си (или другую целевую плат-форму), чтобы скомпилировать реализованный на RPython интерпретататор PyPу.

</p><h4>Заключение</h4>
<p>
Почему все это так восхитительно? Почему стоит гнаться за этой безумной идеей? По-моему, </p><a href="http://pypy.org/people.html#alex-gaynor">Алекс Гейнор</a><p> объяснил это очень хорошо в своем </p><a href="http://alexgaynor.net/2010/may/15/pypy-future-python/">блоге</a><p>: “[За PyPy будущее] потому что [он] более быстрый, более гибкий и является лучшей платформой для развития Питона”.
</p><p>
Вкратце:

</p><ul>
<li>Он быстрый – потому что компилирует исходный код в нативный код (используя JIT).</li>
<li>Он гибкий – потому что добавляет JIT в интерпретатор без особых усилий. </li>
<li>Он гибкий (опять) – потому что вы можете писать интерпретаторы в RPython, что впоследствии упрощает расширение по сравнению с тем же Си (на самом деле упрощает настолько, что даже есть инструкция по написанию собственных интерпретаторов). </li>
</ul>

<h4>Дополнение: другие названия, которые вы, возможно, слышали</h4>

<a href="http://www.python.org/dev/peps/pep-3000/">Python 3000 (Py3k)</a><p>: альтернативное название Python 3.0, основной релиз Питона с </p><a href="http://www.python.org/dev/peps/pep-3000/#compatibility-and-transition">обратной совместимостью</a><p>, который появился в </p><a href="http://python.org/download/releases/3.0/">2008</a><p>. году. Команда Py3k предсказала, что новой версии понадобится примерно </p><a href="http://programmers.stackexchange.com/questions/63859/why-do-people-hesitate-to-use-python-3#answer-63935">пять лет</a><p> чтобы полностью прижиться. И в то время, как большинство (внимание: надуманное утверждение) разработчиков на Питоне продолжают использовать Python 2.x, люди все больше задумываются о Py3k.

</p><a href="http://cython.org/">Cython</a><p>: надмножество Python, включающее возможность вызывать функции Си.
</p><ul>
<li>Задача: позволить писать расширения Си для программ на Питоне. </li>
<li>Также позволяет добавлять <a href="http://docs.cython.org/src/quickstart/cythonize.html">статическую типизацию</a> в существующий код на Питоне, что после повторной компиляции может помочь достичь похожей на Си производительности. </li>
<li>Напоминает PyPy, но это не то же самое. В случае с Cython вы форсируете типизацию в пользовательском коде перед подачей компилятору. В PyPy вы пишете старый добрый Python, а компилятор отвечает за любую оптимизацию. </li>
</ul>

<a href="http://numba.pydata.org/">Numba</a><p>: “специализированный just-in-time компилятор”, который добавляет JIT в снабженный примечаниями код на Питоне. Проще говоря, вы даете ему подсказки, а он ускоряет некоторые части вашего кода. Numba является частью дистрибутива </p><a href="http://docs.continuum.io/anaconda/index.html">Anaconda</a><p> набора пакетов для анализа и управления данными.

</p><a href="http://ipython.org/index.html">IPython</a><p>: сильно отличается от всего, что мы обсудили. Вычислительная среда для Питона. Интерактивная, с поддержкой GUI-пакетов, браузеров и так далее.

</p><a href="http://psyco.sourceforge.net">Psyco</a><p>: </p><a href="http://rayli.net/blog/2010/04/what-is-the-purpose-of-pypy/">модуль расширения Питона</a><p>, одна из первых попыток Питона в области JIT. Давно помечен как </p><a href="http://psyco.sourceforge.net">“неподдерживаемый и мертвый”</a><p>. Главный разработчик Psyco </p><a href="http://pypy.org/people.html#armin-rigo">Армин Риго сейчас работает над PyPy</a><p>. 

</p><h5>Привязки к языкам</h5>

<ul>
<li> <a href="http://rubypython.rubyforge.org">RubyPython</a>: мост между виртуальными машинами Ruby и Python. Позволяет встраивать код на Питоне в код на Ruby. Вы обозначаете, где начинается и заканчивается Питон, а RubyPython обеспечивает передачу данных между виртуальными машинами.<br/>
 </li>
<li> <a href="http://pythonhosted.org/pyobjc/#release-information">PyObjc</a>: языковое соединение между Python и Objective-C, которые ведет себя как мост между ними. На практике это означает, что вы можете использовать библиотеки Objective-C (включая все, что нужно для создания приложения под OS X) в коде на Питоне, и модули Питона в коде на Objective-C. Это удобно, потому что CPython написан на Си, который является подмножеством Objective-C.<br/>
 </li>
<li> <a href="http://www.riverbankcomputing.com/software/pyqt/intro">PyQt</a>: в то время как PyObjc позволяет связать Питон с компонентами OS X GUI, PyQt делает то же для фреймворка Qt. Это дает возможность создавать полноценные графические интерфейсы, обращаться к SQL базам данных и так далее. Еще один инструмент, нацеленный на перенос простоты Питона в другие фреймворки.<br/>
 </li>
</ul>

<h5>JavaScript фреймворки</h5>

<ul>
<li> <a href="http://pyjs.org">pyjs (Pyjamas)</a>: фреймворк для создания веб и десктопных приложений на Питоне. Включает в себя компилятор Python-в-JavaScript, набор виджетов и некоторые другие инструменты.<br/>
 </li>
<li> <a href="http://www.brython.info">Brython</a>: виртуальная машина Python, написанная на Javascript. Позволяет запустить код на Py3k в веб-браузере.<br/>
 </li>
</ul>
      <p class="clear"/>
    </div>

    
  </div></body></html>