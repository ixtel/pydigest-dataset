<html><body><div><div class="entry-content"><p>Работа с базой данных — зачастую самое слабое место в производительности многих web-приложений. И часто можно заметить, как на одни и те же грабли наступают разработчики при проектировании базы данных. Данная подборка советов поможет вам избежать многих ошибок и узнать для себя много полезного. <span id="more-7594"/></p><h3>Общее</h3><ul><li>Под каждую отдельную базу данных желательно создавать отдельного пользователя.</li><li>Кодировка базы может быть любой, если она UTF-8.</li><li>В большинстве случаев лучше использовать движок InnoDB.</li><li>В PHP лучше забыть про сильно устаревшее расширение MySQL и по возможности использовать PDO или MySQLi.</li><li>Без особой нужды не стоит открывать MySQL наружу. Лучше сделать проброс портов:<br/><div id="crayon-56d5b324229a0051617315" class="crayon-syntax crayon-theme-classic crayon-font-courier-new crayon-os-mac print-yes notranslate" data-settings=" minimize scroll-mouseover"><p class="crayon-plain-wrap"/><div class="crayon-main"><table class="crayon-table"><tr class="crayon-row"><td class="crayon-nums " data-settings="show"/><td class="crayon-code"><div class="crayon-pre"><p class="crayon-line" id="crayon-56d5b324229a0051617315-1">ssh<span class="crayon-h"> </span>-fNL<span class="crayon-h"> </span>LOCAL_PORT:localhost:3306<span class="crayon-h"> </span>REMOTE_USER@REMOTE_HOST</p></div></td></tr></table></div></div></li><li>Используйте подсказки от PROCEDURE ANALYSE(), который анализирует структуру вашей таблицы и дает советы по оптимизации. Следует заметить, что это возможно только при наличии реальных данных в таблице, так как анализ происходит на их основе.</li><li>Лучше перейти на <a href="https://mariadb.org/" target="_blank">MariaDB</a> и забыть про MySQL.</li></ul><h3>Поиск и запросы</h3><ul><li>Если при обращении к таблице вам нужна одна-единственная строка, то используйте LIMIT 1. Использование LIMIT 1 будет оптимальнее, так как база данных остановит выборку записей сразу же после нахождения строки вместо того, чтобы выбирать всю таблицу или индекс.<br/><div id="crayon-56d5b324229b0392468707" class="crayon-syntax crayon-theme-classic crayon-font-courier-new crayon-os-mac print-yes notranslate" data-settings=" minimize scroll-mouseover"><p class="crayon-plain-wrap"/><div class="crayon-main"><table class="crayon-table"><tr class="crayon-row"><td class="crayon-nums " data-settings="show"/><td class="crayon-code"><div class="crayon-pre"><p class="crayon-line" id="crayon-56d5b324229b0392468707-1">$r<span class="crayon-h"> </span>=<span class="crayon-h"> </span>mysql_query(<span class="crayon-s">"SELECT * FROM user WHERE state = 'Alabama' LIMIT 1"</span>);</p><p class="crayon-line crayon-striped-line" id="crayon-56d5b324229b0392468707-2"><span class="crayon-st">if</span><span class="crayon-h"> </span>(mysql_num_rows($r)<span class="crayon-h"> </span><span class="crayon-h">&gt;</span><span class="crayon-h"> </span>0)<span class="crayon-h"> </span>{<span class="crayon-h"> </span>...<span class="crayon-h"> </span>}</p></div></td></tr></table></div></div></li><li>Помимо обычного индекса строк, вы можете проиндексировать любые столбцы в таблице. Это даст прирост производительности при поиске.</li><li>Не используйте ORDER BY RAND(). Если вам действительно нужен случайный порядок строк в запросе, то есть много различных способов сделать это иначе. Вам нужно будет написать дополнительный код, однако вы избавитесь от слабого места в производительности. ORDER BY RAND() экспоненциально замедляется при росте базы данных.</li><li>Избегайте использования SELECT *. Чем больше данных считывается из таблицы, тем медленнее запрос, что, в свою очередь, увеличивает время работы с хранилищем данных. Также, если сервер БД установлен отдельно от web-сервера, то будет большая задержка при передаче данных по сети. Лучше делать следующим образом:<br/><div id="crayon-56d5b324229b7218524621" class="crayon-syntax crayon-theme-classic crayon-font-courier-new crayon-os-mac print-yes notranslate" data-settings=" minimize scroll-mouseover"><p class="crayon-plain-wrap"/><div class="crayon-main"><table class="crayon-table"><tr class="crayon-row"><td class="crayon-nums " data-settings="show"/><td class="crayon-code"><div class="crayon-pre"><p class="crayon-line" id="crayon-56d5b324229b7218524621-1">$r<span class="crayon-h"> </span>=<span class="crayon-h"> </span>mysql_query(«<span class="crayon-st">SELECT</span><span class="crayon-h"> </span>username<span class="crayon-h"> </span><span class="crayon-st">FROM</span><span class="crayon-h"> </span><span class="crayon-st">user</span><span class="crayon-h"> </span><span class="crayon-st">WHERE</span><span class="crayon-h"> </span>user_id<span class="crayon-h"> </span>=<span class="crayon-h"> </span>1»);</p><p class="crayon-line crayon-striped-line" id="crayon-56d5b324229b7218524621-2">$d<span class="crayon-h"> </span>=<span class="crayon-h"> </span>mysql_fetch_assoc($r);</p><p class="crayon-line" id="crayon-56d5b324229b7218524621-3">echo<span class="crayon-h"> </span>«Welcome<span class="crayon-h"> </span>{$d[<span class="crayon-s">'username'</span>]}»;</p></div></td></tr></table></div></div></li></ul><h3>Работа с данными</h3><ul><li>Если система 32-битная, то нет смысла ставить свойство UNSIGNED для типа INTEGER, так как такие большие числа в PHP не поддерживаются. Но если вы используете 64-битную систему, то в этом случае PHP поддерживает большие числа, вплоть до BIGINT со знаком.</li><li>Связанные таблицы «Foreign keys» должны иметь сходство по структуре ключей.</li><li>Для хранения булевых значений лучше всего использовать TINYINT(1).</li><li>Денежные единицы лучше всего хранить в целых числах и работать только с целыми числами. Например, числом копеек, чтобы 100 означало один рубль.</li></ul><h3>Работа со строками</h3><ul><li>Лучшая кодировка для большинства баз данных — <u>UTF-8.</u></li><li>Тип TEXT вмещает в себя только 64 Кб. Для того, чтобы вместить более объемные тексты, нужно использовать LONGTEXT.</li><li>В версиях MySQL до 5.0.3 VARCHAR была ограничена 255 символами, однако в более старших версиях ограничением является 65535 символов.</li></ul><h3>Работа с датами</h3><ul><li>При сравнении DATETIME и TIMESTAMP не забывайте делать преобразование типов:<br/><div id="crayon-56d5b324229be159941882" class="crayon-syntax crayon-theme-classic crayon-font-courier-new crayon-os-mac print-yes notranslate" data-settings=" minimize scroll-mouseover"><p class="crayon-plain-wrap"/><div class="crayon-main"><table class="crayon-table"><tr class="crayon-row"><td class="crayon-nums " data-settings="show"/><td class="crayon-code"><div class="crayon-pre"><p class="crayon-line" id="crayon-56d5b324229be159941882-1"><span class="crayon-st">SELECT</span><span class="crayon-h"> </span>*<span class="crayon-h"> </span><span class="crayon-st">FROM</span><span class="crayon-h"> </span><span class="crayon-st">table</span><span class="crayon-h"> </span><span class="crayon-st">WHERE</span><span class="crayon-h"> </span>`<span class="crayon-t">datetime</span>`<span class="crayon-h"> </span>=<span class="crayon-h"> </span><span class="crayon-t">DATE</span>(`<span class="crayon-t">timestamp</span>`)</p></div></td></tr></table></div></div></li><li>Так как TIMESTAMP хранится в виде UNIX_TIMESTAMP, есть возможность выставить автоматическое обновление колонки.</li><li>Типы данных DATE, TIME, DATETIME выводятся в виде строк, поэтому поиск и сравнение различных дат происходит через преобразование.</li></ul><h3>Работа с перечислениями</h3><ul><li>Для перечислений правильно использовать тип ENUM. Это очень быстрый и компактный тип поля, в котором значения хранятся как в TINYINT, но отображаются как в строковом поле.</li><li>Как и для любой строки, для перечислений можно ставить значение по умолчанию.</li><li>Поле с перечислением хранится как число, поэтому скорость работы довольно высокая.</li></ul><h3>Работа с бэкапами</h3><p>Лучше использовать бэкап с дополнительными опциями -Q, -c, -e:</p><div id="crayon-56d5b324229c4045574630" class="crayon-syntax crayon-theme-classic crayon-font-courier-new crayon-os-mac print-yes notranslate" data-settings=" minimize scroll-mouseover"><p class="crayon-plain-wrap"/><div class="crayon-main"><table class="crayon-table"><tr class="crayon-row"><td class="crayon-nums " data-settings="show"/><td class="crayon-code"><div class="crayon-pre"><p class="crayon-line" id="crayon-56d5b324229c4045574630-1">mysqldump<span class="crayon-h"> </span>-Q<span class="crayon-h"> </span>-c<span class="crayon-h"> </span>-e<span class="crayon-h"> </span>-u<span class="crayon-h"> </span><span class="crayon-st">USER</span><span class="crayon-h"> </span>-pPASSWORD<span class="crayon-h"> </span><span class="crayon-st">DATABASE</span><span class="crayon-h"> </span><span class="crayon-h">&gt;</span><span class="crayon-h"> </span>/path<span class="crayon-o">/</span><span class="crayon-st">to</span><span class="crayon-o">/</span><span class="crayon-t">file</span><span class="crayon-o">/</span>dump.<span class="crayon-r">sql</span></p></div></td></tr></table></div></div><p/><ul><li><strong>-Q</strong> оборачивает имена обратными кавычками.</li><li><b>-c</b> делает полную вставку, включая имена колонок.</li><li><b>-e</b> делает расширенную вставку.</li></ul><p>В результате итоговый файл получается меньше, и создается он чуть быстрее.</p><h3>Отладка</h3><ul><li>Если запросы работают медленно, то можно попробовать включить лог для медленных запросов в /etc/mysql/my.cnf, а потом оптимизировать запросы через EXPLAIN.</li><li>Чтобы наблюдать как за запросами, так и в целом за работой сервера, удобно использовать программу Mytop.</li></ul><p><sub>Источники: <a href="http://habrahabr.ru/post/105954/" target="_blank">«<span class="post_title">MySQL шпаргалки</span>»</a> и <a href="http://blog.kron0s.com/top-20-mysql-best-practices" target="_blank" class="broken_link">«20 хороших советов по MySQL»</a></sub></p><p class="mistape_caption"/><footer class="entry-meta clearfix"><p class="vk_like" id="vk_like_bottom_7594"/></footer></div></div></body></html>