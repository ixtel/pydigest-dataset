<html><body><div><article class="post">
  <h1 class="post-title">A Python toolbox</h1>
  
  <p>I started learning Python four years ago and have been heavily programming with
it for near than a year now. In this post I’ll share some tools I use to ease
and speed-up my workflow, either in the Python code or in the development
environment.</p>

<p>These tips should be OS- and editor-independent. I have some useful Vim plugins
to work with Python, but that’ll be for another post. You might have to adapt
commands if you work on Windows.</p>

<h2>Setting Things Up</h2>

<p>Let’s say you’re starting a Python library. You have a couple dependencies, and
hopefully you’d like it to work on multiple versions, like 2.6, 2.7, and 3.x.
How can you test that? You have to (a) manage your dependencies to not mess up
with your user environment, and (b) test with multiple Python versions.</p>

<p>Introducing <a href="http://virtualenv.readthedocs.org/en/latest/virtualenv.html">virtualenv</a>.</p>

<p>Virtualenv lets you create <em>isolated</em> Python environments. That means you get a
pristine environment where you’ll install your library’s dependencies, and
nothing else. It’ll be independent of your user space. It’s important to work
with an isolated environment because you don’t know which environment will your
users have, so you shouldn’t make any assumption besides your own requirements.
Working with your user environment means you might forgot a dependency because
it just works since it’s installed on your computer but it’ll broke if run on
another computer without this dependency.</p>

<p>You should be able to install it with <code>pip</code>:</p>

<pre><code>$ pip install virtualenv
</code></pre>

<p>It needs a directory to store the environment. I usually use <code>venv</code>, but you
can choose whatever you want:</p>

<pre><code>$ virtualenv venv
</code></pre>

<p>You can then either “activate” the environment, which adds its <code>bin</code> directory
in your <code>PATH</code>:</p>

<pre><code>$ source venv/bin/activate
$ python  # that's your virtualenv's Python
$ deactivate
$ python  # that's your Python
</code></pre>

<p>or prefix your commands with <code>venv/bin/</code> (replace <code>venv</code> with your directory’s
name):</p>

<pre><code>$ venv/bin/python  # that's your virtualenv's Python
$ python  # that's your Python
</code></pre>

<p>I usually do the later. Install dependencies in the environment:</p>

<pre><code>$ venv/bin/pip install your-dependency
</code></pre>

<p>Don’t forget to tell Git or any tool you’re using for versioning to ignore
this <code>venv</code> directory. It can take some place (from 12MB to more than 40MB)
depending on the number of dependencies you’re relying on.</p>

<p>To remove an environment, just delete its directory:</p>

<pre><code>$ rm -rf venv
</code></pre>

<p>It can be convenient to save place on your computer if you have dozen of
environments for different projects, especially if can quickly re-create any
environment with its dependencies.</p>

<p>If you’re using <code>pip</code> to manage them, you should know you can install
dependencies not only from the command line, but also from a file, with one
dependency per line. Each one of them is processed as if it were given on the
command-line.</p>

<p>For example, you could have <a href="https://github.com/bfontaine/term2048/blob/master/requirements.txt">a file</a> containing this:</p>

<pre><code>colorama==0.2.7
coverage==3.7.1
pep8==1.4.6
py==1.4.20
tox==1.7.0
argparse&gt;=1.1
virtualenv==1.11.4
</code></pre>

<p>This file is usually called <code>requirements.txt</code>, but here again you can call it
whatever you want. You call install all these at once with this command:</p>

<pre><code>$ pip install -r requirements.txt
</code></pre>

<p>But we’re programmers and we’re lazy, we don’t want to track down each
installed library to include it in this file.</p>

<p>Here comes <code>pip freeze</code>.</p>

<p><code>pip freeze</code> outputs all installed libraries with their version. It can be put
in our <code>requirements.txt</code> for later use:</p>

<pre><code>$ pip freeze &gt; requirements.txt
</code></pre>

<p>This <code>requirements.txt</code> file becomes handy when used with <code>virtualenv</code> because
you’re now able to fire up a new environment and install all required
libraries, with two commands:</p>

<pre><code>$ virtualenv venv
$ venv/bin/pip install -r requirements.txt
</code></pre>

<p>Note that these are libraries used in the environment, not necessarily your
library’s dependencies. In the above example you can see we’re installing
<code>coverage</code> and <code>pep8</code>, which respectively are a code coverage test tool and a
lint one we’ll talk about later in this post, not libraries we’re depending on
here.</p>

<p>You should thus add this file in your public repository, because it provides
anyone with the informations they need to have in order to mirror your
environment and be able to contribute to your project.</p>

<h2>Coding</h2>

<p>Now that your local environment is ready, you can start coding your library.
You’ll often have to fire an interpreter to test some things, use <code>help()</code> to
check a function’s arguments, etc. Having to type the same things over and over
takes time, and remember: we’re lazy.</p>

<p>Like Bash and some other tools, the Python interpreter can be configured with
an user file, namely <code>$PYTHONSTARTUP</code>. It allows you to add autocompletion,
import common modules, and execute pretty much any code you want.</p>

<p>Start by setting <code>PYTHONSTARTUP</code> in your <code>~/.bashrc</code> (if you’re using Bash):</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><pre><code class="bash"><span class="nb">export </span><span class="nv">PYTHONSTARTUP</span><span class="o">=</span><span class="s2">"$HOME/.pythonrc.py"</span>
</code></pre></div></figure>


<p>Here we’re telling the interpreter to look for the <code>$HOME/.pythonrc.py</code> file
and executing it before giving us a prompt.</p>

<p>Let’s initialize this file with autocompletion support:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><pre><code class="python"><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">readline</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">rlcompleter</span>
    <span class="n">readline</span><span class="o">.</span><span class="n">parse_and_bind</span><span class="p">(</span><span class="s">"tab: complete"</span><span class="p">)</span>
</code></pre></div></figure>


<p>You can add a lot more <a href="http://www.sontek.net/blog/2010/12/28/tips_and_tricks_for_the_python_interpreter.html">stuff</a> in this file, like <a href="https://github.com/bfontaine/Dotfiles/blob/master/.pythonrc.py#L21-L38">history</a>
support, <a href="https://github.com/coderholic/config/blob/master/.pythonrc.py#L77-L80">colored prompts</a> or common imports. For example, if you use <code>sys</code>
and <code>re</code> a lot, you can save time by adding them in your startup file:</p>

<figure class="code"><figcaption><span/></figcaption></figure>


<p>You won’t need to type these two lines anymore in your interpreter. It doesn’t
change how Python executes files, just the interactive interpreter.</p>

<h2>Testing</h2>

<p>Four different kinds of tests are covered by this part: style checkers to
ensure your code’s consistency, static analysis tools to detect problems before
executing the code, unit tests to actually test your library, and code coverage
tests to ensure you do test <em>all</em> the code.</p>

<h3>Style Checking</h3>

<p>These are tools which help you maintaining a consistent coding style in your
whole codebase. Most of these tools are easy to use, the hardest part being to
choose which one fits your requirements.</p>

<p>Python has a PEP (<q>Python Enhancement Proposal</q>, sort of RFC), the
<a href="http://legacy.python.org/dev/peps/pep-0008/">PEP 8</a>, dedicated to its coding conventions. If you want to follow
it, a command-line tool, rightly named <code>pep8</code>, is available.</p>

<pre><code>$ venv/bin/pip install pep8
$ venv/bin/pep8 your/lib/root/directory
...
foo/mod.py:84:80: E501 line too long (96 &gt; 79 characters)
foo/mod.py:85:6: E203 whitespace before ':'
foo/mod.py:86:80: E501 line too long (87 &gt; 79 characters)
foo/mod.py:87:4: E121 continuation line indentation is not a multiple of four
...
</code></pre>

<p>It’ll check each file and print a list of warnings. You can choose to hide some
of them, or use a white list to decide which ones you want. It’s a good tool if
you want to follow the PEP 8 conventions.</p>

<p>Another highly customizable tool is <code>pylint</code>. It reads its configuration from
a file in your project, which can <a href="http://stackoverflow.com/a/22449845/735926">inherit</a> from global and user
configurations. It’ll warn you about bad naming, missing docstrings, functions
which take too many arguments, duplicated code, etc. It also gives you some
statistics about your code. It’s really powerful but can be a pain if you don’t
configure it. For example, it warns you about one-letter variables while you
might find them ok.</p>

<p>Enters <code>prospector</code>.</p>

<p>Prospector is built on top of <code>pep8</code> and <code>pylint</code> and comes with sane defaults
regarding the pickiness of both tools. You can <a href="http://blog.landscape.io/prospector-python-static-analysis-for-humans.html">tell it</a> to only
print important problems about your code:</p>

<pre><code>$ venv/bin/pip install prospector
$ venv/bin/prospector --strictness high
</code></pre>

<p>You’ll get a much shorter output, which will hopefully help you find potential
problems in your code.</p>

<h3>Static Analysis</h3>

<p>Here, we’re talking about analysing the code without executing it. Compiled
languages benefit from this at compilation time, but interpreted languages like
Python have no way to have it.</p>

<p>One of the most popular tools for static analysis on Python code is
<a href="https://launchpad.net/pyflakes">Pyflakes</a>. It doesn’t check your coding style like <code>pep8</code> or <code>pylint</code>, but
warns you about missing imports, dead code, unused variables, redefined
functions and more. You can work without style checkers, but static analysis is
really helpful to detect potential bugs before actually running the code.</p>

<p>Pyflakes can be integrated in editors like Vim with <a href="https://github.com/scrooloose/syntastic#readme">Syntastic</a>, but its
command-line usage is as easy as the previous tools:</p>

<pre><code>$ venv/bin/pip install pyflakes
$ venv/bin/pyflakes your/directory
</code></pre>

<p>Prospector, mentioned in the previous section, also includes <code>pyflakes</code>. You
might also want to try <a href="https://pypi.python.org/pypi/flake8">Flake8</a>, which combines <code>pyflakes</code> and <code>pep8</code>.</p>

<h3>Unit Tests</h3>

<p>When talking about <q>testing</q>, we usually think of <em>unit</em> testing, which is
testing small pieces of our code at a time, to make sure everything is working
correctly. The goal is to test only one feature at a time, to quickly be able
to find which parts of the code are not working. There are a lot of great
testing frameworks, and Python comes with a built-in one, <a href="https://docs.python.org/2/library/unittest.html">unittest</a>, which I
personnally use. I won’t cover these, and I’ll instead cover the case when you
need to test on multiple Python versions, which is often the case when you
plan to release a public library. You obviously don’t want to manually switch
to each Python version, install your dependencies then run your tests suit each
time.</p>

<p>This is a job for <code>tox</code>.</p>

<p><a href="https://testrun.org/tox/latest/">Tox</a> uses Virtualenv, which I talked about earlier, to create standalone
Python environments for different Python versions, and test your code in each
one of them.</p>

<pre><code>$ venv/bin/pip install tox
</code></pre>

<p>Like some previous tools, it needs a configuration file. Here is a basic
<code>tox.ini</code> to test on Python 2.6, 2.7, 3.3 and 3.4:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><pre><code class="ini"><span class="k">[tox]</span>
<span class="na">envlist</span> <span class="o">=</span> <span class="s">py26, py27, py33, py34</span>
<span class="na">downloadcache</span> <span class="o">=</span> <span class="s">{toxworkdir}/_download/</span>

<span class="k">[testenv]</span>
<span class="na">sitepackages</span> <span class="o">=</span> <span class="s">False</span>
<span class="na">deps</span> <span class="o">=</span><span class="s"/>
<span class="s">  colorama</span>
<span class="na">commands</span> <span class="o">=</span><span class="s"/>
<span class="s">  {envpython} {toxinidir}/tests/test.py</span>
</code></pre></div></figure>


<p>It declares one dependency, <code>colorama</code>, and tells <code>tox</code> to run tests by
executing <code>tests/test.py</code>. That’s all. We can then run our tests:</p>

<pre><code>$ venv/bin/pip/tox
</code></pre>

<p>It’ll takes some time on the first run to fetch dependencies and create
environments, but all the following times will be faster.</p>

<p>Like <code>virtualenv</code>, <code>tox</code> uses a directory to store these environments. You can
safely delete it if you need more space, it’ll be re-created by <code>tox</code> the next
time:</p>

<pre><code>$ rm -rf .tox
</code></pre>

<h3>Code Coverage</h3>

<p>This last part about testing talks about code coverage tests. These are tests
about tests. The goal here is to ensure your tests cover all your code, and
you don’t leave some parts untested. Most tools tell you how many lines where
executed when running your tests suit, and give you an overall coverage
percentage.</p>

<p>One of them is <code>coverage</code>.</p>

<pre><code>$ venv/bin/pip install coverage
</code></pre>

<p>Give it your project’s root directory as well as a file to run your tests:</p>

<pre><code>$ venv/bin/coverage run --source=your/directory tests/test.py
</code></pre>

<p>It’ll run them, and give you a nice coverage report:</p>

<pre><code>$ coverage report -m
Name              Stmts   Miss  Cover   Missing
-----------------------------------------------
foobar/__init__       5      0   100%
foobar/base          46      2    96%   5-6
foobar/cli          159    159     0%   3-280
foobar/config        66     66     0%   3-150
foobar/session       64     14    78%   9-10, 106-124
foobar/barfooqux     22      0   100%
foobar/helloworld    25     20    20%   14-41
...
-----------------------------------------------
TOTAL               459    313    32%
</code></pre>

<p>It can also give you an HTML version:</p>

<pre><code>$ venv/bin/coverage html
</code></pre>

<p>Getting to 100% is the ultimate goal, but you’ll quickly find that’s the first
80% are easy and the remaining 20% are the hardest part, especially when you
have I/O, external dependencies like databases, and/or complicated
corner-cases.</p>

<p>Check <a href="http://nedbatchelder.com/code/coverage/">Coverage</a>’s doc for more info.</p>

<h2>Debugging</h2>

<p>There are a lot of ways to debug, including logs, but the simplest debugging
tool is the good old <code>print</code>. It becomes really impracticable when you have to
restart your server every time you add or remove one of them from your code.
What if you could fire a Python interpreter right from your code and inspect it
when it’s running? Well, you can do that with Python’s <code>code</code> module! This
trick is really handy, and I’ve been using it heavily instead of these <code>print</code>s
we write everywhere since I’ve discovered it.</p>

<p>The <code>code</code> module provides you with an <code>interact</code> function, which takes a
<code>dict</code> of variables to inject in the interpreter. You’ll be able to print them,
play with them, but these changes won’t be reflected in the program you’re
debugging.</p>

<p>Remember that Python lets you get all global variables as a <code>dict</code> with
<code>globals()</code> and all local ones with <code>locals()</code>. We thus start by creating a
mirror of the local environment:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><pre><code class="python"><span class="nb">vars</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="nb">vars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">locals</span><span class="p">())</span>
</code></pre></div></figure>


<p>These two lines get all global variables (including imported modules) in a
<code>dict</code> called <code>vars</code> and add local variables in it. This can then be passed
directly to the interpreter:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><pre><code class="python"><span class="kn">import</span> <span class="nn">code</span>
<span class="n">code</span><span class="o">.</span><span class="n">interact</span><span class="p">(</span><span class="n">local</span><span class="o">=</span><span class="nb">vars</span><span class="p">)</span>
</code></pre></div></figure>


<p>This will start an interpreter with all these variables already available in
it. There’s nothing to install, this is a <a href="https://docs.python.org/2/library/code.html#code.interact">standard Python module</a>.</p>

<p>You can even inline the code and add it in your favorite snippets manager:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><pre><code class="python"><span class="n">g</span><span class="o">=</span><span class="nb">globals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span><span class="n">g</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">locals</span><span class="p">());</span><span class="kn">import</span> <span class="nn">code</span><span class="p">;</span><span class="n">code</span><span class="o">.</span><span class="n">interact</span><span class="p">(</span><span class="n">local</span><span class="o">=</span><span class="n">g</span><span class="p">)</span>
</code></pre></div></figure>


<p>Don’t forget to remove it when you’re done!</p>

<h2>TL;DR</h2>

<ul>
<li>Use <code>virtualenv</code> to isolate your Python environment, <code>pip freeze</code> and a
<code>requirements.txt</code> file to keep track of your dependencies.</li>
<li>Write a <code>pythonrc.py</code> file to add autocomplete support to your interpreter</li>
<li>Use <code>pep8</code>, <code>pylint</code> and <code>pyflakes</code> to keep a high code quality</li>
<li>Use <code>tox</code> to test on multiple Python versions</li>
<li>Fire a local interpreter instead of <code>print</code>ing variables</li>
</ul>


<p>That was all. Please comment on this post if you think of any tool you use to
speed-up your Python development!</p>

</article>





</div></body></html>