<html><body><div><div itemprop="articleBody"><p>A lazy object proxy is an object that wraps a callable but defers the call until the object is actually required, and caches the result of said call.</p><p>These kinds of objects are useful in resolving various dependency issues, few examples:</p><ul class="simple"><li>Objects that need to held circular references at each other, but at different stages. To instantiate object <cite>Foo</cite> you need an instance of <cite>Bar</cite>. Instance of <cite>Bar</cite> needs an instance of <cite>Foo</cite> in some of it methods (but not at construction). Circular imports sound familiar?</li><li>Performance sensitive code. You don't know ahead of time what you're going to use but you don't want to pay for allocating all the resources at the start as you usually need just few of them.</li></ul><p>There are other examples, I've just made up a couple for context.</p><p>If you've used Django you may be familiar with <a class="reference external" href="https://github.com/django/django/blob/stable/1.7.x/django/utils/functional.py#L337">SimpleLazyObject</a>. For simple use-cases it's fine, and if you're already using Django the choice is obvious. Unfortunately it's missing many magic methods, most glaring omissions: <tt class="docutils literal">__iter__</tt>, <tt class="docutils literal">__getslice__</tt>, <tt class="docutils literal">__call__</tt> etc. It's not too bad, you can just subclass and add them yourself.</p><p>But what if you need to have <tt class="docutils literal">__getattr__</tt>? The horrors of the infinite recursive call beckon.</p><p>Meanwhile I've noticed that <a class="reference external" href="https://github.com/GrahamDumpleton/wrapt">wrapt</a> has a quite complete <a class="reference external" href="http://wrapt.readthedocs.org/en/latest/wrappers.html#object-proxy">object proxy</a>. Unfortunately it's not really amendable to adding a <cite>lazy</cite> behavior in a subclass due to the C extension (I wouldn't make bets on sub-classing the pure-python proxy implementation either without some unwanted overhead :-).</p><p>Thus I forked the code and changed everything to have the <cite>lazy behavior</cite>. You can see the results here: <a class="reference external" href="https://github.com/ionelmc/python-lazy-object-proxy">https://github.com/ionelmc/python-lazy-object-proxy</a></p><p>Part of that is a C extension packaging exercise but that's for another blog-post <a class="footnote-reference" href="#id6" id="id1">[2]</a>.</p><p>I've also done some benchmarks (with <a class="reference external" href="https://github.com/ionelmc/pytest-benchmark">pytest-benchmark</a>) <a class="footnote-reference" href="#id5" id="id2">[1]</a>:</p><div class="term"><pre class="nowrap">
<span>-- benchmark: min 5 rounds (of min 25.00us), 30.00s max time, timer: time.perf_counter --</span>
Name (time in ns)                Min         Max      Mean    StdDev   Rounds  Iterations
<span>-----------------------------------------------------------------------------------------</span>
test_perf[slots]          <span>  606.8182</span><span>  26084.0909</span><span>  627.7139</span><span>   89.5553</span>  1111112          44
test_perf[cext]           <span/><span>   84.7701</span><span/><span>   2830.4598</span><span/><span>   86.2741</span><span/><span>    9.6827</span>  1006712         348
test_perf[simple]         <span>  328.9474</span><span>  11456.5790</span><span>  334.8236</span><span>   41.8470</span>  1195220          76
test_perf[django]         <span>  409.5238</span><span>  17969.8413</span><span>  417.4172</span><span>   49.9735</span>  1158302          63
test_perf[objproxies]     <span/><span>  880.0000</span><span/><span>  31256.6666</span><span/><span>  923.1323</span><span/><span>  106.3637</span>  1111112          30
<span>-----------------------------------------------------------------------------------------</span>
</pre></div><p>The <tt class="docutils literal">slots</tt> and <tt class="docutils literal">cext</tt> implementations are based on <a class="reference external" href="https://github.com/GrahamDumpleton/wrapt">wrapt</a>'s code. I've named the pure Python implementation <tt class="docutils literal">slots</tt> because that is the distinguishing implementation technique. And that was all I had in the beginning. I've wondered why Django's <a class="reference external" href="https://github.com/django/django/blob/stable/1.7.x/django/utils/functional.py#L337">SimpleLazyObject</a> is faster, by a significant margin even.</p><p>To find out what exactly is different I've made a primitive tracer:</p><div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">linecache</span>

<span class="kn">from</span> <span class="nn">lazy_object_proxy.slots</span> <span class="kn">import</span> <span class="n">Proxy</span>
<span class="kn">from</span> <span class="nn">django.utils.functional</span> <span class="kn">import</span> <span class="n">SimpleLazyObject</span>


<span class="k">def</span> <span class="nf">dumbtrace</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"</span><span class="si">%015s</span><span class="s2">:</span><span class="si">%-3s</span><span class="s2"> </span><span class="si">%06s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_filename</span><span class="p">),</span>
        <span class="n">frame</span><span class="o">.</span><span class="n">f_lineno</span><span class="p">,</span>
        <span class="n">event</span><span class="p">,</span>
        <span class="n">linecache</span><span class="o">.</span><span class="n">getline</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_filename</span><span class="p">,</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_lineno</span><span class="p">)</span>
    <span class="p">))</span>
    <span class="k">return</span> <span class="n">dumbtrace</span>  <span class="c1"># "step in"</span>

<span class="k">for</span> <span class="n">Implementation</span> <span class="ow">in</span> <span class="n">Proxy</span><span class="p">,</span> <span class="n">SimpleLazyObject</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">"Testing </span><span class="si">%s</span><span class="s2"> ..."</span> <span class="o">%</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Implementation</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="s1">'foobar'</span><span class="p">)</span>
    <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">settrace</span><span class="p">(</span><span class="n">dumbtrace</span><span class="p">)</span>
    <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">settrace</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>  <span class="c1"># we don't want to trace other stuff</span>
</pre></div><p>And from that I've got:</p><div class="term container"><pre class="code nowrap literal-block">
Testing Proxy ...
       slots.py:122   call     def __str__(self):
       slots.py:123   line         return str(self.__wrapped__)
       slots.py:74    call     @property
       slots.py:76    line         try:
       slots.py:77    line             return __getattr__(self, '__target__')
       slots.py:77  return             return __getattr__(self, '__target__')
       slots.py:123 return         return str(self.__wrapped__)
Testing SimpleLazyObject ...
  functional.py:222   call     def inner(self, *args):
  functional.py:223   line         if self._wrapped is empty:
  functional.py:225   line         return func(self._wrapped, *args)
  functional.py:225 return         return func(self._wrapped, *args)
</pre></div><p>Essentially, the biggest difference is an extra function call (the <tt class="docutils literal">__wrapped__</tt> property).</p><p>Now I've thought to myself: I can do that too, using the <a class="reference external" href="https://blog.ionelmc.ro/2014/11/04/an-interesting-python-descriptor-quirk/">cached property technique</a> I could remove the second function call. But that trick needs a <tt class="docutils literal">__dict__</tt> - it can't work with <tt class="docutils literal">__slots__</tt>. So I've proceeded to make an implementation that doesn't have that (the "<tt class="docutils literal">simple</tt>" from the previous benchmark table). It was faster indeed but then I finally understood why Graham Dumpleton used <tt class="docutils literal">__slots__</tt> (while the tests started to fail).</p><p>Turns out he had replaced the normal <tt class="docutils literal">__dict__</tt> with a property <a class="footnote-reference" href="#id7" id="id3">[3]</a>, and proxying <tt class="docutils literal">vars(obj)</tt> relies on having <tt class="docutils literal">dict__</tt> as a proxy property. In other words, you can't use <tt class="docutils literal">vars</tt> on an object without a <tt class="docutils literal">__dict__</tt> (like most builtin types).</p><p>Interestingly enough, the implementation with <tt class="docutils literal">__slots__</tt> is much faster on PyPy <a class="footnote-reference" href="#id8" id="id4">[4]</a>:</p><div class="term"><pre class="nowrap">
<span>-- benchmark: 4 tests, min 5 rounds (of min 25.00us), 30.00s max time, timer: monotonic --</span>
Name (time in ns)                   Min         Max     Mean   StdDev   Rounds  Iterations
<span>------------------------------------------------------------------------------------------</span>
test_perf[slots]              <span/><span>   2.1267</span><span/><span>    139.0987</span><span/><span>   2.3513</span><span/><span>   0.4176</span>  1003345       13824
test_perf[simple]             <span>  24.0000</span><span>   9981.7000</span><span>  29.9561</span><span/><span>  37.2147</span>  1250001        1000
test_perf[django]             <span>  25.1000</span><span/><span>  10186.4000</span><span>  29.5746</span><span>  26.3704</span>  1195220        1000
test_perf[objproxies]         <span/><span>  25.6000</span><span>   9509.6000</span><span/><span>  30.2238</span><span>  20.0922</span>  1176471        1000
<span>------------------------------------------------------------------------------------------</span>
</pre></div><hr class="docutils"/><p>Now I'm a bit broken up about this, which implementation should be the default? Should the <tt class="docutils literal">simple</tt> one be the default on PyPy?</p></div></div></body></html>