<html><body><div><div class="post-body entry-content" id="post-body-2262890283799972493" itemprop="description articleBody"><p>


All the recent media attention on Bitcoin inspired me to learn how Bitcoin really works, right down to the bytes flowing through the network.
Normal people use software</p><a class="ref" href="#ref1">[1]</a><p> that hides what is really going on, but I wanted to get a hands-on understanding of the Bitcoin protocol.
My goal was to use the Bitcoin system directly: create a Bitcoin transaction manually, feed it into the system as hex data, and see how it gets processed.
This turned out to be considerably harder than I expected, but I learned a lot in the process and hopefully you will find it interesting.
</p><p>
(Feb 23: I have a new article that covers the <a href="http://www.righto.com/2014/02/bitcoin-mining-hard-way-algorithms.html">technical details of mining</a>. If you like this article, check out my mining article too.)
</p><p>
This blog post starts with a quick overview of Bitcoin and then jumps into the low-level details: creating a Bitcoin address, making a transaction, signing the transaction, feeding the transaction into the peer-to-peer network, and observing the results.
</p><h2>A quick overview of Bitcoin</h2><p>
I'll start with a quick overview of how Bitcoin works</p><a class="ref" href="#ref2">[2]</a><p>,
before diving into the details.
Bitcoin is a relatively new digital currency</p><a class="ref" href="#ref3">[3]</a><p> that can be transmitted across the Internet. You can buy bitcoins</p><a class="ref" href="#ref4">[4]</a><p> with dollars or other traditional money from sites such as </p><a href="http://coinbase.com">Coinbase</a> <strike>or <a href="http://mtgox.com">MtGox</a></strike><a class="ref" href="#ref5">[5]</a><p>, send bitcoins to other people, buy things with them at </p><a href="http://www.shopify.com/blog/10480345-75-places-to-spend-your-bitcoins">some</a>Â <a href="https://www.spendbitcoins.com/places/">places</a><p>, and exchange bitcoins back into dollars.
</p><p>
To simplify slightly, bitcoins consist of entries in a distributed database that keeps track of the ownership of bitcoins.
Unlike a bank, bitcoins are not tied to users or accounts. Instead bitcoins are owned by a Bitcoin <i>address</i>, for example <code>1KKKK6N21XKo48zWKuQKXdvSsCf95ibHFa</code>.
</p><h3>Bitcoin transactions</h3><p>
A </p><i>transaction</i><p> is the mechanism for spending bitcoins. In a transaction, the owner of some bitcoins transfers ownership to a new address.
</p><p>
A key innovation of Bitcoin is how transactions are recorded in the distributed database through <i>mining</i>.
Transactions are grouped into blocks and about every 10 minutes a new block of transactions is sent out, becoming part of the transaction log known as the <i>blockchain</i>, which indicates the transaction has been made (more-or-less) official.<a class="ref" href="#ref6">[6]</a>
Bitcoin mining is the process that puts transactions into a block, to make sure everyone has a consistent view of the transaction log.
To mine a block, miners must find an extremely rare solution to an (otherwise-pointless) cryptographic problem. Finding this solution generates a mined block, which becomes part of the official block chain.
</p><p>
Mining is also the mechanism for new bitcoins to enter the system.
When a block is successfully mined, new bitcoins are generated in the block and paid to the miner. This mining bounty is large - currently 25 bitcoins per block (about $19,000). In addition, the miner gets any fees associated with the transactions in the block. Because of this, mining is very competitive with many people attempting to mine blocks.
The difficulty and competitiveness of mining is a key part of Bitcoin security, since it ensures that nobody can flood the system with bad blocks.
</p><h3>The peer-to-peer network</h3><p>
There is no centralized Bitcoin server. Instead, Bitcoin runs on a peer-to-peer network. If you run a Bitcoin client, you become part of that network. The nodes on the network exchange transactions, blocks, and addresses of other peers with each other.
When you first connect to the network, your client downloads the blockchain from some random node or nodes. In turn, your client may provide data to other nodes. When you create a Bitcoin transaction, you send it to some peer, who sends it to other peers, and so on, until it reaches the entire network. Miners pick up your transaction, generate a mined block containing your transaction, and send this mined block to peers. Eventually your client will receive the block and your client shows that the transaction was processed.
</p><h3>Cryptography</h3><p>
Bitcoin uses digital signatures to ensure that only the owner of bitcoins can spend them. The owner of a Bitcoin address has the private key associated with the address. To spend bitcoins, they sign the transaction with this private key, which proves they are the owner. (It's somewhat like signing a physical check to make it valid.) A public key is associated with each Bitcoin address, and anyone can use it to verify the digital signature.
</p><p>
Blocks and transactions are identified by a 256-bit cryptographic hash of their contents. This hash value is used in multiple places in the Bitcoin protocol. In addition, finding a special hash is the difficult task in mining a block.
</p><p>
<a href="http://www.flickr.com/photos/105644709@N08/10867417104/" title="Bitcoin statistic coin ANTANA by antanacoins, on Flickr"><img src="http://farm8.staticflickr.com/7429/10867417104_6595b54daa_n.jpg" alt="Bitcoin statistic coin ANTANA"/></a>
</p>

<h2>Diving into the raw Bitcoin protocol</h2><p>
The remainder of this article discusses, step by step, how I used the raw Bitcoin protocol.
First I generated a Bitcoin address and keys. Next I made a transaction to move a small amount of bitcoins to this address. Signing this transaction took me a lot of time and difficulty. Finally, I fed this transaction into the Bitcoin peer-to-peer network and waited for it to get mined.
The remainder of this article describes these steps in detail.
</p><p>
It turns out that actually using the Bitcoin protocol is harder than I expected. As you will see, the protocol is a bit of a jumble: it uses big-endian numbers, little-endian numbers, fixed-length numbers, variable-length numbers, custom encodings, <a href="http://en.wikipedia.org/wiki/Distinguished_Encoding_Rules#DER_encoding">DER encoding</a>, and a variety of cryptographic algorithms, seemingly arbitrarily. As a result, there's a lot of annoying manipulation to get data into the right format.<a class="ref" href="#ref7">[7]</a>
</p><p>
The second complication with using the protocol directly is that being cryptographic, it is very unforgiving. If you get one byte wrong, the transaction is rejected with no clue as to where the problem is.<a class="ref" href="#ref8">[8]</a>
</p><p>
The final difficulty I encountered is that the process of signing a transaction is much more difficult than necessary, with a lot of details that need to be correct. In particular, the version of a transaction that gets signed is very different from the version that actually gets used.
</p><h2>Bitcoin addresses and keys</h2><p>
My first step was to create a Bitcoin address. Normally you use Bitcoin client software to create an address and the associated keys. However, I wrote some Python code to create the address, showing exactly what goes on behind the scenes.
</p><p>
Bitcoin uses a variety of keys and addresses, so the following diagram may help explain them. You start by creating a random 256-bit private key. The private key is needed to sign a transaction and thus transfer (spend) bitcoins. Thus, the private key must be kept secret or else your bitcoins can be stolen.
</p><p>
The Elliptic Curve DSA algorithm generates a 512-bit public key from the private key. (Elliptic curve cryptography will be discussed later.) This public key is used to verify the signature on a transaction. Inconveniently, the Bitcoin protocol adds a <a href="https://en.bitcoin.it/wiki/Protocol_specification#Signatures">prefix of 04</a> to the public key. The public key is not revealed until a transaction is signed, unlike most systems where the public key is made public.
</p><p>
<a href="https://picasaweb.google.com/lh/photo/PWNDstAMH7mIdYfxE221HqNTQ8Yf_fOdBXli6Rl3Pxs"><img class="hilite" src="https://lh4.googleusercontent.com/-p8yVJXqY7fg/UuLaPjMDtyI/AAAAAAAAWYQ/QoenRIBO1O4/s588/bitcoinkeys.png" alt="How bitcoin keys and addresses are related" title="How bitcoin keys and addresses are related"/>
</a>
</p><p>
</p><p class="cite">
How bitcoin keys and addresses are related
</p>
<p>
The next step is to generate the Bitcoin address that is shared with others.
Since the 512-bit public key is inconveniently large, it is hashed down to 160 bits using the SHA-256 and RIPEMD hash algorithms.<a class="ref" href="#ref9">[9]</a> The key is then encoded in ASCII using Bitcoin's custom Base58Check encoding.<a class="ref" href="#ref10">[10]</a> The resulting address, such as <code>1KKKK6N21XKo48zWKuQKXdvSsCf95ibHFa</code>, is the address people publish in order to receive bitcoins. Note that you cannot determine the public key or the private key from the address. If you lose your private key (for instance by <a href="http://www.usatoday.com/story/news/world/2013/11/28/newser-bitcoin-landfill/3775271/">throwing out your hard drive</a>), your bitcoins are lost forever.
</p><p>
Finally, the <a href="https://en.bitcoin.it/wiki/WIF">Wallet Interchange Format</a> key (WIF) is used to add a private key to your client wallet software. This is simply a Base58Check encoding of the private key into ASCII, which is easily reversed to obtain the 256-bit private key. (I was curious if anyone would use the private key above to steal my 80 cents of bitcoins, and sure enough <a href="http://blockexplorer.com/tx/c92ad3cb375aca80e8b2b740f24130a52d6fdfb24b3effa5b3f97abb99a84393#i72459399">someone did</a>.)
</p><p>
To summarize, there are three types of keys: the private key, the public key, and the hash of the public key, and they are represented externally in ASCII using Base58Check encoding. The private key is the important key, since it is required to access the bitcoins and the other keys can be generated from it. The public key hash is the Bitcoin address you see published.
</p><p>
I used the following code snippet<a class="ref" href="#ref11">[11]</a> to generate a private key in WIF format and an address. The private key is simply a random 256-bit number. The ECDSA crypto library generates the public key from the private key.<a class="ref" href="#ref12">[12]</a> The Bitcoin address is generated by SHA-256 hashing, RIPEMD-160 hashing, and then Base58 encoding with checksum. Finally, the private key is encoded in Base58Check to generate the WIF encoding used to enter a private key into Bitcoin client software.<a class="ref" href="#ref1">[1]</a> Note: this Python random function is not cryptographically strong; use a better function if you're doing this for real.
</p><p>

</p><h2>Inside a transaction</h2><p>
A </p><i>transaction</i><p> is the basic operation in the Bitcoin system.
You might expect that a transaction simply moves some bitcoins from one address to another address, but it's more complicated than that.
A Bitcoin transaction moves bitcoins between one or more </p><i>inputs</i><p> and </p><i>outputs</i><p>. Each input is a transaction and address supplying bitcoins. Each output is an address receiving bitcoin, along with the amount of bitcoins going to that address.
</p><p>
<a href="https://picasaweb.google.com/lh/photo/KzugE1Dj3S_YNt0hrmp8PKNTQ8Yf_fOdBXli6Rl3Pxs"><img class="hilite" src="https://lh4.googleusercontent.com/-FX_lwaangsI/UuNVjoFa4jI/AAAAAAAAWZU/NMeJZDHe6EA/s800/transaction-diagram.png" alt="A sample Bitcoin transaction. Transaction C spends .008 bitcoins from Transactions A and B." title="A sample Bitcoin transaction. Transaction C spends .008 bitcoins from Transactions A and B."/>
</a>
</p><p>
</p><p class="cite">
A sample Bitcoin transaction. Transaction C spends .008 bitcoins from Transactions A and B.
</p>
<p>
The diagram above shows a sample transaction "C". In this transaction, .005 BTC are taken from an address in Transaction A, and .003 BTC are taken from an address in Transaction B. (Note that arrows are references to the previous outputs, so are backwards to the flow of bitcoins.) For the outputs, .003 BTC are directed to the first address and .004 BTC are directed to the second address. The leftover .001 BTC goes to the miner of the block as a fee. Note that the .015 BTC in the other output of Transaction A is not spent in this transaction.
</p><p>
Each input used must be entirely spent in a transaction. If an address received 100 bitcoins in a transaction and you just want to spend 1 bitcoin, the transaction must spend all 100. The solution is to use a second output for <i>change</i>, which returns the 99 leftover bitcoins back to you.
</p><p>
Transactions can also include <i>fees</i>. If there are any bitcoins left over after adding up the inputs and subtracting the outputs, the remainder is a fee paid to the miner.
The fee isn't strictly required, but transactions without a fee will be a low priority for miners and may not be processed for days or may be discarded entirely.<a class="ref" href="#ref13">[13]</a>
A typical fee for a transaction is 0.0002 bitcoins (about 20 cents), so fees are low but not trivial.
</p><h2>Manually creating a transaction</h2><p>
For my experiment I used a simple transaction with one input and one output, which is shown below.
I started by bying bitcoins from </p><a href="http://coinbase.com">Coinbase</a><p> and putting 0.00101234 bitcoins into address </p><code>1MMMMSUb1piy2ufrSguNUdFmAcvqrQF8M5</code><p>, which was transaction </p><a href="https://blockchain.info/tx/81b4c832d70cb56ff957589752eb4125a4cab78a25a8fc52d6a09e5bd4404d48"><code>81b4c832...</code></a><p>. My goal was to create a transaction to transfer these bitcoins to the address I created above,
</p><code>1KKKK6N21XKo48zWKuQKXdvSsCf95ibHFa</code><p>, subtracting a fee of 0.0001 bitcoins. Thus, the destination address will receive 0.00091234 bitcoins.
</p><p>
<a href="https://picasaweb.google.com/lh/photo/VQdIQNIEiihzeRjFO1s1KKNTQ8Yf_fOdBXli6Rl3Pxs"><img class="hilite" src="https://lh5.googleusercontent.com/-DzIHjsd2qEM/UuMH-iJPYJI/AAAAAAAAWYk/YRLW-55mfpY/s400/transaction-diagram-new.png" alt="Structure of the example Bitcoin transaction." title="Structure of the example Bitcoin transaction."/>
</a>
</p><p>
</p><p class="cite">
Structure of the example Bitcoin transaction.
</p>
<p>
Following the <a href="https://en.bitcoin.it/wiki/Protocol_specification#tx">specification</a>, the unsigned transaction can be assembled fairly easily, as shown below. There is one input, which is using output 0 (the first output) from transaction <code>81b4c832...</code>. Note that this transaction hash is inconveniently reversed in the transaction. The output amount is 0.00091234 bitcoins (91234 is 0x016462 in hex), which is stored in the value field in little-endian form. The cryptographic parts - <i>scriptSig</i> and <i>scriptPubKey</i> - are more complex and will be discussed later.
</p><p>
</p><table class="tx">
<tr><td colspan="2">version</td><td>01 00 00 00</td></tr>
<tr><td colspan="2">input count</td><td>01</td></tr>
<tr><td rowspan="5">input</td><td class="txindent">previous output hash<br/>(reversed)</td><td>48 4d 40 d4 5b 9e a0 d6 52 fc a8 25 8a b7 ca a4 25 41 eb 52 97 58 57 f9 6f b5 0c d7 32 c8 b4 81</td></tr>
<tr><td class="txindent">previous output index</td><td>00 00 00 00</td></tr>
<tr><td class="txindent">script length</td><td/></tr>
<tr><td class="txindent">scriptSig</td><td>script containing signature</td></tr>
<tr><td class="txindent">sequence</td><td>ff ff ff ff</td></tr>
<tr><td colspan="2">output count</td><td>01</td></tr>
<tr><td rowspan="3">output</td><td class="txindent">value</td><td>62 64 01 00 00 00 00 00</td></tr>
<tr><td class="txindent">script length</td><td/></tr>
<tr><td class="txindent">scriptPubKey</td><td>script containing destination address</td></tr>
<tr><td colspan="2">block lock time</td><td>00 00 00 00</td></tr>
</table>
<p>
Here's the code I used to generate this unsigned transaction. It's just a matter of <a href="http://docs.python.org/2/library/struct.html">packing</a> the data into binary. Signing the transaction is the hard part, as you'll see next.

</p><h2>How Bitcoin transactions are signed</h2><p>
The following diagram gives a simplified view of how transactions are signed and linked together.</p><a class="ref" href="#ref14">[14]</a><p> Consider the middle transaction, transferring bitcoins from address B to address C. The contents of the transaction (including the hash of the previous transaction) are hashed and signed with B's private key. In addition, B's public key is included in the transaction.
</p><p>
By performing several steps, anyone can verify that the transaction is authorized by B. First, B's public key must correspond to B's address in the previous transaction, proving the public key is valid. (The address can easily be derived from the public key, as explained earlier.) Next, B's signature of the transaction can be verified using the B's public key in the transaction. These steps ensure that the transaction is valid and authorized by B. One unexpected part of Bitcoin is that B's public key isn't made public until it is used in a transaction.
</p><p>
With this system, bitcoins are passed from address to address through a chain of transactions. Each step in the chain can be verified to ensure that bitcoins are being spent validly. Note that transactions can have multiple inputs and outputs in general, so the chain branches out into a tree.
</p><p>
<a href="https://picasaweb.google.com/lh/photo/1EyCN5GPklKAFHGZs8TT2aNTQ8Yf_fOdBXli6Rl3Pxs"><img class="hilite" src="https://lh4.googleusercontent.com/-bweWuuZS2Ws/UuVm2RjRCyI/AAAAAAAAWZ4/IV2rPvunYLQ/s512/bitcoin-transaction-chain.png" alt="How Bitcoin transactions are chained together." title="How Bitcoin transactions are chained together."/>
</a>
</p><p>
</p><div class="cite"><p>
How Bitcoin transactions are chained together.</p><a class="ref" href="#ref14">[14]</a>
</div>
<h2>The Bitcoin scripting language</h2><p>
You might expect that a Bitcoin transaction is signed simply by including the signature in the transaction, but the process is much more complicated.
In fact, there is a small program inside each transaction that gets executed to decide if a transaction is valid.
This program is written in </p><i>Script</i><p>, the </p><a href="http://en.wikipedia.org/wiki/Stack-based">stack-based</a><p> Bitcoin scripting language. Complex redemption conditions can be expressed in this language. For instance, an escrow system can require two out of three specific users must sign the transaction to spend it. Or various types of </p><a href="https://en.bitcoin.it/wiki/Contracts">contracts</a><p> can be set up.</p><a class="ref" href="#ref15">[15]</a>
<p>
The Script language is surprisingly complex, with about <a href="https://en.bitcoin.it/wiki/Script">80 different opcodes</a>. It includes arithmetic, bitwise operations, string operations, conditionals, and stack manipulation. The language also includes the necessary cryptographic operations (SHA-256, RIPEMD, etc.) as primitives. In order to ensure that scripts terminate, the language does not contain any looping operations. (As a consequence, it is not Turing-complete.) In practice, however, only a few types of transactions are supported.<a class="ref" href="#ref16">[16]</a>
</p><p>
In order for a Bitcoin transaction to be valid, the two parts of the redemption script must run successfully.
The script in the old transaction is called <i>scriptPubKey</i> and the script in the new transaction is called <i>scriptSig</i>.
To verify a transaction, the scriptSig executed followed by the scriptPubKey.
If the script completes successfully, the transaction is valid and the Bitcoin can be spent. Otherwise, the transaction is invalid. The point of this is that the scriptPubKey in the old transaction defines the conditions for spending the bitcoins. The scriptSig in the new transaction must provide the data to satisfy the conditions.
</p><p>
In a standard transaction, the scriptSig pushes the signature (generated from the private key) to the stack, followed by the public key. Next, the scriptPubKey (from the source transaction) is executed to verify the public key and then verify the signature.
</p><p>
As expressed in Script, the scriptSig is:
</p><pre>
PUSHDATA
signature data and SIGHASH_ALL
PUSHDATA
public key data
</pre><p>
The scriptPubKey is:
</p><pre>
OP_DUP
OP_HASH160
PUSHDATA
Bitcoin address (public key hash)
OP_EQUALVERIFY
OP_CHECKSIG
</pre>
<p>
When this code executes, PUSHDATA first pushes the signature to the stack. The next PUSHDATA pushes the public key to the stack. Next, OP_DUP duplicates the public key on the stack. OP_HASH160 computes the 160-bit hash of the public key. PUSHDATA pushes the required Bitcoin address. Then OP_EQUALVERIFY verifies the top two stack values are equal - that the public key hash from the new transaction matches the address in the old address. This proves that the public key is valid. Next, OP_CHECKSIG checks that the signature of the transaction matches the public key and signature on the stack. This proves that the signature is valid.
</p><h2>Signing the transaction</h2><p>
I found signing the transaction to be the hardest part of using Bitcoin manually, with a process that is surprisingly difficult and error-prone.
The basic idea is to use the ECDSA elliptic curve algorithm and the private key to generate a digital signature of the transaction, but the details are tricky.
The signing process has been described through a
</p><a href="http://bitcoin.stackexchange.com/questions/3374/how-to-redeem-a-basic-tx">19-step process</a><p> (</p><a href="https://en.bitcoin.it/wiki/OP_CHECKSIG">more info</a><p>).
Click the </p><a href="https://en.bitcoin.it/w/images/en/7/70/Bitcoin_OpCheckSig_InDetail.png">thumbnail below</a><p> for a detailed diagram of the process.
</p><p>
<a href="https://en.bitcoin.it/w/images/en/7/70/Bitcoin_OpCheckSig_InDetail.png">
 <img class="hilite" src="https://lh4.googleusercontent.com/-anHnnkgfQw8/Ut4QeV-Q9yI/AAAAAAAAWXA/RvR5tOvR4tk/s800/signing-thumb.png"/></a>
</p><p>
The biggest complication is the signature appears in the middle of the transaction, which raises the question of how to sign the transaction before you have the signature.
To avoid this problem,
the <i>scriptPubKey</i> script is copied from the source transaction into the spending transaction (i.e. the transaction that is being signed) before computing the signature. Then the signature is turned into code in the Script language, creating the <i>scriptSig</i> script that is embedded in the transaction. It appears that using the previous transaction's <i>scriptPubKey</i> during signing is for historical reasons rather than any logical reason.<a class="ref" href="#ref17">[17]</a>
For transactions with multiple inputs, signing is even more complicated since each input requires a separate signature, but I won't go into the details.
</p><p>
One step that tripped me up is the <i>hash type</i>.
Before signing, the transaction has a hash type constant temporarily appended. For a regular transaction, this is <a href="https://en.bitcoin.it/wiki/OP_CHECKSIG#How_it_works">SIGHASH_ALL</a> (0x00000001). After signing, this hash type is removed from the end of the transaction and appended to the scriptSig.
</p><p>
Another annoying thing about the Bitcoin protocol is that the signature and public key are both 512-bit elliptic curve values, but they are represented in totally different ways: the signature is encoded with <a href="http://en.wikipedia.org/wiki/X.690#DER_encoding">DER</a> encoding but the public key is represented as plain bytes. In addition, both values have an extra byte, but positioned inconsistently: SIGHASH_ALL is put after the signature, and type 04 is put before the public key.
</p><p>
Debugging the signature was made more difficult because the ECDSA algorithm uses a random number.<a class="ref" href="#ref18">[18]</a> Thus, the signature is different every time you compute it, so it can't be compared with a known-good signature.
</p><p>
Update (Feb 2014): An important side-effect of the signature changing every time is that if you re-sign a transaction, the transaction's hash will change. This is known as <a href="https://en.bitcoin.it/wiki/Transaction_Malleability">Transaction Malleability</a>. There are also ways that third parties can modify transactions in trivial ways that change the hash but not the meaning of the transaction. Although it has been known for years, malleability has recently caused big problems (Feb 2014) with MtGox (<a href="https://www.mtgox.com/press_release_20140210.html">press release</a>).
</p><p>
With these complications it took me a long time to get the signature to work.
Eventually, though, I got all the bugs out of my signing code and succesfully signed a transaction. Here's the code snippet I used.
</p><p>

</p><p>
The final scriptSig contains the signature along with the public key for the source address (<code>1MMMMSUb1piy2ufrSguNUdFmAcvqrQF8M5</code>). This proves I am allowed to spend these bitcoins, making the transaction valid.
</p><p>
</p><table class="tx">
  <tr><td colspan="2">PUSHDATA 47</td><td>47</td></tr>
  <tr><td rowspan="8">signature<br/> (DER)</td>
  <td>sequence</td><td>30</td></tr>
  <tr><td class="txindent">length</td><td>44</td></tr>
  <tr><td class="txindent">integer</td><td>02</td></tr>
  <tr><td class="txindent2">length</td><td>20</td></tr>
  <tr><td class="txindent2">X</td><td>2c b2 65 bf 10 70 7b f4 93 46 c3 51 5d d3 d1 6f c4 54 61 8c 58 ec 0a 0f f4 48 a6 76 c5 4f f7 13</td></tr>
  <tr><td class="txindent">integer</td><td>02</td></tr>
<tr><td class="txindent2">length</td><td>20</td></tr>
<tr><td class="txindent2">Y</td><td>
    6c 66 24 d7 62 a1 fc ef 46 18 28 4e ad 8f 08 67 8a c0 5b 13 c8 42 35 f1 65 4e 6a d1 68 23 3e 82</td></tr>
<tr><td colspan="2" class="txindent">SIGHASH_ALL</td><td>01</td></tr>
  <tr><td colspan="2">PUSHDATA 41</td><td>41</td></tr>
  <tr><td rowspan="5">public key</td>
   <td>type</td><td>04</td></tr>
  <tr><td>X</td><td>14 e3 01 b2 32 8f 17 44 2c 0b 83 10 d7 87 bf 3d 8a 40 4c fb d0 70 4f 13 5b 6a d4 b2 d3 ee 75 13</td></tr>
  <tr><td>Y</td><td> 10 f9 81 92 6e 53 a6 e8 c3 9b d7 d3 fe fd 57 6c 54 3c ce 49 3c ba c0 63 88 f2 65 1d 1a ac bf cd</td></tr>
</table>
<p>
The final scriptPubKey contains the script that must succeed to spend the bitcoins. Note that this script is executed at some arbitrary time in the future when the bitcoins are spent.
It contains the destination address
(<code>1KKKK6N21XKo48zWKuQKXdvSsCf95ibHFa</code>) expressed in hex, not Base58Check. The effect is that only the owner of the private key for this address can spend the bitcoins, so that address is in effect the owner.
</p><table class="tx">
  <tr><td>OP_DUP</td><td>76</td></tr>
  <tr><td>OP_HASH160</td><td>a9</td></tr>
  <tr><td>PUSHDATA 14</td><td>14</td></tr>
  <tr><td class="txindent">public key hash</td><td>c8 e9 09 96 c7 c6 08 0e e0 62 84 60 0c 68 4e d9 04 d1 4c 5c</td>
    </tr><tr><td>OP_EQUALVERIFY</td><td>88</td></tr>
    <tr><td>OP_CHECKSIG</td><td>ac</td></tr>
</table>
<h2>The final transaction</h2><p>
Once all the necessary methods are in place, the final transaction can be assembled.

The final transaction is shown below. This combines the scriptSig and scriptPubKey above with the unsigned transaction described earlier.
</p><p>
</p><table class="tx">
<tr><td colspan="2">version</td><td>01 00 00 00</td></tr>
<tr><td colspan="2">input count</td><td>01</td></tr>
<tr><td rowspan="5">input</td><td class="txindent">previous output hash<br/>(reversed)</td><td>48 4d 40 d4 5b 9e a0 d6 52 fc a8 25 8a b7 ca a4 25 41 eb 52 97 58 57 f9 6f b5 0c d7 32 c8 b4 81</td></tr>
<tr><td class="txindent">previous output index</td><td>00 00 00 00</td></tr>
<tr><td class="txindent">script length</td><td>8a</td></tr>
<tr><td class="txindent">scriptSig</td><td>47 30 44 02 20 2c b2 65 bf 10 70 7b f4 93 46 c3 51 5d d3 d1 6f c4 54 61 8c 58 ec 0a 0f f4 48 a6 76 c5 4f f7 13 02 20 6c 66 24 d7 62 a1 fc ef 46 18 28 4e ad 8f 08 67 8a c0 5b 13 c8 42 35 f1 65 4e 6a d1 68 23 3e 82 01 41 04 14 e3 01 b2 32 8f 17 44 2c 0b 83 10 d7 87 bf 3d 8a 40 4c fb d0 70 4f 13 5b 6a d4 b2 d3 ee 75 13 10 f9 81 92 6e 53 a6 e8 c3 9b d7 d3 fe fd 57 6c 54 3c ce 49 3c ba c0 63 88 f2 65 1d 1a ac bf cd</td></tr>
<tr><td class="txindent">sequence</td><td>ff ff ff ff</td></tr>
<tr><td colspan="2">output count</td><td>01</td></tr>
<tr><td rowspan="3">output</td><td class="txindent">value</td><td>62 64 01 00 00 00 00 00</td></tr>
<tr><td class="txindent">script length</td><td>19</td></tr>
<tr><td class="txindent">scriptPubKey</td><td>76 a9 14 c8 e9 09 96 c7 c6 08 0e e0 62 84 60 0c 68 4e d9 04 d1 4c 5c 88 ac</td></tr>
<tr><td colspan="2">block lock time</td><td>00 00 00 00</td></tr>
</table>
<p>
</p><h2>A tangent: understanding elliptic curves</h2><p>
Bitcoin uses elliptic curves as part of the signing algorithm. I had heard about elliptic curves before in the context of solving Fermat's Last Theorem, so I was curious about what they are.
The mathematics of elliptic curves is interesting, so I'll take a detour and give a quick overview.
</p><p>
The name <i>elliptic curve</i> is confusing: elliptic curves are not ellipses, do not look anything like ellipses, and they have very little to do with ellipses.
An elliptic curve is a curve satisfying the fairly simple equation <i>y^2 = x^3 + ax + b</i>.
Bitcoin uses a specific elliptic curve called <a href="http://www.secg.org/collateral/sec2_final.pdf">secp256k1</a> with the simple equation <i>y^2=x^3+7</i>.
<a class="ref" href="#ref25">[25]</a>
</p><p>
<a href="https://picasaweb.google.com/lh/photo/x3-0WmXfEV7hgp6AxLU5K6NTQ8Yf_fOdBXli6Rl3Pxs"><img class="hilite" src="https://lh3.googleusercontent.com/-hYOTYOlOJ5U/Us-rlHxDwGI/AAAAAAAAVdU/Zfd6Fz74gKk/s300/elliptic-curve-small.png" alt="Elliptic curve formula used by Bitcoin." title="Elliptic curve formula used by Bitcoin."/>
</a>
</p><p>
</p><p class="cite">
Elliptic curve formula used by Bitcoin.
</p>
<p>
An important property of elliptic curves is that you can define addition of points on the curve with a simple <a href="http://en.wikipedia.org/wiki/Elliptic_curve#The_group_law">rule</a>: if you draw a straight line through the curve and it hits three points A, B, and C, then addition is defined by A+B+C=0. Due to the special nature of elliptic curves, addition defined in this way works "normally" and forms a group. With addition defined, you can define integer multiplication: e.g. 4A = A+A+A+A.
</p><p>
What makes elliptic curves useful cryptographically is that it's fast to do integer multiplication, but division basically requires brute force. For example, you can compute a product such as 12345678*A = Q really quickly (by computing powers of 2), but if you only know A and Q solving n*A = Q is hard. In elliptic curve cryptography, the secret number 12345678 would be the private key and the point Q on the curve would be the public key.
</p><p>
In cryptography, instead of using real-valued points on the curve, the coordinates are integers modulo a prime.<a class="ref" href="#ref19">[19]</a> One of the surprising properties of elliptic curves is the math works pretty much the same whether you use real numbers or modulo arithmetic.
Because of this, Bitcoin's elliptic curve doesn't look like the picture above, but is a random-looking mess of 256-bit points (imagine a big gray square of points).
</p><p>
The Elliptic Curve Digital Signature Algorithm (<a href="http://en.wikipedia.org/wiki/Elliptic_Curve_DSA">ECDSA</a>) takes a message hash, and then does some straightforward elliptic curve arithmetic using the message, the private key, and a random number<a class="ref" href="#ref18">[18]</a> to generate a new point on the curve that gives a signature. Anyone who has the public key, the message, and the signature can do some simple elliptic curve arithmetic to verify that the signature is valid. Thus, only the person with the private key can sign a message, but anyone with the public key can verify the message.
</p><p>
For more on elliptic curves, see the references<a class="ref" href="#ref20">[20]</a>.
</p><h2>Sending my transaction into the peer-to-peer network</h2><p>
Leaving elliptic curves behind, at this point I've created a transaction and signed it. The next step is to send it into the peer-to-peer network, where it will be picked up by miners and incorporated into a block.
</p><h3>How to find peers</h3><p>
The first step in using the peer-to-peer network is finding a peer.
The list of peers changes every few seconds, whenever someone runs a client.
Once a node is connected to a peer node, they share new peers by exchanging </p><i>addr</i><p> messages whenever a new peer is discovered. Thus, new peers rapidly spread through the system.
</p><p>
There's a chicken-and-egg problem, though, of how to find the first peer. Bitcoin clients solve this problem with several methods. Several reliable peers are registered in DNS under the name <i>bitseed.xf2.org</i>. By doing a nslookup, a client gets the IP addresses of these peers, and hopefully one of them will work.
If that doesn't work, a seed list of peers is hardcoded into the client.
<a class="ref" href="#ref26">[26]</a>
</p><p>
<a href="https://picasaweb.google.com/lh/photo/Zw8y8RELLwKPd3f5nEk2P6NTQ8Yf_fOdBXli6Rl3Pxs"><img class="hilite" src="https://lh3.googleusercontent.com/-S3C58sitiLQ/Us-rln_BqGI/AAAAAAAAVdc/Bsr2aVLYvbk/s400/nslookup.png" alt="nslookup can be used to find Bitcoin peers." title="nslookup can be used to find Bitcoin peers."/>
</a>
</p><p>
</p><p class="cite">
nslookup can be used to find Bitcoin peers.
</p>
<p>
Peers enter and leave the network when ordinary users start and stop Bitcoin clients, so there is a lot of turnover in clients. The clients I use are unlikely to be operational right now, so you'll need to find new peers if you want to do experiments. You may need to try a bunch to find one that works.
</p><h3>Talking to peers</h3><p>
Once I had the address of a working peer, the next step was to send my transaction into the peer-to-peer network.</p><a class="ref" href="#ref8">[8]</a><p>  Using the peer-to-peer protocol is pretty straightforward. I opened a TCP connection to an arbitrary peer on port 8333, started sending messages, and received messages in turn. The Bitcoin peer-to-peer protocol is pretty forgiving; peers would keep communicating even if I totally messed up requests.
</p><p>
Important note: as a few people pointed out, if you want to experiment you should use the Bitcoin <a href="https://en.bitcoin.it/wiki/Testnet">Testnet</a>, which lets you experiment with "fake" bitcoins, since it's easy to lose your valuable bitcoins if you mess up on the real network. (For example, if you forget the change address in a transaction, excess bitcoins will go to the miners as a fee.) But I figured I would use the real Bitcoin network and risk my $1.00 worth of bitcoins.
</p><p>
The protocol consists of about 24 different message types.
Each message is a fairly straightforward binary blob containing an ASCII command name and a binary payload appropriate to the command.
The protocol is well-documented on the <a href="https://en.bitcoin.it/wiki/Protocol_specification">Bitcoin wiki</a>.
</p><p>
The first step when connecting to a peer is to establish the connection by exchanging <i>version</i> messages.
First I send a <i><a href="https://en.bitcoin.it/wiki/Protocol_specification#version">version</a></i> message with my protocol version number<a class="ref" href="#ref21">[21]</a>, address, and a few other things. The peer sends its <i>version</i> message back. After this, nodes are supposed to acknowledge the version message with a <i><a href="https://en.bitcoin.it/wiki/Protocol_specification#verack">verack</a></i> message. (As I mentioned, the protocol is forgiving - everything works fine even if I skip the verack.)
</p><p>
Generating the <i>version</i> message isn't totally trivial since it has a bunch of fields, but it can be created with a few lines of Python. <i>makeMessage</i> below builds an arbitrary peer-to-peer message from the magic number, command name, and payload. <i>getVersionMessage</i> creates the payload for a <i>version</i> message by packing together the various fields.

</p><h3>Sending a transaction: <i>tx</i></h3><p>
I sent the transaction into the peer-to-peer network with the stripped-down Python script below. The script sends a </p><i>version</i><p> message, receives (and ignores) the peer's </p><i>version</i><p> and </p><i>verack</i><p> messages, and then sends the transaction as a </p><i>tx</i><p> message. The hex string is the transaction that I created earlier.

</p><p>
The following screenshot shows how sending my transaction appears in the Wireshark network analysis program<a class="ref" href="#ref22">[22]</a>. I wrote Python scripts to process Bitcoin network traffic, but to keep things simple I'll just use Wireshark here. The "tx" message type is visible in the ASCII dump, followed on the next line by the start of my transaction (01 00 ...).
</p><p>
<a href="https://picasaweb.google.com/lh/photo/24C8JkBF2sCMBxeqZFYptaNTQ8Yf_fOdBXli6Rl3Pxs"><img class="hilite" src="https://lh4.googleusercontent.com/--LYqURgHjRQ/UuINg_1uEMI/AAAAAAAAWXs/UkWpMkKq45w/s700/bitcoin-wireshark-tx.png" alt="A transaction uploaded to Bitcoin, as seen in Wireshark." title="A transaction uploaded to Bitcoin, as seen in Wireshark."/>
</a>
</p><p>
</p><p class="cite">
A transaction uploaded to Bitcoin, as seen in Wireshark.
</p>
<p>
To monitor the progress of my transaction, I had a socket opened to another random peer. Five seconds after sending my transaction, the other peer sent me a <i>tx</i> message with the hash of the transaction I just sent. Thus, it took just a few seconds for my transaction to get passed around the peer-to-peer network, or at least part of it.
</p><h2>Victory: my transaction is mined</h2><p>
After sending my transaction into the peer-to-peer network, I needed to wait for it to be mined before I could claim victory.
Ten minutes later my script received an </p><i>inv</i><p> message with a new block (see Wireshark trace below).
</p><a href="https://blockchain.info/block-index/456667">Checking this block</a><p> showed that it contained my transaction, proving my transaction worked.
I could also verify the success of this transaction by looking in my Bitcoin wallet and by checking online.
Thus, after a lot of effort, I had successfully created a transaction manually and had it accepted by the system. (Needless to say, my first few transaction attempts weren't successful - my faulty transactions vanished into the network, never to be seen again.</p><a class="ref" href="#ref8">[8]</a><p>)
</p><p>
<a href="https://picasaweb.google.com/lh/photo/KLVWQ4CFFrqDb5yGRJ7nT6NTQ8Yf_fOdBXli6Rl3Pxs"><img class="hilite" src="https://lh5.googleusercontent.com/-Ez7hyfuTNKY/UuINidlZelI/AAAAAAAAWX0/F1Y7WwMxhLA/s700/bitcoin-wireshark-inv.png" alt="A new block in Bitcoin, as seen in Wireshark." title="A new block in Bitcoin, as seen in Wireshark."/>
</a>
</p><p>
</p><p class="cite">
A new block in Bitcoin, as seen in Wireshark.
</p>
<p>
My transaction was mined by the large GHash.IO mining pool, into block
<a href="https://blockchain.info/block-index/456667">#279068</a> with hash <code><a href="https://coinbase.com/network/blocks/0000000000000001a27b1d6eb8c405410398ece796e742da3b3e35363c2219ee">0000000000000001a27b1d6eb8c405410398ece796e742da3b3e35363c2219ee</a></code>. (The hash is reversed in <i>inv</i> message above: ee19...) Note that the hash starts with a large number of zeros - finding such a literally one in a quintillion value is what makes mining so difficult. This particular block contains 462 transactions, of which my transaction is just one.
</p><p>
For mining this block, the miners received the reward of 25 bitcoins, and total fees of 0.104 bitcoins, approximately $19,000 and $80 respectively. I paid a fee of 0.0001 bitcoins, approximately 8 cents or 10% of my transaction.
The mining process is very interesting, but I'll leave that for a future article.
</p><p>
<a href="http://www.flickr.com/photos/gastev/9305154893/" title="Untitled by Gastev, on Flickr"><img src="http://farm4.staticflickr.com/3780/9305154893_e1b7925728_n.jpg" alt="Untitled"/></a>
</p><div class="cite"><p>
Bitcoin mining normally uses special-purpose ASIC hardware, designed to compute hashes at high speed.
 Photo credit: </p><a href="http://www.flickr.com/photos/gastev/">Gastev</a><p>, </p><a href="http://creativecommons.org/licenses/by/2.0/deed.en">CC:by</a>
</div>
<h2>Conclusion</h2><p>
Using the raw Bitcoin protocol turned out to be harder than I expected, but I learned a lot about bitcoins along the way, and I hope you did too.
My code is purely for demonstration -  if you actually want to use bitcoins through Python, use a real library</p><a class="ref" href="#ref24">[24]</a><p> rather than my code.

</p><h2>Notes and references</h2>
<a name="ref1"/><p>[1]
The original Bitcoin client is </p><a href="http://bitcoin.org/en/download">Bitcoin-qt</a><p>. In case you're wondering why </p><i>qt</i><p>, the client uses the common </p><a href="http://en.wikipedia.org/wiki/Qt_(software)">Qt UI framework</a><p>. Alternatively you can use wallet software that doesn't participate in the peer-to-peer network, such as </p><a href="https://electrum.org//">Electrum</a><p> or </p><a href="https://multibit.org/">MultiBit</a><p>. Or you can use an online wallet such as </p><a href="http://blockchain.info/wallet">Blockchain.info</a><p>.
</p><p>
<a name="ref2"/>[2]
A couple good articles on Bitcoin are <a href="http://bitcoin.org/en/how-it-works">How it works</a> and the very thorough <a href="http://www.michaelnielsen.org/ddi/how-the-bitcoin-protocol-actually-works/">How the Bitcoin protocol actually works</a>.
</p><p>
<a name="ref3"/>[3]
The original Bitcoin paper is <a href="http://www.bitcoin.org/bitcoin.pdf">Bitcoin: A Peer-to-Peer Electronic Cash System</a> written by the pseudonymous Satoshi Nakamoto in 2008. The true identity of Satoshi Nakamoto is unknown, although there are many theories.
</p><p>
<a name="ref4"/>[4]
You may have noticed that sometimes Bitcoin is capitalized and sometimes not. It's not a problem with my shift key - the <a href="https://en.bitcoin.it/wiki/Introduction#Capitalization_.2F_Nomenclature">"official" style</a> is to capitalize <i>Bitcoin</i> when referring to the system, and lower-case <i>bitcoins</i> when referring to the currency units.
</p><p>
<a name="ref5"/>[5]
In case you're wondering how the popular MtGox Bitcoin exchange got its name, it was originally a trading card exchange called "Magic: The Gathering Online Exchange" and later took the acronym as its name.
</p><p>
<a name="ref6"/>[6]
For more information on what data is in the blockchain, see the very helpful article <a href="http://grantammons.me/bitcoin-litecoin-dogecoin-exploring-the-block-chain/?utm_source=hn&amp;utm_medium=web&amp;utm_campaign=hn">Bitcoin, litecoin, dogecoin: How to explore the block chain</a>.
</p><p>
<a name="ref7"/>[7]
I'm not the only one who finds the Bitcoin transaction format inconvenient. For a rant on how messed up it is, see <a href="http://exiledbear.wordpress.com/2013/06/06/criticisms-of-bitcoins-raw-txn-format/">Criticisms of Bitcoin's raw txn format</a>.
</p><p>
<a name="ref8"/>[8]
You can also generate transaction and send raw transactions into the Bitcoin network using the bitcoin-qt console. Type <i>sendrawtransaction a1b2c3d4...</i>. This has the advantage of providing information in the debug log if the transaction is rejected. If you just want to experiment with the Bitcoin network, this is much, much easier than my manual approach.
</p><p>
<a name="ref9"/>[9]
Apparently there's no solid reason to use RIPEMD-160 hashing to create the address and SHA-256 hashing elsewhere, beyond a vague sense that using a different hash algorithm helps security.
See <a href="http://bitcoin.stackexchange.com/questions/9202/why-does-bitcoin-use-two-hash-functions-sha-256-and-ripemd-160-to-create-an-ad">discussion</a>. Using one round of SHA-256 is subject to a <a href="http://en.wikipedia.org/wiki/Length_extension_attack">length extension attack</a>, which explains why double-hashing is used.
</p><p>
<a name="ref10"/>[10]
The Base58Check algorithm is documented on the <a href="https://en.bitcoin.it/wiki/Base58Check_encoding">Bitcoin wiki</a>. It is similar to base 64 encoding, except it omits the O, 0, I, and l characters to avoid ambiguity in printed text. A 4-byte checksum guards against errors, since using an erroneous bitcoin address will cause the bitcoins to be lost forever.
</p><p>
<a name="ref11"/>[11]
Some boilerplate has been removed from the code snippets. For the full Python code, see my repository <a href="https://github.com/shirriff/bitcoin-code">shirriff/bitcoin-code</a> on GitHub. You will also need the <a href="https://pypi.python.org/pypi/ecdsa/0.10">ecdsa cryptography library</a>.
</p><p>
<a name="ref12"/>[12]
You may wonder how I ended up with addresses with nonrandom prefixes such as 1MMMM. The answer is brute force - I ran the address generation script overnight and collected some good addresses. (These addresses made it much easier to recognize my transactions in my testing.) There are <a href="https://en.bitcoin.it/wiki/Vanitygen">scripts</a> and <a href="https://bitcoinvanity.appspot.com/">websites</a> that will generate these "vanity" addresses for you.
</p><p>
<a name="ref13"/>[13]
For a summary of Bitcoin fees, see <a href="http://bitcoinfees.com/">bitcoinfees.com</a>.
This recent <a href="http://www.reddit.com/r/Bitcoin/comments/1s4zdn/it_currently_costs_around_5_to_send_someone/?utm_medium=twitter&amp;utm_source=Fancy+Show+Tech">Reddit discussion of fees</a> is also interesting.
</p><p>
<a name="ref14"/>[14]
The <a href="http://www.bitcoin.org/bitcoin.pdf">original Bitcoin paper</a> has a similar figure showing how transactions are chained together. I find it very confusing though, since it doesn't distinguish between the address and the public key.
</p><p>
<a name="ref15"/>[15]
For details on the different types of contracts that can be set up with Bitcoin, see <a href="https://en.bitcoin.it/wiki/Contracts">Contracts</a>. One interesting type is the <a href="https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki">2-of-3</a> escrow transaction, where two out of three parties must sign the transaction to release the bitcoins. <a href="https://www.bitrated.com/">Bitrated</a> is one site that provides these.
</p><p>
<a name="ref16"/>[16]
Although Bitcoin's Script language is very flexible, the Bitcoin network only permits a few standard transaction types and <a href="http://wiki.betcoin.tm/Nonstandard_block">non-standard transactions</a> are not propagated (<a href="https://bitcointalk.org/index.php?topic=8924.0">details</a>). <a href="https://en.bitcoin.it/wiki/Free_transaction_relay_policy">Some miners</a> will accept non-standard transactions directly, though.
</p><p>
<a name="ref17"/>[17]
There isn't a security benefit from copying the scriptPubKey into the spending transaction before signing since the hash of the original transaction is included in the spending transaction. For discussion, see <a href="https://bitcointalk.org/index.php?topic=102487.msg1123257#msg1123257">Why TxPrev.PkScript is inserted into TxCopy during signature check?</a>
</p><p>
<a name="ref18"/>[18]
The random number used in the elliptic curve signature algorithm is critical to the security of signing. Sony used a constant instead of a random number in the PlayStation 3, allowing the private key to be <a href="http://www.edn.com/design/consumer/4368066/The-Sony-PlayStation-3-hack-deciphered-what-consumer-electronics-designers-can-learn-from-the-failure-to-protect-a-billion-dollar-product-ecosystem">determined</a>. In an incident related to Bitcoin, <a href="http://www.theregister.co.uk/2013/08/12/android_bug_batters_bitcoin_wallets/">a weakness in the random number generator</a> allowed bitcoins to be stolen from Android clients.
</p><p>
<a name="ref19"/>[19]
For Bitcoin, the coordinates on the elliptic curve are integers modulo the <a href="http://www.wolframalpha.com/input/?i=is+2%5E256+-+2%5E32+-+2%5E9+-2%5E8+-+2%5E7+-+2%5E6+-2%5E4+-1+prime">prime</a><i>2^256 - 2^32 - 2^9 -2^8 - 2^7 - 2^6 -2^4 -1</i>, which is very nearly 2^256. This is why the keys in Bitcoin are 256-bit keys.
</p><p>
<a name="ref20"/>[20]
For information on the historical connection between elliptic curves and ellipses (the equation turns up when integrating to compute the arc length of an ellipse) see the interesting article <a href="http://www.maa.org/sites/default/files/pdf/upload_library/2/Rice-2013.pdf">Why Ellipses Are Not Elliptic Curves</a>, Adrian Rice and Ezra Brown, <i>Mathematics Magazine</i>, vol. 85, 2012, pp. 163-176.
For more introductory information on elliptic curve cryptography, see <a href="http://www.certicom.com/index.php/ecc-tutorial">ECC tutorial</a> or <a href="http://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography">A (Relatively Easy To Understand) Primer on Elliptic Curve Cryptography</a>.
For more on the mathematics of elliptic curves, see
<a href="http://www.math.brown.edu/~jhs/Presentations/WyomingEllipticCurve.pdf">An Introduction to the
Theory of Elliptic Curves</a> by Joseph H. Silverman.
<a href="http://www.math.vt.edu/people/brown/doc/ellip.pdf">Three Fermat trails to elliptic curves</a> includes a discussion of how Fermat's Last Theorem was solved with elliptic curves.
</p><p>
<a name="ref21"/>[21]
There doesn't seem to be <a href="http://bitcoin.stackexchange.com/questions/13537/how-do-i-find-out-what-the-latest-protocol-version-is">documentation</a> on the different Bitcoin protocol versions other than the <a href="https://github.com/bitcoin/bitcoin/blob/v0.8.5/src/version.h#L28">code</a>. I'm using version 60002 somewhat arbitrarily.
</p><p>
<a name="ref22"/>[22]
The Wireshark network analysis software can dump out most types of Bitcoin packets, but only if you download a recent <a href="http://samkear.com/networking/analyzing-bitcoin-network-traffic-wireshark&quot;">"beta release</a> - I'm using version 1.11.2.
</p><p>
<a name="ref24"/>[24]
Several Bitcoin libraries in Python are
<a href="https://en.bitcoin.it/wiki/Bitcoin-python">bitcoin-python</a>, <a href="https://github.com/richardkiss/pycoin">pycoin</a>, and
<a href="https://github.com/jgarzik/python-bitcoinlib">python-bitcoinlib</a>.
</p><p>
<a name="ref25"/>[25]
The elliptic curve plot was generated from the <a href="http://www.sagemath.org/">Sage</a> mathematics package:
</p><pre>
var("x y")
implicit_plot(y^2-x^3-7, (x,-10, 10), (y,-10, 10), figsize=3, title="y^2=x^3+7")
</pre>
<p>
<a name="ref26"/>[26]
The hardcoded peer list in the Bitcoin client is in <a href="https://github.com/bitcoin/bitcoin/blob/master/src/chainparams.cpp">chainparams.cpp</a> in the array <i>pnseed</i>.
For more information on finding Bitcoin peers, see <a href="http://bitcoin.stackexchange.com/questions/3536/how-bitcoin-clients-find-each-other">How Bitcoin clients find each other</a> or <a href="https://en.bitcoin.it/wiki/Satoshi_Client_Node_Discovery">Satoshi client node discovery</a>.
</p><p>
</p><p/>
</div>
</div></body></html>