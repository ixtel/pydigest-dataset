<html><body><div><div id="content-container">
	    
	    


<h1>The Bottom-Line Single Main Difference Between Python 2 and 3</h1>
<p class="originally">Originally published in the <a href="/python-newsletter/">Advanced Python Newsletter</a></p>


<p>"How is Python 3 different from Python 2?"</p>

<p>An excellent question. A hard one, too.  Python 3 has
<em>hundreds</em> of improvements compared to the last Python 2.  Some
of these may matter to you a lot. It's possible most won't matter to
you at all.</p>

<p>Which are which? I have no idea.</p>

<p>But I can bottom line it for you.</p>

<p>We can summarize all the ways Python 3 differs from 2.7 - digest
all the things that are new in 3, and will now <em>never</em> be
backported to 2 - in one sentence:</p>

<p><strong>Python 3 makes it easier to develop high quality
software.</strong></p>

<p>"High quality" means software that is:</p>
<ul>
    <li>Less prone to hidden or tricky bugs - i.e., robust and reliable;</li>
    <li>More straightforward to change over time - in other words, maintainable; and</li>
    <li>Simpler to troubleshoot and fix when things
    <em>do</em> go wrong.</li>
</ul>

<p>You can, of course, create high quality software in Python 2. But
the two hundred-ish improvements in Python 3 generally make it easier
to do so. Here are three examples.</p>

<h2>Evading the Worst Kind of Bug</h2>

<p>Imagine a class representing an angle, in the range of 0
to 360 degrees:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="o">&gt;&gt;&gt;</span> <span class="c"># Python 2 code.</span>
</p></li><li><p class="line"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">TrickyAngle</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</p></li><li><p class="line"><span class="o">...</span>     <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">):</span>
</p></li><li><p class="line"><span class="o">...</span>         <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span>  <span class="n">degrees</span> <span class="o">%</span> <span class="mi">360</span>
</p></li><li><p class="line"><span class="o">...</span>
</p></li><li><p class="line"><span class="o">&gt;&gt;&gt;</span> <span class="n">TrickyAngle</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">TrickyAngle</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</p></li><li><p class="line"><span class="bp">True</span>
</p></li><li><p class="line"><span class="o">&gt;&gt;&gt;</span> <span class="n">TrickyAngle</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">TrickyAngle</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</p></li><li><p class="line"><span class="bp">False</span>
</p></li></ol></pre></div>



<p>Whoa, what just happened? The same char-for-char expression,
<code>TrickyAngle(6) , evaluated twice,
produces two completely opposite values. In Python 2, if you forget to
define the <code>__lt__</code> method on your class, the comparison
falls back to using the object's ID. <em>This is effectively a random
integer</em>. Whether you get True or False is like tossing a coin:
</code></p>



<div class="highlight"><pre><ol><li><p class="line"><span class="c"># In Python 2...</span>
</p></li><li><p class="line"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">TrickyAngle</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span> <span class="n">TrickyAngle</span><span class="p">(</span><span class="mi">84</span><span class="p">)</span>
</p></li><li><p class="line"><span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</p></li><li><p class="line"><span class="p">(</span><span class="mi">4518897296</span><span class="p">,</span> <span class="mi">4518897232</span><span class="p">)</span>
</p></li><li><p class="line"><span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</p></li><li><p class="line"><span class="bp">False</span>
</p></li><li><p class="line"><span class="o">&gt;&gt;&gt;</span>
</p></li><li><p class="line"><span class="o">&gt;&gt;&gt;</span> <span class="c"># Exact same code - run it again...</span>
</p></li><li><p class="line"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">TrickyAngle</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span> <span class="n">TrickyAngle</span><span class="p">(</span><span class="mi">84</span><span class="p">)</span>
</p></li><li><p class="line"><span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</p></li><li><p class="line"><span class="p">(</span><span class="mi">4518897040</span><span class="p">,</span> <span class="mi">4518897104</span><span class="p">)</span>
</p></li><li><p class="line"><span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</p></li><li><p class="line"><span class="bp">True</span>
</p></li></ol></pre></div>



<p><strong>This is the worst kind of bug.</strong> It's the kind that
<em>easily</em> sneaks its way past the most vigilant unit tests, even rigorous
manual testing, all the way into the deployed, production code
base. And you won't even know it's there, until your most valued clients are
screaming at you.
</p>

<p>If that's the worst kind of bug, what's the <em>best</em> kind? The
kind that immediately, unambiguously, loudly announces its presence,
in a way that is impossible to miss:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="o">&gt;&gt;&gt;</span> <span class="c"># Python 3 code.</span>
</p></li><li><p class="line"><span class="o">...</span> <span class="k">class</span> <span class="nc">TrickyAngle</span><span class="p">:</span>
</p></li><li><p class="line"><span class="o">...</span>     <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">):</span>
</p></li><li><p class="line"><span class="o">...</span>         <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span>  <span class="n">degrees</span> <span class="o">%</span> <span class="mi">360</span>
</p></li><li><p class="line"><span class="o">...</span>
</p></li><li><p class="line"><span class="o">&gt;&gt;&gt;</span> <span class="n">TrickyAngle</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">TrickyAngle</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</p></li><li><p class="line"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</p></li><li><p class="line">  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</p></li><li><p class="line"><span class="ne">TypeError</span><span class="p">:</span> <span class="n">unorderable</span> <span class="n">types</span><span class="p">:</span> <span class="n">TrickyAngle</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">TrickyAngle</span><span class="p">()</span>
</p></li></ol></pre></div>



<p>That's right: in Python 3, comparing two objects raises a
<code>TypeError</code> by default, until you explicitly define an
ordering.</p>

<p>This one change is representative of a large class of subtle
semantic improvements in Python 3, each of which eliminates many
potential bugs. Imagine how much debugging time and frustration they
save.</p>

<h2>Streamlined super()</h2>

<p>I'll assume you know about Python's built-in <code>super()</code>
function. It's used in methods, to call a method in the parent
class. In Python 2, you use it like this:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="kn">import</span> <span class="nn">json</span>
</p></li><li><p class="line"><span class="k">class</span> <span class="nc">Config</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</p></li><li><p class="line">    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config_dict</span><span class="p">):</span>
</p></li><li><p class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">config_dict</span>
</p></li><li><p class="line">
</p></li><li><p class="line"><span class="k">class</span> <span class="nc">ClientConfig</span><span class="p">(</span><span class="n">Config</span><span class="p">):</span>
</p></li><li><p class="line">    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_config_file</span><span class="p">):</span>
</p></li><li><p class="line">        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_config_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
</p></li><li><p class="line">            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>
</p></li><li><p class="line">        <span class="nb">super</span><span class="p">(</span><span class="n">ClientConfig</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</p></li></ol></pre></div>



<p>Whenever you call <code>super()</code>, you have to pass in two
arguments. These parameters are useful in multiple inheritance, to
make your classes cooperate. But in the <em>much more common</em> case
of single inheritance, typing in <code>ClientConfig</code> and
<code>self</code> are redundant. That's why in Python 3,
you can omit them both:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="k">class</span> <span class="nc">ClientConfig</span><span class="p">(</span><span class="n">Config</span><span class="p">):</span>
</p></li><li><p class="line">    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_config_file</span><span class="p">):</span>
</p></li><li><p class="line">        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_config_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
</p></li><li><p class="line">            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>
</p></li><li><p class="line">        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c"># &lt;---- Shorter!</span>
</p></li></ol></pre></div>



<p>This has two benefits. The first, obvious one is that if the name
of <code>ClientConfig</code> changes, the call to <code>super()</code>
need not be modified. A small but real maintainability benefit, right there.
</p>

<p>There's also a more immediate, cognitive benefit: you don't have to
think as much when typing out the <code>super</code> line. In Python
2, I always have to take a moment to remember the order of the
arguments, or even look it up. (Is it <code>super(MyClass,
self)</code> or <code>super(self, MyClass)</code>?)  And I have to
glance up at what current class I'm in, if I don't immediately recall
its name.</p>

<p>Running into this just once this doesn't drain much mental
energy. But when you're deep in your focus of coding, even the
smallest distraction can disrupt the pictures you're holding in your
mind; having the freedom to just type "<code>super()</code>" in that
moment can help maintain your flow. Multiplying over every time you
use <code>super</code>, and other improvements like this in Python
3, compounds the effect.</p>

<h2>Unmasked Exceptions</h2>

<p>Suppose you have the following class:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="c"># Valid in both Python 2 and 3.</span>
</p></li><li><p class="line"><span class="k">class</span> <span class="nc">DataSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</p></li><li><p class="line">    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
</p></li><li><p class="line">        <span class="c"># data is of type list.</span>
</p></li><li><p class="line">        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
</p></li><li><p class="line">    <span class="k">def</span> <span class="nf">mean_of_positives</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</p></li><li><p class="line">        <span class="sd">'''</span>
</p></li><li><p class="line"><span class="sd">        Return average of *positive* elements in data set.</span>
</p></li><li><p class="line"><span class="sd">        '''</span>
</p></li><li><p class="line">	<span class="c"># (I'll tell you what's in here momentarily.)</span>
</p></li><li><p class="line">    <span class="k">def</span> <span class="nf">record_first_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest_path</span><span class="p">):</span>
</p></li><li><p class="line">        <span class="sd">'''</span>
</p></li><li><p class="line"><span class="sd">        Sample the current data set by writing</span>
</p></li><li><p class="line"><span class="sd">        first element to a log file.</span>
</p></li><li><p class="line"><span class="sd">        '''</span>
</p></li><li><p class="line">	<span class="c"># (Again, be patient.)</span>
</p></li><li><p class="line">
</p></li><li><p class="line"><span class="c"># Now, somewhere in your application:</span>
</p></li><li><p class="line"><span class="n">dataset</span> <span class="o">=</span> <span class="n">DataSet</span><span class="p">(</span><span class="n">initial_data</span><span class="p">)</span>
</p></li><li><p class="line"><span class="k">try</span><span class="p">:</span>
</p></li><li><p class="line">    <span class="n">posmean</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">mean_of_positives</span><span class="p">()</span>
</p></li><li><p class="line"><span class="k">finally</span><span class="p">:</span>
</p></li><li><p class="line">    <span class="n">dataset</span><span class="o">.</span><span class="n">record_first_element</span><span class="p">(</span><span class="n">sample_file</span><span class="p">)</span>
</p></li></ol></pre></div>



<p>Now suppose the code above is run under Python 2.7, and you see the
following traceback:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</p></li><li><p class="line">  <span class="n">File</span> <span class="s">"chaining.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">25</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</p></li><li><p class="line">    <span class="n">dataset</span><span class="o">.</span><span class="n">record_first_element</span><span class="p">(</span><span class="n">sample_file</span><span class="p">)</span>
</p></li><li><p class="line">  <span class="n">File</span> <span class="s">"chaining.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">16</span><span class="p">,</span> <span class="ow">in</span> <span class="n">record_first_element</span>
</p></li><li><p class="line">    <span class="n">dest</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s">','</span><span class="p">)</span>
</p></li><li><p class="line"><span class="ne">IndexError</span><span class="p">:</span> <span class="nb">list</span> <span class="n">index</span> <span class="n">out</span> <span class="n">of</span> <span class="nb">range</span>
</p></li></ol></pre></div>



<p>Pop quiz: what method of <code>DataSet</code> triggered an
exception?</p>

<p>Got it? Look carefully. Are you <em>sure?</em></p>

<p>It turns out there are <em>two different exceptions</em> raised
here. In Python 2, the <code>IndexError</code> is the second, and
fully masks the first one. But in Python 3, all is revealed:</p>


<div class="highlight"><pre><ol><li><p class="line"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</p></li><li><p class="line">  <span class="n">File</span> <span class="s">"chaining.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">23</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</p></li><li><p class="line">    <span class="n">posmean</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">mean_of_positives</span><span class="p">()</span>
</p></li><li><p class="line">  <span class="n">File</span> <span class="s">"chaining.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">12</span><span class="p">,</span> <span class="ow">in</span> <span class="n">mean_of_positives</span>
</p></li><li><p class="line">    <span class="k">return</span> <span class="n">total</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">positives</span><span class="p">)</span>
</p></li><li><p class="line"><span class="ne">ZeroDivisionError</span><span class="p">:</span> <span class="nb">float</span> <span class="n">division</span> <span class="n">by</span> <span class="n">zero</span>
</p></li><li><p class="line">
</p></li><li><p class="line"><span class="n">During</span> <span class="n">handling</span> <span class="n">of</span> <span class="n">the</span> <span class="n">above</span> <span class="n">exception</span><span class="p">,</span> <span class="n">another</span> <span class="n">exception</span> <span class="n">occurred</span><span class="p">:</span>
</p></li><li><p class="line">
</p></li><li><p class="line"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</p></li><li><p class="line">  <span class="n">File</span> <span class="s">"chaining.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">25</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</p></li><li><p class="line">    <span class="n">dataset</span><span class="o">.</span><span class="n">record_first_element</span><span class="p">(</span><span class="n">sample_file</span><span class="p">)</span>
</p></li><li><p class="line">  <span class="n">File</span> <span class="s">"chaining.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">16</span><span class="p">,</span> <span class="ow">in</span> <span class="n">record_first_element</span>
</p></li><li><p class="line">    <span class="n">dest</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s">','</span><span class="p">)</span>
</p></li><li><p class="line"><span class="ne">IndexError</span><span class="p">:</span> <span class="nb">list</span> <span class="n">index</span> <span class="n">out</span> <span class="n">of</span> <span class="nb">range</span>
</p></li></ol></pre></div>



<p>In the <code>try</code> block, <code>mean_of_positives</code>
raises a <code>ZeroDivisionError</code>. Before bubbling up,
execution jumps to the <code>finally</code> block, where
<code>record_first_element</code> raises <code>IndexError</code>.</p>

<p>Python 3's way of handling the situation is called <em>exception
chaining</em>. There are steps you can take to implement this manually,
but Python 3 gives it to you for free, so to speak.</p>

<p>This benefits your development process in obvious ways. One that
may not be obvious: if your long-running application is properly
logging exceptions, this can <em>massively</em> assist with
troubleshooting rare bugs that are hard to reproduce. Exception
chaining tells you about <em>everything</em> that went
wrong, not just the <em>last</em> thing.</p>

<h2>All Else Being ==</h2>

<p>All else being equal, Python 3 makes it easier to write high
quality software than Python 2.  These are three changes enabling
that, and <a href="/whats-really-new-in-python-3/">there are
hundreds more.</a></p>

<p>Of course, things are <em>not</em> all equal. If you're starting a
brand-new application today, there are plenty of valid reasons to
write it in 2 instead of 3. There will be for a long time.</p>

<p>And if you have a large existing code base, you <em>definitely</em>
want to carefully consider before dropping everything to port it to the
new major version. Python 3 brings many benefits, but switching to it
does have a cost in time and energy.</p>

<p>There's another aspect to all this. The examples above don't convey
the new syntax, core language enhancements, and modules exclusively
available in Python 3...  enabling expressive new patterns, and making
a real impact on development speed and productivity. In other words,
<em>Python 3 is a more powerful and expressive language as a
whole</em>. </p>

<p>That tends to make the language more of a
joy to work with. Which arguably doesn't matter professionally. But as a
developer, it might matter to you personally.</p>

<p>In any event, just keep your eyes open, so you can make the
authentically best decision for you and your team. And whatever you
do, write the best software you can!</p>

<p>Thanks to <a href="https://twitter.com/simeonfranklin">Simeon
Franklin</a> for feedback on a draft of this article.</p>



	</div> 

    </div></body></html>