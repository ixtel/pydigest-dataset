<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/getpro/habr/post_images/d43/bf5/9df/d43bf59dfda401624ee4ad5a80b82f8a.png" alt="image"/>

<div class="spoiler"><b class="spoiler_title">От переводчика</b><div class="spoiler_text"><p>Весьма вольный перевод серии </p><a href="http://akaptur.github.io/blog/2013/11/15/introduction-to-the-python-interpreter/">из</a> <a href="http://akaptur.github.io/blog/2013/11/15/introduction-to-the-python-interpreter-2/">трёх</a> <a href="http://akaptur.github.io/blog/2013/11/17/introduction-to-the-python-interpreter-3/">статей</a><p> об устройстве питоновского интерпретатора. Автор занимается разработкой собственного велосипеда по этой теме и решил поделиться знаниями, появившимися в процессе. Посмотрим, что у него из этого получилось.</p></div></div>
<p>
Данная серия статей рассчитана на тех, кто умеет писать на python в целом, но плохо представляет как этот язык устроен изнутри. Собственно, как и я три месяца назад.
</p><p>
Небольшой дисклеймер: свой рассказ я буду вести на примере интерпретатора python 2.7. Всё, о чем пойдёт речь далее, можно повторить и на python 3.x с поправкой на некоторые различия в синтаксисе и именование некоторых функций.
</p><p>
Итак, начнём.
</p><a name="habracut"/>
<h1>Часть I. Слушай Питон, а что у тебя внутри?</h1>
<p>
Начнём с немного (на самом деле, с сильно) высокоуровневого взгляда на то, что же из себя представляет наша любимая змея. Что происходит, когда вы набираете строку подобную этой в интерактивном интерпретаторе?

</p><pre><code class="python">&gt;&gt;&gt; a = "hello"
</code></pre>
<p>
Ваш палец падает на enter и питон инициирует 4 следующих процесса: </p><a href="http://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7">лексический анализ</a><p>, </p><a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7">парсинг</a><p>, </p><a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29">компиляцию</a><p> и непосредственно </p><a href="http://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D1%80%D0%B5%D1%82%D0%B0%D1%86%D0%B8%D1%8F_%28%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0%29">интерпретацию</a><p>. Лексический анализ – это процесс разбора набранной вами строки кода в определенную последовательность символов, называемых токенами. Далее парсер на основе этих токенов генерирует структуру, которая отображает взаимоотношения между входящими в неё элементами (в данном случае, структура это </p><a href="http://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE">абстрактное синтаксическое древо</a><p> или АСД). Далее, используя АСД, компилятор создаёт один или несколько объектных модулей и передаёт их в интерпретатор для непосредственного выполнения.
</p><p>
Я не буду углубляться в темы лексического анализа, парсинга и компиляции, в основном потому, что сам не имею о них ни малейшего представления. Вместо этого, давайте лучше представим, что умные люди сделали всё как надо и данные этапы в питоновском интерпретаторе отрабатывают без ошибок. Представили? Двигаем дальше.
</p><p>
Прежде чем перейти к </p><a href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B9_%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C">объектным модулям</a><p> (или объектам кода, или объектным файлам), следует кое-что прояснить. В данной серии статей мы будем говорить об объектах функций, объектных модулях и </p><a href="http://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B9%D1%82%D0%BA%D0%BE%D0%B4">байткоде</a><p> – всё это совершенно разные, хоть и некоторым образом связанные между собой понятия. Хотя нам и необязательно знать, что такое объекты функций для понимания интерпретатора, но я всё же хотел бы остановить на них ваше внимание. Не говоря уже о том, что они попросту крутые.
</p><p>
Итак,

</p><h3>Объекты функций или функции, как объекты</h3>
<p>
Если это не первая ваша статья о программировании на питоне, вы должны быть наслышаны о неких «объектах функций». Это именно о них люди с умным видом рассуждают в контексте разговоров о «функциях, как </p><a href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0">объектах первого класса</a><p>» и «наличии </p><a href="http://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0">функций первого класса</a><p> в питоне». Рассмотрим следующий пример:

</p><pre><code class="python">&gt;&gt;&gt; def foo(a):
...     x = 3
...     return x + a
...
&gt;&gt;&gt; foo
&lt;function foo at 0x107ef7aa0&gt;
</code></pre>
<p>
Выражение «функции – это объекты первого класса» означает, что функции – это объекты </p><s>первого класса</s><p>, в том смысле, в коем и списки – это объекты, и экземпляр класса </p><code>MyObject</code><p> – объект. И так как foo это объект, он имеет значимость сам по себе, безотносительно вызова его, как функции (то есть, </p><code>foo</code><p> и </p><code>foo()</code><p> — это разные вещи). Мы можем передать </p><code>foo</code><p> в другую функцию в качестве аргумента, можем переназначить её на новое имя (</p><code>other_function = foo</code><p>). С функциями первого класса можно делать, что угодно и они всё стерпят.

</p><h1>Часть II. Объектные модули</h1>
<p>
На данном этапе we need to go deeper, чтобы узнать, что объект функции в свою очередь содержит объект кода:

</p><pre><code class="python">&gt;&gt;&gt; def foo(a):
...     x = 3
...     return x + a
...
&gt;&gt;&gt; foo
&lt;function foo at 0x107ef7aa0&gt;
&gt;&gt;&gt; foo.func_code
&lt;code object foo at 0x107eeccb0, file "&lt;stdin&gt;", line 1&gt;
</code></pre>
<p>
Как видно из приведённого листинга, объектный модуль является атрибутом объекта функции (у которого есть и множество других атрибутов, но в данном случае особого интереса они не представляют в силу простоты </p><code>foo</code><p>).
</p><p>
Объектный модуль генерируется питоновским компилятором и далее передаётся интерпретатору. Модуль содержит всю необходимую для выполнения информацию. Давайте посмотрим на его атрибуты:

</p><pre><code class="python">&gt;&gt;&gt; dir(foo.func_code)
['__class__', '__cmp__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__',
'__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__ne__', '__new__',
'__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__',
'__subclasshook__', 'co_argcount', 'co_cellvars', 'co_code', 'co_consts', 'co_filename',
'co_firstlineno', 'co_flags', 'co_freevars', 'co_lnotab', 'co_name', 'co_names', 'co_nlocals',
'co_stacksize', 'co_varnames']
</code></pre>
<p>
Их, как видите, немало, поэтому все рассматривать не будем, для примера остановимся на трёх наиболее понятных:

</p><pre><code class="python">&gt;&gt;&gt; foo.func_code.co_varnames
('a', 'x')
&gt;&gt;&gt; foo.func_code.co_consts
(None, 3)
&gt;&gt;&gt; foo.func_code.co_argcount
1
</code></pre>
<p>
Атрибуты выглядят довольно интуитивно:
</p><code>co_varnames</code><p> – имена переменных
</p><code>co_consts</code><p> – значения, о которых знает функция
</p><code>co_argcount</code><p> – количество аргументов, которые функция принимает
</p><p>
Всё это весьма познавательно, но выглядит несколько черезчур высокоуровнево для нашей темы, не правда ли? Где же инструкции интерпретатору для непосредственного выполнения нашего модуля? А такие инструкции есть и представлены они байткодом. Последний также является атрибутом объектного модуля:

</p><pre><code class="python">&gt;&gt;&gt; foo.func_code.co_code 'd\x01\x00}\x01\x00|\x01\x00|\x00\x00\x17S'
</code></pre>
<p>
Что за неведомая байтовая фигня, спросите вы?

</p><h1>Часть III. Байткод</h1>
<p>
Вы наверное и сами понимаете, но я, на всякий случай, озвучу – «байткод» и «объект кода» это разные вещи: первый является атрибутом второго, среди многих других (см. часть 2). Атрибут называется </p><code>co_code</code><p> и содержит все необходимые инструкции для выполнения интерпретатором.
</p><p>
Что же из себя представляет этот байткод? Как следует из названия, это просто последовательность байтов. При выводе в консоль выглядит она достаточно бредово, поэтому давайте приведём её к числовой последовательности, пропустив через </p><code>ord</code><p>:

</p><pre><code class="python">&gt;&gt;&gt; [ord(b) for b in foo.func_code.co_code] [100, 1, 0, 125, 1, 0, 124, 1, 0, 124, 0, 0, 23, 83]
</code></pre>
<p>
Таким образом мы получили числовое представление питоновского байткода. Интерпретатор пройдётся по каждому байту в последовательности и выполнит связанные с ним инструкции. Обратите внимание, что байткод сам по себе не содержит питоновских объектов, ссылок на объекты и т.п.
</p><p>
Байткод можно попытаться понять открыв файл интерпретатора CPython (ceval.c), но мы этого делать не будем. Точнее будем, но позже. Сейчас же пойдём простым путём и воспользуемся модулем </p><code>dis</code><p> из стандартной библиотеки.

</p><h3>Дизассемблируй это</h3>
<p>
Дизассемблирование – это перевод байтовой последовательности в нечто более понятное человеческому разуму. Для этой цели в питоне существует модуль </p><code>dis</code><p>, который подробно покажет вам всё, что скрыто. У модуля нет особого применения в продакшн-коде, результаты его работы нужны только вам, не интерпретатору.
</p><p>
Итак, давайте применим </p><code>dis</code><p> и снимем паранжу с нашего объектного модуля. Для этого воспользуемся функцией </p><code>dis.dis</code><p>:

</p><pre><code class="python">&gt;&gt;&gt; def foo(a):
...     x = 3
...     return x + a
...
&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(foo.func_code)
  2           0 LOAD_CONST               1 (3)
              3 STORE_FAST               1 (x)

  3           6 LOAD_FAST                1 (x)
              9 LOAD_FAST                0 (a)
             12 BINARY_ADD
             13 RETURN_VALUE
</code></pre>

<div class="spoiler"><b class="spoiler_title">Скрытый текст</b><p class="spoiler_text">Зачастую можно видеть записи вида <code>dis.dis(foo)</code>, т.е. объект функции передаётся в дизассемблер напрямую. Это сделано для удобства, под капотом dis всё равно находит и анализирует <code>func_code</code>. В нашем примере мы передаём объект кода явно для лучшего понимания процесса.</p></div>
<p>
Числа в первой колонке – это номера строк анализируемых исходников. Вторая колонка отражает смещение команд в байткоде: </p><code>LOAD_CONST</code><p> находится в позиции «0», </p><code>STORE_FAST</code><p> в позиции «3» и т.д. Третья колонка даёт байтовым инструкциям человекопонятные названия. Названия эти нужны только </p><s>жалким людишкам</s><p> нам, в интерпретаторе они не используются.
</p><p>
Две последние колонки содержат подробности об аргументах для данной команды, если таковые имеются. Четвёртая колонка отражает позицию аргумента в атрибуте объектного модуля. В нашем примере аргумент инструкции </p><code>LOAD_CONST</code><p> находится на первой позиции атрибута-списка co_consts, аргумент </p><code>STORE_FAST</code><p> – на первой позиции </p><code>co_varnames</code><p>. Наконец, в пятой колонке </p><code>dis</code><p> отражает значение или название соответствующей переменной. Убедимся в сказанном на практике:

</p><pre><code class="python">&gt;&gt;&gt; foo.func_code.co_consts[1]
3
&gt;&gt;&gt; foo.func_code.co_varnames[1]
'x'
</code></pre>
<p>
Это также объясняет, почему инструкция </p><code>STORE_FAST</code><p> находится на третьей позиции в байткоде: если где-то в байткоде есть аргумент, следующие два байта будут представлять этот аргумент. Корректная обработка таких ситуаций также ложится на плечи интерпретатора.

</p><div class="spoiler"><b class="spoiler_title">Хинт</b><p class="spoiler_text">Если вас вдруг удивило отсутствие аргументов у <code>BINARY_ADD</code> – возьмите печеньку за внимательность, но не беспокойтесь раньше времени. Мы вернёмся к этому моменту чуть позже, когда разговор пойдёт о самом интерпретаторе.</p></div>
<p>
Как </p><code>dis</code><p> переводит байты (например, 100) в осмысленные имена (например, </p><code>LOAD_CONST</code><p>) и наоборот? Подумайте, как бы вы сами организовали подобную систему? Если у вас появились мысли, вроде «ну, может там есть какой-то список с последовательным определением байтов» или «по-любому словарь с названиями инструкций в качестве ключей и байтами как значениями», поздравляю – вы абсолютно правы. Именно так всё и устроено. Сами определения происходят в файле opcode.py (можно также посмотреть заголовочный файл opcode.h), где вы сможете увидеть ~полторы сотни подобных строк:

</p><pre><code class="python">def_op('LOAD_CONST', 100)       # Index in const list
def_op('BUILD_TUPLE', 102)      # Number of tuple items
def_op('BUILD_LIST', 103)       # Number of list items
def_op('BUILD_SET', 104)        # Number of set items
</code></pre>
<p>
(Какой-то любитель комментариев заботливо оставил нам пояснения к инструкциям.)
</p><p>
Теперь мы имеем некоторое представление о том, чем является (и чем не является) байткод и как использовать </p><code>dis</code><p> для его анализа. В следующих частях мы рассмотрим, как питон может компилироваться в байткод, оставаясь при этом динамическим ЯП.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>