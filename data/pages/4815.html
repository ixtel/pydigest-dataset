<html><body><div><div class="entry-content">
<footer class="post-info">
        <span>Fri 05 June 2015</span>

</footer>      <p>One of the main goals of the entire KivEnt framework is to allow you to write 
tight update loops for your game systems that avoid touching python objects
as much as possible, while still maintaining a fairly pythonic approach to 
writing your update code. One of the advantages of cython here is that we can
freely use Python if we want, or if we are perhaps transitioning from pure 
python code. </p>
<p>However, there is a cost to making use of Python objects in your code and it is 
larger than I expected. For a while now, there has been a small section of code
in the Renderer.update function that indexes into a python list per entity. It 
has been on my list to replace with something that doesn't use python, but I was 
waiting to redo the way we were handling model data entirely.</p>
<p>Anyway, I finally got around to making the changes and I am astounded by the 
performance increase I have observed. Using the 3_creating_a_gamesystem example
from KivEnt and drawing 30,000 entities on my computer I get the following
profiling results:</p>
<p>Old Method:</p>
<div class="highlight"><pre><span class="n">Runtime</span><span class="o">:</span> <span class="mf">12.260</span> <span class="n">seconds</span>
   <span class="n">ncalls</span>  <span class="n">tottime</span>  <span class="n">percall</span>  <span class="n">cumtime</span>  <span class="n">percall</span> <span class="n">filename</span><span class="o">:</span><span class="n">lineno</span><span class="o">(</span><span class="kd">function</span><span class="o">)</span>
      <span class="mi">161</span>    <span class="mf">6.177</span>    <span class="mf">0.038</span>    <span class="mf">6.180</span>    <span class="mf">0.038</span> <span class="n">kivent_core</span><span class="o">\</span><span class="n">systems</span><span class="o">\</span><span class="n">renderers</span><span class="o">.</span><span class="na">pyx</span><span class="o">:</span><span class="mi">521</span><span class="o">(</span><span class="n">update</span><span class="o">)</span>
      <span class="mi">161</span>    <span class="mf">1.701</span>    <span class="mf">0.011</span>    <span class="mf">7.882</span>    <span class="mf">0.049</span> <span class="n">kivent_core</span><span class="o">\</span><span class="n">gameworld</span><span class="o">.</span><span class="na">pyx</span><span class="o">:</span><span class="mi">421</span><span class="o">(</span><span class="n">update</span><span class="o">)</span>
    <span class="mi">30000</span>    <span class="mf">0.618</span>    <span class="mf">0.000</span>    <span class="mf">1.295</span>    <span class="mf">0.000</span> <span class="n">kivent_core</span><span class="o">\</span><span class="n">gameworld</span><span class="o">.</span><span class="na">pyx</span><span class="o">:</span><span class="mi">346</span><span class="o">(</span><span class="n">init_entity</span><span class="o">)</span>
</pre></div>


<p>As you can see the update function with 30,000 entities is taking up the
majority of the update time for the entire frame, and taking much too long to 
be running at 60 fps (entire game must update in under &lt; .016 ms).</p>
<p>New Method:</p>
<div class="highlight"><pre><span class="n">Runtime</span><span class="o">:</span> <span class="mf">10.595</span> <span class="n">seconds</span>
   <span class="n">ncalls</span>  <span class="n">tottime</span>  <span class="n">percall</span>  <span class="n">cumtime</span>  <span class="n">percall</span> <span class="n">filename</span><span class="o">:</span><span class="n">lineno</span><span class="o">(</span><span class="kd">function</span><span class="o">)</span>
      <span class="mi">497</span>    <span class="mf">1.553</span>    <span class="mf">0.003</span>    <span class="mf">2.007</span>    <span class="mf">0.004</span> <span class="n">kivent_core</span><span class="o">\</span><span class="n">gameworld</span><span class="o">.</span><span class="na">pyx</span><span class="o">:</span><span class="mi">436</span><span class="o">(</span><span class="n">update</span><span class="o">)</span>
    <span class="mi">30000</span>    <span class="mf">0.636</span>    <span class="mf">0.000</span>    <span class="mf">1.364</span>    <span class="mf">0.000</span> <span class="n">kivent_core</span><span class="o">\</span><span class="n">gameworld</span><span class="o">.</span><span class="na">pyx</span><span class="o">:</span><span class="mi">361</span><span class="o">(</span><span class="n">init_entity</span><span class="o">)</span>
      <span class="mi">497</span>    <span class="mf">0.443</span>    <span class="mf">0.001</span>    <span class="mf">0.452</span>    <span class="mf">0.001</span> <span class="n">kivent_core</span><span class="o">\</span><span class="n">systems</span><span class="o">\</span><span class="n">renderers</span><span class="o">.</span><span class="na">pyx</span><span class="o">:</span><span class="mi">492</span><span class="o">(</span><span class="n">update</span><span class="o">)</span>
</pre></div>


<p>Huge improvement! We are now capable of easily running at 60 fps, and are only using 
25% of the frametime available. This leaves a lot of time for performing more 
game logic. So what is going on in this particular case?</p>
<h1>The Implementation</h1>
<p>Let's take a look at the old update function, the key line to look at is Line 
43 where we index into the meshes list using the index of the model stored in 
the RenderStruct. If you would like an indepth introduction to how the update
function of Renderer works <a href="https://github.com/kivy/kivent/wiki/Getting-Started-6:-Creating-a-Renderer">read here</a></p>
<p>Old code:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">IndexedBatch</span> <span class="nf">batch</span>
    <span class="k">cdef</span> <span class="kt">list</span> <span class="nf">batches</span>
    <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">batch_key</span>
    <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">index_offset</span><span class="p">,</span> <span class="nf">vert_offset</span>
    <span class="k">cdef</span> <span class="kt">RenderStruct</span>* <span class="nf">render_comp</span>
    <span class="k">cdef</span> <span class="kt">PositionStruct2D</span>* <span class="nf">pos_comp</span>
    <span class="k">cdef</span> <span class="kt">VertexFormat4F</span>* <span class="nf">frame_data</span>
    <span class="k">cdef</span> <span class="kt">GLushort</span>* <span class="nf">frame_indices</span>
    <span class="k">cdef</span> <span class="kt">VertMesh</span> <span class="nf">vert_mesh</span>
    <span class="k">cdef</span> <span class="kt">float</span>* <span class="nf">mesh_data</span>
    <span class="k">cdef</span> <span class="kt">VertexFormat4F</span>* <span class="nf">vertex</span>
    <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="kt">short</span>* <span class="nf">mesh_indices</span>
    <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">used</span><span class="p">,</span> <span class="nf">i</span><span class="p">,</span> <span class="nf">real_index</span><span class="p">,</span> <span class="nf">component_count</span>

    <span class="k">cdef</span> <span class="kt">ComponentPointerAggregator</span> <span class="nf">entity_components</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">attribute_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attribute_count</span>
    <span class="k">cdef</span> <span class="kt">BatchManager</span> <span class="nf">batch_manager</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_manager</span>
    <span class="k">cdef</span> <span class="kt">dict</span> <span class="nf">batch_groups</span> <span class="o">=</span> <span class="n">batch_manager</span><span class="o">.</span><span class="n">batch_groups</span>
    <span class="k">cdef</span> <span class="kt">list</span> <span class="nf">meshes</span> <span class="o">=</span> <span class="n">model_manager</span><span class="o">.</span><span class="n">meshes</span>
    <span class="k">cdef</span> <span class="kt">CMesh</span> <span class="nf">mesh_instruction</span>
    <span class="k">cdef</span> <span class="kt">MemoryBlock</span> <span class="nf">components_block</span>
    <span class="k">cdef</span> <span class="kt">void</span>** <span class="nf">component_data</span>

    <span class="k">for</span> <span class="n">batch_key</span> <span class="ow">in</span> <span class="n">batch_groups</span><span class="p">:</span>
        <span class="n">batches</span> <span class="o">=</span> <span class="n">batch_groups</span><span class="p">[</span><span class="n">batch_key</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">batches</span><span class="p">:</span>

            <span class="n">entity_components</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="n">entity_components</span>
            <span class="n">components_block</span> <span class="o">=</span> <span class="n">entity_components</span><span class="o">.</span><span class="n">memory_block</span>
            <span class="n">used</span> <span class="o">=</span> <span class="n">components_block</span><span class="o">.</span><span class="n">used_count</span>
            <span class="n">component_count</span> <span class="o">=</span> <span class="n">entity_components</span><span class="o">.</span><span class="n">count</span>
            <span class="n">component_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">void</span><span class="o">**&gt;</span><span class="n">components_block</span><span class="o">.</span><span class="n">data</span>
            <span class="n">frame_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">VertexFormat4F</span><span class="o">*&gt;</span><span class="n">batch</span><span class="o">.</span><span class="n">get_vbo_frame_to_draw</span><span class="p">()</span>
            <span class="n">frame_indices</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLushort</span><span class="o">*&gt;</span><span class="n">batch</span><span class="o">.</span><span class="n">get_indices_frame_to_draw</span><span class="p">()</span>
            <span class="n">index_offset</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">used</span><span class="p">):</span>
                <span class="n">real_index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">component_count</span>
                <span class="k">if</span> <span class="n">component_data</span><span class="p">[</span><span class="n">real_index</span><span class="p">]</span> <span class="o">==</span> <span class="bp">NULL</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">render_comp</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">RenderStruct</span><span class="o">*&gt;</span><span class="n">component_data</span><span class="p">[</span><span class="n">real_index</span><span class="o">+</span><span class="mf">0</span><span class="p">]</span>
                <span class="n">vert_offset</span> <span class="o">=</span> <span class="n">render_comp</span><span class="o">.</span><span class="n">vert_index</span>
                <span class="n">vert_mesh</span> <span class="o">=</span> <span class="n">meshes</span><span class="p">[</span><span class="n">render_comp</span><span class="o">.</span><span class="n">vert_index_key</span><span class="p">]</span>
                <span class="n">vertex_count</span> <span class="o">=</span> <span class="n">vert_mesh</span><span class="o">.</span><span class="n">_vert_count</span>
                <span class="n">index_count</span> <span class="o">=</span> <span class="n">vert_mesh</span><span class="o">.</span><span class="n">_index_count</span>
                <span class="k">if</span> <span class="n">render_comp</span><span class="o">.</span><span class="n">render</span><span class="p">:</span>
                    <span class="n">pos_comp</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">PositionStruct2D</span><span class="o">*&gt;</span><span class="n">component_data</span><span class="p">[</span>
                        <span class="n">real_index</span><span class="o">+</span><span class="mf">1</span><span class="p">]</span>
                    <span class="n">mesh_data</span> <span class="o">=</span> <span class="n">vert_mesh</span><span class="o">.</span><span class="n">_data</span>
                    <span class="n">mesh_indices</span> <span class="o">=</span> <span class="n">vert_mesh</span><span class="o">.</span><span class="n">_indices</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index_count</span><span class="p">):</span>
                        <span class="n">frame_indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">index_offset</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">mesh_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">vert_offset</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vertex_count</span><span class="p">):</span>
                        <span class="n">vertex</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">frame_data</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">vert_offset</span><span class="p">]</span>
                        <span class="n">vertex</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_comp</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">mesh_data</span><span class="p">[</span>
                            <span class="n">n</span><span class="o">*</span><span class="n">attribute_count</span><span class="p">]</span>
                        <span class="n">vertex</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_comp</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">mesh_data</span><span class="p">[</span>
                            <span class="n">n</span><span class="o">*</span><span class="n">attribute_count</span><span class="o">+</span><span class="mf">1</span><span class="p">]</span>
                        <span class="n">vertex</span><span class="o">.</span><span class="n">uvs</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="p">[</span><span class="n">n</span><span class="o">*</span><span class="n">attribute_count</span><span class="o">+</span><span class="mf">2</span><span class="p">]</span>
                        <span class="n">vertex</span><span class="o">.</span><span class="n">uvs</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="p">[</span><span class="n">n</span><span class="o">*</span><span class="n">attribute_count</span><span class="o">+</span><span class="mf">3</span><span class="p">]</span>
                    <span class="n">index_offset</span> <span class="o">+=</span> <span class="n">index_count</span>
            <span class="n">batch</span><span class="o">.</span><span class="n">set_index_count_for_frame</span><span class="p">(</span><span class="n">index_offset</span><span class="p">)</span>
            <span class="n">mesh_instruction</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="n">mesh_instruction</span>
            <span class="n">mesh_instruction</span><span class="o">.</span><span class="n">flag_update</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>Our code essentially loops through every batch, looking at each entity in the 
batch, looks up the model for that entity as well as some other game data 
and combines this data, writing out to the actual frame_data and frame_indices
arrays. </p>
<p>The new code eschews with the list lookup entirely by storing a pointer to the 
actual model object. We can then cast this pointer directly to the 
object, avoiding the cost of looking into the list at all, as in Line 40 here:</p>
<p>New code:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">IndexedBatch</span> <span class="nf">batch</span>
    <span class="k">cdef</span> <span class="kt">list</span> <span class="nf">batches</span>
    <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">batch_key</span>
    <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">index_offset</span><span class="p">,</span> <span class="nf">vert_offset</span>
    <span class="k">cdef</span> <span class="kt">RenderStruct</span>* <span class="nf">render_comp</span>
    <span class="k">cdef</span> <span class="kt">PositionStruct2D</span>* <span class="nf">pos_comp</span>
    <span class="k">cdef</span> <span class="kt">VertexFormat4F</span>* <span class="nf">frame_data</span>
    <span class="k">cdef</span> <span class="kt">GLushort</span>* <span class="nf">frame_indices</span>
    <span class="k">cdef</span> <span class="kt">VertexFormat4F</span>* <span class="nf">vertex</span>
    <span class="k">cdef</span> <span class="kt">VertexModel</span> <span class="nf">model</span>
    <span class="k">cdef</span> <span class="kt">GLushort</span>* <span class="nf">model_indices</span>
    <span class="k">cdef</span> <span class="kt">VertexFormat4F</span>* <span class="nf">model_vertices</span>
    <span class="k">cdef</span> <span class="kt">VertexFormat4F</span> <span class="nf">model_vertex</span>
    <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">used</span><span class="p">,</span> <span class="nf">i</span><span class="p">,</span> <span class="nf">real_index</span><span class="p">,</span> <span class="nf">component_count</span><span class="p">,</span> <span class="nf">n</span>
    <span class="k">cdef</span> <span class="kt">ComponentPointerAggregator</span> <span class="nf">entity_components</span>
    <span class="k">cdef</span> <span class="kt">BatchManager</span> <span class="nf">batch_manager</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_manager</span>
    <span class="k">cdef</span> <span class="kt">dict</span> <span class="nf">batch_groups</span> <span class="o">=</span> <span class="n">batch_manager</span><span class="o">.</span><span class="n">batch_groups</span>
    <span class="k">cdef</span> <span class="kt">CMesh</span> <span class="nf">mesh_instruction</span>
    <span class="k">cdef</span> <span class="kt">MemoryBlock</span> <span class="nf">components_block</span>
    <span class="k">cdef</span> <span class="kt">void</span>** <span class="nf">component_data</span>

    <span class="k">for</span> <span class="n">batch_key</span> <span class="ow">in</span> <span class="n">batch_groups</span><span class="p">:</span>
        <span class="n">batches</span> <span class="o">=</span> <span class="n">batch_groups</span><span class="p">[</span><span class="n">batch_key</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">batches</span><span class="p">:</span>
            <span class="n">entity_components</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="n">entity_components</span>
            <span class="n">components_block</span> <span class="o">=</span> <span class="n">entity_components</span><span class="o">.</span><span class="n">memory_block</span>
            <span class="n">used</span> <span class="o">=</span> <span class="n">components_block</span><span class="o">.</span><span class="n">used_count</span>
            <span class="n">component_count</span> <span class="o">=</span> <span class="n">entity_components</span><span class="o">.</span><span class="n">count</span>
            <span class="n">component_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">void</span><span class="o">**&gt;</span><span class="n">components_block</span><span class="o">.</span><span class="n">data</span>
            <span class="n">frame_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">VertexFormat4F</span><span class="o">*&gt;</span><span class="n">batch</span><span class="o">.</span><span class="n">get_vbo_frame_to_draw</span><span class="p">()</span>
            <span class="n">frame_indices</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLushort</span><span class="o">*&gt;</span><span class="n">batch</span><span class="o">.</span><span class="n">get_indices_frame_to_draw</span><span class="p">()</span>
            <span class="n">index_offset</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">used</span><span class="p">):</span>
                <span class="n">real_index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">component_count</span>
                <span class="k">if</span> <span class="n">component_data</span><span class="p">[</span><span class="n">real_index</span><span class="p">]</span> <span class="o">==</span> <span class="bp">NULL</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">render_comp</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">RenderStruct</span><span class="o">*&gt;</span><span class="n">component_data</span><span class="p">[</span><span class="n">real_index</span><span class="o">+</span><span class="mf">0</span><span class="p">]</span>
                <span class="n">vert_offset</span> <span class="o">=</span> <span class="n">render_comp</span><span class="o">.</span><span class="n">vert_index</span>
                <span class="n">model</span> <span class="o">=</span> <span class="p">&lt;</span><span class="kt">VertexModel</span><span class="p">&gt;</span><span class="n">render_comp</span><span class="o">.</span><span class="n">model</span>
                <span class="k">if</span> <span class="n">render_comp</span><span class="o">.</span><span class="n">render</span><span class="p">:</span>
                    <span class="n">pos_comp</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">PositionStruct2D</span><span class="o">*&gt;</span><span class="n">component_data</span><span class="p">[</span>
                        <span class="n">real_index</span><span class="o">+</span><span class="mf">1</span><span class="p">]</span>
                    <span class="n">model_vertices</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">VertexFormat4F</span><span class="o">*&gt;</span><span class="p">(</span>
                        <span class="n">model</span><span class="o">.</span><span class="n">vertices_block</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                    <span class="n">model_indices</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLushort</span><span class="o">*&gt;</span><span class="n">model</span><span class="o">.</span><span class="n">indices_block</span><span class="o">.</span><span class="n">data</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">_index_count</span><span class="p">):</span>
                        <span class="n">frame_indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">index_offset</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">model_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">vert_offset</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">_vertex_count</span><span class="p">):</span>
                        <span class="n">vertex</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">frame_data</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">vert_offset</span><span class="p">]</span>
                        <span class="n">model_vertex</span> <span class="o">=</span> <span class="n">model_vertices</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                        <span class="n">vertex</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_comp</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">model_vertex</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
                        <span class="n">vertex</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_comp</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">model_vertex</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span>
                        <span class="n">vertex</span><span class="o">.</span><span class="n">uvs</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_vertex</span><span class="o">.</span><span class="n">uvs</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
                        <span class="n">vertex</span><span class="o">.</span><span class="n">uvs</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_vertex</span><span class="o">.</span><span class="n">uvs</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span>
                    <span class="n">index_offset</span> <span class="o">+=</span> <span class="n">model</span><span class="o">.</span><span class="n">_index_count</span>
            <span class="n">batch</span><span class="o">.</span><span class="n">set_index_count_for_frame</span><span class="p">(</span><span class="n">index_offset</span><span class="p">)</span>
            <span class="n">mesh_instruction</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="n">mesh_instruction</span>
            <span class="n">mesh_instruction</span><span class="o">.</span><span class="n">flag_update</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>The astute reader will now call me out on the fact that more than just the 
list lookup has changed. This is True, and I haven't tested the exact impact of
just the list lookup to pointer change, however the other changes are mostly 
just changing the type of data fetched as a result of expanding the types of 
data we support. In this particular test case, the change is mostly semantic,
we still have a 4 float array (albeit stored as GLfloats this time), taking up
the exact same amount of memory and everything.</p>
<h1>The New Model Format</h1>
<p>In the first code, our mesh is represented by an array of floats to hold the 
vertex data and an array of unsigned shorts to hold the index data. This comes 
from the model format used internally by Kivy, where all geometry is 
represented by a 2 float pos and a 2 float uvs attribute. One of my longstanding 
goals for KivEnt was to expand the type of supported geometry to cover more of 
the types GL allows us.</p>
<p>Since Kivy and KivEnt are purely OpenGL, we can actually store our model data 
directly in GL types, as we will always be using those types by the time we are 
submitting our vertex data for the frame. Kivy uses pure floats because it makes 
it fairly easy to wrap in python as you just need to know the index of your 
attribute in a float array. However, even if Kivy did support other types 
(it doesn't the support was never completed), we would be forced to separate 
data of different types into completely different VBOs. Whereas, it is 
most efficient for vertex data to be interleaved together. This may involve 
assuming a small cost in padding if array elements need it, but in generally 
this padding should be considered helpful as it better aligns the data for the 
processor to read.</p>
<p>KivEnt already has everything in place to use a struct containing arbitrary GL
types for rendering, and I was hoping to create a python object that could
arbitrary wrap any of the vertex formats we create for rendering, as KivEnt is 
designed to let you rapidly introduce new rendering behavior, and we actually
already have the information to do so since we need it to describe our vertex 
structure to GL.</p>
<p>For instance, our most basic vertex format mirrors Kivy's default:</p>
<div class="highlight"><pre><span class="k">ctypedef</span> <span class="k">struct</span> <span class="nc">VertexFormat4F</span><span class="p">:</span>
    <span class="n">GLfloat</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span> <span class="n">pos</span>
    <span class="n">GLfloat</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span> <span class="n">uvs</span>
</pre></div>


<p>Which is described by the list of tuples:</p>
<div class="highlight"><pre><span class="n">vertex_format_4f</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="n">b</span><span class="s">'pos'</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="s">'float'</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> 
    <span class="p">(</span><span class="n">b</span><span class="s">'uvs'</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="s">'float'</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>


<p>The last value is the offset in the struct of the start of the attribute, and 
is important as we must call <a href="https://www.khronos.org/opengles/sdk/docs/man/xhtml/glVertexAttribPointer.xml">glVertexAttribPointer</a> with an invocation
like this:</p>
<div class="highlight"><pre><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                <span class="n">GL_FALSE</span><span class="p">,</span> <span class="p">&lt;</span><span class="kt">GLsizei</span><span class="p">&gt;</span><span class="n">vbytesize</span><span class="p">,</span> 
                <span class="o">&lt;</span><span class="n">GLvoid</span><span class="o">*&gt;</span><span class="p">&lt;</span><span class="kt">long</span><span class="p">&gt;</span><span class="n">offset</span><span class="p">)</span>
</pre></div>


<p>The tuple in the format holds most of this data, the name is used to fetch the 
attr.index (the actual index is determined by GL), 
the second entry is the attr.size, the third is the attr.type, and 
the final is the offset. The vbytesize is the sizeof of the entire struct, the 
GL_FALSE specifies whether the data should be normalized. </p>
<p>Since we have this data we can use it to arbitrary wrap any of our vertex 
formats, which is implemented in the new rendering.model.Vertex and 
rendering.model.VertexModel classes that will be replacing the old VertMesh 
that stored its vertex data as floats.</p>
<p>First we transform our list of tuples into a dict for ease of use:</p>
<div class="highlight"><pre><span class="n">vertex_format_4f</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="n">b</span><span class="s">'pos'</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="s">'float'</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> 
    <span class="p">(</span><span class="n">b</span><span class="s">'uvs'</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="s">'float'</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>


<p>becomes:</p>
<div class="highlight"><pre><span class="n">format_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">b</span><span class="s">'pos'</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="s">'float'</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">b</span><span class="s">'uvs'</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="s">'float'</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
    <span class="p">}</span>
</pre></div>


<p>Now we use this dict as the basis for a new __getattr__ and __setattr__
for our Vertex class. We need to support types of: GLfloat, GLint, GLuint, 
GLshort, GLushort, GLbyte, and GLubyte. Each vertex gets passed a pointer to 
the start of its struct, and then casts that pointer as a char* so that we can
index by bytes. We can now use the offset contained in our vertex format in 
order to fetch the actual location in memory of the attribute of our struct.
We cast this data to the appropriate type and then either retrieve the values 
or set them to the new values.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">cdef</span> <span class="k">class</span> <span class="nf">Vertex</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__cinit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">dict</span> <span class="n">format</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertex_format</span> <span class="o">=</span> <span class="n">format</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">count</span>
        <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">offset</span>
        <span class="k">cdef</span> <span class="kt">bytes</span> <span class="nf">attr_type</span>
        <span class="k">cdef</span> <span class="kt">char</span>* <span class="nf">data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">char</span><span class="o">*&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_pointer</span>
        <span class="k">cdef</span> <span class="kt">GLfloat</span>* <span class="nf">f_data</span>
        <span class="k">cdef</span> <span class="kt">GLint</span>* <span class="nf">i_data</span>
        <span class="k">cdef</span> <span class="kt">GLuint</span>* <span class="nf">ui_data</span>
        <span class="k">cdef</span> <span class="kt">GLshort</span>* <span class="nf">s_data</span>
        <span class="k">cdef</span> <span class="kt">GLushort</span>* <span class="nf">us_data</span>
        <span class="k">cdef</span> <span class="kt">GLbyte</span>* <span class="nf">b_data</span>
        <span class="k">cdef</span> <span class="kt">GLubyte</span>* <span class="nf">ub_data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">'utf-8'</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_format</span><span class="p">:</span>
            <span class="n">attribute_tuple</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_format</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">attribute_tuple</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
            <span class="n">attr_type</span> <span class="o">=</span> <span class="n">attribute_tuple</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">attribute_tuple</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'float'</span><span class="p">:</span>
                <span class="n">f_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLfloat</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[&lt;</span><span class="kt">float</span><span class="p">&gt;</span><span class="n">f_data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'int'</span><span class="p">:</span>
                <span class="n">i_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLint</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="n">i_data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'uint'</span><span class="p">:</span>
                <span class="n">ui_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLuint</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">unsigned</span> <span class="nb">int</span><span class="o">&gt;</span><span class="n">ui_data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'short'</span><span class="p">:</span>
                <span class="n">s_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLshort</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[&lt;</span><span class="kt">short</span><span class="p">&gt;</span><span class="n">s_data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'ushort'</span><span class="p">:</span>
                <span class="n">us_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLushort</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">unsigned</span> <span class="n">short</span><span class="o">&gt;</span><span class="n">us_data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'byte'</span><span class="p">:</span>
                <span class="n">b_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLbyte</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[&lt;</span><span class="kt">char</span><span class="p">&gt;</span><span class="n">b_data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'ubyte'</span><span class="p">:</span>
                <span class="n">ub_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLubyte</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">unsigned</span> <span class="n">char</span><span class="o">&gt;</span><span class="n">ub_data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mf">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">count</span>
        <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">offset</span>
        <span class="k">cdef</span> <span class="kt">bytes</span> <span class="nf">attr_type</span>
        <span class="k">cdef</span> <span class="kt">char</span>* <span class="nf">data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">char</span><span class="o">*&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_pointer</span>
        <span class="k">cdef</span> <span class="kt">GLfloat</span>* <span class="nf">f_data</span>
        <span class="k">cdef</span> <span class="kt">GLint</span>* <span class="nf">i_data</span>
        <span class="k">cdef</span> <span class="kt">GLuint</span>* <span class="nf">ui_data</span>
        <span class="k">cdef</span> <span class="kt">GLshort</span>* <span class="nf">s_data</span>
        <span class="k">cdef</span> <span class="kt">GLushort</span>* <span class="nf">us_data</span>
        <span class="k">cdef</span> <span class="kt">GLbyte</span>* <span class="nf">b_data</span>
        <span class="k">cdef</span> <span class="kt">GLubyte</span>* <span class="nf">ub_data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">'utf-8'</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_format</span><span class="p">:</span>
            <span class="n">attribute_tuple</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_format</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">attribute_tuple</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
            <span class="n">attr_type</span> <span class="o">=</span> <span class="n">attribute_tuple</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">attribute_tuple</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">count</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">AttributeCountError</span><span class="p">(</span><span class="s">'Expected list of length {count} got'</span>
                    <span class="s">'list of size {length}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> 
                    <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'float'</span><span class="p">:</span>
                    <span class="n">f_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLfloat</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">)]</span>
                    <span class="n">f_data</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">&lt;</span><span class="kt">GLfloat</span><span class="p">&gt;</span><span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'int'</span><span class="p">:</span>
                    <span class="n">i_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLint</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="n">GLint</span><span class="p">)]</span>
                    <span class="n">i_data</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">&lt;</span><span class="kt">GLint</span><span class="p">&gt;</span><span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'uint'</span><span class="p">:</span>
                    <span class="n">ui_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLuint</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="n">GLuint</span><span class="p">)]</span>
                    <span class="n">ui_data</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">&lt;</span><span class="kt">GLuint</span><span class="p">&gt;</span><span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'short'</span><span class="p">:</span>
                    <span class="n">s_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLshort</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="n">GLshort</span><span class="p">)]</span>
                    <span class="n">s_data</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">&lt;</span><span class="kt">GLshort</span><span class="p">&gt;</span><span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'ushort'</span><span class="p">:</span>
                    <span class="n">us_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLushort</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="n">GLushort</span><span class="p">)]</span>
                    <span class="n">us_data</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">&lt;</span><span class="kt">GLushort</span><span class="p">&gt;</span><span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'byte'</span><span class="p">:</span>
                    <span class="n">b_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLbyte</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="n">GLbyte</span><span class="p">)]</span>
                    <span class="n">b_data</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">&lt;</span><span class="kt">GLbyte</span><span class="p">&gt;</span><span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">attr_type</span> <span class="o">==</span> <span class="n">b</span><span class="s">'ubyte'</span><span class="p">:</span>
                    <span class="n">ub_data</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">GLubyte</span><span class="o">*&gt;&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="n">GLubyte</span><span class="p">)]</span>
                    <span class="n">ub_data</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">&lt;</span><span class="kt">GLubyte</span><span class="p">&gt;</span><span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>Vertex forms the basis of the new VertexModel, which also handles allocating its
memory using KivEnt's MemoryBlock system, instead of mallocing all over the place.
This ensures that all models of the same format are stored contiguously, hopefully 
improving cache miss rate for our Renderers as they will be pulling models from 
the same area of memory. The other changes in the update function are a result 
of switching from the float array to the array of arbitrary structs consisting 
of GLtypes.</p>
<p>You can expect to see these changes in KivEnt 2.1.0, hopefully releasing in the
next few weeks. If you want to preview these changes you can visit the 
<a href="https://github.com/kivy/kivent/tree/new_model_format">new_model_format branch</a>
on github.</p>
    </div>

  </div></body></html>