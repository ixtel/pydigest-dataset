<html><body><div><div itemprop="articleBody" class="article-body" dir="ltr">


<p>A <strong>Graph</strong> is an abstract data type meant to implement the mathematical concepts of <em>graph</em> and <em>directed graph</em>. This data structure consists of a finite set of <strong>nodes</strong> (or vertices) together with a <strong>set of edges</strong> (or arcs). An arc is a relation between nodes, and is usually represented by edge(x,y) where we can read that there is a path between "<em>node x</em>" and "<em>node y</em>". Some edges may be associated to a symbolic label or numeric value (cost, length, capacity, price, etc.).</p>
<h3>Representation</h3>
<p>A graph can be represented using an adjacency list, an adjacency matrix or an incidence matrix. In the following code snippets, I'll be using the adjacency list representation.</p>
<p>In an adjacency list, we can store vertices as keys in a dictionary and every vertex stores a list of adjacent vertices. We can easily represent this on python.</p>
<p>Here we will represent a connected graph with six nodes and eight vertices. The graph we will represent will be undirected and with no assigned edge values.</p>
<p> <img class="center" src="//:0" alt="" data-li-src="https://media.licdn.com/mpr/mpr/shrinknp_400_400/AAEAAQAAAAAAAAL2AAAAJDM1ZDU3YzIzLTA1ZmEtNDcyMy1iNDljLTI5MTIzMTk3ZWJlOQ.png"/></p>
<p>The visual representation of our graph is the following:</p>
<p><img class="center" src="//:0" alt="" data-li-src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAOcAAAAJGEwYzUzOTk4LWQwZjYtNGU3OS1iYjlkLTlmYjUxMzc3MDgwMg.png"/></p>
<p>This finite representation of the graph allow us to traverse the nodes using the Depth-First Search (DFS) or the Breadth-First Search (BFS) strategies.</p>
<h3>Depth-First Search</h3>
<p>The DFS visits the vertices down the child nodes before visiting the sibling nodes, it traverses the depth of any particular path before exploring its breath (or in other words it goes from a supplied root down to each branch before backtracking).</p>
<p>This algorithm begins by choosing a "root" node and then iteractively transictioning from the current node to an adjacent and unvisited node, until it reaches a node it can no longer explore. The algorithm then backtracks until it finds a connected node that was not yet visited.</p>
<p>The following code represents an iterative version of the DFS:</p>
<p><img class="center" src="//:0" alt="" data-li-src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAKwAAAAJGRmZWZkYTBlLTY0OTUtNDliNi05OGJkLTk3YmUxNzdiZTM3Nw.png"/></p>
<p>Because we have a connected and undirected graph, calling dfs_iter on any of our nodes will return all nodes. If we had a directed graph we would only find the reachable nodes.</p>
<p>We can implement a recursive version of this algorithm with the following snippet:</p>
<p><img class="center" src="//:0" alt="" data-li-src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAJ7AAAAJGE3MWJjZGI0LTQzM2YtNDA3OS05OWY3LWY0ZGNiNWJiMjQwZA.png"/></p>
<p>We can generate all (non-cyclic) paths between two nodes using a python generator and a fork of our DFS implementation:</p>
<p><img class="center" src="//:0" alt="" data-li-src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAJZAAAAJDU0ZWVkMGY3LTU5ZWEtNDkxMy04Njk1LTQ0OWUyN2YxYzljZQ.png"/></p>
<p><br/>Calling<em> list(dfs_paths(graph, 0, 5))</em> would return the list of possible paths between nodes 0 and 5, which is: [0, 1, 2, 4, 3, 5], [0, 1, 2, 4, 5], [0, 1, 3, 4, 5], [0, 1, 3, 5] and [0, 5]</p>
<p>I hope you enjoyed this article. In the next article I'll be taclking the BFS algorithm.</p>

</div></div></body></html>