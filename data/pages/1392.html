<html><body><div><div class="content html_format"><p>
      В продолжение </p><a href="http://habrahabr.ru/post/201178/">пятого урока</a><p> по изучению азов RabbitMQ, публикую перевод шестого урока с </p><a href="http://www.rabbitmq.com/tutorials/tutorial-six-python.html">официального сайта</a><p>. Все примеры написаны на python (используется pika версии 0.9.8), но по-прежнему их можно реализовать на большинстве </p><a href="http://www.rabbitmq.com/devtools.html">популярных ЯП</a><p>.
</p><p>
Во </p><a href="http://habrahabr.ru/post/150134/">втором уроке</a><p> мы рассмотрели использование очередей задач для распределения ресурсоёмких задач между несколькими подписчиками.
</p><p>
Но что если мы захотим запустить функцию на удаленной машине и дождаться результата? Ну, это совсем другая история. Этот шаблон широко известен как Удаленный Вызов Процедур (Remote Procedure Call или RPC, далее в тексте RPC).
</p><p>
В этом руководстве мы построим, используя RabbitMQ, RPC систему, которая будет включать клиент и масштабируемый RPC сервер. Так как у нас нет реальной трудоемкой задачи требующей распределения, мы создадим простой RPC сервер, возвращающий числа Фибоначчи.
</p><a name="habracut"/>
<h4>Интерфейс клиента</h4><p>
Для иллюстрации использования RPC службы, создадим простой клиентский класс. Этот класс будет содержать метод </p><i>call</i><p>, который будет отправлять RPC запросы и блокироваться до получения ответа:

</p><pre><code class="python">fibonacci_rpc = FibonacciRpcClient()
result = fibonacci_rpc.call(4)
print "fib(4) is %r" % (result,)
</code></pre>
<blockquote><h5>Замечание о RPC</h5><br/>
Несмотря на то, что RPC довольно распространенный шаблон, его часто критикуют. Проблемы обычно возникают, когда разработчик не знает точно, какую функцию он использует: локальную или медленную, выполняющуюся посредством RPC. Неразбериха, вроде этой, может вылиться в непредсказуемость поведения системы, а также вносит излишнюю сложность в процесс отладки. Таким образом, вместо упрощения программного обеспечения неверное использование RPC может привести к не обслуживаемому и не читаемому коду.<br/>
<br/>
С учетом вышеизложенного можно дать следующие рекомендации:<br/>
<ul>
<li>Убедитесь, что это очевидно, какая функция вызывается в каждом конкретном случае: локальная или удаленная;</li>
<li>Документируйте вашу систему. Делайте зависимости между компонентами явными;</li>
<li>Обрабатывайте ошибки. Как должен реагировать клиент, если RPC сервер не отвечает в течение длительного промежутка времени?</li>
<li>Если сомневаетесь — не используйте RPC. Если это возможно, используйте асинхронный конвейер вместо блокирующего RPC, когда результаты асинхронно передаются на следующий уровень обработки.</li>
</ul></blockquote>
<h4>Очередь результатов</h4><p>
Вообще, совершать RPC через RabbitMQ легко. Клиент отправляет запрос и сервер отвечает на запрос. Чтобы получить ответ, клиент должен передать очередь для размещения результатов вместе с запросом. Давайте посмотрим как это выглядит в коде:

</p><pre><code class="python">result = channel.queue_declare(exclusive=True)
callback_queue = result.method.queue

channel.basic_publish(exchange='',
                      routing_key='rpc_queue',
                      properties=pika.BasicProperties(
                            reply_to = callback_queue,
                            ),
                      body=request)

# ...какой-то код для чтения ответного сообщения из callback_queue ...
</code></pre>
<h4>Свойства сообщений</h4><p>
В протоколе AMQP имеется 14 предопределенных свойств сообщений. Большинство из них используются крайне редко, за исключением следующих:

</p><ul>
<li><i>delivery_mode</i>: отмечает сообщение как «стойкое» (со значением 2) или «временное» (любое другое значение). Вы должны помнить это свойство по <a href="http://habrahabr.ru/post/150134/">второму уроку</a>;</li>
<li><i>content_type</i>: используется для описания формата представления данных(mime). К примеру, для часто используемого JSON формата хорошим тоном считается устанавливать это свойство в application/json;</li>
<li><i>reply_to</i>: обычно используется для указания очереди результатов;</li>
<li><i>correlation_id</i>: свойство используется для сопоставления RPC ответов с запросами.</li>
</ul>

<h4>Correlation id</h4><p>
В методе, представленном выше, мы предлагали создавать очередь ответов для каждого RPC запроса. Это несколько избыточно, но, к счастью, есть способ лучше — давайте создадим общую очередь результатов для каждого клиента.
</p><p>
Это поднимает новый вопрос, получив ответ из этой очереди не совсем ясно, какому запросу соответствует этот ответ. И тут нам пригодится свойство </p><i>correlation_id</i><p>. Мы будем присваивать этому свойству уникальное значение при каждом запросе. Позднее, когда мы извлечем полученный ответ из очереди ответов, основываясь на значении этого свойства мы сможем однозначно сопоставить запрос с ответом. Если встретим неизвестное значение в свойстве </p><i>correlation_id</i><p>, мы можем спокойно игнорировать это сообщение, так как оно не соответствует ни одному из наших запросов.
</p><p>
Вы могли бы поинтересоваться, почему мы планируем просто игнорировать неизвестные сообщения из очереди ответов, вместо того, чтобы прервать выполнение сценария? Это связано с вероятностью возникновения race condition на стороне сервера. Хотя это и маловероятно, но вполне возможен сценарий, при котором RPC сервер отправит нам ответ, но не успеет отправить подтверждение обработки запроса. Если это произойдет, перезапущенный RPC сервер снова будет обрабатывать данный запрос. Вот почему на клиенте мы должны корректно обрабатывать повторные ответы. Кроме того, RPC, в идеале, должен быть идемпотентен.

</p><h4>Итоги</h4>
<img src="https://habrastorage.org/getpro/habr/post_images/016/c2d/982/016c2d98222564716931fea17f8ea2be.png" alt="image"/>
<p>
Наш RPC будет работать следующим образом:
</p><p>
 — Когда Клиент стартует, он создает анонимную уникальную очередь результатов;</p><p>
 — Для совершения RPC запроса, Клиент отправляет сообщение с двумя свойствами: </p><i>reply_to</i><p>, где в качестве значения указывается очередь результатов и </p><i>correlation_id</i><p>, устанавливаемый в уникальное значение для каждого запроса.</p><p>
 — Запрос отправляется в очередь </p><i>rpc_queue</i><p>;</p><p>
 — Сервер ожидает запросы из этой очереди. Когда запрос получен, Сервер выполняет свою задачу и отправляет сообщение с результатом обратно Клиенту, используя очередь из свойства </p><i>reply_to</i><p>;</p><p>
 — Клиент ожидает результат из очереди результатов. Когда сообщение получено, Клиент проверяет свойство </p><i>correlation_id</i><p>. Если оно соответствует значение из запроса, то результат отправляется приложению.

</p><h4>Собирая всё вместе</h4><p>
Код сервера rpc_server.py:

</p><pre><code class="python">#!/usr/bin/env python
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters(
        host='localhost'))

channel = connection.channel()

channel.queue_declare(queue='rpc_queue')

def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

def on_request(ch, method, props, body):
    n = int(body)

    print " [.] fib(%s)"  % (n,)
    response = fib(n)

    ch.basic_publish(exchange='',
                     routing_key=props.reply_to,
                     properties=pika.BasicProperties(correlation_id = \
                                                     props.correlation_id),
                     body=str(response))
    ch.basic_ack(delivery_tag = method.delivery_tag)

channel.basic_qos(prefetch_count=1)
channel.basic_consume(on_request, queue='rpc_queue')

print " [x] Awaiting RPC requests"
channel.start_consuming()
</code></pre>
<p>
Серверный код довольно прост:

</p><ul>
<li>(4) Как обычно, мы устанавливаем соединение и объявляем очередь;</li>
<li>(11) Объявляем нашу функцию, возвращающую числа Фибоначчи, которая принимает в качестве аргумента только целые положительные числа(эта функция вряд ли будет работать с большими числами, вероятнее всего это самая медленная из возможных реализаций);</li>
<li>(19) Мы объявляем функцию обратного вызова <i>on_request </i> для <i>basic_consume</i>, которая и является ядром RPC сервера. Она исполняется когда запрос получен. Выполнив работу, функция отправляет результат обратно;</li>
<li>(32) Вероятно, мы захотим когда-нибудь запустить более одного сервера. Для равномерного распределения нагрузки между несколькими серверами мы устанавливаем <i>prefetch_count</i>.</li>
</ul>
<p>
Код клиента rpc_client.py:

</p><pre><code class="python">#!/usr/bin/env python
import pika
import uuid

class FibonacciRpcClient(object):
    def __init__(self):
        self.connection = pika.BlockingConnection(pika.ConnectionParameters(
                host='localhost'))

        self.channel = self.connection.channel()

        result = self.channel.queue_declare(exclusive=True)
        self.callback_queue = result.method.queue

        self.channel.basic_consume(self.on_response, no_ack=True,
                                   queue=self.callback_queue)

    def on_response(self, ch, method, props, body):
        if self.corr_id == props.correlation_id:
            self.response = body

    def call(self, n):
        self.response = None
        self.corr_id = str(uuid.uuid4())
        self.channel.basic_publish(exchange='',
                                   routing_key='rpc_queue',
                                   properties=pika.BasicProperties(
                                         reply_to = self.callback_queue,
                                         correlation_id = self.corr_id,
                                         ),
                                   body=str(n))
        while self.response is None:
            self.connection.process_data_events()
        return int(self.response)

fibonacci_rpc = FibonacciRpcClient()

print " [x] Requesting fib(30)"
response = fibonacci_rpc.call(30)
print " [.] Got %r" % (response,)
</code></pre>
<p>
Код Клиента несколько сложнее:

</p><ul>
<li>(7) Мы устанавливаем соединение, канал и объявляем уникальную очередь результатов для полученных ответов;</li>
<li>(16) Мы подписываемся на очередь результатов для получения ответов от RPC;</li>
<li>(18) Функция обратного вызова '<i>on_response</i>', исполнямая при получении каждого ответа, выполняет довольно тривиальную задачу — для каждого поступившего ответа она проверяет соответствует ли <i>correlation_id</i> тому что мы ожидаем. Если это так, она сохраняет ответ в <i>self.response</i> и прерывает цикл;</li>
<li>(23) Далее, мы определяем наш метод <i>call</i>, который, собственно, и выполняет RPC запрос;</li>
<li>(24) В этом методе мы сначала генерируем уникальный <i>correlation_id</i> и сохраняем его — функция обратного вызова '<i>on_response</i>' будет использовать это значение для отслеживания нужного ответа;</li>
<li>(25) Далее мы помещаем запрос со свойствами <i>reply_to</i> и <i>correlation_id</i> в очередь;</li>
<li>(32) Далее начинается процесс ожидания ответа;</li>
<li>(33) И, в конце, мы возвращаем результат обратно пользователю.</li>
</ul>
<p>
Наш RPC сервис готов. Мы можем запустить сервер:

</p><pre><code class="bash">$ python rpc_server.py
 [x] Awaiting RPC requests
</code></pre><p>
Для получения чисел Фибоначчи запускаем Клиент:

</p><pre><code class="bash">$ python rpc_client.py
 [x] Requesting fib(30)
</code></pre><p>
Представленный вариант реализации RPC не является единственным возможным, но он имеет следующие преимущества:

</p><ul>
<li> Если RPC сервер слишком медленный, вы можете легко добавить еще один. Попробуйте запустить второй rpc_server.py в новой консоли;</li>
<li> На стороне Клиента, RPC требует отправки и получения только одного сообщения. Не требуется синхронный вызов <i>queue_declare</i>. Как результат, RPC клиент обходится одним циклом запрос-ответ для одного RPC запроса.</li>
</ul>
<p>
Наш код, тем не менее, является упрощенным и даже не пытается решать более сложные(но, безусловно, важные) проблемы вроде таких:

</p><ul>
<li>Как должен реагировать Клиент, если сервер не запущен?</li>
<li>Должен ли Клиент иметь таймоут для RPC?</li>
<li>Если Сервер в какой-то момент «сломается» и выбросит исключение, должно ли оно передаваться Клиенту?</li>
<li>Защита от недопустимых входящих сообщений(например, проверка допустимых границ) перед обработкой.</li>
</ul>

<h4>Все статьи руководства</h4>
<a href="http://habrahabr.ru/post/149694/">RabbitMQ tutorial 1 — Hello World</a><p> (python)
</p><a href="http://habrahabr.ru/post/150134/">RabbitMQ tutorial 2 — Очередь задач</a><p> (python)
</p><a href="http://habrahabr.ru/post/200870/">RabbitMQ tutorial 3 — Публикация/Подписка</a><p> (php)
</p><a href="http://habrahabr.ru/post/201096/">RabbitMQ tutorial 4 — Роутинг</a><p> (php)
</p><a href="http://habrahabr.ru/post/201178/">RabbitMQ tutorial 5 — Тематики</a><p> (php)</p><p>
RabbitMQ tutorial 6 — Удаленный вызов процедур (эта статья, python)
      </p><p class="clear"/>
    </div>

    
  </div></body></html>