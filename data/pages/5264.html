<html><body><div><div class="post-layout__content">
        <p>Nearest neighbour search is a common task: given a query object represented as a point in some (often high-dimensional) space, we want to find other objects in that space that lie close to it. For example, a mapping application will perform a nearest neighbours search when we ask it for restaurants close to our location.</p>

<h2 id="nearest-neighbour-search-at-lyst">Nearest neighbour search at Lyst</h2>

<p>Nearest neighbour search underpins two crucial systems at Lyst.</p>

<ol>
<li>Product de-duplication. Because we aggregate products from a vast range of different retailers, often the same product sold by two retailers will be described by different metadata. To identify these cases, we describe our images with a set of numerical features derived using the <a href="http://www.asl.ethz.ch/people/lestefan/personal/iccv2011.pdf">BRISK</a> algorithm. This makes our images points in a high-dimensional space, and we use nearest neighbour search to perform de-duplication.</li>
<li>Related products. Our product pages feature a set of related products that the user might also be interested in. For this task, each product is again represented as a vector (a point in a high-dimensional space) derived from a <a href="http://www2.research.att.com/%7Evolinsky/papers/ieeecomputer.pdf">matrix factorisation</a> recommendation model. When a user visits a product page, we perform real-time nearest neighbours search in that space to find suitable related products.</li>
</ol>

<p>The challenge with making these systems work is scaling them to the size of our product catalogue. To serve related products, we need to perform a NN search over 8 million products in under 100 ms; to perform de-duplication, we need to search over 80 million images in a under half a second.</p>

<p>Within these constraints, it is impossible to perform exhaustive NN search --- taking the query point and computing its distance to every other point. We therefore use approximate nearest neighbour (ANN) search: algorithms and data structures that allow us to trade off a small amount of accuracy for a massive boost in speed.</p>

<h2 id="ann-via-random-projection-forests">ANN via Random Projection Forests</h2>

<p>The essence of approximate nearest neighbour search consists in roughly dividing the search space into a number of buckets that contain points that are close to each other, and then only looking within a given bucket when performing a search. This gives us speed (we only have to scan the contents of a given bucket) at the expense of accuracy (it's possible for a point's nearest neighbours to lie in a different bucket).</p>

<p>This is quite similar to building a hash table (dictionary, associative array etc.), but instead of using a uniform hash function, we use a special function that hashes points close to each other to the same hash code (hence, <a href="https://en.wikipedia.org/wiki/Locality-sensitive_hashing">locality sensitive hashing</a>).</p>

<p>To do this, we use forests of <a href="http://jmlr.org/proceedings/papers/v30/Dasgupta13.pdf">Random Projection trees</a>. This is roughly how it works.</p>

<h3 id="building-an-ann-search-tree">Building an ANN search tree</h3>

<p>We start with the entire set of points (blue) and try to recursively slice it into smaller and smaller buckets that contain only similar points. In this example, we'll pick a query point (red) and see how we can narrow down its approximate nearest neighbours. Note that here we are interested in <a href="https://en.wikipedia.org/wiki/Cosine_similarity">cosine similarity</a> rather than <a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distance</a> (the angle between two points versus the length of the line that connects them).</p>

<p>In the first image, we have all of our candidate points and the query point. At this stage, if we wanted to run our query, we'd have to calculate the similarity of the red point with all the blue points --- and that would be too slow.</p>

<figure class="post-image">
    <img src="/images/ann/plot_0.svg" alt="Step 1"/>

    

</figure>

<p>What we do instead is draw a random vector pointing out from the origin (the red arrow). It's clear that some of the blue points point in the same direction as the arrow (to the right of the red line), and some point away from it (to the left of it). That's our first split: all the dark red points are assigned to one bucket, and the blue points to the other.</p>

<p>Mathematically, we take the <a href="https://en.wikipedia.org/wiki/Dot_product">dot product</a> of the random vector and our points: if it is greater than zero, we assign the points to the left subtree; if it is smaller, we assign them to the right subtree.</p>

<figure class="post-image">
    <img src="/images/ann/plot_1.svg" alt="Step 2"/>

    

</figure>

<p>At this stage, each bucket still contains too many points, and so we continue the process by drawing another random vector, and doing the split again. After these two splits, only the dark red points are in the same bucket as the query point.</p>

<figure class="post-image">
    <img src="/images/ann/plot_2.svg" alt="Step 3"/>

    

</figure>

<p>We continue the splits until we are satisfied with the resulting bucket size. In the last image, only 7 our of the initial 100 points are in the ANN bucket, giving us (in theory) a 10x speed-up when querying.</p>

<figure class="post-image">
    <img src="/images/ann/plot_4.svg" alt="Step 5"/>

    

</figure>

<p>The resulting data structure is a binary tree: at each internal node, we split our set of points into two. The leaf nodes contain the points themselves.</p>

<h3 id="querying">Querying</h3>

<p>Once the tree is built, querying it is very straightforward. If we query for the NNs of a point in the tree, we simply look up its bucket and perform brute force search only within that bucket.</p>

<p>If we query for a new point, we first need to traverse the tree to find the appropriate leaf node. We recursively take the dot product of the query point with the internal node vectors, moving down the correct subtree at every split until we hit a leaf node. In this example, with a tree depth of 4 and 7 points in the leaf node, we would perform 11 distance calculations: far fewer than the 99 we would have to do in a brute force search.</p>

<h3 id="building-a-forest-of-trees">Building a forest of trees</h3>

<p>So far, we have built only on tree. In practice, we build many such trees --- a random projection forest. Because we are using a probabilistic algorithm, it is likely, but not guaranteed, that a leaf node will contain a query point's nearest neighbours. In fact, if we look at the first split in the example above, we can see that there are some points immediately to the left of the query point that fall on the other side of the partition. If we built only one tree, these points would be (erroneously) never retrieved. We build many trees to make this occurence less likely, trading off query time for retrieval accuracy.</p>

<h2 id="ann-search-in-python">ANN search in Python</h2>

<p>With theory out of the way, on to the important question: what can we use to do this in Python?</p>

<p>There are a number of packages that implement approximate nearest neighbour search.</p>

<ol>
<li><a href="http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.LSHForest.html">LSHForest</a>, easy to obtain as part of scikit-learn, supports indexing sparse vectors.</li>
<li><a href="https://github.com/ryanrhymes/panns">panns</a>, supports both Euclidean and angular distance, small index file size.</li>
<li><a href="https://github.com/spotify/annoy">annoy</a> by <a href="https://twitter.com/fulhack">Erik Bernhardsson</a>, a Python wrapper of C++ code, very fast.</li>
</ol>

<p>The advantage of the first two lies in their accessibility: they are implemented in pure Python, and LSHForest is built into scikit-learn. Unfortunately, they seem to be quite slow according to the ANN <a href="https://github.com/erikbern/ann-benchmarks">performance shootout</a> maintained by Erik, the author of annoy.</p>

<p>Annoy itself is very fast and pleasant to use. However, it does not support indexing new points into an existing data structure, and has to keep vectors for all indexed points in memory (or in a memmapped file). For our problems, we found it useful to construct lightweight ANN structures that act as indexes into an external database: we obtain row ids from the index, but perform data retrieval and final scoring using a separate service.</p>

<p>To make this possible, we have released our own Python implementation of Random Projection Forests: <a href="https://github.com/lyst/rpforest">rpforest</a>.</p>

<h2 id="rpforest">RPForest</h2>

<p>RPForest is a Python package for approximate nearest neighbours search, with performance critical parts written in Cython. Install it from pip using <code>pip install rpforest</code>. You'll need to install numpy first and have a C++ compiler.</p>

<p>Using it is straightforward. To fit the model, run:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">rpforest</span> <span class="kn">import</span> <span class="n">RPForest</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">RPForest</span><span class="p">(</span><span class="n">leaf_size</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">no_trees</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></code></pre></figure><p>


The speed-precision tradeoff is governed by the `leaf_size` and `no_trees` parameters. Increasing `leaf_size` leads the model to produce shallower trees with larger leaf nodes; increasing `no_trees` fits more trees.

RPForest supports in-memory ANN queries. After fitting, ANNs can be obtained by calling:


</p><figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">nns</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">x_query</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span></code></pre></figure><p>


It also supports indexing and candidate ANN queries on datasets larger than would fit in available memory. This is accomplished by first fitting the model on a subset of the data, then indexing a larger set of data into the fitted model:


</p><figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">model</span> <span class="o">=</span> <span class="n">RPForest</span><span class="p">(</span><span class="n">leaf_size</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">no_trees</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>

<span class="n">model</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>  <span class="c"># Deletes X_train vectors</span>

<span class="k">for</span> <span class="n">point_id</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">get_x_vectors</span><span class="p">():</span>
     <span class="n">model</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">point_id</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="n">nns</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_candidates</span><span class="p">(</span><span class="n">x_query</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span></code></pre></figure><p>


While not as fast as annoy, RPForest handily beats LSHForest and panns in the ANN performance shootout:
</p><figure class="post-image">
    <img src="ages/ann/glove.png" alt="Performance"/>

    

</figure>

<h2 id="contributing">Contributing</h2>

<p>We wrote RPForest to provide the functionality we needed, and we hope it's useful for you too. Please help us improve it --- all issues and pull requests are welcome on the RPForest <a href="https://github.com/lyst/rpforest">Github page</a>.</p>

    </div>

    </div></body></html>