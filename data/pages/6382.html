<html><body><div><article class="markdown-body entry-content" itemprop="text"><h1><a id="user-content-bot-battle" class="anchor" href="#bot-battle" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Bot Battle</h1>

<h2><a id="user-content-reversi_battlepy" class="anchor" href="#reversi_battlepy" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>reversi_battle.py</h2>

<p>is a variation on the standard Reversi/Othello board game which aims to encourage quick coding. While quick writing code often isn't ideal, it's sometimes desireable to just get a working prototype up and running as quickly as possible.</p>

<p>Instead of playing a single game laying down piece-by-piece players write scripts to play a full game for them. The two bots will face off until one crashes or wins by standard reversi rules. After a single game, script pauses and allows the players time to make the appropriate changes to their bots. Another game is played and the cycle repeats until one of the two players wins five games. Once five games have been won, the "Series" is over and an overall winner is declared.</p>

<p>I didn't bother to include a timer in the game. Players can figure out how to best handle that themselves, but some flexibility should probably be allowed.</p>

<p>Here's a link to a <a href="http://what-is-bioinformatics.blogspot.com/2015/08/bot-battle.html">blog post and video demonstration</a>.</p>

<h2><a id="user-content-practice_botpy-and-practice_bot2py" class="anchor" href="#practice_botpy-and-practice_bot2py" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>practice_bot.py and practice_bot2.py</h2>

<p>are trival examples of bots, but show how a script should be set up to interact with reversi_battle.py. The game exposes the board to each player's bot as a numpy array filled with 0's for empty spaces, and 1's and 2's for spots currently occupied by Player 1 and 2, respectively. The the script, no matter the complexity, should basically, take the current board as input, and output a new board when one of the player's pieces has been played in a valid spot (i.e. a 1 or a 2 has replaced one of the 0s). </p>

<p>These particular bots simply scans for a valid position to play and plays in the first spot it comes across. </p>

<h2><a id="user-content-practice_bot3py-and-practice_bot4py" class="anchor" href="#practice_bot3py-and-practice_bot4py" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>practice_bot3.py and practice_bot4.py</h2>

<p>are slightly more complicated, but no more strategically sound. These bots take one of two actions at random. They either copy the original bots and just play in the first available spot, or they scan all valid spots and play the spot that has the largest sum of indicies (i.e. if the bottom right corner [7,7] were avaliable, it would be chosen since it gets a score of 14).</p>

<p>These bots are slightly more useful for their ability to make a 2D array of all valid spots during a particular play. All higher level decision making written in will depend on this new array. </p>

<h2><a id="user-content-graphicspy" class="anchor" href="#graphicspy" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>graphics.py</h2>

<p>is a light weight wrapper around Tkinker. It was developped by John Zelle and can also be downloaded from <a href="http://mcsp.wartburg.edu/zelle/python/graphics.py">http://mcsp.wartburg.edu/zelle/python/graphics.py</a></p>

<h2><a id="user-content-version-and-dependencies" class="anchor" href="#version-and-dependencies" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" role="img" version="1.1" viewbox="0 0 16 16"><path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"/></svg></a>Version and Dependencies</h2>

<p>Python 2.7</p>

<p>Numpy 1.9.2 (or similar)</p>

<p>The Anaconda distribution is the reccommend method for obtaining numpy if necessary.</p>
</article>
  </div></body></html>