<html><body><div><div class="content html_format"><p>
      Тихо и незаметно (с), </p><a href="https://docs.python.org/3.5/whatsnew/3.5.html">вышел Python версии 3.5</a><p>! И, безусловно, одно из самых интересных нововведений релиза является новый синтаксис определения сопрограмм с помощью ключевых слов </p><b>async/await</b><p>, далее в статье об этом. 
</p><p>
Поверхностный просмотр </p><a href="https://www.python.org/dev/peps/pep-0492/">«PEP 0492 — Coroutines with async and await syntax»</a><p> по началу оставил у меня вопрос «Зачем это надо». Сопрограммы удовлетворительно реализуются на расширенных генераторах и на первый взгляд может показаться, что все свелось к замене </p><b>yield from</b><p> на </p><b>await</b><p>, а декоратора, создающего сопрограмму на </p><b>async</b><p>. Сюда можно добавить и возникающее ощущение, что все это сделано исключительно для использования с модулем </p><b>asyncio</b><p>.

</p><b><i>Но это, конечно же, не так, тема глубже и интереснее.</i></b>
<a name="habracut"/>
<h5>coroutine</h5><p>
Главное, наверное, это то, что теперь сопрограмма в Python — это специальный объект </p><i>native coroutine</i><p>, а не каким-то специальным образом оформленный генератор или еще что-то. Этот объект имеет методы и функции стандартной библиотеки для работы с ним. То есть теперь, это объект, определяемый как часть языка.

</p><h5>await</h5><p>
К сожалению, не нашел в документации и PEP краткое определение для чего введено это новое ключевое слово. Рискну сформулировать его сам: </p><i>Ключевое слово <b>await</b> указывает, что при выполнении следующего за ним выражения возможно переключение с текущей сопрограммы на другую или на основной поток выполнения.</i><p>
Соответственно выражение после </p><b>await</b><p> тоже не простое, это должен быть </p><b>awaitable</b><p> объект.

</p><h5>awaitable object</h5><p>
Есть три варианта awaitable объектов:
</p><ul>
<li>Другая сопрограмма, а именно объект <i>native coroutine</i>. Этот напоминает, и видимо реализовано аналогично случаю, когда в генераторе с помощью <b>yield from</b> вызывается другой генератор.</li>
<li>Сопрограмма на основе генератора, созданная с помощью декоратора <b>types.coroutine()</b>. Это вариант обеспечения совместимости с наработками, где сопрограммы реализованы на основе генераторов.</li>
<li>Специальный объект, у которого реализован магический метод <b>__await__</b>, возвращающий итератор. С помощью этого итератора реализуется возврат результата выполнения сопрограммы.</li>
</ul><p>
Примера, как написать свой </p><i>awaitable</i><p> объект ни в PEP, ни в документации не нашел, во всяком случае на момент написания статьи этого нет. Ниже этот недостаток будет исправлен.)

</p><h5>async</h5><p>
В РЕР десяток абзацев с заголовками «Why ...» и «Why not ...». Почти все они посвящены вопросу, почему это ключевое слово используется так, а не как-то иначе. И действительно, </p><b>async def</b><p> смотрится в коде странно, и вызывает размышления на тему а «pythonic way» ли это? С другой стороны, понятно, что хотели какой-то более целостной картины, так как есть еще и </p><b>async for</b><p> и </p><b>async with</b><p>.
</p><ul>
<li><b>async def</b> — определяет <i>native coroutine function</i>, результатом вызова которой будет объект-сопрограмма <i>native coroutine</i>, пока еще не запущенная.</li>
<li><b>async for</b> — определяет, что итератор используемый в цикле, при получении следующего значения может переключать выполнение с текущей сопрограммы. Объект итератор имеет вместо стандартных магических методов: <b>__iter__</b> и <b>__next__</b>, методы: <b>__aiter__</b> и <b>__anext__</b>. Функционально они аналогичны, но как следует из определения, допускают использования await в своем теле.</li>
<li><b>async with</b> — определяет, что при входе в контекстный блок и выходе из него может быть переключение выполнения с текущей сопрограммы. Так же, как и в случае с асинхронным генератором, вместо магических методов: <b>__enter__</b> и <b>__exit__</b> следует использовать функционально аналогичные <b>__aenter__</b> и <b>__aexit__</b>.</li>
</ul><p>
В определениях, которые даны в PEP написано, что в магических методах может вызываться «асинхронный код». Мне кажется, «переключение выполнения с текущей сопрограммы» более правильный вариант. Использование термина «асинхронный код» может ввести в заблуждение, потому-что «асинхронный код» часто реализуется на функциях обратного вызова, а это немного другая тема.
</p><p>
Примеры на использование асинхронных итераторов и контекст менеджеров в документации и PEP достаточно, usecase в общем-то понятен и все логично. Непонятно только одно — зачем использовать версии магических методов с другими именами, ведь они все равно объявляются с использованием `async def`. Видимо, это что-то, связанное с особенностями реализации, другого объяснения не вижу.

</p><h4>Как это готовить?</h4><p>
Изучение какой-то новой фичи языка или библиотеки быстро упирается в вопрос, как и где это использовать. И более глубокое изучение, на мой взгляд, стоит продолжать уже на практическом примере. Для меня, если тема связана с сопрограммами, асинхронностью и тому подобными вещами, такой практический пример — это написание хеллоуворда, использующего event-driven подход. Формулировка задачи такая: «Вызов функции sleep должен остановить исполнение сопрограммы на определенное время».
</p><p>
Сопрограммы и event-driven прекрасно сочетаются, в </p><a href="http://habrahabr.ru/post/243207/">другой моей статье</a><p> более подробно, почему я так считаю. И пример такого рода хорошо нам продемонстрирует почти все возможности и нюансы использования сопрограмм. 
</p><p>
Предположим, что мы имеем диспетчер событий, запущенный в основном потоке исполнения, который при возникновении ожидаемых событий вызывает функции обратного вызова. Тогда практическая реализация может быть такой:
</p><ul>
<li>Функция sleep настраивает диспетчер событий на вызов функции обратного вызова через заданный промежуток времени. После этого переключает управление в основной поток исполнения (то есть на диспетчер).</li>
<li>Переданная в диспетчер функция обратного вызова вызывается по истечении заданного времени. В ней переходит переключение на сопрограмму с передачей ей какой-то полезной информации.</li>
</ul><p>
Закодировано это может быть как-то так:
</p><pre><code class="python">from time import time
from collections import deque
from tornado.ioloop import IOLoop

current = deque()

class sleep(object):

    def __init__(self, timeout):
        self.deadline = time() + timeout

    def __await__(self):
        def swith_to(coro):
            current.append(coro)
            coro.send(time())
        IOLoop.instance().add_timeout(self.deadline, swith_to, current[0])
        current.pop()
        return (yield)

def coroutine_start(run, *args, **kwargs):
    coro = run(*args, **kwargs)
    current.append(coro)
    coro.send(None)

if __name__ == '__main__':

    async def hello(name, timeout):
        while True:
            now = await sleep(timeout)
            print("Hello, {}!\tts: {}".format(name, now))

    coroutine_start(hello, "Friends", 1.0)
    coroutine_start(hello, "World", 2.5)
    IOLoop.instance().start()
</code></pre><p>
Как видите, код краткий, достаточно понятный и, кстати, рабочий. Опишу основные моменты в нем:
</p><ol>
<li>В качестве диспетчера событий использован <b>tornado.ioloop.IOLoop</b> комментировать по моему тут особо нечего.</li>
<li>Класс <b>sleep</b> — реализует <i>awaitable</i> объект, его функция — передать управление в диспетчер событий, предварительно настроив его на вызов <i>callback</i> через заданный промежуток времени.</li>
<li>Функция обратного вызова определена как замыкание, но в данном случае это не играет никакой роли. Назначение ее — просто переключить выполнение назад на сопрограмму с передачей текущего времени. Переключение выполнения на сопрограмму, производится вызовом ее метода <b>send</b> или метода <b>throw</b> для переключения с выбросом исключения.</li>
<li>Назначение функции <b>coroutine_start</b> — это создать сопрограмму, вызвав функцию фабрику и запустить ее на выполнение. Первый вызов метода <b>send</b> сопрограммы, обязательно должен быть с параметром <b>None</b> — это запускает сопрограмму</li>
<li>Сама функция <b>hello</b> тривиальна. Может и так понятно, но думаю стоит уточнить. Эта функция не сопрограмма! Эта функция, которая создает и возвращает сопрограмму ( функция-фабрика), аналогично функциям, создающим и возвращающим генератор.</li>
</ol>
<p>
Развитие этой идеи: «async/await coroutine and event-driven», можно посмотреть </p><a href="https://github.com/Alesh/Squall/tree/master">по этой ссылке</a><p>. Оно еще сырое, но кроме продемонстрированного переключения по событию «timeout», реализовано переключение сопрограмм по событиям «I/O ready» и «system sygnal». В качестве демо, есть пример асинхронного echo server.

</p><h4>В заключение</h4><p>
Сопрограммы в том или ином виде были доступны уже достаточно давно, но не было «официальных правил игры с ними». Теперь эти «правила игры» определены и зафиксированы и это станет хорошим поводом более широко использовать в Python методы асинхронного программирования.

      	</p><div class="polling">
		

	

    <p class="for_users_only_msg">Только зарегистрированные пользователи могут участвовать в опросе. <a href="https://habrahabr.ru/auth/login/">Войдите</a>, пожалуйста.</p>
	</div>

      <p class="clear"/>
    </div>

    
  </div></body></html>