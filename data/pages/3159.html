<html><body><div><div class="content base">
			<h1>The Issue</h1>
	<p>Python is a dynamic language. The main implementation CPython, is interpreted (actually, it is compiled into code interpreted by a Python virtual machine). The Python interpreter uses a <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank">Global Interpreter Lock (GIL)</a> to protect its structures from concurrent access.</p>
	<p>Outside the Python community, you hear often that <em>Python is slow, and the GIL sucks</em>. Inside the community, the view is more positive, and indeed there is a wealth of approaches for <a title="High Performance Python book" href="http://shop.oreilly.com/product/0636920028963.do" target="_blank">High Performance Python</a>. There are different approaches for I/O-bound problems and CPU-bound problems:</p>
	<ul>
	<li> I/O bound problems can make good use of multi-threading (where the GIL is released during I/O) or asynchronous programming.</li>
	<li>CPU-bound problems can be addressed by better algorithms (nothing beats an algorithm with less computational complexity), using array-based programming (<a href="http://www.numpy.org/" target="_blank">NumPy</a>), using various problem-specific packages written in a compiled language, or using <a href="http://cython.org/" target="_blank">Cython</a>, a mix of C and Python.</li>
	<li>Application-level caches are also helpful, because no computation is always faster than the fastest possible computation.</li>
	</ul>
	<p>Some approaches are quite complex, and unless confined to a small hotspot, the advantage of Python over less dynamic languages might get lost. That’s why one author calls it <a href="http://www.jeffknupp.com/blog/2013/06/30/pythons-hardest-problem-revisited/" target="_blank">Python’s Hardest Problem</a>.</p>
	<p>The GIL constraint is removed when <strong>multiple processes</strong> are used, each with its own Python interpreter and GIL. This works nicely for problems that don’t require massive interaction between data or even massive amounts of read-only data.</p>
	<p>In my own work with <a href="https://www.swisscom.ch/en/business/enterprise/offer/banking/industialisierung-banking/middle-and-back-office-solutions.t2.html" target="_blank">Quantax</a>, the Swisscom Market Risk System, which is written in Python, we always face <a title="The need for speed – Python performs well with NumPy" href="http://ict.swisscom.ch/2014/04/pyspeed/" target="_blank">demand for increased speed</a>. Using a lot of NumPy and many levels of application caches, we achieve about 25000 valuations of financial instruments per second on one core of a laptop CPU.</p>
	<p>However, the price for this is complexity of cache invalidations, and complicated code to map the problem to NumPy.</p>
	<p>We use processes at a relative coarse-grained level, as worker processes to calculate reports. The main issue of processes is the <em>massive amount of common data</em> the financial calculations require, leading to rather large memory consumption per process. However, there is rarely more than one logical process that modifies the objects (by changing transactions or rates).</p>
	<p>If Python wants to be a viable programming environment for medium size applications with those characteristics,<strong> we need two things:</strong></p>
	<ol>
	<li><strong>Speed achievable by (just in time) compilation</strong></li>
	<li><strong>An efficient way to use dozens of cores while sharing memory.</strong></li>
	</ol>
	<p> </p>
	<h1>Solutions</h1>
	<p>With a large community, solutions are bound to come up:</p>
	<h2>PyPy</h2>
	<p>PyPy shows impressive results with its JIT compiler (<a href="http://pypy.readthedocs.org/en/latest/architecture.html" target="_blank">PyPy’s Architecture</a>; <a title="The Performance of Open Source Applications" href="http://www.aosabook.org/en/pypy.html" target="_blank">Overview article</a>). The Python programming ecosystem is large, with many packages coded in other languages. PyPy is slow in providing the whole ecosystem, and is still working on NumPy support.</p>
	<p>PyPy also made a breakthrough progress replacing the GIL by <a href="http://pypy.readthedocs.org/en/latest/stm.html" target="_blank"><strong>Software Transactional Memory (STM)</strong></a>, and getting that up to speed. This allows multi-threaded Python programs to use all cores, with acceptable overhead. It also provides an alternative to locking that may make multi-threaded programming less error-prone.</p>
	<h2>Jython, IronPython</h2>
	<p>These are implementations that target a particular language runtime, Java VM for <a href="http://www.jython.org/" target="_blank">Jython </a>and .NET for <a href="http://ironpython.net/" target="_blank">IronPython</a>. They run without the GIL, because they map Python structures to the thread-safe structures provided by their platforms.  They do not provide JIT compilation. Also, they do not uniformly provide all libraries of the CPython ecosystem.</p>
	<h2>PyParallel</h2>
	<p>PyParallel (long <a href="http://vimeo.com/79539317" target="_blank">talk</a>, <a href="https://speakerdeck.com/trent/parallelism-and-concurrency-with-python" target="_blank">slides</a>, <a href="http://www.infoq.com/articles/PyParallel" target="_blank">summary</a>) is not a solution yet, but an experiment designed to circumvent the GIL in the standard CPython interpreter, under the very specific condition that threads running without the GIL do not modify any Python objects except for those created by that thread.</p>
	<h2>Other compilers: Pyston, Nuitka</h2>
	<ul>
	<li><a href="http://nuitka.net/" target="_blank">Nuitka </a>is a full compiler, which uses the Python runtime to execute code. While admirably compatible with CPython, the achievable speedups seem to be limited to elimination of the parsing overhead and some limited static analysis.</li>
	<li><a href="https://tech.dropbox.com/2014/04/introducing-pyston-an-upcoming-jit-based-python-implementation/" target="_blank">Pyston </a>is a project to build a method-at-a-time JIT using <a href="http://llvm.org" target="_blank">LLVM </a>as its code generator.</li>
	</ul>
	<p> </p>
	<p>I admire these projects for their courage and stamina. Many of them are starving for resources (including money). I believe that PyPy is the most promising, most mature, and most complete of these efforts.</p>
	<p>Let’s see what the community can do to foster it.</p>
	<h1>Community</h1>
	<p>Python is mature, and has a large following, with a wide range of usage (ranging from short-lived glue scripts, ad-hoc analysis, <a href="http://www.raspberrypi.org/documentation/usage/python/" target="_blank">Rasperry Pi</a> applications to full blown applications such as Quantax, stacks (<a href="https://www.openstack.org/" target="_blank">OpenStack</a>) and major services  such as Youtube and Dropbox).</p>
	<p>The community is nice and helpful. There are strong opinions about what is <em>“pythonic”</em> (follows the Python way of doing things). This helps to keep Python conceptually simple<em> (low conceptual overhead).</em> There is central control over language features (by <a href="https://www.python.org/~guido/" target="_blank">Guido van Rossum</a>, the creator of Python) and over the reference implementation, CPython.</p>
	<p>Due to large installed base, the broad user base does not pick up new things very fast. Mostly due to dependencies on libraries, picking up Python 3 has been slow so far (<a href="http://www.randalolson.com/2015/01/30/python-usage-survey-2014/" target="_blank">Survey</a>;  <a href="http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html" target="_blank">Python 3 Q&amp;A</a>).</p>
	<p>Switching to a new language infrastructure such as PyPy is even slower, for several reasons:</p>
	<ul>
	<li>For many purposes, CPython is fast enough.</li>
	<li>Many usage scenarios (especially Python as a glue language) use scripts with a short execution time, for which the warmup of a JIT can be prohibitive.</li>
	<li>Many libraries of CPython call C code; they’re either not available in PyPy or calling them is slow.</li>
	<li>CPython is available on exotic platforms or not so exotic platforms (64-bit Windows) that are not currently supported by PyPy.</li>
	</ul>
	<p>All these are reasons why PyPy hasn’t replaced CPython, and will not do it in the <a title="Guido van Rossum PyCon 2012 Keynote" href="https://www.youtube.com/watch?v=EBRMq2Ioxsc#t=12m30s" target="_blank">near future</a>. Therefore, I recommend a two-pronged approach, with focus on PyPy as the most promising new technology.</p>
	<p> </p>
	<h1>Recommendations</h1>
	<p>For Python to retain its current mainstream acceptance, protect its application code base, and defend its positions against newcomers such as <a href="http://julialang.org/" target="_blank">Julia </a>and conceptually complex languages such as <a href="http://www.scala-lang.org/" target="_blank">Scala</a>, I personally believe <strong>efforts should be focused on:</strong></p>
	<ul>
	<li>CPython as the all-purpose interpreter, compatible with all legacy code and running short scripts efficiently.
	<ul>
	<li>It’s is questionable why CPython needs to provide ongoing Python 3.x support – these folks have little incentive to upgrade anyway!</li>
	<li>PyParallel should become part of CPython, to provide immediate relief for those who need it and can live with its constraints.</li>
	</ul>
	</li>
	<li>PyPy as the high-performance, STM-enabled reference implementation, where performance and modern techniques make a difference.</li>
	<li>Platform-centric implementations will remain a niche (or dead end when resources run out), or should be re-targeted to run on top of PyPy’s infrastructure.</li>
	</ul>
	<p>.</p>
	<h1>Participate!</h1>
	<p>If you are a Python user, you are part of the community, and might want to get involved. This is very welcome! As many other open source projects, PyPy is looking for financial contributions and for volunteer work:</p>
	<ul>
	<li>You may <strong>donate</strong> to <a href="http://pypy.org/" target="_blank">general development</a>, or to a specific topic such as <a href="http://pypy.org/tmdonate2.html" target="_blank">STM</a>.</li>
	<li>You may also become a developer – the best occasion for Swiss people (and ski fans) will be the upcoming <strong><a href="http://morepypy.blogspot.ch/2015/01/leysin-winter-sprint-20-28th-february.html" target="_blank">Leysin Winter Sprint</a> </strong>(20-28th February 2015).</li>
	<li>Windows system cracks may also be interested in helping to finally port <a href="http://pypy.readthedocs.org/en/latest/windows.html#what-is-missing-for-a-full-64-bit-translation" target="_blank">PyPy to Windows 64</a>.</li>
	</ul>				
			
			<hr/>
			
			
		</div>
	
		</div></body></html>