<html><body><div><div id="articleText">
                    <div id="articleLongDescription"><p>There are numerous problems with threads in Python, but Python can work around almost all of these issues with </p><em>coroutines</em><p>, which let you have many seemingly simultaneous functions in your Python programs. Brett Slatkin discusses coroutines in this excerpt from </p><a href="/store/effective-python-59-specific-ways-to-write-better-python-9780134034287?w_ptgrevartcl=Effective+Python+Item+40%3a+Consider+Coroutines+to+Run+Many+Functions+Concurrently_2320938">Effective Python: 59 Specific Ways to Write Better Python</a><p>.</p></div>
                    <p id="articleDescription"/>

                    <a class="relatedBookLink" href="#">From the author of <span class="ss-icon"></span></a>
                    
                    

                <p>Threads give Python programmers a way to run multiple functions seemingly at the same time (see Item 37: “Use Threads for Blocking I/O, Avoid for Parallelism”). But there are three big problems with threads:</p>
<ul>
<li>They require special tools to coordinate with each other safely (see Item 38: “Use <tt>Lock</tt> to Prevent Data Races in Threads” and Item 39: “Use <tt>Queue</tt> to Coordinate Work Between Threads”). This makes code that uses threads harder to reason about than procedural, single-threaded code. This complexity makes threaded code more difficult to extend and maintain over time.</li>
<li>Threads require a lot of memory, about 8 MB per executing thread. On many computers, that amount of memory doesn’t matter for a dozen threads or so. But what if you want your program to run tens of thousands of functions “simultaneously”? These functions may correspond to user requests to a server, pixels on a screen, particles in a simulation, etc. Running a thread per unique activity just won’t work.</li>
<li>Threads are costly to start. If you want to constantly be creating new concurrent functions and finishing them, the overhead of using threads becomes large and slows everything down.</li>
</ul>

<p>Python can work around all these issues with <em>coroutines</em>. Coroutines let you have many seemingly simultaneous functions in your Python programs. They’re implemented as an extension to generators. The cost of starting a generator coroutine is a function call. Once active, they each use less than 1 KB of memory until they’re exhausted.</p>

<p>Coroutines work by enabling the code consuming a generator to <tt>send</tt> a value back into the generator function after each <tt>yield</tt> expression. The generator function receives the value passed to the <tt>send</tt> function as the result of the corresponding <tt>yield</tt> expression.</p>

<pre><code>def</code> my_coroutine():
    <code>while True</code>:
        received <code>=</code> <code>yield</code>
        <code>print</code>(<code>'Received:'</code>, received)

it <code>=</code> my_coroutine()
<code>next</code>(it)             <code># Prime the coroutine</code>
it.send(<code>'First'</code>)
it.send(<code>'Second'</code>)

&gt;&gt;&gt;
Received: First
Received: Second</pre>

<p>The initial call to <tt>next</tt> is required to prepare the generator for receiving the first <tt>send</tt> by advancing it to the first <tt>yield</tt> expression. Together, <tt>yield</tt> and <tt>send</tt> provide generators with a standard way to vary their next yielded value in response to external input.</p>

<p>For example, say you want to implement a generator coroutine that yields the minimum value it’s been sent so far. Here, the bare <tt>yield</tt> prepares the coroutine with the initial minimum value sent in from the outside. Then the generator repeatedly yields the new minimum in exchange for the next value to consider.</p>

<pre><code>def</code> minimize():
    current <code>=</code> <code>yield</code>
    <code>while True</code>:
        value <code>=</code> <code>yield</code> current
        current <code>=</code> <code>min</code>(value, current)</pre>

<p>The code consuming the generator can run one step at a time and will output the minimum value seen after each input.</p>

<pre>it <code>=</code> minimize()
<code>next</code>(it)            <code># Prime the generator</code>
<code>print</code>(it.send(<code>10</code>))
<code>print</code>(it.send(<code>4</code>))
<code>print</code>(it.send(<code>22</code>))
<code>print</code>(it.send(<code>-</code><code>1</code>))

&gt;&gt;&gt;
10
4
4
-1</pre>

<p>The generator function will seemingly run forever, making forward progress with each new call to <tt>send</tt>. Like threads, coroutines are independent functions that can consume inputs from their environment and produce resulting outputs. The difference is that coroutines pause at each <tt>yield</tt> expression in the generator function and resume after each call to <tt>send</tt> from the outside. This is the magical mechanism of coroutines.</p>

<p>This behavior allows the code consuming the generator to take action after each <tt>yield</tt> expression in the coroutine. The consuming code can use the generator’s output values to call other functions and update data structures. Most importantly, it can advance other generator functions until their next <tt>yield</tt> expressions. By advancing many separate generators in lockstep, they will all seem to be running simultaneously, mimicking the concurrent behavior of Python threads.</p>

<h3>The Game of Life</h3>

<p>Let me demonstrate the simultaneous behavior of coroutines with an example. Say you want to use coroutines to implement Conway’s Game of Life. The rules of the game are simple. You have a two-dimensional grid of an arbitrary size. Each cell in the grid can either be alive or empty.</p>

<pre>ALIVE <code>=</code> <code>'*'</code>
EMPTY <code>=</code> <code>'-'</code></pre>

<p>The game progresses one tick of the clock at a time. At each tick, each cell counts how many of its neighboring eight cells are still alive. Based on its neighbor count, each cell decides if it will keep living, die, or regenerate. Here’s an example of a 5×5 Game of Life grid after four generations with time going to the right. I’ll explain the specific rules further below.</p>

<pre>  0   |   1   |   2   |   3   |   4
----- | ----- | ----- | ----- | -----
-*--- | --*-- | --**- | --*-- | -----
--**- | --**- | -*--- | -*--- | -**--
---*- | --**- | --**- | --*-- | -----
----- | ----- | ----- | ----- | -----</pre>

<p>I can model this game by representing each cell as a generator coroutine running in lockstep with all the others.</p>

<p>To implement this, first I need a way to retrieve the status of neighboring cells. I can do this with a coroutine named <tt>count_neighbors</tt> that works by yielding <tt>Query</tt> objects. The <tt>Query</tt> class I define myself. Its purpose is to provide the generator coroutine with a way to ask its surrounding environment for information.</p>

<pre>Query <code>=</code> namedtuple(<code>'Query'</code>, (<code>'y'</code>, <code>'x'</code>))</pre>

<p>The coroutine yields a <tt>Query</tt> for each neighbor. The result of each <tt>yield</tt> expression will be the value <tt>ALIVE</tt> or <tt>EMPTY</tt>. That’s the interface contract I’ve defined between the coroutine and its consuming code. The <tt>count_neighbors</tt> generator sees the neighbors’ states and returns the count of living neighbors.</p>

<pre><code>def</code> count_neighbors(y, x):
    n_ <code>=</code> <code>yield</code> Query(y <code>+</code> <code>1,</code> x <code>+</code> <code>0</code>)  <code># North</code>
    ne <code>=</code> <code>yield</code> Query(y <code>+</code> <code>1,</code> x <code>+</code> <code>1</code>)  <code># Northeast</code>
    <code># Define e_, se, s_, sw, w_, nw ...</code>
    <code># ...</code>
    neighbor_states <code>=</code> [n_, ne, e_, se, s_, sw, w_, nw]
    <code>count</code> <code>=</code> <code>0</code>
    <code>for</code> state <code>in</code> neighbor_states:
        if state <code>==</code> ALIVE:
            <code>count</code> <code>+=</code> <code>1</code>
    <code>return</code> count</pre>

<p>I can drive the <tt>count_neighbors</tt> coroutine with fake data to test it. Here, I show how <tt>Query</tt> objects will be yielded for each neighbor. <tt>count_neighbors</tt> expects to receive cell states corresponding to each <tt>Query</tt> through the coroutine’s <tt>send</tt> method. The final count is returned in the <tt>StopIteration</tt> exception that is raised when the generator is exhausted by the <tt>return</tt> statement.</p>

<pre>it <code>=</code> count_neighbors(<code>10</code>, <code>5</code>)
q1 <code>=</code> <code>next</code>(it)                  <code># Get the first query</code>
<code>print</code>(<code>'First yield: '</code>, q1)
q2 <code>=</code> it.send(ALIVE)            <code># Send q1 state, get q2</code>
<code>print</code>(<code>'Second yield:'</code>, q2)
q3 <code>=</code> it.send(ALIVE)            <code># Send q2 state, get q3</code>
<code># ...</code>
try:
    count <code>=</code> it.send(EMPTY)     <code># Send q8 state, retrieve count</code>
<code>except</code> StopIteration <code>as</code> e:
    <code>print</code>(<code>'Count: '</code>, e.value)  <code># Value from return statement</code>
&gt;&gt;&gt;
First yield:  Query(y=11, x=5)
Second yield: Query(y=11, x=6)
...
Count:  2</pre>

<p>Now I need the ability to indicate that a cell will transition to a new state in response to the neighbor count that it found from <tt>count_neighbors</tt>. To do this, I define another coroutine called <tt>step_cell</tt>. This generator will indicate transitions in a cell’s state by yielding <tt>Transition</tt> objects. This is another class that I define, just like the <tt>Query</tt> class.</p>

<pre>Transition <code>=</code> namedtuple(<code>'Transition'</code>, (<code>'y'</code>, <code>'x'</code>, <code>'state'</code>))</pre>

<p>The <tt>step_cell</tt> coroutine receives its coordinates in the grid as arguments. It yields a <tt>Query</tt> to get the initial state of those coordinates. It runs <tt>count_neighbors</tt> to inspect the cells around it. It runs the game logic to determine what state the cell should have for the next clock tick. Finally, it yields a <tt>Transition</tt> object to tell the environment the cell’s next state.</p>

<pre><code>def</code> game_logic(state, neighbors):
    <code># ...</code>

<code>def</code> step_cell(y, x):
    state <code>=</code> <code>yield</code> Query(y, x)
    neighbors <code>=</code> <code>yield from</code> count_neighbors(y, x)
    next_state <code>=</code> game_logic(state, neighbors)
    <code>yield</code> Transition(y, x, next_state)</pre>


<p>Importantly, the call to <tt>count_neighbors</tt> uses the <tt>yield from</tt> expression. This expression allows Python to compose generator coroutines together, making it easy to reuse smaller pieces of functionality and build complex coroutines from simpler ones. When <tt>count_neighbors</tt> is exhausted, the final value it returns (with the <tt>return</tt> statement) will be passed to <tt>step_cell</tt> as the result of the <tt>yield from</tt> expression.</p>

<p>Now, I can finally define the simple game logic for Conway’s Game of Life. There are only three rules.</p>

<pre><code>def</code> game_logic(state, neighbors):
    if state <code>==</code> ALIVE:
        if neighbors <code>&lt;</code> 2:
            return EMPTY     <code># Die: Too few</code>
        elif neighbors <code>&gt;</code> 3:
            return EMPTY     <code># Die: Too many</code>
    else:
        if neighbors <code>==</code> 3:
            return ALIVE     <code># Regenerate</code>
    return state</pre>

<p>I can drive the <tt>step_cell</tt> coroutine with fake data to test it.</p>

<pre>it <code>=</code> step_cell(<code>10</code>, <code>5</code>)
q0 <code>=</code> <code>next</code>(it)           <code># Initial location query</code>
<code>print</code>(<code>'Me:      '</code>, q0)
q1 <code>=</code> it.send(ALIVE)     <code># Send my status, get neighbor query</code>
<code>print</code>(<code>'Q1:      '</code>, q1)
<code># ...</code>
t1 <code>=</code> it.send(EMPTY)     <code># Send for q8, get game decision</code>
<code>print</code>(<code>'Outcome: '</code>, t1)

&gt;&gt;&gt;
Me:       Query(y=10, x=5)
Q1:       Query(y=11, x=5)
...
Outcome:  Transition(y=10, x=5, state='-')</pre>

<p>The goal of the game is to run this logic for a whole grid of cells in lockstep. To do this, I can further compose the <tt>step_cell</tt> coroutine into a <tt>simulate</tt> coroutine. This coroutine progresses the grid of cells forward by yielding from <tt>step_cell</tt> many times. After progressing every coordinate, it yields a <tt>TICK</tt> object to indicate that the current generation of cells have all transitioned.</p>

<pre>TICK <code>=</code> <code>object</code>()

<code>def</code> simulate(height, width):
<code>    while True:</code>
        <code>for</code> y <code>in</code> <code>range</code>(height):
            for x in <code>range</code>(width):
                <code>yield from</code> step_cell(y, x)
        <code>yield</code> TICK</pre>

<p>What’s impressive about <tt>simulate</tt> is that it’s completely disconnected from the surrounding environment. I still haven’t defined how the grid is represented in Python objects, how <tt>Query</tt>, <tt>Transition</tt>, and <tt>TICK</tt> values are handled on the outside, nor how the game gets its initial state. But the logic is clear. Each cell will transition by running <tt>step_cell</tt>. Then the game clock will tick. This will continue forever, as long as the <tt>simulate</tt> coroutine is advanced.</p>

<p>This is the beauty of coroutines. They help you focus on the logic of what you’re trying to accomplish. They decouple your code’s instructions for the environment from the implementation that carries out your wishes. This enables you to run coroutines seemingly in parallel. This also allows you to improve the implementation of following those instructions over time without changing the coroutines.</p>

<p>Now, I want to run <tt>simulate</tt> in a real environment. To do that, I need to represent the state of each cell in the grid. Here, I define a class to contain the grid:</p>

<pre><code>class</code> Grid(<code>object</code>):
    <code>def</code> __init__(self, height, width):
        self.height <code>=</code> height
        self.width <code>=</code> width
        self.rows <code>=</code> []
        <code>for</code> _ <code>in</code> <code>range</code>(self.height):
            self.rows.append([EMPTY] <code>*</code> self.width)

    <code>def</code> __str__(self):
        <code># ...</code></pre>

<p>The grid allows you to get and set the value of any coordinate. Coordinates that are out of bounds will wrap around, making the grid act like infinite looping space.</p>

<pre>    <code>def</code> query(self, y, x):
        <code>return</code> self.rows[y <code>%</code> self.height][x <code>%</code> self.width]

    <code>def</code> assign(self, y, x, state):
        self.rows[y <code>%</code> self.height][x <code>%</code> self.width] <code>=</code> state</pre>

<p>At last, I can define the function that interprets the values yielded from <tt>simulate</tt> and all of its interior coroutines. This function turns the instructions from the coroutines into interactions with the surrounding environment. It progresses the whole grid of cells forward a single step and then returns a new grid containing the next state.</p>

<pre><code>def</code> live_a_generation(grid, sim):
    progeny <code>=</code> Grid(grid.height, grid.width)
    item <code>=</code> <code>next</code>(sim)
    <code>while</code> item <code>is not</code> TICK:
        <code>if</code> <code>isinstance</code>(item, Query):
            state <code>=</code> grid.query(item.y, item.x)
            item <code>=</code> sim.send(state)
        <code>else:</code>  <code># Must be a Transition</code>
            progeny.assign(item.y, item.x, item.state)
            item <code>=</code> <code>next</code>(sim)
    <code>return</code> progeny</pre>

<p>To see this function in action, I need to create a grid and set its initial state. Here, I make a classic shape called a glider.</p>

<pre>grid <code>=</code> Grid(<code>5</code>, <code>9</code>)
grid.assign(<code>0</code>, <code>3</code>, ALIVE)
<code># ...</code>
<code>print</code>(grid)

&gt;&gt;&gt;
---*-----
----*----
--***----
---------
---------</pre>

<p>Now I can progress this grid forward one generation at a time. You can see how the glider moves down and to the right on the grid based on the simple rules from the <tt>game_logic</tt> function.</p>

<pre><code>class</code> ColumnPrinter(<code>object</code>):
    <code># ...</code>

columns <code>=</code> ColumnPrinter()
sim <code>=</code> simulate(grid.height, grid.width)
<code>for</code> i <code>in</code> <code>range</code>(5):
    columns.append(<code>str</code>(grid))
    grid <code>=</code> live_a_generation(grid, sim)

<code>print</code>(columns)

&gt;&gt;&gt;
    0     |     1     |     2     |     3     |     4
---*----- | --------- | --------- | --------- | ---------
----*---- | --*-*---- | ----*---- | ---*----- | ----*----
--***---- | ---**---- | --*-*---- | ----**--- | -----*---
--------- | ---*----- | ---**---- | ---**---- | ---***---
--------- | --------- | --------- | --------- | ---------</pre>

<p>The best part about this approach is that I can change the <tt>game_logic</tt> function without having to update the code that surrounds it. I can change the rules or add larger spheres of influence with the existing mechanics of <tt>Query</tt>, <tt>Transition</tt>, and <tt>TICK</tt>. This demonstrates how coroutines enable the separation of concerns, which is an important design principle.</p>

<h3>Coroutines in Python 2</h3>

<p>Unfortunately, Python 2 is missing some of the syntactical sugar that makes coroutines so elegant in Python 3. There are two limitations. First, there is no <tt>yield from</tt> expression. That means that when you want to compose generator coroutines in Python 2, you need to include an additional loop at the delegation point.</p>

<pre><code># Python 2</code>
<code>def</code> delegated():
<code>    yield 1</code>
<code>    yield 2</code>

<code>def</code> composed():
    <code>yield</code> <code>'A'</code>
    <code>for</code> value <code>in</code> delegated():  <code># yield from in Python 3</code>
        yield value
    <code>yield</code> <code>'B'</code>

<code>print list</code>(composed())

&gt;&gt;&gt;
['A', 1, 2, 'B']</pre>

<p>The second limitation is that there is no support for the <tt>return</tt> statement in Python 2 generators. To get the same behavior that interacts correctly with <tt>try</tt>/<tt>except</tt>/<tt>finally</tt> blocks, you need to define your own exception type and raise it when you want to return a value.</p>

<pre><code># Python 2</code>
<code>class</code> MyReturn(Exception):
    <code>def</code> __init__(self, value):
        self.value <code>=</code> value

<code>def</code> delegated():
<code>    yield 1</code>
    <code>raise</code> MyReturn(<code>2</code>)  <code># return 2 in Python 3</code>
    <code>yield</code> <code>'Not reached'</code>

<code>def</code> composed():
    try:
        <code>for</code> value <code>in</code> delegated():
            <code>yield</code> value
    <code>except</code> MyReturn <code>as</code> e:
        output <code>=</code> e.value
    <code>yield</code> output <code>*</code> <code>4</code>

<code>print list</code>(composed())

&gt;&gt;&gt;
[1, 8]</pre>

<h3>Things to Remember</h3>
<ul>
<li>Coroutines provide an efficient way to run tens of thousands of functions seemingly at the same time.</li>
<li>Within a generator, the value of the <tt>yield</tt> expression will be whatever value was passed to the generator’s <tt>send</tt> method from the exterior code.</li>
<li>Coroutines give you a powerful tool for separating the core logic of your program from its interaction with the surrounding environment.</li>
<li>Python 2 doesn’t support <tt>yield from</tt> or returning values from generators.</li>
</ul>

            </div>
            </div></body></html>