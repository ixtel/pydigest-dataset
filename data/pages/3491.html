<html><body><div><div class="content html_format"><p>
      Тим Петерс разработал </p><a href="http://ru.wikipedia.org/wiki/Timsort">гибридный алгоритм сортировки Timsort</a><p> в 2002 году. Алгоритм представляет собой искусную комбинацию идей сортировки слиянием и сортировки вставками и заточен на эффективную работу с реальными данными. Впервые Timsort был разработан для Python, но затем </p><a href="http://en.wikipedia.org/wiki/Joshua_Bloch">Джошуа Блох</a><p> (создатель коллекций Java, именно он, кстати, отметил, что </p><a href="http://habrahabr.ru/post/203398/">большинство алгоритмов двоичного поиска содержит ошибку</a><p>) портировал его на Java (методы java.util.Collections.sort и java.util.Arrays.sort). Сегодня Timsort является стандартным алгоритмом сортировки в Android SDK, Oracle JDK и OpenJDK. Учитывая популярность этих платформ, можно сделать вывод, что счёт компьютеров, облачных сервисов и мобильных устройств, использующих Timsort для сортировки, идёт на миллиарды.
</p><p>
Но вернёмся в 2015-й год. После того как мы успешно верифицировали Java-реализации </p><a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BF%D0%BE%D0%B4%D1%81%D1%87%D1%91%D1%82%D0%BE%D0%BC">сортировки подсчётом</a><p> и </p><a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">поразрядной сортировки</a><p> (</p><a href="http://link.springer.com/article/10.1007%2Fs10817-013-9300-y">J. Autom. Reasoning 53(2), 129-139</a><p>) нашим инструментом формальной верификации под названием </p><a href="http://www.key-project.org/">KeY</a><p>, мы искали новый объект для изучения. Timsort казался подходящей кандидатурой, потому что он довольно сложный и широко используется. К сожалению, мы не смогли доказать его корректность. Причина этого при детальном рассмотрении оказалась проста: в реализации Timsort есть баг. Наши теоретические исследования указали нам, где искать ошибку (любопытно, что ошибка была уже в питоновской реализации). В данной статье рассказывается, как мы этого добились.
</p><p>
Статья с более полным анализом, а также несколько тестовых программ доступны на </p><a href="http://www.envisage-project.eu/timsort-specification-and-verification/">нашем сайте</a><p>.
</p><a name="habracut"/>
<b>Содержание</b>
<ol>
<li><a href="#sec1">Баг в реализации Timsort на Android, Java и Python</a><br/>
<a href="#sec11">1.1 Воспроизводим баг Timsort на Java</a><br/>
<a href="#sec12">1.2 Как в принципе работает Timsort?</a><br/>
<a href="#sec13">1.3 Баг Timsort шаг за шагом</a></li>
<li><a href="#sec2">Доказательство (не)корректности Timsort</a><br/>
<a href="#sec21">2.1 Система верификации KeY</a><br/>
<a href="#sec22">2.2 Исправление и его формальная спецификация</a><br/>
<a href="#sec23">2.3 Анализ результатов работы KeY</a></li>
<li><a href="#sec3">Предложенные исправления бага к реализациям Timsort на Python и Android/Java</a><br/>
<a href="#sec31">3.1 Некорректная функция merge_collapse (Python)</a><br/>
<a href="#sec32">3.2 Исправленная функция merge_collapse (Python)</a><br/>
<a href="#sec33">3.3 Некорректная функция mergeCollapse (Java/Android)</a><br/>
<a href="#sec34">3.4 Исправленная функция mergeCollapse (Java/Android)</a></li>
<li><a href="#sec4">Заключение: какие из этого следуют выводы?</a></li>
</ol>
<h2><a name="sec1"/>1. Баг в реализации Timsort на Android, Java и Python</h2><p>
Так в чём же заключается баг? И почему бы вам не попробовать воспроизвести его самим?

</p><h3><a name="sec11"/>1.1 Воспроизводим баг Timsort на Java</h3>
<pre><code>git clone https://github.com/abstools/java-timsort-bug.git
cd java-timsort-bug
javac *.java
java TestTimSort 67108864</code></pre>
<b>Если баг присутствует, вы увидите такой результат</b>
<pre><code>Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 40
at java.util.TimSort.pushRun(TimSort.java:413)
at java.util.TimSort.sort(TimSort.java:240)
at java.util.Arrays.sort(Arrays.java:1438)
at TestTimSort.main(TestTimSort.java:18)
</code></pre>
<strong>Видеозапись воспроизведения ошибки</strong>
<iframe src="https://www.youtube.com/embed/HSyJ8f7h0jI?feature=oembed" frameborder="0" allowfullscreen="">VIDEO</iframe>

<h3><a name="sec12"/>1.2 Как в принципе работает Timsort?</h3><p>
Тimsort — это гибридный алгоритм, который использует сортировку вставкой и сортировку слиянием.
</p><p>
Алгоритм переупорядочивает входной массив слева направо, находя в нём последовательные (неперекрывающиеся) сортированные сегменты («серии», или runs). Если серия короче определённой минимальной длины, она дополняется последующими элементами и сортируется вставкой. Длины созданных серий добавляются в конец массива </p><b>runLen</b><p>. Когда новая серия добавляется в </p><b>runLen</b><p>, метод mergeCollapse сливает серии, пока три последних элемента в </p><b>runLen</b><p> не будут удовлетворять следующей паре условий, которая называется «</p><b>инвариантом</b><p>»:

</p><ol>
<li><b>runLen </b>[n-2] &gt; <b>runLen </b>[n-1] + <b>runLen </b>[n]</li>
<li><b>runLen </b>[n-1] &gt; <b>runLen</b> [n]</li>
</ol><p>
Здесь n — это индекс последней серии в runLen. Идея была в том, что проверка этого инварианта для последних трёх серий гарантирует, что все последовательные тройки серий будут ему удовлетворять. В конце сливаются все серии, что даёт в результате полностью отсортированный входной массив.
</p><p>
Из соображений эффективности желательно выделить как можно меньше памяти под </p><b>runLen</b><p>, но её должно быть достаточно, чтобы туда заведомо поместились все серии. Если инвариант выполняется для всех серий, длина серий будет расти экспоненциально (даже быстрее, чем числа Фибоначчи: длина каждой серии строго больше суммы длин двух последующих). Так как серии не перекрываются, их потребуется не так много, чтобы полностью отсортировать даже огромный входной массив.

</p><h3><a name="sec13"/>1.3 Баг Timsort шаг за шагом</h3><p>
Из следующего фрагмента кода видно, что реализация mergeCollapse проверяет инвариант для последних трёх серий в </p><b>runLen</b><p>:
</p><pre><code class="java">private void mergeCollapse() {
  while (stackSize &gt; 1) {
    int n = stackSize - 2;
    if (n &gt; 0 &amp;&amp; runLen[n-1] &lt;= runLen[n] + runLen[n+1]) {
      if (runLen[n - 1] &lt; runLen[n + 1])
         n--;
      mergeAt(n);
    } else if (runLen[n] &lt;= runLen[n + 1]) {
      mergeAt(n);
    } else {
      break; // инвариант установлен
    }
  }
}
</code></pre><p>
К сожалению, этого не достаточно, чтобы все серии удовлетворяли инварианту. Предположим, что </p><b>runLen</b><p> содержит такой набор длин перед выполнением mergeCollapse (n=4):
</p><pre><code>120, 80, 25, 20, 30</code></pre><p>
На первом проходе цикла while будут объединены серии длиной 25 и 20 (так как 25 &lt; 20 + 30 и 25 &lt; 30):
</p><pre><code>120, 80, 45, 30</code></pre><p>
На втором проходе цикла (теперь n=3), мы определяем, что инвариант установлен для последних трёх серий, потому что 80 &gt; 45 + 30 и 45 &gt; 30, поэтому mergeCollapse завершает работу. </p><b>Но mergeCollapse не восстановил инвариант для всего массива: он нарушается в первой тройке, так как 120 &lt; 80 + 45.</b>
<p>
Генератор тестов на нашем </p><a href="http://www.envisage-project.eu/timsort-specification-and-verification/">сайте</a><p> позволяет выявить эту проблему. Он создаёт входной массив с множеством коротких серий, при этом их длины не удовлетворяют инварианту, что приводит к падению Timsort. Истинная причина ошибки в том, что из-за нарушения инварианта длины серий растут медленнее, чем ожидалось, в результате чего их количество превышает </p><b>runLen.length</b><p> и это приводит к ArrayOutOfBoundsException.

</p><h2><a name="sec2"/>2. Доказательство (не)корректности Timsort</h2><p>
Мы обнаружили, что инвариант mergeCollapse нарушается, когда пытались формально верифицировать Timsort. К счастью, мы также поняли, как его исправить. В итоге нам даже удалось верифицировать исправленную версию, в которой инвариант действительно соблюдается. Но не будем спешить. Для начала разберёмся, что такое формальная верификация и как она выполняется.

</p><h3><a name="sec21"/>2.1 Система верификации KeY</h3>
<a href="http://www.key-project.org">KeY</a><p> — это платформа дедуктивной верификации однопоточных программ на Java и JavaCard. Она позволяет </p><b><i>доказать</i></b><p> корректность программ по заданной спецификации. Грубо говоря, спецификация состоит из </p><b>предусловий</b><p> (в терминах KeY — </p><b>requires</b><p>) и </p><b>постусловий</b><p> (в терминах KeY — </p><b>ensures</b><p>). Спецификации задаются перед методами, которые их реализуют (например, перед упомянутым выше mergeCollapse()). Спецификация метода также называется его </p><b>контрактом</b><p>.
</p><p>
В случае сортировки предусловие просто утверждает, что на вход подаётся непустой массив, а постусловие требует, чтобы результирующий массив был сортирован и являлся перестановкой входного. Система KeY доказывает, что если верифицируемый метод вызвать с входными данными, которые удовлетворяют предусловиям, то метод завершится нормально и результирующее состояние будет удовлетворять постусловию. Это также называется </p><b>полной корректностью</b><p>, потому что доказывается и нормальное завершение метода. Как мы увидели, метод java.util.Arrays.sort() из OpenJDK не соблюдает этот контракт, потому что для определённых входных данных он завершается исключением.
</p><p>
Дополнительно используются инварианты классов и объектов, чтобы указать общие ограничения на значения полей. Обычно проверяется согласованность данных или граничные условия:
</p><pre><code class="java">/*@ private invariant
  @    runBase.length == runLen.length &amp;&amp; runBase != runLen;
  @*/
</code></pre><p>
Этот инвариант говорит, что длины массивов runBase и runLen должны совпадать, но в то же время это должны быть два разных массива. Семантика инвариантов подразумевает, что каждый метод на выходе должен не только обеспечивать постусловия своего контракта, но и инварианты его собственного объекта “this”.
</p><p>
В качестве языка спецификаций KeY использует </p><a href="http://www.jmlspecs.org/">Java Modeling Language</a><p> (JML). Выражения на нём пишутся как на обычном языке Java, поэтому Java-программисты его легко освоят. Главное расширение JML — это кванторы (</p><b>\forall</b><p> T x — для любого T, </p><b>\exists</b><p> T x — существует T) и, конечно, специальные ключевые слова для контрактов. Спецификации JML приводятся в комментариях java-файлов перед кодом, к которому они относятся. Ниже приведён простой пример Java-метода с JML-спецификацией:

</p><pre><code class="java">/*@ private normal_behavior
  @ requires
  @   n &gt;= MIN_MERGE;
  @ ensures
  @   \result &gt;= MIN_MERGE/2;
  @*/

private static int /*@ pure @*/ minRunLength(int n) {
  assert n &gt;= 0;
  int r = 0;      // Становится 1 если хотя бы один единичный бит был удалён сдвигом
  /*@ loop_invariant n &gt;= MIN_MERGE/2 &amp;&amp; r &gt;=0 &amp;&amp; r&lt;=1;
    @ decreases n;
    @ assignable \nothing;
    @*/
  while (n &gt;= MIN_MERGE) {
    r |= (n &amp; 1);
    n &gt;&gt;= 1;
  }
  return n + r;
}
</code></pre><p>
Контракт minRunLength() содержит одно предусловие: входной параметр должен быть не меньше, чем MIN_MERGE. В этом случае (и только в этом) метод обещает завершиться нормально (не зациклиться и не выбросить исключение) и вернуть значение, которое больше или равно MIN_MERGE/2. Дополнительно метод помечен как </p><b>pure</b><p> (чистый). Это означает, что метод не модифицирует кучу.
</p><p>
Ключевой момент в том, что система KeY способна </p><b>статически</b><p> доказать контракты подобных методов для </p><b>любых</b><p> входных параметров. Как это возможно? KeY производит символьное выполнение верифицируемого метода, то есть, выполняет его, используя символьные значения, так что учитываются все возможные пути выполнения. Но этого недостаточно, потому что символьное выполнение циклов с нефиксированным числом итераций (таких как цикл в mergeCollapse(), где мы не знаем значение stackSize) никогда не завершится. Чтобы символьное выполнение циклов стало конечным, используется логика инвариантов. Например, вышеприведённый метод minRunLength() содержит цикл, спецификация которого выражена инвариантом цикла. Инвариант утверждает, что после каждой итерации выполняется условие </p><code>n &gt;= MIN_MERGE/2 &amp;&amp; r &gt;= 0 &amp;&amp; r &lt;= 1</code><p>, и из этого можно доказать постусловие всего метода. Аннотация </p><b>decreases</b><p> (уменьшается) используется, чтобы доказать завершение цикла. В ней указывается выражение, значение которого неотрицательно и строго уменьшается. Конструкция </p><b>assignable</b><p> перечисляет объекты кучи, которые могут быть изменены в цикле. Ключевое слово </p><b>\nothing</b><p> означает, что куча не модифицируется. И действительно: цикл изменяет только локальную переменную r и аргумент n.
</p><p>
В общем, для формальной верификации недостаточно контрактов методов. Необходимо также приводить инварианты циклов. Иногда очень непросто придумать инвариант, который соблюдается в цикле и при этом достаточно силён, чтобы из него вывести постусловие метода. Без инструментальной поддержки и технологии автоматизированного доказательства теорем вряд ли возможно составить правильные инварианты циклов в нетривиальных программах. На самом деле именно здесь и кроется ошибка создателей Timsort. При определённых условиях цикл в mergeCollapse нарушает следующий инвариант класса Timsort (смотрите раздел </p><a href="http://sec13">1.3 Баг Timsort шаг за шагом</a><p>):

</p><pre><code class="java">/*@ private invariant 
  @   (\forall int i; 0&lt;=i &amp;&amp; i&lt;stackSize-4; 
  @                      runLen[i] &gt; runLen[i+1] + runLen[i+2]))
  @*/
</code></pre><p>
Этот инвариант утверждает, что runLen[i] должно быть больше, чем сумма двух последующих элементов, для любых неотрицательных i, меньших stackSize-4. Инвариант не восстанавливается и после цикла, поэтому весь метод mergeCollapse не сохраняет инвариант класса. Следовательно, инвариант цикла не такой строгий, как предполагали разработчики. Это мы и обнаружили в процессе нашей попытки верифицировать Timsort с помощью KeY. Без специального инструмента обнаружить это было бы почти невозможно.
</p><p>
Хотя JML и очень похож на Java, это полноценный язык программирования по контракту, подходящий для полной функциональной верификации Java-программ.

</p><h3><a name="sec22"/>2.2 Исправление и его формальная спецификация</h3>
<i>Упрощённая</i><p> версия контракта, который по задумке авторов должен соблюдаться в mergeCollapse, приведена ниже.
</p><pre><code class="java">/*@ requires
  @   stackSize &gt; 0 &amp;&amp;
  @   runLen[stackSize-4] &gt; runLen[stackSize-3]+runLen[stackSize-2]
  @   &amp;&amp; runLen[stackSize-3] &gt; runLen[stackSize-2];
  @ ensures
  @   (\forall int i; 0&lt;=i &amp;&amp; i&lt;stackSize-2; 
  @                     runLen[i] &gt; runLen[i+1] + runLen[i+2])
  @   &amp;&amp; runLen[stackSize-2] &gt; runLen[stackSize-1]
  @*/
private void mergeCollapse()
</code></pre><p>
Две формулы в </p><b>ensures</b><p> подразумевают, что когда mergeCollapse завершается, </p><b><i>все</i></b><p> серии удовлетворяют инварианту, приведённому в </p><a href="#sec12">разделе 1.2</a><p>. Мы уже видели, что этот контракт не выполняется в текущей реализации mergeCollapse (</p><a href="#sec13">раздел 1.3</a><p>). Теперь мы приводим исправленную версию, которая соблюдает контракт:

</p><pre><code class="java">private void newMergeCollapse() {
  while (stackSize &gt; 1) {
    int n = stackSize - 2;
    if (n &gt; 0   &amp;&amp; runLen[n-1] &lt;= runLen[n] + runLen[n+1] || 
        n-1 &gt; 0 &amp;&amp; runLen[n-2] &lt;= runLen[n] + runLen[n-1]) {
      if (runLen[n - 1] &lt; runLen[n + 1])
        n--;
    } else if (n&lt;0 || runLen[n] &gt; runLen[n + 1]) {
      break; // инвариант установлен
    }
    mergeAt(n);
  }
}
</code></pre><p>
Основная идея этой версии — проверять, что инвариант соблюдается для </p><i>четырёх последних серий</i><p> в runLen вместо </p><i>трёх</i><p>. Как мы увидим ниже, этого достаточно, чтобы длины </p><b>всех</b><p> серий удовлетворяли инварианту после завершения mergeCollapse.
</p><p>
Первый шаг в доказательстве контракта для исправленной версии mergeCollapse — это найти подходящий инвариант цикла. Вот его упрощённая версия:

</p><pre><code class="java">/*@ loop_invariant
  @  (\forall int i; 0&lt;=i &amp;&amp; i&lt;stackSize-4; 
  @             runLen[i] &gt; runLen[i+1] + runLen[i+2])
  @  &amp;&amp; runLen[stackSize-4] &gt; runLen[stackSize-3])
  @*/
</code></pre><p>
Интуитивно инвариант цикла утверждает, что все серии кроме, возможно, последних четырёх, удовлетворяют условию. При этом заметим, что цикл завершается (по оператору break), только если последние четыре серии тоже ему удовлетворяют. Таким образом, можно гарантировать, что все серии удовлетворяют инварианту.

</p><h3><a name="sec23"/>2.3 Анализ результатов работы KeY</h3><p>
Когда мы подаём на вход KeY исправленную версию mergeCollapse вместе с контрактом и инвариантом цикла, система производит символьное выполнение цикла и генерирует условия верификации: формулы, из истинности которых следует, что контракт mergeCollapse выполняется. Следующая (упрощённая) формула показывает главное условие доказательства корректности mergeCollapse, сгенерированное KeY:

</p><img src="http://habrastorage.org/getpro/habr/post_images/987/b13/cfe/987b13cfef5913dfc19ff3677c7960f6.png"/>
<p>
Формула утверждает, что из условий в скобках, которые истинны после завершения цикла, должно следовать постусловие mergeCollapse. Понятно, откуда взялись выражения в скобках: оператор break, который завершает цикл, выполняется только когда они все истинны. Мы формально доказали эту формулу (и все прочие условия верификации) с помощью KeY в полуавтоматическом режиме. Ниже приведён набросок доказательства:

</p><i>Доказательство</i><p>. Формула </p><i>runLen[stackSize-2] &gt; runLen[stackSize-1]</i><p> из постусловия mergeCollapse прямо следует из </p><i>n &gt;= 0 ==&gt; runLen[n] &gt; runLen[n+1]</i><p>.
</p><p>
Докажем следующую формулу:

</p><i>\forall int i; 0&lt;=i &amp;&amp; i&lt;stackSize-2; runLen[i] &gt; runLen[i+1] + runLen[i+2]</i><p>.
</p><p>
Возможны следующие варианты значения i:

</p><ul>
<li>i &lt; stackSize-4: соответствует инварианту цикла</li>
<li>i = stackSize-4: следует из n&gt;1 ==&gt; runLen[n-2] &gt; runLen[n-1] + runLen[n]</li>
<li>i = stackSize-3: следует из n&gt;0 ==&gt; runLen[n-1] &gt; runLen[n] + runLen[n+1]</li>
</ul><p>
Это доказательство показывает, что новая версия </p><i>mergeCollapse</i><p> завершается только когда </p><b>все</b><p> серии удовлетворяют инварианту.

</p><h2><a name="sec3"/>3. Предложенные исправления бага к реализациям Timsort на Python и Android/Java</h2><p>
Наш анализ ошибки (включая исправление </p><i>mergeCollapse</i><p>) был отправлен, рассмотрен и принят в </p><a href="https://bugs.openjdk.java.net/browse/JDK-8072909">багтрекер Java</a><p>.
</p><p>
Баг присутствует как минимум в версии Java для Android, OpenJDK и OracleJDK: во всех используется одинаковый код Timsort. Также баг присутствует в Python. В следующих разделах приводятся оригинальная и исправленная версии.
</p><p>
Как было сказано выше, идея исправления очень проста: проверять, что инвариант выполняется для последних четырёх серий в runLen, а не только для трёх.

</p><h3><a name="sec31"/>3.1 Некорректная функция merge_collapse (Python)</h3><p>
Timsort для Python (написан на C с использованием Python API) доступен </p><a href="https://hg.python.org/cpython/file/5c1bacba828d/Objects/listobject.c">в репозитории subversion</a><p> – Алгоритм также описан </p><a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">здесь</a><p>.
</p><p>
Версия Timsort для Java была портирована с CPython. Версия на CPython содержит ошибку, разработанная для поддержки массивов вплоть до 2</p><sup>64</sup><p> элементов, также содержит ошибку. Однако на современных машинах вызвать ошибку переполнения массива невозможно: алгоритм выделяет 85 элементов для runLen, и этого хватает (как показывает наш анализ в полной статье) для массивов, содержащих не более 2</p><sup>49</sup><p> элементов. Для сравнения, мощнейший на сегодняшний день суперкомпьютер </p><a href="http://en.wikipedia.org/wiki/Tianhe-2">Tianhe-2</a><p> обладает 2</p><sup>50</sup><p> байтами памяти.

</p><pre><code class="cpp">/* The maximum number of entries in a MergeState's 
 * pending-runs stack.
 * This is enough to sort arrays of size up to about
 *     32 * phi ** MAX_MERGE_PENDING
 * where phi ~= 1.618.  85 is ridiculously large enough, 
 * good for an array with 2**64 elements.
 */
#define MAX_MERGE_PENDING 85

merge_collapse(MergeState *ms)
{
    struct s_slice *p = ms-&gt;pending;

    assert(ms);
    while (ms-&gt;n &gt; 1) {
        Py_ssize_t n = ms-&gt;n - 2;
        if (n &gt; 0 &amp;&amp; p[n-1].len &lt;= p[n].len + p[n+1].len) {
            if (p[n-1].len &lt; p[n+1].len)
                --n;
            if (merge_at(ms, n) &lt; 0)
                return -1;
        }
        else if (p[n].len &lt;= p[n+1].len) {
                 if (merge_at(ms, n) &lt; 0)
                        return -1;
        }
        else
            break;
    }
    return 0;
}
</code></pre>
<h3><a name="sec32"/>3.2 Исправленная функция merge_collapse (Python)</h3>
<pre><code class="cpp">merge_collapse(MergeState *ms)
{
    struct s_slice *p = ms-&gt;pending;

    assert(ms);
    while (ms-&gt;n &gt; 1) {
        Py_ssize_t n = ms-&gt;n - 2;
        if (     n &gt; 0   &amp;&amp; p[n-1].len &lt;= p[n].len + p[n+1].len
            || (n-1 &gt; 0 &amp;&amp;  p[n-2].len &lt;= p[n].len + p[n-1].len)) {
            if (p[n-1].len &lt; p[n+1].len)
                --n;
            if (merge_at(ms, n) &lt; 0)
                return -1;
        }
        else if (p[n].len &lt;= p[n+1].len) {
                 if (merge_at(ms, n) &lt; 0)
                        return -1;
        }
        else
            break;
    }
    return 0;
}
</code></pre>
<h3><a name="sec33"/>3.3 Некорректная функция mergeCollapse (Java/Android)</h3><p>
Ошибка полностью аналогична ошибке в Python:
</p><pre><code class="java">   private void mergeCollapse() {
        while (stackSize &gt; 1) {
            int n = stackSize - 2;
            if (n &gt; 0 &amp;&amp; runLen[n-1] &lt;= runLen[n] + runLen[n+1]) {
                if (runLen[n - 1] &lt; runLen[n + 1])
                    n--;
                mergeAt(n);
            } else if (runLen[n] &lt;= runLen[n + 1]) {
                mergeAt(n);
            } else {
                break; // Инвариант установлен
            }
        }
    }
</code></pre>
<h3><a name="sec34"/>3.4 Исправленная функция mergeCollapse (Java/Android)</h3><p>
Исправление аналогично приведённому выше для Python.</p><p>
[UPDATE 26/2: мы изменили код по сравнению с исходной версией статьи. Старый код был эквивалентен, но содержал избыточную проверку и отличался по стилю. Спасибо всем, кто обратил внимание!]
</p><pre><code class="java">   private void newMergeCollapse() {
     while (stackSize &gt; 1) {
       int n = stackSize - 2;
       if (   (n &gt;= 1 &amp;&amp; runLen[n-1] &lt;= runLen[n] + runLen[n+1])
           || (n &gt;= 2 &amp;&amp; runLen[n-2] &lt;= runLen[n] + runLen[n-1])) {
                if (runLen[n - 1] &lt; runLen[n + 1])
                    n--;
            } else if (runLen[n] &gt; runLen[n + 1]) {
                break; // Инвариант установлен
            }
            mergeAt(n);
        }
    }
</code></pre>
<h2><a name="sec4"/>4. Заключение: какие из этого следуют выводы?</h2><p>
При попытке верифицировать Timsort нам не удалось установить инвариант объекта сортировки. Анализируя причины неудачи, мы обнаружили в реализации Timsort ошибку, которая приводит к ArrayOutOfBoundsException для определённых входных данных. Мы предложили исправление ошибочного метода (без ощутимого снижения производительности) и формально доказали, что исправление корректно и ошибки больше нет.
</p><p>
Из этой истории, помимо собственно найденной ошибки, можно сделать несколько наблюдений.
</p><ol>
<li>Зачастую программисты считают формальные методы непрактичными и/или далёкими от реальных задач. Это не так: мы нашли и исправили ошибку в программном обеспечении, которым пользуются миллиарды пользователей каждый день. Как показал наш анализ, найти и исправить такой баг без формального анализа и инструмента для верификации было бы практически невозможно. Ошибка долгие годы жила в стандартной библиотеке языков Java и Python. Её проявления <a href="https://bugs.openjdk.java.net/browse/JDK-8011944">замечали ранее</a> и даже думали, что исправили, но в действительности добились только того, что ошибка стала возникать реже.</li>
<li>Хотя маловероятно, что такая ошибка возникнет случайно, легко представить, как можно её использовать для атаки. Вероятно, в стандартных библиотеках популярных языков программирования кроются и другие незамеченные ошибки. Может быть, стоит заняться их поиском до того как они причинят вред или будут использованы злоумышленниками?</li>
<li>Реакция разработчиков Java на наш отчёт в некотором смысле разочаровывает. Вместо того, чтобы использовать нашу исправленную (и верифицированную!) версию mergeCollapse(), они <a href="http://hg.openjdk.java.net/jdk9/dev/jdk/rev/e276aa5b8a4b">предпочли увеличить</a> выделенный размер runLen до «достаточного» размера. Как мы показали, вовсе не обязательно было так делать. Но теперь каждый, кто использует java.utils.Collection.sort() будет вынужден тратить больше памяти. Учитывая астрономическое число программ, использующих настолько базовую функцию, это приведёт к заметным дополнительным затратам энергии. Мы можем только догадываться, почему не было принято наше решение: возможно разработчики JDK не удосужились прочитать наш отчёт полностью и поэтому не поняли суть исправления и решили не полагаться на него. В конце концов, OpenJDK разрабатывает сообщество, в значительной степени состоящее из добровольцев, у которых не так много времени.</li>
</ol>
<p>
Какие из этого следуют выводы? Мы были бы счастливы, если бы наша работа послужила начальной точкой для более тесного взаимодействия между исследователями формальных методов и разработчиками открытых программных платформ. Формальные методы уже успешно применяются в </p><a href="http://research.microsoft.com/en-us/um/people/lamport/tla/formal-methods-amazon.pdf">Amazon</a><p> и </p><a href="https://research.facebook.com/publications/422671501231772/moving-fast-with-software-verification/">Facebook</a><p>. Современные языки формальной спецификации и инструменты формальной верификации </p><b>не являются</b><p> такими уж запутанными и суперсложными в изучении. Постоянно улучшается их юзабилити и автоматизация. Но нам нужно больше людей, которые бы пробовали, тестировали и использовали наши инструменты. Да, потребуются некоторые усилия, чтобы начать писать формальные спецификации и верифицировать код, но это не сложнее, чем, например, разобраться, как использовать компилятор или средство сборки проектов. Но речь идёт о днях или неделях, а не месяцах или годах. Ну как, </p><b>вы</b><p> принимаете вызов?
</p><p>
С наилучшими пожеланиями,
</p><a href="https://www.cwi.nl/people/2306">Стайн де Гув</a><p>, </p><a href="http://jurriaan.me/">Юриан Рот</a><p>, </p><a href="http://homepages.cwi.nl/~frb/">Франк де Бур</a><p>, </p><a href="https://www.se.tu-darmstadt.de/se/group-members/richard-bubel/">Ричард Бубель</a><p> и </p><a href="https://www.se.tu-darmstadt.de/se/group-members/reiner-haehnle/">Райнер Хенле</a><p>.

</p><h4>Благодарности</h4><p>
Работа частично поддержана проектом седьмой рамочной программы Евросоюза FP7-610582 ENVISAGE: </p><a href="http://www.envisage-project.eu">Engineering Virtualized Services</a><p>.</p><p>
Эта статья не была бы написана без поддержки и вежливых напоминаний </p><a href="http://memkite.com/team/">Амунда Твейта</a><p>! Также мы хотим поблагодарить Беруза Нобакта за то, что предоставил нам видео, демонстрирующее ошибку.

</p><img src="http://habrastorage.org/getpro/habr/post_images/28e/d55/c0a/28ed55c0ad2cfa8b7346d26938cd17b4.gif" alt="Envisage logo"/>
      <p class="clear"/>
    </div>

    
  </div></body></html>