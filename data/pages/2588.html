<html><body><div><div class="inside">

    <abbr class="published" title="2014-12-28T17:00:00+01:00">
      <em>Sun 28 December 2014</em>
    </abbr>

        <h2>Things which aren't magic - Flask and @app.route - Part 1</h2>
        <p/><p>It's been a while since I've posted so figured it's about time I started a new series on my blog. </p>
<p>Here's the first edition of a series I'm calling "Things which aren't magic", where I show how some of the nicer APIs provided by popular open source packages are constructed from the primitives of their respective languages.</p>
<p>In this post we're going to take a look at <a href="flask.pocoo.org">Flask</a>, and more specifically how Flask makes it possible to write "@app.route()" at the top of the function and expose its result to the internet.</p>
<p>Below is the first example given to us on the Flask Homepage, and the first example which we're going to deconstruct in order to better understand how "@app.route()" works.</p>
<div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">"/"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">"Hello World!"</span>
</pre></div>


<h3>@app.route and other decorators</h3>
<p>In order to begin understanding how "@app.route()" works we first need to look at decorators in Python (the things which start with "@", and go above function definitions).</p>
<p>What is a decorator exactly? Nothing special! A decorator is just a function which takes in a function (the one which you decorated with the "@" symbol) and returns a new function. </p>
<p>When you decorate a function, you're telling Python to call the new function returned by your decorator, instead of just running the body of your function directly.</p>
<p>Still not 100% sure? Here's a simple example:</p>
<div class="highlight"><pre><span class="c"># This is our decorator</span>
<span class="k">def</span> <span class="nf">simple_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="c"># This is the new function we're going to return</span>
    <span class="c"># This function will be used in place of our original definition</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">"Entering Function"</span>
        <span class="n">f</span><span class="p">()</span>
        <span class="k">print</span> <span class="s">"Exited Function"</span>

    <span class="k">return</span> <span class="n">wrapper</span>

<span class="nd">@simple_decorator</span> 
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">"Hello World"</span>

<span class="n">hello</span><span class="p">()</span>
</pre></div>


<p>Running the above will give produce the following output:</p>
<div class="highlight"><pre>Entering Function
Hello World
Exited Function
</pre></div>


<p>Great! </p>
<p>Now we're part of the way to understanding how to build our own "@app.route()" decorator, but one difference you may have noticed is that our simple decorator doesn't take in any parameters, but "app.route()" does. </p>
<p>So how can we pass arguments to our decorator? To do that we just create a "decorator factory" function, which we can call, returning the decorator to apply to our function. Let's see how that looks in practice.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">decorator_factory</span><span class="p">(</span><span class="n">enter_message</span><span class="p">,</span> <span class="n">exit_message</span><span class="p">):</span>
    <span class="c"># We're going to return this decorator</span>
    <span class="k">def</span> <span class="nf">simple_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
            <span class="k">print</span> <span class="n">enter_message</span>
            <span class="n">f</span><span class="p">()</span>
            <span class="k">print</span> <span class="n">exit_message</span>

        <span class="k">return</span> <span class="n">wrapper</span>

    <span class="k">return</span> <span class="n">simple_decorator</span>

<span class="nd">@decorator_factory</span><span class="p">(</span><span class="s">"Start"</span><span class="p">,</span> <span class="s">"End"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">"Hello World"</span>

<span class="n">hello</span><span class="p">()</span>
</pre></div>


<p>Will give us the output:</p>



<p>Note that when we write <em>@decorator_factory("Start", "End")</em> we're actually calling the function <em>decorator_factory</em>, which returns the actual decorator that is used, neat, huh?</p>
<h3>Putting the "app" in "app.route"</h3>
<p>Now we know everything we're going to need to know about how decorators work in order to reimplement this part of the Flask API, so lets switch our attention to the importance of the "app" in our Flask Application.</p>
<p>In order to start understanding what's going on inside the Flask object, we'll create our own Python class, NotFlask.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">NotFlask</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">NotFlask</span><span class="p">()</span>
</pre></div>


<p>Not a very interesting class, but one thing to note is that methods of a class can also be used as decorators, so lets make our class a little bit more interesting by adding a method called route which will be a simple decorator factory.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">NotFlask</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">route</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">route_str</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">f</span>

        <span class="k">return</span> <span class="n">decorator</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">NotFlask</span><span class="p">()</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">"/"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">"Hello World!"</span>
</pre></div>


<p>The main difference between this decorator and the decorators that we have created before, is that we don't want to modify the behaviour of the function we're decorating, we just want a reference to it.</p>
<p>So, for our final trick, we're going to use the fact that we're allowed to use side effects inside our decorator function to store a link between the route given to us, and the decorated function that should be associated with it.</p>
<p>To do this we'll add a "routes" dictionary to our NotFlask object, and when our "decorator" function gets called we'll insert the route into our new dicitionary along with the function that it maps to.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">NotFlask</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">routes</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">route</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">route_str</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">routes</span><span class="p">[</span><span class="n">route_str</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
            <span class="k">return</span> <span class="n">f</span>

        <span class="k">return</span> <span class="n">decorator</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">NotFlask</span><span class="p">()</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">"/"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">"Hello World!"</span>
</pre></div>


<p>Now we're almost there! But what use is that dictionary of routes if there's no way to access the view functions inside of it? Lets add a method <em>serve(path)</em>, which gives us the result of running a function for a given route if it exists or raises an exception if the route has not been registered yet.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">NotFlask</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">routes</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">route</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">route_str</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">routes</span><span class="p">[</span><span class="n">route_str</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
            <span class="k">return</span> <span class="n">f</span>

        <span class="k">return</span> <span class="n">decorator</span>

    <span class="k">def</span> <span class="nf">serve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="n">view_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">routes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">view_function</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">view_function</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">'Route "{}"" has not been registered'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>


<span class="n">app</span> <span class="o">=</span> <span class="n">NotFlask</span><span class="p">()</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">"/"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">"Hello World!"</span>
</pre></div>


<p>In this series we're just focusing on replicating the nice APIs of popular libraries, so actually hooking the "serve" method up to a HTTP server is a bit out of the scope of this post, but rest assured, running the following snippet:</p>
<div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">NotFlask</span><span class="p">()</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">"/"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">"Hello World!"</span>

<span class="k">print</span> <span class="n">app</span><span class="o">.</span><span class="n">serve</span><span class="p">(</span><span class="s">"/"</span><span class="p">)</span>
</pre></div>


<p>Will give us:</p>



<p>We've managed a very simple reimplementation of the first example on the Flask website, so lets write some quick tests to check that the behaviour of our small reimplementation of the Flask "@app.route()" is correct.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">TestNotFlask</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">app</span> <span class="o">=</span> <span class="n">NotFlask</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_valid_route</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nd">@self.app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
            <span class="k">return</span> <span class="s">'Hello World'</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">serve</span><span class="p">(</span><span class="s">'/'</span><span class="p">),</span> <span class="s">'Hello World'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_invalid_route</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">serve</span><span class="p">(</span><span class="s">'/invalid'</span><span class="p">)</span>
</pre></div>


<h3>Taking a quick breather.</h3>
<p><strong>That's it!</strong> So, all it takes is a simple decorator, along with a a dictionary to replicate the basic behaviour of the "app.route()" decorator in Flask.</p>
<p>In the next post in this series, and the final post on Flask's app.route() we're going to look at how dynamic URL patterns work, by deconstructing the following example.</p>
<div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">"/hello/&lt;username&gt;"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_user</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">"Hello {} !"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">username</span><span class="p">)</span>
</pre></div>


<p>Stay tuned!</p>


        

        
    </div>
</div></body></html>