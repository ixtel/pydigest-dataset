<html><body><div><div id="blog-content">

  <p id="blog-menu">
    <a href="/blog/2014/10-12-debian-daemons-with-supervisord.html">Previous</a>
    <a href="/blog/2014/10-21-high-performance-python-extensions-part-2.html">Next</a>
    <a href="/blog/all.html">All</a>
  </p>
  
  <h1 id="blog-title">High Performance Python Extensions: Part 1</h1>

  <p id="blog-editing-info">By J. David Lee on 2014-10-19.</p>

  <hr/>

  



<h2>Introduction</h2>

<p>It's commonly said that Python isn't a high performance language, and
in some sense that's true. However, due to the
<a href="http://www.scipy.org/about.html">ecosystem</a> of numeric and scientific
packages that has grown around <a href="http://www.numpy.org">NumPy</a>,
reasonable performance can generally be achieved without too much
difficulty.</p>

<p>When performance is an issue, run-time is generally dominated by a
small number of functions. By rewriting these functions in C,
performance can often be drastically improved.</p>

<p>In the first part of this series we'll look at how to write a Python
extension in C using NumPy's C API in order to improve the performance
of a toy simulation. In future posts we'll build on our solution here
to further improve its performance.</p>

<h3>Files</h3>

<p>The files referenced in this post are available on
<a href="https://github.com/johnnylee/python-numpy-c-extension-examples">github</a>. </p>



<h2>The Simulation</h2>

<p>As a starting point for this exercise, we'll consider a
two-dimensional N-body simulation for N bodies under the influence of
a gravity-like force.</p>

<p>What follows is a class that will be used to store the state of our
world, as well as some temporary variables. </p>

<div class="codehilite"><pre><code><span class="c"># lib/sim.py</span>

<span class="k">class</span> <span class="nc">World</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""World is a structure that holds the state of N bodies and</span>
<span class="sd">    additional variables.</span>

<span class="sd">    threads : (int) The number of threads to use for multithreaded</span>
<span class="sd">              implementations.</span>
<span class="sd">    dt      : (float) The time-step. </span>

<span class="sd">    STATE OF THE WORLD: </span>

<span class="sd">    N : (int) The number of bodies in the simulation.</span>
<span class="sd">    m : (1D ndarray) The mass of each body.</span>
<span class="sd">    r : (2D ndarray) The position of each body.</span>
<span class="sd">    v : (2D ndarray) The velocity of each body.</span>
<span class="sd">    F : (2D ndarray) The force on each body.</span>

<span class="sd">    TEMPORARY VARIABLES:</span>

<span class="sd">    Ft : (3D ndarray) A 2D force array for each thread's local storage.</span>
<span class="sd">    s  : (2D ndarray) The vectors from one body to all others. </span>
<span class="sd">    s3 : (1D ndarray) The norm of each s vector. </span>

<span class="sd">    NOTE: Ft is used by parallel algorithms for thread-local</span>
<span class="sd">          storage. s and s3 are only used by the Python</span>
<span class="sd">          implementation.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                 <span class="n">m_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">m_max</span><span class="o">=</span><span class="mf">30.0</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="mf">50.0</span><span class="p">,</span> <span class="n">v_max</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threads</span> <span class="o">=</span> <span class="n">threads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span>  <span class="o">=</span> <span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">m_min</span><span class="p">,</span> <span class="n">m_max</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">r_max</span><span class="p">,</span> <span class="n">r_max</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">v_max</span><span class="p">,</span> <span class="n">v_max</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">threads</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>
</code></pre></div>

<p>When the simulation begins, <code>N</code> bodies are randomly assigned a mass,
<code>m</code>, position, <code>r</code>, and velocity, <code>v</code>. For each time-step, the
following computations are made: </p>

<ol>
<li>The net force, <code>F</code>, on each body due to all other bodies is
computed.  </li>
<li>The velocity, <code>v</code>, of each body is modified due to the force.</li>
<li>The position, <code>r</code>, of each body is modified due to its velocity.</li>
</ol>

<p>The frist step, computing <code>F</code>, will be our bottleneck. The force on a
single body is the sum of forces due to every other body in the
world. This leads to O(N<sup>2</sup>) complexity. The <code>v</code> and <code>r</code>
updates are both O(N). </p>

<p>If you're interested, this <a href="https://en.wikipedia.org/wiki/N-body_simulation">Wikipedia
article</a> introduces
some approximations that can speed up the computation of forces.</p>



<h2>Pure Python</h2>

<p>An implementation of the time evolution function in pure Python, using
NumPy arrays, provides a starting point for optimization, and a
reference against which to test other implementations. </p>

<div class="codehilite"><pre><code><span class="c"># lib/sim.py</span>

<span class="k">def</span> <span class="nf">compute_F</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="sd">"""Compute the force on each body in the world, w."""</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
        <span class="n">w</span><span class="o">.</span><span class="n">s</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">r</span> <span class="o">-</span> <span class="n">w</span><span class="o">.</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">w</span><span class="o">.</span><span class="n">s3</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">s</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">w</span><span class="o">.</span><span class="n">s</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">1.5</span>
        <span class="n">w</span><span class="o">.</span><span class="n">s3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c"># This makes the self-force zero.</span>
        <span class="n">w</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">m</span><span class="p">[:,</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">s</span> <span class="o">/</span> <span class="n">w</span><span class="o">.</span><span class="n">s3</span><span class="p">[:,</span><span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">evolve</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
    <span class="sd">"""Evolve the world, w, through the given number of steps."""</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
        <span class="n">compute_F</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">w</span><span class="o">.</span><span class="n">v</span> <span class="o">+=</span> <span class="n">w</span><span class="o">.</span><span class="n">F</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">dt</span> <span class="o">/</span> <span class="n">w</span><span class="o">.</span><span class="n">m</span><span class="p">[:,</span><span class="bp">None</span><span class="p">]</span>
        <span class="n">w</span><span class="o">.</span><span class="n">r</span> <span class="o">+=</span> <span class="n">w</span><span class="o">.</span><span class="n">v</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">dt</span>
</code></pre></div>

<p>The O(N<sup>2</sup>) nature of the net force calculation is masked by
NumPy's array notation. Each array operation performs a loop over the
array elements.</p>

<h3>Visualization</h3>

<p>Here's a plot of the paths of seven bodies evolving from a random
initial state:</p>

<p><img src="10-19-example-paths.png" alt="State Machine Diagram"/></p>

<h3>Performance</h3>

<p>In order to benchmark this implementation, we create a script in the
project directory containing the following:</p>

<div class="codehilite"><pre><code><span class="kn">import</span> <span class="nn">lib</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">World</span><span class="p">(</span><span class="mi">101</span><span class="p">)</span>
<span class="n">lib</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)</span>
</code></pre></div>

<p>We benchmark the script using the <code>cProfile</code> module.</p>

<div class="codehilite"><pre><code>python -m cProfile -scum bench.py
</code></pre></div>

<p>The first few lines show us that <code>compute_F</code> is indeed our bottleneck, accounting for over 99% of the run-time.</p>

<div class="codehilite"><pre><code><span class="m">428710</span> <span class="k">function</span> calls <span class="o">(</span><span class="m">428521</span> primitive calls<span class="o">)</span> in 16.836 seconds

   Ordered by: cumulative <span class="nb">time</span>

<span class="nb">   </span>ncalls  tottime  percall  cumtime  percall filename:lineno<span class="o">(</span><span class="k">function</span><span class="o">)</span>
        <span class="m">1</span>    0.000    0.000   16.837   16.837 bench.py:2<span class="o">(</span>&lt;module&gt;<span class="o">)</span>
        <span class="m">1</span>    0.062    0.062   16.756   16.756 sim.py:60<span class="o">(</span>evolve<span class="o">)</span>
     <span class="m">4096</span>   15.551    0.004   16.693    0.004 sim.py:51<span class="o">(</span>compute_F<span class="o">)</span>
   <span class="m">413696</span>    1.142    0.000    1.142    0.000 <span class="o">{</span>method <span class="s1">'sum'</span> ...
        <span class="m">3</span>    0.002    0.001    0.115    0.038 __init__.py:1<span class="o">(</span>&lt;module&gt;<span class="o">)</span>
      ...
</code></pre></div>

<p>With 101 bodies on an Intel i5 desktop, this implementation is able to
evolve the world through 257 time-steps per second. </p>



<h2>Simple C Extension 1</h2>

<p>In this section we'll look at a C extension module implementing the
<code>evolve</code> function. It may be helpful to have a copy of the C file
while going through this section. The file, <code>src/simple1.c</code>, is
available on
<a href="https://github.com/johnnylee/python-numpy-c-extension-examples/blob/master/src/simple1.c">github</a>.</p>

<p>For additional documentation on NumPy's C API, see the <a href="http://docs.scipy.org/doc/numpy/reference/">NumPy
Reference</a>. Python's C API
is documented in detail <a href="https://docs.python.org/2/c-api/">here</a>.</p>

<h3>Boilerplate</h3>

<p>The first thing in the file is a forward declaration of our evolve
function. This will be used directly below in the method list.</p>

<div class="codehilite"><pre><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span><span class="nf">evolve</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> 
</code></pre></div>

<p>The next thing is the method list. </p>

<div class="codehilite"><pre><code><span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">{</span> <span class="s">"evolve"</span><span class="p">,</span> <span class="n">evolve</span><span class="p">,</span> <span class="n">METH_VARARGS</span><span class="p">,</span> <span class="s">"Doc string."</span><span class="p">},</span>
  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">}</span> <span class="cm">/* Sentinel */</span>
<span class="p">};</span>
</code></pre></div>

<p>This is a list of exported methods for the extension module. Here we
only have one method named <code>evolve</code>. </p>

<p>The last bit of boilerplate is the module initialization. </p>

<div class="codehilite"><pre><code><span class="n">PyMODINIT_FUNC</span> <span class="nf">initsimple1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">Py_InitModule</span><span class="p">(</span><span class="s">"simple1"</span><span class="p">,</span> <span class="n">methods</span><span class="p">);</span>
  <span class="n">import_array</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>Note that the name in <code>initsimple1</code> has to match the first argument to
<code>Py_InitModule</code> as shown here. The <code>import_array</code> call is necessary
for any extension using the NumPy API. </p>

<h3>Array Access Macros</h3>

<p>The array access macros can be used to correctly index into an array
regardless of how it's been reshaped or sliced. These macros also make
the code following them much more readable.</p>

<div class="codehilite"><pre><code><span class="cp">#define m(x0) (*(npy_float64*)((PyArray_DATA(py_m) +                \</span>
<span class="cp">                                (x0) * PyArray_STRIDES(py_m)[0])))</span>
<span class="cp">#define m_shape(i) (py_m-&gt;dimensions[(i)])</span>

<span class="cp">#define r(x0, x1) (*(npy_float64*)((PyArray_DATA(py_r) +                \</span>
<span class="cp">                                    (x0) * PyArray_STRIDES(py_r)[0] +   \</span>
<span class="cp">                                    (x1) * PyArray_STRIDES(py_r)[1])))</span>
<span class="cp">#define r_shape(i) (py_r-&gt;dimensions[(i)])</span>
</code></pre></div>

<p>Here we see accessor macros for a one and two dimensional
array. Arrays with higher dimensionality can be accessed in a similar
fashion.</p>

<p>With the help of these macros, we can loop through <code>r</code> using the
following code:</p>

<div class="codehilite"><pre><code><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r_shape</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">r_shape</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">r</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Zero all elements. </span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h4>A Note on Naming</h4>

<p>The macros defined above will only work if the matching NumPy array
objects are defined with the correct names. In the code above, the
arrays are named <code>py_m</code> and <code>py_r</code>. In order to use the same macros
across different functions, the names of the NumPy arrays need to be
kept consistent.</p>

<h3>Computing the Forces</h3>

<p>The function that computes the force array looks fairly verbose,
especially when compared to the five lines of Python above.</p>

<div class="codehilite"><pre><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">compute_F</span><span class="p">(</span><span class="n">npy_int64</span> <span class="n">N</span><span class="p">,</span>
                             <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">py_m</span><span class="p">,</span>
                             <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">py_r</span><span class="p">,</span>
                             <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">py_F</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">npy_int64</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
  <span class="n">npy_float64</span> <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">Fx</span><span class="p">,</span> <span class="n">Fy</span><span class="p">,</span> <span class="n">s3</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>

  <span class="c1">// Set all forces to zero. </span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">F</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Compute forces between pairs of bodies.</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">sx</span> <span class="o">=</span> <span class="n">r</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="n">sy</span> <span class="o">=</span> <span class="n">r</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

      <span class="n">s3</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sx</span><span class="o">*</span><span class="n">sx</span> <span class="o">+</span> <span class="n">sy</span><span class="o">*</span><span class="n">sy</span><span class="p">);</span>
      <span class="n">s3</span> <span class="o">*=</span> <span class="n">s3</span> <span class="o">*</span> <span class="n">s3</span><span class="p">;</span>

      <span class="n">tmp</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="n">s3</span><span class="p">;</span>
      <span class="n">Fx</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="n">sx</span><span class="p">;</span>
      <span class="n">Fy</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="n">sy</span><span class="p">;</span>

      <span class="n">F</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+=</span> <span class="n">Fx</span><span class="p">;</span>
      <span class="n">F</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+=</span> <span class="n">Fy</span><span class="p">;</span>

      <span class="n">F</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-=</span> <span class="n">Fx</span><span class="p">;</span>
      <span class="n">F</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-=</span> <span class="n">Fy</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Notice that we've reduced the range of the inner-loop by using
Newton's third law: forces occur in pairs of equal magnitude and
opposing direction. Unfortunately it's still O(N<sup>2</sup>). </p>

<h3>The Evolution Function</h3>

<p>The final function in the file is the exported <code>evolve</code> function. </p>

<div class="codehilite"><pre><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span><span class="nf">evolve</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// Declare variables. </span>
  <span class="n">npy_int64</span> <span class="n">N</span><span class="p">,</span> <span class="n">threads</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">npy_float64</span> <span class="n">dt</span><span class="p">;</span>
  <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">py_m</span><span class="p">,</span> <span class="o">*</span><span class="n">py_r</span><span class="p">,</span> <span class="o">*</span><span class="n">py_v</span><span class="p">,</span> <span class="o">*</span><span class="n">py_F</span><span class="p">;</span>

  <span class="c1">// Parse arguments. </span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">"ldllO!O!O!O!"</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">threads</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">dt</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">steps</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">N</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">PyArray_Type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">py_m</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">PyArray_Type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">py_r</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">PyArray_Type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">py_v</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">PyArray_Type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">py_F</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Evolve the world. </span>
  <span class="k">for</span><span class="p">(</span><span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">step</span><span class="o">&lt;</span> <span class="n">steps</span><span class="p">;</span> <span class="o">++</span><span class="n">step</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">compute_F</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">py_m</span><span class="p">,</span> <span class="n">py_r</span><span class="p">,</span> <span class="n">py_F</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+=</span> <span class="n">F</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">/</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+=</span> <span class="n">F</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">/</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

      <span class="n">r</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+=</span> <span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
      <span class="n">r</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+=</span> <span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">Py_RETURN_NONE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Here we see how the Python arguments are parsed. In the time-step loop
at the bottom of the function, we see the explicit computation of the
x and y components of the velocity and position vectors.</p>

<h3>Performance</h3>

<p>It shouldn't be surprising that the C version of the <code>evolve</code> function
is faster than the Python version. On the same i5 desktop mentioned
above, the C implementation of the <code>evolve</code> function is able to step
through 17972 time-steps per second. That's a factor of 70 improvement
over the Python implementation. </p>



<h2>Observations</h2>

<p>Notice that the C code has been kept as simple as possible. Input
arguments and output arrays can be type checked and allocated in a
Python wrapper function. Removing allocations not only speeds up
processing, but removes the potential for memory leaks (or worse)
resulting from incorrect reference counts on Python objects.</p>



<h2>Next Time</h2>

<p>In the next part of this series, we'll improve on the performance of
this implementation by taking advantage of C-contiguous NumPy
arrays. After that we'll look at using Intel's SIMD instructions and
OpenMP to push the envelope further. </p>

<p>If you have any questions, comments, suggestions, or corrections,
please let me know via the contact link.</p>

  
  <hr/>
  <div id="blog-about-author">
    <img id="blog-author-image" src="/images/blog-author-jdlee.jpg"/>
    <h4>The Author</h4>
    <p>
      <a href="mailto:jdl-blog@crumpington.com">J. David Lee</a> is a
      programmer turned physicist turned programmer and the
      proprietor of Crumpington Consulting. If you feel that his
      expertise could benefit you or your organization, don't hesitate
      to <a href="/contact.html">get in touch</a>.
    </p>
  </div>
</div>


    </div></body></html>