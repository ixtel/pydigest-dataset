<html><body><div><div class="content html_format"><p>
      Работа с модулями компании (company), контрагентами (party), товаров (product) и склада (stock).</p>

<a name="habracut"/>
<a href="http://habrahabr.ru/post/222121/">Часть 1: Установка tryotnd, структура запросов, работа с БД</a>
<a href="http://habrahabr.ru/post/221887/">Часть 2: Структура методов, работа с пользователями и группами, установка модулей</a>
<a href="http://habrahabr.ru/post/224907/">Часть 3: Работа с модулями компании (company), контрагентами (party), товаров (product) и склада (stock).</a>

<h4>1. Пример установки модулей</h4><p>
У нас в качестве первой итерации поставили задание обеспечить работу склада. Так что займемся установкой соответсвующего модуля. 
</p><p>
После скачивания и распаковки модуля stock, установить его не получится, так как для работы модуля необходимо установить зависимости. Для получения списка зависимостей модуля есть метод </p><code>ir.module.dependencies</code><p>, но он возвращает одну неудоволтворенную зависимость, получить сразу список необходимых модулей через этот метод у меня не получилось. 
</p><p>
Метод </p><code>model.ir.module.module.read</code><p> возвращает поле </p><code>dependencies</code><p>, но там только id необходимых модулей. Можно опять воспользоваться эти методом, что б получить имена этих модулей. Хотя проще будет открыть tryton.cfg, который находится в корне модуля и в разделе depends, посмотреть нужные модули. Для склада это — company, currency, ir, party, product. У модуля party в зависимостях указано еще company. Скачиваем и устанавливаем нужные модули. 
</p><p>
После установки </p><code>system.server.listMethods</code><p> возвращает в классе model на 625 методов больше. Ниже схематическое представление новых методов:

</p>
<p>
Теперь рассмотрим эти методы более детально.

</p><h4>2. API работы с модулями</h4>
<p>
У всех классов есть 6 основных методов: create, delete, fields_get, search, read, write. Ниже я расспишу их для основных классов модулей. 
</p><h5>2.1. API модуля company</h5>
<table>
<tr>
<th>Название метода</th>
<th>Параметры</th>
<th>Описание</th>
</tr>
<tr>
<td>model.company.company.search</td>
<td>[user_id, cookie, [], start, end, null, {}]</td>
<td>Возвращает срез списка id существующих компаний(id[start:end]).</td>
</tr>
<tr>
<td>model.company.company.fields_get</td>
<td>[user_id, cookie, [], {}]</td>
<td>Возвращает список имеющихся у компании полей.</td>
</tr>
<tr>
<td>model.company.company.read</td>
<td>[user_id, cookie, list_of_company_ids, list_of_field_names, {}]</td>
<td>Возвращает значения заданных полей заданных компаний.</td>
</tr>
<tr>
<td>model.company.company.create</td>
<td>[user_id, cookie, [{field_name: field_data, field_name: field_data, ...}], {}]</td>
<td>Создать компанию, минимум необходимо задать поле name.</td>
</tr>
<tr>
<td>model.company.company.delete</td>
<td>[user_id, cookie, list_delete_company_ids, {}]</td>
<td>Удаляет пользователей по id.</td>
</tr>
<tr>
<td>model.company.company.write</td>
<td>[user_id, cookie, list_update_company_ids, [{field_name: field_data, field_name: field_data, ...}], {}]</td>
<td>Изменяет значения полей пользователей по id.</td>
</tr>
</table>
<p>
У модуля компании есть второстепенный класс employee, который позволяет создавать сотрудников. Для назначения сотрудников надо изменить поле employее у компании.

</p><h5>2.2. API модуля party(контрагенты)</h5>

<table>
<tr>
<th>Название метода</th>
<th>Параметры</th>
<th>Описание</th>
</tr>
<tr>
<td>model.party.party.search</td>
<td>[user_id, cookie, [], start, end, null, {}]</td>
<td>Возвращает срез списка id существующих контрагентов(id[start:end]).</td>
</tr>
<tr>
<td>model.party.party.fields_get</td>
<td>[user_id, cookie, [], {}]</td>
<td>Возвращает список имеющихся у контрагента полей.</td>
</tr>
<tr>
<td>model.party.party.read</td>
<td>[user_id, cookie, list_of_party_ids, list_of_field_names, {}]</td>
<td>Возвращает значения заданных полей заданных контрагентов.</td>
</tr>
<tr>
<td>model.party.party.create</td>
<td>[user_id, cookie, [{field_name: field_data, field_name: field_data, ...}], {}]</td>
<td>Создать контрагента, минимум необходимо задать поле name.</td>
</tr>
<tr>
<td>model.party.party.delete</td>
<td>[user_id, cookie, list_delete_party_ids, {}]</td>
<td>Удаляет контрагентов по id.</td>
</tr>
<tr>
<td>model.party.party.write</td>
<td>[user_id, cookie, list_update_party_ids, [{field_name: field_data, field_name: field_data, ...}], {}]</td>
<td>Изменяет значения полей контрагентов по id.</td>
</tr>
</table>
<p>
У модуля контрагентов есть второстепенный класс address, который позволяет создавать адреса и назначать их контрагентам. Этот же класс используется в модуле склада. 

</p><h5>2.3. API модуля product</h5>
<table>
<tr>
<th>Название метода</th>
<th>Параметры</th>
<th>Описание</th>
</tr>
<tr>
<td>model.product.product.search</td>
<td>[user_id, cookie, [], start, end, null, {}]</td>
<td>Возвращает срез списка id существующих продуктов(id[start:end]).</td>
</tr>
<tr>
<td>model.product.product.fields_get</td>
<td>[user_id, cookie, [], {}]</td>
<td>Возвращает список имеющихся у продукта полей.</td>
</tr>
<tr>
<td>model.product.product.read</td>
<td>[user_id, cookie, list_of_product_ids, list_of_field_names, {}]</td>
<td>Возвращает значения заданных полей заданных продуктов.</td>
</tr>
<tr>
<td>model.product.product.create</td>
<td>[user_id, cookie, [{field_name: field_data, field_name: field_data, ...}], {}]</td>
<td>Создать продукт, минимум необходимо задать поле name, list_price, cost_price, default_uom.</td>
</tr>
<tr>
<td>model.product.product.delete</td>
<td>[user_id, cookie, list_delete_product_ids, {}]</td>
<td>Удаляет продукты по id.</td>
</tr>
<tr>
<td>model.product.product.write</td>
<td>[user_id, cookie, list_update_product_ids, [{field_name: field_data, field_name: field_data, ...}], {}]</td>
<td>Изменяет значения полей продуктов по id.</td>
</tr>
</table>
<p>
Есть еще аналогичные методы </p><code>product.template</code><p>, которые делают тоже самое что и </p><code>product.product</code><p>. </p><p>
Также необходимо обратить внимание на обязательное поле default_uom, в котором указывается единица измерения товара. Для работы с единицами измерения используется класс </p><code>product.uom</code><p>. Соотвественно для того, чтобы получить список имеющихся единиц измерения можно воспользоваться методами </p><code>model.product.uom.search, model.product.uom.read</code><p>.

</p><div class="spoiler"><b class="spoiler_title">Список id с названиями uom</b><div class="spoiler_text"><table>
<tr>
<th>id</th>
<th>Название</th>
</tr>
<tr>
<td>1</td>
<td>Штука</td>
</tr>
<tr>
<td>2</td>
<td>Килограмм</td>
</tr>
<tr>
<td>3</td>
<td>Грамм</td>
</tr>
<tr>
<td>4</td>
<td>Карат</td>
</tr>
<tr>
<td>5</td>
<td>Фунт</td>
</tr>
<tr>
<td>6</td>
<td>Унция</td>
</tr>
<tr>
<td>7</td>
<td>Секунда</td>
</tr>
<tr>
<td>8</td>
<td>Минута</td>
</tr>
<tr>
<td>9</td>
<td>Час</td>
</tr>
<tr>
<td>10</td>
<td>Рабочий день</td>
</tr>
<tr>
<td>11</td>
<td>День</td>
</tr>
<tr>
<td>12</td>
<td>Метр</td>
</tr>
<tr>
<td>13</td>
<td>Километр</td>
</tr>
<tr>
<td>14</td>
<td>сантиметр</td>
</tr>
<tr>
<td>15</td>
<td>Миллиметр</td>
</tr>
<tr>
<td>16</td>
<td>Фут</td>
</tr>
<tr>
<td>17</td>
<td>Ярд</td>
</tr>
<tr>
<td>18</td>
<td>Дюйм</td>
</tr>
<tr>
<td>19</td>
<td>Миля</td>
</tr>
<tr>
<td>20</td>
<td>Кубический метр</td>
</tr>
<tr>
<td>21</td>
<td>Литр</td>
</tr>
<tr>
<td>22</td>
<td>Кубический сантиметр</td>
</tr>
<tr>
<td>23</td>
<td>Кубический дюйм</td>
</tr>
<tr>
<td>24</td>
<td>Кубический фут</td>
</tr>
<tr>
<td>25</td>
<td>Галлон</td>
</tr>
<tr>
<td>26</td>
<td>Квадратный метр</td>
</tr>
<tr>
<td>27</td>
<td>Квадратный сантиметр</td>
</tr>
<tr>
<td>28</td>
<td>Ар</td>
</tr>
<tr>
<td>29</td>
<td>Гектар</td>
</tr>
<tr>
<td>30</td>
<td>Квадратный дюйм</td>
</tr>
<tr>
<td>31</td>
<td>Квадратный фут</td>
</tr>
<tr>
<td>32</td>
<td>Квадратный ярд</td>
</tr>
</table>
</div></div>

<div class="spoiler"><b class="spoiler_title">Пример, как получить существующие единицы измерения</b><div class="spoiler_text"><pre><code class="python">import json
import requests

url = 'http://localhost:8000/try'
id = 1
methodname = 'common.server.login'
params = ('test', 'test')
request = json.dumps({
                'id': id,
                'method': methodname,
                'params': params,
                })

r = requests.post(url, data=request)

user_id, cookie = r.json()['result']
print user_id, cookie


id = 2
methodname = 'model.product.uom.search'
params = [user_id, cookie, [], 0, 1000, None, {}]

request = json.dumps({
                'id': id,
                'method': methodname,
                'params': params,
                })

r = requests.post(url, data=request)
print request
uom= r.json()['result']

id = 4
methodname = 'model.product.uom.read'
params = (user_id, cookie, uom, ['name'], {})

request = json.dumps({
                'id': id,
                'method': methodname,
                'params': params,
                })

r = requests.post(url, data=request)
print r.json()['result']
</code></pre>
</div></div>

<h5>2.4. API работы с категориями</h5><p>
Для всех основных классов можно создавать иерархическую категоризацию. Для создания иерархии используется поле parent, в котором указывается id родителя.

</p><table>
<tr>
<th>Название метода</th>
<th>Параметры</th>
<th>Описание</th>
</tr>
<tr>
<td>model.*.category.search</td>
<td>[user_id, cookie, [], start, end, null, {}]</td>
<td>Возвращает срез списка id существующих ктегорий(id[start:end]).</td>
</tr>
<tr>
<td>model.*.category.fields_get</td>
<td>[user_id, cookie, [], {}]</td>
<td>Возвращает список имеющихся у категории полей.</td>
</tr>
<tr>
<td>model.*.category.read</td>
<td>[user_id, cookie, list_of_category_ids, list_of_field_names, {}]</td>
<td>Возвращает значения заданных полей заданных категорий.</td>
</tr>
<tr>
<td>model.*.category.create</td>
<td>[user_id, cookie, [{field_name: field_data, field_name: field_data, ...}], {}]</td>
<td>Создать категорию, минимум необходимо задать поле name.</td>
</tr>
<tr>
<td>model.*.category.delete</td>
<td>[user_id, cookie, list_delete_category_ids, {}]</td>
<td>Удаляет категории по id.</td>
</tr>
<tr>
<td>model.*.category.write</td>
<td>[user_id, cookie, list_update_category_ids, [{field_name: field_data, field_name: field_data, ...}], {}]</td>
<td>Изменяет значения полей категорий по id.</td>
</tr>
</table>

<h5>2.5. API модуля stock (склад)</h5><p>
Очень много времени ушло на понимание того, что для работы со складскими документами надо использовать любого пользователя, кроме admin, и к тому же его необходимо привязать к компании (указать поле company), иначе будете в response получать UserError.
</p><p>
У модуля склада есть 5 типов докуметов:
</p><ol>
<li><b>stock.shipment.in</b> — документ поставки товара на склад от поставщика.</li>
<li><b>stock.shipment.in.return</b> — документ возврата товара поставщику.</li>
<li><b>stock.shipment.internal</b> — документ внутренего перемещения между складами.</li>
<li><b>stock.shipment.out</b> — документ отгрузки товара со склада покупателю.</li>
<li><b>stock.shipment.out.return</b> — документ возврата товара от покупателя.</li>
</ol>
<p>
Ниже представлена схема, для наглядного понимания движения товаров по складам:

</p>
<p>
Для нескольких физических складов надо либо дублировать товарный склад с зонами поставки и отгрузки, либо делать несколько зон хранения.
</p><p>
Ниже представлено API по работе с докуметами склада, вместо звёздочки подставляем класс нужного документа, к примеру </p><code>model.stock.shipment.in.search</code><p>.

</p><table>
<tr>
<th>Название метода</th>
<th>Параметры</th>
<th>Описание</th>
</tr>
<tr>
<td>model.*.search</td>
<td>[user_id, cookie, [], start, end, null, {}]</td>
<td>Возвращает срез списка id существующих документов(id[start:end]).</td>
</tr>
<tr>
<td>model.*.fields_get</td>
<td>[user_id, cookie, [], {}]</td>
<td>Возвращает список имеющихся у документов полей.</td>
</tr>
<tr>
<td>model.*.read</td>
<td>[user_id, cookie, list_of_shipment_ids, list_of_field_names, {}]</td>
<td>Возвращает значения заданных полей заданных документов.</td>
</tr>
<tr>
<td>model.*.create</td>
<td>[user_id, cookie, [{field_name: field_data, field_name: field_data, ...}], {}]</td>
<td>Создать документ.</td>
</tr>
<tr>
<td>model.*.delete</td>
<td>[user_id, cookie, list_delete_shipment_ids, {}]</td>
<td>Удаляет документ по id.</td>
</tr>
<tr>
<td>model.*.write</td>
<td>[user_id, cookie, list_update_shipment_ids, [{field_name: field_data, field_name: field_data, ...}], {}]</td>
<td>Изменяет значения полей документов по id.</td>
</tr>
<tr>
<td>model.*.wait</td>
<td>[user_id, cookie, list_shipment_ids, {}]</td>
<td>Меняет состояние документа в ожидание по id.</td>
</tr>
<tr>
<td>model.*.done</td>
<td>[user_id, cookie, list_shipment_ids, {}]</td>
<td>Меняет состояние документа в выполнено по id.</td>
</tr>
</table>
<p>
У модуля склада есть второстепенный класс location для работы непосредственно со складами, а не движением товаров по складам и зонам.
</p><p>
Вот пример параметров для метода model.stock.shipment.in.create </p><code>[user_id, cookie, [{"company": 1, "incoming_moves": [["create", [{"to_location": 1, "product": 1, "from_location": 5, "company": 1, "unit_price": {"decimal": "12.000", "__class__": "Decimal"}, "currency": 123, "uom": 2, "quantity": 90.0}]]], "warehouse": 4, "supplier": 1}], {}]</code><p>. Обратите внимание на «unit_price»: {«decimal»: «12.000», "__class__": «Decimal»}, если задать в запросе «unit_price»: 12.000, то запрос не выполнится, так как модуль склада не сможет переобразовать число нужный ему в класс Decimal. Такое поведение замечено только в полях, которые отвечают за цену.
</p><p>
У документов поставки stock.shipment.in, есть два состояния — draft (черновик), done (выполнено). У остальных документов три состояние — draft (черновик), wait (ожидание), done (выполнено). Состояние документов влияет на отчеты об остатках по товарам и складам. Если у документа состояние draft, то товар указаный в нём не отображается в отчетах. Если документ в состоянии wait, то в отчетах товар находится на складе с которого делается перемещение/отгрузка. Если документ в состоянии done, то товар в отчет находится на складе на который делается перемещение/отгрузка.
</p><p>
У модуля склада есть отчет остатка продукци на конкретном складе/зоне поставки-отгрузки — wizard.stock.products_by_locations. Для получения отчетов используется главный класс wizard. С помощью метода create создаётся запрос к БД и записывается в БД, метод execute выполняет запрос и результат записывается в бд, метод delete удаляет из БД запрос и результаты его выполнения.

</p><table>
<tr>
<th>Название метода</th>
<th>Параметры</th>
<th>Описание</th>
</tr>
<tr>
<td>wizard.stock.products_by_locations.create</td>
<td>[user_id, cookie, [], {}]</td>
<td>Создаёт запрос для отчета по продуктам на складе. Метод возвращает id отчета.</td>
</tr>
<tr>
<td>wizard.stock.products_by_locations.execute</td>
<td>[user_id, cookie, wizard_id, {«start»: {«forecast_date»: {«month»: number_of_month, "__class__": «date», «day»: number_of_day, «year»: number_of_year}}}, «open», { «active_id»: warehouse_id, «active_model»: «stock.location», «active_ids»: [warehouse_ids]}]</td>
<td>Выполняет запрос. Необходимо указать дату, на которую будет произведен расчет остатков и id склада.</td>
</tr>
<tr>
<td>wizard.stock.products_by_locations.delete</td>
<td>[user_id, cookie, wizard_id, {}]</td>
<td>Удаляет отчет по id.</td>
</tr>
</table>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>