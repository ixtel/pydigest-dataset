<html><body><div><div class="all_external_links">
          <p>Talk to any developer that inherits some large, old code base that has developed semantics as time has gone on and they will always have something they wished they could change about the code they inherited. After inheriting <code>import</code> in Python, I too have a list of things I would love to see changed in how it works to make it a bit more sane and easier to work with. This blog post is basically a brain dump/wishlist of what I would love to see changed in import some day.</p>

<h1 id="toc_0">No global state</h1>

<p>As <code>import</code> currently stands, all of its state is stored in the <code>sys</code> module. This makes growing the API rather painful as it means expanding a module's API surface rather than adding another attribute on an object. For me, I would rather have <code>import</code> be a fully self-contained object that stored all of its own state.</p>

<p>This has been proposed before in <a href="https://www.python.org/dev/peps/pep-0406/">PEP 406</a> and under the name of "import engine". It unfortunately has not gone anywhere simply due to the fact that it would take time to design the API for a fully encapsulated <code>import</code> class and it doesn't buy people anything <em>today</em>. Now in the future it could open up some unique possibilities for <code>import</code> itself -- which will be discussed later -- as well as simply be cleaner to maintain as it would allow for cleaner separation between interpreters in a single process.</p>

<p>Making this actually happen would occur over stages. A new <code>ImportEngine</code> class would created which would define the API we wished <code>import</code> would have from scratch. That API would then delegate under the hood to the <code>sys</code> module so that semantics stayed the same, including making instances of the class callable and assigning such an instance to <code>builtins.__import__</code>. At some point the objects that were stored in the instance of <code>builtins.__import__</code> would be set in the <code>sys</code> module instead of the object delegating to the <code>sys</code> module itself. After a proper amount of time, once everyone had moved over to using the object's API instead of the <code>sys</code> module then we could consider cutting out the import-related parts from the <code>sys</code> module.</p>

<h1 id="toc_1">Make <code>__import__</code> more sane</h1>

<p>In case you didn't know, the <a href="https://docs.python.org/3/library/functions.html#__import__">signature for <code>builtins.__import__()</code></a> is a bit nuts:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">__import__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">globals</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">locals</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fromlist</span><span class="o">=</span><span class="p">(),</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
<p>The <code>locals</code> argument isn't used. The <code>globals</code> argument is only used for calculating relative imports and thus only needs <code>__package__</code> (technically <code>__name__</code> and <code>__path__</code> are also used, but only when <code>__package__</code> isn't defined and that only happens if you do something bad). The <code>fromlist</code> parameter has to do with how the bytecode operates -- which I will talk about later -- and <code>level</code> is just the number of leading dots in a relative import.</p>

<p>If I had my way, the function would be defined as:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">__import__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">spec</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
<p>This is the almost the same signature as <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module"><code>importlib.import_module()</code></a>, but with passing in the spec of the calling module instead of just its <code>__package__</code>; nice, simple, and easy to comprehend. The only thing I might consider changing is keeping the <code>level</code> argument since that is a bit of string parsing that can be done ahead of time and baked into the bytecode, but I don't know if it really would make that much of a performance difference.</p>

<h1 id="toc_2">You can only import modules</h1>

<p>Having the ability to import attributes off of a module really sucks from an implementation perspective. The bytecode itself doesn't handle that bit of detail and instead hoists it upon <code>import</code>. It also leads to people getting into circular import problems. Finally, it causes people to separate from afar what namespace an object belongs to which can make code easier to read by keeping the association of an object and its containing module together). Plus you can easily replace <code>from module import attr</code> with <code>import module; attr = module.att</code>; <a href="https://wiki.python.org/moin/TOOWTDI">TOOWTDI</a>.</p>

<p>So if I had my way, when you said <code>from foo import bar</code>, it would mean Python did <code>import foo.bar; bar = foo.bar</code> and <strong>nothing else</strong>. No more <code>from ... import *</code>, no more <code>__all__</code> for modules, etc.; you wouldn't be allowed to import anything that didn't end up in <code>sys.modules</code> (and I'm sure some teacher is saying "but <code>import *</code> makes things easier", but in my opinion the cost of that little shortcut is too costly to keep it around). It makes thing cleaner to implement which helps eliminate edge cases. It makes code easier to analyze as you would be able to tell what modules you were after (mostly) statically. It just seems better to me both from my end in terms of implementing import and just simplifying the semantics for everyone to comprehend.</p>

<h1 id="toc_3">Looking up <code>__import__</code> like anything else</h1>

<p>Like a lot of syntax in Python, the <code>import</code> statement is really just syntactic sugar for calling the <code>builtins.__import__</code> function. But if we changed the semantics to follow normal name lookup instead of short-circuiting directly the <code>builtins</code> namespace, some opportunities open up.</p>

<p>For instance, would you like to have dependencies unique to your package, e.g. have completely separate copies of your dependencies so you eliminate having to share the same dependency version with all other installed packages? Well, if you changed Python's semantics to look up <code>__import__</code> like any other object then along with the import engine idea mentioned earlier you can have a custom <code>sys.path</code> and <code>sys.modules</code> for your package by having a package-specific <code>__import__</code>. Basically you would need a loader that injected into the module's <code>__dict__</code> its own instance of <code>__import__</code> that knew how to look up dependencies unique to the package. So you could have a <code>.dependencies</code> directory directly in your package's top-level directory and have <code>__import__</code> put that at the front of its own <code>sys.path</code> for handling top-level imports. That way if you needed version 1.3 of a package but other code needed 2.0 you could then put the project's 1.3 version in the <code>.dependencies</code> directory and have that on your private <code>sys.path</code> before <code>site-packages</code>, making everything fall through. It does away with the whole explicit vendoring some projects do to lock down their dependencies.</p>

<p>Now I don't know how truly useful this would be. Vendoring is not hard thanks to relative imports and most projects don't seem to need it. It also complicates things as it means modules wouldn't be shared across packages and so anything that relied on object identity like an <code>except</code> clause for matching caught exceptions could go south really fast (as the <a href="https://github.com/kennethreitz/requests/issues/2870">requests project learned the hard way</a>). And then thanks to the <a href="https://docs.python.org/3/library/venv.html#module-venv"><code>venv</code> module</a> and the concept of virtual environments the whole clashing dependency problem is further minimized. But since I realized this could be made possible I at least wanted to write it down. :)</p>

<h1 id="toc_4">I doubt any of this will ever change</h1>

<p>While I may be able to create an object for <code>__import__</code> that people use, getting people to use that instead of the <code>sys</code> module would be tough, especially thanks to not being able to detect when someone replaced the objects on <code>sys</code> entirely instead of simply mutating them. Changing the signature of <code>__import__</code> would also be somewhat tough, although if an object for <code>__import__</code> was used then the bytecode could call a method on that object and then <code>__import__.__call__</code> would just be a shim for backwards-compatibility (and honestly people should not be calling or mucking with <code>__import__</code> directly anyway; use <code>importlib.import_module()</code> or all of the other various hooks that <code>importlib</code> provides instead). Only importing modules is basically a dead-end due to backwards-compatibility, but I may be able to make the bytecode do more of the work rather than doing it in <code>__import__</code> itself. And getting Python to follow normal lookup instead of going straight to <code>builtins</code> when looking for <code>__import__</code> probably isn't worth the hassle and potential compatibility issues.</p>

        </div>
        </div></body></html>