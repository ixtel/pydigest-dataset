<html><body><div><div class="section" id="introduction">
<h2>1   Introduction</h2>
<blockquote>
Why is it that, for me, combinatorics arouses feelings of pure pleasure,
yet, for many others it evokes feelings of pure panic? - Don Knuth, The Art
of Computer Programming, Vol. 4</blockquote>
<p>The goal of <em>combinatorial generation</em> (or <em>searching</em> as Knuth calls it) is to
exhaustively produce a set of combinatorial objects, one at a time, often
subject to some constraints, and often in a certain required order. Both
<a class="citation-reference" href="#knuth-4a" id="id1">[KNUTH-4A]</a> and <a class="citation-reference" href="#ruskey" id="id2">[RUSKEY]</a> provide excellent introductions to the subject of
combinatorial generation. Combinatorial generation problems encompass a wide
range of problems, from relatively simple (e.g. generating all subsets or all
permutations) to rather complex (e.g. generating all ideals of a poset in Gray
order).</p>
<p>Algorithms for combinatorial generation are often divided into iterative and
recursive categories. Iterative algorithms have traditionally been
considered superior in performance due to the overload of repetitive function
calls in recursive algorithms. Arguably, this advantage is less noticeable when
recursion is used properly (no redundant subtrees in the recursion tree) and
modern compilers are used. Recursive algorithms, on the other hand, often
have the advantage of being easier to read and understand.</p>
<p>These two types of algorithms can be further considered as ways of
approaching a combinatorial generation problem. That is, there are a few
problem-solving strategies that work naturally with each type of algorithm. For
example, with recursion, the main strategy involves reducing the problem to a
subproblem.  Similarly, with iterative algorithms the strategy of finding the
next object in lexicographic order is quite commonly used and is rather
powerful. Approaches that use the algebraic or arithmetic properties of the
objects generated are also often used in iterative algorithms. We will see some
examples of all of these in this article.</p>
<p>Coroutines, which can be seen as a generalization of functions, can encompass
both recursive and iterative algorithms. As such, they provide an ideal
mechanism for combinatorial generation. In fact, one of the most popular
coroutine use patterns in modern programming languages is the <em>generator</em>
pattern, which we will discuss in next section. As the name suggests,
generators provide the perfect mechanism for implementing combinatorial
generation algorithms, recursive or iterative.</p>
<p>In addition, since coroutines are a generalization of functions, we can exploit
their generality to come up with combinatorial generation algorithms that are
arguably somewhere between recursive and iterative. These algorithms introduce
a new strategy for approaching combinatorial generation, which can be taken as
a third approach, in addition to recursive and iterative approaches.</p>
<p>This article is intended to provide an introduction to combinatorial generation
using coroutines. Most of the discussion in this article will be through
examples. Performance is discussed in a few of the examples as well. The main
ideas presented here are either directly taken from those in <a class="citation-reference" href="#kr" id="id3">[KR]</a>, or inspired
by them. Most of the article is written with an intermediate or advanced
programmer with a modest level of familiarity with combinatorics and
combinatorial generation as the audience in mind, though the last few examples
involve combinatorial objects beyond the basics.</p>
<p>Examples are all in Python, and all the source code included here is available
at <a class="reference external" href="https://github.com/sahands/coroutine-generation">https://github.com/sahands/coroutine-generation</a> for any readers who wish to
experiment with the code interactively. You can also see the Prezi slides for
this project <a class="reference external" href="http://prezi.com/jew2sogg0hgz/?utm_campaign=share&amp;utm_medium=copy&amp;rc=ex0share">here</a>.</p>
<dl class="docutils">
<dt>A Note on Python 2 v.s. Python 3</dt>
<dd>All the code in this article is written to be compatible with Python 2.5 to
3.3. However, I make the general assumption that Python 3 is in use, and as
such make no effort to write code that would be more efficient in Python 2. For
example, I use <tt class="docutils literal">range</tt> instead of <tt class="docutils literal">xrange</tt>, since in Python 3 <tt class="docutils literal">xrange</tt> is
removed and <tt class="docutils literal">range</tt> returns an iterator instead of a list. However, in favour
of compatibility with Python 2, no Python 3 specific feature (e.g. <tt class="docutils literal">yield
from</tt>) is used.</dd>
</dl>
</div>
<div class="section" id="coroutines-and-their-implementation-in-python">
<h2>2   Coroutines and Their Implementation in Python</h2>
<div class="section" id="basic-definition">
<h3>2.1   Basic Definition</h3>
<p>As mentioned in the introduction, coroutines are a generalization of functions.
Assume <tt class="docutils literal">A</tt> is function that calls <tt class="docutils literal">B</tt>. In terms of the flow of execution,
this involves <tt class="docutils literal">A</tt> pausing its execution and passing the flow to <tt class="docutils literal">B</tt>. As
such, <tt class="docutils literal">A</tt> can then be seen to be in a "paused" state until <tt class="docutils literal">B</tt> finishes and
returns execution back to the caller, <tt class="docutils literal">A</tt> in this case. Coroutines generalize
functions by allowing for any coroutine to pause its execution and <em>yield</em> a
result at any point, and for any other coroutine to pass the execution to
any other paused coroutine to continue. To achieve this, coroutines need to
remember their state so they can continue exactly where they left of when
resumed. The coroutine's "state" here refers to the values of local variables,
as well as where in the coroutine's code the execution was paused.</p>
<p>In other words, coroutines are functions that allow for multiple entry points,
that can yield multiple times, and resume their execution when called again. On
top of that, coroutines can transfer execution to any other coroutine instead
of just the coroutine that called them. Functions, being special cases of
coroutines, have a single entry point, can only yield once, and can only
transfer execution back to the caller coroutine.</p>
</div>
<div class="section" id="python-generators">
<h3>2.2   Python Generators</h3>
<p>In Python, generators, which are basic coroutines with a few
restrictions, were introduced in <a class="citation-reference" href="#pep-255" id="id4">[PEP-255]</a>. The syntax for defining coroutines
in Python is very similar to that of functions, with the main different being
that instead of <tt class="docutils literal">return</tt> the keyword <tt class="docutils literal">yield</tt> is used to pause the execution
and return the execution to the caller. The syntax for using generators is
rather different from functions though, and is in fact closer to how classes
are treated in Python: calling a generator function returns a newly created
"generator object", which is is an instance of the coroutine independent of
other instances. To call the generator, the <tt class="docutils literal">next</tt> built-in
function is used, and the generator object is passed to <tt class="docutils literal">next</tt> as the
parameter. Here is a very simple example demonstrating how a very simple
function as be implemented as a coroutine using a generator in Python:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">add_coroutine</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>


<span class="c"># Usage:</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">add_func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c"># Equivalent to:</span>
<span class="n">adder</span> <span class="o">=</span> <span class="n">add_coroutine</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">adder</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c"># Further calls such as the following to adder will result in a StopIteration</span>
<span class="c"># being raised.</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">adder</span><span class="p">)</span>
</pre></div>
<p>Of course, the above example is meant to contrast the syntactic differences of
generators and functions. The particular use of a coroutine
demonstrated above is of course completely unnecessary. Let us look at a
somewhat more interesting example, taken, with minor modification, from
<a class="citation-reference" href="#pep-255" id="id5">[PEP-255]</a>:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">fib</span><span class="p">():</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">b</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>


<span class="c"># Usage:</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">fib</span><span class="p">()</span>  <span class="c"># Create a new "instance" of the generator coroutine</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>  <span class="c"># Prints 1</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>  <span class="c"># Prints 1</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>  <span class="c"># Prints 2</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>  <span class="c"># Prints 3</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>  <span class="c"># Prints 5</span>
</pre></div>
<p>Here we have a generator that yields the numbers in the Fibonacci sequence ad
infinitum. Each call to the generator slides the <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt> variables
ahead in the sequence, and then execution is paused and <tt class="docutils literal">b</tt> is yielded.</p>
</div>
<div class="section" id="recursive-generators">
<h3>2.3   Recursive Generators</h3>
<p>Before continuing, let us look at a simple example of a recursive algorithm
implemented using coroutines as well. In this example, we create a very
minimalistic binary tree and then print its post-order traversal. Notice how
generators can be recursive, and how they implement the <tt class="docutils literal">iterator</tt> interface
which allows them to be used inside <tt class="docutils literal">for</tt> loops and generator expressions.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tree</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="s">'left'</span><span class="p">]):</span>
        <span class="k">yield</span> <span class="n">x</span>

    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="s">'right'</span><span class="p">]):</span>
        <span class="k">yield</span> <span class="n">x</span>

    <span class="k">yield</span> <span class="n">tree</span><span class="p">[</span><span class="s">'value'</span><span class="p">]</span>


<span class="c"># Usage:</span>
<span class="n">tree</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

<span class="c"># Let's build a simple tree representing (1 + 3) * (4 - 2)</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">tree</span><span class="p">()</span>
<span class="n">T</span><span class="p">[</span><span class="s">'value'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'*'</span>
<span class="n">T</span><span class="p">[</span><span class="s">'left'</span><span class="p">][</span><span class="s">'value'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'+'</span>
<span class="n">T</span><span class="p">[</span><span class="s">'left'</span><span class="p">][</span><span class="s">'left'</span><span class="p">][</span><span class="s">'value'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'1'</span>
<span class="n">T</span><span class="p">[</span><span class="s">'left'</span><span class="p">][</span><span class="s">'right'</span><span class="p">][</span><span class="s">'value'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'3'</span>
<span class="n">T</span><span class="p">[</span><span class="s">'right'</span><span class="p">][</span><span class="s">'value'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'-'</span>
<span class="n">T</span><span class="p">[</span><span class="s">'right'</span><span class="p">][</span><span class="s">'left'</span><span class="p">][</span><span class="s">'value'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'4'</span>
<span class="n">T</span><span class="p">[</span><span class="s">'right'</span><span class="p">][</span><span class="s">'right'</span><span class="p">][</span><span class="s">'value'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'2'</span>

<span class="n">postfix</span> <span class="o">=</span> <span class="s">' '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">postorder</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">postfix</span><span class="p">)</span>  <span class="c"># Prints 1 3 + 4 2 - *</span>
</pre></div>
<p>In Python 3, with <a class="citation-reference" href="#pep-380" id="id6">[PEP-380]</a>, the above can be made even simpler by using the
<tt class="docutils literal">yield from</tt> statement:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tree</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">yield from</span> <span class="n">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="s">'left'</span><span class="p">])</span>
    <span class="k">yield from</span> <span class="n">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="s">'right'</span><span class="p">])</span>
    <span class="k">yield</span> <span class="n">tree</span><span class="p">[</span><span class="s">'value'</span><span class="p">]</span>
</pre></div>
<p>However, the shorter and nicer Python 3 syntax will not be used for the rest of
the article to keep the code Python 2 compatible.</p>
</div>
<div class="section" id="pep-342-and-the-enhanced-yield-keyword">
<h3>2.4   PEP 342 and the Enhanced <tt class="docutils literal">yield</tt> Keyword</h3>
<p>Python generators were further generalized to allow for more flexible
coroutines in <a class="citation-reference" href="#pep-342" id="id7">[PEP-342]</a>. Prior to the enhancements in <a class="citation-reference" href="#pep-342" id="id8">[PEP-342]</a>, Python's
generators were coroutines that could not accept new parameters after the
initial parameters were passed to the coroutine. With <a class="citation-reference" href="#pep-342" id="id9">[PEP-342]</a>'s <tt class="docutils literal">send</tt>
method, a coroutine's execution can resume with further data passed to it as
well. This is implemented by allowing the <tt class="docutils literal">yield</tt> keyword to be used not just
as a statement but also as an expression, the evaluation of which results in
the coroutine pausing until a value is passed to it via <tt class="docutils literal">send</tt>, which will be
the value that the <tt class="docutils literal">yield</tt> expression evaluates to. In this article, we will
only need to use the generator pattern, and will only use <tt class="docutils literal">yield</tt>
as a statement meaning the <tt class="docutils literal">send</tt> method will not be used.</p>
</div>
<div class="section" id="clarification-regarding-terminology">
<h3>2.5   Clarification Regarding Terminology</h3>
<p>It is important to mention that in some Python literature the word "coroutine"
has come to mean specifically coroutines that use <tt class="docutils literal">yield</tt> as an expression
and hence require the use of <tt class="docutils literal">send</tt> to operate. See <a class="citation-reference" href="#beazley" id="id10">[BEAZLEY]</a> for example
(which, by the way, is an excellent introduction to coroutines and their uses
in IO operations, parsing, and more). I believe this is somewhat inaccurate,
since coroutines are a general concept, and functions, generators with <tt class="docutils literal">next</tt>
or <tt class="docutils literal">send</tt> or both, all fall under coroutines. (That is, on an abstract level,
the set of coroutines contains the set of generators and functions, and more.)</p>
<p>In this article, I use the word "coroutine" in its generality, as defined in
the first paragraph of this section, in accordance with how Knuth defines the
word in <a class="citation-reference" href="#knuth-1" id="id11">[KNUTH-1]</a>. I also will more or less use it interchangeably with
the word "generator", since we will only use coroutines that are generators in
this article.</p>
<p>I will refer the readers interested in the enhanced <tt class="docutils literal">yield</tt> keyword and its
use to <a class="citation-reference" href="#beazley" id="id12">[BEAZLEY]</a>.</p>
</div>
<div class="section" id="a-final-note-on-coroutines-in-python">
<h3>2.6   A Final Note on Coroutines in Python</h3>
<p>Before we move on, it is important to note that even with <a class="citation-reference" href="#pep-342" id="id13">[PEP-342]</a>, Python's
generators do not implement coroutines in full generality.  To quote <a class="citation-reference" href="#py-1" id="id14">[PY-1]</a>:</p>
<blockquote>
All of this makes generator functions quite similar to coroutines; they
yield multiple times, they have more than one entry point and their
execution can be suspended. The only difference is that a generator
function cannot control where should the execution continue after it
yields; the control is always transferred to the generator's caller.</blockquote>
<p>So unlike the way Knuth defines and uses coroutines, Python's generators are
not completely symmetric; an executing generator object is still coupled to the
caller, which creates asymmetry. However, this limitation will not be an issue
for our purposes here.</p>
</div>
</div>
<div class="section" id="motivating-example-multi-radix-numbers">
<h2>3   Motivating Example: Multi-Radix Numbers</h2>
<p>We start our exploration of coroutine-based combinatorial generation with a
simple example: multi-radix numbers. The goal here is to provide a short and
simple example of the common approaches to solving combinatorial generation
problems, and then introduce the coroutine-based approach so as to emphasize
the differences and advantages of each approach. The first approach will be based
on arithmetical properties of the objects we are generating, the second will be
a recursive solution based on a reduction to a subproblem, third will be an
iterative approach based on explicitly finding the next lexicographic item, and
finally, the fourth approach will be the coroutine-based one</p>
<div class="section" id="problem-definition">
<h3>3.1   Problem Definition</h3>
<p>Our goal in this section will be to produce the set of multi-radix numbers in
lexicographic (dictionary) order given a multi-radix <em>base</em> <span class="math">\(M\)</span>. More
specifically, given a list <span class="math">\(M\)</span> of positive numbers, produce all lists
<span class="math">\(a\)</span> of the same length as <span class="math">\(M\)</span> such that <span class="math">\(0 \le a[i] &lt; M[i]\)</span>,
in lexicographic order. Here is an example:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">multiradix_recursive</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">[0, 0, 0]</span>
<span class="go">[0, 0, 1]</span>
<span class="go">[0, 0, 2]</span>
<span class="go">[0, 0, 3]</span>
<span class="go">[0, 1, 0]</span>
<span class="go">[0, 1, 1]</span>
<span class="go">[0, 1, 2]</span>
<span class="go">[0, 1, 3]</span>
<span class="go">[1, 0, 0]</span>
<span class="go">[1, 0, 1]</span>
<span class="go">[1, 0, 2]</span>
<span class="go">[1, 0, 3]</span>
<span class="go">[1, 1, 0]</span>
<span class="go">[1, 1, 1]</span>
<span class="go">[1, 1, 2]</span>
<span class="go">[1, 1, 3]</span>
<span class="go">[2, 0, 0]</span>
<span class="go">[2, 0, 1]</span>
<span class="go">[2, 0, 2]</span>
<span class="go">[2, 0, 3]</span>
<span class="go">[2, 1, 0]</span>
<span class="go">[2, 1, 1]</span>
<span class="go">[2, 1, 2]</span>
<span class="go">[2, 1, 3]</span>
</pre></div>
<p>In other words, the combinatorial set of objects being generated is the
Cartesian product</p>
<p class="math">
\begin{equation*}
\prod_{i=0}^{n-1} \{0, 1, \ldots, m_i - 1\}
\end{equation*}
</p>
<p>where <span class="math">\(M = [m_0, \ldots, m_{n-1}]\)</span>. So those of you familiar with
Python's <tt class="docutils literal">itertools</tt> module might already have thought of a quick solution to
the problem:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>


<span class="k">def</span> <span class="nf">multiradix_product</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">M</span><span class="p">))</span>
</pre></div>
<p>This, of course, is not an algorithm as much as it is delegating the task!
Nonetheless, it is a good start and we will use it as a base-line for
performance comparisons of the rest of the algorithms. We will also briefly
look at how Python's <tt class="docutils literal">itertools.product</tt> function is implemented internally
after we discuss our algorithms.</p>
</div>
<div class="section" id="an-algorithm-based-on-arithmetic">
<h3>3.2   An Algorithm Based on Arithmetic</h3>
<p>To start with our first solution, let's observe that with <span class="math">\(M = [2] * n\)</span>,
the problem is reduced to counting in binary:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">multiradix_recursive</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">[0, 0, 0]</span>
<span class="go">[0, 0, 1]</span>
<span class="go">[0, 1, 0]</span>
<span class="go">[0, 1, 1]</span>
<span class="go">[1, 0, 0]</span>
<span class="go">[1, 0, 1]</span>
<span class="go">[1, 1, 0]</span>
<span class="go">[1, 1, 1]</span>
</pre></div>
<p>This observation leads to the following iterative solution: simply start from
zero and count to <span class="math">\((\prod m_i) - 1\)</span>, and covert the numbers to
the multi-radix base given by <span class="math">\(M\)</span>, similar to how we convert numbers to
binary. This results in the following code.</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">mul</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>


<span class="k">def</span> <span class="nf">number_to_multiradix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">M</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">multiradix_counting</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">last</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">last</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">number_to_multiradix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
<p>We can classify this algorithm as an iterative algorithm that relies on the
arithmetical properties of the objects we are generating. Because of this, it
it does not have a very combinatorial feel to it. It also happens to be quite
slow, especially in Python, since every number in <span class="math">\(a\)</span> is recalculated
each time, and multiple divisions have to happen per generated object.</p>
</div>
<div class="section" id="a-recursive-algorithm-based-on-reduction-to-subproblems">
<h3>3.3   A Recursive Algorithm Based on Reduction to Subproblems</h3>
<p>Next approach is the recursive one. To use recursion, we need to reduce the
problem to a subproblem. Say <span class="math">\(M\)</span> has <span class="math">\(n\)</span> items in it, so we are
producing multi-radix numbers with <span class="math">\(n\)</span> digits.  Let <span class="math">\(M' = [M[0],
M[1], \ldots, M[n-2]]\)</span>. That is, <span class="math">\(M'\)</span> is the first <span class="math">\(n-1\)</span> elements
of <span class="math">\(M\)</span>. Then if we have a list of multi-radix numbers for <span class="math">\(M'\)</span> in
lexicographic order, we can extend that list to a list of lexicographic numbers
for <span class="math">\(M\)</span> by appending <span class="math">\(0\)</span> to <span class="math">\(M[n-1] - 1\)</span> to each element of
the list. This approach leads to the following recursive code:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">multiradix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">__</span> <span class="ow">in</span> <span class="n">multiradix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c"># Extend each multi-radix number of length i with all possible</span>
            <span class="c"># 0 &lt;= x &lt; M[i] to get a multi-radix number of length i + 1.</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
                <span class="k">yield</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">multiradix_recursive</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">multiradix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
<p>Quite simple and elegant, and as we will see, quite fast as well.</p>
</div>
<div class="section" id="an-iterative-algorithm">
<h3>3.4   An Iterative Algorithm</h3>
<p>Now, let's look at the iterative approach. Since our goal is to go from one
given multi-radix number to the next in lexicographic order, we can start
scanning from right to left until we find an index in <span class="math">\(a\)</span> that we can
increment, do the incrementation, and then set everything to the right of that
index to <span class="math">\(0\)</span>. For example, if our multi-radix number system is simply
given by <span class="math">\(M = [10] * 4\)</span>, so we simply have decimal numbers of <span class="math">\(4\)</span>
digits, and our current <span class="math">\(a\)</span> is <span class="math">\(0399\)</span> then scanning from right to
left tells us that <span class="math">\(3\)</span> is the first number that can be incremented, so we
increment <span class="math">\(3\)</span> getting <span class="math">\(0499\)</span> and then set everything to the right
of <span class="math">\(4\)</span> to <span class="math">\(0\)</span> getting <span class="math">\(0400\)</span> which is the next number in
lexicographic order. We can also just set numbers that can not be incremented
to zero as we do the scanning for the first number to increment, which will
save us from having two loops.  This approach results in the following code:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">multiradix_iterative</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">a</span>
        <span class="c"># Find right-most index k such that a[k] &lt; M[k] - 1 by scanning from</span>
        <span class="c"># right to left, and setting everything to zero on the way.</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># Last lexicographic item</span>
                <span class="k">return</span>
        <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="section" id="a-coroutine-based-algorithm">
<h3>3.5   A Coroutine-Based Algorithm</h3>
<p>Finally, let's look at the coroutine-based algorithm. The basic idea here is
very similar to the previous iterative algorithm, but the execution is very
different.</p>
<p>To explain this algorithm, I will borrow Knuth's style of explaining his
coroutine-based algorithms in <a class="citation-reference" href="#kr" id="id15">[KR]</a>. Picture a line of <span class="math">\(n + 1\)</span> friendly
trolls.  Each troll, with the exception of the first troll holds, a number in
his hand.  The trolls will behave in the following manner. When a troll is poked,
if the number in his hand is strictly less than <span class="math">\(m_i - 1\)</span> (meaning the
number can be increased) he simply increments the number and yells out "done".
If the number in his hand is equal to <span class="math">\(m_i - 1\)</span> then he changes the
number to <span class="math">\(0\)</span> and then pokes the previous troll without yelling anything.
The first troll in line is special; whenever poked, he simply yells out "last"
without doing anything else.</p>
<div class="figure">
<img alt="A line of friendly trolls." src="/images/trolls.jpg"/>
<p class="caption">Picture a line of friendly trolls, such as the above, but each holding a
number in his hand.</p>
</div>
<p>We will call the last troll in line (corresponding to index <span class="math">\(n - 1\)</span>) the
<em>lead</em> troll. The algorithm will start with all trolls holding the number
<span class="math">\(0\)</span> in their hands. Each time we need the next item generated, we poke
the lead troll. If we hear "done" then we know we have a new item. If we hear
"last" then we know that we are at the end of the generation task.</p>
<p>In the implementation of the above idea, each troll becomes a coroutine.
Yelling out "done" will be yielding <tt class="docutils literal">True</tt> and yelling out "last" will
yielding <tt class="docutils literal">False</tt>. Troll number <span class="math">\(-1\)</span> is a special <tt class="docutils literal">nobody</tt> coroutine
that simply yields <tt class="docutils literal">False</tt> repeatedly:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">nobody</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="bp">False</span>
</pre></div>
<p>The rest of the trolls are instances of the <tt class="docutils literal">troll</tt> coroutine in the code
given below. Each troll creates the troll previous to it in line, until we get
to troll number <span class="math">\(0\)</span>, which creates a <tt class="docutils literal">nobody</tt> coroutine as its previous
troll.</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">nobody</span> <span class="kn">import</span> <span class="n">nobody</span>


<span class="k">def</span> <span class="nf">troll</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">previous</span> <span class="o">=</span> <span class="n">troll</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">nobody</span><span class="p">()</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">yield</span> <span class="nb">next</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span>  <span class="c"># Poke the previous troll</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">yield</span> <span class="bp">True</span>


<span class="k">def</span> <span class="nf">multiradix_coroutine</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">lead</span> <span class="o">=</span> <span class="n">troll</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">a</span>
    <span class="k">while</span> <span class="nb">next</span><span class="p">(</span><span class="n">lead</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">a</span>
</pre></div>
</div>
<div class="section" id="discussion">
<h3>3.6   Discussion</h3>
<p>In the previous sections we saw four algorithms that solve the problem of
generating multi-radix numbers in lexicographic order. The four algorithms were</p>
<ul class="simple">
<li><tt class="docutils literal">multiradix_counting</tt>: an iterative algorithm based on arithmetic,</li>
<li><tt class="docutils literal">multiradix_recursive</tt>: a recursive algorithm that reduced the problem to a
subproblem,</li>
<li><tt class="docutils literal">multiradix_iterative</tt>: an iterative algorithm that explicitly produced the
next item in lexicographic order,</li>
<li><tt class="docutils literal">multiradix_coroutine</tt>: a coroutine-based algorithm.</li>
</ul>
<p>We also saw how to solve the problem using Python's built-in
<tt class="docutils literal">itertools.product</tt> function. The latest was implemented as
<tt class="docutils literal">multiradix_product</tt>. Let's look at a simple performance comparison of the
five by having them generate all multi-radix numbers with <span class="math">\(M = [10] * 7\)</span>, in
other words, the digits of all 7-digit numbers in base ten. The result is shown
below.</p>
<div class="highlight"><pre>Testing multiradix_product:
Function test_generator took 0.472 seconds to run.

Testing multiradix_counting:
Function test_generator took 26.281 seconds to run.

Testing multiradix_recursive:
Function test_generator took 1.721 seconds to run.

Testing multiradix_iterative:
Function test_generator took 3.687 seconds to run.

Testing multiradix_coroutine:
Function test_generator took 4.726 seconds to run.
</pre></div>
<p>So to rank them in order of efficiency, based on this simple test: we have</p>
<ol class="arabic simple">
<li><tt class="docutils literal">multiradix_recursive</tt></li>
<li><tt class="docutils literal">multiradix_iterative</tt></li>
<li><tt class="docutils literal">multiradix_coroutine</tt></li>
<li><tt class="docutils literal">multiradix_counting</tt></li>
</ol>
<p>The method based on arithmetic is the slowest by a large margin. This makes
sense, provided that we are dealing with base ten numbers, not a power of two
which computers are much better at dealing with. On top of that, Python is
notoriously slow at numeric calculations.</p>
<p>And the fastest, of course, is using the built-in <tt class="docutils literal">itertools.product</tt> method,
which is not surprising in the least because it is implemented in C. However,
it is interesting to find out which, if any, of the above algorithms is used to
implement Python's <tt class="docutils literal">itertools.product</tt> function. For this, let's have a look at
Python's source code, file <tt class="docutils literal">itertoolsmodule.c</tt> (see <a class="citation-reference" href="#py-2" id="id16">[PY-2]</a>). The relevant
section is inside the <tt class="docutils literal">product_next</tt> function:</p>
<div class="highlight"><pre><span class="cm">/* Update the pool indices right-to-left.  Only advance to the</span>
<span class="cm">   next pool when the previous one rolls-over */</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">npools</span><span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">PyTuple_GET_ITEM</span><span class="p">(</span><span class="n">pools</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">PyTuple_GET_SIZE</span><span class="p">(</span><span class="n">pool</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* Roll-over and advance to next pool */</span>
        <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="n">PyTuple_GET_ITEM</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
        <span class="n">oldelem</span> <span class="o">=</span> <span class="n">PyTuple_GET_ITEM</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">PyTuple_SET_ITEM</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">oldelem</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* No rollover. Just increment and stop here. */</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="n">PyTuple_GET_ITEM</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
        <span class="n">oldelem</span> <span class="o">=</span> <span class="n">PyTuple_GET_ITEM</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">PyTuple_SET_ITEM</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">oldelem</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Of course, this is precisely our <tt class="docutils literal">multiradix_iterative</tt>, with reference
counting added.</p>
<p>Our coroutine-based algorithm lags behind all the other ones in terms of
performance except for the arithmetic one. This is not surprising given the
overhead of calling coroutines in Python. However, the coroutine-based approach
will allow us to solve certain problems in very interesting ways, as we will
see.</p>
<p>One last thing to note before moving on is that the coroutines given above can
continue to be called even after <tt class="docutils literal">False</tt> is yielded. In this case, doing so
will result in the list being generated again from scratch, since all the
numbers will have been set to zero by the time we get to <tt class="docutils literal">nobody</tt> and other
than that all the coroutines are ready to run again. As we will see, this is an
interesting property of the coroutine based algorithms, and all of them will
behave in this manner. That being said, in most of them, unlike this particular
example, the order in which the list is generated is reversed each time
<tt class="docutils literal">False</tt> is yielded.</p>
</div>
</div>
<div class="section" id="binary-reflected-gray-codes">
<h2>4   Binary Reflected Gray Codes</h2>
<p>Now, let's consider the case of binary reflected Gray codes and see if we can
apply our coroutine-based approach to this problem.</p>
<div class="section" id="id17">
<h3>4.1   Problem Definition</h3>
<p>For a full introduction and discussion of binary Gray codes, refer to either
<a class="citation-reference" href="#knuth-4a" id="id18">[KNUTH-4A]</a> or <a class="citation-reference" href="#ruskey" id="id19">[RUSKEY]</a>. A binary Gray code is a listing of all binary
strings of length <span class="math">\(n\)</span> such that each two subsequent strings are different
in exactly one index. The binary reflected Gray code (BGRC), is one such code.
It is given by recursively generating the BGRC for <span class="math">\(n - 1\)</span>, then
prepending a zero to all strings, and a one to all the strings in reverse
order. A very naive recursive implementation in Python, which requires the
whole code to be kept in memory, is given below, as a more precise definition.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">gray</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">gray</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">gr</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">([</span><span class="s">'0'</span> <span class="o">+</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">g</span><span class="p">]</span> <span class="o">+</span>
                <span class="p">[</span><span class="s">'1'</span> <span class="o">+</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s">''</span><span class="p">]</span>
</pre></div>
<p>And example output:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">gray</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">000</span>
<span class="go">001</span>
<span class="go">011</span>
<span class="go">010</span>
<span class="go">110</span>
<span class="go">111</span>
<span class="go">101</span>
<span class="go">100</span>
</pre></div>
</div>
<div class="section" id="id20">
<h3>4.2   A Coroutine-Based Algorithm</h3>
<p>The first example in <a class="citation-reference" href="#kr" id="id21">[KR]</a> is precisely BGRC, although it is presented as the
ideals of the totally disconnected poset with <span class="math">\(n\)</span> vertices. To continue
with the trolls of last section, again we have a line of <span class="math">\(n+1\)</span> trolls,
with first troll in line being the special troll that simply yells out "last"
when poked.  This time, however, each troll is simply holding a light in his
hand, which is either on or off. The trolls are also now either asleep or
awake. If a sleeping troll is poked, he simply wakes up and pokes the previous
troll. When an awake troll is poked, he just switches the light (from on to
off, or off to on) and yells "done".</p>
<p>It is relatively easy to see that the index of the first awake troll, starting
from the right, follows the ruler sequence (<span class="math">\(1, 2, 1, 3, 1, 2, 1, 4, 1,
\ldots\)</span>). Once this is established, the fact that the algorithm produces the
BGRC can be shown immediately. I encourage you to convince yourself, mentally
or using a pen and paper, that the above does indeed work as explained.</p>
<p>As for the implementation using coroutines, the awake or asleep state of each
troll is simply a matter of which instruction the coroutine will resume from
when called next. We will not need a variable to keep track of it. This results
in the code for this algorithm to be deceiving simple.  The "lead" coroutine
will again be the last one, and we start the list with the all zeros list.
Putting it all together we have the following code.</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">nobody</span> <span class="kn">import</span> <span class="n">nobody</span>


<span class="k">def</span> <span class="nf">troll</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">previous</span> <span class="o">=</span> <span class="n">troll</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">nobody</span><span class="p">()</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">yield</span> <span class="bp">True</span>
        <span class="k">yield</span> <span class="nb">next</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">lead_coroutine</span> <span class="o">=</span> <span class="n">troll</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">lead_coroutine</span>


<span class="k">def</span> <span class="nf">gray</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">lead</span> <span class="o">=</span> <span class="n">setup</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">a</span>
    <span class="k">while</span> <span class="nb">next</span><span class="p">(</span><span class="n">lead</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">a</span>
</pre></div>
<p>With this algorithm, when <tt class="docutils literal">False</tt> is yielded the first time, <tt class="docutils literal">a</tt> will be
set to the all ones string. As such, if we run the algorithm a second time, we
get the BGRC in reverse order. This can be repeated ad infinitum.</p>
</div>
</div>
<div class="section" id="steinhaus-johnson-trotter-permutation-generation">
<h2>5   Steinhaus-Johnson-Trotter Permutation Generation</h2>
<div class="section" id="id22">
<h3>5.1   Problem Definition</h3>
<p>SJT is an algorithm for generating all permutations in Gray order. Here, Gray
order means that "distance" between two subsequent permutations is one, where a
distance of one means that they differ from each other by one swap of adjacent
elements, also called a transposition. The basic idea of the algorithm is
recursive. Given a list of permutations of <span class="math">\(n-1\)</span>, we can produce a list
of permutations of <span class="math">\(n\)</span> by inserting <span class="math">\(n\)</span> into each permutation of
<span class="math">\(n-1\)</span>, first by starting at the very right end and moving to the left,
and then moving to the right, and so on. Here is an example output for
<span class="math">\(n=3\)</span>.</p>

<p>Here, given the permutations <span class="math">\(12\)</span> and <span class="math">\(21\)</span> for <span class="math">\(n=2\)</span>, SJT
inserts <span class="math">\(3\)</span> at the end of <span class="math">\(12\)</span> and then moves it to the left until
it can not move any further, then moves on to the next permutation of
<span class="math">\(n=2\)</span> which is <span class="math">\(21\)</span> and inserts <span class="math">\(3\)</span> at the left end, and then
moves it to the right until it can no longer move.</p>
<p>A simple recursive implementation of this algorithm is given below.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">permutations</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">pi</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">pi</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
            <span class="n">r</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">yield</span> <span class="p">[]</span>
</pre></div>
</div>
<div class="section" id="id23">
<h3>5.2   A Coroutine-Based Algorithm</h3>
<p>Now let's implement SJT using our coroutine-based approach.  Picture our troll
friends again, standing in a line, and as they did before, each troll is
assigned a number that they will remember, between <span class="math">\(0\)</span> and <span class="math">\(n\)</span>.
This time, however, they no longer hold a number in their hands. Instead, the
numbers are laid out in a row on a table, starting in increasing order:
<span class="math">\(1, 2, 3, \ldots, n\)</span>. Each troll also keeps track of his "direction",
which is either left or right. All trolls start with direction left at the
beginning. Number <span class="math">\(0\)</span> is not on the table since troll number <span class="math">\(0\)</span> is
again the special troll that just yells "last" when poked.</p>
<p>When poked, trolls will walk up to the table and find their number in the row.
They will then look at the number next to their number based on their current
direction (which they meticulously remember!). If the next number is larger
than theirs, or there is no next number, meaning their number is the last or
first in the row (depending on direction), then then they just poke the
previous troll in line, and switch their direction to be opposite of what it
used to be.  Otherwise, they move their number, changing its place with the
number next to it that it was compared to. In this case, they simply yell out
"done".</p>
<p>As before, I encourage you to convince yourself that the above does in fact
produce all permutations in SJT order.</p>
<p>For the coroutine implementation, we follow the above algorithm quite closely,
but add a few things for simplicity. First, we pad both sides of our
permutation with the number <span class="math">\(n + 1\)</span>, which is greater than all numbers in the
permutation. These two numbers will never move and their purpose is to simplify
the code, since we now never have to worry about invalid indices, since we will
always hit a "fence before falling off the cliff". This way we can just check
to see if our number is greater than the next number before doing a swap.</p>
<p>The end result is the following code.</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>


<span class="k">def</span> <span class="nf">nobody</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="bp">False</span>


<span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="c"># Start with the identity permutation with 0 padded on both sides</span>
    <span class="c"># Example: for n = 4, pi starts as [0, 1, 2, 3, 4, 0]</span>
    <span class="c"># The zeros act as "fixed barriers", never moving</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># The inverse permutation starts as the identity as well. It does not need</span>
    <span class="c"># the fixed barriers since their inverses will never be looked up.</span>
    <span class="n">inv</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">troll</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The goal of troll[i] is to move i in the direction of until it hits a</span>
<span class="sd">        "barrier", defined as an element smaller than it.</span>
<span class="sd">        """</span>
        <span class="n">neighbour</span> <span class="o">=</span> <span class="n">troll</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="k">else</span> <span class="n">nobody</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c"># j is the element next to i in pi, in direction d</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">inv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="c"># Swap i and j</span>
                <span class="n">pi</span><span class="p">[</span><span class="n">inv</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">pi</span><span class="p">[</span><span class="n">inv</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span>
                <span class="n">inv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">inv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">inv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">yield</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Change direction and poke</span>
                <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">d</span>
                <span class="k">yield</span> <span class="nb">next</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span>

    <span class="c"># The lead coroutine will be the coroutine in charge of moving 1</span>
    <span class="k">return</span> <span class="n">pi</span><span class="p">,</span> <span class="n">troll</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">permutations</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">lead</span> <span class="o">=</span> <span class="n">setup</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">pi</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">while</span> <span class="nb">next</span><span class="p">(</span><span class="n">lead</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">pi</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">lead</span> <span class="o">=</span> <span class="n">setup</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">print</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">next</span><span class="p">(</span><span class="n">lead</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'----'</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s">'----'</span><span class="p">)</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="id24">
<h3>5.3   Discussion</h3>
<p>First, let's have a look at the performance of the two implementations by
having them generate all <span class="math">\(10!\)</span> (about <span class="math">\(3.6\)</span> million) permutations
of <span class="math">\(n=10\)</span>, and compare the running times:</p>
<div class="highlight"><pre>Testing coroutine-based algorithm:
Function test_generator took 3.944 seconds to run.
Testing recursive algorithm:
Function test_generator took 4.374 seconds to run.
</pre></div>
<p>This time the coroutine-based implementation is slightly faster than the
recursive one.</p>
<p>One last thing to note about this particular example is that similar to our
BGRC example, if run through again, the coroutines will generate the
permutations in reverse order. For example, with <span class="math">\(n=3\)</span> we get:</p>
<div class="highlight"><pre>123
132
312
321
231
213
-------
213
231
321
312
132
123
-------
123
132
312
321
231
213
-------
...
</pre></div>
</div>
</div>
<div class="section" id="ideals-of-a-poset-consisting-of-several-chains">
<h2>6   Ideals of a Poset Consisting of Several Chains</h2>
<div class="section" id="id25">
<h3>6.1   Problem Definition</h3>
<p>Now let's consider another example taken from <a class="citation-reference" href="#kr" id="id26">[KR]</a>. In this example, the
goal is to generate all ideals of a poset consisting of several chains, in Gray
order. In simpler terms, we are to generate all binary strings <span class="math">\(a\)</span> of
length <span class="math">\(n\)</span> such that given some set <span class="math">\(E = \{e_0, e_1, \ldots, e_{m-1}\}\)</span>
with</p>
<p class="math">
\begin{equation*}
0 = e_0 &lt; e_1 &lt; \ldots &lt; e_{m-1} \le n,
\end{equation*}
</p>
<p>we have</p>
<p class="math">
\begin{equation*}
a[k-1] \le a[k] \text{ for } k \not\in E.
\end{equation*}
</p>
<p>This is the same thing as requiring that</p>
<p class="math">
\begin{equation*}
a[e_i] \le a[e_i + 1] \le \ldots \le a[e_{i+1} - 1] \text{ for } 1 \le i &lt; m.
\end{equation*}
</p>
<p>We can see right away that BGRC is a speical case of this one, with <span class="math">\(E =
\{0, 1, 2, 3, \ldots, n\}\)</span>, which reduces the above to a vacuous condition that
is satisfied by any binary string.</p>
<div class="figure">
<img alt="A poset consisting of three chains." src="/images/chain_poset.png"/>
<p class="caption">The poset poset corresponding to <span class="math">\(E = \{0, 2, 3\}\)</span>. If <span class="math">\(i\)</span> is
above <span class="math">\(j\)</span> then we must have <span class="math">\(a[i] \le a[j]\)</span>.</p>
</div>
<p>Here is an example of the desired code for <span class="math">\(E = \{0, 2, 3 \}\)</span> and
<span class="math">\(n=6\)</span>. There are <span class="math">\(3\cdot 2\cdot 4 = 24\)</span> strings in the code total.</p>
<div class="highlight"><pre>000000
000001
000011
000111
001111
001011
001001
001000
011000
011001
011011
011111
010111
010011
010001
010000
110000
110001
110011
110111
111111
111011
111001
111000
</pre></div>
</div>
<div class="section" id="id27">
<h3>6.2   A Coroutine-Based Algorithm</h3>
<p>In this example again, we will have our friendly trolls, with lights in their
hands. They are however, no longer in a neat and tidy straight line. Instead,
Each troll is next to potentially two other trolls, whom he can poke if needed.
Let's call numbers that are at the bottom of a chain "lead" numbers. These are
precisely the numbers in <span class="math">\(E\)</span>. Trolls with lead numbers will have a
access to the previous lead coroutine, and all trolls will have a
reference to the troll with the number above them. If there is no number above
or to the left of a number, then the corresponding trolls will be the special
<tt class="docutils literal">nobody</tt> trolls that always yell out "last".</p>
<p>For example, in the above diagram <tt class="docutils literal"><span class="pre">troll[0].above</span> = troll[1]</tt> and
<tt class="docutils literal"><span class="pre">troll[2].prev_lead</span> = troll[0]</tt>. On the other hand, <tt class="docutils literal"><span class="pre">troll[5].above</span> =
<span class="pre">troll[5].prev_lead</span> = nobody()</tt>.</p>
<p>Similar to the BGRC case, our trolls will be sleeping or awake. The rules for
whom to poke and when to turn the light on and off is a bit more complicated
however. This time, the troll's behaviour depends not only on whether he is
asleep or awake, but also on whether his light is on or off. Instead of
explaining it here, I will let the code do the explanation with some added
comments.</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">nobody</span> <span class="kn">import</span> <span class="n">nobody</span>


<span class="k">def</span> <span class="nf">troll</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="n">above</span> <span class="o">=</span> <span class="n">nobody</span><span class="p">()</span>
    <span class="n">prev_lead</span> <span class="o">=</span> <span class="n">nobody</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">E</span> <span class="o">+</span> <span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
        <span class="n">above</span> <span class="o">=</span> <span class="n">troll</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">E</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">prev_lead</span> <span class="o">=</span> <span class="n">troll</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">E</span><span class="p">[</span><span class="n">E</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c"># Awake and light off - a[i] = 0</span>
        <span class="k">while</span> <span class="nb">next</span><span class="p">(</span><span class="n">above</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">True</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">yield</span> <span class="bp">True</span>

        <span class="c"># Asleep and light on - a[i] = 1</span>
        <span class="k">yield</span> <span class="nb">next</span><span class="p">(</span><span class="n">prev_lead</span><span class="p">)</span>

        <span class="c"># Awake and light on - a[i] = 1</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">yield</span> <span class="bp">True</span>

        <span class="c"># Asleep and light off - a[i] = 0</span>
        <span class="k">while</span> <span class="nb">next</span><span class="p">(</span><span class="n">above</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">True</span>
        <span class="k">yield</span> <span class="nb">next</span><span class="p">(</span><span class="n">prev_lead</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">lead_troll</span> <span class="o">=</span> <span class="n">troll</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">E</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">lead_troll</span>
</pre></div>
<p>The basic idea is to set bits to one starting from the top of the last chain,
and once all the bits in the last chain are set to one, call the coroutine for
the previous lead to go to the next string given by the previous chains, and
then start setting bits to zero starting from the bottom of the chain. Because
of this, the algorithm is a bit similar to our SJT algorithm as well.</p>
<p>This is our most complicated example so far so I highly recommend you spend the
time needed to make sure you understand it fully.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>7   Conclusion</h2>
<p>We looked at a variety of combinatorial generation algorithms implemented using
coroutines. With the examples provided, I hope to have at least created some
intrigue regarding the use of coroutines in solving combinatorial generation
problems. It is my belief that with each style of attacking a combinatorial
generation problem, comes a "mode" of thinking. With recursive algorithms, the
mode of thinking involves finding ways to reduce the problem to a subproblem;
that is, if we have the solution to a smaller instance of the problem, how can
we extend it to a solution for the larger instance? With the iterative
approach, the mode of thinking either involves imitating what a recursive
algorithm does in an iterative way, or it involves finding ways of going
explicitly from one object to the next in the desired order. With both of
these, the mode of thinking is somewhat "global". What I mean by this is that
we are standing outside, looking at the whole list or object, and writing code
that deals with the whole list or one object at a time.</p>
<p>With coroutines, the mode of thinking becomes more "local". We are no longer
looking at the whole list or even a single object, but a single bit or number
in a single object. This mode of thinking involves finding rules by which the
coroutines representing the bits or numbers in the objects we are generating
need to behave and interact with each other so as to produce the desired end
result. I believe that this mode of thinking, apart from being interesting and
novel of and by itself, can be applied to a variety of problems. It is also
quite possible that the mode of thinking might be transferable to other areas,
for example parallel processing and multi-tasking, which are the areas
coroutines have typically been used in.</p>
<p>For those of you interested in learning more <a class="citation-reference" href="#kr" id="id28">[KR]</a> continues generalizing
the BGRC and chain poset algorithms that we saw here, with the final algorithm
generating the ideals of any given poset. The <a class="reference external" href="https://github.com/sahands/coroutine-generation">source code repository for this
article</a> has a few more
examples in Python, including one for generating ideals of the zig-zag poset in
<tt class="docutils literal">zigzag.py</tt>.</p>
</div>
</div></body></html>