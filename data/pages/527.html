<html><body><div><article id="Eq8SHHpwT5qjoUa3VxNs" class="post linked historical">
	<time datetime="2014-02-23" class="article_time">February 23, 2014</time>
  
	<p>Having been so heavily involved with the creation of Python 3, I’m constantly trying to figure out ways to help more of the community make the switch. While doing what I can to make <a href="https://speakerdeck.com/brettcannon/python-3-dot-3-trust-me-its-better-than-python-2-dot-7" rel="nofollow">Python 3 an obviously superior version to Python 2</a>, that only goes so far. At some point you have to start addressing the issues that are acting as blockers for people in general.</p>

<p>At this point I believe the biggest blocker for people is other people. =) What I mean by this is that I have stopped hearing people tell me that they don’t see a reason to switch to Python 3, but instead they tell me they are blocked by a dependency that has not switched over. This then becomes a perpetual issue as people check their dependencies once and then never think to check them again to see if anything has changed; having to manually go through a bunch of <a href="https://pypi.python.org/" rel="nofollow">PyPI</a> project pages to look at trove classifiers and such is not exactly fun and can be time-consuming. Because of this I decided it was worth my time to automate this as best as I could.</p>

<p>That led to me creating <a href="https://pypi.python.org/pypi/caniusepython3" rel="nofollow">caniusepython3</a>. The script will take either a requirements file, a metadata file, or simply a comma-separated list of projects and then using <a href="https://pypi.python.org/pypi/distlib" rel="nofollow">distlib</a> it figures out what dependencies – explicit and implicit – still need to be ported. It will also tell you what leaf nodes of your dependency graph can be ported today so you can go to those projects and request they switch to Python 3 (or if they are inactive projects then start looking for alternatives or fork the project  and port it yourself). And since it’s just a command-line tool you can run it regularly without much hassle to see what projects are currently holding you up.</p>

<p>But this blog post isn’t so much about caniusepython3 as my experience creating a Python project from scratch and deploying to PyPI.</p>
<h1 id="github-travis-is-nice_1">
<a class="head_anchor" href="#github-travis-is-nice_1" rel="nofollow"> </a>GitHub + Travis is nice</h1>
<p>With me being <a href="http://sayspy.blogspot.ca/2009/03/why-python-is-switching-to-mercurial.html" rel="nofollow">the impetus behind Python moving to Mercurial</a> you might be surprised that I used <a href="https://github.com/" rel="nofollow">GitHub</a> for this. While I still do not regret using <a href="http://hg-scm.org/" rel="nofollow">Mercurial</a> for Python at all, I realize that GitHub has more community support. And since the <a href="http://mac.github.com/" rel="nofollow">GitHub for Mac app</a> is nice and does exactly what I want to shield me from ever having to even realize that <a href="http://git-scm.com/" rel="nofollow">git</a> is being used, I’m okay with using GitHub.</p>

<p>But toss in <a href="https://travis-ci.org/" rel="nofollow">Travis</a> and it sweetens the pot. I have previously used <a href="https://drone.io/" rel="nofollow">drone.io</a> for my continuous integration solution, but I decided to give Travis a try this time and it was a rather smooth process. Setup was simple and they have enough Python version coverage to make me happy (2.6, 2.7, 3.2, and 3.3).</p>
<h1 id="python-34-venv-ensurepip-is-very-nice_1">
<a class="head_anchor" href="#python-34-venv-ensurepip-is-very-nice_1" rel="nofollow"> </a>Python 3.4 + venv + ensurepip is VERY nice</h1>
<p>I suspect most people know of <a href="https://pypi.python.org/pypi/virtualenv" rel="nofollow">virtualenv</a> and <a href="https://pypi.python.org/pypi/pip" rel="nofollow">pip</a> at this point. Just in case you don’t, though, virtualenv lets you create an isolated sandbox/virtual environment in which to install dependencies for your project (so it doesn’t pollute your global installation), while pip is a Python project installer. One convenient feature of virtualenv is that it installs pip for you so that creating a virtualenv to work in gets you the basic tools needed to start populating your sandbox with your dependencies and get to work.</p>

<p>In Python 3.3 we actually pulled in virtualenv, cleaned things up a bit, and created the <a href="http://docs.python.org/3/library/venv.html" rel="nofollow">venv</a> module in Python’s standard library. While it’s fantastic to be able to do <code class="prettyprint">python3 -m venv my_sandbox</code> to create a virtual environment to play in, it doesn’t pull in pip like the external project does. I have heard from people they explicit avoid venv because it doesn’t pull in pip.</p>

<p>And this is one of the reasons why Python 3.4 introduced the <a href="http://docs.python.org/3.4/library/ensurepip.html#module-ensurepip" rel="nofollow">ensurepip</a> module which will be triggered during the installation of Python to make sure that pip is also installed. This means that venv now pulls in pip by default as of Python 3.4 which is rather handy and makes getting started that much simpler.</p>

<p>I used to avoid <a href="https://pypi.python.org/pypi/setuptools" rel="nofollow">setuptools</a> and tried to always just use <a href="http://docs.python.org/3/library/distutils.html#module-distutils" rel="nofollow">distutils</a>. This was mostly because distutils was always available while setuptools wasn’t. Then there was the whole setuptools not supporting Python 3, which led to the forking of the project into distribute and then the later unforking (so in case you didn’t know, use setuptools and not distribute!). But at this point setuptools is used by practically everyone and so there’s no reason to not use it and rely on its added feature set.</p>
<h1 id="people-don39t-always-specify-their-python-ver_1">
<a class="head_anchor" href="#people-don39t-always-specify-their-python-ver_1" rel="nofollow"> </a>People don’t always specify their Python version support</h1>
<p>Speaking of metadata, not everyone gets it right. In order to show up on the <a href="https://pypi.python.org/pypi?:action=browse&amp;c=533&amp;show=all" rel="nofollow">list of projects that support Python 3</a>, the project needs to set the <code class="prettyprint">Programming Language :: Python :: 3</code> trove classifier. Unfortunately some projects don’t set the generic Python 3 classifier but do set a more specific one, e.g. <code class="prettyprint">Programming Language :: Python :: 3.3</code>. Other projects don’t set either of them which requires me to go in and find out if I need to manually override them. And then of course there are the projects that have been added to Python 3 at some point, e.g. <a href="https://pypi.python.org/pypi/unittest2" rel="nofollow">unittest2</a>. All of this only applies to released code (e.g. <a href="https://pypi.python.org/pypi/boto" rel="nofollow">boto</a> has Python 3 support in their VCS but it has not been officially released yet).</p>

<p>All of this has led to an <a href="https://github.com/brettcannon/caniusepython3/blob/master/caniusepython3/overrides.json" rel="nofollow"><code class="prettyprint">overrides.json</code> file</a> in caniusepython3 so that I can manually override what the metadata for the project says about Python 3 support. I obviously wish I didn’t have to do this, so if you know of a project that needs to have its metadata updated then file a bug for that project to fix their setup (I <a href="https://github.com/brettcannon/caniusepython3/issues/15" rel="nofollow">plan</a> to for the projects I have already come across but I just have not had the time to do it yet).</p>
<h1 id="psa-read-package-data-through-the-loader_1">
<a class="head_anchor" href="#psa-read-package-data-through-the-loader_1" rel="nofollow"> </a>PSA: read package data through the loader</h1>
<p>And because <code class="prettyprint">overrides.json</code> exists (and will always exist do to stdlib additions), I need a way to read data files in the project’s package. Typically people just use <code class="prettyprint">open()</code>, but that doesn’t work if you’re in a zip file (this is why <a href="https://pypi.python.org/pypi/setuptools" rel="nofollow">setuptools</a> has its <a href="http://pythonhosted.org/setuptools/setuptools.html#setting-the-zip-safe-flag" rel="nofollow"><code class="prettyprint">zip_safe</code> flag</a>).</p>

<p>Well, something that most people don’t realize is that import loaders introduced optional APIs to let loaders read data. Formalized in <a href="http://docs.python.org/3/library/importlib.html#importlib.abc.ResourceLoader" rel="nofollow">importlib.abc.ResourceLoader</a>, loaders can define a <code class="prettyprint">get_data()</code> method which allows code to read data files no matter how everything is stored. Since <a href="http://docs.python.org/3/library/zipimport.html" rel="nofollow">zipimport</a> has existed it has supported this API and <a href="http://docs.python.org/3/library/importlib.html" rel="nofollow">importlib</a> officially completed the picture for loader support, although <a href="http://docs.python.org/3/library/pkgutil.html" rel="nofollow">pkgutil</a> had shims to support it as well for quite a while.</p>

<p>But what’s key is <a href="http://docs.python.org/3/library/pkgutil.html#pkgutil.get_data" rel="nofollow">`pkgutil.get_data()</a> which masks having to make things absolute compared to a package’s file location, making sure to use pkgutil’s shims in versions of Python that pre-date importlib, etc. This means that you can conveniently read in package data while staying zip safe. It’s something every project should be using if they aren’t and need to read data files.</p>
<h1 id="python-3-sure-is-great_1">
<a class="head_anchor" href="#python-3-sure-is-great_1" rel="nofollow"> </a>Python 3 sure is great</h1>
<p>Whenever I do projects I always write them using the latest version of Python. Being involved in Python’s development means that by the time a release comes out I have potentially been living with a new feature for 18 months, so it’s old news to me and thus I just use it out of habit. Then when I set a backwards-compatibility goal I begin to work backwards towards that version support. This allows my code to use as many new features as possible instead of going in the reverse direction and potentially leaving out new features which will carry forward in the future. And specifically in the case of supporting both Python 2 and 3 in a new project, it lets me get my <code class="prettyprint">str</code>/<code class="prettyprint">bytes</code> situation straightened out from the beginning.</p>

<p>In the case of caniusepython3, I scaled back all the way to Python 2.6. People asked for support to at least 2.7, but since the <a href="http://docs.python.org/3/howto/pyporting.html" rel="nofollow">Python 2/3 porting HOWTO</a> says Python 2.6 is a reasonable target I figured I should follow my own advice and go that far back (disclaimer: I wrote the HOWTO; I should also mention the <a href="http://docs.python.org/3.4/howto/pyporting.html" rel="nofollow">Python 3.4 version of the HOWTO</a> is a thorough rewrite). So I started with supporting Python 3.3 exclusively and then worked backwards.</p>
<h2 id="supporting-python-32_2">
<a class="head_anchor" href="#supporting-python-32_2" rel="nofollow"> </a>Supporting Python 3.2</h2>
<p>Getting to Python 3.2 wasn’t hard as it required was adding a dependency on <a href="https://pypi.python.org/pypi/mock" rel="nofollow">mock</a> since it was added to the stdlib. Since Travis doesn’t support Python 3.1 (nor does <a href="https://pypi.python.org/pypi/Django" rel="nofollow">Django</a>), I didn’t worry about explicit Python 3.1 support. But thanks to the language moratorium (<a href="http://legacy.python.org/dev/peps/pep-3003/" rel="nofollow">PEP 3003</a> which I have to disclaim that I co-wrote), there are only library differences which I have to deal with for Python 2.7 anyway.</p>
<h2 id="supporting-python-27_2">
<a class="head_anchor" href="#supporting-python-27_2" rel="nofollow"> </a>Supporting Python 2.7</h2>
<p>Getting down to Python 2.7 wasn’t difficult either. It required more dependencies (<a href="https://pypi.python.org/pypi/argparse" rel="nofollow">argparse</a> and <a href="https://pypi.python.org/pypi/futures" rel="nofollow">concurrent.futures</a>), but that’s no big deal. I also had to add the appropriate <code class="prettyprint">__future__</code> statements for unicode literals and the print function:</p>

<pre><code class="prettyprint lang-python">from __future__ import print_function
from __future__ import unicode_literals
</code></pre>

<p>The only real discrepancy I had to work around was the fact that <code class="prettyprint">io.StringIO</code> wants a <code class="prettyprint">unicode</code> object but gets a <code class="prettyprint">str</code> object when using a bare <code class="prettyprint">print()</code> call when I mocked out <code class="prettyprint">sys.stdout</code> for testing purposes. All I had to do was change to <code class="prettyprint">print('')</code> and that solved everything thanks to the <code class="prettyprint">unicode_literals</code> import.</p>
<h2 id="supporting-python-26_2">
<a class="head_anchor" href="#supporting-python-26_2" rel="nofollow"> </a>Supporting Python 2.6</h2>
<p>If you have not switched passed Python 2.6, I feel bad for you. This was when I really had to scale back serious code in order to support an older version of Python. Having to drop <a href="http://docs.python.org/dev/whatsnew/2.7.html#other-language-changes" rel="nofollow">set literals along with set and dict comprehensions</a> sucked.</p>

<p>I also had to work around losing the richer assertion methods from <a href="https://pypi.python.org/pypi/unittest2" rel="nofollow">unittest2</a>. Instead of just adding another test dependency such as mock I just added appropriate <code class="prettyprint">hasattr()</code> checks so that I didn’t lose the much better failure output.</p>

<p>Finally, losing automatic field numbering in <code class="prettyprint">str.format()</code> was annoying. All it required doing was going back and inserting a number, but it’s one of those things that you think you have fixed, you run your tests, and then you discover that you actually just fail farther down your code. This is why having good test coverage is important.</p>
<h1 id="i-probably-should-have-used-a-template-to-sta_1">
<a class="head_anchor" href="#i-probably-should-have-used-a-template-to-sta_1" rel="nofollow"> </a>I probably should have used a template to start from</h1>
<p>Having not used setuptools before there was a little bit of learning and basic boilerplate to go through. To make my life easier I probably should have just used <a href="https://github.com/audreyr/cookiecutter" rel="nofollow">cookiecutter</a> and <a href="https://github.com/audreyr/cookiecutter-pypackage" rel="nofollow">cookiecutter-pypackage</a> to bootstrap my setup.py and such and worked from there. Another option would have been starting from the <a href="https://github.com/pypa/sampleproject" rel="nofollow">PyPA sample project</a>.</p>
<h1 id="doing-the-right-thing-for-putting-a-project-o_1">
<a class="head_anchor" href="#doing-the-right-thing-for-putting-a-project-o_1" rel="nofollow"> </a>Doing the right thing for putting a project on PyPI</h1>
<p>Since the whole Python packaging ecosystem is actively being fixed, I needed a refresher on how to properly debut a new project on PyPI. The <a href="http://python-packaging-user-guide.readthedocs.org/en/latest/index.html" rel="nofollow">Python packaging user guide</a> has a <a href="http://python-packaging-user-guide.readthedocs.org/en/latest/tutorial.html#create-your-own-project" rel="nofollow">section about it</a> but there were a couple of bits I had to figure out (I have filed bugs to get the doc updated so mentioning this here should be moot at some point).</p>
<h2 id="what-kinds-of-files-to-put-up_2">
<a class="head_anchor" href="#what-kinds-of-files-to-put-up_2" rel="nofollow"> </a>What kinds of files to put up</h2>
<p>If you project is pure Python code, you definitely want the traditional <code class="prettyprint">sdist</code> package, created by <code class="prettyprint">python setup.py sdist</code>. But the new thing to do is to also create a wheel. This requires using setuptools in your <code class="prettyprint">setup.py</code> and installing <a href="https://pypi.python.org/pypi/wheel" rel="nofollow">wheel</a>. With that you can do <code class="prettyprint">python setup.py bdist_wheel</code> and that will create for you a <code class="prettyprint">.whl</code> file (which is basically a zip file with a very specific directory and file layout).</p>

<p>If your project happens to support both Python 2 and 3, then make sure to add a section to your <code class="prettyprint">setup.cfg</code> declaring this fact as wheel files declare their version/API support:</p>

<pre><code class="prettyprint">[wheel]
universal = 1
</code></pre>
<h2 id="registering-and-uploading-to-pypi_2">
<a class="head_anchor" href="#registering-and-uploading-to-pypi_2" rel="nofollow"> </a>Registering and uploading to PyPI</h2>
<p>Once you have created the files you want to upload you will want to register your project name which is a one-time event that you should do through the web UI on PyPI (unfortunately <code class="prettyprint">python setup.py register</code> doesn’t guarantee the use of SSL so it will send your password insecurely).</p>

<p>Once all of that is done you will want to upload your project’s files using <a href="https://pypi.python.org/pypi/twine" rel="nofollow">twine</a>. The reason to use Twine over the old stand by of e.g. <code class="prettyprint">python setup.py sdist upload</code> is for three reasons:</p>

<ol>
<li>It conveniently separates the upload step from the project file creation step</li>
<li>Twine makes sure to use a secure connection to PyPI</li>
<li>If you use GPG, it makes signing project files dead-simple (either use its <code class="prettyprint">-a</code> argument or pass in <code class="prettyprint">.asc</code> files as arguments along with the files you want to upload)</li>
</ol>

<p>With all of this you end up with a project listed on PyPI that supports the old and new ways of hosting projects along with supporting both Python 2 and 3.</p>

  <figure class="postend kudo able clearfix" id="kudo_Eq8SHHpwT5qjoUa3VxNs">
    <a href="#kudo">
      <p class="filling"> </p>
    </a>
    <p class="num">110</p>
    <p class="txt">Kudos</p>
  </figure>
  <figure class="side kudo able clearfix" id="kudo_side_Eq8SHHpwT5qjoUa3VxNs">
    <a href="#kudo">
      <p class="filling"> </p>
    </a>
    <p class="num">110</p>
    <p class="txt">Kudos</p>
  </figure>
</article>

</div></body></html>