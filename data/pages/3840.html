<html><body><div><div class="entry-content">
<p><em>I wrote a blog on <a href="http://pythonforengineers.com/stop-the-works-on-my-machine-syndrome/">how to isolate your Python code</a>, and briefly mentioned Docker at the end. My comments were that I hadn’t really used Docker, and wasn’t sure when to use it.</em></p>
<p><em>Aaron wrote a great comment, in which he called Docker “VirtualEnv on crack”. This amused and intrigued me, so I asked him if he could expand on his comment. </em></p>
<p><em>Note: Docker is not just limited to Python, but can be used to isolate anything on your system, from databases to webapps to multiple versions of the same programming language.</em></p>
<h4>What is docker?</h4>
<p>So if you’ve spent time hanging out on some of the super trendy internet message boards lately (I’m looking at you HN and Reddit) you’ll probably have heard about docker, and how it’s awesome, and how it’s going to change the world of programming and put all the sys-admins out of a job. But maybe you’ve been too busy playing with the latest bleeding edge version of Netflix’s latest open source product to find out more about docker.</p>
<h4>So what is docker again?</h4>
<p>Docker is a way of putting your apps in lightweight containers, built on top of some nifty tech in the Linux kernel (Sorry Windows, you can’t play for now). If you’ve ever built applications for OSX’s sandbox then this is a similar idea. You can control what your application has access to in terms of networking, resources, filesystems and so on.</p>
<p>So you can have your MySql database in one container, your Django app in another, and a Redis in a third. The containers can talk to each other, and you can always make sure you have the exact version of MySql/Django/Whatever you need.</p>
<p>Everything your app needs (above the kernel itself) is contained in your docker container. That includes the OS distro itself, all your libraries, environment variables, EVERYTHING.</p>
<p>Docker containers are built on a copy-on-write filesystem, this means that several different containers can share the same base, but if you add different dependencies, libraries and so on, a new container is created for your app.</p>
<h4>Great, but what the hell IS docker?</h4>
<p>Docker runs as a daemon (on Linux, a daemon is a background process) on your workstation and coordinates building docker images, running the images as containers, pulling/pushing images from a docker repo and keeping track of which containers are currently running on your machine.</p>
<p>Docker hub is a public repository (<em>think github for docker containers</em>) where you’ll find all sorts of useful pre-built images and can store your own. You can also host your own private docker repository to use within your organisation.</p>
<h4>Why should I care?</h4>
<p>So this all sounds great, but you’re probably thinking: how does this apply to me?</p>
<h4>Contain all your dependencies (Not just the python ones)</h4>
<p>Have you ever longed to have that other version of libx installed just for your app inside VirtualEnv without doing all that messy symlinking? With docker you can! Need to run your app on Ubuntu but you run RedHat in production? Dockerise it. Need to install different version of python for all your apps but you can’t mess with the production environment? Docker to the rescue. Have you written one of those really awesome tools for making sure every external application has its environment variables and libs managed as well as keeping everything up to date for your own internal applications? Well good on you, but Docker is probably a lot less work.</p>
<h4> Speed</h4>
<p>Docker isn’t a VM. You’re running on the host hardware, there’s no virtualisation layer. You don’t have to wait for a container to boot, it’s just there, waiting for you.</p>
<h4>Immutable, (really) portable, apps and environments</h4>
<p>When you create an application in a docker image, that app, all its dependencies and associated environment variables are now fixed in stone. It will run the same way on your machine as it does on a production machine, on a customer machine or on your laptop at home. (I’ll let that sink in for a second.)</p>
<p>The application you’ve created is fixed, if you change the code, you build another container and you can deploy that. Doesn’t work? Immediately roll back to your previous image. There are ways to mount code from the host inside a container for testing and developing, so you can see how your latest changes will perform in production too, before deploying.</p>
<p>With docker you don’t need a complicated deployment process, you just download an image from your repo and run it. Anywhere. And it’ll actually work, the same way it worked on your laptop.</p>
<h4>Versioned environments</h4>
<p>Docker allows you to write Dockerfiles to define your image builds, think of them as something between a makefile and a bash script, and they define everything about your application image. So you’ve probably just written a basic dockerfile and built the image, maybe you even put some code inside it. Now.. commit that dockerfile to git. Congratulations! You just created a completely reproducible, versioned environment that defines everything from your operating system up to your test code. Again, I’ll let that sink in for a second.</p>
<h4>Containers are isolated</h4>
<p>When you start building with containers, you have to start thinking modularly. I mean REALLY modularly. If you want to put something in a container closed off from the outside, it better have everything it needs in there. If your applications are already fantastically written, decoupled and modular then great, give yourself a pat on the back, download docker and carry on. However, if some of your applications are coupled, and rely on a bunch of other external factors being true in order to function, then Docker is a good cure. It’ll probably be hard at first to mentally break apart your systems and start thinking modularly, but it’s definitely a Good Thing. Remember the time you read those programming books about clean code and decoupled architectures and you thought ‘Damn this is brilliant, all our code should be like this’. Well working in containers encourages you to create plugable, modular applications (or if you want to be hip: microservices). Embrace it.. and your QA team will thank you.</p>
<h4>Ok I’m sold, now what?</h4>
<p>So hopefully you’re starting to see the power of docker, and that it might be useful. The best place to start is on the<a href="https://www.docker.com/tryit/"> docker website</a>, they have great documentation and getting started guides. The docker mailing list is also helpful and welcoming if you have questions or problems.</p>
<p>And if you’re really feeling adventurous, have a look at some Cool New Things like <a href="https://coreos.com/">CoreOS</a>, <a href="http://mesos.apache.org/">Mesos </a>and <a href="http://kubernetes.io/">Kubernetes</a><em>:</em> soon your whole infrastructure could be decoupled from your hardware and running in distributed multi cloud hybrid datacentres across the globe (+10 points if they’re connected via inflatable WiFi balloons).</p>
<p><em>Aaron is a Python/C++ developer with several years experience working in R&amp;D for VFX industry, find him on Twitter <a href="https://twitter.com/rncry">@rncry</a> if you want to heckle him or talk about Star Wars.</em></p>
<p><em>Next Time:</em> <em>We will look at a practical example on how to get started with Docker, especially to replace VirtualEnv / Virtual Machines. Keep watching this space.<strong><br/>
</strong></em></p><p>
PS: Want a </p><strong>free</strong><p> 1+ hour </p><strong>video</strong> <strong>course</strong><p>,</p><em> Introduction to Web Scraping and Data Analysis</em><p>?
Also get a </p><strong>free</strong><p> mini-book,</p><em> Python: From Apprentice to Master.</em>

 
<em>I will never spam you. Unsubscribe anytime.
</em>
</div>
</div></body></html>