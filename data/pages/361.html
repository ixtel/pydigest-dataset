<html><body><div><div class="ibm-col-1-1">

<h2 id="N10049">Введение</h2><p>Ещё одной привлекательной особенностью Python является простота, скорость и гибкость в создании 
приложений с графическим интерфейсом пользователя (GUI). Это преимущество связано не только с большим 
количеством поддерживаемых графических библиотек: Tkinter, PyQt, PyGTK, wxPython, Pygames и др. Основная 
причина заключается в интерпретирующей природе платформы Python, так как из-за доступности Python-кода 
внешний вид графического приложения всегда можно изменить или дополнить. А весь интерфейс из Python-кода 
к фактической реализации GUI скрыт внутри модулей библиотеки Python.</p><p>Однако этим преимущества разработки GUI-приложений именно на Python не исчерпываются, так как Python 
предлагает:</p><ul class="ibm-bullet-list"><li>
независимость от платформы: графическое приложение, разработанное на Python в одной ОС (например, Linux) 
будет с большой степенью вероятности адекватно работать в любой другой среде (Windows, MacOS, Solaris, 
FreeBSD, …) или потребует для этого незначительных доработок;
</li><li>
GUI-приложения в основном являются диалоговыми, т.е. предназначенными для взаимодействия с 
пользователем, при этом скорость работы приложения определяется действиями пользователя, и здесь исчезает 
один из основных формальных недостатков Python — его замедленность по сравнению с C или C++;
</li><li>
из-за простоты интеграции Python с C/C++, визуальные компоненты проекта (GUI) могут быть написаны на Python 
с учётом скорости разработки (frontend), а внутренние процедуры для обработки данных — на C/C++ (backend).
</li></ul><p>В этой и последующей статьях мы обсудим различные мульти-платформенные технологии создания 
GUI-приложений, доступные для Python-программистов.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N1005A">GUI-приложения</h2><p>Основной целью данной статьи будет <strong>поверхностный</strong> обзор различных вариантов, 
доступных при выборе инструментария для разработки GUI-приложений. Так программист сможет определить, 
какой инструмент наиболее подходит для решения конкретной задачи. Подобная постановка задачи связана 
ещё и с тем, что для всех многочисленных инструментов для разработки GUI-приложений существуют (более или 
менее удачные и полные) руководства. Но практически отсутствуют материалы, в которых бы выполнялся 
сравнительный анализ разных подходов.</p><p>При всём разнообразии, громоздкости и кажущейся сложности различных инструментальных средств 
создания графических приложений, их общая схема однообразна и проста:</p><ul class="ibm-bullet-list"><li>
создаётся бесконечный цикл опроса (ожидания) событий (<strong>главный цикл</strong>), порождаемых 
действиями пользователя (ввод с клавиатуры, перемещение указателя или нажатие кнопки мыши и т.д.);
</li><li>
для каждого потенциально возможного (<strong>обрабатываемого</strong>) события назначается функция 
обратного вызова (<strong>callback функция</strong>), которая будет вызываться при наступлении этого события 
(<strong>обработчик события</strong>);
</li><li>
при возникновении событий, для которых не были назначены обработчики, они будут игнорироваться;
</li><li>
на каждом "витке" главного цикла приложения анализируются наступившие (со времени предыдущего "витка") 
события, и для каждого такого события вызывается его обработчик, если ожидающих событий несколько, то они 
обрабатываются в порядке очереди;
</li><li>
всякий GUI-инструмент имеет некоторый набор графических компонентов (виджетов - widget) и средства для 
компоновки таких виджетов в окне приложения, а каждый из компонентов имеет свой специфический набор 
событий, которые он может генерировать;
</li></ul><p>Такой подход называется событийно управляемым программированием (<strong>event driven 
programming</strong>). Все GUI приложения, независимо от используемой графической технологии, будут 
использовать этот общий шаблон.</p><p>Исходя из подобной сжатой формулировки, в дальнейшем нас будут интересовать только вопросы 
применимости, выбора, установки и начала работы с инструментом. Но иногда мы будем обращаться и к 
специфическим требованиям для определённых инструментов по оформлению функций обработчиков событий. 
Вопросы компоновки виджетов в конкретных средах рассматриваться не будут.</p><p><strong>Примечание.</strong> Внешний вид одного и того же GUI-приложения может отличаться при запуске 
в разных средах (операционных системах, менеджерах рабочего стола, оконных менеджерах). Это обусловлено 
тем, что фактическую прорисовку виджетов обеспечивают не графические библиотеки, а оконный менеджер 
графической системы.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N10087">Tkinter</h2><p>Tkinter является стандартным модулем Python и входит в состав его стандартной библиотеки. Модуль Tkinter 
позиционируется для <strong>быстрого</strong> написания GUI-приложений. Его описание доступно в встроенной 
справочной системе <code>pydoc</code>.</p><p><strong>Примечание.</strong> Справочная система <code>pydoc</code> доступна только в 
операционных системах семейства UNIX (Linux и др.). Для обращения к ней используется команда:</p><p>Значение опции <strong><code>-p</code></strong> определяет порт TCP, который можно 
переопределить. После этого любым Web-браузером можно подключиться к этой справочной системе, набрав в 
адресной строке браузера: <strong>http://localhost:8080</strong>. В реализации Python для ОС Windows есть своя 
справочная система, устанавливаемая вместе с Python.</p><p>Хотя модуль Tkinter считается входящим в состав библиотеки стандартных модулей Python, может 
потребоваться его отдельная инсталляция (или, как минимум, проверка его наличия), так как обычно Tkinter не 
устанавливается при установке Python. Кроме того существуют его различные версии специально для Python 2 и 
Python 3.</p><ul class="ibm-bullet-list"><li>
в .rpm дистрибутивах (Fedora и др.):
<div class="codesection"><pre class="displaycode"><strong># yum list tkinter.*</strong>
...
Установленные пакеты
tkinter.i686                                      2.7.3-7.2.fc17

<strong># yum install python3-tkinter.i686</strong>
...
Установлено:
  python3-tkinter.i686 0:3.2.3-7.fc17</pre></div></li><li>
в .deb дистрибутивах (Debian и др.):
<div class="codesection"><pre class="displaycode"><strong>$ aptitude search python-tk</strong>
p python-tk  - Tkinter - написание Tk программ на Python
p python-tk-dbg  - Tkinter - Writing Tk applications with Python (debug extension)
p python-tksnack  - Sound extension to Tcl/Tk and Python/Tkinter - Python library
<strong># apt-get install python-tk</strong>
…
Настраивается пакет python-tk (2.7.3-1) …

<strong>$ aptitude search python3-tk</strong>
p python3-tk  - Tkinter - Writing Tk applications with Python 3.x
p python3-tk-dbg  - Tkinter - Writing Tk applications with Python 3.x 
(debug extension)
<strong># apt-get install python3-tk</strong>
...
Настраивается пакет python3-tk (3.2.3-1) …</pre></div></li></ul><p>Как видно из примера, иногда могут возникнуть сложности из-за разных наименований пакетов в различных 
дистрибутивах, но эта проблема легко решается.</p><p><strong>Примечание.</strong> Существует ещё одна особенность использования стандартного модуля 
Tkinter, так в версиях Python 2.X он должен записываться в написании 
<strong><code>Tkinter</code></strong>:</p><div class="codesection"><pre class="displaycode">from Tkinter import Label</pre></div><p>Но в версиях Python 3.X он должен записываться в написании 
<strong><code>tkinter</code></strong>, и та же строка будет выглядеть по-другому:</p><div class="codesection"><pre class="displaycode">from tkinter import Label</pre></div><p>Если же необходимо обеспечить совместимость между версиями, то строки импорта могут быть записаны так:</p><div class="codesection"><pre class="displaycode"><strong>
try:
    from tkinter import *
except ImportError:
    from Tkinter import *
</strong></pre></div><p>В качестве иллюстрации будет использована не слишком сложная (но и не тривиальная) задача угадывания 
пользователем случайного числа, генерируемого программой. Вариант кода для Python 3, реализующего задачу 
при использовании <strong><code>Tkinter</code></strong>, в листинге 1 (см. файл 
<strong>gntm.py</strong> в архиве <strong>python_gui.tgz</strong> в разделе "Материалы для скачивания"):</p><h5 id="listing1">Листинг 1. Оконное приложение, использующее Tkinter</h5><div class="codesection"><pre class="displaycode">#!/usr/bin/python3
# -*- coding: utf-8 -*-

from sys import argv
import random
import math
from tkinter import *  

val_range = 0    <strong># диапазон числа</strong>
secret = 0       <strong># угадываемое число</strong>
guesses = 0      <strong># число попыток</strong>
limits = 0       <strong># макс. число попыток</strong>

def new_game():
    global secret, guesses, limits
    msg[ 'text' ] = ' ' * 100 + \
        '\nНовая игра, диапазон: [ 0...{} )\n'.format( val_range )
    secret = random.randrange( 0,val_range )
    guesses = 0
    limits = int( math.ceil( math.log( val_range, 2 ) ) )
    
def input_guess( event ):
    global guesses
    if guesses &lt; 0 :            <strong># признак завершённой игры</strong>
        msg[ 'text' ] += 'Начните новую игру...\n'
        ent.delete( 0, END )
        return
    try :
        value = int( ent.get() )
    except ValueError:
        msg[ 'text' ] += 'Ошибка: значение должно быть целочисленным!\n'
        ent.delete( 0, END )
        return;
    ent.delete( 0, END )
    guesses += 1
    if value &lt; secret :
         msg[ 'text' ] += '{} - это меньше ...\n'.format( value )
    elif value &gt; secret :
        msg[ 'text' ] += '{} - это больше ...\n'.format( value )
    else :
        msg[ 'text' ] += 'Игрок выиграл!\n'
        guesses = -1             <strong># признак завершённой игры</strong>
        return
    if guesses &gt;= limits :        
        msg[ 'text' ] += 'Компьютер выиграл! Загадно было {}\n'.format( secret )
        guesses = -1             <strong># признак завершённой игры</strong>
        return
        
root = Tk()
root.title( 'Угадай число!' )    <strong># окно пиложения</strong>
root.geometry( '500x240' )
Label( root, text='Вводите следующее число...' ).pack( side=TOP )
ent = Entry( root, width=10 )    <strong># поле ввода</strong>
ent.pack( side=TOP )
ent.focus() <strong># избавить от необходимости выполнять щелчок мышью для фокуса</strong>
ent.bind( '&lt;Return&gt;', input_guess )
Button( root, text=' Новая игра ', command=new_game ).pack( side=BOTTOM )
msg = Message( root, bg='white', fg='black', width=400, borderwidth=0 )
msg.pack( side=TOP )             <strong># окно результата</strong>

val_range = ( len( argv ) &gt; 1 and int( argv[ 1 ] ) ) or 100 <strong># параметр - диапазон</strong>
new_game()
root.mainloop()</pre></div><p>Здесь с помощью менеджера компоновки Tkinter при вызове <strong><code>pack()</code></strong> 
в приложение было добавлено несколько виджетов: поле ввода, кнопка и текстовые поля вывода.</p><p>На рисунке 1 показан результат запуска данного приложения.</p><img alt="Рисунок 1. Пример GUI-приложения, основанного на библиотеке Tkinter" src="fig_01.jpg"/><p>Руководство по использованию Tkinter изложено в 1-м томе книге Марка Лутца (см. раздел "Ресурсы"). 
Представленной информации будет вполне достаточно для квалифицированной работы с Tkinter.</p><p>Следует также иметь в виду некоторые ограничения этого способа построения графических приложений, 
так как Tkinter основан на инструментарии Tk, который поддерживает несколько устаревший вид виджетов. 
По умолчанию, он не поддерживает некоторые сложные виджеты, например, деревья или окна с закладками 
и др.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N10137">PyQt</h2><p>Пакет (несколько различных модулей) PyQt являются интерфейсом из Python к графической системе Qt4. 
Для использования PyQt потребуется установить дополнительные модули Python.</p><p>Для Python 2:</p><div class="codesection"><pre class="displaycode"><strong>$ aptitude search python-qt</strong>
p   ipython-qtconsole           - enhanced interactive Python shell - Qt console
p   python-qt4               - Python bindings for Qt4
p   python-qt4-dbg           - Python bindings for Qt4 (debug extensions)
p   python-qt4-dbus          - D-Bus Support for PyQt4
p   python-qt4-dbus-dbg      - D-Bus Support for PyQt4 (debug extensions)
p   python-qt4-dev           - Development files for PyQt4
p   python-qt4-doc           - документация и примеры для PyQt4
p   python-qt4-gl            - Python bindings for Qt4's OpenGL module
p   python-qt4-gl-dbg        - Python bindings for Qt4's OpenGL module (debug extension)
p   python-qt4-phonon        - Python bindings for Phonon
p   python-qt4-phonon-dbg    - Python bindings for Phonon (debug extensions)
p   python-qt4-sql           - интерфейс Python к модулю Qt4 SQL
p   python-qt4-sql-dbg       - Python bindings for PyQt4's SQL module (debug extension)

<strong>$ sudo apt-get install python-qt4 python-qt4-dev python-qt4-doc</strong>
...</pre></div><p>Для Python 3:</p><div class="codesection"><pre class="displaycode"><strong>$ aptitude search  python3-pyqt*</strong>
p   python3-pyqt4              - Python3 bindings for Qt4
p   python3-pyqt4-dbg          - Python3 bindings for Qt4 (debug extensions)
p   python3-pyqt4.phonon       - Python3 bindings for Phonon
p   python3-pyqt4.phonon-dbg   - Python3 bindings for Phonon (debug extensions)
p   python3-pyqt4.qsci         - Python 3 bindings for QScintilla 2
p   python3-pyqt4.qtopengl     - Python 3 bindings for Qt4's OpenGL module
p   python3-pyqt4.qtopengl-dbg - Python 3 bindings for Qt4's OpenGL module (debug...
p   python3-pyqt4.qtsq         - Python3 bindings for PyQt4's SQL module
p   python3-pyqt4.qtsql-dbg    - Python3 bindings for PyQt4's SQL module (debug...

<strong># apt-get install python3-pyqt4</strong>
...</pre></div><p>Далее будут использоваться простые примеры, которых, тем не менее, вполне достаточно для понимания 
логики приложения и начала работы с этими инструментами. Ниже в листинге 2 показано простейшее приложение, 
написанное с использованием PyQt (файл <strong>hw3pyqt.py</strong> в архиве <strong>python_gui.tgz</strong> ).</p><h5 id="N1015D">Листинг 2. Пример PyQt-приложения</h5><div class="codesection"><pre class="displaycode">#!/usr/bin/python3
# -*- coding: utf-8 -*-

import sys
from PyQt4.QtGui import *

<strong># Каждое приложение должно создать объект QApplication
# sys.argv - список аргументов командной строки</strong>
application = QApplication(sys.argv)

<strong># QWidget - базовый класс для всех объектов интерфейса пользователя;
# если использовать для виджета конструктор без родителя, такой виджет станет окном</strong>
widget = QWidget()

widget.resize(320, 240)                 <strong># изменить размеры виджета</strong>
widget.setWindowTitle("Hello, World!")  <strong># установить заголовок</strong>
widget.show()                         <strong>  # отобразить окно на экране</strong>

sys.exit(application.exec_())          <strong> # запуск основного цикла приложения</strong></pre></div><p>В этом примере присутствуют все показанные ранее признаки и структура событийно- управляемого 
приложения, а главное отличие между листингами 1 и 2 исключительно внешнее и заключается в именах 
вызовов API, но сама логика построения приложения остаётся неизменной.</p><p>На рисунке 2 показан результат запуска этого приложения:</p><img alt="Рисунок 2. Пример GUI-приложения, основанного на библиотеке PyQt" src="fig_02.jpg"/><p>Проект PyQt имеет параллельно развивающееся ответвление PySide, которое некоторые разработчики 
считают более удобным, чем оригинальный PyQt.</p><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N10181">PyGTK</h2><p>Проект PyGTK – это ещё один мульти-платформенный GUI инструмент, использующий библиотеки GTK+. В 
листинге 3 показан пример PyGTK-приложения (файл <strong>hw3gtk.py</strong> в архиве 
<strong>python_gui.tgz</strong> ), демонстрирующий что PyGTK также полагается на событийно-управляемый 
подход.</p><h5 id="N1018F">Листинг 3. Пример PyGTK-приложения</h5><div class="codesection"><pre class="displaycode">#!/usr/bin/env python
#-*- coding: UTF-8 -*-

import gtk

def button_clicked(button):
    print 'Hello World!'

def main():
    window = gtk.Window()
    window.set_default_size(240, 180)
    window.set_title('Hello World!')
    window.connect('destroy', lambda w: gtk.main_quit())

    button = gtk.Button('Press Me')
    button.connect('clicked', button_clicked)
    button.show()

    window.add(button)
    window.present()

    gtk.main()

if __name__ == '__main__':
    main()</pre></div><p>На рисунке 3 показан результат запуска этого примера.</p><img alt="Рисунок 3. Пример GUI-приложения, основанного на библиотеке PyGTK" src="fig_03.jpg"/><p>В разделе "Ресурсы" приведены ссылки на подробную документацию по PyGTK, в том числе и на 
русскоязычные материалы.</p><p>Начиная с 2012 года (с версии 2.8), обёртки объектов Glib были вынесены в отдельную библиотеку — 
PyGObject, которая должна будет полностью вытеснить PyGTK при использовании GTK+ версии 3:</p><div class="codesection"><pre class="displaycode"><strong>$ aptitude search python3-gi</strong>
p   python3-gi       - Python 3 bindings for gobject-introspection libraries
p   python3-gi-cairo - Python 3 Cairo bindings for the GObject library
p   python3-gi-dbg   - Python 3 bindings for gobject-introspection libraries (debug ...</pre></div><p>После установки пакета <strong><code>python3-gi</code></strong> можно воспроизвести 
предыдущий пример, но уже с использованием Python 3. В листинге 4 показан обновлённый вариант кода (см. 
файл <strong>hw4gtk.py</strong> из архива <strong>python_gui.tgz</strong>). В данном случае изменения носят 
скорее косметический характер, хотя иногда в ходе миграции из PyGTK в PyGObject могут возникнуть 
определённые проблемы.</p><h5 id="N101B6">Листинг 4. Пример PyGTK-приложения для Python 3</h5><div class="codesection"><pre class="displaycode">#!/usr/bin/python3
#-*- coding: UTF-8 -*-

from gi.repository import Gtk

def button_clicked(button):
    print( 'Hello World!' )

def main():
    window = Gtk.Window()
    window.set_default_size(240, 180)
    window.set_title('Hello World!')
    window.connect('destroy', lambda w: Gtk.main_quit())

    button = Gtk.Button('Press Me')
    button.connect('clicked', button_clicked)
    button.show()

    window.add(button)
    window.present()

   Gtk.main()

if __name__ == '__main__':
    main()</pre></div><p>Исполнение этого примера в Python 3 создаст аналогичное окно.</p><div class="codesection"><pre class="displaycode"><strong>$ python3 hw4gtk.py</strong>
Hello World!
Hello World!
Hello World!
...</pre></div><p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="N101C3">Заключение</h2><p>В этой статье был представлен краткий обзор нескольких инструментов для создания графических 
приложений, доступных к использованию из Python. Также мы описали общие принципы построения 
GUI-приложений (схема событийно управляемых приложений), независимо от того, каким инструментом будет 
реализована отрисовка виджетов.</p><p>Показаны простейшие примеры кода для различных инструментов. Вы можете их взять за основу для 
проверки готовности системы (установки и настройки всех требуемых компонентов), и в качестве стартового 
приложения для придания требуемой функциональности.</p><p>В следующей статье мы продолжим знакомство с технологиями, позволяющими создавать GUI-приложения в 
Python.</p>
<p class="ibm-alternate-rule"><hr/></p><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a></p><h2 id="download">Загрузка</h2>

</div>
</div></body></html>