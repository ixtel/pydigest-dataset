<html><body><div><div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Discussion-line-by-line">Discussion line by line<a class="anchor-link" href="#Discussion-line-by-line">Â¶</a></h3><p>Let's skip down to the the line</p>
<div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
</pre></div>
<p>For those of you not familiar with this line, it tells the Python interpreter to run this section of code when the script is not imported into another piece of code. You can think about it this way</p>
<div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'The program executed by itself'</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'The program has been imported from another module'</span><span class="p">)</span>
</pre></div>
<p>The Python documentation says that this is required when using the <code>multiprocessing</code> module in order to allow for "safe" importing of the <code>main</code> module.</p>
<div class="highlight"><pre><span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
</pre></div>
<p>The line above should be self-explanatory. However, it is important we still understand it. <code>cpu_count()</code> essentially tells us the theoretical maximum number of processes we can run at any given moment. If <code>cpu_count()</code> returns <code>10</code>, in practice, you will never have <code>10</code> workers going at one time. Python turns out to be a polite program. If it sees other processes are running on the machine, it may only use <code>8</code> or <code>9</code> out of <code>10</code>. This is important for the next two lines of code.</p>
<div class="highlight"><pre><span class="n">max_number_processes</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">max_number_processes</span><span class="p">)</span>
</pre></div>
<p>In the first line, I set a maximum number of worker processes that multiprocessing should run at any given moment. Each worker is assigned its own process identification number (pid). You will notice that I stayed on the conservative side by picking <code>2</code>. However, Python will allow you to set the value to <code>cpu_count()</code> or even higher. Since Python will only run processes on available cores, setting <code>max_number_processes</code> to <code>20</code> on a <code>10</code> core machine will still mean that Python may only use <code>8</code> worker processes.</p>
<div class="highlight"><pre><span class="n">total_tasks</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">tasks</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_tasks</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map_async</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">jobs</span><span class="p">)</span>
</pre></div>
<p>OK, the next two lines are where the magic really begins to happen! In this case, we are using <code>map_async</code>. We will skip what this means for now but <code>map_async</code> assigns work to the worker processes. To define the 'work' done by the worker processes, we pass a <code>func</code> I've called <code>work</code> as the first argument in <code>map_async</code> and an <code>iterable</code>, which I defined as <code>tasks</code>, that is a <code>list</code> of integers using <code>range()</code>. <code>tasks</code> is any <code>iterable</code> Python object. It contains all the <code>args</code> you want to pass to <code>work</code>. I'll show a more complicated and more useful iterable later.</p>
<p>It is important to note two things about what we've done. The first is that the number of tasks, 16, is greater than the theoretical maximum number of processes we can run. This means when a worker is done with 'one unit of work,' it moves on to the next. The next note is that <code>map_async</code> does the work in random order and does not wait for a proceeding task to finish before starting a new task. This is the fastest approach, but it means that <code>Unit of work number 6</code> may print before <code>Unit of work number 2</code>. In this case, we aren't worried about that.</p>
<p>The last two lines of code I discovered through painful trial and error.</p>

<p>OK, so <code>close()</code> means that we cannot submit new tasks to our pool of worker processes. Once all the tasks have been completed, the worker processes will exit. This is required before we can run what's probably the most important line in this example, <code>join()</code>. <code>join()</code> says that the code in <code>__main__</code> must wait until all our tasks are complete before continuing! Why is this important? Well, if you plan to use the results returned by your worker processes, you must make the code pause. If you do not use <code>join</code>, the remainder of your script will run after <code>map_async</code> spawns, assigns the tasks, our worker processes. This means you may get errors and other parts of your code will throw a <code>NameError</code> or another ugly error.</p>
<p>OK, so in this example, we didn't do anything too interesting besides introduce the basic structure of a multiproccessing Python script. Please note that you can always import a <code>func</code> you plan to use for your 'unit of work.'</p>

</div>
</div></body></html>