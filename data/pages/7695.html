<html><body><div><div class="post-text" itemprop="text">

<p>When I was playing with my newly created html module, I used weakref module to overcome the circular reference problem. Everything seems to be fine for me! but I am not sure about the way I followed and not sure about the <code>Scope</code> class below. I tried to have a smallest working example (Here is a <a href="https://bitbucket.org/ozanhaci/py2ml/src/3b2ab576260448781b551fa04cd4fdb5449634a1/py2ml/html.py?at=master&amp;fileviewer=file-view-default" rel="nofollow">link</a> for full code). <code>Html</code> class is just for creating html output with python objects. The example below does not do that for simplicity, of course.</p>

<pre><code># encoding: utf-8
from __future__ import print_function, unicode_literals
import weakref


class Scope(object):
    def __init__(self):
        self.ref_holder = set()

    def add(self, obj):
        self.ref_holder.add(obj)

    def __enter__(self):
        return self

    def __exit__(self, *args, **kwargs):
        self.ref_holder = None


class Html(object):
    def __init__(self, parent=None, tag="", scope=None):
        self.scope = scope
        if parent is None:
            self.parent = None
        elif type(parent) != weakref.CallableProxyType:
            self.parent = weakref.proxy(parent)
            if self.scope:
                self.scope.add(parent)
            elif parent.scope:
                parent.scope.add(self)
        else:
            self.parent = parent
        self.tag = tag
        if self.scope:
            self.scope.add(self)
        self.children = []

    def append(self, html):
        if isinstance(html, basestring):
            html = Html(tag=html)
            return self.append(html)
        elif isinstance(html, self.__class__):
            self.children.append(html)
            return html
        else:
            raise Exception("Unknown type")

    def __unicode__(self):
        return 'Html "{tag}" children = {children}'.format(tag=self.tag,
                                            children=list(map(str, self.children)))

    def __str__(self):
        return self.__unicode__()

if __name__ == "__main__":
    with Scope() as scope:
        test_form = Html(tag="form", scope=scope)
        test_form.append(Html(tag="label"))
        test_input = Html(tag="input")
        test_form.append(test_input)
        print(test_form)
</code></pre>

<p>Here are my concerns and I will appreciate your guidance:</p>

<p>I call reference holder class as <code>Scope</code>. It just holds the references to objects even if they are not assigned to any variable so <code>Html</code> object is not garbage collected (note: some objects can change parent/child relation ship and therefore there is not left any strong reference to object, in the real code).</p>

<p>I could simply hold the object references in a list and delete it after that but using <code>with</code> statement seems nicer. Is the class name <code>Scope</code> right for this task and the way I hold references is right? Is there a good way to hold the objects' strong references created on the fly different than my method?</p>

<p>I believe setting the <code>Scope.ref_holder</code> variable to <code>None</code> after exiting with statement, frees all the strong references and then <code>gc</code> collects them. I tested this by disabling <code>gc</code> and calling <code>gc.collect</code> then no object exists as unreacable, am I right to assume this method assures there is no leakage?</p>

<hr/>

<h2>EDIT</h2>

<ol>
<li>I added the <a href="https://bitbucket.org/ozanhaci/py2ml/src/3b2ab576260448781b551fa04cd4fdb5449634a1/py2ml/html.py?at=master&amp;fileviewer=file-view-default" rel="nofollow">link</a> for full source code.</li>
<li>Code is compliant with <strong>Python 2.7</strong></li>
</ol>
    </div>
    </div></body></html>