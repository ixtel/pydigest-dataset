<html><body><div><div id="yasi-yet-another-s-expression-indenter">
<h2>yasi - yet another s-expression indenter</h2>

<div id="introduction">
<h3>Introduction</h3>
<p>yasi is a dialect-aware s-expression indenter that tries to improve on
<a href="https://github.com/ds26gte/scmindent" rel="nofollow">Dorai’s indenter</a> and <em>Vim’s</em>
built in indenter. It can handle <em>Common Lisp</em>, <em>Clojure</em>, <em>Scheme</em> and
<em>newLISP</em> code and their unique syntaxes.</p>
<p>It’s mainly a batch mode indenter inspired by Dorai’s
<a href="https://github.com/ds26gte/scmindent/blob/master/lispindent.lisp" rel="nofollow">lispindent.lisp</a>
that was written first in <em>Python</em> and later translated to <em>newLISP</em>.</p>
<p>Its style of indentation is very close to that of <em>lispindent.lisp</em> and
tries to follow <a href="https://github.com/ds26gte/scmindent" rel="nofollow">these style
guidelines</a> where reasonable.</p>
<p>It should find most use with programmers who use any other editor other
than Emacs which provides excellent indentation for lisp-like forms and
s-expressions out of the box.</p>
<p>I made this because there weren’t any good enough tools out there that
could indent the code I would copy/paste and run from tutorials when I
was starting out with Lisp.</p>
</div>
<div id="installation">
<h3>Installation</h3>
<p>From pypi:</p>
<pre>pip install --upgrade yasi
</pre>
</div>
<div id="features">
<h3>Features</h3>
<p><em>yasi’s</em> indentation relies heavily on regular expressions that give it
an edge over its counterpart <em>lispindent.lisp</em>. Its features include:</p>
<ul>
<li>Support for the different mainstream Lisps out there giving you the
correct indentation of a form according to the dialect’s
syntax/semantic. e.g. The <tt>do</tt> keyword which is a looping construct
in <em>Common Lisp</em> and sequential execution in <em>Clojure</em>. The keyword
should look like this in the two dialects:</li>
</ul>
<pre><span class="c1">;; In Common Lisp</span>
<span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">j</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">j</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="no">nil</span><span class="p">)</span>                       <span class="c1">;Do forever.</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">"~%Input ~D:"</span> <span class="nv">j</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">item</span> <span class="p">(</span><span class="nb">read</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">item</span><span class="p">)</span> <span class="p">(</span><span class="nb">return</span><span class="p">)</span>   <span class="c1">;Process items until NIL seen.</span>
      <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">"~&amp;Output ~D: ~S"</span> <span class="nv">j</span> <span class="nv">item</span><span class="p">))))</span>
</pre>
<pre><span class="c1">;; In Clojure</span>
<span class="p">(</span><span class="nf">do</span>
 <span class="p">(</span><span class="nb">println </span><span class="s">"LOG: Computing..."</span><span class="p">)</span>
 <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span>
</pre>
<ul>
<li>Ability to trim extraneous whitespace and compact code</li>
<li>Issues warnings for possible errors in code like unmatched brackets
and unclosed strings</li>
<li>Correct indentation of user defined macros</li>
<li>Supports additional keywords through a config file in the current or
home directory</li>
<li>Correct indentation of <tt>flets</tt> and <tt>labels</tt>, something that
doesn’t come out of the box even in Emacs</li>
<li>Indentation from standard input</li>
<li>The python version can output a unified diff between the initial and
indented code</li>
</ul>
</div>
<div id="command-line-arguments">
<h3>Command Line Arguments</h3>
<pre>usage: yasi [-h] [-nc] [-nb] [-nm] [--diff] [-nw] [-nr] [--no-output] [-c]
            [-ne] [-o OUTPUT_FILE] [--tab TAB_SIZE] [--dialect DIALECT] [-v]
            [-suffix BACKUP_SUFFIX] [-bd BACKUP_DIR] [-is INDENT_SIZE]
            [-di DEFAULT_INDENT] [-ic] [-uni]
            [files [files ...]]

Dialect-aware s-expression indenter

positional arguments:
  files                 List of files to be indented. Will indent from
                        standard input if no files are specified

optional arguments:
  -h, --help            show this help message and exit
  -nc, --no-compact, --nc
                        Do not compact the code, just indent
  -nb, --no-backup, --nb
                        Do not create a backup file even if --backup-dir is
                        specified
  -nm, --no-modify, --nm
                        Do not modify the file
  --diff, -diff         Prints unified diff of the initial and final result
  -nw, --no-warning, --nw
                        Do not display warnings
  -nr, --no-rc, --nr    Ignore any rc files in the current or home folder
  --no-output, -no-output
                        Suppress output of the indented code
  -c, --color, -color   Display diff text in color
  -ne, --no-exit, --ne  Instructs the program not to exit when a warning is
                        raised.
  -o OUTPUT_FILE        Path/name of output file
  --tab TAB_SIZE, -tab TAB_SIZE
                        Indent with tabs using the specified tabwidth. A tab
                        is assumed equal to 4 spaces by default when expanding
                        the tabs in the input file
  --dialect DIALECT, -dialect DIALECT
                        Use Scheme keywords
  -v, --version         Prints script version
  -suffix BACKUP_SUFFIX, --suffix BACKUP_SUFFIX
                        Backup file suffix
  -bd BACKUP_DIR, --backup-dir BACKUP_DIR, --bd BACKUP_DIR, -backup-dir BACKUP_DIR
                        The directory where the backup file is to be written
  -is INDENT_SIZE, --indent-size INDENT_SIZE, --is INDENT_SIZE
                        The number of spaces per indent
  -di DEFAULT_INDENT, --default-indent DEFAULT_INDENT, --di DEFAULT_INDENT
                        The indent level to be used in case a function's
                        argument is in the next line. Vim uses 2, the most
                        common being 1.
  -ic, --indent-comments, --ic
                        If true, comment lines will be indented possibly
                        messing with any deliberate comment layout
  -uni, --uniform, -uniform, --uni
                        Dictates whether the if-clause and else-clause of an
                        if-likeblock should have the same indent level.
</pre>
</div>
<div id="hanging-indentation">
<h3>Hanging Indentation</h3>
<p>This is where the indented code block is not flush with the left margin.
Lispindent does this by default although differently to the way it’s
implemented in yasi. The effect is obtained by passing <strong>–no-compact</strong>
to the script. Here’s how hanging indentation in lispindent and yasi
differs:</p>
<p>Initial code:</p>
<pre><span class="c1">;; Comment</span>
                    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nv">empty?</span> <span class="nv">macro-name</span><span class="p">))</span>
                    <span class="p">(</span><span class="nb">push</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">macro-name</span> <span class="nv">KEYWORD1</span><span class="p">)</span> <span class="nv">keyword-lst</span><span class="p">)</span>
                    <span class="no">nil</span><span class="p">)</span>

        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nv">empty?</span> <span class="nv">macro-name</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">push</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">macro-name</span> <span class="nv">KEYWORD1</span><span class="p">)</span> <span class="nv">keyword-lst</span><span class="p">)</span>
        <span class="no">nil</span><span class="p">)</span>

                <span class="p">(</span><span class="nv">exit</span><span class="p">)</span>
</pre>
<p>Calling yasi on the file with <strong>–no-compact</strong>:</p>
<pre><span class="c1">;; Comment</span>
                    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nv">empty?</span> <span class="nv">macro-name</span><span class="p">))</span>
                        <span class="p">(</span><span class="nb">push</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">macro-name</span> <span class="nv">KEYWORD1</span><span class="p">)</span> <span class="nv">keyword-lst</span><span class="p">)</span>
                      <span class="no">nil</span><span class="p">)</span>

        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nv">empty?</span> <span class="nv">macro-name</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">push</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">macro-name</span> <span class="nv">KEYWORD1</span><span class="p">)</span> <span class="nv">keyword-lst</span><span class="p">)</span>
          <span class="no">nil</span><span class="p">)</span>

                <span class="p">(</span><span class="nv">exit</span><span class="p">)</span>
</pre>
<p>How lispindent does it(the number of spaces at the start of first block
defines where the rest of the blocks in the file will start):</p>
<pre><span class="c1">;; Comment</span>
                    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nv">empty?</span> <span class="nv">macro-name</span><span class="p">))</span>
                        <span class="p">(</span><span class="nb">push</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">macro-name</span> <span class="nv">KEYWORD1</span><span class="p">)</span> <span class="nv">keyword-lst</span><span class="p">)</span>
                      <span class="no">nil</span><span class="p">)</span>

                    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nv">empty?</span> <span class="nv">macro-name</span><span class="p">))</span>
                        <span class="p">(</span><span class="nb">push</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">macro-name</span> <span class="nv">KEYWORD1</span><span class="p">)</span> <span class="nv">keyword-lst</span><span class="p">)</span>
                      <span class="no">nil</span><span class="p">)</span>

                    <span class="p">(</span><span class="nv">exit</span><span class="p">)</span>
</pre>
</div>
<div id="customization">
<h3>Customization</h3>
<p>Customization is done similarly to the way it’s done in lispindent -
keywords are associated with numbers that determine the next line’s
indentation level.</p>
<p>The additional keywords are defined in a <strong>.yasirc.json</strong> file placed in
the current working directory of in the home folder. Should there be
configuration files in both directories the one in the current working
directory will be preferred.</p>
<p>A typical config file looks like this:</p>
<pre><span class="p">{</span>
  <span class="s2">"scheme"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"do"</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s2">"if"</span><span class="o">:</span> <span class="mi">2</span>
  <span class="p">},</span>
  <span class="s2">"lisp"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"do"</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s2">"if"</span><span class="o">:</span> <span class="mi">2</span>
  <span class="p">},</span>
  <span class="s2">"clojure"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"do"</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s2">"if"</span><span class="o">:</span> <span class="mi">2</span>
  <span class="p">},</span>
  <span class="s2">"newlisp"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"do"</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s2">"if"</span><span class="o">:</span> <span class="mi">2</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
<p>The numbers are described below(assuming standard indentation size of 2
spaces):</p>
<ul>
<li><strong>0</strong> - Associating a keyword with zero turns it into a normal
function i.e removes keywordness</li>
</ul>
<pre><span class="p">(</span><span class="nv">do-the-boogie</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">12</span> <span class="mi">44</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">print</span> <span class="s">"if clause"</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">print</span> <span class="s">"else clause"</span><span class="p">))</span>
</pre>
<ul>
<li><strong>1</strong> - Causes the subforms of the function to be indented uniformly
by a unit indentation size(which can be changed)</li>
</ul>
<pre><span class="p">(</span><span class="nv">do-the-boogie</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">12</span> <span class="mi">44</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">print</span> <span class="s">"if clause"</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">print</span> <span class="s">"else clause"</span><span class="p">))</span>
</pre>
<ul>
<li><strong>2</strong> - Distinguishes the first subform by giving it a greater
indentation than the rest of the subforms the same way the standard
if expression is indented. The first subform has twice the
indentation size as the rest.</li>
</ul>
<pre><span class="p">(</span><span class="nv">do-the-boogie</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">12</span> <span class="mi">44</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">print</span> <span class="s">"if clause"</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">print</span> <span class="s">"else clause"</span><span class="p">))</span>
</pre>
<ul>
<li><strong>3</strong> - Subforms will be indented uniformly by twice the indentation
size</li>
</ul>
<pre><span class="p">(</span><span class="nv">do-the-boogie</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">12</span> <span class="mi">44</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">print</span> <span class="s">"if clause"</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">print</span> <span class="s">"else clause"</span><span class="p">))</span>
</pre>
<ul>
<li><strong>4</strong> - Indents by a unit like a 1-keyword but also its local
functions</li>
</ul>
<pre><span class="p">(</span><span class="nv">letfn</span> <span class="nv">[</span><span class="p">(</span><span class="nv">six-times</span> <span class="nv">[y]</span>
          <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nv">twice</span> <span class="nv">y</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">twice</span> <span class="nv">[x]</span>
          <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))</span><span class="nv">]</span>
  <span class="p">(</span><span class="nv">println</span> <span class="s">"Twice 15 ="</span> <span class="p">(</span><span class="nv">twice</span> <span class="mi">15</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">println</span> <span class="s">"Six times 15 ="</span> <span class="p">(</span><span class="nv">six-times</span> <span class="mi">15</span><span class="p">)))</span>
</pre>
<p>The standard indentation(assuming <tt>letfn</tt> is just another function)
would be:</p>
<pre><span class="p">(</span><span class="nv">letfn</span> <span class="nv">[</span><span class="p">(</span><span class="nv">six-times</span> <span class="nv">[y]</span>
                   <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nv">twice</span> <span class="nv">y</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">twice</span> <span class="nv">[x]</span>
               <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))</span><span class="nv">]</span>
  <span class="p">(</span><span class="nv">println</span> <span class="s">"Twice 15 ="</span> <span class="p">(</span><span class="nv">twice</span> <span class="mi">15</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">println</span> <span class="s">"Six times 15 ="</span> <span class="p">(</span><span class="nv">six-times</span> <span class="mi">15</span><span class="p">)))</span>
</pre>
<div id="about-the-default-indent">
<h4>About the default indent</h4>
<p>The <em>–default-indent</em> comes in in expressions whose subforms usually
start in the subsequent lines. Like in a <tt>cond</tt> expression:</p>
<pre><span class="p">(</span><span class="nb">cond</span>
 <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">this</span> <span class="nv">that</span><span class="p">)</span> <span class="ss">'Yes</span><span class="p">)</span>
 <span class="p">((</span><span class="nb">=</span> <span class="nv">those</span> <span class="nv">these</span><span class="p">)</span> <span class="ss">'No</span><span class="p">))</span>
</pre>
<p>This above result would be the standard/expected indentation. However
one might prefer to have the subforms to start two spaces past the head
of the expression like this.</p>
<pre><span class="p">(</span><span class="nb">cond</span>
  <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">newLISP</span> <span class="nv">CL</span><span class="p">)</span> <span class="ss">'Yes</span><span class="p">)</span>
  <span class="p">((</span><span class="nb">=</span> <span class="nv">Clojure</span> <span class="nv">Lisp</span><span class="p">)</span> <span class="ss">'No</span><span class="p">))</span>
</pre>
<p>This is <em>Vim’s</em> default style of indentation. That option enables you to
specify the amount you want, for example to achieve the style above, you
pass the parameter like so:</p>
<pre>yasi.py test.lisp --lisp --default-indent 2
</pre>
</div>
</div>
<hr class="docutils"/>
<div id="what-yasi-does-not-handle">
<h3>What yasi does not handle</h3>
<p>There are some syntaxes used in some dialects of Scheme that didn’t seem
worth the effort implementing. An example is <em>MzScheme</em> and <em>Gauche’s</em>
use of <tt>#//</tt> or <tt>#[]</tt> for regular expressions.</p>
<div id="modifications-to-lispindent">
<h4>Modifications to lispindent</h4>
<p>I made a couple of modifications to <em>lispindent.lisp</em> and renamed it to
<em>lispindent2.lisp</em>. The changes include:</p>
<ul>
<li>Added comments for some sections of the program that took me time to
understand</li>
<li>It can now indent files from the command line without the need to
redirect file contents to the program. The original one was purely
intended to be used as a filter script indenting only from standard
input.</li>
<li><em>lispindent2.lisp</em> indents <em>Clojure’s</em> <em>vectors</em> and <em>sets</em> better,
i.e with an indentation level of 1, without affecting <em>Lisp’s</em> or
<em>Scheme’s indentation</em>. It uses the file’s extension to determine if
it’s looking at <em>Clojure</em> code. e.g.</li>
</ul>
<pre><span class="c1">;; lispindent2.lisp's indentation</span>
<span class="p">(</span><span class="nb">print </span><span class="p">{</span><span class="nv">define</span> <span class="s">"The keyword does not affect indentation"</span>
    <span class="p">})</span>
</pre>
<pre><span class="c1">;; lispindent.lisp's indentation</span>
<span class="p">(</span><span class="nb">print </span><span class="p">{</span><span class="nv">define</span> <span class="s">"The keyword does not affect indentation"</span>
   <span class="p">})</span>
</pre>
<ul>
<li><em>lispindent2.lisp</em> ignores any code in a multiline comment and won’t
be affected by any unclosed brackets inside the comment like the
original version. Unfortunately, its method of detecting multiline
comments is rather naive and introduces a bug in the code. Refer to
its issues below.</li>
<li><em>lispindent2.lisp</em> writes files using <em>LF</em> line endings be default.
It’s less irritating than <em>CRLF</em> endings which usually light up in an
annoying way in <em>Vim</em>.</li>
</ul>
</div>
<div id="editor-integration">
<h4>Editor Integration</h4>
<p>yasi’s ability to format code from standard input makes it a suitable
candidate for the <tt>equalprg</tt> setting in Vim. Add this in your
<strong>.vimrc</strong> and you’re good to go.</p>
<pre><span class="k">au</span> <span class="k">filetype</span> clojure<span class="p">,</span><span class="nb">lisp</span><span class="p">,</span>scheme<span class="p">,</span>newlisp <span class="k">setlocal</span> <span class="nb">equalprg</span><span class="p">=</span>yasi.<span class="k">py</span>\ <span class="p">--</span>indent<span class="p">-</span><span class="nb">comments</span>
</pre>
<p>You can then indent a function/block by providing the motion after the
<tt>=</tt> sign e.g <tt>=%</tt></p>
<p>You can also checkout these other projects for proper integration
without invoking it externally as a filter script for example:</p>

</div>
<div id="lispindent2-issues">
<h4>lispindent2 Issues</h4>
<p>I inadvertently added a bug in an attempt to prevent it from evaluating
brackets inside multiline comments in Common Lisp and symbols with
whitespace in Scheme.</p>
<p>It uses the pipe character(|) to track whether the comment it’s still
in a multiline comment meaning an odd number of pipes in a multiline
comment will yield a wrong indentation e.g.:</p>
<pre><span class="cm">#|*******************************************************************|
 |   This is a multiline comment that will trip the indenter         |
 |   because the odd number of pipes will cause `multiline-commentp` |
 |   to be true after this comment. It means the rest of the code    |
 |   won't be indented because it thinks it's still in a comment.    |
          Total pipes=11(odd)
 |#</span>
 <span class="p">(</span><span class="nb">print</span> <span class="p">(</span><span class="nb">cons</span>
    <span class="ss">'Hello</span> <span class="c1">;; This line and the one below won't change</span>
    <span class="ss">'World</span>
        <span class="p">))</span>
</pre>
<p>I don’t find this to be a major issue because multiline comments are
rarely used, the common use case being to comment out regions of code
when debugging.</p>
<p><em>lispindent2.lisp</em> uses the <em>Lisp</em> reader function <tt><span class="pre">read-from-string</span></tt>
to get lisp forms and atoms from the read string.</p>
<p>The downside of this is that <tt><span class="pre">read-from-string</span></tt> will fail when the
code in the string is ‘malformed’. For example, if it finds that the dot
operator used for consing in <em>Common Lisp</em> comes after the opening
bracket, it will raise a fatal error. This means that any <em>Clojure</em> code
that tries to use the dot operator to access a class method will not be
indented because of the error. An example is this code:</p>
<pre><span class="p">(</span><span class="kd">defmacro </span><span class="nv">chain</span>
  <span class="p">([</span><span class="nv">x</span> <span class="nv">form</span><span class="p">]</span> <span class="o">`</span><span class="p">(</span><span class="k">. </span><span class="o">~</span><span class="nv">x</span> <span class="o">~</span><span class="nv">form</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">x</span> <span class="nv">form</span> <span class="o">&amp;</span> <span class="nv">more</span><span class="p">]</span> <span class="o">`</span><span class="p">(</span><span class="nf">chain</span> <span class="p">(</span><span class="k">. </span><span class="o">~</span><span class="nv">x</span> <span class="o">~</span><span class="nv">form</span><span class="p">)</span> <span class="o">~@</span><span class="nv">more</span><span class="p">)))</span>
</pre>
<p><em>lispindent2.lisp</em> uses the <tt><span class="pre">ignore-errors</span></tt> macro as a workaround.
Doing that means that it can’t run in <em>GNU Common Lisp</em> because it
doesn’t have the macro.</p>
</div>
<div id="lispindent2-command-line-options">
<h4>lispindent2 Command Line Options</h4>
<pre>+---------------------------------------------------------------------------+
|   Usage:  lispindent2.lisp [[&lt;file&gt;] [--no-modify] [--no-output]]         |
|           --no-output ;; Don't output the indented code, false by default |
|           --no-modify ;; Don't modify the file, false by default          |
+---------------------------------------------------------------------------+
</pre>
</div>
</div>
</div>


</div></body></html>