<html><body><div><div class="document">
<p>The <a class="reference external" href="https://fuhm.net/super-harmful/">dangers of Python's super</a> have been documented... but, in my humble
opinion, not well enough.</p>
<p>A major problem with Python's super() is that it is <em>not</em> straight forward to
figure out needs to call it, even if it doesn't seem like the method's parent
class should need to.</p>
<p>Consider this example, where mixins are used to update a dictionary with some
context (similar to, but less correct than, for example, <a class="reference external" href="https://docs.djangoproject.com/en/dev/ref/class-based-views/base/#django.views.generic.base.TemplateView">Django's
TemplateView</a>):</p>
<pre class="code python literal-block">
<span class="k">class</span> <span class="nc">FirstMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_context</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">"first"</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>

<span class="k">class</span> <span class="nc">BaseClass</span><span class="p">(</span><span class="n">FirstMixin</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_context</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">BaseClass</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_context</span><span class="p">()</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">"base"</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">ctx</span>

<span class="k">class</span> <span class="nc">SecondMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_context</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">SecondMixin</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_context</span><span class="p">()</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">"second"</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">ctx</span>

<span class="k">class</span> <span class="nc">ConcreteClass</span><span class="p">(</span><span class="n">BaseClass</span><span class="p">,</span> <span class="n">SecondMixin</span><span class="p">):</span>
    <span class="k">pass</span>
</pre>
<p>This looks correct... but it isn't! Because <tt class="docutils literal">FirstMixin</tt> doesn't call
<tt class="docutils literal">super()</tt>, <tt class="docutils literal">SecondMixin.get_context</tt> is <em>never</em> called:</p>
<pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">ConcreteClass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">get_context</span><span class="p">()</span>
<span class="go">{"base": True, "first": True} # Note that ``"second": True`` is missing!</span>
</pre>
<p>Alternatively, image that <tt class="docutils literal">FirstMixin.get_context()</tt> <em>does</em> call <tt class="docutils literal">super()</tt>:</p>
<pre class="code python literal-block">
<span class="k">class</span> <span class="nc">FirstMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_context</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">FirstMixin</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_context</span><span class="p">()</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">"first"</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">ctx</span>
</pre>
<p>This will <strong>also</strong> be incorrect, because now the call to <tt class="docutils literal">super()</tt> in
<tt class="docutils literal">SecondMixin</tt> will trigger an error, because the final base class -
<tt class="docutils literal">object</tt> - does <em>not</em> have a <tt class="docutils literal">get_context()</tt> method:</p>
<pre class="code pycon literal-block">
<span class="n"/><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">ConcreteClass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">get_context</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">AttributeError: 'super' object has no attribute 'get_context'</span>
</pre>
<p>What is a poor Pythonista to do?</p>
<p>There are three <em>reasonably</em> simple rules to follow when dealing with this kind
of multiple inheritance:</p>
<ol class="arabic simple">
<li>Mixins should <em>always</em> call <tt class="docutils literal">super()</tt>.</li>
<li>The base class should <em>not</em> call <tt class="docutils literal">super()</tt>.</li>
<li>The base class (or one of its super classes) needs to be at the <em>right</em> of
sub-classe's list of base classes.</li>
</ol>
<p>Note that this will often mean introducing an otherwise unnecessary <tt class="docutils literal">*Base</tt>
class.</p>
<p>To correct the example above:</p>
<pre class="code python literal-block">
<span class="c"># Following rule (1), every mixin calls `super()`</span>
<span class="k">class</span> <span class="nc">FirstMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_context</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">FirstMixin</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_context</span><span class="p">()</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">"first"</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">ctx</span>

<span class="c"># Following rule (2), the base class does *not* call super.</span>
<span class="k">class</span> <span class="nc">BaseClassBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_context</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">"base"</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>

<span class="c"># Notice that, to follow rule (3), an otherwise uneccessary base class has</span>
<span class="c"># been introduced to make sure that the "real" base class (the one without</span>
<span class="c"># the call to super) can be at the very right of the list of base classess.</span>
<span class="k">class</span> <span class="nc">BaseClass</span><span class="p">(</span><span class="n">FirstMixin</span><span class="p">,</span> <span class="n">BaseClassBase</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="c"># Following rule (3), the base class comes at the right end of the list</span>
<span class="c"># of base classess.</span>
<span class="k">class</span> <span class="nc">ConcreteClass</span><span class="p">(</span><span class="n">SecondMixin</span><span class="p">,</span> <span class="n">BaseClass</span><span class="p">):</span>
    <span class="k">pass</span>
</pre>
<p>This will guarantee that the mixins are <em>always</em> called before the base class,
which doesn't call <tt class="docutils literal">super()</tt> in <tt class="docutils literal">get_context()</tt>.</p>
<p>Note that this will still cause problems in the even that multiple base
classess are used (ie, "true" multiple inheritance)... and there isn't much
which can be done about that, at least in the general case.</p>
<p>It is also worth noting that that in many cases the <em>best</em> solution is to avoid
inheritance all together, opting instead for a pattern better suited to the
requirements of the specific problem at hand.</p>
<p>For example, in the sitaution from the example above - where many different
"things" (in the above example: mixins and the base class) need to contribute
to the "context" dictionary - one option which <em>might</em> be more appropriate is
an explicit set of "context providers":</p>
<pre class="code python literal-block">
<span class="k">class</span> <span class="nc">FirstContextProvider</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">"first"</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>

<span class="k">class</span> <span class="nc">BaseClass</span><span class="p">(</span><span class="n">FirstMixin</span><span class="p">):</span>
    <span class="n">context_providers</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">FirstContextProvider</span><span class="p">(),</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="p">{</span><span class="s">"base"</span><span class="p">:</span> <span class="bp">True</span><span class="p">},</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_context</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">provider</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">context_providers</span><span class="p">:</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">provider</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">ctx</span>

<span class="k">class</span> <span class="nc">SecondContextProvider</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">"second"</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>

<span class="k">class</span> <span class="nc">ConcreteClass</span><span class="p">(</span><span class="n">BaseClass</span><span class="p">,</span> <span class="n">SecondMixin</span><span class="p">):</span>
    <span class="n">context_providers</span> <span class="o">=</span> <span class="n">BaseClass</span><span class="o">.</span><span class="n">context_providers</span> <span class="o">+</span> <span class="p">[</span>
        <span class="n">SecondContextProvider</span><span class="p">(),</span>
    <span class="p">]</span>
</pre>
<p>(recall that <a class="reference external" href="https://docs.python.org/2/reference/datamodel.html#object.__call__">__call__</a> method is used to make instances of a call callable)</p>
<p><strong>Edit</strong>: I was corrected by <a class="reference external" href="https://twitter.com/lambacck/">@lambacck</a>, who pointed out the "base class on
the right" rule: <a class="reference external" href="https://twitter.com/lambacck/status/451528854507905024">https://twitter.com/lambacck/status/451528854507905024</a></p>
</div>

    
  </div></body></html>