<html><body><div><p id="disqus_post_title">Fast Python. Выпуск 1. Обновление словарей</p>
<div id="disqus_post_message"><p>Привет! Запускаю раздел <a href="http://djangonaut.blogspot.com/search/label/fast%20python"><strong>Fast Python</strong></a>, в котором буду делиться простыми рецептами про то, как ускорить и оптимизировать выполнение кода на Python.</p>

<p>Первый выпуск будет посвящен обновлению данных в словарях. <a href="https://docs.python.org/3/library/stdtypes.html#dict">Словари</a> - одни из найболее часто используемых типов данных в Python. И сколько времени я с ними не работаю, у меня никогда не возникал вопрос как правильней обновить данные в словаре. Я для себя всегда отвечал на него, что правильней обновлять используя метод <a href="https://docs.python.org/3/library/stdtypes.html#dict.update"><code>update</code></a>, но сегодня с утра наткнулся на <a href="https://twitter.com/bkmontgomery/status/575497098029760512">твит от Брэда Монтгомери</a> и мой мир изменился.</p>

<p>Оказывается, что <strong>более правильным с точки зрения скорости</strong> является обновление словаря через поочередное присваивание значений, чем единичный апдейт. Не верите? Результаты замеров весьма красноречивы:</p>

<p><strong>Python 3.4.3</strong></p>
<pre><code>In [2]: timeit("d = {}; d.update({'first': 'first', 'second': ['one', 'two', 'three'], 'third': True})", number=1000000)
Out[2]: 0.9664371280086925

In [3]: timeit("d = {}; d['first'] = 'first'; d['second'] = ['one', 'two', 'three']; d['third'] = True", number=1000000)                                      
Out[3]: 0.4200690069992561
</code></pre>

<p><strong>Python 2.7.9</strong></p>
<pre><code>In [2]: timeit("d = {}; d.update({'first': 'first', 'second': ['one', 'two', 'three'], 'third': True})", number=1000000)
Out[2]: 1.0035829544067383

In [3]: timeit("d = {}; d['first'] = 'first'; d['second'] = ['one', 'two', 'three']; d['third'] = True", number=1000000)
Out[3]: 0.5186400413513184
</code></pre>

<p><strong>Bonus: PyPy 2.4.0</strong></p>
<pre><code>&gt;&gt;&gt;&gt; timeit("d = {}; d.update({'first': 'first', 'second': ['one', 'two', 'three'], 'third': True})", number=1000000)                                               
0.10811400413513184
&gt;&gt;&gt;&gt; timeit("d = {}; d['first'] = 'first'; d['second'] = ['one', 'two', 'three']; d['third'] = True", number=1000000)                                         
0.005925893783569336
</code></pre>

<hr/>

<p><strong>Итого:</strong> Если вы где-то в коде увидите обновление одиночного или множественных элементов словаря через <code>.update</code> - смело переписывайте этот фрагмент на использование <code>__setitem__</code>.</p>

<p><strong>Fast Python:</strong></p>
<pre name="code" class="py"><code>data['key'] = 'value'
data['another-key'] = 'another-value'</code></pre>

<p><strong>Slow Python:</strong></p>
<pre name="code" class="py"><code>data.update({
    'key': 'value',
    'another-key': 'another-value',
})</code></pre>

<hr/>

<p><strong>UPD:</strong> Михаил Кривушин (<strong>deepwalker</strong>) в комментариях объяснил почему так происходит:</p>
<blockquote>По дороге создается еще один словарь, и потом уже из него копируются элементы<br/>
<a href="https://gist.github.com/Deepwalker/c52a74c26df0707dd303">https://gist.github.com/Deepwalker/c52a74c26df0707dd303</a></blockquote>

<hr/>

<p><strong>UPD2:</strong> Если ключи словаря не используют специальных символов и являются валидными Python ключами, то лучше использовать синтаксис <code>.update(key='value')</code>, вместо <code>.update({'key': 'value'})</code>:</p>

<p><strong>Python 3.4.3</strong></p>
<pre><code>In [2]: timeit("d = {}; d.update(first='first', second=['one', 'two', 'three'], third=True)", number=1000000)
Out[2]: 0.88018084000214
</code></pre>

<p><strong>Python 2.7.9</strong></p>
<pre><code>In [2]: timeit("d = {}; d.update(first='first', second=['one', 'two', 'three'], third=True)", number=1000000)
Out[2]: 0.7820448875427246
</code></pre>

<p><strong>PyPy 2.4.0</strong></p>
<pre><code>&gt;&gt;&gt;&gt; timeit("d = {}; d.update(first='first', second=['one', 'two', 'three'], third=True)", number=1000000)
0.010169029235839844
</code></pre></div>


</div></body></html>