<html><body><div><div class="entry-content">
                
                    <p><br/></p>
<blockquote>
<p><em><strong><span class="dquo">“</span>If you don’t know how compilers work, then you don’t know how computers work. If you’re not 100% sure whether you know how compilers work, then you don’t know how they work.”</strong> — Steve Yegge</em></p>
</blockquote>
<p>There you have it. Think about it. It doesn’t really matter whether you’re a newbie or a seasoned software developer: if you don’t know how compilers and interpreters work, then you don’t know how computers work. It’s that simple.</p>
<p>So, do you know how compilers and interpreters work? And I mean, are you 100% sure that you know how they work? If you don’t.
<img alt="" src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_i_dont_know.png"/></p>
<p>Or if you don’t and you’re really agitated about it.
<img alt="" src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_omg.png"/></p>
<p>Do not worry. If you stick around and work through the series and build an interpreter and a compiler with me you will know how they work in the end. And you will become a confident happy camper too. At least I hope so.
<img alt="" src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_i_know.png"/></p>
<p>Why would you study interpreters and compilers? I will give you three reasons.</p>
<ol>
<li>To write an interpreter or a compiler you have to have a lot of technical skills that you need to use together. Writing an interpreter or a compiler will help you improve those skills and become a better software developer. As well, the skills you will learn are useful in writing any software, not just interpreters or compilers.</li>
<li>You really want to know how computers work. Often interpreters and compilers look like magic. And you shouldn’t be comfortable with that magic. You want to demystify the process of building an interpreter and a compiler, understand how they work, and get in control of things.</li>
<li>You want to create your own programming language or domain specific language. If you create one, you will also need to create either an interpreter or a compiler for it. Recently, there has been a resurgence of interest in new programming languages. And you can see a new programming language pop up almost every day: Elixir, Go, Rust just to name a few.</li>
</ol>
<p><br/>
Okay, but what are interpreters and compilers?</p>
<p>The goal of an <strong>interpreter</strong> or a <strong>compiler</strong> is to translate a source program in some high-level language into some other form. Pretty vague, isn’t it? Just bear with me, later in the series you will learn exactly what the source program is translated into.</p>
<p>At this point you may also wonder what the difference is between an interpreter and a compiler.
For the purpose of this series, let’s agree that if a translator translates a source program into machine language, it is a <strong>compiler</strong>. If a translator processes and executes the source program without translating it into machine language first, it is an <strong>interpreter</strong>. Visually it looks something like this:</p>
<p><img alt="" src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_compiler_interpreter.png"/></p>
<p>I hope that by now you’re convinced that you really want to study and build an interpreter and a compiler. What can you expect from this series on interpreters?</p>
<p>Here is the deal. You and I are going to create a simple interpreter for a large subset of <a href="https://en.wikipedia.org/wiki/Pascal_%28programming_language%29">Pascal</a> language. At the end of this series you will have a working Pascal interpreter and a source-level debugger like Python’s <a href="https://docs.python.org/2/library/pdb.html">pdb</a>.</p>
<p>You might ask, why Pascal? For one thing, it’s not a made-up language that I came up with just for this series: it’s a real programming language that has many important language constructs. And some old, but useful, <span class="caps">CS</span> books use Pascal programming language in their examples (I understand that that’s not a particularly compelling reason to choose a language to build an interpreter for, but I thought it would be nice for a change to learn a non-mainstream language :)</p>
<p>Here is an example of a factorial function in Pascal that you will be able to interpret with your own interpreter and debug with the interactive source-level debugger that you will create along the way:</p>
<div class="highlight"><pre><span class="k">program</span> <span class="n">factorial</span><span class="o">;</span>

<span class="k">function</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">integer</span><span class="p">)</span><span class="o">:</span> <span class="kt">longint</span><span class="o">;</span>
<span class="k">begin</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
        <span class="n">factorial</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="k">else</span>
        <span class="n">factorial</span> <span class="o">:=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">;</span>
<span class="k">end</span><span class="o">;</span>

<span class="k">var</span>
    <span class="n">n</span><span class="o">:</span> <span class="kt">integer</span><span class="o">;</span>

<span class="k">begin</span>
    <span class="k">for</span> <span class="n">n</span> <span class="o">:=</span> <span class="mi">0</span> <span class="k">to</span> <span class="mi">16</span> <span class="k">do</span>
        <span class="nb">writeln</span><span class="p">(</span><span class="n">n</span><span class="o">,</span> <span class="s">'! = '</span><span class="o">,</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="o">;</span>
<span class="k">end</span><span class="o">.</span>
</pre></div>


<p>The implementation language of the Pascal interpreter will be Python, but you can use any language you want because the ideas presented don’t depend on any particular implementation language. Okay, let’s get down to business. Ready, set, go!</p>
<p>You will start your first foray into interpreters and compilers by writing a simple interpreter of arithmetic expressions, also known as a calculator. Today the goal is pretty minimalistic: to make your calculator handle the addition of two single digit integers like <strong>3+5</strong>.
Here is the source code for your calculator, sorry, interpreter:</p>
<div class="highlight"><pre><span class="c"># Token types</span>
<span class="c">#</span>
<span class="c"># EOF (end-of-file) token is used to indicate that</span>
<span class="c"># there is no more input left for lexical analysis</span>
<span class="n">INTEGER</span><span class="p">,</span> <span class="n">PLUS</span><span class="p">,</span> <span class="n">EOF</span> <span class="o">=</span> <span class="s">'INTEGER'</span><span class="p">,</span> <span class="s">'PLUS'</span><span class="p">,</span> <span class="s">'EOF'</span>


<span class="k">class</span> <span class="nc">Token</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c"># token type: INTEGER, PLUS, or EOF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="c"># token value: 0, 1, 2. 3, 4, 5, 6, 7, 8, 9, '+', or None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""String representation of the class instance.</span>

<span class="sd">        Examples:</span>
<span class="sd">            Token(INTEGER, 3)</span>
<span class="sd">            Token(PLUS '+')</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="s">'Token({type}, {value})'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Interpreter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="c"># client string input, e.g. "3+5"</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
        <span class="c"># self.pos is an index into self.text</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># current token instance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_token</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">'Error parsing input'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_next_token</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Lexical analyzer (also known as scanner or tokenizer)</span>

<span class="sd">        This method is responsible for breaking a sentence</span>
<span class="sd">        apart into tokens. One token at a time.</span>
<span class="sd">        """</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span>

        <span class="c"># is self.pos index past the end of the self.text ?</span>
        <span class="c"># if so, then return EOF token because there is no more</span>
        <span class="c"># input left to convert into tokens</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Token</span><span class="p">(</span><span class="n">EOF</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="c"># get a character at the position self.pos and decide</span>
        <span class="c"># what token to create based on the single character</span>
        <span class="n">current_char</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span>

        <span class="c"># if the character is a digit then convert it to</span>
        <span class="c"># integer, create an INTEGER token, increment self.pos</span>
        <span class="c"># index to point to the next character after the digit,</span>
        <span class="c"># and return the INTEGER token</span>
        <span class="k">if</span> <span class="n">current_char</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">token</span> <span class="o">=</span> <span class="n">Token</span><span class="p">(</span><span class="n">INTEGER</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">current_char</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">token</span>

        <span class="k">if</span> <span class="n">current_char</span> <span class="o">==</span> <span class="s">'+'</span><span class="p">:</span>
            <span class="n">token</span> <span class="o">=</span> <span class="n">Token</span><span class="p">(</span><span class="n">PLUS</span><span class="p">,</span> <span class="n">current_char</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">token</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">eat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token_type</span><span class="p">):</span>
        <span class="c"># compare the current token type with the passed token</span>
        <span class="c"># type and if they match then "eat" the current token</span>
        <span class="c"># and assign the next token to the self.current_token,</span>
        <span class="c"># otherwise raise an exception.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">token_type</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_next_token</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""expr -&gt; INTEGER PLUS INTEGER"""</span>
        <span class="c"># set current token to the first token taken from the input</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_next_token</span><span class="p">()</span>

        <span class="c"># we expect the current token to be a single-digit integer</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_token</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">INTEGER</span><span class="p">)</span>

        <span class="c"># we expect the current token to be a '+' token</span>
        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_token</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">PLUS</span><span class="p">)</span>

        <span class="c"># we expect the current token to be a single-digit integer</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_token</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">INTEGER</span><span class="p">)</span>
        <span class="c"># after the above call the self.current_token is set to</span>
        <span class="c"># EOF token</span>

        <span class="c"># at this point INTEGER PLUS INTEGER sequence of tokens</span>
        <span class="c"># has been successfully found and the method can just</span>
        <span class="c"># return the result of adding two integers, thus</span>
        <span class="c"># effectively interpreting client input</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># To run under Python3 replace 'raw_input' call</span>
            <span class="c"># with 'input'</span>
            <span class="n">text</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s">'calc&gt; '</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">EOFError</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">text</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">interpreter</span> <span class="o">=</span> <span class="n">Interpreter</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">expr</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>


<p><br/>
Save the above code into <em>calc1.py</em> file or download it directly from <a href="https://github.com/rspivak/lsbasi/blob/master/part1/calc1.py">GitHub</a>. Before you start digging deeper into the code, run the calculator on the command line and see it in action. Play with it! Here is a sample session on my laptop (if you want to run the calculator under Python3 you will need to replace <em>raw_input</em> with <em>input</em>):</p>
<div class="highlight"><pre><span class="nv">$ </span>python calc1.py
calc&gt; 3+4
7
calc&gt; 3+5
8
calc&gt; 3+9
12
calc&gt;
</pre></div>


<p>For your simple calculator to work properly without throwing an exception, your input needs to follow certain rules:</p>
<ul>
<li>Only single digit integers are allowed in the input</li>
<li>The only arithmetic operation supported at the moment is addition</li>
<li>No whitespace characters are allowed anywhere in the input</li>
</ul>
<p>Those restrictions are necessary to make the calculator simple. Don’t worry, you’ll make it pretty complex pretty soon.</p>
<p>Okay, now let’s dive in and see how your interpreter works and how it evaluates arithmetic expressions.</p>
<p>When you enter an expression <em>3+5</em> on the command line your interpreter gets a string <em>“3+5”</em>. In order for the interpreter to actually understand what to do with that string it first needs to break the input <em>“3+5”</em> into components called <strong>tokens</strong>. A <strong>token</strong> is an object that has a type and a value. For example, for the string <em>“3”</em> the type of the token will be <span class="caps">INTEGER</span> and the corresponding value will be integer <em>3</em>.</p>
<p>The process of breaking the input string into tokens is called <strong>lexical analysis</strong>. So, the first step your interpreter needs to do is read the input of characters and convert it into a stream of tokens. The part of the interpreter that does it is called a <strong>lexical analyzer</strong>, or <strong>lexer</strong> for short. You might also encounter other names for the same component, like <strong>scanner</strong> or <strong>tokenizer</strong>. They all mean the same: the part of your interpreter or compiler that turns the input of characters into a stream of tokens.</p>
<p>The method <em>get_next_token</em> of the <em>Interpreter</em> class is your lexical analyzer. Every time you call it, you get the next token created from the input of characters passed to the interpreter. Let’s take a closer look at the method itself and see how it actually does its job of converting characters into tokens.
The input is stored in the variable <em>text</em> that holds the input string and <em>pos</em> is an index into that string (think of the string as an array of characters). <em>pos</em> is initially set to 0 and points to the character <em>‘3’</em>. The method first checks whether the character is a digit and if so, it increments <em>pos</em> and returns a token instance with the type <span class="caps">INTEGER</span> and the value set to the integer value of the string <em>‘3’</em>, which is an integer <em>3</em>:</p>
<p><img alt="" src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_lexer1.png"/></p>
<p>The <em>pos</em> now points to the <em>‘+’</em> character in the <em>text</em>. The next time you call the method, it tests if a character at the position <em>pos</em> is a digit and then it tests if the character is a plus sign, which it is. As a result the method increments <em>pos</em> and returns a newly created token with the type <span class="caps">PLUS</span> and value <em>‘+’</em>:</p>
<p><img alt="" src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_lexer2.png"/></p>
<p>The <em>pos</em> now points to character <em>‘5’</em>. When you call the <em>get_next_token</em> method again the method checks if it’s a digit, which it is, so it increments <em>pos</em> and returns a new <span class="caps">INTEGER</span> token with the value of the token set to integer <em>5</em>:
<img alt="" src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_lexer3.png"/></p>
<p>Because the <em>pos</em> index is now past the end of the string <em>“3+5”</em> the <em>get_next_token</em> method returns the <span class="caps">EOF</span> token every time you call it:</p>
<p><img alt="" src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_lexer4.png"/></p>
<p>Try it out and see for yourself how the lexer component of your calculator works:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">calc1</span> <span class="kn">import</span> <span class="n">Interpreter</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">interpreter</span> <span class="o">=</span> <span class="n">Interpreter</span><span class="p">(</span><span class="s">'3+5'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">get_next_token</span><span class="p">()</span>
<span class="n">Token</span><span class="p">(</span><span class="n">INTEGER</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">get_next_token</span><span class="p">()</span>
<span class="n">Token</span><span class="p">(</span><span class="n">PLUS</span><span class="p">,</span> <span class="s">'+'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">get_next_token</span><span class="p">()</span>
<span class="n">Token</span><span class="p">(</span><span class="n">INTEGER</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">get_next_token</span><span class="p">()</span>
<span class="n">Token</span><span class="p">(</span><span class="n">EOF</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>


<p>So now that your interpreter has access to the stream of tokens made from the input characters, the interpreter needs to do something with it: it needs to find the structure in the flat stream of tokens it gets from the lexer <em>get_next_token</em>. Your interpreter expects to find the following structure in that stream: <span class="caps">INTEGER</span> -&gt; <span class="caps">PLUS</span> -&gt; <span class="caps">INTEGER</span>. That is, it tries to find a sequence of tokens: integer followed by a plus sign followed by an integer.</p>
<p>The method responsible for finding and interpreting that structure is <em>expr</em>. This method verifies that the sequence of tokens does indeed correspond to the expected sequence of tokens, i.e <span class="caps">INTEGER</span> -&gt; <span class="caps">PLUS</span> -&gt; <span class="caps">INTEGER</span>. After it’s successfully confirmed the structure, it generates the result by adding the value of the token on the left side of the <span class="caps">PLUS</span> and the right side of the <span class="caps">PLUS</span>, thus successfully interpreting the arithmetic expression you passed to the interpreter.</p>
<p>The <em>expr</em> method itself uses the helper method <em>eat</em> to verify that the token type passed to the <em>eat</em> method matches the current token type. After matching the passed token type the <em>eat</em> method gets the next token and assigns it to the <em>current_token</em> variable, thus effectively “eating” the currently matched token and advancing the imaginary pointer in the stream of tokens. If the structure in the stream of tokens doesn’t correspond to the expected <span class="caps">INTEGER</span> <span class="caps">PLUS</span> <span class="caps">INTEGER</span> sequence of tokens the <em>eat</em> method throws an exception.</p>
<p>Let’s recap what your interpreter does to evaluate an arithmetic expression:</p>
<ul>
<li>The interpreter accepts an input string, let’s say “3+5”</li>
<li>The interpreter calls the <em>expr</em> method to find a structure in the stream of tokens returned by the lexical analyzer <em>get_next_token</em>. The structure it tries to find is of the form <span class="caps">INTEGER</span> <span class="caps">PLUS</span> <span class="caps">INTEGER</span>. After it’s confirmed the structure, it interprets the input by adding the values of two <span class="caps">INTEGER</span> tokens because it’s clear to the interpreter at that point that what it needs to do is add two integers, 3 and 5.</li>
</ul>
<p>Congratulate yourself. You’ve just learned how to build your very first interpreter!</p>
<p>Now it’s time for exercises.</p>
<p><img alt="" src="https://ruslanspivak.com/lsbasi-part1/lsbasi_exercises2.png"/></p>
<p>You didn’t think you would just read this article and that would be enough, did you? Okay, get your hands dirty and do the following exercises:</p>
<ol>
<li>Modify the code to allow multiple-digit integers in the input, for example “12+3”</li>
<li>Add a method that skips whitespace characters so that your calculator can handle inputs with whitespace characters like ” 12 + 3”</li>
<li>Modify the code and instead of ‘+’ handle ‘-‘ to evaluate subtractions like “7-5”</li>
</ol>
<p><strong>Check your understanding</strong></p>
<ol>
<li>What is an interpreter?</li>
<li>What is a compiler?</li>
<li>What’s the difference between an interpreter and a compiler?</li>
<li>What is a token?</li>
<li>What is the name of the process that breaks input apart into tokens?</li>
<li>What is the part of the interpreter that does lexical analysis called?</li>
<li>What are the other common names for that part of an interpreter or a compiler?</li>
</ol>
<p>Before I finish this article, I really want you to commit to studying interpreters and compilers. And I want you to do it right now. Don’t put it on the back burner. Don’t wait. If you’ve skimmed the article, start over. If you’ve read it carefully but haven’t done exercises - do them now. If you’ve done only some of them, finish the rest. You get the idea. And you know what? Sign the commitment pledge to start learning about interpreters and compilers today!
<br/>
<br/></p>
<p><i>
I, <strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong>____, of being sound mind and body, do hereby pledge to commit to studying interpreters and compilers starting today and get to a point where I know 100% how they work!</i></p>
<p>Signature:</p>
<p>Date:
</p>
<p><img alt="" src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_commitment_pledge.png"/></p>
<p>Sign it, date it, and put it somewhere where you can see it every day to make sure that you stick to your commitment. And keep in mind the definition of commitment:</p>
<blockquote>
<p><span class="dquo">“</span>Commitment is doing the thing you said you were going to do long after the mood you said it in has left you.” — Darren Hardy</p>
</blockquote>
<p>Okay, that’s it for today. In the next article of the mini series you will extend your calculator to handle more arithmetic expressions. Stay tuned.</p>
<p>If you can’t wait for the second article and are chomping at the bit to start digging deeper into interpreters and compilers, here is a list of books I recommend that will help you along the way:</p>
<ol>
<li>
<p><a href="http://www.amazon.com/gp/product/193435645X/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=193435645X&amp;linkCode=as2&amp;tag=russblo0b-20&amp;linkId=MP4DCXDV6DJMEJBL">Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages (Pragmatic Programmers)</a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=russblo0b-20&amp;l=as2&amp;o=1&amp;a=193435645X" border="0" alt=""/></p>
<p><a href="http://www.amazon.com/gp/product/B00QMJQHYG/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B00QMJQHYG&amp;linkCode=as2&amp;tag=russblo0b-20&amp;linkId=I53DN2FPOSCOLBXA"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=B00QMJQHYG&amp;Format=_SL250_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=russblo0b-20"/></a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=russblo0b-20&amp;l=as2&amp;o=1&amp;a=B00QMJQHYG" border="0" alt=""/></p>
</li>
<li>
<p><a href="http://www.amazon.com/gp/product/0470177071/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0470177071&amp;linkCode=as2&amp;tag=russblo0b-20&amp;linkId=UCLGQTPIYSWYKRRM">Writing Compilers and Interpreters: A Software Engineering Approach</a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=russblo0b-20&amp;l=as2&amp;o=1&amp;a=0470177071" border="0" alt=""/></p>
<p><a href="http://www.amazon.com/gp/product/0470177071/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0470177071&amp;linkCode=as2&amp;tag=russblo0b-20&amp;linkId=FYAZBCVOB66PGR6J"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=0470177071&amp;Format=_SL250_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=russblo0b-20"/></a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=russblo0b-20&amp;l=as2&amp;o=1&amp;a=0470177071" border="0" alt=""/></p>
</li>
<li>
<p><a href="http://www.amazon.com/gp/product/052182060X/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=052182060X&amp;linkCode=as2&amp;tag=russblo0b-20&amp;linkId=ZSKKZMV7YWR22NMW">Modern Compiler Implementation in Java</a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=russblo0b-20&amp;l=as2&amp;o=1&amp;a=052182060X" border="0" alt=""/></p>
<p><a href="http://www.amazon.com/gp/product/052182060X/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=052182060X&amp;linkCode=as2&amp;tag=russblo0b-20&amp;linkId=GPMSWTZYFC2M6MJE"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=052182060X&amp;Format=_SL250_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=russblo0b-20"/></a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=russblo0b-20&amp;l=as2&amp;o=1&amp;a=052182060X" border="0" alt=""/></p>
</li>
<li>
<p><a href="http://www.amazon.com/gp/product/1461446988/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1461446988&amp;linkCode=as2&amp;tag=russblo0b-20&amp;linkId=PAXWJP5WCPZ7RKRD">Modern Compiler Design</a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=russblo0b-20&amp;l=as2&amp;o=1&amp;a=1461446988" border="0" alt=""/></p>
<p><a href="http://www.amazon.com/gp/product/1461446988/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1461446988&amp;linkCode=as2&amp;tag=russblo0b-20&amp;linkId=DZVYHZHDHYAPOQOD"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=1461446988&amp;Format=_SL250_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=russblo0b-20"/></a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=russblo0b-20&amp;l=as2&amp;o=1&amp;a=1461446988" border="0" alt=""/></p>
</li>
<li>
<p><a href="http://www.amazon.com/gp/product/0321486811/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321486811&amp;linkCode=as2&amp;tag=russblo0b-20&amp;linkId=GOEGDQG4HIHU56FQ">Compilers: Principles, Techniques, and Tools (2nd Edition)</a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=russblo0b-20&amp;l=as2&amp;o=1&amp;a=0321486811" border="0" alt=""/></p>
<p><a href="http://www.amazon.com/gp/product/0321486811/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321486811&amp;linkCode=as2&amp;tag=russblo0b-20&amp;linkId=MD7L2CQHFXDYKOG6"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=0321486811&amp;Format=_SL250_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=russblo0b-20"/></a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=russblo0b-20&amp;l=as2&amp;o=1&amp;a=0321486811" border="0" alt=""/></p>
</li>
</ol>
<p><br/>
<span class="caps">BTW</span>, I’m writing a book <strong>“Let’s Build A Web Server: First Steps”</strong> that explains how to write a basic web server from scratch. You can get a feel for the book <a href="http://ruslanspivak.com/lsbaws-part1/" title="Part 1">here</a>, <a href="http://ruslanspivak.com/lsbaws-part2/" title="Part 2">here</a>, and <a href="http://ruslanspivak.com/lsbaws-part3/" title="Part 3">here</a>. Subscribe to the mailing list to get the latest updates about the book and the release date.</p>
<p>


</p>



<p><br/>
<strong>All articles in this series:</strong></p>

            </div>
            
    </div></body></html>