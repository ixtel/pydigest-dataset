<html><body><div><div class="entry-content"><p>CPython allows for potentially unbounded delay in handling signals.  To my
knowledge, there is no fix or workaround that has no drawbacks.</p>

<hr/>

<p>Suppose you sit down across the table from your interviewer, and they ask you
a seemingly simple question:</p>

<p>We have two programs.  One contains the code</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIG_DFL</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>and the other contains</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">handler</span><span class="p">():</span>
</span><span class="line">  <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">)</span>
</span><span class="line"><span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>What are all of the observable differences between these two programs at
runtime?  (Given that this is all you know about the two programs.)</p>

<hr/>

<p>There’s a few different parts to this answer.</p>

<p>At the systems level, you’ll notice that if you <code>kill -TERM</code> the process, when
it exits in the first case, it will have a return code of <code>-SIGTERM</code>, and in
the second it will have a return code of <code>SIGTERM</code>.  Negative return codes are
reserved for processes that die because of a signal.  Because we register a
handler and cause the process to exit intentionally, we can’t cause the
negative return code.</p>

<p>At the python level, you’ll notice a few differences in terms of what code is
executed.  In the first case, nearly nothing is executed, as we terminate as
soon as we hit the signal.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>  In the second case, we are throwing a
<code>SystemExit</code> exception, so all code in <code>finally</code> blocks between the current
execution point and main will run.</p>

<p>However, the most interesting case is <em>when</em> the code is executed, because of
how signals are handled within CPython.  This changes if/when you’ll see the
behavior mentioned in the previous two points.</p>

<p>When you request for a piece of python code to be registered as a signal
handler, CPython registers a function that will add your handler to a queue of
events to be handled, sets the interpreter state to try and run the pending
actions soon, and then returns.  The next time that CPython goes to execute a
python bytecode, it will see that it has pending actions to do, and execute
them only if the current thread is the main thread.  If the current thread is
not the main thread, then it will execute another 100 bytecodes, and then do
the same check again.  Whenever we happen to switch to the main thread again,
we will execute the pending actions, and thus the signal handler.</p>

<p>It’s very important to note that this means that your python signal handler
doesn’t execute as part of the C signal handler.  It can’t.  In order to
execute python code, we’d have to acquire the GIL, and there’s no way that it
would be safe to block on locking the GIL in a signal handler.  There’s also
the important restriction that in order for the python signal handler to
execute, the main thread needs to be awake and running.  This is done to
enforce a consistent behaviour of signals in a multithreaded program.  I have
found these two requirements combined can cause some seriously unexpected
behaviour with respect to when a signal handler will execute.</p>

<p>So let me illustrate the problem that can be caused with some examples.</p>

<p>To start with, the no signal handler case:</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c">#!/usr/bin/env python</span>
</span><span class="line">
</span><span class="line"><span class="kn">import</span> <span class="nn">time</span>
</span><span class="line"><span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>If we run this program under strace, and <code>SIGTERM</code> it while it sleeps,<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> we
see:</p>

<pre><code>select(0, NULL, NULL, NULL, {60, 0})    = ? ERESTARTNOHAND (To be restarted)
--- SIGTERM (Terminated) @ 0 (0) ---
+++ killed by SIGTERM +++
143
</code></pre>

<p>Showing us that the process immediately received a <code>SIGTERM</code> and died, returning
with error code <code>143</code>, which is the same as <code>-SIGTERM</code>.</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c">#!/usr/bin/env python</span>
</span><span class="line">
</span><span class="line"><span class="kn">import</span> <span class="nn">signal</span>
</span><span class="line"><span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">):</span>
</span><span class="line">    <span class="k">pass</span>
</span><span class="line"><span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kn">import</span> <span class="nn">time</span>
</span><span class="line"><span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>If we take this script, run it under strace, and <code>SIGTERM</code> it while it runs, we
see</p>

<pre><code>select(0, NULL, NULL, NULL, {60, 0})    = ? ERESTARTNOHAND (To be restarted)
--- SIGTERM (Terminated) @ 0 (0) ---
rt_sigreturn(0xffffffff)                = -1 EINTR (Interrupted system call)
rt_sigaction(SIGINT, {SIG_DFL, [], SA_RESTORER, 0x7f153709dcb0}, {0x558fd0, [], SA_RESTORER, 0x7f153709dcb0}, 8) = 0
rt_sigaction(SIGTERM, {SIG_DFL, [], SA_RESTORER, 0x7f153709dcb0}, {0x558fd0, [], SA_RESTORER, 0x7f153709dcb0}, 8) = 0
exit_group(0)                           = ?
0
</code></pre>

<p>So here we discover that under the covers, <code>time.sleep</code> maps to an empty
<code>select</code> call to (ab)use the timeout feature of select.  <code>ERESTARTNOHAND</code> is a
return value that’s never seen by client code.  It means that if there’s no
handler (the signal is ignored) that the interrupted syscall will just be
restarted.  In this case, we do have a signal handler for <code>SIGTERM</code>, which
executes, and then from <code>sigreturn</code> we see that the select was then forced to
return with <code>EINTR</code>.  Immediately after receiving the <code>SIGTERM</code>, the python
process exited gracefully.</p>

<p>This is one of the useful features of signals:  they let you break syscalls.
With Python, this is doubly amazing, since it means you can get back to the
python interpreter and be able to run your python signal handler!</p>

<p>However, this doesn’t always work, because whatever C code you’re calling from
python has to abide by the fact that if anything it calls returns with <code>EINTR</code>,
then it should return (hopefully with an <code>EINTR</code>).</p>

<p>And unfortunately, it’s fairly easy to force a call from python that doesn’t
helpfully abide by this rule.</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c">#!/usr/bin/env python</span>
</span><span class="line">
</span><span class="line"><span class="kn">import</span> <span class="nn">signal</span>
</span><span class="line"><span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">):</span>
</span><span class="line">    <span class="k">pass</span>
</span><span class="line"><span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kn">import</span> <span class="nn">socket</span>
</span><span class="line"><span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="s">"www.potato.com"</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>If we run this again under strace, we’ll see that it loops over a set of DNS
servers and possible search domains.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>  If we <code>SIGTERM</code> it during the lookup, we’ll
see the following from strace.</p>

<pre><code>stat("/etc/resolv.conf", {st_mode=S_IFREG|0644, st_size=856, ...}) = 0
socket(PF_INET, SOCK_DGRAM|SOCK_NONBLOCK, IPPROTO_IP) = 3
connect(3, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("second.dns.server.ip")}, 16) = 0
poll([{fd=3, events=POLLOUT}], 1, 0)    = 1 ([{fd=3, revents=POLLOUT}])
sendto(3, "R\315\1\0\0\1\0\0\0\0\0\0\3www\6potato\3com\0\0\1\0\1", 32, MSG_NOSIGNAL, NULL, 0) = 32
poll([{fd=3, events=POLLIN}], 1, 5000)  = ? ERESTART_RESTARTBLOCK (To be restarted)
--- SIGTERM (Terminated) @ 0 (0) ---
rt_sigreturn(0xffffffff)                = -1 EINTR (Interrupted system call)
poll([{fd=3, events=POLLIN}], 1, 4950)  = 1 ([{fd=3, revents=POLLIN}])
ioctl(3, FIONREAD, [32])                = 0
recvfrom(3, "R\315\201\202\0\1\0\0\0\0\0\0\3www\6potato\3com\0\0\1\0\1", 1024, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("first.dns.server.ip")}, [16]) = 32
close(3)                                = 0
socket(PF_INET, SOCK_DGRAM|SOCK_NONBLOCK, IPPROTO_IP) = 3
connect(3, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("first.dns.server.ip")}, 16) = 0
poll([{fd=3, events=POLLOUT}], 1, 0)    = 1 ([{fd=3, revents=POLLOUT}])
sendto(3, "R\315\1\0\0\1\0\0\0\0\0\0\3www\6potato\3com\0\0\1\0\1", 32, MSG_NOSIGNAL, NULL, 0) = 32
</code></pre>

<p>So we see the program receive the signal, and <code>poll</code> return with <code>EINTR</code>.
<code>getaddrinfo</code> then begins doing the DNS queries from the top again.  It appears
that <code>getaddrinfo</code> internally restarts its series of lookups from the very
beginning when it handles the <code>EINTR</code> .<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p>

<p>This means that we can’t really force a call to <code>getaddrinfo</code> to bring us back
to a point where the python interpreter resumes running just by sending a
signal.  We also can’t force the python signal handler for <code>SIGTERM</code> to run
until <code>getaddrinfo</code> returns, and we have no control over how long that takes.</p>

<p>The behavior of code outside our control can cause our signal handler to
potentially never run.  That is very unfortunate.</p>

<p>To bring this all together, let me explain the bug that caused this write up in
the first place to show how this does and can cause problems in the real world.
In our codebase, we register a <code>SIGTERM</code> handler that enforces some very quick
and forceful cleanup.</p>

<figure class="code"><figcaption><span/></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># Snipped context hides that this is a closure and `pid_file_manager` comes</span>
</span><span class="line"><span class="c"># from the environment.</span>
</span><span class="line"><span class="k">def</span> <span class="nf">handle_sigterm</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
</span><span class="line">    <span class="k">if</span> <span class="n">pid_file_manager</span><span class="p">:</span>
</span><span class="line">        <span class="n">pid_file_manager</span><span class="o">.</span><span class="n">close_file</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">)</span>
</span><span class="line">    <span class="n">os</span><span class="o">.</span><span class="n">killpg</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpgrp</span><span class="p">(),</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIGKILL</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>We write out a pidfile, and then we forcefully terminate our entire process
group.  Therefore, it should be highly expected that after receiving a
<code>SIGTERM</code>, the process should exit.  However, because of calls that we have to
<code>getaddrinfo</code>, we sometimes send a <code>SIGTERM</code>, and after 5 seconds, the process
still hasn’t exited.  <a href="https://pypi.python.org/pypi/faulthandler/">faulthandler</a>
shows that we’re in a call to <code>getaddrinfo</code>.  Since the process didn’t
terminate after <code>SIGTERM</code>, we thus assume that it’s completely wedged somehow,
and kill it with a <code>SIGKILL</code>.  We’re then left with a pidfile that wasn’t
properly closed, and our infrastructure sends out a warning.</p>

<p>So there’s three possible directions to go that I see to solve this problem:</p>

<ol>
<li><p>One can try to make signals work by moving all work off of the main thread.</p>

<p>The only way to ensure that a python process will respond to signals in a
timely fashion is to always have the main thread be idle.  This isn’t that
difficult to set up<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>, but it restricts what you can do with signals.</p>

<p>In our codebase, we have a very convenient decorator that sets up <code>SIGALRM</code>
to be delivered after a timeout, and raises a <code>TimeoutException</code> if it
happens.  This lets us recover from when sending or receiving on a socket
hangs.  If we move all of the work off the main thread, then we’ll use the
decorator on a non-main thread, and the <code>SIGALRM</code> will still be handled on
the main thread and the <code>TimeoutException</code> thrown will kill the main thread.</p></li>
<li><p>One can achieve the same goals without using signals.</p>

<p>We happen to already have an execution subdirectory for each python process
that we wish to terminate.  Therefore, one could drop a named pipe in the
execution subdirectory and set up a thread in the python process so that
when any data is read off the named pipe, the thread runs the cleanup and
aborts the process.  Doing so drops the requirement that the main thread
must be available, so as long as the GIL is not acquired, the process will
be able to terminate gracefully.</p></li>
<li><p>One can do the cleanup work elsewhere, and let the python process exit
ungracefully.</p>

<p>The cleanup that is done can be moved to a higher level of the
infrastructure.  This is, somewhat sadly, the route that I ended up going.
We already send a process a <code>SIGKILL</code> if it doesn’t respond to <code>SIGTERM</code> in
time, and it doesn’t make sense to expect a process that has been sent
<code>SIGKILL</code> to exit gracefully, so we now just suppress notifications in that
case.</p></li>
</ol>


<p>Let me finish by saying that everything that I’ve explained is documented in
the text at the top of the documentation for the signal module:</p>

<blockquote><p>This module provides mechanisms to use signal handlers in Python. Some general
rules for working with signals and their handlers:</p>

<ul>
<li>A handler for a particular signal, once set, remains installed until it is
explicitly reset (Python emulates the BSD style interface regardless of the
underlying implementation), with the exception of the handler for SIGCHLD, which
follows the underlying implementation.</li>
<li>There is no way to “block” signals temporarily from critical sections (since
this is not supported by all Unix flavors).</li>
<li>Although Python signal handlers are called asynchronously as far as the Python
user is concerned, they can only occur between the “atomic” instructions of the
Python interpreter. This means that signals arriving during long calculations
implemented purely in C (such as regular expression matches on large bodies of
text) may be delayed for an arbitrary amount of time.</li>
<li>When a signal arrives during an I/O operation, it is possible that the I/O
operation raises an exception after the signal handler returns. This is
dependent on the underlying Unix system’s semantics regarding interrupted system
calls.</li>
<li>Because the C signal handler always returns, it makes little sense to catch
synchronous errors like SIGFPE or SIGSEGV.</li>
<li>Python installs a small number of signal handlers by default: SIGPIPE is ignored
(so write errors on pipes and sockets can be reported as ordinary Python
exceptions) and SIGINT is translated into a KeyboardInterrupt exception. All of
these can be overridden.</li>
</ul>


<p>Some care must be taken if both signals and threads are used in the same
program. The fundamental thing to remember in using signals and threads
simultaneously is: always perform signal() operations in the main thread of
execution. Any thread can perform an alarm(), getsignal(), pause(), setitimer()
or getitimer(); only the main thread can set a new signal handler, and the main
thread will be the only one to receive signals (this is enforced by the Python
signal module, even if the underlying thread implementation supports sending
signals to individual threads). This means that signals can’t be used as a means
of inter-thread communication. Use locks instead.</p></blockquote>

<p>So nothing I’ve described above about Python wasn’t known before.  If you look
at the man page for <code>getaddrinfo</code>, you’ll see that it doesn’t mention returning
with <code>EINTR</code> or being interruptible by a signal.  Everything is working as
designed/intended here, it’s just that this combination causes a very
unfortunate effect.</p>


</div>


  </div></body></html>