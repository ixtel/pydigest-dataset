<html><body><div><div class="sectionbody">
<div class="paragraph"><p>The trickiness comes from the fact that internally, Python 3 strings
are sequences of Unicode code points.  Data, coming in from your
environment, is a byte stream.  As long as all of it is true ASCII
(bytes 0x00..0x7f) Python knows to turn this into a Unicode code point
corresponding to ASCII - no harm, no foul. On output, this is reversed
without fuss.</p></div>
<div class="paragraph"><p>Thus, Python programs operating on pure ASCII text typically don’t
need to be modified much from 2 to 3. For these, the few tricky bits
will be changes in library names.  The 2to3 translator does a pretty
good job of mapping these over.  Later in this HOWTO we’ll show you
a technique for writing your imports that works under either 2 or 3.</p></div>
<div class="paragraph"><p>Another issue that can affect even programs handling only ASCII is
that the meaning of opening a file in binary mode changes in Python 3.
In Python 2, binary mode (“rb”, “wb”) is identical to non-binary mode
(“r”, “w”) under Unix, but changes how line endings are processed
under Windows.  In Python 3, something more serious happens; reads
from that file object return byte-buffer objects rather than strings.</p></div>
<div class="paragraph"><p>(A note on terminology: to avoid ambiguities in the use of the term
<em>bytes</em>, in this document we’ll use <em>byte-buffer</em> to name the Python
3 object that is a sequence of integers in the range 0..255. We
will use <em>byte string</em> for the Python 2 character sequence object.)</p></div>
<div class="paragraph"><p>You’ll actually want binary opens in order to prevent hidden
encode/decode attempts from messing with your binary data.  But it is
likely to trigger mysterious errors when a naive lift of your Python 2
code tries to combine byte-buffer objects with strings, something
Python 3 won’t let it do.</p></div>
<div class="paragraph"><p>Everything changes when the binary data in your I/O meets Python 3
strings. Because Python 3 wants to turn input into a Unicode object,
it needs to have a defined encoding from input bytes.  Its default
input encoding is ‘ascii’ - which will throw a UnicodeEncode error if it
sees an input byte with the high bit set. Program fall down go boom.</p></div>
<div class="paragraph"><p>There are analogous problems on output.  Python can’t write non-ASCII
Unicode characters without decoding them to some concrete byte-stream
representation. Python’s default output encoding is also ‘ascii’, and it
will throw a UnicodeDecode error if it sees an output byte with the
high bit set.</p></div>
<div class="paragraph"><p>When in doubt about what encoding is set for a file object, you can
ask it.  File objects have a read-only ‘encoding’ member; it
defaults to None, which is the Python default encoding, which is
‘ascii’. (This is not specified in the Python documentation, but is
in the official Unicode HOWTO.)</p></div>
<div class="paragraph"><p>Note, however, that the ASCII default applies only to disk files.
The default sys.stdin/sys.stdout/sys.stderr streams, attached to
terminals, have a different default encoding which is probably (but
not necessarily) ‘utf-8’.  Unless you fix this, binary I/O via
shell pipes can have unexpected (and wrong!) results.</p></div>
<div class="paragraph"><p>Other file-like objects, such as pipes returned by the subprocess
module, give you byte streams.</p></div>
<div class="paragraph"><p>Finally, Python has a separate file system encoding property that
applies not to file streams but file <strong>names</strong> - which are internally
Unicode in Python 3 but have to be encoded/decoded to byte
representations in your operating system’s file system.  This too is
usually utf-8, and you almost certainly should <strong>not</strong> mess with it.</p></div>
</div>
</div></body></html>