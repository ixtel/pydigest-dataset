<html><body><div><div class="post-text" itemprop="text">
<p>Disclaimer: I'm neither a credible nor an official source.</p>

<p>I'm almost certain that any implementation of log to the base e function can be made as fast as the log2 function, because to convert one to the other you require a single division by a constant. This is of course assuming that a single division operation is a tiny fraction of the other computations; which in accurate implementations of logarithms is true.</p>

<p>In most cases, numpy uses <code>math.h</code> from <code>glibc</code>, you'll see the same difference in C/C++ if you use <code>math.h</code>/<code>cmath.h</code>. In the comments, some people observe same speeds for <code>np.log</code> and <code>np.log2</code>; I suspect this may come from different builds / platforms.</p>

<p>You can find the nicely commented source code for the two functions in files <code>e_log.c</code>, <code>e_log2.c</code>, <code>e_logf.c</code>, <code>e_log2f.c</code> in the <code>dbl-64/</code> and <code>flt-32/</code> subdirectories of <a href="http://github.com/lattera/glibc/tree/master/sysdeps/ieee754" rel="nofollow">this GitHub repo</a>.</p>

<p>For double precision, in <code>glibc</code>, the <code>log</code> function is implementing a completely different algo (compared to <code>log2</code>) from IBM from ~2001, which was included in their <code>libultim</code> library. Whereas <code>log2</code> is from Sun Microsystems from ~1993. Just looking at the code one can see two different approximations are being implemented. In contrast, for single precision, both functions <code>log</code> and <code>log2</code> are the same apart from division by <code>ln2</code> in the <code>log2</code> case, hence the same speed.</p>

<p>For even more background on the underlying algorithms, alternatives and discussions on which to include in <code>glibc</code> in the future, see <a href="http://sourceware.org/ml/libc-alpha/2007-02/msg00007.html" rel="nofollow">here</a>.</p>
    </div>
    </div></body></html>