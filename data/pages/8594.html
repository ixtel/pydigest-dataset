<html><body><div><div class="content html_format"><p>
      Иногда этот метод называют «крестьянское умножение», иногда «древнеегипетское», иногда «эфиопское», иногда «умножение через удвоение и деление пополам». Некоторым он хорошо известен, некоторым – непонятен, но при этом он достаточно полезен и может использоваться не только для умножения, но и для возведения в степень и расчётов матриц.</p>

<h4>Алгоритм</h4>
<pre><code class="bash">  13  x  19 -&gt;     0
   6     38       19
   3     76 -&gt;
   1    152 -&gt;    95
   0    304      247
                 ^^^
</code></pre><p>
Запишем два перемножаемых числа рядом – они станут заголовками двух столбцов. Третий столбец будет содержать нарастающую сумму.
</p><p>
Если число в левом столбце нечётное, мы добавляем число из правого столбца в нарастающую сумму. Изначально она будет равна нулю.
</p><p>
Затем в левом столбце ниже мы записываем число из заголовка, делённое пополам (с отбрасыванием остатка). 13 / 2 = 6. А во втором столбце мы пишем число, равное удвоению заголовка столбца, 19*2 = 38.
</p><p>
Поскольку число в левом столбце чётное, мы не увеличиваем нарастающую сумму.
</p><a name="habracut"/><p>
Потом мы повторяем процесс деления на два и удвоения. В левом столбце будет 3, это число нечётное, поэтому мы добавляем к 19 76 и получаем 95.
</p><p>
Повторяя процедуру, мы получаем в результате 247.
</p><p>
Проверка:
</p><p>
Среднее между 13 и 19 будет 16</p><p>
16 ^ 2 = 256</p><p>
16 – 13 = 3</p><p>
3 ^ 2 = 9</p><p>
256 – 9 = 247
</p><p>
Если не закончить работу алгоритма, то в левом столбце будут сплошные нули, и поскольку 0 – чётное число, к нарастающей сумме добавлять ничего не будет нужно. Поэтому, как только мы получаем в левом столбце единицу, в третьем столбце появляется ответ.

</p><h4>Доказательство</h4><p>
Почему это работает? Можно сказать, что это обычное двоичное длинное умножение. Но мы приведём более длинное объяснение, которое будет заодно и более общим. 
</p><p>
Обозначим число в левом столбце A, во втором – B, нарастающую сумму – R, а ответ – P. Следовательно
</p><p>
(A*B) + R = P
</p><p>
Тогда, если A чётное, то есть k, для которого A=2k. Перепишем уравнение:
</p><p>
(2k*B) + R = P
</p><p>
Или, что то же самое:
</p><p>
(k*2B) + R = P
</p><p>
Если мы заменим A половиной его значения, а B – удвоенным значением, и назовём их A' и B', то:
</p><p>
(A'*B') + R = P
</p><p>
То есть, если A чётное, мы уполовиним первое число и удвоим второе, и наше уравнение верно. А если нечётное? Тогда A=2k+1
</p><p>
A*B + R = P
</p><p>
(2k+1)*B + R = P
</p><p>
2k*B + B + R = P
</p><p>
2k*B + (B+R) = P
</p><p>
K*2B + (B+R) = P
</p><p>
A'*B' + (B+R) = P
</p><p>
И опять мы обозначили половину A через A' и удвоенное B через B'.
</p><p>
Наше уравнение верно, если мы:
</p><ul>
<li>добавили число из второго столбца к нарастающей сумме</li>
<li>уполовинили первый столбец</li>
<li>удвоили второй</li>
</ul><p>
Видно, что наше уравнение остаётся сбалансированным при выполнении шагов нашего алгоритма.
</p><p>
Когда мы доходим до нуля, то имеем:
</p><p>
0 * B + R = P
</p><p>
Или R=P. Наша нарастающая сумма равна нужному результату.

</p><h5>Обобщение 1: возведение в степень</h5><p>
Попробуем подсчитать 2</p><sup>13</sup><p>. При возведении в степень мы перемножаем числа, а не складываем, поэтому мы усовершенствуем наш алгоритм:
</p><p>
заменим сложение умножением</p><p>
заменим удвоение возведением в квадрат

</p><pre><code class="bash">степень   база
======   ====
  13      2 -&gt;     1
   6      4        2
   3     16 -&gt;
   1    256 -&gt;    32
   0  65546     8192
                ^^^^
</code></pre><p>
Нарастающее произведение начинается с 1. 13 – нечётное, поэтому умножаем второй столбец на нарастающее произведение, получая 2. Теперь мы уполовиним 13 и возведём 2 в квадрат.
</p><p>
6 – чётное, не умножаем нарастающее произведение. Уполовиним 6 и возведём в квадрат 4, получим 16.
</p><p>
3 – нечётное, умножаем 16 на наше нарастающее произведение, получим 32. Уполовиним первый столбец и возведём в квадрат второй.
</p><p>
Последний шаг: 1 – нечётное, умножаем 256 на 32, получаем 8192, что и является ответом.
</p><p>
Доказательство этого алгоритма такое же, как и у прошлого, просто теперь наше уравнение выглядит так:
</p><p>
B</p><sup>A</sup><p>*R=E

</p><h5>Обобщение 2: матрицы</h5><p>
Но этот алгоритм можно использовать не только для возведения чисел в степень – он работает и для матриц. Наше нарастающее произведение начинается с единичной матрицы, а во второй столбец пишется матрица, чью степень нам надо получить. И всё работает.
</p><p>
Далее идёт функция, написанная на языке Python. Она работает для любой неотрицательной степени, и «базы» любого типа, поддерживающего ассоциативное умножение. Иными словами, она работает для любой коллекции с умножением, являющейся </p><a href="http://habrahabr.ru/post/112394/">моноидом</a><p>.
 
</p><pre><code class="python">def fast_exp(b,e,I=1):
# Подсчёт b^e, где e – неотрицательное целое. Начинаем с 
# нарастающего произведения I, так что эта функция будет 
# работать и с числами, и с матрицами

    result = I
    while e &gt; 0:

        if is_odd(e):
            result *= b
        b *= b
        e = e / 2

    return result
</code></pre><p>
Этого даже не нужно понимать, достаточно знать, что она работает для матриц.
</p><p>
Ссылки
</p>
      <p class="clear"/>
    </div>

    
  </div></body></html>