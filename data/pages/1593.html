<html><body><div><div class="entry-content">
		<p>I’ve been playing around with <a title="PyPy" href="http://pypy.org">PyPy</a> lately (more on that later) and decided I’d take a look to see how the NumPy implementation on PyPy (NumPyPy[1]) is coming along.  NumPyPy is potentially very interesting. Because the JIT can remove most of the Python overhead, more of the code can be moved to the Python level. This in turn opens up all sorts of interesting avenues for optimization, including doing the things that <a title="Numexpr on github" href="https://github.com/pydata/numexpr">Numexpr</a> does, only better.  Therefore, I was very exciting when I saw this <a title="Post about NumPyPy running fast" href="%20http://morepypy.blogspot.com/2012/01/numpypy-progress-report-running.html.">post</a> from 2012, describing how NumPyPy was running “relatively real-world” examples over twice as fast as standard NumPy.</p>
<p>I downloaded and installed the NumPyPy code from <a title="NumPyPy Source" href="https://bitbucket.org/pypy/numpy">https://bitbucket.org/pypy/numpy</a>.  This went smoothly except I had to spend a bit of time messing with permissions. I’m not sure if this was something I did on my end, or if the permissions of the source are odd. In either event, installation was pretty easy.  I first tested the speed of NumPyPy using the micro-optimization code from last week – this was my first indication that this wasn’t going to be as impressive as I’d hoped. NumPyPy was over 10⨉ slower than standard NumPy when running this code!</p>
<p>I did some more digging around and found an <a title="NumPy Plans for next six  months" href="https://mail.python.org/pipermail/pypy-dev/2014-February/012214.html">email chain </a>that described how the NumPyPy developers are focusing on completeness before speed. That’s understandable, but certainly isn’t as exciting as a very fast, if incomplete, version of NumPy.</p>
<p>I tried another, very simple,  example, using timeit; in this case standard NumPy was about 7× faster than NumPyPy:</p>
<blockquote>
<pre>$ python -m timeit -s "import numpy as np; a = np.arange(100000.0); b=a*7"  "x = a + b"
10000 loops, best of 3: 71.3 usec per loop</pre>
<pre> $ pypy-2.3.1-osx64/bin/pypy -m timeit -s "import numpy as np; a = np.arange(100000.0); b=a*7"  "x = a + b"
1000 loops, best of 3: 953 usec per loop</pre>
</blockquote>
<p>Just for fun, I dusted off Psymeric.py, a very old replacement for Numeric.array that I wrote to see what kind of performance I could get using Psyco plus Python.  There is a copy of Psymeric hosted at <a title="Psymeric source" href="https://bitbucket.org/dblank/pure-numpy/src">https://bitbucket.org/dblank/pure-numpy/src</a>, although I had to tweak that version slightly to ignore Psyco and run under both Python 2 and 3.  Running the equivalent problem with Psymeric using both CPython and PyPy gives an interesting result:</p>
<blockquote>
<pre>python -m timeit -s "import psymeric as ps; a = ps.Array(range(100000), ps.Float64); b=a*7"  "x = a + b"
10 loops, best of 3: 30.7 msec per loop</pre>
<pre>pypy-2.3.1-osx64/bin/pypy -m timeit -s "import psymeric as ps; a = ps.Array(range(100000), ps.Float64); b=a*7"  "x = a + b"
1000 loops, best of 3: 510 usec per loop</pre>
</blockquote>
<p>Running with CPython this is, predictably, pretty terrible (note the units are <em>ms </em>in this case versus <em>µs</em> in the other cases). However, when run with PyPy, this actually faster than NumPyPy.  Keep in mind that Psymeric is pure Python and we are just relying on PyPy’s JIT to speed it up.</p>
<p>These results made me suspect that NumPyPy was also written in Python, but that appears to not be quite right.  It appears that the core of NumPyPy is written in the RPython, the same subset of Python the PyPy itself is written in. This allows the core to be translated into C. However, as I understand it, in order for this to work, the core needs to be part of PyPy proper, not a separate module. And that appears in fact that is the case: the core parts of numpy are contained in the module <em>_numpy</em> defined in the PyPy source directory micronumpy and they are imported by the NumPyPy package, which is installed separately. If all that sounds wishy-washy, it’s because I’m still very unsure on how this is working, but this is my best guess at the moment.</p>
<p>This puts NumPyPy in an odd position. One of main attractions of PyPy from my perspective is that it’s quite fast. However, NumPyPy is still too slow for most of the applications I’m interested in.  From comments on the mailing list, it sounds like their funding sources for NumPy are more interested in completeness than speed, so the speed situation may not improve soon. I <em>should</em> put my time where my mouth is and figure out how to contribute to the project, but I’m not sure if I’ll have the spare cycles soon.</p>
<p>[1] This was a name used for NumPy on PyPy for a while. I’m not sure if it’s still considered legit, but I can’t go around writing “NumPy on PyPy” over and over.</p>
			</div>

	</div></body></html>