<html><body><div><div class="article-text">
                <p>Welcome to a guide to the basics of mocking in Python. It was borne out of my need to test some code that used a lot of network services and my experience with <a href="https://github.com/golang/mock">GoMock</a>, which showed me how powerful mocking can be when done correctly. (Thanks <a href="https://blog.fugue.co/authors/tyler.html">Tyler</a>!) I'll begin with a philosophical discussion about mocking because good mocking requires a different mindset than good development. Development is about making things, while mocking is about faking things. This may seem obvious, but the "faking it" aspect of mocking tests runs deep, and understanding this completely changes how one looks at testing. After that, we'll look into the mocking tools that Python provides, and then we'll finish up with a full example.</p>
<p>Mocking can be difficult to understand. When I'm testing code that I've written, I want to see whether the code does what it's supposed to do from end-to-end. I usually start thinking about a functional, integrated test, where I enter realistic input and get realistic output. I access every real system that my code uses to make sure the interactions between those systems are working properly, using real objects and real API calls. While these kinds of tests are essential to verify that complex systems are interworking well, they are not what we want from unit tests.</p>
<p>Unit tests are about testing the outermost layer of the code. Integration tests are necessary, but the automated unit tests we run should not reach that depth of systems interaction. This means that any API calls in the function we're testing can and should be mocked out. We should replace any nontrivial API call or object creation with a mock call or object. This allows us to avoid unnecessary resource usage, simplify the instantiation of our tests, and reduce their running time. Think of testing a function that accesses an external HTTP API. Rather than ensuring that a test server is available to send the correct responses, we can mock the HTTP library and replace all the HTTP calls with mock calls. This reduces test complexity and dependencies, and gives us precise control over what the HTTP library returns, which may be difficult to accomplish otherwise. </p>
<h2 id="what-do-we-mean-by-mocking-">What do we mean by mocking?</h2>
<p>The term mocking is thrown around a lot, but this document uses the following definition:</p>
<blockquote>
<p><em>the replacement of one or more function calls or objects with mock calls or objects</em></p>
</blockquote>
<p>A mock function call returns a predefined value immediately, without doing any work. A mock object's attributes and methods are similarly defined entirely in the test, without creating the real object or doing any work. The fact that the writer of the test can define the return values of each function call gives him or her a tremendous amount of power when testing, but it also means that s/he needs to do some foundational work to get everything set up properly.</p>
<p>In Python, mocking is accomplished through the <code>unittest.mock</code> module. The module contains a number of useful classes and functions, the most important of which are the <code>patch</code> function (as decorator and context manager) and the <code>MagicMock</code> class. Mocking in Python is largely accomplished through the use of these two powerful components.</p>
<h2 id="what-do-we-not-mean-by-mocking-">What do we NOT mean by mocking?</h2>
<p>Developers use a lot of "mock" objects or modules, which are fully functional local replacements for networked services and APIs. For example, the <code>moto</code> library is a mock <code>boto</code> library that captures all <code>boto</code> API calls and processes them locally. While these mocks allow developers to test external APIs locally, they still require the creation of real objects. This is not the kind of mocking covered in this document. This document is specifically about using <code>MagicMock</code> objects to fully manage the control flow of the function under test, which allows for easy testing of failures and exception handling.</p>
<h2 id="how-do-we-mock-in-python-">How do we mock in Python?</h2>
<p>Mocking in Python is done by using <code>patch</code> to hijack an API function or object creation call. When <code>patch</code> intercepts a call, it returns a <code>MagicMock</code> object by default. By setting properties on the <code>MagicMock</code> object, you can mock the API call to return any value you want or raise an <code>Exception</code>.</p>
<p>The overall procedure is as follows: </p>
<blockquote>
<ol>
<li>Write the test as if you were using real external APIs. </li>
<li>In the function under test, determine which API calls need to be mocked out; this should be a small number. </li>
<li>In the test function, patch the API calls. </li>
<li>Set up the <code>MagicMock</code> object responses. </li>
<li>Run your test.</li>
</ol>
</blockquote>
<p>If your test passes, you're done. If not, you might have an error in the function under test, or you might have set up your <code>MagicMock</code> response incorrectly. Next, we'll go into more detail about the tools that you use to create and configure mocks.</p>
<h2 id="patch">patch</h2>
<pre><code><span class="hljs-typename">import <span class="hljs-variable">unittest</span> 
<span class="hljs-variable">from</span> <span class="hljs-variable">unittest</span>.<span class="hljs-variable">mock</span> <span class="hljs-variable">import</span> <span class="hljs-variable">patch</span></span></code></pre>
<p><code>patch</code> can be used as a decorator to the test function, taking a string naming the function that will be patched as an argument. In order for <code>patch</code> to locate the function to be patched, it must be specified using its fully qualified name, which may not be what you expect. If a class is imported using a <code>from module import ClassA</code> statement, <code>ClassA</code> becomes part of the namespace of the module into which it is imported.</p>
<p>For example, if a class is imported in the module <code>my_module.py</code> as follows: </p>
<pre><code><span class="hljs-array">[<span class="hljs-variable">in</span> <span class="hljs-variable">my_module</span>.<span class="hljs-variable">py</span>]</span> 
<span class="hljs-typename">from <span class="hljs-variable">module</span> <span class="hljs-variable">import</span> C<span class="hljs-variable">lassA</span></span></code></pre>
<p>It must be patched as <code>@patch(my_module.ClassA)</code>, rather than <code>@patch(module.ClassA)</code>, due to the semantics of the <code>from ... import ...</code> statement, which imports classes and functions into the <em>current</em> namespace.</p>
<p>Typically <code>patch</code> is used to patch an external API call or any other time- or resource-intensive function call or object creation. You should only be patching a few callables per test. If you find yourself trying <code>patch</code> more than a handful of times, consider refactoring your test or the function you're testing.</p>
<p>Using the <code>patch</code> decorator will automatically send a positional argument to the function you're decorating (i.e., your test function). When patching multiple functions, the decorator closest to the function being decorated is called first, so it will create the first positional argument.</p>
<pre><code><span class="hljs-decorator">@patch('module.ClassB')</span>
<span class="hljs-decorator">@patch('module.functionA')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_some_func</span><span class="hljs-params">(self, mock_A, mock_B)</span>:</span>
     ...</code></pre>
<p>By default, these arguments are instances of <code>MagicMock</code>, which is <code>unittest.mock</code>'s default mocking object. You can define the behavior of the patched function by setting attributes on the returned <code>MagicMock</code> instance.</p>
<h2 id="magicmock">MagicMock</h2>
<p><code>MagicMock</code> objects provide a simple mocking interface that allows you to set the return value or other behavior of the function or object creation call that you patched. This allows you to fully define the behavior of the call and avoid creating real objects, which can be onerous. For example, if we're patching a call to <code>requests.get</code>, an HTTP library call, we can define a response to that call that will be returned when the API call is made in the function under test, rather than ensuring that a test server is available to return the desired response.</p>
<p>The two most important attributes of a <code>MagicMock</code> instance are <code>return_value</code> and <code>side_effect</code>, both of which allow us to define the return behavior of the patched call.</p>
<h3 id="return_value">return_value</h3>
<p>The <code>return_value</code> attribute on the <code>MagicMock</code> instance passed into your test function allows you to choose what the patched callable returns. In most cases, you'll want to return a mock version of what the callable would normally return. This can be JSON, an iterable, a value, an instance of the real response object, a <code>MagicMock</code> pretending to be the response object, or just about anything else. When patching objects, the patched call is the object creation call, so the <code>return_value</code> of the <code>MagicMock</code> should be a mock object, which could be another <code>MagicMock</code>.</p>
<p>If the code you're testing is Pythonic and does duck typing rather than explicit typing, using a <code>MagicMock</code> as a response object can be convenient. Rather than going through the trouble of creating a real instance of a class, you can define arbitrary attribute key-value pairs in the <code>MagicMock</code> constructor and they will be automatically applied to the instance.</p>
<pre><code>[<span class="hljs-keyword">in</span> test_my_module]
@<span class="hljs-function"><span class="hljs-title">patch</span><span class="hljs-params">(<span class="hljs-string">'external_module.api_call'</span>)</span></span>
def <span class="hljs-function"><span class="hljs-title">test_some_func</span><span class="hljs-params">(self, mock_api_call)</span></span>:
     mock_api_call<span class="hljs-class">.return_value</span> = 
<span class="hljs-function"><span class="hljs-title">MagicMock</span><span class="hljs-params">(status_code=<span class="hljs-number">200</span>, response=json.dumps({<span class="hljs-string">'key'</span>:<span class="hljs-string">'value'</span>})</span></span>)
     my_module.<span class="hljs-function"><span class="hljs-title">some_func</span><span class="hljs-params">()</span></span>

[<span class="hljs-keyword">in</span> my_module]
import external_module

def <span class="hljs-function"><span class="hljs-title">some_func</span><span class="hljs-params">()</span></span>:
     response = external_module.<span class="hljs-function"><span class="hljs-title">api_call</span><span class="hljs-params">()</span></span> 

     <span class="hljs-id">#normally</span> returns <span class="hljs-tag">a</span> Response <span class="hljs-tag">object</span>, but now returns <span class="hljs-tag">a</span> MagicMock
<span class="hljs-id">#response</span> == mock_api_call<span class="hljs-class">.return_value</span> == <span class="hljs-function"><span class="hljs-title">MagicMock</span><span class="hljs-params">(status_code=<span class="hljs-number">200</span>, response=json.dumps({<span class="hljs-string">'key'</span>:<span class="hljs-string">'value'</span>})</span></span>)</code></pre>
<p>Note that the argument passed to <code>test_some_func</code>, i.e., <code>mock_api_call</code>, is a <code>MagicMock</code> and we are setting <code>return_value</code> to another <code>MagicMock</code>. When mocking, everything is a <code>MagicMock</code>.</p>
<h3 id="speccing-a-magicmock">Speccing a MagicMock</h3>
<p>While a <code>MagicMock</code>’s flexibility is convenient for quickly mocking classes with complex requirements, it can also be a downside. By default, <code>MagicMock</code>s act like they have any attribute, even attributes that you don’t want them to have. In the example above, we return a <code>MagicMock</code> object instead of a <code>Response</code> object. However, say we had made a mistake in the <code>patch</code> call and patched a function that was supposed to return a <code>Request</code> object instead of a <code>Response</code> object. The <code>MagicMock</code> we return will still act like it has all of the attributes of the <code>Request</code> object, even though we meant for it to model a <code>Response</code> object. This can lead to confusing testing errors and incorrect test behavior. </p>
<p>The solution to this is to <code>spec</code> the <code>MagicMock</code> when creating it, using the <code>spec</code> keyword argument: <code>MagicMock(spec=Response)</code>. This creates a <code>MagicMock</code> that will only allow access to attributes and methods that are in the class from which the <code>MagicMock</code> is specced. Attempting to access an attribute not in the originating object will raise an <code>AttributeError</code>, just like the real object would. A simple example is:</p>
<pre><code><span class="hljs-typename">m = M<span class="hljs-variable">agicMock</span>()
<span class="hljs-variable">m.foo</span>() #<span class="hljs-variable">no</span> <span class="hljs-variable">error</span> <span class="hljs-variable">raised</span>

# R<span class="hljs-variable">esponse</span> <span class="hljs-variable">objects</span> <span class="hljs-variable">have</span> <span class="hljs-variable">a status_code</span> <span class="hljs-variable">attribute</span>
<span class="hljs-variable">m = MagicMock</span>(<span class="hljs-variable">spec</span>=R<span class="hljs-variable">esponse</span>, <span class="hljs-variable">status_code</span>=200, <span class="hljs-variable">response</span>=<span class="hljs-variable">json</span>.<span class="hljs-variable">dumps</span>({‘<span class="hljs-variable">key</span>’:</span>’value’}))
<span class="hljs-typename">m.<span class="hljs-variable">foo</span>() #<span class="hljs-variable">raises</span> A<span class="hljs-variable">ttributeError</span>
<span class="hljs-variable">m.status_code</span> #<span class="hljs-variable">no</span> <span class="hljs-variable">error</span> <span class="hljs-variable">raised</span></span></code></pre>
<h3 id="side_effect">side_effect</h3>
<p>Sometimes you'll want to test that your function correctly handles an exception, or that multiple calls of the function you're patching are handled correctly. You can do that using <code>side_effect</code>. Setting <code>side_effect</code> to an exception raises that exception immediately when the patched function is called. </p>
<p>Setting <code>side_effect</code> to an iterable will return the next item from the iterable each time the patched function is called. Setting <code>side_effect</code> to any other value will return that value.</p>
<pre><code>[<span class="hljs-keyword">in</span> test_my_module]
<span class="hljs-decorator">@patch('external_module.api_call')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_some_func</span><span class="hljs-params">(self, mock_api_call)</span>:</span>
     mock_api_call.side_effect = SomeException()
     my_module.some_func()

[<span class="hljs-keyword">in</span> my_module]
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">some_func</span><span class="hljs-params">()</span>:</span>
     <span class="hljs-keyword">try</span>:
          external_module.api_call()
     <span class="hljs-keyword">except</span> SomeException:
          print(“SomeException caught!”)
          <span class="hljs-comment"># this code is executed</span>
     <span class="hljs-keyword">except</span> SomeOtherException:
          print(“SomeOtherException caught!”)
          <span class="hljs-comment"># not executed</span>

[<span class="hljs-keyword">in</span> test_my_module]
<span class="hljs-decorator">@patch('external_module.api_call')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_some_func</span><span class="hljs-params">(self, mock_api_call)</span>:</span>
     mock_api_call.side_effect = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
     my_module.some_func()

[<span class="hljs-keyword">in</span> my_module]
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">some_func</span><span class="hljs-params">()</span>:</span>
     rv0 = external_module.api_call() <span class="hljs-comment"># rv0 == 0</span>
     rv1 = external_module.api_call() <span class="hljs-comment"># rv1 == 1</span></code></pre>
<h3 id="assert_called_with">assert_called_with</h3>
<p><code>assert_called_with</code> asserts that the patched function was called with the arguments specified as arguments to <code>assert_called_with</code>.</p>
<pre><code><span class="hljs-array">[<span class="hljs-variable">inside</span> <span class="hljs-variable">some_func</span>]</span>
<span class="hljs-typename">someAPI.API_<span class="hljs-variable">call</span>(<span class="hljs-variable">foo</span>, <span class="hljs-variable">bar</span>='<span class="hljs-variable">baz</span>')

[<span class="hljs-variable">inside</span> <span class="hljs-variable">test_some_func</span>]
<span class="hljs-variable">some_func</span>()
<span class="hljs-variable">mock_api_call</span>.<span class="hljs-variable">assert_called_with</span>(<span class="hljs-variable">foo</span>, <span class="hljs-variable">bar</span>='<span class="hljs-variable">baz</span>')</span></code></pre>
<h2 id="a-full-example">A full example</h2>
<p>In this example, I'm testing a <code>retry</code> function on <code>Client.update</code>. This means that the API calls in <code>update</code> will be made twice, which is a great time to use <code>MagicMock.side_effect</code>.</p>
<p>The full code of the example is here:</p>
<pre><code><span class="hljs-keyword">import</span> unittest
<span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> patch

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClient</span><span class="hljs-params">(unittest.TestCase)</span>:</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setUp</span><span class="hljs-params">(self)</span>:</span>
    self.vars_client = VarsClient()

<span class="hljs-decorator">@patch('pyvars.vars_client.VarsClient.get')</span>
<span class="hljs-decorator">@patch('requests.post')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_update_retry_works_eventually</span><span class="hljs-params">(self, mock_post, mock_get)</span>:</span>
    mock_get.side_effect = [
        VarsResponse(),
        VarsResponse()]
    mock_post.side_effect = [
        requests.ConnectionError(<span class="hljs-string">'Test error'</span>),
        MagicMock(status_code=<span class="hljs-number">200</span>, headers={<span class="hljs-string">'content-type'</span>:<span class="hljs-string">"application/json"</span>},
                         text=json.dumps({<span class="hljs-string">'status'</span>:<span class="hljs-keyword">True</span>}))
    ]
    response = self.vars_client.update(<span class="hljs-string">'test'</span>, <span class="hljs-string">'0'</span>)
    self.assertEqual(response, response)
<span class="hljs-decorator">@patch('pyvars.vars_client.VarsClient.get')</span>
<span class="hljs-decorator">@patch('requests.post')</span>
     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_update_retry_works_eventually</span><span class="hljs-params">(self, mock_post, mock_get)</span>:</span></code></pre>
<p>I'm patching two calls in the function under test (<code>pyvars.vars_client.VarsClient.update</code>), one to <code>VarsClient.get</code> and one to <code>requests.post</code>. Since I'm patching two calls, I get two arguments to my test function, which I've called <code>mock_post</code> and <code>mock_get</code>. These are both <code>MagicMock</code> objects. In their default state, they don't do much. We need to assign some response behaviors to them.</p>
<pre><code><span class="hljs-typename">mock_get.<span class="hljs-variable">side_effect</span> = [
        V<span class="hljs-variable">arsResponse</span>(),
        V<span class="hljs-variable">arsResponse</span>()]
    <span class="hljs-variable">mock_post</span>.<span class="hljs-variable">side_effect</span> = [
        <span class="hljs-variable">requests</span>.C<span class="hljs-variable">onnectionError</span>('T<span class="hljs-variable">est</span> <span class="hljs-variable">error</span>'),
        M<span class="hljs-variable">agicMock</span>(<span class="hljs-variable">status_code</span>=200, <span class="hljs-variable">headers</span>={'<span class="hljs-variable">content-type</span>':</span><span class="hljs-string">"application/json"</span>},
                         text=json.dumps(<span class="hljs-dictionary">{'status':True}</span>))
    ]</code></pre>
<p>This tests to make sure a retry facility works eventually, so I'll be calling update multiple times, and making multiple calls to <code>VarsClient.get</code> and <code>requests.post</code>. </p>
<p>Here I set up the <code>side_effect</code>s that I want. I want all the calls to <code>VarsClient.get</code> to work (returning an empty <code>VarsResponse</code> is fine for this test), the first call to <code>requests.post</code> to fail with an exception, and the second call to <code>requests.post</code> to work. This kind of fine-grained control over behavior is only possible through mocking.</p>
<pre><code>response = self<span class="hljs-class">.vars_client</span><span class="hljs-class">.update</span>(<span class="hljs-string">'test'</span>, <span class="hljs-string">'0'</span>)
self.<span class="hljs-function"><span class="hljs-title">assertEqual</span><span class="hljs-params">(response, response)</span></span></code></pre>
<p>Once I've set up the <code>side_effect</code>s, the rest of the test is straightforward. The behavior is: the first call to <code>requests.post</code> fails, so the retry facility wrapping <code>VarsClient.update</code> should catch the error, and everything should work the second time. This behavior can be further verified by checking the call history of <code>mock_get</code> and <code>mock_post</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Using mock objects correctly goes against our intuition to make tests as real and thorough as possible, but doing so gives us the ability to write self-contained tests that run quickly, with no dependencies. It gives us the power to test exception handling and edge cases that would otherwise be impossible to test. Most importantly, it gives us the freedom to focus our test efforts on the functionality of our code, rather than our ability to set up a test environment. By concentrating on testing what’s important, we can improve test coverage and increase the reliability of our code, which is why we test in the first place.</p>
<h2 id="documentation-links">Documentation Links</h2>
<p><a href="https://docs.python.org/3/library/unittest.mock.html">https://docs.python.org/3/library/unittest.mock.html</a></p>
<p>And, check out <a href="https://fugue.co">fugue.co</a>.</p>

                

            </div>

            </div></body></html>