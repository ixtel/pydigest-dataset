<html><body><div><div class="post-content"> <a href="https://xkcd.com/1447"> <img src="http://imgs.xkcd.com/comics/meta-analysis.png" class="cover-image"/> </a> <hr class="hr-thin"/> <p>Same way as classes control instance creation and let us define instance behaviour in the form of instance methods and magic methods, <em>metaclasses</em> in Python can do all that and a little more for class objects. The simplest way to deal with metaclasses is to think of them as of <em>classes of classes</em>.</p>  <p>One of the most commonly used metaclasses is <a href="https://docs.python.org/3/library/functions.html#type"><code>type</code></a> since it’s a default metaclass for all classes, and all other metaclasses have to derive from it.</p> <h2 class="no_toc" id="contents">Contents</h2>  <h2 id="type-of-a-type">Type of a type</h2> <p>In Python, everything is an object and every object needs to have a <em>type</em>. In a nutshell, a type is an entity that knows how to create instances, with optional bells and whistles on top. For instance, the type of <code>1</code> is <code>int</code> and the type of <code>int</code> is <code>type</code>:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span>
<span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span></code></pre></div> <p>There’s the <a href="https://docs.python.org/3/library/types.html"><code>types</code></a> module in the standard library that provides a few functions that manipulate types and defines the standard types used by the interpreter. This comes in handy, say, if you need to check whether a given object is a function or a module:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">types</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">)</span>
<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">)</span></code></pre></div> <p>Now, since <code>type</code> is also an object, what about its type? It turns out that <code>type</code>’s type is the <code>type</code> itself, so that’s as far up the type ladder as it goes:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span></code></pre></div> <p>The type of all new-style user-defined classes is also <code>type</code>:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span></code></pre></div> <p>You sort of get that for free in Python 3, but in Python 2 you have to remember to derive all your classes from <code>object</code>, otherwise they end up being of <code>classobj</code> type:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Python 2.x</span>
<span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c"># let's just leave it at that</span>
<span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span></code></pre></div> <p>Finally, when called with three arguments, <code>type</code> acts like a constructor, so you can create new types in an inline fashion. The arguments are: the name of the type, the tuple of base classes and the class dict (which contains everything you would normally put in the class body):</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">Type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s">'Type'</span><span class="p">,</span> <span class="p">(</span><span class="n">A</span><span class="p">,),</span> <span class="p">{</span><span class="s">'x'</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span> <span class="s">'f'</span><span class="p">:</span> <span class="n">f</span><span class="p">})</span>
<span class="n">instance</span> <span class="o">=</span> <span class="n">Type</span><span class="p">()</span>

<span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">Type</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">Type</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">42</span>
<span class="k">assert</span> <span class="n">instance</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span></code></pre></div> <p>We’ll get back to this a bit later when we look at the metaclass constructor.</p>  <p>Since all metaclasses inherit from <code>type</code>, the simplest implementation of a metaclass looks like this:</p>  <p>Any class whose metaclass is <code>M</code> will now be of type <code>M</code> (but also an instance of <code>type</code> since <code>M</code> derives from <code>type</code>).</p> <p>How do we attach the metaclass to a class? Alas, this is yet another thing that’s done differently in Python 2 and Python 3.</p> <p>In Python 2, the metaclass is attached by setting a special field in the class body:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Python 2.x only</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">M</span></code></pre></div> <p>In Python 3, however, the metaclass has to be specified as a keyword argument in the base class list:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Python 3.x only</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">M</span><span class="p">):</span>
    <span class="k">pass</span></code></pre></div> <p>One of the ways to get around this is to use the <a href="https://pypi.python.org/pypi/six"><code>six</code></a> compatibility library which provides a unified way of attaching metaclasses either through a decorator or a special base class:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Python 2 and 3</span>
<span class="kn">import</span> <span class="nn">six</span>

<span class="c"># metaclass</span>
<span class="k">class</span> <span class="nc">M</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="c"># base class</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">A</span><span class="p">)):</span>
    <span class="k">pass</span>

<span class="nd">@six.add_metaclass</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="ow">is</span> <span class="n">M</span>

<span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="ow">is</span> <span class="n">M</span></code></pre></div> <h2 id="intercepting-type-constructors">Intercepting type constructors</h2> <p>As we’ve already seen above, <code>type</code>’s constructor signature looks like this:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">)</span></code></pre></div> <p>Defining classes using the <code>class</code> keyword can be just viewed as a syntactic sugar for calling <code>type</code>’s constructor directly (for the most part, anyway).</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">2</span></code></pre></div> <p>By using <code>type</code> directly, the example above could be rewritten like so:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">clsdict_a</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'x'</span><span class="p">:</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="n">A</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s">'A'</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="n">clsdict_a</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">2</span>

<span class="n">clsdict_b</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'y'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s">'f'</span><span class="p">:</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
    <span class="s">'g'</span><span class="p">:</span> <span class="n">g</span>
<span class="p">}</span>

<span class="n">B</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s">'B'</span><span class="p">,</span> <span class="p">(</span><span class="n">A</span><span class="p">,),</span> <span class="n">clsdict_b</span><span class="p">)</span></code></pre></div> <p>All the real magic is happening in the constructor of <code>type</code>, and user-defined metaclasses can alter the arguments that it receives. In other words, you can intercept class creation right after the class definition was parsed by interpreter and right before it gets passed on to <code>type</code>. This can be done by overriding the <code>__new__</code> method.</p> <p>Let’s look at a specific example where we want all subclasses of a certain class to be assigned automatically incremented <code>id</code> numbers only if the <code>track</code> field is set to true in the class body; we also want to store all tracked classes in a shared class-level <code>classes</code> field.</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">six</span>

<span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="n">classes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="n">clsdict</span><span class="p">[</span><span class="s">'id'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">track</span> <span class="o">=</span> <span class="n">clsdict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'track'</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">clsdict</span><span class="p">[</span><span class="s">'id'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">classes</span><span class="p">)</span> <span class="k">if</span> <span class="n">track</span> <span class="k">else</span> <span class="bp">None</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Meta</span><span class="p">,</span> <span class="n">meta</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">track</span><span class="p">:</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls</span>

<span class="nd">@six.add_metaclass</span><span class="p">(</span><span class="n">Meta</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Trackable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">assert</span> <span class="n">Trackable</span><span class="o">.</span><span class="n">classes</span> <span class="o">==</span> <span class="p">[]</span>
<span class="k">assert</span> <span class="n">Meta</span><span class="o">.</span><span class="n">classes</span> <span class="o">==</span> <span class="p">[]</span>
<span class="k">assert</span> <span class="n">Trackable</span><span class="o">.</span><span class="n">id</span> <span class="ow">is</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Trackable</span><span class="p">):</span>
    <span class="n">track</span> <span class="o">=</span> <span class="bp">True</span>

<span class="k">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span>
<span class="k">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">classes</span> <span class="o">==</span> <span class="n">Trackable</span><span class="o">.</span><span class="n">classes</span> <span class="o">==</span> <span class="p">[</span><span class="n">A</span><span class="p">]</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s">'track'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">assert</span> <span class="n">B</span><span class="o">.</span><span class="n">classes</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">classes</span> <span class="o">==</span> <span class="p">[</span><span class="n">A</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">B</span><span class="o">.</span><span class="n">id</span> <span class="ow">is</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">Trackable</span><span class="p">):</span>
    <span class="n">track</span> <span class="o">=</span> <span class="bp">True</span>

<span class="k">assert</span> <span class="n">C</span><span class="o">.</span><span class="n">classes</span> <span class="o">==</span> <span class="n">B</span><span class="o">.</span><span class="n">classes</span> <span class="o">==</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">C</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">1</span>
<span class="k">assert</span> <span class="n">Trackable</span><span class="o">.</span><span class="n">classes</span><span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="ow">is</span> <span class="n">C</span></code></pre></div> <p>First we define the metaclass <code>Meta</code> as a subclass of <code>type</code> that overrides its <code>__new__</code> method and contains a class-level variable <code>classes</code> that encapsulates the current state.</p> <p>The signature of <code>__new__</code> method matches the signature of <code>type</code>’s constructor – it receives the class name, a tuple of base types and a class dict, and it must return a fully instantiated type. In this method, we check if the class dict has a <code>track</code> field set to a true value and assign a class-level <code>id</code> accordingly if it does; elsewise, it is set to <code>None</code>.</p> <p>Finally, we call the the constructor of the base metaclass to instantiate the type, optionally store it in the list of tracked classes, and then return it. It’s worth mentioning that we could have used <code>type.__new__</code> instead of <code>super(Meta, meta).__new__</code> but it’s generally considered a good habit to avoid hard-coding the base type which may sometimes lead to unexpected inheritance behaviour.</p> <p>Note that all the class-level variables in the metaclass such as <code>classes</code> in the example above can also be accessed by the underlying classes and instances. Same way, instance methods of the metaclass are available as class methods in both classes and instances.</p>  <p>One of the typical use cases for metaclasses is to keep track of the created classes in order to be able to access them at runtime by name or identifier.</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">six</span>

<span class="k">class</span> <span class="nc">RegistryMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">meta</span><span class="o">.</span><span class="n">_registry</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

<span class="nd">@six.add_metaclass</span><span class="p">(</span><span class="n">RegistryMeta</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Registry</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="n">_registry</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Registry</span><span class="p">,</span> <span class="n">meta</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">clsdict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'__base__'</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">_registry</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls</span>
            <span class="k">if</span> <span class="s">'alias'</span> <span class="ow">in</span> <span class="n">clsdict</span><span class="p">:</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">_registry</span><span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls</span>
        <span class="k">return</span> <span class="n">cls</span>

<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">Registry</span><span class="p">)):</span>
    <span class="n">__base__</span> <span class="o">=</span> <span class="bp">True</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">alias</span> <span class="o">=</span> <span class="s">'foo'</span>

<span class="k">assert</span> <span class="n">Registry</span><span class="p">[</span><span class="s">'A'</span><span class="p">]</span> <span class="ow">is</span> <span class="n">A</span>  <span class="c"># lookup by class name</span>
<span class="k">assert</span> <span class="n">Registry</span><span class="p">[</span><span class="s">'B'</span><span class="p">]</span> <span class="ow">is</span> <span class="n">B</span>
<span class="k">assert</span> <span class="n">Registry</span><span class="p">[</span><span class="s">'foo'</span><span class="p">]</span> <span class="ow">is</span> <span class="n">B</span>  <span class="c"># or by alias</span>

<span class="c"># Base is not in registry</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">Registry</span><span class="p">[</span><span class="s">'Base'</span><span class="p">]</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">)</span></code></pre></div> <p>In this example, any subclass of <code>Base</code> (whether direct or indirect) will be tracked by the <code>Registry</code> metaclass, and can be retrieved at a later time via the class name or the <code>alias</code> field if it’s provided.</p> <p>We didn’t want the <code>Base</code> class itself to appear in the class registry, but rather its strict descendants only – so we check whether the class body has <code>__base__</code> field defined, and don’t register it with the metaclass if it does.</p> <p>In order to make the <code>Registry</code> metaclass subscriptable, we’ve had to attach <code>RegistryMeta</code> metaclass to it in which we’ve implemented <code>__getitem__</code> magic method. As scary as “metaclass of a metaclass” may sound, it follows the same logic as if you were implementing a magic method for instances in the class body – if you need the instance (which also happens to be a metaclass in our case) to do something fancy, you implement it in its type so the type knows how to attach that fancy functionality to the object at creation time.</p> <p>To summarize the type/metaclass hierarchy in the example above:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">A</span>
<span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Registry</span>
<span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">Registry</span><span class="p">)</span> <span class="ow">is</span> <span class="n">RegistryMeta</span>
<span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">RegistryMeta</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span></code></pre></div> <h2 id="singleton-pattern">Singleton pattern</h2> <p>Using global “god objects” is generally a bad idea, but if you absolutely have to – you may want to make sure it is actually a singleton. That is, only one unique instance of the class can exist at a time, and the class cannot be inherited from (or, in Java terms, it is <em>final</em>).</p> <p>As we’ve already seen, if a metaclass is attached to the base class, every time the base class is directly or indirectly subclassed the <code>__new__</code> method of the metaclass will be called. This lets us easily handle the no-inheritance part. Well, almost, since we could subclass the metaclass itself, attach it to a new base type and derive that class from the original singleton. If for some reason you would want to prevent that from happening, you could implement a metaclass for the metaclass in order to make the metaclass “final”. However, then one could subclass the metaclass’s metaclass… you get <a href="https://xkcd.com/1447">the point</a>.</p> <p>When it comes to controlling instance creation from the metaclass, <code>__new__</code> is no longer sufficient – we need to override <code>__call__</code> instead. An easy way to remember this: <code>__new__</code> is triggered when a <em>new</em> class is created; <code>__call__</code> is triggered when a new instance is created via the <em>call</em>-like syntax on the class object. This works the same way as when <code>__new__</code> and <code>__call__</code> magic methods are implemented on normal classes, with the former controlling instance creation and the latter making instances callable.</p> <p>To see how these methods work together, take a look at the following snippet:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">six</span>

<span class="k">class</span> <span class="nc">M</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'metaclass::new'</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">meta</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'metaclass::call'</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">'---'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">M</span><span class="p">)):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'class::new'</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'class::init'</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'class::call'</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>


<span class="k">print</span><span class="p">(</span><span class="s">'---'</span><span class="p">)</span>
<span class="n">instance</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="s">'foo'</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'---'</span><span class="p">)</span>
<span class="n">instance</span><span class="p">(</span><span class="s">'bar'</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></code></pre></div> <p>The output looks like this:</p> <div class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">metaclass::new</span>
<span class="go">---</span>
<span class="go">metaclass::call ('foo',) {'x': 1}</span>
<span class="go">class::new ('foo',) {'x': 1}</span>
<span class="go">class::init ('foo',) {'x': 1}</span>
<span class="go">---</span>
<span class="go">class::call ('bar',) {'y': 2}</span></code></pre></div> <p>Back to our singleton class, we’ll need to override <code>__call__</code> in the metaclass to intercept the instance constructor and return the existing instance which can be stored in the class itself. If this instance doesn’t exist yet, we can create it by calling <code>super</code> which in its turn will call the class constructor if it’s defined.</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">six</span>

<span class="k">class</span> <span class="nc">Singleton</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">meta</span><span class="p">)</span> <span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">'Cannot inherit from singleton class'</span><span class="p">)</span>
        <span class="n">clsdict</span><span class="p">[</span><span class="s">'_instance'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Singleton</span><span class="p">,</span> <span class="n">meta</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_instance</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Singleton</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_instance</span>

<span class="nd">@six.add_metaclass</span><span class="p">(</span><span class="n">Singleton</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">a</span> <span class="ow">is</span> <span class="n">b</span>  <span class="c"># all new instances point to the same object</span>

<span class="k">try</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="k">pass</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span>  <span class="c"># cannot inherit from singleton</span></code></pre></div> <p>The implementation is quite simple and transparent, although there’s surely some room for improvement – for instance, <code>__call__</code> method only cares about the arguments it receives the very first time it’s called; every other time it is just going to return the cached instance unconditionally.</p> <h2 id="generating-descriptors">Generating descriptors</h2> <p>Another common use of metaclasses is to automate creation of descriptors. In Python, <em>descriptor</em> is any object that implements at least one of the following methods: <code>__get__</code>, <code>__set__</code> or <code>__delete__</code>.</p> <p>Descriptors control attribute access, and the default behaviour is to get, set or delete an attribute from object’s dictionary. Here’s a naïve implementation:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Descriptor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="k">del</span> <span class="n">instance</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Descriptor</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">'x'</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span>
<span class="k">del</span> <span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">'x'</span><span class="p">)</span></code></pre></div> <p>This may seem like an overkill as we could have just done away with instance variables here. However, descriptors come in handy when we want to inject any additional logic into get, set or delete methods. For example, it is entirely possible to reimplement <code>property</code>, <code>classmethod</code> and <code>staticmethod</code> builtins using field descriptors.</p> <p>Why did we have to pass string<code>'x'</code> to <code>Descriptor</code> explicitly? The reason for this is quite simple – on the one hand, the descriptor needs to know the name of the attribute it is bound to so it can find it in the object’s <code>__dict__</code>, but at the moment of instantiation it cannot reference the class dict because it doesn’t exist yet! In a way, it’s sort of the same as when we assign <code>a = A()</code> and there is no way of telling <code>A</code> that it is going to be assigned to anything, let alone deducing the variable name.</p> <p>Here’s where the metaclasses come in – right before the type is created, we have the full class dict at our disposal, so we can replace certain fields with named descriptors if we want to.</p> <p>In the next example, we will implement a base class whose subclasses can use special syntax to generate typed attributes with default values. Given a class that is defined like so:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Typed</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span>
    <span class="n">y</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span> <span class="s">'foo'</span></code></pre></div> <p>we want <code>x</code> to be an integer attribute with default value of <code>None</code>, and <code>y</code> a string attribute with default value of <code>'foo'</code>. When assigned to, both fields should try to coerce the given values to <code>int</code> and <code>str</code>, respectively.</p> <p>Here is one possible implementation.</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">six</span>

<span class="k">class</span> <span class="nc">Descriptor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls</span> <span class="o">=</span> <span class="n">cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c"># convert the value to `cls` and write to instance dict</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
        <span class="c"># retrieve the value from instance dict</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="n">_types</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">clsdict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">_types</span><span class="p">:</span>
                <span class="c"># a type with no default</span>
                <span class="n">clsdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Descriptor</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">_types</span><span class="p">:</span>
                    <span class="c"># a type and a default value</span>
                    <span class="n">clsdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Descriptor</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Meta</span><span class="p">,</span> <span class="n">meta</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Typed</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">Meta</span><span class="p">)):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Typed</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span>
    <span class="n">y</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span> <span class="s">'foo'</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="s">'42'</span>
<span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">42</span>
<span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="s">'foo'</span>
<span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">42</span>
<span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="s">'42'</span></code></pre></div> <p>Note that we still had to pass field names to <code>Descriptor</code>, but this time it was done automatically by the metaclass, with names simply being equal to the keys in the class dict. This is one of the points of using metaclasses in the first place – do all of the hard work in the metaclass so the user code can be simplified.</p> <p>If you ever wondered how the fancy frameworks like <code>sqlalchemy</code> or <code>django</code> are implemented, where schema definitions look very concise way but there’s a lot going under the hood, this toy example could be a good starting point.</p> </div> </div></body></html>