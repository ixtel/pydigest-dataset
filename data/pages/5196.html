<html><body><div><div class="post-body entry-content" id="post-body-7538005257693128211" itemprop="description articleBody"><p>
Recently I worked on a program which required me to filter hundred of lines of blog titles. Throughout the assignment I stumbled upon a few interesting problems, some of which are outlined in the following paragraphs. </p>

<h3>Non Roman characters issue</h3><p>During the testing session I missed one title and investigating why it happened, I found that it was simply because the title contained non-Roman characters.
</p><p>
Here is the code's snippet that I was previously using:

</p><pre class="brush:python">for e in results:                                                                                                                        
    simple_author=e['author'].split('(')[1][:-1].strip()                                                             
    if freqs.get(simple_author,0) &lt; 1:                                                                                               
        print parse(e['published']).strftime("%Y-%m-%d") , "--",simple_author, "--", e['title']
</pre><p>
And here is the fixed version

</p><pre class="brush:python">for e in results:                                                                                                                        
    simple_author=e['author'].split('(')[1][:-1].strip().encode('UTF-8')                                                             
    if freqs.get(simple_author,0) &lt; 1:                                                                                               
        print parse(e['published']).strftime("%Y-%m-%d") , "--",simple_author, "--", e['title'].encode('UTF-8') 
</pre><p>
To fix the issue I faces I added .encode('UTF-8') in order to encode the characters with the UTF-8 encoding. Here is an example title that would have been otherwise left out:

</p><pre class="brush:bash">2014-11-18 -- Unknown -- Novo website do Liquid Galaxy em PortuguÃªs!</pre><p>
Python 2.7 uses ASCII as its default encoding but in our case that wasn't sufficient to scrape web contents which often contains UTF-8 characters. To be more precise, this program fetches an RSS feed in XML format and in there it finds UTF-8 characters. So when the initial Python code I wrote met UTF-8 characters, while using ASCII encoding as the default sets, it was unable to identify them and returned an error.
</p><p>
Here is an example of the parsing error it gave us while fetching non-roman characters while using ASCII encoding:
</p><pre class="brush:bash">UnicodeEncodeError: 'ascii' codec can't encode character u'\xea' in position 40: ordinal not in range(128)</pre>
<h3>Right and Left text alignment</h3><p>
In addition to the error previously mentioned, I also had the chance to dig into several ways of formatting output.</p><p>
The following format is the one I used as the initial output format:

</p><pre class="brush:python">print("Name".ljust(30)+"Age".rjust(30))
Name                                                     Age</pre>
<h4>Using "ljust" and "rjust" method</h4><p>
I want to improve the readability in the example above by left-justify "Name" by 30 characters and "Age" by another 30 characters distance.
</p><p>
Let's try with the '*' fill character. The syntax is str.ljust(width[, fillchar])

</p><pre class="brush:python">print("Name".ljust(30,'*')+"Age".rjust(30))
Name**************************                           Age</pre><p>
And now let's add .rjust:

</p><pre class="brush:python">print("Name".ljust(30,'*')+"Age".rjust(30,'#'))
Name**************************###########################Age</pre><p>
By using str, it counts from the left by 30 characters including the word "Name" which has four characters</p><p>
and then another 30 characters including "Age" which has three letters, by giving us the desired output.

</p><h4>Using "format" method</h4><p>
Alternatively, it is possible to use the same indentation approach with the </p><i>format</i><p> string method:

</p><pre class="brush:python">print("{!s:{fill}}".format("Name", "Age",fill=30))
Name                                                     Age</pre><p>
And with the same progression, it is also possible to do something like:

</p><pre class="brush:python">print("{!s:*{fill}}".format("Name", "Age",fill=30))
Name**************************                           Age
print("{!s:*{fill}}".format("Name", "Age",fill=30))
Name**************************###########################Age
</pre><p>
"format" also offers a feature to indent text in the middle. To put the desired string in the middle of the "fill" characters trail, simply use the ^ (caret) character:
</p><pre class="brush:python">print("{!s:*^{fill}}{!s:#^{fill}}".format("Age","Name",fill=30))
*************Age**************#############Name#############</pre><p>
Feel free to refer the Python's documentation on Unicode here:
</p><blockquote cite="https://docs.python.org/2/howto/unicode.html">https://docs.python.org/2/howto/unicode.html</blockquote><p>
And for the "format" method it can be referred here:
</p><blockquote cite="https://www.safaribooksonline.com/library/view/python-cookbook-3rd/9781449357337/ch02s13.html">https://www.safaribooksonline.com/library/view/python-cookbook-3rd/9781449357337/ch02s13.html</blockquote>
<p/>
</div>
</div></body></html>