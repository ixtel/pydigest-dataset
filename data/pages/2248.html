<html><body><div><div class="entry-content">
					<p><a href="http://www-staging.loggly.com/wp-content/uploads/2014/11/20141121_MatthewSetter20141204_MatthewSetterPt2_Blog.png" class="vt-p"><img class="aligncenter size-full wp-image-6401" src="http://www-staging.loggly.com/wp-content/uploads/2014/11/20141121_MatthewSetter20141204_MatthewSetterPt2_Blog.png" alt="Taking Advantage of Built-in Logging In PHP, Ruby, And Python Header"/></a></p>
<p>In <a href="https://www.loggly.com/blog/four-key-considerations-guide-logging-approach-php-python-ruby/" class="vt-p">part one of this series</a>, we discussed how logging is the foundation for solving operational problems with software. We established that there always needs to be sufficient information on hand to deal with these problems when they occur. But what should we log? Do we flood log servers with everything and anything? Do we keep logging to a bare minimum? Or do we aim somewhere in the middle?  But theory is one thing; at some stage, we need to look at logging in practice.</p>
<p>Here in part two of the series, we’ll look at some of the pros and cons of using the built-in logging options available in three of the most popular development languages: <i>PHP</i>, <i>Python</i>, and <i>Ruby, </i>along with accompanying code examples.</p>
<h2><b>Logging with PHP</b></h2>
<p>I’ll start with <a href="https://www.loggly.com/docs/php-logs/">PHP logging</a>, as it’s my preferred language. Out of the box, PHP doesn’t have the same level of error logging functionality available as either Python or Ruby. Comprised of two core functions, <a href="http://php.net/manual/en/function.error-log.php" class="vt-p" title="PHP Error Log" target="_blank">error_log</a> and <a href="http://php.net/manual/en/function.trigger-error.php" class="vt-p" title="PHP Trigger Error" target="_blank">trigger_error</a>, PHP is able to log errors which occur, based on a range of severity levels, which you can find <a href="http://php.net/manual/en/errorfunc.constants.php" class="vt-p" title="PHP Manual" target="_blank">in the PHP manual</a>.</p>
<p>These can be fatal errors, such as memory allocation issues, script parsing issues, compile time warnings, user generated warnings and more. Based on the PHP runtime configuration, error logs can be written to a file on the filesystem or sent to a Syslog server, except if the operating system is Windows.</p>
<p>Alternatively, there’s <a href="http://php.net/manual/en/function.syslog.php" class="vt-p" title="PHP function syslog" target="_blank">the syslog function</a>, which can send a message, along with an accompanying <a href="http://php.net/manual/en/function.syslog.php" class="vt-p" title="php function syslog" target="_blank">priority level</a>, to a local <a href="https://www.loggly.com/docs/php-logs/" class="vt-p" title="Loggly PHP Logs" target="_blank">or remote Syslog server</a>, or  alternatively the Windows NT EventLog.</p>
<p>So let’s look at a code sample. Below is a simple function, <em>logData</em>, which will open a connection to a Syslog daemon, write a message with an emergency priority level, then close the connection afterwards.</p>
<p>The logged information will look like the following:</p>
<p>You can see from this example, it’s easy to take textual information and log it as and when needed; from a simple string to a more complex JSON or serialized object.</p>
<p>However, how do you differentiate between environments, such as <i>development</i>, <i>testing</i>, <i>staging</i> and <i>production</i>? How do you set a minimum log priority level? How do you log to multiple places at once, such as email servers, filesystems, and SNMP traps? Using just error_log or syslog, PHP is not able to do this.</p>
<h2><b>Logging with Ruby</b></h2>
<p>When I said that PHP, out the box, doesn’t have the same level of error logging functionality available, I wasn’t meaning to be disingenuous. PHP is quite rich in functionality. But both Ruby and Python offer greater flexibility natively.</p>
<p>Using the built-in <a href="http://www.ruby-doc.org/stdlib-2.1.0/libdoc/logger/rdoc/Logger.html" class="vt-p" title="Ruby Logger Class" target="_blank">Logger class</a>, <a href="https://www.loggly.com/docs/ruby-logs/">Ruby can log messages</a> to a variety of locations, including STDERR, STDOUT, or a file on the filesystem. It can also specify a priority level, including <i>debug</i>, <i>info</i>, <i>warn</i>, <i>error</i>, <i>fatal</i>, and <i>unknown</i>.</p>
<p>These capabilities provide the ability to log for a wide variety of purposes, from the simple to the critical. They make it easier to differentiate amongst the information logged, speeding up search. But what’s especially nice about Ruby’s built-in logging library, is that messages can also be formatted. By default, messages are written with the format below:</p>
<p>This will result in a message like the following:</p>
<p>Taking an example from the Ruby docs (v 2.1.0), we could change the format by setting the formatter as follows:</p>
<p>Given this functionality, based on what is being logged, the application is not forced into a one-size fits all approach. With it, you can write in a format which best suits the needs of the given event and application.</p>
<p>With the code above, we’ve defined a new Logger which will write to the console, along with a format of the timestamp when the message was written, followed by the message. If the message is written with at least a priority of warn, then it will be written out, otherwise it will be ignored.</p>
<p>This will result in a message, such as the one below, being written to stderr:</p>
<p/>
<h2><b>Logging with Python</b></h2>
<p>Now, let’s take a look at Python. Of all three languages, Python is the most natively feature-rich. Possessing the core logging functionality of the other two, and the formatting ability of Ruby, Python additionally combines 11 handlers, which determine where the information logged will be sent.</p>
<p>Taken from <a href="https://docs.python.org/2/library/logging.handlers.html" class="vt-p" title="Python Log Handlers" target="_blank">the Python documentation</a>, these are:</p>
<table>
<tbody>
<tr>
<td>StreamHandler</td>
<td>Sends logging output to streams such as sys.stdout, sys.stderr or any file-like object (or, more precisely, any object which supports write() and flush() methods).</td>
</tr>
<tr>
<td>FileHandler</td>
<td>Sends logging output to a disk file</td>
</tr>
<tr>
<td>RotatingFileHandler</td>
<td>Supports rotation of disk log files</td>
</tr>
<tr>
<td>TimedRotatingFileHandler</td>
<td>Supports rotation of disk log files at certain timed intervals</td>
</tr>
<tr>
<td>SocketHandler</td>
<td>Sends logging output to a network socket. The base class uses a TCP socket.</td>
</tr>
<tr>
<td>DatagramHandler</td>
<td>Supports sending logging messages over UDP sockets.</td>
</tr>
<tr>
<td>SysLogHandler</td>
<td>Supports sending logging messages to a remote or local Unix syslog.</td>
</tr>
<tr>
<td>NTEventLogHandler</td>
<td>Supports sending logging messages to a local Windows NT, Windows 2000 or Windows XP event log</td>
</tr>
<tr>
<td>SMTPHandle</td>
<td>Supports sending logging messages to an email address via SMTP.</td>
</tr>
<tr>
<td>MemoryHandler</td>
<td>Supports buffering of logging records in memory, periodically flushing them to a target handler. Flushing occurs whenever the buffer is full, or when an event of a certain severity or greater is seen.</td>
</tr>
<tr>
<td>HTTPHandler</td>
<td>Supports sending logging messages to a Web server, using either GET or POST semantics.</td>
</tr>
</tbody>
</table>
<p>In addition to the handlers Python also provides filters, which afford a greater level of control over which log records are sent to a given handler. If you’re interested in an in-depth discussion, check out <a href="http://www.onlamp.com/pub/a/python/2005/06/02/logging.html" class="vt-p" title="Python log handler" target="_blank">Jeremy Jones’ post</a>. These two features provide a very rich level of control. For example, in production you may only write logs of level warning or above <a href="https://www.loggly.com/blog/five-things-every-developer-know-syslog/" class="vt-p" title="Loggly 5 things every developer should know about syslog">to a syslog server</a>. But in development, you may want to display information to stdout starting at debug level, providing extra information to developers. Alternatively, in production, you may have a greater need for data retention, so that records <a href="https://www.loggly.com/blog/search-your-logs-log-management/" class="vt-p" title="Loggly: How to: Search Your Logs in the Real World of Log Management">can be searched over a historical basis</a>; which isn’t required in development or staging. Let’s now revisit the previous example using Python. In this, we’ll see something which the others can do with external libraries, but not natively. That is, add multiple handlers to a logger. Say for example, you’re writing a web-based application. Depending on the environment, you’ll have different logging needs, and a one size fits all can be quite limiting.</p>
<p>In the above example, courtesy of <a href="https://docs.python.org/2/howto/logging-cookbook.html" class="vt-p" title="Python Cookbook" target="_blank">the Python Cookbook</a>, a logger has been set up with the minimum log level recorded to debug level. Then, two log handlers are added; the first one writes to a log file and the second to a stream, which is STDERR. However, the stream handler will only output errors at a priority of error or above.</p>
<p>Next a formatter is applied, which will print out the time, the logger’s defined name, the priority level and the message. Now, with just one log call, information can be sent to multiple locations transparently, simplifying code required, directly impacting on application maintainability.</p>
<p>For more information, check out Loggly’s documentation on <a href="https://www.loggly.com/docs/python-syslog/">sending Python logs over syslog</a> and <a href="https://www.loggly.com/docs/python-http/">over HTTP</a>.</p>
<h2><b>Wrapping Up</b></h2>
<p>And that’s an overview of the built-in logging features of <i>PHP</i>, <i>Ruby</i>, and <i>Python</i>. To be fair, I’ve not been able to be to cover each language in-depth. But I hope you see the comparative, strengths of each one’s out-of-the-box capabilities.</p>
<p>In normal development, you’re not going to limit yourself to just the built-in options, but use the full complement of options at your disposal. But as you can see, there’s a bit of difference between the native capabilities of each one.</p>
<p>In the <a href="https://www.loggly.com/blog/privacy-security-performance-logging/" title="How to Solve Privacy, Security and Performance In Logging" class="vt-p">next part in the series</a>, we’ll be looking at the logging libraries available in each of the three languages. For PHP-specifically, you’ll see how it is able to match the sophistication of Python.</p>
<p><i>But till then, what’s your approach to logging across environments?</i></p>
<h2>Additional Reading</h2>

<hr/>
<p class="p1"><strong>Keep Reading This Series</strong></p>
<p class="p1"><a href="https://www.loggly.com/blog/four-key-considerations-guide-logging-approach-php-python-ruby/" title="Four Key Considerations to Guide Your Logging Approach in PHP, Python, or Ruby" class="vt-p">«PART 1: Four Key Considerations to Guide Your Logging Approach in PHP, Python, or Ruby</a></p>
<p class="p1"><a href="https://www.loggly.com/blog/privacy-security-performance-logging/" title="How to Solve Privacy, Security and Performance In Logging" class="vt-p">PART 3: How to Solve Privacy, Security and Performance In Logging »</a></p>
<p> </p>
					
				</div>


				</div></body></html>