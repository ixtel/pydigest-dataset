<html><body><div><div class="post-text" itemprop="text">
<p>You can access the features by using the <code>feature_count_</code> property. This will tell you how many times a particular feature occurred. For example:</p>

<pre><code># Imports
import numpy as np
from sklearn.naive_bayes import MultinomialNB

# Data
X   = np.random.randint(3, size=(3, 10))
X2  = np.random.randint(3, size=(3, 10))
y   = np.array([1, 2, 3])

# Initial fit
clf = MultinomialNB()
clf.fit(X, y)

# Check to see that the stored features are equal to the input features
print np.all(clf.feature_count_ == X)

# Modify fit with new data
clf.partial_fit(X2, y)

# Check to see that the stored features represents both sets of input
print np.all(clf.feature_count_ == (X + X2))
</code></pre>

<p>In the above example, we can see that the <code>feature_count_</code> property is nothing more than a running sum of the number of features for each class. Using this, you can go backwards from your classifier model to your features, to determine the frequency of your features. Unfortunately, your problem is more complex, you now need to go back one more step, as your features are not simply words.</p>

<p>This is where the bad news comes - you used a <code>HashingVectorizer</code> feature extractor. If you refer to <a href="http://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.HashingVectorizer.html" rel="nofollow">the docs</a>: </p>

<blockquote>
  <p>there is no way to compute the inverse transform (from feature indices to string feature names) which can be a problem when trying to introspect which features are most important to a model.</p>
</blockquote>

<p>So even though we know the frequency of the features, we can't translate those features back to words. Had you used a different type of feature extractor (perhaps the one referenced on that same page, <code>CountVectorizer</code>) the situation would be different entirely.</p>

<p>In short - You can extract the features from the model and determine their frequency by class, but you can't convert those features back to words.</p>

<p>To obtain the functionality you desire you would need to start over using a reversible mapping function (a feature extractor that allows you to encode words into features and decode features back into words).</p>
    </div>
    </div></body></html>