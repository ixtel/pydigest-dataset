<html><body><div><div class="all_external_links">
          <p>This post talks about a neat trick for simplifying program flow in Python. If you know Haskell, you'll recognize it as the Maybe monad. If you're more of a Scala or OCaml type of person, it's an Option. If OOP and design patterns rock your boat, it looks eerily like the Null Object Pattern.</p>

<p>Here's a problem to start with: imagine you have a function that deals with several variables. For example, it might do a calculation or perform some I/O based on the variables. One (or more) of them may be not supplied, not valid, unknown, or have to be similarly special-cased.</p>

<p>The naive code might look like:</p>
<div class="highlight"><pre><span class="n">foo</span> <span class="o">=</span> <span class="n">get_foo</span><span class="p">()</span> <span class="c"># may return None if we can't get 'foo'</span>
<span class="n">foo_squared</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">*</span> <span class="n">foo</span>
<span class="n">bar</span> <span class="o">=</span> <span class="o">...</span> <span class="c"># doesn't depend on foo</span>
<span class="n">baz</span> <span class="o">=</span> <span class="n">foo_squared</span> <span class="o">*</span> <span class="n">bar</span>
<span class="k">print</span> <span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="p">,</span> <span class="n">baz</span>
</pre></div>
<p>This doesn't handle the fact that <code>foo</code> might not be known (ie. have the value of <code>None</code> here), in case the program will happily crash.</p>

<p>No worries, we'll just add checks where appropriate, right?</p>
<div class="highlight"><pre><span class="n">foo</span> <span class="o">=</span> <span class="n">get_foo</span><span class="p">()</span> <span class="c"># may return None if we can't get 'foo'</span>

<span class="k">if</span> <span class="n">foo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">foo_squared</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">foo_squared</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">*</span> <span class="n">foo</span>

<span class="n">bar</span> <span class="o">=</span> <span class="o">...</span> <span class="c"># doesn't depend on foo</span>

<span class="k">if</span> <span class="n">foo_squared</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">baz</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">baz</span> <span class="o">=</span> <span class="n">foo_squared</span> <span class="o">*</span> <span class="n">bar</span>

<span class="k">print</span> <span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="p">,</span> <span class="n">baz</span>
</pre></div>
<p>This works correctly (unless I made a mistake), but is ugly and the actual calculation we tried to do is hidden between the special-case checks. In this small example, the calculation can be reordered to simplify it a bit - finding more complex examples of the same problem in real-world code is left as an exercise for the reader.</p>

<p>Instead, let's define something called <em>Maybe</em>, that can be either <em>Nothing</em> (which means, there's no value of interest), or <em>Just(value)</em> if it does hold a useful value. Further more, let's define that any operation that involves a <em>Nothing</em> immediately results in Nothing. Operations that involve a <em>Just(value)</em> will compute the result as usual, but then additionally wrap it again in <em>Just</em>, to produce <em>Just(value)</em>.</p>

<p>The above function then looks something like:</p>
<div class="highlight"><pre><span class="n">foo</span> <span class="o">=</span> <span class="n">maybe_get_foo</span><span class="p">()</span>  <span class="c"># returns  Just(&lt;value&gt;) or Nothing</span>
<span class="n">foo_squared</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">*</span> <span class="n">foo</span>
<span class="n">bar</span> <span class="o">=</span> <span class="o">...</span> <span class="c"># doesn't depend on foo</span>
<span class="n">baz</span> <span class="o">=</span> <span class="n">foo_squared</span> <span class="o">*</span> <span class="n">bar</span>
<span class="k">print</span> <span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="p">,</span> <span class="n">baz</span>
</pre></div>
<p>Much better.</p>

<p>How hard it is to define such a construct in Python? As it turns out, not that hard. Here's a complete implementation, with documentation, tests and a license, in less than 250 lines - <a href="https://gist.github.com/senko/4b09ad285340c8ec2661">maybe.py</a>. It doesn't cover <em>all</em> the operators possible (patches welcome), but it does cover most of the usual suspects.</p>

<p>Functional programming aficionados will probably balk both at the implementation and the usage. There's objects, operator overloading, metaclasses and magic mocking of attributes and function calls. And stuff like this works:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">Just</span><span class="p">(</span><span class="s">'hello'</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="n">Just</span><span class="p">(</span><span class="s">'HELL'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Just</span><span class="p">(</span><span class="n">Nothing</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="n">Nothing</span>
</pre></div>
<p>Is it really a monad, then? Yes, it is - the relevant axioms hold (see the docstrings). However, it doesn't try to shoehorn Lisp, Haskell or Scala syntax into Python (if you're into that, <a href="http://www.infoq.com/articles/fn.py-functional-programming-python">fn.py</a> might be of interest). It uses Python's strengths instead of awkwardly stepping around its "not really a functional programming language" limitations.</p>

<p>And that's why it was fun to write.</p>

        </div>
        </div></body></html>