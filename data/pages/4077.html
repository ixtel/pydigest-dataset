<html><body><div><div id="main_content">
  <p><em><a href="/algods/">Algorithms &amp; Data Structures</a> is an ongoing series in which I explore interesting data structures and algorithms, because they're fun.</em></p>

<p>Most of us have interacted with tries (which I pronounce "try" but some which people pronounce "tree," which strikes me as incredibly confusing) in the form of typeaheads, where you type the beginning of something and it offers you a selection of possible values that start with what you typed. Tries, also known as prefix trees, are an easy way to encode values that share a common prefix, and easily query which values share a given prefix. They're also just simple trees, which makes them easy to understand.</p>

<h2>Thinking about tries</h2>

<p>Imagine you have an array of ASCII strings. It's a large array. Millions of items. And you want to find all of the strings that start with the letters 'foo.' No problem, just loop through them and print the words that match.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">word</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'foo'</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">word</span><span class="p">)</span></code></pre></div>

<p>Simple, straightforward, and painfully slow. On a modern computer, with a million strings, it probably doesn't take very long, but still -- what if you need to search for a couple of hundred such prefixes. Maybe a couple thousand prefixes. Maybe there are a billion strings. That O(<em>n</em>) time complexity starts to look sub-optimal pretty quickly.</p>

<p>A trie can do much better. Search is also done in linear time, but it's linear to the length of the <em>key</em>, not the length of the array to be searched. So the time complexity of searching a thousand strings for examples that start with 'foo' and searching a billion strings for the same prefix are roughly the same (though creating the trie for a billion items is going to take quite a bit longer than creating the trie for a thousand items, so you want to make sure you're in a place where you can build the trie once and search it many many times). </p>

<p><img src="/public/images/trie_example.svg"/>On the right is a trie storing the strings <em>foo</em>, <em>foobar</em>, and <em>foobaz</em>. It's pretty easy to see how this works from the example. </p>

<h3>Inserting a new string into a trie</h3>

<ol>
<li>Set the current node as the root node.</li>
<li>Set the current character as the first character of the string.</li>
<li>Does one of the current node's children encode the current character? 

<ol>
<li>If yes, then set the current node to that child, and set the current character to be the next character in the string.</li>
<li>If no, then add a child to encode the current character, set the current node to that newly created node, and the current character to be the next character in the string.</li>
</ol></li>
<li>Go back to Step 3 until you're out of characters in the string.</li>
</ol>

<p>Pretty simple and straightforward. In this example we store a stop value (maybe a <code>None</code>) as a child to indicate that the string is complete, but in real life you might store values as children that are associated with the string.</p>

<h3>Searching for a string in a trie</h3>

<p>Searching for a string in a trie is basically the same as inserting one, except that instead of adding a new node when you encounter a character that isn't encoded, you return a <code>False</code> value indicating that the string isn't found. If you get to the end of the string and there's not an indicator that this complete string exists (a <code>None</code> as a child, in this example), then return <code>False</code>. Otherwise, return <code>True</code>. This is simple enough that I'm not going to delve too much into it here, but there is code further down.</p>

<h3>Finding all strings that begin with a given prefix</h3>

<p>This is where tries shine. Given a prefix, it's simple to find all encoded values that begin with that prefix. Since all complete strings end with a leaf node, what you want to do is as quickly and easily as possible get to the leaves of all subtrees rooted at the end of the given prefix. This is a perfect place to use a <a href="/sweiqotd/2015/04/12/describe-the-most-common-ways-to-traverse-a-tree/">depth-first search</a> (though since your goal is to visit every leaf, a breadth-first search would work just as well -- if your goal was to find the first value in the subtree that fit some criteria, you'd opt for depth-first search without question so that you could quickly short-circuit the search once a matching value was found). Then return a list of all strings found.</p>

<h2>Onto the code!</h2>

<p>After all of the above narrative, I think the code will be pretty straightforward.</p>

<h3>TrieNode class</h3>

<p>Nothing particularly interesting aobut the <code>TrieNode</code> class. Note that I'm using a dictionary to hold the children, so that I can easily reference them by their value, rather than having to iterate through a list of children to see if a particular value was already a child of the current node. This will save a lot of time and effort down the road.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">TrieNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">{}</span></code></pre></div>

<h3>Trie class</h3>

<p>I decided to create a <code>Trie</code> class to hold the tree's root, and to give a convenient spot to attach functions that manipulate the trie. Right now, we'll just define the <code>__init__</code> function, which simply creates a dummy root node for the rest of the trie to build from.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Trie</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span></code></pre></div>

<h3>Adding a string</h3>

<p>Adding a new string to the trie is simple. Loop through the characters one by one and try to use existing nodes, but when a node doesn't exist for the path you're taking create a new node and keep going. Note that at the end a <code>None</code> key is inserted to indicate that it's the end of the word. That way you can tell if 'foobar' has been entered but 'foo' is not -- even though there are the nodes [f]-[o]-[o], there won't be a <code>None</code> value to indicate that a string actually ended there. Note also that this is an instance function of the <code>Trie</code> class (as are the other functions below), but the rest of the function's definition has been elided.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Trie</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c"># [...]</span>
    <span class="k">def</span> <span class="nf">add_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_node</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">new_node</span>
        <span class="k">if</span> <span class="bp">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span></code></pre></div>

<h3>Testing membership</h3>

<p>How do you know if a particular string has been encoded in the trie? You should be able to follow the same route that the creation function above did, but instead of creating a new node when you discover that one doesn't exist, you can just return false, because if the string you're looking for was in the trie you'd never be missing a node. </p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Trie</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c"># [...] </span>
    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">None</span> <span class="ow">in</span> <span class="n">current</span><span class="o">.</span><span class="n">children</span></code></pre></div>

<p>Clearly some code could be shared between these two functions (and, really, the one below as well), because so many operations on a trie involve navigating through the trie based on a given string, and then doing something when you either can or can't find a path.</p>

<h3>Searching for strings contains a prefix</h3>

<p>This our trie's real meat and potatoes functionality (and, not unsurprisingly, the most complex. It starts off the same as <code>contains</code>, trying to find a route that encodes the given prefix, but instead of stopping there it then uses that node as the root of a depth-first search through the remaining nodes. Two things of note:</p>

<ol>
<li>Because each node only contains a single letter of the string that created it, there's no way for it to know what the substring encoded by the nodes before it was. Because of that, when you process each node you also need to provide the substring seen so far. This is done by pushing a tuple containing the next node to process and the substring that preceded that node into the deque.</li>
<li>Remember that strings are terminated by a <code>None</code> key. Thus the special handling for the <code>None</code> case -- it's what indicates that this particular branch of the search is complete and the substring that has been found thus far is actually the entire string.</li>
</ol>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Trie</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c"># [...]</span>
    <span class="k">def</span> <span class="nf">starts_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">prefix</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">current</span><span class="p">,</span> <span class="n">prefix</span><span class="p">)])</span>
        <span class="k">while</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">prefix</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">key</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">results</span></code></pre></div>

<h2>Takeaways</h2>

<p>Tries are awesome. Though like most tutorials I just used strings for this example, tries are useful any time a series of values needs to be used to look up some other value. Another place you could use them, for instance, is tracking users going through a particular set of screens -- encoded as a trie, it's trivial to see the various paths taken by users once they hit a particular screen.</p>

<p>The downside of a trie is, of course, size. Compared to a single character, a <code>TrieNode</code> is pretty hefty. While the relative size increase goes down as more data is encoded (because, especially if you're encoding strings of real words, patterns repeat quite heavily). There are options for dealing with this that make tries more efficient (at the cost of simplicity), but those are topics for another day.</p>

  </div>

  
  <p>If you enjoyed this post, please share it with others who would also enjoy it.</p>
  </div></body></html>