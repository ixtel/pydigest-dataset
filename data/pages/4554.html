<html><body><div><div class="post-text" itemprop="text">
<p>Because <code>[]</code> and <code>{}</code> are <em>literal syntax</em>. Python can create bytecode just to create the list or dictionary objects:</p>

<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(compile('[]', '', 'eval'))
  1           0 BUILD_LIST               0
              3 RETURN_VALUE        
&gt;&gt;&gt; dis.dis(compile('{}', '', 'eval'))
  1           0 BUILD_MAP                0
              3 RETURN_VALUE        
</code></pre>

<p><code>list()</code> and <code>dict()</code> are separate objects. Their names need to be resolved, the stack has to be involved to push the arguments, the frame has to be stored to retrieve later, and a call has to be made. That all takes more time.</p>

<p>For the empty case, that means you have at the very least a <a href="https://docs.python.org/2/library/dis.html#opcode-LOAD_NAME"><code>LOAD_NAME</code></a> (which has to search through the global namespace as well as the <a href="https://docs.python.org/2/library/__builtin__.html"><code>__builtin__</code> module</a>) followed by a <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>, which has to preserve the current frame:</p>

<pre><code>&gt;&gt;&gt; dis.dis(compile('list()', '', 'eval'))
  1           0 LOAD_NAME                0 (list)
              3 CALL_FUNCTION            0
              6 RETURN_VALUE        
&gt;&gt;&gt; dis.dis(compile('dict()', '', 'eval'))
  1           0 LOAD_NAME                0 (dict)
              3 CALL_FUNCTION            0
              6 RETURN_VALUE        
</code></pre>

<p>You can time the name lookup separately with <code>timeit</code>:</p>

<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit('list', number=10**7)
0.30749011039733887
&gt;&gt;&gt; timeit.timeit('dict', number=10**7)
0.4215109348297119
</code></pre>

<p>The time discrepancy there is probably a dictionary hash collision. Subtract those times from the times for calling those objects, and compare the result against the times for using literals:</p>

<pre><code>&gt;&gt;&gt; timeit.timeit('[]', number=10**7)
0.30478692054748535
&gt;&gt;&gt; timeit.timeit('{}', number=10**7)
0.31482696533203125
&gt;&gt;&gt; timeit.timeit('list()', number=10**7)
0.9991960525512695
&gt;&gt;&gt; timeit.timeit('dict()', number=10**7)
1.0200958251953125
</code></pre>

<p>So having to call the object takes an additional <code>1.00 - 0.31 - 0.30 == 0.39</code> seconds per 10 million calls.</p>

<p>You can avoid the global lookup cost by aliasing the global names as locals (using a <code>timeit</code> setup, everything you bind to a name is a local):</p>

<pre><code>&gt;&gt;&gt; timeit.timeit('_list', '_list = list', number=10**7)
0.1866450309753418
&gt;&gt;&gt; timeit.timeit('_dict', '_dict = dict', number=10**7)
0.19016098976135254
&gt;&gt;&gt; timeit.timeit('_list()', '_list = list', number=10**7)
0.841480016708374
&gt;&gt;&gt; timeit.timeit('_dict()', '_dict = dict', number=10**7)
0.7233691215515137
</code></pre>

<p>but you never can overcome that <code>CALL_FUNCTION</code> cost.</p>
    </div>
    </div></body></html>