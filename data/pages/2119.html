<html><body><div><div class="entry-content">
                <p>The vast majority of us carry a little GPS device in our pockets all day long, quietly recording our location. But location is more than just latitude and longitude; it can tell us about our speed, our direction, our activities, and frankly our lives. Some people regard this as terrifying, but I see a wonderful dataset.</p>
<p>Initially, I didn't have much of a drive to fiddle with my own location history. What could I really do that Google Latitude couldn't already? But after Latitude's <a href="https://support.google.com/gmm/answer/3001634?hl=en">demise</a> in 2013, I entered full fiddle-around mode, and quickly discovered the incredible array of tools that Python puts at your disposal to easily and beautifully manipulate geospatial data.</p>
<p>This blog post focuses on how to analyze your location history data and produce some cool maps to visualize how you spend your time. Of course, there are 1,000,001 more ways to utilize location history, but hopefully this post gives you the tools to pursue those other ideas. </p>
<p>If you're not interested in the learning the code to make these graphs but know me personally, stick around. You might even learn a thing or two about me.</p>
<p>To follow this post, you'll need a bunch of Python packages. </p>

<p>And of course, all this code will be executed using <a href="http://ipython.org">IPython</a>, my best friend. Here's my import list for this tutorial.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.basemap</span> <span class="kn">import</span> <span class="n">Basemap</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPoint</span><span class="p">,</span> <span class="n">MultiPolygon</span>
<span class="kn">from</span> <span class="nn">shapely.prepared</span> <span class="kn">import</span> <span class="n">prep</span>
<span class="kn">import</span> <span class="nn">fiona</span>
<span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">PatchCollection</span>
<span class="kn">from</span> <span class="nn">descartes</span> <span class="kn">import</span> <span class="n">PolygonPatch</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">datetime</span>
</pre></div>


<h2 id="downloading-your-google-location-history">Downloading your Google location history</h2>
<p>If you've previously enabled Google location reporting on your smartphone, your GPS data will be periodically uploaded <a href="https://support.google.com/gmm/answer/3118687?hl=en">to Google's servers</a>.<sup id="sf-visualizing-my-location-history-1-back"><a href="#sf-visualizing-my-location-history-1" class="simple-footnote" title="Edited 11/21/14 to reflect that Google Location history is available on Android or iOS">1</a></sup> The decisions of when and how to upload this data are entirely obfuscated to the end user, but as you'll see below, Android appears to upload a GPS location <strong>every 60 seconds</strong>, at least in my case. That's plenty of data to work with.</p>
<p>Google provides a service called <strong><a href="https://www.google.com/settings/takeout">Takeout</a></strong> that allows us to export any personal Google data. How kind! We'll use Takeout to download our raw location history as a one-time snapshot. Since Latitude was retired, no API exists to access location history in real-time.<sup id="sf-visualizing-my-location-history-2-back"><a href="#sf-visualizing-my-location-history-2" class="simple-footnote" title="If someone knows of a way, please, let me know!">2</a></sup> Here's what to do:</p>
<ol>
<li>Go to <a href="https://www.google.com/settings/takeout">https://www.google.com/settings/takeout</a>. Uncheck all services except "Location History"</li>
<li>The data will be in a json format, which works great for us. Download it in your favorite compression type.</li>
<li>When Google has finished creating your archive, you'll get an email notification and a link to download.</li>
<li>Download and unzip the file, and you should be looking at a <em>LocationHistory.json</em> file.</li>
</ol>
<h2 id="working-with-location-data-in-pandas">Working with location data in Pandas</h2>
<p><strong>Pandas</strong> is an incredibly powerful tool that simplifies working with complex datatypes and performing statistical analysis in the style of <em>R</em>. Because of its flexible structure, I find myself spending a fraction of the time coding the same solution as compared to pure Python.<sup id="sf-visualizing-my-location-history-3-back"><a href="#sf-visualizing-my-location-history-3" class="simple-footnote" title="Which is already so simple to work with!">3</a></sup> Find a great primer on using Pandas <a href="http://www.gregreda.com/2013/10/26/intro-to-pandas-data-structures/">here</a>. We won't be going too in depth.</p>
<p>So, you've installed Pandas. Let's get started! We'll read in the <em>LocationHistory.json</em> file from Google Takeout and create a <code>DataFrame</code>.</p>
<div class="highlight"><pre><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'LocationHistory.json'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
    <span class="n">raw</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

<span class="n">ld</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="s">'locations'</span><span class="p">])</span>
<span class="k">del</span> <span class="n">raw</span> <span class="c">#free up some memory</span>
<span class="c"># convert to typical units</span>
<span class="n">ld</span><span class="p">[</span><span class="s">'latitudeE7'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ld</span><span class="p">[</span><span class="s">'latitudeE7'</span><span class="p">]</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mf">1e7</span><span class="p">)</span> 
<span class="n">ld</span><span class="p">[</span><span class="s">'longitudeE7'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ld</span><span class="p">[</span><span class="s">'longitudeE7'</span><span class="p">]</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mf">1e7</span><span class="p">)</span>
<span class="n">ld</span><span class="p">[</span><span class="s">'timestampMs'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ld</span><span class="p">[</span><span class="s">'timestampMs'</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span> <span class="c">#to seconds</span>
<span class="n">ld</span><span class="p">[</span><span class="s">'datetime'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ld</span><span class="o">.</span><span class="n">timestampMs</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">fromtimestamp</span><span class="p">)</span>
<span class="c"># Rename fields based on the conversions we just did</span>
<span class="n">ld</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s">'latitudeE7'</span><span class="p">:</span><span class="s">'latitude'</span><span class="p">,</span> <span class="s">'longitudeE7'</span><span class="p">:</span><span class="s">'longitude'</span><span class="p">,</span> <span class="s">'timestampMs'</span><span class="p">:</span><span class="s">'timestamp'</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">ld</span> <span class="o">=</span> <span class="n">ld</span><span class="p">[</span><span class="n">ld</span><span class="o">.</span><span class="n">accuracy</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">]</span> <span class="c">#Ignore locations with accuracy estimates over 1000m</span>
<span class="n">ld</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>


<p>Now you've got a Pandas <code>DataFrame</code> called <code>ld</code> containing all your location history and related info. We've got <strong>latitude</strong>, <strong>longitude</strong>, and a <strong>timestamp</strong> (obviously), but also accuracy, activitys [sic], altitude, heading. Google is clearly trying to do some complex backend analysis of your location history to infer what you're up to and where you're going (and you'll see some of these fields in use if you use <em>Google Now</em> on your smartphone). But all we'll need is latitude, longitude, and time.</p>
<h2 id="working-with-shapefiles-in-python">Working with Shapefiles in Python</h2>
<p>The more I learn about mapping, the more I realize how complex it is. But to do what we want to do with our location history, we're going to have to become experts in mapping in a couple hours. We don't have time to learn proprietary GIS software or write our own methods to analyze map data. But Python being Python, we've already got packages to knock this stuff out. </p>
<p><a href="http://en.wikipedia.org/wiki/Shapefile">Shapefile</a> is a widely-used data format for describing points, lines, and polygons. To work with shapefiles, Python gives us <a href="https://pypi.python.org/pypi/Shapely">Shapely</a>.<sup id="sf-visualizing-my-location-history-4-back"><a href="#sf-visualizing-my-location-history-4" class="simple-footnote" title="It's got bindings to GEOS, the engine that will perform a lot of the computation, and a clean syntax.">4</a></sup> Shapely rocks. To briefly read/write shapefiles, we'll use <a href="https://pypi.python.org/pypi/Fiona">Fiona</a>.</p>
<p>To learn Shapely and write this blog post, I leaned heavily on an article from <a href="http://sensitivecities.com/so-youd-like-to-make-a-map-using-python-EN.html">sensitivecities.com</a>. Please, go pester that guy to write more stuff. Tom MacWright also wrote <a href="http://www.macwright.org/2012/10/31/gis-with-python-shapely-fiona.html">a great overview</a> of the tools we'll be using.</p>
<p>First up, you'll need to download shapefile data for the part of the world you're interested in plotting. I wanted to focus on my current home of Seattle, which like many cities <a href="https://data.seattle.gov/dataset/data-seattle-gov-GIS-shapefile-datasets/f7tb-rnup">provides city shapefile map data</a> for free. It's even broken into city neighborhoods! The US Census Bureau provides a ton of national shapefiles <a href="https://www.census.gov/geo/maps-data/data/tiger.html">here</a>. Your city likely provides this kind of data too.</p>
<p>Next, we'll need to import the Shapefile data we downloaded, which is easy as pie.</p>
<div class="highlight"><pre><span class="n">shapefilename</span> <span class="o">=</span> <span class="s">'data/Neighborhoods/WGS84/Neighborhoods'</span>
<span class="n">shp</span> <span class="o">=</span> <span class="n">fiona</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">shapefilename</span><span class="o">+</span><span class="s">'.shp'</span><span class="p">)</span>
<span class="n">coords</span> <span class="o">=</span> <span class="n">shp</span><span class="o">.</span><span class="n">bounds</span>
<span class="n">shp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">extra</span> <span class="o">=</span> <span class="mf">0.01</span>
</pre></div>


<p>Now we'll leverage Basemap to go about actually plotting our shapefiles.</p>
<div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="n">Basemap</span><span class="p">(</span>
    <span class="n">projection</span><span class="o">=</span><span class="s">'tmerc'</span><span class="p">,</span> <span class="n">ellps</span><span class="o">=</span><span class="s">'WGS84'</span><span class="p">,</span>
    <span class="n">lon_0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]]),</span>
    <span class="n">lat_0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">3</span><span class="p">]]),</span>
    <span class="n">llcrnrlon</span><span class="o">=</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">extra</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span>
    <span class="n">llcrnrlat</span><span class="o">=</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">extra</span> <span class="o">*</span> <span class="n">h</span><span class="p">),</span> 
    <span class="n">urcrnrlon</span><span class="o">=</span><span class="n">coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">extra</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span>
    <span class="n">urcrnrlat</span><span class="o">=</span><span class="n">coords</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">extra</span> <span class="o">*</span> <span class="n">h</span><span class="p">),</span>
    <span class="n">resolution</span><span class="o">=</span><span class="s">'i'</span><span class="p">,</span>  <span class="n">suppress_ticks</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">_out</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">readshapefile</span><span class="p">(</span><span class="n">shapefilename</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">'seattle'</span><span class="p">,</span> <span class="n">drawbounds</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>


<p>We'll need the above Basemap object <code>m</code> for both of the following maps.</p>
<hr/>
<h2 id="choropleth-map">Choropleth Map</h2>
<p>A choropleth map <em>"provides an easy way to visualize how a measurement varies across a geographic area."</em><sup id="sf-visualizing-my-location-history-5-back"><a href="#sf-visualizing-my-location-history-5" class="simple-footnote" title="quoted from http://en.wikipedia.org/wiki/Choropleth_map">5</a></sup>. You've seen them a thousand times, usually whenever population or presidential elections are discussed, as in <a href="http://www.101traveldestinations.com/wp-content/uploads/2014/08/choropleth-map-2.jpg">this example</a>.</p>
<p>I wanted to produce a choropleth map of my own location history, but instead of breaking it down by country or state, I wanted to use the <a href="http://en.wikipedia.org/wiki/Neighborhoods_in_Seattle">neighborhoods of Seattle</a>.</p>
<h3 id="step-1-prep-data-and-pare-down-locations">Step 1: Prep data and pare down locations</h3>
<p>The first step is to pare down your location history to <em>only</em> contain points within the map's borders.</p>
<div class="highlight"><pre><span class="c"># set up a map dataframe</span>
<span class="n">df_map</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
    <span class="s">'poly'</span><span class="p">:</span> <span class="p">[</span><span class="n">Polygon</span><span class="p">(</span><span class="n">hood_points</span><span class="p">)</span> <span class="k">for</span> <span class="n">hood_points</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">seattle</span><span class="p">],</span>
    <span class="s">'name'</span><span class="p">:</span> <span class="p">[</span><span class="n">hood</span><span class="p">[</span><span class="s">'S_HOOD'</span><span class="p">]</span> <span class="k">for</span> <span class="n">hood</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">seattle_info</span><span class="p">]</span>
<span class="p">})</span>
<span class="c"># Convert our latitude and longitude into Basemap cartesian map coordinates</span>
<span class="n">mapped_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">mapped_x</span><span class="p">,</span> <span class="n">mapped_y</span><span class="p">))</span> <span class="k">for</span> <span class="n">mapped_x</span><span class="p">,</span> <span class="n">mapped_y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ld</span><span class="p">[</span><span class="s">'longitude'</span><span class="p">],</span> 
            <span class="n">ld</span><span class="p">[</span><span class="s">'latitude'</span><span class="p">])]</span>
<span class="n">all_points</span> <span class="o">=</span> <span class="n">MultiPoint</span><span class="p">(</span><span class="n">mapped_points</span><span class="p">)</span>
<span class="c"># Use prep to optimize polygons for faster computation</span>
<span class="n">hood_polygons</span> <span class="o">=</span> <span class="n">prep</span><span class="p">(</span><span class="n">MultiPolygon</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">df_map</span><span class="p">[</span><span class="s">'poly'</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)))</span>
<span class="c"># Filter out the points that do not fall within the map we're making</span>
<span class="n">city_points</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">hood_polygons</span><span class="o">.</span><span class="n">contains</span><span class="p">,</span> <span class="n">all_points</span><span class="p">)</span>
</pre></div>


<p>Now, <code>city_points</code> contains a list of all points that fall within the map and <code>hood_polygons</code> is a collection of polygons representing, in my case, each neighborhood in Seattle. </p>
<h3 id="step-2-compute-your-measurement-metric">Step 2: Compute your measurement metric</h3>
<p>The raw data for my choropleth should be "number of points in each neighborhood." With Pandas, again, it's <em>easy</em>. (Warning - depending on the size of the <code>city_points</code> array, this could take a few minutes.)</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">num_of_contained_points</span><span class="p">(</span><span class="n">apolygon</span><span class="p">,</span> <span class="n">city_points</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">prep</span><span class="p">(</span><span class="n">apolygon</span><span class="p">)</span><span class="o">.</span><span class="n">contains</span><span class="p">,</span> <span class="n">city_points</span><span class="p">)))</span>

<span class="n">df_map</span><span class="p">[</span><span class="s">'hood_count'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_map</span><span class="p">[</span><span class="s">'poly'</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">num_of_contained_points</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">city_points</span><span class="p">,))</span>
<span class="n">df_map</span><span class="p">[</span><span class="s">'hood_hours'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_map</span><span class="o">.</span><span class="n">hood_count</span><span class="o">/</span><span class="mf">60.0</span>
</pre></div>


<p>So now, <code>df_map.hood_count</code> contains a count of the number of gps points located within each neighborhood. But what do those counts really mean? It's not very meaningful knowing that I spent 2,500 "datapoints" in Capitol Hill, except to compare against other neighborhoods. And we could do that. Or we could convert <code>hood_count</code> into time...</p>
<p>Turns out, that's <strong>really</strong> easy, for one simple reason. From investigating my location history, it seems that unless my phone is off or without reception, Android reports my location <em>exactly</em> every 60 seconds. Not usually 60 seconds, not sometimes 74 seconds, <strong><em>60 seconds</em></strong>. It's been true on Android 4.2-4.4, and using a Samsung S3 and my current Nexus 5. Hopefully that means it holds true for you, too.<sup id="sf-visualizing-my-location-history-6-back"><a href="#sf-visualizing-my-location-history-6" class="simple-footnote" title="Of course, if this doesn't hold true, you can still convert to time. You'll just have to actually compute time differences. Something like myseries.diff().sum() should be a good start">6</a></sup> So if we make the assumption that I keep my phone on 24/7 (true) and I have city-wide cellular reception (also true), then all we need to do is <code>hood_count/60.0</code>, as shown above, and now we're talking in hours instead of datapoints<sup id="sf-visualizing-my-location-history-7-back"><a href="#sf-visualizing-my-location-history-7" class="simple-footnote" title="YES, I realize that using this methodology, 2 data points would be calculated as 2 minutes, when possibly I only spent 1 minute there and caught the tail ends in multiple GPS snapshots. So my estimates of time may be slightly elevated. But the tradeoff for solving this problem is miniscule.">7</a></sup>. </p>
<h3 id="step-3-plot-the-choropleth">Step 3: Plot the choropleth</h3>
<p>We've got our location data. We've got our shapefiles in order. All that's left - plot! Note that I've removed location data near my work and home, partly so they don't skew the colormap, and partly to anonymize my data just an eensy bit.</p>
<p>This plotting code for the choropleth gets a bit wordy for a blog format, so check the code as a Gist at the below link.</p>
<p><a href="https://gist.github.com/tylerhartley/c5ea21e2a4879fcc4151"/></p><p/>






<p><span id="ex1" class="zoom">
    <img src="/images/latitude/choropleth.png" alt="Choropleth of my location history"/>
</span></p>
<hr/>
<h2 id="hexbin-map">Hexbin Map</h2>
<p>We can also take a different approach to choropleths, and instead of using each neighborhood polygon as a bin, let Basemap generate uniform hexagonal bins for us! It's a great way to visualize point density, as all our bins will be of equal size. Best of all, it requires essentially no extra work as we've already defined our neighborhood <code>Patches</code> and paired down our location data. See the code below in the Gist.</p>
<p><a href="https://gist.github.com/tylerhartley/8bb82acd62472dfebfea"/></p><p/>
<p><span id="ex2" class="zoom">
    <img src="/images/latitude/hexbin.png" alt="Hexbin of my location history"/>
</span></p>
<p>Some super interesting patterns pop out immediately. I pretty much just hang out in North Seattle and Downtown. You can quickly spot my time on the Burke-Gilman trail on the east side, and you can also spot some of my favorite hangouts. Some of my friends may even see their houses on here (remember I've removed location data from near my work and home).</p>
<p>Of course, I don't <em>always</em> have my phone with me, and I notice some glaring vacancies on the map where I <em>know</em> I've been like Discovery Park, Madison, West Seattle, Seward Park, etc. But all in all, pretty awesome graph.</p>
<hr/>
<h2 id="map-of-flights-taken">Map of Flights Taken</h2>
<p>If you haven't already figured it out, I <em>really</em> liked Google Latitude. One thing Latitude attempted was to track all your instances of flights. I'd say their algorithm caught about 90% of the flights I took, but it never gave me the ability to visualize them on a map. Always bummed me out!</p>
<p>But now, armed with our raw location data and Pandas, we should be able to meet and even exceed Latitude's attempts to identify flights. The basic algorithm seems pretty simple - "if speed is greater than ~300kph, you're flying" because honestly, when else are you going that fast? But there are problems with that approach:</p>
<ol>
<li><strong>GPS location can be inaccurate.</strong> Take a peek at the <code>accuracy</code> field in your Data Frame. Not always spot-on. We could filter out inaccurate data points, but GPS doesn't have to be that far off to break our criteria. Think about it - if we're sampling location once per minute then all it would take is to be off by 200kph/60min or 3.3 km (~2 miles) and your algorithm would think you were flying! Looking through my location history, this  happens a few times per week. So we'll have to address this concern in the algo.</li>
<li><strong>Your phone collects GPS data mid-flight.</strong> This one caught me off guard. When I fly, I activate "airplane mode" which, as far as I could tell, deactivated wifi/cellular data/GPS. Turns out? It only deactivates the first two. Consequently, during a given flight, my phone will occasionally collect an (accurate!) location in mid-flight. If we're not careful, our algorithm could interpret each of these datapoints as a layover, and break our single flight into many small ones. That's no good.</li>
<li><strong>Using speed assumes no delays.</strong> Sometimes, I may turn off my phone for a flight only to sit on the tarmac for 2 hours. Or, the flight may be in a holding pattern before landing. Either scenario would dramatically decrease my computed "speed" by artificially increasing the time between airplane-mode <code>on</code> and <code>off</code> datapoints. </li>
</ol>
<p>We need something quick and dirty that can address these concerns.</p>
<p>First, we'll compute distance and speed between each GPS point, and create a new DataFrame to hold those values:</p>
<div class="highlight"><pre><span class="n">degrees_to_radians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span> 
<span class="n">ld</span><span class="p">[</span><span class="s">'phi'</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">90.0</span> <span class="o">-</span> <span class="n">ld</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span> <span class="o">*</span> <span class="n">degrees_to_radians</span> 
<span class="n">ld</span><span class="p">[</span><span class="s">'theta'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ld</span><span class="o">.</span><span class="n">longitude</span> <span class="o">*</span> <span class="n">degrees_to_radians</span>
<span class="c"># Compute distance between two GPS points on a unit sphere</span>
<span class="n">ld</span><span class="p">[</span><span class="s">'distance'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span> 
    <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ld</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ld</span><span class="o">.</span><span class="n">phi</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ld</span><span class="o">.</span><span class="n">theta</span> <span class="o">-</span> <span class="n">ld</span><span class="o">.</span><span class="n">theta</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> 
    <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ld</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ld</span><span class="o">.</span><span class="n">phi</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="p">)</span> <span class="o">*</span> <span class="mf">6378.100</span> <span class="c"># radius of earth in km</span>

<span class="n">ld</span><span class="p">[</span><span class="s">'speed'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ld</span><span class="o">.</span><span class="n">distance</span><span class="o">/</span><span class="p">(</span><span class="n">ld</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">-</span> <span class="n">ld</span><span class="o">.</span><span class="n">timestamp</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="mi">3600</span> <span class="c">#km/hr</span>

<span class="c"># Make a new dataframe containing the difference in location between each pair of points. </span>
<span class="c"># Any one of these pairs is a potential flight</span>
<span class="n">flightdata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s">'endlat'</span><span class="p">:</span><span class="n">ld</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
                             <span class="s">'endlon'</span><span class="p">:</span><span class="n">ld</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
                             <span class="s">'enddatetime'</span><span class="p">:</span><span class="n">ld</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span>
                             <span class="s">'distance'</span><span class="p">:</span><span class="n">ld</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span>
                             <span class="s">'speed'</span><span class="p">:</span><span class="n">ld</span><span class="o">.</span><span class="n">speed</span><span class="p">,</span>
                             <span class="s">'startlat'</span><span class="p">:</span><span class="n">ld</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
                             <span class="s">'startlon'</span><span class="p">:</span><span class="n">ld</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
                             <span class="s">'startdatetime'</span><span class="p">:</span><span class="n">ld</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span>
                             <span class="p">}</span>
                       <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>


<p>Now <code>flightdata</code> contains a comparison of each adjacent GPS location. All that's left to do is filter out the true flight instances from the rest of them.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">distance_on_unit_sphere</span><span class="p">(</span><span class="n">lat1</span><span class="p">,</span> <span class="n">long1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">long2</span><span class="p">):</span>
    <span class="c"># http://www.johndcook.com/python_longitude_latitude.html</span>
    <span class="c"># Convert latitude and longitude to spherical coordinates in radians.</span>
    <span class="n">degrees_to_radians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span>  
    <span class="c"># phi = 90 - latitude</span>
    <span class="n">phi1</span> <span class="o">=</span> <span class="p">(</span><span class="mf">90.0</span> <span class="o">-</span> <span class="n">lat1</span><span class="p">)</span><span class="o">*</span><span class="n">degrees_to_radians</span>
    <span class="n">phi2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">90.0</span> <span class="o">-</span> <span class="n">lat2</span><span class="p">)</span><span class="o">*</span><span class="n">degrees_to_radians</span>
    <span class="c"># theta = longitude</span>
    <span class="n">theta1</span> <span class="o">=</span> <span class="n">long1</span><span class="o">*</span><span class="n">degrees_to_radians</span>
    <span class="n">theta2</span> <span class="o">=</span> <span class="n">long2</span><span class="o">*</span><span class="n">degrees_to_radians</span>

    <span class="n">cos</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span> <span class="o">-</span> <span class="n">theta2</span><span class="p">)</span> <span class="o">+</span> 
           <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi2</span><span class="p">))</span>
    <span class="n">arc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span> <span class="n">cos</span> <span class="p">)</span>
    <span class="c"># Remember to multiply arc by the radius of the earth </span>
    <span class="c"># in your favorite set of units to get length.</span>
    <span class="k">return</span> <span class="n">arc</span>
</pre></div>


<div class="highlight"><pre><span class="c"># Weed out the obviously not-flights using very conservative criteria</span>
<span class="n">flights</span> <span class="o">=</span> <span class="n">flightdata</span><span class="p">[(</span><span class="n">flightdata</span><span class="o">.</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">flightdata</span><span class="o">.</span><span class="n">distance</span> <span class="o">&gt;</span> <span class="mi">80</span><span class="p">)]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
<span class="c">#### Combine instances of flight that are directly adjacent </span>
<span class="c"># Find the indices of flights that are directly adjacent</span>
<span class="n">_f</span> <span class="o">=</span> <span class="n">flights</span><span class="p">[</span><span class="n">flights</span><span class="p">[</span><span class="s">'index'</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">adjacent_flight_groups</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">_f</span><span class="p">,</span> <span class="p">(</span><span class="n">_f</span><span class="p">[</span><span class="s">'index'</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="c"># Now iterate through the groups of adjacent flights and merge their data into</span>
<span class="c"># one flight entry</span>
<span class="k">for</span> <span class="n">flight_group</span> <span class="ow">in</span> <span class="n">adjacent_flight_groups</span><span class="p">:</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">flight_group</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="c">#the index of flight termination</span>
    <span class="n">flights</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">[</span><span class="s">'startlat'</span><span class="p">,</span> <span class="s">'startlon'</span><span class="p">,</span> <span class="s">'startdatetime'</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">flight_group</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">startlat</span><span class="p">,</span> 
                                                         <span class="n">flight_group</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">startlon</span><span class="p">,</span> 
                                                         <span class="n">flight_group</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">startdatetime</span><span class="p">]</span>
    <span class="c"># Recompute total distance of flight</span>
    <span class="n">flights</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s">'distance'</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance_on_unit_sphere</span><span class="p">(</span><span class="n">flights</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">startlat</span><span class="p">,</span>
                                                           <span class="n">flights</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">startlon</span><span class="p">,</span>
                                                           <span class="n">flights</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">endlat</span><span class="p">,</span>
                                                           <span class="n">flights</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">endlon</span><span class="p">)</span><span class="o">*</span><span class="mf">6378.1</span>   

<span class="c"># Cool. We're done! Now remove the "flight" entries we don't need anymore.</span>
<span class="n">flights</span> <span class="o">=</span> <span class="n">flights</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">_f</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c"># Finally, we can be confident that we've removed instances of flights broken up by</span>
<span class="c"># GPS data points during flight. We can now be more liberal in our constraints for what</span>
<span class="c"># constitutes flight. Let's remove any instances below 200km as a final measure.</span>
<span class="n">flights</span> <span class="o">=</span> <span class="n">flights</span><span class="p">[</span><span class="n">flights</span><span class="o">.</span><span class="n">distance</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>


<p>This algorithm worked 100% of the time for me - no false positives or negatives. But it isn't my favorite algorithm...it's fairly brittle. The core of it centers around the assumption that inter-flight GPS data will be directly adjacent to one another. That's why the initial screening on line 2 had to be so liberal. If you have any superior solutions, <strong>please give me some suggestions in the comments!</strong><sup id="sf-visualizing-my-location-history-8-back"><a href="#sf-visualizing-my-location-history-8" class="simple-footnote" title="Part of the algo that I like the least centers around finding runs of consecutive numbers (e.g. 3, 4, or 8, 9, 10). Turns out, that's actually harder than it looks. I ended up going down a stackoverflow rabbit hole trying to optimize that search algorithm and, in the end, stuck with the first thing I came up with.">8</a></sup>.</p>
<p>Now, the <code>flights</code> DataFrame contains only instances of true flight. All that's left to do is plot them. </p>
<p>Matplotlib's Basemap again comes to the rescue. If we plot on a flat projection like <code>tmerc</code>, the <code>drawgreatcircle</code> function will produce a true path arc just like we see in the <a href="http://content.delta.com/content/www/en_US/traveling-with-us/where-we-fly/flight-partners/virgin-atlantic-partnership/vs-route-map/_jcr_content/mainPar/image.img.20130621T202250093Z.png">in-flight magazines</a>.</p>
<p><a href="https://gist.github.com/tylerhartley/f338b9f638fbcb8605a5"/></p><p/>


<p><span id="ex3" class="zoom">
    <img alt="Flights within the US" src="/images/latitude/us_flights.png"/>
</span></p>


<p><span id="ex4" class="zoom">
    <img alt="Global flights" src="/images/latitude/all_flights.png"/>
</span></p>
<p>Perfect! I realize this graph probably isn't intrinsically interesting to anybody - who cares about my flight history? - but for me, I can draw a lot of fun conclusions. You can see some popular layover locations, all those lines in/out of Seattle, plus a recent trip to southeast Asia. And Basemap has made it so simple for us - no Shapefiles to import because all that map info is baked into to the Basemap module. I can even calculate all the skymiles I <em>should</em> have earned with a single line of code:</p>



<p>53,000 miles. If only I had loyalty to any one airline!</p>
<h2 id="wrapup">Wrapup</h2>
<p>You've now got the code to go ahead and reproduce these maps. But you also have the tools to go so much further! Figure out where you usually go on the weekends; calculate your fastest commute route; measure the amount of time you spend driving vs. walking.<sup id="sf-visualizing-my-location-history-9-back"><a href="#sf-visualizing-my-location-history-9" class="simple-footnote" title="I can guarantee you Google is already asking these questions of your data">9</a></sup> While these questions may be for another blog post, they'll still be using the same tools you've seen here and nothing more. And that's pretty amazing.</p><hr/><h4>Footnotes</h4><ol class="simple-footnotes"><li id="sf-visualizing-my-location-history-1">Edited 11/21/14 to reflect that Google Location history is available on Android or iOS <a href="#sf-visualizing-my-location-history-1-back" class="simple-footnote-back">↩</a></li><li id="sf-visualizing-my-location-history-2">If someone knows of a way, please, let me know! <a href="#sf-visualizing-my-location-history-2-back" class="simple-footnote-back">↩</a></li><li id="sf-visualizing-my-location-history-3">Which is already so simple to work with! <a href="#sf-visualizing-my-location-history-3-back" class="simple-footnote-back">↩</a></li><li id="sf-visualizing-my-location-history-4">It's got bindings to GEOS, the engine that will perform a lot of the computation, and a clean syntax. <a href="#sf-visualizing-my-location-history-4-back" class="simple-footnote-back">↩</a></li><li id="sf-visualizing-my-location-history-5">quoted from <a href="http://en.wikipedia.org/wiki/Choropleth_map">http://en.wikipedia.org/wiki/Choropleth_map</a> <a href="#sf-visualizing-my-location-history-5-back" class="simple-footnote-back">↩</a></li><li id="sf-visualizing-my-location-history-6">Of course, if this <em>doesn't</em> hold true, you can still convert to time. You'll just have to actually compute time differences. Something like <code>myseries.diff().sum()</code> should be a good start <a href="#sf-visualizing-my-location-history-6-back" class="simple-footnote-back">↩</a></li><li id="sf-visualizing-my-location-history-7">YES, I realize that using this methodology, 2 data points would be calculated as 2 minutes, when possibly I only spent 1 minute there and caught the tail ends in multiple GPS snapshots. So my estimates of time may be <em>slightly</em> elevated. But the tradeoff for solving this problem is miniscule. <a href="#sf-visualizing-my-location-history-7-back" class="simple-footnote-back">↩</a></li><li id="sf-visualizing-my-location-history-8">Part of the algo that I like the least centers around finding runs of consecutive numbers (e.g. 3, 4, or 8, 9, 10). Turns out, that's actually harder than it looks. I ended up going down a stackoverflow rabbit hole trying to optimize that search algorithm and, in the end, stuck with the first thing I came up with. <a href="#sf-visualizing-my-location-history-8-back" class="simple-footnote-back">↩</a></li><li id="sf-visualizing-my-location-history-9">I can guarantee you Google is already asking these questions of your data <a href="#sf-visualizing-my-location-history-9-back" class="simple-footnote-back">↩</a></li></ol>
            </div>
            
    </div></body></html>