<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/files/282/54e/361/28254e361465469591b7eb1be8192a51.jpg" alt="image"/>
<p>
Доброго времени суток. Ранее </p><a href="http://ringcloud.ru">RingCloud</a> <a href="http://megamozg.ru/company/ringcloud/blog/14380/">анонсировал</a><p> запуск REST API, которое позволит нашему продукту интегрироваться с различными CRM-системами. И хотя его разработка еще продолжается, мы рады представить Вашему вниманию первую версию. Под катом мы рассмотрим общую архитектуру данного сервиса, его принцип работы, а так же разберём примеры использования.
</p><a name="habracut"/><p>
Когда мы только планировали свой сервис, мы ставили перед собой цели сделать его максимально удобным для интеграции, а такие задачи без достойного API не решить. По этому решили уделить данном сервису как можно больше внимания, построив его максимально надёжным и удобным.

</p><h2>Управление ключами API</h2><p>
Для использования API Вам потребуется уникальный </p><i>API Key</i><p> и пароль к нему, для этого идём в свой личный кабинет и в соответствующем </p><a href="https://online.ringcloud.ru">разделе</a><p> создаём ключик

</p><img src="https://habrastorage.org/files/ecd/936/605/ecd9366059f64696adb91e60409fe3ff.PNG" alt="image"/>
<p>
Ключ генерируется автоматически, он состоит из префикса с номером вашего аккаунта и телом самого ключа, для того чтобы скопировать ключ необходимо просто кликнуть ЛКМ на строку с ключом. Пароль так же генерируется автоматически и для его изменения, если он вам покажется слишком простым, нужно нажать на иконку справа. Для каждого ключа необходимо указать права доступа, это сделано для разграничения полномочий между вашими приложениями. Уровни доступа работают по принципу «RO/RW» и позволяют разграничить разрешённые действия. 
</p><p>
Описание функций RingCloud API, доступных на данный момент, вы сможете получить на </p><a href="https://api.ringcloud.ru/docs/">странице документации</a> 

<h2>Архитектура</h2><p>
Данный сервис построен по принципу кластера, с балансировкой нагрузки между нодами обрабатывающими запросы. Так как сервис использует HTTPS, то было решено сместить эту задачу на балансировщик. Ноды, обработав запросы, обращаются к ядру системы включающему в себя сервера VoIP, БД, и cache основанный на Redis. </p><p>
Надо сказать, что </p><a href="http://redis.io/">Redis</a><p> у нас очень широко используется во всех узлах RingCloud, мы им очень довольны в плане удобства и быстродействия. 
</p><p>
В качестве балансировщика и серверов WEB интерфейса мы используем </p><a href="http://nginx.org/">Nginx</a><p> так как он нас полностью устроил по функционалу и производительности, на нём прекрасно реализован функционал балансировки, он отлично работает с HTTPS, обладает очень удобной конфигурацией.

</p><img src="https://habrastorage.org/files/d60/9db/ebb/d609dbebb7e047bf9c5c1c9b4202877c.png" alt="image"/>

<h2>Примеры использования</h2><p>
Наше API мы разрабатываем опираясь на </p><a href="https://ru.wikipedia.org/wiki/REST">REST</a><p> методологию, чтобы максимально упростить использование. </p><p>
Давайте рассмотрим принцип формирования запроса. Все url-адреса API имеют вид:
</p><pre><code class="bash">https://api.ringcloud.ru/&lt;&lt;url&gt;&gt;?api_key=API_KEY&amp;hash=HASH
</code></pre><p>
здесь:
</p><ul>
<li><b>url</b> – адрес, соответствующий вызываемой функции API </li>
<li><b>api_key</b> – ключ API </li>
<li><b>hash</b> – хэш — вычисляется как md5 от ключа API и пароля </li>
</ul><p>
В случае успешного выполнения любого запроса (за исключением загрузки файла записи разговора – в этом случае будет возвращен непосредственно сам файл) ответ от сервера имеет вид:
</p><pre><code class="python">{"status": "success", "message": null, "data": "some_data"}
</code></pre><p>
В случае возникновения ошибки (кроме ошибки при загрузке файла записи разговора – в этом случае будет возвращена пустая строка) ответ от сервера имеет вид:
</p><pre><code class="python">{"status": "error", "message": "some_error", "data": null}
</code></pre>
<p>
Каждый ответ от сервера содержит код состояния HTTP. В таблице ниже приведены наиболее часто используемые из них.

</p><b>Наиболее часто используемые коды состояния</b>
<table>
<tr>
<th>Код состояния HTTP</th>
<th>Описание</th>
</tr>
<tr>
<td>200</td>
<td>Функция успешно выполнена</td>
</tr>
<tr>
<td>400</td>
<td>Неправильно переданы параметры. Например, при обновлении данных был указан несуществующий пользователь</td>
</tr>
<tr>
<td>403</td>
<td>Не задан ключ API или хэш, ключ API не существует или неверно вычислен хэш</td>
</tr>
<tr>
<td>404</td>
<td>Запрашиваемый url или файл не найден</td>
</tr>
<tr>
<td>405</td>
<td>Метод не поддерживается – вместо GET использован POST запрос или наоборот</td>
</tr>
<tr>
<td>429</td>
<td>Слишком много запросов– достигнуто ограничение на частоту запросов к API</td>
</tr>
<tr>
<td>500</td>
<td>Внутренняя ошибка. В идеале не должен возвращаться никогда.</td>
</tr>
</table>
<p>
На данный момент возможна работа с двумя объектами (ресурсами в терминологии REST): «Пользователи» и «Вызовы». С помощью первого можно создавать пользователей, получать о них информацию и изменять их данные. Второй объект предназначен для работы со звонками. С его помощью можно совершить звонок, а также получить информацию об активных и совершенных вызовах. Далее, существуют определенные ограничения на частоту обращений к нашему API. Давайте поясним используемую нами модель. Во-первых, ограничения считаются отдельно для каждого ключа. Во-вторых, в рамках одного ключа существуют ограничения на однотипные запросы, т.е. запросы с полностью одинаковыми URL-адресами. Например, если у Вас есть только один ключ API, и Вы отправляете в минуту два запроса на изменение внутреннего номера у одного и того же пользователя, то успешно отработает только первый запрос. А вот изменить внутренние номера у двух разных пользователей вполне возможно.

</p><b>Функции объекта «Пользователи» и временные ограничения</b>
<table>
<tr>
<th>Название</th>
<th>URL-адрес</th>
<th>Ограничение</th>
</tr>
<tr>
<td>Получение списка пользователей аккаунта</td>
<td><pre><code class="bash">/v1/users
</code></pre></td>
<td>1 запрос в секунду</td>
</tr>
<tr>
<td>Получение информации по конкретному пользователю</td>
<td><pre><code class="bash">/v1/users/&lt;username&gt;
</code></pre></td>
<td>1 запрос в секунду</td>
</tr>
<tr>
<td>Изменение пароля</td>
<td><pre><code class="bash">/v1/users/&lt;username&gt;/update_password
</code></pre></td>
<td>1 запрос в секунду</td>
</tr>
<tr>
<td>Изменение внутреннего номера</td>
<td><pre><code class="bash">/v1/users/&lt;username&gt;/update_extension_number
</code></pre></td>
<td>1 запрос в 5 секунд</td>
</tr>
<tr>
<td>Изменение email</td>
<td><pre><code class="bash">/v1/users/&lt;username&gt;/update_email
</code></pre></td>
<td>1 запрос в 5 секунд</td>
</tr>
<tr>
<td>Включение Voice Box</td>
<td><pre><code class="bash">/v1/users/&lt;username&gt;/voice_mail_box_on
</code></pre></td>
<td>1 запрос в 5 секунд</td>
</tr>
<tr>
<td>Выключение Voice Box</td>
<td><pre><code class="bash">/v1/users/&lt;username&gt;/voice_mail_box_off
</code></pre></td>
<td>1 запрос в 5 секунд</td>
</tr>
<tr>
<td>Создание пользователя</td>
<td><pre><code class="bash">/v1/users/create
</code></pre></td>
<td>1 запрос в 60 секунд</td>
</tr>
<tr>
<td>Получение списка записей</td>
<td><pre><code class="bash">/v1/users/&lt;username&gt;/records
</code></pre></td>
<td>1 запрос в 5 секунд</td>
</tr>
<tr>
<td>загрузка записи разговора</td>
<td><pre><code class="bash">/v1/users/&lt;username&gt;/records/&lt;filename&gt;
</code></pre></td>
<td>1 запрос в секунду</td>
</tr>
</table>

<b>Функции объекта «Вызовы» и временные ограничения</b>

<table>
<tr>
<th>Название</th>
<th>URL-адрес</th>
<th>Ограничение</th>
</tr>
<tr>
<td>Получение списка каналов для контекста</td>
<td><pre><code class="bash">/v1/calls/channels
</code></pre></td>
<td>1 запрос в 2 секунды</td>
</tr>
<tr>
<td>Получение информации по каналу</td>
<td><pre><code class="bash">/v1/calls/channels/&lt;channel&gt;
</code></pre></td>
<td>1 запрос в 2 секунды</td>
</tr>
<tr>
<td>Оригинация вызова</td>
<td><pre><code class="bash">/v1/calls
</code></pre></td>
<td>1 запрос в 5 секунды</td>
</tr>
<tr>
<td>Получение списка совершённых вызовов</td>
<td><pre><code class="bash">/v1/calls/complite
</code></pre></td>
<td>1 запрос в 5 секунды</td>
</tr>
<tr>
<td>Получение списка текущих вызовов</td>
<td><pre><code class="bash">/v1/calls/active
</code></pre></td>
<td>1 запрос в 5 секунды</td>
</tr>
</table>

<b>Как работает оригинация вызова</b>
<p>
Для того чтобы сделать звонок на потребуется сотрудник который подключился по SIP к серверу RingCloud с помощью «софтфона» или стационарного SIP телефона, и номер на который будем звонить. При отправке запроса в API система сначала вызывает сотрудника (назовём его абонент А), а затем, только когда сотрудник ответил, набирает номер на который мы планируем совершить звонок, таким образом мы оригинируем вызов между абонентом А и абонентом Б
</p><img src="https://habrastorage.org/files/449/486/968/44948696827d4def97ec301678a08dda.jpg" alt="image"/>
<p>
Рассмотрим небольшой пример обращения на Python к нашему API. Вот как можно позвонить с внутреннего номера, закрепленного за сотрудником с именем 1679728441 на номер 7910123456:

</p><pre><code class="python"># Импортируем  всё что нам потребуется для оригинации вызова
import requests
import hashlib
import json
# объявляем переменные с данными в виде строки, которые нам потребуются для работы с RingCloud API

api_key = 'YOUR_API_KEY'
password = 'YOUR_PASS'

hash = hashlib.md5(api_key+password).hexdigest()
payload = {
    'user': '1679728441',
    'num': '7910123456'
}
data = {'params': payload}
# Выполняем запрос
r = requests.post("https://api.ringcloud.ru/v1/calls?api_key=%s&amp;hash=%s" %
                  (api_key, hash), data=json.dumps(data))
print r.text
</code></pre>

<div class="spoiler"><b class="spoiler_title">И тоже самое на PHP:</b><div class="spoiler_text"><pre><code class="php">&lt;?php
$apiKey = 'YOUR_API_KEY’;
$password = 'YOUR_PASS';
$hash = md5($apiKey . $password);
$apiUrl = 'https://api.ringcloud.ru/v1/calls?api_key=' . $apiKey . '&amp;hash=' . $hash;
$callData = [
   'params' =&gt; [
   'num' =&gt; '7910123456',
   'user' =&gt; '1679728441'
   ]
];
$ch = curl_init($apiUrl);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_POST, true);
curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($callData));
$result = curl_exec($ch);
echo $result; 
/* 
{
"status": "success",
"message": null,
"data": "Originate successfully queued"
}
*/
?&gt;
</code></pre>
</div></div>
<p>
Также параллельно с проектом разработки RingCloud API мы разрабатываем библиотеки, позволяющие максимально быстро начать использование его в своих приложениях и сервисах. Пока готова только первая версия библиотеки на PHP она находится </p><a href="https://bitbucket.org/ringcloud/ringcloud_phapi">здесь</a>
<p>
Ну вот вроде бы и всё чем мы хотели с вами поделиться. Актуальную версию документации по нашему API можно найти </p><a href="http://api.ringcloud.ru/docs">здесь</a><p>. В ближайших планах – создание </p><a href="https://bitbucket.org/ringcloud/ringcloud_pyapi/overview">полноценного пакета</a><p> для Python для работы с нашим API и, конечно же, расширение функционала. Спасибо за внимание.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>