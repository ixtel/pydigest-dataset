<html><body><div><div class="post-body entry-content" id="post-body-317971864158524742" itemprop="description articleBody">
<p>The Apache/mod_wsgi module I authored has been in suspended animation for some time. Today though I announce a new release (version 3.5) to address a security vulnerability, plus bring overdue updates to address issues in support for Apache 2.4 and Python 3.4.</p>
<p>Version 3.5 of mod_wsgi can be downloaded from github at:</p>

<p>The release notes for version 3.5 of mod_wsgi can be found at:</p>

<p>Although the security vulnerability will not affect all users, it is highly recommended you upgrade to this new version, or any newer revision of a Linux distributions binary package which includes a back ported fix for the issue.</p>
<p>In addition to the details of this vulnerability, I also include here details of an issue which was previously fixed in mod_wsgi 3.4 but was recently also discovered to be more severe than previously believed and which itself constitutes a security issue.</p>
<p>For more details read on. I will follow up this post with a further post about the general future of the mod_wsgi module for Apache.</p>
<p><strong>Issue: Possibility of local privilege escalation when using daemon mode. (CVE-2014-0240)</strong></p>
<p>The issue is believed to affect Linux systems running kernel versions &gt;= 2.6.0 and &lt; 3.1.0.</p>
<p>The issue affects all versions of mod_wsgi up to and including version 3.4.</p>
<p>The source of the issue derives from mod_wsgi not correctly handling Linux specific error codes from setuid(), which differ to what would be expected to be returned by UNIX systems conforming to the Open Group UNIX specification for setuid().</p>

<p>This difference in behaviour between Linux and the UNIX specification was believed to have been removed in version 3.1.0 of the Linux kernel.</p>

<p>The issue would allow a user, where Apache is initially being started as the root user and where running code under mod_wsgi daemon mode as an unprivileged user, to manipulate the number of processes run by that user to affect the outcome of setuid() when daemon mode processes are forked and so gain escalated privileges for the users code.</p>
<p>Due to the nature of the issue, if you provide a service or allow untrusted users to run Python web applications you do not control the code for, and do so using daemon mode of mod_wsgi, you should update mod_wsgi as soon as possible.</p>
<p>If you are unable to upgrade to a newer version of mod_wsgi, but wish to back port the fix to an older version of mod_wsgi that you are using, then the patch from mod_wsgi 3.5 can be found at:</p>

<p>There is no workaround for this issue, so using a version of mod_wsgi which incorporates the fix is your only choice.</p>
<p> </p>
<p>Thanks go to Róbert Kisteleki for identifying this issue.</p>
<p><strong>Issue: Possibility of information disclosure via Content-Type response header. (CVE-2014-0242)</strong></p>
<p>The issue was actually identified and previously fixed in version 3.4 (August 2012) of mod_wsgi.</p>
<blockquote>
<p>Response Content-Type header could be corrupted when being sent in multithreaded configuration and embedded mode being used. Problem thus affected Windows and worker MPM on UNIX.</p>
</blockquote>
<p>Release notes for version 3.4 of mod_wsgi can be viewed at:</p>

<p>At the time it was believed to be relatively benign, only ever having been seen with one specific web application (Trac - http://trac.edgewall.org), with the corrupted value always appearing to be replaced with a small set of known values which themselves did not raise concerns.</p>
<p>A new example of this problem has now been identified which opens this issue up as being able to cause arbitrary corruption of the web server HTTP response Content-Type value, resulting in possible exposure of data from the hosted web application to a HTTP client.</p>
<p>The new example also opens the possibility that the issue can occur with any Apache MPM and not just multithreaded MPMs as previously identified. Albeit that it still requires some form of background application threads to be in use, when a single threaded Apache MPM is being used.</p>
<p>In either case, it is still however restricted to the case where embedded mode of mod_wsgi is being used.</p>
<p>The specific scenario which can trigger the issue is where the value for the Content-Type response header is dynamically generated, and where the stack frame where the calculation was done went out of use between the time that the WSGI start_response() function was called and the first non empty byte string was yielded from the WSGI application for the response, resulting in the Python object being destroyed and memory returned to the free list.</p>
<p>At the same time, it would have been necessary for a parallel request thread or an application background thread to execute during that window of time and perform sufficient object allocations so as to reuse the memory previously used by the value of the Content-Type response header.</p>
<p>Example code which can be used to trigger the specific scenario can be found at:</p>

<p>That example code also provides a workaround if you find yourself affected by the issue but cannot upgrade straight away. It consists of the @intern_content_type decorator/wrapper. This can be applied to the WSGI application entry point and will use a cache to store the value of the Content-Type response header to ensure it is persistent for the life of the request.</p>
<p>If you are still using a version of mod_wsgi older than version 3.4, but are unable to upgrade to a newer version of mod_wsgi  and wish to back port the fix to the older version of mod_wsgi that you are using, then the patch from mod_wsgi 3.4 can be found at:</p>

<p>Thanks go to Buck Golemon for identifying this subsequent issue.</p>
<p/>
</div>
</div></body></html>