<html><body><div><div class="document">
<p>Handling the <a class="reference external" href="https://docs.djangoproject.com/en/dev/releases/1.6/#get-query-set-and-similar-methods-renamed-to-get-queryset">rename</a>
of <tt class="docutils literal">get_query_set</tt> to <tt class="docutils literal">get_queryset</tt> in Django 1.6 is very tricky - much
trickier than it might seem.</p>
<p>For many 3rd party libraries, you will have a few aims:</p>
<ol class="arabic simple">
<li>Maintain compatibility with older Django versions, and older projects
(including libraries) that might call your code, or subclass it.</li>
<li>Update your code to be compatible with latest versions of Django</li>
<li>Stop getting warnings when running your code/tests. Warnings you've already
addressed are a pain, as they drown out the ones you haven't addressed.</li>
</ol>
<p>Subclassing makes this much, much harder.</p>
<p>Suppose you have:</p>
<pre class="code python literal-block">
<span class="keyword">class</span> <span class="name class">FooManager</span><span class="punctuation">(</span><span class="name">models</span><span class="operator">.</span><span class="name">Manager</span><span class="punctuation">):</span>

    <span class="keyword">def</span> <span class="name function">active</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">):</span>
        <span class="keyword">return</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">get_query_set</span><span class="punctuation">()</span><span class="operator">.</span><span class="name">filter</span><span class="punctuation">(</span><span class="name">active</span><span class="operator">=</span><span class="name builtin pseudo">True</span><span class="punctuation">)</span>

    <span class="keyword">def</span> <span class="name function">get_query_set</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">):</span>
        <span class="keyword">return</span> <span class="name">FooQuerySet</span><span class="punctuation">(</span><span class="name">model</span><span class="operator">=</span><span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">model</span><span class="punctuation">)</span>
</pre>
<p>How do you update this code?</p>
<p>The tricky bit is that you need to consider a class that subclasses
<tt class="docutils literal">FooManager</tt>, which you don't control. That code might not be updated yet.</p>
<p>A very important example is the <tt class="docutils literal">RelatedManager</tt> class in Django, which
dynamically subclasses the default manager on a model to provide access to
related objects. You use this all the time, in ORM calls like
<tt class="docutils literal">person.schools.all()</tt> â roughly speaking <tt class="docutils literal">schools</tt> returns a dynamic
subclass of <tt class="docutils literal">School.objects</tt>. In Django 1.5, this subclass overrides the
<tt class="docutils literal">get_query_set</tt> method so that it calls <tt class="docutils literal">super.get_query_set</tt>
(e.g. <tt class="docutils literal">School.objects.get_query_set</tt>) and then <a class="reference external" href="https://github.com/django/django/blob/stable/1.5.x/django/db/models/fields/related.py#L499">adds some filters</a>
to limit to the particular related object it is attached to.</p>
<p>You certainly need compatibility with this if you want to still support Django
1.5. But there could be other examples of things that subclass <tt class="docutils literal">FooManager</tt>
explicitly and are outside your control. Let's represent all these subclasses as
follows:</p>
<pre class="code python literal-block">
<span class="keyword">class</span> <span class="name class">FooManagerSubClass</span><span class="punctuation">(</span><span class="name">FooManager</span><span class="punctuation">):</span>

    <span class="keyword">def</span> <span class="name function">get_query_set</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">):</span>
        <span class="keyword">return</span> <span class="name builtin">super</span><span class="punctuation">(</span><span class="name">FooManagerSubClass</span><span class="punctuation">,</span> <span class="name builtin pseudo">self</span><span class="punctuation">)</span><span class="operator">.</span><span class="name">get_query_set</span><span class="punctuation">()</span><span class="operator">.</span><span class="name">order_by</span><span class="punctuation">(</span><span class="literal string single">'bar'</span><span class="punctuation">)</span>
</pre>
<p>Now, imagine an instance of <tt class="docutils literal">FooManagerSubClass</tt>, and calling the <tt class="docutils literal">active</tt>
method on it. The call look like:</p>
<pre class="literal-block">
FooManager.active -&gt;
FooManagerSubClass.get_query_set -&gt;
FooManager.get_query_set
</pre>
<p>So all the defined behaviours combine as they should.</p>
<p>Now you come to update <tt class="docutils literal">FooManager</tt> so that it will still work with Django
1.5, but works on Django 1.6 and later without issuing warnings if everyone is
using <tt class="docutils literal">get_queryset</tt>.</p>
<p>How should you rewrite it?</p>
<p>First pass:</p>
<pre class="code python literal-block">
<span class="keyword">class</span> <span class="name class">FooManager</span><span class="punctuation">(</span><span class="name">models</span><span class="operator">.</span><span class="name">Manager</span><span class="punctuation">):</span>

    <span class="keyword">def</span> <span class="name function">get_queryset</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">):</span>
        <span class="keyword">return</span> <span class="name">FooQuerySet</span><span class="punctuation">(</span><span class="name">model</span><span class="operator">=</span><span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">model</span><span class="punctuation">)</span>

    <span class="name">get_query_set</span> <span class="operator">=</span> <span class="name">get_queryset</span>  <span class="comment single"># Django 1.5 compat</span>

    <span class="keyword">def</span> <span class="name function">active</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">):</span>
        <span class="keyword">return</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">get_queryset</span><span class="punctuation">()</span><span class="operator">.</span><span class="name">filter</span><span class="punctuation">(</span><span class="name">active</span><span class="operator">=</span><span class="name builtin pseudo">True</span><span class="punctuation">)</span>
</pre>
<p>This looks correct, but <tt class="docutils literal"><span class="pre">FooManagerSubClass().active()</span></tt> is now broken, because
calling it runs:</p>
<pre class="literal-block">
FooManager.active -&gt;
FooManager.get_queryset
</pre>
<p>â that is, it misses out <tt class="docutils literal">FooManagerSubClass.get_query_set</tt>, because
<tt class="docutils literal">active</tt> is calling <tt class="docutils literal">get_queryset</tt>, and the subclass knows nothing about
that, it's only overridden the <tt class="docutils literal">get_query_set</tt> method.</p>
<p>(This type of failure is particularly nasty, because the failure is silent. It
applies to related managers, which are going to be broken in a nasty way - they
no longer have filtering applied, so <tt class="docutils literal">person.schools.all()</tt> returns all
schools, not just the ones related to <tt class="docutils literal">person</tt>. And you probably won't have an
explicit unit test for this).</p>
<p>So, now you need something like this:</p>
<pre class="code python literal-block">
<span class="keyword">class</span> <span class="name class">FooManager</span><span class="punctuation">(</span><span class="name">models</span><span class="operator">.</span><span class="name">Manager</span><span class="punctuation">):</span>

    <span class="keyword">def</span> <span class="name function">get_queryset</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">):</span>
        <span class="keyword">return</span> <span class="name">FooQuerySet</span><span class="punctuation">(</span><span class="name">model</span><span class="operator">=</span><span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">model</span><span class="punctuation">)</span>

    <span class="name">get_query_set</span> <span class="operator">=</span> <span class="name">get_queryset</span>

    <span class="keyword">def</span> <span class="name function">active</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">):</span>
        <span class="name">m</span> <span class="operator">=</span> <span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">get_query_set</span>
             <span class="keyword">if</span> <span class="name builtin">hasattr</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="literal string single">'get_query_set'</span><span class="punctuation">)</span>
             <span class="keyword">else</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">get_queryset</span><span class="punctuation">)</span>
        <span class="keyword">return</span> <span class="name">m</span><span class="punctuation">()</span><span class="operator">.</span><span class="name">filter</span><span class="punctuation">(</span><span class="name">active</span><span class="operator">=</span><span class="name builtin pseudo">True</span><span class="punctuation">)</span>
</pre>
<p>But now you now get warnings emitted when <tt class="docutils literal">active()</tt> is called in some cases,
even on Django 1.6 and later - in particular, you get it when you call it via a
<tt class="docutils literal">RelatedManager</tt> on Django 1.6 and later, due to the way that Django sticks
<tt class="docutils literal">get_query_set</tt> wrappers on manager subclasses that don't define
<tt class="docutils literal">get_query_set</tt> explicitly (such as <tt class="docutils literal">RelatedManager</tt>) - via
<a class="reference external" href="https://github.com/django/django/blob/stable/1.6.x/django/utils/deprecation.py#L50">RenamedMethodsBase</a>.</p>
<p>Also, if you reverse the conditional so that <tt class="docutils literal">get_queryset</tt> is called in
preference to <tt class="docutils literal">get_query_set</tt>, then <tt class="docutils literal">active()</tt> breaks as above, so you can't
do that.</p>
<p>This is trickier than it seems!</p>
<p>Due to the subclassing issue, I can't find a way, even with modifying Django's
behaviour, to satisfy all the constraints, at least if you want warnings to be
emitted when they need to be, and silenced when you've fixed your code. I've
updated the Django docs to my best ideas so far.</p>
<p><em>Update, 2015-07-08:</em></p>
<p>With Django 1.8 in the mix, it gets much worse.</p>
<p>Django 1.8 removes the <tt class="docutils literal">get_query_set</tt> compatiblity shim, and this method is
no longer defined on its <tt class="docutils literal">RelatedManager</tt> classes. Remember that these
<tt class="docutils literal">RelatedManager</tt> classes will be created by Django and will subclass whatever
manager you defined on your model. It's possible to end up with a stack like
this:</p>
<ol class="arabic simple">
<li>Base class - Django 1.8 <tt class="docutils literal">Manager</tt> class.</li>
<li>Manager sub class that uses the above pattern for compatiblity with Django 1.5,
and therefore defines a <tt class="docutils literal">get_query_set</tt> method (e.g. <tt class="docutils literal">SomeUsefulManager</tt>)</li>
<li>Another manager sub class that uses the above pattern for compatiblity with
Django 1.5, (e.g. <tt class="docutils literal">FooManager</tt> as defined above).</li>
<li>Django 1.8 <tt class="docutils literal">RelatedManager</tt> class, which does not use the above pattern or
provide a <tt class="docutils literal">get_query_set</tt> method.</li>
</ol>
<p>In this case, suppose you call the <tt class="docutils literal">.active()</tt> on the entire stack. This
resolves to <tt class="docutils literal">FooManager.active()</tt> method, which ends up calling
<tt class="docutils literal">SomeUsefulManager.get_query_set</tt> -&gt; <tt class="docutils literal">SomeUsefulManager.get_queryset</tt> -&gt;
<tt class="docutils literal">Manager.get_queryset</tt>, thus missing out <tt class="docutils literal">RelatedManager.get_queryset</tt>. The
result is, as above, a major bug where queries (including updates and deletes)
that are supposed to be limited to a related object apply to all records.</p>
<p>To fix this, you need to change the pattern so that if we are on Django 1.8, we
do not provide the <tt class="docutils literal">get_query_set</tt> method to our subclasses (but we do still
call it on our super-classes). You can't monkey-patch your way out of this, by
the way, because <tt class="docutils literal">RelatedManager</tt> classes are created dynamically. This fix
also must be applied to all managers that are attempting compatibility with
Django 1.5 to 1.8:</p>
<pre class="code python literal-block">
<span class="keyword">class</span> <span class="name class">FooManager</span><span class="punctuation">(</span><span class="name">models</span><span class="operator">.</span><span class="name">Manager</span><span class="punctuation">):</span>

    <span class="keyword">def</span> <span class="name function">get_queryset</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">):</span>
        <span class="keyword">return</span> <span class="name">FooQuerySet</span><span class="punctuation">(</span><span class="name">model</span><span class="operator">=</span><span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">model</span><span class="punctuation">)</span>

    <span class="keyword">if</span> <span class="name">django</span><span class="operator">.</span><span class="name">VERSION</span> <span class="operator">&lt;</span> <span class="punctuation">(</span><span class="literal number integer">1</span><span class="punctuation">,</span> <span class="literal number integer">6</span><span class="punctuation">):</span>
         <span class="name">get_query_set</span> <span class="operator">=</span> <span class="name">get_queryset</span>

    <span class="keyword">def</span> <span class="name function">active</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">):</span>
        <span class="name">m</span> <span class="operator">=</span> <span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">get_query_set</span>
             <span class="keyword">if</span> <span class="name builtin">hasattr</span><span class="punctuation">(</span><span class="name builtin pseudo">self</span><span class="punctuation">,</span> <span class="literal string single">'get_query_set'</span><span class="punctuation">)</span>
             <span class="keyword">else</span> <span class="name builtin pseudo">self</span><span class="operator">.</span><span class="name">get_queryset</span><span class="punctuation">)</span>
        <span class="keyword">return</span> <span class="name">m</span><span class="punctuation">()</span><span class="operator">.</span><span class="name">filter</span><span class="punctuation">(</span><span class="name">active</span><span class="operator">=</span><span class="name builtin pseudo">True</span><span class="punctuation">)</span>
</pre>
<p>Working out what the conditional should be is tricky. The above is the pattern I
decided to use in <a class="reference external" href="https://docs.djangoproject.com/en/1.8/releases/1.6/#get-query-set-and-similar-methods-renamed-to-get-queryset">the Django 1.6 release notes</a>,
which only defines the method if you are on Django 1.5. An alternative would be
to define it all the way up to Django 1.7, but you get problems either way.</p>
<p>The above pattern will only work correctly on Django 1.6 and up if all the
classes in the stack follow this pattern. Otherwise you will get methods being
missed out. So, despite the fact that Django 1.6 had compatibility shims for
code that might be slow to upgrade, you can't rely on that, and will get
potentially serious bugs if you don't upgrade your entire stack to cope with
this.</p>
</div>


    </div></body></html>