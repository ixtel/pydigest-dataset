<html><body><div><div class="post"><h1 class="post-title">Python zip( ) Fu</h1><span class="post-date"><svg class="icon-calendar"/> 27 September 2015</span><p>In functional programming iterating over few things simultaneously is called “<a href="http://stackoverflow.com/a/1115570">zip</a>”. Python has built-in <code>zip</code> function for this. From the docs:</p><p><strong>zip</strong>(<em>*iterables</em>)</p><blockquote><p>Make an iterator that aggregates elements from each of the iterables.</p><p>Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted. With a single iterable argument, it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator.</p></blockquote><p>As an example, lets consider iteration over two lists:</p><div class="highlight"><pre><code class="language-python" data-lang="python">&gt;&gt;&gt; colors = ['red', 'green', 'blue']
&gt;&gt;&gt; vals = [55, 89, 144, 233]
&gt;&gt;&gt; for col, val in zip(colors, vals):
...     print(col, val)
...
('red', 55)
('green', 89)
('blue', 144)</code></pre></div><p>As you might have noticed, example code produced exactly 3 tuples. This is equal to the length of the shortest input sequence, i.e. <code>colors</code>. Such behavior is acceptable when we don’t care about trailing, unmatched values from the longer sequences. Otherwise, usage of <code>itertools.zip_longest()</code> should be considered (<em>Python 3 only</em>).</p><p>Well, you say that’s great, but where begins the real power of <code>zip</code>? It begins when using <code>zip</code> in conjunction with the <code>*</code> operator.</p><h2 id="zip--and-the-power-of-unpacking">zip( ) and the power of unpacking</h2><p>Star <code>*</code> operator unpacks the sequence into positional arguments, as follows:</p><div class="highlight"><pre><code class="language-python" data-lang="python">&gt;&gt;&gt; def puts(arg1, arg2):
...     print(arg1)
...     print(arg2)
...
&gt;&gt;&gt; args = ('spam', 'eggs')
&gt;&gt;&gt; puts(*args)
spam
eggs</code></pre></div><p>When <code>*args</code> passed to the <code>puts</code>, it’s values <em>unpacked</em> into the function’s positional arguments <code>arg1</code> and <code>arg2</code>. It’s the same as:</p><div class="highlight"><pre><code class="language-python" data-lang="python">arg1, arg2 = ('spam', 'eggs')</code></pre></div><p>Utilizing this property and what we have learned about <code>zip</code>, let’s solve few problems in a <em>pythonic</em> manner:</p><h3 id="group-x-and-y-components-of-the-vectors-into-separate-lists">group <em>x</em> and <em>y</em> components of the vectors into separate lists</h3><div class="highlight"><pre><code class="language-python" data-lang="python">&gt;&gt;&gt; dots = [(1, 3), (2, 4), (3, 5)]
&gt;&gt;&gt; x_lst, y_lst = zip(*dots)
&gt;&gt;&gt; x_lst
(1, 2, 3)
&gt;&gt;&gt; y_lst
(3, 4, 5)</code></pre></div><h3 id="transpose-a-matrix">transpose a matrix</h3><div class="highlight"><pre><code class="language-python" data-lang="python">&gt;&gt;&gt; mtx = [(1, 2),
...        (3, 4),
...        (5, 6)]
&gt;&gt;&gt; zip(*mtx)
[(1, 3, 5), (2, 4, 6)]</code></pre></div><h3 id="rotate-a-matrix">rotate a matrix</h3><div class="highlight"><pre><code class="language-python" data-lang="python">&gt;&gt;&gt; zip(*mtx[::-1])
[(5, 3, 1), (6, 4, 2)]</code></pre></div><h3 id="clustering-a-data-series-into-n-length-groups-idiom">clustering a data series into n-length groups idiom</h3><div class="highlight"><pre><code class="language-python" data-lang="python">&gt;&gt;&gt; seq = range(1, 10)
&gt;&gt;&gt; zip(*[iter(seq)]*3)
[(1, 2, 3), (4, 5, 6), (7, 8, 9)]</code></pre></div><p>Last is difficult at glance. Here is a <a href="http://stackoverflow.com/a/2233247">good explanation</a> of what is actually happening. In short, the above code snippet is the same as:</p><div class="highlight"><pre><code class="language-python" data-lang="python">&gt;&gt;&gt; x = iter(range(1, 10))
&gt;&gt;&gt; zip(x, x, x)
[(1, 2, 3), (4, 5, 6), (7, 8, 9)]</code></pre></div><p>Try to play with it!</p><h2 id="python-dictionaries-and-zip-">Python dictionaries and zip( )</h2><p>Now, let’s take a look on how <code>zip</code> can be used to manipulate <code>dict</code>. When you have <em>keys</em> and <em>values</em> stored in different places, <code>zip</code> provides a convenient way to glue them together into the single <code>dict</code>:</p><div class="highlight"><pre><code class="language-python" data-lang="python">&gt;&gt;&gt; keys = ['spam', 'eggs']
&gt;&gt;&gt; vals = [42, 1729]
&gt;&gt;&gt; d = dict(zip(keys, vals))
&gt;&gt;&gt; d
{'eggs': 1729, 'spam': 42}</code></pre></div><p>We can invert (i.e. swap keys and values) our <code>dict</code> simply using <code>dict.values()</code> and <code>dict.keys()</code> methods:</p><div class="highlight"><pre><code class="language-python" data-lang="python">&gt;&gt;&gt; inv_d = dict(zip(d.values(), d.keys()))
&gt;&gt;&gt; inv_d
{1729: 'eggs', 42: 'spam'}</code></pre></div><p>Don’t forget that <code>dict</code> keys should be <em>hashable</em> values because basically <code>dict</code> is a hash table.</p><h2 id="summary">Summary</h2><p>Python built-in <code>zip</code> function helps to iterate over few sequences in parallel. Combined with <em>unpacking</em> and different list manipulation techniques like <em>slicing</em> and <em>comprehensions</em> it becomes a really handy tool. Moreover, combined with other functional programming tools like <code>lambda</code> expressions and <code>map</code> function it facilitates creation of readable code avoiding excessive usage of loop constructs. A good example could be found here: <a href="https://bradmontgomery.net/blog/2013/04/01/pythons-zip-map-and-lambda/">Python’s zip, map, and lambda</a>.</p><p>Next post: <a href="/digging-around-factorial-function">Digging around factorial function</a></p></div></div></body></html>