<html><body><div><div dir="ltr" id="content" lang="en"><span class="anchor" id="top"/>
<span class="anchor" id="line-1"/><p class="line867">
</p><h1 id="Sorting_Mini-HOW_TO">Sorting Mini-HOW TO</h1>
<span class="anchor" id="line-2"/><p class="line867"><strong>Original version by Andrew Dalke with a major update by Raymond Hettinger</strong> <span class="anchor" id="line-3"/><span class="anchor" id="line-4"/></p><p class="line867"/> <span class="anchor" id="line-5"/><span class="anchor" id="line-6"/><p class="line862">Python lists have a built-in <tt>sort()</tt> method that modifies the list in-place and a <tt>sorted()</tt> built-in function that builds a new sorted list from an iterable. <span class="anchor" id="line-7"/><span class="anchor" id="line-8"/></p><p class="line874">There are many ways to use them to sort data and there doesn't appear to be a single, central place in the various manuals describing them, so I'll do so here. <span class="anchor" id="line-9"/><span class="anchor" id="line-10"/></p><p class="line867">
</p><h2 id="Sorting_Basics">Sorting Basics</h2>
<span class="anchor" id="line-11"/><p class="line862">A simple ascending sort is very easy -- just call the <tt>sorted()</tt> function. It returns a new sorted list: <span class="anchor" id="line-12"/><span class="anchor" id="line-13"/></p><p class="line867"><span class="anchor" id="line-14"/><span class="anchor" id="line-15"/><span class="anchor" id="line-16"/></p><pre><span class="anchor" id="line-1"/>&gt;&gt;&gt; sorted([5, 2, 3, 1, 4])
<span class="anchor" id="line-2"/>[1, 2, 3, 4, 5]</pre><span class="anchor" id="line-17"/><p class="line862">You can also use the <tt>list.sort()</tt> method of a list. It modifies the list in-place (and returns None to avoid confusion). Usually it's less convenient than <tt>sorted()</tt> - but if you don't need the original list, it's slightly more efficient. <span class="anchor" id="line-18"/><span class="anchor" id="line-19"/></p><p class="line867"><span class="anchor" id="line-20"/><span class="anchor" id="line-21"/><span class="anchor" id="line-22"/><span class="anchor" id="line-23"/><span class="anchor" id="line-24"/></p><pre><span class="anchor" id="line-1-1"/>&gt;&gt;&gt; a = [5, 2, 3, 1, 4]
<span class="anchor" id="line-2-1"/>&gt;&gt;&gt; a.sort()
<span class="anchor" id="line-3"/>&gt;&gt;&gt; a
<span class="anchor" id="line-4"/>[1, 2, 3, 4, 5]</pre><span class="anchor" id="line-25"/><p class="line862">Another difference is that the <tt>list.sort()</tt> method is only defined for lists.  In contrast, the <tt>sorted()</tt> function accepts any iterable. <span class="anchor" id="line-26"/><span class="anchor" id="line-27"/></p><p class="line867"><span class="anchor" id="line-28"/><span class="anchor" id="line-29"/><span class="anchor" id="line-30"/></p><pre><span class="anchor" id="line-1-2"/>&gt;&gt;&gt; sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
<span class="anchor" id="line-2-2"/>[1, 2, 3, 4, 5]</pre><span class="anchor" id="line-31"/><p class="line867">
</p><h2 id="Key_Functions">Key Functions</h2>
<span class="anchor" id="line-32"/><p class="line862">Starting with Python 2.4, both <tt>list.sort()</tt> and <tt>sorted()</tt> added a <tt>key</tt> parameter to specify a function to be called on each list element prior to making comparisons. <span class="anchor" id="line-33"/><span class="anchor" id="line-34"/></p><p class="line874">For example, here's a case-insensitive string comparison: <span class="anchor" id="line-35"/><span class="anchor" id="line-36"/></p><p class="line867"><span class="anchor" id="line-37"/><span class="anchor" id="line-38"/><span class="anchor" id="line-39"/></p><pre><span class="anchor" id="line-1-3"/>&gt;&gt;&gt; sorted("This is a test string from Andrew".split(), key=str.lower)
<span class="anchor" id="line-2-3"/>['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']</pre><span class="anchor" id="line-40"/><p class="line862">The value of the <tt>key</tt> parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. <span class="anchor" id="line-41"/><span class="anchor" id="line-42"/></p><p class="line874">A common pattern is to sort complex objects using some of the object's indices as a key.  For example: <span class="anchor" id="line-43"/><span class="anchor" id="line-44"/></p><p class="line867"><span class="anchor" id="line-45"/><span class="anchor" id="line-46"/><span class="anchor" id="line-47"/><span class="anchor" id="line-48"/><span class="anchor" id="line-49"/><span class="anchor" id="line-50"/><span class="anchor" id="line-51"/><span class="anchor" id="line-52"/></p><pre><span class="anchor" id="line-1-4"/>&gt;&gt;&gt; student_tuples = [
<span class="anchor" id="line-2-4"/>        ('john', 'A', 15),
<span class="anchor" id="line-3-1"/>        ('jane', 'B', 12),
<span class="anchor" id="line-4-1"/>        ('dave', 'B', 10),
<span class="anchor" id="line-5"/>]
<span class="anchor" id="line-6"/>&gt;&gt;&gt; sorted(student_tuples, key=lambda student: student[2])   # sort by age
<span class="anchor" id="line-7"/>[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]</pre><span class="anchor" id="line-53"/><p class="line874">The same technique works for objects with named attributes.  For example: <span class="anchor" id="line-54"/><span class="anchor" id="line-55"/></p><p class="line867"><span class="anchor" id="line-56"/><span class="anchor" id="line-57"/><span class="anchor" id="line-58"/><span class="anchor" id="line-59"/><span class="anchor" id="line-60"/><span class="anchor" id="line-61"/><span class="anchor" id="line-62"/><span class="anchor" id="line-63"/><span class="anchor" id="line-64"/><span class="anchor" id="line-65"/><span class="anchor" id="line-66"/><span class="anchor" id="line-67"/><span class="anchor" id="line-68"/><span class="anchor" id="line-69"/><span class="anchor" id="line-70"/><span class="anchor" id="line-71"/><span class="anchor" id="line-72"/><span class="anchor" id="line-73"/></p><pre><span class="anchor" id="line-1-5"/>&gt;&gt;&gt; class Student:
<span class="anchor" id="line-2-5"/>        def __init__(self, name, grade, age):
<span class="anchor" id="line-3-2"/>                self.name = name
<span class="anchor" id="line-4-2"/>                self.grade = grade
<span class="anchor" id="line-5-1"/>                self.age = age
<span class="anchor" id="line-6-1"/>        def __repr__(self):
<span class="anchor" id="line-7-1"/>                return repr((self.name, self.grade, self.age))
<span class="anchor" id="line-8"/>        def weighted_grade(self):
<span class="anchor" id="line-9"/>                return 'CBA'.index(self.grade) / float(self.age)
<span class="anchor" id="line-10"/>
<span class="anchor" id="line-11"/>&gt;&gt;&gt; student_objects = [
<span class="anchor" id="line-12"/>        Student('john', 'A', 15),
<span class="anchor" id="line-13"/>        Student('jane', 'B', 12),
<span class="anchor" id="line-14"/>        Student('dave', 'B', 10),
<span class="anchor" id="line-15"/>]
<span class="anchor" id="line-16"/>&gt;&gt;&gt; sorted(student_objects, key=lambda student: student.age)   # sort by age
<span class="anchor" id="line-17"/>[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]</pre><span class="anchor" id="line-74"/><p class="line867">
</p><h2 id="Operator_Module_Functions">Operator Module Functions</h2>
<span class="anchor" id="line-75"/><p class="line862">The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The <a class="http" href="http://docs.python.org/library/operator.html#module-operator">operator module</a> has <tt>itemgetter</tt>, <tt>attrgetter</tt>, and starting in Python 2.6 a <tt>methodcaller</tt> function. <span class="anchor" id="line-76"/><span class="anchor" id="line-77"/></p><p class="line874">Using those functions, the above examples become simpler and faster. <span class="anchor" id="line-78"/><span class="anchor" id="line-79"/></p><p class="line867"><span class="anchor" id="line-80"/><span class="anchor" id="line-81"/><span class="anchor" id="line-82"/><span class="anchor" id="line-83"/><span class="anchor" id="line-84"/><span class="anchor" id="line-85"/><span class="anchor" id="line-86"/><span class="anchor" id="line-87"/></p><pre><span class="anchor" id="line-1-6"/>&gt;&gt;&gt; from operator import itemgetter, attrgetter, methodcaller
<span class="anchor" id="line-2-6"/>
<span class="anchor" id="line-3-3"/>&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(2))
<span class="anchor" id="line-4-3"/>[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
<span class="anchor" id="line-5-2"/>
<span class="anchor" id="line-6-2"/>&gt;&gt;&gt; sorted(student_objects, key=attrgetter('age'))
<span class="anchor" id="line-7-2"/>[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]</pre><span class="anchor" id="line-88"/><span class="anchor" id="line-89"/><p class="line874">The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: <span class="anchor" id="line-90"/><span class="anchor" id="line-91"/></p><p class="line867"><span class="anchor" id="line-92"/><span class="anchor" id="line-93"/><span class="anchor" id="line-94"/><span class="anchor" id="line-95"/><span class="anchor" id="line-96"/><span class="anchor" id="line-97"/></p><pre><span class="anchor" id="line-1-7"/>&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(1,2))
<span class="anchor" id="line-2-7"/>[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]
<span class="anchor" id="line-3-4"/>
<span class="anchor" id="line-4-4"/>&gt;&gt;&gt; sorted(student_objects, key=attrgetter('grade', 'age'))
<span class="anchor" id="line-5-3"/>[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]</pre><span class="anchor" id="line-98"/><span class="anchor" id="line-99"/><p class="line862">The third function from the operator module, <tt>methodcaller</tt> is used in the following example in which the weighted grade of each student is shown before sorting on it: <span class="anchor" id="line-100"/><span class="anchor" id="line-101"/><span class="anchor" id="line-102"/><span class="anchor" id="line-103"/><span class="anchor" id="line-104"/><span class="anchor" id="line-105"/></p><pre><span class="anchor" id="line-1-8"/>&gt;&gt;&gt; [(student.name, student.weighted_grade()) for student in student_objects]
<span class="anchor" id="line-2-8"/>[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
<span class="anchor" id="line-3-5"/>&gt;&gt;&gt; sorted(student_objects, key=methodcaller('weighted_grade'))
<span class="anchor" id="line-4-5"/>[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]</pre><span class="anchor" id="line-106"/><p class="line867">
</p><h2 id="Ascending_and_Descending">Ascending and Descending</h2>
<span class="anchor" id="line-107"/><p class="line862">Both <tt>list.sort()</tt> and <tt>sorted()</tt> accept a <tt>reverse</tt> parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: <span class="anchor" id="line-108"/><span class="anchor" id="line-109"/></p><p class="line867"><span class="anchor" id="line-110"/><span class="anchor" id="line-111"/><span class="anchor" id="line-112"/><span class="anchor" id="line-113"/><span class="anchor" id="line-114"/><span class="anchor" id="line-115"/></p><pre><span class="anchor" id="line-1-9"/>&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(2), reverse=True)
<span class="anchor" id="line-2-9"/>[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
<span class="anchor" id="line-3-6"/>
<span class="anchor" id="line-4-6"/>&gt;&gt;&gt; sorted(student_objects, key=attrgetter('age'), reverse=True)
<span class="anchor" id="line-5-4"/>[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]</pre><span class="anchor" id="line-116"/><p class="line867">
</p><h2 id="Sort_Stability_and_Complex_Sorts">Sort Stability and Complex Sorts</h2>
<span class="anchor" id="line-117"/><p class="line862">Starting with Python 2.2, sorts are guaranteed to be <a class="http" href="http://en.wikipedia.org/wiki/Sorting_algorithm#Stability">stable</a>. That means that when multiple records have the same key, their original order is preserved. <span class="anchor" id="line-118"/><span class="anchor" id="line-119"/></p><p class="line867"><span class="anchor" id="line-120"/><span class="anchor" id="line-121"/><span class="anchor" id="line-122"/><span class="anchor" id="line-123"/></p><pre><span class="anchor" id="line-1-10"/>&gt;&gt;&gt; data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
<span class="anchor" id="line-2-10"/>&gt;&gt;&gt; sorted(data, key=itemgetter(0))
<span class="anchor" id="line-3-7"/>[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]</pre><span class="anchor" id="line-124"/><p class="line862">Notice how the two records for <tt>'blue'</tt> retain their original order so that <tt>('blue', 1)</tt> is guaranteed to precede <tt>('blue', 2)</tt>. <span class="anchor" id="line-125"/><span class="anchor" id="line-126"/></p><p class="line874">This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: <span class="anchor" id="line-127"/><span class="anchor" id="line-128"/></p><p class="line867"><span class="anchor" id="line-129"/><span class="anchor" id="line-130"/><span class="anchor" id="line-131"/><span class="anchor" id="line-132"/></p><pre><span class="anchor" id="line-1-11"/>&gt;&gt;&gt; s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
<span class="anchor" id="line-2-11"/>&gt;&gt;&gt; sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
<span class="anchor" id="line-3-8"/>[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]</pre><span class="anchor" id="line-133"/><p class="line862">The <a class="http" href="http://en.wikipedia.org/wiki/Timsort">Timsort</a> algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. <span class="anchor" id="line-134"/><span class="anchor" id="line-135"/></p><p class="line867">
</p><h2 id="The_Old_Way_Using_Decorate-Sort-Undecorate">The Old Way Using Decorate-Sort-Undecorate</h2>
<span class="anchor" id="line-136"/><p class="line874">This idiom is called Decorate-Sort-Undecorate after its three steps: <span class="anchor" id="line-137"/><span class="anchor" id="line-138"/></p><ul><li>First, the initial list is decorated with new values that control the sort order. <span class="anchor" id="line-139"/></li><li>Second, the decorated list is sorted. <span class="anchor" id="line-140"/></li><li>Finally, the decorations are removed, creating a list that contains only the initial values in the new order. <span class="anchor" id="line-141"/><span class="anchor" id="line-142"/></li></ul><p class="line874">For example, to sort the student data by grade using the DSU approach: <span class="anchor" id="line-143"/><span class="anchor" id="line-144"/></p><p class="line867"><span class="anchor" id="line-145"/><span class="anchor" id="line-146"/><span class="anchor" id="line-147"/><span class="anchor" id="line-148"/><span class="anchor" id="line-149"/></p><pre><span class="anchor" id="line-1-12"/>&gt;&gt;&gt; decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
<span class="anchor" id="line-2-12"/>&gt;&gt;&gt; decorated.sort()
<span class="anchor" id="line-3-9"/>&gt;&gt;&gt; [student for grade, i, student in decorated]               # undecorate
<span class="anchor" id="line-4-7"/>[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]</pre><span class="anchor" id="line-150"/><p class="line874">This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. <span class="anchor" id="line-151"/><span class="anchor" id="line-152"/></p><p class="line862">It is not strictly necessary in all cases to include the index <tt>i</tt> in the decorated list. Including it gives two benefits: <span class="anchor" id="line-153"/><span class="anchor" id="line-154"/></p><p class="line862">Another name for this idiom is <a class="http" href="http://en.wikipedia.org/wiki/Schwartzian_transform">Schwartzian transform</a>, after Randal L. Schwartz, who popularized it among Perl programmers. <span class="anchor" id="line-158"/><span class="anchor" id="line-159"/></p><p class="line874">For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. <span class="anchor" id="line-160"/><span class="anchor" id="line-161"/></p><p class="line867">
</p><h2 id="The_Old_Way_Using_the_cmp_Parameter">The Old Way Using the cmp Parameter</h2>
<span class="anchor" id="line-162"/><p class="line862">Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no <tt>sorted()</tt> builtin and <tt>list.sort()</tt> took no keyword arguments. Instead, all of the Py2.x versions supported a <tt>cmp</tt> parameter to handle user specified comparison functions. <span class="anchor" id="line-163"/><span class="anchor" id="line-164"/></p><p class="line862">In Py3.0, the <tt>cmp</tt> parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the <tt>__cmp__</tt> methods). <span class="anchor" id="line-165"/><span class="anchor" id="line-166"/></p><p class="line874">In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: <span class="anchor" id="line-167"/><span class="anchor" id="line-168"/></p><p class="line867"><span class="anchor" id="line-169"/><span class="anchor" id="line-170"/><span class="anchor" id="line-171"/><span class="anchor" id="line-172"/><span class="anchor" id="line-173"/></p><pre><span class="anchor" id="line-1-13"/>&gt;&gt;&gt; def numeric_compare(x, y):
<span class="anchor" id="line-2-13"/>        return x - y
<span class="anchor" id="line-3-10"/>&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
<span class="anchor" id="line-4-8"/>[1, 2, 3, 4, 5]</pre><span class="anchor" id="line-174"/><p class="line874">Or you can reverse the order of comparison with: <span class="anchor" id="line-175"/><span class="anchor" id="line-176"/></p><p class="line867"><span class="anchor" id="line-177"/><span class="anchor" id="line-178"/><span class="anchor" id="line-179"/><span class="anchor" id="line-180"/><span class="anchor" id="line-181"/></p><pre><span class="anchor" id="line-1-14"/>&gt;&gt;&gt; def reverse_numeric(x, y):
<span class="anchor" id="line-2-14"/>        return y - x
<span class="anchor" id="line-3-11"/>&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
<span class="anchor" id="line-4-9"/>[5, 4, 3, 2, 1]</pre><span class="anchor" id="line-182"/><p class="line874">When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: <span class="anchor" id="line-183"/><span class="anchor" id="line-184"/></p><p class="line867"><span class="anchor" id="line-185"/><span class="anchor" id="line-186"/><span class="anchor" id="line-187"/><span class="anchor" id="line-188"/><span class="anchor" id="line-189"/><span class="anchor" id="line-190"/><span class="anchor" id="line-191"/><span class="anchor" id="line-192"/><span class="anchor" id="line-193"/><span class="anchor" id="line-194"/><span class="anchor" id="line-195"/><span class="anchor" id="line-196"/><span class="anchor" id="line-197"/><span class="anchor" id="line-198"/><span class="anchor" id="line-199"/><span class="anchor" id="line-200"/><span class="anchor" id="line-201"/><span class="anchor" id="line-202"/><span class="anchor" id="line-203"/></p><pre><span class="anchor" id="line-1-15"/>def cmp_to_key(mycmp):
<span class="anchor" id="line-2-15"/>    'Convert a cmp= function into a key= function'
<span class="anchor" id="line-3-12"/>    class K(object):
<span class="anchor" id="line-4-10"/>        def __init__(self, obj, *args):
<span class="anchor" id="line-5-5"/>            self.obj = obj
<span class="anchor" id="line-6-3"/>        def __lt__(self, other):
<span class="anchor" id="line-7-3"/>            return mycmp(self.obj, other.obj) &lt; 0
<span class="anchor" id="line-8-1"/>        def __gt__(self, other):
<span class="anchor" id="line-9-1"/>            return mycmp(self.obj, other.obj) &gt; 0
<span class="anchor" id="line-10-1"/>        def __eq__(self, other):
<span class="anchor" id="line-11-1"/>            return mycmp(self.obj, other.obj) == 0
<span class="anchor" id="line-12-1"/>        def __le__(self, other):
<span class="anchor" id="line-13-1"/>            return mycmp(self.obj, other.obj) &lt;= 0
<span class="anchor" id="line-14-1"/>        def __ge__(self, other):
<span class="anchor" id="line-15-1"/>            return mycmp(self.obj, other.obj) &gt;= 0
<span class="anchor" id="line-16-1"/>        def __ne__(self, other):
<span class="anchor" id="line-17-1"/>            return mycmp(self.obj, other.obj) != 0
<span class="anchor" id="line-18"/>    return K</pre><span class="anchor" id="line-204"/><p class="line874">To convert to a key function, just wrap the old comparison function: <span class="anchor" id="line-205"/><span class="anchor" id="line-206"/></p><p class="line867"><span class="anchor" id="line-207"/><span class="anchor" id="line-208"/><span class="anchor" id="line-209"/></p><pre><span class="anchor" id="line-1-16"/>&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
<span class="anchor" id="line-2-16"/>[5, 4, 3, 2, 1]</pre><span class="anchor" id="line-210"/><p class="line862">In Python 2.7, the <em>cmp_to_key()</em> tool was added to the <em>functools</em> module. <span class="anchor" id="line-211"/><span class="anchor" id="line-212"/></p><p class="line867">
</p><h2 id="Maintaining_Sort_Order">Maintaining Sort Order</h2>
<span class="anchor" id="line-213"/><p class="line862">Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve "one obvious way to do it." Instead Python delegates this task to third-party libraries that are available on the <a class="https" href="https://pypi.python.org/pypi">Python Package Index</a>. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. <span class="anchor" id="line-214"/><span class="anchor" id="line-215"/></p><ul><li><p class="line891"><a class="http" href="http://www.grantjenks.com/docs/sortedcontainers/">Python SortedContainers Module</a> - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, <a class="http" href="http://www.grantjenks.com/docs/sortedcontainers/performance.html">performance comparison</a>, and contributing/development guidelines. <span class="anchor" id="line-216"/></p></li><li><p class="line891"><a class="https" href="https://pypi.python.org/pypi/rbtree">Python rbtree Module</a> - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. <span class="anchor" id="line-217"/></p></li><li><p class="line891"><a class="https" href="https://pypi.python.org/pypi/treap">Python treap Module</a> - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. <span class="anchor" id="line-218"/></p></li><li><p class="line891"><a class="https" href="https://pypi.python.org/pypi/bintrees">Python bintrees Module</a> - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. <span class="anchor" id="line-219"/></p></li><li><p class="line891"><a class="https" href="https://pypi.python.org/pypi/Banyan">Python banyan Module</a> - Provides a fast, C-implementation for dict and set data types. <span class="anchor" id="line-220"/></p></li><li><p class="line891"><a class="https" href="https://pypi.python.org/pypi/skiplistcollections">Python skiplistcollections Module</a> - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. <span class="anchor" id="line-221"/></p></li><li><p class="line891"><a class="https" href="https://pypi.python.org/pypi/blist">Python blist Module</a> - Provides sorted list, dict and set data types based on the "blist" data type, a B-tree implementation. Implemented in Python and C. <span class="anchor" id="line-222"/><span class="anchor" id="line-223"/></p></li></ul><p class="line867">
</p><h2 id="Odd_and_Ends">Odd and Ends</h2>
<span class="anchor" id="line-224"/><ul><li><p class="line862">For locale aware sorting, use <tt>locale.strxfrm()</tt> for a key function or <tt>locale.strcoll()</tt> for a comparison function. <span class="anchor" id="line-225"/><span class="anchor" id="line-226"/></p></li><li class="gap"><p class="line862">The <tt>reverse</tt> parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin <tt>reversed</tt> function twice: <span class="anchor" id="line-227"/></p><ul><li><span class="anchor" id="line-228"/><span class="anchor" id="line-229"/><span class="anchor" id="line-230"/><pre><span class="anchor" id="line-1-17"/>&gt;&gt;&gt; data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
<span class="anchor" id="line-2-17"/>&gt;&gt;&gt; assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))</pre><span class="anchor" id="line-231"/><span class="anchor" id="line-232"/></li></ul></li><li class="gap">To create a standard sort order for a class, just add the appropriate rich comparison methods: <span class="anchor" id="line-233"/><ul><li><span class="anchor" id="line-234"/><span class="anchor" id="line-235"/><span class="anchor" id="line-236"/><span class="anchor" id="line-237"/><span class="anchor" id="line-238"/><span class="anchor" id="line-239"/><span class="anchor" id="line-240"/><span class="anchor" id="line-241"/><span class="anchor" id="line-242"/><pre><span class="anchor" id="line-1-18"/>&gt;&gt;&gt; Student.__eq__ = lambda self, other: self.age == other.age
<span class="anchor" id="line-2-18"/>&gt;&gt;&gt; Student.__ne__ = lambda self, other: self.age != other.age
<span class="anchor" id="line-3-13"/>&gt;&gt;&gt; Student.__lt__ = lambda self, other: self.age &lt; other.age
<span class="anchor" id="line-4-11"/>&gt;&gt;&gt; Student.__le__ = lambda self, other: self.age &lt;= other.age
<span class="anchor" id="line-5-6"/>&gt;&gt;&gt; Student.__gt__ = lambda self, other: self.age &gt; other.age
<span class="anchor" id="line-6-4"/>&gt;&gt;&gt; Student.__ge__ = lambda self, other: self.age &gt;= other.age
<span class="anchor" id="line-7-4"/>&gt;&gt;&gt; sorted(student_objects)
<span class="anchor" id="line-8-2"/>[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]</pre><span class="anchor" id="line-243"/><p class="line862">For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The <tt>functools.total_ordering</tt> class decorator makes this easy to implement. <span class="anchor" id="line-244"/><span class="anchor" id="line-245"/></p></li></ul></li><li class="gap">Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: <span class="anchor" id="line-246"/><ul><li><span class="anchor" id="line-247"/><span class="anchor" id="line-248"/><span class="anchor" id="line-249"/><span class="anchor" id="line-250"/><span class="anchor" id="line-251"/><pre><span class="anchor" id="line-1-19"/>&gt;&gt;&gt; students = ['dave', 'john', 'jane']
<span class="anchor" id="line-2-19"/>&gt;&gt;&gt; newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
<span class="anchor" id="line-3-14"/>&gt;&gt;&gt; sorted(students, key=newgrades.__getitem__)
<span class="anchor" id="line-4-12"/>['jane', 'dave', 'john']</pre><span class="anchor" id="line-252"/></li></ul></li></ul><span class="anchor" id="bottom"/></div></div></body></html>