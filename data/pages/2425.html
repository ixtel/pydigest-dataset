<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/files/719/289/aed/719289aed4594aeda16e9b2b0fbe2467.jpg"/>
<p>
Приближаются новогодние праздники, и было решено сделать что-то новогоднее с использованием имеющегося Raspberry Pi B-модели. До этого я использовал его в качестве веб-сервера. Затем немного игрался с GPIO на Python заставляя светиться светодиоды.
</p><p>
Что ж, небольшая искусственная елка подсказала мне как можно совместить мое желание с моими навыками. Гирлянда на светодиодах!
</p><a name="habracut"/>
<img src="https://habrastorage.org/files/7e5/a30/64c/7e5a3064c5e042a59c9e3caa0117bb9a.jpg"/>
<p>
Гирлянда? Хм… Я же смогу сам заставить ее мигать как захочу! Я сразу решил заложить возможность легко добавлять различные эффекты ее «мигания». Сделать расширяемое приложение.

</p><h4>Что нужно</h4><p>
Не буду рассказывать как включать и устанавливать ОС на Raspberry Pi. Про это написано немало статей. Скажу, что имелся Raspberry Pi Model B с установленной ОС Arch Linux. Думаю, большинство тут описанного будет справедливо и для других GNU/Linux дистрибутивов. Например, Raspbian.
</p><p>
Итак, из харда понадобится: Raspberry Pi, разноцветные светодиоды, резисторы номиналом от 100 Ом до 1 КОм, кнопка, клеммы для GPIO, провода.

</p><img src="https://habrastorage.org/files/fc7/f20/e78/fc7f20e78487472ab3f2756cfd4e13fe.jpg"/>
<p>
Количество светодиодов может быть различным. В моем случае их задействовано было 6. Подключать к GPIO выходам светодиоды необходимо через резисторы. Из-за того, что светодиоды были совершенно разного происхождения, пришлось индивидуально подбирать номинал резисторов чтобы добиться оптимальной яркости. В целом можно обойтись номиналом 330 Ом.
</p><p>
Кнопка нужна чтобы можно было с её помощью переключать эффекты гирлянды.

</p><h4>Подключаем</h4><p>
Схема подключения:

</p><img src="https://habrastorage.org/files/33c/aa5/a9f/33caa5a9fb6444c1a025c33b20b6fa04.jpg"/>
<p>
Обратите внимание на порты с пометкой GND. Это земля, их нельзя использовать как вход или выход. Для кнопки резистор не нужен. Защита от замыкания уже предусмотрена в Raspberry Pi.
</p><p>
Вот так это выглядело:

</p><img src="https://habrastorage.org/files/b2e/761/63a/b2e76163ad2f4606bd812a91ba7a1cdb.jpg"/>

<img src="https://habrastorage.org/files/e46/01c/8bf/e4601c8bfcd4435aad278e1c19c3f1e7.jpg"/>

<img src="https://habrastorage.org/files/40c/1f2/35e/40c1f235e16047c2b2ca13818e8990c1.jpg"/>
<p>
С подключением светодиодов можно экспериментировать. На некоторые порты у меня подключено парралено два светодиода для большего разнообразия.

</p><h4>Подготавливаем программное обеспечение</h4><p>
Нам понадобится Python 3. На Arch Linux я ставил так:

</p><pre><code class="bash">sudo pacman -S python
</code></pre><p>
Возможно на других дистрибутивах пакет будет называться python3.
</p><p>
Также необходим Python-модуль RPi.GPIO. Я устанавливал с помощью easy_install:

</p><pre><code class="bash">sudo easy_install RPi.GPIO
</code></pre><p>
Возможно на других дистрибутивах этот модуль есть в репозитории, так что можете поискать.
</p><p>
После подключения хорошо бы протестировать как работают наши светодиоды и кнопка. Вот небольшой пример как это можно сделать:

</p><pre><code class="python">#gpio_test.py
import RPi.GPIO as GPIO
import sys

GPIO.setmode(GPIO.BOARD)

led = 8
button = 5

# Устанавливаем порты светодиода и кнопки
GPIO.setup(led, GPIO.OUT)
GPIO.setup(button, GPIO.IN)

# Зажигаем светодиод
GPIO.output(led, 1)

# Ждём пока кнопка не нажата
while GPIO.input(button):
    pass
# Как нажали -- тушим светодиод
if GPIO.input(button) == False:
    GPIO.output(led, 0)
    print("Button pressed")

GPIO.cleanup()
</code></pre><p>
Здесь устанавливаем порт с номером из переменной led как выход, а порт с button как вход. Затем подаём на порт led сигнал 1 (зажгись!) и ждём пока кнопка не нажата. Как только кнопку нажали, тушим светодиод и зачищаемя.
</p><p>
В примере выше тестируем светодиод, подключённый к 8-му порту и кнопку, подключённую к 5-му. Запустить скрипт можно так:

</p><pre><code class="bash">sudo python3 gpio_test.py
</code></pre><p>
Обратите внимание, что выполнять скрипт нужно с root-правами. Например, используя sudo. После запуска светодиод, подключённый к 8-му порту должен зажечься. После нажатия кнопки — потухнуть, и скрипт завершит свою работу.
</p><p>
Меняя значение переменной led в скрипте на номер нужного порта можно протестировать работу всех светодиодов.

</p><h4>Моё ПО</h4><p>
Не буду подробно останавливаться на коде, который я написал далее для нужного мне функционала. Дам ссылку на github: </p><a href="https://github.com/jhekasoft/raspberry-led-garland">https://github.com/jhekasoft/raspberry-led-garland</a><p>.
</p><p>
Расскажу как настраивать и писать свои эффекты.

</p><h4>Установка</h4><p>
Поместите приложение в /opt/raspberry-led-garland или создайте симлинк. Например:

</p><pre><code class="bash">sudo ln -s /home/jheka/raspberry-led-garland /opt/raspberry-led-garland
</code></pre><p>
Конечно, размещатся оно может в любом месте, но дальше я буду рассчитывать, что оно лежит именно там.

</p><h5>Настройка</h5><p>
Конфиг находится в JSON-формате в файле settings.json. Если Вы подключили светодиоды и кнопку по схеме, котороя приводилась ранее, то в конфиге можно ничего не менять. Пример файла settings.json:

</p><pre><code class="javascript">{
    "leds": [
        {"num": 8, "state": 0},
        {"num": 11, "state": 0},
        {"num": 12, "state": 0},
        {"num": 13, "state": 0},
        {"num": 15, "state": 0},
        {"num": 16, "state": 0}
    ],
    "button": {"num": 5},
    "effects": ["static", "blink", "slow_blink", "fast_blink", "run", "fast_run", "off"],
    "logfile": "/var/log/raspberry-led-garland.log"
}
</code></pre><p>
Здесь в leds перечислены порты подключённых светодиодов (num) и их первоначально состояние (state, 0 — выключен). Количество светодиодов может быть произвольным, главное чтобы портов хватило у GPIO.
</p><p>
Далее в button установлен номер порта кнопки (num).
</p><p>
В effects перечислены имена эффектов в том порядке, в котором они будут переключаться кнопкой. Все эффекты лежат в дирректории effects в виде файла с Python-классом. 
</p><p>
Логируется всё в файл, указанный в logfile.

</p><h4>Эффекты</h4><p>
По сути сейчас есть три основных эффекта: статика, мигание и бегущий светодиод.
</p><p>
Как упомянул выше, эффекты расположены в директории effects. Вы может добавлять туда свои эффекты. Также не забудьте добавить их в конфиг. Давайте разберём эффект blink. Вот его содержимое:

</p><pre><code class="python">#blink.py
import RPi.GPIO as GPIO

class GarlandEffect(object):
    delay = 1.0
    ledstate = 0

    def __init__(self, garland):
        self.garland = garland
        self.ledstate = 1

    def iterate(self):
        if not self.garland.checkIterationDelay(self.delay):
            return False

        self.garland.setLedsState(self.ledstate)
        self.garland.gpioOutSetState()
        self.ledstate = 1 - self.ledstate

        return True
</code></pre><p>
При инициализации (функция __init__) устанавливаем ему объект гирлянды (garland). Это должно происходить практически в каждом эффекте. Далее указываем начальное состояние для всех светодиодов 1 (включены).
</p><p>
При каждой итерации (функция iterate) проеряем, а не прошло ли время, равное установленной задержки в 1 секунду (delay = 1.0). Если нет, то ничего не делаем (return False). Если прошло, то устанавливаем состояние ledstate всем светодиодам и меняем значение переменной состояния на обратное чтобы на следующей итерации оно было другим.
</p><p>
Взглянем ещё на эффект fast_blink:

</p><pre><code class="python">#fast_blink.py
import effects.blink

class GarlandEffect(effects.blink.GarlandEffect):
    delay = 0.1
</code></pre><p>
Как видим, он наследуется от blink и у него установлена задержка в 0.1 секунду. То есть это всё тот же blink, просто с меньшей задержкой между итерацией — светодиоды быстрее мигают.
</p><p>
Обратите внимание на эффект с именем off. В нём при инициализации тушаться все светодиоды и ничего не происходит при итерации. Таким образом реализовано затухание гирлянды.

</p><h4>systemd сервис</h4><p>
Чтобы гирлянда была автономной и работала после старта системы я написал небольшой конфиг для запуска нашего скрипка как сервиса. Файл systemd/garland.service необходимо скопировать в /etc/systemd/system/. Затем выполнить:

</p><pre><code class="bash">sudo systemctl enable garland.service
</code></pre><p>
Скрипт запустится при старте системы. Для немедленного запуска можно выполнить это:

</p><pre><code class="bash">sudo systemctl start garland.service
</code></pre><p>
Надеюсь, не обидетесь за использование systemd. Она на Arch Linux уже давно и я к ней привык. В своё время тоже холиварили по этому поводу.

</p><h4>Демо</h4><p>
Вот как это выглядит:

</p><iframe src="https://www.youtube.com/embed/LzOqd2I7T7M?feature=oembed" frameborder="0" allowfullscreen="">VIDEO</iframe>

<iframe src="https://www.youtube.com/embed/vw-3WvY2TMk?feature=oembed" frameborder="0" allowfullscreen="">VIDEO</iframe>
<p>
Надеюсь вы также подключитесь к этому делу и сделаете свои гирлянды с большим количеством светодиодов, а также напишите свои интересные эффекты! С наступающими!
      </p><p class="clear"/>
    </div>

    
  </div></body></html>