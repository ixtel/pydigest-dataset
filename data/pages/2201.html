<html><body><div><div class="content html_format">
      <h4>Вступление</h4><p>
Это, так сказать, «бонусная» статья в моей серии статей о плагинах к медиацентру Kodi (XBMC). Прежде всего, необходимо отметить, что, начиная с версии 14.0, популярный медиацентр меняет название с XBMC на Kodi. О причинах смены названия можно почитать на официальном сайте и форуме, и для нашей статьи они не принципиальны. Однако дальше в статье будет использоваться новое название — Kodi.</p><a name="habracut"/>

<h5>Предыдущие статьи</h5>
<a href="http://habrahabr.ru/post/193374/">Подробная анатомия простого плагина для XBMC</a>
<a href="http://habrahabr.ru/post/193704/">Пишем плагин для XBMC с собственным интерфейсом: часть I — теория и простейший пример</a>
<a href="http://habrahabr.ru/post/194124/">Пишем плагин для XBMC с собственным интерфейсом: часть II — диалоги и украшателства</a>
<a href="http://habrahabr.ru/post/194380/">Пишем плагин для XBMC с собственным интерфейсом: часть III — API и микро-фреймворк</a>

<h4>xbmcswift2</h4><p>
В первой статье — </p><a href="http://habrahabr.ru/post/193374/">«Подробная анатомия простого плагина для XBMC»</a><p> — было рассказано о базовых принципах работы плагинов-источников контента, т. е. плагинов, которые позволяют смотреть видео и слушать музыку с различных онлайновых ресурсов. Этих базовых принципов два:
</p><ol>
<li>Каждый элемент виртуального каталога (ссылка на подраздел или файл для проигрывания) представляет собой объект класса <b>xbmcgui.listItem</b>, содержащий всю информацию об элементе виртуального каталога. При создании списка элементов мы последовательно создаем объекты <b>xbmcgui.listItem</b>, задаем их свойства (эскиз, фанарт, ссылка, дополнительная информация) и «скармливаем» эти элементы функции <b>xbmcplugin.addDirectoryItem</b>.</li>
<li>Для создания многоуровневых каталогов плагин рекурсивно вызывает сам себя, передавая параметры в виде URL-encoded строки через элемент списка sys.argv[2]. При этом нам нужно декодировать эти параметры и вызвать соответствующую часть кода, чтобы, например, сформировать каталог нижнего уровня (подраздел) или воспроизвести видео по ссылке. Т. е. нам нужно организовать маршрутизацию таких рекурсивных вызовов.</li>
</ol><p>
В результате на разработчика плагина возлагается лишняя работа, не связанная непосредственно с получением информации, организацией контента и его воспроизведением.
</p><p>
При создании xbmcswift2 разработчик, очевидно, вдохновлялся популярными микро-фреймворками Python для веб-разработки — Flask и Bottle. Механизм маршрутизации рекурсивных вызовов явно позаимствован у этих фреймворков — пути вызовов и передача параметров реализованы через декораторы функций.</p><p>
Кроме этого, в xbmcswift2 унифицирована структура элементов виртуальных каталогов. Теперь отдельный элемент представляет собой питоновский словарь со всеми необходимыми свойствами в виде пар ключ—значение. Эти элементы объединяются в список, и для отображения списка элементов в интерфейсе Kodi функция, «украшенная» декоратором маршрута, должна вернуть этот список. Дальнейшую обработку списка и декодирование словарей, описывающих элементы этого списка, берет на себя xbmcswift2.</p><p>
Помимо упрощения создания списков контента и маршрутизации рекурсивных вызовов xbmcswift2 предлагает такие приятные возможности, как кэширование объектов, возвращаемых функциями и методами, а также постоянное хранилище для хранения состояния объектов между рекурсивными вызовами. xbmcswift2 также позволяет выполнять отладку кода плагина в консоли, без использования Kodi.
</p><p>
Чтобы проиллюстрировать использование xbmcswift2, я возьму плагин из статьи </p><a href="http://habrahabr.ru/post/193374/">«Подробная анатомия простого плагина для XBMC»</a><p> и перепишу под этот фреймворк. Для простоты новый плагин не будет выводить никаких сообщений на экран, поэтому языковые файлы в нем отсутствуют.

</p><div class="spoiler"><b class="spoiler_title">Код плагина</b><div class="spoiler_text"><pre><code class="python"># -*- coding: utf-8 -*-
# Name:        plugin.video.cnet
# Author:      Roman V.M.
# Created:     02.02.2014
# Licence:     GPL v.3: http://www.gnu.org/copyleft/gpl.html

# Импортируем стандартные модули
import sys
import os
import urllib2
import xml.dom.minidom
# Импортируем xbmcswift2
from xbmcswift2 import Plugin

# Создаем объект plugin
plugin = Plugin()
# Получаем путь к плагину
addon_path = plugin.addon.getAddonInfo('path').decode('utf-8')
# Комбинируем путь к значкам
thumbpath = os.path.join(addon_path, 'resources', 'thumbnails')
# Комбинируем путь к фанарту
fanart = os.path.join(addon_path, 'fanart.jpg')
# Импортируем собственный модуль
sys.path.append(os.path.join(addon_path, 'resources', 'lib'))
from feeds import FEEDS


# Кэшируем объект, возвращаемый функцией (список), на 30 мин.
@plugin.cached(30)
def rss_parser(url):
    listing = []
    try:
        HEADER = {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; rv:18.0) Gecko/20100101 Firefox/20.0'}
        request = urllib2.Request(url, None, HEADER)
        rss = xml.dom.minidom.parse(urllib2.urlopen(request, None, 3))
    except urllib2.URLError:
        pass
    else:
        titles = rss.getElementsByTagName('title')
        links = rss.getElementsByTagName('link')
        for title, link in zip(titles[2:], links[2:]):
            title = title.toxml().replace('&lt;title&gt;&lt;![CDATA[', '').replace(']]&gt;&lt;/title&gt;', '')
            link = link.toxml().replace('&lt;link&gt;', '').replace('&lt;/link&gt;', '')
            listing.append((title, link))
    return listing


# Корневой путь
@plugin.route('/')
def feed_index():
    feed_list = []
    for i in range(len(FEEDS)):
        # Прописываем свойства каждого раздела.
        # Текстовая подпись:
        feed = {'label': FEEDS[i]['label'],
                # Эскиз:
                'thumbnail': os.path.join(thumbpath, FEEDS[i]['thumb']),
                # Дополнительные свойства объекта (фонарт):
                'properties': {'fanart_image': fanart},
                # Комбинируем путь к объекту.
                'path': plugin.url_for('podcast_index', feed=str(i))}
        feed_list.append(feed)
    # Возвращаем список разделов подкастов с дополнительными свойствами:
    # метод сортировки списка и режим отображения ("Эскизы" в скине Confluence).
    return plugin.finish(feed_list, sort_methods=['label'], view_mode=500)


# Список подкастов в разделе
@plugin.route('/feeds/&lt;feed&gt;')
def podcast_index(feed):
    feedNo = int(feed)
    quality = plugin.addon.getSetting('quality')
    # Получаем список подкастов в данном разделе.
    podcasts = rss_parser(url=FEEDS[feedNo][quality])
    thumb = os.path.join(thumbpath, FEEDS[feedNo]['thumb'])
    podcast_list = []
    for podcast in podcasts:
        item = {'label': podcast[0],
                'thumbnail': thumb,
                'properties': {'fanart_image': fanart},
                'path': plugin.url_for('play_podcast', url=podcast[1]),
                # Указываем, что данный объект не содержит вложенных объектов (видео для воспроизведения).
                'is_playable': True}
        podcast_list.append(item)
    # Возвращаем список подкастов без дополнительных ствойств
    return podcast_list


@plugin.route('/play/&lt;url&gt;')
def play_podcast(url):
    # Отдаем команду Kodi воспроизвести видео по ссылке.
    plugin.set_resolved_url(url)


if __name__ == '__main__':
    # Запускаем плагин.
    plugin.run()
</code></pre>
</div></div>
<p>
Теперь, как всегда, построчный разбор. Для отображения номеров строк используйте текстовый редактор с соответствующей функцией, например Notepad++. Очевидные вещи и то, что понятно из комментариев, пропускаю.
</p><p>
30: декоратор </p><i>@plugin.cached()</i><p> используется для кэширования объектов, возвращаемых функциями или методами. Таким декоратором рекомендуется «украшать» функции, получающие содержимое с веб-сайтов, чтобы не создавать излишнюю нагрузку на эти сайты. Срок кэширования в минутах задается в качестве параметра декоратора.</p><p>
49: декоратор </p><i>@plugin.route()</i><p> используется для маршрутизации вызовов плагина. Плагин в обязательном порядке должен содержать как минимум корневой маршрут ('/').</p><p>
55—61: свойства элемента списка задаются в виде достаточно простого и понятного словаря.</p><p>
61: метод </p><i>url_for()</i><p> формирует правильный путь для рекурсивного вызова плагина, чтобы этот путь мог быть декодирован xbmcswift2. В качестве первого параметра используется имя вызываемой функции в виде строки, а дополнительная информация передается через именованные параметры. В качестве параметров можно использовать только простые строки. Соответственно, все другие типы данных должны быть приведены к строкам. Символы, отличные от ASCII, можно передавать в виде URL-encoded последовательности (например, «Вася» &gt; «%D0%92%D0%B0%D1%81%D1%8F » или в кодировке base64.</p><p>
65: метод </p><i>finish()</i><p> используется для передачи дополнительных параметров отображения списка контента (помимо самого списка). Если никаких дополнительных параметров возвращать не нужно, можно вернуть сам список, не используя метод </p><i>finish()</i><p>.</p><p>
69,70: вызываем функцию, которая формирует список подкастов. В качестве параметра передаем номер раздела в списке (точнее, tuple) FEEDS.</p><p>
83: указываем, что этот элемент не содержит вложенных элементов (в данном случае элемент списка — файл для проигрывания). По умолчанию этот параметр равен False, поэтому в предыдущей функции он опущен.</p><p>
89—90: здесь для отправки файла в основной код Kodi на проигрывание используется специальная функция </p><i>play_podcast()</i><p>, которая, в свою очередь, вызывает метод </p><i>set_resolved_url()</i><p>. Этот метод представляет собой «обертку» xbmcswift2 вокруг стандартной функции Kodi Python API </p><i>xbmcplugin.setResolvedUrl()</i><p>. Использование </p><i>xbmcplugin.setResolvedUrl()</i><p> плохо документировано, но именно такой метод является предпочтительным для запуска проигрывания мультимедийных файлов. Безусловно, можно использовать прямые ссылки на эти файлы (и в примере из статьи </p><a href="http://habrahabr.ru/post/193374/">«Подробная анатомия простого плагина для XBMC»</a><p> был использован простой вариант с прямыми ссылками), но при использовании прямых ссылок имеются нежелательные побочные эффекты. Например, при формировании списка файлов Kodi старается прочитать метаданные этих файлов, что при большом количестве элементов списка и медленном соединении приводит к тому, что список формируется очень долго. Кроме того, при использовании прямых ссылок не поддерживаются автозакладки и отметки просмотренного. Причина последнего непонятна (по всей видимости, баг.) Однако в случае использования xbmcplugin.setResolvedUrl() и его аналога из xbmcswift2 — </p><i>set_resolved_url()</i><p> — этих побочных эффектов не наблюдается.

</p><h4>Заключение</h4><p>
Микрофреймврок xbmcswift2 доступен в официальном репозитории Kodi, и при создании плагина на его основе микро-фреймворк нужно указать в качестве зависимости в файле метаданных плагина Kodi — addon.xml. Подробнее об этом см. в предыдущих статьях и в официальной Вики.</p><p>
Готовый демонстрационный плагин на базе xbmcswift2 можно загрузить </p><a href="https://cloud.mail.ru/public/3e5395cb9896/plugin.video.cnet-0.0.2.zip">отсюда</a><p>.
</p><p>
Надеюсь, информация из этих статей поможет вам в написании полезных плагинов для Kodi. Как показывает практика, самая сложная задача при написании плагина — это вытащить ссылки на видео или музыку с того или иного сайта, а уже организовать информацию и ссылки в плагине значительно проще.

</p><h4>Источники информации</h4>
<a href="https://xbmcswift2.readthedocs.org/en/latest/">Официальная документация xbmcswift2</a><p>.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>