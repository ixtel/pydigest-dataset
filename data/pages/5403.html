<html><body><div><div id="content">
  


<h1>A couple quick tips</h1>

<p class="meta">Published <a href="/weblog/2015/jul/22/">July 22, 2015</a>. Filed under:
  
<a href="/weblog/categories/django/">Django</a>, <a href="/weblog/categories/python/">Python</a>.
  
</p><p>As noted <a href="/weblog/2015/jul/20/news-and-such/">the other day</a>, I’ve spent the last little while working to freshen up <a href="/projects/">various bits of open-source code I maintain</a>, in order to make sure all of them have at least one recent release. Along the way I’ve picked up a few little tips and tricks; some of them may be old hat to you if you’ve been lucky enough to be working with fairly modern Django and Python versions for a while, but I think they’re still worth sharing. Today I’d like to dive into two in particular that are relevant for people who write and distribute Django applications.</p>
<h2>Tell people about your Django version compatibility!</h2>
<p>One big complaint that I’ve heard several times — and run into more than once myself — about the Django application ecosystem is that it’s sometimes difficult to figure out which versions of Django a particular application is compatible with. The obvious place to mention this is in an application’s documentation (and if you’re a Django application author and you <em>don’t</em> have some documentation, you are, as the kids say these days, doing it wrong). Usually I try to make sure Django version compatibility (and Python version compatibility) gets mentioned at least once in the documentation for anything I write; for example, <a href="/projects/django-flashpolicies/">django-flashpolicies</a> lists Django and Python version compatibility in <a href="http://django-flashpolicies.readthedocs.org/en/latest/install.html">its installation instructions</a>. And just to be extra careful, it provides that information again <a href="http://django-flashpolicies.readthedocs.org/en/latest/faq.html#what-versions-of-django-are-supported">in its <span class="caps">FAQ</span></a>.</p>
<p>And while you should have this mentioned somewhere in your documentation (my preference is to do it in a “how to install this” document), there’s one other place where you can and should mention Django version compatibility: in your trove classifiers.</p>
<p>Trove classifiers are part of your application’s <code>setup.py</code> file, and are used to provide some extra metadata about your code, which can then be displayed, filtered, searched on, etc. by users of the Python Package Index or other tools which work with packaged Python code. PyPI publishes <a href="https://pypi.python.org/pypi?%3Aaction=list_classifiers">a full list of current trove classifiers</a>, and making good use of them can help significantly with your application’s discoverability.</p>
<p>But there are two sets of classifiers in particular that I want to encourage people to use. One set indicates Python version compatibility, and lets you indicate a package that’s Python-2-only, a package that’s Python-3-only, a package that works on both, and which specific releases your package works on. Going back to the example of <code>django-flashpolicies</code>, it includes these trove classifiers in <a href="https://github.com/ubernostrum/django-flashpolicies/blob/master/setup.py">its setup.py</a>:</p>
<div class="codehilite"><pre><span class="s">'Programming Language :: Python :: 2'</span><span class="p">,</span>
<span class="s">'Programming Language :: Python :: 2.7'</span><span class="p">,</span>
<span class="s">'Programming Language :: Python :: 3'</span><span class="p">,</span>
<span class="s">'Programming Language :: Python :: 3.3'</span><span class="p">,</span>
<span class="s">'Programming Language :: Python :: 3.4'</span><span class="p">,</span>
</pre></div>


<p>This tells anyone who’s searching/filtering (and PyPI has an interface for doing that) that <code>django-flashpolicies</code>  works on both Python 2 and Python 3, and specifically supports Python 2.7, 3.3 and 3.4 (the same set of versions supported by the last two releases of Django itself).</p>
<p>For years now, PyPI has also had a trove classifier to indicate a package is meant to work with Django (the classifier is <code>Framework :: Django</code>). But recently, the kind folks who run PyPI added an extra set of classifiers to indicate Django version compatibility. Which means <code>django-flashpolicies</code> can also include this information in its <code>setup.py</code>:</p>
<div class="codehilite"><pre><span class="s">'Framework :: Django :: 1.7'</span><span class="p">,</span>
<span class="s">'Framework :: Django :: 1.8'</span><span class="p">,</span>
</pre></div>


<p>And voilà! Now we don’t even have to turn to the documentation (though this still should be mentioned in your documentation) to find out whether something is compatible with the latest version of Django — we can see it <a href="https://pypi.python.org/pypi/django-flashpolicies">right from the listing page on PyPI</a> (under “Categories”), and best of all those classifiers turn into links which can be used to filter for packages. So if you want to see <a href="https://pypi.python.org/pypi?:action=browse&amp;show=all&amp;c=214&amp;c=605">all packages compatible with Django 1.8</a>, you can, and if you’re like me and you’re running Django 1.8 on Python 3.4, you can see <a href="https://pypi.python.org/pypi?:action=browse&amp;show=all&amp;c=214&amp;c=587&amp;c=605">all packages compatible with both of those</a>.</p>
<p>So next time you’re packaging up a Django application for others to use, remember to set the correct trove classifiers in your <code>setup.py</code> — I, and many other people, will thank you for it.</p>
<h2>Make it easy to run your tests</h2>
<p>The Python ecosystem is fortunate to have an almost embarrassing number of good testing tools, so for most types of Python-based projects the difficult part is choosing <em>which</em> great testing tool you’ll use. Distributing a Django application with tests can be slightly trickier, though, because even though Django has good built-in testing tools (and is easy to integrate with popular third-party testing frameworks), you need to configure Django in order to run the tests.</p>
<p>When you’re just running your test suite locally on your own computer, this isn’t so bad; you can set up a virtualenv with a bare-bones Django project in it, and use <code>manage.py test</code>. When you’re trying to distribute an application to other people, and especially when you’re trying to use online continuous-integration services like <a href="https://travis-ci.org/">Travis <span class="caps">CI</span></a>, though, that’s not an option.</p>
<p>Fortunately, Django is easy to configure in “standalone” mode, and easy to configure in a way that’s not dependent on the specifics of the system it will run on. The particular two-step involved here is actually a bit more than two steps, but it’s still fairly simple:</p>
<ol>
<li>Create a dictionary containing the settings you’ll need.</li>
<li>Call Django’s <a href="https://docs.djangoproject.com/en/1.8/topics/settings/#using-settings-without-setting-django-settings-module">settings.configure()</a>, passing in the dictionary of settings as keyword arguments.</li>
<li>Call <a href="https://docs.djangoproject.com/en/1.8/ref/applications/#how-applications-are-loaded">django.setup()</a> to load your settings and populate Django’s application registry.</li>
<li>Instantiate a test runner and invoke it.</li>
</ol>
<p>All of this is covered in <a href="https://docs.djangoproject.com/en/1.8/topics/testing/advanced/#using-the-django-test-runner-to-test-reusable-applications">Django’s own testing documentation</a>, which shows how easy it is to create a single file to run your application’s tests.</p>
<p>One thing not mentioned there is that it’s also easy to provide a standard and non-Django-specific entry point to running your tests. For years, the <code>setuptools</code> project has provided the ability to specify a test runner in a package’s <code>setup.py</code> file, which makes running tests as easy as <code>setup.py test</code>. Historically I’ve avoided <code>setuptools</code> because of a lot of baggage and (in my opinion) poor design decisions, but the state of Python packaging has significantly improved in recent years, to the point where I’m comfortable making use of <code>setuptools</code> at least for this particular convenience. The result is that, once you write your standalone test-runner script (by the convention in the Django documentation, called <code>runtests.py</code>), you can simply add the relevant bits to your application’s <code>setup.py</code> file and suddenly <code>setup.py test</code> will just work:</p>
<div class="codehilite"><pre><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>

<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"yourapp"</span><span class="p">,</span>
      <span class="n">zip_safe</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
      <span class="c"># …other options here…</span>
      <span class="n">packages</span><span class="o">=</span><span class="p">[</span><span class="s">'yourapp'</span><span class="p">,</span> <span class="s">'yourapp.migrations'</span><span class="p">,</span> <span class="s">'yourapp.tests'</span><span class="p">],</span>
      <span class="n">test_suite</span><span class="o">=</span><span class="p">[</span><span class="s">'yourapp.runtests.run_tests'</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>


<p>Other than changing the import to be <code>from setuptools import setup</code> instead of <code>from distutils.core import setup</code>, there is one important change to make when doing this: the <code>zip_safe=False</code> argument, which is <code>setuptools</code>-specific, and ensures that <code>setuptools</code> won’t try to distribute or install your package as a zipped “egg” file (this would be an example of the negative baggage <code>setuptools</code> brings — eggs were an attempt to emulate Java’s <abbr title="Java Archive"><span class="caps">JAR</span></abbr> as a single-file distribution format, and only really succeeded at being confusing and requiring everyone else to implement workarounds for accidental egg installation). And while Django can handle an application installed as an egg, I strongly recommend not using or allowing them, for a few reasons:</p>
<ul>
<li>They’re sufficiently different from everything else in the standard Python ecosystem that they’ll just confuse your users.</li>
<li>If you need a simple single-file, pre-built distribution format, <a href="http://pythonwheels.com/">wheel</a> is a better solution and has support in standard Python packaging tools.</li>
<li>Third-party packages may not be expecting or able to work properly with your application if it’s distributed/installed as an egg.</li>
<li>And Django itself will probably <a href="https://groups.google.com/forum/#!topic/django-developers/60E1uUuK2yU">drop support for eggs in the near future</a>.</li>
</ul>
<p>At any rate, being able to simply use <code>setup.py test</code> is pretty compelling, and makes the process of documenting how to run your tests, or integrating with online testing tools, a whole lot easier. For reference, <a href="https://github.com/ubernostrum/django-project-portfolio/blob/master/projects/runtests.py">here’s a full example of a runtests.py file</a> (from <a href="/projects/django-project-portfolio/">django-project-portfolio</a>), and <a href="https://github.com/ubernostrum/django-project-portfolio/blob/master/setup.py">here’s a full example setup.py using it</a>.</p>


  </div>
  

  </div></body></html>