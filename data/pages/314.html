<html><body><div><div class="content_body" data-subscribe="true" data-view="content#body"><h2 id="how-to-run-unit-tests-without-testing-your-patience">How to Run Unit Tests Without Testing Your Patience</h2>

<p>More often than not, the software we write directly interacts with what we would label as “dirty” services. In layman’s terms: services that are crucial to our application, but whose interactions have intended but undesired side-effects—that is, undesired in the context of an autonomous test run.</p>

<p>For example: perhaps we’re writing a social app and want to test out our new ‘Post to Facebook feature’, but don’t want to <em>actually</em> post to Facebook every time we run our test suite.</p>

<p>The Python <code>unittest</code> library includes a subpackage named <code>unittest.mock</code>—or if you declare it as a dependency, simply <code>mock</code>—which provides extremely powerful and useful means by which to mock and stub out these undesired side-effects.</p>

<p><img src="//assets.toptal.io/uploads/blog/image/252/toptal-blog-image-1389090346415.png" alt="mocking and unit tests in python"/></p>

<p><em>Note: <code>mock</code> is <a href="http://www.python.org/dev/peps/pep-0417/">newly included</a> in the standard library as of Python 3.3; prior distributions will have to use the Mock library downloadable via <a href="https://pypi.python.org/pypi/mock">PyPI</a>.</em></p>

<h2 id="fear-system-calls">Fear System Calls</h2>

<p>To give you another example, and one that we’ll run with for the rest of the article, consider <strong>system calls</strong>. It’s not difficult to see that these are prime candidates for mocking: whether you’re writing a script to eject a CD drive, a web server which removes antiquated cache files from <code>/tmp</code>, or a socket server which binds to a TCP port, these calls all feature undesired side-effects in the context of your unit-tests.</p>

<p class="pop_out_box is-full_width is-big">
As a developer, you care more that your library successfully called the system function for ejecting a CD as opposed to experiencing your CD tray open every time a test is run.
</p>

<p>As a developer, you care more that your library successfully called the system function for ejecting a CD (with the correct arguments, etc.) as opposed to actually experiencing your CD tray open every time a test is run. (Or worse, multiple times, as multiple tests reference the eject code during a single unit-test run!)</p>

<p>Likewise, keeping your unit-tests efficient and performant means keeping as much “slow code” out of the automated test runs, namely filesystem and network access.</p>

<p>For our first example, we’ll refactor a standard Python test case from original form to one using <code>mock</code>. We’ll demonstrate how writing a test case with mocks will make our tests smarter, faster, and able to reveal more about how the software works.</p>

<h2 id="a-simple-delete-function">A Simple Delete Function</h2>

<p>We all need to delete files from our filesystem from time to time, so let’s write a function in Python which will make it a bit easier for our scripts to do so.</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os

def rm(filename):
    os.remove(filename)
</code></pre>

<p>Obviously, our <code>rm</code> method at this point in time doesn’t provide much more than the underlying <code>os.remove</code> method, but our codebase will improve, allowing us to add more functionality here.</p>

<p>Let’s write a traditional test case, i.e., without mocks:</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

from mymodule import rm

import os.path
import tempfile
import unittest

class RmTestCase(unittest.TestCase):

    tmpfilepath = os.path.join(tempfile.gettempdir(), "tmp-testfile")

    def setUp(self):
        with open(self.tmpfilepath, "wb") as f:
            f.write("Delete me!")
        
    def test_rm(self):
        # remove the file
        rm(self.tmpfilepath)
        # test that it was actually removed
        self.assertFalse(os.path.isfile(self.tmpfilepath), "Failed to remove the file.")
</code></pre>

<p>Our test case is pretty simple, but every time it is run, a temporary file is created and then deleted. Additionally, we have no way of testing whether our <code>rm</code> method properly passes the argument down to the <code>os.remove</code> call. We can <em>assume</em> that it does based on the test above, but much is left to be desired.</p>

<h3 id="refactoring-with-mocks">Refactoring with Mocks</h3>

<p>Let’s refactor our test case using <code>mock</code>:</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

from mymodule import rm

import mock
import unittest

class RmTestCase(unittest.TestCase):
    
    @mock.patch('mymodule.os')
    def test_rm(self, mock_os):
        rm("any path")
        # test that rm called os.remove with the right parameters
        mock_os.remove.assert_called_with("any path")
</code></pre>

<p>With these refactors, we have fundamentally changed the way that the test operates. Now, we have an <em>insider</em>, an object we can use to verify the functionality of another.</p>

<h4 id="potential-pitfalls">Potential Pitfalls</h4>

<p>One of the first things that should stick out is that we’re using the <code>mock.patch</code> method decorator  to mock an object located at <code>mymodule.os</code>, and injecting that mock into our test case method. Wouldn’t it make more sense to just mock <code>os</code> itself, rather than the reference to it at <code>mymodule.os</code>?</p>

<p>Well, Python is somewhat of a sneaky snake when it comes to imports and managing modules. At runtime, the <code>mymodule</code> module has its own <code>os</code> which is imported into its own local scope in the module. Thus, if we mock <code>os</code>, we won’t see the effects of the mock in the <code>mymodule</code> module.</p>

<p>The mantra to keep repeating is this:</p>

<blockquote>
  <p>Mock an item <em>where it is used</em>, not where it came from.</p>
</blockquote>

<p>If you need to mock the <code>tempfile</code> module for <code>myproject.app.MyElaborateClass</code>, you probably need to apply the mock to <code>myproject.app.tempfile</code>, as each module keeps its own imports.</p>

<p>With that pitfall out of the way, let’s keep mocking.</p>

<h3 id="adding-validation-to-rm">Adding Validation to ‘rm’</h3>

<p>The <code>rm</code> method defined earlier is quite oversimplified. We’d like to have it validate that a path exists and is a file before just blindly attempting to remove it. Let’s refactor <code>rm</code> to be a bit smarter:</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import os.path

def rm(filename):
    if os.path.isfile(filename):
        os.remove(filename)
</code></pre>

<p>Great. Now, let’s adjust our test case to keep coverage up.</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

from mymodule import rm

import mock
import unittest

class RmTestCase(unittest.TestCase):
    
    @mock.patch('mymodule.os.path')
    @mock.patch('mymodule.os')
    def test_rm(self, mock_os, mock_path):
        # set up the mock
        mock_path.isfile.return_value = False
        
        rm("any path")
        
        # test that the remove call was NOT called.
        self.assertFalse(mock_os.remove.called, "Failed to not remove the file if not present.")
        
        # make the file 'exist'
        mock_path.isfile.return_value = True
        
        rm("any path")
        
        mock_os.remove.assert_called_with("any path")
</code></pre>

<p>Our testing paradigm has completely changed. We now can verify and validate internal functionality of methods without <em>any</em> side-effects.</p>

<h3 id="file-removal-as-a-service">File-Removal as a Service</h3>

<p>So far, we’ve only been working with supplying mocks for functions, but not for methods on objects or cases where mocking is necessary for sending parameters. Let’s cover object methods first.</p>

<p>We’ll begin with a refactor of the <code>rm</code> method into a service class. There really isn’t a justifiable need, per se, to encapsulate such a simple function into an object, but it will at the very least help us demonstrate key concepts in <code>mock</code>. Let’s refactor:</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import os.path

class RemovalService(object):
    """A service for removing objects from the filesystem."""

    def rm(filename):
        if os.path.isfile(filename):
            os.remove(filename)
</code></pre>

<p>You’ll notice that not much has changed in our test case:</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

from mymodule import RemovalService

import mock
import unittest

class RemovalServiceTestCase(unittest.TestCase):
    
    @mock.patch('mymodule.os.path')
    @mock.patch('mymodule.os')
    def test_rm(self, mock_os, mock_path):
        # instantiate our service
        reference = RemovalService()
        
        # set up the mock
        mock_path.isfile.return_value = False
        
        reference.rm("any path")
        
        # test that the remove call was NOT called.
        self.assertFalse(mock_os.remove.called, "Failed to not remove the file if not present.")
        
        # make the file 'exist'
        mock_path.isfile.return_value = True
        
        reference.rm("any path")
        
        mock_os.remove.assert_called_with("any path")
</code></pre>

<p>Great, so we now know that the <code>RemovalService</code> works as planned. Let’s create another service which declares it as a dependency:</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import os.path

class RemovalService(object):
    """A service for removing objects from the filesystem."""

    def rm(self, filename):
        if os.path.isfile(filename):
            os.remove(filename)
            

class UploadService(object):

    def __init__(self, removal_service):
        self.removal_service = removal_service
        
    def upload_complete(self, filename):
        self.removal_service.rm(filename)
</code></pre>

<p>Since we already have test coverage on the <code>RemovalService</code>, we’re not going to validate internal functionality of the <code>rm</code> method in our tests of <code>UploadService</code>. Rather, we’ll simply test (without side-effects, of course) that <code>UploadService</code> <em>calls</em> the <code>RemovalService.rm</code> method, which we know “just works™” from our previous test case.</p>

<p>There are two ways to go about this:</p>

<ol>
  <li>Mock out the <code>RemovalService.rm</code> method itself.</li>
  <li>Supply a mocked instance in the constructor of <code>UploadService</code>.</li>
</ol>

<p>As both methods are often important in unit-testing, we’ll review both.</p>

<h4 id="option-1-mocking-instance-methods">Option 1: Mocking Instance Methods</h4>

<p>The <code>mock</code> library has a special method decorator for mocking object instance methods and properties, the <code>@mock.patch.object</code> decorator:</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

from mymodule import RemovalService, UploadService

import mock
import unittest

class RemovalServiceTestCase(unittest.TestCase):
    
    @mock.patch('mymodule.os.path')
    @mock.patch('mymodule.os')
    def test_rm(self, mock_os, mock_path):
        # instantiate our service
        reference = RemovalService()
        
        # set up the mock
        mock_path.isfile.return_value = False
        
        reference.rm("any path")
        
        # test that the remove call was NOT called.
        self.assertFalse(mock_os.remove.called, "Failed to not remove the file if not present.")
        
        # make the file 'exist'
        mock_path.isfile.return_value = True
        
        reference.rm("any path")
        
        mock_os.remove.assert_called_with("any path")
      
      
class UploadServiceTestCase(unittest.TestCase):

    @mock.patch.object(RemovalService, 'rm')
    def test_upload_complete(self, mock_rm):
        # build our dependencies
        removal_service = RemovalService()
        reference = UploadService(removal_service)
        
        # call upload_complete, which should, in turn, call `rm`:
        reference.upload_complete("my uploaded file")
        
        # check that it called the rm method of any RemovalService
        mock_rm.assert_called_with("my uploaded file")
        
        # check that it called the rm method of _our_ removal_service
        removal_service.rm.assert_called_with("my uploaded file")
</code></pre>

<p>Great! We’ve validated that the <code>UploadService</code> successfully calls our instance’s <code>rm</code> method. Notice anything interesting in there? The patching mechanism actually replaced the <code>rm</code> method of all <code>RemovalService</code> instances in our test method. That means that we can actually inspect the instances themselves. If you want to see more, try dropping in a breakpoint in your mocking code to get a good feel for how the patching mechanism works.</p>

<h4 id="pitfall-decorator-order">Pitfall: Decorator Order</h4>

<p>When using multiple decorators on your test methods, <em>order is important</em>, and it’s kind of confusing. Basically, when mapping decorators to method parameters, <a href="http://www.voidspace.org.uk/python/mock/patch.html#nesting-patch-decorators">work backwards</a>. Consider this example:</p>

<pre><code>    @mock.patch('mymodule.sys')
    @mock.patch('mymodule.os')
    @mock.patch('mymodule.os.path')
    def test_something(self, mock_os_path, mock_os, mock_sys):
        pass
</code></pre>

<p>Notice how our parameters are matched to the reverse order of the decorators? That’s partly because of <a href="http://docs.python.org/2/reference/compound_stmts.html#function-definitions">the way that Python works</a>. With multiple method decorators, here’s the order of execution in pseudocode:</p>

<pre><code>patch_sys(patch_os(patch_os_path(test_something)))
</code></pre>

<p>Since the patch to <code>sys</code> is the outermost patch, it will be executed last, making it the last parameter in the actual test method arguments. Take note of this well and use a debugger when running your tests to make sure that the right parameters are being injected in the right order.</p>

<h4 id="option-2-creating-mock-instances">Option 2: Creating Mock Instances</h4>

<p>Instead of mocking the specific instance method, we could instead just supply a mocked instance to <code>UploadService</code> with its constructor. I prefer option 1 above, as it’s  a lot more precise, but there are many cases where option 2 might be efficient or necessary. Let’s refactor our test again:</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

from mymodule import RemovalService, UploadService

import mock
import unittest

class RemovalServiceTestCase(unittest.TestCase):
    
    @mock.patch('mymodule.os.path')
    @mock.patch('mymodule.os')
    def test_rm(self, mock_os, mock_path):
        # instantiate our service
        reference = RemovalService()
        
        # set up the mock
        mock_path.isfile.return_value = False
        
        reference.rm("any path")
        
        # test that the remove call was NOT called.
        self.assertFalse(mock_os.remove.called, "Failed to not remove the file if not present.")
        
        # make the file 'exist'
        mock_path.isfile.return_value = True
        
        reference.rm("any path")
        
        mock_os.remove.assert_called_with("any path")
      
      
class UploadServiceTestCase(unittest.TestCase):

    def test_upload_complete(self, mock_rm):
        # build our dependencies
        mock_removal_service = mock.create_autospec(RemovalService)
        reference = UploadService(mock_removal_service)
        
        # call upload_complete, which should, in turn, call `rm`:
        reference.upload_complete("my uploaded file")
        
        # test that it called the rm method
        mock_removal_service.rm.assert_called_with("my uploaded file")
</code></pre>

<p>In this example, we haven’t even had to patch any functionality, we simply create an auto-spec for the <code>RemovalService</code> class, and then inject this instance into our <code>UploadService</code> to validate the functionality.</p>

<p>The <a href="http://www.voidspace.org.uk/python/mock/helpers.html#autospeccing"><code>mock.create_autospec</code></a> method creates a functionally equivalent instance to the provided class. What this means, practically speaking, is that when the returned instance is interacted with, it will raise exceptions if used in illegal ways. More specifically, if a method is called with the wrong number of arguments, an exception will be raised. This is extremely important as refactors happen. As a library changes, tests break and that is expected. Without using an auto-spec, our tests will still pass even though the underlying implementation is broken.</p>

<h4 id="pitfall-the-mockmock-and-mockmagicmock-classes">Pitfall: The <code>mock.Mock</code> and <code>mock.MagicMock</code> Classes</h4>

<p>The <code>mock</code> library also includes two important classes upon which most of the internal functionality is built upon: <code>[mock.Mock</code>](http://www.voidspace.org.uk/python/mock/mock.html) and <a href="http://www.voidspace.org.uk/python/mock/magicmock.html#magic-mock"><code>mock.MagicMock</code></a>. When given a choice to use a <code>mock.Mock</code> instance, a <code>mock.MagicMock</code> instance, or an auto-spec, always favor using an auto-spec, as it helps keep your tests sane for future changes. This is because <code>mock.Mock</code> and <code>mock.MagicMock</code> accept all method calls and property assignments regardless of the underlying API. Consider the following use case:</p>

<pre><code>class Target(object):
    def apply(value):
        return value

def method(target, value):
    return target.apply(value)
</code></pre>

<p>We can test this with a <code>mock.Mock</code> instance like this:</p>

<pre><code>class MethodTestCase(unittest.TestCase):

    def test_method(self):
        target = mock.Mock()

        method(target, "value")

        target.apply.assert_called_with("value")
</code></pre>

<p>This logic seems sane, but let’s modify the <code>Target.apply</code> method to take more parameters:</p>

<pre><code>class Target(object):
    def apply(value, are_you_sure):
        if are_you_sure:
            return value
        else:
            return None
</code></pre>

<p>Re-run your test, and you’ll find that it still passes. That’s because it isn’t built against your actual API. This is why you should <em>always</em> use the <code>create_autospec</code> method and the <code>autospec</code> parameter with the <code>@patch</code> and <code>@patch.object</code> decorators.</p>

<h2 id="real-world-example-mocking-a-facebook-api-call">Real-World Example: Mocking a Facebook API Call</h2>

<p>To finish up, let’s write a more applicable real-world example, one which we mentioned in the introduction: posting a message to Facebook. We’ll write a nice wrapper class and a corresponding test case.</p>

<pre><code>import facebook

class SimpleFacebook(object):
    
    def __init__(self, oauth_token):
        self.graph = facebook.GraphAPI(oauth_token)

    def post_message(self, message):
        """Posts a message to the Facebook wall."""
        self.graph.put_object("me", "feed", message=message)
</code></pre>

<p>Here’s our test case, which checks that we post the message without <em>actually</em> posting the message:</p>

<pre><code>import facebook
import simple_facebook
import mock
import unittest

class SimpleFacebookTestCase(unittest.TestCase):
    
    @mock.patch.object(facebook.GraphAPI, 'put_object', autospec=True)
    def test_post_message(self, mock_put_object):
        sf = simple_facebook.SimpleFacebook("fake oauth token")
        sf.post_message("Hello World!")

        # verify
        mock_put_object.assert_called_with(message="Hello World!")
</code></pre>

<p>As we’ve seen so far, it’s <em>really</em> simple to start writing smarter tests with <code>mock</code> in Python.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Python’s <code>mock</code> library, if a little confusing to work with, is a game-changer for <a href="https://www.toptal.com/qa/how-to-write-testable-code-and-why-it-matters">unit-testing</a>. We’ve demonstrated common use-cases for getting started using <code>mock</code> in unit-testing, and hopefully this article will help <a href="https://www.toptal.com/python">Python developers</a> overcome the initial hurdles and write excellent, tested code.</p>
<div class="blog_author_big_banner is-active" data-ga-action="ClickedOnHireTheAuthor_bottom" data-ga-label="an-introduction-to-mocking-in-python" data-view="content#bottom_banner"><h2>About the author</h2><div class="skill_talent for-blog_post"><div class="skill_talent-main"><a class="link skill_talent-name" href="/resume/tyler-kocheran">Naftuli Tzvi Kay, United States</a><div class="clearfix"><p class="skill_talent-member_since">member since October 4, 2011</p></div><div class="skill_talent-description"><p>Naftuli Tzvi is a software developer and systems administrator with top-of-class ability across a variety of platforms, languages, and systems.  </p><a class="link" href="/resume/tyler-kocheran">[click to continue...]</a></div></div></div></div><p class="template" data-role="subscribe_template" data-template="{&quot;html&quot;:&quot;\u003cdiv class=\&quot;embeddable_form-wrapper\&quot; data-view=\&quot;blog_subscribe#form\&quot;\u003e\u003cform action=\&quot;/blog/subscription\&quot; class=\&quot;embeddable_form for-post\&quot; data-entity=\&quot;blog_subscription\&quot; data-remote=\&quot;\&quot; data-view=\&quot;form#form\&quot; method=\&quot;post\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-step is-email_form is-current\&quot; data-role=\&quot;step\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-row is-label\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-label_title\&quot;\u003eLike what you\u0026#39;re reading?\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-label\&quot;\u003eGet the latest updates first.\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row form-field is-email_field\&quot;\u003e\u003cinput autocomplete=\&quot;off\&quot; class=\&quot;input is-medium\&quot; data-role=\&quot;email\&quot; name=\&quot;blog_subscription[email]\&quot; placeholder=\&quot;Enter your email address...\&quot; type=\&quot;text\&quot; /\u003e\u003cinput name=\&quot;blog_subscription[vertical]\&quot; type=\&quot;hidden\&quot; value=\&quot;developers\&quot; /\u003e\u003cinput name=\&quot;from_widget\&quot; type=\&quot;hidden\&quot; value=\&quot;true\&quot; /\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-submit\&quot;\u003e\u003cinput class=\&quot;button is-green_candy is-default is-full_width\&quot; data-loader-text=\&quot;Subscribing...\&quot; data-role=\&quot;submit\&quot; type=\&quot;submit\&quot; value=\&quot;Get Exclusive Updates\&quot; /\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-privacy\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-privacy\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-privacy_icon\&quot;\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-privacy_text\&quot;\u003eNo spam. Just great engineering and design posts.\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-step is-confirmation\&quot; data-role=\&quot;step\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-row is-label is-success\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-label_title\&quot;\u003eLike what you\u0026#39;re reading?\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-label\&quot;\u003eGet the latest updates first.\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-success\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-label is-header\&quot;\u003eThank you for subscribing!\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-label\&quot;\u003eYou can edit your subscription preferences \u003ca href='#' data-role='preferences_link'\u003ehere\u003c/a\u003e.\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\&quot;embeddable_form-row is-success\&quot;\u003e\u003cdiv class=\&quot;embeddable_form-done\&quot;\u003e\u003cul class=\&quot;blog_follow_us\&quot;\u003e\u003cul class=\&quot;social_share\&quot;\u003e\u003cli class=\&quot;social_share-item is-facebook\&quot;\u003e\u003cdiv class=\&quot;fb-like\&quot; data-href=\&quot;https://www.toptal.com/blog\&quot; data-layout=\&quot;button_count\&quot; data-send=\&quot;false\&quot; data-show-faces=\&quot;false\&quot; data-width=\&quot;450\&quot;\u003e\u003c/div\u003e\u003c/li\u003e\u003cli class=\&quot;social_share-item is-twitter_follow\&quot;\u003e\u003ca class=\&quot;twitter-follow-button\&quot; data-show-count=\&quot;true\&quot; href=\&quot;https://twitter.com/toptalllc\&quot;\u003eFollow @toptalllc\u003c/a\u003e\u003c/li\u003e\u003cli class=\&quot;social_share-item is-google_plus_follow\&quot;\u003e\u003cdiv class=\&quot;g-follow\&quot; data-annotation=\&quot;bubble\&quot; data-height=\&quot;20\&quot; data-href=\&quot;https://plus.google.com/109028009576318848424\&quot; data-rel=\&quot;publisher\&quot;\u003e\u003c/div\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/form\u003e\u003c/div\u003e&quot;}"/></div></div></body></html>