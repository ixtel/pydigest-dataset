<html><body><div><div class="entry-content clearfix">
  	<p>So, when using <a href="http://www.sqlalchemy.org">SqlAlchemy</a> declarative base, I came up with the need of importing every single model into the current namespace before I can create them in the database.</p>
<p>This is not a problem if you have a single models.py file.</p>

<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>from</span> app.<span>models</span> <span>import</span> *
Model.<span>metadata</span>.<span>create_all</span><span>(</span>bind<span>=</span>engine<span>)</span></pre></td></tr></table></div>

<p>But for larger projects, you can pretty much have 10, 20, 30 model files inside a models module this can quickly become annoying or simply verbose – not to mention the occasional omission.</p>
<p>I saw several different approaches, some hackish, some elegant, but none doing precisely what I wanted to do; namely, scan a module and import all classes that inherits from my base Model class.</p>
<p>I wanted to use Python’s own tools to solve this, trying not to rely in hackish solutions but rather leverage Python’s internal mechanism to scan and load modules. That said, I ended up creating a utils function that looks within a module for any subclass of a given baseclass and imports them into a given scope.</p>
<p>It uses pkgutil.iter_modules to iterate through all files of a module, loads that module into a variable and uses inspect.getmembers to get every class inside the module.</p>

<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>import</span> <span>inspect</span>
<span>import</span> <span>pkgutil</span>
 
 
<span>def</span> import_all_subclasses_of<span>(</span>module_to_scan<span>,</span> baseclass<span>,</span> scope<span>)</span>:
    <span>"""
    :param module_to_scan: Module to scan.
    :param baseclass: A base class to check.
    :param scope: globals(), locals() or a dict-like object.
    """</span>
    path <span>=</span> module_to_scan.__path__
    <span>for</span> mod <span>in</span> <span>pkgutil</span>.<span>iter_modules</span><span>(</span>path<span>)</span>:
        module <span>=</span> mod<span>[</span><span>0</span><span>]</span>.<span>find_module</span><span>(</span>mod<span>[</span><span>1</span><span>]</span><span>)</span>.<span>load_module</span><span>(</span>mod<span>[</span><span>1</span><span>]</span><span>)</span>
 
        <span>for</span> name<span>,</span> obj <span>in</span> <span>inspect</span>.<span>getmembers</span><span>(</span>module<span>,</span> <span>inspect</span>.<span>isclass</span><span>)</span>:
            <span>if</span> <span>issubclass</span><span>(</span>obj<span>,</span> baseclass<span>)</span> <span>and</span> name <span>!=</span> baseclass.__name__:
                scope<span>[</span>name<span>]</span> <span>=</span> obj</pre></td></tr></table></div>

<p>The usage ?</p>

<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>from</span> app <span>import</span> models
<span>from</span> sqlalchemy.<span>ext</span>.<span>declarative</span> <span>import</span> declarative_base
 
Model <span>=</span> declarative_base<span>(</span>name<span>=</span><span>'Model'</span><span>)</span>
 
<span>def</span> init_db<span>(</span><span>)</span>:
    import_all_subclasses_of<span>(</span>models<span>,</span> Model<span>,</span> <span>locals</span><span>(</span><span>)</span><span>)</span>
    Model.<span>metadata</span>.<span>create_all</span><span>(</span>bind<span>=</span>engine<span>)</span></pre></td></tr></table></div>

<p>I must say that although I think I came up with a somewhat elegant solution, I’m still not entirely happy with it. The line that loads the module by using find_module and then load_module looks unnecessary to me, but I didn’t manage to find a better way of using the Module Loader object that pkgutil.iter_modules returns.</p>
<p>But it works. Oh boy, it works just fine.</p>
<p>PS: Maybe I could simply have a custom metaclass for my base Model class registering in a registry and then using it without messing up SqlAlchemy’s internals. But I like the generic-ness of this solution.</p>
<p id="wp_fb_like_button"><like href="http://blog.alienretro.com/importing-all-sqlalchemy-models-classes-dynamically/" send="false" layout="standard" show_faces="false" font="arial" action="like" colorscheme="light"/></p>        <h3>Use Facebook to Comment on this Post</h3>
        <p id="fb-root"/><comments href="http://blog.alienretro.com/importing-all-sqlalchemy-models-classes-dynamically/" num_posts="8"/>  </div> 
  
    
  </div></body></html>