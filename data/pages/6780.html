<html><body><div><div class="section" id="abstract">
   
   <p>
    Several modern programming languages have so-called "
    <tt class="docutils literal">
     null
    </tt>
    -coalescing" or
"
    <tt class="docutils literal">
     null
    </tt>
    - aware" operators, including C#
    <a class="footnote-reference" href="#id7" id="id1">
     [1]
    </a>
    , Dart
    <a class="footnote-reference" href="#id8" id="id2">
     [2]
    </a>
    , Perl, Swift, and PHP
(starting in version 7). These operators provide syntactic sugar for common
patterns involving null references.
   </p>
   <ul class="simple">
    <li>
     The "
     <tt class="docutils literal">
      null
     </tt>
     -coalescing" operator is a binary operator that returns its left
operand if it is not
     <tt class="docutils literal">
      null
     </tt>
     . Otherwise it returns its right operand.
    </li>
    <li>
     The "
     <tt class="docutils literal">
      null
     </tt>
     -aware member access" operator accesses an instance member only
if that instance is non-
     <tt class="docutils literal">
      null
     </tt>
     . Otherwise it returns
     <tt class="docutils literal">
      null
     </tt>
     . (This is also
called a "safe navigation" operator.)
    </li>
    <li>
     The "
     <tt class="docutils literal">
      null
     </tt>
     -aware index access" operator accesses an element of a collection
only if that collection is non-
     <tt class="docutils literal">
      null
     </tt>
     . Otherwise it returns
     <tt class="docutils literal">
      null
     </tt>
     . (This
is another type of "safe navigation" operator.)
    </li>
   </ul>
   <p>
    The purpose of this PEP is to explore the possibility of implementing similar
operators in Python. It provides some background material and then offers
several competing alternatives for implementation.
   </p>
   <p>
    The initial reaction to this idea is majority negative. Even if ultimately
rejected, this PEP still serves a purpose: to fully document the reasons why
Python should not add this behavior, so that it can be pointed to in the future
when the question inevitably arises again. (This is the null alternative, so to
speak!)
   </p>
   <p>
    This proposal advances multiple alternatives, and it should be considered
severable. It may be accepted in whole or in part. For example, the safe
navigation operators might be rejected even if the
    <tt class="docutils literal">
     null
    </tt>
    -coalescing operator
is approved, or vice-versa.
   </p>
   <p>
    Of course, Python does not have
    <tt class="docutils literal">
     null
    </tt>
    ; it has
    <tt class="docutils literal">
     None
    </tt>
    , which is conceptually
distinct. Although this PEP is inspired by "
    <tt class="docutils literal">
     null
    </tt>
    -aware" operators in other
languages, it uses the term "
    <tt class="docutils literal">
     None
    </tt>
    -aware" operators to describe some
hypothetical Python implementations.
   </p>
  </div>
  <div class="section" id="background">
   
   <div class="section" id="specialness-of-none">
    
    <p>
     The Python language does not currently define any special behavior for
     <tt class="docutils literal">
      None
     </tt>
     .
This PEP suggests making
     <tt class="docutils literal">
      None
     </tt>
     a special case. This loss of generality is a
noticeable drawback of the proposal. A generalization of
     <tt class="docutils literal">
      None
     </tt>
     -aware
operators is set forth later in this document in order to avoid this
specialization.
    </p>
   </div>
   <div class="section" id="utility-of-none">
    
    <p>
     One common criticism of adding special syntax for
     <tt class="docutils literal">
      None
     </tt>
     is that
     <tt class="docutils literal">
      None
     </tt>
     shouldn't be used in the first place: it's a code smell. A related criticism is
that
     <tt class="docutils literal">
      None
     </tt>
     -aware operators are used to silence errors (such as the novice
misunderstanding of an implicit
     <tt class="docutils literal">
      return None
     </tt>
     ) akin to
     <a class="reference external" href="http://php.net/manual/en/language.operators.errorcontrol.php">
      PHP's @ operator
     </a>
     . Therefore,
the utility of
     <tt class="docutils literal">
      None
     </tt>
     must be debated before discussing whether to add new
behavior around it.
    </p>
    <p>
     Python does not have any concept of
     <tt class="docutils literal">
      null
     </tt>
     . Every Python identifier must
refer to an instance, so there cannot be any
     <tt class="docutils literal">
      null
     </tt>
     references. Python does
have a special instance called
     <tt class="docutils literal">
      None
     </tt>
     that can be used to represent missing
values, but
     <tt class="docutils literal">
      None
     </tt>
     is conceptually distinct from
     <tt class="docutils literal">
      null
     </tt>
     .
    </p>
    <p>
     The most frequent use of
     <tt class="docutils literal">
      None
     </tt>
     in Python is to provide a default value for
optional arguments when some other default object is unwieldy. For example:
     <tt class="docutils literal">
      def get(url, proxy=None):
     </tt>
     . In this case,
     <tt class="docutils literal">
      proxy
     </tt>
     is an optional
argument. If
     <tt class="docutils literal">
      proxy
     </tt>
     is
     <tt class="docutils literal">
      None
     </tt>
     , then the request should be sent directly to
the server; otherwise, the request should be routed through the specified proxy
server. This use of
     <tt class="docutils literal">
      None
     </tt>
     is preferred here to some other sentinel value or
the Null Object Pattern.
     <a class="footnote-reference" href="#id9" id="id3">
      [3]
     </a>
    </p>
    <p>
     Examples of this form abound. Consider
     <tt class="docutils literal">
      types.py
     </tt>
     in the standard library:
    </p>
    <pre class="literal-block">
def prepare_class(name, bases=(), kwds=None):
    if kwds is None:
        kwds = {}
    else:
        kwds = dict(kwds)
    ...
</pre>
    <p>
     Another frequent use of
     <tt class="docutils literal">
      None
     </tt>
     is interfacing with external systems. Many of
those other systems have a concept of
     <tt class="docutils literal">
      null
     </tt>
     . Therefore, Python code must have
a way of representing
     <tt class="docutils literal">
      null
     </tt>
     , and typically it is represented by
     <tt class="docutils literal">
      None
     </tt>
     . For
example, databases can have
     <tt class="docutils literal">
      null
     </tt>
     values, and most Python database drivers
will convert
     <tt class="docutils literal">
      null
     </tt>
     to
     <tt class="docutils literal">
      None
     </tt>
     when retrieving data from a database, and will
convert from
     <tt class="docutils literal">
      None
     </tt>
     back to
     <tt class="docutils literal">
      null
     </tt>
     when sending data to a database.
    </p>
    <p>
     This convention of interchanging
     <tt class="docutils literal">
      null
     </tt>
     and
     <tt class="docutils literal">
      None
     </tt>
     is widespread in Python.
It is canonized in the Python DBAPI (PEP-249).
     <a class="footnote-reference" href="#id10" id="id4">
      [4]
     </a>
     The
     <tt class="docutils literal">
      json
     </tt>
     module in the
standard library and the third party PyYAML package both use
     <tt class="docutils literal">
      None
     </tt>
     to
represent their respective languages'
     <tt class="docutils literal">
      null
     </tt>
     .
    </p>
    <p>
     The C language
     <tt class="docutils literal">
      null
     </tt>
     often bleeds into Python, too, particularly for thin
wrappers around C libraries. For example, in
     <tt class="docutils literal">
      pyopenssl
     </tt>
     , the
     <tt class="docutils literal">
      X509
     </tt>
     class
has
     <a class="reference external" href="https://github.com/pyca/pyopenssl/blob/3257877f8846e4357b495fa6c9344d01b11cf16d/OpenSSL/crypto.py#L1219">
      a get_notBefore() method
     </a>
     that returns either a timestamp or
     <tt class="docutils literal">
      None
     </tt>
     . This
function is a thin wrapper around an OpenSSL function with the return type
     <tt class="docutils literal">
      ASN1_TIME *
     </tt>
     . Because this C pointer may be
     <tt class="docutils literal">
      null
     </tt>
     , the Python wrapper must
be able to represent
     <tt class="docutils literal">
      null
     </tt>
     , and
     <tt class="docutils literal">
      None
     </tt>
     is the chosen representation.
    </p>
    <p>
     The representation of
     <tt class="docutils literal">
      null
     </tt>
     is particularly noticeable when Python code is
marshalling data between two systems. For example, consider a Python server that
fetches data from a database and converts it to JSON for consumption by another
process. In this case, it's often desirable that
     <tt class="docutils literal">
      null
     </tt>
     in the database can be
easily translated to
     <tt class="docutils literal">
      null
     </tt>
     in JSON. If
     <tt class="docutils literal">
      None
     </tt>
     is not used for this purpose,
then each package will have to define its own representation of
     <tt class="docutils literal">
      null
     </tt>
     , and
converting between these representations adds unnecessary complexity to the
Python glue code.
    </p>
    <p>
     Therefore, the preference for avoiding
     <tt class="docutils literal">
      None
     </tt>
     is nothing more than a
preference.
     <tt class="docutils literal">
      None
     </tt>
     has legitimate uses, particularly in specific types of
software. Any hypothetical
     <tt class="docutils literal">
      None
     </tt>
     -aware operators should be construed as
syntactic sugar for simplifying common patterns involving
     <tt class="docutils literal">
      None
     </tt>
     , and
     <em>
      should
not be construed
     </em>
     as error handling behavior.
    </p>
   </div>
   <div class="section" id="behavior-in-other-languages">
    
    <p>
     Given that
     <tt class="docutils literal">
      null
     </tt>
     -aware operators exist in other modern languages, it may be
helpful to quickly understand how they work in those languages.
    </p>
    <p>
     C# example:
    </p>
    <pre class="literal-block">
/* Null-coalescing. */

String s1 = null;
String s2 = "hello";
String s3 = s1 ?? s2;
Console.WriteLine("s3 is: " + s3);
// s3 is: hello

/* Null-aware member access, a.k.a. safe navigation. */

Console.WriteLine("s1.Length is: " + s1?.Length);
Console.WriteLine("s2.Length is: " + s2?.Length);
// s1.Length is:
// s2.Length is: 5

/* Null-aware index access, a.k.a. safe navigation. */

Dictionary&lt;string,string&gt; d1 = null;
Dictionary&lt;string,string&gt; d2 = new Dictionary&lt;string, string&gt;
{
    { "foo", "bar" },
    { "baz", "bat" }
};

Console.WriteLine("d1[\"foo\"] is: " + d1?["foo"]);
Console.WriteLine("d2[\"foo\"] is: " + d2?["foo"]);
// d1["foo"] is:
// d2["foo"] is: bar

/* Short Circuiting */

Console.WriteLine("s1 trim/upper is: " + s1?.Trim().Length);
Console.WriteLine("s2 trim/upper is: " + s2?.Trim().Length);
// s1 trimmed length is:
// s2 trimmed length is: 5

String s4 = s1 ?? s2 ?? DoError();
Console.WriteLine("s4 is: " + s4)
// s4 is: hello
</pre>
    <p>
     A
     <a class="reference external" href="https://dotnetfiddle.net/SxQNG8">
      working example
     </a>
     can be viewed online.
    </p>
    <p>
     Of utmost importance, notice the short circuiting behavior. The short circuiting
of
     <tt class="docutils literal">
      <span class="pre">
       ??
      </span>
     </tt>
     is similar to short circuiting of other boolean operators such as
     <tt class="docutils literal">
      ||
     </tt>
     or
     <tt class="docutils literal">
      &amp;&amp;
     </tt>
     and should not be surprising. Helpfully,
     <cite>
      ?.
     </cite>
     is
     <em>
      also
     </em>
     short
circuiting:
     <tt class="docutils literal">
      <span class="pre">
       s1?.Trim()
      </span>
     </tt>
     evaluates to null, but
     <tt class="docutils literal">
      <span class="pre">
       s1?.Trim().Length
      </span>
     </tt>
     does not
attempt to dereference the
     <tt class="docutils literal">
      null
     </tt>
     pointer.
    </p>
   </div>
  </div>
  <div class="section" id="rationale">
   
   <div class="section" id="existing-alternatives">
    
    <p>
     Python does not have any specific
     <tt class="docutils literal">
      None
     </tt>
     -aware operators, but it does have
operators that can be used for a similar purpose. This section describes why
these alternatives may be undesirable for some common
     <tt class="docutils literal">
      None
     </tt>
     patterns.
    </p>
    <div class="section" id="or-operator">
     
     <p>
      Similar behavior can be achieved with the
      <tt class="docutils literal">
       or
      </tt>
      operator, but
      <tt class="docutils literal">
       or
      </tt>
      checks
whether its left operand is false-y, not specifically
      <tt class="docutils literal">
       None
      </tt>
      . This can lead
to surprising behavior. Consider the scenario of computing the price of some
products a customer has in his/her shopping cart:
     </p>
     <pre class="literal-block">
&gt;&gt;&gt; price = 100
&gt;&gt;&gt; requested_quantity = 5
&gt;&gt;&gt; default_quantity = 1
&gt;&gt;&gt; (requested_quantity or default_quantity) * price
500
&gt;&gt;&gt; requested_quantity = None
&gt;&gt;&gt; (requested_quantity or default_quantity) * price
100
&gt;&gt;&gt; requested_quantity = 0
&gt;&gt;&gt; (requested_quantity or default_quantity) * price # oops!
100
</pre>
     <p>
      An experienced Python developer should know how
      <tt class="docutils literal">
       or
      </tt>
      works and be capable of
avoiding bugs like this. However, getting in the habit of using
      <tt class="docutils literal">
       or
      </tt>
      for this
purpose still might cause an experienced developer to occasionally make this
mistake, especially when refactoring existing code and not carefully paying
attention to the possible values of the left-hand operand.
     </p>
     <p>
      For inexperienced developers, the problem is worse. The top Google hit for
"python null coalesce" is a
      <a class="reference external" href="http://stackoverflow.com/questions/4978738/is-there-a-python-equivalent-of-the-c-sharp-null-coalescing-operator">
       StackOverflow page
      </a>
      , and the top answer says to use
      <tt class="docutils literal">
       or
      </tt>
      .
The top answer goes on to explain the caveats of using
      <tt class="docutils literal">
       or
      </tt>
      like this, but how
many beginning developers go on to read all those caveats? The accepted answer
on
      <a class="reference external" href="http://stackoverflow.com/questions/13710631/is-there-shorthand-for-returning-a-default-value-if-none-in-python">
       a more recent question
      </a>
      says to use
      <tt class="docutils literal">
       or
      </tt>
      without any caveats at all. These two questions have a combined 26,000
views!
     </p>
     <p>
      The common usage of
      <tt class="docutils literal">
       or
      </tt>
      for the purpose of providing default values is
undeniable, and yet it is also booby-trapped for unsuspecting newcomers. This
suggests that a safe operator for providing default values would have positive
utility. While some critics claim that
      <tt class="docutils literal">
       None
      </tt>
      -aware operators will be abused
for error handling, they are no more prone to abuse than
      <tt class="docutils literal">
       or
      </tt>
      is.
     </p>
    </div>
    <div class="section" id="ternary-operator">
     
     <p>
      Another common way to intialize default values is to use the ternary operator.
Here is an excerpt from the popular
      <a class="reference external" href="https://github.com/kennethreitz/requests/blob/14a555ac716866678bf17e43e23230d81a8149f5/requests/models.py#L212">
       Requests package
      </a>
      :
     </p>
     <pre class="literal-block">
data = [] if data is None else data
files = [] if files is None else files
headers = {} if headers is None else headers
params = {} if params is None else params
hooks = {} if hooks is None else hooks
</pre>
     <p>
      This particular formulation has the undesirable effect of putting the operands
in an unintuitive order: the brain thinks, "use
      <tt class="docutils literal">
       data
      </tt>
      if possible and use
      <tt class="docutils literal">
       []
      </tt>
      as a fallback," but the code puts the fallback
      <em>
       before
      </em>
      the preferred
value.
     </p>
     <p>
      The author of this package could have written it like this instead:
     </p>
     <pre class="literal-block">
data = data if data is not None else []
files = files if files is not None else []
headers = headers if headers is not None else {}
params = params if params is not None else {}
hooks = hooks if hooks is not None else {}
</pre>
     <p>
      This ordering of the operands is more intuitive, but it requires 4 extra
characters (for "not "). It also highlights the repetition of identifiers:
      <tt class="docutils literal">
       data if data
      </tt>
      ,
      <tt class="docutils literal">
       files if files
      </tt>
      , etc. This example benefits from short
identifiers, but what if the tested expression is longer and/or has side
effects? This is addressed in the next section.
     </p>
    </div>
   </div>
   <div class="section" id="motivating-examples">
    
    <p>
     The purpose of this PEP is to simplify some common patterns involving
     <tt class="docutils literal">
      None
     </tt>
     .
This section presents some examples of common
     <tt class="docutils literal">
      None
     </tt>
     patterns and explains
the drawbacks.
    </p>
    <p>
     This first example is from a Python web crawler that uses the popular Flask
framework as a front-end. This function retrieves information about a web site
from a SQL database and formats it as JSON to send to an HTTP client:
    </p>
    <pre class="literal-block">
class SiteView(FlaskView):
    @route('/site/&lt;id_&gt;', methods=['GET'])
    def get_site(self, id_):
        site = db.query('site_table').find(id_)

        return jsonify(
            first_seen=site.first_seen.isoformat() if site.first_seen is not None else None,
            id=site.id,
            is_active=site.is_active,
            last_seen=site.last_seen.isoformat() if site.last_seen is not None else None,
            url=site.url.rstrip('/')
        )
</pre>
    <p>
     Both
     <tt class="docutils literal">
      first_seen
     </tt>
     and
     <tt class="docutils literal">
      last_seen
     </tt>
     are allowed to be
     <tt class="docutils literal">
      null
     </tt>
     in the
database, and they are also allowed to be
     <tt class="docutils literal">
      null
     </tt>
     in the JSON response. JSON
does not have a native way to represent a
     <tt class="docutils literal">
      datetime
     </tt>
     , so the the server's
contract states that any non-
     <tt class="docutils literal">
      null
     </tt>
     date is represented as a ISO-8601 string.
    </p>
    <p>
     Note that this code is invalid by PEP-8 standards: several lines are over the
line length limit. In fact,
     <em>
      including it in this document
     </em>
     violates the PEP
formatting standard! But it's not unreasonably indented, nor are any of the
identifiers excessively long. The excessive line length is due to the
repetition of identifiers on both sides of the ternary
     <tt class="docutils literal">
      if
     </tt>
     and the verbosity
of the ternary itself (10 characters out of a 78 character line length).
    </p>
    <p>
     One way to fix this code is to replace each ternary with a full
     <tt class="docutils literal">
      if/else
     </tt>
     block:
    </p>
    <pre class="literal-block">
class SiteView(FlaskView):
    @route('/site/&lt;id_&gt;', methods=['GET'])
    def get_site(self, id_):
        site = db.query('site_table').find(id_)

        if site.first_seen is None:
            first_seen = None
        else:
            first_seen = site.first_seen.isoformat()

        if site.last_seen is None:
            last_seen = None
        else:
            last_seen = site.last_seen.isoformat()

        return jsonify(
            first_seen=first_seen,
            id=site.id,
            is_active=site.is_active,
            last_seen=last_seen,
            url=site.url.rstrip('/')
        )
</pre>
    <p>
     This version definitely isn't
     <em>
      bad
     </em>
     . It is easy to read and understand. On the
other hand, adding 8 lines of code to express this common behavior feels a bit
heavy, especially for a deliberately simplified example. If a larger, more
complicated data model was being used, then it would get tedious to continually
write in this long form. The readability would start to suffer as the number of
lines in the function grows, and a refactoring would be forced.
    </p>
    <p>
     Another alternative is to rename some of the identifiers:
    </p>
    <pre class="literal-block">
class SiteView(FlaskView):
    @route('/site/&lt;id_&gt;', methods=['GET'])
    def get_site(self, id_):
        site = db.query('site_table').find(id_)

        fs = site.first_seen
        ls = site.last_seen

        return jsonify(
            first_seen=fs.isodate() if fs is not None else None,
            id=site.id,
            is_active=site.is_active,
            last_seen=ls.isodate() if ls is not None else None,,
            url=site.url.rstrip('/')
        )
</pre>
    <p>
     This adds fewer lines of code than the previous example, but it comes at the
expense of introducing extraneous identifiers that amount to nothing more than
aliases. These new identifiers are short enough to fit a ternary expression onto
one line, but the identifiers are also less intuitive, e.g.
     <tt class="docutils literal">
      fs
     </tt>
     versus
     <tt class="docutils literal">
      first_seen
     </tt>
     .
    </p>
    <p>
     As a quick preview, consider an alternative rewrite using a new operator
     <tt class="docutils literal">
      đŠ
     </tt>
     .
(This spelling of the operator is merely a placeholder so that the
     <em>
      concept
     </em>
     can
be debated without arguing about
     <em>
      spelling
     </em>
     . It is not intended to reflect the
public's opinion of said operator. It may, however, bring new meaning to the
phrase "code smell".):
    </p>
    <pre class="literal-block">
class SiteView(FlaskView):
    @route('/site/&lt;id_&gt;', methods=['GET'])
    def get_site(self, id_):
        site = db.query('site_table').find(id_)

        return jsonify(
            first_seen=siteđŠfirst_seen.isoformat(),
            id=site.id,
            is_active=site.is_active,
            last_seen=siteđŠlast_seen.isoformat(),
            url=site.url.rstrip('/')
        )
</pre>
    <p>
     The
     <tt class="docutils literal">
      đŠ
     </tt>
     operator behaves as a "safe navigation" operator, allowing a more
concise syntax where the expression
     <tt class="docutils literal">
      site.first_seen
     </tt>
     is not duplicated.
    </p>
    <p>
     The next example is from a trending project on GitHub called
     <a class="reference external" href="https://github.com/lorien/grab/blob/4c95b18dcb0fa88eeca81f5643c0ebfb114bf728/grab/upload.py">
      Grab
     </a>
     ,
which is a Python scraping library:
    </p>
    <pre class="literal-block">
class BaseUploadObject(object):
    def find_content_type(self, filename):
        ctype, encoding = mimetypes.guess_type(filename)
        if ctype is None:
            return 'application/octet-stream'
        else:
            return ctype

class UploadContent(BaseUploadObject):
    def __init__(self, content, filename=None, content_type=None):
        self.content = content
        if filename is None:
            self.filename = self.get_random_filename()
        else:
            self.filename = filename
        if content_type is None:
            self.content_type = self.find_content_type(self.filename)
        else:
            self.content_type = content_type

class UploadFile(BaseUploadObject):
    def __init__(self, path, filename=None, content_type=None):
        self.path = path
        if filename is None:
            self.filename = os.path.split(path)[1]
        else:
            self.filename = filename
        if content_type is None:
            self.content_type = self.find_content_type(self.filename)
        else:
            self.content_type = content_type
</pre>
    <div class="note">
     <p class="first admonition-title">
      Note
     </p>
     <p class="last">
      I don't know the author of the Grab project. I used it as an example
because it is a trending repo on GitHub and it has good examples of common
      <tt class="docutils literal">
       None
      </tt>
      patterns.
     </p>
    </div>
    <p>
     This example contains several good examples of needing to provide default
values. It is a bit verbose as it is, and it is certainly not improved by the
ternary operator:
    </p>
    <pre class="literal-block">
class BaseUploadObject(object):
    def find_content_type(self, filename):
        ctype, encoding = mimetypes.guess_type(filename)
        return 'application/octet-stream' if ctype is None else ctype

class UploadContent(BaseUploadObject):
    def __init__(self, content, filename=None, content_type=None):
        self.content = content
        self.filename = self.get_random_filename() if filename \
            is None else filename
        self.content_type = self.find_content_type(self.filename) \
            if content_type is None else content_type

class UploadFile(BaseUploadObject):
    def __init__(self, path, filename=None, content_type=None):
        self.path = path
        self.filename = os.path.split(path)[1] if filename is \
            None else filename
        self.content_type = self.find_content_type(self.filename) \
            if content_type is None else content_type
</pre>
    <p>
     The first ternary expression is tidy, but it reverses the intuitive order of
the operands: it should return
     <tt class="docutils literal">
      ctype
     </tt>
     if it has a value and use the string
literal as fallback. The other ternary expressions are unintuitive and so
long that they must be wrapped. The overall readability is worsened, not
improved.
    </p>
    <p>
     This code
     <em>
      might
     </em>
     be improved, though, if there was a syntactic shortcut for
this common need to supply a default value. We'll assume the fictitious
operator
     <tt class="docutils literal">
      âđ
     </tt>
     to avoid a premature debate about the spelling of said
operator:
    </p>
    <pre class="literal-block">
class BaseUploadObject(object):
    def find_ctype(self, filename):
        ctype, encoding = mimetypes.guess_type(filename)
        return ctype âđ 'application/octet-stream'

class UploadContent(BaseUploadObject):
    def __init__(self, content, filename=None, content_type=None):
        self.content = content
        self.filename = filename âđ self.get_random_filename()
        self.content_type = content_type âđ self.find_ctype(self.filename)

class UploadFile(BaseUploadObject):
    def __init__(self, path, filename=None, content_type=None):
        self.path = path
        self.filename = filename âđ os.path.split(path)[1]
        self.content_type = content_type âđ self.find_ctype(self.filename)
</pre>
    <p>
     This syntax has an intuitive ordering of the operands, e.g.
     <tt class="docutils literal">
      ctype
     </tt>
     -- the
preferred value -- comes before the fallback value. The terseness of the syntax
also makes for fewer lines of code and less code to visually parse.
    </p>
    <div class="note">
     <p class="first admonition-title">
      Note
     </p>
     <p class="last">
      I cheated on the last example: I renamed
      <tt class="docutils literal">
       find_content_type
      </tt>
      to
      <tt class="docutils literal">
       find_ctype
      </tt>
      in order to fit two of the lines under 80 characters. If you
find this underhanded, you can go back and apply the same renaming to the
previous 2 examples. You'll find that it doesn't change the
conclusions.
     </p>
    </div>
   </div>
   <div class="section" id="usage-of-none-in-the-standard-library">
    
    <p>
     The previous sections show some code patterns that are claimed to be "common",
but how common are they? The attached script
     <a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0505/find-pep505.py">
      find-pep505.py
     </a>
     is meant to
answer this question. It uses the
     <tt class="docutils literal">
      ast
     </tt>
     module to search for variations of the
following patterns in any
     <tt class="docutils literal">
      *.py
     </tt>
     file.
    </p>
    <blockquote>
     <pre class="doctest-block">
&gt;&gt;&gt; # None-coalescing if block
...
&gt;&gt;&gt; if a is None:
...     a = b
</pre>
     <pre class="doctest-block">
&gt;&gt;&gt; # [Possible] None-coalescing "or" operator
...
&gt;&gt;&gt; a or 'foo'
&gt;&gt;&gt; a or []
&gt;&gt;&gt; a or {}
</pre>
     <pre class="doctest-block">
&gt;&gt;&gt; # None-coalescing ternary
...
&gt;&gt;&gt; a if a is not None else b
&gt;&gt;&gt; b if a is None else a
</pre>
     <pre class="doctest-block">
&gt;&gt;&gt; # Safe navigation "and" operator
...
&gt;&gt;&gt; a and a.foo
&gt;&gt;&gt; a and a['foo']
&gt;&gt;&gt; a and a.foo()
</pre>
     <pre class="doctest-block">
&gt;&gt;&gt; # Safe navigation if block
...
&gt;&gt;&gt; if a is not None:
...     a.foo()
</pre>
     <pre class="doctest-block">
&gt;&gt;&gt; # Safe navigation ternary
...
&gt;&gt;&gt; a.foo if a is not None else b
&gt;&gt;&gt; b if a is None else a.foo
</pre>
    </blockquote>
    <p>
     This script takes one or more names of Python source files to analyze:
    </p>
    <pre class="literal-block">
$ python3 find-pep505.py test.py
$ find /usr/lib/python3.4 -name '*.py' | xargs python3 find-pep505.py
</pre>
    <p>
     The script prints out any matches it finds. Sample:
    </p>
    <pre class="literal-block">
None-coalescing if block: /usr/lib/python3.4/inspect.py:594
    if _filename is None:
         _filename = getsourcefile(object) or getfile(object)

[Possible] None-coalescing `or`: /usr/lib/python3.4/lib2to3/refactor.py:191
        self.explicit = explicit or []

None-coalescing ternary: /usr/lib/python3.4/decimal.py:3909
        self.clamp = clamp if clamp is not None else dc.clamp

Safe navigation `and`: /usr/lib/python3.4/weakref.py:512
        obj = info and info.weakref()

Safe navigation `if` block: /usr/lib/python3.4/http/cookiejar.py:1895
                        if k is not None:
                            lc = k.lower()
                        else:
                            lc = None

Safe navigation ternary: /usr/lib/python3.4/sre_parse.py:856
        literals = [None if s is None else s.encode('latin-1') for s in literals]
</pre>
    <div class="note">
     <p class="first admonition-title">
      Note
     </p>
     <p class="last">
      Coalescing with
      <tt class="docutils literal">
       or
      </tt>
      is marked as a "possible" match, because it's not
trivial to infer whether
      <tt class="docutils literal">
       or
      </tt>
      is meant to coalesce False-y values
(correct) or if it meant to coalesce
      <tt class="docutils literal">
       None
      </tt>
      (incorrect). On the other
hand, we assume that
      <tt class="docutils literal">
       and
      </tt>
      is always incorrect for safe navigation.
     </p>
    </div>
    <p>
     The script has been tested against
     <a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0505/test.py">
      test.py
     </a>
     and the Python 3.4
standard library, but it should work on any arbitrary Python 3 source code. The
complete output from running it against the standard library is attached to this
proposal as
     <a class="reference external" href="https://hg.python.org/peps/raw-file/tip/pep-0505/find-pep505.out">
      find-pep505.out
     </a>
     .
    </p>
    <p>
     The script counts how many matches it finds and prints the totals at the
end:
    </p>
    <pre class="literal-block">
Total None-coalescing `if` blocks: 426
Total [possible] None-coalescing `or`: 119
Total None-coalescing ternaries: 21
Total Safe navigation `and`: 9
Total Safe navigation `if` blocks: 55
Total Safe navigation ternaries: 7
</pre>
    <p>
     This is a total of 637 possible matches for these common code patterns in the
standard library. Allowing for some false positives and false negatives, it is
fair to say that these code patterns are definitely common in the standard
library.
    </p>
   </div>
   <div class="section" id="rejected-ideas">
    
    <p>
     Several related ideas were discussed on python-ideas, and some of these were
roundly rejected by BDFL, the community, or both. For posterity's sake, some of
those ideas are recorded here.
    </p>
    <div class="section" id="none-aware-function-call">
     
     <p>
      The
      <tt class="docutils literal">
       None
      </tt>
      -aware syntax applies to attribute and index access, so it seems
natural to ask if it should also apply to function invocation syntax. It might
be written as
      <tt class="docutils literal">
       <span class="pre">
        foo?()
       </span>
      </tt>
      , where
      <tt class="docutils literal">
       foo
      </tt>
      is only called if it is not None. This
idea was quickly rejected, for several reasons.
     </p>
     <p>
      First, no other mainstream language has such syntax. Moreover, it would be
difficult to discern if a function call returned
      <tt class="docutils literal">
       None
      </tt>
      because the function
itself returned
      <tt class="docutils literal">
       None
      </tt>
      or because it was short-circuited. Finally, Python
evaluates arguments to a function before it looks up the function itself, so
      <tt class="docutils literal">
       <span class="pre">
        foo?(bar())
       </span>
      </tt>
      would still call
      <tt class="docutils literal">
       bar()
      </tt>
      even if
      <tt class="docutils literal">
       foo
      </tt>
      is
      <tt class="docutils literal">
       None
      </tt>
      . This
behaviour is unexpected for a so-called "short-circuiting" operator.
     </p>
     <p>
      Instead, the "
      <tt class="docutils literal">
       None
      </tt>
      -severing" operator is proposed below. This operator
offers a concise form for writing
      <tt class="docutils literal">
       None
      </tt>
      -aware function expressions that is
truly short-circuiting.
     </p>
    </div>
    <div class="section" id="unary-postfix-operator">
     
     <p>
      To generalize the
      <tt class="docutils literal">
       None
      </tt>
      -aware behavior and limit the number of new operators
introduced, a unary, postfix operator spelled
      <tt class="docutils literal">
       ?
      </tt>
      was suggested. The idea is
that
      <tt class="docutils literal">
       ?
      </tt>
      might return a special object that could would override dunder
methods that return
      <tt class="docutils literal">
       self
      </tt>
      . For example,
      <tt class="docutils literal">
       foo?
      </tt>
      would evaluate to
      <tt class="docutils literal">
       foo
      </tt>
      if
it is not
      <tt class="docutils literal">
       None
      </tt>
      , otherwise it would evaluate to an instance of
      <tt class="docutils literal">
       NoneQuestion
      </tt>
      :
     </p>
     <pre class="literal-block">
class NoneQuestion():
    def __call__(self, *args, **kwargs):
        return self

    def __getattr__(self, name):
        return self

    def __getitem__(self, key):
        return self
</pre>
     <p>
      With this new operator and new type, an expression like
      <tt class="docutils literal">
       <span class="pre">
        foo?.bar[baz]
       </span>
      </tt>
      evaluates to
      <tt class="docutils literal">
       NoneQuestion
      </tt>
      if
      <tt class="docutils literal">
       foo
      </tt>
      is None. This is a nifty
generalization, but it's difficult to use in practice since most existing code
won't know what
      <tt class="docutils literal">
       NoneQuestion
      </tt>
      is.
     </p>
     <p>
      Going back to one of the motivating examples above, consider the following:
     </p>
     <pre class="literal-block">
&gt;&gt;&gt; import json
&gt;&gt;&gt; created = None
&gt;&gt;&gt; json.dumps({'created': created?.isoformat()})``
</pre>
     <p>
      The JSON serializer does not know how to serialize
      <tt class="docutils literal">
       NoneQuestion
      </tt>
      , nor will
any other API. This proposal actually requires
      <em>
       lots of specialized logic
      </em>
      throughout the standard library and any third party library.
     </p>
     <p>
      At the same time, the
      <tt class="docutils literal">
       ?
      </tt>
      operator may also be
      <strong>
       too general
      </strong>
      , in the sense
that it can be combined with any other operator. What should the following
expressions mean?
     </p>
     <blockquote>
      <pre class="doctest-block">
&gt;&gt;&gt; x? + 1
&gt;&gt;&gt; x? -= 1
&gt;&gt;&gt; x? == 1
&gt;&gt;&gt; ~x?
</pre>
     </blockquote>
     <p>
      This degree of generalization is not useful. The operators actually proposed
herein are intentionally limited to a few operators that are expected to make it
easier to write common code patterns.
     </p>
    </div>
    <div class="section" id="haskell-style-maybe">
     
     <p>
      Haskell has a concept called
      <a class="reference external" href="https://wiki.haskell.org/Maybe">
       Maybe
      </a>
      that
encapsulates the idea of an optional value without relying on any special
keyword (e.g.
      <tt class="docutils literal">
       null
      </tt>
      ) or any special instance (e.g.
      <tt class="docutils literal">
       None
      </tt>
      ). In Haskell, the
purpose of
      <tt class="docutils literal">
       Maybe
      </tt>
      is to avoid separate handling of "something" and nothing".
The concept is so heavily intertwined with Haskell's lazy evaluation that it
doesn't translate cleanly into Python.
     </p>
     <p>
      There is a Python package called
      <a class="reference external" href="https://pypi.python.org/pypi/pymaybe/0.1.1">
       pymaybe
      </a>
      that provides a rough
approximation. The documentation shows the following example that appears
relevant to the discussion at hand:
     </p>
     <pre class="literal-block">
&gt;&gt;&gt; maybe('VALUE').lower()
'value'

&gt;&gt;&gt; maybe(None).invalid().method().or_else('unknown')
'unknown'
</pre>
     <p>
      The function
      <tt class="docutils literal">
       maybe()
      </tt>
      returns either a
      <tt class="docutils literal">
       Something
      </tt>
      instance or a
      <tt class="docutils literal">
       Nothing
      </tt>
      instance. Similar to the unary postfix operator described in the
previous section,
      <tt class="docutils literal">
       Nothing
      </tt>
      overrides dunder methods in order to allow
chaining on a missing value.
     </p>
     <p>
      Note that
      <tt class="docutils literal">
       or_else()
      </tt>
      is eventually required to retrieve the underlying value
from
      <tt class="docutils literal">
       pymaybe
      </tt>
      's wrappers. Furthermore,
      <tt class="docutils literal">
       pymaybe
      </tt>
      does not short circuit any
evaluation. Although
      <tt class="docutils literal">
       pymaybe
      </tt>
      has some strengths and may be useful in its own
right, it also demonstrates why a pure Python implementation of coalescing is
not nearly as powerful as support built into the language.
     </p>
    </div>
   </div>
  </div>
  <div class="section" id="specification">
   
   <p>
    This PEP suggests 4 new operators be added to Python:
   </p>
   <ol class="arabic simple">
    <li>
     <tt class="docutils literal">
      None
     </tt>
     -coalescing operator
    </li>
    <li>
     <tt class="docutils literal">
      None
     </tt>
     -severing operator
    </li>
    <li>
     <tt class="docutils literal">
      None
     </tt>
     -aware attribute access
    </li>
    <li>
     <tt class="docutils literal">
      None
     </tt>
     -aware index access/slicing
    </li>
   </ol>
   <p>
    We will continue to assume the same spellings as in
the previous sections in order to focus on behavior before diving into the much
more contentious issue of how to spell these operators.
   </p>
   <p>
    A generalization of these operators is also proposed below under the heading
"Generalized Coalescing".
   </p>
   <div class="section" id="none-coalescing-operator">
    
    <p>
     The
     <tt class="docutils literal">
      None
     </tt>
     -coalescing operator is a short-circuiting, binary operator that behaves
in the following way.
    </p>
    <ol class="arabic simple">
     <li>
      Evaluate the left operand first.
     </li>
     <li>
      If the left operand is not
      <tt class="docutils literal">
       None
      </tt>
      , then return it immediately.
     </li>
     <li>
      Else, evaluate the right operand and return the result.
     </li>
    </ol>
    <p>
     Some simple examples:
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; 1 âđ 2
1
&gt;&gt;&gt; None âđ 2
2
&gt;&gt;&gt; 1 âđ None
1
</pre>
    <p>
     Importantly, note that the right operand is not evaluated unless the left
operand is None:
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; def err(): raise Exception('foo')
&gt;&gt;&gt; 1 âđ err()
1
&gt;&gt;&gt; None âđ err()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 1, in err
Exception: foo
</pre>
    <p>
     The operator is left associative. Combined with its short circuiting behavior,
this makes the operator easy to chain:
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; timeout = None
&gt;&gt;&gt; local_timeout = 60
&gt;&gt;&gt; global_timeout = 300
&gt;&gt;&gt; timeout âđ local_timeout âđ global_timeout
60

&gt;&gt;&gt; local_timeout = None
&gt;&gt;&gt; timeout âđ local_timeout âđ global_timeout
300

&gt;&gt;&gt; import time
&gt;&gt;&gt; timeout âđ local_timeout âđ global_timeout âđ time.sleep(10)
300
</pre>
    <p>
     Note in the last example that
     <tt class="docutils literal">
      time.sleep(10)
     </tt>
     represents an expensive
function call, e.g. initializing a complex data structure. In this example
     <tt class="docutils literal">
      time.sleep
     </tt>
     is not evaluated, and the result
     <tt class="docutils literal">
      300
     </tt>
     is returned instantly.
    </p>
    <p>
     The operator has higher precedence than the comparison operators
     <tt class="docutils literal">
      ==
     </tt>
     ,
     <tt class="docutils literal">
      &gt;
     </tt>
     ,
     <tt class="docutils literal">
      is
     </tt>
     , etc., but lower precedence than any bitwise or arithmetic operators.
This precedence is chosen for making "default value" expressions intuitive to
read and write:
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; user_flag = None
&gt;&gt;&gt; default_flag = True
&gt;&gt;&gt; not user_flag âđ default_flag # Same as next expression.
False
&gt;&gt;&gt; not (user_flag âđ default_flag) # Same as previous.
False
&gt;&gt;&gt; (not user_flag) âđ default_flag # Different from previous.
True

&gt;&gt;&gt; user_quantity = None
&gt;&gt;&gt; default_quantity = 1
&gt;&gt;&gt; 1 == user_quantity âđ default_quantity # Same as next expression.
True
&gt;&gt;&gt; 1 == (user_quantity âđ default_quantity) # Same as previous.
True
&gt;&gt;&gt; (1 == user_quantity) âđ default_quantity # Different from previous.
False

&gt;&gt;&gt; user_words = None
&gt;&gt;&gt; default_words = ['foo', 'bar']
&gt;&gt;&gt; 'foo' in user_words âđ default_words # Same as next expression.
True
&gt;&gt;&gt; 'foo' in (user_words âđ default_words) # Same as previous.
True
&gt;&gt;&gt; ('foo' in user_words) âđ default_words # Different from previous.
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: argument of type 'NoneType' is not iterable

&gt;&gt;&gt; user_discount = None
&gt;&gt;&gt; default_discount = 0.9
&gt;&gt;&gt; price = 100
&gt;&gt;&gt; price * user_discount âđ default_discount
</pre>
    <p>
     Recall the example above of calculating the cost of items in a shopping cart,
and the easy-to-miss bug. This type of bug is not possible with the
     <tt class="docutils literal">
      None
     </tt>
     -
coalescing operator, because there is no implicit type coersion to
     <tt class="docutils literal">
      bool
     </tt>
     :
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; price = 100
&gt;&gt;&gt; requested_quantity = 0
&gt;&gt;&gt; default_quantity = 1
&gt;&gt;&gt; (requested_quantity âđ default_quantity) * price
0
</pre>
    <p>
     The
     <tt class="docutils literal">
      None
     </tt>
     -coalescing operator also has a corresponding assignment shortcut.
The following assignments are semantically equivalent:
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; foo âđ= []
&gt;&gt;&gt; foo = foo âđ []
</pre>
    <p>
     The
     <tt class="docutils literal">
      None
     </tt>
     coalescing operator improves readability, especially when handling
default function arguments. Consider again the example of requests, rewritten to
use
     <tt class="docutils literal">
      None
     </tt>
     -coalescing:
    </p>
    <pre class="literal-block">
def __init__(self, data=None, files=None, headers=None, params=None, hooks=None):
    self.data = data âđ []
    self.files = files âđ []
    self.headers = headers âđ {}
    self.params = params âđ {}
    self.hooks = hooks âđ {}
</pre>
    <p>
     The operator makes the intent easier to follow (by putting operands in an
intuitive order) and is more concise than the ternary operator, while still
preserving the short circuit semantics of the code that it replaces.
    </p>
   </div>
   <div class="section" id="none-severing-operator">
    
    <p>
     The idea of a
     <tt class="docutils literal">
      None
     </tt>
     -aware function invocation syntax was discussed on python-
ideas. The idea was not popular, so no such operator is included in this
proposal. (Justification for its exclusion is discussed in a previous section.)
Still, calling a function when it is not
     <tt class="docutils literal">
      None
     </tt>
     is a common idiom in Python,
particularly for callback functions. Consider this hypothetical example:
    </p>
    <pre class="literal-block">
import time

def delay(seconds, callback=None):
    time.sleep(seconds)

    if callback is not None:
        callback()
</pre>
    <p>
     With the rejected
     <tt class="docutils literal">
      None
     </tt>
     -aware function call syntax, this example might be
written more concisely as:
    </p>
    <pre class="literal-block">
import time

def delay(seconds, callback=None):
    time.sleep(seconds)
    callback?()
</pre>
    <p>
     Instead, consider a "
     <tt class="docutils literal">
      None
     </tt>
     -severing" operator, however, which is a short-
circuiting, boolean operator similar to the
     <tt class="docutils literal">
      None
     </tt>
     -coalesing operator, except
it returns
     <tt class="docutils literal">
      None
     </tt>
     if the left operand is
     <tt class="docutils literal">
      None
     </tt>
     and returns the right
operand otherwise. It has short circuiting behavior that compliments the
     <tt class="docutils literal">
      None
     </tt>
     -coalescing operator: if the left operand is None, then the right
operand is not evaluated. Let's temporarily spell this operator
     <tt class="docutils literal">
      â
     </tt>
     and
rewrite the example accordingly:
    </p>
    <pre class="literal-block">
import time

def delay(seconds, callback=None):
    time.sleep(seconds)
    callback â callback()
</pre>
    <p>
     At this point, you may be astonished at the mere suggestion of such a strange
operator with limited practical usefulness. It is proposed here because of the
symmetry it has with the
     <tt class="docutils literal">
      None
     </tt>
     -coalescing operator. This symmetry may be more
apparent if the two operators have complementary spellings.
    </p>
    <p>
     In the same way that
     <tt class="docutils literal">
      or
     </tt>
     and
     <tt class="docutils literal">
      and
     </tt>
     go together,
     <tt class="docutils literal">
      None
     </tt>
     -coalescing and
     <tt class="docutils literal">
      None
     </tt>
     - severing might be spelled in a pleasing, symmetric way, e.g.
     <tt class="docutils literal">
      or?
     </tt>
     and
     <tt class="docutils literal">
      and?
     </tt>
     . If such a spelling can be decided on, then this operator adds very
little cognitive load or special machinery to the language, and it's minor
utility may justify its inclusion in the language.
    </p>
    <p>
     Note that
     <tt class="docutils literal">
      None
     </tt>
     -severing could also be used as an alternative to "safe
navigation", at the expense of some repeated expressions:
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; d = None
&gt;&gt;&gt; type(d â d.isoformat())
&lt;class 'NoneType'&gt;

&gt;&gt;&gt; d = datetime.now()
&gt;&gt;&gt; d â d.isoformat()
'2015-10-16T20:53:40.312135'
</pre>
    <p>
     The repeated expression
     <tt class="docutils literal">
      d
     </tt>
     makes this less useful than a
     <tt class="docutils literal">
      None
     </tt>
     -aware
attribute access operator, but to repeat what was said at the outset: this
proposal may be approved or rejected in whole or in part. This unlikely operator
is included in the proposal in order to be comprehensive.
    </p>
    <p>
     The precedence and associativity of the
     <tt class="docutils literal">
      None
     </tt>
     -severing operator are the same
as the
     <tt class="docutils literal">
      None
     </tt>
     -coalescing operator.
    </p>
   </div>
   <div class="section" id="none-aware-attribute-access-operator">
    
    <p>
     The
     <tt class="docutils literal">
      None
     </tt>
     -aware attribute access operator (also called "safe navigation")
checks its left operand. If the left operand is
     <tt class="docutils literal">
      None
     </tt>
     , then the operator
evaluates to
     <tt class="docutils literal">
      None
     </tt>
     . If the the left operand is not
     <tt class="docutils literal">
      None
     </tt>
     , then the
operator accesses the attribute named by the right operand. As in the previous
section, we continue to use the temporary spelling
     <tt class="docutils literal">
      đŠ
     </tt>
     :
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; from datetime import date
&gt;&gt;&gt; d = date.today()
&gt;&gt;&gt; d.year
2015

&gt;&gt;&gt; d = None
&gt;&gt;&gt; d.year
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'year'

&gt;&gt;&gt; dđŠyear
None
</pre>
    <p>
     The operator has the same precedence and associativity as the plain attribute
access operator
     <tt class="docutils literal">
      .
     </tt>
     , but this operator is also short-circuiting in a unique
way: if the left operand is
     <tt class="docutils literal">
      None
     </tt>
     , then any series of attribute access, index
access, slicing, or function call operators immediately to the right of it
     <em>
      are
not evaluated
     </em>
     .
    </p>
    <blockquote>
     <pre class="doctest-block">
&gt;&gt;&gt; name = ' The Black Knight '
&gt;&gt;&gt; name.strip()[4:].upper()
'BLACK KNIGHT'
</pre>
     <pre class="doctest-block">
&gt;&gt;&gt; name = None
&gt;&gt;&gt; nameđŠstrip()[4:].upper()
None
</pre>
    </blockquote>
    <p>
     If this operator did not short circuit in this way, then the second example
would partially evaluate
     <tt class="docutils literal">
      nameđŠstrip()
     </tt>
     to
     <tt class="docutils literal">
      None()
     </tt>
     and then fail with
     <tt class="docutils literal">
      TypeError: 'NoneType' object is not callable
     </tt>
     .
    </p>
    <p>
     To put it another way, the following expressions are semantically equivalent:
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; nameđŠstrip()[4:].upper()
&gt;&gt;&gt; name.strip()[4:].upper() if name is not None else None
</pre>
    <div class="note">
     <p class="first admonition-title">
      Note
     </p>
     <p class="last">
      C# implements its safe navigation operators with the same short-circuiting
semantics, but Dart does not. In Dart, the second example (suitably
translated) would fail. The C# semantics are obviously superior, given the
original goal of writing common cases more concisely. The Dart semantics are
nearly useless.
     </p>
    </div>
    <p>
     This operator short circuits one or more attribute access, index access,
slicing, or function call operators that are immediately to its right, but it
does not short circuit any other operators (logical, bitwise, arithmetic, etc.),
nor does it escape parentheses:
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; d = date.today()
&gt;&gt;&gt; dđŠyear.numerator + 1
2016

&gt;&gt;&gt; d = None
&gt;&gt;&gt; dđŠyear.numerator + 1
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

&gt;&gt;&gt; (dđŠyear).numerator + 1
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'numerator'
</pre>
    <p>
     Note that the error in the second example is not on the attribute access
     <tt class="docutils literal">
      numerator
     </tt>
     . In fact, that attribute access is never performed. The error
occurs when adding
     <tt class="docutils literal">
      None + 1
     </tt>
     , because the
     <tt class="docutils literal">
      None
     </tt>
     -aware attribute access
does not short circuit
     <tt class="docutils literal">
      +
     </tt>
     .
    </p>
    <p>
     The third example fails because the operator does not escape parentheses. In
that example, the attribute access
     <tt class="docutils literal">
      numerator
     </tt>
     is evaluated and fails because
     <tt class="docutils literal">
      None
     </tt>
     does not have that attribute.
    </p>
    <p>
     Finally, observe that short circuiting adjacent operators is not at all the same thing as propagating
     <tt class="docutils literal">
      None
     </tt>
     throughout an expression:
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; userđŠfirst_name.upper()
</pre>
    <p>
     If
     <tt class="docutils literal">
      user
     </tt>
     is not
     <tt class="docutils literal">
      None
     </tt>
     , then
     <tt class="docutils literal">
      user.first_name
     </tt>
     is evaluated. If
     <tt class="docutils literal">
      user.first_name
     </tt>
     evaluates to
     <tt class="docutils literal">
      None
     </tt>
     , then
     <tt class="docutils literal">
      user.first_name.upper()
     </tt>
     is
an error! In English, this expression says, "
     <tt class="docutils literal">
      user
     </tt>
     is optional but if it has
a value, then it must have a
     <tt class="docutils literal">
      first_name
     </tt>
     , too.""
    </p>
    <p>
     If
     <tt class="docutils literal">
      first_name
     </tt>
     is supposed to be optional attribute, then the expression must
make that explicit:
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; userđŠfirst_nameđŠupper()
</pre>
    <p>
     The operator is not intended as an error silencing mechanism, and it would be
undesirable if its presence infected nearby operators.
    </p>
   </div>
   <div class="section" id="none-aware-index-access-slicing-operator">
    
    <p>
     The
     <tt class="docutils literal">
      None
     </tt>
     -aware index access/slicing operator (also called "safe navigation")
is nearly identical to the
     <tt class="docutils literal">
      None
     </tt>
     -aware attribute access operator. It combines
the familiar square bracket syntax
     <tt class="docutils literal">
      []
     </tt>
     with new punctuation or a new keyword,
the spelling of which is discussed later:
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; person = {'name': 'Mark', 'age': 32}
&gt;&gt;&gt; person['name']
'Mark'

&gt;&gt;&gt; person = None
&gt;&gt;&gt; person['name']
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'NoneType' object is not subscriptable

&gt;&gt;&gt; personđŠ['name']
None
</pre>
    <p>
     The
     <tt class="docutils literal">
      None
     </tt>
     -aware slicing operator behaves similarly:
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; name = 'The Black Knight'
&gt;&gt;&gt; name[4:]
'Black Knight'

&gt;&gt;&gt; name = None
&gt;&gt;&gt; name[4:]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'NoneType' object is not subscriptable

&gt;&gt;&gt; nameđŠ[4:]
None
</pre>
    <p>
     These operators have the same precedence as the plain index access and slicing
operators. They also have the same short-circuiting behavior as the
     <tt class="docutils literal">
      None
     </tt>
     -aware attribute access.
    </p>
   </div>
   <div class="section" id="generalized-coalescing">
    
    <p>
     Making
     <tt class="docutils literal">
      None
     </tt>
     a special case may seem too specialized and magical. It is
possible to generalize the behavior by making the
     <tt class="docutils literal">
      None
     </tt>
     -aware operators
invoke a dunder method, e.g.
     <tt class="docutils literal">
      __coalesce__(self)
     </tt>
     that returns
     <tt class="docutils literal">
      True
     </tt>
     if an
object should be coalesced and
     <tt class="docutils literal">
      False
     </tt>
     otherwise.
    </p>
    <p>
     With this generalization,
     <tt class="docutils literal">
      object
     </tt>
     would implement a dunder method equivalent
to this:
    </p>
    <pre class="literal-block">
def __coalesce__(self):
    return False
</pre>
    <p>
     <tt class="docutils literal">
      NoneType
     </tt>
     would implement a dunder method equivalent to this:
    </p>
    <pre class="literal-block">
def __coalesce__(self):
    return True
</pre>
    <p>
     If this generalization is accepted, then the operators will need to be renamed
such that the term
     <tt class="docutils literal">
      None
     </tt>
     is not used, e.g. "Coalescing Operator", "Coalesced
Member Access Operator", etc.
    </p>
    <p>
     The coalescing operator would invoke this dunder method. The following two expressions are semantically equivalent:
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; foo âđ bar
&gt;&gt;&gt; bar if foo.__coalesce__() else foo
</pre>
    <p>
     The coalesced attribute and index access operators would invoke the same dunder
method:
    </p>
    <pre class="literal-block">
&gt;&gt;&gt; userđŠfirst_name.upper()
&gt;&gt;&gt; None if user.__coalesce__() else user.first_name.upper()
</pre>
    <p>
     This generalization allows for domain-specific
     <tt class="docutils literal">
      null
     </tt>
     objects to be coalesced
just like
     <tt class="docutils literal">
      None
     </tt>
     . For example the
     <tt class="docutils literal">
      pyasn1
     </tt>
     package has a type called
     <tt class="docutils literal">
      Null
     </tt>
     that represents an ASN.1
     <tt class="docutils literal">
      null
     </tt>
     .
    </p>
    <blockquote>
     <pre class="doctest-block">
&gt;&gt;&gt; from pyasn1.type import univ
&gt;&gt;&gt; univ.Null() âđ univ.Integer(123)
Integer(123)
</pre>
    </blockquote>
    <p>
     In addition to making the proposed operators less specialized, this
generalization also makes it easier to work with the Null Object Pattern,
     <a class="footnote-reference" href="#id9" id="id5">
      [3]
     </a>
     for those developers who prefer to avoid using
     <tt class="docutils literal">
      None
     </tt>
     .
    </p>
   </div>
   <div class="section" id="operator-spelling">
    
    <p>
     Despite significant support for the proposed operators, the majority of
discussion on python-ideas fixated on the spelling. No consensus was achieved on
this question, for two reasons. First, Python eschews punctuation for logical
operators. For example, it uses
     <tt class="docutils literal">
      not
     </tt>
     instead of
     <tt class="docutils literal">
      !
     </tt>
     and
     <tt class="docutils literal">
      âŚ if âŚ else âŚ
     </tt>
     instead of
     <tt class="docutils literal">
      <span class="pre">
       ?:
      </span>
     </tt>
     . Introducing new punctuation is a major turnoff to many
Pythonistas, including BDFL. Second, adding new keywords to the language is
not backwards compatible. Any new keyword could only be introduced in the next
major version, e.g. Python 4. (Even then,
     <a class="reference external" href="http://opensource.com/life/14/9/why-python-4-wont-be-python-3">
      there would be resistance
     </a>
     .)
    </p>
    <p>
     Furthermore, nearly every single punctuation character on a standard keyboard
already has special meaning in Python. The only exceptions are
     <tt class="docutils literal">
      $
     </tt>
     ,
     <tt class="docutils literal">
      !
     </tt>
     ,
     <tt class="docutils literal">
      ?
     </tt>
     , and backtick (as of Python 3). This leaves few options for a new, single-
character operator. A two character spelling is more likely, such as the
     <tt class="docutils literal">
      <span class="pre">
       ??
      </span>
     </tt>
     and
     <tt class="docutils literal">
      <span class="pre">
       ?.
      </span>
     </tt>
     spellings in other programming languages, but this decreases the
appeal of punctuation even further.
    </p>
    <p>
     Finally, other projects in the Python universe assign special meaning to
punctuation. For example,
     <a class="reference external" href="https://ipython.org/ipython-doc/2/interactive/reference.html">
      IPython
     </a>
     assigns special meaning to
     <tt class="docutils literal">
      %
     </tt>
     ,
     <tt class="docutils literal">
      %%
     </tt>
     ,
     <tt class="docutils literal">
      ?
     </tt>
     ,
     <tt class="docutils literal">
      <span class="pre">
       ??
      </span>
     </tt>
     ,
     <tt class="docutils literal">
      $
     </tt>
     , and
     <tt class="docutils literal">
      $$
     </tt>
     , among others. Out of deference to those
projects and the large communities using them, introducing conflicting syntax
into Python is undesirable.
    </p>
    <p>
     This is not the first PEP to deal with this dilemma. PEP-308
     <a class="footnote-reference" href="#id11" id="id6">
      [5]
     </a>
     , which
introduced the ternary operator, faced similar issues.
    </p>
    <div class="section" id="alternative-spellings">
     
     <p>
      In keeping with the spirit of the PEP, many alternative spellings for these
      <tt class="docutils literal">
       None
      </tt>
      -aware operators are suggested, including some that conflict with each
other. Deconfliction will be handled only if any part of this proposal is
accepted.
     </p>
     <p>
      One caveat noted by several respondents on python-ideas: using similar spelling
for
      <tt class="docutils literal">
       None
      </tt>
      coalescing and other
      <tt class="docutils literal">
       None
      </tt>
      -aware operators may be confusing,
because they have different short circuit semantics: coalescing short circuits
on non-
      <tt class="docutils literal">
       None
      </tt>
      , while
      <tt class="docutils literal">
       None
      </tt>
      -aware attribute/index access short circuit on
      <tt class="docutils literal">
       None
      </tt>
      . This is a potential downside to spellings like
      <tt class="docutils literal">
       <span class="pre">
        ??
       </span>
      </tt>
      and
      <tt class="docutils literal">
       <span class="pre">
        ?.
       </span>
      </tt>
      . This
is only a practical concern if any part of this proposal is actually accepted,
so there is no need to pontificate any further.
     </p>
     <p>
      The following spellings are proposed candidates for the
      <tt class="docutils literal">
       None
      </tt>
      -coalescing
operator.
     </p>
     <ol class="arabic">
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          foo
          <span class="pre">
           ??
          </span>
          bar
          <span class="pre">
           ??
          </span>
          baz
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: same spelling as C# and Dart
          </li>
          <li>
           Cons: punctuation is ugly; possible conflict with IPython; difficult to
google to find out what it means
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          foo or? bar or? baz
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: similar to existing
           <tt class="docutils literal">
            or
           </tt>
           operator
          </li>
          <li>
           Cons: the difference between this and
           <tt class="docutils literal">
            or
           </tt>
           is not intuitive; punctuation
is ugly; different precedence from
           <tt class="docutils literal">
            or
           </tt>
           may be confusing
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          foo ? bar ? baz
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: similar to
           <tt class="docutils literal">
            <span class="pre">
             ??
            </span>
           </tt>
           used in other languages
          </li>
          <li>
           Cons: punctuation is ugly; possible conflict with IPython; not used by any
other language
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          foo $$ bar $$ baz
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: pronounced "value operator" because it returns the first operand
that has a "value"
          </li>
          <li>
           Cons: punctuation is ugly; not used by any other language
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          foo else bar else baz
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: prettier than punctuation; uses an existing keyword
          </li>
          <li>
           Cons: difficult or impossible to implement with Python's LL(1) parser
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          foo or else bar or else baz
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: prettier than punctuation; use existing keywords
          </li>
          <li>
           Cons: difficult or impossible to implement with Python's LL(1) parser
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          foo def bar def baz
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: pronounced 'default'; prettier than punctuation
          </li>
          <li>
           Cons: difficult or impossible to implement with Python's LL(1) parser
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          foo then bar then baz
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: prettier than punctuation
          </li>
          <li>
           Cons: requires a new keyword, probably can't be implemented until Python 4
(and maybe not even then)
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         No
         <tt class="docutils literal">
          None
         </tt>
         -coalescing operator.
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           (Pros and cons discussed throughout this document.)
          </li>
         </ul>
        </dd>
       </dl>
      </li>
     </ol>
     <p>
      The following spellings are proposed candidates for the
      <tt class="docutils literal">
       None
      </tt>
      -severing
operator. Each alternative has symmetry with one of the proposed spellings of
the
      <tt class="docutils literal">
       None
      </tt>
      - coalescing operator.
     </p>
     <ol class="arabic">
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          foo !! bar
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: symmetric with
           <tt class="docutils literal">
            <span class="pre">
             ??
            </span>
           </tt>
          </li>
          <li>
           Cons: punctuation is ugly; possible conflict with IPython; difficult to
google to find out what it means
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          foo and? bar
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: symmetric with
           <tt class="docutils literal">
            or?
           </tt>
          </li>
          <li>
           Cons: punctuation is ugly; possible conflict with IPython; difficult to
google to find out what it means; different precedence from
           <tt class="docutils literal">
            and
           </tt>
           may be
confusing
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         No
         <tt class="docutils literal">
          None
         </tt>
         -severing operator.
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           (Pros and cons discussed throughout this document.)
          </li>
         </ul>
        </dd>
       </dl>
      </li>
     </ol>
     <p>
      The following spellings are proposed candidates for the
      <tt class="docutils literal">
       None
      </tt>
      -aware attribute
access operator. If you find any of these hard to read, consider that we may
adopt a convention of adding whitespace around a
      <tt class="docutils literal">
       None
      </tt>
      -aware operator to
improve readability.
     </p>
     <ol class="arabic">
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          <span class="pre">
           foo?.bar
          </span>
         </tt>
         ,
         <tt class="docutils literal">
          foo
          <span class="pre">
           ?.
          </span>
          bar
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: same spelling as C# and Dart
          </li>
          <li>
           Cons: punctuation is ugly; possible conflict with IPython; difficult to
google to find out what it means; difficult to differentiate from
           <tt class="docutils literal">
            .
           </tt>
           when reading quickly
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          <span class="pre">
           foo$.bar
          </span>
         </tt>
         ,
         <tt class="docutils literal">
          foo $. bar
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: symmetry with
           <tt class="docutils literal">
            $$
           </tt>
           operator proposed above
          </li>
          <li>
           Cons: punctuation is ugly; difficult to google; possible confusion because
it looks a bit like other languages' string interpolation; difficult to
google to find out what it means; difficult to differentiate from
           <tt class="docutils literal">
            .
           </tt>
           when reading quickly
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          foo!bar
         </tt>
         ,
         <tt class="docutils literal">
          foo ! bar
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: similar to ordinary
           <tt class="docutils literal">
            .
           </tt>
           operator
          </li>
          <li>
           Cons: punctuation is ugly; possible conflict with IPython; no corresponding
spelling for index access (e.g.
           <tt class="docutils literal">
            <span class="pre">
             foo!['bar']
            </span>
           </tt>
           is ambiguous)
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          <span class="pre">
           foo-&gt;bar
          </span>
         </tt>
         ,
         <tt class="docutils literal">
          foo
          <span class="pre">
           -&gt;
          </span>
          bar
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: easier to read than other punctuation; less likely to be confused
with ordinary attribute access
          </li>
          <li>
           Cons: punctuation is ugly; difficult to google; confusing because it is
spelled the same as C's dereference operator
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          foo try .bar
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: uses an existing keyword;
          </li>
          <li>
           Cons: difficult or impossible to implement in Python's LL(1) parser
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         No
         <tt class="docutils literal">
          None
         </tt>
         -aware attribute access operator.
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           (Pros and cons discussed throughout this document.)
          </li>
         </ul>
        </dd>
       </dl>
      </li>
     </ol>
     <p>
      The following spellings are proposed candidates for the
      <tt class="docutils literal">
       None
      </tt>
      -aware index
access/slicing operator. The punctuation used for this operator ought to
resemble the punctuation used for the
      <tt class="docutils literal">
       None
      </tt>
      -aware attribute access.
     </p>
     <ol class="arabic">
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          <span class="pre">
           foo?['bar']
          </span>
         </tt>
         ,
         <tt class="docutils literal">
          foo ? ['bar']
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: same spelling as C# and Dart
          </li>
          <li>
           Cons: punctuation is ugly; possible conflict with IPython; difficult to
google to find out what it means
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          <span class="pre">
           foo$['bar']
          </span>
         </tt>
         ,
         <tt class="docutils literal">
          foo $ ['bar']
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: symmetry with
           <tt class="docutils literal">
            $$
           </tt>
           operator proposed above
          </li>
          <li>
           Cons: punctuation is ugly; possible confusion because
it looks a bit like other languages' string interpolation
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          <span class="pre">
           foo-&gt;['bar']
          </span>
         </tt>
         ,
         <tt class="docutils literal">
          foo
          <span class="pre">
           -&gt;
          </span>
          ['bar']
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: easier to read than other punctuation; less likely to be confused
with ordinary attribute access
          </li>
          <li>
           Cons: punctuation is ugly; difficult to google; confusing because it is
spelled the same as C's dereference operator
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         <tt class="docutils literal">
          foo try ['bar']
         </tt>
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           Pros: uses an existing keyword;
          </li>
          <li>
           Cons: difficult or impossible to implement in Python's LL(1) parser
          </li>
         </ul>
        </dd>
       </dl>
      </li>
      <li>
       <dl class="first docutils">
        <dt>
         No
         <tt class="docutils literal">
          None
         </tt>
         -aware index access/slicing operator.
        </dt>
        <dd>
         <ul class="first last simple">
          <li>
           (Pros and cons discussed throughout this document.)
          </li>
         </ul>
        </dd>
       </dl>
      </li>
     </ol>
    </div>
    <div class="section" id="community-poll">
     
     <p>
      In order to collect data about the Python community's preferences for
      <tt class="docutils literal">
       None
      </tt>
      -aware operators, and with BDFL's consent, a public poll will be
conducted, just as with PEP-308. The poll is viewed as a data-gathering
exercise, not a democratic vote.
     </p>
     <p>
      The poll will allow respondents to rank their favorite options from the previous
section. The results will
be placed in this section of the PEP.
     </p>
     <p>
      ...TBD...
     </p>
    </div>
   </div>
   <div class="section" id="implementation">
    
    <p>
     Given that the need for
     <tt class="docutils literal">
      None
     </tt>
     -aware operators is questionable and the
spelling of said operators is almost incendiary, the implementation details for
CPython will be deferred unless and until we have a clearer idea that one (or
more) of the proposed operators will be approved.
    </p>
    <p>
     ...TBD...
    </p>
   </div>
  </div>
  </div></body></html>