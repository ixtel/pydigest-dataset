<html><body><div><div class="entry-content">
					<hr/>
<h2><span>Introduction</span></h2>
<p>Ah, quantum mechanics, inscrutable and stupendous way of doing physics and yet, no-one knows why it works. I have always been amazed by the wonders of quantum world and always looked for the ways of grasping its significance. One really illustrative example of the quantum phenomena is called a <em>finite square well</em>, and here I present my solution of this popular problem solved in the numerical computation package of Python.</p>
<p>Finite square well, what does it mean? Actually it’s quite simple to comprehend – a finite square well is a one-dimensional function <em>V(x)</em> which has a constant value <em>V<sub>0</sub></em> everywhere except where <em>|x| &lt; L</em>, when it drops to zero (Figure). <em>V(x)</em> is called the <em>potential function </em>and it determines behavior of the quantum particle. Don’t be afraid now- even though quantum physics was designed to accommodate subatomic particles, you don’t need to know particle physics to understand this post. Quantum theory works well even if you imagine normal everyday objects like footballs, cars or rabbits instead of protons and electrons.</p>
<figure data-shortcode="caption" id="attachment_225" class="wp-caption alignleft"><a href="https://helentronica.files.wordpress.com/2014/09/325px-finite_potential_well_symmetric-svg1.png"><img class="wp-image-225 size-medium" src="https://helentronica.files.wordpress.com/2014/09/325px-finite_potential_well_symmetric-svg1.png?w=300&amp;h=207" alt="325px-Finite_Potential_Well_Symmetric.svg[1]"/></a><figcaption class="wp-caption-text">Potential function of the finite square well</figcaption></figure>
<p>The idea is that particle is <em>bounded </em>within the region <em>-L&lt;x&lt;L, </em>and does not have enough energy to leave it. This is called a <em>bound state</em>. Classical interpretation would be a tiny ball in the box bouncing back and forth from two sides, forever.  What sense does it make? Well, in school grade physics you learned that higher the position of the body, bigger is its potential energy. So, top of the mountain”contains” higher potential than the mountain’s bottom. If there was car between two mountains it would be forever stuck in the valley between if it’s engine cannot make more (kinetic) energy than it is potential at the top of the mountains.</p>
<h2><span>Here comes the Schrödinger</span></h2>
<p>How to describe behavior of such particle? In many textbooks, online classes, websites, etc. you’ll find that you can not treat quantum particle as an ordinary physical body (even though it can <em>look</em> like an ordinary body, have mass like ordinary body and so on), simply because you can not know for sure its performances like position, speed or momentum. Instead, you attach some transcendental function <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/> which is space dependent and use it to find a <em>probability </em>of particle’s position, momentum etc at the given time. To get nice and clean expression for the <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/>-function, we introduce Her Majesty – the Schrödinger equation:</p>
<p><a href="https://helentronica.files.wordpress.com/2014/09/schrodinger1.png"><img class="aligncenter wp-image-229 size-medium" src="https://helentronica.files.wordpress.com/2014/09/schrodinger1.png?w=300&amp;h=60" alt="schrodinger[1]"/></a></p>
<p>Note: this is <em>time-independent </em>form of the Schrödinger equation, and it will give us a time-independent solutions of <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/>. But don’t worry, time-independent solutions are very insightful and – now comes the best part – complete solution is just a linear combination of time-independent solutions!</p>
<p>To make long story short – to describe the behavior of the particle, just give me the Schrödinger equation and the potential function and I will tell you all you want to know about the particle.</p>
<h2><span>Do it the Python way</span></h2>
<p>As you see, problem includes differential equation and it’s solution may be tricky if you are a fan of “pen and paper” approach. But, there are people out there who made computers do all this dirty work, and some of these tools are available in our beloved Python. The one I will use is a routine called <em>odeint() </em>(which stands for ordinary differential equation-something)<em> </em>and is included in standard <em>scipy.integrate</em> package. The <em>odeint() </em>works in a two-state-space representation of <img src="https://s0.wp.com/latex.php?latex=%5Cpsi&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi" title="\psi" class="latex"/>: state one is function <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/> the way we want it and state two is a first derivative of <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/>.</p>
<p>The thing is – this way we can get infinitely many solutions. But not all of them are meaningful. We need to find only those solutions where <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/> does not diverge at the edges of <em>x</em>. If it diverges, it disobeys the condition of square-integrability: <img src="https://s0.wp.com/latex.php?latex=%5Cint_%7B-%5Cinfty%7D%5E%5Cinfty%5C%21%7C%5Cpsi%28x%29%7C%5E2%5C%2C%5Cmathrm%7Bd%7Dx+%3D+1&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\int_{-\infty}^\infty\!|\psi(x)|^2\,\mathrm{d}x = 1" title="\int_{-\infty}^\infty\!|\psi(x)|^2\,\mathrm{d}x = 1" class="latex"/>  and we deal with the physical falseness.</p>
<p>So here’s what we do: we run value of particle’s energy <em>E</em> from 0 to some value, say <em>Vo</em>, and calculate <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/> for each E. Value of <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/> (at the far outside of the finite well – <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28b%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(b)" title="\psi(b)" class="latex"/> where <em>b&gt;&gt;L</em>), is put into the separate list whose roots (places where it crosses zero) are to be found. Only those energies <em>E</em> for which <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28b%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(b)" title="\psi(b)" class="latex"/> is zero are taken in consideration and represent valid state of the particle. Here we see first of many weird things happening in the quantum world – particle can not have any value for kinetic energy, only some of discrete numbers.</p>
<h3>Equation solving code</h3>
<p>As said earlier, to solve the differential equation we use <em>scipy.integrate.odeint()</em> routine. To properly work with it, we need to rewrite the Schrödinger equation in state-space representation, where first state is <img src="https://s0.wp.com/latex.php?latex=%5Cdot%7B%5Cpsi%7D&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\dot{\psi}" title="\dot{\psi}" class="latex"/> and second state <img src="https://s0.wp.com/latex.php?latex=%5Cddot%7B%5Cpsi%7D&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\ddot{\psi}" title="\ddot{\psi}" class="latex"/>. Since the <i>odeint()</i> works stepwise, it will take states from the previous step in each computation. The state-space function will finally look like this:</p>
<pre class="brush: python; collapse: false; title: ; notranslate" title="">
def SE(psi, x):
    """
    Returns derivatives for the 1D schrodinger eq.
    Requires global value E to be set somewhere. State0 is
    first derivative of the wave function psi, and state1 is
    its second derivative.
    """
    state0 = psi[1]
    state1 = 2.0*(V(x) - E)*psi[0]
    return array([state0, state1])
</pre>
<p>(Note: I’ve put <em>m</em> so that <img src="https://s0.wp.com/latex.php?latex=%5Chbar%5E2%2Fm+%3D+1&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\hbar^2/m = 1" title="\hbar^2/m = 1" class="latex"/>, just for simplicity). This function prepares state-space only. Following function does the real job, calls the state-space function and calculates the wave function <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/> for a given energy <em>E</em>. It also returns value of <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/> at the location <em>x=b</em> to test divergence.</p>
<pre class="brush: python; collapse: false; title: ; notranslate" title="">
def Wave_function(energy):
    """
    Calculates wave function psi for the given value
    of energy E and returns value at point b
    """
    global psi
    global E
    E = energy
    psi = odeint(SE, psi0, x)
    return psi[-1,0]
</pre>
<p>Of course, for the first step there is no previous step – that’s why we introduce variable <img src="https://s0.wp.com/latex.php?latex=%5Cpsi_0&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi_0" title="\psi_0" class="latex"/>, which holds initial conditions: <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%280%29+%3D+1&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(0) = 1" title="\psi(0) = 1" class="latex"/> and <img src="https://s0.wp.com/latex.php?latex=%5Cdot%7B%5Cpsi%7D%280%29+%3D+0&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\dot{\psi}(0) = 0" title="\dot{\psi}(0) = 0" class="latex"/></p>
<h3>Finding allowed states</h3>
<p>Once we have the values of <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28b%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(b)" title="\psi(b)" class="latex"/> for a range of energies we need to distinguish those states where <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29+&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x) " title="\psi(x) " class="latex"/> diverges. This is done using the Brent method to find a zero of the function <em class="xref py py-obj">f</em> on the sign changing interval [a , b]. The method is available as a Python’s routine <em>scipy.optimize.brentq(). </em>For an array of energies <em>e </em>we will check the sign of the <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28b%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(b)" title="\psi(b)" class="latex"/>. When the sign changes, it means that <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28b%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(b)" title="\psi(b)" class="latex"/> crosses zero point and now we can call <em>brentq() </em> to find the exact zero-point. The function is embedded as follows:</p>
<pre class="brush: python; collapse: false; title: ; notranslate" title="">
def find_all_zeroes(x,y):
    """
    Gives all zeroes in y = f(x)
    """
    all_zeroes = []
    s = sign(y)
    for i in range(len(y)-1):
        if s[i]+s[i+1] == 0:
            zero = brentq(Wave_function, x[i], x[i+1])
            all_zeroes.append(zero)
    return all_zeroes
</pre>
<p>The function will return an array <em>all_zeroes</em> which contains all zero points of the <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28b%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(b)" title="\psi(b)" class="latex"/>. How nicely the function works, you can see on this image:</p>
<figure data-shortcode="caption" id="attachment_260" class="wp-caption aligncenter"><a href="https://helentronica.files.wordpress.com/2014/09/allowede.png"><img class="wp-image-260 size-large" src="https://helentronica.files.wordpress.com/2014/09/allowede.png?w=809&amp;h=603" alt=""/></a><figcaption class="wp-caption-text">Allowed energies for which <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28b%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(b)" title="\psi(b)" class="latex"/> converges</figcaption></figure>
<p>In this example, I put <em>V<sub>0</sub></em> to 20, <em>L</em> to 1, and <em>m</em> so that <img src="https://s0.wp.com/latex.php?latex=%5Chbar%5E2%2Fm+%3D+1&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\hbar^2/m = 1" title="\hbar^2/m = 1" class="latex"/>. We obtain only 4 four allowed bound states with energies 0.92, 3.65, 8.09, and 14.</p>
<h2><span>Images, yaaay!</span></h2>
<p>Now there’s a little trick. You remember that fantastic little function which solves differential equations, <em>odeint(), </em>needs some initial conditions to work, right?. These are the values of <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/> at <em>x=0</em>. What we get from it is the function <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/> only right from 0! What happens on the left side? It depends on how we set the initial conditions. For if we chose <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%280%29+%3D+1&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(0) = 1" title="\psi(0) = 1" class="latex"/> and <img src="https://s0.wp.com/latex.php?latex=%5Cdot%7B%5Cpsi%7D%280%29+%3D+0&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\dot{\psi}(0) = 0" title="\dot{\psi}(0) = 0" class="latex"/> we get something called<em> symmetrical case</em>, so left side is just mirrored right side. But if we reverse initial conditions so that <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%280%29+%3D+0&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(0) = 0" title="\psi(0) = 0" class="latex"/> and <img src="https://s0.wp.com/latex.php?latex=%5Cdot%7B%5Cpsi%7D%280%29+%3D+1&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\dot{\psi}(0) = 1" title="\dot{\psi}(0) = 1" class="latex"/>, we get <em>antisymmetric case</em>. Why is that so? I’ll tell you just that symmetrical states correspond to the cosine based functions, while antisymmetric correspond to the sine based functions. More about it will come a bit later.</p>
<p>Let’s see how the states of <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/> look like. For the symmetrical case (<img src="https://s0.wp.com/latex.php?latex=%5Cpsi%280%29+%3D+1&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(0) = 1" title="\psi(0) = 1" class="latex"/>, <img src="https://s0.wp.com/latex.php?latex=%5Cdot%7B%5Cpsi%7D%280%29+%3D+0&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\dot{\psi}(0) = 0" title="\dot{\psi}(0) = 0" class="latex"/>):</p>
<figure data-shortcode="caption" id="attachment_266" class="wp-caption alignleft"><a href="https://helentronica.files.wordpress.com/2014/09/symmetrical_e.png"><img class="wp-image-266 " src="https://helentronica.files.wordpress.com/2014/09/symmetrical_e.png?w=270&amp;h=201" alt="Allowed energies for the symmetrical states"/></a><figcaption class="wp-caption-text">Allowed energies for the symmetrical states</figcaption></figure>
<figure data-shortcode="caption" id="attachment_267" class="wp-caption alignleft"><a href="https://helentronica.files.wordpress.com/2014/09/symmetrical_states.png"><img class="wp-image-267" src="https://helentronica.files.wordpress.com/2014/09/symmetrical_states.png?w=270&amp;h=201" alt="Allowed symmetrical states"/></a><figcaption class="wp-caption-text">Allowed symmetrical states</figcaption></figure>
<p> <br/>
 <br/>
 <br/>
 <br/>
 <br/>
 <br/>
 <br/>
 <br/>
 <br/>
 <br/>
 <br/>
 </p>
<p>And for the antisymmetrical case (<img src="https://s0.wp.com/latex.php?latex=%5Cpsi%280%29+%3D+0&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(0) = 0" title="\psi(0) = 0" class="latex"/>, <img src="https://s0.wp.com/latex.php?latex=%5Cdot%7B%5Cpsi%7D%280%29+%3D+1&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\dot{\psi}(0) = 1" title="\dot{\psi}(0) = 1" class="latex"/>):</p>
<figure data-shortcode="caption" id="attachment_264" class="wp-caption alignleft"><a href="https://helentronica.files.wordpress.com/2014/09/antisymmetrical_e.png"><img class="wp-image-264 " src="https://helentronica.files.wordpress.com/2014/09/antisymmetrical_e.png?w=269&amp;h=200" alt="Allowed energies for the antisymmetrical states"/></a><figcaption class="wp-caption-text">Allowed energies for the antisymmetrical states</figcaption></figure>
<figure data-shortcode="caption" id="attachment_265" class="wp-caption alignleft"><a href="https://helentronica.files.wordpress.com/2014/09/antisymmetrical_states.png"><img class="wp-image-265 " src="https://helentronica.files.wordpress.com/2014/09/antisymmetrical_states.png?w=271&amp;h=201" alt="Allowed antisymmetrical states"/></a><figcaption class="wp-caption-text">Allowed antisymmetrical states</figcaption></figure>
<p> <br/>
 <br/>
 <br/>
 <br/>
 <br/>
 <br/>
 <br/>
 <br/>
 <br/>
 <br/>
 <br/>
 <br/>
 </p>
<p>This is nice and correct way to solve the problem of the finite square well. But, I don’t like this boring pictures, so I decided to cheat a little bit <span class="wp-smiley wp-emoji wp-emoji-smile" title=":)">:)</span>. You see, the <em>odeint() </em>requires the initial conditions at <em>x = 0</em>, assuming <em>x</em> goes from <em>0</em> to <em>b</em>. But what if I give it values <em>-b &lt; x&lt; b</em>? Normally, we expect <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28-b%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(-b)" title="\psi(-b)" class="latex"/> to be o. But if we put initial conditions to be zero, we won’t get any non-zero result. That’s how the <em>odeint()</em> works, I can not prevent it. So here is where I cheat: I put <em>x</em> to be from <em>-b</em> to <em>b</em>, but initial conditions are not zero. Instead, they are some arbitrarily small value. Of course, <em>odeint()</em> will mess up values, but, interestingly, <em>the shape</em> of the function <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/> will stay correct! Additionally, it will calculate both symmetrical and antisymmetrical states. Great!</p>
<p>So, let’s do it again. Energies of allowed states are already calculated, it’s the first graph you see in this article. Bound states are here, presented in symmetrical and antisymmetrical case:</p>
<figure data-shortcode="caption" id="attachment_271" class="wp-caption aligncenter"><a href="https://helentronica.files.wordpress.com/2014/09/all_states.png"><img class="wp-image-271 size-large" src="https://helentronica.files.wordpress.com/2014/09/all_states.png?w=809&amp;h=603" alt="All allowed states"/></a><figcaption class="wp-caption-text">All allowed states</figcaption></figure>
<p>As said earlier, values are messed up, since the integral of <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/> squared is not 1. But it doesn’t matter cause <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/> is normalized anyway later. Few things about these states.</p>
<ol>
<li>Particle exists only in discrete states and is associated with the corresponding energy in each state. The states are <em>orthonormal. </em>One state can not be represented as a linear combination of other states. So, the particle can not be in the state which is not representable as a combination of given states.</li>
<li>Probability of finding particle in space is integral of <img src="https://s0.wp.com/latex.php?latex=%7C%5Cpsi%28x%29%7C%5E2&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="|\psi(x)|^2" title="|\psi(x)|^2" class="latex"/>. We see that in the first state (<em>ground state</em>) most likely to find the particle is in the center of the well. But if you give the particle a bit of energy and it jumps into the second state (<em>excited state</em>) you will find it most likely between center and edges.</li>
<li>What happens with the particle behind the walls of the well? We see that <img src="https://s0.wp.com/latex.php?latex=%5Cpsi%28x%29&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\psi(x)" title="\psi(x)" class="latex"/> is not zero left from <em>-L</em> and right from <em>L. </em>It means that<em> there is a non-zero probability of finding a particle outside the well</em>! Remember the analogy with the car between the mountains? It would mean that car has somehow ended behind the mountain although it can not climb it. The phenomenon is called <strong>quantum tunnelling</strong> and it may seem crazy in case of a car and a mountain, but it is quite common and normal thing in subatomic particles.</li>
</ol>
<h2><span>Is all this right?</span></h2>
<p>Did I do something wrong? Who guarantees that my functions <em>odeint()</em> and <em>brentq()</em> are used properly? Are these solutions of Schrödinger equation correct? To check it, I run a numerical computation of analytical model, provided in “<em>Introduction to Quantum Mechanics”</em> by D. Griffiths, page 62. In that model, we need to find solution of the equation <img src="https://s0.wp.com/latex.php?latex=%5Ctan%28z%29+%3D+%5Csqrt%7B%28z_0%2Fz%29%5E2-1%7D&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="\tan(z) = \sqrt{(z_0/z)^2-1}" title="\tan(z) = \sqrt{(z_0/z)^2-1}" class="latex"/> where  <img src="https://s0.wp.com/latex.php?latex=z+%3D+%5Cdfrac%7B%5Csqrt%7B%282mE%29%7DL%7D%7B%5Chbar%7D&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="z = \dfrac{\sqrt{(2mE)}L}{\hbar}" title="z = \dfrac{\sqrt{(2mE)}L}{\hbar}" class="latex"/> and <img src="https://s0.wp.com/latex.php?latex=z_0+%3D+%5Cdfrac%7B%5Csqrt%7B%282mV_0%29%7DL%7D%7B%5Chbar%7D&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="z_0 = \dfrac{\sqrt{(2mV_0)}L}{\hbar}" title="z_0 = \dfrac{\sqrt{(2mV_0)}L}{\hbar}" class="latex"/>. This will give us energies of allowed symmetrical states. For antisymmetrical states we should use  <img src="https://s0.wp.com/latex.php?latex=-%5Ccot%28z%29+%3D+%5Csqrt%7B%28z_0%2Fz%29%5E2-1%7D&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="-\cot(z) = \sqrt{(z_0/z)^2-1}" title="-\cot(z) = \sqrt{(z_0/z)^2-1}" class="latex"/>. Python method that does the job is presented here:</p>
<pre class="brush: python; collapse: false; title: ; notranslate" title="">
def find_analytic_energies(en):
    """
    Calculates Energy values for the finite square well using analytical
    model (Griffiths, Introduction to Quantum Mechanics, page 62.)
    """
    z = sqrt(2*en)
    z0 = sqrt(2*Vo)
    z_zeroes = []
    f_sym = lambda z: tan(z)-sqrt((z0/z)**2-1)      # Formula 2.138, symmetrical case
    f_asym = lambda z: -1/tan(z)-sqrt((z0/z)**2-1)  # Formula 2.138, antisymmetrical case

    # first find the zeroes for the symmetrical case
    s = sign(f_sym(z))
    for i in range(len(s)-1):   # find zeroes of this crazy function
       if s[i]+s[i+1] == 0:
           zero = brentq(f_sym, z[i], z[i+1])
           z_zeroes.append(zero)
    print "Energies from the analytical model are: "
    print "Symmetrical case)"
    for i in range(0, len(z_zeroes),2):   # discard z=(2n-1)pi/2 solutions cause that's where tan(z) is discontinuous
        print "%.4f" %(z_zeroes[i]**2/2)
    # Now for the asymmetrical
    z_zeroes = []
    s = sign(f_asym(z))
    for i in range(len(s)-1):   # find zeroes of this crazy function
       if s[i]+s[i+1] == 0:
           zero = brentq(f_asym, z[i], z[i+1])
           z_zeroes.append(zero)
    print "(Antisymmetrical case)"
    for i in range(0, len(z_zeroes),2):   # discard z=npi solutions cause that's where cot(z) is discontinuous
        print "%.4f" %(z_zeroes[i]**2/2)

</pre>
<p>As a result, I get output in Python console:</p>
<pre> Energies from the analyitical model are:
 (Symmetrical case)
 0.9179
 8.0922
 19.9726
 (Antisymmetrical case)
 3.6462
 14.0022</pre>
<p>and that corresponds completely to programs computation.  We can be sure that program works for as long as <em>E</em> is smaller than <img src="https://s0.wp.com/latex.php?latex=V_0&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="V_0" title="V_0" class="latex"/>, and <img src="https://s0.wp.com/latex.php?latex=V_0&amp;bg=ffffff&amp;fg=5e5e5e&amp;s=0" alt="V_0" title="V_0" class="latex"/> is not unreasonablly large. Finally, the source code for the whole program is here:</p>
<pre class="brush: python; collapse: true; light: false; title: ; toolbar: true; notranslate" title="">
# -*- coding: utf-8 -*-
"""
Created on Mon Sep 03 21:02:59 2014

@author: Pero

1D Schrödinger Equation in a finite square well.

Program calculates bound states and energies for a finite potential well. It will find eigenvalues
in a given range of energies and plot wave function for each state.

For a given energy vector e, program will calculate 1D wave function using the Schrödinger equation
in a finite square well defined by the potential V(x). If the wave function diverges on x-axis, the
energy e represents an unstable state and will be discarded. If the wave function converges on x-axis,
energy e is taken as an eigenvalue of the Hamiltonian (i.e. it is alowed energy and wave function
represents allowed state). 

Program uses differential equation solver &amp;amp;amp;amp;quot;odeint&amp;amp;amp;amp;quot; to calculate Sch. equation and optimization
tool &amp;amp;amp;amp;quot;brentq&amp;amp;amp;amp;quot; to find the root of the function. Both tools are included in the Scipy module.
The following functions are provided:

    - V(x) is a potential function of the square well. For a given x it returns the value of the potential
    - SE(psi, x) creates the state vector for a Schrödinger differential equation. Arguments are:
        psi - previous state of the wave function
        x - the x-axis
    - Wave_function(energy) calculates wave function using SE and &amp;amp;amp;amp;quot;odeint&amp;amp;amp;amp;quot;. It returns the wave-function
        at the value b far outside of the square well, so we can estimate convergence of the wave function.
    - find_all_zeroes(x,y) finds the x values where y(x) = 0 using &amp;amp;amp;amp;quot;brentq&amp;amp;amp;amp;quot; tool.    

Values of m and L are taken so that h-bar^2/m*L^2 is 1.

v2 adds feature of computational solution of analytical model from the usual textbooks. As a result,
energies computed by the program are printed and compared with those gained by the previous program.
"""
from pylab import *
from scipy.integrate import odeint
from scipy.optimize import brentq

def V(x):
    """
    Potential function in the finite square well. Width is L and value is global variable Vo
    """
    L = 1
    if abs(x) &gt; L:
        return 0
    else:
        return Vo

def SE(psi, x):
    """
    Returns derivatives for the 1D schrodinger eq.
    Requires global value E to be set somewhere. State0 is first derivative of the
    wave function psi, and state1 is its second derivative.
    """
    state0 = psi[1]
    state1 = 2.0*(V(x) - E)*psi[0]
    return array([state0, state1])

def Wave_function(energy):
    """
    Calculates wave function psi for the given value
    of energy E and returns value at point b
    """
    global psi
    global E
    E = energy
    psi = odeint(SE, psi0, x)
    return psi[-1,0]

def find_all_zeroes(x,y):
    """
    Gives all zeroes in y = Psi(x)
    """
    all_zeroes = []
    s = sign(y)
    for i in range(len(y)-1):
        if s[i]+s[i+1] == 0:
            zero = brentq(Wave_function, x[i], x[i+1])
            all_zeroes.append(zero)
    return all_zeroes

def find_analytic_energies(en):
    """
    Calculates Energy values for the finite square well using analytical
    model (Griffiths, Introduction to Quantum Mechanics, 1st edition, page 62.)
    """
    z = sqrt(2*en)
    z0 = sqrt(2*Vo)
    z_zeroes = []
    f_sym = lambda z: tan(z)-sqrt((z0/z)**2-1)      # Formula 2.138, symmetrical case
    f_asym = lambda z: -1/tan(z)-sqrt((z0/z)**2-1)  # Formula 2.138, antisymmetrical case

    # first find the zeroes for the symmetrical case
    s = sign(f_sym(z))
    for i in range(len(s)-1):   # find zeroes of this crazy function
       if s[i]+s[i+1] == 0:
           zero = brentq(f_sym, z[i], z[i+1])
           z_zeroes.append(zero)
    print "Energies from the analyitical model are: "
    print "Symmetrical case)"
    for i in range(0, len(z_zeroes),2):   # discard z=(2n-1)pi/2 solutions cause that's where tan(z) is discontinous
        print "%.4f" %(z_zeroes[i]**2/2)
    # Now for the asymmetrical
    z_zeroes = []
    s = sign(f_asym(z))
    for i in range(len(s)-1):   # find zeroes of this crazy function
       if s[i]+s[i+1] == 0:
           zero = brentq(f_asym, z[i], z[i+1])
           z_zeroes.append(zero)
    print "(Antisymmetrical case)"
    for i in range(0, len(z_zeroes),2):   # discard z=npi solutions cause that's where ctg(z) is discontinous
        print "%.4f" %(z_zeroes[i]**2/2)

N = 1000                  # number of points to take
psi = np.zeros([N,2])     # Wave function values and its derivative (psi and psi')
psi0 = array([0,1])   # Wave function initial states
Vo = 20
E = 0.0                   # global variable Energy  needed for Sch.Eq, changed in function "Wave function"
b = 2                     # point outside of well where we need to check if the function diverges
x = linspace(-b, b, N)    # x-axis

def main():
    # main program        

    en = linspace(0, Vo, 100)   # vector of energies where we look for the stable states

    psi_b = []      # vector of wave function at x = b for all of the energies in en
    for e1 in en:
        psi_b.append(Wave_function(e1))     # for each energy e1 find the the psi(x) at x = b
    E_zeroes = find_all_zeroes(en, psi_b)   # now find the energies where psi(b) = 0 

    # Print energies for the bound states
    print "Energies for the bound states are: "
    for E in E_zeroes:
        print "%.2f" %E
    # Print energies of each bound state from the analytical model
    find_analytic_energies(en)   

    # Plot wave function values at b vs energy vector
    figure()
    plot(en/Vo,psi_b)
    title('Values of the $\Psi(b)$ vs. Energy')
    xlabel('Energy, $E/V_0$')
    ylabel('$\Psi(x = b)$', rotation='horizontal')
    for E in E_zeroes:
        plot(E/Vo, [0], 'go')
        annotate("E = %.2f"%E, xy = (E/Vo, 0), xytext=(E/Vo, 30))
    grid()

    # Plot the wavefunctions for first 4 eigenstates
    figure(2)
    for E in E_zeroes[0:4]:
        Wave_function(E)
        plot(x, psi[:,0], label="E = %.2f"%E)
    legend(loc="upper right")
    title('Wave function')
    xlabel('x, $x/L$')
    ylabel('$\Psi(x)$', rotation='horizontal', fontsize = 15)
    grid()

if __name__ == "__main__":
    main()

</pre>
		<div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><div class="sharedaddy sd-block sd-like jetpack-likes-widget-wrapper jetpack-likes-widget-unloaded" id="like-post-wrapper-65788698-224-56d5b32b92fd2" data-src="//widgets.wp.com/likes/#blog_id=65788698&amp;post_id=224&amp;origin=helentronica.wordpress.com&amp;obj_id=65788698-224-56d5b32b92fd2" data-name="like-post-frame-65788698-224-56d5b32b92fd2"><h3 class="sd-title">Like this:</h3><p class="likes-widget-placeholder post-likes-widget-placeholder"><span class="button"><span>Like</span></span> <span class="loading">Loading...</span></p><span class="sd-text-color"/><a class="sd-link-color"/></div></div>					</div>

	</div></body></html>