<html><body><div><article class="text">
        

        <header class="article-header">
            <h1 class="page-title">PEP 0488 -- Elimination of PYO files</h1>
        </header>

        

 
  <table class="rfc2822 docutils field-list" frame="void" rules="none">
   <col class="field-name"/>
   
   <col class="field-body"/>
   
   <tbody valign="top">
    <tr class="field">
     <th class="field-name">
      PEP:
     </th>
     <td class="field-body">
      488
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Title:
     </th>
     <td class="field-body">
      Elimination of PYO files
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Author:
     </th>
     <td class="field-body">
      Brett Cannon &lt;brett at python.org&gt;
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Status:
     </th>
     <td class="field-body">
      Final
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Type:
     </th>
     <td class="field-body">
      Standards Track
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Created:
     </th>
     <td class="field-body">
      20-Feb-2015
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Python-Version:
     </th>
     <td class="field-body">
      3.5
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Post-History:
     </th>
     <td class="field-body">
      2015-03-06
2015-03-13
2015-03-20
     </td>
    </tr>
   </tbody>
  </table>
  <hr/>
  
  <div class="section" id="abstract">
   
   <p>
    This PEP proposes eliminating the concept of PYO files from Python.
To continue the support of the separation of bytecode files based on
their optimization level, this PEP proposes extending the PYC file
name to include the optimization level in the bytecode repository
directory when there are optimizations applied.
   </p>
  </div>
  <div class="section" id="rationale">
   
   <p>
    As of today, bytecode files come in two flavours: PYC and PYO. A PYC
file is the bytecode file generated and read from when no
optimization level is specified at interpreter startup (i.e.,
    <tt class="docutils literal">
     <span class="pre">
      -O
     </span>
    </tt>
    is not specified). A PYO file represents the bytecode file that is
read/written when
    <strong>
     any
    </strong>
    optimization level is specified (i.e., when
    <tt class="docutils literal">
     <span class="pre">
      -O
     </span>
    </tt>
    <strong>
     or
    </strong>
    <tt class="docutils literal">
     <span class="pre">
      -OO
     </span>
    </tt>
    is specified). This means that while PYC
files clearly delineate the optimization level used when they were
generated -- namely no optimizations beyond the peepholer -- the same
is not true for PYO files. To put this in terms of optimization
levels and the file extension:
   </p>
   <blockquote>
    <ul class="simple">
     <li>
      0:
      <tt class="docutils literal">
       .pyc
      </tt>
     </li>
     <li>
      1 (
      <tt class="docutils literal">
       <span class="pre">
        -O
       </span>
      </tt>
      ):
      <tt class="docutils literal">
       .pyo
      </tt>
     </li>
     <li>
      2 (
      <tt class="docutils literal">
       <span class="pre">
        -OO
       </span>
      </tt>
      ):
      <tt class="docutils literal">
       .pyo
      </tt>
     </li>
    </ul>
   </blockquote>
   <p>
    The reuse of the
    <tt class="docutils literal">
     .pyo
    </tt>
    file extension for both level 1 and 2
optimizations means that there is no clear way to tell what
optimization level was used to generate the bytecode file. In terms
of reading PYO files, this can lead to an interpreter using a mixture
of optimization levels with its code if the user was not careful to
make sure all PYO files were generated using the same optimization
level (typically done by blindly deleting all PYO files and then
using the
    <cite>
     compileall
    </cite>
    module to compile all-new PYO files
    <a class="footnote-reference" href="#id12" id="id1">
     [1]
    </a>
    ).
This issue is only compounded when people optimize Python code beyond
what the interpreter natively supports, e.g., using the astoptimizer
project
    <a class="footnote-reference" href="#id13" id="id2">
     [2]
    </a>
    .
   </p>
   <p>
    In terms of writing PYO files, the need to delete all PYO files
every time one either changes the optimization level they want to use
or are unsure of what optimization was used the last time PYO files
were generated leads to unnecessary file churn. The change proposed
by this PEP also allows for
    <strong>
     all
    </strong>
    optimization levels to be
pre-compiled for bytecode files ahead of time, something that is
currently impossible thanks to the reuse of the
    <tt class="docutils literal">
     .pyo
    </tt>
    file
extension for multiple optimization levels.
   </p>
   <p>
    As for distributing bytecode-only modules, having to distribute both
    <tt class="docutils literal">
     .pyc
    </tt>
    and
    <tt class="docutils literal">
     .pyo
    </tt>
    files is unnecessary for the common use-case
of code obfuscation and smaller file deployments. This means that
bytecode-only modules will only load from their non-optimized
    <tt class="docutils literal">
     .pyc
    </tt>
    file name.
   </p>
  </div>
  <div class="section" id="proposal">
   
   <p>
    To eliminate the ambiguity that PYO files present, this PEP proposes
eliminating the concept of PYO files and their accompanying
    <tt class="docutils literal">
     .pyo
    </tt>
    file extension. To allow for the optimization level to be unambiguous
as well as to avoid having to regenerate optimized bytecode files
needlessly in the
    <cite>
     __pycache__
    </cite>
    directory, the optimization level
used to generate the bytecode file will be incorporated into the
bytecode file name. When no optimization level is specified, the
pre-PEP
    <tt class="docutils literal">
     .pyc
    </tt>
    file name will be used (i.e., no optimization level
will be specified in the file name). For example, a source file named
    <tt class="docutils literal">
     foo.py
    </tt>
    in CPython 3.5 could have the following bytecode files
based on the interpreter's optimization level (none,
    <tt class="docutils literal">
     <span class="pre">
      -O
     </span>
    </tt>
    , and
    <tt class="docutils literal">
     <span class="pre">
      -OO
     </span>
    </tt>
    ):
   </p>
   <blockquote>
    <ul class="simple">
     <li>
      0:
      <tt class="docutils literal">
       <span class="pre">
        foo.cpython-35.pyc
       </span>
      </tt>
      (i.e., no change)
     </li>
     <li>
      1:
      <tt class="docutils literal">
       <span class="pre">
        foo.cpython-35.opt-1.pyc
       </span>
      </tt>
     </li>
     <li>
      2:
      <tt class="docutils literal">
       <span class="pre">
        foo.cpython-35.opt-2.pyc
       </span>
      </tt>
     </li>
    </ul>
   </blockquote>
   <p>
    Currently bytecode file names are created by
    <tt class="docutils literal">
     importlib.util.cache_from_source()
    </tt>
    , approximately using the
following expression defined by
    <a class="reference external" href="/dev/peps/pep-3147">
     PEP 3147
    </a>
    <a class="footnote-reference" href="#id14" id="id3">
     [3]
    </a>
    ,
    <a class="footnote-reference" href="#id15" id="id4">
     [4]
    </a>
    ,
    <a class="footnote-reference" href="#id16" id="id5">
     [5]
    </a>
    :
   </p>
   <pre class="literal-block">
'{name}.{cache_tag}.pyc'.format(name=module_name,
                                cache_tag=sys.implementation.cache_tag)
</pre>
   <p>
    This PEP proposes to change the expression when an optimization
level is specified to:
   </p>
   <pre class="literal-block">
'{name}.{cache_tag}.opt-{optimization}.pyc'.format(
        name=module_name,
        cache_tag=sys.implementation.cache_tag,
        optimization=str(sys.flags.optimize))
</pre>
   <p>
    The "opt-" prefix was chosen so as to provide a visual separator
from the cache tag. The placement of the optimization level after
the cache tag was chosen to preserve lexicographic sort order of
bytecode file names based on module name and cache tag which will
not vary for a single interpreter. The "opt-" prefix was chosen over
"o" so as to be somewhat self-documenting. The "opt-" prefix was
chosen over "O" so as to not have any confusion in case "0" was the
leading prefix of the optimization level.
   </p>
   <p>
    A period was chosen over a hyphen as a separator so as to distinguish
clearly that the optimization level is not part of the interpreter
version as specified by the cache tag. It also lends to the use of
the period in the file name to delineate semantically different
concepts.
   </p>
   <p>
    For example, if
    <tt class="docutils literal">
     <span class="pre">
      -OO
     </span>
    </tt>
    had been passed to the interpreter then
instead of
    <tt class="docutils literal">
     <span class="pre">
      importlib.cpython-35.pyo
     </span>
    </tt>
    the file name would be
    <tt class="docutils literal">
     <span class="pre">
      importlib.cpython-35.opt-2.pyc
     </span>
    </tt>
    .
   </p>
   <p>
    Leaving out the new
    <tt class="docutils literal">
     opt-
    </tt>
    tag when no optimization level is
applied should increase backwards-compatibility. This is also more
understanding of Python implementations which have no use for
optimization levels (e.g., PyPy[10]_).
   </p>
   <p>
    It should be noted that this change in no way affects the performance
of import. Since the import system looks for a single bytecode file
based on the optimization level of the interpreter already and
generates a new bytecode file if it doesn't exist, the introduction
of potentially more bytecode files in the
    <tt class="docutils literal">
     __pycache__
    </tt>
    directory
has no effect in terms of stat calls. The interpreter will continue
to look for only a single bytecode file based on the optimization
level and thus no increase in stat calls will occur.
   </p>
   <p>
    The only potentially negative result of this PEP is the probable
increase in the number of
    <tt class="docutils literal">
     .pyc
    </tt>
    files and thus increase in storage
use. But for platforms where this is an issue,
    <tt class="docutils literal">
     sys.dont_write_bytecode
    </tt>
    exists to turn off bytecode generation so
that it can be controlled offline.
   </p>
  </div>
  <div class="section" id="implementation">
   
   <p>
    An implementation of this PEP is available
    <a class="footnote-reference" href="#id22" id="id6">
     [11]
    </a>
    .
   </p>
   <div class="section" id="importlib">
    
    <p>
     As
     <tt class="docutils literal">
      importlib.util.cache_from_source()
     </tt>
     is the API that exposes
bytecode file paths as well as being directly used by importlib, it
requires the most critical change. As of Python 3.4, the function's
signature is:
    </p>
    <pre class="literal-block">
importlib.util.cache_from_source(path, debug_override=None)
</pre>
    <p>
     This PEP proposes changing the signature in Python 3.5 to:
    </p>
    <pre class="literal-block">
importlib.util.cache_from_source(path, debug_override=None, *, optimization=None)
</pre>
    <p>
     The introduced
     <tt class="docutils literal">
      optimization
     </tt>
     keyword-only parameter will control
what optimization level is specified in the file name. If the
argument is
     <tt class="docutils literal">
      None
     </tt>
     then the current optimization level of the
interpreter will be assumed (including no optimization). Any argument
given for
     <tt class="docutils literal">
      optimization
     </tt>
     will be passed to
     <tt class="docutils literal">
      str()
     </tt>
     and must have
     <tt class="docutils literal">
      str.isalnum()
     </tt>
     be true, else
     <tt class="docutils literal">
      ValueError
     </tt>
     will be raised (this
prevents invalid characters being used in the file name). If the
empty string is passed in for
     <tt class="docutils literal">
      optimization
     </tt>
     then the addition of
the optimization will be suppressed, reverting to the file name
format which predates this PEP.
    </p>
    <p>
     It is expected that beyond Python's own two optimization levels,
third-party code will use a hash of optimization names to specify the
optimization level, e.g.
     <tt class="docutils literal">
      <span class="pre">
       hashlib.sha256(','.join(['no
      </span>
      dead code', 'const
      <span class="pre">
       folding'])).hexdigest()
      </span>
     </tt>
     .
While this might lead to long file names, it is assumed that most
users never look at the contents of the __pycache__ directory and so
this won't be an issue.
    </p>
    <p>
     The
     <tt class="docutils literal">
      debug_override
     </tt>
     parameter will be deprecated. A
     <tt class="docutils literal">
      False
     </tt>
     value will be equivalent to
     <tt class="docutils literal">
      optimization=1
     </tt>
     while a
     <tt class="docutils literal">
      True
     </tt>
     value will represent
     <tt class="docutils literal">
      <span class="pre">
       optimization=''
      </span>
     </tt>
     (a
     <tt class="docutils literal">
      None
     </tt>
     argument will
continue to mean the same as for
     <tt class="docutils literal">
      optimization
     </tt>
     ). A
deprecation warning will be raised when
     <tt class="docutils literal">
      debug_override
     </tt>
     is given a
value other than
     <tt class="docutils literal">
      None
     </tt>
     , but there are no plans for the complete
removal of the parameter at this time (but removal will be no later
than Python 4).
    </p>
    <p>
     The various module attributes for importlib.machinery which relate to
bytecode file suffixes will be updated
     <a class="footnote-reference" href="#id18" id="id7">
      [7]
     </a>
     . The
     <tt class="docutils literal">
      DEBUG_BYTECODE_SUFFIXES
     </tt>
     and
     <tt class="docutils literal">
      OPTIMIZED_BYTECODE_SUFFIXES
     </tt>
     will
both be documented as deprecated and set to the same value as
     <tt class="docutils literal">
      BYTECODE_SUFFIXES
     </tt>
     (removal of
     <tt class="docutils literal">
      DEBUG_BYTECODE_SUFFIXES
     </tt>
     and
     <tt class="docutils literal">
      OPTIMIZED_BYTECODE_SUFFIXES
     </tt>
     is not currently planned, but will be
not later than Python 4).
    </p>
    <p>
     All various finders and loaders will also be updated as necessary,
but updating the previous mentioned parts of importlib should be all
that is required.
    </p>
   </div>
   <div class="section" id="rest-of-the-standard-library">
    
    <p>
     The various functions exposed by the
     <tt class="docutils literal">
      py_compile
     </tt>
     and
     <tt class="docutils literal">
      compileall
     </tt>
     functions will be updated as necessary to make sure
they follow the new bytecode file name semantics
     <a class="footnote-reference" href="#id17" id="id8">
      [6]
     </a>
     ,
     <a class="footnote-reference" href="#id12" id="id9">
      [1]
     </a>
     . The CLI
for the
     <tt class="docutils literal">
      compileall
     </tt>
     module will not be directly affected (the
     <tt class="docutils literal">
      <span class="pre">
       -b
      </span>
     </tt>
     flag will be implicit as it will no longer generate
     <tt class="docutils literal">
      .pyo
     </tt>
     files when
     <tt class="docutils literal">
      <span class="pre">
       -O
      </span>
     </tt>
     is specified).
    </p>
   </div>
  </div>
  <div class="section" id="compatibility-considerations">
   
   <p>
    Any code directly manipulating bytecode files from Python 3.2 on
will need to consider the impact of this change on their code (prior
to Python 3.2 -- including all of Python 2 -- there was no
__pycache__ which already necessitates bifurcating bytecode file
handling support). If code was setting the
    <tt class="docutils literal">
     debug_override
    </tt>
    argument to
    <tt class="docutils literal">
     importlib.util.cache_from_source()
    </tt>
    then care will be
needed if they want the path to a bytecode file with an optimization
level of 2. Otherwise only code
    <strong>
     not
    </strong>
    using
    <tt class="docutils literal">
     importlib.util.cache_from_source()
    </tt>
    will need updating.
   </p>
   <p>
    As for people who distribute bytecode-only modules (i.e., use a
bytecode file instead of a source file), they will have to choose
which optimization level they want their bytecode files to be since
distributing a
    <tt class="docutils literal">
     .pyo
    </tt>
    file with a
    <tt class="docutils literal">
     .pyc
    </tt>
    file will no longer be
of any use. Since people typically only distribute bytecode files for
code obfuscation purposes or smaller distribution size then only
having to distribute a single
    <tt class="docutils literal">
     .pyc
    </tt>
    should actually be beneficial
to these use-cases. And since the magic number for bytecode files
changed in Python 3.5 to support
    <a class="reference external" href="/dev/peps/pep-0465">
     PEP 465
    </a>
    there is no need to support
pre-existing
    <tt class="docutils literal">
     .pyo
    </tt>
    files
    <a class="footnote-reference" href="#id19" id="id10">
     [8]
    </a>
    .
   </p>
  </div>
  <div class="section" id="rejected-ideas">
   
   <div class="section" id="completely-dropping-optimization-levels-from-cpython">
    
    <p>
     Some have suggested that instead of accommodating the various
optimization levels in CPython, we should instead drop them
entirely. The argument is that significant performance gains would
occur from runtime optimizations through something like a JIT and not
through pre-execution bytecode optimizations.
    </p>
    <p>
     This idea is rejected for this PEP as that ignores the fact that
there are people who do find the pre-existing optimization levels for
CPython useful. It also assumes that no other Python interpreter
would find what this PEP proposes useful.
    </p>
   </div>
   <div class="section" id="alternative-formatting-of-the-optimization-level-in-the-file-name">
    
    <p>
     Using the "opt-" prefix and placing the optimization level between
the cache tag and file extension is not critical. All options which
have been considered are:
    </p>
    <ul class="simple">
     <li>
      <tt class="docutils literal">
       <span class="pre">
        importlib.cpython-35.opt-1.pyc
       </span>
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       <span class="pre">
        importlib.cpython-35.opt1.pyc
       </span>
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       <span class="pre">
        importlib.cpython-35.o1.pyc
       </span>
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       <span class="pre">
        importlib.cpython-35.O1.pyc
       </span>
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       <span class="pre">
        importlib.cpython-35.1.pyc
       </span>
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       <span class="pre">
        importlib.cpython-35-O1.pyc
       </span>
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       <span class="pre">
        importlib.O1.cpython-35.pyc
       </span>
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       <span class="pre">
        importlib.o1.cpython-35.pyc
       </span>
      </tt>
     </li>
     <li>
      <tt class="docutils literal">
       <span class="pre">
        importlib.1.cpython-35.pyc
       </span>
      </tt>
     </li>
    </ul>
    <p>
     These were initially rejected either because they would change the
sort order of bytecode files, possible ambiguity with the cache tag,
or were not self-documenting enough. An informal poll was taken and
people clearly preferred the formatting proposed by the PEP
     <a class="footnote-reference" href="#id20" id="id11">
      [9]
     </a>
     .
Since this topic is non-technical and of personal choice, the issue
is considered solved.
    </p>
   </div>
   
  </div>
  
  <div class="section" id="copyright">
   
   <p>
    This document has been placed in the public domain.
   </p>
   
  </div>
 
Source: <a href="https://hg.python.org/peps/file/tip/pep-0488.txt">https://hg.python.org/peps/file/tip/pep-0488.txt</a>

    </article>


                </div></body></html>