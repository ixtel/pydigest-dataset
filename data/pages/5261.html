<html><body><div><article>
	<h1>Working with Python's 3rd Party Libraries the Right Way</h1>


	<br/>
	<p>Although the Python's standard library provides a great set of awesome
functionalities, there will be times that you will eventually run into the
need of making use of third party libraries.</p>
<p>And this is nothing to be ashamed of! Can you imagine building a webserver
from scratch? Or making a port to a database driver? Or, maybe, comming up
with an image manipulation tool? I'm not saying that this is impossible, all
I'm saying is that it would be a whole new project by itself.</p>
<p>Third party libraries are welcome in a way that they prevent you from
reinventing the wheel. They save you time to focus on what really matters:
to finish and deliver your application.</p>
<p>By the time I'm writing this entry, the <a class="reference external" href="https://pypi.python.org/pypi">Python Package Index (PyPI)</a> is
loaded with <strong>62788</strong> packages that address different purposes and it is
most likely that there is already something there that will do the heavy
lifting for you.</p>
<p>There are different ways to install and make use of those packages and
here I'm going to show you the way it works for me.</p>
<hr class="docutils"/>
<div class="section" id="a-quick-dive-into-python-modules">
<h2>A quick dive into Python modules</h2>
<p>The Python module system is one of the most awesome features of the Python
programming languge. Different from other popular languages, a Python
module is namespace and, during runtime, an object. To understand how
to use third party packages, it is important to grasp the basics of how
Python's modules work.</p>
<p>Say you are writing a silly script that outputs a random number between
0 and 10. In order to do so, after a quick Google search you find out that
the standard library provides you with a module called <code>random</code> that
will do exactly what you want. Then you would start by doing something
like:</p>
<pre class="code python literal-block">
<span class="c"># file: silly.py</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="k">print</span> <span class="n">r</span>
</pre>
<p>Once you attempt to run this code, you'll get the following output:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>python silly.py
Traceback <span class="o">(</span>most recent call last<span class="o">)</span>:
  File <span class="s2">"silly.py"</span>, line 3, in &lt;module&gt;
    <span class="nv">r</span> <span class="o">=</span> random.randint<span class="o">(</span>0, 10<span class="o">)</span>
NameError: name <span class="s1">'random'</span> is not defined
</pre>
<p>What happened? As the uncaught error suggests, you are trying to call the
method <code>randint</code> in a binding named <code>random</code> that does not
exist in the current context.</p>
<p>Alright. Let's fix it:</p>
<pre class="code python literal-block">
<span class="c"># file: silly.py</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="k">print</span> <span class="n">r</span>
</pre>
<p>And now, if we run our script, everything works as expected:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>python silly.py
4
</pre>
<p>It generated a <strong>4</strong> but if you run it several times you'll notice that
at each run it outputs a different random number between 0 and 10, just as
we wanted in the first place.</p>
<p>That's cool, but what we are really interested in is how did that happen.
Where did the <code>import random</code> get what was needed to make our code
work?</p>
<p>To understand that, let's run another command line tool:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>whereis python
python: /usr/bin/python3.4m /usr/bin/python /usr/bin/python3.4 /usr/bin/python2.7 /usr/bin/python2.7-config /etc/python /etc/python3.4 /etc/python2.7 /usr/lib/python3.4 /usr/lib/python2.7 /usr/bin/X11/python3.4m /usr/bin/X11/python /usr/bin/X11/python3.4 /usr/bin/X11/python2.7 /usr/bin/X11/python2.7-config /usr/local/lib/python3.4 /usr/local/lib/python2.7 /usr/include/python3.4m /usr/include/python2.7 /usr/share/python /usr/share/man/man1/python.1.gz
</pre>
<p class="alert alert-warning">
    <strong>Note:</strong> Your output might differ because of the Python
    versions installed on your computer.
</p><p>The <code>whereis</code> program locates the binary, source, and manual page
files for a command, that in our case is <code>python</code>.</p>
<p>Now, if you snoop into one of your Python <code>lib/</code> directories (in our
case, <code>/usr/local/lib/python2.7/</code>, since we have been using using the
system's default Python installation), you will find that it is composed
by all the standard library modules, including our already familiar
<code>random</code>. And that is where it goes looking for standard library
modules when we use an <code>import</code> statement on our code.</p>
<p class="alert alert-warning">
    <strong>Note:</strong> In constrast with the standard library modules,
    for the sake of organization, the third party modules live in special
    directories called <code>site-packages/</code> and
    <code>dist-packages/</code> located right under the <code>lib/</code>
    directory we just talked about.
</p></div>
<hr class="docutils"/>
<div class="section" id="meet-pip">
<h2>Meet 'pip'</h2>
<p><code>pip</code> is a recursive acronym and stands for "pip installs packages".
It has become the official Python package manager and it is used basically
to install and uninstall packages from the Python Package Index.</p>
<p>If you are using the most recent versions of Python (2.7.9+ or 3.4+)
<code>pip</code> comes already bundled into the Python installation.</p>
<p>To check if <code>pip</code> is installed on your machine, type the following
command in a terminal:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>pip --version
pip 6.1.1 from /usr/local/lib/python2.7/dist-packages <span class="o">(</span>python 2.7<span class="o">)</span>
</pre>
<p>If it is installed, your output should be similar to the one above.
However, don't fear if it isn't: there's a one-liner to fix this problem:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>curl -s https://bootstrap.pypa.io/get-pip.py <span class="p">|</span> sudo python /dev/stdin
</pre>
<p>OK! Now that you have your package manager installed, let's use it to
download and install the packages needed to create a website using the
almighty Django framework:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>sudo pip install django
</pre>
<p>It is simple as that!</p>
<p>Once you've done that, you'll be able to follow the <a class="reference external" href="https://docs.djangoproject.com/en/1.8/intro/tutorial01/">Django's official
tutorial</a>.</p>
<p>However, <strong>although it works, it is a terrible idea</strong> to bloat your
Python installation with third party libraries because of the following
reasons:</p>
<ul class="simple">
<li>You may have more than one project that depends on different versions
of the same library. It is impossible to have different versions of the
same library under the same Python installation.</li>
<li>You may want to verify what are the exact dependencies of a particular
project in order to run it somewhere else. If you install everything
under the same Python installation, it is impossible to track what project
is using what dependency.</li>
</ul>
<p>That being said, <strong>I highly recommend that you use virtualenv as the
foundation of your Python projects</strong> as you will see in the next session.</p>
<p>Now that you know the wrong way to use <code>pip</code>, let's uninstall the
<code>django</code> package we installed before and learn how to do it the right
way. In a terminal type:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>sudo pip uninstall django
</pre>
<p>Done. As you can see, uninstalling packages is as easy as installing them
with the aid of <code>pip</code>.</p>
<p>For more commands and further information on <code>pip</code>, please refer to
the <a class="reference external" href="https://pip.pypa.io/en/stable/">pip documentation</a>.</p>
</div>
<hr class="docutils"/>
<div class="section" id="sandboxing-projects-with-virtualenv">
<h2>Sandboxing projects with 'virtualenv'</h2>
<p>By now, you should have understood why it is important (and sane) to
separate the dependencies of your projects and that no Python package
should be installed under the main Python installation.</p>
<p>Except that this is a lie. There are three packages that should be
installed under the main Python installation. One is already there:
<code>pip</code>. The other two are <code>virtualenv</code> and
<code>virtualenvwrapper</code>. We'll take a look at <code>virtualenvwrapper</code>
in the next session, but, right now, let's concern ourselves with the
<code>virtualenv</code> only.</p>
<p>What <code>virtualenv</code> does are basically two things:</p>
<ul class="simple">
<li>It creates a new instance of your main Python installation in
a particular directory.</li>
<li>It provides tools for you to <em>activate</em> and <em>deactivate</em> these instances
in a way that whenever they are activated, they have precedence on your
system's PATH. In other words, it means that if you activated your
virtualenv and attempted to run any Python binary, it is going to look
for it in the new instance's directory first.</li>
</ul>
<p>And that, my friend, is how you will be sandboxing your projects! We begin
installing the <code>virtualenv</code> in your main Python installation:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>sudo pip install virtualenv
</pre>
<p class="alert alert-warning">
    <strong>Note:</strong> This step doesn't need to be repeated for every
    project. You'll do it only once.
</p><p>Now that we have virtualenv available, let's <em>make a directory</em> for our
sandboxed django project and <em>cd</em> into it:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>makedir -p <span class="nv">$HOME</span>/Workspace/my-sandboxed-django-proj
<span class="nv">$ </span><span class="nb">cd</span> <span class="nv">$HOME</span>/Workspace/my-sandboxed-django-proj
</pre>
<p>And next we create a virtualenv <em>for this project</em>:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>virtualenv .venv
New python executable in .venv/bin/python
Installing setuptools, pip...done.
</pre>
<p>The directory structure should look like this:</p>
<pre class="code text literal-block">
my-sandboxed-django-proj/
└── .venv/
    ├── bin/
    ├── include/
    ├── lib/
    └── local/
</pre>
<p>Now, the only remaining thing we have to do before we install the django
package is to activate our newly created virtual environment:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span><span class="nb">source</span> .venv/bin/activate
</pre>
<p>And that's it. If everything worked, you should notice that your prompt
has changed to something like:</p>
<pre class="code text literal-block">
(.venv)$
</pre>
<p>Great! Now you are safe to install your third party libraries and code
your Django application. How to install the <code>django</code> package in your
newly activated virtualenv? Easy, with <code>pip</code>:</p>
<pre class="code shell literal-block">
<span class="o">(</span>.venv<span class="o">)</span><span class="nv">$ </span>pip install django
</pre>
<p class="alert alert-warning">
    <strong>Note:</strong> Attention here! Notice that here we did not use
    <code>sudo</code> in front of our command. If we did, the package would be
    installed in the main Python installation directory, even though we were
    with the <code>virtualenv</code> activated.
</p><p>Alright, now you can import all needed third party library, code your
Django application and conquer the world!</p>
<p>Once you are done using your <code>virtualenv</code> you can deactivate it by
typing:</p>
<pre class="code shell literal-block">
<span class="o">(</span>.venv<span class="o">)</span><span class="nv">$ </span>deactivate
</pre>
<p>Smooth and simple. Now everything goes back to how it was in the last
section. If you attempt to install something with pip it is going to be
installed in the main Python installation and you prompt should have gone
back to its usual look.</p>
<p>And we are done with <code>virtualenv</code>. There's not a lot more to be said
here. If you want more information visit <a class="reference external" href="https://virtualenv.pypa.io/en/latest/">virtualenv documentation</a>.</p>
</div>
<hr class="docutils"/>
<div class="section" id="the-convenient-virtualenvwrapper">
<h2>The convenient 'virtualenvwrapper'</h2>
<p>Lazy programmers might think that having to do all of the above steps for
every project might seem to be a burden, than why not create a script to
do that for you?</p>
<p>You don't need to: <code>virtualenvwrapper</code> is a collection of shell
functions that will ease your life with sandboxed Python environments. It
includes:</p>
<ul class="simple">
<li>A centralized way of mantaining your virtualenvironments</li>
<li>Activation of a virtualenvironment from anywhere in the directory tree</li>
<li>Temporary virtualenvironments to make quick tests</li>
<li>Autocomplete</li>
</ul>
<p>Isn't it awesome? Let's configure it. We start by installing it.</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>sudo pip install virtualenvwrapper
</pre>
<p class="alert alert-warning">
    <strong>Note:</strong> The truth is that you didn't need to install
    <code>virtualenv</code> beforehand in order to install
    <code>virtualenvwrapper</code>. This happens because
    <strong>when you use</strong> <code>pip</code> <strong>to install a package, it
    automatically installs all its dependecies recursively</strong>. Since
    <code>virtualenv</code> is a dependency for <code>virtualenvwrapper</code> the
    previous command would suffice.
</p><p class="alert alert-warning">
    <strong>Note:</strong> As for <code>virtualenv</code>, this step doesn't
    need to be repeated for every project. You'll do it only once.
</p><p>The last configuration step, before we have access to all the utilities of
<code>virtualenvwrapper</code> is that we need to tell it where to save our
virtualenvironments (<code>$WORKON_HOME</code>) and autostart it whenever we
start a new terminal. We do that by appending the following lines to our
<code>$HOME/.bashrc</code> file (or similars):</p>
<pre class="code shell literal-block">
<span class="c"># file: $HOME/.bashrc
</span>
<span class="c"># ... other content goes here ...
</span>
<span class="nb">export </span><span class="nv">WORKON_HOME</span><span class="o">=</span><span class="nv">$HOME</span>/.venvs
<span class="nb">export </span><span class="nv">VIRTUALENVWRAPPER_SCRIPT</span><span class="o">=</span>/usr/local/bin/virtualenvwrapper.sh
<span class="nb">source</span> <span class="nv">$VIRTUALENVWRAPPER_SCRIPT</span>
</pre>
<p>Now restart your terminal or type:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span><span class="nb">source</span> <span class="nv">$HOME</span>/.bashrc
</pre>
<p>Are you ready to see its joy?</p>
<p>So you want to create a new virtualenvrionment? No problem! Go ahead and type:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>mkvirtualenv my-new-virtualenv
New python executable in my-new-virtualenv/bin/python
Installing setuptools, pip...done.
</pre>
<p>Whoa! You shell should have changed to the following and you already know
what that means:</p>
<pre class="code text literal-block">
(my-new-virtualenv)$
</pre>
<p>That's right. You activated your virtualenv with one single command. To
deactivate it is the same command as for <code>virtualenv</code>, just type:</p>
<pre class="code shell literal-block">
<span class="o">(</span>my-new-virtualenv<span class="o">)</span><span class="nv">$ </span>deactivate
</pre>
<p>And what if you want it active once again? No problem, here you go:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>workon my-new-virtualenv
</pre>
<p>Simple? Oh! You don't want that virtualenvironment anymore? Easy:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>rmvirtualenv my-new-virtualenv
Removing my-new-virtualenv...
</pre>
<p>That's it. Gone.</p>
<p>Want to test what is going to be the new library for your project? OK. How
about you make a temporary environment:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>mktmpenv
New python executable in tmp-ffe1f7f2b5e5102f/bin/python
Installing setuptools, pip...done.
This is a temporary environment. It will be deleted when you run <span class="s1">'deactivate'</span>.
</pre>
<p>Yes. You should be in a temporary environment that will autodestruct once
you deactivate it!</p>
<p>There are many commands provided by the <code>virtualenvwrapper</code> and you
can check them out in the <a class="reference external" href="https://virtualenvwrapper.readthedocs.org/en/latest/">virtualenvwrapper documentation</a>. Here I just
presented some that I use constantly.</p>
<p>Once you have a virtualenvironment activated, to install requirements is
straightforward as usual: just use <code>pip</code> as we did before in the
previous sections.</p>
<p>The virtualenvironments are all held under the <code>$WORKON_HOME</code> that
you specified on the <code>$HOME/.bashrc</code>, so if you need, just <em>cd</em> into
it and do whatever you have to do.</p>
</div>
<hr class="docutils"/>
<div class="section" id="freezing-and-consuming-freezed-requirements">
<h2>Freezing and consuming freezed requirements</h2>
<p>If you want to share your code with other people and make it less of
a pain for them to run it, it is a good practice to freeze (write)
a relation of the dependencies of your project in
a <code>requirements.txt</code> file.</p>
<p>In order to do so, we can use one functionality of <code>pip</code>. Just
activate the virtualenvironment with your dependencies and then type:</p>
<pre class="code shell literal-block">
<span class="o">(</span>my-virtualenv<span class="o">)</span><span class="nv">$ </span>pip freeze &gt; requirements.txt
</pre>
<p class="alert alert-warning">
    <strong>Note:</strong> The name of the output file could be anything, but
    <code>requirements.txt</code> is the usual choice and it should be
    adopted to become compatible with the community.
</p><p>Suppose that in your virtualenvironment '<code>my-virtualenv</code>' there was
a <code>django</code> and <code>MySQL-python</code> installation. The content of the
resulting <code>requirementes.txt</code> would be:</p>
<pre class="code text literal-block">
Django==1.8.3
MySQL-python==1.2.5
</pre>
<p>Where the values on the left of the equality are the packages and the
values on the right of the equality are their respective versions.</p>
<p>And that's it, once someone put their hand on your code, the first thing
they would do is to create a new virtualenvironment and then type:</p>
<pre class="code shell literal-block">
<span class="o">(</span>new-virtualenv<span class="o">)</span><span class="nv">$ </span>pip install -r requirements.txt
</pre>
<p>And that would install the right version of all the dependencies needed for
them to run your code.</p>
</div>
<hr class="docutils"/>
<div class="section" id="installing-specific-versions-of-3rd-party-libraries">
<h2>Installing specific versions of 3rd party libraries</h2>
<p>You can tell <code>pip</code> to install a specific version of a library by
typing the commands as follows:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>pip install <span class="nv">django</span><span class="o">==</span>1.6.11
</pre>
<p>That would install the Django in its version 1.6.11. Notice that there
must exist a correspondent version available at the Python Package Index.</p>
<p class="alert alert-warning">
    <strong>Note:</strong> If you do not specify a version, pip will
    install the latest stable release available with a matching package
    name.
</p></div>
<hr class="docutils"/>
<div class="section" id="using-different-python-versions">
<h2>Using different Python versions</h2>
<p>It might be the case that you have multiple Python versions installed on
your machine.</p>
<p>If that is the case, both <code>virtualenv</code> and <code>virtualenvwrapper</code>
provide ways for you to specify what version the target virtualenvironment
is going to be.</p>
<p>For virtualenv, use:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>virtualenv &lt;path to virtualenv&gt; -p &lt;path to python executable&gt;
</pre>
<p>And for virtualenvwrapper you can also use:</p>
<pre class="code shell literal-block">
<span class="nv">$ </span>mkvirtualenv &lt;virtualenv name&gt; -p &lt;path to python executable&gt;
</pre>
<p>If you do not specify a version, the Python version used to install
<code>virtualenv</code> or <code>virtualenvwrapper</code> will be used.</p>
</div>
<hr class="docutils"/>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>Although there are other sandboxing projects for Python out there, such
as <a class="reference external" href="https://github.com/yyuu/pyenv">Pyenv</a>, I think the ones I described here are the most popular and
you could (and should) even use them in production.</p>
<p>I hope this entry helps people that are starting to dive into the pythonic
world to get to know a little bit more about the Python ecossistem and
avoid making the same mistakes I've made when I was starting myself.</p>
<p>If you have a question or a suggestion, please feel more than welcome to
use the comment section below.</p>
</div>

<br/>
</article>
</div></body></html>