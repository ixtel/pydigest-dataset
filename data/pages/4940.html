<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/files/e36/58a/ca6/e3658aca69ab496895f5bc53c7357632.jpeg"/>
<p>
[ </p><a href="http://habrahabr.ru/post/259219/">Первая часть</a><p> ]
</p><p>
В этом посте будет то, что не поместилось в первую часть. Это некоторые операторы, которые есть в </p><code>aggregation framework</code><p> и достаточно вольный перевод трех статей из раздела </p><a href="http://docs.mongodb.org/ecosystem/#use-cases">экоситема</a><p> на сайте со справкой к </p><code>MongoDB</code><p>, описывающих некоторые случаи применения для интернет-коммерции.
</p><p>
Случаи использования разделены там на восемь статей, которые условно можно разделить на три группы. Мне показались самыми интересными для перевода три материала, связанные с </p><code>e-commerce</code><p>.

</p><ol>
<li><a href="#1">Операторы в aggregation framework</a></li>
<li><a href="#2"> Каталог продуктов</a></li>
<li><a href="#3"> Корзина и управления остатками на складе </a></li>
<li><a href="#4"> Иерархия категорий</a></li>
</ol>
<a name="habracut"/>

<h3><a name="1"/> <font> Операторы в aggregation framework</font></h3><p>
Как правило в </p><code>aggregation framework</code><p> есть основные операторы например </p><code>$project</code><p> или </p><code>$group</code><p> из которых формируются цепочки </p><code>pipeline</code><p>.</p><p>
Но есть и такие операторы как </p><code>$cond</code><p>, которые всегда находятся внутри основных операторов. 
</p><em><font>$cond</font><font> примерный аналог обычного if</font></em><p>
Появился с версии </p><code>2.6</code><p> и у него есть две формы записи:
</p><pre><code class="python">{ $cond: { if: &lt;boolean-expression&gt;, then: &lt;true-case&gt;, else: &lt;false-case-&gt; } }
или
{ $cond: [ &lt;boolean-expression&gt;, &lt;true-case&gt;, &lt;false-case&gt; ] }
</code></pre><p>
Пример, есть следующие документы:
</p><pre><code class="python">{ "_id" : 1, "item" : "abc1", qty: 300 }
{ "_id" : 2, "item" : "abc2", qty: 200 }
{ "_id" : 3, "item" : "xyz1", qty: 250 }
</code></pre><p>
Установим </p><code>discount</code><p> равным </p><code>30</code><p>, если поле </p><code>qty</code><p> больше или равно </p><code>250</code><p>, иначе </p><code>discount</code><p> будет равен </p><code>20</code>
<pre><code class="python">db.test.aggregate( [ { 
      $project:{
             item: 1,
             discount: { $cond: { if: { $gte: [ "$qty", 250 ] }, then: 30, else: 20 } }
        }
} ] )
</code></pre><p>
Полученный результат:
</p><pre><code class="python">{ "_id" : 1, "item" : "abc1", "discount" : 30 }
{ "_id" : 2, "item" : "abc2", "discount" : 20 }
{ "_id" : 3, "item" : "xyz1", "discount" : 30 }
</code></pre>

<em><font>$ifNull </font><font> проверяет что поле существует и не равно null</font></em>
<p>
Если поля нет, то заменяет его нужным значением.
</p><pre><code class="python">{ "_id" : 1, "item" : "abc1", description: "product 1", qty: 300 }
{ "_id" : 2, "item" : "abc2", description: null, qty: 200 }
{ "_id" : 3, "item" : "xyz1", qty: 250 }
</code></pre><p>Возвращает </p><code>Unspecified</code><p> если поля </p><code>description</code><p> не существует или оно равно </p><code>null</code><p>.
</p><pre><code class="python">db.test.aggregate( [ {
         $project: { item: 1, description: { $ifNull: [ "$description", "Unspecified" ]}}
} ] )
</code></pre><p>Результат:
</p><pre><code class="python">{ "_id" : 1, "item" : "abc1", "description" : "product 1" }
{ "_id" : 2, "item" : "abc2", "description" : "Unspecified" }
{ "_id" : 3, "item" : "xyz1", "description" : "Unspecified" }
</code></pre>
<em><font>$let </font><font> создает переменные </font></em>
<p>
Оператор </p><code>$let</code><p> может создавать переменные и потом проводить с ними какие то операции. </p><p>
В примере создаем две переменные, </p><code>total</code><p> присваиваем значение сумы двух полей </p><code>price, tax</code><p>. А переменной </p><code>discounted</code><p> результат, который возвращает логический оператор </p><code>cond</code><p>. </p><p>
После этого перемножаем переменные </p><code>total</code><p> и </p><code>discounted</code><p> и возвращаем их произведение.

</p><pre><code class="python">{ _id: 1, price: 10, tax: 0.50, applyDiscount: true }
{ _id: 2, price: 10, tax: 0.25, applyDiscount: false }

db.test.aggregate( [ {
      $project: {
         finalTotal: {
            $let: {
               vars: {
                  total: { $add: [ '$price', '$tax' ] },
                  discounted: { $cond: { if: '$applyDiscount', then: 0.9, else: 1 } }
               },
               in: { $multiply: [ "$$total", "$$discounted" ] }
            }
         }
      }
}] )

{ "_id" : 1, "finalTotal" : 9.450000000000001 }
{ "_id" : 2, "finalTotal" : 10.25 }
</code></pre>
<em><font>$map </font><font> применяет определенное выражения к каждому элементу</font></em><p>
Применяет какое либо выражение к каждому элементу, в данном примере каждому элементу массива прибавляется </p><code>+2</code><p>.
</p><pre><code class="python">{ _id: 1, quizzes: [ 5, 6, 7 ] }
{ _id: 2, quizzes: [ ] }

db.grades.aggregate([{ 
     $project:{ 
          adjustedGrades: {$map: {input: "$quizzes", as: "grade", in: { $add: [ "$$grade", 2 ] } } }
      }
}])

{ "_id" : 1, "adjustedGrades" : [ 7, 8, 9 ] }
{ "_id" : 2, "adjustedGrades" : [ ] }
</code></pre>

<em><font>$setEquals </font><font> сравнивает массивы</font></em>
<p>
Сравнивает два и более массивов и возвращает </p><code>true</code><p> если они имеют похожие элементы.
</p><table>
<tr>
<td> Пример</td>
<td>Результат </td>
</tr>
<tr>
<td> { $setEquals: [ [ «a», «b», «a» ], [ «b», «a» ] ] }</td>
<td>true</td>
</tr>
<tr>
<td> { $setEquals: [ [ «a», «b» ], [ [ «a», «b» ] ] ] } </td>
<td>false</td>
</tr>
</table>
<em><font>$setIntersection </font><font> возвращает совпавшие элементы</font></em><p>
Принимает два или более массивов и возвращает массив, содержащий элементы, которые присутствуют в каждом из входных массивов. Если один из массивов пустой или содержит вложенные массивы, то возвращает пустой массив.
</p><table>
<tr>
<td> Пример</td>
<td>Результат </td>
</tr>
<tr>
<td> { $setIntersection: [ [ «a», «b», «a» ], [ «b», «a» ] ] }</td>
<td> [ «b», «a» ]</td>
</tr>
<tr>
<td>{ $setIntersection: [ [ «a», «b» ], [ [ «a», «b» ] ] ] } </td>
<td> [ ]</td>
</tr>
</table>
<em><font>$setUnion </font><font> возвращает элементы, присутствующие в любом из входных параметров.</font></em>
<p>
Принимает два или более массивов и возвращает массив, содержащий элементы, которые появляются в любом входном массиве.
</p><table>
<tr>
<td> Пример</td>
<td>Результат </td>
</tr>
<tr>
<td>{ $setUnion: [ [ «a», «b», «a» ], [ «b», «a» ] ] } </td>
<td> [ «b», «a» ]</td>
</tr>
<tr>
<td> { $setUnion: [ [ «a», «b» ], [ [ «a», «b» ] ] ] }</td>
<td>[ [ «a», «b» ], «b», «a» ] </td>
</tr>
</table>
<em><font>$setDifference </font><font> тоже что setUnion но наоборот </font></em>
<table>
<tr>
<td> Пример</td>
<td>Результат </td>
</tr>
<tr>
<td>{ $setDifference: [ [ «a», «b», «a» ], [ «b», «a» ] ] } </td>
<td>[ ]</td>
</tr>
<tr>
<td> { $setDifference: [ [ «a», «b» ], [ [ «a», «b» ] ] ] }</td>
<td>[ «a», «b» ] </td>
</tr>
</table>
<em><font>$setIsSubset </font><font> проверяет на подмножество</font></em><p>
 Принимает два массива и возвращает True, если первый массив подмножество второго, в том числе когда первый массив равен второму, и false если наоборот.
</p><table>
<tr>
<td> Пример</td>
<td>Результат </td>
</tr>
<tr>
<td> { $setIsSubset: [ [ «a», «b», «a» ], [ «b», «a» ] ] }</td>
<td>true </td>
</tr>
<tr>
<td> { $setIsSubset: [ [ «a», «b» ], [ [ «a», «b» ] ] ] }</td>
<td>false </td>
</tr>
</table>
<em><font>$anyElementTrue </font></em><p>
Оценивает массив в виде набора элементов и возвращает True, если любой из элементов True и false если наоборот. Пустой массив возвращает false. Принимает один аргумент.
</p><table>
<tr>
<td> Пример</td>
<td>Результат </td>
</tr>
<tr>
<td> { $anyElementTrue: [ [ true, false ] ] }</td>
<td> </td>
</tr>
<tr>
<td> { $anyElementTrue: [ [ [ false ] ] ] }</td>
<td> </td>
</tr>
<tr>
<td> { $anyElementTrue: [ [ null, false, 0 ] ] }</td>
<td> </td>
</tr>
<tr>
<td> { $anyElementTrue: [ [ ] ] }</td>
<td> </td>
</tr>
</table>
<em><font>$allElementsTrue </font></em><p>
Проверяет массив и возвращает True, если не один элемент массива не равен false. В противном случае, возвращает false. Пустой массив возвращает True.
</p><table>
<tr>
<td> Пример</td>
<td>Результат </td>
</tr>
<tr>
<td> { $allElementsTrue: [ [ true, 1, «someString» ] ] }</td>
<td> </td>
</tr>
<tr>
<td> { $allElementsTrue: [ [ [ false ] ] ] }</td>
<td> </td>
</tr>
<tr>
<td> { $allElementsTrue: [ [ ] ] }</td>
<td> </td>
</tr>
<tr>
<td> { $allElementsTrue: [ [ null, false, 0 ] ] }</td>
<td> </td>
</tr>
</table>
<em><font>$cmp </font><font> — сравнивает два элемента</font></em><p>
Сравнивает два элемента и возвращает:
</p><ul>
<li>-1, если первое значение меньше второго.</li>
<li> 1, если первое значение больше второго.</li>
<li> 0, если оба значения равны.</li>
</ul>
<pre><code class="python">{ "_id" : 1, "item" : "abc1", description: "product 1", qty: 300 }
{ "_id" : 2, "item" : "abc2", description: "product 2", qty: 200 }
{ "_id" : 3, "item" : "xyz1", description: "product 3", qty: 250 }
</code></pre><p>
C помощью </p><code>$cmp</code><p> сравниваем значение поля </p><code>qty</code><p> с </p><code>250</code><p>:

</p><pre><code class="python">db.test.aggregate( [ {
       $project:{ _id: 0, item: 1,qty: 1, cmpTo250: { $cmp: [ "$qty", 250 ] } }
} ] )
</code></pre><p>
Результат:
</p><pre><code class="python">{ "item" : "abc1", "qty" : 300, "cmpTo250" : 1 }
{ "item" : "abc2", "qty" : 200, "cmpTo250" : -1 }
{ "item" : "xyz1", "qty" : 250, "cmpTo250" : 0 }
</code></pre>

<em><font>$add </font><font> прибавляет</font></em>
<pre><code class="python">{ "_id" : 1, "item" : "abc", "price" : 10, "fee" : 2 }
{ "_id" : 2, "item" : "jkl", "price" : 20, "fee" : 1 }

db.test.aggregate([ { $project: { item: 1, total: { $add: [ "$price", "$fee" ] } } }  ])

{ "_id" : 1, "item" : "abc", "total" : 12 }
{ "_id" : 2, "item" : "jkl", "total" : 21 }
</code></pre>

<em><font>$subtract </font><font> вычитает</font></em><p>
Может возвращать разницу дат в милисекундах.
</p><pre><code class="python">{ "_id" : 1, "item" : "abc", "price" : 10, "fee" : 2, "discount" : 5 }
{ "_id" : 2, "item" : "jkl", "price" : 20, "fee" : 1, "discount" : 2 }

db.test.aggregate( [ { 
      $project: { item: 1, total: { $subtract: [ { $add: [ "$price", "$fee" ] }, "$discount" ] } } 
} ] )

{ "_id" : 1, "item" : "abc", "total" : 7 }
{ "_id" : 2, "item" : "jkl", "total" : 19 }
</code></pre>
<em><font>$multiply </font><font> умножает </font></em>

<pre><code class="python">{ "_id" : 1, "item" : "abc", "price" : 10, "quantity": 2 }
{ "_id" : 2, "item" : "jkl", "price" : 20, "quantity": 1  }

db.test.aggregate([ { $project: { item: 1, total: { $multiply: [ "$price", "$quantity" ] } } } ])

{ "_id" : 1, "item" : "abc", "total" : 20 }
{ "_id" : 2, "item" : "jkl",   "total" : 20 }
</code></pre>
<em><font>$divide </font><font> оператор деления </font></em>
<pre><code class="python">
{ "_id" : 1, "name" : "A", "hours" : 80, "resources" : 7 },
{ "_id" : 2, "name" : "B", "hours" : 40, "resources" : 4 }

db.test.aggregate([ { $project: { name: 1, workdays: { $divide: [ "$hours", 8 ] } } } ])

{ "_id" : 1, "name" : "A", "workdays" : 10 }
{ "_id" : 2, "name" : "B", "workdays" : 5 }
</code></pre>

<em><font>$concat </font><font> — конкатенация строк</font></em>
<pre><code class="python">{ "_id" : 1, "item" : "ABC1", quarter: "13Q1", "description" : "product 1" }

db.test.aggregate([ { $project: { itemDescription: { $concat: [ "$item", " - ", "$description" ] } } } ])

{ "_id" : 1, "itemDescription" : "ABC1 - product 1" }
</code></pre>
<em><font>$substr </font><font> возвращает подстроку </font></em>
<p>
Получает индекс начала и количество символов от начала. Индекс начинается с нуля.

</p><pre><code class="python">{ "_id" : 1, "item" : "ABC1", quarter: "13Q1", "description" : "product 1" }
{ "_id" : 2, "item" : "ABC2", quarter: "13Q4", "description" : "product 2" }
db.inventory.aggregate([{
    $project:{
        item: 1,
        yearSubstring: { $substr: [ "$quarter", 0, 2 ] },
        quarterSubtring: { $substr: [ "$quarter", 2, -1 ] }
     }
}])
{ "_id" : 1, "item" : "ABC1", "yearSubstring" : "13", "quarterSubtring" : "Q1" }
{ "_id" : 2, "item" : "ABC2", "yearSubstring" : "13", "quarterSubtring" : "Q4" }
</code></pre>

<em><font>$toLower </font><font> — преобразует в нижний регистр </font></em>
<pre><code class="python">{ "_id" : 1, "item" : "ABC1", quarter: "13Q1", "description" : "PRODUCT 1" }

db.test.aggregate([{
    $project:{  item: { $toLower: "$item" }, description: { $toLower: "$description" }}
}])

{ "_id" : 1, "item" : "abc1", "description" : "product 1" }
</code></pre>
<em><font>$toUpper </font><font> преобразует в верхний регистр</font></em>

<pre><code class="python">{ "_id" : 2, "item" : "abc2", quarter: "13Q4", "description" : "Product 2" }

db.inventory.aggregate( [ {
       $project:{ item: { $toUpper: "$item" }, description: { $toUpper: "$description" } }
} ] )

{ "_id" : 2, "item" : "ABC2", "description" : "PRODUCT 2" }
</code></pre>

<em><font>$strcasecmp </font><font> сравнивает строки </font></em><p>
Сравнивает две строки и возвращает:
</p><ul>
<li> 1, если первая строка “больше” второй строки.</li>
<li> 0, если две строки равны.</li>
<li>-1, если первая строка “меньше” второй строки.</li>
</ul><p>
Оператор не чувствителен к регистру.
</p><pre><code class="python">{ "_id" : 1, "item" : "ABC1", quarter: "13Q1", "description" : "product 1" }
{ "_id" : 2, "item" : "ABC2", quarter: "13Q4", "description" : "product 2" }
{ "_id" : 3, "item" : "XYZ1", quarter: "14Q2", "description" : null }

db.inventory.aggregate([{
       $project:{ item: 1, comparisonResult: { $strcasecmp: [ "$quarter", "13q4" ] } }
}])

{ "_id" : 1, "item" : "ABC1", "comparisonResult" : -1 }
{ "_id" : 2, "item" : "ABC2", "comparisonResult" : 0 }
{ "_id" : 3, "item" : "XYZ1", "comparisonResult" : 1 }
</code></pre>

<h5>Работа с датами</h5>
<em><font>$dayOfYear </font><font> день в году по счету</font></em>
<em><font>$dayOfMonth </font><font> день в месяце по счету</font></em>
<em><font>$dayOfWeek </font><font> возвращает день недели по счету, 1 (суббота) — 7 (воскресенье).</font></em>
<em><font>$year </font><font> возвращает год </font></em>
<em><font>$month </font><font> возвращает месяц по счету</font></em>
<em><font>$week </font><font> возвращает номер недели в году как число от 0 до 53</font></em>
<em><font>$hour </font><font> возвращает час как число между 0 и 23</font></em>
<em><font>$minute </font><font> возвращает минуту как число между 0 и 59</font></em>
<em><font>$second </font><font> возвращает секунды как число между 0 и 23</font></em>
<em><font>$millisecond </font><font> возвращает милисекунды как число между 0 и 999</font></em>
<p>
Возвращает день года для даты в виде числа между 1 и 366.</p><p>
Например для 1 января вернет 1.
</p><pre><code class="python">{ "_id": 1, "item": "abc", "date" : ISODate("2014-01-01T08:15:39.736Z") }
db.sales.aggregate( [ {
    $project: {
           year: { $year: "$date" },
           month: { $month: "$date" }, 
           day: { $dayOfMonth: "$date" },
           hour: { $hour: "$date" },
           minutes: { $minute: "$date" },
           seconds: { $second: "$date" },
           milliseconds: { $millisecond: "$date" },
           dayOfYear: { $dayOfYear: "$date" },
           dayOfWeek: { $dayOfWeek: "$date" },
           week: { $week: "$date" }
      }
} ] )

{
  "_id" : 1, 
  "year" : 2014, 
  "month" : 1, 
  "day" : 1,
  "hour" : 8,
  "minutes" : 15,
  "seconds" : 39,
  "milliseconds" : 736,
  "dayOfYear" : 1,
  "dayOfWeek" : 4,
  "week" : 0
}
</code></pre>

<em><font>$dateToString </font><font> преобразует в строку</font></em>
<p>
Преобразует объект date в строку в соответствии с заданным форматом.
</p><pre><code class="python">{
  "_id" : 1,
  "item" : "abc",
  "price" : 10,
  "quantity" : 2,
  "date" : ISODate("2014-01-01T08:15:39.736Z")
}
db.test.aggregate( [ {
       $project: {
          yearMonthDay: { $dateToString: { format: "%Y-%m-%d", date: "$date" } },
          time: { $dateToString: { format: "%H:%M:%S:%L", date: "$date" } }
       }
} ] )
{ "_id" : 1, "yearMonthDay" : "2014-01-01", "time" : "08:15:39:736" }
</code></pre>

<h3><a name="2"/> <font> Каталог продуктов</font></h3><p>
Эта глава описывает основные принципы проектирования каталога товаров в системе электронной коммерции, с использованием </p><code>MongoDB</code><p>.
</p><p>
Каталог товаров должен уметь хранить различные виды объектов, у каждого из которых должен быть свой список характеристик.</p><p>
Для реляционных баз данных существуют несколько решений подобных задач, отличающихся в том числе по производительности. Мы рассмотрим некоторые из этих вариантов, а затем посмотрим как это будет решаться в </p><code>MongoDB</code><p>.

</p><h4><font>SQL и реляционная модель данных</font></h4>
<em><font>Concrete Table Inheritance (Наследование с таблицами конечных классов)</font></em><p>
Первый вариант в реляционной модели — это создание своей таблицы для каждой категории товаров:

</p><pre><code class="sql">CREATE TABLE `product_audio_album` (
    `sku` char(8) NOT NULL,
    ...
    `artist` varchar(255) DEFAULT NULL,
    `genre_0` varchar(255) DEFAULT NULL,
    `genre_1` varchar(255) DEFAULT NULL,
    ...,
    PRIMARY KEY(`sku`))
...
CREATE TABLE `product_film` (
    `sku` char(8) NOT NULL,
    ...
    `title` varchar(255) DEFAULT NULL,
    `rating` char(8) DEFAULT NULL,
    ...,
    PRIMARY KEY(`sku`))
...
</code></pre><p>
У этого подходя есть два основных ограничения связанных с гибкостью.
</p><ul>
<li>Собственно создание каждый раз новой таблицы для каждой новой категории продуктов.</li>
<li>Явная адаптация запросов для конкретного типа продуктов.</li>
</ul>

<em><font>Single Table Inheritance (Наследование с единой таблицей)</font></em>
<p>
Второй вариант в реляционной модели состоит в использовании одной таблицы для всех категорий товаров. И добавляя новые колонки в любое время нужно сохранять данные о типах товаров:

</p><pre><code class="sql">CREATE TABLE `product` (
    `sku` char(8) NOT NULL,
    ...
    `artist` varchar(255) DEFAULT NULL,
    `genre_0` varchar(255) DEFAULT NULL,
    `genre_1` varchar(255) DEFAULT NULL,
    ...
    `title` varchar(255) DEFAULT NULL,
    `rating` char(8) DEFAULT NULL,
    ...,
    PRIMARY KEY(`sku`))
</code></pre><p>
Этот подход является более гибким и он позволяет делать одиночные запросы с учетом различных типов продуктов.

</p><em><font>Multiple Table Inheritance (множественное наследование таблиц)</font></em>
<p>
Также в реляционной модели можно использовать «множественное наследование таблиц», паттерн, при котором общие для всех категорий товаров атрибуты, находятся в основной таблице </p><code>product</code><p> и в отдельных таблицах (для каждой категории своя) будут содержаться различающиеся атрибуты.
</p><p>
Рассмотрим следующий </p><code>SQL</code><p> пример:
</p><pre><code class="sql">CREATE TABLE `product` (
    `sku` char(8) NOT NULL,
    `title` varchar(255) DEFAULT NULL,
    `description` varchar(255) DEFAULT NULL,
    `price`, ...
    PRIMARY KEY(`sku`))

CREATE TABLE `product_audio_album` (
    `sku` char(8) NOT NULL,
    ...
    `artist` varchar(255) DEFAULT NULL,
    `genre_0` varchar(255) DEFAULT NULL,
    `genre_1` varchar(255) DEFAULT NULL,
    ...,
    PRIMARY KEY(`sku`),
    FOREIGN KEY(`sku`) REFERENCES `product`(`sku`))
...
CREATE TABLE `product_film` (
    `sku` char(8) NOT NULL,
    ...
    `title` varchar(255) DEFAULT NULL,
    `rating` char(8) DEFAULT NULL,
    ...,
    PRIMARY KEY(`sku`),
    FOREIGN KEY(`sku`) REFERENCES `product`(`sku`))
...
</code></pre><p>
Этот вариант является более эффективным чем наследование одной таблицы и чуть более гибким чем создание таблицы для каждой категории. Этот вариант требует применения «дорогостоящего» </p><code>JOIN</code><p> для получения всех атрибутов относящихся к конкретному товару.

</p><em><font>Значения атрибутов для каждой сущности</font></em>
<p>
И последний паттерн в реляционной модели — это схема </p><code>entity-attribute-value</code><p>. В соответствии с этой схемой у нас будет таблица с тремя столбцами например </p><code>entity_id</code><p>, </p><code>attribute_id</code><p>, </p><code>value</code><p> с помощью которых будет описываться каждый продукт.
</p><p>
Рассмотрим пример с хранением аудио записей:
</p><table>
<tr>
<td>Entity</td>
<td>Attribute</td>
<td>Value</td>
</tr>
<tr>
<td>sku_00e8da9b</td>
<td>type</td>
<td>Audio Album</td>
</tr>
<tr>
<td>sku_00e8da9b</td>
<td>title</td>
<td>A Love Supreme</td>
</tr>
<tr>
<td>sku_00e8da9b</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>sku_00e8da9b</td>
<td>artist</td>
<td>John Coltrane</td>
</tr>
<tr>
<td>sku_00e8da9b</td>
<td>genre</td>
<td>Jazz</td>
</tr>
<tr>
<td>sku_00e8da9b</td>
<td>genre</td>
<td>General</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</table>

<p>
Эта схема достаточно гибкая:
</p><p>
Любой товар может иметь любой набор атрибутов. Новые категории продуктов не требуют внесения изменений в базу.
</p><p>
Недостатком этого варианта является то, что потребуются много запросов, содержащих </p><code>JOIN</code><p>, что в свою очередь не очень хорошо для производительности.
</p><p>
Кроме того, некоторые решения для </p><code>e-commerce</code><p> с реляционными системами баз данных сериализуют эти данные в колонке BLOB. И атрибуты товаров становятся труднодоступными для поиска и сортировки.
 
</p><h4><font>Не реляционная модель данных</font></h4><p>
Поскольку </p><code>mongodb</code><p> не являет реляционной базой данных, то для создания каталога продукции у нас появляются дополнительные возможности в плане гибкости.
</p><p>
Самый лучший вариант — использовать одну коллекцию для хранения всех видов документов. И поскольку для каждого документа схема может быть любой, то можно хранить все имеющиеся у товара характеристики (атрибуты) в одном документе.
</p><p>
В корне документа должна находится общая информация о продукте, чтобы облегчить поиск по всему каталогу. А уже в субдокументах должны находиться поля, которые у каждого документа уникальны. Рассмотрим пример:

</p><pre><code class="python">{
  sku: "00e8da9b",
  type: "Audio Album",
  title: "A Love Supreme",
  description: "by John Coltrane",
  asin: "B0000A118M",

  shipping: {
    weight: 6,
    dimensions: {
      width: 10,
      height: 10,
      depth: 1
    },
  },

  pricing: {
    list: 1200,
    retail: 1100,
    savings: 100,
    pct_savings: 8
  },

  details: {
    title: "A Love Supreme [Original Recording Reissued]",
    artist: "John Coltrane",
    genre: [ "Jazz", "General" ],
        ...
    tracks: [
      "A Love Supreme Part I: Acknowledgement",
      "A Love Supreme Part II - Resolution",
      "A Love Supreme, Part III: Pursuance",
      "A Love Supreme, Part IV-Psalm"
    ],
  },
}
</code></pre>
<p>
Для документов в которых хранится информация о фильмах </p><code> { type: "Film" }</code><p> Основные поля цена, доставка и т.д. остаются такими же. А вот содержание субдокумента будет отличатся. Например:

</p><pre><code class="python">{
  sku: "00e8da9d",
  type: "Film",
  ...,
  asin: "B000P0J0AQ",

  shipping: { ... },

  pricing: { ... },

  details: {
    title: "The Matrix",
    director: [ "Andy Wachowski", "Larry Wachowski" ],
    writer: [ "Andy Wachowski", "Larry Wachowski" ],
    ...,
    aspect_ratio: "1.66:1"
  },
}
</code></pre>
<p>
В большинстве случаев основные операции для каталога товаров — это поиск. Ниже мы увидим различные типы запросов, которые могут пригодиться. Все примеры будут на </p><code>Python/PyMongo</code><p>.

</p><em><font>Найти альбомы по жанру и отсортировать по году выпуска</font></em><p>
Этот запрос возвращает документы с товарами соотвествующими конкретному жанру и отсортированные в обратном хронологическом порядке:
</p><pre><code class="python">query = db.products.find({'type':'Audio Album',  'details.genre': 'jazz'}).sort([('details.issue_date', -1)])
</code></pre><p>
Для этого запроса необходим индекс, для полей, используемых в запросе и в сортировке:
</p><pre><code class="python">db.products.ensure_index([ ('type', 1), ('details.genre', 1), ('details.issue_date', -1)])
</code></pre>

<em><font>Найти товары, отсортированные по проценту скидки в порядке убывания.</font></em><p>
В то время как большинство запросов будет для определённого типа продукта (например альбомы, фильмы и т.д.), часто нам может понадобится вернуть все товары в определенном ценовом диапазоне.
</p><p>
Найдем товары у которых хорошая скидка, для поиска будем использовать поле с ценами, которое есть во всех документах.

</p><pre><code class="python">query = db.products.find( { 'pricing.pct_savings': {'$gt': 25 }).sort([('pricing.pct_savings', -1)])
</code></pre><p>
Для этого запроса создадим индекс по полю </p><code>pricing.pct_savings</code><p>:

</p><pre><code class="python">db.products.ensure_index('pricing.pct_savings')
</code></pre>
<code>MongoDB</code><p> может прочитать индексы как в порядке возрастания так и убывания.

</p><em><font>Найти все фильмы в которых играли известные актеры</font></em><p>
Находим документы у которых тип документа </p><code>"Film"</code><p> и в атрибутах документа есть значение </p><code>{ 'actor': 'Keanu Reeves' }</code><p>. Результат отсортируем по дате в порядке убывания.

</p><pre><code class="python">query = db.products.find({'type': 'Film', 'details.actor': 'Keanu Reeves'}).sort([('details.issue_date', -1)])
</code></pre><p>
Для этого запроса создадим следующий индекс:

</p><pre><code class="python">db.products.ensure_index([ ('type', 1), ('details.actor', 1), ('details.issue_date', -1)])
</code></pre><p>
Индекс начинается с поля </p><code>type</code><p> которое есть во всех документах и дальше уже идет по полю </p><code>details.actor</code><p> этим мы как бы сужаем область поиска. Таким образом, индекс будет максимально эффективен.

</p><em><font>Найдем все фильмы у которых есть определённое слово в названии</font></em>
<p>
Для того, чтобы выполнить запрос поиска по словам независимо от типа базы данных, база должна будет просканировать какую-то часть документов, чтоб получить результат.

</p><code>Mongodb</code><p> поддерживает в запросах регулярные выражения. В Python можно использовать модуль </p><code>re</code><p> для конструирования регулярных выражений.
</p><pre><code class="python">import re
re_hacker = re.compile(r'.*hacker.*', re.IGNORECASE)

query = db.products.find({'type': 'Film', 'title': re_hacker}).sort([('details.issue_date', -1)])
</code></pre>
<p>
Mongodb предоставляет специальный синтаксис для регулярных выражений, поэтому для запросов можно обходится без модуля </p><code>re</code><p>. Рассмотрим следующий пример, альтернативный предыдущему.

</p><pre><code class="python">query = db.products.find({ 'type': 'Film', 'title': {'$regex': '.*hacker.*', '$options':'i'}}).sort([('details.issue_date', -1)])
</code></pre>
<code>$options</code><p> специальный оператор, в данном случае он указывает, что искомое слово не зависит от регистра.
</p><p>
Создадим индекс:

</p><pre><code class="python">db.products.ensure_index([ ('type', 1), ('details.issue_date', -1), ('title', 1) ])
</code></pre><p>
Этот индекс позволяет избежать сканирования целых документов, благодаря индексу сканироваться будет только поле </p><code>title</code><p>.

</p><h4>Масштабирование ( Sharding ) </h4>
<p>
Производительность базы данных при масштабировании зависит от индексов. Можно использовать шардинг для повышения производительности, тогда большие индексы будут влезать в оперативную память.</p><p>
В конфигурации шардов выбираем </p><code>shard key</code><p>, это позволит </p><code>mongos</code><p> маршрутизировать запросы непосредственно нужного нам шарда или небольшой группы шардов.
</p><p>
Поскольку в большинстве запросов присутствует поле </p><code>type</code><p>, его можно включить в </p><code>shard key</code><p>. Для остальной части </p><code>shard key</code><p> нужно учитывать:
</p><ul>
<li><code>details.issue_date </code> мы не будем включать в <code>shard key</code>, потому что это поле не присутствует в запросах а только в сортировке.</li>
<li>Нужно включить одно или несколько полей которые содержатся в <code>detail</code> и являются часто запрашиваемыми.</li>
</ul>
<p>
В следующем примере предположим что поле </p><code> details.genre </code><p> является вторым по важности полем после </p><code>type</code><p>. Инициализируем шардирование с помощью </p><code> Python/PyMongo</code>
<pre><code class="python">&gt;&gt;&gt; db.command('shardCollection', 'product', {  key : { 'type': 1, 'details.genre' : 1, 'sku':1 } } )
{ "collectionsharded" : "details.genre", "ok" : 1 }
</code></pre><p>
Даже если мы составим неудачный </p><code>shard key</code><p>, то все равно от шардинга будет польза:
</p><ol>
<li>Шардинг даст большой объем оперативной памяти, доступный для хранения индексов.</li>
<li><code>MongoDB</code> будет распараллеливать запросы по шардам, уменьшая задержку.</li>
</ol>

<h5>Чтение</h5><p>
Хотя шардинг это хороший способ масштабирования, некоторые наборы данных невозможно разделить таким образом, чтобы </p><code>mongos</code><p> направлял запросы к нужным шардам.</p><p>
В таком случае </p><code>mongos</code><p> отправляет запросы сразу ко всем шардам, а затем с полученным результатом уже возвращается к клиенту.</p><p>
Мы можем немного увеличить производительность за счет того, что явно укажем с какого шарда предпочтительнее читать.
</p><p>
Свойство </p><code>SECONDARY</code><p> в следующем примере, позволяет читать из вторичного узла (а также первичного) для всего соединения.
</p><pre><code class="python">conn = pymongo.MongoClient(read_preference=pymongo.SECONDARY)
</code></pre>
<code>SECONDARY_ONLY</code><p> означает что клиент будет читать только из вторичного члена.
</p><pre><code class="python">conn = pymongo.MongoClient(read_preference=pymongo.SECONDARY_ONLY)
</code></pre><p>
Можно также указать </p><code>read_preference</code><p> для конкретных запросов, например:
</p><pre><code class="python">results = db.product.find(..., read_preference=pymongo.SECONDARY)
</code></pre><p>
или
</p><pre><code class="python">results = db.product.find(..., read_preference=pymongo.SECONDARY_ONLY)
</code></pre>

<h3><a name="3"/> <font> Корзина и управления остатками на складе</font></h3>
<p>
Пользователи интернет-магазинов регулярно добавляют и удаляют элементы из своей «корзины», и поэтому количество товара на складе может постоянно меняться в течении покупки несколько раз, к тому же пользователь магазина может отказаться от покупок в любой момент, а иногда могут возникнуть другие непредвиденные проблемы для решения которых потребуется отменить заказ.
 </p><p>
Все это может немного затруднять учет наличествующих на складе товаров, и нам нужно убедиться что пользователи не смогут «купить» те товары которых уже зарезервированы.
</p><p>
Поэтому у корзины будет время в течении которого, если она была неактивна, то зарезервированные товары снова станут доступны всем остальным и корзина будет очищена. 

</p><img src="https://habrastorage.org/getpro/habr/post_images/dc4/4c7/77a/dc44c777a24dc25eb4dbff115df2e865.png"/>
<p>
В коллекцию </p><code>Inventory</code><p> должны сохранятся документы, содержащие текущее количество запасов по каждой единицы складского учета ( </p><a href="https://ru.wikipedia.org/wiki/SKU">SKU</a><p>; или item), а также список корзин с количеством товаров в каждой. Тогда мы можем вернуть доступные остатки, если они находились в корзине, но клиент не пользовался корзиной какое-то время.
</p><p>
В следующем примере </p><code>_id</code><p> поле хранящее </p><a href="https://ru.wikipedia.org/wiki/SKU">SKU</a>

<pre><code class="python"># В этом документе содержится _id:SKU,  также мы видим, что количество товаров в наличии 16 штук, 1 шт. в            # корзине с id 42, и 2 шт. в корзине c id 43. Это оставляет в общей сложности 19 не проданных единиц товара.
{
    _id: '00e8da9b',
    qty: 16,
    carted: [
        { qty: 1, cart_id: 42, timestamp: ISODate("2012-03-09T20:55:36Z") },
        { qty: 2, cart_id: 43, timestamp: ISODate("2012-03-09T21:55:36Z") },
    ]
}
</code></pre>
<i>В данном примере используется простая схема, в продакшене мы можем объединить эту схему с каталогом товаров описанным во второй главе.</i>
<p>
Для нормального моделирования корзины мы нуждаемся в </p><a href="https://ru.wikipedia.org/wiki/SKU">SKU</a><p>, </p><code>quantity</code><p> полях, а также в каких то уточняющих полях, находящихся в </p><code>item_details</code>
<pre><code class="python"># Поле item_details в каждом документе позволяет приложению отображать детали содержимого корзины 
# пользователя, не делая второй запрос для выборки этих деталей из каталога товаров.
{
    _id: 42,
    last_modified: ISODate("2012-03-09T20:55:36Z"),
    status: 'active',
    items: [
        { sku: '00e8da9b', qty: 1, item_details: {...} },
        { sku: '0ab42f88', qty: 4, item_details: {...} }
    ]
}
</code></pre>

<h4>Операции<h4><em><font>Добавление элемента в корзину</font></em><br/>
<br/>
Основным моментом в работе с корзиной является перемещение товара из имеющихся запасов на складе в корзину.<br/>
Важно не поместить в корзину уже зарезервированный товар. Реализуем это с помощью функции <code>add_item_to_cart</code>.<br/>
<br/>
<pre><code class="python">def add_item_to_cart(cart_id, sku, qty, details):
    now = datetime.utcnow()

    # Убедимся, что корзина по прежнему активна и добавим товар
    result = db.cart.update( 
       {'_id': cart_id, 'status': 'active' }, 
       {'$set': {'last_modified':now}, '$push': {'items': {'sku':sku, 'qty':qty, 'details':details}}}, 
       w=1
     )
    if not result['updatedExisting']:
        raise CartInactive()

    # Обновляем остатки
    result = db.inventory.update(
        {'_id':sku, 'qty': {'$gte': qty}},
        {'$inc': {'qty':-qty}, '$push': {'carted': {'qty':qty, 'cart_id':cart_id, 'timestamp':now}}}, 
        w=1
    )
    if not result['updatedExisting']:
        # Если обновить остатки не получилось, то откатываем состояние корзины, удаляем из нее товар.
        db.cart.update( {'_id': cart_id }, { '$pull': { 'items': {'sku': sku } } })
        raise InadequateInventory()
</code></pre><br/>
<i>Для этой функции не будет индексов, поскольку на поле <code>_id</code> индекс устанавливается автоматически.</i><br/>
Первая операция в этой функции — это проверка, что корзина активна и только после этого туда добавляется товар. Тогда мы проверяем доступность нужного количества остатков на складе и если да, то уменьшаем их.<br/>
Если же на складе нет нужного количества товаров то обновляем корзину, удаляя из неё товар.<br/>
<br/>
<em><font>Изменение количества в корзине</font></em><br/>
<br/>
Приложение должно проверять, что когда пользователь увеличивает количество товаров в корзине, они есть в наличии на складе.<br/>
<pre><code class="python">
def update_quantity(cart_id, sku, old_qty, new_qty):
    # индекс не нужен так как для поля _id создается по умолчанию.
    now = datetime.utcnow()
    delta_qty = new_qty - old_qty

    # Убедимся, что корзина по прежнему активна и после этого добавляем товарную позицию.
    result = db.cart.update( 
        {'_id': cart_id, 'status': 'active', 'items.sku': sku }, 
        {'$set': { 'last_modified': now, 'items.$.qty': new_qty } },  
        w=1
    )
    if not result['updatedExisting']:
        raise CartInactive()

    # Обновление остатков
    result = db.inventory.update(
        {'_id':sku, 'carted.cart_id': cart_id, 'qty': {'$gte': delta_qty} }, 
        {'$inc': {'qty': -delta_qty },'$set': { 'carted.$.qty': new_qty, 'timestamp': now } }, 
        w=1
    )
    if not result['updatedExisting']:
        # Если обновление остатков не произошло то возвращаем старое количество товаров
        db.cart.update( {'_id': cart_id, 'items.sku': sku }, {'$set': { 'items.$.qty': old_qty } } )
        raise InadequateInventory()
</code></pre><br/>
<br/>
<em><font>Окончание сделки</font></em><br/>
<br/>
В конце нужно проверить способ оплаты и, если оплата прошла, успешно очистить корзину.<br/>
<pre><code class="python">def checkout(cart_id):
    now = datetime.utcnow()

    # Проверяем что состояние корзины &lt;code&gt;active&lt;/code&gt; и устанавливаем состояние &lt;code&gt;pending&lt;/code&gt;. 
    # также получаем детали корзины чтобы мы могли сформировать окончательный чек
    cart = db.cart.find_and_modify(
         {'_id': cart_id, 'status': 'active' }, 
         update={'$set': { 'status': 'pending','last_modified': now } }
     )
    if cart is None:
        raise CartInactive()

    # Проверяем детали оплаты; коллекция payment
    try:
        collect_payment(cart)
        db.cart.update( {'_id': cart_id }, {'$set': { 'status': 'complete' } } )
        db.inventory.update( {'carted.cart_id': cart_id}, {'$pull': {'cart_id': cart_id} }, multi=True)
    except:
        db.cart.update( {'_id': cart_id }, {'$set': { 'status': 'active' } } )
        raise 
</code></pre><br/>
Начинаем с блокирования корзины, установив состояние <code>pending</code>. Тогда система обновит корзину и автоматически вернет детали, содержащие платежную информацию.<br/>
<ul>
<li>Если оплата прошла успешно, то приложение удалит <code>cart_id</code> из документов в коллекции <code>inventory</code>. И установит состояние корзины <code>complete</code>.</li>
<li>Если платеж был отклонен, приложение разблокирует корзину, установив его статус на активный и сообщит об ошибке оплаты.</li>
</ul><br/>
<br/>
<em><font>Возвращение товаров на склад.</font></em><br/>
Периодически приложение должно обнулять неактивные корзины и возвращать товары обратно на склад.<br/>
Переменная <code>timeout</code> содержит в себе время истечения активности корзины.<br/>
<pre><code class="python">def expire_carts(timeout):
    now = datetime.utcnow()
    threshold = now - timedelta(seconds=timeout)
    # Блокирование и нахождение всех бездействующих корзин
    db.cart.update(
         {'status': 'active', 'last_modified': { '$lt': threshold } }, 
         {'$set': { 'status': 'expiring' } }, 
         multi=True 
    )
    # Идем по бездействующим корзинам
    for cart in db.cart.find({'status': 'expiring'}):
        # Возвращаем все товары на склад
        for item in cart['items']:
            db.inventory.update(
                { '_id': item['sku'],  'carted.cart_id': cart['id'], 'carted.qty': item['qty'] },
                {'$inc': { 'qty': item['qty'] }, '$pull': { 'carted': { 'cart_id': cart['id'] } } }
             )
        db.cart.update( {'_id': cart['id'] }, {'$set': { 'status': 'expired' })
</code></pre><br/>
<br/>
Эта функция:<br/>
<ul>
<li>Находит все корзины, которые старше заданного времени.</li>
<li>Для каждой неактивной корзины, все товары возвращает в доступные остатки на складе.</li>
<li>Как только все товары будут возвращены на склад, установим состояние корзины <code>expired</code>.</li>
</ul><br/>
<br/>
Создадим индекс содержащий поля <code>status</code> и <code>last_modified</code>.<br/>
<pre><code class="python">db.cart.ensure_index([('status', 1), ('last_modified', 1)])
</code></pre><br/>
<br/>
<em><font>Обработка ошибок.</font></em><br/>
Вышеописанные операции не учитывают одну возможную проблему: если исключение произойдет после обновления корзины, но перед обновлением документов в коллекции <code>inventory</code>, то в результате это может привести к тому, что время корзины уже истекло, а товары не возвратились на склад.<br/>
<br/>
Чтоб учесть этот случай, приложение нуждается в периодической очистке найденных в <code>inventory</code> товаров которые имеют <code>carted</code> и не забыть проверить что они точно есть в корзине и сделать их доступными на складе.<br/>
<br/>
<pre><code class="python">def cleanup_inventory(timeout):
    now = datetime.utcnow()
    threshold = now - timedelta(seconds=timeout)

    # Находим все элементы с истекшим сроком
    for item in db.inventory.find( {'carted.timestamp': {'$lt': threshold }}):
        carted = dict(
            (carted_item['cart_id'], carted_item) for carted_item in item['carted'] if carted_item['timestamp'] &lt; threshold
         )
        # Первый проход: Находим любые активные корзины и обновим carted, которые находятся в коллекции inventory    
        for cart in db.cart.find( { '_id': {'$in': carted.keys() }, 'status':'active'}):
            cart = carted[cart['_id']]
            db.inventory.update(
                {'_id': item['_id'], 'carted.cart_id':cart['_id'] }, 
                { '$set': {'carted.$.timestamp':now }}
            )
            del carted[cart['_id']]

        # Второй проход: Все carted присуствующие в словаре должны быть возвращены на склад.
        for cart_id, carted_item in carted.items():
            db.inventory.update(
                { '_id': item['_id'], 'carted.cart_id': cart_id,  'carted.qty': carted_item['qty'] },
                { '$inc': { 'qty': carted_item['qty'] }, '$pull': { 'carted': { 'cart_id': cart_id } } }
            )
</code></pre><br/>
<br/>
В итоге эта функция находит все «carted» элементы, которые имеют временные метки старше, чем константа <code>timeout</code>. И затем два раза проходим по этим пунктам:<br/>
<ul>
<li>Из элементов с метками времени старше <code>timeout</code>, если корзина по-прежнему активна, сбрасываем время.</li>
<li>И товары, которые которые остаются в неактивной корзине, функция возвращает на склад.</li>
</ul><br/>
<br/>
<em><font>Шардинг</font></em><br/>
Если мы решим шардировать эту систему, то идеальным вариантом для <code>shard key</code> будет <code>_id</code>, потому что большинство операций обновления используют поле <code>_id</code>.<br/>
Это позволит <code> mongos</code> маршрутизировать все обновления которые выбраны по <code> _id</code> в одном процессе <code>mongod</code>.<br/>
<br/>
Но есть два недостатка в использовании <code> _id</code> в качестве <code>shard key</code>.<br/>
<br/>
Если <code>_id</code> в коллекции <code>cart</code> будет инкрементом, то все новые документы будут на одном шарде.<br/>
<br/>
Мы можем уменьшить этот эффект, выбирая случайное значение после создания корзины, такие как хэш (например MD5 или SHA-1) из идентификатора ObjectID, как _id.<br/>
Этот процесс показан ниже:<br/>
<br/>
<pre><code class="python">import hashlib
import bson

cart_id = bson.ObjectId()
cart_id_hash = hashlib.md5(str(cart_id)).hexdigest()

cart = { "_id": cart_id, "cart_hash": cart_id_hash }
db.cart.insert(cart)
</code></pre><br/>
Время истечения корзины и регулирование операций, требующих обновления и широковещательных запросов ко всем шардам, используют <code> _id</code> в качестве <code>shard key</code>.<br/>
<br/>
Это может быть не очень актуальным, истечение функции запуска относительно нечасто, и их можно искусственно замедлить (умеренно используя функции <code>Sleep ()</code>), чтобы минимизировать нагрузку на сервер. <br/>
<br/>
Для шардинга с помощью Python/PyMongo используем следующие команды:<br/>
<pre><code class="python">&gt;&gt;&gt; db.command('shardCollection', 'inventory',  'key': { '_id': 1 } )
{ "collectionsharded" : "inventory", "ok" : 1 }
&gt;&gt;&gt; db.command('shardCollection', 'cart',   'key': { '_id': 1 } )
{ "collectionsharded" : "cart", "ok" : 1 }
</code></pre><br/>
<br/>
<h3><a name="4"/> <font> Иерархия категорий</font></h3><br/>
<br/>
Будем моделировать дерево категорий с товарами. Каждая категория будет сохранятся в своём документе у которого будет список предков или список родителей.<br/>
Для примера будем использовать список жанров:<br/>
<br/>
<img src="http://docs.mongodb.org/ecosystem/_images/use-cases-category1.png"/><br/>
Поскольку эти виды категорий изменяются не часто, наше моделирование будет фокусироваться на операциях необходимых для поддержания иерархии, а не производительности операций обновления.<br/>
<br/>
Эта схема имеет следующие свойства:<br/>
<ul>
<li>Каждую категорию в дереве представляет один документ</li>
<li><code>Objectid</code> идентифицирует каждый документ категории для внутренних перекрестных ссылок.</li>
<li>Каждый документ с категорией имеет удобочитаемое имя и поле с нормальным URL-адресом.</li>
<li>Схема хранит список предков для каждой категории, чтобы упростить получение всех предков используя только один запрос.</li>
</ul><br/>
<br/>
Рассмотрим следующий прототип:<br/>
<pre><code class="python">{ "_id" : ObjectId("4f5ec858eb03303a11000002"),
  "name" : "Modal Jazz",
  "parent" : ObjectId("4f5ec858eb03303a11000001"),
  "slug" : "modal-jazz",
  "ancestors" : [
         { "_id" : ObjectId("4f5ec858eb03303a11000001"), "slug" : "bop",  "name" : "Bop" },
         { "_id" : ObjectId("4f5ec858eb03303a11000000"), "slug" : "ragtime", "name" : "Ragtime" } 
     ]
}
</code></pre><br/>
<br/>
В этом разделе будут описываться операции манипуляции с деревом категорий, которые могут понадобится в E-Commerce решениях. Все примеры будут использовать <code>Python/PyMongo</code><br/>
<br/>
<em><font>Чтение и показ категорий</font></em><br/>
Запрос.<br/>
Используем следующие опции для чтения и показа дерева категорий. В этом запросе будем использовать поле <code>slug</code> и возвращать информацию о категории <code>“bread crumb”</code><br/>
<br/>
<pre><code class="python">category = db.categories.find({'slug':slug}, {'_id':0, 'name':1, 'ancestors.slug':1, 'ancestors.name':1 })
</code></pre><br/>
Создадим уникальный индекс по полю <code>slug</code>.<br/>
<br/>
<pre><code class="python">&gt;&gt;&gt; db.categories.ensure_index('slug', unique=True)
</code></pre><br/>
<em><font>Добавление категории</font></em><br/>
Чтобы добавить категорию, необходимо сначала определить её предков. Добавим новую категорию -<code>Swing</code> в виде потомка категории <code>Ragtime</code>, как показано на схеме:<br/>
<img src="http://docs.mongodb.org/ecosystem/_images/use-cases-category2.png"/><br/>
<br/>
Операция добавления категории довольно проста, за исключением предков. Чтобы добавить предков в массив, рассмотрим следующую функцию:<br/>
<br/>
<pre><code class="python">def build_ancestors(_id, parent_id):
    parent = db.categories.find_one({'_id': parent_id}, {'name': 1, 'slug': 1, 'ancestors':1})
    parent_ancestors = parent.pop('ancestors')
    ancestors = [ parent ] + parent_ancestors
    db.categories.update({'_id': _id}, {'$set': { 'ancestors': ancestors } })
</code></pre><br/>
Нужно попасть на один уровень вверх в дереве и получить список предков для <code>Ragtime</code>, которые можно использовать для создания списка предков <code>Swing</code>.<br/>
Тогда создадим документ и установим ему следующие значения:<br/>
<br/>
<pre><code class="python">doc = dict(name='Swing', slug='swing', parent=ragtime_id)
swing_id = db.categories.insert(doc)
build_ancestors(swing_id, ragtime_id)
</code></pre><br/>
Для операций добавления новой категории нам хватит индекса по умолчанию на <code>_id</code><br/>
<br/>
<em><font>Изменение предков у категории</font></em><br/>
В этом разделе рассмотрим процесс изменения дерева, поставим категорию <code>bop</code> над категорией <code>swing</code>. <br/>
<img src="http://docs.mongodb.org/ecosystem/_images/use-cases-category3.png"/><br/>
<br/>
Обновим документ <code>bop</code> чтобы изменить значения родителя:<br/>
<pre><code class="python">db.categories.update({'_id':bop_id}, {'$set': { 'parent': swing_id } } )
</code></pre><br/>
Следующая функция перестроит поле где хранятся предки.<br/>
<br/>
<pre><code class="python">def build_ancestors_full(_id, parent_id):
    ancestors = []
    while parent_id is not None:
        parent = db.categories.find_one({'_id': parent_id}, {'parent': 1, 'name': 1, 'slug': 1, 'ancestors':1})
        parent_id = parent.pop('parent')
        ancestors.append(parent)
    db.categories.update({'_id': _id}, {'$set': { 'ancestors': ancestors } }) 
</code></pre><br/>
Можно использовать следующий цикл для реконструирования всех потомков <code>bop</code><br/>
<br/>
<pre><code class="python">for cat in db.categories.find({'ancestors._id': bop_id}, {'parent': 1}):
    build_ancestors_full(cat['_id'], cat['parent'])
</code></pre><br/>
Создадим индекс для поля <code>ancestors._id</code> который нужен для операций обновления.<br/>
<br/>
<pre><code class="python">db.categories.ensure_index('ancestors._id')
</code></pre><br/>
<br/>
<em><font>Переименование категории</font></em><br/>
Для переименования категории нужно обновить как саму категорию так и всех потомков.<br/>
Рассмотрим переименования категории “Bop” в “BeBop” это изображено на следующей диаграме:<br/>
<img src="http://docs.mongodb.org/ecosystem/_images/use-cases-category4.png"/><br/>
Первое что нужно — это изменить имя категории:<br/>
<br/>
<pre><code class="python">db.categories.update({'_id':bop_id}, {'$set': { 'name': 'BeBop' } })
</code></pre><br/>
Далее нужно обновить у каждого потомка список предков:<br/>
<br/>
<pre><code class="python">db.categories.update({'ancestors._id': bop_id}, {'$set': { 'ancestors.$.name': 'BeBop' } }, multi=True)
</code></pre><br/>
Эта операция использует:<br/>
<ul>
<li>Позиционный оператор $ чтобы найти нужного предка не зная точно его <code>_id</code>.</li>
<li>Опцию <code>multi</code> которая указывает что нужно обновить все документы подпадающие под условие.</li>
</ul><br/>
Для этого обновления у нас уже есть индекс <code>ancestors._id</code>.<br/>
<br/>
<em><font>Шардинг</font></em><br/>
<br/>
Для большинства случаев шардинг этой коллекции имеет ограниченную ценность, потому что эта коллекция будет очень маленькой. Если нужен шард то для <code>shard key</code> подойдет поле <code>_id</code>.<br/>
<br/>
<pre><code class="python">&gt;&gt;&gt; db.command('shardCollection', 'categories', {  'key': {'_id': 1} })
{ "collectionsharded" : "categories", "ok" : 1 }
</code></pre><br/>
<br/>
P.S. Просьба о грамматических ошибках и ошибках перевода писать в личку.<br/>
<br/>
Используемые материалы:<br/>
<br/>
<a href="http://docs.mongodb.org/ecosystem/#use-cases"> Эко система MongoDB </a><br/>
<a href="http://docs.mongodb.org/manual/reference/operator/aggregation/">Справка по операторам в aggregation framework</a><br/>
<a href="http://habrahabr.ru/post/217393/">Статья про шардинг на хабре</a><br/>
<a href="http://design-pattern.ru/">Справочник «Паттерны проектирования» (ru)</a></h4></h4>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>