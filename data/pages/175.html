<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/getpro/habr/post_images/f54/f36/d44/f54f36d44609afab8cf09e26f78d666b.jpg" align="left"/><p>
Иногда сложно найти в Сети правильные, а главное актуальные «best practices» для языка. Документация, конечно же, содержит всю необходимую информацию, но отсеять нужную вещь в абзацах подробного (на то она и документация) описания довольно сложно. Но недавно мне улыбнулся поиск Google, и я наткнулся на очень полезные «паттерны» языка Python от одного из core разработчиков — Raymond Hettinger.

</p><i>Примечание</i><p>: Все рекомендации даны в нескольких вариантах: сначала идут самые «плохие» варианты, а дальше предлагается лучшая альтернатива. Актуально для версии языка 2.7, отличия для версии 3.3 читайте в примечаниях к конкретному «паттерну».
 </p><a name="habracut"/>

<h5>Цикл по массиву из чисел</h5>
<b>Плохо</b><p>: иногда пишут так. 
</p><pre><code class="python">for i in [0, 1, 2, 3, 4, 5]:
    print i**2
</code></pre>
<b>Хорошо</b><p>: лучший, с генератором. Но в 32 битной системе список из миллиона чисел будет занимать ~ 32 mb памяти. 
</p><pre><code class="python">for i in range(6):
    print i**2
</code></pre>
<b>Отлично:</b><p> самый лучший вариант. В отличии от второго </p><code>xrange</code><p> возвращает только одно значение за раз, и не нужно лишнюю память для хранения всего массива. 
</p><pre><code class="python">for i in xrange(6):
    print i**2
</code></pre>
<i>Примечание</i><p>: В версии Python 3.3 </p><code>xrange</code><p> уже в ядре и называеться просто </p><code>range</code><p>. 

</p><h5>Цикл по списку</h5>
<b>Плохо</b><p>: часто бывшие С программисты пишут так.
</p><pre><code class="python">colors = ['red', 'green', 'blue', 'yellow']
for i in range(len(colors)):
    print colors[i]
</code></pre>
<b>Хорошо</b><p>: лучший вариант. 
</p><pre><code class="python">colors = ['red', 'green', 'blue', 'yellow']
for color in colors:
    print color
</code></pre><p>
Но если нужно пройти по списку задом на перед? 

</p><b>Плохо</b><p>: опять, прошло из C дает о себе знать:
</p><pre><code class="python">colors = ['red', 'green', 'blue', 'yellow']

for i in range(len(colors)-1, -1, -1):
print colors[i]
</code></pre>
<b>Хорошо</b><p>: но в Python пишут вот так: 
</p><pre><code class="python">colors = ['red', 'green', 'blue', 'yellow']
for color in reversed(colors):
    print color
</code></pre>

<h5>Цикл по списку с индексами</h5>
<b>Плохо</b><p> тоже что и выше. 
</p><pre><code class="python">colors = ['red', 'green', 'blue', 'yellow']
for i in range(len(colors)):
    print i, '--&gt;', colors[i]
</code></pre>
<b>Хорошо</b><p>: более элегантный вариант: 
</p><pre><code class="python">colors = ['red', 'green', 'blue', 'yellow']
for i, color in enumerate(colors):
    print i, '--&gt;', color
</code></pre>

<h5>Цикл по двум спискам</h5>
<b>Плохо</b><p> тоже что и выше. 
</p><pre><code class="python">names = ['raymond', 'rachel', 'matthew']
colors = ['red', 'green', 'blue', 'yellow']
n = min(len(names), len(colors))
for i in range(n):
    print names[i], '--&gt;', colors[i]
</code></pre>
<b>Хорошо</b><p>: с двух списков делаем один список кортежей. Проблема в том что </p><code>zip </code><p>использует больше памяти чем первый вариант.
</p><pre><code class="python">names = ['raymond', 'rachel', 'matthew']
colors = ['red', 'green', 'blue', 'yellow']
for name, color in zip(names, colors):
    print name, '--&gt;', color
</code></pre>
<b>Отлично</b><p>: в отличии от </p><code>zip</code><p>, </p><code>izip </code><p>использует кэширование, что помогает существенно сэкономить память. 
</p><pre><code class="python">names = ['raymond', 'rachel', 'matthew']
colors = ['red', 'green', 'blue', 'yellow']
for name, color in izip(names, colors):
    print name, '--&gt;', color
</code></pre>
<i>Примечание</i><p>: В версии Python 3.3 </p><code>izip </code><p>вписан в ядро и называется просто </p><code>zip</code><p>. 

</p><h5>Сортировка списка по алгоритму</h5>
<b>Плохо</b><p>: используя функцию для сравнения.
</p><pre><code class="python">colors = ['red', 'green', 'blue', 'yellow']

def compare_length(c1, c2):
    if len(c1) &lt; len(c2): return -1
    if len(c1) &gt; len(c2): return 1
    return 0

print sorted(colors, cmp=compare_length)
</code></pre>

<b>Хорошо</b><p>: используя сортировку по ключу. Использует намного меньше памяти.
</p><pre><code class="python">colors = ['red', 'green', 'blue', 'yellow']

print sorted(colors, key=len)
</code></pre>
<i>Примечание</i><p>: Метод </p><code>cmp </code><p>убран с ядра Python 3.x. 

</p><h5>Цикл по ключам словаря</h5><p>
Обычный способ возвращает ключи. При таком цикле происходит итерация словаря, поэтому в процессе его изменять нельзя. 
</p><pre><code class="python">for k in d:
    print k
</code></pre><p>
Для изменения словаря в цикле используйте цикл по ключам (Пример: удаление всех ключей начинающихся с </p><code>R</code><p>):
</p><pre><code class="python">for k in d.keys():
    if k.startswith('R'):
        del d[k]
</code></pre><p>
В этом случае </p><code>d.keys()</code><p> делает копию ключей словаря, что позволяет нам свободно работать с оригинальной структурой. 

</p><h5>Цикл по ключам и значением словаря</h5>
<b>Плохо</b><p>: цикл по ключам и возвращение значение по последним. Медленный способ:
</p><pre><code class="python">for k in d:
    print k, '--&gt;', d[k]
</code></pre>
<b>Хорошо</b><p>: быстрее делать цикл по значениях:
</p><pre><code class="python">for k, v in d.items():
    print k, '--&gt;', v
</code></pre>
<b>Отлично</b><p>: Но самый лучший и быстрый способ это использовать итератор:
</p><pre><code class="python">for k, v in d.iteritems():
    print k, '--&gt;', v
</code></pre>

<h5>Соединение двух списков в один словарь</h5><p>
Очень быстрый метод, используется только один кортеж для генерации словаря. 
</p><pre><code class="python">names = ['raymond', 'rachel', 'matthew']
colors = ['red', 'green', 'blue']

d = dict(izip(names, colors))
# d будет иметь следующее значение: 
# {'matthew': 'blue', 'rachel': 'green', 'raymond': 'red'}
</code></pre>

<h5>Подсчет элементов в словаре</h5>
<b>Плохо</b><p>: обычный способ:
</p><pre><code class="python">colors = ['red', 'green', 'red', 'blue', 'green', 'red']
d = {}

for color in colors:
    if color not in d:
        d[color] = 0
    d[color] += 1

#{'blue': 1, 'green': 2, 'red': 3}
</code></pre>
<b>Хорошо</b><p>: использует функцию </p><code>get()</code><p>:
</p><pre><code class="python">colors = ['red', 'green', 'red', 'blue', 'green', 'red']
d = {}

for color in colors:
    d[color] = d.get(color, 0) + 1
</code></pre>
<b>Отлично</b><p>: самый продвинутый способ это использовать </p><code>defaultdict()</code><p>. Но вы должны знать </p><a href="http://docs.python.org/dev/library/collections#collections.defaultdict">как он работает</a><p>. 
</p><pre><code class="python">d = defaultdict(int)
for color in colors:
    d[color] += 1
</code></pre>

<h5>Группирование элементов списка</h5>
<b>Плохо</b><p>: если нужно сгруппировать элементы списка по некоторому признаку (в примере — длина строки) часто используют такой метод: 
</p><pre><code class="python">names = ['raymond', 'rachel', 'matthew', 'roger', 'betty', 'melissa', 'judith', 'charlie']
d = {}

for name in names:
    key = len(name)
    if key not in d:
        d[key] = []
    d[key].append(name)
{5: ['roger', 'betty'], 6: ['rachel', 'judith'], 7: ['raymond', 'matthew', 'melissa', 'charlie']}
</code></pre>
<b>Хорошо</b><p>: но есть способ гораздо элегантней и быстрее:
</p><pre><code class="python">d = defaultdict(list)
for name in names:
    key = len(name)
    d[key].append(name)
</code></pre>

<h5>Итог</h5><p>
На сегодня все. Надеюсь эти тривиальные, но полезные примеры помогут кому-то улучшить свой код, как они помогли это сделать мне. Их автором является Raymond Hettinger (</p><a href="https://twitter.com/raymondh">@raymondh</a><p>), Python Core Developer.

</p><i>UPD</i><p>: Видео доклада на PyCon 2013, с которого были взяты примеры кода: </p><a href="http://youtu.be/OSGv2VnC0go">http://youtu.be/OSGv2VnC0go</a><p> (на английском), содержит еще очень много интересной информации не перенесенной в статью, а также юмор и харизму докладчика.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>