<html><body><div><div class="post-text" itemprop="text">
<h1>Simulated MultiKey Dictionary</h1>

<p><code>multi_key_dict</code> did not allow <code>__getitem__()</code> with multiple keys at onces... </p>

<p>(e.g. <code>d["red", "green"]</code>) </p>

<p>A multi key can be simulated with <code>tuple</code> or <code>set</code> keys. If order does not matter, <code>set</code> seems the best (actually the hashable <code>frozenset</code>), so that [<code>"red", "blue"]</code> is the same a <code>["blue", "red"]</code>.</p>

<h1>Simulated MultiVal Dictionary</h1>

<p>Multi values are inherent by using certain datatypes, it can be any <em>storage</em> element that may be conveniently indexed.  A standard <code>dict</code> should provide that.</p>

<h1>Non-determinism</h1>

<p>Using a probability distribution defined by the rules and assumptions<sup>1</sup>, non-deterministic selection is performed using <a href="https://docs.python.org/3/library/random.html#examples-and-recipes" rel="nofollow">this recipe</a> from the python docs.</p>

<h1><code>MultiKeyMultiValNonDeterministicDict</code> Class</h1>

<p><sup>What a name, \o/ !</sup></p>

<p>This class takes multiple keys that define a probabilistic rule set of  multiple values.  During item creation (<code>__setitem__()</code>) all value probabilities are precomputed for all combinations of keys<sup>1</sup>.  During item access (<code>__getitem__()</code>) the precomputed probability distribution is selected and the result is evaluated based on a random weighted selection.</p>

<h2>Definition</h2>

<pre><code>import random
import operator
import bisect
import itertools

# or use itertools.accumulate in python 3
def accumulate(iterable, func=operator.add):
    'Return running totals'
    # accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15
    # accumulate([1,2,3,4,5], operator.mul) --&gt; 1 2 6 24 120
    it = iter(iterable)
    try:
        total = next(it)
    except StopIteration:
        return
    yield total
    for element in it:
        total = func(total, element)
        yield total

class MultiKeyMultiValNonDeterministicDict(dict):

    def key_combinations(self, keys):
        """get all combinations of keys"""
        return [frozenset(subset) for L in range(0, len(keys)+1) for subset in itertools.combinations(keys, L)]

    def multi_val_rule_prob(self, rules, rule):
        """
        assign probabilities for each value, 
        spreading undefined result probabilities
        uniformly over the leftover results not defined by rule.
        """
        all_results = set([result for result_probs in rules.values() for result in result_probs])
        prob = rules[rule]
        leftover_prob = 1.0 - sum([x for x in prob.values()])
        leftover_results = len(all_results) - len(prob)
        for result in all_results:
            if result not in prob:
                # spread undefined prob uniformly over leftover results
                prob[result] = leftover_prob/leftover_results
        return prob

    def multi_key_rule_prob(self, key, val):
        """
        assign probability distributions for every combination of keys,
        using the default for combinations not defined in rule set
        """ 
        combo_probs = {}
        for combo in self.key_combinations(key):
            if combo in val:
                result_probs = self.multi_val_rule_prob(val, combo).items()
            else:
                result_probs = self.multi_val_rule_prob(val, frozenset([])).items()
            combo_probs[combo] = result_probs
        return combo_probs

    def weighted_random_choice(self, weighted_choices):
        """make choice from weighted distribution"""
        choices, weights = zip(*weighted_choices)
        cumdist = list(accumulate(weights))
        return choices[bisect.bisect(cumdist, random.random() * cumdist[-1])]

    def __setitem__(self, key, val):
        """
        set item in dictionary, 
        assigns values to keys with precomputed probability distributions
        """

        precompute_val_probs = self.multi_key_rule_prob(key, val)        
        # use to show ALL precomputed probabilities for key's rule set
        # print precompute_val_probs        

        dict.__setitem__(self, frozenset(key), precompute_val_probs)

    def __getitem__(self, key):
        """
        get item from dictionary, 
        randomly select value based on rule probability
        """
        key = frozenset([key]) if isinstance(key, str) else frozenset(key)             
        val = None
        weighted_val = None        
        if key in self.keys():
            val = dict.__getitem__(self, key)
            weighted_val = val[key]
        else:
            for k in self.keys():
                if key.issubset(k):
                    val = dict.__getitem__(self, k)
                    weighted_val = val[key]

        # used to show probabality for key
        # print weighted_val

        if weighted_val:
            prob_results = self.weighted_random_choice(weighted_val)
        else:
            prob_results = None
        return prob_results
</code></pre>

<h2>Usage</h2>

<pre><code>d = MultiKeyMultiValNonDeterministicDict()

d["red","blue","green"] = {
    # {rule_set} : {result: probability}
    frozenset(["red", "green"]): {"ballon": 0.8},
    frozenset(["blue"]): {"toy": 0.15},
    frozenset([]): {"car": 0.05}
}
</code></pre>

<h1>Testing</h1>

<p>Check the probabilities</p>

<pre><code>N = 10000
red_green_test = {'car':0.0, 'toy':0.0, 'ballon':0.0}
red_blue_test = {'car':0.0, 'toy':0.0, 'ballon':0.0}
blue_test = {'car':0.0, 'toy':0.0, 'ballon':0.0}
red_blue_green_test = {'car':0.0, 'toy':0.0, 'ballon':0.0}
default_test = {'car':0.0, 'toy':0.0, 'ballon':0.0}

for _ in xrange(N):
    red_green_test[d["red","green"]] += 1.0
    red_blue_test[d["red","blue"]] += 1.0
    blue_test[d["blue"]] += 1.0
    default_test[d["green"]] += 1.0
    red_blue_green_test[d["red","blue","green"]] += 1.0

print 'red,green test      =', ' '.join('{0}: {1:05.2f}%'.format(key, 100.0*val/N) for key, val in red_green_test.items())
print 'red,blue test       =', ' '.join('{0}: {1:05.2f}%'.format(key, 100.0*val/N) for key, val in red_blue_test.items())
print 'blue test           =', ' '.join('{0}: {1:05.2f}%'.format(key, 100.0*val/N) for key, val in blue_test.items())
print 'default test        =', ' '.join('{0}: {1:05.2f}%'.format(key, 100.0*val/N) for key, val in default_test.items())
print 'red,blue,green test =', ' '.join('{0}: {1:05.2f}%'.format(key, 100.0*val/N) for key, val in red_blue_green_test.items())
</code></pre>

<p><strong>Ouput</strong></p>

<pre><code>red,green test      = car: 09.89% toy: 10.06% ballon: 80.05%
red,blue test       = car: 05.30% toy: 47.71% ballon: 46.99%
blue test           = car: 41.69% toy: 15.02% ballon: 43.29%
default test        = car: 05.03% toy: 47.16% ballon: 47.81%
red,blue,green test = car: 04.85% toy: 49.20% ballon: 45.95%
</code></pre>

<p><strong>Probabilities match rules!</strong></p>

<hr/>

<h3>Footnotes</h3>

<ol>
<li><p>Distribution Assumption</p>

<p>Since the rule set is not fully defined, assumptions are made about the probability distributions, most of this is done in <code>multi_val_rule_prob()</code>.  Basically any undefined probability will be spread uniformly over the remaining values. This is done for <em>all</em> combinations of keys, and creates a generalized key interface for the random weighted selection.</p>

<p>Given the example rule set</p>

<pre><code>d["red","blue","green"] = {
    # {rule_set} : {result: probability}
    frozenset(["red", "green"]): {"ballon": 0.8},
    frozenset(["blue"]): {"toy": 0.15},
    frozenset([]): {"car": 0.05}
}
</code></pre>

<p>this will create the following distributions</p>

<pre><code>'red'           = [('car', 0.050), ('toy', 0.475), ('ballon', 0.475)]
'green'         = [('car', 0.050), ('toy', 0.475), ('ballon', 0.475)]
'blue'          = [('car', 0.425), ('toy', 0.150), ('ballon', 0.425)]
'blue,red'      = [('car', 0.050), ('toy', 0.475), ('ballon', 0.475)]
'green,red'     = [('car', 0.098), ('toy', 0.098), ('ballon', 0.800)]
'blue,green'    = [('car', 0.050), ('toy', 0.475), ('ballon', 0.475)]
'blue,green,red'= [('car', 0.050), ('toy', 0.475), ('ballon', 0.475)]
 default        = [('car', 0.050), ('toy', 0.475), ('ballon', 0.475)]
</code></pre>

<p>If this is incorrect, please advise.</p></li>
</ol>
    </div>
    </div></body></html>