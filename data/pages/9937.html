<html><body><div><blockquote>
<p><tt>Database</tt> is a base class for database testing packages.
To create your database testing class, inherit this class and override methods below.</p>
<p>def initialize(self):</p>
<blockquote>
Handler for initialize database object.</blockquote>
<p>def get_data_directory(self):</p>
<blockquote>
<p>Path to data directory of your databse.</p>
<p>Example:</p>
<pre>def get_data_directory(self):
    return os.path.join(self.base_dir, 'data')
</pre>
</blockquote>
<p>def initialize_database(self):</p>
<blockquote>
<p>Handler to initialize your database.</p>
<p>Example:</p>
<pre>def initialize_database(self):
   if not os.path.exists(os.path.join(self.base_dir, 'data', 'PG_VERSION')):
       args = ([self.initdb, '-D', os.path.join(self.base_dir, 'data'), '--lc-messages=C'] +
               self.settings['initdb_args'].split())

       try:
           p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
           output, err = p.communicate()
           if p.returncode != 0:
               raise RuntimeError("initdb failed: %r" % err)
       except OSError as exc:
           raise RuntimeError("failed to spawn initdb: %s" % exc)
</pre>
</blockquote>
<p>def get_server_commandline(self):</p>
<blockquote>
<p>Command line to invoke your database server.</p>
<p>Example:</p>
<pre>def get_server_commandline(self):
    return (['postgres',
             '-p', str(self.settings['port']),
             '-D', os.path.join(self.base_dir, 'data'),
             '-k', os.path.join(self.base_dir, 'tmp')] +
            self.settings['postgres_args'].split())
</pre>
</blockquote>
<p>def prestart(self):</p>
<blockquote>
Handler called before invoking your database server.</blockquote>
<p>def poststart(self):</p>
<blockquote>
Hander called after invoking your database server.</blockquote>
<p>def is_server_available(self):</p>
<blockquote>
<p>Methods check your database server available.
The <tt>Database</tt> class uses this method to check the server boots up.</p>
<p>Example:</p>
<pre>try:
    with closing(pg8000.connect(**self.dsn(database='template1'))):
        pass
except pg8000.Error:
    return False
else:
    return True
</pre>
</blockquote>
<p>def is_alive(self):</p>
<blockquote>
Methods check the database server is alive.</blockquote>
<p>@property
def server_pid(self):</p>
<blockquote>
Process ID of the database server.</blockquote>
</blockquote>
<blockquote>
<p><tt>DatabaseFactory</tt> is a factory class for the database class.
To create your database factory class, inherit this class and set <tt>target_class</tt> variable:</p>
<pre>class PostgresqlFactory(DatabaseFactory):
    target_class = Postgresql
</pre>
<p>The factory class should work like a <tt>target_class</tt>:</p>
<pre># The factory class generates like a ``target_class``, in this case, generates ``Postgresql`` class
Postgresql = PostgresqlFactory()

# The generated class works same as ``target_class``
with Postgresql() as pgsql:
    #
    # do any tests using the database ...
    #
</pre>
<p>It can bypass parameters to the <tt>target_class</tt> on every instantiation:</p>
<pre>Postgresql = PostgresqlFactory(copy_data_from='/path/to/database')

with Postgresql() as pgsql:
    #
    # Test with ``copy_data_from`` parameter :-)
    #
</pre>
<p>Also, it is able to cache the database generated at <tt>Database.initialize_database()</tt>
with <tt>cache_initialized_db</tt> parameter.
It avoids running database initialization on every tests:</p>
<pre># Initialize database once
Postgresql = PostgresqlFactory(cache_initialized_db=True)

with Postgresql() as pgsql:
    # copy cached database for this test.
</pre>
<p>If you want to fixtures to the database, use <tt>on_initialized</tt> parameter:</p>
<pre>def handler(pgsql):
    # inserting fixtures

# Initialize database once, and call ``on_initialized`` handler
Postgresql = PostgresqlFactory(cache_initialized_db=True,
                               on_initialized=handler)
</pre>
</blockquote>
<blockquote>
<p>Generates decorator that skips the testcase if database command not found.
To create decorator, inherit this class and set <tt>name</tt> variable and override <tt>search_server()</tt> method.</p>
<p>Example:</p>
<pre>class PostgresqlSkipIfNotInstalledDecorator(SkipIfNotInstalledDecorator):
    name = 'PostgreSQL'

    def search_server(self):
        find_program('postgres', ['bin'])  # raise exception if not found


skipIfNotFound = skipIfNotInstalled = PostgresqlSkipIfNotInstalledDecorator()

@skipIfNotFound
def test():
    # testcase
</pre>
</blockquote>
</div></body></html>