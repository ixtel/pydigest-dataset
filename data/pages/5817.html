<html><body><div><div class="article-content">
        
        
        
        <p><a class="modal-link" href="/_file/blog/playing-around-with-python-in-postgresql/postgresql-python.png" title=""><img src="/_file/blog/playing-around-with-python-in-postgresql/postgresql-python.png" alt=""/></a></p>

        

<p>I’m kind of guy who likes to make jokes or take some ideas ad absurdum. It may looks useless, but examination of extremes helps me appreciate the middle way.</p>
				
<p>Some time ago I was heavily infected by an idea: “let’s ditch the server side” (see my article: <a href="http://www.vertabelo.com/blog/notes-from-the-lab/do-we-still-need-server-side-programming" target="_blank">Do we still need server side programming?</a>). The “PostgreSQL as an Application Server” idea was born then. My Vertabelo colleagues insisted that I should write an article about it. I didn’t like it at first: it would require some real work :) This week I said why not? I’ll learn something new about PostgreSQL at least. So here we go.</p>
				
<h3>PostgreSQL as an application server</h3>
				
<p>What is an application server? My definition is: a runtime and store for business logic. PostgreSQL has stored procedures so we use them as a runtime. PostgreSQL is a database so it can store anything :)</p>
				
<p>The database for an application server may look like:</p>
        
	
        

        
        <p>↑ Click on a logo to open the model in Vertabelo | <a href="/_file/blog/playing-around-with-python-in-postgresql/postgres-as-application-server.png" title="Postgres as application server" target="_blank">Download the model as a png file</a></p>
        
        
				
<pre class="brush:sql">create table handler(
    path varchar(255),
    code text,
    template text);</pre>
									 
<p>Each row of the <code>handler</code> table contains the information how to handle an HTTP request for a given resource:</p>
				
<ul>
	<li><code>path</code> contains the path to a requested resource (e.g. <code>/, /admin</code>)</li>
	<li><code>code</code> contains a code to run while processing a request</li>
	<li><code>template</code> contains an HTML template which will be rendered as response</li>
</ul>
				
<p>Here is a pseudo code of how a response is generated.</p>
				
<pre class="brush:sql">response_html = template(code(path))</pre>
				
<p>Yep. That’s nothing revolutionary. You may have seen this in other web frameworks.</p>
				
<h4>PL/pgSQL or Python? An obvious choice</h4>
				
<p>As I said before, PostgreSQL supports stored procedures and I’ll use them to implement the core of an application server. Stored procedures can be written in built-in language <a href="http://www.postgresql.org/docs/9.3/static/plpgsql.html" title="PostgreSQL: Documentation: 9.3: PL/pgSQL - SQL Procedural Language" target="_blank">PL/pgSQL</a> (yikes!) or, for example, in <a href="http://www.postgresql.org/docs/9.3/static/plpython.html" title="PostgreSQL: Documentation: 9.3: PL/Python - Python Procedural Language" target="_blank">Python</a> (yummy). I’ve decided to use Python for hmmm... obvious reasons. (The core PostgreSQL distribution also supports <a href="http://www.postgresql.org/docs/current/interactive/plperl.html" title="PostgreSQL: Documentation: 9.4: PL/Perl - Perl Procedural Language" target="_blank">Perl</a> and <a href="PL/Tcl http://www.postgresql.org/docs/current/interactive/pltcl.html" title="PostgreSQL: Documentation: 9.4: PL/Tcl - Tcl Procedural Language" target="_blank">Tcl</a> as procedural languages.)</p>
				
<p>You’ll have install and enable an extension to have Python working in your database. The Extension is called <code>postgresql-plpython-9.3</code>, at least in Ubuntu.</p>
				
<p>Let’s create a sample database and enable support for Python.</p>
								
<ol>
<li>Connect as a postgres
<pre class="brush:bash">su - postgres
psql</pre>
</li>

<li>Then execute following queries:
<pre class="brush:sql"># create test user and the database
create user test with password 'test';
create database test owner test;

&gt;# connect to test database
\c test

# enable python in that database
CREATE PROCEDURAL LANGUAGE 'plpythonu' HANDLER plpython_call_handler;

# enable python for test user
UPDATE pg_language SET lanpltrusted = true WHERE lanname LIKE 'plpythonu';</pre>
</li>
</ol>
				
				<p>Support has been enabled. You may check it by running example code from <a href="http://www.postgresql.org/docs/9.3/static/plpython.html" title="PostgreSQL: Documentation: 9.3: PL/Python - Python Procedural Language" target="_blank">documentation</a>.</p>

        
        
        <p>A D V E R T I S E M E N T<br/><a href="http://www.vertabelo.com/start" target="_blank" title="Online database modeling tool for PostgreSQL users. Try it now in your browser, without registration!"><img src="/_file/banners/data-modeling-tool-for-postgresql-735x250.png" alt="Online tool for database design. Start modeling in your browser, without any registration!"/></a></p>
        
<h3>Handling requests</h3>
        
<p>Let’s code the core of our solution. As I’ve mentioned before, the core will execute code for a given path and render output as an HTML page. The path, code and HTML template are stored in the <code>handler</code> table. Here is a handle_request function written in Python for PostgreSQL.</p>

<pre class="brush:python">CREATE OR REPLACE FUNCTION handle_request(IN path text) RETURNS text AS
$$
import urlparse

url=urlparse.urlparse(path)
params=urlparse.parse_qs(url.query)

stm = plpy.prepare("SELECT code, template FROM handler WHERE path = $1", [ "text" ])
rv = plpy.execute(stm, [ url.path ])

if(len(rv) == 0):
  return "not found"
else:
  code = rv[0]['code']
  template = rv[0]['template']
  locals = {'path': url.path, 'params': params, 'ctx': {}}
  exec(code, globals(), locals)	   
  ctx = locals['ctx']
  return template.format(**ctx)

$$
LANGUAGE 'plpythonu' VOLATILE;</pre>

<p>The procedure parses URL parameters. Then it reads the Python code and the HTML template from the database. Finally, it runs the Python code and renders the result.</p>

<p>And here is a sample request handler for / page.</p>

<pre class="brush:sql">insert into handler values('/', '# put you python code here',  '&lt;h1&gt;Hello world&lt;/h1&gt;');</pre>

<p>Let’s see how it works.</p>

<pre class="brush:sql">test=&gt; select handle_request('/');
    handle_request    
----------------------
 &lt;h1&gt;Hello world&lt;/h1&gt;
(1 row)</pre>

<p>It works :).</p>

<h4>Handling user input</h4>

<p>Let’s do something more dynamic. The user can provide a message to display in the “message” parameter. The code displays the value in the template.</p>

<pre class="brush:python">insert into handler values('/dynamic', 
'
message=""
if params.has_key("message"):
   message = params["message"][0]

ctx["message"] = message
'
,  '&lt;h2&gt;Dynamic&lt;/h2&gt; message: &lt;b&gt;{message}&lt;/b&gt;');</pre>


<pre class="brush:sql">test=&gt; select handle_request('/dynamic?message=foo');
            handle_request            
--------------------------------------
 &lt;h2&gt;Dynamic&lt;/h2&gt; message: &lt;b&gt;foo&lt;/b&gt;
(1 row)</pre>

<h4>Reading content from the database</h4>

<p>Or even more dynamic. The code inserts new items into the todo table.</p>

<pre class="brush:sql">create table todo (
		item varchar(255)
);
</pre>
<pre class="brush:sql">        
insert into handler values('/todo', 
'
if params.has_key("item"):
   item = params["item"][0]
   stm = plpy.prepare("insert into todo values($1)", [ "text" ])
   plpy.execute(stm, [item])

stm = plpy.prepare("select item from todo", [])
rv = plpy.execute(stm,[])
list=""

for r in rv:
   list =  list + "&lt;li&gt;%s&lt;/li&gt;" % (r["item"])

ctx["list"] = list;
'
,  

'&lt;h2&gt;TODO&lt;/h2&gt;
&lt;ol&gt;
{list}
&lt;/ol&gt;
&lt;hr&gt;
&lt;form&gt;&lt;input type="text" name="item"&gt;&lt;button&gt;add&lt;/button&gt;&lt;/form&gt;
&lt;hr&gt;
');</pre>

<p>Please test this example by yourself just after you launch the HTTP connector.</p>

<h3>HTTP server</h3>
<p>I was thinking about how to handle an HTTP request in the PostgreSQL. I’ve decided to write a simple HTTP connector instead of embedding HTTP server in the PostgreSQL itself. Here is the code:</p>

<pre class="brush:python">#  http.py
import SimpleHTTPServer
import SocketServer
import psycopg2 as dbapi2

PORT = 8000

class Handler(SimpleHTTPServer.SimpleHTTPRequestHandler):
	def do_GET(self):
		self.send_response(200)
		self.send_header("Content-type", "text/html")
		self.end_headers()

		db = dbapi2.connect (database="test", user="test", 
			password="test", host="localhost", port=5433)
		try:
			cur = db.cursor()
			try:
				cur.execute("select handle_request(%(path)s);",
					{'path': self.path})
				rows = cur.fetchall()
				result=rows[0][0]
				self.wfile.write(result)
			finally:
				cur.close()
		finally:
			db.commit()
			db.close()

httpd = SocketServer.TCPServer(("", PORT), Handler)

print "serving at port", PORT
httpd.serve_forever()</pre>

<p>Save it as <code>http.py</code> and run it</p>

<p>Now you can open your browser and click this <a href="http://localhost:8000/dynamic?message=foo" target="_blank">link</a>.</p>
<p><img src="/_file/blog/playing-around-with-python-in-postgresql/dynamic-content.png" alt="Dynamic content"/></p>


<p>And your favourite database editor:</p> 
<p><img src="/_file/blog/playing-around-with-python-in-postgresql/database-editor.png" alt="Database editor"/></p>
<p>Now you have configured the development environment. Enjoy!</p>

<h3>Conclusions</h3>
<p>That’s all folks. If someone decides to develop a CRUD application for the <code>handler</code> table he/she may end up with IDE for “PostgresSQL as an Application Server” :D.</p>

<p>Seriously though, what did I learn with this exercise? Well, I have overcome my fear of writing stored procedures. It turns out that with a developer-friendly programming language, stored procedures are yet another piece of code, not something you only approach with a manual at hand.</p>

<p>What do you think about storing business logic in the database and treating it as a data?</p>
      
      </div>
    </div></body></html>