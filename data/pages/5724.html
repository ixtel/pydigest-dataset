<html><body><div><div class="field__item even" property="content:encoded"><p><a href="http://en.wikipedia.org/wiki/Python_%28programming_language%29" target="_blank">Python</a> has become an increasingly common language for data scientists, back-end engineers, and front-end engineers, providing a unifying platform for the range of disciplines found on an engineering team. One of the benefits of Python is that it allows software developers to choose and make use of zillions of good code packages. Among the huge number of excellent Python packages, a data scientist may use Pandas for data manipulation, NumPy for matrix computation, matplotlib for plotting, SciPy for mathematical modeling, and Scikit Learn for machine learning. Another benefit of using Python is that it allows developers to contribute their own code packages to the community or share a library with other Python programmers. At Endgame, library sharing is very common across projects for agile product development. For example, the implementation of a new clustering algorithm as a Python library can be used in multiple products with minimum adaptation. This tutorial will cover the basic steps and recommended practices for how to structure a Python project, package the code, distribute it over a Git repository (Github or a private Git repository) and install the package via pip.</p>
<p>For busy readers, I’ve developed a workflow diagram, below, so that you can quickly glance at the steps that I’ll outline in more detail throughout the post. Feel free to look back at the workflow diagram anytime you need a reminder of how the process works.</p>
<p> </p>
<p><img alt="Workflow Diagram for Open-Sourcing a Python Library" src="https://www.endgame.com/sites/default/files/PythonLibraryHowToWorkFlow.jpg"/></p>
<p> </p>
<p><u><strong>Step One: Setup</strong></u></p>
<p>Let’s suppose we are going to develop a new Python package that will include some exciting machine learning functionality. We decide to name the package "egclustering" to indicate that it contains functions for clustering. In the future, if we are to develop a new set of functions for classification, we could create a new package called "egclassification". In this way, functions designed for different purposes are organized into different buckets. We will name the project folder on the local computer as "eglearning". In the end, the whole project will be version controlled via Git, and be put on a remote Git repository, either GitHub or a private remote repository. Anyone who wants to use the library would just need to install the package from the remote repository. </p>
<p><em>Term Definitions</em></p>
<p>Before we dig into the details, let’s define some terms:</p>
<ul><li>Python Module: A Python module is a py file that contains classes, functions and/or other Python definitions and statements. More detailed information can be found <a href="https://docs.python.org/2/tutorial/modules.html" target="_blank">here</a>.</li>
<li>Python Package: A Python package includes a collection of modules and a ___init___.py file. Packages can be nested at any depth, provided that the sub-directories contain their own __init__.py file.</li>
<li>Distribution: A distribution is one level higher than a package. A distribution may contain one or multiple packages. In file systems, a distribution is the folder that includes the folders of packages and a dedicated setup.py file. </li>
</ul><p><u><strong>Step Two: Project Structure</strong></u></p>
<p>A clearly defined project structure is critically important when creating a Python code package. Not only will it present your work in an organized way and help users find valuable information easily, but it will also be much easier to add new packages or files in the future if the project scales.</p>
<p>I will take the recommendation from "<a href="http://www.kennethreitz.org/essays/repository-structure-and-python" target="_blank">Repository Structure and Python</a>" to structure a new project, only adding a new file called README.md which is an introductory file used on GitHub, as shown below.</p>
<p>README.rst<br/>
README.md<br/>
LICENSE<br/>
setup.py<br/>
requirements.txt<br/>
egclustering<br/>
            __init__.py<br/>
            clusteringModuleLight.py (This py file contains the code.)<br/>
            helpers.py<br/>
docs<br/>
            conf.py<br/>
            index.rst<br/>
tests<br/>
            test_basic.py<br/>
            test_advanced.py </p>
<p>The project structure is well explained on the page referenced above. Still, it might be helpful to emphasize a few points here:</p>
<ul><li><strong>setup.py</strong> is the file that tells a distribution tool, such as Distutils or Setuptools, how to install and configure the package. It is a must-have.</li>
<li><strong>egclustering </strong>is the actual package name. How would we (or a distribution tool) know that? Because it contains a __init__.py file. The __init__.py file could be empty, or contain statements for some initiation activities.</li>
<li><strong>clusteringModuleLight.py</strong> is the core file that defines the classes and functions. A single py file like that is called a module. A package may contain multiple modules. A package may also contain other packages, namely sub-packages, as long as there is a __init__.py included in a package folder. A project may contain multiple packages as well. For instance, we may create a new folder on par with "egclustering" called "egclassification" and put a new __init__.py under it.</li>
<li>Once you find a structure you like, it can serve as a template for future structures. You only need to copy and paste the whole project folder and give it a new project name. More advanced users can try using some template tools, for example, <a href="https://github.com/audreyr/cookiecutter" target="_blank">cookiecutter</a>. </li>
</ul><p><u><strong>Step Three:</strong></u><u><strong> Setup Git and GitHub (or private GitHub) Repository</strong></u></p>
<p>Ctrl+Alt+t to open a new terminal, and type in the following two commands to install Git on your computer, if you haven't done so. </p>
<p>            sudo apt-get update<br/>
            sudo apt-get install git</p>
<p>If the remote repository will be on GitHub (or any other source code host, such as bitbucket.org), open a web browser and go to github.com, apply for an account, and create a new repository with a name like 'peterpan' in my case. If the remote repository will be on a private GitHub, create a new repository in a similar way. In either situation, you will need to tell GitHub your public key so that you can use ssh protocol to access the repository. </p>
<p>To generate a new pair of ssh keys (private and public), type the commands in the terminal:</p>
<p>            ssh-keygen -t rsa -C "<a href="mailto:your_email@example.com">your_email@example.com</a>"<br/>
            eval "$(ssh-agent -s)"<br/>
            ssh-add ~/.ssh/id_rsa</p>
<p>Then go to the settings page of your github account and copy and paste the content in the pub file into a new key. The details of generating ssh keys can be found on this settings page.</p>
<p>You should now have a new repository on GitHub ready to go. Click on the link of the repo and it will open the repo's webpage. At the moment, you only have a master branch. We need to create a new branch called "develop" so that all the development will happen on the "develop" branch. Once the code reaches a level of maturity, we put it on "master" branch for release.</p>
<p>To do that, click "branch", and in the blank field, type "develop". When that's done, a new branch will be created. </p>
<p><u><strong>Step Four: Initiate the Local Git and Syn with the Remote Repository</strong></u></p>
<p>So far, we have installed Git locally to control the source code version, created the skeleton structure of the project, and set up the remote repository that will be linked with the local Git. Now, open a terminal window and change the directory (command ‘cd’) in the project folder (in my case, it is ~/workspace/peterpan). Type:</p>
<p>            git init<br/>
            git add .  </p>
<p>The period “.” after “git add” indicates to add the current folder into Git control.</p>
<p>If you haven't done so already, you will need to tell Git who you are. Type:</p>
<p>            git config --global user.name "your name"<br/>
            git config --global user.email "your email address"</p>
<p>Now let's tell local Git what remote repository it will be associated with. Before doing that, we need to get the URL of the remote repository so that the local Git knows where to locate it. On your browser, open the remote Git repository webpage, either on Github or your private GitHub. On the bottom of the right-side panel, you will see URL in different protocols of https, SSH, or subversion. If you're using GitHub and your repository is public, you may choose to use the https URL. Otherwise, use the SSH URL. Click the "copy to clipboard" button to copy the link.</p>
<p>In the same terminal, type:</p>
<p>            git remote -v </p>
<p>to check what remote repositories you currently have. There should be nothing.</p>
<p>Now use the copied URL (which in my case is <a href="mailto:git@github.com">git@github.com</a>:richardxy/peterpan.git) to construct the command below. "peterpanssh" is the name I gave to this specific remote repository which helps the local Git to identify which remote repository we deal with.</p>
<p>            git remote add peterpanssh <a href="mailto:git@github.com">git@github.com</a>:richardxy/peterpan.git</p>
<p>When you type in the command “git remote -v” again, you should see the new remote repository has been registered with the local Git. You can add more remote repositories in this way by using “git remote add” command. In the case when you would like to delete a remote repository, which basically means "break the link between the local git and the remote repository", you can do Git remote rm (repository name), such as:</p>
<p>            git remote rm peterpanssh</p>
<p>If you don't like the current name of a repository, you can rename it by using the following command.</p>
<p>            git remote rename (oldname) (newname), such as:<br/>
            git remote rename peterpanssh myrepo</p>
<p>At the moment, the local Git repository has only one branch. Use “git branch” to check, and you will see “master” only. A better practice is to create a “develop” branch and develop your work there. To do this, type:</p>
<p>            git checkout -b develop</p>
<p>Now type “git branch” again and hit enter in the terminal window, and you will see the branch “develop” with an asterisk attached ahead of it, which means that the branch “develop” is the current working branch.</p>
<p>Now that we have linked a remote Git repository with the local Git, we can start synchronizing them. When you created the new repository on the remote Git (Github or your company's private Git repository), you may have opted in to add a .gitignore file. At the moment, .gitignore file exists only at the remote repository, but not at the local git repository. So we need to pull it to the local repository and merge it with what we have in the local repository. To do that, we use the command below:</p>
<p>            git pull peterpanssh develop </p>
<p>Of course, peterpanssh is the name of the remote repository registered with the local git. You may use your own name.</p>
<p>“Git pull” works fine in small and simple projects like this. But when working on a project that has many branches in its repository, separate commands "git fetch" and "git merge" are recommended. More advanced materials can be found at <a href="http://git-scm.com/docs/git-pull" target="_blank">git-pull</a> Documentation and <a href="http://longair.net/blog/2009/04/16/git-fetch-and-merge/" target="_blank">Mark's blog</a>.</p>
<p>Once the local Git repository has everything the remote Git repository has (and more), we can commit and push the contents in the local Git to the remote Git.</p>
<p>The reason for committing to Git is to put the source code under Git's version control. The workflow related to committing usually includes:</p>
<p><strong>Modify code</strong> -&gt; <strong>Stage code</strong> -&gt; <strong>Commit code</strong></p>
<p>So, before we actually commit the code, we need to stage the modified files. We do this to tell Git what changes should be kept and put under version control. The easiest way to stage the changes is to use:</p>
<p>            git add -p</p>
<p>That will bring up an interactive session that presents you with all the changes and lets you decide to stage them or not. As we haven't made many changes so far, this interactive session should be short. Now we can enter:</p>
<p>            git commit -m "initial commit"</p>
<p>The letter "m" means "message", and the string after "-m" is the message to describe the commit.</p>
<p>After committing, the staged changes (by the "git add" command) are now placed in the local Git repository. The next step is to push it to the remote repository. Using the command below will do this:</p>
<p>            git push peterpanssh HEAD:develop</p>
<p>In this case, "peterpanssh" is the remote repository name registered with the local Git, and "develop" is the branch that you would like to push the code to. </p>
<p><u><strong>Step Five: Develop the Software Package</strong></u></p>
<p>So far, we have built the entire infrastructure for hosting the local project, controlling the software versions both locally and remotely. Now it's time to work on the code in the package. To put the changes under version control (when you’re done with the project, or any time you think it’s needed), use:</p>
<p>            git add -p<br/>
            git commit -m "messages"<br/>
            git push repo_name HEAD:repo_branch</p>
<p><u><strong>Step Six: Write setup.py</strong></u></p>
<p>When your code package has reached a certain level of maturity, you can consider releasing it for distribution. A distribution may contain one or multiple packages that are meant to be installed at the same time. A designated<em>setup.py</em> file is required to be present in the folder that contains the package(s) to be distributed. Earlier, when we created the project structure, we already created an empty setup.py file. Now it's time to populate it with content. </p>
<p>A setup.py file contains at least the following information:</p>
<p><em>           </em>from setuptools import setup, find_packages<br/><em>           </em>setup(name='eglearning',<br/><em>           </em>packages=find_packages()<br/>
           )</p>
<p>There are a few distribution tools in Python. The standard tool for packaging in Python is distutils, and setuptools is an upgrade of distutils, with more features. In the setup() function, the minimum information we need to supply is the name of the distribution, and what packages are to be included. The function find_packages() will recursively go through the current folder and its sub-folders to collect package information, as long as a __init__.py is found in a package folder.</p>
<p>It is also helpful to provide the meta data for the distribution, such as version, a description of what the distribution does, and author information. If the distribution has dependencies, it is recommended to include the installation requirements in setup.py. Therefore, it may end up looking like this:</p>
<p><em>          </em><em> </em>from setuptools import setup, find_packages<br/><em>           </em>setup(name='eglearning',<br/><em>           </em><em>           </em>version='0.1a',<br/><em>           </em><em>           </em>description='a machine learning package developed at Endgame',<br/><em>           </em><em>           </em>packages=find_packages(),<br/><em>           </em><em>           </em>install_requires=[<br/><em>           </em><em>           </em><em>           </em>'Pandas&gt;=0.14',<br/><em>           </em><em>           </em><em>           </em>'Numpy&gt;=1.8',<br/><em>           </em><em>           </em><em>           </em>'scikit-learn&gt;=0.13',<br/><em>           </em><em>           </em><em>           </em>'elasticsearch',<br/><em>           </em><em>           </em><em>           </em>'pyes',<br/><em>           </em><em>           </em>],<br/><em>           </em>)</p>
<p>To write more advanced setup.py, <a href="https://docs.python.org/2/distutils/setupscript.html" target="_blank">Python documentation</a> or this <a href="http://www.siafoo.net/article/77" target="_blank">web page</a> are good resources.</p>
<p>When you are done with setup.py, commit the change and push it to the remote repository by typing the following commands:</p>
<p><em>           </em>git add -p<br/><em>           </em>git commit -m 'modified setup.py'<br/><em>           </em>git push peterpanssh HEAD:develop</p>
<p><u><strong>Step Seven: Merge Branch Develop to Master</strong></u></p>
<p>According to Python engineer <a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank">Vincent Driessen</a>, "we consider origin/master to be the main branch where the source code of HEAD always reflects a production-ready state." When the code in the develop branch enters the production-ready state, it should be merged into the master branch. To do this, simply type in the terminal under the project directory:</p>
<p><em>          </em><em> </em>git checkout master<br/><em>           </em>git merge develop</p>
<p>Now we can push the master branch to the remote repository:</p>
<p><em>          </em><em> </em>git push peterpanssh</p>
<p><u><strong>Step Eight: Install the Distribution from the Remote Repository</strong></u></p>
<p>The Python package management tool "pip" supports the installation of a package distribution from a remote repository such as GitHub, or a private remote repository. pip currently supports cloning over the protocols of git, https and ssh. Here we will use ssh.</p>
<p>You may choose to install from a specific commit (identified by a MD5 check-sum) or whatever the latest commit in a branch. To specify a commit for cloning, type:</p>
<p><em>           </em>sudo pip install -e git://github.com/richardxy/peterpan.git@4e476e99ce2649a679828cf01bb6b3fd7856281f#egg=MLM0.01</p>
<p>In this case, "github.com/richardxy/peterpan.git" is the ssh clone URL with ":" after ".com" being replaced with "/". This is tricky and it won't work if you omitted the replacement. The parameter "egg" is also a requirement. The value is up to you.</p>
<p>If you opt to clone the latest version in the branch (e.g. “develop” branch), type:</p>
<p><em>           </em>sudo pip install -e git://github.com/richardxy/<a href="mailto:peterpan.git@develop">peterpan.git@develop</a>#egg=MLM0.02</p>
<p>You only need to specify the branch name after "@" and before "egg" parameter. This is my preferred method.</p>
<p>Then pip will check if the installation requirements are met and install the dependencies and the package for you. Once it's done, type: </p>
<p><em>          </em><em> </em>pip freeze</p>
<p>to find the newly installed package. You will see something like this:</p>
<p><em>           </em>-e git://github.com/richardxy/peterpan.git@2251f3b9fd1b26cb41526f394dad81016d099b03#egg=eglearning-develop</p>
<p>Here, 2251f3b9fd1b26cb41526f394dad81016d099b03 is the MD5 checksum of the latest commit. </p>
<p>Type the command below to create a requirements document that registers all of the installed packages and versions. </p>
<p><em>          </em><em> </em>pip freeze &gt; requirements.txt</p>
<p>Then open requirements.txt, replace the checksum with the branch name, such as “develop”, and save it. The reason for doing that is, the next time when a user tries to install the package, there might be new commit and therefore the MD5 would have changed. Using the branch name will always point to the latest commit in that branch.</p>
<p>One caveat: if virtualenv is used, the pip freeze command should look like this so that only the configurations in the virtual environment will be captured:</p>
<p><em>           </em>pip freeze -l &gt; requirements.txt</p>
<p><u><strong>Conclusion</strong></u></p>
<p>This tutorial covers the most fundamental and essential procedures for creating a Python project, applying version control during the development, packaging the code, distributing it over code-sharing repositories, and installing the package via cloning the source code. Following this process can help non-computer science-trained data scientists get more comfortable using well-known collaborative tools like Python for software development and distribution.</p>
</div></div></body></html>