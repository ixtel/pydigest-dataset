<html><body><div><div class="post-text" itemprop="text">
<p>Ok, here's an alternative using <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow">concurrent.futures</a> which also utilizes <code>multiprocessing</code> under its hood but imho comes with a much nicer interface than <code>multiprocessing</code>. It even allows you to easily switch from multiprocessing to multithreading.</p>

<p>It is pretty simple. First you create define some jobs that you'd like to have executed in parallel to some extend. <code>max_workers</code> defines the number of maximum parallel threads/processes the <code>executor</code> will spawn. Then you <code>submit</code> your jobs to the <code>executor</code> which will take care of executing them in parallel (up to <code>num_wookrers</code> of parallel threads/processes). You can either poll the futures status or use <code>concurrent.futures.as_completed(submitted_futures)</code> to yield them as they finish.</p>

<p>Here's a generic example:</p>

<pre><code>with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
    jobs = [executor.submit(d.sum,1,2),
            executor.submit(d.diff,2,1,),
            executor.submit(d.mull,1,2),
            executor.submit(d.division,10,5),
            executor.submit(d.sum,1,12),
            executor.submit(d.diff,12,1),
            executor.submit(d.mull,11,2),
            executor.submit(d.division,10,15),
            executor.submit(d.sum,11,12),
            executor.submit(d.diff,12,1),
            executor.submit(d.mull,11,2),
            executor.submit(d.division,110,5),
            ]
    for future in concurrent.futures.as_completed(jobs):
        try:
            print ('%r result with: %s'%(future,future.result()))
        except Exception as exc:
            print('%r generated an exception: %s' % (future, exc))
</code></pre>

<p>To be honest, I could not follow your code as it simply did not make any sense to me. By now I think you'd like to run all these arith. functions in parallel and store the results within an object. So here's something that might get close to what you want to achieve. </p>

<pre><code>def parallel_exec_store_result(method):
    @wraps(method)
    def wrapped(self, *args, **kwargs):
        return self.add_job(method,*args,**kwargs).result()
    return wrapped

class ThreadedResults(object):
    def __init__(self, max_workers=2):
        self.results = defaultdict(dict)
        self.executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)

    def add_job(self, fn, *args, **kwargs):
        ts_start = time.time()
        future = self.executor.submit(fn, self, *args, **kwargs)
        self.results[future]['job']=(fn,args,kwargs)
        self.results[future]['ts_start']=ts_start
        return future

    def get_results(self):
        for future in concurrent.futures.as_completed(self.results):
            yield self.results[future], future

    @parallel_exec_store_result
    def sum(self, a, b):
        return a + b

    @parallel_exec_store_result
    def diff(self, a, b):
        return a - b

    @parallel_exec_store_result
    def mull(self, a, b):
        return a * b

    @parallel_exec_store_result
    def division(self, a, b):
        return a / b


if __name__ == '__main__':
    d = ThreadedResults(max_workers = 2)
    d.sum(1,2)
    d.diff(2,1)
    d.mull(1,2)
    d.division(10,5)
    d.sum(1,12)
    d.diff(12,1)
    d.mull(11,2)
    d.division(10,15)
    d.sum(11,12)
    d.diff(12,1)
    d.mull(11,2)
    d.division(110,5)

    for resultstruct, future in d.get_results():
        print resultstruct, future, future.result()
</code></pre>

<p>which outputs the result dict that tracks the execution, the future itself and the futures result.</p>

<pre><code>{'job': (&lt;function division at 0x01ED1870&gt;, (110, 5), {}), 'ts_start': 1448053043.529} &lt;Future at 0x1ed7810 state=finished returned int&gt; 22
{'job': (&lt;function mull at 0x01ED17F0&gt;, (11, 2), {}), 'ts_start': 1448053043.528} &lt;Future at 0x1ed7630 state=finished returned int&gt; 22
{'job': (&lt;function diff at 0x01ED1770&gt;, (12, 1), {}), 'ts_start': 1448053043.528} &lt;Future at 0x1ed75d0 state=finished returned int&gt; 11
{'job': (&lt;function sum at 0x01ED16F0&gt;, (1, 2), {}), 'ts_start': 1448053043.527} &lt;Future at 0x1ed7270 state=finished returned int&gt; 3
{'job': (&lt;function division at 0x01ED1870&gt;, (10, 15), {}), 'ts_start': 1448053043.528} &lt;Future at 0x1ed7690 state=finished returned int&gt; 0
{'job': (&lt;function diff at 0x01ED1770&gt;, (2, 1), {}), 'ts_start': 1448053043.527} &lt;Future at 0x1ed72d0 state=finished returned int&gt; 1
{'job': (&lt;function sum at 0x01ED16F0&gt;, (11, 12), {}), 'ts_start': 1448053043.529} &lt;Future at 0x1ed76f0 state=finished returned int&gt; 23
{'job': (&lt;function division at 0x01ED1870&gt;, (10, 5), {}), 'ts_start': 1448053043.528} &lt;Future at 0x1ed7510 state=finished returned int&gt; 2
{'job': (&lt;function diff at 0x01ED1770&gt;, (12, 1), {}), 'ts_start': 1448053043.529} &lt;Future at 0x1ed7750 state=finished returned int&gt; 11
{'job': (&lt;function sum at 0x01ED16F0&gt;, (1, 12), {}), 'ts_start': 1448053043.528} &lt;Future at 0x1ed7570 state=finished returned int&gt; 13
{'job': (&lt;function mull at 0x01ED17F0&gt;, (11, 2), {}), 'ts_start': 1448053043.529} &lt;Future at 0x1ed77b0 state=finished returned int&gt; 22
{'job': (&lt;function mull at 0x01ED17F0&gt;, (1, 2), {}), 'ts_start': 1448053043.528} &lt;Future at 0x1ed73d0 state=finished returned int&gt; 2
</code></pre>

<p>Note that you can just simply replace <code>ThreadPoolExecutor</code> with <code>ProcessPoolExecutor</code> but you'll get a pickling error when trying to use the <code>ProcessPoolExecutor</code> (or multiprocessing itself) in combination with instance- or nested-methods. Therefore I'd recommend to use threading instead. If you insist on using multiprocessing you should have a look at <a href="https://stackoverflow.com/questions/1816958/">the answers to this question</a>. </p>
    </div>
    </div></body></html>