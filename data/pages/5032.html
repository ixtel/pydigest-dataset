<html><body><div><div class="entry">
    <p>When scraping websites using a headless browser, if it is possible to call the XMLHttpRequest call using <a href="https://github.com/cryzed/Selenium-Requests">Selenium Requests</a> which is an extension of <a href="http://docs.python-requests.org/en/latest/">Selenium-Requests</a>. The Selenium Requests Library works by creating a small webserver, spawning another selenium window and copying all of the browser cookies. The solution is ingenious, and making calls with the requests library makes things a lot easier.</p>

<p>These are the possible pitfalls when using Selenium Requests</p>

<ul>
<li> When selenium requests spawns the extra selenium windows to get the cookies this takes time.</li>
<li>When doing repeated XMLHttpRequest calls, it does not seem to update the cookies, in certain cases it does not work.</li>
<li>On rare occasions it can crash the headless browser.</li>
</ul>

<p>Selenium requests is a great addon to to python selenium, and I use it frequently. It is in the cases when Selenium Requests does not work that I am talking about.</p>

<p>Recently a client asked me to scrape results from kickstarter. In this case he wanted all <a href="http://nbviewer.ipython.org/gist/johnpauljanecek/3446d11bed47b3b12b27">kickstarter projects which are card games in the USA</a>. I was able to locate the XMLHttpRequest, but is sets an anti-xss token on one of the headers. I located where the token is in the webpage and extracted it, but when I set the headers, the request would fail. But when I called the request from within firebug, it worked fine. Inclued in this post is a ipython notebook which explains the technique I used to solve the problem. <a href="http://nbviewer.ipython.org/gist/johnpauljanecek/3446d11bed47b3b12b27">IPython notebook demonstrating the technique</a></p>

<p>The important function in example is in SearchPage.doajaxresultsrequest with this piece of javascript code.</p>

<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><code class="language-javascript" data-lang="javascript"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</code></pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">_jsonResult</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">token</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'meta[name = "csrf-token"]'</span><span class="p">).</span><span class="nx">getAttribute</span><span class="p">(</span><span class="s2">"content"</span><span class="p">);</span>
        
        <span class="kd">var</span> <span class="nx">xmlhttp</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
    
        <span class="nx">xmlhttp</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">xmlhttp</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="nx">xmlhttp</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">window</span><span class="p">.</span><span class="nx">_jsonResult</span> <span class="o">=</span> <span class="nx">jsonResult</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">xmlhttp</span><span class="p">.</span><span class="nx">responseText</span><span class="p">);</span>
            <span class="p">}}</span>

        <span class="nx">xmlhttp</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">"GET"</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
        <span class="nx">xmlhttp</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s2">"X-CSRF-Token"</span><span class="p">,</span><span class="nx">token</span><span class="p">);</span>
        <span class="nx">xmlhttp</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s2">"X-Requested-With"</span><span class="p">,</span><span class="s2">"XMLHttpRequest"</span><span class="p">)</span>
        <span class="nx">xmlhttp</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s2">"Accept"</span><span class="p">,</span><span class="s2">"application/json, text/javascript, */*; q=0.01"</span><span class="p">)</span>
        <span class="nx">xmlhttp</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>

        <span class="k">return</span> <span class="kc">true</span><span class="p">;;</span>
</pre></div>
</td></tr></table>

<p>The url is pulled off the arguments array, the xss token is extracted from the document,and then the XMLHTTPRequest call is setup and called. I decided not to wait for the XMLHTTPRequest call to complete, but instead store the result in window._jsonResult.</p>

<p>A second call is then made with  getajaxresult to return the result. In this case the XMLHttpRequest is parsed into json before it is stored, that means when the result is fetched by python there is no need to parse it with JSON.</p>

<p>The first example uses the browser class of my <a href="http://johnpauljanecek.github.io/controlling-docker-containers-with-python-rpyc/">docker_rpyc module</a> . The second example uses the worker class of my rpyc_docker module which means the browser is running totally headless and isolated within a docker container. Since my library uses rpyc the code is almost identical, and the same SearchPage class in the same namespace can be used. It is also possible to run multiple isolated headless browsers.</p>

<h1>Possible improvements on the technique.</h1>

<ul>
<li>Instead of making two calls to get the result, wait till the XMLHttpRequest finishes before returning, I am not really sure if this is an improvement.</li>
<li>Have the XMLHttpRequest call save the status of the request instead of just saving the result.</li>
<li>Have an array which stores XMLHttpRequests, and then repeatedly call the request function. Since javascript is able to do asycronous requests this would probably be a lot quicker for multiple XMLHttpRequests.</li>
<li>A similar technique can be used to hook HMLHttpRequests, and then intercepting the results.</li>
</ul>

<h1>Why this matters ?</h1>

<p>In the past scraping web pages could be done with just curl and raw http requests. But websites have transformed from a series of static pages, into applications running inside a web browser. As a result new web scraping techniques need to be developed. From my experience the hybrid method of web scraping websites is highly effective. So a combination of raw http calls, running headless browsers and injecting javacripts.</p>

  </div>

  </div></body></html>