<html><body><div><div class="content">

    <p>
For Linux users, the command line is a celebrated part of our entire
experience. Unlike other popular operating systems, where the command
line is a scary proposition for all but the most experienced veterans, in
the Linux community, command-line use is encouraged. Often the command
line can provide a more elegant and efficient solution when compared
to doing a similar task with a graphical user interface.
</p>


<p>
As the Linux community has grown up with a dependence on the command line,
UNIX shells, such as bash and zsh, have grown into extremely formidable
tools that complement the UNIX shell experience. With bash and other
similar shells, a number of powerful features are
available, such as piping, filename wild-carding and the ability to read
commands from a file called a script. 
</p>

<p>
Let's look at a real-world example to
demonstrate the power of the command line. Every time users log in to
a service, their user names are logged to a text file. For this example,
let's find out how
many unique users use the service.
</p>

<p>
The series of commands in the following example show the power of more complex
utilities by chaining together smaller building blocks:

</p><pre><code>
$ cat names.log | sort | uniq | wc -l
</code></pre>


<p>
The pipe
symbol (|) is used to pass the standard output of one command into the
standard input of the next command. In the example here, the output of
<code>cat
names.txt</code> is passed into the <code>sort</code>
command. The output of the <code>sort</code>
command is each line of the file rearranged in alphabetical order. This
subsequently is piped into the <code>uniq</code> command, which removes any duplicate
names. Finally, the output of <code>uniq</code> is passed to the
<code>wc</code> command. <code>wc</code>
is a counting command, and with the <code>-l</code> flag set, it
returns the number of
lines. This allows you to chain a number of commands together.
</p>

<p>
However, sometimes what is needed can become quite complex, and chaining
commands together can become unwieldy. In that case, shell
scripts are the answer. A shell script is a list of commands that are read
by the shell and executed in order. Shell scripts also support some
programming language fundamentals, such as variables, flow control and
data structures. Shell scripts can be very useful for batch jobs that
will be run often and repeatedly. Unfortunately, shell scripts come with
some disadvantages:
</p>

<ul><li>
<p>
Shell scripts easily can become overly complicated and unreadable to
a developer wanting to improve or maintain them.
</p></li>

<li>
<p>
Often the syntax and interpreter for these shell scripts can be
awkward and unintuitive. The more awkward the syntax, the less readable
it is for the developer who must work with these scripts.
</p></li>

<li>
<p>
The code is generally unusable in other scripts. Code reuse among
scripts tends to be difficult, and scripts tend to be very specific to
a certain problem.
</p></li>

<li>
<p>
Libraries for advanced features, such as HTML parsing or HTTP requests,
are not as easily available as they are with modern programming and scripting
languages.
</p></li></ul>

<p>
These problems can make shell scripting an awkward undertaking and often
can lead to a lot of wasted developer time. Instead, the Python programming
language can be used as a very able replacement. There are many benefits
to using Python as a replacement for shell scripts:
</p>

<ul><li>
<p>
Python is installed by default on all the major Linux
distributions. Opening a command line and typing
<code>python</code> immediately will drop you
into a Python interpreter. This ubiquity makes it a sensible
choice for most scripting tasks.
</p></li>

<li>
<p>
Python has a very easy to read and understand syntax. Its style 
emphasizes minimalism and clean code while allowing the developer
to write in a bare-bones style that suits shell scripting.
</p></li>

<li>
<p>
Python is an interpreted language, meaning there is no compile
stage. This makes Python an ideal language for scripting. Python also
comes with a Read Eval Print Loop, which allows you to try out
new code quickly in an interpreted way. This lets the developer tinker with
ideas without having to write the full program out into a file.
</p></li>

<li>
<p>
Python is a fully featured programming language. Code reuse is
simple, because Python modules easily can be imported and used in any Python
script. Scripts easily can be extended or built upon.
</p></li>

<li>
<p>
Python has access to an excellent standard library and thousands of
third-party libraries for all sorts of advanced utilities, such as parsers
and request libraries. For instance, Python's standard library includes
datetime libraries that allow you to parse dates into any format
that you specify and compare it to other dates easily.
</p></li>

<li>
<p>
Python can be a simple link in the chain. Python should not replace
all the bash commands. It is as powerful to write Python programs
that behave in a UNIX fashion (that is, read in standard input and write
to standard output) as it is to write Python replacements for existing shell
commands, such as cat and sort.
</p></li></ul>

<p>
Let's build on the problem that was solved earlier in this article.
Besides the work
already done, let's find out know how many times a certain user has logged
in to the system. The <code>uniq</code> command simply removes duplicates but gives no information
on how many duplicates there are. Instead of <code>uniq</code>, a Python script
can be used as another command in the chain. Here's a Python program to do
this (in my examples, I refer to this file as namescount.py):

</p><pre><code>
#!/usr/bin/env python
import sys

if __name__ == "__main__":
    # Initialize a names dictionary as empty to start with.
    # Each key in this dictionary will be a name and the value
    # will be the number of times that name appears.
    names = {}
    # sys.stdin is a file object. All the same functions that
    # can be applied to a file object can be applied to sys.stdin.
    for name in sys.stdin.readlines():
            # Each line will have a newline on the end
            # that should be removed.
            name = name.strip()
            if name in names:
                    names[name] += 1
            else:
                    names[name] = 1

    # Iterating over the dictionary,
    # print name followed by a space followed by the
    # number of times it appeared.
    for name, count in names.iteritems():
            sys.stdout.write("%d\t%s\n" % (count, name))
</code></pre>


<p>
Let's look at how this Python script fits into the chain of
commands. First, it reads in input from standard input exposed through
the sys.stdin object. Any output is written to the sys.stdout object, which
is how standard output is implemented in Python. A Python dictionary
(often called a hash map in other languages) is used to get a mapping
from the user name to the duplicate count. To get a count of all the users,
execute the following:

</p><pre><code>
$ cat names.log | python namescount.py
</code></pre>


<p>
This displays a count of how many times a user appears along with
the user's name using a tab as a separator. The next thing to do is
display,
in order, the users who used the system most often. This can be done at
the Python level, but let's implement it using the utilities that are
already provided by the core UNIX utilities. Previously, I used the
<code>sort</code> command to sort alphabetically. If the command is provided with a
<code>-rn</code> flag, it sorts the lines numerically, in
descending order. As
the Python script prints to standard out, you simply can pipe the command
into <code>sort</code> and retrieve the output you want:

</p><pre><code>
$ cat names.log | python namescount.py | sort -rn
</code></pre>


<p>
This is an example of the power of using Python as part of a chain of
commands. The advantages of using Python in this scenario are as follows:
</p>

<ul><li>
<p>
The ability to chain with tools like cat and sort. Simple utilities
(reading a file line by line and sorting a file numerically) are handled
by tried-and-trusted UNIX commands. These commands also are reading line
by line, which means these functions can scale to files that are large
in size, and they are very quick.
</p></li>

<li>
<p>
When some heavy-lifting is needed in the chain, a very clear, concise
Python script can be written, which does what it needs to do and then
offloads the responsibility to the next link in the chain.
</p></li>

<li>
<p>
It is a reusable module, although this example is specifically about names,
if you feed this any input that contains duplicate lines, it
will print out each line and the number of duplicates. Making the Python
code modular allows you to apply it in a range of scenarios.
</p></li></ul>
  </div>
      </div></body></html>