<html><body><div><div class="post-header">
<p class="post-author vcard">
Posted by
<span class="fn" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person">
<meta content="https://plus.google.com/116771000414090157228" itemprop="url"/>
<a class="g-profile" href="https://plus.google.com/116771000414090157228" rel="author" title="author profile">
<span itemprop="name">Kannan Ponnusamy</span>
</a>
</span>
<span>|</span><span class="post-date">January 28, 2015</span>
<br/>
<span>Tags:
		
<a href="http://blog.endpoint.com/search/label/bash">bash</a>,
<a href="http://blog.endpoint.com/search/label/python">python</a>
</span>
</p>
</div>
<div class="post-body entry-content" id="post-body-40999697215220214" itemprop="description articleBody">
<div dir="ltr" trbidi="on"><h3>The Problem </h3><p>When I launch a long running unix process within a python script, it waits until the process is finished, and only then do I get the complete output of my program. This is annoying if I'm running a process that takes a while to finish. And I want to capture the output and display it in the nice manner with clear formatting.
</p><h3>Using the subprocess and shlex library </h3><p>Python has a “batteries included” philosophy. I have used 2 standard libraries to solve this problem.
</p><pre class="brush:python">import subprocess 
import shlex 
</pre><ul><li> subprocess - Works with additional processes<br/>
</li>
<li> shlex      - Lexical analysis of shell-style syntaxes </li>
</ul><h3>subprocess.popen </h3><p>To run a process and read all of its output, set the stdout value to PIPE and call communicate().
</p><pre class="brush:python">import subprocess
process = subprocess.Popen(['echo', '"Hello stdout"'], stdout=subprocess.PIPE)
stdout = process.communicate()[0]
print 'STDOUT:{}'.format(stdout)
</pre><p>The above script will wait for the process to complete and then it will display the output. So now we are going to read the stdout line by line and display it in the console untill it completes the process. 
</p><pre class="brush:python">output = process.stdout.readline()
</pre><p>This will read a line from the stdout.
</p><pre class="brush:python">process.poll()
</pre><p>The poll() method will return
</p><ul><li>the exit code if the process is completed.</li>
<li> None if the process is still running.</li>
</ul><pre class="brush:python">while True:
        output = process.stdout.readline()
        if output == '' and process.poll() is not None:
            break
        if output:
            print output.strip()
    rc = process.poll()
</pre><p>The above will loop and keep on reading the stdout and check for the return code and displays the output in real time. </p><p>
I had one more problem in parsing the shell commands to pass it to popen when I set the shell=False.  Below is an example command:
</p><pre class="brush:bash">rsync -avzXH --delete --exclude=*.swp --exclude=**/drivers.ini /media/lgisos/lg.iso root@42-a:/isodevice
</pre><p>To split the string using shell-like syntax I have used shlex library's split method.
</p><h3>Here is the final code looks like </h3><pre class="brush:python">def run_command(command):
    process = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE)
    while True:
        output = process.stdout.readline()
        if output == '' and process.poll() is not None:
            break
        if output:
            print output.strip()
    rc = process.poll()
    return rc
</pre></div>
<p/>
</div>
</div></body></html>