<html><body><div><article>
            <p>This morning I realized something incredibly stupid. Stupid, because
it has no real value except as a curiosity–which is to say, its
perfect for this blog, which has featured <a href="http://sigusr2.net/dispatching-with-with.html">other</a>,
<a href="http://sigusr2.net/python-worlds.html">things</a>, of a <a href="http://sigusr2.net/pattern-matching-with-with.html">similar</a> <a href="http://sigusr2.net/call-cc-for-python.html">nature</a>.</p>

<p>Anyone familiar with Python and functional programming, will lambast
Python for its measly one-line anonymous functions. What if they could
do more?  Well, they can! And, they can even introduce lexically
scoped bindings as one would get if they had just used a better
language to begin with, all in a “somewhat”<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> nice, easy, and
clean way.</p>

<p>I present to you, a one-line<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> echo server that will eventually
exhaust all of your memory, and slow to a crawl…</p>

<pre><code>import socket
import itertools

(lambda port=9000, s=socket.socket(socket.AF_INET, socket.SOCK_STREAM):
      s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) == None and 
      s.bind(('', port)) == None and
      s.listen(5) == None and
      list(map(lambda c:
                  c[0].sendall(c[0].recv(1024)) and
                  c[0].close(),
               (s.accept() for _ in itertools.count(1)))))()
</code></pre>

<p>Wait, what? Yeah. Something special, isn’t it? There’s a lot going
on here, so let’s break it down a bit.</p>

<pre><code>lambda port=9000, s=socket.socket(socket.AF_INET, socket.SOCK_STREAM):
</code></pre>

<p>This is the best part of the trick, and the reason I threw in “let” in
the title. In lexically scoped languages, such as Scheme, it’s common
to see the use of the <code>let</code> form which introduces new bindings that are
lexically bound, <em>i.e.</em>, local to the body of the <code>let</code> expression. These
are isomorphic to “block-scoped” variables one might find in other
languages.</p>

<pre><code>(let ((port 9000))
   &lt;some body&gt;)
</code></pre>

<p>In Scheme, the above <code>let</code> defines <code>port</code> only within <code>&lt;some
body&gt;</code>. That construct is isomorphic to the following Scheme (and in
fact many implementations just macro expand <code>let</code> into this):</p>

<pre><code>((lambda (port) &lt;some body&gt;) 9000)
</code></pre>

<p>We utilize default arguments to assign names to values in the Python
version, and exploit the fact that a <code>lambda</code> by itself doesn’t bind
to a name as <code>def</code> does<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>, and doesn’t commonly appear in the global
scope.  What this means is that our “bindings” are evaluated when the
anonymous function is created, which means it’s safe to use within a
loop, or some other nested scope.</p>

<p>This <code>lambda</code> perversion, therefore, is isomorphic to the following Python:</p>

<pre><code>(lambda port: &lt;utilize port somehow&gt;)(9000)
</code></pre>

<p>Now, that we’ve established this baseline, let’s move on.</p>

<pre><code>s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) == None and 
s.bind(('', port)) == None and
s.listen(5) == None and
</code></pre>

<p>Here, we exploit the fact that the <code>and</code> operator evaluates all of its
operands provided they return truthy values. Since these functions return
<code>None</code>, we just check to see if they returned <code>None</code> and continue to the
next statement. This is of course roughly isomorphic to the following:</p>

<pre><code>s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.bind(('', port))
s.listen(5)
</code></pre>

<p>Simple enough.</p>

<p>Continuing on, we get to the trickiest part of it all:</p>

<pre><code>list(map(lambda c:
             c[0].sendall(c[0].recv(1024)) and
             c[0].close(),
         (s.accept() for _ in itertools.count(1))))
</code></pre>

<p>Ignoring the outer <code>list</code> for now, we see a simple call to <code>map</code>,
which maps the <code>lambda</code> over the values produced by the generator
expression. The generator expression produces an infinite list
connected sockets, but since <code>s.accept()</code> blocks until a client is
connected, this implements a typical listen-accept loop. The roughly
isomorphic, plain ole Python looks like so:</p>

<pre><code>while True:
    c = s.accept()
    c[0].sendall(c[0].recv(1024))
    c[0].close()
</code></pre>

<p>Why roughly? Because <code>map</code> is lazily evaluated, and produces a <em>new</em>
generator. We need a forcing function in order for each connected
socket to be applied to the <code>lambda</code> we have passed to the <code>map</code>
call. Enter <code>list</code> which does that beautifully, though <em>ensures</em> that
we’ll eventually completely exhaust memory if we accept a lot of
connections. That list being generated will store the value <code>None</code> for
every client that exists.</p>

<p>The only thing left to do is invoke our echo server, by wrapping <code>()</code> around
the <code>lambda</code> and tacking on <code>()</code> to call it.</p>

<p><strong>Update:</strong> <a href="https://lobste.rs/s/ayd1md/a_one_line_echo_server_using_let_in_python/comments/akgbj5#c_akgbj5">trousers</a> suggested that a <code>set</code> comprehension could
avoid the catastrophic unbounded memory problem present with the call to <code>list</code>.
No <code>set</code> comprehension, however, should be necessary if we just instead change
<code>list</code> to <code>set</code>.</p>



            <p class="signoff">— 2014-11-12</p>
         </article>
      </div></body></html>