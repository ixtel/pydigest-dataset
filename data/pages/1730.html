<html><body><div><div class="layoutArea">
<p class="column">
Он в корне отличается от иерархической кластеризации, поскольку ему нужно заранее указать, сколько кластеров генерировать. Алгоритм определяет размеры кластеров исходя из структуры данных.<span><br/></span>

  
 
 
  Кластеризация методом K-средних начинается с выбора k случайно расположенных центроидов (точек, представляющих центр кластера). Каждому элементу назначается ближайший центроид. После того как назначение выполнено, каждый центроид перемещается в точку, рассчитываемую как среднее по всем приписанным к нему элементам. Затем назначение выполняется снова. Эта процедура повторяется до тех пор, пока назначения не прекратят изменяться.</p>
<div class="separator">
<a href="http://1.bp.blogspot.com/-nxP0E5zJu0c/VDb6HgkivJI/AAAAAAAAASk/52OIqOKvKaU/s1600/2014-10-10%2B01-11-44%2Bbook.uz%2Bwp-content%2Buploads%2B2010%2B10%2Bkol_razum.pdf.png" imageanchor="1"><img border="0" src="http://1.bp.blogspot.com/-nxP0E5zJu0c/VDb6HgkivJI/AAAAAAAAASk/52OIqOKvKaU/s1600/2014-10-10%2B01-11-44%2Bbook.uz%2Bwp-content%2Buploads%2B2010%2B10%2Bkol_razum.pdf.png"/></a></div>
<p class="column">
На первом шаге случайно размещены два центроида (изображены темными кружками). На втором шаге каждый элемент приписан к ближайшему центроиду. В данном случае A и B приписаны к верхнему центроиду, а C, D и E – к нижнему. На третьем шаге каждый центроид перемещен в точку, рассчитанную как среднее по всем приписанным к нему элементам. После пересчета назначений оказалось, что C теперь ближе к верхнему центроиду, а D и E – по-прежнему ближе к нижнему. Окончательный результат достигается, когда A, B и C помещены в один кластер, а D и E – в другой.
    </p>
<div class="column">
<p>
В данном методе, ОЧЕНЬ важен выбор центроидов, т.к. в конечном итоге все точки к ним стянутся, но если все 4 будут очень близкие цвета и из них будут состоять большие области, то в конечном итоге вы и получите приблизительно одинаковые центры. Таким образом центроиды должны быть максимально разнесены (желательно равномерно и равноудаленно).
</p><p>
Для большего понимания приведу пример. Давайте рассмотрим такую картинку.

</p>
<p>
Чтобы решить поставленную задачу в такой, монотонной четко разделенной картинке, достаточно написать небольшой код:
</p></div>
<pre class="brush: python">def k_cluster_by_area(points, k=4):

 clusters_by_area = {}

 for point in points:
  clusters_by_area[point] = clusters_by_area.setdefault(point, 0) + 1

 sorted_x = sorted(clusters_by_area.items(), key=operator.itemgetter(1))

 return sorted_x[-k:]
</pre>
<p class="column">
<br/>
Тут мы просто посчитали, сколько раз, какой цвет встречается, отсортировали и вывели k результатов. Этот метод можно применить к любому изображению, работает достаточно быстро, но есть НО! А именно, мы не получим ТОНАЛЬНОСТЬ картинки! Однако, как я писал выше, в нашей задаче важны центры, вот эту задачу и решает этот код!) Мы берем самые популярные цвета, за изначальные центры кластеров, а потом они постепенно мутируют) На самом деле, желательно брать не просто первые k, а посчитать все комбанации расстояний и выбрать k по макс расстояниям, чтобы центры не оказались рядом (например 2 оттенка серого). Но мне влом и вы сделаете это сами)<br/>
<br/>
Надеюсь, стало яснее. Таким образом, как найти изначальные центры кластеров нам известно, осталось только свести все пиксели в эти точки.  А теперь сам код: </p>
<p class="column">
<br/></p>
<pre class="brush: python">def k_cluster(img, distance=euclidean, k=4):
 
 points = get_points(img)
 clusters = {}

 # центры кластеры
 cluster_centers = k_cluster_by_area(points, k)
 for cluster_center in cluster_centers:
  # avg_sum_coords - список сумм r, g, b координат всех пикселей кластера
  # count_points - кол-во пикселей в кластере
  # какие конкретно пиксели в кластере не запоминаем в целях экономии памяти и времени
  clusters[cluster_center] = {'avg_sum_coords':list(cluster_center), 'count_points':1}

 while len(points):

  # находим ближайшие точки к центрам кластеров
  bestmatches = {}
  for point in points:

   # расстояние каждой точки до каждого центра кластера
   for cluster_center in clusters:
    d = distance(cluster_center, point)
    if not bestmatches:
     bestmatches = {'distance':d, 'point': point, 'cluster_center': cluster_center}

    if d &lt; bestmatches['distance']:
     bestmatches = {'distance': d, 'point': point, 'cluster_center': cluster_center}

  # перекидываем ближайшие точки в соответствующий кластер
  bestmatch = bestmatches['point']
  cluster_center = bestmatches['cluster_center']
  points2 = []
  new_points = []

  for point in points:
   if point == bestmatch:
    new_points.append(point)
   else:
    points2.append(point)


  points = points2[:]

  # меняем центр кластера
  print clusters.keys(), len(points)

  r_avg, g_avg, b_avg = 0, 0, 0
  cluster_avg_coord = clusters[cluster_center]['avg_sum_coords']

  new_points_len = len(new_points)
  clusters[cluster_center]['count_points'] += new_points_len
  claster_count_points = clusters[cluster_center]['count_points']

  cluster_avg_coord[0] += bestmatch[0]*new_points_len
  cluster_avg_coord[1] += bestmatch[1]*new_points_len
  cluster_avg_coord[2] += bestmatch[2]*new_points_len


  new_center = cluster_avg_coord[0]/claster_count_points, cluster_avg_coord[1]/claster_count_points, cluster_avg_coord[2]/claster_count_points
  
  # если новый центр кластера отличается от предыдущего
  if not new_center in clusters:
   clusters[new_center] = clusters.pop(cluster_center)

 return clusters.keys()
</pre>
<div class="column">
<p>
Работает это дело не быстро ;(, поэтому я советую сжимать картинку, хотя бы до разрешения 100 на 100.</p><p>
Понятно, что идея не нова и сравнить вы можете, например с данным сайтом </p><a href="http://design-seeds.com/">http://design-seeds.com</a><p>
Давайте разберем пример. С указанного выше сайта взяли картинку и их разбиение на цвета. Здесь можно заметить, что их задача - это выбрать основные центровые цвета, что немного отличается от нашей задачи, но все же.

</p><hr/>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://2.bp.blogspot.com/-c6D3HVGt8uA/VDr6nyHyP-I/AAAAAAAAATM/S8XphKk3fwI/s1600/2014-10-13%2B02-02-55%2BDesign%2BSeeds%C2%AE%2B%7C%2Bfor%2Ball%2Bwho%2B%E2%9D%A4%2Bcolor%2B%7C%2Bdried%2Bhues.png" imageanchor="1"><img border="0" src="http://2.bp.blogspot.com/-c6D3HVGt8uA/VDr6nyHyP-I/AAAAAAAAATM/S8XphKk3fwI/s1600/2014-10-13%2B02-02-55%2BDesign%2BSeeds%C2%AE%2B%7C%2Bfor%2Ball%2Bwho%2B%E2%9D%A4%2Bcolor%2B%7C%2Bdried%2Bhues.png"/></a></td></tr>
<tr><td class="tr-caption">Пример с сайта</td></tr>
</tbody></table><p>
Сначала посмотрим на наш метод выбора первоначальных центров, исходя из предположения простого количественного показателя использования цветов. Изначальные центры ниже подписано, сколько раз цвет встречался на картинке.

</p><table cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://1.bp.blogspot.com/-gUnMxHm4Yh4/VDsGw8ZN-9I/AAAAAAAAAUA/UkwSPJ6fQBU/s1600/2014-10-13%2B02-52-49%2B%231f1317%2BColor%2BHex.png" imageanchor="1"><img border="0" src="http://1.bp.blogspot.com/-gUnMxHm4Yh4/VDsGw8ZN-9I/AAAAAAAAAUA/UkwSPJ6fQBU/s1600/2014-10-13%2B02-52-49%2B%231f1317%2BColor%2BHex.png"/></a></td></tr>
<tr><td class="tr-caption">7 раз</td></tr>
</tbody></table>
</div>
<table cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://2.bp.blogspot.com/-OMNlqu6VGMg/VDsGcfJB1hI/AAAAAAAAATg/TmR_lVQb_oA/s1600/2014-10-13%2B02-51-35%2B%23130b11%2BColor%2BHex.png" imageanchor="1"><img border="0" src="http://2.bp.blogspot.com/-OMNlqu6VGMg/VDsGcfJB1hI/AAAAAAAAATg/TmR_lVQb_oA/s1600/2014-10-13%2B02-51-35%2B%23130b11%2BColor%2BHex.png"/></a></td></tr>
<tr><td class="tr-caption">4 раза</td></tr>
</tbody></table>
<table cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://3.bp.blogspot.com/-3mUlPLNThYU/VDsGhm2yYdI/AAAAAAAAATo/VhSJziDxxp0/s1600/2014-10-13%2B02-51-51%2B%231c121d%2BColor%2BHex.png" imageanchor="1"><img border="0" src="http://3.bp.blogspot.com/-3mUlPLNThYU/VDsGhm2yYdI/AAAAAAAAATo/VhSJziDxxp0/s1600/2014-10-13%2B02-51-51%2B%231c121d%2BColor%2BHex.png"/></a></td></tr>
<tr><td class="tr-caption">4 раза</td></tr>
</tbody></table>

<table cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://2.bp.blogspot.com/-DI3RJC9lolM/VDsGo68YmBI/AAAAAAAAATw/GB18wNm_jUg/s1600/2014-10-13%2B02-52-08%2B%2314161d%2BColor%2BHex.png" imageanchor="1"><img border="0" src="http://2.bp.blogspot.com/-DI3RJC9lolM/VDsGo68YmBI/AAAAAAAAATw/GB18wNm_jUg/s1600/2014-10-13%2B02-52-08%2B%2314161d%2BColor%2BHex.png"/></a></td></tr>
<tr><td class="tr-caption">4 раза</td></tr>
</tbody></table>



<table cellpadding="0" cellspacing="0" class="tr-caption-container"><tbody>
<tr><td><a href="http://1.bp.blogspot.com/-JRwOHZfi1FU/VDsGsacE91I/AAAAAAAAAT4/BmNG0u_AoGc/s1600/2014-10-13%2B02-52-24%2B%23130b0f%2BColor%2BHex.png" imageanchor="1"><img border="0" src="http://1.bp.blogspot.com/-JRwOHZfi1FU/VDsGsacE91I/AAAAAAAAAT4/BmNG0u_AoGc/s1600/2014-10-13%2B02-52-24%2B%23130b0f%2BColor%2BHex.png"/></a></td></tr>
<tr><td class="tr-caption">5 раз</td></tr>
</tbody></table>
</div>
</div></body></html>