<html><body><div><div class="postcontents">
                    <p>Well, this is pretty useless, but it is possible. But again its pretty.. uesless. This tutorial will hopefully help you to better understand how a simple webserver could work and that it's no problem writing one in PHP. But again using this in production would be trying to eat a soup with a fork. So just, .... just don't. Let me shortly explain why this is not a that good idea.</p>

<blockquote>
  <p>PHP is a scripting language that simply is not really designed for such tasks.</p>
</blockquote>

<p>A webserver is a long running process which PHP is not made for. Also PHP does not natively support threading ( <a href="https://github.com/krakjoe/pthreads">pthreads</a> ), which will make developing a good performing webserver a really hard task. But this might change. <br/>
If you met some programmers, there was probably one who made jokes about how freaking bad PHP is. Let me tell you something about that guy: He... is... a... dumbass! Who either didn't touch PHP for about 10 years or copycats another guy who hates that language, to be a cool kid. <em>We don't put 42 <code>require_once</code> calls on the top of every document anymore.</em> So don't be that guy... Seriously that kind of staff is the 24 year old virgin equivalent to Nationalism. <br/>
So maybe, just maybe we are going to write one day, long running process with PHP. <br/>
I've driven away a bit, sorry...</p>

<h2 id="usethesourceluke">Use the Source, Luke</h2>

<p>The entire source is available on Github: <a href="https://github.com/ClanCatsStation/PHPWebserver">https://github.com/ClanCatsStation/PHPWebserver</a></p>

<h2 id="basics">Basics</h2>

<p>Enough warnings about doing what I'm about to explain how to do. let's get started eating the god damit soup with god damit chopsticks.</p>

<p>How does a webserver basically work?</p>

<ol>
<li>The server listens for incoming connections.</li>
<li>A client connects to the server.</li>
<li>The server accepts the connection and handles the input.</li>
<li>The server responds to client the.</li>
</ol>

<h2 id="structure">Structure</h2>

<p>I'm going to build this as an abstraction of the Request and Response. There are many ways designing an application, I prefer writing in the first step, that part of the application that uses the API. Followed by writing the actual API. </p>

<p>So later I wan't to be able to use the thing like this:</p>

<pre><code class="language-php">// create a new server instance
$server = new Server( '127.0.0.1', 80 );

// start listening
$server-&gt;listen( function( Request $request ) 
{
    return new Response( 'Hello Dude' );
});
</code></pre>

<p>The directory structure (just as help):</p>

<pre><code>server  
composer.json  
src/Request.php  
src/Response.php  
src/Server.php  
src/Exception.php  
</code></pre>

<p>I'm going to use <code>PSR-4</code> autoloading. So start by creating a new <code>composer.json</code> file. ( Don't forget to run <code>composer install</code> afterwards )</p>

<pre><code class="language-php">{
    "autoload":
    {
        "psr-4": 
        {
            "ClanCats\\Station\\PHPServer\\": "src/"    
        }
    }
}
</code></pre>

<h2 id="initializing"> Initializing</h2>

<p>Next we create the script file (<code>server</code>) which will take care of starting the server. We don't add the <code>.php</code> extension. So that bash knows what do do, add the following header:</p>

<pre><code class="language-php">#!/usr/bin/env php
&lt;?php  
</code></pre>

<p>We are always going to bind the server to localhost but we wan't to be able to define the port as command line argument.</p>

<pre><code class="language-php">// we never need the first argument
array_shift( $argv );

// the next argument should be the port if not use 80
if ( empty( $argv ) )  
{
    $port = 80;
} else {
    $port = array_shift( $argv );
}
</code></pre>

<p>This allows as to start the server <strong>later</strong> like this:</p>

<pre><code>$ sudo php server 8008
</code></pre>

<p>If we combine that with what we defined before we get the following file:</p>

<pre><code class="language-php">#!/usr/bin/env php
&lt;?php  
use ClanCats\Station\PHPServer\Server;  
use ClanCats\Station\PHPServer\Request;  
use ClanCats\Station\PHPServer\Response;

// we never need the first argument
array_shift( $argv );

// the next argument should be the port if not use 80
if ( empty( $argv ) )  
{
    $port = 80;
} else {
    $port = array_shift( $argv );
}

require 'vendor/autoload.php';

// create a new server instance
$server = new Server( '127.0.0.1', $port );

// start listening
$server-&gt;listen( function( Request $request ) 
{
    return new Response( 'Hello Dude' );
});
</code></pre>

<h2 id="serverobject">Server Object</h2>

<p>Next lets create our <code>src/Server.php</code> file which is going to handle the socket.</p>

<pre><code class="language-php">&lt;?php namespace ClanCats\Station\PHPServer;

class Server  
{
}
</code></pre>

<p>Our server class is going to hold the <em>host</em>, the <em>port</em> and the <em>socket resource</em> so add the following class variables.</p>

<pre><code class="language-php">protected $host = null;  
protected $port = null;  
protected $socket = null;  
</code></pre>

<h3 id="createasocket"> Create a socket</h3>

<p>To bind a socket we need to have one so create the <code>createSocket</code> function.</p>

<pre><code class="language-php">protected function createSocket()  
{
    $this-&gt;socket = socket_create( AF_INET, SOCK_STREAM, 0 );
}
</code></pre>

<p>The first argument specifies the domain / protocol family of the socket. <code>AF_INET</code> is for <code>IPv4</code> <code>TCP</code> and <code>UDP</code> protocols.</p>

<p>The second argument defines the communication type of the socket. <code>SOCK_STREAM</code> is a simple full-duplex connection based byte stream.</p>

<p>The third argument sets the protocol.</p>

<h3 id="bindthesocket">Bind the socket</h3>

<p>This is pretty self explaining. The <code>socket_bind</code> function returns <code>false</code> when something goes wrong. Because this should never happen we throw an exception with the socket error message.</p>

<pre><code class="language-php">protected function bind()  
{
    if ( !socket_bind( $this-&gt;socket, $this-&gt;host, $this-&gt;port ) )
    {
        throw new Exception( 'Could not bind: '.$this-&gt;host.':'.$this-&gt;port.' - '.socket_strerror( socket_last_error() ) );
    }
}
</code></pre>

<h3 id="createandbindthesocketonconstruct">Create and bind the socket on construct</h3>

<p>We could also create a connect function, but to keep stuff simple we just do it in the constructor.</p>

<pre><code class="language-php">public function __construct( $host, $port )  
{
    $this-&gt;host = $host;
    $this-&gt;port = (int) $port;

    // create a socket
    $this-&gt;createSocket();

    // bind the socket
    $this-&gt;bind();
}
</code></pre>

<h3 id="listenforconnections">Listen for connections</h3>

<p>Beacuse I don't want to split this function in 20 segments just to explain what happens, I added my bullshit to the comments.</p>

<pre><code class="language-php">public function listen( $callback )  
{
    // check if the callback is valid. Throw an exception
    // if not.
    if ( !is_callable( $callback ) )
    {
        throw new Exception('The given argument should be callable.');
    }

    // Now here comes the thing that makes this process
    // long, infinite, never ending..
    while ( 1 ) 
    {
        // listen for connections
        socket_listen( $this-&gt;socket );

        // try to get the client socket resource
        // if false we got an error close the connection and skip
        if ( !$client = socket_accept( $this-&gt;socket ) ) 
        {
            socket_close( $client ); continue;
        }

        // create new request instance with the clients header.
        // In the real world of course you cannot just fix the max size to 1024..
        $request = Request::withHeaderString( socket_read( $client, 1024 ) );

        // execute the callback 
        $response = call_user_func( $callback, $request );

        // check if we really recived an Response object
        // if not return a 404 response object
        if ( !$response || !$response instanceof Response )
        {
            $response = Response::error( 404 );
        }

        // make a string out of our response
        $response = (string) $response;

        // write the response to the client socket
        socket_write( $client, $response, strlen( $response ) );

        // close the connetion so we can accept new ones
        socket_close( $client );
    }
}
</code></pre>

<h2 id="requestobject">Request Object</h2>

<p>Now it's time to create the <code>src/Request.php</code> file which is going to handle the user input.</p>

<pre><code class="language-php">&lt;?php namespace ClanCats\Station\PHPServer;

class Request  
{
}
</code></pre>

<p>Our Request is going to hold the HTTP request <code>method</code>, the <code>uri</code>, <code>parameters</code> and <code>headers</code>. So add these class variables:</p>

<pre><code class="language-php">protected $method = null;  
protected $uri = null;  
protected $parameters = [];  
protected $headers = [];  
</code></pre>

<h3 id="parsetheheader">Parse the header</h3>

<p>Now in our <code>listen</code> function we already pass the socket input / request header to the <code>withHeaderString</code> function. A <code>http</code> header looks like this:</p>

<pre><code>GET / HTTP/1.1  
Host: 127.0.0.1:8008  
Connection: keep-alive  
Accept: text/html  
User-Agent: Chrome/41.0.2272.104  
Accept-Encoding: gzip, deflate, sdch  
Accept-Language: en-US,en;q=0.8,de;q=0.6  
</code></pre>

<p>So what we need to do is parse that data. The first line indicates the request method, uri and protocol. Followed by key, value header parameters.</p>

<pre><code>public static function withHeaderString( $header )  
{
    // explode the string into lines.
    $lines = explode( "\n", $header );

    // extract the method and uri
    list( $method, $uri ) = explode( ' ', array_shift( $lines ) );

    $headers = [];

    foreach( $lines as $line )
    {
        // clean the line
        $line = trim( $line );

        if ( strpos( $line, ': ' ) !== false )
        {
            list( $key, $value ) = explode( ': ', $line );
            $headers[$key] = $value;
        }
    }   

    // create new request object
    return new static( $method, $uri, $headers );
}
</code></pre>

<p>Our constructor recives <code>$method</code>, <code>$uri</code> and <code>$headers</code>. We could simply just assign them to a class variable. But for this example I want to split and parse the query parameters.</p>

<pre><code class="language-php">public function __construct( $method, $uri, $headers = [] )  
{
    $this-&gt;headers = $headers;
    $this-&gt;method = strtoupper( $method );

    // split uri and parameters string
    @list( $this-&gt;uri, $params ) = explode( '?', $uri );

    // parse the parmeters
    parse_str( $params, $this-&gt;parameters );
}
</code></pre>

<h3 id="createrequestgettermethods">Create request getter methods</h3>

<p>Because our class variables <em>method</em>, <em>uri</em>, <em>parameters</em> and <em>headers</em> are protected we need to create some getters to make the request data accessible.</p>

<p>There is nothing specail with the <em>method</em> and <em>uri</em> getters. They just return..</p>

<pre><code class="language-php">public function method()  
{
    return $this-&gt;method;
}
</code></pre>

<pre><code class="language-php">public function uri()  
{
    return $this-&gt;uri;
}
</code></pre>

<p>Now the <em>header</em> and <em>param</em> getter should allow giving a default value. Which get return if no data with the given key is found.</p>

<pre><code class="language-php">public function header( $key, $default = null )  
{
    if ( !isset( $this-&gt;headers[$key] ) )
    {
        return $default;
    }

    return $this-&gt;headers[$key];
}
</code></pre>

<pre><code>public function param( $key, $default = null )  
{
    if ( !isset( $this-&gt;parameters[$key] ) )
    {
        return $default;
    }

    return $this-&gt;parameters[$key];
}
</code></pre>

<h2 id="responseobject">Response Object</h2>

<p>Being muted isn't much fun. Of course we wan't to be able to respond to our request. As you see in the <em>listen</em> function, the given callback has to return a <em>Response</em> object. Otherwise a <em>404</em> response is returend. </p>

<p>How does a <code>http</code> response look like? Actually pretty much the same as the request. We have a <em>header</em> and a body. And we will simply write them both into the socket to respond to the client.</p>

<p>Again this is not the optimal way for a solid implementation its an example..</p>

<p>Create a new file <code>src/Response.php</code>.</p>

<pre><code class="language-php">&lt;?php namespace ClanCats\Station\PHPServer;

class Response  
{
}
</code></pre>

<h3 id="statuscodes">Status codes</h3>

<p>404 in tha house! To be able to build our header string we need to know the http status codes. We could also set them manually, but who the hell wants to write stuff manually?</p>

<p>This array pretty much covers the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">http status codes definitions</a>. Taken from CCF.</p>

<pre><code class="language-php">protected static $statusCodes = [  
    // Informational 1xx
    100 =&gt; 'Continue',
    101 =&gt; 'Switching Protocols',

    // Success 2xx
    200 =&gt; 'OK',
    201 =&gt; 'Created',
    202 =&gt; 'Accepted',
    203 =&gt; 'Non-Authoritative Information',
    204 =&gt; 'No Content',
    205 =&gt; 'Reset Content',
    206 =&gt; 'Partial Content',

    // Redirection 3xx
    300 =&gt; 'Multiple Choices',
    301 =&gt; 'Moved Permanently',
    302 =&gt; 'Found', // 1.1
    303 =&gt; 'See Other',
    304 =&gt; 'Not Modified',
    305 =&gt; 'Use Proxy',
    // 306 is deprecated but reserved
    307 =&gt; 'Temporary Redirect',

    // Client Error 4xx
    400 =&gt; 'Bad Request',
    401 =&gt; 'Unauthorized',
    402 =&gt; 'Payment Required',
    403 =&gt; 'Forbidden',
    404 =&gt; 'Not Found',
    405 =&gt; 'Method Not Allowed',
    406 =&gt; 'Not Acceptable',
    407 =&gt; 'Proxy Authentication Required',
    408 =&gt; 'Request Timeout',
    409 =&gt; 'Conflict',
    410 =&gt; 'Gone',
    411 =&gt; 'Length Required',
    412 =&gt; 'Precondition Failed',
    413 =&gt; 'Request Entity Too Large',
    414 =&gt; 'Request-URI Too Long',
    415 =&gt; 'Unsupported Media Type',
    416 =&gt; 'Requested Range Not Satisfiable',
    417 =&gt; 'Expectation Failed',

    // Server Error 5xx
    500 =&gt; 'Internal Server Error',
    501 =&gt; 'Not Implemented',
    502 =&gt; 'Bad Gateway',
    503 =&gt; 'Service Unavailable',
    504 =&gt; 'Gateway Timeout',
    505 =&gt; 'HTTP Version Not Supported',
    509 =&gt; 'Bandwidth Limit Exceeded'
];
</code></pre>

<p>Just a little thing aside there is a repository that covering the 7xx http status codes: <a href="https://github.com/joho/7XX-rfc">https://github.com/joho/7XX-rfc</a> They are hilarious :)</p>

<h3 id="responseconstructor">Response constructor</h3>

<p>The general parameters our response object should implement are the http <em>status</em>, <em>body</em> and other headers.</p>

<pre><code class="language-php">protected $status = 200;  
protected $body = '';  
protected $headers = [];  
</code></pre>

<p>Body should be a must argument in the constructor, while the status and other headers should be optional. Also the constructor should set some default values like the current <em>Date</em> or the <em>Server</em> header.</p>

<pre><code class="language-php">public function __construct( $body, $status = null )  
{
    if ( !is_null( $status ) )
    {
        $this-&gt;status = $status;
    }

    $this-&gt;body = $body;

    // set inital headers
    $this-&gt;header( 'Date', gmdate( 'D, d M Y H:i:s T' ) );
    $this-&gt;header( 'Content-Type', 'text/html; charset=utf-8' );
    $this-&gt;header( 'Server', 'PHPServer/1.0.0 (Whateva)' );
}
</code></pre>

<h3 id="settingheaders">Setting headers</h3>

<p>To be able to add new header parameters to the object we need to create a setter method.</p>

<pre><code class="language-php">public function header( $key, $value )  
{
    $this-&gt;headers[ucfirst($key)] = $value;
}
</code></pre>

<p><code>ucfirst</code> is loved by lazy folks like me. It uppercases ( if thats actually a word ) the first character of a string. This way you can create new responses like this:</p>

<pre><code class="language-php">$response = new Response( 'Hello World' );
$response-&gt;header( 'date', '13.09.1959' );
</code></pre>

<h3 id="buildingtheheaderstring">Building the header string</h3>

<p>We made eveything so fancy abstracted but we cannot simply pass our response object to the socket writer. We need to build a string out of our data.</p>

<p>A http header response string will look like the following:</p>

<pre><code>HTTP/1.1 200 OK  
Date: 13.09.1959  
Server: PHPServer  
</code></pre>

<p>We have all the data we need so we can create the following function:</p>

<pre><code class="language-php">public function buildHeaderString()  
{
    $lines = [];

    // response status 
    $lines[] = "HTTP/1.1 ".$this-&gt;status." ".static::$statusCodes[$this-&gt;status];

    // add the headers
    foreach( $this-&gt;headers as $key =&gt; $value )
    {
        $lines[] = $key.": ".$value;
    }

    return implode( " \r\n", $lines )."\r\n\r\n";
}
</code></pre>

<h3 id="letthemagichappen">Let the magic happen</h3>

<p>And because again we are all lazy fucks that don't want to execute <code>buildHeaderString</code> just to build a header string, we create the magic <code>__toString</code> method that returns the entire string written to the open connection.</p>

<pre><code class="language-php">public function __toString()  
{
    return $this-&gt;buildHeaderString().$this-&gt;body;
}
</code></pre>

<h2 id="thatsit">Thats it!</h2>

<p>Well thats everything, hopefully... You should now be able to start your server just like this:</p>

<pre><code>$ sudo php server 8008
</code></pre>

<p>And access it with your browser:</p>

<pre><code>http://127.0.0.1:8008/everything/you/want/?cool=yes  
</code></pre>

<hr/>

<h2 id="postscriptum">post-scriptum</h2>

<p>When I started this article I did not thought it would be that freaking big. Also I have to admire i got pissed after the first hour about myself starting to write this thing. So please execuse that the quality is not consistent or close to good. But I think the tutorial and espacially the source might help you to better understand how a webserver works. If you come from PHP and don't want to read yourself through the sources of apache or nginx etc.. This tutorial hopefully helped you getting the basic basics of a webserver.</p>
                </div> 
                </div></body></html>