<html><body><div><section class="slides layout-widescreen">
      
      <article>
        <h1>Go and the Zen of Python</h1>
        
        
        
          
        
          
        
      </article>
      
  
  
      <article>
      
        <h3>What is Go?</h3>
        
  
  <p>
    A new programming language. (First release in November 2009, 1.0 in March 2012.)
  </p>
  

  
  <p>
    In a nutshell:
  </p>
  

  <ul>
  
    <li>A simple language that is easy to learn and read.</li>
  
    <li>Statically typed, but with a dynamic feel.</li>
  
    <li>Compiled to native machine code, but has a fast development cycle.</li>
  
    <li>Language-level concurrency features.</li>
  
    <li>Expansive "batteries included" standard library.</li>
  
    <li>Great tools.</li>
  
    <li>Open source. (BSD)</li>
  
  </ul>

      
      </article>
  
  
  
      <article>
      
        <h3>What is Go used for?</h3>
        
  
  <p>
    Go is a general-purpose programming language, like Python, Java, or C.
  </p>
  

  
  <p>
    Some common uses:
  </p>
  

  <ul>
  
    <li>Server daemons</li>
  
    <li>Command-line tools</li>
  
    <li>Web applications</li>
  
    <li>Games</li>
  
    <li>Scientific computing</li>
  
    <li>High frequency trading</li>
  
  </ul>

  
  <p>
    And, of course, there are many more.
  </p>
  

  
  <p>
    Whatever you do, there's a good chance that Go can help you to do it.
  </p>
  

      
      </article>
  
  
  
      <article>
      
        <h3>Who uses Go?</h3>
        
  
  <p>
    Some names that I could fit on one slide:
  </p>
  

  <ul>
  
    <li>Anchor</li>
  
    <li>BBC World News</li>
  
    <li>Bitly</li>
  
    <li>Canonical</li>
  
    <li>Carbon Games</li>
  
    <li>CloudFlare</li>
  
    <li>Google</li>
  
    <li>Heroku</li>
  
    <li>Iron.io</li>
  
    <li>ngmoco:)</li>
  
    <li>SoundCloud</li>
  
  </ul>

      
      </article>
  
  
  
      <article>
      
        <h3>Go one-pagers (1/4)</h3>
        
  <div class="code playground" contenteditable="true" spellcheck="false">


<pre><span num="3">package main</span>
<span num="4"/>
<span num="5">import "fmt"</span>
<span num="6"/>
<span num="7">func main() {</span>
<span num="8">    fmt.Println("Hello, Pythonistas!")</span>
<span num="9">}</span>
</pre>


</div>

      
      </article>
  
  
  
      <article>
      
        <h3>Go one-pagers (2/4)</h3>
        
  <div class="code playground" contenteditable="true" spellcheck="false">


<pre><span num="3">package main</span>
<span num="4"/>
<span num="5">import (</span>
<span num="6">    "fmt"</span>
<span num="7">    "net/http"</span>
<span num="8">)</span>
<span num="9"/>
<span num="10">func main() {</span>
<span num="11">    http.HandleFunc("/", hello)</span>
<span num="12">    http.ListenAndServe("localhost:8000", nil)</span>
<span num="13">}</span>
<span num="14"/>
<span num="15">func hello(w http.ResponseWriter, r *http.Request) {</span>
<span num="16">    fmt.Fprintln(w, "Hello, Pythonistas!")</span>
<span num="17">}</span>
</pre>


</div>

      
      </article>
  
  
  
      <article>
      
        <h3>Go one-pagers (3/4)</h3>
        
  <div class="code playground" contenteditable="true" spellcheck="false">


<pre><span num="3">package main</span>
<span num="4"/>
<span num="5">import ( "fmt"; "net/http"; "time" )</span>
<span num="6"/>
<span num="7">func main() {</span>
<span num="8">    urls := []string{"http://google.com/", "http://bing.com/"}</span>
<span num="9">    start := time.Now()</span>
<span num="10">    done := make(chan string)</span>
<span num="11">    for _, u := range urls {</span>
<span num="12">        go func(u string) {</span>
<span num="13">            resp, err := http.Get(u)</span>
<span num="14">            if err != nil {</span>
<span num="15">                done &lt;- u + " " + err.Error()</span>
<span num="16">            } else {</span>
<span num="17">                done &lt;- u + " " + resp.Status</span>
<span num="18">            }</span>
<span num="19">        }(u)</span>
<span num="20">    }</span>
<span num="21">    for _ = range urls {</span>
<span num="22">        fmt.Println(&lt;-done, time.Since(start))</span>
<span num="23">    }</span>
<span num="24">}</span>
</pre>


</div>

      
      </article>
  
  
  
      <article>
      
        <h3>Go one-pagers (4/4)</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">


<pre><span num="3">package main</span>
<span num="4"/>
<span num="5">import ( "encoding/json"; "fmt"; "io"; "os" )</span>
<span num="6"/>
<span num="7">func main() {</span>
<span num="8">    d := json.NewDecoder(os.Stdin)</span>
<span num="9">    var err error</span>
<span num="10">    for err == nil {</span>
<span num="11">        var v interface{}</span>
<span num="12">        if err = d.Decode(&amp;v); err != nil {</span>
<span num="13">            break</span>
<span num="14">        }</span>
<span num="15">        var b []byte</span>
<span num="16">        if b, err = json.MarshalIndent(v, "", "  "); err != nil {</span>
<span num="17">            break</span>
<span num="18">        }</span>
<span num="19">        _, err = os.Stdout.Write(b)</span>
<span num="20">    }</span>
<span num="21">    if err != io.EOF {</span>
<span num="22">        fmt.Fprintln(os.Stderr, err)</span>
<span num="23">        os.Exit(1)</span>
<span num="24">    }</span>
<span num="25">}</span>
</pre>


</div>

      
      </article>
  
  
  
      <article>
      
        <h3>Go and me</h3>
        
  
  <p>
    I (adg) joined the Go team at Google in February 2010. 
  </p>
  

  
  <p>
    Before then, Python had been my day-to-day language for many years.
  </p>
  

  
  <p>
    Go has since entirely replaced Python in my life.
  </p>
  

  
  <p>
    I am obviously biased, but IMO: if you love Python, you'll love Go.
  </p>
  

      
      </article>
  
  
  
      <article>
      
        <h3>The Zen of Python</h3>
        
  
  <div class="code"><pre>&gt;&gt;&gt; import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!</pre></div>
  

      
      </article>
  
  
  
      <article>
      
        <h3>Zen is good</h3>
        
  
  <p>
    This is a nice list.
  </p>
  

  
  <p>
    I agree with most of it.
  </p>
  

  
  <p>
    (Although Python doesn't, sometimes.)
  </p>
  

      
      </article>
  
  
  
      <article>
      
        <h3>Go is Zenlike</h3>
        
  
  <p>
    Go meets nearly all of Tim Peters' criteria.
  </p>
  

  
  <p>
    (Maybe not that one about being Dutch.)
  </p>
  

  
  <p>
    Let's take a look at some of them and see how Go fits in.
  </p>
  

      
      </article>
  
  
  
      <article>
      
        <h3>"Beautiful is better than ugly."</h3>
        
  
  <p>
    Go has a lightweight, regular syntax reminiscent of C (without the warts).
  </p>
  

  
  <p>
    I think it's beautiful. I've certainly seen some beautiful Go code.
  </p>
  

  
  <p>
    But beauty, as they say, is in the eye of the beholder. So enough about that.
  </p>
  

      
      </article>
  
  
  
      <article>
      
        <h3>"Simple is better than complex." </h3>
        
  
  <p>
    Methods are just functions (no special location)
  </p>
  

  
  <p>
    There's no <code>this</code> or <code>self</code> - the receiver is like any other function argument
  </p>
  

  
  <div class="code"><pre>type Vector struct {
  X, Y float64
}

func (v Vector) Abs() float64 {
  return math.Sqrt(v.X*v.X + v.Y*v.Y)
}</pre></div>
  

      
      </article>
  
  
  
      <article>
      
        <h3>"Simple is better than complex." </h3>
        
  
  <p>
    Methods can be declared on any named type (no classes)
  </p>
  

  
  <div class="code"><pre>type Scalar float64

func (s Scalar) Abs() float64 {
  if s &lt; 0 {
    return float64(-s)
  }
  return float64(s)
}</pre></div>
  

      
      </article>
  
  
  
      <article>
      
        <h3>"Simple is better than complex." </h3>
        
  
  <p>
    Interfaces are just methods (no data)
  </p>
  

  
  <p>
    Interfaces are implicit (no <code>implements</code> declaration)
  </p>
  

  
  <div class="code"><pre>type Abser interface {
  Abs() float64
}</pre></div>
  

  
  <p>
    (Both <code>Vector</code> and <code>Scalar</code> implement <code>Abser</code>,
<br/>

    even though they don't know that <code>Abser</code> exists.)
  </p>
  

      
      </article>
  
  
  
      <article>
      
        <h3>"Simple is better than complex." </h3>
        
  
  <p>
    No constructors or destructors.
  </p>
  

  
  <p>
    A constructor is just a function:
  </p>
  

  
  <div class="code"><pre>type Database struct {
  client *rpc.Client
}

func NewDatabase(addr string) (*Database, error) {
  client, err := rpc.Dial("tcp", addr)
  if err != nil {
    return nil, err
  }
  return &amp;Database{client}, nil
}</pre></div>
  

      
      </article>
  
  
  
      <article>
      
        <h3>"Simple is better than complex." </h3>
        
  
  <p>
    Identifier case sets visibility.
  </p>
  

  
  <p>
    If a name begins with a capital, it is visible outside its package:
  </p>
  

  
  <div class="code"><pre>package foo

type Foo struct { // exported type
  bar int // unexported field
}

func (f Foo) Bar() {} // exported method

func (f Foo) quux() {} // unexported method</pre></div>
  

  
  <p>
    Only code inside the package can see unexported ("private") names.
  </p>
  

      
      </article>
  
  
  
      <article>
      
        <h3>"Simple is better than complex." </h3>
        
  <ul>
  
    <li>Garbage collection (only)</li>
  
    <li>Regular scoping (and name shadowing) rules</li>
  
  </ul>

  
  <p>
    And there's less:
  </p>
  

  <ul>
  
    <li>No subtype inheritance* (no subclasses)</li>
  
    <li>No decorators*</li>
  
    <li>No named or optional arguments</li>
  
    <li>No iterators</li>
  
    <li>No generators</li>
  
    <li>No exceptions</li>
  
  </ul>

  
  <p>
    (*However, Go's "struct embedding" permits similar functionality.)
  </p>
  

      
      </article>
  
  
  
      <article>
      
        <h3>"Explicit is better than implicit."</h3>
        
  <ul>
  
    <li>Explicit error handling (no exceptions)</li>
  
    <li>Explicit dependencies</li>
  
    <li>No implicit numeric conversions</li>
  
    <li>Structs define memory layout (no hidden costs)</li>
  
  </ul>

      
      </article>
  
  
  
      <article>
      
        <h3>"Flat is better than nested."</h3>
        
  
  <p>
    "Bail early" is idiomatic coding style
  </p>
  

  
  <div class="code"><pre>func badStyle(a int) error {
  b, err := one(a)
  if err == nil {
    c, err := two(b)
    if err == nil {
      err = three(c)
    }
  }
  return err
}

func goodStyle(a int) error {
  b, err := one(a)
  if err != nil {
    return err
  }
  c, err := two(b)
  if err != nil {
    return err
  }
  return three(c)
}</pre></div>
  

      
      </article>
  
  
  
      <article>
      
        <h3>"Flat is better than nested."</h3>
        
  <ul>
  
    <li>Methods are not nested inside classes (no classes, remember?)</li>
  
    <li>Package name space is flat</li>
  
    <li>Multiple files that comprise one package share one name space</li>
  
  </ul>

      
      </article>
  
  
  
      <article>
      
        <h3>"Sparse is better than dense."</h3>
        
  
  <p>
    Go's syntax doesn't encourage crazy one-liners.
  </p>
  

  <ul>
  
    <li>No list comprehensions</li>
  
    <li>No ternary operator (<code>expression?true:false</code>)</li>
  
  </ul>

  
  <p>
    When reading Go code the control flow is obvious.
  </p>
  

      
      </article>
  
  
  
      <article>
      
        <h3>"Practicality beats purity."</h3>
        
  
  <p>
    Go has some built-in generic data structures:
  </p>
  

  <ul>
  
    <li>maps (dicts)</li>
  
    <li>slices (lists)</li>
  
    <li>channels (a concurrency primitive like Python's queues)</li>
  
  </ul>

      
      </article>
  
  
  
      <article>
      
        <h3>"Readability counts."</h3>
        
  
  <p>
    Go was designed for teams of hundreds/thousands of programmers.
<br/>

    Readability is of paramount importance.
  </p>
  

  <ul>
  
    <li>The <code>gofmt</code> tool enforces "one true style." (No more stupid arguments.)</li>
  
  </ul>

  <ul>
  
    <li>Type inference saves a lot of typing, but not at the cost of readability. Types are still required where they help readability (function declarations, for example).</li>
  
  </ul>

  <ul>
  
    <li>Many other language design decisions were made in the name of readability (case-based name visibility, for example).</li>
  
  </ul>

      
      </article>
  
  
  
      <article>
      
        <h3>Bonuses</h3>
        
  
  <p>
    Go's concurrency features will transform the way you think about code:
  </p>
  

  <ul>
  
    <li>blocking is fine; no need to split concurrent processes into a series of callbacks,</li>
  
    <li>code runs in parallel with little additional cost (no GIL).</li>
  
  </ul>

  
  <p>
    Deployment is trivial:
  </p>
  

  <ul>
  
    <li>compile and ship a single statically-linked binary,</li>
  
    <li>goodbye "dependency hell."</li>
  
  </ul>

  
  <p>
    And there's much more than I could fit into this short talk. :-)
  </p>
  

      
      </article>
  
  
  
      <article>
      
        <h3>"There should be one obvious way to do it."</h3>
        
  
  <p>
    I would argue that this is more true of Go than Python.
  </p>
  

      
      </article>
  
  
  
      <article>
      
        <h3>"Now is better than never."</h3>
        
  
  <p>
    Learn Go today! It's easy.
  </p>
  

  
  <p>
    My rule of thumb:
  </p>
  

  <ul>
  
    <li>productive in one day,</li>
  
    <li>efficient in one week,</li>
  
    <li>expert in one year.</li>
  
  </ul>

  
  <p>
    References, articles, tutorials, and more:
  </p>
  
<p class="link"><a href="http://golang.org" target="_blank">golang.org</a></p>
  
  <p>
    An interactive web-based tour of Go:
  </p>
  
<p class="link"><a href="http://tour.golang.org" target="_blank">tour.golang.org</a></p>
      
      </article>
  
  

      <article>
        <h3>Thank you</h3>
        
          
        
          
        
      </article>

    </section>

    <p id="help">
      Use the left and right arrow keys or click the left and right
      edges of the page to navigate between slides.<br/>
      (Press 'H' or navigate to hide this message.)
    </p>

    
    
    

    
  </div></body></html>