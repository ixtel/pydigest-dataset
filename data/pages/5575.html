<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/files/0f0/925/186/0f092518650f41a38ae9f8a83f01206d.jpg"/>
<p>
Фреймворк Django, пожалуй, самый популярный для языка Python. Однако, при всей его популярности, часто критикуют его ORM — а именно lookup синтаксис через подчеркивания. На самом деле, такой выбор синтаксиса вполне обоснован — он легок в понимании, расширяем, а главное — прост, как швабра. Тем не менее, хочется красоты, или даже прямо изящества. Но красота — понятие относительное, поэтому будем отталкиваться из конкретных задач. Если заинтриговал — добро пожаловать под кат.
</p><a name="habracut"/><p>
На самом деле, у lookup через подчеркивания есть два основных недостатка:</p><p>
1. Плохая читаемость строки, если она достаточно длинная.</p><p>
Пример:

</p><pre><code class="python">&gt;&gt;&gt; query = SomeModel.objects.filter(user__savepoint__created_datetime__gte=last_week)
</code></pre><p>
Строка плохо читаема, т. к. с первого взгляда created_datetime можно спутать с created__datetime, либо наоборот — можно не поставить второе подчеркивание между user и savepoint. К тому же lookup параметр можно спутать с полем модели. Конечно, при более детальном рассмотрении видно, что имеется ввиду «больше либо равно», но при чтении кода — это ведь потеря драгоценных секунд!
</p><p>
2. Трудно переиспользовать строку поиска. Возьмем в качестве примера запрос выше и попытаемся сортировать результаты по полю created_datetime.

</p><pre><code class="python">&gt;&gt;&gt; query.order_by('user__savepoint__created_datetime')
</code></pre><p>
Как видите, длинную строку нам пришлось набрать заново, при чем мы не можем ее сохранить в качестве переменной, т. к. в одном случае мы используем строку, а выше — keyword аргумент.
</p><p>
Придирчивый читатель заметит, что мы могли бы сохранить основную часть строки в переменной query_param = 'user__savepoint_created_datetime' и сделать такой хак:

</p><pre><code class="python">&gt;&gt;&gt; SomeModel.objects.filter(**{'{}_gte'.format(query_param): last_week}).order_by(query_param)
</code></pre><p>
Но такой код еще более запутанный, т. е. главную задачу рефакторинга — упростить код, он не выполнил.</p><p>
Из первого пункта, следует, что нам нужно каким-то образом заменить подчеркивания на точку. Также мы знаем, что мы можем переопределить поведение операций сравнения: __eq__, __gt__, __lt__ и др.</p><p>
Чтобы использовать его похожим образом: 

</p><pre><code class="python">&gt;&gt;&gt; SomeModel.user.savepoint.created_datetime &gt;= last_week
</code></pre><p>
Однако, первое решение не такое уж и замечательное, т. к. придется патчить джанговские классы моделей и полей, а это уже накладывает большие ограничения для использования решения в реальном мире. К тому же, имя модели может быть довольно длинным, а значит наше решение будет слишком многословным, когда придется комбинировать несколько фильтров. На помощь нам придет класс Q — очень краткий, не содержит ничего лишнего. Сделаем что-нибудь подобное — и назовем его S (от Sugar). Будем его использовать для генерации строк.

</p><pre><code class="python">&gt;&gt;&gt; S.user.savepoint.created_datetime &gt;= last_week 
{'user__savepoint__created_datetime__gte': last_week}
</code></pre><p>
Однако использовать его все еще не так уж и удобно:

</p><pre><code class="python">&gt;&gt;&gt; SomeModel.objects.filter(**(S.user.savepoint.created_datetime &gt;= last_week))
</code></pre><p>
На помощь нам снова придет класс Q — его можно прямо передавать в filter, так будем возвращать готовый его экземпляр!

</p><pre><code class="python">&gt;&gt;&gt; S.user.savepoint.created_datetime &gt;= last_week
Q(user__savepoint__created_datetime__gte=last_week)

&gt;&gt;&gt; SomeModel.objects.filter(S.user.savepoint.created_datetime &gt;= last_week)
</code></pre><p>
Итак, API использования у нас есть, дело осталось за реализацией. Нетерпеливые могут сразу открыть репозиторий </p><a href="https://github.com/Nepherhotep/django-orm-sugar">github.com/Nepherhotep/django-orm-sugar</a><p>.

</p><h2>Задача №1. Переопределение операций сравнения</h2><p>
Открываем документацию здесь </p><a href="https://docs.python.org/2/reference/datamodel.html#object.__lt__">docs.python.org/2/reference/datamodel.html#object.__lt__</a><p> и смотрим, какие функции нам доступны. Это __lt__, __le__, __gt__, __ge__, __eq__, __ne__. Переопределяем их, чтобы они возвращали соответствующий Q объект:

</p><pre><code class="python">def __ge__(self, value):
    return Q(**{'{}__gte'.format(self.get_path()): value})

и т. д.
</code></pre><p>
Однако, операцию is переопределить нельзя, также будут сложности с проверкой на contains в питоновском стиле:

</p><pre><code class="python">'substr' in S.user.username
</code></pre><p>
Поэтому для таких операций создаем одноименные функции:

</p><pre><code class="python">def contains(self, value):
    return Q(**{'{}__contains'.format(self.get_path()): value})

def in_list(self, value):
    return Q(**{'{}__value'.format(self.get_path()): value})
</code></pre><p>
В качестве демонстрации удобства, добавляем полезный метод in_range:

</p><pre><code class="python">def in_range(self, min_value, max_value):
     return (self &lt;= min_value) &amp; (self &gt;= max_value)
</code></pre><p>
Его удобство в том, что можно передать сразу два параметра, что было невозможно при использовании keyword аргументов.

</p><pre><code class="python">&gt;&gt;&gt; SomeModel.objects.filter(S.user.savepoint.created_datetime.in_range(month_ago, week_ago))
</code></pre>

<h2>Задача №2. Создание дочерних экземпляров при доступе по точке</h2>
<pre><code class="python">&gt;&gt;&gt; S.user.savepoint.create_datetime
</code></pre><p>
Во-первых, будем все-таки работать с атрибутами объекта, а не класса. Но т. к. выше мы использовали класс без вызова конструктора, то просто создадим на уровне модуля объект. Во-вторых, сам исходный класс назовем более вменяемо — SugarQueryHelper.

</p><pre><code class="python">class SugarQueryHelper(object):
    pass

S = SugarQueryHelper()
</code></pre><p>
Чтобы генерировать атрибуты на лету, нужно переопределить метод __getattr__ — он будет вызываться в последнюю очередь, если атрибут не найден другими способами.

</p><pre><code class="python">    def __getattr__(self, item):
        return SugarQueryHelper()
</code></pre><p>
Но нам нужно также запомнить имя переданного параметра, чтобы на основе его генерировать Q объект, а также ссылку на родительский класс.

</p><pre><code class="python">class SugarQueryHelper(object):
    def __init__(self, parent=None, name=''):
        self.__parent = parent
        self.__name = name

    def __getattr__(self, item):
        return SugarQueryHelper(self, item)
</code></pre><p>
Теперь осталось добавить генерацию путей, и модуль готов!

</p><pre><code class="python">    def get_path(self):
        if self.__parent:
            parent_param = self.__parent.get_path()
            if parent_param:
                # объединяем строки, если получили непустой путь от родителя
                return '__'.join([parent_param, self.__name])
        # в ином случае просто возвращаем имя текущего объекта
        return self.__name
</code></pre><p>
Теперь этот метод можно использовать не только внутри SugarQueryHelper, но и для тех случаев, когда нужно передать строку запроса в order_by или select_related.</p><p>
Покажем, что это решает озвученную проблему выше — переиспользование строки запроса.

</p><pre><code class="python">&gt;&gt;&gt; sdate = S.user.savepoint.created_datetime
&gt;&gt;&gt; SomeModel.filter(sdate &gt;= last_week).order_by(sdate.get_path())
</code></pre>

<h2>Дальнейшее развитие</h2><p>
Модуль получился вполне неплох, несмотря на тривиальность исполнения. Но есть вещи, которые можно было бы улучшить.
</p><p>
Если внимательно посмотреть, то S объект не позволяет обращаться к полям, которые названы так же, как вспомогательные функции — contains, icontains, exact и т. д. Конечно, маловероятно, что кому-нибудь придет в голову так называть поля, но по закону Мерфи такие случаи когда-нибудь произойдут.
</p><p>
Что тут можно сделать? Немного поменять схему работы — переопределить метод __call__, и если он вызывается, то имя последнего объекта в пути можно пропустить. При этом сами вспомогательные функции начинать с подчеркивания, а регистрацию (без подчеркивания) осуществлять через декоратор:

</p><pre><code class="python">@register_hook('icontains')
def _icontains(self, value):
    return Q(...)
</code></pre><p>
Однако, такое решение мне показалось менее очевидным в некоторых ситуациях. В итоге, т.к. библиотека всего лишь генерирует Q объекты, и обычный способ через keywords по-прежнему доступен, я решил не дорабатывать эту реализацию (версия доступна в ветке special_names).
</p><p>
Следующее, что можно было сделать — реализовать его Q совместимым. Т.е. вместо того, чтобы импортировать S и Q, можно было использовать только Q в обоих случаях. Однако, у Q объекта довольно сложная реализация, к тому же есть публичные методы, которые будут непонятными для пользователя библиотеки. Решить проблему нахрапом не получилось, поэтому оставил как есть.
</p><p>
Еще можно сделать аналогичным фильтрацию прямо из кастомизированного менеджера запросов </p><a href="https://docs.djangoproject.com/en/1.8/topics/db/managers/#custom-managers">docs.djangoproject.com/en/1.8/topics/db/managers/#custom-managers</a><p>. Тогда, переопределив его, можно делать запрос вида:

</p><pre><code class="python">&gt;&gt;&gt; SomeModel.s_objects.user.age &gt;= 16
&lt;QuerySet&gt;
</code></pre><p>
Однако, это ломает понимание происходящего в рамках действующего в джанге подхода. К тому же, польза такого подхода теряется полностью, если придется скомбинировать два и более фильтра:

</p><pre><code class="python">&gt;&gt;&gt; (SomeModel.s_objects.user.age &gt;= 16) &amp; (SomeModel.s_objects.user.is_active == True)
vs
&gt;&gt;&gt; SomeModel.objects.filter((S.user.age &gt;= 16) &amp; (S.user.is_active == True))
</code></pre><p>
Не так уж и кратко, не правда ли? Не говоря уже о возможных проблемах, если попытаться скомбинировать запросы из разных моделей — синтаксис ведь позволяет!

</p><h2>Послесловие</h2><p>
Как видите, написать полезную штуку бывает не так уж и сложно. В данном случае, все тяжелые операции ложаться на плечи стандартных функций джанги — ведь менеджер запросов сам проверяет, что ему передали — число, дату или F-объект, корректны ли имена полей и так далее. Также, модуль будет работать как во второй, так и третьей версиях питона.</p><p>
Если у кого-то есть какие-то идеи, замечания или предложения — пишите в комментариях или шлите пул реквесты.
</p><p>
Спасибо за внимание!

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>