<html><body><div><ul class="simple">
<li><p id="change-0.9.0b1-41"><span class="target" id="change-e911a8b7deaa9ca6726dfc5d21dfd76d"><strong>[sql] [feature] </strong></span>Added support for “unique constraint” reflection, via the
<a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints" title="sqlalchemy.engine.reflection.Inspector.get_unique_constraints"><code class="xref py py-meth docutils literal"><span class="pre">Inspector.get_unique_constraints()</span></code></a> method.
Thanks for Roman Podolyaka for the patch.<a class="changeset-link headerlink reference internal" href="#change-e911a8b7deaa9ca6726dfc5d21dfd76d">¶</a></p><p>This change is also <strong>backported</strong> to: 0.8.4</p>
<p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/1443">#1443</a></p>

</li>
<li><p id="change-0.9.0b1-42"><span class="target" id="change-93cc634b6be87be3a5f50c6295f3ece2"><strong>[sql] [feature] </strong></span>The <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.update" title="sqlalchemy.sql.expression.update"><code class="xref py py-func docutils literal"><span class="pre">update()</span></code></a>, <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.insert" title="sqlalchemy.sql.expression.insert"><code class="xref py py-func docutils literal"><span class="pre">insert()</span></code></a>, and <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.delete" title="sqlalchemy.sql.expression.delete"><code class="xref py py-func docutils literal"><span class="pre">delete()</span></code></a> constructs
will now interpret ORM entities as target tables to be operated upon,
e.g.:</p><div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">insert</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">delete</span>

<span class="n">ins</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">SomeMappedClass</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="n">del_</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">SomeMappedClass</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">SomeMappedClass</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>

<span class="n">upd</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">SomeMappedClass</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">SomeMappedClass</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'ed'</span><span class="p">)</span></pre></div>
</div>
<a class="changeset-link headerlink reference internal" href="#change-93cc634b6be87be3a5f50c6295f3ece2">¶</a><p>This change is also <strong>backported</strong> to: 0.8.3</p>
<p/>

</li>
<li><p id="change-0.9.0b1-43"><span class="target" id="change-8eb029cbdea1c892a1ad62622f54cdba"><strong>[sql] [feature] [postgresql] [mysql] </strong></span>The Postgresql and MySQL dialects now support reflection/inspection
of foreign key options, including ON UPDATE, ON DELETE.  Postgresql
also reflects MATCH, DEFERRABLE, and INITIALLY.  Coutesy ijl.<a class="changeset-link headerlink reference internal" href="#change-8eb029cbdea1c892a1ad62622f54cdba">¶</a></p><p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2183">#2183</a></p>

</li>
<li><p id="change-0.9.0b1-44"><span class="target" id="change-d24a04a8befc766ba1bf79f8656487a5"><strong>[sql] [feature] </strong></span>A <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal"><span class="pre">bindparam()</span></code></a> construct with a “null” type (e.g. no type
specified) is now copied when used in a typed expression, and the
new copy is assigned the actual type of the compared column.  Previously,
this logic would occur on the given <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal"><span class="pre">bindparam()</span></code></a> in place.
Additionally, a similar process now occurs for <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal"><span class="pre">bindparam()</span></code></a> constructs
passed to <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.ValuesBase.values" title="sqlalchemy.sql.expression.ValuesBase.values"><code class="xref py py-meth docutils literal"><span class="pre">ValuesBase.values()</span></code></a> for an <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal"><span class="pre">Insert</span></code></a> or
<a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Update" title="sqlalchemy.sql.expression.Update"><code class="xref py py-class docutils literal"><span class="pre">Update</span></code></a> construct, within the compilation phase of the
construct.</p><p>These are both subtle behavioral changes which may impact some
usages.</p>

<a class="changeset-link headerlink reference internal" href="#change-d24a04a8befc766ba1bf79f8656487a5">¶</a><p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2850">#2850</a></p>

</li>
<li><p id="change-0.9.0b1-45"><span class="target" id="change-39321a75ce7fa62c42a70b5096452d0e"><strong>[sql] [feature] </strong></span>An overhaul of expression handling for special symbols particularly
with conjunctions, e.g.
<code class="docutils literal"><span class="pre">None</span></code> <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.null" title="sqlalchemy.sql.expression.null"><code class="xref py py-func docutils literal"><span class="pre">expression.null()</span></code></a> <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.true" title="sqlalchemy.sql.expression.true"><code class="xref py py-func docutils literal"><span class="pre">expression.true()</span></code></a>
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.false" title="sqlalchemy.sql.expression.false"><code class="xref py py-func docutils literal"><span class="pre">expression.false()</span></code></a>, including consistency in rendering NULL
in conjunctions, “short-circuiting” of <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.and_" title="sqlalchemy.sql.expression.and_"><code class="xref py py-func docutils literal"><span class="pre">and_()</span></code></a> and <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.or_" title="sqlalchemy.sql.expression.or_"><code class="xref py py-func docutils literal"><span class="pre">or_()</span></code></a>
expressions which contain boolean constants, and rendering of
boolean constants and expressions as compared to “1” or “0” for backends
that don’t feature <code class="docutils literal"><span class="pre">true</span></code>/<code class="docutils literal"><span class="pre">false</span></code> constants.</p>
<a class="changeset-link headerlink reference internal" href="#change-39321a75ce7fa62c42a70b5096452d0e">¶</a><p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2734">#2734</a>, <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2804">#2804</a>, <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2823">#2823</a></p>

</li>
<li><p id="change-0.9.0b1-46"><span class="target" id="change-272e70220cd05bb94293b58f14259825"><strong>[sql] [feature] </strong></span>The typing system now handles the task of rendering “literal bind” values,
e.g. values that are normally bound parameters but due to context must
be rendered as strings, typically within DDL constructs such as
CHECK constraints and indexes (note that “literal bind” values
become used by DDL as of <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2742">#2742</a>).  A new method
<a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor" title="sqlalchemy.types.TypeEngine.literal_processor"><code class="xref py py-meth docutils literal"><span class="pre">TypeEngine.literal_processor()</span></code></a> serves as the base, and
<a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param" title="sqlalchemy.types.TypeDecorator.process_literal_param"><code class="xref py py-meth docutils literal"><span class="pre">TypeDecorator.process_literal_param()</span></code></a> is added to allow wrapping
of a native literal rendering method.</p>
<a class="changeset-link headerlink reference internal" href="#change-272e70220cd05bb94293b58f14259825">¶</a><p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2838">#2838</a></p>

</li>
<li><p id="change-0.9.0b1-47"><span class="target" id="change-98eded5d80636b193ea09e3c9865f4a1"><strong>[sql] [feature] </strong></span>The <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.tometadata" title="sqlalchemy.schema.Table.tometadata"><code class="xref py py-meth docutils literal"><span class="pre">Table.tometadata()</span></code></a> method now produces copies of
all <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.SchemaItem.info" title="sqlalchemy.schema.SchemaItem.info"><code class="xref py py-attr docutils literal"><span class="pre">SchemaItem.info</span></code></a> dictionaries from all <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.SchemaItem" title="sqlalchemy.schema.SchemaItem"><code class="xref py py-class docutils literal"><span class="pre">SchemaItem</span></code></a>
objects within the structure including columns, constraints,
foreign keys, etc.   As these dictionaries
are copies, they are independent of the original dictionary.
Previously, only the <code class="docutils literal"><span class="pre">.info</span></code> dictionary of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal"><span class="pre">Column</span></code></a> was transferred
within this operation, and it was only linked in place, not copied.<a class="changeset-link headerlink reference internal" href="#change-98eded5d80636b193ea09e3c9865f4a1">¶</a></p><p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2716">#2716</a></p>

</li>
<li><p id="change-0.9.0b1-48"><span class="target" id="change-2f3ab8473c252112e2ebb16aa940261f"><strong>[sql] [feature] </strong></span>The <code class="docutils literal"><span class="pre">default</span></code> argument of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal"><span class="pre">Column</span></code></a> now accepts a class
or object method as an argument, in addition to a standalone function;
will properly detect if the “context” argument is accepted or not.<a class="changeset-link headerlink reference internal" href="#change-2f3ab8473c252112e2ebb16aa940261f">¶</a></p><p/>

</li>
<li><p id="change-0.9.0b1-49"><span class="target" id="change-13e79ff2064616ed83c6e394ab472ee5"><strong>[sql] [feature] </strong></span>Added new method to the <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.insert" title="sqlalchemy.sql.expression.insert"><code class="xref py py-func docutils literal"><span class="pre">insert()</span></code></a> construct
<a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Insert.from_select" title="sqlalchemy.sql.expression.Insert.from_select"><code class="xref py py-meth docutils literal"><span class="pre">Insert.from_select()</span></code></a>.  Given a list of columns and
a selectable, renders <code class="docutils literal"><span class="pre">INSERT</span> <span class="pre">INTO</span> <span class="pre">(table)</span> <span class="pre">(columns)</span> <span class="pre">SELECT</span> <span class="pre">..</span></code>.
While this feature is highlighted as part of 0.9 it is also
backported to 0.8.3.</p>
<a class="changeset-link headerlink reference internal" href="#change-13e79ff2064616ed83c6e394ab472ee5">¶</a><p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/722">#722</a></p>

</li>
<li><p id="change-0.9.0b1-50"><span class="target" id="change-3300a90d71384cf7c366f03b14fa1351"><strong>[sql] [feature] </strong></span>Provided a new attribute for <a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal"><span class="pre">TypeDecorator</span></code></a>
called <a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.TypeDecorator.coerce_to_is_types" title="sqlalchemy.types.TypeDecorator.coerce_to_is_types"><code class="xref py py-attr docutils literal"><span class="pre">TypeDecorator.coerce_to_is_types</span></code></a>,
to make it easier to control how comparisons using
<code class="docutils literal"><span class="pre">==</span></code> or <code class="docutils literal"><span class="pre">!=</span></code> to <code class="docutils literal"><span class="pre">None</span></code> and boolean types goes
about producing an <code class="docutils literal"><span class="pre">IS</span></code> expression, or a plain
equality expression with a bound parameter.<a class="changeset-link headerlink reference internal" href="#change-3300a90d71384cf7c366f03b14fa1351">¶</a></p><p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2734">#2734</a>, <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2744">#2744</a></p>

</li>
<li><p id="change-0.9.0b1-51"><span class="target" id="change-e50ad7b22d3a616aeb47cf832c27097a"><strong>[sql] [feature] </strong></span>A <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.label" title="sqlalchemy.sql.expression.label"><code class="xref py py-func docutils literal"><span class="pre">label()</span></code></a> construct will now render as its name alone
in an <code class="docutils literal"><span class="pre">ORDER</span> <span class="pre">BY</span></code> clause, if that label is also referred to
in the columns clause of the select, instead of rewriting the
full expression.  This gives the database a better chance to
optimize the evaluation of the same expression in two different
contexts.</p>
<a class="changeset-link headerlink reference internal" href="#change-e50ad7b22d3a616aeb47cf832c27097a">¶</a><p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/1068">#1068</a></p>

</li>
<li><p id="change-0.9.0b1-52"><span class="target" id="change-4a3641b48480cf313538449a8e5b1c5f"><strong>[sql] [bug] </strong></span>Fixed bug where <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal"><span class="pre">type_coerce()</span></code></a> would not interpret ORM
elements with a <code class="docutils literal"><span class="pre">__clause_element__()</span></code> method properly.<a class="changeset-link headerlink reference internal" href="#change-4a3641b48480cf313538449a8e5b1c5f">¶</a></p><p>This change is also <strong>backported</strong> to: 0.8.3</p>
<p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2849">#2849</a></p>

</li>
<li><p id="change-0.9.0b1-53"><span class="target" id="change-a5059e2a0d6f7ae306b16d71a6884f3f"><strong>[sql] [bug] </strong></span>The <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.types.Enum"><code class="xref py py-class docutils literal"><span class="pre">Enum</span></code></a> and <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Boolean" title="sqlalchemy.types.Boolean"><code class="xref py py-class docutils literal"><span class="pre">Boolean</span></code></a> types now bypass
any custom (e.g. TypeDecorator) type in use when producing the
CHECK constraint for the “non native” type.  This so that the custom type
isn’t involved in the expression within the CHECK, since this
expression is against the “impl” value and not the “decorated” value.<a class="changeset-link headerlink reference internal" href="#change-a5059e2a0d6f7ae306b16d71a6884f3f">¶</a></p><p>This change is also <strong>backported</strong> to: 0.8.3</p>
<p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2842">#2842</a></p>

</li>
<li><p id="change-0.9.0b1-54"><span class="target" id="change-2d486e59e387ed6c8d50bf5d99627cdf"><strong>[sql] [bug] </strong></span>The <code class="docutils literal"><span class="pre">.unique</span></code> flag on <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Index" title="sqlalchemy.schema.Index"><code class="xref py py-class docutils literal"><span class="pre">Index</span></code></a> could be produced as <code class="docutils literal"><span class="pre">None</span></code>
if it was generated from a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal"><span class="pre">Column</span></code></a> that didn’t specify <code class="docutils literal"><span class="pre">unique</span></code>
(where it defaults to <code class="docutils literal"><span class="pre">None</span></code>).  The flag will now always be <code class="docutils literal"><span class="pre">True</span></code> or
<code class="docutils literal"><span class="pre">False</span></code>.<a class="changeset-link headerlink reference internal" href="#change-2d486e59e387ed6c8d50bf5d99627cdf">¶</a></p><p>This change is also <strong>backported</strong> to: 0.8.3</p>
<p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2825">#2825</a></p>

</li>
<li><p id="change-0.9.0b1-55"><span class="target" id="change-6f6cd0ca9e6e5050ad6d52b884122ea9"><strong>[sql] [bug] </strong></span>Fixed bug in default compiler plus those of postgresql, mysql, and
mssql to ensure that any literal SQL expression values are
rendered directly as literals, instead of as bound parameters,
within a CREATE INDEX statement.  This also changes the rendering
scheme for other DDL such as constraints.<a class="changeset-link headerlink reference internal" href="#change-6f6cd0ca9e6e5050ad6d52b884122ea9">¶</a></p><p>This change is also <strong>backported</strong> to: 0.8.3</p>
<p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2742">#2742</a></p>

</li>
<li><p id="change-0.9.0b1-56"><span class="target" id="change-0e498b684ea9cbcfc3f277d61204d65b"><strong>[sql] [bug] </strong></span>A <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal"><span class="pre">select()</span></code></a> that is made to refer to itself in its FROM clause,
typically via in-place mutation, will raise an informative error
message rather than causing a recursion overflow.<a class="changeset-link headerlink reference internal" href="#change-0e498b684ea9cbcfc3f277d61204d65b">¶</a></p><p>This change is also <strong>backported</strong> to: 0.8.3</p>
<p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2815">#2815</a></p>

</li>
<li><p id="change-0.9.0b1-57"><span class="target" id="change-6e1a5094981c35f027081bae82ca704a"><strong>[sql] [bug] </strong></span>Fixed bug where using the <code class="docutils literal"><span class="pre">column_reflect</span></code> event to change the <code class="docutils literal"><span class="pre">.key</span></code>
of the incoming <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal"><span class="pre">Column</span></code></a> would prevent primary key constraints,
indexes, and foreign key constraints from being correctly reflected.<a class="changeset-link headerlink reference internal" href="#change-6e1a5094981c35f027081bae82ca704a">¶</a></p><p>This change is also <strong>backported</strong> to: 0.8.3</p>
<p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2811">#2811</a></p>

</li>
<li><p id="change-0.9.0b1-58"><span class="target" id="change-d12e927d520f09485a8678152c280b4e"><strong>[sql] [bug] </strong></span>The <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.notin_" title="sqlalchemy.sql.operators.ColumnOperators.notin_"><code class="xref py py-meth docutils literal"><span class="pre">ColumnOperators.notin_()</span></code></a> operator added in 0.8 now properly
produces the negation of the expression “IN” returns
when used against an empty collection.<a class="changeset-link headerlink reference internal" href="#change-d12e927d520f09485a8678152c280b4e">¶</a></p><p>This change is also <strong>backported</strong> to: 0.8.3</p>
<p/>

</li>
<li><p id="change-0.9.0b1-59"><span class="target" id="change-2c8dbe177a3c8cba08249e3cdeca2362"><strong>[sql] [bug] [postgresql] </strong></span>Fixed bug where the expression system relied upon the <code class="docutils literal"><span class="pre">str()</span></code>
form of a some expressions when referring to the <code class="docutils literal"><span class="pre">.c</span></code> collection
on a <code class="docutils literal"><span class="pre">select()</span></code> construct, but the <code class="docutils literal"><span class="pre">str()</span></code> form isn’t available
since the element relies on dialect-specific compilation constructs,
notably the <code class="docutils literal"><span class="pre">__getitem__()</span></code> operator as used with a Postgresql
<code class="docutils literal"><span class="pre">ARRAY</span></code> element.  The fix also adds a new exception class
<a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.UnsupportedCompilationError" title="sqlalchemy.exc.UnsupportedCompilationError"><code class="xref py py-exc docutils literal"><span class="pre">UnsupportedCompilationError</span></code></a> which is raised in those cases
where a compiler is asked to compile something it doesn’t know
how to.<a class="changeset-link headerlink reference internal" href="#change-2c8dbe177a3c8cba08249e3cdeca2362">¶</a></p><p>This change is also <strong>backported</strong> to: 0.8.3</p>
<p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2780">#2780</a></p>

</li>
<li><p id="change-0.9.0b1-60"><span class="target" id="change-ec66deaad21dd8b26baa4f0b315154b4"><strong>[sql] [bug] </strong></span>Multiple fixes to the correlation behavior of
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal"><span class="pre">Select</span></code></a> constructs, first introduced in 0.8.0:</p><ul>
<li>To satisfy the use case where FROM entries should be
correlated outwards to a SELECT that encloses another,
which then encloses this one, correlation now works
across multiple levels when explicit correlation is
established via <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.correlate" title="sqlalchemy.sql.expression.Select.correlate"><code class="xref py py-meth docutils literal"><span class="pre">Select.correlate()</span></code></a>, provided
that the target select is somewhere along the chain
contained by a WHERE/ORDER BY/columns clause, not
just nested FROM clauses. This makes
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.correlate" title="sqlalchemy.sql.expression.Select.correlate"><code class="xref py py-meth docutils literal"><span class="pre">Select.correlate()</span></code></a> act more compatibly to
that of 0.7 again while still maintaining the new
“smart” correlation.</li>
<li>When explicit correlation is not used, the usual
“implicit” correlation limits its behavior to just
the immediate enclosing SELECT, to maximize compatibility
with 0.7 applications, and also prevents correlation
across nested FROMs in this case, maintaining compatibility
with 0.8.0/0.8.1.</li>
<li>The <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except" title="sqlalchemy.sql.expression.Select.correlate_except"><code class="xref py py-meth docutils literal"><span class="pre">Select.correlate_except()</span></code></a> method was not
preventing the given FROM clauses from correlation in
all cases, and also would cause FROM clauses to be incorrectly
omitted entirely (more like what 0.7 would do),
this has been fixed.</li>
<li>Calling <cite>select.correlate_except(None)</cite> will enter
all FROM clauses into correlation as would be expected.</li>
</ul>
<a class="changeset-link headerlink reference internal" href="#change-ec66deaad21dd8b26baa4f0b315154b4">¶</a><p>This change is also <strong>backported</strong> to: 0.8.2</p>
<p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2668">#2668</a>, <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2746">#2746</a></p>

</li>
<li><p id="change-0.9.0b1-61"><span class="target" id="change-69bb8fab2a49ae9f49bba3d45913e256"><strong>[sql] [bug] </strong></span>Fixed bug whereby joining a select() of a table “A” with multiple
foreign key paths to a table “B”, to that table “B”, would fail
to produce the “ambiguous join condition” error that would be
reported if you join table “A” directly to “B”; it would instead
produce a join condition with multiple criteria.<a class="changeset-link headerlink reference internal" href="#change-69bb8fab2a49ae9f49bba3d45913e256">¶</a></p><p>This change is also <strong>backported</strong> to: 0.8.2</p>
<p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2738">#2738</a></p>

</li>
<li><p id="change-0.9.0b1-62"><span class="target" id="change-875b41219bbc43340ccf3d1e7d1f5fbf"><strong>[sql] [bug] [reflection] </strong></span>Fixed bug whereby using <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData.reflect" title="sqlalchemy.schema.MetaData.reflect"><code class="xref py py-meth docutils literal"><span class="pre">MetaData.reflect()</span></code></a> across a remote
schema as well as a local schema could produce wrong results
in the case where both schemas had a table of the same name.<a class="changeset-link headerlink reference internal" href="#change-875b41219bbc43340ccf3d1e7d1f5fbf">¶</a></p><p>This change is also <strong>backported</strong> to: 0.8.2</p>
<p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2728">#2728</a></p>

</li>
<li><p id="change-0.9.0b1-63"><span class="target" id="change-413cb4c102d2705b115721cf5917ed43"><strong>[sql] [bug] </strong></span>Removed the “not implemented” <code class="docutils literal"><span class="pre">__iter__()</span></code> call from the base
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal"><span class="pre">ColumnOperators</span></code></a> class, while this was introduced
in 0.8.0 to prevent an endless, memory-growing loop when one also
implements a <code class="docutils literal"><span class="pre">__getitem__()</span></code> method on a custom
operator and then calls erroneously <code class="docutils literal"><span class="pre">list()</span></code> on that object,
it had the effect of causing column elements to report that they
were in fact iterable types which then throw an error when you try
to iterate.   There’s no real way to have both sides here so we
stick with Python best practices.  Careful with implementing
<code class="docutils literal"><span class="pre">__getitem__()</span></code> on your custom operators!<a class="changeset-link headerlink reference internal" href="#change-413cb4c102d2705b115721cf5917ed43">¶</a></p><p>This change is also <strong>backported</strong> to: 0.8.2</p>
<p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2726">#2726</a></p>

</li>
<li><p id="change-0.9.0b1-64"><span class="target" id="change-97b9ec01528f6ce1a103f8b8800d8b35"><strong>[sql] [bug] </strong></span>Fixed regression dating back to 0.7.9 whereby the name of a CTE might
not be properly quoted if it was referred to in multiple FROM clauses.<a class="changeset-link headerlink reference internal" href="#change-97b9ec01528f6ce1a103f8b8800d8b35">¶</a></p><p>This change is also <strong>backported</strong> to: 0.8.3, 0.7.11</p>
<p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2801">#2801</a></p>

</li>
<li><p id="change-0.9.0b1-65"><span class="target" id="change-0b6b7933cd03daaa51c88661f6a18a77"><strong>[sql] [bug] [cte] </strong></span>Fixed bug in common table expression system where if the CTE were
used only as an <code class="docutils literal"><span class="pre">alias()</span></code> construct, it would not render using the
WITH keyword.<a class="changeset-link headerlink reference internal" href="#change-0b6b7933cd03daaa51c88661f6a18a77">¶</a></p><p>This change is also <strong>backported</strong> to: 0.8.3, 0.7.11</p>
<p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2783">#2783</a></p>

</li>
<li><p id="change-0.9.0b1-66"><span class="target" id="change-ee864489da68afbc90051f4bb9d0f94c"><strong>[sql] [bug] </strong></span>Fixed bug in <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.CheckConstraint" title="sqlalchemy.schema.CheckConstraint"><code class="xref py py-class docutils literal"><span class="pre">CheckConstraint</span></code></a> DDL where the “quote” flag from a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal"><span class="pre">Column</span></code></a> object would not be propagated.<a class="changeset-link headerlink reference internal" href="#change-ee864489da68afbc90051f4bb9d0f94c">¶</a></p><p>This change is also <strong>backported</strong> to: 0.8.3, 0.7.11</p>
<p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2784">#2784</a></p>

</li>
<li><p id="change-0.9.0b1-67"><span class="target" id="change-68ca19e2d66effbff44cb5a9c9633d5f"><strong>[sql] [bug] </strong></span>The “name” attribute is set on <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Index" title="sqlalchemy.schema.Index"><code class="xref py py-class docutils literal"><span class="pre">Index</span></code></a> before the “attach”
events are called, so that attachment events can be used to dynamically
generate a name for the index based on the parent table and/or
columns.<a class="changeset-link headerlink reference internal" href="#change-68ca19e2d66effbff44cb5a9c9633d5f">¶</a></p><p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2835">#2835</a></p>

</li>
<li><p id="change-0.9.0b1-68"><span class="target" id="change-f9093cc2030bb467e2b99b6844eee451"><strong>[sql] [bug] </strong></span>The erroneous kw arg “schema” has been removed from the <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKey" title="sqlalchemy.schema.ForeignKey"><code class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></code></a>
object. this was an accidental commit that did nothing; a warning is raised
in 0.8.3 when this kw arg is used.<a class="changeset-link headerlink reference internal" href="#change-f9093cc2030bb467e2b99b6844eee451">¶</a></p><p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2831">#2831</a></p>

</li>
<li><p id="change-0.9.0b1-69"><span class="target" id="change-80f90191c40a63606c13f48bd62758c9"><strong>[sql] [bug] </strong></span>A rework to the way that “quoted” identifiers are handled, in that
instead of relying upon various <code class="docutils literal"><span class="pre">quote=True</span></code> flags being passed around,
these flags are converted into rich string objects with quoting information
included at the point at which they are passed to common schema constructs
like <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal"><span class="pre">Table</span></code></a>, <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal"><span class="pre">Column</span></code></a>, etc.   This solves the issue
of various methods that don’t correctly honor the “quote” flag such
as <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine.has_table" title="sqlalchemy.engine.Engine.has_table"><code class="xref py py-meth docutils literal"><span class="pre">Engine.has_table()</span></code></a> and related methods.  The <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.elements.quoted_name" title="sqlalchemy.sql.elements.quoted_name"><code class="xref py py-class docutils literal"><span class="pre">quoted_name</span></code></a>
object is a string subclass that can also be used explicitly if needed;
the object will hold onto the quoting preferences passed and will
also bypass the “name normalization” performed by dialects that
standardize on uppercase symbols, such as Oracle, Firebird and DB2.
The upshot is that the “uppercase” backends can now work with force-quoted
names, such as lowercase-quoted names and new reserved words.</p>
<a class="changeset-link headerlink reference internal" href="#change-80f90191c40a63606c13f48bd62758c9">¶</a><p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/2812">#2812</a></p>

</li>
<li><p id="change-0.9.0b1-70"><span class="target" id="change-6116437230b6aca55206409a957f932e"><strong>[sql] [bug] </strong></span>The resolution of <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKey" title="sqlalchemy.schema.ForeignKey"><code class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></code></a> objects to their
target <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal"><span class="pre">Column</span></code></a> has been reworked to be as
immediate as possible, based on the moment that the
target <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal"><span class="pre">Column</span></code></a> is associated with the same
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal"><span class="pre">MetaData</span></code></a> as this <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKey" title="sqlalchemy.schema.ForeignKey"><code class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></code></a>, rather
than waiting for the first time a join is constructed,
or similar. This along with other improvements allows
earlier detection of some foreign key configuration
issues.  Also included here is a rework of the
type-propagation system, so that
it should be reliable now to set the type as <code class="docutils literal"><span class="pre">None</span></code>
on any <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal"><span class="pre">Column</span></code></a> that refers to another via
<a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKey" title="sqlalchemy.schema.ForeignKey"><code class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></code></a> - the type will be copied from the
target column as soon as that other column is associated,
and now works for composite foreign keys as well.</p>
<a class="changeset-link headerlink reference internal" href="#change-6116437230b6aca55206409a957f932e">¶</a><p>References: <a class="reference external" href="http://www.sqlalchemy.org/trac/ticket/1765">#1765</a></p>

</li>
</ul>
</div></body></html>