<html><body><div><div class="section">
              <h1>psq 0.2.1</h1>

              


<p>A simple task queue using Google Cloud Pub/Sub</p>








<p><a href="https://travis-ci.org/GoogleCloudPlatform/psq" rel="nofollow"><img src="https://travis-ci.org/GoogleCloudPlatform/psq.svg"/>
</a> <a href="https://coveralls.io/github/GoogleCloudPlatform/psq?branch=master" rel="nofollow"><img src="https://coveralls.io/repos/GoogleCloudPlatform/psq/badge.svg?branch=master&amp;service=github"/></a> <a href="https://pypi.python.org/pypi/psq" rel="nofollow"><img src="https://img.shields.io/pypi/v/psq.svg"/>
</a></p>
<p><tt>psq</tt> is an example Python implementation of a simple distributed task
queue using <a href="https://cloud.google.com/pubsub/" rel="nofollow">Google Cloud Pub/Sub</a>.</p>
<p><tt>psq</tt> requires minimal configuration and relies on Cloud Pub/Sub to
provide scalable and reliable messaging.</p>
<p><tt>psq</tt> is intentionally similar to <a href="http://python-rq.org/" rel="nofollow">rq</a> and
<a href="https://github.com/rdegges/simpleq" rel="nofollow">simpleq</a>, and takes some
inspiration from <a href="http://www.celeryproject.org/" rel="nofollow">celery</a> and <a href="http://jeffknupp.com/blog/2014/02/11/a-celerylike-python-task-queue-in-55-lines-of-code/" rel="nofollow">this
blog
post</a>.</p>
<div id="installation">
<h2>Installation</h2>
<p>Install via <a href="https://pypi.python.org/pypi/pip" rel="nofollow">pip</a>:</p>
<pre>pip install psq
</pre>
</div>
<div id="prerequisites">
<h2>Prerequisites</h2>
<ul>
<li>A project on the <a href="https://console.developers.google.com" rel="nofollow">Google Developers
Console</a>.</li>
<li>The <a href="https://cloud.google.com/sdk" rel="nofollow">Google Cloud SDK</a> installed
locally.</li>
<li>You will need the <a href="https://console.developers.google.com/flows/enableapi?apiid=datastore,pubsub" rel="nofollow">Cloud Pub/Sub API
enabled</a>
on your project. The link will walk you through enabling the API.</li>
<li>You will need to run <tt>gcloud auth</tt> before running these examples so
that authentication to Google Cloud Platform services is handled
transparently.</li>
</ul>
</div>
<div id="usage">
<h2>Usage</h2>
<p>First, create a task:</p>
<pre><span class="k">def</span> <span class="nf">adder</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre>
<p>Then, create a pubsub client and a queue:</p>
<pre><span class="kn">from</span> <span class="nn">gcloud</span> <span class="kn">import</span> <span class="n">pubsub</span>
<span class="kn">import</span> <span class="nn">psq</span>


<span class="n">PROJECT_ID</span> <span class="o">=</span> <span class="s1">'your-project-id'</span>

<span class="n">client</span> <span class="o">=</span> <span class="n">pubsub</span><span class="o">.</span><span class="n">Client</span><span class="p">(</span><span class="n">project</span><span class="o">=</span><span class="n">PROJECT_ID</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">psq</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
</pre>
<p>Now you can enqueue tasks:</p>
<pre><span class="kn">from</span> <span class="nn">tasks</span> <span class="kn">import</span> <span class="n">adder</span>

<span class="n">q</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">adder</span><span class="p">)</span>
</pre>
<p>In order to get task results, you have to configure storage:</p>
<pre><span class="kn">from</span> <span class="nn">gcloud</span> <span class="kn">import</span> <span class="n">pubsub</span>
<span class="kn">import</span> <span class="nn">psq</span>


<span class="n">PROJECT_ID</span> <span class="o">=</span> <span class="s1">'your-project-id'</span>

<span class="n">ps_client</span> <span class="o">=</span> <span class="n">pubsub</span><span class="o">.</span><span class="n">Client</span><span class="p">(</span><span class="n">project</span><span class="o">=</span><span class="n">PROJECT_ID</span><span class="p">)</span>
<span class="n">ds_client</span> <span class="o">=</span> <span class="n">datastore</span><span class="o">.</span><span class="n">Client</span><span class="p">(</span><span class="n">dataset_id</span><span class="o">=</span><span class="n">PROJECT_ID</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">psq</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span>
    <span class="n">ps_client</span><span class="p">,</span>
    <span class="n">storage</span><span class="o">=</span><span class="n">psq</span><span class="o">.</span><span class="n">DatastoreStorage</span><span class="p">(</span><span class="n">ds_client</span><span class="p">))</span>
</pre>
<p>With storage configured, you can get the result of a task:</p>
<pre><span class="n">r</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">adder</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">r</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="c1"># -&gt; 11</span>
</pre>
<p>You can also define multiple queues:</p>
<pre><span class="n">fast</span> <span class="o">=</span> <span class="n">psq</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="s1">'fast'</span><span class="p">)</span>
<span class="n">slow</span> <span class="o">=</span> <span class="n">psq</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="s1">'slow'</span><span class="p">)</span>
</pre>
</div>
<div id="things-to-note">
<h2>Things to note</h2>
<p>Because <tt>psq</tt> is largely similar to <tt>rq</tt>, similar rules around tasks
apply. You can put any Python function call on a queue, provided:</p>
<ul>
<li>The function is importable by the worker. This means the
<tt>__module__</tt> that the function lives in must be importable.
Notably, you can’t enqueue functions that are declared in the
<strong>main</strong> module - such as tasks defined in a file that is run
directly with <tt>python</tt> or via the interactive interpreter.</li>
<li>The function can be a string, but it must be the absolutely importable path
to a function that the worker can import. Otherwise, the task will fail.</li>
<li>The worker and the applications queuing tasks must share exactly the
same source code.</li>
<li>The function can’t depend on global context such as global variables,
current_request, etc. Pass any needed context into the worker at
queue time.</li>
</ul>
<div id="delivery-guarantees">
<h3>Delivery guarantees</h3>
<p>Pub/sub guarantees your tasks will be delivered to the workers, but
<tt>psq</tt> doesn’t presently guarantee that a task completes execution or
exactly-once semantics, though it does allow you to provide your own
mechanisms for this. This is similar to Celery’s
<a href="http://celery.readthedocs.org/en/latest/faq.html#faq-acks-late-vs-retry" rel="nofollow">default</a>
configuration.</p>
<p>Task completion guarantees can be provided via late ack support. Late
ack is possible with Cloud Pub/sub, but it currently not implemented in
this library. See <a href="https://github.com/GoogleCloudPlatform/psq/blob/master/CONTRIBUTING.md" rel="nofollow">CONTRIBUTING.md</a>.</p>
<p>There are many approaches for exactly-once semantics, such as
distributed locks. This is possible in systems such as
<a href="http://zookeeper.apache.org/doc/r3.1.2/recipes.html#sc_recipes_Locks" rel="nofollow">zookeeper</a>
and <a href="http://redis.io/topics/distlock" rel="nofollow">redis</a>.</p>
</div>
</div>
<div id="running-a-worker">
<h2>Running a worker</h2>
<p>Execute <tt>psqworker</tt> in the <em>same directory where you tasks are
defined</em>:</p>
<pre>psqworker.py config.q
</pre>
<p><tt>psqworker</tt> only operates on one queue at a time. If you want a server
to listen to multiple queues, use something like
<a href="http://supervisord.org/" rel="nofollow">supervisord</a> to run multiple <tt>psqworker</tt>
processes.</p>
</div>
<div id="broadcast-queues">
<h2>Broadcast queues</h2>
<p>A normal queue will send a single task to a single worker, spreading
your tasks over all workers listening to the same queue. There are also
broadcast queues, which will deliver a copy of the task to <em>every</em>
worker. This is useful in situations where you want every worker to
execute the same task, such as installing or upgrading software on every
server.</p>
<pre><span class="n">broadcast_q</span> <span class="o">=</span> <span class="n">psq</span><span class="o">.</span><span class="n">BroadcastQueue</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">restart_apache_task</span><span class="p">():</span>
    <span class="n">call</span><span class="p">([</span><span class="s2">"apachectl"</span><span class="p">,</span> <span class="s2">"restart"</span><span class="p">])</span>

<span class="n">broadcast_q</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">restart_apache_task</span><span class="p">)</span>
</pre>
<p>Broadcast queues provide an implementation of the solution described in
<a href="https://cloud.google.com/solutions/reliable-task-scheduling-compute-engine" rel="nofollow">Reliable Task Scheduling on Google Compute
Engine</a>.</p>
<p><em>Note</em>: broadcast queues do not currently support any form of storage
and do not support return values.</p>
</div>
<div id="retries">
<h2>Retries</h2>
<p>Raising <tt>psq.Retry</tt> in your task will cause it to be retried.</p>
<pre><span class="kn">from</span> <span class="nn">psq</span> <span class="kn">import</span> <span class="n">Retry</span>

<span class="k">def</span> <span class="nf">retry_if_fail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'http://some.flaky.service.com'</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">Retry</span><span class="p">()</span>
</pre>
</div>
<div id="flask-other-contexts">
<h2>Flask &amp; other contexts</h2>
<p>You can bind an extra context manager to the queue.</p>
<pre><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">psq</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">extra_context</span><span class="o">=</span><span class="n">app</span><span class="o">.</span><span class="n">app_context</span><span class="p">)</span>
</pre>
<p>This will ensure that the context is available in your tasks, which is
useful for things such as database connections, etc.:</p>
<pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">current_app</span>

<span class="k">def</span> <span class="nf">flasky_task</span><span class="p">():</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="n">current_app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">'BACKEND'</span><span class="p">]</span>
</pre>
</div>
<div id="ideas-for-improvements">
<h2>Ideas for improvements</h2>
<ul>
<li>some sort of storage solution for broadcast queues.</li>
<li>Memcache/redis value store.</li>
<li>@task decorator that adds a delay/defer function.</li>
<li>Task chaining / groups / chords.</li>
<li>Late ack.</li>
<li>Gevent worker.</li>
<li>batch support for queueing.</li>
</ul>
</div>




<a name="downloads"> </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>105</span> downloads in the last week
  </li>
  <li>
    <span>806</span> downloads in the last month
  </li>
</ul>









            </div>


          </div></body></html>