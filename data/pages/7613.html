<html><body><div><div class="content html_format"><p>
      Программа, способная к логическим выводам в рамках поставленной задачи, может казаться техническим чудом и воплощением Скайнета. Но, как можно убедиться ниже, на сегодняшний день создать такую программу на языке Python не составит труда, если использовать семантические технологии. Мы остановимся на наглядном примере онтологий — родословных — и для любого члена семьи в родословной сможем выводить его родственные отношения произвольной сложности (она ограничена вычислительными ресурсами). К примеру, на фамильном древе семьи Романовых ниже показан внучатый двоюродный племянник (first cousin twice removed) российского императора Петра II.</p>

<img src="https://habrastorage.org/getpro/habr/post_images/d23/314/13a/d2331413a25143c93218a2b9796c666d.png" alt="image"/>
<p>
Так что если вы хотите познакомиться с технологиями семантического веба на практике, добро пожаловать под кат, где мы потренируемся </p><s>на кошках</s><p> на родословных.
</p><a name="habracut"/><p>
О триплетах, RDF и онтологиях можно прочесть в </p><a href="https://en.wikipedia.org/wiki/Semantic_Web">википедии</a><p> или в </p><a href="http://habrahabr.ru/post/14849">других</a> <a href="http://habrahabr.ru/company/itis/blog/258405">постах</a><p>. Для описания семейных связей в родословных мы задействуем OWL 2 онтологию Family History Knowledge Base (</p><a href="http://ceur-ws.org/Vol-1207/paper_11.pdf">FHKB</a><p>). Заметим, что авторы FHKB хотя и признают своё детище хорошим учебным примером, всё же </p><a href="http://www.researchgate.net/publication/271131820_Manchester_Family_History_Advanced_OWL_Tutorial">не рекомендуют</a><p> OWL 2 к использованию в реальных генеалогических приложениях из-за вычислительной сложности для сегодняшних систем рассуждений. Наше же приложение останется учебным: мы ограничимся небольшими генеалогиями до ста членов семей.
</p><p>
Генеалогические данные обычно доступны в текстовом формате </p><a href="https://en.wikipedia.org/wiki/GEDCOM">GEDCOM</a><p> (</p><b>.ged</b><p>). Некоторые генеалогические порталы и программы по ведению родословных позволяют выгружать графы связей в этом формате. Мы прочитаем GEDCOM при помощи </p><a href="https://github.com/madprime/python-gedcom">одноимённой библиотеки</a><p> для языка Python и сгенерируем триплеты индивидуумов (так называемый </p><a href="https://en.wikipedia.org/wiki/Abox">ABox</a><p>) для онтологии FHKB. Логика (</p><a href="https://en.wikipedia.org/wiki/Tbox">TBox</a><p>) для выведения родственных связей у нас уже имеется, и всё, что нам нужно сделать — это задать данные, к которым эта логика будет применяться.
</p><p>
Представим, что у нас есть данные для следующих трёх индивидуумов (абстрактно), на примере вышеупомянутой семьи русских царей:

</p><pre><code class="markdown">Александр I *есть-брат* Николая I.
Николай I *есть-отец* Александра II.
</code></pre>
<p>
и логика FHKB:

</p><pre><code class="markdown">Свойство *есть-дядя* является последовательностью свойств *есть-брат* и *есть-отец*.
</code></pre>
<p>
Тогда система рассуждений в состоянии установить следующий факт:

</p><pre><code class="markdown">Александр I *есть-дядя* Александра II.
</code></pre>
<p>
Эта же информация на RDF-наречии </p><a href="http://www.w3.org/TR/turtle">Turtle</a><p> ниже. Оно компактно и довольно легко читается:

</p><pre><code class="markdown">fhkb:i1 a owl:NamedIndividual ;
    fhkb:isBrotherOf fhkb:i2 ;
    rdfs:label "Александр I" .

fhkb:i2 a owl:NamedIndividual ;
    fhkb:isFatherOf fhkb:i3 ;
    rdfs:label "Николай I" .

fhkb:i3 a owl:NamedIndividual ;
    rdfs:label "Александр II" .

fhkb:isFatherOf a owl:ObjectProperty ;
    rdfs:label "есть-отец" .

fhkb:isBrotherOf a owl:ObjectProperty ;
    rdfs:label "есть-брат" .

fhkb:isUncleOf a owl:ObjectProperty ;
    owl:propertyChainAxiom ( fhkb:isBrotherOf fhkb:isFatherOf ) ;
    rdfs:label "есть-дядя" .
</code></pre>
<p>
(Примечание: здесь опущены некоторые детали для наглядности. В оригинальной FHKB свойства </p><i>isFatherOf</i><p>, </p><i>isBrotherOf</i><p> и </p><i>isUncleOf</i><p> определены несколько иначе для оптимизации логических рассуждений.)
</p><p>
Итак, мы задали индивидуумов </p><i>i1</i><p>, </p><i>i2</i><p> и </p><i>i3</i><p>, свойства </p><i>isFatherOf</i><p> и </p><i>isBrotherOf</i><p>, назначили эти свойства индивидуумам и ввели новое свойство </p><i>isUncleOf</i><p>. Обратим внимание на префиксы </p><b>rdfs</b><p>:, </p><b>owl</b><p>: и </p><b>fhkb</b><p>: — они показывают задействованные области знаний. Префикс </p><b>rdfs</b><p>: указывает на стандартную схему RDF (в примере выше это свойство label). Префикс </p><b>owl</b><p>: указывает на стандартные онтологические термины (индивидуум, свойство, последовательность свойств и т.д.). А префикс </p><b>fhkb</b><p>: — это используемая нами генеалогическая онтология FHKB, где определена логика родственных связей (</p><i>isFatherOf</i><p>, </p><i>isBrotherOf</i><p>, </p><i>isUncleOf</i><p>, а также другие термины, </p><i>isGrandfatherOf</i><p>, </p><i>isFirstCousinOf</i><p> и т.д.).
</p><p>
Для каждого индивидуума нам достаточно взять из GEDCOM только минимальную информацию об отцовстве (материнстве), братьях, сёстрах и браках (по сути, GEDCOM больше ничего и не содержит), все остальные родственные связи, логика для которых нам дана в FHKB, будут выведены системой рассуждений.

</p><img src="https://habrastorage.org/getpro/habr/post_images/a17/192/a67/a17192a67bf6a864b08603ccac07a16f.png" alt="image"/>
<p>
Итак, логическая база (TBox) доступна в Turtle-файле </p><a href="https://github.com/blokhin/genealogical-trees/blob/master/data/header.ttl"><b>header.ttl</b></a><p> из репозитория для этой статьи. Генеалогия царской семьи Романовых в GEDCOM тоже </p><a href="https://github.com/blokhin/genealogical-trees/blob/master/data/tsars.ged">присутствует</a><p>, но читателю рекомендуется взять свою для интереса. А вот и скрипт, который сгенерирует индивидуумов для онтологии FHKB из GEDCOM-файла: </p><a href="https://github.com/blokhin/genealogical-trees/blob/master/gedcom2ttl.py"><b>gedcom2ttl.py</b></a><p>. (После клонирования репозитория необходимо установить Python-зависимости при помощи команды </p><b>pip install -r requirements.txt</b><p>.) Скопируем FHKB-логику </p><b>header.ttl</b><p> в новый файл и дозапишем в него результат работы скрипта:

</p><pre><code class="bash">cp data/header.ttl romanov_family.ttl
./gedcom2ttl.py data/tsars.ged &gt;&gt; romanov_family.ttl
</code></pre>
<p>
В результате у нас получилась онтология (TBox+ABox) в формате Turtle, которую можно открыть в любом внешнем редакторе (например, </p><a href="http://protege.stanford.edu">Protégé</a><p>). При необходимости Turtle может быть преобразован в XML-формат OWL с помощью скрипта </p><a href="https://github.com/blokhin/genealogical-trees/blob/master/ttl2owl.py"><b>ttl2owl.py</b></a><p>. Теперь выведение родственных связей по этой онтологии — дело техники. Мне известны три современные системы рассуждений для языка Python с открытым исходным кодом: </p><a href="https://github.com/RDFLib/OWL-RL">RDFClosure</a><p>, </p><a href="https://github.com/RDFLib/FuXi">FuXi</a><p> и </p><a href="http://owl.man.ac.uk/factplusplus">Fact++</a><p> с обёрткой </p><a href="http://owl-cpp.sourceforge.net"><i>owlcpp</i></a><p>. На самом деле, их гораздо больше, если «подружить» Python с виртуальной машиной Java (исторически Java лидирует в семантических технологиях и предоставляет гораздо больший набор инструментов). Упомянутые три выстроены по нарастанию сложности и производительности. Первая представляет собой наивный подход «грубой силы», когда все возможные триплеты генерируются методом перебора. Вторая (FuXi) основана на инфиксной Python-нотации для OWL и </p><a href="https://ru.wikipedia.org/wiki/Алгоритм_Rete">алгоритме Rete</a><p>. Третья (Fact++) является низкоуровневой оптимизированной реализацией </p><a href="http://www.cs.ox.ac.uk/ian.horrocks/Publications/download/2007/HoSa07a.pdf">алгоритма Tableaux</a><p>. В целом, на сегодня это одна из самых эффективных систем рассуждений с открытым исходным кодом. Для наших задач достаточно первой системы (RDFClosure), тем более, что она написана на чистом Python и устанавливается тривиальной командой pip install. Для рассуждений по генеалогии Романовых </p><b>tsars.ged</b><p> (41 член семьи) RDFClosure на ноутбуке с Intel Core i7 1.70GHz требует около десяти секунд.
</p><p>
Как уже говорилось, недостатком OWL 2 применительно к родословным является вычислительная сложность. Я опустил некоторые родственные отношения, упомянутые на иллюстрации выше, и сократил семейное древо Романовых до царственных особ и их ближайших родственников, чтобы демонстрационные рассуждения не загружали ваш компьютер слишком сильно. Если задать все родственные связи с иллюстрации выше и расширить генеалогию хотя бы до нескольких сотен членов семей, RDFClosure становится бесполезной (Fact++, впрочем, продолжает работать).
</p><p>
Запустим рассуждения для полученной выше онтологии:

</p><pre><code class="bash">./infer.py romanov_family.ttl
</code></pre>
<p>
Пока идут рассуждения, поясню ключевые моменты скрипта </p><a href="https://github.com/blokhin/genealogical-trees/blob/master/infer.py"><b>infer.py</b></a><p>. Его суть умещается в шести строках:

</p><pre><code class="python">import rdflib
from RDFClosure import DeductiveClosure, OWLRL_Extension
g = rdflib.Graph()
g.parse("romanov_family.ttl", format="turtle")
DeductiveClosure(OWLRL_Extension).expand(g)
print g.serialize(format="turtle")
</code></pre>
<p>
В первых двух строках мы импортируем систему рассуждений RDFClosure и библиотеку RDFLib, обеспечивающую взаимодействие с онтологиями. В третьей и четвёртой строке — объявляем граф и наполняем его содержимым онтологии </p><b>romanov_family.ttl</b><p>. Пятая строка — это запуск рассуждений. В данном случае они являются ничем иным, как циклическим расширением входного графа новыми триплетами по правилам OWL 2. Шестая — печать полученного графа (в том же самом формате Turtle).
</p><p>
Итак, мы получили результат </p><b>romanov_family.ttl.inferred</b><p> (по дисковому размеру он в несколько раз больше входного файла). Подготовим его для визуализации. Я написал простое HTML5-приложение (</p><a href="https://github.com/blokhin/genealogical-trees/blob/master/index.html"><b>index.html</b></a><p>), показывающее граф выведенных родственных отношений в браузере с помощью JavaScript-библиотеки D3.js. Оно доступно в </p><a href="http://blokhin.github.io/genealogical-trees/#ru">онлайн-ветви</a><p> репозитория к этой статье. Рёбра графа соответствуют сведениям, взятым из GEDCOM (браки, </p><i>isFatherOf</i><p>, </p><i>isMotherOf</i><p>), а выведенные родственные отношения подсвечиваются разными цветами при выборе члена семьи. Выбор происходит по наведению курсора или по касанию на сенсорных дисплеях. Граф для этого приложения задаётся в формате JSON с очень простой структурой — список рёбер с указанием вершин (индивидуумов) и типа связи (родственного отношения) между ними. Онтология, полученная на предыдущем шаге, переводится в этот JSON скриптом </p><a href="https://github.com/blokhin/genealogical-trees/blob/master/ttl2json.py"><b>ttl2json.py</b></a><p>:

</p><pre><code class="bash">./ttl2json.py romanov_family.ttl.inferred &gt; romanov_family.json
</code></pre>
<p>
По умолчанию HTML5-приложение загружает JSON по адресу </p><b>data/tsars.json</b><p>. Новый сгенерированный вами JSON можно загрузить в браузер простым нажатием кнопки на веб-странице (используется интерфейс File API без сервера, и визуализация работает оффлайн).
</p><p>
Все вышеописанные команды собраны в Shell-скрипт </p><a href="https://github.com/blokhin/genealogical-trees/blob/master/gedcom2json.sh"><b>gedcom2json.sh</b></a><p>. С его помощью можно непосредственно переводить GEDCOM-генеалогии в JSON с выведенными родственными связями для визуализации. Добавить выведение и визуализацию других родственных связей относительно просто. Для этого нужно, во-первых, дописать соответствующую логику в </p><a href="https://github.com/blokhin/genealogical-trees/blob/master/data/header.ttl">TBox FHKB</a><p>, во-вторых, внести идентификатор новой родственной связи в конвертер Turtle-JSON </p><a href="https://github.com/blokhin/genealogical-trees/blob/master/ttl2json.py"><b>ttl2json.py</b></a><p>, в третьих, задать цвет, название и идентификатор новой родственной связи в коде HTML5-визуализации. Само собой, время генерации JSON из GEDCOM при этом несколько вырастет.
</p><p>
В дополнение, есть идея, что входными данными для любой онтологии (не только генеалогической) могут служить интеллект-карты (mind maps). Разумеется, при рисовании необходимо придерживаться чётких правил, чтобы можно было перевести карту в ABox онтологии, используя, например, Python XMind SDK. Именно так, например, я запускал логические рассуждения для своей родословной, которую исторически вёл в виде интеллект-карты.
</p><p>
Подведём итоги: задав между членами семьи только самые ближайшие родственные связи (братьев и сестёр, браки, отцовство и материнство) и определив логику остальных связей, мы смогли вывести все остальные связи благодаря семантическим технологиям. Таким образом, мы прикоснулись к мощнейшему инструменту, лежащему в основе таких продуктов, как </p><a href="http://products.wolframalpha.com/api/faqs.html">Wolfram Alpha</a><p> и </p><a href="http://blogs.gartner.com/darin-stewart/2012/05/17/googles-knowledge-graph-yeah-thats-the-semantic-web-sort-of">граф знаний Google</a><p>. Онтологии и системы рассуждений — зрелые и широко используемые сегодня технологии, но, к сожалению, порог вхождения в эту область отнюдь не низок.
</p><p>
Ссылка на репозиторий к этой статье: </p><a href="https://github.com/blokhin/genealogical-trees">github.com/blokhin/genealogical-trees</a><p>
HTML5-приложение: </p><a href="http://blokhin.github.io/genealogical-trees/#ru">blokhin.github.io/genealogical-trees/#ru</a><p>
Общедоступные GEDCOM-файлы можно экспортировать из генеалогических порталов, например, </p><a href="http://www.wikitree.com">www.wikitree.com</a>
<p>
Приятного погружения в семантические технологии, и да не страшен будет нам Скайнет!

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>