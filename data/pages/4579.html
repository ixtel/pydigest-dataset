<html><body><div><div class="content html_format">
      
<p>
Язык программирования </p><a href="http://nim-lang.org/">Nim</a><p> (ранее именовался Nimrod) — захватывающий! В то время как </p><a href="http://nim-lang.org/docs/tut1.html">официальная документация с примерами</a><p> плавно знакомит с языком, я хочу быстро показать вам что можно сделать с Nim, что было бы труднее или невозможно сделать на других языках.
</p><p>
Я открыл для себя Nim, когда искал правильный инструмент для написания игры, HoorRace, преемник моей текущей DDNet игры/мода Teeworlds.

</p><i>(прим. пер. На синтаксис Nim имели влияние Modula 3, Delphi, Ada, C++, Python, Lisp, Oberon.)</i>

<h1>Запускаем!</h1><p>
Да, эта часть всё ещё не захватывает, но просто следите за продолжением поста:

</p><pre><code class="ruby">for i in 0..10:
  echo "Hello World"[0..i]
</code></pre>
<a name="habracut"/><p>
Для запуска, естественно, потребуется </p><a href="http://nim-lang.org/download.html">компилятор Nim</a><p> (прим. пер. в ArchLinux, например, пакет есть </p><code>community/nim</code><p>). Сохраните этот код в файл hello.nim, скомпилируйте его при помощи </p><code>nim c hello.nim</code><p>, и, наконец, запустите исполняемый файл </p><code>./hello</code><p>. Или воспользуйтесь командой </p><code>nim -r c hello.nim</code><p>, которая скомпилирует и запустит полученный файл. Для сборки оптимизированной версии воспользуйтесь командой </p><code>nim -d:release c hello.nim</code><p>. После запуска вы увидите вот такой вывод в консоль:

</p><pre><code>H
He
Hel
Hell
Hello
Hello 
Hello W
Hello Wo
Hello Wor
Hello Worl
Hello World
</code></pre>

<h1>Исполняем код во время компиляции</h1><p>
Для реализации эффективной процедуры CRC32 вам понадобится предвычисленная таблица. Вы можете её вычислить во время выполнения программы или сохранить её в коде в виде магического массива. Конечно мы не хотим магических цифр в нашем коде, так что мы будем вычислять таблицу на запуске программы (по крайней мере сейчас):

</p><pre><code class="ruby">import unsigned, strutils

type CRC32* = uint32
const initCRC32* = CRC32(-1)

proc createCRCTable(): array[256, CRC32] =
  for i in 0..255:
    var rem = CRC32(i)
    for j in 0..7:
      if (rem and 1) &gt; 0: rem = (rem shr 1) xor CRC32(0xedb88320)
      else: rem = rem shr 1
    result[i] = rem

# Table created at runtime
var crc32table = createCRCTable()

proc crc32(s): CRC32 =
  result = initCRC32
  for c in s:
    result = (result shr 8) xor crc32table[(result and 0xff) xor ord(c)]
  result = not result

# String conversion proc $, automatically called by echo
proc `$`(c: CRC32): string = int64(c).toHex(8)

echo crc32("The quick brown fox jumps over the lazy dog")
</code></pre>
<p>
Отлично! Это работает и мы получили </p><code>414FA339</code><p>. Однако, было бы гораздо лучше, если бы мы могли вычислить CRC таблицу во время компиляции. И в Nim это можно сделать очено просто, заменяем нашу строку с присвоением crc32table на следующий код:

</p><pre><code class="ruby"># Table created at compile time
const crc32table = createCRCTable()
</code></pre><p>
Да, верно, всё что нам нужно сделать, так это заменить </p><code>var</code><p> на </p><code>const</code><p>. Прекрасно, не правда ли? Мы можем писать один и тот же код, который можно исполнять как в работе программы, так и на этапе компиляции. Никакого шаблонного метапрограммирования.

</p><h1>Расширяем язык</h1><p>
Шаблоны и макросы могут быть использованы для избегания копирования и лапши в коде, при этом они будут обработаны на этапе компиляции.
</p><p>
Темплейты просто заменяются на вызовы соответствующих функций во время компиляции. Мы можем определить наши собственные циклы вот так:

</p><pre><code class="ruby">template times(x: expr, y: stmt): stmt =
  for i in 1..x:
    y

10.times:
  echo "Hello World"
</code></pre>
<p>
Компилятор преобразует </p><code>times</code><p> в обычный цикл:

</p><pre><code class="ruby">for i in 1..10:
  echo "Hello World"
</code></pre>
<p>
Если вас заинтересовал синтаксис </p><code>10.times</code><p>, то знайте, что это просто обычный вызов </p><code>times</code><p> с первым аргументом </p><code>10</code><p> и блоком кода в качестве второго аргумента. Вы могли просто написать: </p><code>times(10):</code><p>, подробнее смотрите о Unified Call Syntax ниже.
</p><p>
Или инициализируйте последовательности (массивы произвольной длинны) удобнее:

</p><pre><code class="ruby">template newSeqWith(len: int, init: expr): expr =
  var result = newSeq[type(init)](len)
  for i in 0 .. &lt;len:
    result[i] = init
  result

# Create a 2-dimensional sequence of size 20,10
var seq2D = newSeqWith(20, newSeq[bool](10))

import math
randomize()
# Create a sequence of 20 random integers smaller than 10
var seqRand = newSeqWith(20, random(10))
echo seqRand
</code></pre>
<p>
Макрос заходит на шаг дальше и позволяет вам анализировать и манипулировать AST. Например, в Nim нет </p><a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D0%BE%D0%B5_%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5">списковых включений</a><p> (прим. пер. list comprehensions), но мы можем добавить их в язык при помощи макроса. Теперь вместо:

</p><pre><code class="ruby">var res: seq[int] = @[]
for x in 1..10:
  if x mod 2 == 0:
    res.add(x)
echo res

const n = 20
var result: seq[tuple[a,b,c: int]] = @[]
for x in 1..n:
  for y in x..n:
    for z in y..n:
      if x*x + y*y == z*z:
        result.add((x,y,z))
echo result
</code></pre>
<p>
Вы можете использовать модуль </p><code>future</code><p> и писать:

</p><pre><code class="ruby">import future
echo lc[x | (x &lt;- 1..10, x mod 2 == 0), int]
const n = 20
echo lc[(x,y,z) | (x &lt;- 1..n, y &lt;- x..n, z &lt;- y..n,
                   x*x + y*y == z*z), tuple[a,b,c: int]]
</code></pre>

<h1>Добавляем свои оптимизации в компилятор</h1><p>
Вместо оптимизации своего кода, не предпочли бы вы сделать компилятор умнее? В Nim это возможно!

</p><pre><code class="ruby">var x: int
for i in 1..1_000_000_000:
  x += 2 * i
echo x
</code></pre><p>
Этот (достаточно бесполезный) код может быть ускорен при помощи обучения компилятора двум оптимизациям:

</p><pre><code class="ruby">template optMul{`*`(a,2)}(a: int): int =
  let x = a
  x + x

template canonMul{`*`(a,b)}(a: int{lit}, b: int): int =
  b * a
</code></pre><p>
В первом шаблоне мы указываем, что </p><code>a * 2</code><p> может быть заменено на </p><code>a + a</code><p>. Во втором шаблоне мы указываем что </p><code>int</code><p>-переменные могут быть поменяны местами, если первый агрумент — число-константа, это нужно чтобы мы могли применить первый шаблон.
</p><p>
Более сложные шаблоны также могут быть реализованы, например, для оптимизации булевой логики:

</p><pre><code class="ruby">template optLog1{a and a}(a): auto = a
template optLog2{a and (b or (not b))}(a,b): auto = a
template optLog3{a and not a}(a: int): auto = 0

var
  x = 12
  s = x and x
  # Hint: optLog1(x) --&gt; ’x’ [Pattern]

  r = (x and x) and ((s or s) or (not (s or s)))
  # Hint: optLog2(x and x, s or s) --&gt; ’x and x’ [Pattern]
  # Hint: optLog1(x) --&gt; ’x’ [Pattern]

  q = (s and not x) and not (s and not x)
  # Hint: optLog3(s and not x) --&gt; ’0’ [Pattern]
</code></pre><p>
Здесь </p><code>s</code><p> оптимизируется до </p><code>x</code><p>, </p><code>r</code><p> тоже оптимизируется до </p><code>x</code><p>, и </p><code>q</code><p> сразу инициализируется нулём.
</p><p>
Если вы хотите увидеть как применяются шаблоны для избегания выделения </p><code>bigint</code><p>, посмотрите на шаблоны, начинающиеся с </p><code>opt</code><p> в </p><a href="https://github.com/def-/nim-bigints/blob/master/src/bigints.nim">библиотеке biginsts.nim</a><p>:

</p><pre><code class="ruby">import bigints

var i = 0.initBigInt
while true:
  i += 1
  echo i
</code></pre>

<h1>Подключайте свои C-функции и библиотеки</h1><p>
Так как Nim транслируется в C (C++/Obj-C), использование сторонних функций не составляет никакой проблемы.
</p><p>
Вы можете легко использовать ваши любимые функции из стандартной библиотеки:

</p><pre><code class="ruby">proc printf(formatstr: cstring)
  {.header: "&lt;stdio.h&gt;", varargs.}
printf("%s %d\n", "foo", 5)
</code></pre>
<p>
Или использовать свой собственный код, написанный на C:

</p><pre><code>void hi(char* name) {
  printf("awesome %s\n", name);
}
</code></pre>
<pre><code class="ruby">{.compile: "hi.c".}
proc hi*(name: cstring) {.importc.}
hi "from Nim"
</code></pre>
<p>
Или любой библиотеки, какой пожелаете, при помощи c2nim:

</p><pre><code class="ruby">proc set_default_dpi*(dpi: cdouble) {.cdecl,
  importc: "rsvg_set_default_dpi",
  dynlib: "librsvg-2.so".}
</code></pre>

<h1>Управление сборщиком мусора</h1><p>
Для достижения «soft realtime», вы можете сказать сборщику мусора когда и сколько он может работать. Основная логика игры с предотвращением вмешательства сборщика мусора может быть реализована на Nim примерно вот так:

</p><pre><code class="ruby">gcDisable()
while true:
  gameLogic()
  renderFrame()
  gcStep(us = leftTime)
  sleep(restTime)
</code></pre>

<h1>Типобезопасные множества и enum</h1><p>
Часто вам может быть нужно математическое множество со значениями, которые вы определили самостоятельно. Вот так можно это реализовать с уверенностью, что типы будут проверены компилятором:

</p><pre><code class="ruby">type FakeTune = enum
  freeze, solo, noJump, noColl, noHook, jetpack

var x: set[FakeTune]

x.incl freeze
x.incl solo
x.excl solo

echo x + {noColl, noHook}

if freeze in x:
  echo "Here be freeze"

var y = {solo, noHook}
y.incl 0 # Error: type mismatch
</code></pre>
<p>
Вы не можете случайно добавить значение другого типа. Внутренне это работает как эффективный битовый вектор.
</p><p>
То же самое возможно и с массивами, индексируйте их с помощью enum.

</p><pre><code class="ruby">var a: array[FakeTune, int]
a[freeze] = 100
echo a[freeze]
</code></pre>

<h1>Unified Call Syntax</h1><p>
Это просто синтаксический сахар, но это определённо очень удобно (прим. пер. я считаю это ужасным!). В Python я всегда забываю является </p><code>len</code><p> и </p><code>append</code><p> функциями или методами. В Nim вам не нужно это помнить, потому что можно писать как угодно. Nim использует Unified Call Syntax (синтаксис унифицированного вызова), который также сейчас предложен в C++ товарищами Herb Sutter и Bjarne Stroustrup.

</p><pre><code class="ruby">var xs = @[1,2,3]

# Procedure call syntax
add(xs, 4_000_000)
echo len(xs)

# Method call syntax
xs.add(0b0101_0000_0000)
echo xs.len()

# Command invocation syntax
xs.add 0x06_FF_FF_FF
echo xs.len
</code></pre>

<h1>Производительность</h1><p>
(прим. пер. этот раздел в оригинальной статье «устарел», поэтому предлагаю ссылки на </p><a href="https://github.com/logicchains/LPATHBench/blob/master/writeup.md">оригинальный обновлённый benchmark</a><p> и </p><a href="http://hookrace.net/blog/what-is-special-about-nim/#good-performance">benchmark, приведённый в оригинале статьи</a><p>)
</p><p>
От переводчика:
</p><p>
Если кратко, то Nim генерирует код, который так же быстр, как и написанный человеком C/C++. Nim может транслировать код в C/C++/Obj-C (а ниже будет показано, что может и в JS) и компилировать его gcc/clang/llvm_gcc/MS-vcc/Intel-icc. Как показывают искуственные тесты, Nim сравним по скорости с C/C++/D/Rust и быстрее Go, Crystal, Java и многих других.

</p><h1>Транслируем в JavaScript</h1><p>
Nim может транслировать Nim код в JavaScript. Это позволяет писать и клиентский, и серверный код на Nim. Давайте сделаем маленький сайт, который будет считать посетителей. Это будет наш client.nim:

</p><pre><code class="ruby">import htmlgen, dom

type Data = object
  visitors {.importc.}: int
  uniques {.importc.}: int
  ip {.importc.}: cstring

proc printInfo(data: Data) {.exportc.} =
  var infoDiv = document.getElementById("info")
  infoDiv.innerHTML = p("You're visitor number ", $data.visitors,
    ", unique visitor number ", $data.uniques,
    " today. Your IP is ", $data.ip, ".")
</code></pre>
<p>
Мы определяем тип </p><code>Data</code><p>, который будем передавать от сервера клиенту. Процедура </p><code>printInfo</code><p> будет вызвана с этими данными для отображения. Для сборки нашего клиентского кода выполним команду </p><code>nim js client</code><p>. Результат будет сохранён в </p><code>nimcache/client.js</code><p>.
</p><p>
Для сервера нам понадобится пакетный менеджер Nimble, так как нам нужно будет установить </p><a href="https://github.com/dom96/jester">Jester</a><p> (sinatra-подобный web framework для Nim). Устанавливаем Jester: </p><code>nimble install jester</code><p>. Теперь напишем наш server.nim:

</p><pre><code class="ruby">import jester, asyncdispatch, json, strutils, times, sets, htmlgen, strtabs

var
  visitors = 0
  uniques = initSet[string]()
  time: TimeInfo

routes:
  get "/":
    resp body(
      `div`(id="info"),
      script(src="/client.js", `type`="text/javascript"),
      script(src="/visitors", `type`="text/javascript"))

  get "/client.js":
    const result = staticExec "nim -d:release js client"
    const clientJS = staticRead "nimcache/client.js"
    resp clientJS

  get "/visitors":
    let newTime = getTime().getLocalTime
    if newTime.monthDay != time.monthDay:
      visitors = 0
      init uniques
      time = newTime

    inc visitors
    let ip =
      if request.headers.hasKey "X-Forwarded-For":
        request.headers["X-Forwarded-For"]
      else:
        request.ip
    uniques.incl ip

    let json = %{"visitors": %visitors,
                 "uniques": %uniques.len,
                 "ip": %ip}
    resp "printInfo($#)".format(json)

runForever()
</code></pre>
<p>
При открытии </p><a href="http://localhost:5000/">http://localhost:5000/</a><p> сервер будет возвращать «пустую» страницу с подключёнными </p><code>/client.js</code><p> и </p><code>/visitors</code><p>. </p><code>/client.js</code><p> будет возвращать файл, полученный через </p><code>nim js client</code><p>, а </p><code>/visitors</code><p> будет генерировать JS код с вызовом </p><code>printInfo(JSON)</code><p>.
</p><p>
Вы можете увидеть </p><a href="http://visitors.hookrace.net/">полученный Jester сайт онлайн</a><p>, он будет показывать вот такую строку:

</p><pre><code>You're visitor number 11, unique visitor number 11 today. Your IP is 134.90.126.175.
</code></pre>

<h1>Заключение</h1><p>
Я надеюсь, я смог заинтересовать языком программирования Nim.</p><p>
Обратите внимание, что язык ещё не полностью стабилен. Однако, Nim 1.0 уже не за горами. Так что это отличное время для знакомства с Nim!
</p><p>
Бонус: так как Nim транслируется в C и зависит только от стандартной библиотеки C, ваш код будет работать практически везде.
      </p><p class="clear"/>
    </div>

    
  </div></body></html>