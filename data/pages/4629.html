<html><body><div><div id="articleText">
                    <div id="articleLongDescription"><p>Functions in Python have a variety of extra features that make the programmer’s life easier. Some are similar to capabilities in other programming languages, but many are unique to Python. These extras can make a function’s purpose more obvious. They can eliminate noise and clarify the intention of callers. They can significantly reduce subtle bugs that are difficult to find. In this excerpt  from </p><a href="http://www.informit.com/store/effective-python-59-specific-ways-to-write-better-python-9780134034287?w_ptgrevartcl=Effective+Python%3a+8+Specific+Ways+to+Write+Better+Functions+in+Python+_2314818">Effective Python: 59 Specific Ways to Write Better Python</a><p>, Brett Slatkin shows you 4 best practices for function arguments in Python. 

</p></div>
                    <p id="articleDescription"/>

                    <a class="relatedBookLink" href="#">From the book <span class="ss-icon"></span></a>
                    
                    

                
<h2>Item 18: Reduce Visual Noise with Variable Positional Arguments</h2>

<p>Accepting optional positional arguments (often called <em>star args</em> in reference to the conventional name for the parameter, <tt>*args</tt>) can make a function call more clear and remove <em>visual noise</em>.</p>

<p>For example, say you want to log some debug information. With a fixed number of arguments, you would need a function that takes a message and a list of values.</p>

<pre><code>def</code> log(message, values):
    <code>if not</code> values:
        <code>print</code>(message)
    <code>else</code>:
        values_str <code>=</code> <code>', '</code>.join(<code>str</code>(x) <code>for</code> x <code>in</code> values)
        <code>print</code>(<code>'%s: %s'</code> <code>%</code> (message, values_str))

log(<code>'My numbers are'</code>, [<code>1</code>, <code>2</code>])
log(<code>'Hi there'</code>, [])

&gt;&gt;&gt;
My numbers are: 1, 2
Hi there</pre>

<p>Having to pass an empty list when you have no values to log is cumbersome and noisy. It’d be better to leave out the second argument entirely. You can do this in Python by prefixing the last positional parameter name with <tt>*</tt>. The first parameter for the log message is required, whereas any number of subsequent positional arguments are optional. The function body doesn’t need to change, only the callers do.</p>

<pre><code>def</code> log(message, <code>*</code>values):  <code># The only difference</code>
    <code>if not</code> values:
        <code>print</code>(message)
    <code>else</code>:
        values_str <code>=</code> <code>', '</code>.join(<code>str</code>(x) <code>for</code> x <code>in</code> values)
        <code>print</code>(<code>'%s: %s'</code> <code>%</code> (message, values_str))

log(<code>'My numbers are'</code>, <code>1</code>, <code>2</code>)
log(<code>'Hi there'</code>)  <code># Much better</code>

&gt;&gt;&gt;
My numbers are: 1, 2
Hi there</pre>

<p>If you already have a list and want to call a variable argument function like <tt>log</tt>, you can do this by using the <tt>*</tt> operator. This instructs Python to pass items from the sequence as positional arguments.</p>

<pre>favorites <code>=</code> [<code>7</code>, <code>33</code>, <code>99</code>]
log(<code>'Favorite colors'</code>, <code>*</code>favorites)

&gt;&gt;&gt;
Favorite colors: 7, 33, 99</pre>

<p>There are two problems with accepting a variable number of positional arguments.</p>

<p>The first issue is that the variable arguments are always turned into a tuple before they are passed to your function. This means that if the caller of your function uses the <tt>*</tt> operator on a generator, it will be iterated until it’s exhausted. The resulting tuple will include every value from the generator, which could consume a lot of memory and cause your program to crash.</p>

<pre><code>def</code> my_generator():
    <code>for</code> i <code>in</code> <code>range</code>(<code>10</code>):
        <code>yield i</code>

<code>def</code> my_func(<code>*</code>args):
    <code>print</code>(args)

it <code>=</code> my_generator()
my_func(<code>*</code>it)

&gt;&gt;&gt;
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</pre>

<p>Functions that accept <tt>*args</tt> are best for situations where you know the number of inputs in the argument list will be reasonably small. It’s ideal for function calls that pass many literals or variable names together. It’s primarily for the convenience of the programmer and the readability of the code.</p>

<p>The second issue with <tt>*args</tt> is that you can’t add new positional arguments to your function in the future without migrating every caller. If you try to add a positional argument in the front of the argument list, existing callers will subtly break if they aren’t updated.</p>

<pre><code>def</code> log(sequence, message, <code>*</code>values):
    <code>if not</code> values:
        <code>print</code>(<code>'%s: %s'</code> <code>%</code> (sequence, message))
    <code>else</code>:
        values_str <code>=</code> <code>', '</code>.join(<code>str</code>(x) <code>for</code> x <code>in</code> values)
        <code>print</code>(<code>'%s: %s: %s'</code> <code>%</code> (sequence, message, values_str))

log(<code>1</code>, <code>'Favorites'</code>, <code>7</code>, <code>33</code>)      <code># New usage is OK</code>
log(<code>'Favorite numbers'</code>, <code>7</code>, <code>33</code>)  <code># Old usage breaks</code>

&gt;&gt;&gt;
1: Favorites: 7, 33
Favorite numbers: 7: 33</pre>

<p>The problem here is that the second call to <tt>log</tt> used <tt>7</tt> as the <tt>message</tt> parameter because a <tt>sequence</tt> argument wasn’t given. Bugs like this are hard to track down because the code still runs without raising any exceptions. To avoid this possibility entirely, you should use keyword-only arguments when you want to extend functions that accept <tt>*args</tt> (see Item 21: “Enforce Clarity with Keyword-Only Arguments”).</p>

<h3>Things to Remember</h3>

<ul>
<li>Functions can accept a variable number of positional arguments by using <tt>*args</tt> in the <tt>def</tt> statement.</li>
<li>You can use the items from a sequence as the positional arguments for a function with the <tt>*</tt> operator.</li>
<li>Using the <tt>*</tt> operator with a generator may cause your program to run out of memory and crash.</li>
<li>Adding new positional parameters to functions that accept <tt>*args</tt> can introduce hard-to-find bugs.</li>
</ul>


<h2>Item 19: Provide Optional Behavior with Keyword Arguments</h2>

<p>Like most other programming languages, calling a function in Python allows for passing arguments by position.</p>

<pre><code>def</code> remainder(number, divisor):
    <code>return</code> number <code>%</code> divisor

<code>assert</code> remainder(<code>20</code>, <code>7</code>) <code>==</code> <code>6</code></pre>

<p>All positional arguments to Python functions can also be passed by keyword, where the name of the argument is used in an assignment within the parentheses of a function call. The keyword arguments can be passed in any order as long as all of the required positional arguments are specified. You can mix and match keyword and positional arguments. These calls are equivalent:</p>

<pre>remainder(<code>20</code>, <code>7</code>)
remainder(<code>20</code>, divisor<code>=</code><code>7</code>)
remainder(number<code>=</code><code>20</code>, divisor<code>=</code><code>7</code>)
remainder(divisor<code>=</code><code>7</code>, number<code>=</code><code>20</code>)</pre>

<p>Positional arguments must be specified before keyword arguments.</p>

<pre>remainder(number<code>=</code><code>20</code>, <code>7</code>)

&gt;&gt;&gt;
SyntaxError: non-keyword arg after keyword arg</pre>

<p>Each argument can only be specified once.</p>

<pre>remainder(<code>20</code>, number<code>=</code><code>7</code>)

&gt;&gt;&gt;
TypeError: remainder() got multiple values for argument 'number'</pre>

<p>The flexibility of keyword arguments provides three significant benefits.</p>

<p>The first advantage is that keyword arguments make the function call clearer to new readers of the code. With the call <tt>remainder(20, 7)</tt>, it’s not evident which argument is the number and which is the divisor without looking at the implementation of the <tt>remainder</tt> method. In the call with keyword arguments, <tt>number=20</tt> and <tt>divisor=7</tt> make it immediately obvious which parameter is being used for each purpose.</p>

<p>The second impact of keyword arguments is that they can have default values specified in the function definition. This allows a function to provide additional capabilities when you need them but lets you accept the default behavior most of the time. This can eliminate repetitive code and reduce noise.</p>

<p>For example, say you want to compute the rate of fluid flowing into a vat. If the vat is also on a scale, then you could use the difference between two weight measurements at two different times to determine the flow rate.</p>

<pre><code>def</code> flow_rate(weight_diff, time_diff):
    <code>return</code> weight_diff <code>/</code> time_diff

weight_diff <code>=</code> <code>0.5</code>
time_diff <code>=</code> <code>3</code>
flow <code>=</code> flow_rate(weight_diff, time_diff)
<code>print</code>(<code>'%.3f kg per second'</code> <code>%</code> flow)

&gt;&gt;&gt;
0.167 kg per second</pre>

<p>In the typical case, it’s useful to know the flow rate in kilograms per second. Other times, it’d be helpful to use the last sensor measurements to approximate larger time scales, like hours or days. You can provide this behavior in the same function by adding an argument for the time period scaling factor.</p>

<pre><code>def</code> flow_rate(weight_diff, time_diff, period):
    <code>return</code> (weight_diff <code>/</code> time_diff) <code>*</code> period</pre>

<p>The problem is that now you need to specify the <tt>period</tt> argument every time you call the function, even in the common case of flow rate per second (where the period is <tt>1</tt>).</p>

<pre>flow_per_second <code>=</code> flow_rate(weight_diff, time_diff, <code>1</code>)</pre>

<p>To make this less noisy, I can give the <tt>period</tt> argument a default value.</p>

<pre><code>def</code> flow_rate(weight_diff, time_diff, period<code>=</code><code>1</code>):
    <code>return</code> (weight_diff <code>/</code> time_diff) <code>*</code> period</pre>

<p>The <tt>period</tt> argument is now optional.</p>

<pre>flow_per_second <code>=</code> flow_rate(weight_diff, time_diff)
flow_per_hour <code>=</code> flow_rate(weight_diff, time_diff, period<code>=</code><code>3600</code>)</pre>

<p>This works well for simple default values (it gets tricky for complex default values—see Item 20: “Use <tt>None</tt> and Docstrings to Specify Dynamic Default Arguments”).</p>

<p>The third reason to use keyword arguments is that they provide a powerful way to extend a function’s parameters while remaining backwards compatible with existing callers. This lets you provide additional functionality without having to migrate a lot of code, reducing the chance of introducing bugs.</p>

<p>For example, say you want to extend the <tt>flow_rate</tt> function above to calculate flow rates in weight units besides kilograms. You can do this by adding a new optional parameter that provides a conversion rate to your preferred measurement units.</p>

<pre><code>def</code> flow_rate(weight_diff, time_diff,
              period<code>=</code><code>1</code>, units_per_kg<code>=</code><code>1</code>):
    <code>return</code> ((weight_diff <code>*</code> units_per_kg) <code>/</code> time_diff) <code>*</code> period</pre>

<p>The default argument value for <tt>units_per_kg</tt> is <tt>1</tt>, which makes the returned weight units remain as kilograms. This means that all existing callers will see no change in behavior. New callers to <tt>flow_rate</tt> can specify the new keyword argument to see the new behavior.</p>

<pre>pounds_per_hour <code>=</code> flow_rate(weight_diff, time_diff,
                            period<code>=</code><code>3600</code>, units_per_kg<code>=</code><code>2.2</code>)</pre>

<p>The only problem with this approach is that optional keyword arguments like <tt>period</tt> and <tt>units_per_kg</tt> may still be specified as positional arguments.</p>

<pre>pounds_per_hour <code>=</code> flow_rate(weight_diff, time_diff, <code>3600</code>, <code>2.2</code>)</pre>

<p>Supplying optional arguments positionally can be confusing because it isn’t clear what the values <tt>3600</tt> and <tt>2.2</tt> correspond to. The best practice is to always specify optional arguments using the keyword names and never pass them as positional arguments.</p>



<h3>Things to Remember</h3>

<ul>
<li>Function arguments can be specified by position or by keyword.</li>
<li>Keywords make it clear what the purpose of each argument is when it would be confusing with only positional arguments.</li>
<li>Keyword arguments with default values make it easy to add new behaviors to a function, especially when the function has existing callers.</li>
<li>Optional keyword arguments should always be passed by keyword instead of by position.</li>
</ul>


<h2>Item 20: Use <tt>None</tt> and Docstrings to Specify Dynamic Default Arguments</h2>

<p>Sometimes you need to use a non-static type as a keyword argument’s default value. For example, say you want to print logging messages that are marked with the time of the logged event. In the default case, you want the message to include the time when the function was called. You might try the following approach, assuming the default arguments are reevaluated each time the function is called.</p>

<pre><code>def</code> log(message, when<code>=</code>datetime.now()):
    <code>print</code>(<code>'%s: %s'</code> <code>%</code> (when, message))

log(<code>'Hi there!'</code>)
sleep(<code>0.1</code>)
log(<code>'Hi again!'</code>)

&gt;&gt;&gt;
2014-11-15 21:10:10.371432: Hi there!
2014-11-15 21:10:10.371432: Hi again!</pre>

<p>The timestamps are the same because <tt>datetime.now</tt> is only executed a single time: when the function is defined. Default argument values are evaluated only once per module load, which usually happens when a program starts up. After the module containing this code is loaded, the <tt>datetime.now</tt> default argument will never be evaluated again.</p>

<p>The convention for achieving the desired result in Python is to provide a default value of <tt>None</tt> and to document the actual behavior in the docstring (see Item 49: “Write Docstrings for Every Function, Class, and Module”). When your code sees an argument value of <tt>None</tt>, you allocate the default value accordingly.</p>

<pre><code>def</code> log(message, when<code>=</code><code>None</code>):
    <code>"""Log a message with a timestamp.</code>

<code>    Args:</code>
<code>        message: Message to print.</code>
<code>        when: datetime of when the message occurred.</code>
<code>            Defaults to the present time.</code>
<code>    """</code>
    when <code>=</code> datetime.now() <code>if</code> when <code>is None else</code> when
    <code>print</code>(<code>'%s: %s'</code> <code>%</code> (when, message))</pre>

<p>Now the timestamps will be different.</p>

<pre>log(<code>'Hi there!'</code>)
sleep(<code>0.1</code>)
log(<code>'Hi again!'</code>)

&gt;&gt;&gt;
2014-11-15 21:10:10.472303: Hi there!
2014-11-15 21:10:10.573395: Hi again!</pre>

<p>Using <tt>None</tt> for default argument values is especially important when the arguments are mutable. For example, say you want to load a value encoded as JSON data. If decoding the data fails, you want an empty dictionary to be returned by default. You might try this approach.</p>

<pre><code>def</code> decode(data, default<code>=</code>{}):
    <code>try:</code>
        <code>return</code> json.loads(data)
    <code>except</code> ValueError:
        <code>return</code> default</pre>

<p>The problem here is the same as the <tt>datetime.now</tt> example above. The dictionary specified for <tt>default</tt> will be shared by all calls to <tt>decode</tt> because default argument values are only evaluated once (at module load time). This can cause extremely surprising behavior.</p>

<pre>foo <code>=</code> decode(<code>'bad data'</code>)
foo[<code>'stuff'</code>] <code>=</code> <code>5</code>
bar <code>=</code> decode(<code>'also bad'</code>)
bar[<code>'meep'</code>] <code>=</code> <code>1</code>
<code>print</code>(<code>'Foo:'</code>, foo)
<code>print</code>(<code>'Bar:'</code>, bar)

&gt;&gt;&gt;
Foo: {'stuff': 5, 'meep': 1}
Bar: {'stuff': 5, 'meep': 1}</pre>

<p>You’d expect two different dictionaries, each with a single key and value. But modifying one seems to also modify the other. The culprit is that <tt>foo</tt> and <tt>bar</tt> are both equal to the <tt>default</tt> parameter. They are the same dictionary object.</p>

<pre><code>assert</code> foo <code>is</code> bar</pre>

<p>The fix is to set the keyword argument default value to <tt>None</tt> and then document the behavior in the function’s docstring.</p>

<pre><code>def</code> decode(data, default<code>=</code><code>None</code>):
    <code>"""Load JSON data from a string.</code>

<code>    Args:</code>
<code>        data: JSON data to decode.</code>
<code>        default: Value to return if decoding fails.</code>
<code>            Defaults to an empty dictionary.</code>
<code>    """</code>
    <code>if</code> default <code>is None</code>:
        default <code>=</code> {}
    <code>try</code>:
        <code>return</code> json.loads(data)
    <code>except</code> ValueError:
        <code>return</code> default</pre>

<p>Now, running the same test code as before produces the expected result.</p>

<pre>foo <code>=</code> decode(<code>'bad data'</code>)
foo[<code>'stuff'</code>] <code>=</code> <code>5</code>
bar <code>=</code> decode(<code>'also bad'</code>)
bar[<code>'meep'</code>] <code>=</code> <code>1</code>
<code>print</code>(<code>'Foo:'</code>, foo)
<code>print</code>(<code>'Bar:'</code>, bar)

&gt;&gt;&gt;
Foo: {'stuff': 5}
Bar: {'meep': 1}</pre>

<h3>Things to Remember</h3>

<ul>
<li>Default arguments are only evaluated once: during function definition at module load time. This can cause odd behaviors for dynamic values (like <tt>{}</tt> or <tt>[]</tt>).</li>
<li>Use <tt>None</tt> as the default value for keyword arguments that have a dynamic value. Document the actual default behavior in the function’s docstring.</li>
</ul>


<h2>Item 21: Enforce Clarity with Keyword-Only Arguments</h2>

<p>Passing arguments by keyword is a powerful feature of Python functions (see Item 19: “Provide Optional Behavior with Keyword Arguments”). The flexibility of keyword arguments enables you to write code that will be clear for your use cases.</p>

<p>For example, say you want to divide one number by another but be very careful about special cases. Sometimes you want to ignore <tt>ZeroDivisionError</tt> exceptions and return infinity instead. Other times, you want to ignore <tt>OverflowError</tt> exceptions and return zero instead.</p>

<pre><code>def</code> safe_division(number, divisor, ignore_overflow,
                  ignore_zero_division):
    <code>try</code>:
        <code>return</code> number <code>/</code> divisor
    <code>except</code> OverflowError:
        <code>if</code> ignore_overflow:
            <code>return 0</code>
        <code>else</code>:
            <code>raise</code>
    <code>except</code> ZeroDivisionError:
        <code>if</code> ignore_zero_division:
            <code>return</code> <code>float</code>(<code>'inf'</code>)
        <code>else</code>:
            <code>raise</code></pre>

<p>Using this function is straightforward. This call will ignore the <tt>float</tt> overflow from division and will return zero.</p>

<pre>result <code>=</code> safe_division(<code>1</code>, <code>10</code><code>**</code><code>500</code>, <code>True</code>, <code>False</code>)
<code>print</code>(result)

&gt;&gt;&gt;
0.0</pre>

<p>This call will ignore the error from dividing by zero and will return infinity.</p>

<pre>result <code>=</code> safe_division(<code>1</code>, <code>0</code>, <code>False</code>, <code>True</code>)
<code>print</code>(result)

&gt;&gt;&gt;
inf</pre>

<p>The problem is that it’s easy to confuse the position of the two Boolean arguments that control the exception-ignoring behavior. This can easily cause bugs that are hard to track down. One way to improve the readability of this code is to use keyword arguments. By default, the function can be overly cautious and can always re-raise exceptions.</p>

<pre><code>def</code> safe_division_b(number, divisor,
                    ignore_overflow<code>=</code><code>False</code>,
                    ignore_zero_division<code>=</code><code>False</code>):
    <code># ...</code></pre>

<p>Then callers can use keyword arguments to specify which of the ignore flags they want to flip for specific operations, overriding the default behavior.</p>

<pre>safe_division_b(<code>1</code>, <code>10</code><code>**</code><code>500</code>, ignore_overflow<code>=</code><code>True</code>)
safe_division_b(<code>1</code>, <code>0</code>, ignore_zero_division<code>=</code><code>True</code>)</pre>

<p>The problem is, since these keyword arguments are optional behavior, there’s nothing forcing callers of your functions to use keyword arguments for clarity. Even with the new definition of <tt>safe_division_b</tt>, you can still call it the old way with positional arguments.</p>

<pre>safe_division_b(<code>1</code>, <code>10</code><code>**</code><code>500</code>, <code>True</code>, <code>False</code>)</pre>

<p>With complex functions like this, it’s better to require that callers are clear about their intentions. In Python 3, you can demand clarity by defining your functions with keyword-only arguments. These arguments can only be supplied by keyword, never by position.</p>

<p>Here, I redefine the <tt>safe_division</tt> function to accept keyword-only arguments. The <tt>*</tt> symbol in the argument list indicates the end of positional arguments and the beginning of keyword-only arguments.</p>

<pre><code>def</code> safe_division_c(number, divisor, <code>*</code>,
                    ignore_overflow<code>=</code><code>False</code>,
                    ignore_zero_division<code>=</code><code>False</code>):
    <code># ...</code></pre>

<p>Now, calling the function with positional arguments for the keyword arguments won’t work.</p>

<pre>safe_division_c(<code>1</code>, <code>10</code><code>**</code><code>500</code>, <code>True</code>, <code>False</code>)

&gt;&gt;&gt;
TypeError: safe_division_c() takes 2 positional arguments but 4 were given</pre>

<p>Keyword arguments and their default values work as expected.</p>

<pre>safe_division_c(<code>1</code>, <code>0</code>, ignore_zero_division<code>=</code><code>True</code>)  <code># OK</code>

<code>try</code>:
    safe_division_c(<code>1</code>, <code>0</code>)
<code>except</code> ZeroDivisionError:
    <code>pass</code>  <code># Expected</code></pre>

<h3>Keyword-Only Arguments in Python 2</h3>

<p>Unfortunately, Python 2 doesn’t have explicit syntax for specifying keyword-only arguments like Python 3. But you can achieve the same behavior of raising <tt>TypeErrors</tt> for invalid function calls by using the <tt>**</tt> operator in argument lists. The <tt>**</tt> operator is similar to the <tt>*</tt> operator (see Item 18: “Reduce Visual Noise with Variable Positional Arguments”), except that instead of accepting a variable number of positional arguments, it accepts any number of keyword arguments, even when they’re not defined.</p>

<pre><code># Python 2</code>
<code>def</code> print_args(<code>*</code>args, <code>**</code>kwargs):
    <code>print</code> <code>'Positional:'</code>, args
    <code>print</code> <code>'Keyword:   '</code>, kwargs

print_args(<code>1</code>, <code>2</code>, foo<code>=</code><code>'bar'</code>, stuff<code>=</code><code>'meep'</code>)

&gt;&gt;&gt;
Positional: (1, 2)
Keyword:    {'foo': 'bar', 'stuff': 'meep'}</pre>

<p>To make <tt>safe_division</tt> take keyword-only arguments in Python 2, you have the function accept <tt>**kwargs</tt>. Then you <tt>pop</tt> keyword arguments that you expect out of the <tt>kwargs</tt> dictionary, using the <tt>pop</tt> method’s second argument to specify the default value when the key is missing. Finally, you make sure there are no more keyword arguments left in <tt>kwargs</tt> to prevent callers from supplying arguments that are invalid.</p>

<pre><code># Python 2</code>
<code>def</code> safe_division_d(number, divisor, <code>**</code>kwargs):
    ignore_overflow <code>=</code> kwargs.pop(<code>'ignore_overflow'</code>, <code>False</code>)
    ignore_zero_div <code>=</code> kwargs.pop(<code>'ignore_zero_division'</code>, <code>False</code>)
    <code>if</code> kwargs:
        <code>raise</code> TypeError(<code>'Unexpected **kwargs: %r'</code> <code>%</code> kwargs)
    <code># ...</code></pre>

<p>Now, you can call the function with or without keyword arguments.</p>

<pre>safe_division_d(<code>1</code>, <code>10</code>)
safe_division_d(<code>1</code>, <code>0</code>, ignore_zero_division<code>=</code><code>True</code>)
safe_division_d(<code>1</code>, <code>10</code><code>**</code><code>500</code>, ignore_overflow<code>=</code><code>True</code>)</pre>

<p>Trying to pass keyword-only arguments by position won’t work, just like in Python 3.</p>

<pre>safe_division_d(<code>1</code>, <code>0</code>, <code>False</code>, <code>True</code>)

&gt;&gt;&gt;
TypeError: safe_division_d() takes 2 positional arguments but 4 were given</pre>

<p>Trying to pass unexpected keyword arguments also won’t work.</p>

<pre>safe_division_d(<code>0</code>, <code>0</code>, unexpected<code>=</code><code>True</code>)

&gt;&gt;&gt;
TypeError: Unexpected **kwargs: {'unexpected': True}</pre>

<h3>Things to Remember</h3>

<ul>
<li>Keyword arguments make the intention of a function call more clear.</li>
<li>Use keyword-only arguments to force callers to supply keyword arguments for potentially confusing functions, especially those that accept multiple Boolean flags.</li>
<li>Python 3 supports explicit syntax for keyword-only arguments in functions.</li>
<li>Python 2 can emulate keyword-only arguments for functions by using <tt>**kwargs</tt> and manually raising <tt>TypeError</tt> exceptions.</li>
</ul>
            </div>
            </div></body></html>