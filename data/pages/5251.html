<html><body><div><div class="entry-content" itemprop="text"><p>Finding template documents with RethinkDB and the Bing API in Python</p>
<p>Many businesses require new clients to fill out a form to pre-qualify them or to get information to quote a project. Given a list of industries, we can use search engine results to filter the industry list to just those that require forms (you could use this to find industries to target for a form-filling application, for instance)</p>
<p>It would be relatively cheap to have this analysis done using Amazon Mechanical Turk, but this is a good project to learn how RethinkDB works.</p>
<p>RethinkDB is advertised as a real-time, document oriented database, “Document oriented” meaning that it stores semi-structured data, like the JSON output from an API. Bing provides an API that is very easy to use, but rate limited, so we’ll build out a small data warehouse of API results that we can later explore to find content generation ideas.</p>
<p>RethinkDB is very simple to install:</p>
<pre>
yum -y install rethinkdb

rethinkdb --bind all
</pre>
<p>Once it’s installed, we’ll need to create the tables we want to use (note that we don’t need to define a schema). Also note that creating a query doesn’t run it until you call “run”, which lets you mix the query construction into your code.</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>import</span> rethinkdb <span>as</span> r
r.<span>connect</span><span>(</span><span>"&lt;server&gt;"</span><span>,</span> <span>28015</span><span>)</span>.<span>repl</span><span>(</span><span>)</span>
db <span>=</span> r.<span>db</span><span>(</span><span>"search"</span><span>)</span>
 
tables <span>=</span> <span>[</span><span>"search_results"</span><span>,</span> <span>"industries"</span><span>]</span>
<span>for</span> t <span>in</span> tables:
  <span>try</span>:
    db.<span>table_create</span><span>(</span>t<span>)</span>.<span>run</span><span>(</span><span>)</span>
  <span>except</span> r.<span>RqlRuntimeError</span> <span>as</span> e:
    <span>print</span> e</pre></td></tr></table></div>
<p>To populate the industries list, we must obtain the list of business types. This could come from the headings in the phone book, or a business taxonomy like NAICS codes. NAICS codes have the nice property that they are collected in groups by industry type, so for instance you can pull a large list of only construction businesses.</p>
<p>I pulled this list from a couple places, and found that I needed to clean it up (remove extra whitespace, duplicates, etc).</p>
<p>The RethinkDB insert API has support for batch updates, which is nice for this case. It apparently also supports upserts, although I couldn’t figure out how to do a batch upsert in python.</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python">src <span>=</span> r<span>'d:/projects/bing/industries.txt'</span>
<span>with</span> <span>open</span><span>(</span>src<span>,</span> mode<span>=</span><span>"r"</span><span>)</span> <span>as</span> f:
    industries <span>=</span> f.<span>readlines</span><span>(</span><span>)</span>
 
industries <span>=</span> <span>filter</span><span>(</span><span>lambda</span> x : x <span>!=</span> <span>'<span>\n</span>'</span><span>,</span> industries<span>)</span>
industries <span>=</span> <span>[</span>x.<span>strip</span><span>(</span><span>)</span>.<span>lower</span><span>(</span><span>)</span> <span>for</span> x <span>in</span> industries<span>]</span>
industries <span>=</span> <span>list</span><span>(</span><span>set</span><span>(</span>industries<span>)</span><span>)</span>
industries <span>=</span> <span>sorted</span><span>(</span>industries<span>)</span>
 
data <span>=</span> <span>[</span><span>{</span><span>'industry'</span>: value<span>}</span> <span>for</span> value <span>in</span> industries<span>]</span>
 
db <span>=</span> r.<span>db</span><span>(</span><span>"search"</span><span>)</span>
table <span>=</span> db.<span>table</span><span>(</span><span>"industries"</span><span>)</span>
query <span>=</span> table.<span>insert</span><span>(</span>data<span>)</span>
<span>print</span> query.<span>run</span><span>(</span><span>)</span></pre></td></tr></table></div>
<p>Now that we have this list, we can start querying the Bing API. You can get a key from the Azure Data portal for free with a Microsoft Account – they let you run up to 5,000 queries a month, so you likely will want to pick just one for testing purposes.</p>
<p>Interestingly, the API uses Basic Auth with the key for authentication.</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>def</span> search<span>(</span><span>keyword</span><span>)</span>:
  <span>import</span> <span>urllib2</span>
  <span>import</span> json
 
  keyBing <span>=</span> <span>'&lt;insert key&gt;'</span>
  credentialBing <span>=</span> <span>'Basic '</span> + <span>(</span><span>':%s'</span> % keyBing<span>)</span>.<span>encode</span><span>(</span><span>'base64'</span><span>)</span><span>[</span>:<span>]</span>
  searchString <span>=</span> <span>'%27'</span> + <span>keyword</span>.<span>replace</span><span>(</span><span>' '</span><span>,</span> <span>'+'</span><span>)</span> + <span>'%27'</span>
  top <span>=</span> <span>20</span>
  offset <span>=</span> <span>0</span>
 
  <span># Web, Image, News, Video</span>
  url <span>=</span> <span>'https://api.datamarket.azure.com/Bing/Search/Web?'</span> + \
      <span>'Query=%s&amp;$top=%d&amp;$skip=%d&amp;$format=json'</span> % \
      <span>(</span>searchString<span>,</span> top<span>,</span> offset<span>)</span>
 
  request <span>=</span> <span>urllib2</span>.<span>Request</span><span>(</span>url<span>)</span>
  request.<span>add_header</span><span>(</span><span>'Authorization'</span><span>,</span> credentialBing<span>)</span>
  requestOpener <span>=</span> <span>urllib2</span>.<span>build_opener</span><span>(</span><span>)</span>
  response <span>=</span> requestOpener.<span>open</span><span>(</span>request<span>)</span> 
 
  <span>return</span> json.<span>load</span><span>(</span>response<span>)</span></pre></td></tr></table></div>
<p>We also need to define a function that lets use save the API results. When writing an ETL process, it’s a good practice to import all the data as it is given to you, so that if you misunderstand something about the original interface you can backtrack easily later. It’s also a good practice to record information about where you got the data – the time, search query, and search engine. It’s possible that it might even be goot to record the API key, if you were scaling this up, as this would let you re-generate records you care about later.</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>def</span> saveResults<span>(</span><span>keyword</span><span>,</span> results<span>)</span>:
  <span>import</span> <span>datetime</span>
  currentTime <span>=</span> <span>datetime</span>.<span>datetime</span>.<span>now</span><span>(</span><span>)</span>.<span>strftime</span><span>(</span><span>"%I:%M%p on %B %d, %Y"</span><span>)</span>
 
  db <span>=</span> r.<span>db</span><span>(</span><span>"search"</span><span>)</span>
  table <span>=</span> db.<span>table</span><span>(</span><span>"search_results"</span><span>)</span>
 
  index <span>=</span> <span>1</span>
  <span>for</span> row <span>in</span> results<span>[</span><span>'d'</span><span>]</span><span>[</span><span>'results'</span><span>]</span>:
    <span>print</span> row
    record <span>=</span> row
    record<span>[</span><span>'search_query'</span><span>]</span> <span>=</span> <span>keyword</span>
    record<span>[</span><span>'api'</span><span>]</span> <span>=</span> <span>'Web'</span>
    record<span>[</span><span>'rank'</span><span>]</span> <span>=</span> index
    record<span>[</span><span>'src'</span><span>]</span> <span>=</span> <span>'Bing'</span>
    record<span>[</span><span>'retrieved'</span><span>]</span> <span>=</span> currentTime
 
    rdbResults <span>=</span> table.<span>insert</span><span>(</span>record<span>)</span>.<span>run</span><span>(</span><span>)</span>
 
    index <span>=</span> index + <span>1</span></pre></td></tr></table></div>
<p>Before we start populating this into RethinkDB, we need to write a query that checks to see if we’ve run this search already, to prevent overrunning our API limits.</p>
<p>One of the neat things about RethinkDB is that we can write WHERE clauses as lambdas, which are tokenized into their lower-level protocol language, then run on the database. One thing that takes some getting used to is that column headers are case-sensitive, unlike most SQL.</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>def</span> check<span>(</span><span>keyword</span><span>)</span>:
  db <span>=</span> r.<span>db</span><span>(</span><span>'search'</span><span>)</span>
  table <span>=</span> db.<span>table</span><span>(</span><span>'search_results'</span><span>)</span>
  rows <span>=</span> table.<span>filter</span><span>(</span><span>lambda</span> x: x<span>[</span><span>'search_query'</span><span>]</span> <span>==</span> value<span>)</span>
  <span>return</span> rows.<span>count</span><span>(</span><span>)</span>.<span>run</span><span>(</span><span>)</span></pre></td></tr></table></div>
<p>Once we’ve done all this, we can bind everything together. I got a few errors from the Bing API (2x per 800 calls), so I just catch and continue, but for a more robust system you’d want to do better.</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>def</span> executeQuery<span>(</span><span>keyword</span><span>)</span>:
  <span>if</span> <span>(</span>check<span>(</span><span>keyword</span><span>)</span> <span>==</span> <span>0</span><span>)</span>:
    <span>try</span>:
      results <span>=</span> search<span>(</span><span>keyword</span><span>)</span>
      saveResults<span>(</span><span>keyword</span><span>,</span> results<span>)</span>
    <span>except</span>:
      <span>print</span> <span>"Error"</span></pre></td></tr></table></div>
<p>All we know now is what results Bing returns for a given query, which doesn’t answer the original question of whether a given business requires new client forms.</p>
<p>Buried in this data are several interesting scenarios: some top ranked matches are sites doing SEO, others are perfect matches with spelling differences between our query and the results, or terms synomymous with our query more standard for the industry in question.</p>
<p>As one approach, we can update all the documents in the database with the Levenshtein edit distance between the search query and the document title. This takes a little while – RethinkDB does have indexing, which I haven’t investigated yet.</p>
<p>Note that because “not” is a reserved word in Python, the API uses “not_”. Another nice API feature is that the query results are cursors, so we can operate on each operation in the stream individually. Doing updates on these is simple, because RethinkDB automatically pulls down it’s internal ID.</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>def</span> updateDoc<span>(</span>table<span>,</span> doc<span>)</span>:
  doc<span>[</span><span>'Title_Query_Distance'</span><span>]</span> <span>=</span> \
    Levenshtein.<span>ratio</span><span>(</span>doc<span>[</span><span>'search_query'</span><span>]</span><span>,</span> doc<span>[</span><span>'Title'</span><span>]</span><span>)</span>
  table.<span>update</span><span>(</span>doc<span>)</span>.<span>run</span><span>(</span><span>)</span>
 
<span># this query takes about ten seconds on a 31k row table, with no indexes</span>
toUpdate <span>=</span> \
  table.<span>filter</span><span>(</span>r.<span>row</span>.<span>has_fields</span><span>(</span><span>"Title_Query_Distance"</span><span>)</span>.<span>not_</span><span>(</span><span>)</span><span>)</span>.<span>run</span><span>(</span><span>)</span>
 
<span>[</span>updateDoc<span>(</span>table<span>,</span> doc<span>)</span> <span>for</span> doc <span>in</span> toUpdate<span>]</span></pre></td></tr></table></div>
<p>Once we’ve done all this, we can filter on the edit distance and search result rank, to find some good matches:</p>
<div class="wp_syntax"><table><tr><td class="code"><pre class="python"><span>[</span>x <span>for</span> x <span>in</span> \
  table.<span>filter</span><span>(</span><span>{</span><span>'rank'</span>: <span>1</span><span>}</span><span>)</span> \
       .<span>filter</span><span>(</span><span>lambda</span> x: x<span>[</span><span>'Title_Query_Distance'</span><span>]</span> <span>&lt;</span> <span>.05</span><span>)</span> \
       .<span>pluck</span><span>(</span><span>"Title"</span><span>,</span> <span>"search_query"</span><span>,</span> <span>"Url"</span><span>)</span> \
       .<span>limit</span><span>(</span><span>10</span><span>)</span> \
       .<span>run</span><span>(</span><span>)</span><span>]</span></pre></td></tr></table></div>
<p>The following are the results of this query – you can see these look pretty good. Getting all the good results will require some manual intervention, but the manual work is on a dataset that resembles what we really want in the end.</p>
<pre>
[{u'Title': u'REQUEST FOR PROPOSALS GYM FLOOR SANDING AND REFINISHING ...',
  u'Url': u'http://www.ri.net/middletown/rfp/RFP_MHS_GymFloorSanding.pdf',
  u'search_query': u'floor resurfacing proposal'},
 {u'Title': u'REQUEST FOR PROPOSAL (DESIGN BUILD FEE) CONSTRUCTION OF ...',
  u'Url': u'http://www.harborhousefl.com/wp-content/uploads/2012/05/Harbor-House-RFP-Final_Perimeter-Wall-2012.pdf',
  u'search_query': u'gate installation proposal'},
 {u'Title': u'REQUEST FOR PROPOSAL COUNTYWIDE RECORDS MANAGEMENT AND ...',
  u'Url': u'http://www.state.nj.us/counties/mercer/pdfs/exempt_rfpss200801.pdf',
  u'search_query': u'storage consultants proposal'},
 {u'Title': u'REQUEST FOR PROPOSAL #6645 SEALANT &amp; CAULKING SERVICES FOR ...',
  u'Url': u'http://www.ewashtenaw.org/government/departments/finance/purchasing/online_bids/bid-status-previous-years/previous-year-assets/assets_2011/rfp6645.pdf',
  u'search_query': u'caulking proposal'}]
</pre>
</div></div></body></html>