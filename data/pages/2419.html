<html><body><div><div class="content container">
      




<p class="date">12 Dec 2014</p>


<p>In this post we will learn how to use the <a href="https://docs.python.org/3/library/ast.html">ast</a> module to extract docstrings from Python files.</p>

<h2 id="what-is-ast">What is ast?</h2>

<p>Simply put, <a href="https://docs.python.org/3/library/ast.html">ast</a> is a module present in the standard library that can parse Python syntax. Its whole purpose is to read Python code and to break it down into its syntactic components. Let’s explore this concept by analyzing a simple statement:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span></code></pre></figure>

<p>To parse a statement with <a href="https://docs.python.org/3/library/ast.html">ast</a>, we can pass the code as a string to the function <code class="highlighter-rouge">ast.parse</code>.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">ast</span>
<span class="n">mod</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">'a = 3 * (b + c)'</span><span class="p">)</span></code></pre></figure>

<p>The function will return an instance of the <code class="highlighter-rouge">ast.Module</code> class that represents, simply put, a piece of code.</p>

<p><em>How do we extract the contents of this piece of code?</em> — <code class="highlighter-rouge">ast.Module</code> has an attribute called <code class="highlighter-rouge">body</code>, that lets you retrieve a list of all the syntactic expressions contained in this code:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; mod.body
[&lt;_ast.Assign at 0x494cc18&gt;]</code></pre></figure>

<p>As you can see, the attribute body is a Python list containing a single element, of type <code class="highlighter-rouge">ast.Assignment</code>. Unsuprisingly this corresponds to the single assignment operation <code class="highlighter-rouge">a = value</code> that we performed.</p>

<p><em>How do we retrieve the left and right components of the assignment?</em> — Easily enough, the <code class="highlighter-rouge">ast.Assignment</code> has two attributes <code class="highlighter-rouge">targets</code> and <code class="highlighter-rouge">values</code> that contain exactly those two components.</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; assignment = mod.body[0]
&gt;&gt;&gt; assignment.targets
[&lt;_ast.Name at 0x494cd68&gt;]
&gt;&gt;&gt; assignment.value
&lt;_ast.BinOp at 0x494c198&gt;</code></pre></figure>

<div class="tip">
    <p>To interactively explore which fields are available, each ast object exposes the attribute <code>_fields</code> containing a list of the available fields.</p>
</div>

<p>As you can see, the targets are the value we are assigning to ( in this case it is a <code class="highlighter-rouge">ast.Name</code> object corresponding to the variable <code class="highlighter-rouge">a</code>), and the value is a binary operation, <code class="highlighter-rouge">ast.BinOp</code>, that corresponds to the expression <code class="highlighter-rouge">3 * (b + c)</code>. We can continue this process untill we decompose the expression into its prime components.</p>

<p>The end result of this process is called <em>Abstract Syntax Tree</em>. Each entity (<code class="highlighter-rouge">ast.Node</code>) can be decomposed in a recursive structure. The following scheme is an illustration of the Abstract Syntax Tree for the expression above (put your mouse on the nodes to reveal the code):</p>

<p id="graph"/>




<h2 id="getting-all-the-functions">Getting all the functions</h2>

<p>Now that we have a good understanding of how the parsing works, we can write a simple tool that takes a Python file and extracts all the toplevel function definitions.</p>

<p>The main idea is that we iterate over all the nodes in <code class="highlighter-rouge">Module.body</code> and we use <code class="highlighter-rouge">isinstance</code> to check if the node is a function definition. As an example, we’ll parse the <code class="highlighter-rouge">ast</code> module itself, but you can use whatever module you want. To retrieve the location of the <code class="highlighter-rouge">ast</code> module we will use the following code:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; import ast
&gt;&gt;&gt; ast.__file__
'C:\\Users\\Gabriele\\Anaconda\\lib\\ast.pyc'
&gt;&gt;&gt; # stripping the pyc and adding the py
&gt;&gt;&gt; import os
&gt;&gt;&gt; ast_filename = os.path.splitext(ast.__file__)[0] + '.py'</code></pre></figure>

<p>At this point we read the file as a string and we parse it with <code class="highlighter-rouge">ast</code>. Then, we iterate on the expression contained in the model and we collect all of the <code class="highlighter-rouge">ast.FunctionDef</code> instances:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">with</span> <span class="n">fd</span> <span class="k">as</span> <span class="nb">open</span><span class="p">(</span><span class="n">ast_filename</span><span class="p">):</span>
    <span class="n">file_contents</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">module</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">file_contents</span><span class="p">)</span>
<span class="n">function_definitions</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">body</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">FunctionDef</span><span class="p">)]</span></code></pre></figure>

<p>If we want to see the function names, we can simply access the <code class="highlighter-rouge">name</code> attribute of <code class="highlighter-rouge">ast.FunctionDef</code>:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; [f.name for f in function_definitions]
['parse',
 'literal_eval',
 'dump',
 'copy_location',
 'fix_missing_locations',
 'increment_lineno',
 'iter_fields',
 'iter_child_nodes',
 'get_docstring',
 'walk']</code></pre></figure>

<p><em>How do we extract the docstrings?</em>— Easy, you can use <code class="highlighter-rouge">ast.get_docstring</code> on a <code class="highlighter-rouge">ast.FunctionDef</code> object. The following code will print the name of each function and its documentation:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">function_definitions</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'---'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'---'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">get_docstring</span><span class="p">(</span><span class="n">f</span><span class="p">))</span></code></pre></figure>

<p>That will produce the following output:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>---
parse
---
Parse the source into an AST node.
Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).
---
literal_eval
---
Safely evaluate an expression node or a string containing a Python
expression.  The string or node provided may only consist of the following
...
</code></pre>
</div>

<p>So far we learned how to extract docstrings from function definitions, but <em>what about classes and methods?</em></p>

<p>As you know, when you declare a class, you write a bunch of <em>function definitions</em> in the class <em>body</em> to declare its methods. This translates in <code class="highlighter-rouge">ast</code> as follows. Class definitions are represented as <code class="highlighter-rouge">ast.ClassDef</code> instances, and each <code class="highlighter-rouge">ast.ClassDef</code> object contains a <code class="highlighter-rouge">body</code> attribute that contains the function definitions (or methods). In the following example we first collect all the classes in the module, then for each class we collects its methods.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">class_definitions</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">body</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">ClassDef</span><span class="p">)]</span>
<span class="n">method_definitions</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">class_def</span> <span class="ow">in</span> <span class="n">class_definitions</span><span class="p">:</span>
    <span class="n">method_definitions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">class_def</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">FunctionDef</span><span class="p">])</span></code></pre></figure>

<p>At this point, extracting the docstring is a matter of calling <code class="highlighter-rouge">ast.get_docstring</code> on the collected <code class="highlighter-rouge">ast.FunctionDef</code> and <code class="highlighter-rouge">ast.ClassDef</code> objects.</p>

<p>For more <code class="highlighter-rouge">ast</code> goodness, please check out the <a href="https://docs.python.org/3.4/library/ast.html"> official documentation</a>.</p>

<p>Thank you for reading, and happy parsing!</p>


<p class="separator"/>


<h3>Share this Post</h3>





    
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>            </noscript>



    </div>

    </div></body></html>