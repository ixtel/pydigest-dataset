<html><body><div><article id="0Z4Q9QosSem3matNClP" class="post  historical">
	<time datetime="2015-01-06" class="article_time">January  6, 2015</time>
  
	<p>Generators are a very fascinating concept in python; generators have a wide range of applications from simple lazy evaluation to mind-blowing advanced concurrent execution of tasks (<em>see <a href="http://www.dabeaz.com/finalgenerator/" rel="nofollow">David Beazley</a></em>). Before we dive into the fascinating world of python generators, we take a little detour to explain <em>python iterators</em>, a concept that I feel is integral to grasping generators.</p>
<h1 id="python-iterators_1">
<a class="head_anchor" href="#python-iterators_1" rel="nofollow"> </a>Python Iterators</h1>
<p>Simply put, an iterator in python is any python type that can be used with a <code class="prettyprint">for</code> loop. Python <em>lists, tuples, dicts and sets</em> are all examples of inbuilt iterators. One may ask, <em>what about these types that make them iterators and is this a property of only inbuilt types?</em> <br/>
 These types are iterators because they implement the <strong>iterator protocol</strong>. Then again, <strong>What is the iterator protocol?</strong><br/>
To answer this question requires another little detour. In python, there are some special object methods commonly referred to as <strong><em>magic methods</em></strong>. Just stay with me on this and believe what I say on faith at least till we get to object orientation in python. These methods are not normally called explicitly in code but are called implicitly by the python interpreter during code execution. A very familiar example of these magic methods is the <code class="prettyprint">__init__</code> method that is roughly analogous to a constructor that is called during the initialization of a python object. Similar to the way <code class="prettyprint">__init__</code> magic method has to be implemented for custom object initialization, the iterator protocol has a number of magic methods that need to be implemented by any object that wants to be used as an <strong><em>iterator</em></strong>. These methods are</p>

<ul>
<li><p><code class="prettyprint">__iter__</code> method that is called on initialization of an iterator. This should return an object that has a  <code class="prettyprint">next</code> method (In python 3 this is changed to <code class="prettyprint">__next__</code>).</p></li>
<li><p><code class="prettyprint">next</code> method that is called whenever the <a href="https://docs.python.org/2/library/functions.html#next" rel="nofollow"><code class="prettyprint">next()</code></a> global function is invoked with the iterator as argument. The iterator <code class="prettyprint">next</code> method should return the next value for the iterable. When an iterator is used with  a <em>for</em> loop, the <em>for</em> loop implicitly calls <code class="prettyprint">next()</code> on the iterator object. This method should raise a <code class="prettyprint">StopIteration</code> exception when there is no longer any new value to return to signal the end of the iteration.</p></li>
</ul>

<p>Any python class can be defined to act as an iterator so long as the iterator protocol is implemented. This is illustrated by implementing a simple iterator that returns Fibonacci numbers up to a given maximum value.</p>

<pre><code class="prettyprint lang-python">class Fib:                                        
    def __init__(self, max):                      
        self.max = max

    def __iter__(self):                          
        self.a = 0
        self.b = 1
        return self

    def next(self):                          
        fib = self.a
        if fib &gt; self.max:
            raise StopIteration                  
        self.a, self.b = self.b, self.a + self.b
        return fib           

&gt;&gt;&gt;for i in Fib(10):
        print i      

0
1
1
2
3
5
8               
</code></pre>

<p>We also go ahead and implement our own custom <code class="prettyprint">range</code> function for  looping through numbers. This simple implementation only loops from 0 upwards.</p>

<pre><code class="prettyprint lang-python">
class CustomRange:
    def __init__(self, max):
        self.max = max

    def __iter__(self):
        self.curr = 0
        return self

    def next(self):
        numb = self.curr
        if self.curr &gt;= self.max:
            raise StopIteration
        self.curr += 1
        return numb

for i in CustomRange(10):
     print i 
0
1
2
3
4
5
6
7
8
9
</code></pre>
<h1 id="back-to-generators_1">
<a class="head_anchor" href="#back-to-generators_1" rel="nofollow"> </a>Back To Generators</h1>
<p>Now, we have a basic understanding of iterators but how do they relate to generators. In short, python generators are iterators. <strong><em>PEP 255</em></strong> that describes simple generators refers to generators by their full name, <strong><em>generator-iterators</em></strong>. Generators are used either by calling the next method on the generator object or using the generator object in a <em>for</em> loop. </p>

<p>In python, generator functions or just generators return generator objects.  These generators are functions that contain the <code class="prettyprint">yield</code> key word. Rather than having to write every generators with the <code class="prettyprint">__iter__</code> and <code class="prettyprint">next</code>  which is pretty cumbersome, python provides the <code class="prettyprint">yield</code> key word that provides an easy way for defining generators. For example the Fibonacci iterator can be recast as a generator using the <code class="prettyprint">yield</code> key word as shown below:</p>

<pre><code class="prettyprint lang-python">def fib(max):
    a, b = 0, 1
    while a &lt; max:
        yield a
        a, b = b, a + b
</code></pre>

<p>The use of the <code class="prettyprint">yield</code> key word greatly simplifies the creation of the generator. </p>
<h2 id="the-code-classprettyprintyieldcode-keyword_2">
<a class="head_anchor" href="#the-code-classprettyprintyieldcode-keyword_2" rel="nofollow"> </a>The <code class="prettyprint">yield</code>  keyword</h2>
<p>The <code class="prettyprint">yield</code> keyword is used in the following way </p>

<pre><code class="prettyprint lang-python">yield expression_list
</code></pre>

<p>The <code class="prettyprint">yield</code> keyword is central to python generator functions but what does this <code class="prettyprint">yield</code> keyword do? To understand the <code class="prettyprint">yield</code> keyword, we contrast it with the <code class="prettyprint">return</code> key word; the other keyword that gives back control to the caller of a function. When a function that is executing encounters the <code class="prettyprint">yield</code> keyword, it suspends execution at that point, saves its context and returns to the caller along with any value in the expression_list; when the caller invokes next on the object, execution of the function continues till another <strong><em>yield</em></strong> or  <strong><em>return</em></strong> is encountered or end of function is reached. To quote PEP 255, </p>
<blockquote>
<p>If a yield statement is encountered, the state of the function is<br/>
   frozen, and the value of expression_list is returned to .next()’s<br/>
  caller.  By “frozen” we mean that all local state is retained,<br/>
  including the current bindings of local variables, the instruction<br/>
  pointer, and the internal evaluation stack:  enough information is<br/>
 saved so that the next time .next() is invoked, the function can<br/>
proceed exactly as if the yield statement were just another external<br/>
 call.<br/>
On the other hand when a function encounters a <code class="prettyprint">return statement</code>, it returns to the caller along with any value proceeding the <code class="prettyprint">return</code> statement and the execution of such function is complete for all intent and purposes. One can think of <code class="prettyprint">yield</code> as causing only a temporary interruption in the executions of a function.</p>
</blockquote><h1 id="python-generators-in-action_1">
<a class="head_anchor" href="#python-generators-in-action_1" rel="nofollow"> </a>Python generators in action</h1>
<p>Returning to the Fibonacci number function, if we wanted to generate all Fibonacci numbers up to a maximum value, the following non-generator snippet can be used to create the sequence</p>

<pre><code class="prettyprint lang-python">def fib(max):
    numbers = []
    a, b = 0, 1
    while a &lt; max:
        numbers.append(a)
        a, b = b, a + b
     return numbers
</code></pre>

<p>The above snippets eagerly calculates all the numbers below <em>max</em> and returns the collection of such numbers using a single function call. On the other hand, using the Fibonacci generator to solve the same problem is a different ball game. We can either use it in a <strong><em>for</em></strong> loop and allow the <strong><em>for</em></strong> construct to implicitly initialize the generator and call <code class="prettyprint">next</code> on the generator object or by explicitly initializing and calling <code class="prettyprint">next</code> on it. The values are returned one after the order by calling the <code class="prettyprint">next</code> on the generator. <br/>
The Fibonacci number generator is implemented using the <code class="prettyprint">yield</code> keyword as shown below:</p>

<pre><code class="prettyprint lang-python">def fib(max):
    a, b = 0, 1
    while a &lt; max:
        yield a
        a, b = b, a + b
</code></pre>

<p>In the following sections, we explicitly initialize the generator and make use of the `<code class="prettyprint">next</code> function to get values from the generator. First, we initialize the generator object as shown below</p>

<pre><code class="prettyprint lang-python"> &gt;&gt;&gt; gen = fib(10)
&gt;&gt;&gt; gen
&lt;generator object fib at 0x1069a6d20&gt;
&gt;&gt;&gt; 
</code></pre>

<p>What has happened above is that when the generator is called, the arguments <em>(max has a value of 10)</em> are bound to names but the body of the function is not executed. Rather a <strong>generator-iterator</strong> object is returned as shown by the value of  <code class="prettyprint">gen</code>. This object can then be used as an iterator. Note that it is the presence of the <code class="prettyprint">yield</code> keyword is responsible for this. </p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; next(gen)
0
&gt;&gt;&gt; next(gen)
1
&gt;&gt;&gt; next(gen)
1
&gt;&gt;&gt; next(gen)
2
&gt;&gt;&gt; next(gen)
3
&gt;&gt;&gt; next(gen)
5
&gt;&gt;&gt; next(gen)
8
&gt;&gt;&gt; next(gen)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>

<p>Now when the <code class="prettyprint">next</code> function is called with the generator object as argument, the generator function body executes till it encounters a <code class="prettyprint">yield</code> or <code class="prettyprint">return</code> statement or the end of the function body is reached. In the case of encountering a yield statement, the expression following the yield is returned to the caller and the state of the function is saved. When <code class="prettyprint">next</code> is called on the Fibonacci generator object <code class="prettyprint">a is bound to 0</code> and <code class="prettyprint">b is bound to 1</code>. The <code class="prettyprint">while</code> condition is true so the first statement of the while loop is executed which happens to be a <code class="prettyprint">yield</code> expression. This expression return the value of <code class="prettyprint">a</code> which happens to be <code class="prettyprint">0</code> to the caller and suspends at that point with all local context saved.<br/>
Think of this as eating your lunch partly and then storing it so as to  continue eating later. You can keep eating till the lunch is exhausted and in the case of a generator, this is the function getting to a return statement or the end of function body. When the <code class="prettyprint">next</code> is called on the Fibonacci  object again, execution resumes  at the <code class="prettyprint">a, b = b, a+b</code> line and continues executing as normal till <code class="prettyprint">yield</code> is encountered again. This continues till the loop condition is <code class="prettyprint">false</code> and a <code class="prettyprint">StopIteration</code> exception is then raised to signal that there is no more data to generate.</p>
<h1 id="generator-expressions_1">
<a class="head_anchor" href="#generator-expressions_1" rel="nofollow"> </a>Generator Expressions</h1>
<p>In python comprehensions, we discussed list comprehensions and how they are formed. One drawback with list comprehensions is that values are calculated all at once regardless of whether the values are needed at that time or not. This may sometimes consume an inordinate amount of computer memory. <a href="https://www.python.org/dev/peps/pep-0289/" rel="nofollow">PEP 289</a> proposed the generator expression to resolve this and this proposal was accepted and added to the language. Generator expressions are  like list comprehensions; the <strong>only</strong> difference is that the square brackets in list comprehensions are replaced by circular brackets that return. We contrast list comprehensions and generators below.</p>

<p>To generate a list of the square of number from 0 to 10 using list comprehensions the following is done:</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; squares = [i**2 for i in range(10)]
&gt;&gt;&gt; squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>

<p>We could use a generator expression such as below in place of  a list comprehension:</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; squares = (i**2 for i in range(10))
&gt;&gt;&gt; squares
&lt;generator object &lt;genexpr&gt; at 0x1069a6d70&gt;
</code></pre>

<p>We can then access the values of the generators using <em>for</em> loops or <code class="prettyprint">next</code> methods as shown below. Each value is then computed only on demand.</p>

<pre><code class="prettyprint lang-python">&gt;&gt;&gt; squares = (i**2 for i in range(10))
&gt;&gt;&gt; for square in squares:
            print square
0
1
4
9
16
25
36
49
64
81
</code></pre>
<h1 id="of-what-use-are-these-generators_1">
<a class="head_anchor" href="#of-what-use-are-these-generators_1" rel="nofollow"> </a>Of what use are these generators?</h1>
<p>Python generators provide the basis for <strong><em>lazy evaluation</em></strong> or <strong><em>calculation on demand</em></strong> in python. Lazy evaluation is an integral part of stream processing (processing of huge amount of data). For example, imagine we wanted an  create an indeterminate amount of Fibonacci numbers, this would not be possible with a non-generator approach because we have to define the amount of numbers we need or go into an infinite loop. On the other hand, adopting the generator approach makes doing so trivial; we just have to call <code class="prettyprint">next</code> to get the next Fibonacci number without bothering about where or when the stream of numbers ends. A more practical type of stream processing is handling large data files such as log files. Generators provide a space efficient method for such data processing as only parts of the file are handled at one given point in time. (<a href="http://www.dabeaz.com/generators-uk/GeneratorsUK.pdf" rel="nofollow">David Beazley</a>.</p>

<p>Generators can also be used to replace callbacks. Rather than pass a callback to a function, the function can yield control to the caller when it needs to report to the caller. The caller can then invoke the function that would have been used as a callback. This frees the main function from having to know about the callback.</p>

<p>At a more advanced level, generators can also be used to implement concurrency (<a href="http://www.dabeaz.com/finalgenerator/" rel="nofollow">David Beazley</a>). When a generator <code class="prettyprint">yields</code> control to the caller, the caller can then go ahead to call another generator simulating concurrency. </p>

<p>The above listed are just a few of possible applications of python generators. In a follow up post, we will discuss new additions to python generators that enable a caller to send values to a generator as well as some advanced uses of generators.</p>
<h2 id="further-reading_2">
<a class="head_anchor" href="#further-reading_2" rel="nofollow"> </a>Further Reading</h2>
<p><a href="https://www.python.org/dev/peps/pep-0255/" rel="nofollow">PEP 255 – Simple Generators</a></p>

<p><a href="https://www.python.org/dev/peps/pep-0289/" rel="nofollow">PEP 289 – Generator Expressions</a></p>

<p><a href="http://www.dabeaz.com/finalgenerator/FinalGenerator.pdf" rel="nofollow">Generators: The Final Frontier by David Beazley</a></p>

<p><a href="https://docs.python.org/2/tutorial/classes.html#generators" rel="nofollow">Python Tutorials - Generators</a></p>

<p><a href="https://docs.python.org/2/tutorial/classes.html#generator-expressions" rel="nofollow">Python Tutorials - Generator Expressions</a></p>

<p><a href="https://docs.python.org/2/tutorial/classes.html#iterators" rel="nofollow">Python Tutorials - Iterators</a></p>

  <figure class="postend kudo able clearfix" id="kudo_0Z4Q9QosSem3matNClP">
    <a href="#kudo">
      <p class="filling"> </p>
    </a>
    <p class="num">345</p>
    <p class="txt">Kudos</p>
  </figure>
  <figure class="side kudo able clearfix" id="kudo_side_0Z4Q9QosSem3matNClP">
    <a href="#kudo">
      <p class="filling"> </p>
    </a>
    <p class="num">345</p>
    <p class="txt">Kudos</p>
  </figure>
</article>

</div></body></html>