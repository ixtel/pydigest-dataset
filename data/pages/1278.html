<html><body><div><div class="body">
            
            <p>Yesterday I wrote a small introduction to Scheme for Python programmers <a href="http://blog.vosnax.ru/2013/10/23/Scheme-for-Pythonistas/">here</a>. I believe it might be a good start because being new to Scheme myself is pretty much what I understood first. Today, I read some questions on Stackoverflow and felt that I had to keep going. With hopefully more and more complicated samples. I'll try to cover it this article some new basic stuff.</p>

<ul>
<li>Branch statement (<code>if</code>, <code>cond</code>…) </li>
<li>use of <code>set!</code> and <code>define</code> </li>
<li><code>let</code> expression to create local variables</li>
<li>named <code>let</code> to create loops </li>
<li><code>let*</code> recursive to create interdependant variables</li>
</ul>
<h1>Branching statements</h1>
<p>I have been programming for many years and only recently discovered that statements like if, switch, unless etc. could be called as branching statements because a program can be written as a tree or graph. A <code>if</code> is branching a program in at most two different places. If the condition is true, it execute the first statement. If the condition is false it may execute the second statement or keep going if there is no second statement. A if in Scheme can be written like this.</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="k">if </span><span class="nv">condition</span>
    <span class="nv">statement1</span>
    <span class="nv">statement2</span><span class="p">)</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="nv">x</span>
  <span class="nv">y</span><span class="p">)</span>
</pre></div>
</td></tr></table></div></div>
<p>In Scheme, the if statement will return the result of the statement it executes. As you can see, the last sample above is returning the maximal value.We can then rewrite it in a lambda that return the maximal value of 2 variables.</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">max </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="nv">x</span>
    <span class="nv">y</span><span class="p">))</span>
</pre></div>
</td></tr></table></div></div>
<p>It as easy as it can be. Now what if we wanted the squared value of <code>max(x, y)</code>?</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">maxSquared</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">* </span><span class="nv">y</span> <span class="nv">y</span><span class="p">)))</span>

<span class="c1">; A smarter way to write it</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">maxSquared</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nb">max </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">* </span><span class="nv">max</span> <span class="nv">max</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div></div>
<p>In the first sample above, you can see that we can not only return a value but execute a statement and return its value. In the second sample, I used the let block to reduce the complexity of the function. Since we are doing the same operation on the result of the <code>if</code>, it doesn't make sense to repeat the operation in each statement. We can instead store the result of the <code>if</code> in a variable named <code>max</code> and square the <code>max</code>.</p>

<p>In python we could write the above function like that:</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">maxSquared</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">:</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="n">y</span>

    <span class="k">return</span> <span class="nb">max</span> <span class="o">*</span> <span class="nb">max</span>

<span class="c"># Or more simply</span>
<span class="k">def</span> <span class="nf">maxSquared</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="k">else</span> <span class="n">y</span>
    <span class="k">return</span> <span class="nb">max</span> <span class="o">*</span> <span class="nb">max</span>
</pre></div>
</td></tr></table></div></div>
<p>Now that you should understand exactly how the if statement works, I'll go back to one example I wrote from the first article.</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">z</span>
    <span class="k">elif</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</pre></div>
</td></tr></table></div></div><div class="code"><div><table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">foo</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
        <span class="nv">z</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
            <span class="nv">x</span>
            <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))))</span>
</pre></div>
</td></tr></table></div></div>
<p>As you can see, the scheme version isn't really sexy and nesting <code>ifs</code> can make the code harder to read than the code in Python. Fortunately Scheme has some other construct that we can play with. In this particular case, it makes more sense to use the <code>cond</code> function. We could then rewrite the above function like this:</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">foo</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">z</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">&lt; </span><span class="nv">y</span> <span class="nv">z</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
        <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))))</span>
</pre></div>
</td></tr></table></div></div>
<p>The <code>cond</code> function is pretty much similar to a <code>switch/case</code> statement. The <code>cond</code> function is called with lists of conditions paired with expressions. To make it easier to understand, here is an example:</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nf">cond</span>
  <span class="p">(</span><span class="nf">condition1</span> <span class="nv">expression1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">condition2</span> <span class="nv">expression2</span> <span class="nv">expression3</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">condition3</span> <span class="nv">expression4</span> <span class="nv">expression5</span> <span class="o">...</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">conditionN</span> <span class="nv">expressionN</span> <span class="o">...</span><span class="p">))</span>

<span class="o">#</span> <span class="nv">And</span>

<span class="p">(</span><span class="nf">cond</span>
  <span class="p">(</span><span class="nf">condition1</span> <span class="nv">expression1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">condition2</span> <span class="nv">expression2</span> <span class="nv">expression3</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">condition3</span> <span class="nv">expression4</span> <span class="nv">expression5</span> <span class="o">...</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">conditionN</span> <span class="nv">expressionN</span> <span class="o">...</span><span class="p">)</span>
  <span class="p">(</span><span class="k">else </span><span class="nv">expressions</span> <span class="o">....</span><span class="p">))</span>
</pre></div>
</td></tr></table></div></div>
<p>When evaluation <code>cond</code> it will test the first condition, if it fails, it will evaluate the next condition. As soon as a test test to true, it will execute the expressions that are related to the condition. Each condition are packed in their own list followed by expression that should be executed in order if the condition evaluates to true. The <code>else</code> that should be present as the last condition might be an implementation specific thing. In chicken scheme, trying to add conditions after a <code>else</code> will create a warning but is still possible.</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="c1">; Define else as boolean true</span>
<span class="p">(</span><span class="k">define else </span><span class="no">#t</span><span class="p">)</span>

<span class="p">(</span><span class="nf">cond</span>
  <span class="p">(</span><span class="nf">condition1</span> <span class="nv">expr</span><span class="o">...</span><span class="p">)</span>
  <span class="p">(</span><span class="k">else </span><span class="o">...</span><span class="p">))</span>
</pre></div>
</td></tr></table></div></div>
<p>In chicken scheme, even if you define <code>else</code> to <code>#f</code>, it won't change how the else is handled. Also, it is important to note that the latest evaluated expression is the value returned by the <code>cond</code> statement. Which means that we can nest the <code>cond</code> statement just like a <code>if</code>. In fact, in functional languages, any function that doesn't have side effect should return something that can be later used somewhere else. The result of theses functions can be used directly as argument to other functions instead of creating variables. The good thing about it is that you're unlikely to see unused variable in functional code. We rarely have to create variables since we are probably going to call directly other function with the result of other functions.</p>
<h1>The <code>let</code> expression</h1>
<p>The <code>let</code> expression is one important expression, it allows us to create variables that can be used multiple times. Variables in let are limited to the length of the let. Variables are lexically scoped and destroyed with the let that created them. <code>Let</code> expressions are hidden lambdas.</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="c1">; These are equivalent</span>
<span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span> <span class="mi">2</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</pre></div>
</td></tr></table></div></div>
<p>In python, there is nothing really similar. It's pretty much like creating a function and calling it directly after. Using the lambda syntax, we could write something like this:</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="o">#</span> <span class="nv">Almost</span> <span class="nv">like</span> <span class="nv">the</span> <span class="nv">first</span> <span class="nv">example</span> <span class="nv">of</span> <span class="nv">lambda</span>
<span class="p">(</span><span class="k">lambda </span><span class="nv">x,</span> <span class="nv">y:</span> <span class="nv">x</span> <span class="nv">+</span> <span class="nv">y</span><span class="p">)(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</td></tr></table></div></div><div class="code"><div><table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="c"># It's pretty much the only possible equivalent.</span>
<span class="k">def</span> <span class="nf">plus</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
<span class="n">plus</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</td></tr></table></div></div>
<p>Unfortunately, python doesn't really handle anonymous function with more than one expression. Since let are usually unamed, it is hardly possible to reproduce in python with more than one expression. But there is more to let in Scheme. Since recursion is pretty much important and that using <code>define</code> and <code>set!</code> within functions might not be always a good idea. It is possible to create named <code>let</code> that can be called recursively from within.</p>

<p>In my first article, I used the named lambda to do recursion:</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">loop</span> <span class="nv">start</span> <span class="nv">stop</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loopInner</span> <span class="p">((</span><span class="nf">start</span> <span class="nv">start</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">stop</span> <span class="nv">stop</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">level</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">print</span> <span class="nv">start</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">start</span> <span class="nv">stop</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">loopInner</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">start</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">stop</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">level</span><span class="p">))</span>
      <span class="nv">level</span><span class="p">))</span>
</pre></div>
</td></tr></table></div></div><h1>Use of <code>define</code> and <code>set!</code></h1>
<p>Since <code>define</code> and <code>set!</code> are lexically scoped and are pretty much the same thing as <code>=</code>. Someone could ask himself, what is the point of using let instead of <code>define</code> or <code>set!</code>. Well, I'd say that let are safer to use. Let's look at an example.</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="k">let </span><span class="p">()</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">a</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">3</span><span class="p">)</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">a</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</td></tr></table></div></div>
<p>What will be the value of <code>a</code> after the execution? Think about it… If you think that after the execution the value of a should be 2 then you are right. To make it clear, here is how I believe thigns are happening.</p>

<ul>
<li>We defined a in the current scope (global)</li>
<li>We entered the let</li>
<li>We set a to 2 (set is searching for a and found it in the global scope)</li>
<li>We define a in the current scope (let)</li>
<li>We set a to 4 (we found a in the current scope and we leave the global unchanged)</li>
<li>The let return and anything that was created inside it is also freed.</li>
</ul>

<p>If we did write the code like this, the value of a would remain unchanged in the global scope.</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">a</span> <span class="mi">2</span><span class="p">))</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">a</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">a</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</td></tr></table></div></div>
<p>The use of <code>set!</code> may be dangerous as it can change the state of a variable in a global scope. The define should always define local variables but if you use <code>set!</code> before defining a local variable, then you are playing with fire.</p>

<p>In python, in order to have access to a global variable, you have to mark it as global.</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">hmm</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">hmm</span><span class="p">()</span>
<span class="n">a</span> <span class="o">==</span> <span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">hmm</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">a</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">a</span> <span class="o">==</span> <span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="bp">False</span>

<span class="c"># But in python, this is illegal</span>
<span class="k">def</span> <span class="nf">hmm</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">global</span> <span class="n">a</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c"># also illegal</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">4</span>
<span class="k">def</span> <span class="nf">hmm</span><span class="p">():</span>
    <span class="k">print</span> <span class="n">a</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</td></tr></table></div></div>
<p>In Python, we can read a global variable without marking it global as long as we aren't going to modify it. If we are assigning a value to a variable, it will get created locally and the global variable gets masked by the local variable. If we are assigning a value to a variable locally, any try to read a value from that variable before assignment will result into an unbound variable. In Scheme, as soon as something exists, we can use it. Once global variables are masked, we are stuck with local variables and global variables remain untouched.</p>

<p>Now more about the named let. It's like a usual let but with a name. The name can be used like a function call and the parameters are the same that we used to create it. Well we can change the parameter but they are in the same order.</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="nv">for</span> <span class="p">((</span><span class="nf">count</span> <span class="mi">10</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">print</span> <span class="nv">count</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">count</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">for</span> <span class="p">(</span><span class="nb">- </span><span class="nv">count</span> <span class="mi">1</span><span class="p">))</span>
      <span class="no">#t</span><span class="p">))</span>


<span class="c1">; Prints</span>
<span class="nv">&gt;</span> <span class="mi">10</span>
<span class="nv">&gt;</span> <span class="mi">9</span>
<span class="nv">&gt;</span> <span class="mi">8</span>
<span class="nv">&gt;</span> <span class="mi">7</span>
<span class="nv">&gt;</span> <span class="mi">6</span>
<span class="nv">&gt;</span> <span class="mi">5</span>
<span class="nv">&gt;</span> <span class="mi">4</span>
<span class="nv">&gt;</span> <span class="mi">3</span>
<span class="nv">&gt;</span> <span class="mi">2</span>
<span class="nv">&gt;</span> <span class="mi">1</span>
<span class="nv">&gt;</span> <span class="mi">0</span>
<span class="nv">returns</span> <span class="no">#t</span>
</pre></div>
</td></tr></table></div></div>
<p>On each step, the variable sent in the position of <code>count</code> is decremented by one until it reaches 0. When it reaches 0 it will return <code>#t</code> and the recursion stops. The execution would then leave the let and keep going. Calling the function <code>for</code> outside of the <code>let</code> should not be possible unless the variable is already define in a different closure.</p>
<h2>Recursive let</h2>
<p>The <code>let</code> syntax does come in multiple flavour for better result. The recursive let is a special case that allows the programmer to use previously defined variables. This syntax is called <code>let*</code> instead of just <code>let</code>.</p>
<h3>Example</h3><div class="code"><div><table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">a</span> <span class="mi">1</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">b</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="mi">1</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">c</span> <span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">c</span><span class="p">))</span>

<span class="nv">&gt;</span> <span class="mi">1</span>
<span class="nv">&gt;</span> <span class="mi">2</span>
<span class="nv">&gt;</span> <span class="mi">2</span>
</pre></div>
</td></tr></table></div></div>
<p>In python, I'd imagine this non working example:</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"/><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">hmm</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">a</span>
    <span class="k">print</span> <span class="n">b</span>
    <span class="k">print</span> <span class="n">c</span>

<span class="n">hmm</span><span class="p">()</span>
</pre></div>
</td></tr></table></div></div>
<p>Unfortunately how the language is defined, it isn't possible to do. One would have to create 3 different variables and call a function like this:</p>
<div class="code"><div><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">let</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">a</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

    <span class="k">print</span> <span class="n">a</span>
    <span class="k">print</span> <span class="n">b</span>
    <span class="k">print</span> <span class="n">c</span>

<span class="n">let</span><span class="p">()</span>

<span class="c"># Converting how the scheme code is built to python it would look like this</span>
<span class="c"># But I'm pretty sure that how it is done internally is implementation specific</span>
<span class="c"># and it could be done effectively</span>
<span class="k">def</span> <span class="nf">let</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">let2</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">let3</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">let4</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">print</span> <span class="n">a</span>
                <span class="k">print</span> <span class="n">b</span>
                <span class="k">print</span> <span class="n">c</span>
            <span class="k">return</span> <span class="n">let4</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">let3</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">let2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">let</span><span class="p">()</span> 
</pre></div>
</td></tr></table></div></div>
<p>There are more <code>let</code> variant and It's still pretty new to me and It would take a long time to talk about them. The most important is to understand the basics and then the other form of <code>let</code> and <code>lambda</code> should be easy to learn. As I'm trying to compare languages to each others I won't go into details much more. What is less obvious is that the let form has some advantages over “usual” sequential programming. A <code>let</code> can be easily transformed to a named let. Named let can be then reused recursively. Arguments of the closure are defined together. In python, variable can be defined anywhere and it might cause confusion and unused variables. In Scheme, we know which variables are used and where they should be located. It might sound a bit like C where variable declaration had to be done first. In Scheme, it does feel natural because <code>let</code> block can be small or big. A function may contain multiple <code>let</code> blocks and they are self contained. I believe it forces programmers to write clean code. If Scheme code isn't clean… it will be quite evident and will look pretty ugly.</p>

        </div>
    </div></body></html>