<html><body><div><div class="content html_format"><p>
      В </p><a href="http://habrahabr.ru/company/mailru/blog/201778/">предыдущей статье</a><p> мы на практике разобрались, где и в каких случаях можно использовать ручное профилирование, а так же познакомились со статистическими профайлерами.
</p><p>
Сегодня мы познакомимся с основной и самой многочисленной группой инструментов — событийными профайлерами.

</p><a name="habracut"/>


<h2>Задача для тренировки</h2><p>
В прошлой статье мы разбирали </p><a href="http://projecteuler.net/problem=3">задачу 3</a><p> из </p><a href="http://projecteuler.net/">Проекта Эйлера</a><p>. Для разнообразия возьмём какой-нибудь другой пример, например, </p><a href="http://projecteuler.net/problem=7">задачу 7</a><p> из этого же сборника задач:
</p><blockquote>Выписав первые шесть простых чисел, получим 2, 3, 5, 7, 11 и 13. Очевидно, что 6-ое простое число — 13.<br/>
Какое число является 10001-ым простым числом?</blockquote><p>
Пишем код:
</p><pre><code class="python">"""Project Euler problem 7 solve"""
from __future__ import print_function
import math
import sys


def is_prime(num):
    """Checks if num is prime number"""
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True


def get_prime_numbers(count):
    """Get 'count' prime numbers"""
    prime_numbers = [2]
    next_number = 3

    while len(prime_numbers) &lt; count:
        if is_prime(next_number):
            prime_numbers.append(next_number)
        next_number += 1

    return prime_numbers


if __name__ == '__main__':
    try:
        count = int(sys.argv[1])
    except (TypeError, ValueError, IndexError):
        sys.exit("Usage: euler_7.py number")
    if count &lt; 1:
        sys.exit("Error: number must be greater than zero")

    prime_numbers = get_prime_numbers(count)
    print("Answer: %d" % prime_numbers[-1])
</code></pre><p>
Помним, что код не идеален, и многие вещи можно сделать проще, лучше, быстрее. Именно в этом заключается цель данной статьи =)
</p><p>
В прошлой статье я </p><a href="http://habrahabr.ru/company/mailru/blog/201778/#comment_6970418">оконфузился</a><p> и не сделал самого важного: тестов. На самом деле поломать программу в процессе рефакторинга или оптимизации легче простого, и каждый цикл профилирования и переписывания кода должен в обязательном порядке сопровождаться тестированием функционала (как непосредственно затронутого изменениями, так и всего остального, ведь сайд-эффекты такие сайд-эффекты). Попробуем исправиться и добавим тесты в нашу программу. Самый простой и подходящий для такого простого скрипта вариант — использовать модуль </p><a href="http://docs.python.org/2/library/doctest.html">doctest</a><p>. Добавляем тесты и запускаем их:
</p><div class="spoiler"><b class="spoiler_title">Тесты</b><div class="spoiler_text"><pre><code class="python">"""Project Euler problem 7 solve"""
from __future__ import print_function
import math
import sys


def is_prime(num):
    """
    Checks if num is prime number.

    &gt;&gt;&gt; is_prime(2)
    True
    &gt;&gt;&gt; is_prime(3)
    True
    &gt;&gt;&gt; is_prime(4)
    False
    &gt;&gt;&gt; is_prime(5)
    True
    &gt;&gt;&gt; is_prime(41)
    True
    &gt;&gt;&gt; is_prime(42)
    False
    &gt;&gt;&gt; is_prime(43)
    True
    """
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True


def get_prime_numbers(count):
    """
    Get 'count' prime numbers.

    &gt;&gt;&gt; get_prime_numbers(1)
    [2]
    &gt;&gt;&gt; get_prime_numbers(2)
    [2, 3]
    &gt;&gt;&gt; get_prime_numbers(3)
    [2, 3, 5]
    &gt;&gt;&gt; get_prime_numbers(6)
    [2, 3, 5, 7, 11, 13]
    &gt;&gt;&gt; get_prime_numbers(9)
    [2, 3, 5, 7, 11, 13, 17, 19, 23]
    &gt;&gt;&gt; get_prime_numbers(19)
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]
    """
    prime_numbers = [2]
    next_number = 3

    while len(prime_numbers) &lt; count:
        if is_prime(next_number):
            prime_numbers.append(next_number)
        next_number += 1

    return prime_numbers


if __name__ == '__main__':
    try:
        count = int(sys.argv[1])
    except (TypeError, ValueError, IndexError):
        sys.exit("Usage: euler_7.py number")
    if count &lt; 1:
        sys.exit("Error: number must be greater than zero")

    prime_numbers = get_prime_numbers(count)
    print("Answer: %d" % prime_numbers[-1])
</code></pre></div></div>
<div class="spoiler"><b class="spoiler_title">Запуск тестов и результат</b><div class="spoiler_text"><pre><code>➜ python -m doctest -v euler_7.py
Trying:
    get_prime_numbers(1)
Expecting:
    [2]
ok
Trying:
    get_prime_numbers(2)
Expecting:
    [2, 3]
ok
Trying:
    get_prime_numbers(3)
Expecting:
    [2, 3, 5]
ok
Trying:
    get_prime_numbers(6)
Expecting:
    [2, 3, 5, 7, 11, 13]
ok
Trying:
    get_prime_numbers(9)
Expecting:
    [2, 3, 5, 7, 11, 13, 17, 19, 23]
ok
Trying:
    get_prime_numbers(19)
Expecting:
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]
ok
Trying:
    is_prime(2)
Expecting:
    True
ok
Trying:
    is_prime(3)
Expecting:
    True
ok
Trying:
    is_prime(4)
Expecting:
    False
ok
Trying:
    is_prime(5)
Expecting:
    True
ok
Trying:
    is_prime(41)
Expecting:
    True
ok
Trying:
    is_prime(42)
Expecting:
    False
ok
Trying:
    is_prime(43)
Expecting:
    True
ok
1 items had no tests:
    euler_7
2 items passed all tests:
   6 tests in euler_7.get_prime_numbers
   7 tests in euler_7.is_prime
13 tests in 3 items.
13 passed and 0 failed.
Test passed.
</code></pre></div></div>
<p>
Давайте посмотрим, насколько быстрый у нас получился код:
</p><pre><code>➜ python -m timeit -n 10 -s'import euler_7' 'euler_7.get_prime_numbers(10001)'
10 loops, best of 3: 1.27 sec per loop
</code></pre><p>
Да, небыстро, есть что пооптимизировать =)

</p><h2>Инструменты</h2><p>
Стандартные библиотеки Python поражают своим разнообразием. В них, кажется, есть всё, что только может понадобится разработчику, и профайлеры не исключение. На самом деле их целых три «из коробки»:
</p><ul>
<li><strong>cProfile</strong> — относительно новый (с версии 2.5) модуль, написанный на C и оттого быстрый</li>
<li><strong>profile</strong> — нативная реализация профайлера (написан на чистом питоне), медленный, и поэтому не рекомендуется к использованию</li>
<li><strong>hotshot</strong> — экспериментальный модуль на си, очень быстрый, но больше не поддерживается и в любой момент может быть удалён из стандартных библиотек</li>
</ul>

<h3>cProfile</h3><p>
Какой разговор о профилировании питона обходится без описания </p><a href="http://docs.python.org/2/library/profile.html">cProfile</a><p> — одного из стандартных модулей Python?</p><p>
Уверен, каждый программист Python хоть раз пробовал запустить cProfile:
</p><pre><code>➜ python -m cProfile -s time euler_7.py 10001
         428978 function calls in 1.552 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   104741    0.955    0.000    1.361    0.000 euler_7.py:7(is_prime)
   104741    0.367    0.000    0.367    0.000 {range}
        1    0.162    0.162    1.550    1.550 euler_7.py:32(get_prime_numbers)
   104741    0.039    0.000    0.039    0.000 {math.sqrt}
   104742    0.024    0.000    0.024    0.000 {len}
    10000    0.003    0.000    0.003    0.000 {method 'append' of 'list' objects}
        1    0.001    0.001    1.552    1.552 euler_7.py:1(&lt;module&gt;)
        1    0.000    0.000    0.000    0.000 {print}
        1    0.000    0.000    0.000    0.000 __future__.py:48(&lt;module&gt;)
        7    0.000    0.000    0.000    0.000 __future__.py:75(__init__)
        1    0.000    0.000    0.000    0.000 __future__.py:74(_Feature)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
</code></pre>
<i>Сразу заметим разницу во времени выполнения программы: без профайлера: 1.27 секунды, с профайлером: 1.55 секунд, то есть на 20% медленнее в нашем конкретном случае. И это ещё очень хороший результат!</i>
<p>
Итак, мы видим, что самая долгая (по суммарному времени) операция — функция </p><strong>is_prime</strong><p>. Практически всё время программа проводит в этой функции. Следующий по «тяжести» вызов — функция </p><strong>range</strong><p>, которая как раз вызывается из функции is_prime. Читаем </p><a href="http://docs.python.org/2/library/functions.html#range">документацию</a><p> и понимаем, что при вызове range в памяти создаётся список со всеми числами из заданного диапазона. С учётом того, что функция range вызывается 104741 раз, а верхняя граница диапазона при каждом вызове инкрементируется (перебираем числа последовательно), можно сделать вывод, что длина списка, создаваемого функцией range достигает сотни тысяч элементов к концу работы программы и список создаётся больше ста тысяч раз. Почитав ещё </p><a href="https://wiki.python.org/moin/ForLoop#Things_to_remember">документацию</a><p> мы узнаём, что нам следует использовать функцию </p><strong>xrange</strong><p> в этом цикле (внимательный читатель должен почувствовать сарказм в этом месте, ведь любой питонист знает про range VS xrange). Плюсом замены range на xrange будет так же явная экономия памяти (эту теорию мы проверим позже). Заменяем, запускаем тесты: всё ок, запускаем профайлер:
</p><pre><code>➜ python -m cProfile -s time euler_7.py 10001
         324237 function calls in 1.010 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   104741    0.825    0.000    0.857    0.000 euler_7.py:7(is_prime)
        1    0.127    0.127    1.009    1.009 euler_7.py:32(get_prime_numbers)
   104741    0.032    0.000    0.032    0.000 {math.sqrt}
   104742    0.022    0.000    0.022    0.000 {len}
    10000    0.003    0.000    0.003    0.000 {method 'append' of 'list' objects}
        1    0.001    0.001    1.010    1.010 euler_7.py:1(&lt;module&gt;)
        1    0.000    0.000    0.000    0.000 {print}
        1    0.000    0.000    0.000    0.000 __future__.py:48(&lt;module&gt;)
        7    0.000    0.000    0.000    0.000 __future__.py:75(__init__)
        1    0.000    0.000    0.000    0.000 __future__.py:74(_Feature)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
</code></pre><p>
1.010 секунды вместо 1.552, то есть в полтора раза быстрее! Нормально. Теперь самое узкое место в программе — функция </p><strong>is_prime</strong><p> сама по себе. Оптимизируем её позже, с использованием других инструментов.
</p><p>
Выводить результаты профилирования в консоль не всегда удобно, гораздо удобнее сохранять их в файл для дальнейшего анализа. Для этого можно воспользоваться ключом "-o":
</p><pre><code>➜ python -m cProfile -o euler_7.prof euler_7.py 10001
➜ ls
euler_7.prof      euler_7.py
</code></pre><p>
или можно воспользоваться простейшим декоратором:
</p><pre><code class="python">import cProfile


def profile(func):
    """Decorator for run function profile"""
    def wrapper(*args, **kwargs):
        profile_filename = func.__name__ + '.prof'
        profiler = cProfile.Profile()
        result = profiler.runcall(func, *args, **kwargs)
        profiler.dump_stats(profile_filename)
        return result
    return wrapper


@profile
def get_prime_numbers(count):
    ...
</code></pre><p>
И тогда при каждом вызове функции foo будет сохранён файл с результатами профилирования («get_prime_numbers.prof» в нашем случае).

</p><h3>hotshot</h3>
<a href="http://docs.python.org/2/library/hotshot.html">hotshot</a><p> — ещё один стандартный модуль Python, на данный момент не поддерживается и в любое время может быть удалён из стандартных библиотек. Но пока он есть, можно использовать его, ведь он очень быстрый и даёт минимальный оверхед при запуске программы под профайлером. Использовать его очень просто:
</p><pre><code class="python">import hotshot


prof = hotshot.Profile("profile_name.prof")
prof.start()

# your code goes here

prof.stop()
prof.close()
</code></pre><p>
Или в виде декоратора:
</p><pre><code class="python">import hotshot


def profile(func):
    """Decorator for run function profile"""
    def wrapper(*args, **kwargs):
        profile_filename = func.__name__ + '.prof'
        profiler = hotshot.Profile(profile_filename)
        profiler.start()
        result = func(*args, **kwargs)
        profiler.stop()
        profiler.close()
        return result
    return wrapper


@profile
def get_prime_numbers(count):
    ...
</code></pre>

<h2>Анализ результатов профилирования</h2><p>
Редко когда получается вывести результаты профилирования на экран сразу после запуска программы. Да и смысла в таких результатах немного: только простейшие скрипты и удастся изучить. Для просмотра и анализа данных лучше воспользоваться встроенным в Python модулем </p><a href="http://docs.python.org/2/library/profile.html#the-stats-class">pstats</a><p> (удобнее в сочетании с замечательной консолью </p><a href="http://ipython.org/">iPython</a><p>):
</p><pre><code>➜ ipython

In [1]: import pstats

In [2]: p = pstats.Stats('get_prime_numbers.prof')

In [3]: p.sort_stats('calls').print_stats()

         324226 function calls in 1.018 seconds

   Ordered by: call count

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   104742    0.023    0.000    0.023    0.000 {len}
   104741    0.821    0.000    0.854    0.000 euler_7.py:19(is_prime)
   104741    0.034    0.000    0.034    0.000 {math.sqrt}
    10000    0.003    0.000    0.003    0.000 {method 'append' of 'list' objects}
        1    0.138    0.138    1.018    1.018 euler_7.py:44(get_prime_numbers)
</code></pre><p>
Консоль, конечно, хорошая штука, но не очень наглядная. В особо сложных ситуациях, в программах с сотнями и тысячами вызовов анализ результатов представляется затруднительным. Так уж устроены люди, что графическую информацию нам (в отличие от компьютеров) воспринимать гораздо проще, чем текстовую. На помощь приходят различные инструменты для анализа результатов профилирования.

</p><h3>kcachegrind</h3><p>
Начну, пожалуй, с такого известного инструмента, как </p><a href="http://kcachegrind.sourceforge.net/">kcachegrind</a><p>, который, на самом деле, предназначен для визуализации результатов утилиты </p><a href="http://valgrind.org/docs/manual/cl-manual.html">Callgrind</a><p>, но переконвертировав результаты Python-профалера, их можно открыть в kcachegrind. Конвертирование выполняется с помощью утилиты </p><a href="https://github.com/pwaller/pyprof2calltree/">pyprof2calltree</a><p>:
</p><pre><code>➜ pip install pyprof2calltree
➜ pyprof2calltree -i profile_results.prof -o profile_results.kgrind
</code></pre><p>
Можно сразу открыть результаты в kcachegrind, без сохранения в файл:
</p><pre><code>➜ pyprof2calltree -i profile_results.prof -k
</code></pre><p>
Программа позволяет наглядно увидеть сколько времени занимает тот или иной вызов, а так же все вызовы внутри него. Так же можно посмотреть дерево вызовов и кучу другой полезной информации. Интерфейс выглядит таким образом:
</p><img src="http://habrastorage.org/storage3/e74/79f/99b/e7479f99be484a8ab9e08f0c931bc52b.png"/>

<h3>RunSnakeRun</h3><p>
Ещё одна программа для визуализации результатов профайлинга </p><a href="http://www.vrplumber.com/programming/runsnakerun/">RunSnakeRun</a><p> была изначально написана для работы с профайлером питона (это видно из её названия). Похожа на kcachegrind, но, как говорят авторы, выгодно отличается более простым интерфейсом и функционалом. Установка не вызовет сложностей:
</p><pre><code>➜ brew install wxwidgets
➜ pip install SquareMap RunSnakeRun
</code></pre><p>
Использование тоже:
</p><pre><code>➜ runsnake profile_results.prof
</code></pre><p>
Точно так же видим карту квадратов: чем больше площадь квадрата, тем больше времени заняло выполнение соответствующей функции:
</p><img src="http://habrastorage.org/storage3/d81/18a/559/d8118a55984b6459a4b2352fbc242c55.jpg"/>
<p>
RunSnakeRun позволяет так же визуализировать результат профилирования потребления памяти с помощью утилиты </p><a href="https://launchpad.net/meliae">Meliae</a><p>:
</p><img src="http://habrastorage.org/storage3/76a/ac5/f12/76aac5f12125c49547eb89c016ef7ae2.png"/>

<h3>gprof2dot</h3><p>
Утилита </p><a href="https://code.google.com/p/jrfonseca/wiki/Gprof2Dot">gprof2dot</a><p> генерирует картинку с деревом вызовов функций и информацией о времени их выполнения. В большинстве случаев этого достаточно для поиска узких мест в программе. Ставим и генерируем картинку:
</p><pre><code>➜ brew install graphviz
➜ pip install gprof2dot
➜ gprof2dot -f pstats profile_results.prof | dot -Tpng -o profile_results.png
</code></pre><p>
Результат:
</p><img src="http://habrastorage.org/storage3/d12/1e9/cd2/d121e9cd2a2ae3a8d1117c34dd5c8633.png"/>

<h2>Профилирование Django</h2><p>
Для профилирования Django удобно использовать модуль </p><a href="https://github.com/django-extensions/django-extensions">django-extensions</a><p>, который, помимо кучи разных полезных вещей, имеет полезную команду «runprofileserver». Использовать его просто. Ставим:
</p><pre><code>➜ pip install django-extensions</code></pre><p>
Добавляем application в settings.py:
</p><pre><code class="python">INSTALLED_APPS += ('django_extensions',)
</code></pre><p>
Запускаем:
</p><pre><code>➜ python manage.py runprofileserver --use-cprofile --prof-path=/tmp/prof/
</code></pre><p>
В директории /tmp/prof/ будет создан файл с результатами профилирования для каждого запроса в приложение:
</p><pre><code>➜ ls /tmp/prof/
admin.000276ms.1374075009.prof
admin.account.user.000278ms.1374075014.prof admin.jsi18n.000185ms.1374075018.prof
favicon.ico.000017ms.1374075001.prof
root.000073ms.1374075004.prof
static.admin.css.base.css.000011ms.1374075010.prof
static.admin.css.forms.css.000013ms.1374075017.prof
static.admin.img.icon-yes.gif.000001ms.1374075015.prof
static.admin.img.sorting-icons.gif.000001ms.1374075015.prof
static.admin.js.core.js.000018ms.1374075014.prof
static.admin.js.jquery.js.000003ms.1374075014.prof
static.css.bootstrap-2.3.2.min.css.000061ms.1374074996.prof
static.img.glyphicons-halflings.png.000001ms.1374075005.prof
static.js.bootstrap-2.3.2.min.js.000004ms.1374074996.prof
static.js.jquery-2.0.2.min.js.000001ms.1374074996.prof
user.login.000187ms.1374075001.prof
</code></pre><p>
Дальнейший анализ можно выполнить с помощью любого из инструментов, перечисленных выше: pstats, kcachegrind, RunSnakeRun или gprof2dot. Или любого другого =)
</p><p>
Помимо встроенного в Python профайлера имеется так же масса сторонних программ, простых и сложных, полезных и не очень.

</p><h2>pycallgraph</h2>
<a href="https://github.com/gak/pycallgraph/">pycallgraph</a><p> позволяет строить дерево вызовов программы Python. Ставим:
</p><pre><code>➜ brew install graphviz
➜ pip install pycallgraph
</code></pre><p>
Запускаем и смотрим результат:
</p><pre><code>➜ pycallgraph graphviz -- euler_7.py 10001
➜ open pycallgraph.png
</code></pre>
<img src="http://habrastorage.org/storage3/5f6/57a/ac4/5f657aac48a325ae6e02631665b50f3a.png"/>

<h2>line_profiler</h2>
<a href="https://bitbucket.org/robertkern/line_profiler">line_profiler</a><p>, как следует из его названия, позволяет построчно отпрофилировать нужные участки кода. Ставим:
</p><pre><code>➜ pip install line_profiler
</code></pre><p>
Добавляем в нужные места декоратор «profile» (я временно убрал докстринги для более компактного вывода результатов):
</p><pre><code class="python">@profile
def is_prime(num):
    for i in xrange(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True


@profile
def get_prime_numbers(count):
    prime_numbers = [2]
    next_number = 3

    while len(prime_numbers) &lt; count:
        if is_prime(next_number):
            prime_numbers.append(next_number)
        next_number += 1

    return prime_numbers
</code></pre><p>
Запускаем профилирование:
</p><pre><code>➜ kernprof.py -v -l euler_7.py 10001
Wrote profile results to euler_7.py.lprof
Timer unit: 1e-06 s

File: euler_7.py
Function: is_prime at line 7
Total time: 10.7963 s

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     7                                           @profile
     8                                           def is_prime(num):
     9   2935963      5187211      1.8     48.0      for i in xrange(2, int(math.sqrt(num)) + 1):
    10   2925963      5421919      1.9     50.2          if num % i == 0:
    11     94741       169309      1.8      1.6              return False
    12     10000        17904      1.8      0.2      return True

File: euler_7.py
Function: get_prime_numbers at line 15
Total time: 23.263 s

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    15                                           @profile
    16                                           def get_prime_numbers(count):
    17         1            5      5.0      0.0      prime_numbers = [2]
    18         1            3      3.0      0.0      next_number = 3
    19
    20    104742       208985      2.0      0.9      while len(prime_numbers) &lt; count:
    21    104741     22843717    218.1     98.2          if is_prime(next_number):
    22     10000        22405      2.2      0.1              prime_numbers.append(next_number)
    23    104741       187927      1.8      0.8          next_number += 1
    24
    25         1            2      2.0      0.0      return prime_numbers
</code></pre>
<i>Сразу замечаем огромный оверхед: программа выполнялась больше 30 секунд, при том, что без профайлера она отрабатывает быстрее, чем за секунду.</i>
<p>
Анализируя результаты можно сделать вывод, что наибольшее время программа тратит в строках 9 и 10, проверяя делители числа для определения его «простоты». И для каждого последующего числа происходят все те же самые проверки. Логичной оптимизацией программы является проверка в качестве делителей только тех чисел, которые ранее были определены как простые:
</p><pre><code class="python">def is_prime(num, prime_numbers):
    """
    Checks if num is prime number.

    &gt;&gt;&gt; is_prime(2, [])
    True
    &gt;&gt;&gt; is_prime(3, [2])
    True
    &gt;&gt;&gt; is_prime(4, [2, 3])
    False
    &gt;&gt;&gt; is_prime(5, [2, 3])
    True
    &gt;&gt;&gt; is_prime(41, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37])
    True
    &gt;&gt;&gt; is_prime(42, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41])
    False
    &gt;&gt;&gt; is_prime(43, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41])
    True
    """
    limit = int(math.sqrt(num)) + 1
    for i in prime_numbers:
        if i &gt; limit:
            break
        if num % i == 0:
            return False
    return True


def get_prime_numbers(count):
    """
    Get 'count' prime numbers.

    &gt;&gt;&gt; get_prime_numbers(1)
    [2]
    &gt;&gt;&gt; get_prime_numbers(2)
    [2, 3]
    &gt;&gt;&gt; get_prime_numbers(3)
    [2, 3, 5]
    &gt;&gt;&gt; get_prime_numbers(6)
    [2, 3, 5, 7, 11, 13]
    &gt;&gt;&gt; get_prime_numbers(9)
    [2, 3, 5, 7, 11, 13, 17, 19, 23]
    &gt;&gt;&gt; get_prime_numbers(19)
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]
    """
    prime_numbers = [2]
    next_number = 3

    while len(prime_numbers) &lt; count:
        if is_prime(next_number, prime_numbers):
            prime_numbers.append(next_number)
        next_number += 1

    return prime_numbers
</code></pre><p>
Запускаем тесты, убеждаемся, что всё отрабатывает правильно, замерим время выполнения программы:
</p><pre><code>➜ python -m timeit -n 10 -s'import euler_7' 'euler_7.get_prime_numbers(10001)'
10 loops, best of 3: 390 msec per loop
</code></pre><p>
Ускорили работу почти в три раза, неплохо. Запустим ещё разок профилирование:
</p><pre><code>➜ kernprof.py -v -l euler_7.py 10001
Wrote profile results to euler_7.py.lprof
Timer unit: 1e-06 s

File: euler_7.py
Function: is_prime at line 7
Total time: 4.54317 s

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     7                                           @profile
     8                                           def is_prime(num, prime_numbers):
     9    104741       310160      3.0      6.8      limit = int(math.sqrt(num)) + 1
    10    800694      1296045      1.6     28.5      for i in prime_numbers:
    11    800692      1327770      1.7     29.2          if i &gt; limit:
    12      9998        17109      1.7      0.4              break
    13    790694      1409731      1.8     31.0          if num % i == 0:
    14     94741       165761      1.7      3.6              return False
    15     10000        16599      1.7      0.4      return True

File: euler_7.py
Function: get_prime_numbers at line 18
Total time: 10.5464 s

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    18                                           @profile
    19                                           def get_prime_numbers(count):
    20         1            4      4.0      0.0      prime_numbers = [2]
    21         1            2      2.0      0.0      next_number = 3
    22
    23    104742       202443      1.9      1.9      while len(prime_numbers) &lt; count:
    24    104741     10143489     96.8     96.2          if is_prime(next_number, prime_numbers):
    25     10000        22374      2.2      0.2              prime_numbers.append(next_number)
    26    104741       178074      1.7      1.7          next_number += 1
    27
    28         1            1      1.0      0.0      return prime_numbers
</code></pre><p>
Как видим, программа стала выполняться гораздо быстрее.

</p><h2>memory_profiler</h2><p>
Для профилирования памяти можно использовать </p><a href="https://github.com/fabianp/memory_profiler">memory_profiler</a><p>. Использовать его так же просто, как line_profiler. Ставим:
</p><pre><code>➜ pip install psutil memory_profiler
</code></pre><p>
Запускаем:
</p><pre><code>➜ python -m memory_profiler euler_7.py 10001
Filename: euler_7.py

Line #    Mem usage    Increment   Line Contents
================================================
    18    8.441 MiB   -0.531 MiB   @profile
    19                             def get_prime_numbers(count):
    20    8.445 MiB    0.004 MiB       prime_numbers = [2]
    21    8.445 MiB    0.000 MiB       next_number = 3
    22
    23    8.973 MiB    0.527 MiB       while len(prime_numbers) &lt; count:
    24                                     if is_prime(next_number, prime_numbers):
    25    8.973 MiB    0.000 MiB               prime_numbers.append(next_number)
    26    8.973 MiB    0.000 MiB           next_number += 1
    27
    28    8.973 MiB    0.000 MiB       return prime_numbers


Filename: euler_7.py

Line #    Mem usage    Increment   Line Contents
================================================
     7    8.973 MiB    0.000 MiB   @profile
     8                             def is_prime(num, prime_numbers):
     9    8.973 MiB    0.000 MiB       limit = int(math.sqrt(num)) + 1
    10    8.973 MiB    0.000 MiB       for i in prime_numbers:
    11    8.973 MiB    0.000 MiB           if i &gt; limit:
    12    8.973 MiB    0.000 MiB               break
    13    8.973 MiB    0.000 MiB           if num % i == 0:
    14    8.973 MiB    0.000 MiB               return False
    15    8.973 MiB    0.000 MiB       return True
</code></pre><p>
Как видим, никаких особых проблем с памятью у нас нет. Всё в пределах нормы.

</p><h2>Ещё инструменты</h2><p>
Перечислю ещё несколько инструментов для профилирования, к сожалению, статья и так получилась огромной, и разобрать все из них не предоставляется возможным.
</p><ul>
<li><a href="http://www.aminus.net/wiki/Dowser">Dowser</a> — отличнейший инструмент для профилирования памяти</li>
<li><a href="http://guppy-pe.sourceforge.net/">guppy</a> — ещё одна программа для профилирования памяти</li>
<li><a href="https://launchpad.net/meliae">Meliae</a> — уже упоминавшийся ранее инструмент для профилирования памяти, которую можно использовать вместе с RunSnakeRun</li>
<li><a href="http://pythonhosted.org/Pympler/muppy.html">muppy</a> — обнаружение утечек памяти</li>
<li><a href="http://jmdana.github.io/memprof/">memprof</a> — снова профилирование памяти</li>
<li><a href="http://mg.pov.lt/objgraph/">objgraph</a> — интересный инструмент для исследования объектов</li>
</ul>
<p>
Мы познакомились с инструментами для профилирования кода на Python. Множество из них осталось за кадром, надеюсь, мои коллеги дополнят меня в комментариях.
</p><p>
В следующей статье мы познакомимся с методами и инструментами для отладки Python-программ. Оставайтесь на связи!

</p><i>Минутка статистики: в трёх статьях про профилирование питона я использовал слово «профилирование» больше ста раз.</i>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>