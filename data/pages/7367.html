<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/files/97b/a96/d4c/97ba96d4c55d4e73a6205689cfb98604.png" alt="SWAPY" align="left"/><p>SWAPY – графическая утилита для автоматизации UI для pywinauto (Python).
</p><p>
В версии </p><a href="https://github.com/pywinauto/SWAPY/releases">0.4.7</a><p> полностью переработан генератор кода. Основные возможности, а также примеры как быстро и просто создать скрипты автоматического тестирования UI, смотрите под катом.
</p><a name="habracut"/>
<h3>Описание</h3><p>
SWAPY – графическая утилита для просмотра иерархии окон и генерации кода автоматизации UI для библиотеки pywinauto.

</p><img src="https://habrastorage.org/files/002/1c8/f76/0021c8f76d3d45408739bea0c26d1002.png" alt="Interface"/>
<p>
Само название это акроним, отражающий основную идею приложения — Simple Windows Automation on PYthon. Утилита представляет собой полноценный exe файл, собранный с помощью PyInstaller. SWAPY не требует никаких дополнительных установок для автоматизации и генерации кода. Конечно, для дальнейшего использования кода вам понадобится установить как минимум Python и pywinauto. Но для проверки возможностей и, самое главное, подойдет ли такая связка для автоматизации Вашего приложения, SWAPY вполне самодостаточна.
</p><p>
Утилита содержит три основных компонента, это:

</p><ul>
<li>дерево объектов</li>
<li>таблица свойств выбранного объекта</li>
<li>поле с кодом</li>
</ul><p>
Чтобы создать скрипт, необходимо найти элемент в дереве всех контролов и затем вызвать действие, например, Click. При этом выполнится как само действие над объектом, так и обновится поле с кодом.
</p><p>
Раньше генератору кода уделялось мало внимания. Чаще использовались функции поиска элемента и просмотра его параметров. Все фиксы и фичи для генератора кода добавлялись по остаточному принципу. В итоге, чтобы получить рабочий код, нужны были определенные усилия со стороны пользователя — необходимо было последовательно проинициализировать всех предков.
</p><p>
Новый генератор кода, в основном, лишен прежних недостатков.

</p><h3>История развития</h3><p>
В начале 2011 года, будучи на должности «Automation QA Engineer», открыл для себя библиотеку для автоматизации UI – pywinauto. Об истории развития самой библиотеки можно кое-что узнать в статье </p><a href="http://habrahabr.ru/company/intel/blog/266459/">«Старый новый pywinauto»</a><p>. На тот момент она практически не поддерживалась. Тем не менее Pywinauto победила всех своих конкурентов и была выбрана для тестирования ряда продуктов со средней сложностью графического интерфейса.
</p><p>
Отмечу основные преимущества, благодаря которым выбор пал именно на этот вариант:

</p><ol>
<li>Цена инструмента. Pywinauto бесплатна, распространяется под лицензией GNU LGPL v.2.1</li>
<li>Это библиотека Python. Со всеми его возможностями, библиотеками, и т.д.</li>
<li>Простая подготовка окружения. Подготовить виртуальную машину для тестирования установив Python + pywinauto сильно проще установки, например, такого монстра как TestComplete. Это весьма актуально в контексте использования Continuous Integration.</li>
</ol><p>
Вскоре обнаружился один недостаток — тратится много времени на поиск необходимого элемента и анализ его свойств. Очень не хватало графической утилиты для просмотра дерева элементов и их параметров. Библиотеке для автоматизации графических интерфейсов было бы не плохо иметь графический интерфейс.
</p><p>
Было решено исправить эту несправедливость.

</p><img src="https://habrastorage.org/files/679/9d0/d20/6799d0d20afc480494f020705c9f7bde.png" alt="logo-head" align="left"/><p>В апреле 2011 года я начал работу над утилитой, к концу года версия стремительно выросла до 0.3.0, а утилита уже имела все ключевые составляющие и… множество проблем…
</p><p>
В течение следующего года потихоньку исправлялись ошибки и что-то незначительное добавлялось. А потом я сменил работу и интерес поддерживать утилиту, которую сам не использую, да еще и в одиночку, пропал.
</p><p>
Второе дыхание SWAPY получил в сентябре 2015, когда ребята из pywinauto позвали к себе.
</p><p>
С тех пор стал снова активно развивать утилиту. Ключевым улучшением можно назвать новый генератор кода.
</p><p>
Я пересмотрел свое отношение к функции генерации кода как к одной из основных функций. Именно через генератор кода можно познакомить разработчика с дополнительными возможностями библиотеки, а также спасти даже опытного разработчика от рутины.

</p><h3>Новые возможности</h3>
<ul>
<li>Генератор кода теперь работает нормально. Имеется ввиду что не нужно кликать по всем предкам в дереве объекта, чтобы получился рабочий код. Сейчас достаточно отыскать необходимый элемент и выполнить над ним действие, код будет автоматически построен вплоть до импорта. Один клик в новой версии:<br/>
<br/>
<pre><code class="python">from pywinauto.application import Application

app = Application().Start(cmd_line=u'"C:\\Program Files (x86)\\Notepad++\\notepad++.exe" ')
notepad = app[u'Notepad++']
notepad.Wait('ready')
systabcontrol = notepad.Tab
systabcontrol.Select(u'new 1')

app.Kill_()
</code></pre><br/>
В старой версии аналогичное действие приводит к такому результату:<br/>
<br/>
<pre><code class="python">import pywinauto

pwa_app = pywinauto.application.Application()
ctrl.Select(0)
</code></pre><br/>
Очевидно что такой код работать не будет.</li>
<li>Понятные имена переменных. Согласитесь, <code>systabcontrol</code> намного понятнее какого то <code>ctrl</code>. Имена формируются на базе имени класса контрола, либо из самого короткого имени для доступа (из pywinauto). Только если оба эти случая были безуспешными, то будет использовано безликое — <code>control</code>.</li>
<li>Контроль над одинаковыми именами переменных. Если необходимо работать с разными контролами, имеющими одинаковые имена, SWAPY следит что бы они оставались уникальными.<br/>
<br/>
<pre><code class="python">button = calcframe.Button19
button.Click()
button2 = calcframe.Button20
button2.Click()
</code></pre><br/>
Это актуально для следующего пункта.</li>
<li>Повторное использование. Как правило, действие состоит из двух строк. В первой происходит инициализация доступа к контролу, во второй — непосредственно действие. Так вот, если понадобилось в какой то момент повторить действие над контролом, который уже был инициализирован, то добавляется просто код действия.<br/>
<br/>
<pre><code class="python">button = calcframe.Button19
button.Click()
button2 = calcframe.Button20
button2.Click()
button.Click()  # Повторный Click по Button19
</code></pre></li>
<li><img src="https://habrastorage.org/files/c43/462/0b1/c434620b114b4674a87fa35f1db4cae6.png" alt="clear_last_command" align="right"/>Отмена последней команды. Частенько возникает необходимость удалить последнюю команду, например после неудачных экспериментов. Теперь есть возможность сделать это через контекстное меню редактора. При этом имя исчезнувшей переменной освободится и будет использовано в следующий раз. Отменять можно любое количество шагов. Нужно понимать, что отмена последней команды лишь очистит код, действие в приложении не будет отменено.<br/>
<br/>
Также есть возможность очистить сразу весь код, а еще можно сохранить весь код в файл.<br/>
</li>
<li><img src="https://habrastorage.org/files/fa1/5f5/e12/fa15f5e1252e40b2b2a606b2423607b8.png" alt="image" align="left"/>Изменение кода «на лету». Пока эта функциональность используется в окнах верхнего уровня для переключения между <code>app = Application().Start(cmd_line=...</code> и <code>app = Application().Connect(title=...</code>. В большинстве случаев будет достаточно <code>Start</code>, но если не нужно запускать приложение, то следует выбрать <code>Application.Connect</code> в контекстном меню дерева объектов, кликнув на имени окна. Код в редакторе обновится, исчезнут привязанные к методу <code>Application().Start</code> команды — <code>calcframe.Wait('ready')</code> в начале и <code>app.Kill_()</code> в конце.<br/>
<br/>
Пример кода со стартом приложения.<br/>
<br/>
<pre><code class="python">from pywinauto.application import Application

app = Application().Start(cmd_line=u'"C:\\Program Files (x86)\\Notepad++\\notepad++.exe" ')
notepad = app[u'Notepad++']
notepad.Wait('ready')

app.Kill_()
</code></pre><br/>
Подключается к уже запущенному приложению.<br/>
<br/>
<pre><code class="python">from pywinauto.application import Application

app = Application().Connect(title=u'new 1 - Notepad++', class_name='Notepad++')
notepad = app[u'Notepad++']
</code></pre><br/>
</li>
</ul>
<h3>Пример использования</h3><p>
Теперь давайте создадим несколько скриптов для автоматизации тестирования. Я постарался выбрать достаточно жизненные примеры и одновременно продемонстрировать новые фичи кодогенератора.

</p><h4>Текст лицензии</h4><p>
В этом тесте мы проверим что текст лицензии отображается на диалоге About. Одновременно убедимся что SWAPY понимает, что новое окно принадлежит старому приложению и не будет создавать лишних вызовов </p><code>app = Application().Start(...)</code><p>.

</p><div class="spoiler"><b class="spoiler_title">Проверка текста лицензии</b><div class="spoiler_text"><ol>
<li>Запускаем вручную Notepad++.</li>
<li>Находим в дереве элементов SWAPY нужный элемент меню и кликаем на него.<br/>
<img src="https://habrastorage.org/files/7df/ce7/315/7dfce73159db4151867d00a73ece02e1.png" alt="click_menu"/></li>
<li>Чтобы обновить дерево элементов для отображения вновь открытого окна, нужно поставить выделение на <code>root</code> элемент в дереве. При этом все дочерние элементы обновятся.</li>
<li>Находим About диалог, он у меня называется <code>Window#657198</code>, это SWAPY сама сформировала название из handle окна, так как обычным способом(<code>window.Texts()</code>) имя не определилось.</li>
<li>В иерархии About диалога находим текст лицензии и кликаем на него.<br/>
<br/>
<img src="https://habrastorage.org/files/d87/447/ac0/d87447ac094945aa8aea7a3aa2648457.png" alt="About"/><br/>
<br/>
Добавились только следующие строчки:<br/>
<br/>
<pre><code class="python">window = app.Dialog
edit = window.Edit2
edit.Click()  # Изменим на получение текста
</code></pre><br/>
Т.е. SWAPY использовала существующую переменную <code>app</code>. С автогенерацией кода для этого теста мы закончили. Обратите внимание что Notepad++ будет запущен и закрыт после теста, за это отвечает последняя строка <code>app.Kill_()</code>.</li>
</ol><p>
Финальный код теста может выглядеть следующим образом:

</p><pre><code class="python">from pywinauto.application import Application
expected_text = “...”

app = Application().Start(cmd_line=u'"C:\\Program Files (x86)\\Notepad++\\notepad++.exe" ')
notepad = app[u'Notepad++']
notepad.Wait('ready')
menu_item = notepad.MenuItem(u'&amp;?-&gt;\u041e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0435...\tF1')
menu_item.Click()
window = app.Dialog
edit = window.Edit2
actual_text = edit.Texts()

app.Kill_()

assertEqual(expected_text, actual_text)
</code></pre><p>
Как видите, минимум собственного кода.
</p></div></div>
<h4>Порядок вкладок</h4><p>
Давайте проверим перемещение вкладок. Нарочно допустим ошибку при генерации кода и посмотрим как SWAPY позволит её убрать.

</p><div class="spoiler"><b class="spoiler_title">Проверка изменения порядка вкладок</b><div class="spoiler_text"><ol>
<li>Запускаем вручную Notepad++.</li>
<li>Откроем две дополнительные вкладки. Находим в дереве элементов необходимый <code>ToolBar</code> и выполняем действие <code>Click</code> на кнопке с индексом 0. Вследствие чего появится код и откроется одна новая вкладка.<br/>
<br/>
<img src="https://habrastorage.org/files/0ce/b0b/8de/0ceb0b8ded80448ab864def21c626698.png" alt="add_tab"/><br/>
<br/>
Нам нужна еще одна вкладка, повторим действие еще раз. Поскольку текст кнопок недоступен, используется адресация по индексу. Мы не заметили и нечаянно кликнули на кнопку с индексом 1.<br/>
<br/>
Добавился код:<br/>
<br/>
<img src="https://habrastorage.org/files/b72/82b/87a/b7282b87a36f44b198fb46c32a2c0476.png" alt="fix_code" align="right"/><pre><code class="python">toolbar_button2 = toolbarwindow.Button(1)
toolbar_button2.Click()
</code></pre><br/>
Нужно исправляться. Чтобы не повторять все сначала, SWAPY позволяет отменить последнюю команду (можно последовательно отменить хоть весь код).<br/>
<br/>
<code>Clear last command</code> отменит последнюю команду (выделенный фрагмент) — как раз то, что нам и нужно. Чтобы полностью очистить код, есть команда <code>Clear the code</code>. Полная очистка спрятана за диалогом с подтверждением, во избежание несчастных случаев на производстве.<br/>
<br/>
Теперь мы сделаем все правильно и кликнем по кнопке с индексом 0.<br/>
<br/>
Добавится код:<br/>
<br/>
<pre><code class="python">toolbar_button.Click()
</code></pre><br/>
SWAPY помнит что уже есть <code>toolbar_button = toolbarwindow.Button(0)</code> и для повторного клика инициализировать его уже не нужно.<br/>
</li>
<li>Для drug-n-drop воспользуемся методом <code>toolbarwindow.DragMouseInput</code>. Детали использования можно подсмотреть в <a href="http://pywinauto.github.io/docs/code/pywinauto.controls.HwndWrapper.html?highlight=dragmouseinput#pywinauto.controls.HwndWrapper.HwndWrapper.DragMouseInput">документации</a>.<br/>
<br/>
Координаты вкладок можно определить с помощью <code>systabcontrol.GetTabRect(0).mid_point()</code></li>
</ol><p>
Тест может выглядеть так:

</p><pre><code class="python"># automatically generated by SWAPY
from pywinauto.application import Application

app = Application().Start(cmd_line=u'"C:\\Program Files (x86)\\'
                                   u'Notepad++\\notepad++.exe" ')
notepad = app[u'Notepad++']
notepad.Wait('ready')
systabcontrol = notepad.Tab
assertEqual([u'Tab', u'new 1'], systabcontrol.Texts())

toolbarwindow = notepad[u'3']
toolbar_button = toolbarwindow.Button(0)
toolbar_button.Click()
toolbar_button.Click()

assertEqual([u'Tab', u'new 1', u'new 2', u'new 3'], systabcontrol.Texts())

systabcontrol.DragMouseInput(
    press_coords=systabcontrol.GetTabRect(0).mid_point(),
    release_coords=systabcontrol.GetTabRect(2).mid_point())

assertEqual([u'Tab', u'new 2', u'new 3', u'new 1'], systabcontrol.Texts())

app.Kill_()
</code></pre><p>
Тут пришлось немного почитать документацию и немного поработать с генерированным кодом.
</p></div></div>
<h4>Вставка и сохранение текста</h4><p>
Тест требует проверить копирование и вставку текста с последующим сохранением. Усложним задачу — Notepad++ уже запущен и свернут (Minimize), а стандартный notepad (из которого будет производится копирование) только предстоит запустить.

</p><div class="spoiler"><b class="spoiler_title">Работа с несколькими окнами</b><div class="spoiler_text"><ol>
<li>Подготовим тестовые приложения. Запустим и свернем Notepad++, запустим обычный notepad с тестовым файлом = «notepad check.txt».</li>
<li>В дереве объектов найдем блокнот и кликнем по содержимому редактора.<br/>
<br/>
<img src="https://habrastorage.org/files/a84/965/d16/a84965d16a2d4cd99fb8201efc40d51a.png" alt="notepad"/><br/>
<br/>
Обратите внимание, что notepad будет запущен с оригинальными аргументами.</li>
<li>Теперь отыщем Notepad++ и его текстовое поле. Нужно не забыть его сначала развернуть (Restore).<br/>
<br/>
<img src="https://habrastorage.org/files/987/82d/a5c/98782da5c5884168bf636da9d47ce704.png" alt="restore"/><br/>
<br/>
<img src="https://habrastorage.org/files/1cd/654/b50/1cd654b5058c4ccd9fc2ae7cf2b48ad8.png" alt="editor"/><br/>
<br/>
Все идет по плану, но тут внезапно мы вспомнили, что по условию задачи Notepad++ уже запущен, а наш код попытается его запустить. <br/>
SWAPY по умолчанию генерирует связку <code>app = Application().Start ... app.Kill_()</code>. Но в нашем случае нам не нужно еще раз запускать Notepad++.<br/>
<br/>
Новый генератор кода позволяет изменять «подход» для генерации кода, причем это можно делать даже постфактум.</li>
<li>Для изменения <code>Application().Start</code> на <code>Application().Connect</code> нужно вызвать контекстное меню для окна приложения Notepad++ и выбрать <code>Application().Connect</code>.<br/>
<br/>
<img src="https://habrastorage.org/files/6e9/672/6a5/6e96726a5dc4479480d1f9343bc940f0.png" alt="Connect"/></li>
<li>Копирование и вставку текста мы оформим позже, а сейчас предположим что текст есть и его нужно сохранить.<br/>
<br/>
<img src="https://habrastorage.org/files/f61/c70/2ef/f61c702effff42bbb714c477d87c2726.png" alt="save_as"/></li>
<li>Открылось окно «Save as», необходимо обновить дерево элементов что бы его увидеть. Для этого нужно выделить root элемент дерева. После обновления дерева, кликнем на поле с именем сохраняемого файла (чтобы потом поменять) и на кнопку для сохранения.<br/>
<br/>
<img src="https://habrastorage.org/files/7c8/2ae/50c/7c82ae50ce494bb6a8637d94f3d5ffaa.png" alt="accept"/></li>
</ol><p>
Все основные действия есть, теперь осталось добавить отправку команд CTRL+C, CTRL+V и проверки чтобы получился настоящий тест.</p><p>
Для отправки команд, воспользуемся встроенным методом </p><a href="http://pywinauto.github.io/docs/code/pywinauto.controls.HwndWrapper.html?highlight=type#pywinauto.controls.HwndWrapper.HwndWrapper.TypeKeys">TypeKeys</a><p>.
</p><p>
Полный текст приведен ниже:

</p><pre><code class="python"># automatically generated by SWAPY
from pywinauto.application import Application
import time
import os

SAVE_PATH = r"Notepad_default_path"

app = Application().Start(cmd_line=u'"C:\\Windows\\system32\\notepad.exe" check.txt')
notepad = app.Notepad
notepad.Wait('ready')
edit = notepad.Edit
edit.TypeKeys("^a^c")  # Copy all the text

app2 = Application().Connect(title=u'new 1 - Notepad++', class_name='Notepad++')
notepad2 = app2[u'Notepad++']
notepad2.Restore()
scintilla = notepad2[u'1']
scintilla.TypeKeys("^a^v")  # Paste the text

#Save a file
menu_item = notepad2.MenuItem(u'&amp;\u0424\u0430\u0439\u043b-&gt;\u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u043a\u0430\u043a...\tCtrl+Alt+S')
menu_item.Click()
window = app2.Dialog
edit2 = window.Edit
filename = "checked_at_%s" % time.time()  # Compose a filename
edit2.TypeKeys(filename)
button = window.Button
button.Click()

with open(os.path.join(SAVE_PATH, filename)) as f:
    assertEqual(“expected_text”, f.read())

app.Kill_()
</code></pre>
</div></div>
<h3>А можно еще лучше?</h3><p>
Безусловно — Да!
</p><p>
Даже в описанных примерах мы вынуждены были делать </p><code>Click()</code><p> а потом уже вручную менять на получение текста — </p><code>Texts()</code><p>. Или же вручную добавляли </p><code>TypeKeys</code><p>. В будущих релизах еще предстоит упростить такие популярные действия, добавив дополнительные пункты в контекстное меню.
</p><p>
Пока нельзя управлять форматом доступа к элементам. Pywinauto позволяет получить доступ к элементам через атрибуты — </p><code>window.Edit</code><p>, а если это невозможно (недопустимое имя для переменной Python), то через </p><code>__getitem__</code><p> — </p><code>window[u'0']</code><p>.
</p><p>
SWAPY находит самое короткое имя для доступа и пробует его применить в качестве атрибута. Если не получается, то через </p><code>__getitem__</code><p>. Идея пока самая простая — получить короткий код.
</p><p>
Но, например, в тесте «Порядок вкладок» есть такая строчка </p><code>toolbarwindow = notepad[u'3']</code><p>. Все работает, все ОК. Но, представьте, вы открыли этот тест через некоторое время, а там такой magic number. Вместо тройки могло бы быть </p><code>Toolbar</code><p> — самое понятное, а не самое короткое имя. В планах — дать юзеру возможность выбирать имя (“Имя! Имя, сестра!”).
</p><p>
Также пока нужно обновлять дерево объектов вручную. Автоматический refresh явно добавит удобства.

</p><h3>Полезные ссылки</h3>

<h3>P.S.</h3><p>
Хотел бы поблагодарить камрадов </p><a href="http://habrahabr.ru/users/vasily-v-ryabov/">vasily-v-ryabov</a><p> и </p><a href="https://github.com/airelil">airelil</a><p> за активное участие в обсуждении фич для нового генератора кода.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>