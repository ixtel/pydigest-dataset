<html><body><div><div class="seven units entry-content">	
			
			 <span class="date-container minor-meta meta-color">January 7, 2014</span>	
				<p>When I set out to integrate <a href="http://bower.io/">Bower</a> and <a href="http://gruntjs.com/">Grunt</a> into our current Python projects I wasn’t looking to upset the balance, but instead improve the process for front-end development. Integrating these tools allows us to lighten our repository by moving third party dependencies to Bower, along with giving us easier access to build tools like <a href="http://www.requirejs.org/">Require.js</a> and <a href="http://sass-lang.com/">Sass</a>. Ultimately these tools give us the ability to deploy optimized assets without the need to check them into git and manage changes to built files across branches.<span id="more-1435"/></p>
<h2>File Structure and setup</h2>
<p>With our current python file structure, we have a nice setup for integrating the new tools. There are a number of files that need to be added to utilize the new tools.</p>

<h3>Bower</h3>
<p>Setting up Bower is simple.</p>
<p><code>$ bower init</code></p>
<p>Answer the prompts to generate your bower.json.</p>
<p>After you have a bower.json you will need to create a .bowerrc to tell Bower where to install components.</p>
<p>In your favorite editor open .bowerrc and add the following.<br/>
</p><p>
This tells Bower to install its components into a bower_components folder under the subdirectory AppName. If you didn’t do this, your site would not have access to the installed components because they are outside the web server root.
</p><p>Now you are free to install components.</p>
<p><code>$ bower install --save jquery</code></p>
<h3>Grunt</h3>
<p>Once you have bower you can start installing components, but you need to be able to build them. Enter Grunt.</p>
<p>Grunt is a task runner written in Javascript for <a href="http://nodejs.org/">Node.js</a>. Grunt will allow us to write some tasks to do things like compile javascript with r.js, compile Sass with node-sass, start the development server, and actively watch files for changes.</p>
<p>We first need to create a package.json to outline what node packages we need.</p>
<p>We will be using a few grunt plugins to handle creating tasks for us.</p>
<ul>
<li>node-sass – Implements Node bindings for libsass.</li>
<li>grunt-contrib-watch – tasks for watching files and executing tasks when changes occur.</li>
<li>grunt-sass – tasks for building Sass with node-sass.</li>
<li>grunt-contrib-requirejs – tasks for compiling javascript with requirejs and r.js.</li>
<li>load-grunt-tasks – automatically load grunt tasks from installed plugins.</li>
<li>time-grunt – display execution summary on end.</li>
</ul>

<p>Once we have our package.json created and dependencies declared we can install those dependancies with one command.</p>
<p><code>$ npm install<br/>
</code></p>
<p>After our dependancies are installed we can write our Gruntfile.</p>

<p>While there is a lot going on in this Gruntfile.js, there are a few key items to explain.</p>
<h4>Running the server and building sass</h4>
<p>We have a custom Grunt task called ‘runApp’ that will kick off our python server using the ‘run_appname.sh’ bash script.</p>

<p>The task starts by spawning a child process using Node’s built in child process tasks, and runs the ‘run_appname.sh’ script. We don’t need to pass any arguments to the script, but we do set the cwd (current working directory) with the options argument. Additionally we log out all events from the child process, stdout, stderr, data, and close.</p>
<p>To run the server in tandem with the watch task we have a combined task called ‘server’ that will first start the python server and second start the watch to rebuild JS and CSS files when they change.</p>
<h4>Building and deploying</h4>
<p>Since we are using javascript and Sass compilers there will inevitably come a time when we need to build those for deployment. With Grunt we have a task to do just that.</p>
<p><code>$ grunt build</code></p>
<p>This task is almost never necessary for development – ‘watch’ and ‘server’ should be used then. The ‘build’ task is mostly intended to be used on deployment. After the latest has been pulled from git ‘$ grunt build’ should be run to compile the latest css and javascript from source. This allows us to not only deliver small/optimized files, but now there is no need to commit compiled files to source control.</p>
<p>While this simplifies things a little it also adds some overhead to our server stack. In addition to needing Python we also need Node and NPM.</p>
<p>The typical deployment workflow would be as follows.</p>

<ol>
<li>fetch the latest from origin</li>
<li>pull the latest code from the master branch</li>
<li>activate the virtualenv and update/install any python packages</li>
<li>install or update node packages</li>
<li>install or update bower components</li>
<li>build the latest css and js using grunt</li>
<li>restart the service/application using supervisord</li>
</ol>
<p>This is a simple deploy workflow, there could be more complex steps involved like tagging new and old releases, etc…</p>
<h3>Python Configuration</h3>
<p>Using Require.js and r.js to build our javascript for production means we will have two different files for development and production. On build r.js creates ‘main-built.js’ for production, we need a way to tell our views what environment version to use.</p>
<p>To configure the views to use either development or production versions of our files we use a ‘Config’ python class. Imported from ‘/AppName/common/config.py’ as ‘CONFIG’.</p>
<p>This sets up our configuration variables, of which we have a ‘js’ object.</p>
<p>The ‘CONFIG.js’ object contains two properties.</p>
<ul>
<li>‘main’ – this is the name of the main javascript file (main for un-built, and main-built for built)</li>
<li>‘loader’ – the loader script to use (require.js, almond.js, etc AMD loader…)</li>
</ul>

<p>The config.py values can be overridden for local development via ‘/AppName/common/local_config.py’.</p>

<p>The local config is never checked into version control, allowing everyone to configure the app for their environment without conflict.</p>
<h3>View setup</h3>
<p>In our route callback we return the ‘CONFIG.js’ data to the views as the ‘js’ property, along with any other view data.</p>

<p>In our view we output the correct loader and main file using the ‘js.loader’ and ‘js.main’ properties respectively.</p>

<h2>Final thoughts</h2>
<p>As we begin to use these tools on more projects I suspect more changes/improvements will happen. This first attempt was to simply integrate tools we are accustomed to using on other simpler projects into more advanced projects that utilize server languages. As we improve this integration I would like to see us attempt to follow this process with other languages like PHP, and frameworks like Magento.</p>
<span class="blog-tags minor-meta"><strong>Tags: </strong><span><a href="http://reverb.findawayworld.com/tag/bower/" rel="tag">bower</a>, <a href="http://reverb.findawayworld.com/tag/grunt/" rel="tag">grunt</a>, <a href="http://reverb.findawayworld.com/tag/node/" rel="tag">node</a>, <a href="http://reverb.findawayworld.com/tag/npm/" rel="tag">npm</a>, <a href="http://reverb.findawayworld.com/tag/python/" rel="tag">python</a>, <a href="http://reverb.findawayworld.com/tag/r-js/" rel="tag">r.js</a>, <a href="http://reverb.findawayworld.com/tag/require/" rel="tag">require</a>, <a href="http://reverb.findawayworld.com/tag/sass/" rel="tag">sass</a></span></span>				
				
				
				

								
			</div>	
			

		</div></body></html>