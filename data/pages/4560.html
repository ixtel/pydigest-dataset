<html><body><div><div class="ui text container">
    


    
  
  

<p>It's the old problem of "Do I seek permission or ask for forgiveness?". It's rarely easy to know which one to use in Python because working with exceptions in Python is so damn easy.  </p>
<p>Generally I prefer neither. I.e. just do. Don't write defensive code if you don't have to. Only seek permission <em>or</em> ask for forgiveness if you expect it to happen and that that's normal.  </p>
<p>Consider the following three functions:  </p>
<div class="highlight">

<pre><span class="k">def</span> <span class="nf">f0</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">PI</span> <span class="o">/</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">PI</span> <span class="o">/</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>


<span class="k">def</span> <span class="nf">f2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">PI</span> <span class="o">/</span> <span class="n">x</span>
    <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>

<p>Which one do you think is the fastest? If I run this 1,000,000 times and never pass in a value for <code>x=0</code> will it make any difference?  </p>
<p>Before you look at it, what do you think the result will be?  </p>
<p><br/>  </p>
<p>The answer is below.  </p>
<p><br/>  </p>
<p>Read on.  </p>
<p><br/>  </p>
<p>Scroll down for the results.  </p>
<p><br/>  </p>
<p>Have you made a guess yet?  </p>
<p><br/>  </p>
<p>What do you think it's going to be?  </p>
<p><br/>  </p>
<p>Scroll some more.  </p>
<p><br/>  </p>
<p>Almost there!  </p>
<p><br/>  </p>
<p>Ok, the results are as follows when running each of the above mentioned functions ~33,000,000 times on my MacBook:  </p>
<pre>
f0 4.16087803245
f1 4.84187698364
f2 4.73760977387
(smaller is better)
</pre>

<p>Conclusion, the <strong>difference is miniscule</strong>. The fastest is to not do any exception handling or condition checking but it's generally no big difference.  </p>
<p>This test was done with Python 2.7.9. You can <a href="https://gist.github.com/peterbe/50311faa4fa3341982f3">try the code for yourself</a>.  </p>
<p><strong>Just one more thought</strong></p>
<p>As I wrote this post I started thinking more and more about the "code style aspect" rather than the performance.  </p>
<p>Basically, I think it boils down to the following rules:  </p>
<ol>
<li>
<p>If you're working with external I/O (e.g. network or a database) use the "ask for forgiveness" approach (aka. exception wrapping). I.e. don't do <code>if requests.head(url).status_code == 200: stuff = requests.get(url)</code>  </p>
</li>
<li>
<p>If you want to make a really user-friendly Python API, use the "seek permission" approach (aka. if-statement first). E.g. <code>def calculate(guests): if isinstance(guests, basestring): guests = [guests]</code>  </p>
</li>
<li>
<p>All else just do. That makes the code more Pythonic. If you have a sub-routine that sends in variable of the totally crazy-wrong type to your function, don't change the function, change the sub-routine.  </p>
</li>
</ol>
<p><strong>UPDATE</strong></p>
<p>Here are the numbers for <a href="http://pypy.org/">PyPy</a>:  </p>
<pre>
f0 0.369750552707
f1 0.321069081624
f2 0.411438703537
(smaller is better)
</pre>

<p>That's after averaging 15 runs of the script.  </p>
<p>Note that the function with the extra if statement is faster.  </p>
<p>And here are the numbers of Python 3.4.2:  </p>
<pre>
f0 4.99579153742
f1 5.77459328515
f2 5.38382162367
(smaller is better)
</pre>

<p>That's averaging 10 rounds.  </p>
<p>One almost interesting thing about these numbers is that the <strong>sum of them</strong> are different and tells us a tiny story about performance for the language:  </p>
<pre>
Python 2.7.9   13.74036478996
PyPy 2.4.0     1.102258337868
Python 3.4.2   16.15420644624
(smaller is better)
</pre>

<p><strong>UPDATE 2</strong></p>
<p>Here's the <a href="https://gist.github.com/peterbe/d42cdb884f8707c84906">node equivalent version</a> and its times:  </p>
<pre>
f0 0.215509441
f1 0.228280196357
f2 0.316222934714
(smaller is better)
</pre>

<p>That means that my Node v0.10.35 is 45% faster than PyPy. But please, don't take that seriously. </p>

  <section id="buttons">
    <a href="https://twitter.com/peterbe" class="twitter-follow-button" data-show-count="false">Follow @peterbe</a>
  </section>

  <h2 class="ui dividing header">Comments</h2>

      <p id="comments-outer" class="ui comments">
          </p>
    
  
      <p id="preview-comment-outer" class="ui comments preview"/>

    
  

<h2 class="ui dividing header">Related posts</h2>

<dl>
    <dt>Previous:</dt>
  <dd><a href="/plog/premailer-2.9.0">premailer 2.9.0 and new rules for `base_url`</a>
  <small>11 May 2015</small>
  </dd>
  
    <dt>Next:</dt>
  <dd><a href="/plog/G">How I git</a>
  <small>18 June 2015</small>
  </dd>
  </dl>

<dl>
  <dt>Related by keywords:</dt>
    <dd><a href="/plog/uniqifiers-benchmark" data-plogrank="21600.0">Fastest way to uniqify a list in Python</a>
  <small>14 August 2006</small>
  </dd>
    <dd><a href="/plog/mincss" data-plogrank="4025.0">mincss "Clears the junk out of your CSS"</a>
  <small>21 January 2013</small>
  </dd>
    <dd><a href="/plog/gzip-rules-the-world-of-optimization" data-plogrank="1679.0">Gzip rules the world of optimization, often</a>
  <small>09 August 2014</small>
  </dd>
    <dd><a href="/plog/worrying-about-io-blocking" data-plogrank="1668.0">How I stopped worrying about IO blocking Tornado</a>
  <small>18 September 2012</small>
  </dd>
    <dd><a href="/plog/getting-random-rows-postgresql-django" data-plogrank="1439.0">Optimization of getting random rows out of a PostgreSQL in Django</a>
  <small>23 February 2011</small>
  </dd>
    <dd><a href="/plog/requirejs-vs-headjs" data-plogrank="1160.0">RequireJS versus HeadJS</a>
  <small>09 January 2011</small>
  </dd>
    <dd><a href="/plog/thousands-commafy-large-numbers" data-plogrank="957.0">Fastest way to thousands-commafy large numbers in Python/PyPy</a>
  <small>13 October 2012</small>
  </dd>
    <dd><a href="/plog/calculator-in-python-for-dummies" data-plogrank="701.0">Calculator in Python for dummies</a>
  <small>17 December 2007</small>
  </dd>
    <dd><a href="/plog/mincss-in-action" data-plogrank="540.0">mincss in action - sample report from the wild</a>
  <small>22 January 2013</small>
  </dd>
    <dd><a href="/plog/optimizing-moztrap" data-plogrank="509.0">Optimizing MozTrap</a>
  <small>04 June 2014</small>
  </dd>
    <dd><a href="/plog/mincss-0.8" data-plogrank="362.0">mincss version 0.8 is much much faster</a>
  <small>27 February 2013</small>
  </dd>
    <dd><a href="/plog/EditDistanceMatcher" data-plogrank="249.0">EditDistanceMatcher - NodeJS script for doing edit distance 1 matching</a>
  <small>05 February 2011</small>
  </dd>
  </dl>

  </div>

  </div></body></html>