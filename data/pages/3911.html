<html><body><div><div class="content html_format"><p>
      Захотелось мне сделать шаблонизатор, чтобы как slim, теги чтобы автоматом закрывались и прочее. Красиво же так:</p>
<pre><code>html
  head
    title
        - yield "Плюшка!" + " Чашка чаю!"
</code></pre>
<p>
Но и этого мне мало, хочу чтобы не было своего недоязыка, хочу чтобы просто питоновские конструкции. А кто захочет себе в ногу стрельнуть и бизнес логики в шаблоны навалить, то это проблема начинашек, мне зачем мучаться размазывая код вьюх в папки типа utils, template_tags и прочее?
</p><p>
А и еще можно кстати угореть так уж угореть — а пусть шаблоны через новый механизм импорта в python 3 тянутся. И если надо что-то от другого шаблона себе вставить, то тоже пусть также работает.
</p><p>
А еще, еще пусть каждый шаблон это генератор!

</p><a name="habracut"/>
<p>
Ну сказано сделано, встречайте </p><a href="https://github.com/Deepwalker/backslant">github.com/Deepwalker/backslant</a><p>. Он еще конечно не до конца допилен, но надо получить фидбек.
</p><p>
Итак, попробуем на пять, base.bs:

</p><pre><code>!doctype/ html
html
head
    title
        | Page Title
body
    h1 {'class': ' '.join(['main', 'content'], 'ng-app': 'Application'} "Page Header"
    div.content
        - yield from options['content_block']()
    div.footer "Backslant © 2015"
</code></pre>
<p>
Что тут у нас — </p><code>doctype</code><p> заканчивается на </p><code>/</code><p>, значит тег закрывать через </p><code>&lt;/doctype&gt;</code><p> не надо.
</p><p>
Строки пока начинаются с </p><code>"</code><p>, надо допилить грамматику чтобы можно было сразу после тела тега, попозже.
</p><p>
У </p><code>h1</code><p> аргументы передаются обычным python </p><code>dict</code><p>, в рамках которого любой код, который можно в объявлении словаря.
</p><p>
Дальше интересное — </p><code>yield from</code><p> из вызова некоего </p><code>content_block</code><p>, который лежит в каком-то </p><code>options</code><p>. Ну что сказать — </p><code>options</code><p> это </p><code>kwargs</code><p>, так как объявления параметров шаблона у нас тут нет. Может и зря кстати что нет.
</p><p>
Так вот, про </p><code>content_block</code><p> — тут мы ожидаем что нам передадут в параметре некий колбек, и считаем что там будет генератор — у нас же все шаблоны генераторы. Вот значит какой-то шаблон захочет использовать наш base.bs, и вызовет его render, и передаст туда колбек.
</p><p>
И это будет index.bs:

</p><pre><code>- from . import base
:call base.render(*options)
    :content_block
        - for i in range(10):
            p
                - yield 'Paragraph {}'.format(i)
    :footer_block
        p "Index page"
</code></pre>
<p>
Тут мы используем немножко сахара вместо того чтобы честно объявить просто функцию и передать её. </p><code>:call</code><p> переберет свои дочерние ноды, проверит что все они объявления функций, и засунет их в параметры. А </p><code>:content_block</code><p> как раз и объявляет функцию без аргументов с именем </p><code>content_block</code><p>, и с этим же именем </p><code>:call</code><p> отправит ее в аргументы.</p><p>
А потом в питоно коде можем использовать:

</p><pre><code class="python">import backslant
sys.meta_path.insert(0, backslant.PymlFinder('./templates', hook='backslant_import'))
from backslant_import.home import index
for chunk in index.render(title='The Real Thing'):
    print(chunk)
</code></pre>
<p>
Безумненько. Что добавить по синтаксису — функцию объявить можно, прям </p><code>- def func(a=True)</code><p> и прочее. </p><code>for</code><p>, </p><code>if</code><p>, </p><code>elif</code><p>, </p><code>else</code><p> — просто чистый питон. Конечно же можно и нужно использовать </p><code>yield</code><p> и </p><code>yield from</code><p>. Можно импортировать всё что угодно и как угодно использовать.</p><p>
Из неподдержанного — </p><code>try: except: ...</code><p>. Текущая версия парсера не очень дружит, надо переделать парсинг.
</p><p>
Что дальше — генератор же. А генератор как известно еще и </p><code>send</code><p> умеет, не только </p><code>next</code><p>. Правда что из этого можно получить, ну не знаю, можно пофантазировать. Может как-то докармливать данными и отдавать порции на выход.
</p><p>
Скорость — такая же как у jinja2. Можно наверное попробовать как-то разогнать еще, но в основном код состоит из </p><code>yield</code><p> и </p><code>yield from</code><p>, компилируется через </p><code>ast</code><p>, нечего особо оптимизировать.
</p><p>
Так вот. Синтаксис можно еще допилить, внедрить какие-то идеи.
</p><p>
Есть кстати идеи? Давайте обсудим. А пока можно посмотреть на проект, потыркать примеры </p><a href="https://github.com/Deepwalker/backslant/tree/master/example">github.com/Deepwalker/backslant/tree/master/example</a>

      
      <p class="clear"/>
    </div>

    
  </div></body></html>