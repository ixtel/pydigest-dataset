<html><body><div><div id="content">

            

            
        


            <div class="section">
              <h1>Corrfunc 0.2.2</h1>

              


<p>Blazing fast correlation functions on the CPU</p>








<p><a href="https://github.com/manodeep/Corrfunc/releases/latest" rel="nofollow"><img src="https://img.shields.io/github/release/manodeep/Corrfunc.svg"/>
</a> <a href="https://raw.githubusercontent.com/manodeep/Corrfunc/master/LICENSE" rel="nofollow"><img src="https://img.shields.io/badge/license-MIT-blue.svg"/>
</a> <a href="https://zenodo.org/badge/latestdoi/19184/manodeep/Corrfunc" rel="nofollow"><img src="https://zenodo.org/badge/19184/manodeep/Corrfunc.svg"/>
</a> <a href="https://travis-ci.org/manodeep/Corrfunc" rel="nofollow"><img src="https://travis-ci.org/manodeep/Corrfunc.svg?branch=master"/></a> <a href="https://github.com/manodeep/Corrfunc/issues" rel="nofollow"><img src="https://img.shields.io/github/issues/manodeep/Corrfunc.svg"/>
</a> <a href="https://scan.coverity.com/projects/manodeep-corrfunc" rel="nofollow"><img src="https://img.shields.io/coverity/scan/6982.svg"/>
</a></p>
<div id="description">
<h2>Description</h2>
<p>This repo contains a set of codes to measure the following OpenMP
parallelized clustering measures in a cosmological box (co-moving XYZ)
or on a mock (RA, DEC, CZ). Also, contains the associated paper to be
published in Astronomy &amp; Computing Journal (at some point).</p>
</div>
<div id="installation">
<h2>Installation</h2>
<div id="pre-requisites">
<h3>Pre-requisites</h3>
<ol>
<li>OpenMP capable compiler like <tt>icc</tt>, <tt>gcc</tt> or <tt>clang &gt;= 3.7</tt>. If
not available, please disable <tt>USE_OMP</tt> option option in
<tt>theory.options</tt> and <tt>mocks.options</tt>. You might need to ask your
sys-admin for system-wide installs of the compiler; if you prefer to
install your own then <tt>conda install gcc</tt> (MAC/linux) or
<tt>(sudo) port install gcc5</tt> (on MAC) should work. <em>Note “gcc“ on
macports defaults to “gcc48“ and the portfile is currently broken
on “El Capitan“</em>.</li>
<li><tt>gsl</tt>. Use either
<tt>conda install <span class="pre">-c</span> <span class="pre">https://conda.anaconda.org/asmeurer</span> gsl</tt>
(MAC/linux) or <tt>(sudo) port install gsl</tt> (MAC) to install <tt>gsl</tt>
if necessary.</li>
<li><tt>python &gt;= 2.6</tt> or <tt><span class="pre">python&gt;=3.4</span></tt> for compiling the C extensions.</li>
<li><tt><span class="pre">numpy&gt;=1.7</span></tt> for compiling the C extensions.</li>
</ol>
<p><em>If python and/or numpy are not available, then the C extensions will
not be compiled</em>.</p>
</div>
<div id="preferred-method">
<h3>Preferred Method</h3>
<pre>$ git clone https://github.com/manodeep/Corrfunc/
$ make
$ make install
$ python setup.py install (--user)
</pre>
<p>Assuming you have <tt>gcc</tt> in your <tt>PATH</tt>, <tt>make</tt> and
<tt>make install</tt> should compile and install the C libraries + python
extensions within the source directory. If you would like to install the
python C extensions in your environment, then
<tt>python setup.py install <span class="pre">(--user)</span></tt> should be sufficient.</p>
</div>
<div id="alternative">
<h3>Alternative</h3>
<p>The python package is directly installable via <tt>pip install Corrfunc</tt>.</p>
</div>
<div id="installation-notes">
<h3>Installation notes</h3>
<p>If compilation went smoothly, please run <tt>make tests</tt> to ensure the
code is working correctly. Depending on the hardware and compilation
options, the tests might take more than a few minutes. <em>Note that the
tests are exhaustive and not traditional unit tests</em>.</p>
<p>While I have tried to ensure that the package compiles and runs out of
the box, cross-platform compatibility turns out to be incredibly hard.
If you run into any issues during compilation and you have all of the
pre-requisistes, please see the <a href="FAQ" rel="nofollow">FAQ</a> or <a href="mailto:manodeep%40gmail.com">email
me</a>. Also, feel free to create a new issue
with the <tt>Installation</tt> label.</p>
</div>
<div id="clustering-measures-on-a-cosmological-box">
<h3>Clustering Measures on a Cosmological box</h3>
<p>All codes that work on cosmological boxes with co-moving positions are
located in the <tt>xi_theory</tt> directory. The various clustering measures
are:</p>
<ol>
<li><tt>xi_of_r</tt> – Measures auto/cross-correlations between two boxes.
The boxes do not need to be cubes.</li>
<li><tt>xi</tt> – Measures 3-d auto-correlation in a cubic cosmological box.
Assumes PERIODIC boundary conditions.</li>
<li><tt>wp</tt> – Measures auto 2-d point projected correlation function in a
cubic cosmological box. Assumes PERIODIC boundary conditions.</li>
<li><tt>xi_rp_pi</tt> – Measures the auto/cross correlation function between
two boxes. The boxes do not need to be cubes.</li>
<li><tt>vpf</tt> – Measures the void probability function + counts-in-cells.</li>
</ol>
</div>
<div id="clustering-measures-on-a-mock">
<h3>Clustering measures on a Mock</h3>
<p>All codes that work on mock catalogs (RA, DEC, CZ) are located in the
<tt>xi_mocks</tt> directory. The various clustering measures are:</p>
<ol>
<li><tt>DDrppi</tt> – The standard auto/cross correlation between two data
sets. The outputs, DD, DR and RR can be combined using <tt>wprp</tt> to
produce the Landy-Szalay estimator for <span class="math">\(w_p(r_p)\)</span>.</li>
<li><tt>wtheta</tt> – Computes angular correlation function between two data
sets. The outputs from <tt>DDtheta_mocks</tt> need to be combined with
<tt>wtheta</tt> to get the full <span class="math">\(\omega(\theta)\)</span></li>
<li><tt>vpf</tt> – Computes the void probability function on mocks.</li>
</ol>
</div>
</div>
<div id="science-options">
<h2>Science options</h2>
<ol>
<li><tt>PERIODIC</tt> (ignored in case of wp/xi) – switches periodic boundary
conditions on/off. Enabled by default.</li>
<li><tt>OUTPUT_RPAVG</tt> – switches on output of <tt>&lt;rp&gt;</tt> in each <tt>rp</tt>
bin. Can be a massive performance hit (~ 2.2x in case of wp).
Disabled by default. Needs code option <tt>DOUBLE_PREC</tt> to be enabled
as well. For the mocks, <tt>OUTPUT_RPAVG</tt> causes only a mild increase
in runtime and is enabled by default.</li>
<li><tt>OUTPUT_THETAAVG</tt> – switches on output of in each theta bin. Can
be extremely slow (~5x) depending on compiler, and CPU capabilities.
Disabled by default.</li>
</ol>
<div id="mocks">
<h3>Mocks</h3>
<ol>
<li><tt>LINK_IN_DEC</tt> – creates binning in declination for mocks. Please
check that for your desired binning in <span class="math">\(r_p\)</span>/<span class="math">\(\theta\)</span>,
this binning does not produce incorrect results (due to numerical
precision).</li>
<li><tt>LINK_IN_RA</tt> – creates binning in RA once binning in DEC has been
enabled. Same numerical issues as <tt>LINK_IN_DEC</tt></li>
<li><tt>FAST_DIVIDE</tt> – Divisions are slow but required
<span class="math">\(DD(r_p,\pi)\)</span>. This Makefile option (in mocks.options) replaces
the divisions to a reciprocal followed by a Newton-Raphson. The code
will run ~20% faster at the expense of some numerical precision.
Please check that the loss of precision is not important for your
use-case. Also, note that the mocks tests for <span class="math">\(DD(r_p, \pi)\)</span>
<em>will fail</em> if you enable <tt>FAST_DIVIDE</tt>.</li>
</ol>
</div>
</div>
<div id="common-code-options-for-both-mocks-and-cosmological-boxes">
<h2>Common Code options for both Mocks and Cosmological Boxes</h2>
<ol>
<li><tt>DOUBLE_PREC</tt> – does the calculations in double precision.
Disabled by default.</li>
<li><tt>USE_AVX</tt> – uses the AVX instruction set found in Intel/AMD CPUs
&gt;= 2011 (Intel: Sandy Bridge or later; AMD: Bulldozer or later).
Enabled by default - code will run much slower if the CPU does not
support AVX instructions. On Linux, check for “avx” in /proc/cpuinfo
under flags. If you do not have AVX, but have a SSE4 system instead,
email me - I will send you a copy of the code with SSE4 intrinsics.
Or, take the relevant SSE code from the public repo at
<a href="https://manodeep.github.io/pairwise" rel="nofollow">pairwise</a>.</li>
<li><tt>USE_OMP</tt> – uses OpenMP parallelization. Scaling is great for DD
(perfect scaling up to 12 threads in my tests) and okay (runtime
becomes constant ~6-8 threads in my tests) for <tt>DDrppi</tt> and <tt>wp</tt>.</li>
</ol>
<p><em>Optimization for your architecture</em></p>
<ol>
<li>The values of <tt>bin_refine_factor</tt> and/or <tt>zbin_refine_factor</tt> in
the countpairs_*.c files control the cache-misses, and
consequently, the runtime. In my trial-and-error methods, I have seen
any values larger than 3 are always slower. But some different
combination of 1/2 for <tt>(z)bin_refine_factor</tt> might be faster on
your platform.</li>
<li>If you have AVX2/AVX-512/KNC, you will need to rewrite the entire AVX
section.</li>
</ol>
</div>
<div id="author">
<h2>Author</h2>
<p>Corrfunc is written/maintained by Manodeep Sinha. Please contact the
<a href="mailto:manodeep%40gmail.com">author</a> in case of any issues.</p>
</div>
<div id="citing">
<h2>Citing</h2>
<p>If you use the code, please cite using the Zenodo DOI. The BibTex entry
for the code is</p>
<pre>@misc{Corrfunc,
  author       = {Manodeep Sinha},
  title        = {{Corrfunc: Development release to create zenodo DOI
                   Corrfunc: Development release to create zenodo DOI}},
  month        = nov,
  year         = 2015,
  doi          = {10.5281/zenodo.33655},
  url          = {http://dx.doi.org/10.5281/zenodo.33655}
}
</pre>
</div>
<div id="license">
<h2>LICENSE</h2>
<p>Corrfunc is released under the MIT license. Basically, do what you want
with the code including using it in commercial application.</p>
</div>



<a name="downloads"> </a>


<ul class="nodot">
  <li><strong>Downloads (All Versions):</strong></li>
  <li>
    <span>0</span> downloads in the last day
  </li>
  <li>
    <span>37</span> downloads in the last week
  </li>
  <li>
    <span>441</span> downloads in the last month
  </li>
</ul>









            </div>


          </div>
          </div></body></html>