<html><body><div><div class="content html_format">
      <img src="https://habrastorage.org/getpro/habr/post_images/ce0/ad6/4cd/ce0ad64cd9047a68b80610ac14943915.png" alt="image" align="right"/><p>
Давным давно был язык С. И были в нем 2 функции управляющие памятью — malloc и free. Но это было слишком сложно.</p><p>
Посмотрел на это Бьёрн Страуструп и решил что нужно сделать все проще. И изобрел С++. В дополнение к malloc/free там появились new/delete, деструкторы, RAII, auto и shared указатели.</p><p>
Посмотрел на это Гвидо ван Россум, и решил, что С++ тоже не достаточно прост. Он решил идти другим путем и придумал Python, в котором даже malloc и free нет.</p><p>
А тем временем норвежские </p><a href="http://en.wikipedia.org/wiki/Qt_Development_Frameworks#History">троли</a><p> создали на С++ GUI-библиотеку Qt, которая упрощает управление памятью для своих объектов за счет того, что сама их удаляет, когда посчитает нужным.</p><p>
Phil Thompson расстроился, что отличной библиотеки Qt нету для замечательного языка Python. И решил их объединить проектом PyQt. Однако, как оказалось, если скрестить разные парадигмы управления памятью, обязательно вылезут побочные эффекты. Давайте посмотрим какие… 
</p><a name="habracut"/>
<h6>*Историческая справедливость и хронология принесена в жертву художественной составляющей вступления.</h6><p>
Модель работы PyQt можно упрощенно представить следующим образом: для каждого публичного класса С++ создается класс-обертка в Python. Программист работает с объектом-оберткой, а она вызывает методы «настоящего» C++-объекта.</p><p>
Все хорошо, пока объект и обертка синхронно создаются и синхронно умирают. Но эту синхронность можно нарушить. У меня получалось это сделать 3-я способами:
</p><ul>
<li> Python-обертка создана, С++объект- нет </li>
<li> Сборщик мусора Python удалил нужный объект </li>
<li> Qt удалила объект. Python-обертка жива </li>
</ul>

<h2>Python-обертка создана, С++объект- нет</h2>

<pre><code class="python">    from PyQt4.QtCore import QObject

    class MyObject(QObject):
        def __init__(self):
            self.field = 7

    obj = MyObject()
    print(obj.field)
    obj.setObjectName("New object")

&gt;&gt;&gt; Traceback (most recent call last):
&gt;&gt;&gt;   File "pyinit.py", line 9, in &lt;module&gt;
&gt;&gt;&gt;     obj.setObjectName("New object")
&gt;&gt;&gt; RuntimeError: '__init__' method of object's base class (MyObject) not called.
</code></pre>
<p>
Этот и другие примеры можно посмотреть </p><a href="https://github.com/hlamer/pyqt-memory-mgmt">здесь</a>
<p>
В конструкторе MyObject мы не вызвали конструктор базового класса. При этом объект успешно создался, им можно пользоваться. Однако при первой попытке вызвать C++-метод мы получим </p><i>RuntimeError</i><p> с объяснением, что мы сделали не правильно.</p><p>
Исправленный вариант:

</p><pre><code class="python">    ...
    class MyObject(QObject):
        def __init__(self):
            QObject.__init__(self)
    ...
</code></pre>

<h2>Сборщик мусора Python удалил нужный объект</h2>
<pre><code class="python">    from PyQt4.QtGui import QApplication, QLabel

    def createLabel():
        label = QLabel("Hello, world!")
        label.show()

    app = QApplication([])
    createLabel()

    app.exec_()
</code></pre>
<p>
Если бы этот код был написан на C++, после </p><i>app.exec_()</i><p> мы бы получили окошко c «Hello, world!». Но, этот код ничего не покажет. Когда функция </p><i>createLabel()</i><p> закончила выполняться, в Python-коде больше не осталось ссылок на </p><i>label</i><p>, и заботливый сборщик мусора удалил Python-обертку. В свою очередь обертка удалила C++-объект.
</p><p>
Исправленный вариант:
</p><pre><code class="python">    from PyQt4.QtGui import QApplication, QLabel

    def createLabel():
        label = QLabel("Hello, world!")
        label.show()
        return label

    app = QApplication([])
    label = createLabel()

    app.exec_()
</code></pre><p>
Сохраняем ссылки на все созданные объекты, даже если не собираемся пользоваться этими ссылками.

</p><h2>Qt удалила объект. Python-обертка жива</h2><p>
Предыдущие 2 случая описаны в документации к PyQt/Pyside и довольно тривиальны. Гораздо более сложные проблемы возникают, когда Python-часть не знает о том, что библиотека Qt удалила C++-объект.</p><p>
Qt может удалить объект при удалении родительского объекта, закрытии окна, вызове </p><i>deleteLater()</i><p> и в некоторых других ситуациях.</p><p>
После удаления можно работать с методами обертки, написанными на чистом Python, а попытка доступа к C++-части вызывает </p><i>RuntimeError</i><p> или </p><b>падение приложения</b><p>.
</p><p>
Начнем с очень простого способа выстрелить себе в ногу:
</p><pre><code class="python">    from PyQt4.QtCore import QTimer
    from PyQt4.QtGui import QApplication, QWidget


    app = QApplication([])

    widget = QWidget()
    widget.setWindowTitle("Dead widget")
    widget.deleteLater()

    QTimer.singleShot(0, app.quit)  # Делаем так, чтобы приложение завершилось сразу после старта
    app.exec_()  #  Запускаем приложение, чтобы оно выполнило deleteLater()

    print(widget.windowTitle())

&gt;&gt;&gt; Traceback (most recent call last):
&gt;&gt;&gt;   File "1_basic.py", line 20, in &lt;module&gt;
&gt;&gt;&gt;     print(widget.windowTitle())
&gt;&gt;&gt; RuntimeError: wrapped C/C++ object of type QWidget has been deleted
</code></pre>
<p>
Создаем QWidget, просим Qt его удалить. Во время </p><i>app.exec_()</i><p> объект будет удален. Обертка об этом не знает, и при попытке вызвать </p><i> windowTitle()</i><p> бросит исключение или вызовет падение.</p><p>
Разумеется, если программист вызвал </p><i>deleteLater()</i><p> а потом использует объект, то он сам и виноват. Однако в реальном коде часто случается более сложный сценарий:
</p><ol>
<li>Создаем объект</li>
<li>Подключаем внешние сигналы к слотам объекта</li>
<li>Qt удаляет объект. Например, при закрытии окна</li>
<li>Слот удаленного объекта вызывается таймером или сигналом из внешнего мира</li>
<li>Приложение падает или генерирует исключение</li>
</ol>

<div class="spoiler"><b class="spoiler_title">Длинный приближенный к жизни пример</b><div class="spoiler_text"><pre><code class="python">    from PyQt4.QtCore import Qt, QTimer
    from PyQt4.QtGui import QApplication, QLabel, QLineEdit


    def onLineEditTextChanged():
        print('~~~~ Line edit text changed')

    def onLabelDestroyed():
        print('~~~~ C++ label object destroyed')

    def changeLineEditText():
        print('~~~~ Changing line edit text')
        lineEdit.setText("New text")


    class Label(QLabel):
        def __init__(self):
            QLabel.__init__(self)
            self.setAttribute(Qt.WA_DeleteOnClose)
            self.destroyed.connect(onLabelDestroyed)

        def __del__(self):
            print('~~~~ Python label objВ качестве источника внешних сигналов используется QLineEdit, а в качестве удаляемого объекта - Label.ect destroyed')

        def setText(self, text):
            print('~~~~ Changing label text')
            QLabel.setText(self, text)

        def close(self):
            print('~~~~ Closing label')
            QLabel.close(self)


    app = QApplication([])
    app.setQuitOnLastWindowClosed(False)

    label = Label()
    label.show()

    lineEdit = QLineEdit()
    lineEdit.textChanged.connect(onLineEditTextChanged)
    lineEdit.textChanged.connect(label.setText)


    QTimer.singleShot(1000, label.close)   # пользователь закрыл одно из окон
    QTimer.singleShot(2000, changeLineEditText)  # пользователь изменил текст в другом окне. Произошло исключение.
    QTimer.singleShot(3000, app.quit)

    app.exec_()

    print('~~~~ Application exited')

&gt;&gt;&gt; ~~~~ Closing label
&gt;&gt;&gt; ~~~~ C++ label object destroyed
&gt;&gt;&gt; ~~~~ Changing line edit text
&gt;&gt;&gt; ~~~~ Line edit text changed
&gt;&gt;&gt; ~~~~ Changing label text
&gt;&gt;&gt; Traceback (most recent call last):
&gt;&gt;&gt;   File "2_reallife.py", line 33, in setText
&gt;&gt;&gt;     QLabel.setText(self, text)
&gt;&gt;&gt; RuntimeError: wrapped C/C++ object of type Label has been deleted
&gt;&gt;&gt; ~~~~ Application exited
&gt;&gt;&gt; ~~~~ Python label object destroyed
</code></pre><p>
Label подключен к сигналу textChanged от QLineEdit. Через 1 секунду после запуска label закрывается и удаляется. Программисту и пользователю он больше не нужен. Однако через 2 секунды удаленный label получает сигнал. В консоль сыплется исключение или приложение неожиданно падает.
</p></div></div>

<h4>Когда слоты не отключаются автоматически</h4><p>
 В С++-приложениях при удалении объекта отключаются все его слоты, поэтому проблем не возникает. Однако PyQt и PySide не всегда могут «отключить» объект. Мне стало интересно разобраться, когда слоты не отключаются. В процессе экспериментов родился следующий тест: 

</p><div class="spoiler"><b class="spoiler_title">Еще больше кода</b><div class="spoiler_text"><pre><code class="python">    PYSIDE = False
    USE_SINGLESHOT = True

    if PYSIDE:
        from PySide.QtCore import Qt, QTimer
        from PySide.QtGui import QApplication, QLineEdit
    else:
        from PyQt4.QtCore import Qt, QTimer
        from PyQt4.QtGui import QApplication, QLineEdit


    def onLineEditDestroyed():
        print('~~~~ C++ lineEdit object destroyed')

    def onSelectionChanged():
        print('~~~~ Pure C++ method selectAll() called')


    class LineEdit(QLineEdit):
        def __init__(self):
            QLineEdit.__init__(self)
            self.setText("foo bar")

            self.destroyed.connect(onLineEditDestroyed)
            #self.selectionChanged.connect(onSelectionChanged)

        def __del__(self):
            print('~~~~ Python lineEdit object destroyed')

        def clear(self):
            """Overridden Qt method
            """
            print('~~~~ Overridden method clear() called')
            QLineEdit.clear(self)

        def purePythonMethod(self):
            """Pure python method.
            Does not override any C++ methods
            """
            print('~~~~ Pure Python method called')
            self.windowTitle()  # generate exception


    app = QApplication([])
    app.setQuitOnLastWindowClosed(False)

    lineEdit = LineEdit()
    lineEdit.deleteLater()


    if USE_SINGLESHOT:
        #QTimer.singleShot(1000, lineEdit.clear)
        #QTimer.singleShot(1000, lineEdit.purePythonMethod)
        QTimer.singleShot(1000, lineEdit.selectAll)  # pure C++ method
    else:
        timer = QTimer(None)
        timer.setSingleShot(True)
        timer.setInterval(1000)
        timer.start()

        #timer.timeout.connect(lineEdit.clear)
        #timer.timeout.connect(lineEdit.purePythonMethod)
        timer.timeout.connect(lineEdit.selectAll)  # pure C++ method


    QTimer.singleShot(2000, app.quit)

    app.exec_()

    print('~~~~ Application exited')
</code></pre>
</div></div>
<p>
Как выяснилось, результат зависит от того, какие слоты удаленного объекта были подключены к сигналам. Поведение слегка отличается в PyQt и PySide.
</p><table>
<tr>
<th>Тип слота</th>
<th>PyQt</th>
<th>PySide</th>
</tr>
<tr>
<th>метод С++-объекта</th>
<td>слот отключается</td>
<td>слот отключается</td>
</tr>
<tr>
<th>метод или функция на чистом Python</th>
<td>падение</td>
<td>слот отключается</td>
</tr>
<tr>
<th>метод С++-объекта перегруженный Python-оберткой</th>
<td>падение</td>
<td>падение</td>
</tr>
</table>
<h4>Решение</h4><p>
С удалением C++-объектов особенно тяжело бороться. Проявляется она иногда не скоро, и совсем не явно. Некоторые советы:
</p><ul>
<li>Если собираетесь удалить объект, у которого есть Python-слоты, вручную отключайте объект от сигналов извне</li>
<li>Чтобы отследить момент удаления объекта можно использовать сигнал <i>QObject.destroyed</i>, но не метод <i>__del__</i> Python-обертки</li>
<li>Не используйте <i>QTimer.singleShot</i> для объектов, которые могут быть удалены. Такой таймер невозможно остановить.</li>
</ul><p>
Если есть серебрянная пуля, буду рад прочитать про нее в комментариях.

</p><h2>Заключение</h2><p>
Надеюсь никто не сделал вывод, что следует бояться PyQt/PiSide? На практике проблемы случаются не часто. У любого инструмента есть сильные и слабые стороны, которые нужно знать.

      
      </p><p class="clear"/>
    </div>

    
  </div></body></html>