<html><body><div><div id="content" class="page-content" itemprop="articleBody">
				<p>A few weeks ago, during a <a href="http://tech.gc.com/the-benefit-of-hack-days/">GameChanger Hack Day</a>, my fellow data engineer <a href="https://github.com/zacharym">Zach Markin</a> and I prototyped a <a href="http://en.wikipedia.org/wiki/Multi-armed_bandit">multi-armed bandit</a> micro service. As a motivating example, consider the problem of deciding between these three buttons on some page of a website:</p>

<p><img src="/images/bayesian-statistics-and-multi-armed-bandits/buttons.png" alt=""/></p>

<p>There are many ways to tackle this problem:</p>

<ul>
  <li>Pick what you think looks best.</li>
  <li>Pick what you think will perform best.</li>
  <li>Run a test to statistically measure which performs best, and pick it.</li>
</ul>

<p>If the thing being chosen (a “Sign up today” button in our example) is tied to an important part of your site (signups usually are,) then it is likely worth testing. Traditionally, a test is run by splitting people into test groups (and a control group if there is an existing choice,) running the test until a certain number of people have seen all of the test options, and then making a decision based off a <a href="http://en.wikipedia.org/wiki/Statistical_hypothesis_testing">statistical hypothesis test</a>.</p>

<p>A multi-armed bandit algorithm works a bit differently. Instead of having a step where the test is running and a step where we make a decision, a multi-armed bandit is always testing and always choosing. The better a choice performs, the more often it is displayed. For example, if green gets a higher click rate, it gets displayed more. The most important advantage here is that the multi-armed bandit starts to favor the higher performing option quickly so that money isn’t lost on a poorly performing option for the entire duration of a test.</p>

<p>To calculate just how often each color should be displayed, I wanted to find a distribution describing the probability of each color performing best. I took a Bayesian approach, based off <a href="http://engineering.richrelevance.com/bayesian-ab-tests/">Sergey Feldman’s</a> and <a href="http://www.evanmiller.org/bayesian-ab-testing.html">Evan Miller’s</a> excellent blog posts on the subject. To see what I ended up doing, skip on down to <a href="#thesolution">the solution</a>, but first, I’ll briefly speak about why I used a Bayesian model.</p>

<h2 id="why-bayes">Why Bayes?</h2>

<p>Recently at GameChanger, we’ve increased our focus on measuring the impact of our product and design changes on our customers’ experiences. We’ve been using KissMetrics, and specifically their <a href="http://support.kissmetrics.com/tools/a-b-test-report/">A-B testing tool</a> which uses a <a href="http://support.kissmetrics.com/tools/a-b-test-report/certainty-of-improvement.html">normal approximation</a> to calculate certainty of results. This is an efficient approximation of the <a href="http://en.wikipedia.org/wiki/Binomial_distribution">Binomial distribution</a>, which describes the probability of seeing <code class="highlighter-rouge">k</code> successes from <code class="highlighter-rouge">n</code> trials. In our case, a user landing on a page with a test is a trial; a user performing some desired interaction on the page is a success. The certainty displayed, however, comes with a few caveats.</p>

<h3 id="statistical-significance-and-hypothesis-testing">Statistical Significance and Hypothesis Testing</h3>

<p>As mentioned above, hypothesis testing is the traditional methodology for running a statistical test. This approach is often called the <em>frequentist approach</em>, and it assumes that there is some <em>true value</em> for the variable being measured which we are attempting to discover through our test. In our case, we measure the success rates for each of the colors of the button. We test each option, and assuming their rates are different, we can measure the probability that their <em>true values</em> are actually different or if the difference observed is the result random chance.</p>

<p>This requires us to choose a somewhat arbitrary level of significance (typically “95% confidence”) before we run our tests that will determine if the results are significant or not. We also have to be aware of the risk of committing type I and type II errors. (A type I error is incorrectly rejecting a true null hypothesis, and a type II error is the failure to correctly reject a false null hypothesis. <a href="http://en.wikipedia.org/wiki/Type_I_and_type_II_errors">Wikipedia</a> expands much more on this.) This complexity is not a flaw in a <em>frequentist approach</em>, in fact it is part of its power. A statistical significance test typically ends with a statement that some initial hypothesis is either <em>true or false</em> (or inconclusive) with a given probability of being correct. This complexity, however, does not easily translate to appropriate business decisions. But there is another approach.</p>

<h3 id="bayesian-testing">Bayesian Testing</h3>

<p><a href="https://xkcd.com/1132/"><img src="/images/bayesian-statistics-and-multi-armed-bandits/frequentists_vs_bayesians.png" alt="'Detector! What would the Bayesian statistician say if I asked him whether the--' [roll] 'I AM A NEUTRINO DETECTOR, NOT A LABYRINTH GUARD. SERIOUSLY, DID YOUR BRAIN FALL OUT?' [roll] '... yes.'"/></a></p>

<p><a href="https://xkcd.com/1132/">xkcd.com/1132</a></p>

<p>Bayesian statistics is built from a different view of the world altogether. The effect that we are attempting to measure (still a success rate) does not in fact have a <em>true value</em> but instead a probability distribution that describes its potential values. A Bayesian statistician makes use of a <em>prior distribution</em> from which they have reason to believe represents the distribution of the value being measured, and then updates that from the data observed. The choice of the <em>prior</em> is the black art of Bayesian statistics, much like the arbitrary level of significance chosen in significance testing. However, it is easy to choose a prior which will be overwhelmed by our experimental data.</p>

<p>The difference here is a bit subtle, particularly if you don’t spend your days heads down in a statistics text book. (Something I’ve been guilty of.) A hypothesis is designed from the start to reach a decision at a certain level of significance. For example, in Experimental Physics, discoveries are typically required to show <a href="http://en.wikipedia.org/wiki/Higgs_boson#Experimental_search">statistical significance of 5 sigma</a>, or 99.99997% certainty (on two different devices) to be declared “True”. In our example, we’d likely choose 95% certainty, run the test, and decide that the blue button (for example) is the best and move on (given the caveats discussed above).</p>

<p>The <em>Bayesian approach</em> does not provide such a statement of truth. Instead, it provides a probability distribution that describes the value we are measuring. In our example, we might be able to make the statement that “there is an 88% chance that blue is best” or “there is 65% chance that blue is at least 10% better than red and green”. Additionally, the distribution is important for the multi-armed bandit algorithm; I was looking to find the individual probabilities for each color that it performs best, given the data observed.</p>

<p>Generally, the Bayesian approach is much easier to understand and communicate. Feldman’s <a href="http://engineering.richrelevance.com/bayesian-ab-tests/">post mentioned earlier</a> provides a helpful example:</p>

<blockquote>
  <p>Which of these two statements is more appealing:</p>

  <p>(1) “We rejected the null hypothesis that A=B with a p-value of 0.043.”</p>

  <p>(2) “There is an 85% chance that A has a 5% lift over B .”</p>

  <p>Bayesian modeling can answer questions like (2) directly.</p>
</blockquote>

<p>From my experience, I tend to agree with Feldman’s analysis that questions like this second one are much easier to explain and to convert into specific and practical business advice. The hypothesis test gives a “decision” with reasonably difficult assumptions baked in whereas the Bayesian analysis gives useful information which can inform a decision with very few assumptions baked in.</p>

<p>Now onto how I went about finding this probability distribution.</p>

<p><a name="thesolution">
</a></p>

<h2 id="the-solution">The Solution</h2>

<p>I started with <a href="http://www.evanmiller.org/bayesian-ab-testing.html">Miller’s post</a> (mentioned earlier), which amazingly has a closed form solution for a Bayesian A/B Test. The issue, however, is that I was aiming for an A/B/C/… test which has an arbitrary number of options. Simply formulating this isn’t an easy task, and I’m fairly convinced that a closed form solution to this does not exist. (I’d love to be proven wrong! If you’ve solved this or have read a paper that does, please <a href="mailto:erik@gc.com">shoot me an email</a> [and <a href="https://gc.com/about/careers">come work with us!</a>])</p>

<p>Luckily, Bayesian models can easily be simulated, and in fact that is the approach taken in <a href="http://engineering.richrelevance.com/bayesian-ab-tests">Feldman’s post</a>. In Python (with <a href="http://www.numpy.org/"><code class="highlighter-rouge">numpy</code></a> installed) we can write a function to compare two tests:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">mean</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">beta</span>

<span class="k">def</span> <span class="nf">prob_a_beats_b</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="c"># a and b each tuples: (success_count, trials_count)</span>
    <span class="n">a_samples</span> <span class="o">=</span> <span class="n">beta</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
    <span class="n">b_samples</span> <span class="o">=</span> <span class="n">beta</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mean</span><span class="p">(</span><span class="n">a_samples</span> <span class="o">&gt;</span> <span class="n">b_samples</span><span class="p">)</span></code></pre></figure>

<p>Here we are drawing <code class="highlighter-rouge">10000</code> random samples from a <a href="http://en.wikipedia.org/wiki/Beta_distribution">Beta distribution</a> updated with the observed successes and failures. Then we simply pair these samples up in order and count how often <code class="highlighter-rouge">a_sample &gt; b_sample</code>. For example if our red button was clicked 500 out of 1,000 times, and our blue button was clicked 4,800 out of 10,000 times, we see:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">In</span><span class="p">:</span> <span class="n">prob_a_beats_b</span><span class="p">((</span><span class="mi">500</span><span class="p">,</span><span class="mi">1000</span><span class="p">),</span> <span class="p">(</span><span class="mi">4800</span><span class="p">,</span> <span class="mi">10000</span><span class="p">))</span>
<span class="n">Out</span><span class="p">:</span> <span class="mf">0.88641999999999999</span></code></pre></figure>

<p>We can see that 50% &gt; 48% easily, but the second option has much more data, so we are not entirely sure that the first option is the best. If we compare this to the closed form solution in <a href="http://www.evanmiller.org/bayesian-ab-testing.html">Miller’s post</a>, it’s quite close. In this specific case we get <code class="highlighter-rouge">0.88631554438158755</code>.</p>

<p>Now we want to push this further and compare a specific test to all the rest. None of the approaches above do this directly, but it’s fairly straight forward to expand on the <code class="highlighter-rouge">prob_a_beats_b</code> function from above:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">mean</span><span class="p">,</span> <span class="n">maximum</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">beta</span>

<span class="k">def</span> <span class="nf">prob_a_beats_all</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="c"># a and each other arg is a tuple: (success_count, trials_count)</span>
    <span class="n">a_samples</span> <span class="o">=</span> <span class="n">beta</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
    <span class="n">others</span> <span class="o">=</span> <span class="p">[</span><span class="n">beta</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="n">max_others</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">maximum</span><span class="p">,</span> <span class="n">others</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mean</span><span class="p">(</span><span class="n">a_samples</span> <span class="o">&gt;</span> <span class="n">max_others</span><span class="p">)</span></code></pre></figure>

<p>Here we’ve done almost the exact same thing as the first example, except that we are comparing against multiple other options. We sample for all of them, and then take the maximum for each one. We do the same pairing, and then measure how often the <code class="highlighter-rouge">a_sample &gt; max(other_samples)</code>. Expanding our example, we include a newly added green button which was clicked 12 out of only 30 times:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">In</span><span class="p">:</span> <span class="n">prob_a_beats_all</span><span class="p">((</span><span class="mi">500</span><span class="p">,</span><span class="mi">1000</span><span class="p">),</span> <span class="p">(</span><span class="mi">4800</span><span class="p">,</span> <span class="mi">10000</span><span class="p">),</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
<span class="n">Out</span><span class="p">:</span> <span class="mf">0.76488</span></code></pre></figure>

<p>We now need one more function so that we can compute all of these probabilities and get the full distribution:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">mean</span><span class="p">,</span> <span class="n">maximum</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">beta</span>

<span class="k">def</span> <span class="nf">prob_vector</span><span class="p">(</span><span class="n">selections</span><span class="p">):</span>
    <span class="c"># dict of {selection_id: (success_count, trials_count)}</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">prob_a_beas_all</span><span class="p">(</span>
            <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="n">other_v</span> <span class="k">for</span> <span class="n">other_k</span><span class="p">,</span> <span class="n">other_v</span> <span class="ow">in</span> <span class="n">selections</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">other_k</span><span class="p">]</span>
        <span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">selctions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">weights</span></code></pre></figure>

<p>This gets us very close. For our example:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">In</span><span class="p">:</span> <span class="n">prob_vector</span><span class="p">({</span><span class="s">'red'</span><span class="p">:</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="s">'blue'</span><span class="p">:</span> <span class="p">(</span><span class="mi">4800</span><span class="p">,</span> <span class="mi">10000</span><span class="p">),</span> <span class="s">'green'</span><span class="p">:</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">30</span><span class="p">)})</span>
<span class="n">Out</span><span class="p">:</span> <span class="p">{</span><span class="s">'red'</span><span class="p">:</span> <span class="mf">0.76766000000000001</span><span class="p">,</span> <span class="s">'blue'</span><span class="p">:</span> <span class="mf">0.091800000000000007</span><span class="p">,</span> <span class="s">'green'</span><span class="p">:</span> <span class="mf">0.14032</span><span class="p">}</span></code></pre></figure>

<p>You may be surprised to notice that the probability of “<code class="highlighter-rouge">green</code> is best” is greater than <code class="highlighter-rouge">blue</code>’s. Before we address that, though, note that because this process is based off random sampling, the sum of all these probabilities is not exactly <code class="highlighter-rouge">1.0</code>. (In this case it is <code class="highlighter-rouge">0.99978</code>.) To deal with this, we’ll write one more function:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">normalized_prob_vector</span><span class="p">(</span><span class="n">selctions</span><span class="p">):</span>
    <span class="c"># dict of {selection_id: (success_count, trials_count)}</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">prob_vector</span><span class="p">(</span><span class="n">selections</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">/</span><span class="n">total</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">weights</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></code></pre></figure>

<p>The output for our example now is:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">In</span><span class="p">:</span> <span class="n">normalized_prob_vector</span><span class="p">({</span><span class="s">'red'</span><span class="p">:</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="s">'blue'</span><span class="p">:</span> <span class="p">(</span><span class="mi">4800</span><span class="p">,</span> <span class="mi">10000</span><span class="p">),</span> <span class="s">'green'</span><span class="p">:</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">30</span><span class="p">)})</span>
<span class="n">Out</span><span class="p">:</span> <span class="p">{</span><span class="s">'red'</span><span class="p">:</span> <span class="mf">0.7664006736707033</span><span class="p">,</span> <span class="s">'blue'</span><span class="p">:</span> <span class="mf">0.091907931670542953</span><span class="p">,</span> <span class="s">'green'</span><span class="p">:</span> <span class="mf">0.14169139465875372</span><span class="p">}</span></code></pre></figure>

<p>Awesome! Now, back to the value for <code class="highlighter-rouge">green</code> being greater than <code class="highlighter-rouge">blue</code>. If we measure the probability that <code class="highlighter-rouge">blue &gt; green</code>, we get about <code class="highlighter-rouge">0.8</code>, so we should not interpret this result that <code class="highlighter-rouge">green</code> is better than <code class="highlighter-rouge">blue</code>. Instead, because we are measuring the chance that each <code class="highlighter-rouge">color</code> is the <em>best</em>, we are pretty certain that <code class="highlighter-rouge">red</code> is the best and even more certain that <code class="highlighter-rouge">red</code> is better than <code class="highlighter-rouge">blue</code>. However, we don’t have nearly as much information about <code class="highlighter-rouge">green</code>, and as such there is a larger chance that as more information comes in, it may end up being best.</p>

<h2 id="final-thoughts">Final Thoughts</h2>

<p>There is plenty of debate over Bayesian v Frequentist approaches to statistical analysis and modeling. Ultimately though, your choice depends mostly on the context of the problem. This problem in particular was well suited for a Bayesian approach, and the ability to get results through a simulation make it easy to get to an actionable result quickly. Unfortunately though, like most things, there is no silver bullet and you will want to spend some time understanding your problems and the cost and benefits of different statistical approaches.</p>

				<footer class="page-footer">
					
				</footer>
				<aside>
					<hr/>
<p id="disqus_thread"/>

<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
				</aside>
			</div>
		</div></body></html>