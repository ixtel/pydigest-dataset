<html><body><div><div class="post">
  <h1 class="post-title">Currying explained for Python programmers</h1>
  <span class="post-date">23 Jun 2015</span>
  <p>One thing that strikes Haskell beginners with its weirdness is the
notion of a <em>curried</em> function. Since all functions are curried by
default in Haskell, it’s safe to say that it’s essential to understand
what currying is to be able to delve deeper into Haskell.</p>

<p>Although the idea of currying is not particularly hard to grasp, it sounds a bit weird since it’s kind of a crazy way of approaching
functions—especially due to the tuple-based ontology familiar from calculus classes.</p>

<p>Before even trying to define what currying is at an abstract level, let’s go ahead and define a “function”<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>
<code>f</code> in Python to fiddle with its behavior.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">14</span></code></pre></div>

<p><code>f</code> is simply a function that returns  and it
works as intended. Now, what concerns us is what happens if we do
<code>f(2)</code>. Of course as expected, Python passively-aggressively tells
us that we made the mistake of not providing <code>f</code> with enough arguments.</p>

<p><code>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: f() takes exactly 3 arguments (1 given)
</code></p>

<p>This is the expected behavior with the common conception of a
function; a function must be fed the number of arguments it requires. In Haskell though, all functions show curried behavior: they are
defined as the sequence of multiple single-argument functions. So if I
were to define the same function <code>f</code> in Haskell, the application
of <code>f</code> to a single argument would return another function
expecting to operate on the remaining two arguments. If I were to
apply that function to another single argument, that would return yet
another function expecting to operate on the third one of the three arguments <code>f</code> accepts in total. You get the idea.</p>

<p>To make things a bit more concrete, let’s make ourselves a curried
function in Python.</p>



<p>Let’s play with our curried <code>f</code>; if we call it with a single
argument, we get a new function that we will store to <code>g</code>.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">curried_f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">21</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">curried_f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">21</span></code></pre></div>

<p>Or, we can do this</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">curried_f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">h</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="mi">21</span></code></pre></div>

<p>But why would anyone want this? The answer may not be apparent in
Pythonian thinking. But consider <code>map</code>, for example. We can
<code>map</code> over a list if we have a function expecting a single
argument. If we were to use a function that takes multiple arguments, we
would have to use <code>lambda</code> or define a new function. But with this
curried function we made we could compute  for
 simply like this</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">map</span><span class="p">(</span><span class="n">curried_f</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">[</span><span class="mi">74</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">77</span><span class="p">]</span></code></pre></div>

<p>Or we could plug it into <code>reduce</code> like:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">curried_f</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="mi">17436</span></code></pre></div>

<p>Of course, these high-level operations such as <code>map</code> and
<code>reduce</code> are not used that frequently in Python, but they go so
well with Haskell’s take on programming that being able to get things
done with these higher level functions is kind of like the Haskell
programmer’s <a href="https://en.wikipedia.org/wiki/Programming_idiom"><em>idiomatic competence</em></a>. If these stuff sound interesting to you, definitely take a look at <a href="http://learnyouahaskell.com/higher-order-functions#curried-functions">what Miran Lipovača has to say about them</a>.</p>



</div>

</div></body></html>