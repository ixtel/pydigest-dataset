<html><body><div><div class="talks">
  
    
      <img src="http://dropbucket.ru/peterson"/>
    

    <div class="talk">
      
        <p><strong>Benjamin Peterson</strong>, Developer of CPython. He also wrote the six Python 2/3 compatibility library and has contributed to numerous projects in the Python ecosystem including PyPy and py.tes.</p>
      

      <p><a href="/2015/program/content/progress/" target="_self"><b>Python Packaging Progress</b></a></p>
      <p/><p>Python packaging is infamous for being brittle and hard to use.
Thankfully, a lot of progress has been made in recent years. This talk
will explain some of the components and tools in modern Python packaging
including pip, PyPI, virtualenv, and wheels.</p>
<p>I'd say the talk is for an intermediate to advanced audience. Ideally,
attendees will leave with a clearer idea of how Python packaging works
as well as an sense of optimism. :)</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/vlasovskii"/>
    

    <div class="talk">
      
        <p><strong>Андрей Власовских</strong>, Разработчик PyCharm и эмулятора Vim для сред программирования в JetBrains. Автор библиотеки funcparserlib для написания парсеров на Python в функциональном стиле.</p>
      

      <p><a href="/2015/program/content/vlasovskich/" target="_self"><b>Чем аннотации типов могут быть полезны для вас</b></a></p>
      <p/><p>PEP 484 вводит аннотации типов для Python 3. Аннотации типов могут улучшить читаемость кода как для людей, так и для инструментов анализа кода. Они делают код лучше и безопаснее. В этом докладе мы обсудим, почему это так.</p>
<p>Мы кратко рассмотрим, что такое аннотации типов и перейдём к практическим примерам того, где они могут быть полезны и что они дают. Далее мы обсудим ряд полезных советов по написанию и использованию аннотаций. Мы увидим, что в большинстве случаев простых аннотаций типов на основе классов и встроенных коллекций вполне достаточно для публичных API наших библиотек. Мы также обсудим, что могут дать аннотации типов для сторонних библиотек.</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/glibin"/>
    

    <div class="talk">
      
        <p><strong>Виталий Глибин</strong>, сооснователь сервиса для ведения вакансий Huntflow, руководитель frontend разработки в Программе ГлавБух.</p>
      

      <p><a href="/2015/program/content/glibin/" target="_self"><b>Изоморфные приложения и Python</b></a></p>
      <p/><p>Доклад будет посвящен проблеме единой шаблонизации на сервере и клиенте. Для чего это нужно? Например, вы делаете классный интернет-магазин на Django и хотите, чтобы в каталоге товаров при изменении каких-то параметров список товаров динамически фильтровался. </p>
<p>Как было раньше?
Человек нажимает на фильтр, страница перезагружается с новым отфильтрованным списком товаров.
Это было очень медленно, и появился AJAX, разработчики стали при изменении фильтра загружать с сервера только кусочек html с отфильтрованными товарами.
Но и этого показалось мало, теперь с сервера мы получаем JSON, а на клиенте производим отрисовку нового списка товаров.</p>
<p>Что получаем в итоге?
Есть некий шаблон, который отрисовывает список товаров на сервере, и есть шаблон, который делает это же на клиенте. Соответственно, разработчику часто необходимо поддерживать два шаблона, что может приводить к ошибкам при изменениях. Зато у клиента все быстро :)</p>
<p>С появлением NodeJS разработчики стали задумываться о том, что теперь и на сервере, и на клиенте можно использовать единую шаблонизацию (единый код), который впоследствии назвали изоморфным. Именно поэтому разработчики часто выбирают NodeJS как основу для своих следующих проектов. </p>
<p>Я хочу рассказать о том, как можно не отказываться от Python на сервере, при этом получив все преимущества изоморфных приложений: от небольших контентных до сложных сервисных сайтов, на основе своего собственного опыта.</p>
<p>Плюс расскажу, для чего вообще в 2015 году нужна серверная шаблонизация и почему это важно.</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/beda"/>
    

    <div class="talk">
      
        <p><strong>Илья Беда</strong>, тимлидер bro.agency.</p>
      

      <p><a href="/2015/program/content/beda/" target="_self"><b>View как чистая функция от состояния базы данных</b></a></p>
      <p/><p>В большинстве WEB приложений мы так или иначе взаимодействуем с базой данных. Она хранит в себе информацию, а мы, как программисты, пишем код, преобразующий эти данные в html странички или API интерфейсы.
И так как единой точкой правды является база данных, то и кэшировать WEB приложения нужно, основываясь на её состоянии. 
В своем докладе я расскажу про методы кэширования, основанные на ORM. О том, как можно кэшировать запросы к базе данных и функции, зависящие от них. И самое главное, о том, как такой кэш корректно инвалидировать.</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/soldatenko"/>
    

    <div class="talk">
      
        <p><strong>Андрей Солдатенко</strong>, Python Backend Developer и QA Automation Lead в Wargaming.NET. </p>
      

      <p><a href="/2015/program/content/soldatenko/" target="_self"><b>Погружение в полнотекстовый поиск, используя Python</b></a></p>
      <p/><p>В наши дни мир тонет в текстовой информации. Все эти годы существующие технологии были сфокусированы на хранении и структурировании данных. Но что же делать, если нам необходимо принимать решение в режиме реального времени, используя эти данные?
Я с радостью поделюсь накопленным опытом разработки веб-приложений, использующих полнотекстовый поиск, которые написаны на Python с использованием Django-фреймворка, а также расскажу о результатах исследования разных поисковых движков и интеграции веб-приложений с haystack и elasticsearch.
Также поговорим о будущем полнотекстового поиска в контексте Django 1.9 и Python.</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/petlinski"/>
    

    <div class="talk">
      
        <p><strong>Павел Петлинский</strong>, ведущий инженер-разработчик Python в Rambler&amp;Co.</p>
      

      <p><a href="/2015/program/content/rambler/" target="_self"><b>Making of external DSL for Django ORM</b></a></p>
      <p/><p>Рассказ пойдет о том, как мы реализовали в Django механизм такой же, как  Advanced Searching в JIRA, о внутреннем устройстве подобных решений (написание DSL, разбор грамматик и т.п.),
зачем и как мы их применяем на нашем проекте.</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/savin"/>
    

    <div class="talk">
      
        <p><strong>Иван Савин</strong>, IPONWEB.</p>
      

      <p><a href="/2015/program/content/savin/" target="_self"><b>Как сделать логирование приятным в быстро развивающемся проекте</b></a></p>
      <p/><p>Часто логированию уделяется немного внимания и по мере развития приложения править систему логирования становится сложнее. В итоге логи уже не так информативны, чтобы легко понять состояние программы в нужный момент в прошлом, и не так читабельны, чтобы сделать это быстро. </p>
<p>В докладе будут освещены следующие вопросы:
- Каких ошибок можно избежать при проектировании логирования: способы конфигурации, антипаттерны;
- Как не переписывать все вызовы записи в лог при изменении логики логирования (собственные адаптеры и фильтры);
- Динамический контекст в логировании: как добавить в нужные записи только то, что хотелось бы потом увидеть;
- Реальный и простой пример перехода к современному логированию и анализу логов: Logstash - ElasticSearch - Kibana.</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/sinitcin"/>
    

    <div class="talk">
      
        <p><strong>Валентин Синицын</strong>, разработчик сервиса Яндекс.Такси</p>
      

      <p><a href="/2015/program/content/sinicin/" target="_self"><b>Python: управление памятью</b></a></p>
      <p/><p>Программистам на Python не нужно задумываться об управлении памятью — за них все делает интерпретатор. Как правило, это все, что необходимо знать об управлении памятью в Python.
Порой подобный «минимализм» приводит к неожиданным последствиям. Память начинает «течь», и понять, кто в этом виноват, оказывается непросто.
В этом докладе мы сделаем обзор подсистемы управления памятью в самой популярной реализации Python — CPython. Будут рассмотрены процедуры выделения памяти и сборки мусора, способы взаимодействия с ними из Python-кода, а также типовые ошибки, которые могут помешать их нормальной работе. Мы также продемонстрируем серию простых экспериментов, доказывающих, что работа с памятью в Python действительно происходит именно так, а не иначе.</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/gael"/>
    

    <div class="talk">
      
        <p><strong>Gael Varoquaux</strong>, core developer of scikit-learn, joblib, Mayavi and nilearn, a nominated member of the PSF</p>
      

      <p><a href="/2015/program/content/gael/" target="_self"><b>Building a cutting-edge data processing environment on a budget</b></a></p>
      <p/><p>As a penniless academic I wanted to do "big data" for science. Open
source, Python, and simple patterns were the way forward. Staying on top
of todays growing datasets is an arm race. Data analytics machinery
—clusters, NOSQL, visualization, Hadoop, machine learning, ...— can
spread a team's resources thin. Focusing on simple patterns, lightweight
technologies, and a good understanding of the applications gets us most
of the way for a fraction of the cost. These patterns appear underline
the design of Mayavi, for interactive 3D visualization, scikit-learn, for
easy machine learning, and joblib for out-of-core and parallel computing.</p>
<p>I will present a personal perspective on ten years of scientific data
processing with Python. What are the emerging patterns in data
processing? How can modern data-mining ideas be used without a big
engineering team? What constraints and design trade-offs govern software
projects like scikit-learn, Mayavi, or joblib? How can we make the most
out of distributed hardware with simple framework-less code?</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/vahrushev"/>
    

    <div class="talk">
      
        <p><strong>Дмитрий Вахрушев</strong>, web-разработчик, питонист, линуксоид. </p>
      

      <p><a href="/2015/program/content/vahrushev/" target="_self"><b>Архитектура RESTful API на Pyramid — приемы проектирования</b></a></p>
      <p/><p>Pyramid — чрезвычайно гибкий фреймворк, идеально подходящий тем разработчикам, которые точно знают, что им нужно. Обратная сторона его гибкости — отсутствие единственно верных, одобренных авторами, способов решения задач. В этом докладе 
я поделюсь своими, проверенными временем, рецептами построения RESTful API на Pyramid. Будут затронуты вопросы:</p>
<ul>
<li>общей архитектуры Pyramid приложения;</li>
<li>проектирования слоя бизнес-логики в виде иерархии ресурсов;</li>
<li>использования траверсал-роутинга;</li>
<li>обработки ошибок;</li>
<li>управления правами доступа с использованием встроенного ACL;</li>
<li>тестирования;</li>
<li>интеграции с другими частями проекта. </li>
</ul>
      
    </div>
  
    
      <img src="http://dropbucket.ru/shvets"/>
    

    <div class="talk">
      
        <p><strong>Александр Швец</strong>, компания Marilyn, директор по продукту.</p>
      

      <p><a href="/2015/program/content/celery/" target="_self"><b>Секреты здорового питания: полезные рецепты с Celery</b></a></p>
      <p/><ul>
<li>Секретный состав сельдерея или неформальное введение в архитектуру Celery</li>
<li>Подбираем ингредиенты на пробу. Как правильно логировать и отлаживать очередей</li>
<li>Заботимся о долгом послевкусии. Как обеспечить стабильную работу очередей без простоя и потери задач</li>
<li>Готовимся к кулинарному состязанию. Как избежать гонок при выполнении задач</li>
<li>Несколько профессиональных рецептов шеф-повара по настройке Celery для больших проектов</li>
</ul>
      
    </div>
  
    
      <img src="http://dropbucket.ru/pyconru/shepanovsky"/>
    

    <div class="talk">
      
        <p><strong>Александр Щепановский</strong>, автор библиотек funcy, cacheops.</p>
      

      <p><a href="/2015/program/content/Shchepanovskiy/" target="_self"><b>Никогда больше так не делай</b></a></p>
      <p/><p>Чтобы поддерживать свои стандарты как стиля кодирования, так и его семантики, мы часто используем линтеры. Однако, добавлять свои правила в них достаточно сложно. Поэтому в большинстве команд средства никак или почти никак не подстраиваются ни под конкретный проект, ни под команду в целом. <br/>
Ревью кода позволяет частично закрыть этот недостаток, однако, иногда хочется просто ткнуть пальцем и сказать «никогда больше так не делай». Я расскажу о своём проекте-исследовании того, как сделать автоматизацию таких ситуаций простой, а поэтому гибкой и практичной.</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/pyconru/аpatrushev"/>
    

    <div class="talk">
      
        <p><strong>Антон Патрушев</strong>, associate Information Systems Officer в UNFCCC.</p>
      

      <p><a href="/2015/program/content/patrushev/" target="_self"><b>Оптимизация: на грани и за</b></a></p>
      <p/><p>Нередко при разработке мы сталкиваемся с ситуациями, когда для увеличения производительности приложения надо делать крупные рефакторинги, менять архитектуру. Но что делать, если на это нет времени и производительность нужна прямо здесь и сейчас? Конечно, в первую очередь, нужно прибегнуть к традиционной медицине — профилировать и править узкие места. Но об этом уже сказано очень много. Я бы хотел рассказать о нескольких нетрадиционных техниках, которые мне однажды помогли побороть проблемы с производительностью:</p>
<ul>
<li>Жизнь без GC: как и зачем?</li>
<li>Выжмем ещё немного, не переписывая весь код: модификация AST при импорте;</li>
<li>Декораторы и байткод: пару процентов почти за просто так.</li>
</ul>
      
    </div>
  
    
      <img src="http://dropbucket.ru/matveenko"/>
    

    <div class="talk">
      
        <p><strong>Сергей Матвеенко</strong>, Senior Python Developer компании DataArt.</p>
      

      <p><a href="/2015/program/content/matveenko/" target="_self"><b>«Вещи» на Python</b></a></p>
      <p/><p>Одним из факторов популярности Python является его применение в самых разных областях информационных технологий.</p>
<p>«Internet of Things» («Интернет вещей») — одно из популярнейших и активно развивающихся сейчас направлений ИТ. Ожидаемо, в IoT тоже используется Python. Я немного расскажу о доступных способах снизить порог входа в IoT, расскажу о возможностях протокола «alljoyn», одного из самых популярных протоколов IoT и покажу на примере натоящего устройства, как с помощью DeviceHive D-Bus Framework можно создавать из любых управляемых устройств, которые у вас есть под рукой, устройства, работающие по протоколу «alljoyn».</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/sibiryakov"/>
    

    <div class="talk">
      
        <p><strong>Александр Сибиряков</strong>, Python-разработчик в Scrapinghub.</p>
      

      <p><a href="/2015/program/content/sibiryakov/" target="_self"><b>Frontera: распределенный робот для обхода интернета в больших объемах</b></a></p>
      <p/><p>В этом докладе я собираюсь представить новый open source фреймворк, разработанный в Scrapinghub. Frontera позволяет построить распределенного робота для скачивания страниц из интернета в больших объемах в реальном времени. Также он может быть использован для построения сфокусированных роботов для выкачивания подмножества заранее известных веб-сайтов.</p>
<p>Фреймворк предлагает:
<em> настраиваемое хранилище URL документов (RDBMS или Key Value),
</em> управление стратегиями обхода,
<em> абстракцию транспортного уровня,
</em> абстракцию модуля загрузки.
 Помимо описания фреймворка и системных требований, я расскажу о нашем опыте скачивания испанского интернета с помощью Fronter'ы и представлю небольшую статистику. </p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/pony"/>
    

    <div class="talk">
      
        <p><strong>Александр Козловский, Алексей Малашкевич</strong>, авторы объектно-реляционного маппера Pony ORM.</p>
      

      <p><a href="/2015/program/content/pony/" target="_self"><b>Разработка одностраничных веб-приложений с использованием PonyORM и ReactJS</b></a></p>
      <p/><p>ReactJS — современная популярная библиотека для построения Single Page Application. ReactJS позволяет создавать понятную и масштабируемую архитектуру веб-приложений, разбивать страницы на независимые компоненты, а также обеспечивает высокую скорость рендеринга. В то же время, ReactJS не описывает, каким образом должен выглядеть уровень «моделей» паттерна MVC и как должно быть организовано взаимодействие с бэкендом.</p>
<p>PonyORM — это объектно-реляционный маппер на языке Python, который позволяет описать модели сущностей и удобно работать с ними на бэкенде. Теперь, в дополнение к PonyORM, появилась библиотека PonyJS, которая позволяет автоматически генерировать аналогичные модели на фронтенде и работать с ними из языка JavaScript. Теперь вы можете написать запрос с помощью PonyORM, автоматически сериализовать данные в JSON, передать их на фронтенд и работать с ними как с полноценными объектами, а затем передать изменения обратно и сохранить их в базе данных.</p>
<p>В докладе будет рассказано, как можно создать одностраничное приложение на ReactJS, использующее объекты PonyORM/PonyJS в качестве моделей.</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/tuzova"/>
    

    <div class="talk">
      
        <p><strong>Екатерина Тузова</strong>, разработчик PyCharm.</p>
      

      <p><a href="/2015/program/content/tuzova/" target="_self"><b>Numpy: векторизация</b></a></p>
      <p/><p>NumPy — это базовая библиотека для научных вычислений на Python. На основе массивов NumPy построено множество библиотек для различных областей науки: машинного обучения, символьных вычислений, работы с биологическими данными. Однако, для того чтобы использовать NumPy эффективно, приходится слегка изменить свой подход к написанию кода.
Мы увидим, почему циклы в Python работают медленно и как использование векторных операций из Numpy улучшает производительность.</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/borisov"/>
    

    <div class="talk">
      
        <p><strong>Кирилл Борисов</strong>, разработчик в Яндексе.</p>
      

      <p><a href="/2015/program/content/borisov/" target="_self"><b>Автоматизированные рефакторинги: AST, FST и все-все-все</b></a></p>
      <p/><p>Одна из самых неприятных вещей в работе программиста — рутина. К сожалению, её не избежать — работы по поддержке существующего кода заставляют нас вносить одинаковые изменения в несколько файлов разом. По мере роста проекта эта задача вырастает до десятков правок в сотнях файлов, заставляя даже самого терпеливого программиста задуматься о смысле бытия. Но что делать? Автоматизируйте это! В этом докладе мы расскажем о разных способах работать с исходным кодом из Python, и почему это весело.
В докладе:
- Всякую рутинную работу можно превратить в интересную задачу по автоматизации рутины;
- В «батарейках» Python можно найти достаточно средств для самостоятельного анализа исходного кода;
- Топорный подход с «find/replace» часто не подходит из-за необходимости учитывать контекст каждой конкретной правки, равно как и сохранять по возможности оформление исходного файла;
- Регулярные выражения <em>не</em> подходят для разбора исходного кода на сложных языках программирования;
- Любая достаточно продвинутая программа неотличима от магии.</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/pyconru/svetlov"/>
    

    <div class="talk">
      
        <p><strong>Андрей Светлов</strong>, Python Core Developer, инженер в DataRobot.</p>
      

      <p><a href="/2015/program/content/svetlov/" target="_self"><b>Aiohttp</b></a></p>
      <p/><p>Aiohttp — самая популярная asyncio-совместимая библиотека на сегодняшний день.
В докладе мы рассмотрим:
<em> Web-клиент. Примитивный запрос. Использование авторизации и сессий.
</em> Web-сервер. Примитивный пример. Сложные routes.
<em> Web-sockets. Клиент и сервер. Обработка параллельных задач (asyncio.wait)
</em> Тестирование. Явный loop
<em> Базы данных. Redis, Postgres, Mongo.
</em> Сессии.
<em> Авторизация и права доступа.
</em> Debugtoolbar.
* PEP 492</p>
<p>Доклад рассчитан на разработчиков, которые хотят попробовать asyncio подход, но не знают, с чего начать :)</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/petrov"/>
    

    <div class="talk">
      
        <p><strong>Григорий Петров</strong>, технический евангелист в VoxImplant.</p>
      

      <p><a href="/2015/program/content/petrov/" target="_self"><b>50 оттенков кеширования: обзор актуальных батареек</b></a></p>
      <p/><p>Кеширование так же многообразно, как и варианты использования python. Создавая веб приложение на Django или программируя логику онлайн игры в embedded python, разработчик использует множество стратегий для ускорения работы своего кода. 
В обзорном докладе Григорий расскажет о современных подходах к кешированию в разных областях разработки на python, обрисует текущее состояние экосистемы и поделится интересными кейсами из практики.</p>
      
    </div>
  
    
      <img src="http://dropbucket.ru/ignatov"/>
    

    <div class="talk">
      
        <p><strong>Константин Игнатов</strong>, программист в отделе исследований Qrator Labs.</p>
      

      <p><a href="/2015/program/content/ignatov/" target="_self"><b>Превращаем свалку проектов в экосистему при помощи setuptools</b></a></p>
      <p/><p>В докладе мы рассмотрим создание файлов setup.py и setup.cfg.</p>
<ul>
<li>Используем edit-mode при установке пакетов</li>
<li>Простой setup.py для простого проекта</li>
<li>Устанавливаем дополнительные файлы</li>
<li>Строим расширения</li>
<li>Делаем сложные зависимости</li>
<li>Добавляем консольные скрипты</li>
<li>Включаем поддержку плагинов</li>
</ul>
<p>Будет полезно всем, кто: разрабатывает &gt;1 взаимодействующих друг с другом проектов, копирует в каждый новый проект папку с любимыми функциями, устанавливает проекты при помощи git clone, copy, rsync и тп, 
не пишет расширения из-за сложности развёртывания, пишет консольные скрипты при помощи def main()... if name == '<strong>main</strong>'..., 
избегает пакетирования, потому что проекты слишком зависят друг от друга (изменения в одном приводят к изменениям везде).</p>
      
    </div>
  
  </div>
  

      </div></body></html>